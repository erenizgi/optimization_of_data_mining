{
    "author": "vsemozhetbyt",
    "message": "tools: overhaul tools/doc/html.js\n\nPR-URL: https://github.com/nodejs/node/pull/20613\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "12b0159adf88a46b6ea4ffc1f8b910ebb56fecb9",
    "files": [
        {
            "sha": "60cacd5b791bcbad7ef9fc3b15dd19413395f667",
            "filename": "tools/doc/html.js",
            "status": "modified",
            "additions": 213,
            "deletions": 307,
            "changes": 520,
            "blob_url": "https://github.com/nodejs/node/blob/12b0159adf88a46b6ea4ffc1f8b910ebb56fecb9/tools%2Fdoc%2Fhtml.js",
            "raw_url": "https://github.com/nodejs/node/raw/12b0159adf88a46b6ea4ffc1f8b910ebb56fecb9/tools%2Fdoc%2Fhtml.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fhtml.js?ref=12b0159adf88a46b6ea4ffc1f8b910ebb56fecb9",
            "patch": "@@ -29,109 +29,50 @@ const typeParser = require('./type-parser.js');\n \n module.exports = toHTML;\n \n-const STABILITY_TEXT_REG_EXP = /(.*:)\\s*(\\d)([\\s\\S]*)/;\n-const DOC_CREATED_REG_EXP = /<!--\\s*introduced_in\\s*=\\s*v([0-9]+)\\.([0-9]+)\\.([0-9]+)\\s*-->/;\n-\n-// Customized heading without id attribute.\n+// Make `marked` to not automatically insert id attributes in headings.\n const renderer = new marked.Renderer();\n-renderer.heading = function(text, level) {\n-  return `<h${level}>${text}</h${level}>\\n`;\n-};\n-marked.setOptions({\n-  renderer: renderer\n-});\n+renderer.heading = (text, level) => `<h${level}>${text}</h${level}>\\n`;\n+marked.setOptions({ renderer });\n \n const docPath = path.resolve(__dirname, '..', '..', 'doc');\n \n const gtocPath = path.join(docPath, 'api', '_toc.md');\n const gtocMD = fs.readFileSync(gtocPath, 'utf8').replace(/^@\\/\\/.*$/gm, '');\n const gtocHTML = marked(gtocMD).replace(\n   /<a href=\"(.*?)\"/g,\n-  (all, href) => `<a class=\"nav-${toID(href)}\" href=\"${href}\"`\n+  (all, href) => `<a class=\"nav-${href.replace('.html', '')\n+                                      .replace(/\\W+/g, '-')}\" href=\"${href}\"`\n );\n \n const templatePath = path.join(docPath, 'template.html');\n const template = fs.readFileSync(templatePath, 'utf8');\n \n-var docCreated = null;\n-var nodeVersion = null;\n-\n-/**\n- * opts: input, filename, nodeVersion.\n- */\n-function toHTML(opts, cb) {\n-  nodeVersion = opts.nodeVersion || process.version;\n-  docCreated = opts.input.match(DOC_CREATED_REG_EXP);\n-\n-  const lexed = marked.lexer(opts.input);\n-  render({\n-    lexed: lexed,\n-    filename: opts.filename,\n-    template: template,\n-    nodeVersion: nodeVersion,\n-    analytics: opts.analytics,\n-  }, cb);\n-}\n-\n-function toID(filename) {\n-  return filename\n-    .replace('.html', '')\n-    .replace(/[^\\w-]/g, '-')\n-    .replace(/-+/g, '-');\n-}\n-\n-/**\n- * opts: lexed, filename, template, nodeVersion.\n- */\n-function render(opts, cb) {\n-  var { lexed, filename, template } = opts;\n-  const nodeVersion = opts.nodeVersion || process.version;\n+function toHTML({ input, filename, nodeVersion, analytics }, cb) {\n+  filename = path.basename(filename, '.md');\n \n-  // Get the section.\n-  const section = getSection(lexed);\n+  const lexed = marked.lexer(input);\n \n-  filename = path.basename(filename, '.md');\n+  const firstHeading = lexed.find(({ type }) => type === 'heading');\n+  const section = firstHeading ? firstHeading.text : 'Index';\n \n-  parseText(lexed);\n-  lexed = preprocessElements(lexed);\n-\n-  // Generate the table of contents.\n-  // This mutates the lexed contents in-place.\n-  buildToc(lexed, filename, function(er, toc) {\n-    if (er) return cb(er);\n-\n-    const id = toID(path.basename(filename));\n-\n-    template = template.replace(/__ID__/g, id);\n-    template = template.replace(/__FILENAME__/g, filename);\n-    template = template.replace(/__SECTION__/g, section || 'Index');\n-    template = template.replace(/__VERSION__/g, nodeVersion);\n-    template = template.replace(/__TOC__/g, toc);\n-    template = template.replace(\n-      /__GTOC__/g,\n-      gtocHTML.replace(`class=\"nav-${id}`, `class=\"nav-${id} active`)\n-    );\n-\n-    if (opts.analytics) {\n-      template = template.replace(\n-        '<!-- __TRACKING__ -->',\n-        analyticsScript(opts.analytics)\n-      );\n-    }\n+  preprocessText(lexed);\n+  preprocessElements(lexed);\n \n-    template = template.replace(/__ALTDOCS__/, altDocs(filename));\n+  // Generate the table of contents. This mutates the lexed contents in-place.\n+  const toc = buildToc(lexed, filename);\n \n-    // Content has to be the last thing we do with the lexed tokens,\n-    // because it's destructive.\n-    const content = marked.parser(lexed);\n-    template = template.replace(/__CONTENT__/g, content);\n+  const id = filename.replace(/\\W+/g, '-');\n \n-    cb(null, template);\n-  });\n-}\n+  let HTML = template.replace('__ID__', id)\n+                     .replace(/__FILENAME__/g, filename)\n+                     .replace('__SECTION__', section)\n+                     .replace(/__VERSION__/g, nodeVersion)\n+                     .replace('__TOC__', toc)\n+                     .replace('__GTOC__', gtocHTML.replace(\n+                       `class=\"nav-${id}`, `class=\"nav-${id} active`));\n \n-function analyticsScript(analytics) {\n-  return `\n+  if (analytics) {\n+    HTML = HTML.replace('<!-- __TRACKING__ -->', `\n     <script src=\"assets/dnt_helper.js\"></script>\n     <script>\n       if (!_dntEnabled()) {\n@@ -143,149 +84,143 @@ function analyticsScript(analytics) {\n         ga('create', '${analytics}', 'auto');\n         ga('send', 'pageview');\n       }\n-    </script>\n-  `;\n-}\n-\n-// Replace placeholders in text tokens.\n-function replaceInText(text) {\n-  return linkJsTypeDocs(linkManPages(text));\n-}\n-\n-function altDocs(filename) {\n-  if (!docCreated) {\n-    console.error(`Failed to add alternative version links to ${filename}`);\n-    return '';\n-  }\n-\n-  function lte(v) {\n-    const ns = v.num.split('.');\n-    if (docCreated[1] > +ns[0])\n-      return false;\n-    if (docCreated[1] < +ns[0])\n-      return true;\n-    return docCreated[2] <= +ns[1];\n+    </script>`);\n   }\n \n-  const versions = [\n-    { num: '10.x' },\n-    { num: '9.x' },\n-    { num: '8.x', lts: true },\n-    { num: '7.x' },\n-    { num: '6.x', lts: true },\n-    { num: '5.x' },\n-    { num: '4.x', lts: true },\n-    { num: '0.12.x' },\n-    { num: '0.10.x' }\n-  ];\n-\n-  const host = 'https://nodejs.org';\n-  const href = (v) => `${host}/docs/latest-v${v.num}/api/${filename}.html`;\n-\n-  function li(v) {\n-    let html = `<li><a href=\"${href(v)}\">${v.num}`;\n-\n-    if (v.lts)\n-      html += ' <b>LTS</b>';\n-\n-    return html + '</a></li>';\n+  const docCreated = input.match(\n+    /<!--\\s*introduced_in\\s*=\\s*v([0-9]+)\\.([0-9]+)\\.[0-9]+\\s*-->/);\n+  if (docCreated) {\n+    HTML = HTML.replace('__ALTDOCS__', altDocs(filename, docCreated));\n+  } else {\n+    console.error(`Failed to add alternative version links to ${filename}`);\n+    HTML = HTML.replace('__ALTDOCS__', '');\n   }\n \n-  const lis = versions.filter(lte).map(li).join('\\n');\n+  // Content insertion has to be the last thing we do with the lexed tokens,\n+  // because it's destructive.\n+  HTML = HTML.replace('__CONTENT__', marked.parser(lexed));\n \n-  if (!lis.length)\n-    return '';\n-\n-  return `\n-    <li class=\"version-picker\">\n-      <a href=\"#\">View another version <span>&#x25bc;</span></a>\n-      <ol class=\"version-picker\">${lis}</ol>\n-    </li>\n-  `;\n+  cb(null, HTML);\n }\n \n // Handle general body-text replacements.\n // For example, link man page references to the actual page.\n-function parseText(lexed) {\n-  lexed.forEach(function(tok) {\n-    if (tok.type === 'table') {\n-      if (tok.cells) {\n-        tok.cells.forEach((row, x) => {\n-          row.forEach((_, y) => {\n-            if (tok.cells[x] && tok.cells[x][y]) {\n-              tok.cells[x][y] = replaceInText(tok.cells[x][y]);\n-            }\n-          });\n-        });\n+function preprocessText(lexed) {\n+  lexed.forEach((token) => {\n+    if (token.type === 'table') {\n+      if (token.header) {\n+        token.header = token.header.map(replaceInText);\n       }\n \n-      if (tok.header) {\n-        tok.header.forEach((_, i) => {\n-          if (tok.header[i]) {\n-            tok.header[i] = replaceInText(tok.header[i]);\n-          }\n+      if (token.cells) {\n+        token.cells.forEach((row, i) => {\n+          token.cells[i] = row.map(replaceInText);\n         });\n       }\n-    } else if (tok.text && tok.type !== 'code') {\n-      tok.text = replaceInText(tok.text);\n+    } else if (token.text && token.type !== 'code') {\n+      token.text = replaceInText(token.text);\n     }\n   });\n }\n \n+// Replace placeholders in text tokens.\n+function replaceInText(text) {\n+  if (text === '') return text;\n+  return linkJsTypeDocs(linkManPages(text));\n+}\n+\n+// Syscalls which appear in the docs, but which only exist in BSD / macOS.\n+const BSD_ONLY_SYSCALLS = new Set(['lchmod']);\n+const MAN_PAGE = /(^|\\s)([a-z.]+)\\((\\d)([a-z]?)\\)/gm;\n+\n+// Handle references to man pages, eg \"open(2)\" or \"lchmod(2)\".\n+// Returns modified text, with such refs replaced with HTML links, for example\n+// '<a href=\"http://man7.org/linux/man-pages/man2/open.2.html\">open(2)</a>'.\n+function linkManPages(text) {\n+  return text.replace(\n+    MAN_PAGE, (match, beginning, name, number, optionalCharacter) => {\n+      // Name consists of lowercase letters,\n+      // number is a single digit with an optional lowercase letter.\n+      const displayAs = `${name}(${number}${optionalCharacter})`;\n+\n+      if (BSD_ONLY_SYSCALLS.has(name)) {\n+        return `${beginning}<a href=\"https://www.freebsd.org/cgi/man.cgi` +\n+          `?query=${name}&sektion=${number}\">${displayAs}</a>`;\n+      }\n+      return `${beginning}<a href=\"http://man7.org/linux/man-pages/man${number}` +\n+        `/${name}.${number}${optionalCharacter}.html\">${displayAs}</a>`;\n+    });\n+}\n+\n+const TYPE_SIGNATURE = /\\{[^}]+\\}/g;\n+function linkJsTypeDocs(text) {\n+  const parts = text.split('`');\n+\n+  // Handle types, for example the source Markdown might say\n+  // \"This argument should be a {number} or {string}\".\n+  for (let i = 0; i < parts.length; i += 2) {\n+    const typeMatches = parts[i].match(TYPE_SIGNATURE);\n+    if (typeMatches) {\n+      typeMatches.forEach((typeMatch) => {\n+        parts[i] = parts[i].replace(typeMatch, typeParser.toLink(typeMatch));\n+      });\n+    }\n+  }\n+\n+  return parts.join('`');\n+}\n+\n // Preprocess stability blockquotes and YAML blocks.\n-function preprocessElements(input) {\n-  var state = null;\n-  const output = [];\n+function preprocessElements(lexed) {\n+  const STABILITY_RE = /(.*:)\\s*(\\d)([\\s\\S]*)/;\n+  let state = null;\n   let headingIndex = -1;\n   let heading = null;\n \n-  output.links = input.links;\n-  input.forEach(function(tok, index) {\n-    if (tok.type === 'heading') {\n+  lexed.forEach((token, index) => {\n+    if (token.type === 'heading') {\n       headingIndex = index;\n-      heading = tok;\n+      heading = token;\n     }\n-    if (tok.type === 'html' && common.isYAMLBlock(tok.text)) {\n-      tok.text = parseYAML(tok.text);\n+    if (token.type === 'html' && common.isYAMLBlock(token.text)) {\n+      token.text = parseYAML(token.text);\n     }\n-    if (tok.type === 'blockquote_start') {\n+    if (token.type === 'blockquote_start') {\n       state = 'MAYBE_STABILITY_BQ';\n-      return;\n+      lexed[index] = { type: 'space' };\n     }\n-    if (tok.type === 'blockquote_end' && state === 'MAYBE_STABILITY_BQ') {\n+    if (token.type === 'blockquote_end' && state === 'MAYBE_STABILITY_BQ') {\n       state = null;\n-      return;\n+      lexed[index] = { type: 'space' };\n     }\n-    if (tok.type === 'paragraph' && state === 'MAYBE_STABILITY_BQ') {\n-      if (tok.text.match(/Stability:.*/g)) {\n-        const stabilityMatch = tok.text.match(STABILITY_TEXT_REG_EXP);\n-        const stability = Number(stabilityMatch[2]);\n+    if (token.type === 'paragraph' && state === 'MAYBE_STABILITY_BQ') {\n+      if (token.text.includes('Stability:')) {\n+        const [, prefix, number, explication] = token.text.match(STABILITY_RE);\n         const isStabilityIndex =\n           index - 2 === headingIndex || // General.\n           index - 3 === headingIndex;   // With api_metadata block.\n \n         if (heading && isStabilityIndex) {\n-          heading.stability = stability;\n+          heading.stability = number;\n           headingIndex = -1;\n           heading = null;\n         }\n-        tok.text = parseAPIHeader(tok.text).replace(/\\n/g, ' ');\n-        output.push({ type: 'html', text: tok.text });\n-        return;\n+        token.text = `<div class=\"api_stability api_stability_${number}\">` +\n+          '<a href=\"documentation.html#documentation_stability_index\">' +\n+          `${prefix} ${number}</a>${explication}</div>`\n+          .replace(/\\n/g, ' ');\n+        lexed[index] = { type: 'html', text: token.text };\n       } else if (state === 'MAYBE_STABILITY_BQ') {\n-        output.push({ type: 'blockquote_start' });\n         state = null;\n+        lexed[index - 1] = { type: 'blockquote_start' };\n       }\n     }\n-    output.push(tok);\n   });\n-\n-  return output;\n }\n \n function parseYAML(text) {\n   const meta = common.extractAndParseYAML(text);\n-  const html = ['<div class=\"api_metadata\">'];\n+  let html = '<div class=\"api_metadata\">\\n';\n \n   const added = { description: '' };\n   const deprecated = { description: '' };\n@@ -302,159 +237,130 @@ function parseYAML(text) {\n   }\n \n   if (meta.changes.length > 0) {\n-    let changes = meta.changes.slice();\n-    if (added.description) changes.push(added);\n-    if (deprecated.description) changes.push(deprecated);\n+    if (added.description) meta.changes.push(added);\n+    if (deprecated.description) meta.changes.push(deprecated);\n \n-    changes = changes.sort((a, b) => versionSort(a.version, b.version));\n+    meta.changes.sort((a, b) => versionSort(a.version, b.version));\n \n-    html.push('<details class=\"changelog\"><summary>History</summary>');\n-    html.push('<table>');\n-    html.push('<tr><th>Version</th><th>Changes</th></tr>');\n+    html += '<details class=\"changelog\"><summary>History</summary>\\n' +\n+            '<table>\\n<tr><th>Version</th><th>Changes</th></tr>\\n';\n \n-    changes.forEach((change) => {\n-      html.push(`<tr><td>${change.version}</td>`);\n-      html.push(`<td>${marked(change.description)}</td></tr>`);\n+    meta.changes.forEach((change) => {\n+      html += `<tr><td>${change.version}</td>\\n` +\n+                  `<td>${marked(change.description)}</td></tr>\\n`;\n     });\n \n-    html.push('</table>');\n-    html.push('</details>');\n+    html += '</table>\\n</details>\\n';\n   } else {\n-    html.push(`${added.description}${deprecated.description}`);\n-  }\n-\n-  html.push('</div>');\n-  return html.join('\\n');\n-}\n-\n-// Syscalls which appear in the docs, but which only exist in BSD / macOS.\n-const BSD_ONLY_SYSCALLS = new Set(['lchmod']);\n-\n-// Handle references to man pages, eg \"open(2)\" or \"lchmod(2)\".\n-// Returns modified text, with such refs replaced with HTML links, for example\n-// '<a href=\"http://man7.org/linux/man-pages/man2/open.2.html\">open(2)</a>'.\n-function linkManPages(text) {\n-  return text.replace(\n-    /(^|\\s)([a-z.]+)\\((\\d)([a-z]?)\\)/gm,\n-    (match, beginning, name, number, optionalCharacter) => {\n-      // Name consists of lowercase letters, number is a single digit.\n-      const displayAs = `${name}(${number}${optionalCharacter})`;\n-      if (BSD_ONLY_SYSCALLS.has(name)) {\n-        return `${beginning}<a href=\"https://www.freebsd.org/cgi/man.cgi?query=${name}` +\n-          `&sektion=${number}\">${displayAs}</a>`;\n-      } else {\n-        return `${beginning}<a href=\"http://man7.org/linux/man-pages/man${number}` +\n-          `/${name}.${number}${optionalCharacter}.html\">${displayAs}</a>`;\n-      }\n-    });\n-}\n-\n-function linkJsTypeDocs(text) {\n-  const parts = text.split('`');\n-  var i;\n-  var typeMatches;\n-\n-  // Handle types, for example the source Markdown might say\n-  // \"This argument should be a {Number} or {String}\".\n-  for (i = 0; i < parts.length; i += 2) {\n-    typeMatches = parts[i].match(/\\{([^}]+)\\}/g);\n-    if (typeMatches) {\n-      typeMatches.forEach(function(typeMatch) {\n-        parts[i] = parts[i].replace(typeMatch, typeParser.toLink(typeMatch));\n-      });\n-    }\n+    html += `${added.description}${deprecated.description}\\n`;\n   }\n \n-  // TODO: maybe put more stuff here?\n-  return parts.join('`');\n+  html += '</div>';\n+  return html;\n }\n \n-function parseAPIHeader(text) {\n-  const classNames = 'api_stability api_stability_$2';\n-  const docsUrl = 'documentation.html#documentation_stability_index';\n-\n-  text = text.replace(\n-    STABILITY_TEXT_REG_EXP,\n-    `<div class=\"${classNames}\"><a href=\"${docsUrl}\">$1 $2</a>$3</div>`\n-  );\n-  return text;\n-}\n-\n-// Section is just the first heading.\n-function getSection(lexed) {\n-  for (var i = 0, l = lexed.length; i < l; i++) {\n-    var tok = lexed[i];\n-    if (tok.type === 'heading') return tok.text;\n-  }\n-  return '';\n-}\n-\n-function getMark(anchor) {\n-  return `<span><a class=\"mark\" href=\"#${anchor}\" id=\"${anchor}\">#</a></span>`;\n+const numberRe = /^\\d*/;\n+function versionSort(a, b) {\n+  a = a.trim();\n+  b = b.trim();\n+  let i = 0; // Common prefix length.\n+  while (i < a.length && i < b.length && a[i] === b[i]) i++;\n+  a = a.substr(i);\n+  b = b.substr(i);\n+  return +b.match(numberRe)[0] - +a.match(numberRe)[0];\n }\n \n-function buildToc(lexed, filename, cb) {\n-  var toc = [];\n-  var depth = 0;\n-\n+function buildToc(lexed, filename) {\n   const startIncludeRefRE = /^\\s*<!-- \\[start-include:(.+)\\] -->\\s*$/;\n-  const endIncludeRefRE = /^\\s*<!-- \\[end-include:(.+)\\] -->\\s*$/;\n+  const endIncludeRefRE = /^\\s*<!-- \\[end-include:.+\\] -->\\s*$/;\n   const realFilenames = [filename];\n-\n-  lexed.forEach(function(tok) {\n-    // Keep track of the current filename along @include directives.\n-    if (tok.type === 'html') {\n-      let match;\n-      if ((match = tok.text.match(startIncludeRefRE)) !== null)\n-        realFilenames.unshift(match[1]);\n-      else if (tok.text.match(endIncludeRefRE))\n+  const idCounters = Object.create(null);\n+  let toc = '';\n+  let depth = 0;\n+\n+  lexed.forEach((token) => {\n+    // Keep track of the current filename along comment wrappers of inclusions.\n+    if (token.type === 'html') {\n+      const [, includedFileName] = token.text.match(startIncludeRefRE) || [];\n+      if (includedFileName !== undefined)\n+        realFilenames.unshift(includedFileName);\n+      else if (endIncludeRefRE.test(token.text))\n         realFilenames.shift();\n     }\n \n-    if (tok.type !== 'heading') return;\n-    if (tok.depth - depth > 1) {\n-      return cb(new Error('Inappropriate heading level\\n' +\n-                          JSON.stringify(tok)));\n+    if (token.type !== 'heading') return;\n+\n+    if (token.depth - depth > 1) {\n+      throw new Error(`Inappropriate heading level:\\n${JSON.stringify(token)}`);\n     }\n \n-    depth = tok.depth;\n+    depth = token.depth;\n     const realFilename = path.basename(realFilenames[0], '.md');\n-    const apiName = tok.text.trim();\n-    const id = getId(`${realFilename}_${apiName}`);\n-    toc.push(new Array((depth - 1) * 2 + 1).join(' ') +\n-             `* <span class=\"stability_${tok.stability}\">` +\n-             `<a href=\"#${id}\">${tok.text}</a></span>`);\n-    tok.text += getMark(id);\n-    if (realFilename === 'errors' && apiName.startsWith('ERR_')) {\n-      tok.text += getMark(apiName);\n+    const headingText = token.text.trim();\n+    const id = getId(`${realFilename}_${headingText}`, idCounters);\n+    toc += ' '.repeat((depth - 1) * 2) +\n+           `* <span class=\"stability_${token.stability}\">` +\n+           `<a href=\"#${id}\">${token.text}</a></span>\\n`;\n+    token.text += `<span><a class=\"mark\" href=\"#${id}\" id=\"${id}\">#</a></span>`;\n+    if (realFilename === 'errors' && headingText.startsWith('ERR_')) {\n+      token.text += `<span><a class=\"mark\" href=\"#${headingText}\" ` +\n+                                             `id=\"${headingText}\">#</a></span>`;\n     }\n   });\n \n-  toc = marked.parse(toc.join('\\n'));\n-  cb(null, toc);\n+  return marked(toc);\n }\n \n-const idCounters = {};\n-function getId(text) {\n-  text = text.toLowerCase();\n-  text = text.replace(/[^a-z0-9]+/g, '_');\n-  text = text.replace(/^_+|_+$/, '');\n-  text = text.replace(/^([^a-z])/, '_$1');\n-  if (idCounters.hasOwnProperty(text)) {\n-    text += `_${++idCounters[text]}`;\n-  } else {\n-    idCounters[text] = 0;\n+const notAlphaNumerics = /[^a-z0-9]+/g;\n+const edgeUnderscores = /^_+|_+$/g;\n+const notAlphaStart = /^[^a-z]/;\n+function getId(text, idCounters) {\n+  text = text.toLowerCase()\n+             .replace(notAlphaNumerics, '_')\n+             .replace(edgeUnderscores, '')\n+             .replace(notAlphaStart, '_$&');\n+  if (idCounters[text] !== undefined) {\n+    return `${text}_${++idCounters[text]}`;\n   }\n+  idCounters[text] = 0;\n   return text;\n }\n \n-const numberRe = /^(\\d*)/;\n-function versionSort(a, b) {\n-  a = a.trim();\n-  b = b.trim();\n-  let i = 0; // Common prefix length.\n-  while (i < a.length && i < b.length && a[i] === b[i]) i++;\n-  a = a.substr(i);\n-  b = b.substr(i);\n-  return +b.match(numberRe)[1] - +a.match(numberRe)[1];\n+function altDocs(filename, docCreated) {\n+  const [, docCreatedMajor, docCreatedMinor] = docCreated.map(Number);\n+  const host = 'https://nodejs.org';\n+  const versions = [\n+    { num: '10.x' },\n+    { num: '9.x' },\n+    { num: '8.x', lts: true },\n+    { num: '7.x' },\n+    { num: '6.x', lts: true },\n+    { num: '5.x' },\n+    { num: '4.x', lts: true },\n+    { num: '0.12.x' },\n+    { num: '0.10.x' }\n+  ];\n+\n+  const getHref = (versionNum) =>\n+    `${host}/docs/latest-v${versionNum}/api/${filename}.html`;\n+\n+  const wrapInListItem = (version) =>\n+    `<li><a href=\"${getHref(version.num)}\">${version.num}` +\n+    `${version.lts ? ' <b>LTS</b>' : ''}</a></li>`;\n+\n+  function isDocInVersion(version) {\n+    const [versionMajor, versionMinor] = version.num.split('.').map(Number);\n+    if (docCreatedMajor > versionMajor) return false;\n+    if (docCreatedMajor < versionMajor) return true;\n+    return docCreatedMinor <= versionMinor;\n+  }\n+\n+  const list = versions.filter(isDocInVersion).map(wrapInListItem).join('\\n');\n+\n+  return list ? `\n+    <li class=\"version-picker\">\n+      <a href=\"#\">View another version <span>&#x25bc;</span></a>\n+      <ol class=\"version-picker\">${list}</ol>\n+    </li>\n+  ` : '';\n }"
        }
    ],
    "stats": {
        "total": 520,
        "additions": 213,
        "deletions": 307
    }
}