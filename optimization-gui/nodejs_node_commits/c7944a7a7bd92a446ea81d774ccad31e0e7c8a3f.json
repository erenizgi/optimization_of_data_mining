{
    "author": "bengl",
    "message": "fs: readdir optionally returning type information\n\nreaddir and readdirSync now have a \"withFileTypes\" option, which, when\nenabled, provides an array of DirectoryEntry objects, similar to Stats\nobjects, which have the filename and the type information.\n\nRefs: https://github.com/nodejs/node/issues/15699\n\nPR-URL: https://github.com/nodejs/node/pull/22020\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Roman Reiss <me@silverwind.io>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>",
    "sha": "c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
    "files": [
        {
            "sha": "01023eb56e3e52c714c1fa20e69c0e97f310789a",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 99,
            "deletions": 2,
            "changes": 101,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -283,6 +283,92 @@ synchronous use libuv's threadpool, which can have surprising and negative\n performance implications for some applications. See the\n [`UV_THREADPOOL_SIZE`][] documentation for more information.\n \n+## Class: fs.Dirent\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+When [`fs.readdir()`][] or [`fs.readdirSync()`][] is called with the\n+`withFileTypes` option set to `true`, the resulting array is filled with\n+`fs.Dirent` objects, rather than strings or `Buffers`.\n+\n+### dirent.isBlockDevice()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a block device.\n+\n+### dirent.isCharacterDevice()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a character device.\n+\n+### dirent.isDirectory()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a file system\n+directory.\n+\n+### dirent.isFIFO()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a first-in-first-out\n+(FIFO) pipe.\n+\n+### dirent.isFile()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a regular file.\n+\n+### dirent.isSocket()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a socket.\n+\n+### dirent.isSymbolicLink()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Returns `true` if the `fs.Dirent` object describes a symbolic link.\n+\n+\n+### dirent.name\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string|Buffer}\n+\n+The file name that this `fs.Dirent` object refers to. The type of this\n+value is determined by the `options.encoding` passed to [`fs.readdir()`][] or\n+[`fs.readdirSync()`][].\n+\n ## Class: fs.FSWatcher\n <!-- YAML\n added: v0.5.8\n@@ -2319,9 +2405,10 @@ changes:\n * `path` {string|Buffer|URL}\n * `options` {string|Object}\n   * `encoding` {string} **Default:** `'utf8'`\n+  * `withFileTypes` {boolean} **Default:** `false`\n * `callback` {Function}\n   * `err` {Error}\n-  * `files` {string[]|Buffer[]}\n+  * `files` {string[]|Buffer[]|fs.Dirent[]}\n \n Asynchronous readdir(3). Reads the contents of a directory.\n The callback gets two arguments `(err, files)` where `files` is an array of\n@@ -2332,6 +2419,9 @@ object with an `encoding` property specifying the character encoding to use for\n the filenames passed to the callback. If the `encoding` is set to `'buffer'`,\n the filenames returned will be passed as `Buffer` objects.\n \n+If `options.withFileTypes` is set to `true`, the `files` array will contain\n+[`fs.Dirent`][] objects.\n+\n ## fs.readdirSync(path[, options])\n <!-- YAML\n added: v0.1.21\n@@ -2345,7 +2435,8 @@ changes:\n * `path` {string|Buffer|URL}\n * `options` {string|Object}\n   * `encoding` {string} **Default:** `'utf8'`\n-* Returns: {string[]} An array of filenames excluding `'.'` and `'..'`.\n+  * `withFileTypes` {boolean} **Default:** `false`\n+* Returns: {string[]|Buffer[]|fs.Dirent[]}\n \n Synchronous readdir(3).\n \n@@ -2354,6 +2445,9 @@ object with an `encoding` property specifying the character encoding to use for\n the filenames returned. If the `encoding` is set to `'buffer'`,\n the filenames returned will be passed as `Buffer` objects.\n \n+If `options.withFileTypes` is set to `true`, the result will contain\n+[`fs.Dirent`][] objects.\n+\n ## fs.readFile(path[, options], callback)\n <!-- YAML\n added: v0.1.29\n@@ -4637,6 +4731,7 @@ the file contents.\n [`WriteStream`]: #fs_class_fs_writestream\n [`EventEmitter`]: events.html\n [`event ports`]: http://illumos.org/man/port_create\n+[`fs.Dirent`]: #fs_class_fs_dirent\n [`fs.FSWatcher`]: #fs_class_fs_fswatcher\n [`fs.Stats`]: #fs_class_fs_stats\n [`fs.access()`]: #fs_fs_access_path_mode_callback\n@@ -4652,6 +4747,8 @@ the file contents.\n [`fs.mkdtemp()`]: #fs_fs_mkdtemp_prefix_options_callback\n [`fs.open()`]: #fs_fs_open_path_flags_mode_callback\n [`fs.read()`]: #fs_fs_read_fd_buffer_offset_length_position_callback\n+[`fs.readdir()`]: #fs_fs_readdir_path_options_callback\n+[`fs.readdirSync()`]: #fs_fs_readdirsync_path_options\n [`fs.readFile()`]: #fs_fs_readfile_path_options_callback\n [`fs.readFileSync()`]: #fs_fs_readfilesync_path_options\n [`fs.realpath()`]: #fs_fs_realpath_path_options_callback"
        },
        {
            "sha": "a0e5f64476c0fd9fdb03f683c90e79b30d486086",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 19,
            "deletions": 4,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -58,6 +58,8 @@ const { getPathFromURL } = require('internal/url');\n const internalUtil = require('internal/util');\n const {\n   copyObject,\n+  Dirent,\n+  getDirents,\n   getOptions,\n   nullCheck,\n   preprocessSymlinkDestination,\n@@ -773,8 +775,19 @@ function readdir(path, options, callback) {\n   validatePath(path);\n \n   const req = new FSReqCallback();\n-  req.oncomplete = callback;\n-  binding.readdir(pathModule.toNamespacedPath(path), options.encoding, req);\n+  if (!options.withFileTypes) {\n+    req.oncomplete = callback;\n+  } else {\n+    req.oncomplete = (err, result) => {\n+      if (err) {\n+        callback(err);\n+        return;\n+      }\n+      getDirents(path, result, callback);\n+    };\n+  }\n+  binding.readdir(pathModule.toNamespacedPath(path), options.encoding,\n+                  !!options.withFileTypes, req);\n }\n \n function readdirSync(path, options) {\n@@ -783,9 +796,10 @@ function readdirSync(path, options) {\n   validatePath(path);\n   const ctx = { path };\n   const result = binding.readdir(pathModule.toNamespacedPath(path),\n-                                 options.encoding, undefined, ctx);\n+                                 options.encoding, !!options.withFileTypes,\n+                                 undefined, ctx);\n   handleErrorFromBinding(ctx);\n-  return result;\n+  return options.withFileTypes ? getDirents(path, result) : result;\n }\n \n function fstat(fd, options, callback) {\n@@ -1819,6 +1833,7 @@ module.exports = fs = {\n   writeFileSync,\n   write,\n   writeSync,\n+  Dirent,\n   Stats,\n \n   get ReadStream() {"
        },
        {
            "sha": "e0ddee4c7f2296b85cc69c8f3269eb624405e65a",
            "filename": "lib/internal/fs/promises.js",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/lib%2Finternal%2Ffs%2Fpromises.js",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/lib%2Finternal%2Ffs%2Fpromises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fpromises.js?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -19,6 +19,7 @@ const { getPathFromURL } = require('internal/url');\n const { isUint8Array } = require('internal/util/types');\n const {\n   copyObject,\n+  getDirents,\n   getOptions,\n   getStatsFromBinding,\n   nullCheck,\n@@ -37,10 +38,13 @@ const {\n   validateUint32\n } = require('internal/validators');\n const pathModule = require('path');\n+const { promisify } = require('internal/util');\n \n const kHandle = Symbol('handle');\n const { kUsePromises } = binding;\n \n+const getDirectoryEntriesPromise = promisify(getDirents);\n+\n class FileHandle {\n   constructor(filehandle) {\n     this[kHandle] = filehandle;\n@@ -312,8 +316,12 @@ async function readdir(path, options) {\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n   validatePath(path);\n-  return binding.readdir(pathModule.toNamespacedPath(path),\n-                         options.encoding, kUsePromises);\n+  const result = await binding.readdir(pathModule.toNamespacedPath(path),\n+                                       options.encoding, !!options.withTypes,\n+                                       kUsePromises);\n+  return options.withFileTypes ?\n+    getDirectoryEntriesPromise(path, result) :\n+    result;\n }\n \n async function readlink(path, options) {"
        },
        {
            "sha": "f065ba41e89f2afb44a9e9a0a051289bc549a514",
            "filename": "lib/internal/fs/utils.js",
            "status": "modified",
            "additions": 116,
            "deletions": 1,
            "changes": 117,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/lib%2Finternal%2Ffs%2Futils.js",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/lib%2Finternal%2Ffs%2Futils.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Futils.js?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -12,6 +12,8 @@ const {\n const { isUint8Array } = require('internal/util/types');\n const pathModule = require('path');\n const util = require('util');\n+const kType = Symbol('type');\n+const kStats = Symbol('stats');\n \n const {\n   O_APPEND,\n@@ -31,24 +33,135 @@ const {\n   S_IFREG,\n   S_IFSOCK,\n   UV_FS_SYMLINK_DIR,\n-  UV_FS_SYMLINK_JUNCTION\n+  UV_FS_SYMLINK_JUNCTION,\n+  UV_DIRENT_UNKNOWN,\n+  UV_DIRENT_FILE,\n+  UV_DIRENT_DIR,\n+  UV_DIRENT_LINK,\n+  UV_DIRENT_FIFO,\n+  UV_DIRENT_SOCKET,\n+  UV_DIRENT_CHAR,\n+  UV_DIRENT_BLOCK\n } = process.binding('constants').fs;\n \n const isWindows = process.platform === 'win32';\n \n+let fs;\n+function lazyLoadFs() {\n+  if (!fs) {\n+    fs = require('fs');\n+  }\n+  return fs;\n+}\n+\n function assertEncoding(encoding) {\n   if (encoding && !Buffer.isEncoding(encoding)) {\n     throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);\n   }\n }\n \n+class Dirent {\n+  constructor(name, type) {\n+    this.name = name;\n+    this[kType] = type;\n+  }\n+\n+  isDirectory() {\n+    return this[kType] === UV_DIRENT_DIR;\n+  }\n+\n+  isFile() {\n+    return this[kType] === UV_DIRENT_FILE;\n+  }\n+\n+  isBlockDevice() {\n+    return this[kType] === UV_DIRENT_BLOCK;\n+  }\n+\n+  isCharacterDevice() {\n+    return this[kType] === UV_DIRENT_CHAR;\n+  }\n+\n+  isSymbolicLink() {\n+    return this[kType] === UV_DIRENT_LINK;\n+  }\n+\n+  isFIFO() {\n+    return this[kType] === UV_DIRENT_FIFO;\n+  }\n+\n+  isSocket() {\n+    return this[kType] === UV_DIRENT_SOCKET;\n+  }\n+}\n+\n+class DirentFromStats extends Dirent {\n+  constructor(name, stats) {\n+    super(name, null);\n+    this[kStats] = stats;\n+  }\n+}\n+\n+for (const name of Reflect.ownKeys(Dirent.prototype)) {\n+  if (name === 'constructor') {\n+    continue;\n+  }\n+  DirentFromStats.prototype[name] = function() {\n+    return this[kStats][name]();\n+  };\n+}\n+\n function copyObject(source) {\n   var target = {};\n   for (var key in source)\n     target[key] = source[key];\n   return target;\n }\n \n+function getDirents(path, [names, types], callback) {\n+  var i;\n+  if (typeof callback == 'function') {\n+    const len = names.length;\n+    let toFinish = 0;\n+    for (i = 0; i < len; i++) {\n+      const type = types[i];\n+      if (type === UV_DIRENT_UNKNOWN) {\n+        const name = names[i];\n+        const idx = i;\n+        toFinish++;\n+        lazyLoadFs().stat(pathModule.resolve(path, name), (err, stats) => {\n+          if (err) {\n+            callback(err);\n+            return;\n+          }\n+          names[idx] = new DirentFromStats(name, stats);\n+          if (--toFinish === 0) {\n+            callback(null, names);\n+          }\n+        });\n+      } else {\n+        names[i] = new Dirent(names[i], types[i]);\n+      }\n+    }\n+    if (toFinish === 0) {\n+      callback(null, names);\n+    }\n+  } else {\n+    const len = names.length;\n+    for (i = 0; i < len; i++) {\n+      const type = types[i];\n+      if (type === UV_DIRENT_UNKNOWN) {\n+        const name = names[i];\n+        const stats = lazyLoadFs().statSync(pathModule.resolve(path, name));\n+        names[i] = new DirentFromStats(name, stats);\n+      } else {\n+        names[i] = new Dirent(names[i], types[i]);\n+      }\n+    }\n+    return names;\n+  }\n+}\n+\n function getOptions(options, defaultOptions) {\n   if (options === null || options === undefined ||\n       typeof options === 'function') {\n@@ -342,6 +455,8 @@ function validatePath(path, propName = 'path') {\n module.exports = {\n   assertEncoding,\n   copyObject,\n+  Dirent,\n+  getDirents,\n   getOptions,\n   nullCheck,\n   preprocessSymlinkDestination,"
        },
        {
            "sha": "28d5a9ca4edd38eeacf553d549ab35ef407a8dbe",
            "filename": "src/node_constants.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/src%2Fnode_constants.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/src%2Fnode_constants.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_constants.cc?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -1022,6 +1022,16 @@ void DefineSystemConstants(Local<Object> target) {\n   NODE_DEFINE_CONSTANT(target, O_WRONLY);\n   NODE_DEFINE_CONSTANT(target, O_RDWR);\n \n+  // file types from readdir\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_UNKNOWN);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FILE);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_DIR);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_LINK);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FIFO);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_SOCKET);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_CHAR);\n+  NODE_DEFINE_CONSTANT(target, UV_DIRENT_BLOCK);\n+\n   NODE_DEFINE_CONSTANT(target, S_IFMT);\n   NODE_DEFINE_CONSTANT(target, S_IFREG);\n   NODE_DEFINE_CONSTANT(target, S_IFDIR);"
        },
        {
            "sha": "fb976a31a5b3c1a8090fa73fe3a420ac091706dd",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 174,
            "deletions": 43,
            "changes": 217,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -561,51 +561,139 @@ void AfterScanDir(uv_fs_t* req) {\n   FSReqBase* req_wrap = FSReqBase::from_req(req);\n   FSReqAfterScope after(req_wrap, req);\n \n-  if (after.Proceed()) {\n-    Environment* env = req_wrap->env();\n-    Local<Value> error;\n-    int r;\n-    Local<Array> names = Array::New(env->isolate(), 0);\n-    Local<Function> fn = env->push_values_to_array_function();\n-    Local<Value> name_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-    size_t name_idx = 0;\n+  if (!after.Proceed()) {\n+    return;\n+  }\n+  Environment* env = req_wrap->env();\n+  Local<Value> error;\n+  int r;\n+  Local<Array> names = Array::New(env->isolate(), 0);\n+  Local<Function> fn = env->push_values_to_array_function();\n+  Local<Value> name_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+  size_t name_idx = 0;\n \n-    for (int i = 0; ; i++) {\n-      uv_dirent_t ent;\n+  for (int i = 0; ; i++) {\n+    uv_dirent_t ent;\n \n-      r = uv_fs_scandir_next(req, &ent);\n-      if (r == UV_EOF)\n-        break;\n-      if (r != 0) {\n-        return req_wrap->Reject(\n-            UVException(r, nullptr, req_wrap->syscall(),\n-                        static_cast<const char*>(req->path)));\n+    r = uv_fs_scandir_next(req, &ent);\n+    if (r == UV_EOF)\n+      break;\n+    if (r != 0) {\n+      return req_wrap->Reject(\n+          UVException(r, nullptr, req_wrap->syscall(),\n+            static_cast<const char*>(req->path)));\n+    }\n+\n+    MaybeLocal<Value> filename =\n+      StringBytes::Encode(env->isolate(),\n+          ent.name,\n+          req_wrap->encoding(),\n+          &error);\n+    if (filename.IsEmpty())\n+      return req_wrap->Reject(error);\n+\n+    name_argv[name_idx++] = filename.ToLocalChecked();\n+\n+    if (name_idx >= arraysize(name_argv)) {\n+      MaybeLocal<Value> ret = fn->Call(env->context(), names, name_idx,\n+                                       name_argv);\n+      if (ret.IsEmpty()) {\n+        return;\n       }\n+      name_idx = 0;\n+    }\n+  }\n \n-      MaybeLocal<Value> filename =\n-          StringBytes::Encode(env->isolate(),\n-                              ent.name,\n-                              req_wrap->encoding(),\n-                              &error);\n-      if (filename.IsEmpty())\n-        return req_wrap->Reject(error);\n+  if (name_idx > 0) {\n+    fn->Call(env->context(), names, name_idx, name_argv)\n+      .ToLocalChecked();\n+  }\n \n-      name_argv[name_idx++] = filename.ToLocalChecked();\n+  req_wrap->Resolve(names);\n+}\n \n-      if (name_idx >= arraysize(name_argv)) {\n-        fn->Call(env->context(), names, name_idx, name_argv)\n-            .ToLocalChecked();\n-        name_idx = 0;\n+void AfterScanDirWithTypes(uv_fs_t* req) {\n+  FSReqBase* req_wrap = FSReqBase::from_req(req);\n+  FSReqAfterScope after(req_wrap, req);\n+\n+  if (!after.Proceed()) {\n+    return;\n+  }\n+\n+  Environment* env = req_wrap->env();\n+  Local<Value> error;\n+  int r;\n+  Local<Array> names = Array::New(env->isolate(), 0);\n+  Local<Function> fn = env->push_values_to_array_function();\n+  Local<Value> name_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+  size_t name_idx = 0;\n+  Local<Value> types = Array::New(env->isolate(), 0);\n+  Local<Value> type_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+  size_t type_idx = 0;\n+\n+  for (int i = 0; ; i++) {\n+    uv_dirent_t ent;\n+\n+    r = uv_fs_scandir_next(req, &ent);\n+    if (r == UV_EOF)\n+      break;\n+    if (r != 0) {\n+      return req_wrap->Reject(\n+          UVException(r, nullptr, req_wrap->syscall(),\n+            static_cast<const char*>(req->path)));\n+    }\n+\n+    MaybeLocal<Value> filename =\n+      StringBytes::Encode(env->isolate(),\n+          ent.name,\n+          req_wrap->encoding(),\n+          &error);\n+    if (filename.IsEmpty())\n+      return req_wrap->Reject(error);\n+\n+    name_argv[name_idx++] = filename.ToLocalChecked();\n+\n+    if (name_idx >= arraysize(name_argv)) {\n+      MaybeLocal<Value> ret = fn->Call(env->context(), names, name_idx,\n+                                       name_argv);\n+      if (ret.IsEmpty()) {\n+        return;\n       }\n+      name_idx = 0;\n     }\n \n-    if (name_idx > 0) {\n-      fn->Call(env->context(), names, name_idx, name_argv)\n-          .ToLocalChecked();\n+    type_argv[type_idx++] = Integer::New(env->isolate(), ent.type);\n+\n+    if (type_idx >= arraysize(type_argv)) {\n+      MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx,\n+          type_argv);\n+      if (ret.IsEmpty()) {\n+        return;\n+      }\n+      type_idx = 0;\n     }\n+  }\n \n-    req_wrap->Resolve(names);\n+  if (name_idx > 0) {\n+    MaybeLocal<Value> ret = fn->Call(env->context(), names, name_idx,\n+        name_argv);\n+    if (ret.IsEmpty()) {\n+      return;\n+    }\n+  }\n+\n+  if (type_idx > 0) {\n+    MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx,\n+        type_argv);\n+    if (ret.IsEmpty()) {\n+      return;\n+    }\n   }\n+\n+  Local<Array> result = Array::New(env->isolate(), 2);\n+  result->Set(0, names);\n+  result->Set(1, types);\n+  req_wrap->Resolve(result);\n }\n \n \n@@ -1372,15 +1460,22 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n-  if (req_wrap_async != nullptr) {  // readdir(path, encoding, req)\n-    AsyncCall(env, req_wrap_async, args, \"scandir\", encoding, AfterScanDir,\n-              uv_fs_scandir, *path, 0 /*flags*/);\n-  } else {  // readdir(path, encoding, undefined, ctx)\n-    CHECK_EQ(argc, 4);\n+  bool with_types = args[2]->BooleanValue();\n+\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // readdir(path, encoding, withTypes, req)\n+    if (with_types) {\n+      AsyncCall(env, req_wrap_async, args, \"scandir\", encoding,\n+                AfterScanDirWithTypes, uv_fs_scandir, *path, 0 /*flags*/);\n+    } else {\n+      AsyncCall(env, req_wrap_async, args, \"scandir\", encoding,\n+                AfterScanDir, uv_fs_scandir, *path, 0 /*flags*/);\n+    }\n+  } else {  // readdir(path, encoding, withTypes, undefined, ctx)\n+    CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n     FS_SYNC_TRACE_BEGIN(readdir);\n-    int err = SyncCall(env, args[3], &req_wrap_sync, \"scandir\",\n+    int err = SyncCall(env, args[4], &req_wrap_sync, \"scandir\",\n                        uv_fs_scandir, *path, 0 /*flags*/);\n     FS_SYNC_TRACE_END(readdir);\n     if (err < 0) {\n@@ -1394,14 +1489,22 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n     Local<Value> name_v[NODE_PUSH_VAL_TO_ARRAY_MAX];\n     size_t name_idx = 0;\n \n+    Local<Value> types;\n+    Local<Value> type_v[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+    size_t type_idx;\n+    if (with_types) {\n+      types = Array::New(env->isolate(), 0);\n+      type_idx = 0;\n+    }\n+\n     for (int i = 0; ; i++) {\n       uv_dirent_t ent;\n \n       r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);\n       if (r == UV_EOF)\n         break;\n       if (r != 0) {\n-        Local<Object> ctx = args[3].As<Object>();\n+        Local<Object> ctx = args[4].As<Object>();\n         ctx->Set(env->context(), env->errno_string(),\n                  Integer::New(env->isolate(), r)).FromJust();\n         ctx->Set(env->context(), env->syscall_string(),\n@@ -1414,8 +1517,9 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n                                                        ent.name,\n                                                        encoding,\n                                                        &error);\n+\n       if (filename.IsEmpty()) {\n-        Local<Object> ctx = args[3].As<Object>();\n+        Local<Object> ctx = args[4].As<Object>();\n         ctx->Set(env->context(), env->error_string(), error).FromJust();\n         return;\n       }\n@@ -1430,6 +1534,19 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n         }\n         name_idx = 0;\n       }\n+\n+      if (with_types) {\n+        type_v[type_idx++] = Integer::New(env->isolate(), ent.type);\n+\n+        if (type_idx >= arraysize(type_v)) {\n+          MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx,\n+              type_v);\n+          if (ret.IsEmpty()) {\n+            return;\n+          }\n+          type_idx = 0;\n+        }\n+      }\n     }\n \n     if (name_idx > 0) {\n@@ -1439,7 +1556,21 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n       }\n     }\n \n-    args.GetReturnValue().Set(names);\n+    if (with_types && type_idx > 0) {\n+      MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx, type_v);\n+      if (ret.IsEmpty()) {\n+        return;\n+      }\n+    }\n+\n+    if (with_types) {\n+      Local<Array> result = Array::New(env->isolate(), 2);\n+      result->Set(0, names);\n+      result->Set(1, types);\n+      args.GetReturnValue().Set(result);\n+    } else {\n+      args.GetReturnValue().Set(names);\n+    }\n   }\n }\n "
        },
        {
            "sha": "75452895cc178e354843bbe8b01b68661166daa2",
            "filename": "test/parallel/test-fs-readdir-types.js",
            "status": "added",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/test%2Fparallel%2Ftest-fs-readdir-types.js",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/test%2Fparallel%2Ftest-fs-readdir-types.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-readdir-types.js?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -0,0 +1,95 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const fs = require('fs');\n+\n+const tmpdir = require('../common/tmpdir');\n+\n+const binding = process.binding('fs');\n+\n+const readdirDir = tmpdir.path;\n+const files = ['empty', 'files', 'for', 'just', 'testing'];\n+const constants = process.binding('constants').fs;\n+const types = {\n+  isDirectory: constants.UV_DIRENT_DIR,\n+  isFile: constants.UV_DIRENT_FILE,\n+  isBlockDevice: constants.UV_DIRENT_BLOCK,\n+  isCharacterDevice: constants.UV_DIRENT_CHAR,\n+  isSymbolicLink: constants.UV_DIRENT_LINK,\n+  isFIFO: constants.UV_DIRENT_FIFO,\n+  isSocket: constants.UV_DIRENT_SOCKET\n+};\n+const typeMethods = Object.keys(types);\n+\n+// Make sure tmp directory is clean\n+tmpdir.refresh();\n+\n+// Create the necessary files\n+files.forEach(function(currentFile) {\n+  fs.closeSync(fs.openSync(`${readdirDir}/${currentFile}`, 'w'));\n+});\n+\n+\n+function assertDirents(dirents) {\n+  assert.strictEqual(files.length, dirents.length);\n+  for (const [i, dirent] of dirents.entries()) {\n+    assert(dirent instanceof fs.Dirent);\n+    assert.strictEqual(dirent.name, files[i]);\n+    assert.strictEqual(dirent.isFile(), true);\n+    assert.strictEqual(dirent.isDirectory(), false);\n+    assert.strictEqual(dirent.isSocket(), false);\n+    assert.strictEqual(dirent.isBlockDevice(), false);\n+    assert.strictEqual(dirent.isCharacterDevice(), false);\n+    assert.strictEqual(dirent.isFIFO(), false);\n+    assert.strictEqual(dirent.isSymbolicLink(), false);\n+  }\n+}\n+\n+// Check the readdir Sync version\n+assertDirents(fs.readdirSync(readdirDir, { withFileTypes: true }));\n+\n+// Check the readdir async version\n+fs.readdir(readdirDir, {\n+  withFileTypes: true\n+}, common.mustCall((err, dirents) => {\n+  assert.ifError(err);\n+  assertDirents(dirents);\n+}));\n+\n+// Check for correct types when the binding returns unknowns\n+const UNKNOWN = constants.UV_DIRENT_UNKNOWN;\n+const oldReaddir = binding.readdir;\n+binding.readdir = common.mustCall((path, encoding, types, req, ctx) => {\n+  if (req) {\n+    const oldCb = req.oncomplete;\n+    req.oncomplete = (err, results) => {\n+      if (err) {\n+        oldCb(err);\n+        return;\n+      }\n+      results[1] = results[1].map(() => UNKNOWN);\n+      oldCb(null, results);\n+    };\n+    oldReaddir(path, encoding, types, req);\n+  } else {\n+    const results = oldReaddir(path, encoding, types, req, ctx);\n+    results[1] = results[1].map(() => UNKNOWN);\n+    return results;\n+  }\n+}, 2);\n+assertDirents(fs.readdirSync(readdirDir, { withFileTypes: true }));\n+fs.readdir(readdirDir, {\n+  withFileTypes: true\n+}, common.mustCall((err, dirents) => {\n+  assert.ifError(err);\n+  assertDirents(dirents);\n+}));\n+\n+// Dirent types\n+for (const method of typeMethods) {\n+  const dirent = new fs.Dirent('foo', types[method]);\n+  for (const testMethod of typeMethods) {\n+    assert.strictEqual(dirent[testMethod](), testMethod === method);\n+  }\n+}"
        },
        {
            "sha": "2a63f97c798075e8341dc603848935c0e8f3a451",
            "filename": "tools/doc/type-parser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/tools%2Fdoc%2Ftype-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f/tools%2Fdoc%2Ftype-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Ftype-parser.js?ref=c7944a7a7bd92a446ea81d774ccad31e0e7c8a3f",
            "patch": "@@ -58,6 +58,7 @@ const customTypesMap = {\n   'EventEmitter': 'events.html#events_class_eventemitter',\n \n   'FileHandle': 'fs.html#fs_class_filehandle',\n+  'fs.Dirent': 'fs.html#fs_class_fs_dirent',\n   'fs.FSWatcher': 'fs.html#fs_class_fs_fswatcher',\n   'fs.ReadStream': 'fs.html#fs_class_fs_readstream',\n   'fs.Stats': 'fs.html#fs_class_fs_stats',"
        }
    ],
    "stats": {
        "total": 576,
        "additions": 524,
        "deletions": 52
    }
}