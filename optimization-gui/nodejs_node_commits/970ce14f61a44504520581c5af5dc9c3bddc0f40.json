{
    "author": "shigeki",
    "message": "crypto: remove deperecated methods of TLS version\n\nAll version-specific methods were deprecated in OpenSSL 1.1.0 and\nmin/max versions explicitly need to be set.\nThis still keeps comptatible with JS and OpenSSL-1.0.2 APIs for now.\n\ncrypto, constants: add constant of OpenSSL-1.1.0\n\nSeveral constants for OpenSSL-1.1.0 engine were removed and renamed in\nOpenSSL-1.1.0. This added one renamed constant in order to have a\ncompatible feature with that of OpenSSL-1.0.2.\nOther missed or new constants in OpenSSL-1.1.0 are not yet added.\n\ncrypto,tls,constants: remove OpenSSL1.0.2 support\n\nThis is semver-majar change so that we need not to have\ncompatibilities with older versions.\n\nFixes: https://github.com/nodejs/node/issues/4270\nPR-URL: https://github.com/nodejs/node/pull/19794\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Rod Vagg <rod@vagg.org>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "970ce14f61a44504520581c5af5dc9c3bddc0f40",
    "files": [
        {
            "sha": "68339c0032804b0d7298ecd16d9e8a10a17f2963",
            "filename": "src/node_constants.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 10,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/970ce14f61a44504520581c5af5dc9c3bddc0f40/src%2Fnode_constants.cc",
            "raw_url": "https://github.com/nodejs/node/raw/970ce14f61a44504520581c5af5dc9c3bddc0f40/src%2Fnode_constants.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_constants.cc?ref=970ce14f61a44504520581c5af5dc9c3bddc0f40",
            "patch": "@@ -917,12 +917,8 @@ void DefineOpenSSLConstants(Local<Object> target) {\n     NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_RAND);\n # endif\n \n-# ifdef ENGINE_METHOD_ECDH\n-    NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_ECDH);\n-# endif\n-\n-# ifdef ENGINE_METHOD_ECDSA\n-    NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_ECDSA);\n+# ifdef ENGINE_METHOD_EC\n+    NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_EC);\n # endif\n \n # ifdef ENGINE_METHOD_CIPHERS\n@@ -933,10 +929,6 @@ void DefineOpenSSLConstants(Local<Object> target) {\n     NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_DIGESTS);\n # endif\n \n-# ifdef ENGINE_METHOD_STORE\n-    NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_STORE);\n-# endif\n-\n # ifdef ENGINE_METHOD_PKEY_METHS\n     NODE_DEFINE_CONSTANT(target, ENGINE_METHOD_PKEY_METHS);\n # endif"
        },
        {
            "sha": "9733fddcf3e2ec1e147551f0be61d3a3f5c2d9b6",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 208,
            "changes": 242,
            "blob_url": "https://github.com/nodejs/node/blob/970ce14f61a44504520581c5af5dc9c3bddc0f40/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/970ce14f61a44504520581c5af5dc9c3bddc0f40/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=970ce14f61a44504520581c5af5dc9c3bddc0f40",
            "patch": "@@ -105,118 +105,6 @@ struct StackOfX509Deleter {\n \n using StackOfX509 = std::unique_ptr<STACK_OF(X509), StackOfX509Deleter>;\n \n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-static void RSA_get0_key(const RSA* r, const BIGNUM** n, const BIGNUM** e,\n-                         const BIGNUM** d) {\n-  if (n != nullptr) {\n-    *n = r->n;\n-  }\n-  if (e != nullptr) {\n-    *e = r->e;\n-  }\n-  if (d != nullptr) {\n-    *d = r->d;\n-  }\n-}\n-\n-static void DH_get0_pqg(const DH* dh, const BIGNUM** p, const BIGNUM** q,\n-                        const BIGNUM** g) {\n-  if (p != nullptr) {\n-    *p = dh->p;\n-  }\n-  if (q != nullptr) {\n-    *q = dh->q;\n-  }\n-  if (g != nullptr) {\n-    *g = dh->g;\n-  }\n-}\n-\n-static int DH_set0_pqg(DH* dh, BIGNUM* p, BIGNUM* q, BIGNUM* g) {\n-  if ((dh->p == nullptr && p == nullptr) ||\n-      (dh->g == nullptr && g == nullptr)) {\n-    return 0;\n-  }\n-\n-  if (p != nullptr) {\n-    BN_free(dh->p);\n-    dh->p = p;\n-  }\n-  if (q != nullptr) {\n-    BN_free(dh->q);\n-    dh->q = q;\n-  }\n-  if (g != nullptr) {\n-    BN_free(dh->g);\n-    dh->g = g;\n-  }\n-\n-  return 1;\n-}\n-\n-static void DH_get0_key(const DH* dh, const BIGNUM** pub_key,\n-                        const BIGNUM** priv_key) {\n-  if (pub_key != nullptr) {\n-    *pub_key = dh->pub_key;\n-  }\n-  if (priv_key != nullptr) {\n-    *priv_key = dh->priv_key;\n-  }\n-}\n-\n-static int DH_set0_key(DH* dh, BIGNUM* pub_key, BIGNUM* priv_key) {\n-  if (pub_key != nullptr) {\n-    BN_free(dh->pub_key);\n-    dh->pub_key = pub_key;\n-  }\n-  if (priv_key != nullptr) {\n-    BN_free(dh->priv_key);\n-    dh->priv_key = priv_key;\n-  }\n-\n-  return 1;\n-}\n-\n-static const SSL_METHOD* TLS_method() { return SSLv23_method(); }\n-\n-static void SSL_SESSION_get0_ticket(const SSL_SESSION* s,\n-                                    const unsigned char** tick, size_t* len) {\n-  *len = s->tlsext_ticklen;\n-  if (tick != nullptr) {\n-    *tick = s->tlsext_tick;\n-  }\n-}\n-\n-#define SSL_get_tlsext_status_type(ssl) (ssl->tlsext_status_type)\n-\n-static int X509_STORE_up_ref(X509_STORE* store) {\n-  CRYPTO_add(&store->references, 1, CRYPTO_LOCK_X509_STORE);\n-  return 1;\n-}\n-\n-static int X509_up_ref(X509* cert) {\n-  CRYPTO_add(&cert->references, 1, CRYPTO_LOCK_X509);\n-  return 1;\n-}\n-\n-#define EVP_MD_CTX_new EVP_MD_CTX_create\n-#define EVP_MD_CTX_free EVP_MD_CTX_destroy\n-\n-HMAC_CTX* HMAC_CTX_new() {\n-  HMAC_CTX* ctx = Malloc<HMAC_CTX>(1);\n-  HMAC_CTX_init(ctx);\n-  return ctx;\n-}\n-\n-void HMAC_CTX_free(HMAC_CTX* ctx) {\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-  HMAC_CTX_cleanup(ctx);\n-  free(ctx);\n-}\n-#endif  // OPENSSL_VERSION_NUMBER < 0x10100000L\n-\n static const char* const root_certs[] = {\n #include \"node_root_certs.h\"  // NOLINT(build/include_order)\n };\n@@ -233,19 +121,11 @@ template void SSLWrap<TLSWrap>::AddMethods(Environment* env,\n template void SSLWrap<TLSWrap>::ConfigureSecureContext(SecureContext* sc);\n template void SSLWrap<TLSWrap>::SetSNIContext(SecureContext* sc);\n template int SSLWrap<TLSWrap>::SetCACerts(SecureContext* sc);\n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-template SSL_SESSION* SSLWrap<TLSWrap>::GetSessionCallback(\n-    SSL* s,\n-    unsigned char* key,\n-    int len,\n-    int* copy);\n-#else\n template SSL_SESSION* SSLWrap<TLSWrap>::GetSessionCallback(\n     SSL* s,\n     const unsigned char* key,\n     int len,\n     int* copy);\n-#endif\n template int SSLWrap<TLSWrap>::NewSessionCallback(SSL* s,\n                                                   SSL_SESSION* sess);\n template void SSLWrap<TLSWrap>::OnClientHello(\n@@ -270,33 +150,6 @@ template int SSLWrap<TLSWrap>::SelectALPNCallback(\n     void* arg);\n #endif  // TLSEXT_TYPE_application_layer_protocol_negotiation\n \n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-static Mutex* mutexes;\n-\n-static void crypto_threadid_cb(CRYPTO_THREADID* tid) {\n-  static_assert(sizeof(uv_thread_t) <= sizeof(void*),\n-                \"uv_thread_t does not fit in a pointer\");\n-  CRYPTO_THREADID_set_pointer(tid, reinterpret_cast<void*>(uv_thread_self()));\n-}\n-\n-\n-static void crypto_lock_init(void) {\n-  mutexes = new Mutex[CRYPTO_num_locks()];\n-}\n-\n-\n-static void crypto_lock_cb(int mode, int n, const char* file, int line) {\n-  CHECK(!(mode & CRYPTO_LOCK) ^ !(mode & CRYPTO_UNLOCK));\n-  CHECK(!(mode & CRYPTO_READ) ^ !(mode & CRYPTO_WRITE));\n-\n-  auto mutex = &mutexes[n];\n-  if (mode & CRYPTO_LOCK)\n-    mutex->Lock();\n-  else\n-    mutex->Unlock();\n-}\n-#endif\n-\n \n static int PasswordCallback(char *buf, int size, int rwflag, void *u) {\n   if (u) {\n@@ -526,6 +379,8 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());\n   Environment* env = sc->env();\n \n+  int min_version = 0;\n+  int max_version = 0;\n   const SSL_METHOD* method = TLS_method();\n \n   if (args.Length() == 1 && args[0]->IsString()) {\n@@ -548,29 +403,47 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n     } else if (strcmp(*sslmethod, \"SSLv3_client_method\") == 0) {\n       return env->ThrowError(\"SSLv3 methods disabled\");\n     } else if (strcmp(*sslmethod, \"SSLv23_method\") == 0) {\n-      method = SSLv23_method();\n+      method = TLS_method();\n     } else if (strcmp(*sslmethod, \"SSLv23_server_method\") == 0) {\n-      method = SSLv23_server_method();\n+      method = TLS_server_method();\n     } else if (strcmp(*sslmethod, \"SSLv23_client_method\") == 0) {\n-      method = SSLv23_client_method();\n+      method = TLS_client_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_method\") == 0) {\n-      method = TLSv1_method();\n+      min_version = TLS1_VERSION;\n+      max_version = TLS1_VERSION;\n+      method = TLS_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_server_method\") == 0) {\n-      method = TLSv1_server_method();\n+      min_version = TLS1_VERSION;\n+      max_version = TLS1_VERSION;\n+      method = TLS_server_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_client_method\") == 0) {\n-      method = TLSv1_client_method();\n+      min_version = TLS1_VERSION;\n+      max_version = TLS1_VERSION;\n+      method = TLS_client_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_1_method\") == 0) {\n-      method = TLSv1_1_method();\n+      min_version = TLS1_1_VERSION;\n+      max_version = TLS1_1_VERSION;\n+      method = TLS_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_1_server_method\") == 0) {\n-      method = TLSv1_1_server_method();\n+      min_version = TLS1_1_VERSION;\n+      max_version = TLS1_1_VERSION;\n+      method = TLS_server_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_1_client_method\") == 0) {\n-      method = TLSv1_1_client_method();\n+      min_version = TLS1_1_VERSION;\n+      max_version = TLS1_1_VERSION;\n+      method = TLS_client_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_2_method\") == 0) {\n-      method = TLSv1_2_method();\n+      min_version = TLS1_2_VERSION;\n+      max_version = TLS1_2_VERSION;\n+      method = TLS_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_2_server_method\") == 0) {\n-      method = TLSv1_2_server_method();\n+      min_version = TLS1_2_VERSION;\n+      max_version = TLS1_2_VERSION;\n+      method = TLS_server_method();\n     } else if (strcmp(*sslmethod, \"TLSv1_2_client_method\") == 0) {\n-      method = TLSv1_2_client_method();\n+      min_version = TLS1_2_VERSION;\n+      max_version = TLS1_2_VERSION;\n+      method = TLS_client_method();\n     } else {\n       return env->ThrowError(\"Unknown method\");\n     }\n@@ -592,7 +465,8 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n                                  SSL_SESS_CACHE_NO_INTERNAL |\n                                  SSL_SESS_CACHE_NO_AUTO_CLEAR);\n \n-#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+  SSL_CTX_set_min_proto_version(sc->ctx_, min_version);\n+  SSL_CTX_set_max_proto_version(sc->ctx_, max_version);\n   // OpenSSL 1.1.0 changed the ticket key size, but the OpenSSL 1.0.x size was\n   // exposed in the public API. To retain compatibility, install a callback\n   // which restores the old algorithm.\n@@ -603,7 +477,6 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n   }\n   SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_,\n                                    SecureContext::TicketCompatibilityCallback);\n-#endif\n }\n \n \n@@ -1061,11 +934,6 @@ void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {\n \n   node::Utf8Value curve(env->isolate(), args[0]);\n \n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-  SSL_CTX_set_options(sc->ctx_, SSL_OP_SINGLE_ECDH_USE);\n-  SSL_CTX_set_ecdh_auto(sc->ctx_, 1);\n-#endif\n-\n   if (strcmp(*curve, \"auto\") == 0)\n     return;\n \n@@ -1324,17 +1192,9 @@ void SecureContext::GetTicketKeys(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n \n   Local<Object> buff = Buffer::New(wrap->env(), 48).ToLocalChecked();\n-#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n   memcpy(Buffer::Data(buff), wrap->ticket_key_name_, 16);\n   memcpy(Buffer::Data(buff) + 16, wrap->ticket_key_hmac_, 16);\n   memcpy(Buffer::Data(buff) + 32, wrap->ticket_key_aes_, 16);\n-#else\n-  if (SSL_CTX_get_tlsext_ticket_keys(wrap->ctx_,\n-                                     Buffer::Data(buff),\n-                                     Buffer::Length(buff)) != 1) {\n-    return wrap->env()->ThrowError(\"Failed to fetch tls ticket keys\");\n-  }\n-#endif\n \n   args.GetReturnValue().Set(buff);\n #endif  // !def(OPENSSL_NO_TLSEXT) && def(SSL_CTX_get_tlsext_ticket_keys)\n@@ -1357,32 +1217,16 @@ void SecureContext::SetTicketKeys(const FunctionCallbackInfo<Value>& args) {\n     return env->ThrowTypeError(\"Ticket keys length must be 48 bytes\");\n   }\n \n-#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n   memcpy(wrap->ticket_key_name_, Buffer::Data(args[0]), 16);\n   memcpy(wrap->ticket_key_hmac_, Buffer::Data(args[0]) + 16, 16);\n   memcpy(wrap->ticket_key_aes_, Buffer::Data(args[0]) + 32, 16);\n-#else\n-  if (SSL_CTX_set_tlsext_ticket_keys(wrap->ctx_,\n-                                     Buffer::Data(args[0]),\n-                                     Buffer::Length(args[0])) != 1) {\n-    return env->ThrowError(\"Failed to fetch tls ticket keys\");\n-  }\n-#endif\n \n   args.GetReturnValue().Set(true);\n #endif  // !def(OPENSSL_NO_TLSEXT) && def(SSL_CTX_get_tlsext_ticket_keys)\n }\n \n \n void SecureContext::SetFreeListLength(const FunctionCallbackInfo<Value>& args) {\n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-  // |freelist_max_len| was removed in OpenSSL 1.1.0. In that version OpenSSL\n-  // mallocs and frees buffers directly, without the use of a freelist.\n-  SecureContext* wrap;\n-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n-\n-  wrap->ctx_->freelist_max_len = args[0]->Int32Value();\n-#endif\n }\n \n \n@@ -1478,7 +1322,6 @@ int SecureContext::TicketKeyCallback(SSL* ssl,\n }\n \n \n-#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n int SecureContext::TicketCompatibilityCallback(SSL* ssl,\n                                                unsigned char* name,\n                                                unsigned char* iv,\n@@ -1513,7 +1356,6 @@ int SecureContext::TicketCompatibilityCallback(SSL* ssl,\n   }\n   return 1;\n }\n-#endif\n \n \n void SecureContext::CtxGetter(const FunctionCallbackInfo<Value>& info) {\n@@ -1592,19 +1434,11 @@ void SSLWrap<Base>::ConfigureSecureContext(SecureContext* sc) {\n }\n \n \n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-template <class Base>\n-SSL_SESSION* SSLWrap<Base>::GetSessionCallback(SSL* s,\n-                                               unsigned char* key,\n-                                               int len,\n-                                               int* copy) {\n-#else\n template <class Base>\n SSL_SESSION* SSLWrap<Base>::GetSessionCallback(SSL* s,\n                                                const unsigned char* key,\n                                                int len,\n                                                int* copy) {\n-#endif\n   Base* w = static_cast<Base*>(SSL_get_app_data(s));\n \n   *copy = 0;\n@@ -3566,14 +3400,12 @@ SignBase::~SignBase() {\n \n SignBase::Error SignBase::Init(const char* sign_type) {\n   CHECK_EQ(mdctx_, nullptr);\n-#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n   // Historically, \"dss1\" and \"DSS1\" were DSA aliases for SHA-1\n   // exposed through the public API.\n   if (strcmp(sign_type, \"dss1\") == 0 ||\n       strcmp(sign_type, \"DSS1\") == 0) {\n     sign_type = \"SHA1\";\n   }\n-#endif\n   const EVP_MD* md = EVP_get_digestbyname(sign_type);\n   if (md == nullptr)\n     return kSignUnknownDigest;\n@@ -5556,12 +5388,6 @@ void InitCryptoOnce() {\n   SSL_library_init();\n   OpenSSL_add_all_algorithms();\n \n-#if OPENSSL_VERSION_NUMBER < 0x10100000L\n-  crypto_lock_init();\n-  CRYPTO_set_locking_callback(crypto_lock_cb);\n-  CRYPTO_THREADID_set_callback(crypto_threadid_cb);\n-#endif\n-\n #ifdef NODE_FIPS_MODE\n   /* Override FIPS settings in cnf file, if needed. */\n   unsigned long err = 0;  // NOLINT(runtime/int)"
        }
    ],
    "stats": {
        "total": 254,
        "additions": 36,
        "deletions": 218
    }
}