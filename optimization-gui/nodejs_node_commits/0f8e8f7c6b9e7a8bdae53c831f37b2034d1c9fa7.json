{
    "author": "sam-github",
    "message": "tls: introduce client 'session' event\n\nOpenSSL has supported async notification of sessions and tickets since\n1.1.0 using SSL_CTX_sess_set_new_cb(), for all versions of TLS. Using\nthe async API is optional for TLS1.2 and below, but for TLS1.3 it will\nbe mandatory. Future-proof applications should start to use async\nnotification immediately. In the future, for TLS1.3, applications that\ndon't use the async API will silently, but gracefully, fail to resume\nsessions and instead do a full handshake.\n\nSee: https://wiki.openssl.org/index.php/TLS1.3#Sessions\n\nPR-URL: https://github.com/nodejs/node/pull/25831\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Fedor Indutny <fedor.indutny@gmail.com>",
    "sha": "0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
    "files": [
        {
            "sha": "7add7d5fef8e200f5d041c0e802e10346e8ab879",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 46,
            "deletions": 3,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -152,9 +152,9 @@ will create a new session. See [RFC 2246][] for more information, page 23 and\n Resumption using session identifiers is supported by most web browsers when\n making HTTPS requests.\n \n-For Node.js, clients must call [`tls.TLSSocket.getSession()`][] after the\n-[`'secureConnect'`][] event to get the session data, and provide the data to the\n-`session` option of [`tls.connect()`][] to reuse the session. Servers must\n+For Node.js, clients wait for the [`'session'`][] event to get the session data,\n+and provide the data to the `session` option of a subsequent [`tls.connect()`][]\n+to reuse the session. Servers must\n implement handlers for the [`'newSession'`][] and [`'resumeSession'`][] events\n to save and restore the session data using the session ID as the lookup key to\n reuse sessions. To reuse sessions across load balancers or cluster workers,\n@@ -614,6 +614,45 @@ determine if the server certificate was signed by one of the specified CAs. If\n `tlsSocket.alpnProtocol` property can be checked to determine the negotiated\n protocol.\n \n+### Event: 'session'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `session` {Buffer}\n+\n+The `'session'` event is emitted on a client `tls.TLSSocket` when a new session\n+or TLS ticket is available. This may or may not be before the handshake is\n+complete, depending on the TLS protocol version that was negotiated. The event\n+is not emitted on the server, or if a new session was not created, for example,\n+when the connection was resumed. For some TLS protocol versions the event may be\n+emitted multiple times, in which case all the sessions can be used for\n+resumption.\n+\n+On the client, the `session` can be provided to the `session` option of\n+[`tls.connect()`][] to resume the connection.\n+\n+See [Session Resumption][] for more information.\n+\n+Note: For TLS1.2 and below, [`tls.TLSSocket.getSession()`][] can be called once\n+the handshake is complete.  For TLS1.3, only ticket based resumption is allowed\n+by the protocol, multiple tickets are sent, and the tickets aren't sent until\n+later, after the handshake completes, so it is necessary to wait for the\n+`'session'` event to get a resumable session.  Future-proof applications are\n+recommended to use the `'session'` event instead of `getSession()` to ensure\n+they will work for all TLS protocol versions.  Applications that only expect to\n+get or use 1 session should listen for this event only once:\n+\n+```js\n+tlsSocket.once('session', (session) => {\n+  // The session can be used immediately or later.\n+  tls.connect({\n+    session: session,\n+    // Other connect options...\n+  });\n+});\n+```\n+\n ### tlsSocket.address()\n <!-- YAML\n added: v0.11.4\n@@ -880,6 +919,9 @@ for debugging.\n \n See [Session Resumption][] for more information.\n \n+Note: `getSession()` works only for TLS1.2 and below. Future-proof applications\n+should use the [`'session'`][] event.\n+\n ### tlsSocket.getTLSTicket()\n <!-- YAML\n added: v0.11.4\n@@ -1540,6 +1582,7 @@ where `secureSocket` has the same API as `pair.cleartext`.\n [`'resumeSession'`]: #tls_event_resumesession\n [`'secureConnect'`]: #tls_event_secureconnect\n [`'secureConnection'`]: #tls_event_secureconnection\n+[`'session'`]: #tls_event_session\n [`--tls-cipher-list`]: cli.html#cli_tls_cipher_list_list\n [`NODE_OPTIONS`]: cli.html#cli_node_options_options\n [`crypto.getCurves()`]: crypto.html#crypto_crypto_getcurves"
        },
        {
            "sha": "9d47c9c2baf27d6ad6adbdbd6102c3a9d2de2aa7",
            "filename": "lib/_tls_wrap.js",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/lib%2F_tls_wrap.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/lib%2F_tls_wrap.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_tls_wrap.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -214,6 +214,12 @@ function requestOCSPDone(socket) {\n }\n \n \n+function onnewsessionclient(sessionId, session) {\n+  debug('client onnewsessionclient', sessionId, session);\n+  const owner = this[owner_symbol];\n+  owner.emit('session', session);\n+}\n+\n function onnewsession(sessionId, session) {\n   const owner = this[owner_symbol];\n \n@@ -514,6 +520,21 @@ TLSSocket.prototype._init = function(socket, wrap) {\n \n     if (options.session)\n       ssl.setSession(options.session);\n+\n+    ssl.onnewsession = onnewsessionclient;\n+\n+    // Only call .onnewsession if there is a session listener.\n+    this.on('newListener', newListener);\n+\n+    function newListener(event) {\n+      if (event !== 'session')\n+        return;\n+\n+      ssl.enableSessionCallbacks();\n+\n+      // Remover this listener since its no longer needed.\n+      this.removeListener('newListener', newListener);\n+    }\n   }\n \n   ssl.onerror = onerror;"
        },
        {
            "sha": "041bd41edde5ecfc7fabb3614674acf340c05ad5",
            "filename": "lib/https.js",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/lib%2Fhttps.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/lib%2Fhttps.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fhttps.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -117,18 +117,20 @@ function createConnection(port, host, options) {\n     }\n   }\n \n-  const socket = tls.connect(options, () => {\n-    if (!options._agentKey)\n-      return;\n+  const socket = tls.connect(options);\n \n-    this._cacheSession(options._agentKey, socket.getSession());\n-  });\n-\n-  // Evict session on error\n-  socket.once('close', (err) => {\n-    if (err)\n-      this._evictSession(options._agentKey);\n-  });\n+  if (options._agentKey) {\n+    // Cache new session for reuse\n+    socket.on('session', (session) => {\n+      this._cacheSession(options._agentKey, session);\n+    });\n+\n+    // Evict session on error\n+    socket.once('close', (err) => {\n+      if (err)\n+        this._evictSession(options._agentKey);\n+    });\n+  }\n \n   return socket;\n }"
        },
        {
            "sha": "228dd0d16da12280700a41684f15d3df85510102",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -512,6 +512,7 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n \n   // SSL session cache configuration\n   SSL_CTX_set_session_cache_mode(sc->ctx_.get(),\n+                                 SSL_SESS_CACHE_CLIENT |\n                                  SSL_SESS_CACHE_SERVER |\n                                  SSL_SESS_CACHE_NO_INTERNAL |\n                                  SSL_SESS_CACHE_NO_AUTO_CLEAR);\n@@ -1540,7 +1541,10 @@ int SSLWrap<Base>::NewSessionCallback(SSL* s, SSL_SESSION* sess) {\n       reinterpret_cast<const char*>(session_id_data),\n       session_id_length).ToLocalChecked();\n   Local<Value> argv[] = { session_id, session };\n-  w->awaiting_new_session_ = true;\n+  // On servers, we pause the handshake until callback of 'newSession', which\n+  // calls NewSessionDoneCb(). On clients, there is no callback to wait for.\n+  if (w->is_server())\n+    w->awaiting_new_session_ = true;\n   w->MakeCallback(env->onnewsession_string(), arraysize(argv), argv);\n \n   return 0;"
        },
        {
            "sha": "fdd51dc57bf91a906258cfbccd220632edf35501",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -792,6 +792,11 @@ void TLSWrap::EnableSessionCallbacks(\n   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n   CHECK_NOT_NULL(wrap->ssl_);\n   wrap->enable_session_callbacks();\n+\n+  // Clients don't use the HelloParser.\n+  if (wrap->is_client())\n+    return;\n+\n   crypto::NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);\n   wrap->hello_parser_.Start(SSLWrap<TLSWrap>::OnClientHello,\n                             OnClientHelloParseEnd,"
        },
        {
            "sha": "cf1bbdf26268237feb8c3c37d7772923ea5e48c1",
            "filename": "test/parallel/test-https-client-resume.js",
            "status": "modified",
            "additions": 12,
            "deletions": 15,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-https-client-resume.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-https-client-resume.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-https-client-resume.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -43,45 +43,42 @@ const server = https.createServer(options, common.mustCall((req, res) => {\n }, 2));\n \n // start listening\n-server.listen(0, function() {\n-\n-  let session1 = null;\n+server.listen(0, common.mustCall(function() {\n   const client1 = tls.connect({\n     port: this.address().port,\n     rejectUnauthorized: false\n-  }, () => {\n+  }, common.mustCall(() => {\n     console.log('connect1');\n-    assert.ok(!client1.isSessionReused(), 'Session *should not* be reused.');\n-    session1 = client1.getSession();\n+    assert.strictEqual(client1.isSessionReused(), false);\n     client1.write('GET / HTTP/1.0\\r\\n' +\n                   'Server: 127.0.0.1\\r\\n' +\n                   '\\r\\n');\n-  });\n+  }));\n \n-  client1.on('close', () => {\n-    console.log('close1');\n+  client1.on('session', common.mustCall((session) => {\n+    console.log('session');\n \n     const opts = {\n       port: server.address().port,\n       rejectUnauthorized: false,\n-      session: session1\n+      session,\n     };\n \n-    const client2 = tls.connect(opts, () => {\n+    const client2 = tls.connect(opts, common.mustCall(() => {\n       console.log('connect2');\n-      assert.ok(client2.isSessionReused(), 'Session *should* be reused.');\n+      assert.strictEqual(client2.isSessionReused(), true);\n       client2.write('GET / HTTP/1.0\\r\\n' +\n                     'Server: 127.0.0.1\\r\\n' +\n                     '\\r\\n');\n-    });\n+    }));\n \n     client2.on('close', () => {\n       console.log('close2');\n       server.close();\n     });\n \n     client2.resume();\n-  });\n+  }));\n \n   client1.resume();\n-});\n+}));"
        },
        {
            "sha": "5c812c8f0432ea3de4261da05ee5f2b53a1dbea1",
            "filename": "test/parallel/test-tls-async-cb-after-socket-end.js",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-async-cb-after-socket-end.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-async-cb-after-socket-end.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-async-cb-after-socket-end.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -6,9 +6,15 @@ const fixtures = require('../common/fixtures');\n const SSL_OP_NO_TICKET = require('crypto').constants.SSL_OP_NO_TICKET;\n const tls = require('tls');\n \n-// Check tls async callback after socket ends\n+// Check that TLS1.2 session resumption callbacks don't explode when made after\n+// the tls socket is destroyed. Disable TLS ticket support to force the legacy\n+// session resumption mechanism to be used.\n+\n+// TLS1.2 is the last protocol version to support TLS sessions, after that the\n+// new and resume session events will never be emitted on the server.\n \n const options = {\n+  maxVersion: 'TLSv1.2',\n   secureOptions: SSL_OP_NO_TICKET,\n   key: fixtures.readSync('test_key.pem'),\n   cert: fixtures.readSync('test_cert.pem')\n@@ -25,6 +31,8 @@ server.on('newSession', common.mustCall((key, session, done) => {\n \n server.on('resumeSession', common.mustCall((id, cb) => {\n   sessionCb = cb;\n+  // Destroy the client and then call the session cb, to check that the cb\n+  // doesn't explode when called after the handle has been destroyed.\n   next();\n }));\n "
        },
        {
            "sha": "9f868fdcdc0a497699b249e58f73568e6f8607fd",
            "filename": "test/parallel/test-tls-client-resume.js",
            "status": "modified",
            "additions": 25,
            "deletions": 17,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-client-resume.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-client-resume.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-client-resume.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -20,9 +20,9 @@\n // USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n 'use strict';\n-// Create an ssl server.  First connection, validate that not resume.\n-// Cache session and close connection.  Use session on second connection.\n-// ASSERT resumption.\n+\n+// Check that the ticket from the first connection causes session resumption\n+// when used to make a second connection.\n \n const common = require('../common');\n if (!common.hasCrypto)\n@@ -43,39 +43,47 @@ const server = tls.Server(options, common.mustCall((socket) => {\n }, 2));\n \n // start listening\n-server.listen(0, function() {\n+server.listen(0, common.mustCall(function() {\n \n+  let sessionx = null;\n   let session1 = null;\n   const client1 = tls.connect({\n     port: this.address().port,\n     rejectUnauthorized: false\n-  }, () => {\n+  }, common.mustCall(() => {\n     console.log('connect1');\n-    assert.ok(!client1.isSessionReused(), 'Session *should not* be reused.');\n-    session1 = client1.getSession();\n-  });\n+    assert.strictEqual(client1.isSessionReused(), false);\n+    sessionx = client1.getSession();\n+  }));\n+\n+  client1.once('session', common.mustCall((session) => {\n+    console.log('session1');\n+    session1 = session;\n+  }));\n \n-  client1.on('close', () => {\n-    console.log('close1');\n+  client1.on('close', common.mustCall(() => {\n+    assert(sessionx);\n+    assert(session1);\n+    assert.strictEqual(sessionx.compare(session1), 0);\n \n     const opts = {\n       port: server.address().port,\n       rejectUnauthorized: false,\n       session: session1\n     };\n \n-    const client2 = tls.connect(opts, () => {\n+    const client2 = tls.connect(opts, common.mustCall(() => {\n       console.log('connect2');\n-      assert.ok(client2.isSessionReused(), 'Session *should* be reused.');\n-    });\n+      assert.strictEqual(client2.isSessionReused(), true);\n+    }));\n \n-    client2.on('close', () => {\n+    client2.on('close', common.mustCall(() => {\n       console.log('close2');\n       server.close();\n-    });\n+    }));\n \n     client2.resume();\n-  });\n+  }));\n \n   client1.resume();\n-});\n+}));"
        },
        {
            "sha": "98fe533b6969d6e92ae46e988f15843e25805c4f",
            "filename": "test/parallel/test-tls-ticket-cluster.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-ticket-cluster.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-ticket-cluster.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-ticket-cluster.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -45,7 +45,6 @@ if (cluster.isMaster) {\n       session: lastSession,\n       rejectUnauthorized: false\n     }, () => {\n-      lastSession = c.getSession();\n       c.end();\n \n       if (++reqCount === expectedReqCount) {\n@@ -55,6 +54,8 @@ if (cluster.isMaster) {\n       } else {\n         shoot();\n       }\n+    }).once('session', (session) => {\n+      lastSession = session;\n     });\n   }\n "
        },
        {
            "sha": "d11535dd3a52552ac34c9d7c69fd8f7f556737b7",
            "filename": "test/parallel/test-tls-ticket.js",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-ticket.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7/test%2Fparallel%2Ftest-tls-ticket.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-ticket.js?ref=0f8e8f7c6b9e7a8bdae53c831f37b2034d1c9fa7",
            "patch": "@@ -81,6 +81,15 @@ const shared = net.createServer(function(c) {\n   });\n });\n \n+// 'session' events only occur for new sessions. The first connection is new.\n+// After, for each set of 3 connections, the middle connection is made when the\n+// server has random keys set, so the client's ticket is silently ignored, and a\n+// new ticket is sent.\n+const onNewSession = common.mustCall((s, session) => {\n+  assert(session);\n+  assert.strictEqual(session.compare(s.getSession()), 0);\n+}, 4);\n+\n function start(callback) {\n   let sess = null;\n   let left = servers.length;\n@@ -99,6 +108,7 @@ function start(callback) {\n       else\n         connect();\n     });\n+    s.once('session', (session) => onNewSession(s, session));\n   }\n \n   connect();"
        }
    ],
    "stats": {
        "total": 197,
        "additions": 148,
        "deletions": 49
    }
}