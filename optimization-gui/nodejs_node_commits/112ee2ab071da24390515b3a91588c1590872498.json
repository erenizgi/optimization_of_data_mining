{
    "author": "addaleax",
    "message": "src: improve ToV8Value() functions\n\n- Cache the `isolate` value between calls\n- Introduce an overload for dealing with integers/numbers\n- Use the vectored `v8::Array::New` constructor + `MaybeStackBuffer`\n  for faster array creation\n\nPR-URL: https://github.com/nodejs/node/pull/25288\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "112ee2ab071da24390515b3a91588c1590872498",
    "files": [
        {
            "sha": "6d612f1eb7c8b756489955aeff7ec913097cfdcb",
            "filename": "src/util-inl.h",
            "status": "modified",
            "additions": 41,
            "deletions": 14,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/112ee2ab071da24390515b3a91588c1590872498/src%2Futil-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/112ee2ab071da24390515b3a91588c1590872498/src%2Futil-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil-inl.h?ref=112ee2ab071da24390515b3a91588c1590872498",
            "patch": "@@ -377,8 +377,9 @@ inline char* UncheckedCalloc(size_t n) { return UncheckedCalloc<char>(n); }\n void ThrowErrStringTooLong(v8::Isolate* isolate);\n \n v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n-                                    const std::string& str) {\n-  v8::Isolate* isolate = context->GetIsolate();\n+                                    const std::string& str,\n+                                    v8::Isolate* isolate) {\n+  if (isolate == nullptr) isolate = context->GetIsolate();\n   if (UNLIKELY(str.size() >= static_cast<size_t>(v8::String::kMaxLength))) {\n     // V8 only has a TODO comment about adding an exception when the maximum\n     // string size is exceeded.\n@@ -393,33 +394,33 @@ v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n \n template <typename T>\n v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n-                                    const std::vector<T>& vec) {\n-  v8::Isolate* isolate = context->GetIsolate();\n+                                    const std::vector<T>& vec,\n+                                    v8::Isolate* isolate) {\n+  if (isolate == nullptr) isolate = context->GetIsolate();\n   v8::EscapableHandleScope handle_scope(isolate);\n \n-  v8::Local<v8::Array> arr = v8::Array::New(isolate, vec.size());\n+  MaybeStackBuffer<v8::Local<v8::Value>, 128> arr(vec.size());\n+  arr.SetLength(vec.size());\n   for (size_t i = 0; i < vec.size(); ++i) {\n-    v8::Local<v8::Value> val;\n-    if (!ToV8Value(context, vec[i]).ToLocal(&val) ||\n-        arr->Set(context, i, val).IsNothing()) {\n+    if (!ToV8Value(context, vec[i], isolate).ToLocal(&arr[i]))\n       return v8::MaybeLocal<v8::Value>();\n-    }\n   }\n \n-  return handle_scope.Escape(arr);\n+  return handle_scope.Escape(v8::Array::New(isolate, arr.out(), arr.length()));\n }\n \n template <typename T, typename U>\n v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n-                                    const std::unordered_map<T, U>& map) {\n-  v8::Isolate* isolate = context->GetIsolate();\n+                                    const std::unordered_map<T, U>& map,\n+                                    v8::Isolate* isolate) {\n+  if (isolate == nullptr) isolate = context->GetIsolate();\n   v8::EscapableHandleScope handle_scope(isolate);\n \n   v8::Local<v8::Map> ret = v8::Map::New(isolate);\n   for (const auto& item : map) {\n     v8::Local<v8::Value> first, second;\n-    if (!ToV8Value(context, item.first).ToLocal(&first) ||\n-        !ToV8Value(context, item.second).ToLocal(&second) ||\n+    if (!ToV8Value(context, item.first, isolate).ToLocal(&first) ||\n+        !ToV8Value(context, item.second, isolate).ToLocal(&second) ||\n         ret->Set(context, first, second).IsEmpty()) {\n       return v8::MaybeLocal<v8::Value>();\n     }\n@@ -428,6 +429,32 @@ v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n   return handle_scope.Escape(ret);\n }\n \n+template <typename T, typename >\n+v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n+                                    const T& number,\n+                                    v8::Isolate* isolate) {\n+  if (isolate == nullptr) isolate = context->GetIsolate();\n+\n+  using Limits = std::numeric_limits<T>;\n+  // Choose Uint32, Int32, or Double depending on range checks.\n+  // These checks should all collapse at compile time.\n+  if (static_cast<uint32_t>(Limits::max()) <=\n+          std::numeric_limits<uint32_t>::max() &&\n+      static_cast<uint32_t>(Limits::min()) >=\n+          std::numeric_limits<uint32_t>::min() && Limits::is_exact) {\n+    return v8::Integer::NewFromUnsigned(isolate, static_cast<uint32_t>(number));\n+  }\n+\n+  if (static_cast<int32_t>(Limits::max()) <=\n+          std::numeric_limits<int32_t>::max() &&\n+      static_cast<int32_t>(Limits::min()) >=\n+          std::numeric_limits<int32_t>::min() && Limits::is_exact) {\n+    return v8::Integer::New(isolate, static_cast<int32_t>(number));\n+  }\n+\n+  return v8::Number::New(isolate, static_cast<double>(number));\n+}\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "ffa5a308a7788f855341aa731f196228ab386e9f",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/112ee2ab071da24390515b3a91588c1590872498/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/112ee2ab071da24390515b3a91588c1590872498/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=112ee2ab071da24390515b3a91588c1590872498",
            "patch": "@@ -35,6 +35,7 @@\n #include <string.h>\n \n #include <functional>  // std::function\n+#include <limits>\n #include <set>\n #include <string>\n #include <array>\n@@ -519,13 +520,21 @@ using DeleteFnPtr = typename FunctionDeleter<T, function>::Pointer;\n std::set<std::string> ParseCommaSeparatedSet(const std::string& in);\n \n inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n-                                           const std::string& str);\n+                                           const std::string& str,\n+                                           v8::Isolate* isolate = nullptr);\n+template <typename T, typename test_for_number =\n+    typename std::enable_if<std::numeric_limits<T>::is_specialized, bool>::type>\n+inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n+                                           const T& number,\n+                                           v8::Isolate* isolate = nullptr);\n template <typename T>\n inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n-                                           const std::vector<T>& vec);\n+                                           const std::vector<T>& vec,\n+                                           v8::Isolate* isolate = nullptr);\n template <typename T, typename U>\n inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,\n-                                           const std::unordered_map<T, U>& map);\n+                                           const std::unordered_map<T, U>& map,\n+                                           v8::Isolate* isolate = nullptr);\n \n // These macros expects a `Isolate* isolate` and a `Local<Context> context`\n // to be in the scope."
        }
    ],
    "stats": {
        "total": 70,
        "additions": 53,
        "deletions": 17
    }
}