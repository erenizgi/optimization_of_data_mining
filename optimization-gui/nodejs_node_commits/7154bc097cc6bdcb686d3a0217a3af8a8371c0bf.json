{
    "author": "jasnell",
    "message": "fs: add FSReqPromise\n\nPR-URL: https://github.com/nodejs/node/pull/18297\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "7154bc097cc6bdcb686d3a0217a3af8a8371c0bf",
    "files": [
        {
            "sha": "286cf12dd6643f55b5ce97188d72a0bf2bddfd9b",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=7154bc097cc6bdcb686d3a0217a3af8a8371c0bf",
            "patch": "@@ -38,6 +38,7 @@ namespace node {\n   V(DNSCHANNEL)                                                               \\\n   V(FSEVENTWRAP)                                                              \\\n   V(FSREQWRAP)                                                                \\\n+  V(FSREQPROMISE)                                                             \\\n   V(GETADDRINFOREQWRAP)                                                       \\\n   V(GETNAMEINFOREQWRAP)                                                       \\\n   V(HTTP2SESSION)                                                             \\"
        },
        {
            "sha": "614bf315502aef1ac412e2232fdc623593e643b7",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=7154bc097cc6bdcb686d3a0217a3af8a8371c0bf",
            "patch": "@@ -220,6 +220,7 @@ class ModuleWrap;\n   V(preference_string, \"preference\")                                          \\\n   V(priority_string, \"priority\")                                              \\\n   V(produce_cached_data_string, \"produceCachedData\")                          \\\n+  V(promise_string, \"promise\")                                                \\\n   V(raw_string, \"raw\")                                                        \\\n   V(read_host_object_string, \"_readHostObject\")                               \\\n   V(readable_string, \"readable\")                                              \\\n@@ -241,6 +242,7 @@ class ModuleWrap;\n   V(sni_context_string, \"sni_context\")                                        \\\n   V(stack_string, \"stack\")                                                    \\\n   V(status_string, \"status\")                                                  \\\n+  V(statfields_string, \"statFields\")                                          \\\n   V(stdio_string, \"stdio\")                                                    \\\n   V(subject_string, \"subject\")                                                \\\n   V(subjectaltname_string, \"subjectaltname\")                                  \\"
        },
        {
            "sha": "b72f19d07d8e114ab6c9896879aa1fd7638f1ea8",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 82,
            "deletions": 26,
            "changes": 108,
            "blob_url": "https://github.com/nodejs/node/blob/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=7154bc097cc6bdcb686d3a0217a3af8a8371c0bf",
            "patch": "@@ -97,6 +97,7 @@ using v8::Local;\n using v8::MaybeLocal;\n using v8::Number;\n using v8::Object;\n+using v8::Promise;\n using v8::String;\n using v8::Undefined;\n using v8::Value;\n@@ -127,30 +128,75 @@ void FSReqWrap::Resolve(Local<Value> value) {\n   MakeCallback(env()->oncomplete_string(), arraysize(argv), argv);\n }\n \n-void FSReqWrap::Init(const char* syscall,\n-                     const char* data,\n-                     size_t len,\n-                     enum encoding encoding) {\n-  syscall_ = syscall;\n-  encoding_ = encoding;\n-\n-  if (data != nullptr) {\n-    CHECK_EQ(data_, nullptr);\n-    buffer_.AllocateSufficientStorage(len + 1);\n-    buffer_.SetLengthAndZeroTerminate(len);\n-    memcpy(*buffer_, data, len);\n-    data_ = *buffer_;\n-  }\n-}\n-\n void NewFSReqWrap(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args.IsConstructCall());\n   Environment* env = Environment::GetCurrent(args.GetIsolate());\n   new FSReqWrap(env, args.This());\n }\n \n+FSReqPromise::FSReqPromise(Environment* env, Local<Object> req)\n+    : FSReqBase(env, req, AsyncWrap::PROVIDER_FSREQPROMISE) {\n+  auto resolver = Promise::Resolver::New(env->context()).ToLocalChecked();\n+  req->Set(env->context(), env->promise_string(),\n+           resolver.As<Promise>()).FromJust();\n+\n+  Local<ArrayBuffer> ab =\n+      ArrayBuffer::New(env->isolate(), statFields_,\n+                       sizeof(double) * 14,\n+                       v8::ArrayBufferCreationMode::kInternalized);\n+  object()->Set(env->context(),\n+                env->statfields_string(),\n+                Float64Array::New(ab, 0, 14)).FromJust();\n+}\n+\n+FSReqPromise::~FSReqPromise() {\n+  // Validate that the promise was explicitly resolved or rejected.\n+  CHECK(finished_);\n+}\n+\n+void FSReqPromise::Reject(Local<Value> reject) {\n+  finished_ = true;\n+  InternalCallbackScope callback_scope(this);\n+  HandleScope scope(env()->isolate());\n+  Local<Value> value =\n+      object()->Get(env()->context(),\n+                    env()->promise_string()).ToLocalChecked();\n+  CHECK(value->IsPromise());\n+  Local<Promise> promise = value.As<Promise>();\n+  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n+  resolver->Reject(env()->context(), reject);\n+}\n+\n+void FSReqPromise::FillStatsArray(const uv_stat_t* stat) {\n+  node::FillStatsArray(statFields_, stat);\n+}\n \n-FSReqAfterScope::FSReqAfterScope(FSReqWrap* wrap, uv_fs_t* req)\n+void FSReqPromise::ResolveStat() {\n+  Resolve(\n+      object()->Get(env()->context(),\n+                    env()->statfields_string()).ToLocalChecked());\n+}\n+\n+void FSReqPromise::Resolve(Local<Value> value) {\n+  finished_ = true;\n+  InternalCallbackScope callback_scope(this);\n+  HandleScope scope(env()->isolate());\n+  Local<Value> val =\n+      object()->Get(env()->context(),\n+                    env()->promise_string()).ToLocalChecked();\n+  CHECK(val->IsPromise());\n+  Local<Promise> promise = val.As<Promise>();\n+  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n+  resolver->Resolve(env()->context(), value);\n+}\n+\n+void NewFSReqPromise(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args.IsConstructCall());\n+  Environment* env = Environment::GetCurrent(args.GetIsolate());\n+  new FSReqPromise(env, args.This());\n+}\n+\n+FSReqAfterScope::FSReqAfterScope(FSReqBase* wrap, uv_fs_t* req)\n     : wrap_(wrap),\n       req_(req),\n       handle_scope_(wrap->env()->isolate()),\n@@ -190,15 +236,15 @@ bool FSReqAfterScope::Proceed() {\n }\n \n void AfterNoArgs(uv_fs_t* req) {\n-  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n \n   if (after.Proceed())\n     req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));\n }\n \n void AfterStat(uv_fs_t* req) {\n-  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n \n   if (after.Proceed()) {\n@@ -208,15 +254,15 @@ void AfterStat(uv_fs_t* req) {\n }\n \n void AfterInteger(uv_fs_t* req) {\n-  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n \n   if (after.Proceed())\n     req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), req->result));\n }\n \n void AfterStringPath(uv_fs_t* req) {\n-  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n \n   MaybeLocal<Value> link;\n@@ -235,7 +281,7 @@ void AfterStringPath(uv_fs_t* req) {\n }\n \n void AfterStringPtr(uv_fs_t* req) {\n-  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n \n   MaybeLocal<Value> link;\n@@ -254,7 +300,7 @@ void AfterStringPtr(uv_fs_t* req) {\n }\n \n void AfterScanDir(uv_fs_t* req) {\n-  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n \n   if (after.Proceed()) {\n@@ -318,12 +364,12 @@ class fs_req_wrap {\n };\n \n template <typename Func, typename... Args>\n-inline FSReqWrap* AsyncDestCall(Environment* env,\n+inline FSReqBase* AsyncDestCall(Environment* env,\n     const FunctionCallbackInfo<Value>& args,\n     const char* syscall, const char* dest, size_t len,\n     enum encoding enc, uv_fs_cb after, Func fn, Args... fn_args) {\n   Local<Object> req = args[args.Length() - 1].As<Object>();\n-  FSReqWrap* req_wrap = Unwrap<FSReqWrap>(req);\n+  FSReqBase* req_wrap = Unwrap<FSReqBase>(req);\n   CHECK_NE(req_wrap, nullptr);\n   req_wrap->Init(syscall, dest, len, enc);\n   int err = fn(env->event_loop(), req_wrap->req(), fn_args..., after);\n@@ -343,7 +389,7 @@ inline FSReqWrap* AsyncDestCall(Environment* env,\n }\n \n template <typename Func, typename... Args>\n-inline FSReqWrap* AsyncCall(Environment* env,\n+inline FSReqBase* AsyncCall(Environment* env,\n     const FunctionCallbackInfo<Value>& args,\n     const char* syscall, enum encoding enc,\n     uv_fs_cb after, Func fn, Args... fn_args) {\n@@ -1396,6 +1442,16 @@ void InitFs(Local<Object> target,\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"FSReqWrap\");\n   fst->SetClassName(wrapString);\n   target->Set(context, wrapString, fst->GetFunction()).FromJust();\n+\n+  // Create Function Template for FSReqPromise\n+  Local<FunctionTemplate> fpt =\n+      FunctionTemplate::New(env->isolate(), NewFSReqPromise);\n+  fpt->InstanceTemplate()->SetInternalFieldCount(1);\n+  AsyncWrap::AddWrapMethods(env, fpt);\n+  Local<String> promiseString =\n+      FIXED_ONE_BYTE_STRING(env->isolate(), \"FSReqPromise\");\n+  fpt->SetClassName(promiseString);\n+  target->Set(context, promiseString, fpt->GetFunction()).FromJust();\n }\n \n }  // namespace fs"
        },
        {
            "sha": "7e2046130943cebb78f1cfa54f15c6174b6b373d",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 53,
            "deletions": 11,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/7154bc097cc6bdcb686d3a0217a3af8a8371c0bf/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=7154bc097cc6bdcb686d3a0217a3af8a8371c0bf",
            "patch": "@@ -17,26 +17,37 @@ using v8::Value;\n \n namespace fs {\n \n-class FSReqWrap : public ReqWrap<uv_fs_t> {\n+class FSReqBase : public ReqWrap<uv_fs_t> {\n  public:\n-  FSReqWrap(Environment* env, Local<Object> req)\n-      : ReqWrap(env, req, AsyncWrap::PROVIDER_FSREQWRAP) {\n+  FSReqBase(Environment* env, Local<Object> req, AsyncWrap::ProviderType type)\n+      : ReqWrap(env, req, type) {\n     Wrap(object(), this);\n   }\n \n-  virtual ~FSReqWrap() {\n+  virtual ~FSReqBase() {\n     ClearWrap(object());\n   }\n \n   void Init(const char* syscall,\n             const char* data = nullptr,\n             size_t len = 0,\n-            enum encoding encoding = UTF8);\n+            enum encoding encoding = UTF8) {\n+    syscall_ = syscall;\n+    encoding_ = encoding;\n+\n+    if (data != nullptr) {\n+      CHECK_EQ(data_, nullptr);\n+      buffer_.AllocateSufficientStorage(len + 1);\n+      buffer_.SetLengthAndZeroTerminate(len);\n+      memcpy(*buffer_, data, len);\n+      data_ = *buffer_;\n+    }\n+  }\n \n-  virtual void FillStatsArray(const uv_stat_t* stat);\n-  virtual void Reject(Local<Value> reject);\n-  virtual void Resolve(Local<Value> value);\n-  virtual void ResolveStat();\n+  virtual void FillStatsArray(const uv_stat_t* stat) = 0;\n+  virtual void Reject(Local<Value> reject) = 0;\n+  virtual void Resolve(Local<Value> value) = 0;\n+  virtual void ResolveStat() = 0;\n \n   const char* syscall() const { return syscall_; }\n   const char* data() const { return data_; }\n@@ -51,20 +62,51 @@ class FSReqWrap : public ReqWrap<uv_fs_t> {\n   const char* data_ = nullptr;\n   MaybeStackBuffer<char> buffer_;\n \n+  DISALLOW_COPY_AND_ASSIGN(FSReqBase);\n+};\n+\n+class FSReqWrap : public FSReqBase {\n+ public:\n+  FSReqWrap(Environment* env, Local<Object> req)\n+      : FSReqBase(env, req, AsyncWrap::PROVIDER_FSREQWRAP) { }\n+\n+  void FillStatsArray(const uv_stat_t* stat) override;\n+  void Reject(Local<Value> reject) override;\n+  void Resolve(Local<Value> value) override;\n+  void ResolveStat() override;\n+\n+ private:\n   DISALLOW_COPY_AND_ASSIGN(FSReqWrap);\n };\n \n+class FSReqPromise : public FSReqBase {\n+ public:\n+  FSReqPromise(Environment* env, Local<Object> req);\n+\n+  ~FSReqPromise() override;\n+\n+  void FillStatsArray(const uv_stat_t* stat) override;\n+  void Reject(Local<Value> reject) override;\n+  void Resolve(Local<Value> value) override;\n+  void ResolveStat() override;\n+\n+ private:\n+  bool finished_ = false;\n+  double statFields_[14] {};\n+  DISALLOW_COPY_AND_ASSIGN(FSReqPromise);\n+};\n+\n class FSReqAfterScope {\n  public:\n-  FSReqAfterScope(FSReqWrap* wrap, uv_fs_t* req);\n+  FSReqAfterScope(FSReqBase* wrap, uv_fs_t* req);\n   ~FSReqAfterScope();\n \n   bool Proceed();\n \n   void Reject(uv_fs_t* req);\n \n  private:\n-  FSReqWrap* wrap_ = nullptr;\n+  FSReqBase* wrap_ = nullptr;\n   uv_fs_t* req_ = nullptr;\n   HandleScope handle_scope_;\n   Context::Scope context_scope_;"
        }
    ],
    "stats": {
        "total": 175,
        "additions": 138,
        "deletions": 37
    }
}