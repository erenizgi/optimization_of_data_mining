{
    "author": "iansu",
    "message": "test: add blocks and comments to fs-promises tests\n\nPR-URL: https://github.com/nodejs/node/pull/23627\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\nReviewed-By: Ben Coe <bencoe@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "3b7f9bc761091785fb74109487c2be01dbc37857",
    "files": [
        {
            "sha": "6b8fe3bb250899dc26ab642077c8a0e88fe3f947",
            "filename": "test/parallel/test-fs-promises.js",
            "status": "modified",
            "additions": 159,
            "deletions": 125,
            "changes": 284,
            "blob_url": "https://github.com/nodejs/node/blob/3b7f9bc761091785fb74109487c2be01dbc37857/test%2Fparallel%2Ftest-fs-promises.js",
            "raw_url": "https://github.com/nodejs/node/raw/3b7f9bc761091785fb74109487c2be01dbc37857/test%2Fparallel%2Ftest-fs-promises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises.js?ref=3b7f9bc761091785fb74109487c2be01dbc37857",
            "patch": "@@ -74,31 +74,37 @@ async function getHandle(dest) {\n {\n   async function doTest() {\n     tmpdir.refresh();\n+\n     const dest = path.resolve(tmpDir, 'baz.js');\n-    await copyFile(fixtures.path('baz.js'), dest);\n-    await access(dest, 'r');\n \n-    const handle = await open(dest, 'r+');\n-    assert.strictEqual(typeof handle, 'object');\n+    // handle is object\n+    {\n+      const handle = await getHandle(dest);\n+      assert.strictEqual(typeof handle, 'object');\n+    }\n \n-    let stats = await handle.stat();\n-    verifyStatObject(stats);\n-    assert.strictEqual(stats.size, 35);\n+    // file stats\n+    {\n+      const handle = await getHandle(dest);\n+      let stats = await handle.stat();\n+      verifyStatObject(stats);\n+      assert.strictEqual(stats.size, 35);\n \n-    await handle.truncate(1);\n+      await handle.truncate(1);\n \n-    stats = await handle.stat();\n-    verifyStatObject(stats);\n-    assert.strictEqual(stats.size, 1);\n+      stats = await handle.stat();\n+      verifyStatObject(stats);\n+      assert.strictEqual(stats.size, 1);\n \n-    stats = await stat(dest);\n-    verifyStatObject(stats);\n+      stats = await stat(dest);\n+      verifyStatObject(stats);\n \n-    stats = await handle.stat();\n-    verifyStatObject(stats);\n+      stats = await handle.stat();\n+      verifyStatObject(stats);\n \n-    await handle.datasync();\n-    await handle.sync();\n+      await handle.datasync();\n+      await handle.sync();\n+    }\n \n     // test fs.read promises when length to read is zero bytes\n     {\n@@ -113,115 +119,140 @@ async function getHandle(dest) {\n       await unlink(dest);\n     }\n \n-    const buf = Buffer.from('hello fsPromises');\n-    const bufLen = buf.length;\n-    await handle.write(buf);\n-    const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);\n-    assert.strictEqual(ret.bytesRead, bufLen);\n-    assert.deepStrictEqual(ret.buffer, buf);\n-\n-    const buf2 = Buffer.from('hello FileHandle');\n-    const buf2Len = buf2.length;\n-    await handle.write(buf2, 0, buf2Len, 0);\n-    const ret2 = await handle.read(Buffer.alloc(buf2Len), 0, buf2Len, 0);\n-    assert.strictEqual(ret2.bytesRead, buf2Len);\n-    assert.deepStrictEqual(ret2.buffer, buf2);\n-    await truncate(dest, 5);\n-    assert.deepStrictEqual((await readFile(dest)).toString(), 'hello');\n-\n-    await chmod(dest, 0o666);\n-    await handle.chmod(0o666);\n-\n-    await chmod(dest, (0o10777));\n-    await handle.chmod(0o10777);\n-\n-    if (!common.isWindows) {\n-      await chown(dest, process.getuid(), process.getgid());\n-      await handle.chown(process.getuid(), process.getgid());\n+    // bytes written to file match buffer\n+    {\n+      const handle = await getHandle(dest);\n+      const buf = Buffer.from('hello fsPromises');\n+      const bufLen = buf.length;\n+      await handle.write(buf);\n+      const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);\n+      assert.strictEqual(ret.bytesRead, bufLen);\n+      assert.deepStrictEqual(ret.buffer, buf);\n     }\n \n-    assert.rejects(\n-      async () => {\n-        await chown(dest, 1, -1);\n-      },\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        name: 'RangeError [ERR_OUT_OF_RANGE]',\n-        message: 'The value of \"gid\" is out of range. ' +\n-                 'It must be >= 0 && < 4294967296. Received -1'\n-      });\n+    // truncate file to specified length\n+    {\n+      const handle = await getHandle(dest);\n+      const buf = Buffer.from('hello FileHandle');\n+      const bufLen = buf.length;\n+      await handle.write(buf, 0, bufLen, 0);\n+      const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);\n+      assert.strictEqual(ret.bytesRead, bufLen);\n+      assert.deepStrictEqual(ret.buffer, buf);\n+      await truncate(dest, 5);\n+      assert.deepStrictEqual((await readFile(dest)).toString(), 'hello');\n+    }\n \n-    assert.rejects(\n-      async () => {\n-        await handle.chown(1, -1);\n-      },\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        name: 'RangeError [ERR_OUT_OF_RANGE]',\n-        message: 'The value of \"gid\" is out of range. ' +\n-                  'It must be >= 0 && < 4294967296. Received -1'\n-      });\n+    // invalid change of ownership\n+    {\n+      const handle = await getHandle(dest);\n \n-    await utimes(dest, new Date(), new Date());\n-\n-    try {\n-      await handle.utimes(new Date(), new Date());\n-    } catch (err) {\n-      // Some systems do not have futimes. If there is an error,\n-      // expect it to be ENOSYS\n-      common.expectsError({\n-        code: 'ENOSYS',\n-        type: Error\n-      })(err);\n+      await chmod(dest, 0o666);\n+      await handle.chmod(0o666);\n+\n+      await chmod(dest, (0o10777));\n+      await handle.chmod(0o10777);\n+\n+      if (!common.isWindows) {\n+        await chown(dest, process.getuid(), process.getgid());\n+        await handle.chown(process.getuid(), process.getgid());\n+      }\n+\n+      assert.rejects(\n+        async () => {\n+          await chown(dest, 1, -1);\n+        },\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"gid\" is out of range. ' +\n+                  'It must be >= 0 && < 4294967296. Received -1'\n+        });\n+\n+      assert.rejects(\n+        async () => {\n+          await handle.chown(1, -1);\n+        },\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"gid\" is out of range. ' +\n+                    'It must be >= 0 && < 4294967296. Received -1'\n+        });\n     }\n \n-    await handle.close();\n+    // set modification times\n+    {\n+      const handle = await getHandle(dest);\n \n-    const newPath = path.resolve(tmpDir, 'baz2.js');\n-    await rename(dest, newPath);\n-    stats = await stat(newPath);\n-    verifyStatObject(stats);\n+      await utimes(dest, new Date(), new Date());\n \n-    if (common.canCreateSymLink()) {\n-      const newLink = path.resolve(tmpDir, 'baz3.js');\n-      await symlink(newPath, newLink);\n-      if (!common.isWindows) {\n-        await lchown(newLink, process.getuid(), process.getgid());\n+      try {\n+        await handle.utimes(new Date(), new Date());\n+      } catch (err) {\n+        // Some systems do not have futimes. If there is an error,\n+        // expect it to be ENOSYS\n+        common.expectsError({\n+          code: 'ENOSYS',\n+          type: Error\n+        })(err);\n       }\n-      stats = await lstat(newLink);\n-      verifyStatObject(stats);\n \n-      assert.strictEqual(newPath.toLowerCase(),\n-                         (await realpath(newLink)).toLowerCase());\n-      assert.strictEqual(newPath.toLowerCase(),\n-                         (await readlink(newLink)).toLowerCase());\n+      await handle.close();\n+    }\n+\n+    // create symlink\n+    {\n+      const newPath = path.resolve(tmpDir, 'baz2.js');\n+      await rename(dest, newPath);\n+      let stats = await stat(newPath);\n+      verifyStatObject(stats);\n \n-      const newMode = 0o666;\n-      if (common.isOSX) {\n-        // lchmod is only available on macOS\n-        await lchmod(newLink, newMode);\n+      if (common.canCreateSymLink()) {\n+        const newLink = path.resolve(tmpDir, 'baz3.js');\n+        await symlink(newPath, newLink);\n+        if (!common.isWindows) {\n+          await lchown(newLink, process.getuid(), process.getgid());\n+        }\n         stats = await lstat(newLink);\n-        assert.strictEqual(stats.mode & 0o777, newMode);\n-      } else {\n-        await Promise.all([\n-          assert.rejects(\n-            lchmod(newLink, newMode),\n-            common.expectsError({\n-              code: 'ERR_METHOD_NOT_IMPLEMENTED',\n-              type: Error,\n-              message: 'The lchmod() method is not implemented'\n-            })\n-          )\n-        ]);\n+        verifyStatObject(stats);\n+\n+        assert.strictEqual(newPath.toLowerCase(),\n+                           (await realpath(newLink)).toLowerCase());\n+        assert.strictEqual(newPath.toLowerCase(),\n+                           (await readlink(newLink)).toLowerCase());\n+\n+        const newMode = 0o666;\n+        if (common.isOSX) {\n+          // lchmod is only available on macOS\n+          await lchmod(newLink, newMode);\n+          stats = await lstat(newLink);\n+          assert.strictEqual(stats.mode & 0o777, newMode);\n+        } else {\n+          await Promise.all([\n+            assert.rejects(\n+              lchmod(newLink, newMode),\n+              common.expectsError({\n+                code: 'ERR_METHOD_NOT_IMPLEMENTED',\n+                type: Error,\n+                message: 'The lchmod() method is not implemented'\n+              })\n+            )\n+          ]);\n+        }\n+\n+        await unlink(newLink);\n       }\n-\n-      await unlink(newLink);\n     }\n \n-    const newLink2 = path.resolve(tmpDir, 'baz4.js');\n-    await link(newPath, newLink2);\n+    // create hard link\n+    {\n+      const newPath = path.resolve(tmpDir, 'baz2.js');\n+      const newLink = path.resolve(tmpDir, 'baz4.js');\n+      await link(newPath, newLink);\n \n-    await unlink(newLink2);\n+      await unlink(newLink);\n+    }\n \n     // testing readdir lists both files and directories\n     {\n@@ -231,7 +262,7 @@ async function getHandle(dest) {\n       await mkdir(newDir);\n       await writeFile(newFile, 'DAWGS WIN!', 'utf8');\n \n-      stats = await stat(newDir);\n+      const stats = await stat(newDir);\n       assert(stats.isDirectory());\n       const list = await readdir(tmpDir);\n       assert.notStrictEqual(list.indexOf('dir'), -1);\n@@ -244,23 +275,23 @@ async function getHandle(dest) {\n     {\n       const dir = path.join(tmpDir, nextdir());\n       await mkdir(dir, 777);\n-      stats = await stat(dir);\n+      const stats = await stat(dir);\n       assert(stats.isDirectory());\n     }\n \n     // mkdir when options is string.\n     {\n       const dir = path.join(tmpDir, nextdir());\n       await mkdir(dir, '777');\n-      stats = await stat(dir);\n+      const stats = await stat(dir);\n       assert(stats.isDirectory());\n     }\n \n     // mkdirp when folder does not yet exist.\n     {\n       const dir = path.join(tmpDir, nextdir(), nextdir());\n       await mkdir(dir, { recursive: true });\n-      stats = await stat(dir);\n+      const stats = await stat(dir);\n       assert(stats.isDirectory());\n     }\n \n@@ -283,15 +314,15 @@ async function getHandle(dest) {\n     {\n       const dir = path.resolve(tmpDir, `${nextdir()}/./${nextdir()}`);\n       await mkdir(dir, { recursive: true });\n-      stats = await stat(dir);\n+      const stats = await stat(dir);\n       assert(stats.isDirectory());\n     }\n \n     // mkdirp ../\n     {\n       const dir = path.resolve(tmpDir, `${nextdir()}/../${nextdir()}`);\n       await mkdir(dir, { recursive: true });\n-      stats = await stat(dir);\n+      const stats = await stat(dir);\n       assert(stats.isDirectory());\n     }\n \n@@ -313,15 +344,18 @@ async function getHandle(dest) {\n       });\n     }\n \n-    await mkdtemp(path.resolve(tmpDir, 'FOO'));\n-    assert.rejects(\n-      // mkdtemp() expects to get a string prefix.\n-      async () => mkdtemp(1),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n-      }\n-    );\n+    // mkdtemp with invalid numeric prefix\n+    {\n+      await mkdtemp(path.resolve(tmpDir, 'FOO'));\n+      assert.rejects(\n+        // mkdtemp() expects to get a string prefix.\n+        async () => mkdtemp(1),\n+        {\n+          code: 'ERR_INVALID_ARG_TYPE',\n+          name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+        }\n+      );\n+    }\n \n   }\n "
        }
    ],
    "stats": {
        "total": 284,
        "additions": 159,
        "deletions": 125
    }
}