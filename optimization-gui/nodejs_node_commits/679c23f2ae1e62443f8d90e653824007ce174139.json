{
    "author": "cjihrig",
    "message": "report: use uv_getnameinfo() for socket endpoints\n\nPR-URL: https://github.com/nodejs/node/pull/25962\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "679c23f2ae1e62443f8d90e653824007ce174139",
    "files": [
        {
            "sha": "34fa1b7405a7190aa8c56bbf9675bc16e3a876d3",
            "filename": "src/node_report_utils.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 24,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/679c23f2ae1e62443f8d90e653824007ce174139/src%2Fnode_report_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/679c23f2ae1e62443f8d90e653824007ce174139/src%2Fnode_report_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report_utils.cc?ref=679c23f2ae1e62443f8d90e653824007ce174139",
            "patch": "@@ -9,8 +9,6 @@ using node::MallocedBuffer;\n void ReportEndpoints(uv_handle_t* h, std::ostringstream& out) {\n   struct sockaddr_storage addr_storage;\n   struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);\n-  char hostbuf[NI_MAXHOST];\n-  char portbuf[NI_MAXSERV];\n   uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n   int addr_size = sizeof(addr_storage);\n   int rc = -1;\n@@ -26,33 +24,22 @@ void ReportEndpoints(uv_handle_t* h, std::ostringstream& out) {\n       break;\n   }\n   if (rc == 0) {\n-    // getnameinfo will format host and port and handle IPv4/IPv6.\n-    rc = getnameinfo(addr,\n-                     addr_size,\n-                     hostbuf,\n-                     sizeof(hostbuf),\n-                     portbuf,\n-                     sizeof(portbuf),\n-                     NI_NUMERICSERV);\n-    if (rc == 0) {\n-      out << std::string(hostbuf) << \":\" << std::string(portbuf);\n-    }\n+    // uv_getnameinfo will format host and port and handle IPv4/IPv6.\n+    uv_getnameinfo_t local;\n+    rc = uv_getnameinfo(h->loop, &local, nullptr, addr, NI_NUMERICSERV);\n+\n+    if (rc == 0)\n+      out << local.host << \":\" << local.service;\n \n     if (h->type == UV_TCP) {\n       // Get the remote end of the connection.\n       rc = uv_tcp_getpeername(&(handle->tcp), addr, &addr_size);\n       if (rc == 0) {\n-        rc = getnameinfo(addr,\n-                         addr_size,\n-                         hostbuf,\n-                         sizeof(hostbuf),\n-                         portbuf,\n-                         sizeof(portbuf),\n-                         NI_NUMERICSERV);\n-        if (rc == 0) {\n-          out << \" connected to \";\n-          out << std::string(hostbuf) << \":\" << std::string(portbuf);\n-        }\n+        uv_getnameinfo_t remote;\n+        rc = uv_getnameinfo(h->loop, &remote, nullptr, addr, NI_NUMERICSERV);\n+\n+        if (rc == 0)\n+          out << \" connected to \" << remote.host << \":\" << remote.service;\n       } else if (rc == UV_ENOTCONN) {\n         out << \" (not connected)\";\n       }"
        }
    ],
    "stats": {
        "total": 35,
        "additions": 11,
        "deletions": 24
    }
}