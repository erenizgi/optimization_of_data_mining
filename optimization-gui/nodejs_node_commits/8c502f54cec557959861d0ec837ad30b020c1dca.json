{
    "author": "tniessen",
    "message": "crypto: add API for key pair generation\n\nThis adds support for RSA, DSA and EC key pair generation with a\nvariety of possible output formats etc.\n\nPR-URL: https://github.com/nodejs/node/pull/22660\nFixes: https://github.com/nodejs/node/issues/15116\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "8c502f54cec557959861d0ec837ad30b020c1dca",
    "files": [
        {
            "sha": "0af7bea90edece3580c30578c2a659c590b70873",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -1673,6 +1673,116 @@ Use [`crypto.getHashes()`][] to obtain an array of names of the available\n signing algorithms. Optional `options` argument controls the\n `stream.Writable` behavior.\n \n+### crypto.generateKeyPair(type, options, callback)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `type`: {string} Must be `'rsa'`, `'dsa'` or `'ec'`.\n+* `options`: {Object}\n+  - `modulusLength`: {number} Key size in bits (RSA, DSA).\n+  - `publicExponent`: {number} Public exponent (RSA). **Default:** `0x10001`.\n+  - `divisorLength`: {number} Size of `q` in bits (DSA).\n+  - `namedCurve`: {string} Name of the curve to use (EC).\n+  - `publicKeyEncoding`: {Object}\n+    - `type`: {string} Must be one of `'pkcs1'` (RSA only) or `'spki'`.\n+    - `format`: {string} Must be `'pem'` or `'der'`.\n+  - `privateKeyEncoding`: {Object}\n+    - `type`: {string} Must be one of `'pkcs1'` (RSA only), `'pkcs8'` or\n+      `'sec1'` (EC only).\n+    - `format`: {string} Must be `'pem'` or `'der'`.\n+    - `cipher`: {string} If specified, the private key will be encrypted with\n+      the given `cipher` and `passphrase` using PKCS#5 v2.0 password based\n+      encryption.\n+    - `passphrase`: {string} The passphrase to use for encryption, see `cipher`.\n+* `callback`: {Function}\n+  - `err`: {Error}\n+  - `publicKey`: {string|Buffer}\n+  - `privateKey`: {string|Buffer}\n+\n+Generates a new asymmetric key pair of the given `type`. Only RSA, DSA and EC\n+are currently supported.\n+\n+It is recommended to encode public keys as `'spki'` and private keys as\n+`'pkcs8'` with encryption:\n+\n+```js\n+const { generateKeyPair } = require('crypto');\n+generateKeyPair('rsa', {\n+  modulusLength: 4096,\n+  publicKeyEncoding: {\n+    type: 'spki',\n+    format: 'pem'\n+  },\n+  privateKeyEncoding: {\n+    type: 'pkcs8',\n+    format: 'pem',\n+    cipher: 'aes-256-cbc',\n+    passphrase: 'top secret'\n+  }\n+}, (err, publicKey, privateKey) => {\n+  // Handle errors and use the generated key pair.\n+});\n+```\n+\n+On completion, `callback` will be called with `err` set to `undefined` and\n+`publicKey` / `privateKey` representing the generated key pair. When PEM\n+encoding was selected, the result will be a string, otherwise it will be a\n+buffer containing the data encoded as DER. Note that Node.js itself does not\n+accept DER, it is supported for interoperability with other libraries such as\n+WebCrypto only.\n+\n+### crypto.generateKeyPairSync(type, options)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `type`: {string} Must be `'rsa'`, `'dsa'` or `'ec'`.\n+* `options`: {Object}\n+  - `modulusLength`: {number} Key size in bits (RSA, DSA).\n+  - `publicExponent`: {number} Public exponent (RSA). **Default:** `0x10001`.\n+  - `divisorLength`: {number} Size of `q` in bits (DSA).\n+  - `namedCurve`: {string} Name of the curve to use (EC).\n+  - `publicKeyEncoding`: {Object}\n+    - `type`: {string} Must be one of `'pkcs1'` (RSA only) or `'spki'`.\n+    - `format`: {string} Must be `'pem'` or `'der'`.\n+  - `privateKeyEncoding`: {Object}\n+    - `type`: {string} Must be one of `'pkcs1'` (RSA only), `'pkcs8'` or\n+      `'sec1'` (EC only).\n+    - `format`: {string} Must be `'pem'` or `'der'`.\n+    - `cipher`: {string} If specified, the private key will be encrypted with\n+      the given `cipher` and `passphrase` using PKCS#5 v2.0 password based\n+      encryption.\n+    - `passphrase`: {string} The passphrase to use for encryption, see `cipher`.\n+* Returns: {Object}\n+  - `publicKey`: {string|Buffer}\n+  - `privateKey`: {string|Buffer}\n+\n+Generates a new asymmetric key pair of the given `type`. Only RSA, DSA and EC\n+are currently supported.\n+\n+It is recommended to encode public keys as `'spki'` and private keys as\n+`'pkcs8'` with encryption:\n+\n+```js\n+const { generateKeyPairSync } = require('crypto');\n+const { publicKey, privateKey } = generateKeyPairSync('rsa', {\n+  modulusLength: 4096,\n+  publicKeyEncoding: {\n+    type: 'spki',\n+    format: 'pem'\n+  },\n+  privateKeyEncoding: {\n+    type: 'pkcs8',\n+    format: 'pem',\n+    cipher: 'aes-256-cbc',\n+    passphrase: 'top secret'\n+  }\n+});\n+```\n+\n+The return value `{ publicKey, privateKey }` represents the generated key pair.\n+When PEM encoding was selected, the respective key will be a string, otherwise\n+it will be a buffer containing the data encoded as DER.\n+\n ### crypto.getCiphers()\n <!-- YAML\n added: v0.9.3"
        },
        {
            "sha": "33f655c067b950c42ba705126518ca4173820c46",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -729,6 +729,11 @@ be called no more than one time per instance of a `Hash` object.\n \n [`hash.update()`][] failed for any reason. This should rarely, if ever, happen.\n \n+<a id=\"ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS\"></a>\n+### ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS\n+\n+The selected public or private key encoding is incompatible with other options.\n+\n <a id=\"ERR_CRYPTO_INVALID_DIGEST\"></a>\n ### ERR_CRYPTO_INVALID_DIGEST\n "
        },
        {
            "sha": "12f5bd4bd94539b9e930b294b8f6d7be55ec80a7",
            "filename": "lib/crypto.js",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/lib%2Fcrypto.js",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/lib%2Fcrypto.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fcrypto.js?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -54,6 +54,10 @@ const {\n   scrypt,\n   scryptSync\n } = require('internal/crypto/scrypt');\n+const {\n+  generateKeyPair,\n+  generateKeyPairSync\n+} = require('internal/crypto/keygen');\n const {\n   DiffieHellman,\n   DiffieHellmanGroup,\n@@ -152,6 +156,8 @@ module.exports = exports = {\n   getHashes,\n   pbkdf2,\n   pbkdf2Sync,\n+  generateKeyPair,\n+  generateKeyPairSync,\n   privateDecrypt,\n   privateEncrypt,\n   publicDecrypt,"
        },
        {
            "sha": "017c54838f932c30196924af81fb0846969dc80b",
            "filename": "lib/internal/crypto/keygen.js",
            "status": "added",
            "additions": 238,
            "deletions": 0,
            "changes": 238,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/lib%2Finternal%2Fcrypto%2Fkeygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/lib%2Finternal%2Fcrypto%2Fkeygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fkeygen.js?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -0,0 +1,238 @@\n+'use strict';\n+\n+const { internalBinding } = require('internal/bootstrap/loaders');\n+const { AsyncWrap, Providers } = internalBinding('async_wrap');\n+const {\n+  generateKeyPairRSA,\n+  generateKeyPairDSA,\n+  generateKeyPairEC,\n+  OPENSSL_EC_NAMED_CURVE,\n+  OPENSSL_EC_EXPLICIT_CURVE,\n+  PK_ENCODING_PKCS1,\n+  PK_ENCODING_PKCS8,\n+  PK_ENCODING_SPKI,\n+  PK_ENCODING_SEC1,\n+  PK_FORMAT_DER,\n+  PK_FORMAT_PEM\n+} = internalBinding('crypto');\n+const { isUint32 } = require('internal/validators');\n+const {\n+  ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_INVALID_CALLBACK,\n+  ERR_INVALID_OPT_VALUE\n+} = require('internal/errors').codes;\n+\n+function generateKeyPair(type, options, callback) {\n+  if (typeof options === 'function') {\n+    callback = options;\n+    options = undefined;\n+  }\n+\n+  const impl = check(type, options);\n+\n+  if (typeof callback !== 'function')\n+    throw new ERR_INVALID_CALLBACK();\n+\n+  const wrap = new AsyncWrap(Providers.KEYPAIRGENREQUEST);\n+  wrap.ondone = (ex, pubkey, privkey) => {\n+    if (ex) return callback.call(wrap, ex);\n+    callback.call(wrap, null, pubkey, privkey);\n+  };\n+\n+  handleError(impl, wrap);\n+}\n+\n+function generateKeyPairSync(type, options) {\n+  const impl = check(type, options);\n+  return handleError(impl);\n+}\n+\n+function handleError(impl, wrap) {\n+  const ret = impl(wrap);\n+  if (ret === undefined)\n+    return; // async\n+\n+  const [err, publicKey, privateKey] = ret;\n+  if (err !== undefined)\n+    throw err;\n+\n+  return { publicKey, privateKey };\n+}\n+\n+function parseKeyEncoding(keyType, options) {\n+  const { publicKeyEncoding, privateKeyEncoding } = options;\n+\n+  if (publicKeyEncoding == null || typeof publicKeyEncoding !== 'object')\n+    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding', publicKeyEncoding);\n+\n+  const { format: strPublicFormat, type: strPublicType } = publicKeyEncoding;\n+\n+  let publicType;\n+  if (strPublicType === 'pkcs1') {\n+    if (keyType !== 'rsa') {\n+      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+        strPublicType, 'can only be used for RSA keys');\n+    }\n+    publicType = PK_ENCODING_PKCS1;\n+  } else if (strPublicType === 'spki') {\n+    publicType = PK_ENCODING_SPKI;\n+  } else {\n+    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding.type', strPublicType);\n+  }\n+\n+  let publicFormat;\n+  if (strPublicFormat === 'der') {\n+    publicFormat = PK_FORMAT_DER;\n+  } else if (strPublicFormat === 'pem') {\n+    publicFormat = PK_FORMAT_PEM;\n+  } else {\n+    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding.format',\n+                                    strPublicFormat);\n+  }\n+\n+  if (privateKeyEncoding == null || typeof privateKeyEncoding !== 'object')\n+    throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding', privateKeyEncoding);\n+\n+  const {\n+    cipher,\n+    passphrase,\n+    format: strPrivateFormat,\n+    type: strPrivateType\n+  } = privateKeyEncoding;\n+\n+  let privateType;\n+  if (strPrivateType === 'pkcs1') {\n+    if (keyType !== 'rsa') {\n+      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+        strPrivateType, 'can only be used for RSA keys');\n+    }\n+    privateType = PK_ENCODING_PKCS1;\n+  } else if (strPrivateType === 'pkcs8') {\n+    privateType = PK_ENCODING_PKCS8;\n+  } else if (strPrivateType === 'sec1') {\n+    if (keyType !== 'ec') {\n+      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+        strPrivateType, 'can only be used for EC keys');\n+    }\n+    privateType = PK_ENCODING_SEC1;\n+  } else {\n+    throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.type', strPrivateType);\n+  }\n+\n+  let privateFormat;\n+  if (strPrivateFormat === 'der') {\n+    privateFormat = PK_FORMAT_DER;\n+  } else if (strPrivateFormat === 'pem') {\n+    privateFormat = PK_FORMAT_PEM;\n+  } else {\n+    throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.format',\n+                                    strPrivateFormat);\n+  }\n+\n+  if (cipher != null) {\n+    if (typeof cipher !== 'string')\n+      throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.cipher', cipher);\n+    if (privateType !== PK_ENCODING_PKCS8) {\n+      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+        strPrivateType, 'does not support encryption');\n+    }\n+    if (typeof passphrase !== 'string') {\n+      throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.passphrase',\n+                                      passphrase);\n+    }\n+  }\n+\n+  return {\n+    cipher, passphrase, publicType, publicFormat, privateType, privateFormat\n+  };\n+}\n+\n+function check(type, options, callback) {\n+  if (typeof type !== 'string')\n+    throw new ERR_INVALID_ARG_TYPE('type', 'string', type);\n+  if (options == null || typeof options !== 'object')\n+    throw new ERR_INVALID_ARG_TYPE('options', 'object', options);\n+\n+  // These will be set after parsing the type and type-specific options to make\n+  // the order a bit more intuitive.\n+  let cipher, passphrase, publicType, publicFormat, privateType, privateFormat;\n+\n+  let impl;\n+  switch (type) {\n+    case 'rsa':\n+      {\n+        const { modulusLength } = options;\n+        if (!isUint32(modulusLength))\n+          throw new ERR_INVALID_OPT_VALUE('modulusLength', modulusLength);\n+\n+        let { publicExponent } = options;\n+        if (publicExponent == null) {\n+          publicExponent = 0x10001;\n+        } else if (!isUint32(publicExponent)) {\n+          throw new ERR_INVALID_OPT_VALUE('publicExponent', publicExponent);\n+        }\n+\n+        impl = (wrap) => generateKeyPairRSA(modulusLength, publicExponent,\n+                                            publicType, publicFormat,\n+                                            privateType, privateFormat,\n+                                            cipher, passphrase, wrap);\n+      }\n+      break;\n+    case 'dsa':\n+      {\n+        const { modulusLength } = options;\n+        if (!isUint32(modulusLength))\n+          throw new ERR_INVALID_OPT_VALUE('modulusLength', modulusLength);\n+\n+        let { divisorLength } = options;\n+        if (divisorLength == null) {\n+          divisorLength = -1;\n+        } else if (!isUint32(divisorLength)) {\n+          throw new ERR_INVALID_OPT_VALUE('divisorLength', divisorLength);\n+        }\n+\n+        impl = (wrap) => generateKeyPairDSA(modulusLength, divisorLength,\n+                                            publicType, publicFormat,\n+                                            privateType, privateFormat,\n+                                            cipher, passphrase, wrap);\n+      }\n+      break;\n+    case 'ec':\n+      {\n+        const { namedCurve } = options;\n+        if (typeof namedCurve !== 'string')\n+          throw new ERR_INVALID_OPT_VALUE('namedCurve', namedCurve);\n+        let { paramEncoding } = options;\n+        if (paramEncoding == null || paramEncoding === 'named')\n+          paramEncoding = OPENSSL_EC_NAMED_CURVE;\n+        else if (paramEncoding === 'explicit')\n+          paramEncoding = OPENSSL_EC_EXPLICIT_CURVE;\n+        else\n+          throw new ERR_INVALID_OPT_VALUE('paramEncoding', paramEncoding);\n+\n+        impl = (wrap) => generateKeyPairEC(namedCurve, paramEncoding,\n+                                           publicType, publicFormat,\n+                                           privateType, privateFormat,\n+                                           cipher, passphrase, wrap);\n+      }\n+      break;\n+    default:\n+      throw new ERR_INVALID_ARG_VALUE('type', type,\n+                                      \"must be one of 'rsa', 'dsa', 'ec'\");\n+  }\n+\n+  ({\n+    cipher,\n+    passphrase,\n+    publicType,\n+    publicFormat,\n+    privateType,\n+    privateFormat\n+  } = parseKeyEncoding(type, options));\n+\n+  return impl;\n+}\n+\n+module.exports = { generateKeyPair, generateKeyPairSync };"
        },
        {
            "sha": "f6aee89dca63b73c6c21a8d02d28d2ac0dcfec8c",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -509,6 +509,8 @@ E('ERR_CRYPTO_HASH_DIGEST_NO_UTF16', 'hash.digest() does not support UTF-16',\n   Error);\n E('ERR_CRYPTO_HASH_FINALIZED', 'Digest already called', Error);\n E('ERR_CRYPTO_HASH_UPDATE_FAILED', 'Hash update failed', Error);\n+E('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS', 'The selected key encoding %s %s.',\n+  Error);\n E('ERR_CRYPTO_INVALID_DIGEST', 'Invalid digest: %s', TypeError);\n E('ERR_CRYPTO_INVALID_STATE', 'Invalid state for operation %s', Error);\n E('ERR_CRYPTO_PBKDF2_ERROR', 'PBKDF2 error', Error);"
        },
        {
            "sha": "17fd8440881fb98b41996aebe7f3f4f623342f0a",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -97,6 +97,7 @@\n       'lib/internal/crypto/cipher.js',\n       'lib/internal/crypto/diffiehellman.js',\n       'lib/internal/crypto/hash.js',\n+      'lib/internal/crypto/keygen.js',\n       'lib/internal/crypto/pbkdf2.js',\n       'lib/internal/crypto/random.js',\n       'lib/internal/crypto/scrypt.js',"
        },
        {
            "sha": "b10676ce1d092ca694507915dd158e29e40b8acb",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -73,6 +73,7 @@ namespace node {\n #if HAVE_OPENSSL\n #define NODE_ASYNC_CRYPTO_PROVIDER_TYPES(V)                                   \\\n   V(PBKDF2REQUEST)                                                            \\\n+  V(KEYPAIRGENREQUEST)                                                        \\\n   V(RANDOMBYTESREQUEST)                                                       \\\n   V(SCRYPTREQUEST)                                                            \\\n   V(TLSWRAP)"
        },
        {
            "sha": "47e0ba5349e66d84b05f6b26031459771837d84b",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 459,
            "deletions": 0,
            "changes": 459,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -88,6 +88,7 @@ using v8::SideEffectType;\n using v8::Signature;\n using v8::String;\n using v8::Uint32;\n+using v8::Undefined;\n using v8::Value;\n \n \n@@ -4832,6 +4833,453 @@ void Scrypt(const FunctionCallbackInfo<Value>& args) {\n #endif  // OPENSSL_NO_SCRYPT\n \n \n+class KeyPairGenerationConfig {\n+ public:\n+  virtual EVPKeyCtxPointer Setup() = 0;\n+  virtual bool Configure(const EVPKeyCtxPointer& ctx) {\n+    return true;\n+  }\n+};\n+\n+class RSAKeyPairGenerationConfig : public KeyPairGenerationConfig {\n+ public:\n+  RSAKeyPairGenerationConfig(unsigned int modulus_bits, unsigned int exponent)\n+    : modulus_bits_(modulus_bits), exponent_(exponent) {}\n+\n+  EVPKeyCtxPointer Setup() override {\n+    return EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, nullptr));\n+  }\n+\n+  bool Configure(const EVPKeyCtxPointer& ctx) override {\n+    if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx.get(), modulus_bits_) <= 0)\n+      return false;\n+\n+    // 0x10001 is the default RSA exponent.\n+    if (exponent_ != 0x10001) {\n+      BignumPointer bn(BN_new());\n+      CHECK_NOT_NULL(bn.get());\n+      CHECK(BN_set_word(bn.get(), exponent_));\n+      if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)\n+        return false;\n+    }\n+\n+    return true;\n+  }\n+\n+ private:\n+  const unsigned int modulus_bits_;\n+  const unsigned int exponent_;\n+};\n+\n+class DSAKeyPairGenerationConfig : public KeyPairGenerationConfig {\n+ public:\n+  DSAKeyPairGenerationConfig(unsigned int modulus_bits, int divisor_bits)\n+    : modulus_bits_(modulus_bits), divisor_bits_(divisor_bits) {}\n+\n+  EVPKeyCtxPointer Setup() override {\n+    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));\n+    if (!param_ctx)\n+      return nullptr;\n+\n+    if (EVP_PKEY_paramgen_init(param_ctx.get()) <= 0)\n+      return nullptr;\n+\n+    if (EVP_PKEY_CTX_set_dsa_paramgen_bits(param_ctx.get(), modulus_bits_) <= 0)\n+      return nullptr;\n+\n+    if (divisor_bits_ != -1) {\n+      if (EVP_PKEY_CTX_ctrl(param_ctx.get(), EVP_PKEY_DSA, EVP_PKEY_OP_PARAMGEN,\n+                            EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS, divisor_bits_,\n+                            nullptr) <= 0) {\n+        return nullptr;\n+      }\n+    }\n+\n+    EVP_PKEY* params = nullptr;\n+    if (EVP_PKEY_paramgen(param_ctx.get(), &params) <= 0)\n+      return nullptr;\n+    param_ctx.reset();\n+\n+    EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(params, nullptr));\n+    EVP_PKEY_free(params);\n+    return key_ctx;\n+  }\n+\n+ private:\n+  const unsigned int modulus_bits_;\n+  const int divisor_bits_;\n+};\n+\n+class ECKeyPairGenerationConfig : public KeyPairGenerationConfig {\n+ public:\n+  ECKeyPairGenerationConfig(int curve_nid, int param_encoding)\n+    : curve_nid_(curve_nid), param_encoding_(param_encoding) {}\n+\n+  EVPKeyCtxPointer Setup() override {\n+    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));\n+    if (!param_ctx)\n+      return nullptr;\n+\n+    if (EVP_PKEY_paramgen_init(param_ctx.get()) <= 0)\n+      return nullptr;\n+\n+    if (EVP_PKEY_CTX_set_ec_paramgen_curve_nid(param_ctx.get(),\n+                                               curve_nid_) <= 0)\n+      return nullptr;\n+\n+    if (EVP_PKEY_CTX_set_ec_param_enc(param_ctx.get(), param_encoding_) <= 0)\n+      return nullptr;\n+\n+    EVP_PKEY* params = nullptr;\n+    if (EVP_PKEY_paramgen(param_ctx.get(), &params) <= 0)\n+      return nullptr;\n+    param_ctx.reset();\n+\n+    EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(params, nullptr));\n+    EVP_PKEY_free(params);\n+    return key_ctx;\n+  }\n+\n+ private:\n+  const int curve_nid_;\n+  const int param_encoding_;\n+};\n+\n+enum PKEncodingType {\n+  // RSAPublicKey / RSAPrivateKey according to PKCS#1.\n+  PK_ENCODING_PKCS1,\n+  // PrivateKeyInfo or EncryptedPrivateKeyInfo according to PKCS#8.\n+  PK_ENCODING_PKCS8,\n+  // SubjectPublicKeyInfo according to X.509.\n+  PK_ENCODING_SPKI,\n+  // ECPrivateKey according to SEC1.\n+  PK_ENCODING_SEC1\n+};\n+\n+enum PKFormatType {\n+  PK_FORMAT_DER,\n+  PK_FORMAT_PEM\n+};\n+\n+struct KeyPairEncodingConfig {\n+  PKEncodingType type_;\n+  PKFormatType format_;\n+};\n+\n+typedef KeyPairEncodingConfig PublicKeyEncodingConfig;\n+\n+struct PrivateKeyEncodingConfig : public KeyPairEncodingConfig {\n+  const EVP_CIPHER* cipher_;\n+  // This char* will be passed to OPENSSL_clear_free.\n+  std::shared_ptr<char> passphrase_;\n+  unsigned int passphrase_length_;\n+};\n+\n+class GenerateKeyPairJob : public CryptoJob {\n+ public:\n+  GenerateKeyPairJob(Environment* env,\n+                     std::unique_ptr<KeyPairGenerationConfig> config,\n+                     PublicKeyEncodingConfig public_key_encoding,\n+                     PrivateKeyEncodingConfig private_key_encoding)\n+    : CryptoJob(env),\n+    config_(std::move(config)),\n+    public_key_encoding_(public_key_encoding),\n+    private_key_encoding_(private_key_encoding),\n+    pkey_(nullptr) {}\n+\n+  inline void DoThreadPoolWork() override {\n+    if (!GenerateKey())\n+      errors_.Capture();\n+  }\n+\n+  inline bool GenerateKey() {\n+    // Make sure that the CSPRNG is properly seeded so the results are secure.\n+    CheckEntropy();\n+\n+    // Create the key generation context.\n+    EVPKeyCtxPointer ctx = config_->Setup();\n+    if (!ctx)\n+      return false;\n+\n+    // Initialize key generation.\n+    if (EVP_PKEY_keygen_init(ctx.get()) <= 0)\n+      return false;\n+\n+    // Configure key generation.\n+    if (!config_->Configure(ctx))\n+      return false;\n+\n+    // Generate the key.\n+    EVP_PKEY* pkey = nullptr;\n+    if (EVP_PKEY_keygen(ctx.get(), &pkey) != 1)\n+      return false;\n+    pkey_.reset(pkey);\n+    return true;\n+  }\n+\n+  inline void AfterThreadPoolWork() override {\n+    Local<Value> args[3];\n+    ToResult(&args[0], &args[1], &args[2]);\n+    async_wrap->MakeCallback(env->ondone_string(), 3, args);\n+  }\n+\n+  inline void ToResult(Local<Value>* err,\n+                       Local<Value>* pubkey,\n+                       Local<Value>* privkey) {\n+    if (pkey_ && EncodeKeys(pubkey, privkey)) {\n+      CHECK(errors_.empty());\n+      *err = Undefined(env->isolate());\n+    } else {\n+      if (errors_.empty())\n+        errors_.Capture();\n+      CHECK(!errors_.empty());\n+      *err = errors_.ToException(env);\n+      *pubkey = Undefined(env->isolate());\n+      *privkey = Undefined(env->isolate());\n+    }\n+  }\n+\n+  inline bool EncodeKeys(Local<Value>* pubkey, Local<Value>* privkey) {\n+    EVP_PKEY* pkey = pkey_.get();\n+    BIOPointer bio(BIO_new(BIO_s_mem()));\n+    CHECK(bio);\n+\n+    // Encode the public key.\n+    if (public_key_encoding_.type_ == PK_ENCODING_PKCS1) {\n+      // PKCS#1 is only valid for RSA keys.\n+      CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n+      RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n+      if (public_key_encoding_.format_ == PK_FORMAT_PEM) {\n+        // Encode PKCS#1 as PEM.\n+        if (PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) != 1)\n+          return false;\n+      } else {\n+        // Encode PKCS#1 as DER.\n+        CHECK_EQ(public_key_encoding_.format_, PK_FORMAT_DER);\n+        if (i2d_RSAPublicKey_bio(bio.get(), rsa.get()) != 1)\n+          return false;\n+      }\n+    } else {\n+      CHECK_EQ(public_key_encoding_.type_, PK_ENCODING_SPKI);\n+      if (public_key_encoding_.format_ == PK_FORMAT_PEM) {\n+        // Encode SPKI as PEM.\n+        if (PEM_write_bio_PUBKEY(bio.get(), pkey) != 1)\n+          return false;\n+      } else {\n+        // Encode SPKI as DER.\n+        CHECK_EQ(public_key_encoding_.format_, PK_FORMAT_DER);\n+        if (i2d_PUBKEY_bio(bio.get(), pkey) != 1)\n+          return false;\n+      }\n+    }\n+\n+    // Convert the contents of the BIO to a JavaScript object.\n+    BIOToStringOrBuffer(bio.get(), public_key_encoding_.format_, pubkey);\n+    USE(BIO_reset(bio.get()));\n+\n+    // Now do the same for the private key (which is a bit more difficult).\n+    if (private_key_encoding_.type_ == PK_ENCODING_PKCS1) {\n+      // PKCS#1 is only permitted for RSA keys and without encryption.\n+      CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n+      CHECK_NULL(private_key_encoding_.cipher_);\n+\n+      RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n+      if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n+        // Encode PKCS#1 as PEM.\n+        if (PEM_write_bio_RSAPrivateKey(bio.get(), rsa.get(),\n+                                        nullptr, nullptr, 0,\n+                                        nullptr, nullptr) != 1)\n+          return false;\n+      } else {\n+        // Encode PKCS#1 as DER.\n+        CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n+        if (i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1)\n+          return false;\n+      }\n+    } else if (private_key_encoding_.type_ == PK_ENCODING_PKCS8) {\n+      if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n+        // Encode PKCS#8 as PEM.\n+        if (PEM_write_bio_PKCS8PrivateKey(\n+                bio.get(), pkey,\n+                private_key_encoding_.cipher_,\n+                private_key_encoding_.passphrase_.get(),\n+                private_key_encoding_.passphrase_length_,\n+                nullptr, nullptr) != 1)\n+          return false;\n+      } else {\n+        // Encode PKCS#8 as DER.\n+        CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n+        if (i2d_PKCS8PrivateKey_bio(\n+                bio.get(), pkey,\n+                private_key_encoding_.cipher_,\n+                private_key_encoding_.passphrase_.get(),\n+                private_key_encoding_.passphrase_length_,\n+                nullptr, nullptr) != 1)\n+          return false;\n+      }\n+    } else {\n+      CHECK_EQ(private_key_encoding_.type_, PK_ENCODING_SEC1);\n+\n+      // SEC1 is only permitted for EC keys and without encryption.\n+      CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);\n+      CHECK_NULL(private_key_encoding_.cipher_);\n+\n+      ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));\n+      if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n+        // Encode SEC1 as PEM.\n+        if (PEM_write_bio_ECPrivateKey(bio.get(), ec_key.get(),\n+                                       nullptr, nullptr, 0,\n+                                       nullptr, nullptr) != 1)\n+          return false;\n+      } else {\n+        // Encode SEC1 as DER.\n+        CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n+        if (i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1)\n+          return false;\n+      }\n+    }\n+\n+    BIOToStringOrBuffer(bio.get(), private_key_encoding_.format_, privkey);\n+    return true;\n+  }\n+\n+  inline void BIOToStringOrBuffer(BIO* bio, PKFormatType format,\n+                                  Local<Value>* out) const {\n+    BUF_MEM* bptr;\n+    BIO_get_mem_ptr(bio, &bptr);\n+    if (format == PK_FORMAT_PEM) {\n+      // PEM is an ASCII format, so we will return it as a string.\n+      *out = String::NewFromUtf8(env->isolate(), bptr->data,\n+                                 NewStringType::kNormal,\n+                                 bptr->length).ToLocalChecked();\n+    } else {\n+      CHECK_EQ(format, PK_FORMAT_DER);\n+      // DER is binary, return it as a buffer.\n+      *out = Buffer::Copy(env, bptr->data, bptr->length).ToLocalChecked();\n+    }\n+  }\n+\n+ private:\n+  CryptoErrorVector errors_;\n+  std::unique_ptr<KeyPairGenerationConfig> config_;\n+  PublicKeyEncodingConfig public_key_encoding_;\n+  PrivateKeyEncodingConfig private_key_encoding_;\n+  EVPKeyPointer pkey_;\n+};\n+\n+void GenerateKeyPair(const FunctionCallbackInfo<Value>& args,\n+                     unsigned int n_opts,\n+                     std::unique_ptr<KeyPairGenerationConfig> config) {\n+  Environment* env = Environment::GetCurrent(args);\n+  PublicKeyEncodingConfig public_key_encoding;\n+  PrivateKeyEncodingConfig private_key_encoding;\n+\n+  // Public key encoding: type (int) + pem (bool)\n+  CHECK(args[n_opts]->IsInt32());\n+  public_key_encoding.type_ = static_cast<PKEncodingType>(\n+      args[n_opts].As<Int32>()->Value());\n+  CHECK(args[n_opts + 1]->IsInt32());\n+  public_key_encoding.format_ = static_cast<PKFormatType>(\n+      args[n_opts + 1].As<Int32>()->Value());\n+\n+  // Private key encoding: type (int) + pem (bool) + cipher (optional, string) +\n+  //                       passphrase (optional, string)\n+  CHECK(args[n_opts + 2]->IsInt32());\n+  private_key_encoding.type_ = static_cast<PKEncodingType>(\n+      args[n_opts + 2].As<Int32>()->Value());\n+  CHECK(args[n_opts + 1]->IsInt32());\n+  private_key_encoding.format_ = static_cast<PKFormatType>(\n+      args[n_opts + 3].As<Int32>()->Value());\n+  if (args[n_opts + 4]->IsString()) {\n+    String::Utf8Value cipher_name(env->isolate(),\n+                                  args[n_opts + 4].As<String>());\n+    private_key_encoding.cipher_ = EVP_get_cipherbyname(*cipher_name);\n+    if (private_key_encoding.cipher_ == nullptr)\n+      return env->ThrowError(\"Unknown cipher\");\n+\n+    // We need to take ownership of the string and want to avoid creating an\n+    // unnecessary copy in memory, that's why we are not using String::Utf8Value\n+    // here.\n+    CHECK(args[n_opts + 5]->IsString());\n+    Local<String> passphrase = args[n_opts + 5].As<String>();\n+    int len = passphrase->Utf8Length(env->isolate());\n+    private_key_encoding.passphrase_length_ = len;\n+    void* mem = OPENSSL_malloc(private_key_encoding.passphrase_length_ + 1);\n+    CHECK_NOT_NULL(mem);\n+    private_key_encoding.passphrase_.reset(static_cast<char*>(mem),\n+        [len](char* p) {\n+          OPENSSL_clear_free(p, len);\n+        });\n+    passphrase->WriteUtf8(env->isolate(),\n+                          private_key_encoding.passphrase_.get());\n+  } else {\n+    CHECK(args[n_opts + 5]->IsNullOrUndefined());\n+    private_key_encoding.cipher_ = nullptr;\n+    private_key_encoding.passphrase_length_ = 0;\n+  }\n+\n+  std::unique_ptr<GenerateKeyPairJob> job(\n+      new GenerateKeyPairJob(env, std::move(config), public_key_encoding,\n+                             private_key_encoding));\n+  if (args[n_opts + 6]->IsObject())\n+    return GenerateKeyPairJob::Run(std::move(job), args[n_opts + 6]);\n+  env->PrintSyncTrace();\n+  job->DoThreadPoolWork();\n+  Local<Value> err, pubkey, privkey;\n+  job->ToResult(&err, &pubkey, &privkey);\n+\n+  bool (*IsNotTrue)(Maybe<bool>) = [](Maybe<bool> maybe) {\n+    return maybe.IsNothing() || !maybe.ToChecked();\n+  };\n+  Local<Array> ret = Array::New(env->isolate(), 3);\n+  if (IsNotTrue(ret->Set(env->context(), 0, err)) ||\n+      IsNotTrue(ret->Set(env->context(), 1, pubkey)) ||\n+      IsNotTrue(ret->Set(env->context(), 2, privkey)))\n+    return;\n+  args.GetReturnValue().Set(ret);\n+}\n+\n+void GenerateKeyPairRSA(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args[0]->IsUint32());\n+  const uint32_t modulus_bits = args[0].As<Uint32>()->Value();\n+  CHECK(args[1]->IsUint32());\n+  const uint32_t exponent = args[1].As<Uint32>()->Value();\n+  std::unique_ptr<KeyPairGenerationConfig> config(\n+      new RSAKeyPairGenerationConfig(modulus_bits, exponent));\n+  GenerateKeyPair(args, 2, std::move(config));\n+}\n+\n+void GenerateKeyPairDSA(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args[0]->IsUint32());\n+  const uint32_t modulus_bits = args[0].As<Uint32>()->Value();\n+  CHECK(args[1]->IsInt32());\n+  const int32_t divisor_bits = args[1].As<Int32>()->Value();\n+  std::unique_ptr<KeyPairGenerationConfig> config(\n+      new DSAKeyPairGenerationConfig(modulus_bits, divisor_bits));\n+  GenerateKeyPair(args, 2, std::move(config));\n+}\n+\n+void GenerateKeyPairEC(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args[0]->IsString());\n+  String::Utf8Value curve_name(args.GetIsolate(), args[0].As<String>());\n+  int curve_nid = EC_curve_nist2nid(*curve_name);\n+  if (curve_nid == NID_undef)\n+    curve_nid = OBJ_sn2nid(*curve_name);\n+  // TODO(tniessen): Should we also support OBJ_ln2nid? (Other APIs don't.)\n+  if (curve_nid == NID_undef) {\n+    Environment* env = Environment::GetCurrent(args);\n+    return env->ThrowTypeError(\"Invalid ECDH curve name\");\n+  }\n+  CHECK(args[1]->IsUint32());\n+  const uint32_t param_encoding = args[1].As<Int32>()->Value();\n+  CHECK(param_encoding == OPENSSL_EC_NAMED_CURVE ||\n+        param_encoding == OPENSSL_EC_EXPLICIT_CURVE);\n+  std::unique_ptr<KeyPairGenerationConfig> config(\n+      new ECKeyPairGenerationConfig(curve_nid, param_encoding));\n+  GenerateKeyPair(args, 2, std::move(config));\n+}\n+\n+\n void GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n@@ -5242,6 +5690,17 @@ void Initialize(Local<Object> target,\n #endif\n \n   env->SetMethod(target, \"pbkdf2\", PBKDF2);\n+  env->SetMethod(target, \"generateKeyPairRSA\", GenerateKeyPairRSA);\n+  env->SetMethod(target, \"generateKeyPairDSA\", GenerateKeyPairDSA);\n+  env->SetMethod(target, \"generateKeyPairEC\", GenerateKeyPairEC);\n+  NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE);\n+  NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE);\n+  NODE_DEFINE_CONSTANT(target, PK_ENCODING_PKCS1);\n+  NODE_DEFINE_CONSTANT(target, PK_ENCODING_PKCS8);\n+  NODE_DEFINE_CONSTANT(target, PK_ENCODING_SPKI);\n+  NODE_DEFINE_CONSTANT(target, PK_ENCODING_SEC1);\n+  NODE_DEFINE_CONSTANT(target, PK_FORMAT_DER);\n+  NODE_DEFINE_CONSTANT(target, PK_FORMAT_PEM);\n   env->SetMethod(target, \"randomBytes\", RandomBytes);\n   env->SetMethodNoSideEffect(target, \"timingSafeEqual\", TimingSafeEqual);\n   env->SetMethodNoSideEffect(target, \"getSSLCiphers\", GetSSLCiphers);"
        },
        {
            "sha": "9369e332eb4e7f7f607152ca3e1030527f96f32c",
            "filename": "test/parallel/test-crypto-keygen.js",
            "status": "added",
            "additions": 634,
            "deletions": 0,
            "changes": 634,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/test%2Fparallel%2Ftest-crypto-keygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/test%2Fparallel%2Ftest-crypto-keygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-keygen.js?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -0,0 +1,634 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const assert = require('assert');\n+const {\n+  createSign,\n+  createVerify,\n+  generateKeyPair,\n+  generateKeyPairSync,\n+  publicEncrypt,\n+  privateDecrypt\n+} = require('crypto');\n+\n+// Asserts that the size of the given key (in chars or bytes) is within 10% of\n+// the expected size.\n+function assertApproximateSize(key, expectedSize) {\n+  const u = typeof key === 'string' ? 'chars' : 'bytes';\n+  const min = Math.floor(0.9 * expectedSize);\n+  const max = Math.ceil(1.1 * expectedSize);\n+  assert(key.length >= min,\n+         `Key (${key.length} ${u}) is shorter than expected (${min} ${u})`);\n+  assert(key.length <= max,\n+         `Key (${key.length} ${u}) is longer than expected (${max} ${u})`);\n+}\n+\n+// Tests that a key pair can be used for encryption / decryption.\n+function testEncryptDecrypt(publicKey, privateKey) {\n+  const message = 'Hello Node.js world!';\n+  const plaintext = Buffer.from(message, 'utf8');\n+  const ciphertext = publicEncrypt(publicKey, plaintext);\n+  const received = privateDecrypt(privateKey, ciphertext);\n+  assert.strictEqual(received.toString('utf8'), message);\n+}\n+\n+// Tests that a key pair can be used for signing / verification.\n+function testSignVerify(publicKey, privateKey) {\n+  const message = 'Hello Node.js world!';\n+  const signature = createSign('SHA256').update(message)\n+                                        .sign(privateKey, 'hex');\n+  const okay = createVerify('SHA256').update(message)\n+                                     .verify(publicKey, signature, 'hex');\n+  assert(okay);\n+}\n+\n+// Constructs a regular expression for a PEM-encoded key with the given label.\n+function getRegExpForPEM(label) {\n+  const head = `\\\\-\\\\-\\\\-\\\\-\\\\-BEGIN ${label}\\\\-\\\\-\\\\-\\\\-\\\\-`;\n+  const body = '([a-zA-Z0-9\\\\+/=]{64}\\n)*[a-zA-Z0-9\\\\+/=]{1,64}';\n+  const end = `\\\\-\\\\-\\\\-\\\\-\\\\-END ${label}\\\\-\\\\-\\\\-\\\\-\\\\-`;\n+  return new RegExp(`^${head}\\n${body}\\n${end}\\n$`);\n+}\n+\n+const pkcs1PubExp = getRegExpForPEM('RSA PUBLIC KEY');\n+const pkcs1PrivExp = getRegExpForPEM('RSA PRIVATE KEY');\n+const spkiExp = getRegExpForPEM('PUBLIC KEY');\n+const pkcs8Exp = getRegExpForPEM('PRIVATE KEY');\n+const pkcs8EncExp = getRegExpForPEM('ENCRYPTED PRIVATE KEY');\n+const sec1Exp = getRegExpForPEM('EC PRIVATE KEY');\n+\n+// Since our own APIs only accept PEM, not DER, we need to convert DER to PEM\n+// for testing.\n+function convertDERToPEM(label, der) {\n+  const base64 = der.toString('base64');\n+  const lines = [];\n+  let i = 0;\n+  while (i < base64.length) {\n+    const n = Math.min(base64.length - i, 64);\n+    lines.push(base64.substr(i, n));\n+    i += n;\n+  }\n+  const body = lines.join('\\n');\n+  const r = `-----BEGIN ${label}-----\\n${body}\\n-----END ${label}-----\\n`;\n+  assert(getRegExpForPEM(label).test(r));\n+  return r;\n+}\n+\n+{\n+  // To make the test faster, we will only test sync key generation once and\n+  // with a relatively small key.\n+  const ret = generateKeyPairSync('rsa', {\n+    publicExponent: 0x10001,\n+    modulusLength: 1024,\n+    publicKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'pem'\n+    },\n+    privateKeyEncoding: {\n+      type: 'pkcs8',\n+      format: 'pem'\n+    }\n+  });\n+\n+  assert.strictEqual(Object.keys(ret).length, 2);\n+  const { publicKey, privateKey } = ret;\n+\n+  assert.strictEqual(typeof publicKey, 'string');\n+  assert(pkcs1PubExp.test(publicKey));\n+  assertApproximateSize(publicKey, 272);\n+  assert.strictEqual(typeof privateKey, 'string');\n+  assert(pkcs8Exp.test(privateKey));\n+  assertApproximateSize(privateKey, 912);\n+\n+  testEncryptDecrypt(publicKey, privateKey);\n+  testSignVerify(publicKey, privateKey);\n+}\n+\n+{\n+  // Test async RSA key generation.\n+  generateKeyPair('rsa', {\n+    publicExponent: 0x10001,\n+    modulusLength: 4096,\n+    publicKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'der'\n+    },\n+    privateKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'pem'\n+    }\n+  }, common.mustCall((err, publicKeyDER, privateKey) => {\n+    assert.ifError(err);\n+\n+    // The public key is encoded as DER (which is binary) instead of PEM. We\n+    // will still need to convert it to PEM for testing.\n+    assert(Buffer.isBuffer(publicKeyDER));\n+    const publicKey = convertDERToPEM('RSA PUBLIC KEY', publicKeyDER);\n+    assertApproximateSize(publicKey, 720);\n+\n+    assert.strictEqual(typeof privateKey, 'string');\n+    assert(pkcs1PrivExp.test(privateKey));\n+    assertApproximateSize(privateKey, 3272);\n+\n+    testEncryptDecrypt(publicKey, privateKey);\n+    testSignVerify(publicKey, privateKey);\n+  }));\n+}\n+\n+{\n+  // Test async DSA key generation.\n+  generateKeyPair('dsa', {\n+    modulusLength: 2048,\n+    divisorLength: 256,\n+    publicKeyEncoding: {\n+      type: 'spki',\n+      format: 'pem'\n+    },\n+    privateKeyEncoding: {\n+      type: 'pkcs8',\n+      format: 'der',\n+      cipher: 'aes-128-cbc',\n+      passphrase: 'secret'\n+    }\n+  }, common.mustCall((err, publicKey, privateKeyDER) => {\n+    assert.ifError(err);\n+\n+    assert.strictEqual(typeof publicKey, 'string');\n+    assert(spkiExp.test(publicKey));\n+    // The private key is DER-encoded.\n+    assert(Buffer.isBuffer(privateKeyDER));\n+    const privateKey = convertDERToPEM('ENCRYPTED PRIVATE KEY', privateKeyDER);\n+\n+    assertApproximateSize(publicKey, 1194);\n+    assertApproximateSize(privateKey, 1054);\n+\n+    // Since the private key is encrypted, signing shouldn't work anymore.\n+    assert.throws(() => {\n+      testSignVerify(publicKey, privateKey);\n+    }, /bad decrypt/);\n+\n+    // Signing should work with the correct password.\n+    testSignVerify(publicKey, {\n+      key: privateKey,\n+      passphrase: 'secret'\n+    });\n+  }));\n+}\n+\n+{\n+  // Test async elliptic curve key generation, e.g. for ECDSA, with a SEC1\n+  // private key.\n+  generateKeyPair('ec', {\n+    namedCurve: 'prime256v1',\n+    paramEncoding: 'named',\n+    publicKeyEncoding: {\n+      type: 'spki',\n+      format: 'pem'\n+    },\n+    privateKeyEncoding: {\n+      type: 'sec1',\n+      format: 'pem'\n+    }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+\n+    assert.strictEqual(typeof publicKey, 'string');\n+    assert(spkiExp.test(publicKey));\n+    assert.strictEqual(typeof privateKey, 'string');\n+    assert(sec1Exp.test(privateKey));\n+\n+    testSignVerify(publicKey, privateKey);\n+  }));\n+}\n+\n+{\n+  // Test async elliptic curve key generation, e.g. for ECDSA, with an encrypted\n+  // private key.\n+  generateKeyPair('ec', {\n+    namedCurve: 'P-256',\n+    paramEncoding: 'named',\n+    publicKeyEncoding: {\n+      type: 'spki',\n+      format: 'pem'\n+    },\n+    privateKeyEncoding: {\n+      type: 'pkcs8',\n+      format: 'pem',\n+      cipher: 'aes-128-cbc',\n+      passphrase: 'top secret'\n+    }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+\n+    assert.strictEqual(typeof publicKey, 'string');\n+    assert(spkiExp.test(publicKey));\n+    assert.strictEqual(typeof privateKey, 'string');\n+    assert(pkcs8EncExp.test(privateKey));\n+\n+    // Since the private key is encrypted, signing shouldn't work anymore.\n+    assert.throws(() => {\n+      testSignVerify(publicKey, privateKey);\n+    }, /bad decrypt/);\n+\n+    testSignVerify(publicKey, {\n+      key: privateKey,\n+      passphrase: 'top secret'\n+    });\n+  }));\n+}\n+\n+{\n+  // Test invalid key types.\n+  for (const type of [undefined, null, 0]) {\n+    common.expectsError(() => generateKeyPairSync(type, {}), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      message: 'The \"type\" argument must be of type string. Received type ' +\n+               typeof type\n+    });\n+  }\n+\n+  common.expectsError(() => generateKeyPairSync('rsa2', {}), {\n+    type: TypeError,\n+    code: 'ERR_INVALID_ARG_VALUE',\n+    message: \"The argument 'type' must be one of \" +\n+             \"'rsa', 'dsa', 'ec'. Received 'rsa2'\"\n+  });\n+}\n+\n+{\n+  // Missing / invalid publicKeyEncoding.\n+  for (const enc of [undefined, null, 0, 'a', true]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: enc,\n+      privateKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${enc}\" is invalid for option \"publicKeyEncoding\"`\n+    });\n+  }\n+\n+  // Missing publicKeyEncoding.type.\n+  for (const type of [undefined, null, 0, true, {}]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type,\n+        format: 'pem'\n+      },\n+      privateKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${type}\" is invalid for option ` +\n+               '\"publicKeyEncoding.type\"'\n+    });\n+  }\n+\n+  // Missing / invalid publicKeyEncoding.format.\n+  for (const format of [undefined, null, 0, false, 'a', {}]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type: 'pkcs1',\n+        format\n+      },\n+      privateKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${format}\" is invalid for option ` +\n+               '\"publicKeyEncoding.format\"'\n+    });\n+  }\n+\n+  // Missing / invalid privateKeyEncoding.\n+  for (const enc of [undefined, null, 0, 'a', true]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      },\n+      privateKeyEncoding: enc\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${enc}\" is invalid for option \"privateKeyEncoding\"`\n+    });\n+  }\n+\n+  // Missing / invalid privateKeyEncoding.type.\n+  for (const type of [undefined, null, 0, true, {}]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      },\n+      privateKeyEncoding: {\n+        type,\n+        format: 'pem'\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${type}\" is invalid for option ` +\n+               '\"privateKeyEncoding.type\"'\n+    });\n+  }\n+\n+  // Missing / invalid privateKeyEncoding.format.\n+  for (const format of [undefined, null, 0, false, 'a', {}]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      },\n+      privateKeyEncoding: {\n+        type: 'pkcs1',\n+        format\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${format}\" is invalid for option ` +\n+               '\"privateKeyEncoding.format\"'\n+    });\n+  }\n+\n+  // cipher of invalid type.\n+  for (const cipher of [0, true, {}]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      },\n+      privateKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem',\n+        cipher\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${cipher}\" is invalid for option ` +\n+               '\"privateKeyEncoding.cipher\"'\n+    });\n+  }\n+\n+  // Invalid cipher.\n+  common.expectsError(() => generateKeyPairSync('rsa', {\n+    modulusLength: 4096,\n+    publicKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'pem'\n+    },\n+    privateKeyEncoding: {\n+      type: 'pkcs8',\n+      format: 'pem',\n+      cipher: 'foo',\n+      passphrase: 'secret'\n+    }\n+  }), {\n+    type: Error,\n+    message: 'Unknown cipher'\n+  });\n+\n+  // cipher, but no valid passphrase.\n+  for (const passphrase of [undefined, null, 5, false, true]) {\n+    common.expectsError(() => generateKeyPairSync('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: {\n+        type: 'pkcs1',\n+        format: 'pem'\n+      },\n+      privateKeyEncoding: {\n+        type: 'pkcs8',\n+        format: 'pem',\n+        cipher: 'aes-128-cbc',\n+        passphrase\n+      }\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${passphrase}\" is invalid for option ` +\n+               '\"privateKeyEncoding.passphrase\"'\n+    });\n+  }\n+\n+  // Test invalid callbacks.\n+  for (const cb of [undefined, null, 0, {}]) {\n+    common.expectsError(() => generateKeyPair('rsa', {\n+      modulusLength: 4096,\n+      publicKeyEncoding: { type: 'pkcs1', format: 'pem' },\n+      privateKeyEncoding: { type: 'pkcs1', format: 'pem' }\n+    }, cb), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_CALLBACK'\n+    });\n+  }\n+}\n+\n+// Test RSA parameters.\n+{\n+  // Test invalid modulus lengths.\n+  for (const modulusLength of [undefined, null, 'a', true, {}, [], 512.1, -1]) {\n+    common.expectsError(() => generateKeyPair('rsa', {\n+      modulusLength\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${modulusLength}\" is invalid for option ` +\n+               '\"modulusLength\"'\n+    });\n+  }\n+\n+  // Test invalid exponents.\n+  for (const publicExponent of ['a', true, {}, [], 3.5, -1]) {\n+    common.expectsError(() => generateKeyPair('rsa', {\n+      modulusLength: 4096,\n+      publicExponent\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${publicExponent}\" is invalid for option ` +\n+               '\"publicExponent\"'\n+    });\n+  }\n+}\n+\n+// Test DSA parameters.\n+{\n+  // Test invalid modulus lengths.\n+  for (const modulusLength of [undefined, null, 'a', true, {}, [], 4096.1]) {\n+    common.expectsError(() => generateKeyPair('dsa', {\n+      modulusLength\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${modulusLength}\" is invalid for option ` +\n+               '\"modulusLength\"'\n+    });\n+  }\n+\n+  // Test invalid divisor lengths.\n+  for (const divisorLength of ['a', true, {}, [], 4096.1]) {\n+    common.expectsError(() => generateKeyPair('dsa', {\n+      modulusLength: 2048,\n+      divisorLength\n+    }), {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${divisorLength}\" is invalid for option ` +\n+               '\"divisorLength\"'\n+    });\n+  }\n+}\n+\n+// Test EC parameters.\n+{\n+  // Test invalid curves.\n+  common.expectsError(() => {\n+    generateKeyPairSync('ec', {\n+      namedCurve: 'abcdef',\n+      publicKeyEncoding: { type: 'spki', format: 'pem' },\n+      privateKeyEncoding: { type: 'sec1', format: 'pem' }\n+    });\n+  }, {\n+    type: TypeError,\n+    message: 'Invalid ECDH curve name'\n+  });\n+\n+  // It should recognize both NIST and standard curve names.\n+  generateKeyPair('ec', {\n+    namedCurve: 'P-256',\n+    publicKeyEncoding: { type: 'spki', format: 'pem' },\n+    privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+  }));\n+\n+  generateKeyPair('ec', {\n+    namedCurve: 'secp192k1',\n+    publicKeyEncoding: { type: 'spki', format: 'pem' },\n+    privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+  }));\n+}\n+\n+// Test invalid key encoding types.\n+{\n+  // Invalid public key type.\n+  for (const type of ['foo', 'pkcs8', 'sec1']) {\n+    common.expectsError(() => {\n+      generateKeyPairSync('rsa', {\n+        modulusLength: 4096,\n+        publicKeyEncoding: { type, format: 'pem' },\n+        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n+      });\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${type}\" is invalid for option ` +\n+               '\"publicKeyEncoding.type\"'\n+    });\n+  }\n+\n+  // Invalid private key type.\n+  for (const type of ['foo', 'spki']) {\n+    common.expectsError(() => {\n+      generateKeyPairSync('rsa', {\n+        modulusLength: 4096,\n+        publicKeyEncoding: { type: 'spki', format: 'pem' },\n+        privateKeyEncoding: { type, format: 'pem' }\n+      });\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${type}\" is invalid for option ` +\n+               '\"privateKeyEncoding.type\"'\n+    });\n+  }\n+\n+  // Key encoding doesn't match key type.\n+  for (const type of ['dsa', 'ec']) {\n+    common.expectsError(() => {\n+      generateKeyPairSync(type, {\n+        modulusLength: 4096,\n+        namedCurve: 'P-256',\n+        publicKeyEncoding: { type: 'pkcs1', format: 'pem' },\n+        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n+      });\n+    }, {\n+      type: Error,\n+      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS',\n+      message: 'The selected key encoding pkcs1 can only be used for RSA keys.'\n+    });\n+\n+    common.expectsError(() => {\n+      generateKeyPairSync(type, {\n+        modulusLength: 4096,\n+        namedCurve: 'P-256',\n+        publicKeyEncoding: { type: 'spki', format: 'pem' },\n+        privateKeyEncoding: { type: 'pkcs1', format: 'pem' }\n+      });\n+    }, {\n+      type: Error,\n+      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS',\n+      message: 'The selected key encoding pkcs1 can only be used for RSA keys.'\n+    });\n+  }\n+\n+  for (const type of ['rsa', 'dsa']) {\n+    common.expectsError(() => {\n+      generateKeyPairSync(type, {\n+        modulusLength: 4096,\n+        publicKeyEncoding: { type: 'spki', format: 'pem' },\n+        privateKeyEncoding: { type: 'sec1', format: 'pem' }\n+      });\n+    }, {\n+      type: Error,\n+      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS',\n+      message: 'The selected key encoding sec1 can only be used for EC keys.'\n+    });\n+  }\n+\n+  // Attempting to encrypt a non-PKCS#8 key.\n+  for (const type of ['pkcs1', 'sec1']) {\n+    common.expectsError(() => {\n+      generateKeyPairSync(type === 'pkcs1' ? 'rsa' : 'ec', {\n+        modulusLength: 4096,\n+        namedCurve: 'P-256',\n+        publicKeyEncoding: { type: 'spki', format: 'pem' },\n+        privateKeyEncoding: {\n+          type,\n+          format: 'pem',\n+          cipher: 'aes-128-cbc',\n+          passphrase: 'hello'\n+        }\n+      });\n+    }, {\n+      type: Error,\n+      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS',\n+      message: `The selected key encoding ${type} does not support encryption.`\n+    });\n+  }\n+}"
        },
        {
            "sha": "5ff8760daa0e523be05f637afdefe6ab760db07a",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/8c502f54cec557959861d0ec837ad30b020c1dca/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/8c502f54cec557959861d0ec837ad30b020c1dca/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=8c502f54cec557959861d0ec837ad30b020c1dca",
            "patch": "@@ -46,6 +46,7 @@ const { getSystemErrorName } = require('util');\n     delete providers.WORKER;\n     if (!common.isMainThread)\n       delete providers.INSPECTORJSBINDING;\n+    delete providers.KEYPAIRGENREQUEST;\n \n     const objKeys = Object.keys(providers);\n     if (objKeys.length > 0)"
        }
    ],
    "stats": {
        "total": 1457,
        "additions": 1457,
        "deletions": 0
    }
}