{
    "author": "danbev",
    "message": "src: rename req_wrap with -async/-sync suffix\n\nThis commit renames the req_wrap variable to use an -async/-sync\nsuffix to avoid cases where the variables were being shadowed.\n\nPR-URL: https://github.com/nodejs/node/pull/19628\nRefs: https://github.com/nodejs/node/pull/19614\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "ed86cc570e875b00a6c94839d87027a27ce85932",
    "files": [
        {
            "sha": "5e88f76c40da2fe7538a8550d458353842dc78dc",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 176,
            "deletions": 171,
            "changes": 347,
            "blob_url": "https://github.com/nodejs/node/blob/ed86cc570e875b00a6c94839d87027a27ce85932/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ed86cc570e875b00a6c94839d87027a27ce85932/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=ed86cc570e875b00a6c94839d87027a27ce85932",
            "patch": "@@ -769,14 +769,14 @@ void Access(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // access(path, mode, req)\n-    AsyncCall(env, req_wrap, args, \"access\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // access(path, mode, req)\n+    AsyncCall(env, req_wrap_async, args, \"access\", UTF8, AfterNoArgs,\n               uv_fs_access, *path, mode);\n   } else {  // access(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"access\", uv_fs_access, *path, mode);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"access\", uv_fs_access, *path, mode);\n   }\n }\n \n@@ -790,14 +790,14 @@ void Close(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   int fd = args[0].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {  // close(fd, req)\n-    AsyncCall(env, req_wrap, args, \"close\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {  // close(fd, req)\n+    AsyncCall(env, req_wrap_async, args, \"close\", UTF8, AfterNoArgs,\n               uv_fs_close, fd);\n   } else {  // close(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[2], &req_wrap, \"close\", uv_fs_close, fd);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[2], &req_wrap_sync, \"close\", uv_fs_close, fd);\n   }\n }\n \n@@ -898,17 +898,17 @@ static void Stat(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {  // stat(path, req)\n-    AsyncCall(env, req_wrap, args, \"stat\", UTF8, AfterStat,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {  // stat(path, req)\n+    AsyncCall(env, req_wrap_async, args, \"stat\", UTF8, AfterStat,\n               uv_fs_stat, *path);\n   } else {  // stat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req_wrap;\n-    int err = SyncCall(env, args[2], &req_wrap, \"stat\", uv_fs_stat, *path);\n+    FSReqWrapSync req_wrap_sync;\n+    int err = SyncCall(env, args[2], &req_wrap_sync, \"stat\", uv_fs_stat, *path);\n     if (err == 0) {\n       FillStatsArray(env->fs_stats_field_array(),\n-                     static_cast<const uv_stat_t*>(req_wrap.req.ptr));\n+                     static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n     }\n   }\n }\n@@ -922,17 +922,18 @@ static void LStat(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {  // lstat(path, req)\n-    AsyncCall(env, req_wrap, args, \"lstat\", UTF8, AfterStat,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {  // lstat(path, req)\n+    AsyncCall(env, req_wrap_async, args, \"lstat\", UTF8, AfterStat,\n               uv_fs_lstat, *path);\n   } else {  // lstat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req_wrap;\n-    int err = SyncCall(env, args[2], &req_wrap, \"lstat\", uv_fs_lstat, *path);\n+    FSReqWrapSync req_wrap_sync;\n+    int err = SyncCall(env, args[2], &req_wrap_sync, \"lstat\", uv_fs_lstat,\n+                       *path);\n     if (err == 0) {\n       FillStatsArray(env->fs_stats_field_array(),\n-                     static_cast<const uv_stat_t*>(req_wrap.req.ptr));\n+                     static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n     }\n   }\n }\n@@ -946,17 +947,17 @@ static void FStat(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   int fd = args[0].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {  // fstat(fd, req)\n-    AsyncCall(env, req_wrap, args, \"fstat\", UTF8, AfterStat,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {  // fstat(fd, req)\n+    AsyncCall(env, req_wrap_async, args, \"fstat\", UTF8, AfterStat,\n               uv_fs_fstat, fd);\n   } else {  // fstat(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req_wrap;\n-    int err = SyncCall(env, args[2], &req_wrap, \"fstat\", uv_fs_fstat, fd);\n+    FSReqWrapSync req_wrap_sync;\n+    int err = SyncCall(env, args[2], &req_wrap_sync, \"fstat\", uv_fs_fstat, fd);\n     if (err == 0) {\n       FillStatsArray(env->fs_stats_field_array(),\n-                     static_cast<const uv_stat_t*>(req_wrap.req.ptr));\n+                     static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n     }\n   }\n }\n@@ -975,14 +976,14 @@ static void Symlink(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsInt32());\n   int flags = args[2].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // symlink(target, path, flags, req)\n-    AsyncDestCall(env, req_wrap, args, \"symlink\", *path, path.length(), UTF8,\n-                  AfterNoArgs, uv_fs_symlink, *target, *path, flags);\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // symlink(target, path, flags, req)\n+    AsyncDestCall(env, req_wrap_async, args, \"symlink\", *path, path.length(),\n+                  UTF8, AfterNoArgs, uv_fs_symlink, *target, *path, flags);\n   } else {  // symlink(target, path, flags, undefinec, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[4], &req, \"symlink\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[4], &req_wrap_sync, \"symlink\",\n              uv_fs_symlink, *target, *path, flags);\n   }\n }\n@@ -999,14 +1000,14 @@ static void Link(const FunctionCallbackInfo<Value>& args) {\n   BufferValue dest(env->isolate(), args[1]);\n   CHECK_NE(*dest, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // link(src, dest, req)\n-    AsyncDestCall(env, req_wrap, args, \"link\", *dest, dest.length(), UTF8,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // link(src, dest, req)\n+    AsyncDestCall(env, req_wrap_async, args, \"link\", *dest, dest.length(), UTF8,\n                   AfterNoArgs, uv_fs_link, *src, *dest);\n   } else {  // link(src, dest)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[3], &req, \"link\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"link\",\n              uv_fs_link, *src, *dest);\n   }\n }\n@@ -1022,19 +1023,19 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // readlink(path, encoding, req)\n-    AsyncCall(env, req_wrap, args, \"readlink\", encoding, AfterStringPtr,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)\n+    AsyncCall(env, req_wrap_async, args, \"readlink\", encoding, AfterStringPtr,\n               uv_fs_readlink, *path);\n   } else {\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req;\n-    int err = SyncCall(env, args[3], &req, \"readlink\",\n+    FSReqWrapSync req_wrap_sync;\n+    int err = SyncCall(env, args[3], &req_wrap_sync, \"readlink\",\n                        uv_fs_readlink, *path);\n     if (err < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n-    const char* link_path = static_cast<const char*>(req.req.ptr);\n+    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);\n \n     Local<Value> error;\n     MaybeLocal<Value> rc = StringBytes::Encode(env->isolate(),\n@@ -1062,14 +1063,16 @@ static void Rename(const FunctionCallbackInfo<Value>& args) {\n   BufferValue new_path(env->isolate(), args[1]);\n   CHECK_NE(*new_path, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {\n-    AsyncDestCall(env, req_wrap, args, \"rename\", *new_path, new_path.length(),\n-                  UTF8, AfterNoArgs, uv_fs_rename, *old_path, *new_path);\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {\n+    AsyncDestCall(env, req_wrap_async, args, \"rename\", *new_path,\n+                  new_path.length(), UTF8, AfterNoArgs, uv_fs_rename,\n+                  *old_path, *new_path);\n   } else {\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[3], &req, \"rename\", uv_fs_rename, *old_path, *new_path);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"rename\", uv_fs_rename,\n+             *old_path, *new_path);\n   }\n }\n \n@@ -1085,14 +1088,15 @@ static void FTruncate(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[1]->IsNumber());\n   const int64_t len = args[1].As<Integer>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {\n-    AsyncCall(env, req_wrap, args, \"ftruncate\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {\n+    AsyncCall(env, req_wrap_async, args, \"ftruncate\", UTF8, AfterNoArgs,\n               uv_fs_ftruncate, fd, len);\n   } else {\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[3], &req, \"ftruncate\", uv_fs_ftruncate, fd, len);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"ftruncate\", uv_fs_ftruncate, fd,\n+             len);\n   }\n }\n \n@@ -1105,14 +1109,14 @@ static void Fdatasync(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   const int fd = args[0].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {\n-    AsyncCall(env, req_wrap, args, \"fdatasync\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {\n+    AsyncCall(env, req_wrap_async, args, \"fdatasync\", UTF8, AfterNoArgs,\n               uv_fs_fdatasync, fd);\n   } else {\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[2], &req, \"fdatasync\", uv_fs_fdatasync, fd);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[2], &req_wrap_sync, \"fdatasync\", uv_fs_fdatasync, fd);\n   }\n }\n \n@@ -1125,14 +1129,14 @@ static void Fsync(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   const int fd = args[0].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {\n-    AsyncCall(env, req_wrap, args, \"fsync\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {\n+    AsyncCall(env, req_wrap_async, args, \"fsync\", UTF8, AfterNoArgs,\n               uv_fs_fsync, fd);\n   } else {\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[2], &req, \"fsync\", uv_fs_fsync, fd);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[2], &req_wrap_sync, \"fsync\", uv_fs_fsync, fd);\n   }\n }\n \n@@ -1145,14 +1149,14 @@ static void Unlink(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n-  if (req_wrap != nullptr) {\n-    AsyncCall(env, req_wrap, args, \"unlink\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n+  if (req_wrap_async != nullptr) {\n+    AsyncCall(env, req_wrap_async, args, \"unlink\", UTF8, AfterNoArgs,\n               uv_fs_unlink, *path);\n   } else {\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req;\n-    SyncCall(env, args[2], &req, \"unlink\", uv_fs_unlink, *path);\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[2], &req_wrap_sync, \"unlink\", uv_fs_unlink, *path);\n   }\n }\n \n@@ -1165,14 +1169,14 @@ static void RMDir(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[1]);  // rmdir(path, req)\n-  if (req_wrap != nullptr) {\n-    AsyncCall(env, req_wrap, args, \"rmdir\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);  // rmdir(path, req)\n+  if (req_wrap_async != nullptr) {\n+    AsyncCall(env, req_wrap_async, args, \"rmdir\", UTF8, AfterNoArgs,\n               uv_fs_rmdir, *path);\n   } else {  // rmdir(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[2], &req_wrap, \"rmdir\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[2], &req_wrap_sync, \"rmdir\",\n              uv_fs_rmdir, *path);\n   }\n }\n@@ -1189,14 +1193,14 @@ static void MKDir(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[1]->IsInt32());\n   const int mode = args[1].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // mkdir(path, mode, req)\n-    AsyncCall(env, req_wrap, args, \"mkdir\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)\n+    AsyncCall(env, req_wrap_async, args, \"mkdir\", UTF8, AfterNoArgs,\n               uv_fs_mkdir, *path, mode);\n   } else {  // mkdir(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"mkdir\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"mkdir\",\n              uv_fs_mkdir, *path, mode);\n   }\n }\n@@ -1212,20 +1216,20 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // realpath(path, encoding, req)\n-    AsyncCall(env, req_wrap, args, \"realpath\", encoding, AfterStringPtr,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)\n+    AsyncCall(env, req_wrap_async, args, \"realpath\", encoding, AfterStringPtr,\n               uv_fs_realpath, *path);\n   } else {  // realpath(path, encoding, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    int err = SyncCall(env, args[3], &req_wrap, \"realpath\",\n+    FSReqWrapSync req_wrap_sync;\n+    int err = SyncCall(env, args[3], &req_wrap_sync, \"realpath\",\n                        uv_fs_realpath, *path);\n     if (err < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n \n-    const char* link_path = static_cast<const char*>(req_wrap.req.ptr);\n+    const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);\n \n     Local<Value> error;\n     MaybeLocal<Value> rc = StringBytes::Encode(env->isolate(),\n@@ -1253,20 +1257,20 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // readdir(path, encoding, req)\n-    AsyncCall(env, req_wrap, args, \"scandir\", encoding, AfterScanDir,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // readdir(path, encoding, req)\n+    AsyncCall(env, req_wrap_async, args, \"scandir\", encoding, AfterScanDir,\n               uv_fs_scandir, *path, 0 /*flags*/);\n   } else {  // readdir(path, encoding, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    int err = SyncCall(env, args[3], &req_wrap, \"scandir\",\n+    FSReqWrapSync req_wrap_sync;\n+    int err = SyncCall(env, args[3], &req_wrap_sync, \"scandir\",\n                        uv_fs_scandir, *path, 0 /*flags*/);\n     if (err < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n \n-    CHECK_GE(req_wrap.req.result, 0);\n+    CHECK_GE(req_wrap_sync.req.result, 0);\n     int r;\n     Local<Array> names = Array::New(env->isolate(), 0);\n     Local<Function> fn = env->push_values_to_array_function();\n@@ -1276,7 +1280,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n     for (int i = 0; ; i++) {\n       uv_dirent_t ent;\n \n-      r = uv_fs_scandir_next(&(req_wrap.req), &ent);\n+      r = uv_fs_scandir_next(&(req_wrap_sync.req), &ent);\n       if (r == UV_EOF)\n         break;\n       if (r != 0) {\n@@ -1337,14 +1341,14 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsInt32());\n   const int mode = args[2].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // open(path, flags, mode, req)\n-    AsyncCall(env, req_wrap, args, \"open\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // open(path, flags, mode, req)\n+    AsyncCall(env, req_wrap_async, args, \"open\", UTF8, AfterInteger,\n               uv_fs_open, *path, flags, mode);\n   } else {  // open(path, flags, mode, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    int result = SyncCall(env, args[4], &req_wrap, \"open\",\n+    FSReqWrapSync req_wrap_sync;\n+    int result = SyncCall(env, args[4], &req_wrap_sync, \"open\",\n                           uv_fs_open, *path, flags, mode);\n     args.GetReturnValue().Set(result);\n   }\n@@ -1365,14 +1369,14 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsInt32());\n   const int mode = args[2].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // openFileHandle(path, flags, mode, req)\n-    AsyncCall(env, req_wrap, args, \"open\", UTF8, AfterOpenFileHandle,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // openFileHandle(path, flags, mode, req)\n+    AsyncCall(env, req_wrap_async, args, \"open\", UTF8, AfterOpenFileHandle,\n               uv_fs_open, *path, flags, mode);\n   } else {  // openFileHandle(path, flags, mode, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    int result = SyncCall(env, args[4], &req_wrap, \"open\",\n+    FSReqWrapSync req_wrap_sync;\n+    int result = SyncCall(env, args[4], &req_wrap_sync, \"open\",\n                           uv_fs_open, *path, flags, mode);\n     if (result < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n@@ -1398,15 +1402,15 @@ static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsInt32());\n   const int flags = args[2].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // copyFile(src, dest, flags, req)\n-    AsyncDestCall(env, req_wrap, args, \"copyfile\",\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // copyFile(src, dest, flags, req)\n+    AsyncDestCall(env, req_wrap_async, args, \"copyfile\",\n                   *dest, dest.length(), UTF8, AfterNoArgs,\n                   uv_fs_copyfile, *src, *dest, flags);\n   } else {  // copyFile(src, dest, flags, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[4], &req_wrap, \"copyfile\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[4], &req_wrap_sync, \"copyfile\",\n              uv_fs_copyfile, *src, *dest, flags);\n   }\n }\n@@ -1450,14 +1454,14 @@ static void WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n   char* buf = buffer_data + off;\n   uv_buf_t uvbuf = uv_buf_init(const_cast<char*>(buf), len);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[5]);\n-  if (req_wrap != nullptr) {  // write(fd, buffer, off, len, pos, req)\n-    AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[5]);\n+  if (req_wrap_async != nullptr) {  // write(fd, buffer, off, len, pos, req)\n+    AsyncCall(env, req_wrap_async, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, &uvbuf, 1, pos);\n   } else {  // write(fd, buffer, off, len, pos, undefined, ctx)\n     CHECK_EQ(argc, 7);\n-    FSReqWrapSync req_wrap;\n-    int bytesWritten = SyncCall(env, args[6], &req_wrap, \"write\",\n+    FSReqWrapSync req_wrap_sync;\n+    int bytesWritten = SyncCall(env, args[6], &req_wrap_sync, \"write\",\n                                 uv_fs_write, fd, &uvbuf, 1, pos);\n     args.GetReturnValue().Set(bytesWritten);\n   }\n@@ -1493,14 +1497,14 @@ static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {\n     iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));\n   }\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // writeBuffers(fd, chunks, pos, req)\n-    AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // writeBuffers(fd, chunks, pos, req)\n+    AsyncCall(env, req_wrap_async, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, *iovs, iovs.length(), pos);\n   } else {  // writeBuffers(fd, chunks, pos, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    int bytesWritten = SyncCall(env, args[4], &req_wrap, \"write\",\n+    FSReqWrapSync req_wrap_sync;\n+    int bytesWritten = SyncCall(env, args[4], &req_wrap_sync, \"write\",\n                                 uv_fs_write, fd, *iovs, iovs.length(), pos);\n     args.GetReturnValue().Set(bytesWritten);\n   }\n@@ -1532,8 +1536,8 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n   char* buf = nullptr;\n   size_t len;\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[4]);\n-  const bool is_async = req_wrap != nullptr;\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[4]);\n+  const bool is_async = req_wrap_async != nullptr;\n \n   // Avoid copying the string when it is externalized but only when:\n   // 1. The target encoding is compatible with the string's encoding, and\n@@ -1556,29 +1560,30 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   if (is_async) {  // write(fd, string, pos, enc, req)\n-    CHECK_NE(req_wrap, nullptr);\n+    CHECK_NE(req_wrap_async, nullptr);\n     len = StringBytes::StorageSize(env->isolate(), value, enc);\n     FSReqBase::FSReqBuffer& stack_buffer =\n-        req_wrap->Init(\"write\", len, enc);\n+        req_wrap_async->Init(\"write\", len, enc);\n     // StorageSize may return too large a char, so correct the actual length\n     // by the write size\n     len = StringBytes::Write(env->isolate(), *stack_buffer, len, args[1], enc);\n     stack_buffer.SetLengthAndZeroTerminate(len);\n     uv_buf_t uvbuf = uv_buf_init(*stack_buffer, len);\n-    int err = uv_fs_write(env->event_loop(), req_wrap->req(),\n+    int err = uv_fs_write(env->event_loop(), req_wrap_async->req(),\n                           fd, &uvbuf, 1, pos, AfterInteger);\n-    req_wrap->Dispatched();\n+    req_wrap_async->Dispatched();\n     if (err < 0) {\n-      uv_fs_t* uv_req = req_wrap->req();\n+      uv_fs_t* uv_req = req_wrap_async->req();\n       uv_req->result = err;\n       uv_req->path = nullptr;\n-      AfterInteger(uv_req);  // after may delete req_wrap if there is an error\n+      AfterInteger(uv_req);  // after may delete req_wrap_async if there is\n+                             // an error\n     } else {\n-      req_wrap->SetReturnValue(args);\n+      req_wrap_async->SetReturnValue(args);\n     }\n   } else {  // write(fd, string, pos, enc, undefined, ctx)\n     CHECK_EQ(argc, 6);\n-    FSReqWrapSync req_wrap;\n+    FSReqWrapSync req_wrap_sync;\n     FSReqBase::FSReqBuffer stack_buffer;\n     if (buf == nullptr) {\n       len = StringBytes::StorageSize(env->isolate(), value, enc);\n@@ -1591,7 +1596,7 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n       buf = *stack_buffer;\n     }\n     uv_buf_t uvbuf = uv_buf_init(buf, len);\n-    int bytesWritten = SyncCall(env, args[5], &req_wrap, \"write\",\n+    int bytesWritten = SyncCall(env, args[5], &req_wrap_sync, \"write\",\n                                 uv_fs_write, fd, &uvbuf, 1, pos);\n     args.GetReturnValue().Set(bytesWritten);\n   }\n@@ -1637,14 +1642,14 @@ static void Read(const FunctionCallbackInfo<Value>& args) {\n   char* buf = buffer_data + off;\n   uv_buf_t uvbuf = uv_buf_init(const_cast<char*>(buf), len);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[5]);\n-  if (req_wrap != nullptr) {  // read(fd, buffer, offset, len, pos, req)\n-    AsyncCall(env, req_wrap, args, \"read\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[5]);\n+  if (req_wrap_async != nullptr) {  // read(fd, buffer, offset, len, pos, req)\n+    AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger,\n               uv_fs_read, fd, &uvbuf, 1, pos);\n   } else {  // read(fd, buffer, offset, len, pos, undefined, ctx)\n     CHECK_EQ(argc, 7);\n-    FSReqWrapSync req_wrap;\n-    const int bytesRead = SyncCall(env, args[6], &req_wrap, \"read\",\n+    FSReqWrapSync req_wrap_sync;\n+    const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, \"read\",\n                                    uv_fs_read, fd, &uvbuf, 1, pos);\n     args.GetReturnValue().Set(bytesRead);\n   }\n@@ -1666,14 +1671,14 @@ static void Chmod(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[1]->IsInt32());\n   int mode = args[1].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // chmod(path, mode, req)\n-    AsyncCall(env, req_wrap, args, \"chmod\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // chmod(path, mode, req)\n+    AsyncCall(env, req_wrap_async, args, \"chmod\", UTF8, AfterNoArgs,\n               uv_fs_chmod, *path, mode);\n   } else {  // chmod(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"chmod\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"chmod\",\n              uv_fs_chmod, *path, mode);\n   }\n }\n@@ -1694,14 +1699,14 @@ static void FChmod(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[1]->IsInt32());\n   const int mode = args[1].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // fchmod(fd, mode, req)\n-    AsyncCall(env, req_wrap, args, \"fchmod\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // fchmod(fd, mode, req)\n+    AsyncCall(env, req_wrap_async, args, \"fchmod\", UTF8, AfterNoArgs,\n               uv_fs_fchmod, fd, mode);\n   } else {  // fchmod(fd, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"fchmod\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"fchmod\",\n              uv_fs_fchmod, fd, mode);\n   }\n }\n@@ -1725,14 +1730,14 @@ static void Chown(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsUint32());\n   const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Uint32>()->Value());\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // chown(path, uid, gid, req)\n-    AsyncCall(env, req_wrap, args, \"chown\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // chown(path, uid, gid, req)\n+    AsyncCall(env, req_wrap_async, args, \"chown\", UTF8, AfterNoArgs,\n               uv_fs_chown, *path, uid, gid);\n   } else {  // chown(path, uid, gid, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[4], &req_wrap, \"chown\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[4], &req_wrap_sync, \"chown\",\n              uv_fs_chown, *path, uid, gid);\n   }\n }\n@@ -1756,14 +1761,14 @@ static void FChown(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsUint32());\n   const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Uint32>()->Value());\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // fchown(fd, uid, gid, req)\n-    AsyncCall(env, req_wrap, args, \"fchown\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // fchown(fd, uid, gid, req)\n+    AsyncCall(env, req_wrap_async, args, \"fchown\", UTF8, AfterNoArgs,\n               uv_fs_fchown, fd, uid, gid);\n   } else {  // fchown(fd, uid, gid, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[4], &req_wrap, \"fchown\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[4], &req_wrap_sync, \"fchown\",\n              uv_fs_fchown, fd, uid, gid);\n   }\n }\n@@ -1784,14 +1789,14 @@ static void UTimes(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsNumber());\n   const double mtime = args[2].As<Number>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // utimes(path, atime, mtime, req)\n-    AsyncCall(env, req_wrap, args, \"utime\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // utimes(path, atime, mtime, req)\n+    AsyncCall(env, req_wrap_async, args, \"utime\", UTF8, AfterNoArgs,\n               uv_fs_utime, *path, atime, mtime);\n   } else {  // utimes(path, atime, mtime, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[4], &req_wrap, \"utime\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[4], &req_wrap_sync, \"utime\",\n              uv_fs_utime, *path, atime, mtime);\n   }\n }\n@@ -1811,14 +1816,14 @@ static void FUTimes(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsNumber());\n   const double mtime = args[2].As<Number>()->Value();\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n-  if (req_wrap != nullptr) {  // futimes(fd, atime, mtime, req)\n-    AsyncCall(env, req_wrap, args, \"futime\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n+  if (req_wrap_async != nullptr) {  // futimes(fd, atime, mtime, req)\n+    AsyncCall(env, req_wrap_async, args, \"futime\", UTF8, AfterNoArgs,\n               uv_fs_futime, fd, atime, mtime);\n   } else {  // futimes(fd, atime, mtime, undefined, ctx)\n     CHECK_EQ(argc, 5);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[4], &req_wrap, \"futime\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[4], &req_wrap_sync, \"futime\",\n              uv_fs_futime, fd, atime, mtime);\n   }\n }\n@@ -1834,16 +1839,16 @@ static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n-  if (req_wrap != nullptr) {  // mkdtemp(tmpl, encoding, req)\n-    AsyncCall(env, req_wrap, args, \"mkdtemp\", encoding, AfterStringPath,\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)\n+    AsyncCall(env, req_wrap_async, args, \"mkdtemp\", encoding, AfterStringPath,\n               uv_fs_mkdtemp, *tmpl);\n   } else {  // mkdtemp(tmpl, encoding, undefined, ctx)\n     CHECK_EQ(argc, 4);\n-    FSReqWrapSync req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"mkdtemp\",\n+    FSReqWrapSync req_wrap_sync;\n+    SyncCall(env, args[3], &req_wrap_sync, \"mkdtemp\",\n              uv_fs_mkdtemp, *tmpl);\n-    const char* path = static_cast<const char*>(req_wrap.req.path);\n+    const char* path = static_cast<const char*>(req_wrap_sync.req.path);\n \n     Local<Value> error;\n     MaybeLocal<Value> rc ="
        }
    ],
    "stats": {
        "total": 347,
        "additions": 176,
        "deletions": 171
    }
}