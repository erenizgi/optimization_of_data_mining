{
    "author": "vsemozhetbyt",
    "message": "doc: unify more headings\n\nPR-URL: https://github.com/nodejs/node/pull/20046\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "6e869be104374a2970a60de8bfccce9f6197af31",
    "files": [
        {
            "sha": "2628cc290a566030270fd409cdaf7537dcd826e8",
            "filename": "doc/api/async_hooks.md",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/6e869be104374a2970a60de8bfccce9f6197af31/doc%2Fapi%2Fasync_hooks.md",
            "raw_url": "https://github.com/nodejs/node/raw/6e869be104374a2970a60de8bfccce9f6197af31/doc%2Fapi%2Fasync_hooks.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fasync_hooks.md?ref=6e869be104374a2970a60de8bfccce9f6197af31",
            "patch": "@@ -75,7 +75,7 @@ function destroy(asyncId) { }\n function promiseResolve(asyncId) { }\n ```\n \n-#### `async_hooks.createHook(callbacks)`\n+#### async_hooks.createHook(callbacks)\n \n <!-- YAML\n added: v8.1.0\n@@ -168,7 +168,7 @@ provided by AsyncHooks itself. The logging should then be skipped when\n it was the logging itself that caused AsyncHooks callback to call. By\n doing this the otherwise infinite recursion is broken.\n \n-#### `asyncHook.enable()`\n+#### asyncHook.enable()\n \n * Returns: {AsyncHook} A reference to `asyncHook`.\n \n@@ -184,7 +184,7 @@ const async_hooks = require('async_hooks');\n const hook = async_hooks.createHook(callbacks).enable();\n ```\n \n-#### `asyncHook.disable()`\n+#### asyncHook.disable()\n \n * Returns: {AsyncHook} A reference to `asyncHook`.\n \n@@ -200,7 +200,7 @@ Key events in the lifetime of asynchronous events have been categorized into\n four areas: instantiation, before/after the callback is called, and when the\n instance is destroyed.\n \n-##### `init(asyncId, type, triggerAsyncId, resource)`\n+##### init(asyncId, type, triggerAsyncId, resource)\n \n * `asyncId` {number} A unique ID for the async resource.\n * `type` {string} The type of the async resource.\n@@ -250,7 +250,7 @@ It is possible to have type name collisions. Embedders are encouraged to use\n unique prefixes, such as the npm package name, to prevent collisions when\n listening to the hooks.\n \n-###### `triggerId`\n+###### `triggerAsyncId`\n \n `triggerAsyncId` is the `asyncId` of the resource that caused (or \"triggered\")\n the new resource to initialize and that caused `init` to call. This is different\n@@ -396,7 +396,7 @@ The graph only shows *when* a resource was created, not *why*, so to track\n the *why* use `triggerAsyncId`.\n \n \n-##### `before(asyncId)`\n+##### before(asyncId)\n \n * `asyncId` {number}\n \n@@ -414,7 +414,7 @@ callback multiple times, while other operations like `fs.open()` will call\n it only once.\n \n \n-##### `after(asyncId)`\n+##### after(asyncId)\n \n * `asyncId` {number}\n \n@@ -425,7 +425,7 @@ will run *after* the `'uncaughtException'` event is emitted or a `domain`'s\n handler runs.\n \n \n-##### `destroy(asyncId)`\n+##### destroy(asyncId)\n \n * `asyncId` {number}\n \n@@ -437,7 +437,7 @@ made to the `resource` object passed to `init` it is possible that `destroy`\n will never be called, causing a memory leak in the application. If the resource\n does not depend on garbage collection, then this will not be an issue.\n \n-##### `promiseResolve(asyncId)`\n+##### promiseResolve(asyncId)\n \n * `asyncId` {number}\n \n@@ -464,7 +464,7 @@ init for PROMISE with id 6, trigger id: 5  # the Promise returned by then()\n   after 6\n ```\n \n-#### `async_hooks.executionAsyncId()`\n+#### async_hooks.executionAsyncId()\n \n <!-- YAML\n added: v8.1.0\n@@ -506,7 +506,7 @@ const server = net.createServer(function onConnection(conn) {\n Note that promise contexts may not get precise executionAsyncIds by default.\n See the section on [promise execution tracking][].\n \n-#### `async_hooks.triggerAsyncId()`\n+#### async_hooks.triggerAsyncId()\n \n * Returns: {number} The ID of the resource responsible for calling the callback\n   that is currently being executed.\n@@ -583,7 +583,7 @@ Library developers that handle their own asynchronous resources performing tasks\n like I/O, connection pooling, or managing callback queues may use the\n `AsyncWrap` JavaScript API so that all the appropriate callbacks are called.\n \n-### `class AsyncResource()`\n+### Class: AsyncResource\n \n The class `AsyncResource` is designed to be extended by the embedder's async\n resources. Using this, users can easily trigger the lifetime events of their\n@@ -629,7 +629,7 @@ asyncResource.emitBefore();\n asyncResource.emitAfter();\n ```\n \n-#### `AsyncResource(type[, options])`\n+#### new AsyncResource(type[, options])\n \n * `type` {string} The type of async event.\n * `options` {Object}\n@@ -662,7 +662,7 @@ class DBQuery extends AsyncResource {\n }\n ```\n \n-#### `asyncResource.runInAsyncScope(fn[, thisArg, ...args])`\n+#### asyncResource.runInAsyncScope(fn[, thisArg, ...args])\n <!-- YAML\n added: v9.6.0\n -->\n@@ -677,7 +677,7 @@ of the async resource. This will establish the context, trigger the AsyncHooks\n before callbacks, call the function, trigger the AsyncHooks after callbacks, and\n then restore the original execution context.\n \n-#### `asyncResource.emitBefore()`\n+#### asyncResource.emitBefore()\n <!-- YAML\n deprecated: v9.6.0\n -->\n@@ -693,7 +693,7 @@ will abort. For this reason, the `emitBefore` and `emitAfter` APIs are\n considered deprecated. Please use `runInAsyncScope`, as it provides a much safer\n alternative.\n \n-#### `asyncResource.emitAfter()`\n+#### asyncResource.emitAfter()\n <!-- YAML\n deprecated: v9.6.0\n -->\n@@ -712,18 +712,18 @@ will abort. For this reason, the `emitBefore` and `emitAfter` APIs are\n considered deprecated. Please use `runInAsyncScope`, as it provides a much safer\n alternative.\n \n-#### `asyncResource.emitDestroy()`\n+#### asyncResource.emitDestroy()\n \n Call all `destroy` hooks. This should only ever be called once. An error will\n be thrown if it is called more than once. This **must** be manually called. If\n the resource is left to be collected by the GC then the `destroy` hooks will\n never be called.\n \n-#### `asyncResource.asyncId()`\n+#### asyncResource.asyncId()\n \n * Returns: {number} The unique `asyncId` assigned to the resource.\n \n-#### `asyncResource.triggerAsyncId()`\n+#### asyncResource.triggerAsyncId()\n \n * Returns: {number} The same `triggerAsyncId` that is passed to the\n `AsyncResource` constructor."
        },
        {
            "sha": "a878ad27177b7d08e9ddc02face2971f4d1fb028",
            "filename": "doc/api/dns.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6e869be104374a2970a60de8bfccce9f6197af31/doc%2Fapi%2Fdns.md",
            "raw_url": "https://github.com/nodejs/node/raw/6e869be104374a2970a60de8bfccce9f6197af31/doc%2Fapi%2Fdns.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fdns.md?ref=6e869be104374a2970a60de8bfccce9f6197af31",
            "patch": "@@ -56,7 +56,7 @@ dns.resolve4('archive.org', (err, addresses) => {\n There are subtle consequences in choosing one over the other, please consult\n the [Implementation considerations section][] for more information.\n \n-## Class dns.Resolver\n+## Class: dns.Resolver\n <!-- YAML\n added: v8.3.0\n -->"
        },
        {
            "sha": "4090e545fdb54ba0ddc0f43f04b3ae835abd902e",
            "filename": "doc/api/esm.md",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/6e869be104374a2970a60de8bfccce9f6197af31/doc%2Fapi%2Fesm.md",
            "raw_url": "https://github.com/nodejs/node/raw/6e869be104374a2970a60de8bfccce9f6197af31/doc%2Fapi%2Fesm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fesm.md?ref=6e869be104374a2970a60de8bfccce9f6197af31",
            "patch": "@@ -37,11 +37,14 @@ Only the CLI argument for the main entry point to the program can be an entry\n point into an ESM graph. Dynamic import can also be used to create entry points\n into ESM graphs at runtime.\n \n-#### `import.meta`\n+#### import.meta\n+\n+* {Object}\n \n The `import.meta` metaproperty is an `Object` that contains the following\n property:\n-* `url` {string} The absolute `file:` URL of the module\n+\n+* `url` {string} The absolute `file:` URL of the module.\n \n ### Unsupported\n "
        }
    ],
    "stats": {
        "total": 47,
        "additions": 25,
        "deletions": 22
    }
}