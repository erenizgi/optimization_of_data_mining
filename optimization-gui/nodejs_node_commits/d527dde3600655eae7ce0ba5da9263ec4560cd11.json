{
    "author": "addaleax",
    "message": "src: use JS inheritance for `AsyncWrap`\n\nFor all classes descending from `AsyncWrap`, use JS inheritance\ninstead of manually adding methods to the individual classes.\n\nThis allows cleanup of some code around transferring handles\nover IPC.\n\nPR-URL: https://github.com/nodejs/node/pull/23094\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "d527dde3600655eae7ce0ba5da9263ec4560cd11",
    "files": [
        {
            "sha": "2cffb77e521978025f9110713a4c56baa8ade3fc",
            "filename": "lib/internal/worker.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/lib%2Finternal%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/lib%2Finternal%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fworker.js?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -73,7 +73,8 @@ Object.setPrototypeOf(MessagePort.prototype, EventEmitter.prototype);\n delete MessagePort.prototype.stop;\n delete MessagePort.prototype.drain;\n delete MessagePort.prototype.hasRef;\n-delete MessagePort.prototype.getAsyncId;\n+MessagePort.prototype.ref = MessagePortPrototype.ref;\n+MessagePort.prototype.unref = MessagePortPrototype.unref;\n \n // A communication channel consisting of a handle (that wraps around an\n // uv_async_t) which can receive information from other threads and emits"
        },
        {
            "sha": "38c0a73c51e145355d69c0d04f78bb42bab043d4",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -422,7 +422,6 @@\n         'src/node_root_certs.h',\n         'src/node_version.h',\n         'src/node_watchdog.h',\n-        'src/node_wrap.h',\n         'src/node_revert.h',\n         'src/node_i18n.h',\n         'src/node_worker.h',"
        },
        {
            "sha": "eb67433c39f6e5f733b84892f7dad514bf030e31",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 9,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -64,7 +64,7 @@ struct AsyncWrapObject : public AsyncWrap {\n   static inline void New(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n     CHECK(args.IsConstructCall());\n-    CHECK(env->async_wrap_constructor_template()->HasInstance(args.This()));\n+    CHECK(env->async_wrap_object_ctor_template()->HasInstance(args.This()));\n     CHECK(args[0]->IsUint32());\n     auto type = static_cast<ProviderType>(args[0].As<Uint32>()->Value());\n     new AsyncWrapObject(env, args.This(), type);\n@@ -424,12 +424,16 @@ void AsyncWrap::QueueDestroyAsyncId(const FunctionCallbackInfo<Value>& args) {\n       args[0].As<Number>()->Value());\n }\n \n-void AsyncWrap::AddWrapMethods(Environment* env,\n-                               Local<FunctionTemplate> constructor,\n-                               int flag) {\n-  env->SetProtoMethod(constructor, \"getAsyncId\", AsyncWrap::GetAsyncId);\n-  if (flag & kFlagHasReset)\n-    env->SetProtoMethod(constructor, \"asyncReset\", AsyncWrap::AsyncReset);\n+Local<FunctionTemplate> AsyncWrap::GetConstructorTemplate(Environment* env) {\n+  Local<FunctionTemplate> tmpl = env->async_wrap_ctor_template();\n+  if (tmpl.IsEmpty()) {\n+    tmpl = env->NewFunctionTemplate(nullptr);\n+    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"AsyncWrap\"));\n+    env->SetProtoMethod(tmpl, \"getAsyncId\", AsyncWrap::GetAsyncId);\n+    env->SetProtoMethod(tmpl, \"asyncReset\", AsyncWrap::AsyncReset);\n+    env->set_async_wrap_ctor_template(tmpl);\n+  }\n+  return tmpl;\n }\n \n void AsyncWrap::Initialize(Local<Object> target,\n@@ -525,17 +529,20 @@ void AsyncWrap::Initialize(Local<Object> target,\n   env->set_async_hooks_promise_resolve_function(Local<Function>());\n   env->set_async_hooks_binding(target);\n \n+  // TODO(addaleax): This block might better work as a\n+  // AsyncWrapObject::Initialize() or AsyncWrapObject::GetConstructorTemplate()\n+  // function.\n   {\n     auto class_name = FIXED_ONE_BYTE_STRING(env->isolate(), \"AsyncWrap\");\n     auto function_template = env->NewFunctionTemplate(AsyncWrapObject::New);\n     function_template->SetClassName(class_name);\n-    AsyncWrap::AddWrapMethods(env, function_template);\n+    function_template->Inherit(AsyncWrap::GetConstructorTemplate(env));\n     auto instance_template = function_template->InstanceTemplate();\n     instance_template->SetInternalFieldCount(1);\n     auto function =\n         function_template->GetFunction(env->context()).ToLocalChecked();\n     target->Set(env->context(), class_name, function).FromJust();\n-    env->set_async_wrap_constructor_template(function_template);\n+    env->set_async_wrap_object_ctor_template(function_template);\n   }\n }\n "
        },
        {
            "sha": "360380afc3459bf1ce9b37cbea26de2f75febc40",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -104,21 +104,15 @@ class AsyncWrap : public BaseObject {\n     PROVIDERS_LENGTH,\n   };\n \n-  enum Flags {\n-    kFlagNone = 0x0,\n-    kFlagHasReset = 0x1\n-  };\n-\n   AsyncWrap(Environment* env,\n             v8::Local<v8::Object> object,\n             ProviderType provider,\n             double execution_async_id = -1);\n \n   virtual ~AsyncWrap();\n \n-  static void AddWrapMethods(Environment* env,\n-                             v8::Local<v8::FunctionTemplate> constructor,\n-                             int flags = kFlagNone);\n+  static v8::Local<v8::FunctionTemplate> GetConstructorTemplate(\n+      Environment* env);\n \n   static void Initialize(v8::Local<v8::Object> target,\n                          v8::Local<v8::Value> unused,"
        },
        {
            "sha": "3187b7d4760b1df34d9f4f2e2384f8eb59e79248",
            "filename": "src/cares_wrap.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fcares_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fcares_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcares_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -2220,23 +2220,23 @@ void Initialize(Local<Object> target,\n \n   Local<FunctionTemplate> aiw =\n       BaseObject::MakeLazilyInitializedJSTemplate(env);\n-  AsyncWrap::AddWrapMethods(env, aiw);\n+  aiw->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> addrInfoWrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"GetAddrInfoReqWrap\");\n   aiw->SetClassName(addrInfoWrapString);\n   target->Set(addrInfoWrapString, aiw->GetFunction(context).ToLocalChecked());\n \n   Local<FunctionTemplate> niw =\n       BaseObject::MakeLazilyInitializedJSTemplate(env);\n-  AsyncWrap::AddWrapMethods(env, niw);\n+  niw->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> nameInfoWrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"GetNameInfoReqWrap\");\n   niw->SetClassName(nameInfoWrapString);\n   target->Set(nameInfoWrapString, niw->GetFunction(context).ToLocalChecked());\n \n   Local<FunctionTemplate> qrw =\n       BaseObject::MakeLazilyInitializedJSTemplate(env);\n-  AsyncWrap::AddWrapMethods(env, qrw);\n+  qrw->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> queryWrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"QueryReqWrap\");\n   qrw->SetClassName(queryWrapString);\n@@ -2245,7 +2245,7 @@ void Initialize(Local<Object> target,\n   Local<FunctionTemplate> channel_wrap =\n       env->NewFunctionTemplate(ChannelWrap::New);\n   channel_wrap->InstanceTemplate()->SetInternalFieldCount(1);\n-  AsyncWrap::AddWrapMethods(env, channel_wrap);\n+  channel_wrap->Inherit(AsyncWrap::GetConstructorTemplate(env));\n \n   env->SetProtoMethod(channel_wrap, \"queryAny\", Query<QueryAnyWrap>);\n   env->SetProtoMethod(channel_wrap, \"queryA\", Query<QueryAWrap>);"
        },
        {
            "sha": "a210252643c8a47468cf3e6c6bdb91482ed45c4b",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -319,7 +319,8 @@ struct PackageConfig {\n   V(async_hooks_destroy_function, v8::Function)                               \\\n   V(async_hooks_init_function, v8::Function)                                  \\\n   V(async_hooks_promise_resolve_function, v8::Function)                       \\\n-  V(async_wrap_constructor_template, v8::FunctionTemplate)                    \\\n+  V(async_wrap_object_ctor_template, v8::FunctionTemplate)                    \\\n+  V(async_wrap_ctor_template, v8::FunctionTemplate)                           \\\n   V(buffer_prototype_object, v8::Object)                                      \\\n   V(context, v8::Context)                                                     \\\n   V(domain_callback, v8::Function)                                            \\\n@@ -329,13 +330,15 @@ struct PackageConfig {\n   V(filehandlereadwrap_template, v8::ObjectTemplate)                          \\\n   V(fsreqpromise_constructor_template, v8::ObjectTemplate)                    \\\n   V(fs_use_promises_symbol, v8::Symbol)                                       \\\n+  V(handle_wrap_ctor_template, v8::FunctionTemplate)                          \\\n   V(host_import_module_dynamically_callback, v8::Function)                    \\\n   V(host_initialize_import_meta_object_callback, v8::Function)                \\\n   V(http2ping_constructor_template, v8::ObjectTemplate)                       \\\n   V(http2settings_constructor_template, v8::ObjectTemplate)                   \\\n   V(http2stream_constructor_template, v8::ObjectTemplate)                     \\\n   V(immediate_callback_function, v8::Function)                                \\\n   V(inspector_console_api_object, v8::Object)                                 \\\n+  V(libuv_stream_wrap_ctor_template, v8::FunctionTemplate)                    \\\n   V(message_port, v8::Object)                                                 \\\n   V(message_port_constructor_template, v8::FunctionTemplate)                  \\\n   V(pipe_constructor_template, v8::FunctionTemplate)                          \\"
        },
        {
            "sha": "aaf03dcb2b558885e4df1f223ef67fc1a1c7872d",
            "filename": "src/fs_event_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ffs_event_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ffs_event_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ffs_event_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -105,7 +105,7 @@ void FSEventWrap::Initialize(Local<Object> target,\n   t->InstanceTemplate()->SetInternalFieldCount(1);\n   t->SetClassName(fsevent_string);\n \n-  AsyncWrap::AddWrapMethods(env, t);\n+  t->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   env->SetProtoMethod(t, \"start\", Start);\n   env->SetProtoMethod(t, \"close\", Close);\n "
        },
        {
            "sha": "d4c5962c35e806ac635b985661deb15e14a9ae95",
            "filename": "src/handle_wrap.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fhandle_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fhandle_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fhandle_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -130,13 +130,19 @@ void HandleWrap::OnClose(uv_handle_t* handle) {\n   }\n }\n \n-\n-void HandleWrap::AddWrapMethods(Environment* env,\n-                                Local<FunctionTemplate> t) {\n-  env->SetProtoMethod(t, \"close\", HandleWrap::Close);\n-  env->SetProtoMethodNoSideEffect(t, \"hasRef\", HandleWrap::HasRef);\n-  env->SetProtoMethod(t, \"ref\", HandleWrap::Ref);\n-  env->SetProtoMethod(t, \"unref\", HandleWrap::Unref);\n+Local<FunctionTemplate> HandleWrap::GetConstructorTemplate(Environment* env) {\n+  Local<FunctionTemplate> tmpl = env->handle_wrap_ctor_template();\n+  if (tmpl.IsEmpty()) {\n+    tmpl = env->NewFunctionTemplate(nullptr);\n+    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"HandleWrap\"));\n+    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));\n+    env->SetProtoMethod(tmpl, \"close\", HandleWrap::Close);\n+    env->SetProtoMethodNoSideEffect(tmpl, \"hasRef\", HandleWrap::HasRef);\n+    env->SetProtoMethod(tmpl, \"ref\", HandleWrap::Ref);\n+    env->SetProtoMethod(tmpl, \"unref\", HandleWrap::Unref);\n+    env->set_handle_wrap_ctor_template(tmpl);\n+  }\n+  return tmpl;\n }\n \n "
        },
        {
            "sha": "b2722511c3c09f05b4d28e047b791da434e1b86d",
            "filename": "src/handle_wrap.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fhandle_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fhandle_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fhandle_wrap.h?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -73,8 +73,8 @@ class HandleWrap : public AsyncWrap {\n   virtual void Close(\n       v8::Local<v8::Value> close_callback = v8::Local<v8::Value>());\n \n-  static void AddWrapMethods(Environment* env,\n-                             v8::Local<v8::FunctionTemplate> constructor);\n+  static v8::Local<v8::FunctionTemplate> GetConstructorTemplate(\n+      Environment* env);\n \n  protected:\n   HandleWrap(Environment* env,"
        },
        {
            "sha": "49e1dcc6e8a30c39bfea02047257ac517aadb488",
            "filename": "src/inspector_js_api.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Finspector_js_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Finspector_js_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_js_api.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -307,7 +307,7 @@ void Initialize(Local<Object> target, Local<Value> unused,\n       env->NewFunctionTemplate(JSBindingsConnection::New);\n   tmpl->InstanceTemplate()->SetInternalFieldCount(1);\n   tmpl->SetClassName(conn_str);\n-  AsyncWrap::AddWrapMethods(env, tmpl);\n+  tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   env->SetProtoMethod(tmpl, \"dispatch\", JSBindingsConnection::Dispatch);\n   env->SetProtoMethod(tmpl, \"disconnect\", JSBindingsConnection::Disconnect);\n   target"
        },
        {
            "sha": "99ea7d870b8afb597e618ca1c04961b744ab50ea",
            "filename": "src/js_stream.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fjs_stream.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fjs_stream.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_stream.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -202,8 +202,7 @@ void JSStream::Initialize(Local<Object> target,\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"JSStream\");\n   t->SetClassName(jsStreamString);\n   t->InstanceTemplate()->SetInternalFieldCount(1);\n-\n-  AsyncWrap::AddWrapMethods(env, t);\n+  t->Inherit(AsyncWrap::GetConstructorTemplate(env));\n \n   env->SetProtoMethod(t, \"finishWrite\", Finish<WriteWrap>);\n   env->SetProtoMethod(t, \"finishShutdown\", Finish<ShutdownWrap>);"
        },
        {
            "sha": "f4f5b263a6567bfa9c42e2ae255a861e3afbe1cb",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -2250,7 +2250,7 @@ void Initialize(Local<Object> target,\n   // Create FunctionTemplate for FSReqCallback\n   Local<FunctionTemplate> fst = env->NewFunctionTemplate(NewFSReqCallback);\n   fst->InstanceTemplate()->SetInternalFieldCount(1);\n-  AsyncWrap::AddWrapMethods(env, fst);\n+  fst->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> wrapString =\n       FIXED_ONE_BYTE_STRING(isolate, \"FSReqCallback\");\n   fst->SetClassName(wrapString);\n@@ -2263,7 +2263,7 @@ void Initialize(Local<Object> target,\n   // to do anything in the constructor, so we only store the instance template.\n   Local<FunctionTemplate> fh_rw = FunctionTemplate::New(isolate);\n   fh_rw->InstanceTemplate()->SetInternalFieldCount(1);\n-  AsyncWrap::AddWrapMethods(env, fh_rw);\n+  fh_rw->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> fhWrapString =\n       FIXED_ONE_BYTE_STRING(isolate, \"FileHandleReqWrap\");\n   fh_rw->SetClassName(fhWrapString);\n@@ -2272,7 +2272,7 @@ void Initialize(Local<Object> target,\n \n   // Create Function Template for FSReqPromise\n   Local<FunctionTemplate> fpt = FunctionTemplate::New(isolate);\n-  AsyncWrap::AddWrapMethods(env, fpt);\n+  fpt->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> promiseString =\n       FIXED_ONE_BYTE_STRING(isolate, \"FSReqPromise\");\n   fpt->SetClassName(promiseString);\n@@ -2282,7 +2282,7 @@ void Initialize(Local<Object> target,\n \n   // Create FunctionTemplate for FileHandle\n   Local<FunctionTemplate> fd = env->NewFunctionTemplate(FileHandle::New);\n-  AsyncWrap::AddWrapMethods(env, fd);\n+  fd->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   env->SetProtoMethod(fd, \"close\", FileHandle::Close);\n   env->SetProtoMethod(fd, \"releaseFD\", FileHandle::ReleaseFD);\n   Local<ObjectTemplate> fdt = fd->InstanceTemplate();\n@@ -2301,7 +2301,7 @@ void Initialize(Local<Object> target,\n   Local<FunctionTemplate> fdclose = FunctionTemplate::New(isolate);\n   fdclose->SetClassName(FIXED_ONE_BYTE_STRING(isolate,\n                         \"FileHandleCloseReq\"));\n-  AsyncWrap::AddWrapMethods(env, fdclose);\n+  fdclose->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<ObjectTemplate> fdcloset = fdclose->InstanceTemplate();\n   fdcloset->SetInternalFieldCount(1);\n   env->set_fdclose_constructor_template(fdcloset);"
        },
        {
            "sha": "b95a81e385c23965a3fa6923b45bcd9c8c70a953",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -2960,14 +2960,14 @@ void Initialize(Local<Object> target,\n \n   Local<FunctionTemplate> ping = FunctionTemplate::New(env->isolate());\n   ping->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"Http2Ping\"));\n-  AsyncWrap::AddWrapMethods(env, ping);\n+  ping->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<ObjectTemplate> pingt = ping->InstanceTemplate();\n   pingt->SetInternalFieldCount(1);\n   env->set_http2ping_constructor_template(pingt);\n \n   Local<FunctionTemplate> setting = FunctionTemplate::New(env->isolate());\n   setting->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"Http2Setting\"));\n-  AsyncWrap::AddWrapMethods(env, setting);\n+  setting->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<ObjectTemplate> settingt = setting->InstanceTemplate();\n   settingt->SetInternalFieldCount(1);\n   env->set_http2settings_constructor_template(settingt);\n@@ -2984,7 +2984,7 @@ void Initialize(Local<Object> target,\n   env->SetProtoMethod(stream, \"respond\", Http2Stream::Respond);\n   env->SetProtoMethod(stream, \"rstStream\", Http2Stream::RstStream);\n   env->SetProtoMethod(stream, \"refreshState\", Http2Stream::RefreshState);\n-  AsyncWrap::AddWrapMethods(env, stream);\n+  stream->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   StreamBase::AddMethods<Http2Stream>(env, stream);\n   Local<ObjectTemplate> streamt = stream->InstanceTemplate();\n   streamt->SetInternalFieldCount(1);\n@@ -2997,7 +2997,7 @@ void Initialize(Local<Object> target,\n       env->NewFunctionTemplate(Http2Session::New);\n   session->SetClassName(http2SessionClassName);\n   session->InstanceTemplate()->SetInternalFieldCount(1);\n-  AsyncWrap::AddWrapMethods(env, session);\n+  session->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   env->SetProtoMethod(session, \"origin\", Http2Session::Origin);\n   env->SetProtoMethod(session, \"altsvc\", Http2Session::AltSvc);\n   env->SetProtoMethod(session, \"ping\", Http2Session::Ping);"
        },
        {
            "sha": "dcaf3d211aee4e9e8c104a7e3b4f6fe456eedc09",
            "filename": "src/node_http_parser.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_http_parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_http_parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http_parser.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -763,7 +763,7 @@ void Initialize(Local<Object> target,\n #undef V\n   target->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"methods\"), methods);\n \n-  AsyncWrap::AddWrapMethods(env, t);\n+  t->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   env->SetProtoMethod(t, \"close\", Parser::Close);\n   env->SetProtoMethod(t, \"free\", Parser::Free);\n   env->SetProtoMethod(t, \"execute\", Parser::Execute);"
        },
        {
            "sha": "0a79d6f9d3d36a8b7619abb8375266b99e0cfa46",
            "filename": "src/node_messaging.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_messaging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_messaging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -722,9 +722,7 @@ MaybeLocal<Function> GetMessagePortConstructor(\n     Local<FunctionTemplate> m = env->NewFunctionTemplate(MessagePort::New);\n     m->SetClassName(env->message_port_constructor_string());\n     m->InstanceTemplate()->SetInternalFieldCount(1);\n-\n-    AsyncWrap::AddWrapMethods(env, m);\n-    HandleWrap::AddWrapMethods(env, m);\n+    m->Inherit(HandleWrap::GetConstructorTemplate(env));\n \n     env->SetProtoMethod(m, \"postMessage\", MessagePort::PostMessage);\n     env->SetProtoMethod(m, \"start\", MessagePort::Start);"
        },
        {
            "sha": "ca0927af66220031ce96350fb1dce9dd4cc79bca",
            "filename": "src/node_stat_watcher.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_stat_watcher.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_stat_watcher.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_stat_watcher.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -50,9 +50,7 @@ void StatWatcher::Initialize(Environment* env, Local<Object> target) {\n   Local<String> statWatcherString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"StatWatcher\");\n   t->SetClassName(statWatcherString);\n-\n-  AsyncWrap::AddWrapMethods(env, t);\n-  HandleWrap::AddWrapMethods(env, t);\n+  t->Inherit(HandleWrap::GetConstructorTemplate(env));\n \n   env->SetProtoMethod(t, \"start\", StatWatcher::Start);\n "
        },
        {
            "sha": "63d89a966d14ff2a6f7e0abc172bd5849d2f157e",
            "filename": "src/node_worker.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_worker.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_worker.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -482,8 +482,8 @@ void InitWorker(Local<Object> target,\n     Local<FunctionTemplate> w = env->NewFunctionTemplate(Worker::New);\n \n     w->InstanceTemplate()->SetInternalFieldCount(1);\n+    w->Inherit(AsyncWrap::GetConstructorTemplate(env));\n \n-    AsyncWrap::AddWrapMethods(env, w);\n     env->SetProtoMethod(w, \"startThread\", Worker::StartThread);\n     env->SetProtoMethod(w, \"stopThread\", Worker::StopThread);\n     env->SetProtoMethod(w, \"ref\", Worker::Ref);"
        },
        {
            "sha": "42caca2dc6452d725ba31e87beabea422dae7c18",
            "filename": "src/node_wrap.h",
            "status": "removed",
            "additions": 0,
            "deletions": 72,
            "changes": 72,
            "blob_url": "https://github.com/nodejs/node/blob/2ebdba12297348649620e3d302b156c149d85a6e/src%2Fnode_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/2ebdba12297348649620e3d302b156c149d85a6e/src%2Fnode_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_wrap.h?ref=2ebdba12297348649620e3d302b156c149d85a6e",
            "patch": "@@ -1,72 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-#ifndef SRC_NODE_WRAP_H_\n-#define SRC_NODE_WRAP_H_\n-\n-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n-\n-#include \"env.h\"\n-#include \"pipe_wrap.h\"\n-#include \"tcp_wrap.h\"\n-#include \"tty_wrap.h\"\n-#include \"uv.h\"\n-#include \"v8.h\"\n-\n-namespace node {\n-\n-// TODO(addaleax): Use real inheritance for the JS object templates to avoid\n-// this unnecessary case switching.\n-#define WITH_GENERIC_UV_STREAM(env, obj, BODY)                                \\\n-    do {                                                                      \\\n-      if (env->tcp_constructor_template().IsEmpty() == false &&               \\\n-          env->tcp_constructor_template()->HasInstance(obj)) {                \\\n-        TCPWrap* const wrap = Unwrap<TCPWrap>(obj);                           \\\n-        BODY                                                                  \\\n-      } else if (env->tty_constructor_template().IsEmpty() == false &&        \\\n-                 env->tty_constructor_template()->HasInstance(obj)) {         \\\n-        TTYWrap* const wrap = Unwrap<TTYWrap>(obj);                           \\\n-        BODY                                                                  \\\n-      } else if (env->pipe_constructor_template().IsEmpty() == false &&       \\\n-                 env->pipe_constructor_template()->HasInstance(obj)) {        \\\n-        PipeWrap* const wrap = Unwrap<PipeWrap>(obj);                         \\\n-        BODY                                                                  \\\n-      }                                                                       \\\n-    } while (0)\n-\n-inline uv_stream_t* HandleToStream(Environment* env,\n-                                   v8::Local<v8::Object> obj) {\n-  v8::HandleScope scope(env->isolate());\n-\n-  WITH_GENERIC_UV_STREAM(env, obj, {\n-    if (wrap == nullptr)\n-      return nullptr;\n-    return reinterpret_cast<uv_stream_t*>(wrap->UVHandle());\n-  });\n-\n-  return nullptr;\n-}\n-\n-}  // namespace node\n-\n-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n-\n-#endif  // SRC_NODE_WRAP_H_"
        },
        {
            "sha": "93dcf0122d2fa7d87eb0a61105e7be19b5691e32",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -755,8 +755,8 @@ void Initialize(Local<Object> target,\n   Local<FunctionTemplate> z = env->NewFunctionTemplate(ZCtx::New);\n \n   z->InstanceTemplate()->SetInternalFieldCount(1);\n+  z->Inherit(AsyncWrap::GetConstructorTemplate(env));\n \n-  AsyncWrap::AddWrapMethods(env, z);\n   env->SetProtoMethod(z, \"write\", ZCtx::Write<true>);\n   env->SetProtoMethod(z, \"writeSync\", ZCtx::Write<false>);\n   env->SetProtoMethod(z, \"init\", ZCtx::Init);"
        },
        {
            "sha": "eb1e06876c2d86a7471ba5d9b45b7e72f29e14c7",
            "filename": "src/pipe_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fpipe_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fpipe_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fpipe_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -28,7 +28,6 @@\n #include \"node.h\"\n #include \"node_buffer.h\"\n #include \"node_internals.h\"\n-#include \"node_wrap.h\"\n #include \"connect_wrap.h\"\n #include \"stream_base-inl.h\"\n #include \"stream_wrap.h\"\n@@ -78,9 +77,7 @@ void PipeWrap::Initialize(Local<Object> target,\n   t->SetClassName(pipeString);\n   t->InstanceTemplate()->SetInternalFieldCount(1);\n \n-  AsyncWrap::AddWrapMethods(env, t);\n-  HandleWrap::AddWrapMethods(env, t);\n-  LibuvStreamWrap::AddMethods(env, t);\n+  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));\n \n   env->SetProtoMethod(t, \"bind\", Bind);\n   env->SetProtoMethod(t, \"listen\", Listen);\n@@ -98,7 +95,7 @@ void PipeWrap::Initialize(Local<Object> target,\n \n   // Create FunctionTemplate for PipeConnectWrap.\n   auto cwt = BaseObject::MakeLazilyInitializedJSTemplate(env);\n-  AsyncWrap::AddWrapMethods(env, cwt);\n+  cwt->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> wrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"PipeConnectWrap\");\n   cwt->SetClassName(wrapString);"
        },
        {
            "sha": "af6cbfb4e5991bb4745cb861c0447e2fe6c9da1a",
            "filename": "src/process_wrap.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 18,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fprocess_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fprocess_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fprocess_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -20,10 +20,9 @@\n // USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n #include \"env-inl.h\"\n-#include \"handle_wrap.h\"\n #include \"node_internals.h\"\n-#include \"node_wrap.h\"\n #include \"stream_base-inl.h\"\n+#include \"stream_wrap.h\"\n #include \"util-inl.h\"\n \n #include <string.h>\n@@ -58,8 +57,7 @@ class ProcessWrap : public HandleWrap {\n         FIXED_ONE_BYTE_STRING(env->isolate(), \"Process\");\n     constructor->SetClassName(processString);\n \n-    AsyncWrap::AddWrapMethods(env, constructor);\n-    HandleWrap::AddWrapMethods(env, constructor);\n+    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));\n \n     env->SetProtoMethod(constructor, \"spawn\", Spawn);\n     env->SetProtoMethod(constructor, \"kill\", Kill);\n@@ -92,6 +90,17 @@ class ProcessWrap : public HandleWrap {\n     MarkAsUninitialized();\n   }\n \n+  static uv_stream_t* StreamForWrap(Environment* env, Local<Object> stdio) {\n+    Local<String> handle_key = env->handle_string();\n+    // This property has always been set by JS land if we are in this code path.\n+    Local<Object> handle =\n+        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();\n+\n+    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();\n+    CHECK_NOT_NULL(stream);\n+    return stream;\n+  }\n+\n   static void ParseStdioOptions(Environment* env,\n                                 Local<Object> js_options,\n                                 uv_process_options_t* options) {\n@@ -115,22 +124,10 @@ class ProcessWrap : public HandleWrap {\n       } else if (type->StrictEquals(env->pipe_string())) {\n         options->stdio[i].flags = static_cast<uv_stdio_flags>(\n             UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE);\n-        Local<String> handle_key = env->handle_string();\n-        Local<Object> handle =\n-            stdio->Get(context, handle_key).ToLocalChecked().As<Object>();\n-        CHECK(!handle.IsEmpty());\n-        options->stdio[i].data.stream =\n-            reinterpret_cast<uv_stream_t*>(\n-                Unwrap<PipeWrap>(handle)->UVHandle());\n+        options->stdio[i].data.stream = StreamForWrap(env, stdio);\n       } else if (type->StrictEquals(env->wrap_string())) {\n-        Local<String> handle_key = env->handle_string();\n-        Local<Object> handle =\n-            stdio->Get(context, handle_key).ToLocalChecked().As<Object>();\n-        uv_stream_t* stream = HandleToStream(env, handle);\n-        CHECK_NOT_NULL(stream);\n-\n         options->stdio[i].flags = UV_INHERIT_STREAM;\n-        options->stdio[i].data.stream = stream;\n+        options->stdio[i].data.stream = StreamForWrap(env, stdio);\n       } else {\n         Local<String> fd_key = env->fd_string();\n         Local<Value> fd_value = stdio->Get(context, fd_key).ToLocalChecked();"
        },
        {
            "sha": "e1792a0267af749e65b6005d54976d8647a54268",
            "filename": "src/signal_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fsignal_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fsignal_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fsignal_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -50,9 +50,7 @@ class SignalWrap : public HandleWrap {\n     Local<String> signalString =\n         FIXED_ONE_BYTE_STRING(env->isolate(), \"Signal\");\n     constructor->SetClassName(signalString);\n-\n-    AsyncWrap::AddWrapMethods(env, constructor);\n-    HandleWrap::AddWrapMethods(env, constructor);\n+    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));\n \n     env->SetProtoMethod(constructor, \"start\", Start);\n     env->SetProtoMethod(constructor, \"stop\", Stop);"
        },
        {
            "sha": "0b00f225d8ad7b94c27073c950d6812fc674f4d1",
            "filename": "src/stream_pipe.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fstream_pipe.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fstream_pipe.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -257,7 +257,7 @@ void InitializeStreamPipe(Local<Object> target,\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"StreamPipe\");\n   env->SetProtoMethod(pipe, \"unpipe\", StreamPipe::Unpipe);\n   env->SetProtoMethod(pipe, \"start\", StreamPipe::Start);\n-  AsyncWrap::AddWrapMethods(env, pipe);\n+  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   pipe->SetClassName(stream_pipe_string);\n   pipe->InstanceTemplate()->SetInternalFieldCount(1);\n   target"
        },
        {
            "sha": "9ccace435c6796030c469279f37e7b1684f79d80",
            "filename": "src/stream_wrap.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 25,
            "changes": 70,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fstream_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fstream_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -66,7 +66,7 @@ void LibuvStreamWrap::Initialize(Local<Object> target,\n   Local<String> wrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"ShutdownWrap\");\n   sw->SetClassName(wrapString);\n-  AsyncWrap::AddWrapMethods(env, sw);\n+  sw->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   target->Set(wrapString, sw->GetFunction(env->context()).ToLocalChecked());\n   env->set_shutdown_wrap_template(sw->InstanceTemplate());\n \n@@ -76,7 +76,7 @@ void LibuvStreamWrap::Initialize(Local<Object> target,\n   Local<String> writeWrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"WriteWrap\");\n   ww->SetClassName(writeWrapString);\n-  AsyncWrap::AddWrapMethods(env, ww);\n+  ww->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   target->Set(writeWrapString,\n               ww->GetFunction(env->context()).ToLocalChecked());\n   env->set_write_wrap_template(ww->InstanceTemplate());\n@@ -96,20 +96,36 @@ LibuvStreamWrap::LibuvStreamWrap(Environment* env,\n }\n \n \n-void LibuvStreamWrap::AddMethods(Environment* env,\n-                                 v8::Local<v8::FunctionTemplate> target) {\n-  Local<FunctionTemplate> get_write_queue_size =\n-      FunctionTemplate::New(env->isolate(),\n-                            GetWriteQueueSize,\n-                            env->as_external(),\n-                            Signature::New(env->isolate(), target));\n-  target->PrototypeTemplate()->SetAccessorProperty(\n-      env->write_queue_size_string(),\n-      get_write_queue_size,\n-      Local<FunctionTemplate>(),\n-      static_cast<PropertyAttribute>(ReadOnly | DontDelete));\n-  env->SetProtoMethod(target, \"setBlocking\", SetBlocking);\n-  StreamBase::AddMethods<LibuvStreamWrap>(env, target);\n+Local<FunctionTemplate> LibuvStreamWrap::GetConstructorTemplate(\n+    Environment* env) {\n+  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();\n+  if (tmpl.IsEmpty()) {\n+    tmpl = env->NewFunctionTemplate(nullptr);\n+    tmpl->SetClassName(\n+        FIXED_ONE_BYTE_STRING(env->isolate(), \"LibuvStreamWrap\"));\n+    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));\n+    Local<FunctionTemplate> get_write_queue_size =\n+        FunctionTemplate::New(env->isolate(),\n+                              GetWriteQueueSize,\n+                              env->as_external(),\n+                              Signature::New(env->isolate(), tmpl));\n+    tmpl->PrototypeTemplate()->SetAccessorProperty(\n+        env->write_queue_size_string(),\n+        get_write_queue_size,\n+        Local<FunctionTemplate>(),\n+        static_cast<PropertyAttribute>(ReadOnly | DontDelete));\n+    env->SetProtoMethod(tmpl, \"setBlocking\", SetBlocking);\n+    StreamBase::AddMethods<LibuvStreamWrap>(env, tmpl);\n+    env->set_libuv_stream_wrap_ctor_template(tmpl);\n+  }\n+  return tmpl;\n+}\n+\n+\n+LibuvStreamWrap* LibuvStreamWrap::From(Environment* env, Local<Object> object) {\n+  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();\n+  CHECK(!sw.IsEmpty() && sw->HasInstance(object));\n+  return Unwrap<LibuvStreamWrap>(object);\n }\n \n \n@@ -170,21 +186,25 @@ void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) {\n \n \n \n-template <class WrapType, class UVType>\n+template <class WrapType>\n static Local<Object> AcceptHandle(Environment* env, LibuvStreamWrap* parent) {\n+  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||\n+                std::is_base_of<UDPWrap, WrapType>::value,\n+                \"Can only accept stream handles\");\n+\n   EscapableHandleScope scope(env->isolate());\n   Local<Object> wrap_obj;\n-  UVType* handle;\n \n   wrap_obj = WrapType::Instantiate(env, parent, WrapType::SOCKET);\n   if (wrap_obj.IsEmpty())\n     return Local<Object>();\n \n-  WrapType* wrap;\n-  ASSIGN_OR_RETURN_UNWRAP(&wrap, wrap_obj, Local<Object>());\n-  handle = wrap->UVHandle();\n+  HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj);\n+  CHECK_NOT_NULL(wrap);\n+  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());\n+  CHECK_NOT_NULL(stream);\n \n-  if (uv_accept(parent->stream(), reinterpret_cast<uv_stream_t*>(handle)))\n+  if (uv_accept(parent->stream(), stream))\n     ABORT();\n \n   return scope.Escape(wrap_obj);\n@@ -209,11 +229,11 @@ void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {\n     Local<Object> pending_obj;\n \n     if (type == UV_TCP) {\n-      pending_obj = AcceptHandle<TCPWrap, uv_tcp_t>(env(), this);\n+      pending_obj = AcceptHandle<TCPWrap>(env(), this);\n     } else if (type == UV_NAMED_PIPE) {\n-      pending_obj = AcceptHandle<PipeWrap, uv_pipe_t>(env(), this);\n+      pending_obj = AcceptHandle<PipeWrap>(env(), this);\n     } else if (type == UV_UDP) {\n-      pending_obj = AcceptHandle<UDPWrap, uv_udp_t>(env(), this);\n+      pending_obj = AcceptHandle<UDPWrap>(env(), this);\n     } else {\n       CHECK_EQ(type, UV_UNKNOWN_HANDLE);\n     }"
        },
        {
            "sha": "98f0ca4ac4fb6720aaef093d0daa9457843aa77d",
            "filename": "src/stream_wrap.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fstream_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fstream_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.h?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -76,6 +76,8 @@ class LibuvStreamWrap : public HandleWrap, public StreamBase {\n   ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override;\n   WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override;\n \n+  static LibuvStreamWrap* From(Environment* env, v8::Local<v8::Object> object);\n+\n  protected:\n   LibuvStreamWrap(Environment* env,\n                   v8::Local<v8::Object> object,\n@@ -84,8 +86,8 @@ class LibuvStreamWrap : public HandleWrap, public StreamBase {\n \n   AsyncWrap* GetAsyncWrap() override;\n \n-  static void AddMethods(Environment* env,\n-                         v8::Local<v8::FunctionTemplate> target);\n+  static v8::Local<v8::FunctionTemplate> GetConstructorTemplate(\n+      Environment* env);\n \n  protected:\n   inline void set_fd(int fd) {"
        },
        {
            "sha": "ff30be33635a223e8e80651344f3f0bb2afd7099",
            "filename": "src/tcp_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ftcp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ftcp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftcp_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -88,9 +88,7 @@ void TCPWrap::Initialize(Local<Object> target,\n   t->InstanceTemplate()->Set(env->onread_string(), Null(env->isolate()));\n   t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));\n \n-  AsyncWrap::AddWrapMethods(env, t, AsyncWrap::kFlagHasReset);\n-  HandleWrap::AddWrapMethods(env, t);\n-  LibuvStreamWrap::AddMethods(env, t);\n+  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));\n \n   env->SetProtoMethod(t, \"open\", Open);\n   env->SetProtoMethod(t, \"bind\", Bind);\n@@ -115,7 +113,7 @@ void TCPWrap::Initialize(Local<Object> target,\n   // Create FunctionTemplate for TCPConnectWrap.\n   Local<FunctionTemplate> cwt =\n       BaseObject::MakeLazilyInitializedJSTemplate(env);\n-  AsyncWrap::AddWrapMethods(env, cwt);\n+  cwt->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> wrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"TCPConnectWrap\");\n   cwt->SetClassName(wrapString);"
        },
        {
            "sha": "3462dac8ae0d64b7b0c2cd2583eed4223938fae8",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -891,7 +891,7 @@ void TLSWrap::Initialize(Local<Object> target,\n       Local<FunctionTemplate>(),\n       static_cast<PropertyAttribute>(ReadOnly | DontDelete));\n \n-  AsyncWrap::AddWrapMethods(env, t, AsyncWrap::kFlagHasReset);\n+  t->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   env->SetProtoMethod(t, \"receive\", Receive);\n   env->SetProtoMethod(t, \"start\", Start);\n   env->SetProtoMethod(t, \"setVerifyMode\", SetVerifyMode);"
        },
        {
            "sha": "1d0ea90f36b42c3ae3bbf185381f33dc52a2a731",
            "filename": "src/tty_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ftty_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Ftty_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftty_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -24,7 +24,6 @@\n #include \"env-inl.h\"\n #include \"handle_wrap.h\"\n #include \"node_buffer.h\"\n-#include \"node_wrap.h\"\n #include \"stream_base-inl.h\"\n #include \"stream_wrap.h\"\n #include \"util-inl.h\"\n@@ -52,10 +51,7 @@ void TTYWrap::Initialize(Local<Object> target,\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n   t->SetClassName(ttyString);\n   t->InstanceTemplate()->SetInternalFieldCount(1);\n-\n-  AsyncWrap::AddWrapMethods(env, t);\n-  HandleWrap::AddWrapMethods(env, t);\n-  LibuvStreamWrap::AddMethods(env, t);\n+  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));\n \n   env->SetProtoMethodNoSideEffect(t, \"getWindowSize\", TTYWrap::GetWindowSize);\n   env->SetProtoMethod(t, \"setRawMode\", SetRawMode);"
        },
        {
            "sha": "77139c2f935bf3b3c2d526940e1afdfccf920c00",
            "filename": "src/udp_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fudp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/src%2Fudp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fudp_wrap.cc?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -135,8 +135,7 @@ void UDPWrap::Initialize(Local<Object> target,\n   env->SetProtoMethod(t, \"setTTL\", SetTTL);\n   env->SetProtoMethod(t, \"bufferSize\", BufferSize);\n \n-  AsyncWrap::AddWrapMethods(env, t);\n-  HandleWrap::AddWrapMethods(env, t);\n+  t->Inherit(HandleWrap::GetConstructorTemplate(env));\n \n   target->Set(udpString, t->GetFunction(env->context()).ToLocalChecked());\n   env->set_udp_constructor_function(\n@@ -145,7 +144,7 @@ void UDPWrap::Initialize(Local<Object> target,\n   // Create FunctionTemplate for SendWrap\n   Local<FunctionTemplate> swt =\n       BaseObject::MakeLazilyInitializedJSTemplate(env);\n-  AsyncWrap::AddWrapMethods(env, swt);\n+  swt->Inherit(AsyncWrap::GetConstructorTemplate(env));\n   Local<String> sendWrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"SendWrap\");\n   swt->SetClassName(sendWrapString);"
        },
        {
            "sha": "453100d10886ffbe879531f522a45ac7a8925640",
            "filename": "test/parallel/test-accessor-properties.js",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/d527dde3600655eae7ce0ba5da9263ec4560cd11/test%2Fparallel%2Ftest-accessor-properties.js",
            "raw_url": "https://github.com/nodejs/node/raw/d527dde3600655eae7ce0ba5da9263ec4560cd11/test%2Fparallel%2Ftest-accessor-properties.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-accessor-properties.js?ref=d527dde3600655eae7ce0ba5da9263ec4560cd11",
            "patch": "@@ -32,24 +32,26 @@ const UDP = internalBinding('udp_wrap').UDP;\n     UDP.prototype.fd;\n   }, TypeError);\n \n+  const StreamWrapProto = Object.getPrototypeOf(TTY.prototype);\n+\n   // Should not throw for Object.getOwnPropertyDescriptor\n   assert.strictEqual(\n-    typeof Object.getOwnPropertyDescriptor(TTY.prototype, 'bytesRead'),\n+    typeof Object.getOwnPropertyDescriptor(StreamWrapProto, 'bytesRead'),\n     'object'\n   );\n \n   assert.strictEqual(\n-    typeof Object.getOwnPropertyDescriptor(TTY.prototype, 'fd'),\n+    typeof Object.getOwnPropertyDescriptor(StreamWrapProto, 'fd'),\n     'object'\n   );\n \n   assert.strictEqual(\n-    typeof Object.getOwnPropertyDescriptor(TTY.prototype, '_externalStream'),\n+    typeof Object.getOwnPropertyDescriptor(StreamWrapProto, '_externalStream'),\n     'object'\n   );\n \n   assert.strictEqual(\n-    typeof Object.getOwnPropertyDescriptor(UDP.prototype, 'fd'),\n+    typeof Object.getOwnPropertyDescriptor(StreamWrapProto, 'fd'),\n     'object'\n   );\n }"
        }
    ],
    "stats": {
        "total": 338,
        "additions": 140,
        "deletions": 198
    }
}