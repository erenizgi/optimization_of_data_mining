{
    "author": "tniessen",
    "message": "crypto: handle OpenSSL error queue in CipherBase\n\nThis handles all errors produced by OpenSSL within the CipherBase\nclass. API functions ensure that they do not add any new errors to the\nerror queue. Also adds a couple of CHECKs and throws under certain\nconditions.\n\nPR-URL: https://github.com/nodejs/node/pull/21288\nFixes: https://github.com/nodejs/node/issues/21281\nRefs: https://github.com/nodejs/node/pull/21287\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>",
    "sha": "85b0f1649d07294afea6cfbb3082c18a3dc2079a",
    "files": [
        {
            "sha": "3df00baf659f532535cbad60457e75139b289ca3",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 39,
            "deletions": 18,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/85b0f1649d07294afea6cfbb3082c18a3dc2079a/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/85b0f1649d07294afea6cfbb3082c18a3dc2079a/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=85b0f1649d07294afea6cfbb3082c18a3dc2079a",
            "patch": "@@ -2591,6 +2591,7 @@ void CipherBase::Init(const char* cipher_type,\n                       int key_buf_len,\n                       unsigned int auth_tag_len) {\n   HandleScope scope(env()->isolate());\n+  MarkPopErrorOnReturn mark_pop_error_on_return;\n \n #ifdef NODE_FIPS_MODE\n   if (FIPS_mode()) {\n@@ -2615,6 +2616,7 @@ void CipherBase::Init(const char* cipher_type,\n                                1,\n                                key,\n                                iv);\n+  CHECK_NE(key_len, 0);\n \n   ctx_.reset(EVP_CIPHER_CTX_new());\n \n@@ -2623,7 +2625,11 @@ void CipherBase::Init(const char* cipher_type,\n     EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n \n   const bool encrypt = (kind_ == kCipher);\n-  EVP_CipherInit_ex(ctx_.get(), cipher, nullptr, nullptr, nullptr, encrypt);\n+  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,\n+                             nullptr, nullptr, encrypt)) {\n+    return ThrowCryptoError(env(), ERR_get_error(),\n+                            \"Failed to initialize cipher\");\n+  }\n \n   if (encrypt && (mode == EVP_CIPH_CTR_MODE || mode == EVP_CIPH_GCM_MODE ||\n       mode == EVP_CIPH_CCM_MODE)) {\n@@ -2642,12 +2648,15 @@ void CipherBase::Init(const char* cipher_type,\n \n   CHECK_EQ(1, EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len));\n \n-  EVP_CipherInit_ex(ctx_.get(),\n-                    nullptr,\n-                    nullptr,\n-                    reinterpret_cast<unsigned char*>(key),\n-                    reinterpret_cast<unsigned char*>(iv),\n-                    encrypt);\n+  if (1 != EVP_CipherInit_ex(ctx_.get(),\n+                             nullptr,\n+                             nullptr,\n+                             reinterpret_cast<unsigned char*>(key),\n+                             reinterpret_cast<unsigned char*>(iv),\n+                             encrypt)) {\n+    return ThrowCryptoError(env(), ERR_get_error(),\n+                            \"Failed to initialize cipher\");\n+  }\n }\n \n \n@@ -2682,6 +2691,7 @@ void CipherBase::InitIv(const char* cipher_type,\n                         int iv_len,\n                         unsigned int auth_tag_len) {\n   HandleScope scope(env()->isolate());\n+  MarkPopErrorOnReturn mark_pop_error_on_return;\n \n   const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);\n   if (cipher == nullptr) {\n@@ -2712,7 +2722,11 @@ void CipherBase::InitIv(const char* cipher_type,\n     EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n \n   const bool encrypt = (kind_ == kCipher);\n-  EVP_CipherInit_ex(ctx_.get(), cipher, nullptr, nullptr, nullptr, encrypt);\n+  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,\n+                             nullptr, nullptr, encrypt)) {\n+    return ThrowCryptoError(env(), ERR_get_error(),\n+                            \"Failed to initialize cipher\");\n+  }\n \n   if (IsAuthenticatedMode()) {\n     CHECK(has_iv);\n@@ -2725,12 +2739,15 @@ void CipherBase::InitIv(const char* cipher_type,\n     return env()->ThrowError(\"Invalid key length\");\n   }\n \n-  EVP_CipherInit_ex(ctx_.get(),\n-                    nullptr,\n-                    nullptr,\n-                    reinterpret_cast<const unsigned char*>(key),\n-                    reinterpret_cast<const unsigned char*>(iv),\n-                    encrypt);\n+  if (1 != EVP_CipherInit_ex(ctx_.get(),\n+                             nullptr,\n+                             nullptr,\n+                             reinterpret_cast<const unsigned char*>(key),\n+                             reinterpret_cast<const unsigned char*>(iv),\n+                             encrypt)) {\n+    return ThrowCryptoError(env(), ERR_get_error(),\n+                            \"Failed to initialize cipher\");\n+  }\n }\n \n \n@@ -2775,6 +2792,7 @@ static bool IsValidGCMTagLength(unsigned int tag_len) {\n bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n                                    unsigned int auth_tag_len) {\n   CHECK(IsAuthenticatedMode());\n+  MarkPopErrorOnReturn mark_pop_error_on_return;\n \n   if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),\n                            EVP_CTRL_AEAD_SET_IVLEN,\n@@ -2917,6 +2935,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n bool CipherBase::SetAAD(const char* data, unsigned int len, int plaintext_len) {\n   if (!ctx_ || !IsAuthenticatedMode())\n     return false;\n+  MarkPopErrorOnReturn mark_pop_error_on_return;\n \n   int outlen;\n   const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n@@ -2976,6 +2995,7 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n                                             int* out_len) {\n   if (!ctx_)\n     return kErrorState;\n+  MarkPopErrorOnReturn mark_pop_error_on_return;\n \n   const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n \n@@ -2987,10 +3007,10 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n   // on first update:\n   if (kind_ == kDecipher && IsAuthenticatedMode() && auth_tag_len_ > 0 &&\n       auth_tag_len_ != kNoAuthTagLength && !auth_tag_set_) {\n-    EVP_CIPHER_CTX_ctrl(ctx_.get(),\n-                        EVP_CTRL_GCM_SET_TAG,\n-                        auth_tag_len_,\n-                        reinterpret_cast<unsigned char*>(auth_tag_));\n+    CHECK(EVP_CIPHER_CTX_ctrl(ctx_.get(),\n+                              EVP_CTRL_GCM_SET_TAG,\n+                              auth_tag_len_,\n+                              reinterpret_cast<unsigned char*>(auth_tag_)));\n     auth_tag_set_ = true;\n   }\n \n@@ -3068,6 +3088,7 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {\n bool CipherBase::SetAutoPadding(bool auto_padding) {\n   if (!ctx_)\n     return false;\n+  MarkPopErrorOnReturn mark_pop_error_on_return;\n   return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);\n }\n "
        }
    ],
    "stats": {
        "total": 57,
        "additions": 39,
        "deletions": 18
    }
}