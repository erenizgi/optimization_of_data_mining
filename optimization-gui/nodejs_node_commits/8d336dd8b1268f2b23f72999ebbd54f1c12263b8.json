{
    "author": "Trott",
    "message": "doc: improve text in async_hooks.md\n\n* Remove unnecessary *Note:* designations.\n* Various small edits for tone, punctuation, etc.\n\nPR-URL: https://github.com/nodejs/node/pull/19312\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "8d336dd8b1268f2b23f72999ebbd54f1c12263b8",
    "files": [
        {
            "sha": "fdbcbe51f98f17dfaa49cd09d721bd801ad9f77d",
            "filename": "doc/api/async_hooks.md",
            "status": "modified",
            "additions": 16,
            "deletions": 18,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/8d336dd8b1268f2b23f72999ebbd54f1c12263b8/doc%2Fapi%2Fasync_hooks.md",
            "raw_url": "https://github.com/nodejs/node/raw/8d336dd8b1268f2b23f72999ebbd54f1c12263b8/doc%2Fapi%2Fasync_hooks.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fasync_hooks.md?ref=8d336dd8b1268f2b23f72999ebbd54f1c12263b8",
            "patch": "@@ -246,9 +246,9 @@ instances and asynchronous work scheduled by them.\n \n Users are able to define their own `type` when using the public embedder API.\n \n-*Note:* It is possible to have type name collisions. Embedders are encouraged\n-to use unique prefixes, such as the npm package name, to prevent collisions\n-when listening to the hooks.\n+It is possible to have type name collisions. Embedders are encouraged to use\n+unique prefixes, such as the npm package name, to prevent collisions when\n+listening to the hooks.\n \n ###### `triggerId`\n \n@@ -282,10 +282,10 @@ TCPWRAP(4): trigger: 2 execution: 0\n The `TCPSERVERWRAP` is the server which receives the connections.\n \n The `TCPWRAP` is the new connection from the client. When a new\n-connection is made the `TCPWrap` instance is immediately constructed. This\n-happens outside of any JavaScript stack (side note: a `executionAsyncId()` of\n-`0` means it's being executed from C++, with no JavaScript stack above it).\n-With only that information, it would be impossible to link resources together in\n+connection is made, the `TCPWrap` instance is immediately constructed. This\n+happens outside of any JavaScript stack. (An `executionAsyncId()` of `0` means\n+that it is being executed from C++ with no JavaScript stack above it). With only\n+that information, it would be impossible to link resources together in\n terms of what caused them to be created, so `triggerAsyncId` is given the task\n of propagating what resource is responsible for the new resource's existence.\n \n@@ -420,9 +420,9 @@ it only once.\n \n Called immediately after the callback specified in `before` is completed.\n \n-*Note:* If an uncaught exception occurs during execution of the callback, then\n-`after` will run *after* the `'uncaughtException'` event is emitted or a\n-`domain`'s handler runs.\n+If an uncaught exception occurs during execution of the callback, then `after`\n+will run *after* the `'uncaughtException'` event is emitted or a `domain`'s\n+handler runs.\n \n \n ##### `destroy(asyncId)`\n@@ -432,11 +432,10 @@ Called immediately after the callback specified in `before` is completed.\n Called after the resource corresponding to `asyncId` is destroyed. It is also\n called asynchronously from the embedder API `emitDestroy()`.\n \n-*Note:* Some resources depend on garbage collection for cleanup, so if a\n-reference is made to the `resource` object passed to `init` it is possible that\n-`destroy` will never be called, causing a memory leak in the application. If\n-the resource does not depend on garbage collection, then this will not be an\n-issue.\n+Some resources depend on garbage collection for cleanup, so if a reference is\n+made to the `resource` object passed to `init` it is possible that `destroy`\n+will never be called, causing a memory leak in the application. If the resource\n+does not depend on garbage collection, then this will not be an issue.\n \n ##### `promiseResolve(asyncId)`\n \n@@ -447,9 +446,8 @@ invoked (either directly or through other means of resolving a promise).\n \n Note that `resolve()` does not do any observable synchronous work.\n \n-*Note:* This does not necessarily mean that the `Promise` is fulfilled or\n-rejected at this point, if the `Promise` was resolved by assuming the state\n-of another `Promise`.\n+The `Promise` is not necessarily fulfilled or rejected at this point if the\n+`Promise` was resolved by assuming the state of another `Promise`.\n \n ```js\n new Promise((resolve) => resolve(true)).then((a) => {});"
        }
    ],
    "stats": {
        "total": 34,
        "additions": 16,
        "deletions": 18
    }
}