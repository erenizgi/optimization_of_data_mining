{
    "author": "addaleax",
    "message": "zlib: add brotli support\n\nRefs: https://github.com/nodejs/node/pull/20458\n\nCo-authored-by: Hackzzila <admin@hackzzila.com>\n\nPR-URL: https://github.com/nodejs/node/pull/24938\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Jan Krems <jan.krems@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Myles Borins <myles.borins@gmail.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "73753d48639200f79957b822599e9848b0ac942f",
    "files": [
        {
            "sha": "9d6f438508d66cc243566ea5e0a46cfb0cbb33c8",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -624,6 +624,16 @@ An attempt was made to register something that is not a function as an\n The type of an asynchronous resource was invalid. Note that users are also able\n to define their own types if using the public embedder API.\n \n+<a id=\"ERR_BROTLI_INVALID_PARAM\"></a>\n+### ERR_BROTLI_INVALID_PARAM\n+\n+An invalid parameter key was passed during construction of a Brotli stream.\n+\n+<a id=\"ERR_BROTLI_COMPRESSION_FAILED\">\n+### ERR_BROTLI_COMPRESSION_FAILED\n+\n+Data passed to a Brotli stream was not successfully compressed.\n+\n <a id=\"ERR_BUFFER_CONTEXT_NOT_AVAILABLE\"></a>\n ### ERR_BUFFER_CONTEXT_NOT_AVAILABLE\n "
        },
        {
            "sha": "700277630054a65d25e545a190e5c9607b1f83f9",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -546,6 +546,7 @@ E('ERR_ARG_NOT_ITERABLE', '%s must be iterable', TypeError);\n E('ERR_ASSERTION', '%s', Error);\n E('ERR_ASYNC_CALLBACK', '%s must be a function', TypeError);\n E('ERR_ASYNC_TYPE', 'Invalid name for async \"type\": %s', TypeError);\n+E('ERR_BROTLI_INVALID_PARAM', '%s is not a valid Brotli parameter', RangeError);\n E('ERR_BUFFER_OUT_OF_BOUNDS',\n   // Using a default argument here is important so the argument is not counted\n   // towards `Function#length`."
        },
        {
            "sha": "5bb7f8bfcb0970b25ad1efab1ccf935961cbd7f9",
            "filename": "lib/zlib.js",
            "status": "modified",
            "additions": 89,
            "deletions": 5,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/lib%2Fzlib.js",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/lib%2Fzlib.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fzlib.js?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -22,10 +22,11 @@\n 'use strict';\n \n const {\n+  ERR_BROTLI_INVALID_PARAM,\n   ERR_BUFFER_TOO_LARGE,\n   ERR_INVALID_ARG_TYPE,\n   ERR_OUT_OF_RANGE,\n-  ERR_ZLIB_INITIALIZATION_FAILED\n+  ERR_ZLIB_INITIALIZATION_FAILED,\n } = require('internal/errors').codes;\n const Transform = require('_stream_transform');\n const {\n@@ -45,11 +46,18 @@ const { owner_symbol } = require('internal/async_hooks').symbols;\n \n const constants = internalBinding('constants').zlib;\n const {\n+  // Zlib flush levels\n   Z_NO_FLUSH, Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,\n+  // Zlib option values\n   Z_MIN_CHUNK, Z_MIN_WINDOWBITS, Z_MAX_WINDOWBITS, Z_MIN_LEVEL, Z_MAX_LEVEL,\n   Z_MIN_MEMLEVEL, Z_MAX_MEMLEVEL, Z_DEFAULT_CHUNK, Z_DEFAULT_COMPRESSION,\n   Z_DEFAULT_STRATEGY, Z_DEFAULT_WINDOWBITS, Z_DEFAULT_MEMLEVEL, Z_FIXED,\n-  DEFLATE, DEFLATERAW, INFLATE, INFLATERAW, GZIP, GUNZIP, UNZIP\n+  // Node's compression stream modes (node_zlib_mode)\n+  DEFLATE, DEFLATERAW, INFLATE, INFLATERAW, GZIP, GUNZIP, UNZIP,\n+  BROTLI_DECODE, BROTLI_ENCODE,\n+  // Brotli operations (~flush levels)\n+  BROTLI_OPERATION_PROCESS, BROTLI_OPERATION_FLUSH,\n+  BROTLI_OPERATION_FINISH\n } = constants;\n \n // translation table for return codes.\n@@ -212,7 +220,7 @@ function ZlibBase(opts, mode, handle, { flush, finishFlush, fullFlush }) {\n   // The ZlibBase class is not exported to user land, the mode should only be\n   // passed in by us.\n   assert(typeof mode === 'number');\n-  assert(mode >= DEFLATE && mode <= UNZIP);\n+  assert(mode >= DEFLATE && mode <= BROTLI_ENCODE);\n \n   if (opts) {\n     chunkSize = opts.chunkSize;\n@@ -481,7 +489,7 @@ function processCallback() {\n   // important to null out the values once they are no longer needed since\n   // `_handle` can stay in memory long after the buffer is needed.\n   var handle = this;\n-  var self = this.jsref;\n+  var self = this[owner_symbol];\n   var state = self._writeState;\n \n   if (self._hadError) {\n@@ -622,6 +630,9 @@ function Zlib(opts, mode) {\n                    this._writeState,\n                    processCallback,\n                    dictionary)) {\n+    // TODO(addaleax): Sometimes we generate better error codes in C++ land,\n+    // e.g. ERR_BROTLI_PARAM_SET_FAILED -- it's hard to access them with\n+    // the current bindings setup, though.\n     throw new ERR_ZLIB_INITIALIZATION_FAILED();\n   }\n \n@@ -734,6 +745,70 @@ function createConvenienceMethod(ctor, sync) {\n   }\n }\n \n+const kMaxBrotliParam = Math.max(...Object.keys(constants).map((key) => {\n+  return key.startsWith('BROTLI_PARAM_') ? constants[key] : 0;\n+}));\n+\n+const brotliInitParamsArray = new Uint32Array(kMaxBrotliParam + 1);\n+\n+const brotliDefaultOpts = {\n+  flush: BROTLI_OPERATION_PROCESS,\n+  finishFlush: BROTLI_OPERATION_FINISH,\n+  fullFlush: BROTLI_OPERATION_FLUSH\n+};\n+function Brotli(opts, mode) {\n+  assert(mode === BROTLI_DECODE || mode === BROTLI_ENCODE);\n+\n+  brotliInitParamsArray.fill(-1);\n+  if (opts && opts.params) {\n+    for (const origKey of Object.keys(opts.params)) {\n+      const key = +origKey;\n+      if (Number.isNaN(key) || key < 0 || key > kMaxBrotliParam ||\n+          (brotliInitParamsArray[key] | 0) !== -1) {\n+        throw new ERR_BROTLI_INVALID_PARAM(origKey);\n+      }\n+\n+      const value = opts.params[origKey];\n+      if (typeof value !== 'number' && typeof value !== 'boolean') {\n+        throw new ERR_INVALID_ARG_TYPE('options.params[key]',\n+                                       'number', opts.params[origKey]);\n+      }\n+      brotliInitParamsArray[key] = value;\n+    }\n+  }\n+\n+  const handle = mode === BROTLI_DECODE ?\n+    new binding.BrotliDecoder(mode) : new binding.BrotliEncoder(mode);\n+\n+  this._writeState = new Uint32Array(2);\n+  if (!handle.init(brotliInitParamsArray,\n+                   this._writeState,\n+                   processCallback)) {\n+    throw new ERR_ZLIB_INITIALIZATION_FAILED();\n+  }\n+\n+  ZlibBase.call(this, opts, mode, handle, brotliDefaultOpts);\n+}\n+Object.setPrototypeOf(Brotli.prototype, Zlib.prototype);\n+Object.setPrototypeOf(Brotli, Zlib);\n+\n+function BrotliCompress(opts) {\n+  if (!(this instanceof BrotliCompress))\n+    return new BrotliCompress(opts);\n+  Brotli.call(this, opts, BROTLI_ENCODE);\n+}\n+Object.setPrototypeOf(BrotliCompress.prototype, Brotli.prototype);\n+Object.setPrototypeOf(BrotliCompress, Brotli);\n+\n+function BrotliDecompress(opts) {\n+  if (!(this instanceof BrotliDecompress))\n+    return new BrotliDecompress(opts);\n+  Brotli.call(this, opts, BROTLI_DECODE);\n+}\n+Object.setPrototypeOf(BrotliDecompress.prototype, Brotli.prototype);\n+Object.setPrototypeOf(BrotliDecompress, Brotli);\n+\n+\n function createProperty(ctor) {\n   return {\n     configurable: true,\n@@ -759,6 +834,8 @@ module.exports = {\n   DeflateRaw,\n   InflateRaw,\n   Unzip,\n+  BrotliCompress,\n+  BrotliDecompress,\n \n   // Convenience methods.\n   // compress/decompress a string or buffer in one step.\n@@ -775,7 +852,11 @@ module.exports = {\n   gunzip: createConvenienceMethod(Gunzip, false),\n   gunzipSync: createConvenienceMethod(Gunzip, true),\n   inflateRaw: createConvenienceMethod(InflateRaw, false),\n-  inflateRawSync: createConvenienceMethod(InflateRaw, true)\n+  inflateRawSync: createConvenienceMethod(InflateRaw, true),\n+  brotliCompress: createConvenienceMethod(BrotliCompress, false),\n+  brotliCompressSync: createConvenienceMethod(BrotliCompress, true),\n+  brotliDecompress: createConvenienceMethod(BrotliDecompress, false),\n+  brotliDecompressSync: createConvenienceMethod(BrotliDecompress, true),\n };\n \n Object.defineProperties(module.exports, {\n@@ -786,6 +867,8 @@ Object.defineProperties(module.exports, {\n   createGzip: createProperty(Gzip),\n   createGunzip: createProperty(Gunzip),\n   createUnzip: createProperty(Unzip),\n+  createBrotliCompress: createProperty(BrotliCompress),\n+  createBrotliDecompress: createProperty(BrotliDecompress),\n   constants: {\n     configurable: false,\n     enumerable: true,\n@@ -803,6 +886,7 @@ Object.defineProperties(module.exports, {\n const bkeys = Object.keys(constants);\n for (var bk = 0; bk < bkeys.length; bk++) {\n   var bkey = bkeys[bk];\n+  if (bkey.startsWith('BROTLI')) continue;\n   Object.defineProperty(module.exports, bkey, {\n     enumerable: false, value: constants[bkey], writable: false\n   });"
        },
        {
            "sha": "a0baf052be74d977195ed07fde5c9fc2396a7d76",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -11,6 +11,7 @@\n     'node_shared%': 'false',\n     'force_dynamic_crt%': 0,\n     'node_module_version%': '',\n+    'node_shared_brotli%': 'false',\n     'node_shared_zlib%': 'false',\n     'node_shared_http_parser%': 'false',\n     'node_shared_cares%': 'false',"
        },
        {
            "sha": "f6787e5ad8f31754c78830e326caf8a6457dd3a0",
            "filename": "node.gypi",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/node.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/node.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gypi?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -208,6 +208,10 @@\n       'dependencies': [ 'deps/nghttp2/nghttp2.gyp:nghttp2' ],\n     }],\n \n+    [ 'node_shared_brotli==\"false\"', {\n+      'dependencies': [ 'deps/brotli/brotli.gyp:brotli' ],\n+    }],\n+\n     [ 'OS==\"mac\"', {\n       # linking Corefoundation is needed since certain OSX debugging tools\n       # like Instruments require it for some features"
        },
        {
            "sha": "3bfed6d4b57ea213b03437cae711b3a78812a21e",
            "filename": "src/node_metadata.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/src%2Fnode_metadata.cc",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/src%2Fnode_metadata.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_metadata.cc?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -1,5 +1,6 @@\n #include \"node_metadata.h\"\n #include \"ares.h\"\n+#include \"brotli/encode.h\"\n #include \"nghttp2/nghttp2ver.h\"\n #include \"node.h\"\n #include \"util.h\"\n@@ -72,6 +73,13 @@ Metadata::Versions::Versions() {\n   llhttp = per_process::llhttp_version;\n   http_parser = per_process::http_parser_version;\n \n+  brotli =\n+    std::to_string(BrotliEncoderVersion() >> 24) +\n+    \".\" +\n+    std::to_string((BrotliEncoderVersion() & 0xFFF000) >> 12) +\n+    \".\" +\n+    std::to_string(BrotliEncoderVersion() & 0xFFF);\n+\n #if HAVE_OPENSSL\n   openssl = GetOpenSSLVersion();\n #endif"
        },
        {
            "sha": "ef93c7b7e41707220977726da70b45052c14c3b1",
            "filename": "src/node_metadata.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/src%2Fnode_metadata.h",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/src%2Fnode_metadata.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_metadata.h?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -12,6 +12,7 @@ namespace node {\n   V(v8)                                                                        \\\n   V(uv)                                                                        \\\n   V(zlib)                                                                      \\\n+  V(brotli)                                                                    \\\n   V(ares)                                                                      \\\n   V(modules)                                                                   \\\n   V(nghttp2)                                                                   \\"
        },
        {
            "sha": "4c65ede612c0aefc4fee385f90e508dff26c6c63",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 424,
            "deletions": 31,
            "changes": 455,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -28,6 +28,9 @@\n #include \"util-inl.h\"\n \n #include \"v8.h\"\n+\n+#include \"brotli/encode.h\"\n+#include \"brotli/decode.h\"\n #include \"zlib.h\"\n \n #include <errno.h>\n@@ -82,7 +85,9 @@ enum node_zlib_mode {\n   GUNZIP,\n   DEFLATERAW,\n   INFLATERAW,\n-  UNZIP\n+  UNZIP,\n+  BROTLI_DECODE,\n+  BROTLI_ENCODE\n };\n \n #define GZIP_HEADER_ID1 0x1f\n@@ -111,13 +116,13 @@ class ZlibContext : public MemoryRetainer {\n   void SetFlush(int flush);\n   void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;\n   CompressionError GetErrorInfo() const;\n+  inline void SetMode(node_zlib_mode mode) { mode_ = mode; }\n+  CompressionError ResetStream();\n \n   // Zlib-specific:\n   CompressionError Init(int level, int window_bits, int mem_level, int strategy,\n                         std::vector<unsigned char>&& dictionary);\n-  inline void SetMode(node_zlib_mode mode) { mode_ = mode; }\n   void SetAllocationFunctions(alloc_func alloc, free_func free, void* opaque);\n-  CompressionError ResetStream();\n   CompressionError SetParams(int level, int strategy);\n \n   SET_MEMORY_INFO_NAME(ZlibContext)\n@@ -146,6 +151,77 @@ class ZlibContext : public MemoryRetainer {\n   DISALLOW_COPY_AND_ASSIGN(ZlibContext);\n };\n \n+// Brotli has different data types for compression and decompression streams,\n+// so some of the specifics are implemented in more specific subclasses\n+class BrotliContext : public MemoryRetainer {\n+ public:\n+  BrotliContext() = default;\n+\n+  void SetBuffers(char* in, uint32_t in_len, char* out, uint32_t out_len);\n+  void SetFlush(int flush);\n+  void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;\n+  inline void SetMode(node_zlib_mode mode) { mode_ = mode; }\n+\n+ protected:\n+  node_zlib_mode mode_ = NONE;\n+  uint8_t* next_in_ = nullptr;\n+  uint8_t* next_out_ = nullptr;\n+  size_t avail_in_ = 0;\n+  size_t avail_out_ = 0;\n+  BrotliEncoderOperation flush_ = BROTLI_OPERATION_PROCESS;\n+  // TODO(addaleax): These should not need to be stored here.\n+  // This is currently only done this way to make implementing ResetStream()\n+  // easier.\n+  brotli_alloc_func alloc_ = nullptr;\n+  brotli_free_func free_ = nullptr;\n+  void* alloc_opaque_ = nullptr;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(BrotliContext);\n+};\n+\n+class BrotliEncoderContext final : public BrotliContext {\n+ public:\n+  void Close();\n+  void DoThreadPoolWork();\n+  CompressionError Init(brotli_alloc_func alloc,\n+                        brotli_free_func free,\n+                        void* opaque);\n+  CompressionError ResetStream();\n+  CompressionError SetParams(int key, uint32_t value);\n+  CompressionError GetErrorInfo() const;\n+\n+  SET_MEMORY_INFO_NAME(BrotliEncoderContext)\n+  SET_SELF_SIZE(BrotliEncoderContext)\n+  SET_NO_MEMORY_INFO()  // state_ is covered through allocation tracking.\n+\n+ private:\n+  bool last_result_ = false;\n+  DeleteFnPtr<BrotliEncoderState, BrotliEncoderDestroyInstance> state_;\n+};\n+\n+class BrotliDecoderContext final : public BrotliContext {\n+ public:\n+  void Close();\n+  void DoThreadPoolWork();\n+  CompressionError Init(brotli_alloc_func alloc,\n+                        brotli_free_func free,\n+                        void* opaque);\n+  CompressionError ResetStream();\n+  CompressionError SetParams(int key, uint32_t value);\n+  CompressionError GetErrorInfo() const;\n+\n+  SET_MEMORY_INFO_NAME(BrotliDecoderContext)\n+  SET_SELF_SIZE(BrotliDecoderContext)\n+  SET_NO_MEMORY_INFO()  // state_ is covered through allocation tracking.\n+\n+ private:\n+  BrotliDecoderResult last_result_ = BROTLI_DECODER_RESULT_SUCCESS;\n+  BrotliDecoderErrorCode error_ = BROTLI_DECODER_NO_ERROR;\n+  std::string error_string_;\n+  DeleteFnPtr<BrotliDecoderState, BrotliDecoderDestroyInstance> state_;\n+};\n+\n template <typename CompressionContext>\n class CompressionStream : public AsyncWrap, public ThreadPoolWork {\n  public:\n@@ -340,6 +416,16 @@ class CompressionStream : public AsyncWrap, public ThreadPoolWork {\n       Close();\n   }\n \n+  static void Reset(const FunctionCallbackInfo<Value> &args) {\n+    CompressionStream* wrap;\n+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n+\n+    AllocScope alloc_scope(wrap);\n+    const CompressionError err = wrap->context()->ResetStream();\n+    if (err.IsError())\n+      wrap->EmitError(err);\n+  }\n+\n   void MemoryInfo(MemoryTracker* tracker) const override {\n     tracker->TrackField(\"compression context\", ctx_);\n     tracker->TrackFieldWithSize(\"zlib_memory\",\n@@ -362,14 +448,19 @@ class CompressionStream : public AsyncWrap, public ThreadPoolWork {\n   // to V8; rather, we first store it as \"unreported\" memory in a separate\n   // field and later report it back from the main thread.\n   static void* AllocForZlib(void* data, uInt items, uInt size) {\n-    CompressionStream* ctx = static_cast<CompressionStream*>(data);\n     size_t real_size =\n         MultiplyWithOverflowCheck(static_cast<size_t>(items),\n-                                  static_cast<size_t>(size)) + sizeof(size_t);\n-    char* memory = UncheckedMalloc(real_size);\n+                                  static_cast<size_t>(size));\n+    return AllocForBrotli(data, real_size);\n+  }\n+\n+  static void* AllocForBrotli(void* data, size_t size) {\n+    size += sizeof(size_t);\n+    CompressionStream* ctx = static_cast<CompressionStream*>(data);\n+    char* memory = UncheckedMalloc(size);\n     if (UNLIKELY(memory == nullptr)) return nullptr;\n-    *reinterpret_cast<size_t*>(memory) = real_size;\n-    ctx->unreported_allocations_.fetch_add(real_size,\n+    *reinterpret_cast<size_t*>(memory) = size;\n+    ctx->unreported_allocations_.fetch_add(size,\n                                            std::memory_order_relaxed);\n     return memory + sizeof(size_t);\n   }\n@@ -484,6 +575,7 @@ class ZlibStream : public CompressionStream<ZlibContext> {\n     Local<ArrayBuffer> ab = array->Buffer();\n     uint32_t* write_result = static_cast<uint32_t*>(ab->GetContents().Data());\n \n+    CHECK(args[5]->IsFunction());\n     Local<Function> write_js_callback = args[5].As<Function>();\n \n     std::vector<unsigned char> dictionary;\n@@ -525,20 +617,88 @@ class ZlibStream : public CompressionStream<ZlibContext> {\n       wrap->EmitError(err);\n   }\n \n-  static void Reset(const FunctionCallbackInfo<Value> &args) {\n-    ZlibStream* wrap;\n+  SET_MEMORY_INFO_NAME(ZlibStream)\n+  SET_SELF_SIZE(ZlibStream)\n+};\n+\n+template <typename CompressionContext>\n+class BrotliCompressionStream : public CompressionStream<CompressionContext> {\n+ public:\n+  BrotliCompressionStream(Environment* env,\n+                          Local<Object> wrap,\n+                          node_zlib_mode mode)\n+    : CompressionStream<CompressionContext>(env, wrap) {\n+    context()->SetMode(mode);\n+  }\n+\n+  inline CompressionContext* context() {\n+    return this->CompressionStream<CompressionContext>::context();\n+  }\n+  typedef typename CompressionStream<CompressionContext>::AllocScope AllocScope;\n+\n+  static void New(const FunctionCallbackInfo<Value>& args) {\n+    Environment* env = Environment::GetCurrent(args);\n+    CHECK(args[0]->IsInt32());\n+    node_zlib_mode mode =\n+        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());\n+    new BrotliCompressionStream(env, args.This(), mode);\n+  }\n+\n+  static void Init(const FunctionCallbackInfo<Value>& args) {\n+    BrotliCompressionStream* wrap;\n     ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n+    CHECK(args.Length() == 3 && \"init(params, writeResult, writeCallback)\");\n+\n+    CHECK(args[1]->IsUint32Array());\n+    uint32_t* write_result = reinterpret_cast<uint32_t*>(Buffer::Data(args[1]));\n+\n+    CHECK(args[2]->IsFunction());\n+    Local<Function> write_js_callback = args[2].As<Function>();\n+    wrap->InitStream(write_result, write_js_callback);\n \n     AllocScope alloc_scope(wrap);\n-    const CompressionError err = wrap->context()->ResetStream();\n-    if (err.IsError())\n+    CompressionError err =\n+        wrap->context()->Init(\n+          CompressionStream<CompressionContext>::AllocForBrotli,\n+          CompressionStream<CompressionContext>::FreeForZlib,\n+          static_cast<CompressionStream<CompressionContext>*>(wrap));\n+    if (err.IsError()) {\n       wrap->EmitError(err);\n+      args.GetReturnValue().Set(false);\n+      return;\n+    }\n+\n+    CHECK(args[0]->IsUint32Array());\n+    const uint32_t* data = reinterpret_cast<uint32_t*>(Buffer::Data(args[0]));\n+    size_t len = args[0].As<Uint32Array>()->Length();\n+\n+    for (int i = 0; static_cast<size_t>(i) < len; i++) {\n+      if (data[i] == static_cast<uint32_t>(-1))\n+        continue;\n+      err = wrap->context()->SetParams(i, data[i]);\n+      if (err.IsError()) {\n+        wrap->EmitError(err);\n+        args.GetReturnValue().Set(false);\n+        return;\n+      }\n+    }\n+\n+    args.GetReturnValue().Set(true);\n   }\n \n-  SET_MEMORY_INFO_NAME(ZlibStream)\n-  SET_SELF_SIZE(ZlibStream)\n+  static void Params(const FunctionCallbackInfo<Value>& args) {\n+    // Currently a no-op, and not accessed from JS land.\n+    // At some point Brotli may support changing parameters on the fly,\n+    // in which case we can implement this and a JS equivalent similar to\n+    // the zlib Params() function.\n+  }\n+\n+  SET_MEMORY_INFO_NAME(BrotliCompressionStream)\n+  SET_SELF_SIZE(BrotliCompressionStream)\n };\n \n+using BrotliEncoderStream = BrotliCompressionStream<BrotliEncoderContext>;\n+using BrotliDecoderStream = BrotliCompressionStream<BrotliDecoderContext>;\n \n void ZlibContext::Close() {\n   CHECK_LE(mode_, UNZIP);\n@@ -876,29 +1036,194 @@ CompressionError ZlibContext::SetParams(int level, int strategy) {\n }\n \n \n+void BrotliContext::SetBuffers(char* in, uint32_t in_len,\n+                               char* out, uint32_t out_len) {\n+  next_in_ = reinterpret_cast<uint8_t*>(in);\n+  next_out_ = reinterpret_cast<uint8_t*>(out);\n+  avail_in_ = in_len;\n+  avail_out_ = out_len;\n+}\n+\n+\n+void BrotliContext::SetFlush(int flush) {\n+  flush_ = static_cast<BrotliEncoderOperation>(flush);\n+}\n+\n+\n+void BrotliContext::GetAfterWriteOffsets(uint32_t* avail_in,\n+                                         uint32_t* avail_out) const {\n+  *avail_in = avail_in_;\n+  *avail_out = avail_out_;\n+}\n+\n+\n+void BrotliEncoderContext::DoThreadPoolWork() {\n+  CHECK_EQ(mode_, BROTLI_ENCODE);\n+  CHECK(state_);\n+  const uint8_t* next_in = next_in_;\n+  last_result_ = BrotliEncoderCompressStream(state_.get(),\n+                                             flush_,\n+                                             &avail_in_,\n+                                             &next_in,\n+                                             &avail_out_,\n+                                             &next_out_,\n+                                             nullptr);\n+  next_in_ += next_in - next_in_;\n+}\n+\n+\n+void BrotliEncoderContext::Close() {\n+  state_.reset();\n+  mode_ = NONE;\n+}\n+\n+CompressionError BrotliEncoderContext::Init(brotli_alloc_func alloc,\n+                                            brotli_free_func free,\n+                                            void* opaque) {\n+  alloc_ = alloc;\n+  free_ = free;\n+  alloc_opaque_ = opaque;\n+  state_.reset(BrotliEncoderCreateInstance(alloc, free, opaque));\n+  if (!state_) {\n+    return CompressionError(\"Could not initialize Brotli instance\",\n+                            \"ERR_ZLIB_INITIALIZATION_FAILED\",\n+                            -1);\n+  } else {\n+    return CompressionError {};\n+  }\n+}\n+\n+CompressionError BrotliEncoderContext::ResetStream() {\n+  return Init(alloc_, free_, alloc_opaque_);\n+}\n+\n+CompressionError BrotliEncoderContext::SetParams(int key, uint32_t value) {\n+  if (!BrotliEncoderSetParameter(state_.get(),\n+                                 static_cast<BrotliEncoderParameter>(key),\n+                                 value)) {\n+    return CompressionError(\"Setting parameter failed\",\n+                            \"ERR_BROTLI_PARAM_SET_FAILED\",\n+                            -1);\n+  } else {\n+    return CompressionError {};\n+  }\n+}\n+\n+CompressionError BrotliEncoderContext::GetErrorInfo() const {\n+  if (!last_result_) {\n+    return CompressionError(\"Compression failed\",\n+                            \"ERR_BROTLI_COMPRESSION_FAILED\",\n+                            -1);\n+  } else {\n+    return CompressionError {};\n+  }\n+}\n+\n+\n+void BrotliDecoderContext::Close() {\n+  state_.reset();\n+  mode_ = NONE;\n+}\n+\n+void BrotliDecoderContext::DoThreadPoolWork() {\n+  CHECK_EQ(mode_, BROTLI_DECODE);\n+  CHECK(state_);\n+  const uint8_t* next_in = next_in_;\n+  last_result_ = BrotliDecoderDecompressStream(state_.get(),\n+                                               &avail_in_,\n+                                               &next_in,\n+                                               &avail_out_,\n+                                               &next_out_,\n+                                               nullptr);\n+  next_in_ += next_in - next_in_;\n+  if (last_result_ == BROTLI_DECODER_RESULT_ERROR) {\n+    error_ = BrotliDecoderGetErrorCode(state_.get());\n+    error_string_ = std::string(\"ERR_\") + BrotliDecoderErrorString(error_);\n+  }\n+}\n+\n+CompressionError BrotliDecoderContext::Init(brotli_alloc_func alloc,\n+                                            brotli_free_func free,\n+                                            void* opaque) {\n+  alloc_ = alloc;\n+  free_ = free;\n+  alloc_opaque_ = opaque;\n+  state_.reset(BrotliDecoderCreateInstance(alloc, free, opaque));\n+  if (!state_) {\n+    return CompressionError(\"Could not initialize Brotli instance\",\n+                            \"ERR_ZLIB_INITIALIZATION_FAILED\",\n+                            -1);\n+  } else {\n+    return CompressionError {};\n+  }\n+}\n+\n+CompressionError BrotliDecoderContext::ResetStream() {\n+  return Init(alloc_, free_, alloc_opaque_);\n+}\n+\n+CompressionError BrotliDecoderContext::SetParams(int key, uint32_t value) {\n+  if (!BrotliDecoderSetParameter(state_.get(),\n+                                 static_cast<BrotliDecoderParameter>(key),\n+                                 value)) {\n+    return CompressionError(\"Setting parameter failed\",\n+                            \"ERR_BROTLI_PARAM_SET_FAILED\",\n+                            -1);\n+  } else {\n+    return CompressionError {};\n+  }\n+}\n+\n+CompressionError BrotliDecoderContext::GetErrorInfo() const {\n+  if (error_ != BROTLI_DECODER_NO_ERROR) {\n+    return CompressionError(\"Decompression failed\",\n+                            error_string_.c_str(),\n+                            static_cast<int>(error_));\n+  } else if (flush_ == BROTLI_OPERATION_FINISH &&\n+             last_result_ == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {\n+    // Match zlib's behaviour, as brotli doesn't have its own code for this.\n+    return CompressionError(\"unexpected end of file\",\n+                            \"Z_BUF_ERROR\",\n+                            Z_BUF_ERROR);\n+  } else {\n+    return CompressionError {};\n+  }\n+}\n+\n+\n+template <typename Stream>\n+struct MakeClass {\n+  static void Make(Environment* env, Local<Object> target, const char* name) {\n+    Local<FunctionTemplate> z = env->NewFunctionTemplate(Stream::New);\n+\n+    z->InstanceTemplate()->SetInternalFieldCount(1);\n+    z->Inherit(AsyncWrap::GetConstructorTemplate(env));\n+\n+    env->SetProtoMethod(z, \"write\", Stream::template Write<true>);\n+    env->SetProtoMethod(z, \"writeSync\", Stream::template Write<false>);\n+    env->SetProtoMethod(z, \"close\", Stream::Close);\n+\n+    env->SetProtoMethod(z, \"init\", Stream::Init);\n+    env->SetProtoMethod(z, \"params\", Stream::Params);\n+    env->SetProtoMethod(z, \"reset\", Stream::Reset);\n+\n+    Local<String> zlibString = OneByteString(env->isolate(), name);\n+    z->SetClassName(zlibString);\n+    target->Set(env->context(),\n+                zlibString,\n+                z->GetFunction(env->context()).ToLocalChecked()).FromJust();\n+  }\n+};\n+\n void Initialize(Local<Object> target,\n                 Local<Value> unused,\n                 Local<Context> context,\n                 void* priv) {\n   Environment* env = Environment::GetCurrent(context);\n-  Local<FunctionTemplate> z = env->NewFunctionTemplate(ZlibStream::New);\n-\n-  z->InstanceTemplate()->SetInternalFieldCount(1);\n-  z->Inherit(AsyncWrap::GetConstructorTemplate(env));\n \n-  env->SetProtoMethod(z, \"write\", ZlibStream::Write<true>);\n-  env->SetProtoMethod(z, \"writeSync\", ZlibStream::Write<false>);\n-  env->SetProtoMethod(z, \"close\", ZlibStream::Close);\n-\n-  env->SetProtoMethod(z, \"init\", ZlibStream::Init);\n-  env->SetProtoMethod(z, \"params\", ZlibStream::Params);\n-  env->SetProtoMethod(z, \"reset\", ZlibStream::Reset);\n-\n-  Local<String> zlibString = FIXED_ONE_BYTE_STRING(env->isolate(), \"Zlib\");\n-  z->SetClassName(zlibString);\n-  target->Set(env->context(),\n-              zlibString,\n-              z->GetFunction(env->context()).ToLocalChecked()).FromJust();\n+  MakeClass<ZlibStream>::Make(env, target, \"Zlib\");\n+  MakeClass<BrotliEncoderStream>::Make(env, target, \"BrotliEncoder\");\n+  MakeClass<BrotliDecoderStream>::Make(env, target, \"BrotliDecoder\");\n \n   target->Set(env->context(),\n               FIXED_ONE_BYTE_STRING(env->isolate(), \"ZLIB_VERSION\"),\n@@ -944,6 +1269,8 @@ void DefineZlibConstants(Local<Object> target) {\n   NODE_DEFINE_CONSTANT(target, DEFLATERAW);\n   NODE_DEFINE_CONSTANT(target, INFLATERAW);\n   NODE_DEFINE_CONSTANT(target, UNZIP);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_ENCODE);\n \n   NODE_DEFINE_CONSTANT(target, Z_MIN_WINDOWBITS);\n   NODE_DEFINE_CONSTANT(target, Z_MAX_WINDOWBITS);\n@@ -957,6 +1284,72 @@ void DefineZlibConstants(Local<Object> target) {\n   NODE_DEFINE_CONSTANT(target, Z_MIN_LEVEL);\n   NODE_DEFINE_CONSTANT(target, Z_MAX_LEVEL);\n   NODE_DEFINE_CONSTANT(target, Z_DEFAULT_LEVEL);\n+\n+  // Brotli constants\n+  NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_PROCESS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FLUSH);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_FINISH);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_OPERATION_EMIT_METADATA);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_MODE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MODE_GENERIC);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MODE_TEXT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MODE_FONT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_MODE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_QUALITY);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MIN_QUALITY);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MAX_QUALITY);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_QUALITY);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGWIN);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MIN_WINDOW_BITS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MAX_WINDOW_BITS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_LARGE_MAX_WINDOW_BITS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DEFAULT_WINDOW);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LGBLOCK);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MIN_INPUT_BLOCK_BITS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_MAX_INPUT_BLOCK_BITS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_SIZE_HINT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_LARGE_WINDOW);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NPOSTFIX);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_PARAM_NDIRECT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_ERROR);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_SUCCESS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT);\n+  NODE_DEFINE_CONSTANT(target,\n+      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_PARAM_LARGE_WINDOW);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NO_ERROR);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_SUCCESS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_INPUT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_NEEDS_MORE_OUTPUT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_RESERVED);\n+  NODE_DEFINE_CONSTANT(target,\n+      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE);\n+  NODE_DEFINE_CONSTANT(target,\n+      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CL_SPACE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_TRANSFORM);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DICTIONARY);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_1);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_PADDING_2);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_FORMAT_DISTANCE);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_INVALID_ARGUMENTS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES);\n+  NODE_DEFINE_CONSTANT(target, BROTLI_DECODER_ERROR_UNREACHABLE);\n }\n \n }  // namespace node"
        },
        {
            "sha": "18dffe0cadbe36dce2b0ecda8e5e02f5dad03070",
            "filename": "test/parallel/test-process-versions.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/73753d48639200f79957b822599e9848b0ac942f/test%2Fparallel%2Ftest-process-versions.js",
            "raw_url": "https://github.com/nodejs/node/raw/73753d48639200f79957b822599e9848b0ac942f/test%2Fparallel%2Ftest-process-versions.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-process-versions.js?ref=73753d48639200f79957b822599e9848b0ac942f",
            "patch": "@@ -2,7 +2,7 @@\n const common = require('../common');\n const assert = require('assert');\n \n-const expected_keys = ['ares', 'modules', 'node',\n+const expected_keys = ['ares', 'brotli', 'modules', 'node',\n                        'uv', 'v8', 'zlib', 'nghttp2', 'napi',\n                        'http_parser', 'llhttp'];\n \n@@ -25,6 +25,7 @@ assert.deepStrictEqual(actual_keys, expected_keys);\n const commonTemplate = /^\\d+\\.\\d+\\.\\d+(?:-.*)?$/;\n \n assert(commonTemplate.test(process.versions.ares));\n+assert(commonTemplate.test(process.versions.brotli));\n assert(commonTemplate.test(process.versions.llhttp));\n assert(commonTemplate.test(process.versions.http_parser));\n assert(commonTemplate.test(process.versions.node));"
        }
    ],
    "stats": {
        "total": 577,
        "additions": 540,
        "deletions": 37
    }
}