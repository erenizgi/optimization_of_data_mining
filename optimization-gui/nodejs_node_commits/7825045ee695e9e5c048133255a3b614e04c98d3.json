{
    "author": "jasnell",
    "message": "http2: improve http2 code a bit\n\nMultiple general improvements to http2 internals for\nreadability and efficiency\n\nPR-URL: https://github.com/nodejs/node/pull/23984\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "7825045ee695e9e5c048133255a3b614e04c98d3",
    "files": [
        {
            "sha": "f18a73b95e24219db75b5a073daa6871a7c9e22a",
            "filename": "benchmark/http2/headers.js",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/7825045ee695e9e5c048133255a3b614e04c98d3/benchmark%2Fhttp2%2Fheaders.js",
            "raw_url": "https://github.com/nodejs/node/raw/7825045ee695e9e5c048133255a3b614e04c98d3/benchmark%2Fhttp2%2Fheaders.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fhttp2%2Fheaders.js?ref=7825045ee695e9e5c048133255a3b614e04c98d3",
            "patch": "@@ -39,8 +39,7 @@ function main({ n, nheaders }) {\n \n     function doRequest(remaining) {\n       const req = client.request(headersObject);\n-      req.end();\n-      req.on('data', () => {});\n+      req.resume();\n       req.on('end', () => {\n         if (remaining > 0) {\n           doRequest(remaining - 1);"
        },
        {
            "sha": "35856490f7e4a2e44355c24f6cf8da1868761f9b",
            "filename": "benchmark/http2/respond-with-fd.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/7825045ee695e9e5c048133255a3b614e04c98d3/benchmark%2Fhttp2%2Frespond-with-fd.js",
            "raw_url": "https://github.com/nodejs/node/raw/7825045ee695e9e5c048133255a3b614e04c98d3/benchmark%2Fhttp2%2Frespond-with-fd.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fhttp2%2Frespond-with-fd.js?ref=7825045ee695e9e5c048133255a3b614e04c98d3",
            "patch": "@@ -7,9 +7,9 @@ const fs = require('fs');\n const file = path.join(path.resolve(__dirname, '../fixtures'), 'alice.html');\n \n const bench = common.createBenchmark(main, {\n-  requests: [100, 1000, 10000, 100000],\n-  streams: [100, 200, 1000],\n-  clients: [1, 2],\n+  requests: [100, 1000, 5000],\n+  streams: [1, 10, 20, 40, 100, 200],\n+  clients: [2],\n   benchmarker: ['h2load']\n }, { flags: ['--no-warnings'] });\n "
        },
        {
            "sha": "aab7c6b609b7151045712f04fffcf0d643e00e2c",
            "filename": "benchmark/http2/simple.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/7825045ee695e9e5c048133255a3b614e04c98d3/benchmark%2Fhttp2%2Fsimple.js",
            "raw_url": "https://github.com/nodejs/node/raw/7825045ee695e9e5c048133255a3b614e04c98d3/benchmark%2Fhttp2%2Fsimple.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fhttp2%2Fsimple.js?ref=7825045ee695e9e5c048133255a3b614e04c98d3",
            "patch": "@@ -6,9 +6,9 @@ const fs = require('fs');\n const file = path.join(path.resolve(__dirname, '../fixtures'), 'alice.html');\n \n const bench = common.createBenchmark(main, {\n-  requests: [100, 1000, 10000, 100000],\n-  streams: [100, 200, 1000],\n-  clients: [1, 2],\n+  requests: [100, 1000, 5000],\n+  streams: [1, 10, 20, 40, 100, 200],\n+  clients: [2],\n   benchmarker: ['h2load']\n }, { flags: ['--no-warnings'] });\n "
        },
        {
            "sha": "c8701af616f32782d924dd849eb7e47b293370e6",
            "filename": "lib/internal/http2/util.js",
            "status": "modified",
            "additions": 25,
            "deletions": 19,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/7825045ee695e9e5c048133255a3b614e04c98d3/lib%2Finternal%2Fhttp2%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/7825045ee695e9e5c048133255a3b614e04c98d3/lib%2Finternal%2Fhttp2%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fhttp2%2Futil.js?ref=7825045ee695e9e5c048133255a3b614e04c98d3",
            "patch": "@@ -430,14 +430,20 @@ function mapToHeaders(map,\n   let count = 0;\n   const keys = Object.keys(map);\n   const singles = new Set();\n-  for (var i = 0; i < keys.length; i++) {\n-    let key = keys[i];\n-    let value = map[key];\n+  let i;\n+  let isArray;\n+  let key;\n+  let value;\n+  let isSingleValueHeader;\n+  let err;\n+  for (i = 0; i < keys.length; i++) {\n+    key = keys[i];\n+    value = map[key];\n     if (value === undefined || key === '')\n       continue;\n     key = key.toLowerCase();\n-    const isSingleValueHeader = kSingleValueHeaders.has(key);\n-    let isArray = Array.isArray(value);\n+    isSingleValueHeader = kSingleValueHeaders.has(key);\n+    isArray = Array.isArray(value);\n     if (isArray) {\n       switch (value.length) {\n         case 0:\n@@ -459,26 +465,26 @@ function mapToHeaders(map,\n       singles.add(key);\n     }\n     if (key[0] === ':') {\n-      const err = assertValuePseudoHeader(key);\n+      err = assertValuePseudoHeader(key);\n       if (err !== undefined)\n         return err;\n       ret = `${key}\\0${value}\\0${ret}`;\n       count++;\n-    } else {\n-      if (isIllegalConnectionSpecificHeader(key, value)) {\n-        return new ERR_HTTP2_INVALID_CONNECTION_HEADERS(key);\n-      }\n-      if (isArray) {\n-        for (var k = 0; k < value.length; k++) {\n-          const val = String(value[k]);\n-          ret += `${key}\\0${val}\\0`;\n-        }\n-        count += value.length;\n-      } else {\n-        ret += `${key}\\0${value}\\0`;\n-        count++;\n+      continue;\n+    }\n+    if (isIllegalConnectionSpecificHeader(key, value)) {\n+      return new ERR_HTTP2_INVALID_CONNECTION_HEADERS(key);\n+    }\n+    if (isArray) {\n+      for (var k = 0; k < value.length; k++) {\n+        const val = String(value[k]);\n+        ret += `${key}\\0${val}\\0`;\n       }\n+      count += value.length;\n+      continue;\n     }\n+    ret += `${key}\\0${value}\\0`;\n+    count++;\n   }\n \n   return [ret, count];"
        },
        {
            "sha": "95f3f4a8f7c1d26127e78ad86c363dd612a58bb4",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 180,
            "deletions": 167,
            "changes": 347,
            "blob_url": "https://github.com/nodejs/node/blob/7825045ee695e9e5c048133255a3b614e04c98d3/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7825045ee695e9e5c048133255a3b614e04c98d3/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=7825045ee695e9e5c048133255a3b614e04c98d3",
            "patch": "@@ -911,8 +911,10 @@ int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,\n   Debug(session, \"beginning headers for stream %d\", id);\n \n   Http2Stream* stream = session->FindStream(id);\n-  if (stream == nullptr) {\n-    if (!session->CanAddStream()) {\n+  // The common case is that we're creating a new stream. The less likely\n+  // case is that we're receiving a set of trailers\n+  if (LIKELY(stream == nullptr)) {\n+    if (UNLIKELY(!session->CanAddStream())) {\n       // Too many concurrent streams being opened\n       nghttp2_submit_rst_stream(**session, NGHTTP2_FLAG_NONE, id,\n                                 NGHTTP2_ENHANCE_YOUR_CALM);\n@@ -940,7 +942,7 @@ int Http2Session::OnHeaderCallback(nghttp2_session* handle,\n   // If stream is null at this point, either something odd has happened\n   // or the stream was closed locally while header processing was occurring.\n   // either way, do not proceed and close the stream.\n-  if (stream == nullptr)\n+  if (UNLIKELY(stream == nullptr))\n     return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n \n   // If the stream has already been destroyed, ignore.\n@@ -955,7 +957,7 @@ int Http2Session::OnHeaderCallback(nghttp2_session* handle,\n \n \n // Called by nghttp2 when a complete HTTP2 frame has been received. There are\n-// only a handful of frame types tha we care about handling here.\n+// only a handful of frame types that we care about handling here.\n int Http2Session::OnFrameReceive(nghttp2_session* handle,\n                                  const nghttp2_frame* frame,\n                                  void* user_data) {\n@@ -1032,22 +1034,25 @@ int Http2Session::OnFrameNotSent(nghttp2_session* handle,\n   Environment* env = session->env();\n   Debug(session, \"frame type %d was not sent, code: %d\",\n         frame->hd.type, error_code);\n-  // Do not report if the frame was not sent due to the session closing\n-  if (error_code != NGHTTP2_ERR_SESSION_CLOSING &&\n-      error_code != NGHTTP2_ERR_STREAM_CLOSED &&\n-      error_code != NGHTTP2_ERR_STREAM_CLOSING) {\n-    Isolate* isolate = env->isolate();\n-    HandleScope scope(isolate);\n-    Local<Context> context = env->context();\n-    Context::Scope context_scope(context);\n \n-    Local<Value> argv[3] = {\n-      Integer::New(isolate, frame->hd.stream_id),\n-      Integer::New(isolate, frame->hd.type),\n-      Integer::New(isolate, error_code)\n-    };\n-    session->MakeCallback(env->onframeerror_string(), arraysize(argv), argv);\n+  // Do not report if the frame was not sent due to the session closing\n+  if (error_code == NGHTTP2_ERR_SESSION_CLOSING ||\n+      error_code == NGHTTP2_ERR_STREAM_CLOSED ||\n+      error_code == NGHTTP2_ERR_STREAM_CLOSING) {\n+    return 0;\n   }\n+\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+  Context::Scope context_scope(context);\n+\n+  Local<Value> argv[3] = {\n+    Integer::New(isolate, frame->hd.stream_id),\n+    Integer::New(isolate, frame->hd.type),\n+    Integer::New(isolate, error_code)\n+  };\n+  session->MakeCallback(env->onframeerror_string(), arraysize(argv), argv);\n   return 0;\n }\n \n@@ -1074,25 +1079,26 @@ int Http2Session::OnStreamClose(nghttp2_session* handle,\n   Http2Stream* stream = session->FindStream(id);\n   // Intentionally ignore the callback if the stream does not exist or has\n   // already been destroyed\n-  if (stream != nullptr && !stream->IsDestroyed()) {\n-    stream->Close(code);\n-    // It is possible for the stream close to occur before the stream is\n-    // ever passed on to the javascript side. If that happens, skip straight\n-    // to destroying the stream. We can check this by looking for the\n-    // onstreamclose function. If it exists, then the stream has already\n-    // been passed on to javascript.\n-    Local<Value> fn =\n-        stream->object()->Get(context, env->onstreamclose_string())\n-            .ToLocalChecked();\n-    if (fn->IsFunction()) {\n-      Local<Value> argv[] = {\n-        Integer::NewFromUnsigned(isolate, code)\n-      };\n-      stream->MakeCallback(fn.As<Function>(), arraysize(argv), argv);\n-    } else {\n-      stream->Destroy();\n-    }\n+  if (stream == nullptr || stream->IsDestroyed())\n+    return 0;\n+\n+  stream->Close(code);\n+  // It is possible for the stream close to occur before the stream is\n+  // ever passed on to the javascript side. If that happens, skip straight\n+  // to destroying the stream. We can check this by looking for the\n+  // onstreamclose function. If it exists, then the stream has already\n+  // been passed on to javascript.\n+  Local<Value> fn =\n+      stream->object()->Get(context, env->onstreamclose_string())\n+          .ToLocalChecked();\n+\n+  if (!fn->IsFunction()) {\n+    stream->Destroy();\n+    return 0;\n   }\n+\n+  Local<Value> arg = Integer::NewFromUnsigned(isolate, code);\n+  stream->MakeCallback(fn.As<Function>(), 1, &arg);\n   return 0;\n }\n \n@@ -1125,53 +1131,56 @@ int Http2Session::OnDataChunkReceived(nghttp2_session* handle,\n         \"%d, flags: %d\", id, len, flags);\n   Environment* env = session->env();\n   HandleScope scope(env->isolate());\n+\n   // We should never actually get a 0-length chunk so this check is\n   // only a precaution at this point.\n-  if (len > 0) {\n-    // Notify nghttp2 that we've consumed a chunk of data on the connection\n-    // so that it can send a WINDOW_UPDATE frame. This is a critical part of\n-    // the flow control process in http2\n-    CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);\n-    Http2Stream* stream = session->FindStream(id);\n-    // If the stream has been destroyed, ignore this chunk\n-    if (stream->IsDestroyed())\n-      return 0;\n-\n-    stream->statistics_.received_bytes += len;\n-\n-    // Repeatedly ask the stream's owner for memory, and copy the read data\n-    // into those buffers.\n-    // The typical case is actually the exception here; Http2StreamListeners\n-    // know about the HTTP2 session associated with this stream, so they know\n-    // about the larger from-socket read buffer, so they do not require copying.\n-    do {\n-      uv_buf_t buf = stream->EmitAlloc(len);\n-      ssize_t avail = len;\n-      if (static_cast<ssize_t>(buf.len) < avail)\n-        avail = buf.len;\n-\n-      // `buf.base == nullptr` is the default Http2StreamListener's way\n-      // of saying that it wants a pointer to the raw original.\n-      // Since it has access to the original socket buffer from which the data\n-      // was read in the first place, it can use that to minimize ArrayBuffer\n-      // allocations.\n-      if (LIKELY(buf.base == nullptr))\n-        buf.base = reinterpret_cast<char*>(const_cast<uint8_t*>(data));\n-      else\n-        memcpy(buf.base, data, avail);\n-      data += avail;\n-      len -= avail;\n-      stream->EmitRead(avail, buf);\n-\n-      // If the stream owner (e.g. the JS Http2Stream) wants more data, just\n-      // tell nghttp2 that all data has been consumed. Otherwise, defer until\n-      // more data is being requested.\n-      if (stream->IsReading())\n-        nghttp2_session_consume_stream(handle, id, avail);\n-      else\n-        stream->inbound_consumed_data_while_paused_ += avail;\n-    } while (len != 0);\n-  }\n+  if (len == 0)\n+    return 0;\n+\n+  // Notify nghttp2 that we've consumed a chunk of data on the connection\n+  // so that it can send a WINDOW_UPDATE frame. This is a critical part of\n+  // the flow control process in http2\n+  CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);\n+  Http2Stream* stream = session->FindStream(id);\n+  // If the stream has been destroyed, ignore this chunk\n+  if (stream->IsDestroyed())\n+    return 0;\n+\n+  stream->statistics_.received_bytes += len;\n+\n+  // Repeatedly ask the stream's owner for memory, and copy the read data\n+  // into those buffers.\n+  // The typical case is actually the exception here; Http2StreamListeners\n+  // know about the HTTP2 session associated with this stream, so they know\n+  // about the larger from-socket read buffer, so they do not require copying.\n+  do {\n+    uv_buf_t buf = stream->EmitAlloc(len);\n+    ssize_t avail = len;\n+    if (static_cast<ssize_t>(buf.len) < avail)\n+      avail = buf.len;\n+\n+    // `buf.base == nullptr` is the default Http2StreamListener's way\n+    // of saying that it wants a pointer to the raw original.\n+    // Since it has access to the original socket buffer from which the data\n+    // was read in the first place, it can use that to minimize ArrayBuffer\n+    // allocations.\n+    if (LIKELY(buf.base == nullptr))\n+      buf.base = reinterpret_cast<char*>(const_cast<uint8_t*>(data));\n+    else\n+      memcpy(buf.base, data, avail);\n+    data += avail;\n+    len -= avail;\n+    stream->EmitRead(avail, buf);\n+\n+    // If the stream owner (e.g. the JS Http2Stream) wants more data, just\n+    // tell nghttp2 that all data has been consumed. Otherwise, defer until\n+    // more data is being requested.\n+    if (stream->IsReading())\n+      nghttp2_session_consume_stream(handle, id, avail);\n+    else\n+      stream->inbound_consumed_data_while_paused_ += avail;\n+  } while (len != 0);\n+\n   return 0;\n }\n \n@@ -1430,7 +1439,7 @@ void Http2Session::HandleOriginFrame(const nghttp2_frame* frame) {\n   nghttp2_extension ext = frame->ext;\n   nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);\n \n-  Local<Array> holder = Array::New(isolate);\n+  Local<Value> holder = Array::New(isolate);\n   Local<Function> fn = env()->push_values_to_array_function();\n   Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n \n@@ -1449,9 +1458,7 @@ void Http2Session::HandleOriginFrame(const nghttp2_frame* frame) {\n       fn->Call(context, holder, j, argv).ToLocalChecked();\n   }\n \n-  Local<Value> args[1] = { holder };\n-\n-  MakeCallback(env()->onorigin_string(), arraysize(args), args);\n+  MakeCallback(env()->onorigin_string(), 1, &holder);\n }\n \n // Called by OnFrameReceived when a complete PING frame has been received.\n@@ -1464,56 +1471,60 @@ void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n   bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n   if (ack) {\n     Http2Ping* ping = PopPing();\n-    if (ping != nullptr) {\n-      ping->Done(true, frame->ping.opaque_data);\n-    } else {\n+\n+    if (ping == nullptr) {\n       // PING Ack is unsolicited. Treat as a connection error. The HTTP/2\n       // spec does not require this, but there is no legitimate reason to\n       // receive an unsolicited PING ack on a connection. Either the peer\n       // is buggy or malicious, and we're not going to tolerate such\n       // nonsense.\n       arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);\n       MakeCallback(env()->error_string(), 1, &arg);\n+      return;\n     }\n-  } else {\n-    // Notify the session that a ping occurred\n-    arg = Buffer::Copy(env(),\n-                       reinterpret_cast<const char*>(frame->ping.opaque_data),\n-                       8).ToLocalChecked();\n-    MakeCallback(env()->onping_string(), 1, &arg);\n+\n+    ping->Done(true, frame->ping.opaque_data);\n+    return;\n   }\n+\n+  // Notify the session that a ping occurred\n+  arg = Buffer::Copy(env(),\n+                      reinterpret_cast<const char*>(frame->ping.opaque_data),\n+                      8).ToLocalChecked();\n+  MakeCallback(env()->onping_string(), 1, &arg);\n }\n \n // Called by OnFrameReceived when a complete SETTINGS frame has been received.\n void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {\n   bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n-  if (ack) {\n-    // If this is an acknowledgement, we should have an Http2Settings\n-    // object for it.\n-    Http2Settings* settings = PopSettings();\n-    if (settings != nullptr) {\n-      settings->Done(true);\n-    } else {\n-      // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2\n-      // spec does not require this, but there is no legitimate reason to\n-      // receive an unsolicited SETTINGS ack on a connection. Either the peer\n-      // is buggy or malicious, and we're not going to tolerate such\n-      // nonsense.\n-      // Note that nghttp2 currently prevents this from happening for SETTINGS\n-      // frames, so this block is purely defensive just in case that behavior\n-      // changes. Specifically, unlike unsolicited PING acks, unsolicited\n-      // SETTINGS acks should *never* make it this far.\n-      Isolate* isolate = env()->isolate();\n-      HandleScope scope(isolate);\n-      Local<Context> context = env()->context();\n-      Context::Scope context_scope(context);\n-      Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);\n-      MakeCallback(env()->error_string(), 1, &arg);\n-    }\n-  } else {\n-    // Otherwise, notify the session about a new settings\n+  if (!ack) {\n+    // This is not a SETTINGS acknowledgement, notify and return\n     MakeCallback(env()->onsettings_string(), 0, nullptr);\n+    return;\n   }\n+\n+  // If this is an acknowledgement, we should have an Http2Settings\n+  // object for it.\n+  Http2Settings* settings = PopSettings();\n+  if (settings != nullptr) {\n+    settings->Done(true);\n+    return;\n+  }\n+  // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2\n+  // spec does not require this, but there is no legitimate reason to\n+  // receive an unsolicited SETTINGS ack on a connection. Either the peer\n+  // is buggy or malicious, and we're not going to tolerate such\n+  // nonsense.\n+  // Note that nghttp2 currently prevents this from happening for SETTINGS\n+  // frames, so this block is purely defensive just in case that behavior\n+  // changes. Specifically, unlike unsolicited PING acks, unsolicited\n+  // SETTINGS acks should *never* make it this far.\n+  Isolate* isolate = env()->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env()->context();\n+  Context::Scope context_scope(context);\n+  Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);\n+  MakeCallback(env()->error_string(), 1, &arg);\n }\n \n // Callback used when data has been written to the stream.\n@@ -1535,7 +1546,10 @@ void Http2Session::OnStreamAfterWrite(WriteWrap* w, int status) {\n // queue), but only if a write has not already been scheduled.\n void Http2Session::MaybeScheduleWrite() {\n   CHECK_EQ(flags_ & SESSION_STATE_WRITE_SCHEDULED, 0);\n-  if (session_ != nullptr && nghttp2_session_want_write(session_)) {\n+  if (UNLIKELY(session_ == nullptr))\n+    return;\n+\n+  if (nghttp2_session_want_write(session_)) {\n     HandleScope handle_scope(env()->isolate());\n     Debug(this, \"scheduling write\");\n     flags_ |= SESSION_STATE_WRITE_SCHEDULED;\n@@ -1594,7 +1608,7 @@ void Http2Session::ClearOutgoing(int status) {\n \n     for (int32_t stream_id : current_pending_rst_streams) {\n       Http2Stream* stream = FindStream(stream_id);\n-      if (stream != nullptr)\n+      if (LIKELY(stream != nullptr))\n         stream->FlushRstStream();\n     }\n   }\n@@ -1769,7 +1783,7 @@ Http2Stream* Http2Session::SubmitRequest(\n   Http2Stream::Provider::Stream prov(options);\n   *ret = nghttp2_submit_request(session_, prispec, nva, len, *prov, nullptr);\n   CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);\n-  if (*ret > 0)\n+  if (LIKELY(*ret > 0))\n     stream = new Http2Stream(this, *ret, NGHTTP2_HCAT_HEADERS, options);\n   return stream;\n }\n@@ -1784,59 +1798,58 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   IncrementCurrentSessionMemory(buf.len);\n   CHECK(stream_buf_ab_.IsEmpty());\n \n+  OnScopeLeave on_scope_leave([&]() {\n+    // Once finished handling this write, reset the stream buffer.\n+    // The memory has either been free()d or was handed over to V8.\n+    DecrementCurrentSessionMemory(buf.len);\n+    stream_buf_ab_ = Local<ArrayBuffer>();\n+    stream_buf_ = uv_buf_init(nullptr, 0);\n+  });\n+\n+  // Only pass data on if nread > 0\n   if (nread <= 0) {\n     free(buf.base);\n     if (nread < 0) {\n       PassReadErrorToPreviousListener(nread);\n     }\n-  } else {\n-    // Only pass data on if nread > 0\n-\n-    // Makre sure that there was no read previously active.\n-    CHECK_NULL(stream_buf_.base);\n-    CHECK_EQ(stream_buf_.len, 0);\n-\n-    // Remember the current buffer, so that OnDataChunkReceived knows the\n-    // offset of a DATA frame's data into the socket read buffer.\n-    stream_buf_ = uv_buf_init(buf.base, nread);\n-\n-    // Verify that currently: There is memory allocated into which\n-    // the data has been read, and that memory buffer is at least as large\n-    // as the amount of data we have read, but we have not yet made an\n-    // ArrayBuffer out of it.\n-    CHECK_LE(static_cast<size_t>(nread), stream_buf_.len);\n-\n-    Isolate* isolate = env()->isolate();\n-\n-    // Create an array buffer for the read data. DATA frames will be emitted\n-    // as slices of this array buffer to avoid having to copy memory.\n-    stream_buf_ab_ =\n-        ArrayBuffer::New(isolate,\n-                         buf.base,\n-                         nread,\n-                         v8::ArrayBufferCreationMode::kInternalized);\n-\n-    statistics_.data_received += nread;\n-    ssize_t ret = Write(&stream_buf_, 1);\n-\n-    if (ret < 0) {\n-      Debug(this, \"fatal error receiving data: %d\", ret);\n-\n-      Local<Value> argv[] = {\n-        Integer::New(isolate, ret),\n-      };\n-      MakeCallback(env()->error_string(), arraysize(argv), argv);\n-    } else {\n-      MaybeStopReading();\n-    }\n+    return;\n   }\n \n-  // Since we are finished handling this write, reset the stream buffer.\n-  // The memory has either been free()d or was handed over to V8.\n-  DecrementCurrentSessionMemory(buf.len);\n+  // Make sure that there was no read previously active.\n+  CHECK_NULL(stream_buf_.base);\n+  CHECK_EQ(stream_buf_.len, 0);\n+\n+  // Remember the current buffer, so that OnDataChunkReceived knows the\n+  // offset of a DATA frame's data into the socket read buffer.\n+  stream_buf_ = uv_buf_init(buf.base, nread);\n+\n+  // Verify that currently: There is memory allocated into which\n+  // the data has been read, and that memory buffer is at least as large\n+  // as the amount of data we have read, but we have not yet made an\n+  // ArrayBuffer out of it.\n+  CHECK_LE(static_cast<size_t>(nread), stream_buf_.len);\n+\n+  Isolate* isolate = env()->isolate();\n \n-  stream_buf_ab_ = Local<ArrayBuffer>();\n-  stream_buf_ = uv_buf_init(nullptr, 0);\n+  // Create an array buffer for the read data. DATA frames will be emitted\n+  // as slices of this array buffer to avoid having to copy memory.\n+  stream_buf_ab_ =\n+      ArrayBuffer::New(isolate,\n+                        buf.base,\n+                        nread,\n+                        v8::ArrayBufferCreationMode::kInternalized);\n+\n+  statistics_.data_received += nread;\n+  ssize_t ret = Write(&stream_buf_, 1);\n+\n+  if (UNLIKELY(ret < 0)) {\n+    Debug(this, \"fatal error receiving data: %d\", ret);\n+    Local<Value> arg = Integer::New(isolate, ret);\n+    MakeCallback(env()->error_string(), 1, &arg);\n+    return;\n+  }\n+\n+  MaybeStopReading();\n }\n \n bool Http2Session::HasWritesOnSocketForStream(Http2Stream* stream) {"
        }
    ],
    "stats": {
        "total": 406,
        "additions": 212,
        "deletions": 194
    }
}