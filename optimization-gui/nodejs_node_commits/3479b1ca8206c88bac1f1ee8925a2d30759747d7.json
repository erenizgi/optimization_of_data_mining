{
    "author": "BridgeAR",
    "message": "util,assert: improve performance\n\nThis significantly improves regular and typed array performance by\nnot checking the indices keys anymore. This can be done with a V8\nAPI that allows to only retrieve the non indices property keys.\n\nPR-URL: https://github.com/nodejs/node/pull/22197\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "3479b1ca8206c88bac1f1ee8925a2d30759747d7",
    "files": [
        {
            "sha": "729bd1c31efa6851ddf9dc0146deca5b4c1ec364",
            "filename": "lib/internal/util/comparisons.js",
            "status": "modified",
            "additions": 37,
            "deletions": 44,
            "changes": 81,
            "blob_url": "https://github.com/nodejs/node/blob/3479b1ca8206c88bac1f1ee8925a2d30759747d7/lib%2Finternal%2Futil%2Fcomparisons.js",
            "raw_url": "https://github.com/nodejs/node/raw/3479b1ca8206c88bac1f1ee8925a2d30759747d7/lib%2Finternal%2Futil%2Fcomparisons.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Fcomparisons.js?ref=3479b1ca8206c88bac1f1ee8925a2d30759747d7",
            "patch": "@@ -4,6 +4,7 @@ const { compare } = process.binding('buffer');\n const { isArrayBufferView } = require('internal/util/types');\n const { internalBinding } = require('internal/bootstrap/loaders');\n const { isDate, isMap, isRegExp, isSet } = internalBinding('types');\n+const { getOwnNonIndexProperties } = process.binding('util');\n \n const ReflectApply = Reflect.apply;\n \n@@ -106,24 +107,11 @@ function strictDeepEqual(val1, val2, memos) {\n     if (val1.length !== val2.length) {\n       return false;\n     }\n-    const keys = objectKeys(val1);\n-    if (keys.length !== objectKeys(val2).length) {\n+    const keys1 = getOwnNonIndexProperties(val1);\n+    if (keys1.length !== getOwnNonIndexProperties(val2).length) {\n       return false;\n     }\n-    // Fast path for non sparse arrays (no key comparison for indices\n-    // properties).\n-    // See https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys\n-    if (val1.length === keys.length) {\n-      if (keys.length === 0 || keys[val1.length - 1] === `${val1.length - 1}`) {\n-        return keyCheck(val1, val2, kStrict, memos, kIsArray, []);\n-      }\n-    } else if (keys.length > val1.length &&\n-               keys[val1.length - 1] === `${val1.length - 1}`) {\n-      const minimalKeys = keys.slice(val1.length);\n-      return keyCheck(val1, val2, kStrict, memos, kIsArray, minimalKeys);\n-    }\n-    // Only set this to kIsArray in case the array is not sparse!\n-    return keyCheck(val1, val2, kStrict, memos, kNoIterator, keys);\n+    return keyCheck(val1, val2, kStrict, memos, kIsArray, keys1);\n   }\n   if (val1Tag === '[object Object]') {\n     return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n@@ -148,18 +136,14 @@ function strictDeepEqual(val1, val2, memos) {\n     if (!areSimilarTypedArrays(val1, val2)) {\n       return false;\n     }\n-    // Buffer.compare returns true, so val1.length === val2.length\n-    // if they both only contain numeric keys, we don't need to exam further.\n-    const keys = objectKeys(val1);\n-    if (keys.length !== objectKeys(val2).length) {\n+    // Buffer.compare returns true, so val1.length === val2.length. If they both\n+    // only contain numeric keys, we don't need to exam further than checking\n+    // the symbols.\n+    const keys1 = getOwnNonIndexProperties(val1);\n+    if (keys1.length !== getOwnNonIndexProperties(val2).length) {\n       return false;\n     }\n-    if (keys.length === val1.length) {\n-      return keyCheck(val1, val2, kStrict, memos, kNoIterator, []);\n-    }\n-    // Only compare the special keys.\n-    const minimalKeys = keys.slice(val1.length);\n-    return keyCheck(val1, val2, kStrict, memos, kNoIterator, minimalKeys);\n+    return keyCheck(val1, val2, kStrict, memos, kNoIterator, keys1);\n   } else if (isSet(val1)) {\n     if (!isSet(val2) || val1.size !== val2.size) {\n       return false;\n@@ -173,21 +157,10 @@ function strictDeepEqual(val1, val2, memos) {\n   // TODO: Make the valueOf checks safe.\n   } else if (typeof val1.valueOf === 'function') {\n     const val1Value = val1.valueOf();\n-    if (val1Value !== val1) {\n-      if (typeof val2.valueOf !== 'function') {\n-        return false;\n-      }\n-      if (!innerDeepEqual(val1Value, val2.valueOf(), true))\n-        return false;\n-      // Fast path for boxed primitive strings.\n-      if (typeof val1Value === 'string') {\n-        const keys = objectKeys(val1);\n-        if (keys.length !== objectKeys(val2).length) {\n-          return false;\n-        }\n-        const minimalKeys = keys.slice(val1.length);\n-        return keyCheck(val1, val2, kStrict, memos, kNoIterator, minimalKeys);\n-      }\n+    if (val1Value !== val1 &&\n+        (typeof val2.valueOf !== 'function' ||\n+          !innerDeepEqual(val1Value, val2.valueOf(), kStrict))) {\n+      return false;\n     }\n   }\n   return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n@@ -277,7 +250,7 @@ function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n     }\n   }\n \n-  if (strict) {\n+  if (strict && arguments.length === 5) {\n     const symbolKeysA = getOwnPropertySymbols(val1);\n     if (symbolKeysA.length !== 0) {\n       let count = 0;\n@@ -310,7 +283,7 @@ function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n   if (aKeys.length === 0 &&\n       (iterationType === kNoIterator ||\n         iterationType === kIsArray && val1.length === 0 ||\n-      val1.size === 0)) {\n+        val1.size === 0)) {\n     return true;\n   }\n \n@@ -578,8 +551,28 @@ function objEquiv(a, b, strict, keys, memos, iterationType) {\n     }\n   } else if (iterationType === kIsArray) {\n     for (; i < a.length; i++) {\n-      if (!innerDeepEqual(a[i], b[i], strict, memos)) {\n+      if (hasOwnProperty(a, i)) {\n+        if (!hasOwnProperty(b, i) ||\n+            !innerDeepEqual(a[i], b[i], strict, memos)) {\n+          return false;\n+        }\n+      } else if (hasOwnProperty(b, i)) {\n         return false;\n+      } else {\n+        // Array is sparse.\n+        const keysA = objectKeys(a);\n+        i++;\n+        for (; i < keysA.length; i++) {\n+          const key = keysA[i];\n+          if (!hasOwnProperty(b, key) ||\n+              !innerDeepEqual(a[key], b[i], strict, memos)) {\n+            return false;\n+          }\n+        }\n+        if (keysA.length !== objectKeys(b).length) {\n+          return false;\n+        }\n+        return true;\n       }\n     }\n   }"
        },
        {
            "sha": "591f3e3b5eb91ff1877d7e1bd14574bf028fbf26",
            "filename": "src/node_util.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/3479b1ca8206c88bac1f1ee8925a2d30759747d7/src%2Fnode_util.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3479b1ca8206c88bac1f1ee8925a2d30759747d7/src%2Fnode_util.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_util.cc?ref=3479b1ca8206c88bac1f1ee8925a2d30759747d7",
            "patch": "@@ -16,6 +16,29 @@ using v8::Proxy;\n using v8::String;\n using v8::Value;\n \n+static void GetOwnNonIndexProperties(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Local<Context> context = env->context();\n+\n+  if (!args[0]->IsObject())\n+    return;\n+\n+  v8::Local<v8::Object> object = args[0].As<v8::Object>();\n+\n+  // Return only non-enumerable properties by default.\n+  v8::Local<v8::Array> properties;\n+\n+  if (!object->GetPropertyNames(\n+        context, v8::KeyCollectionMode::kOwnOnly,\n+        v8::ONLY_ENUMERABLE,\n+        v8::IndexFilter::kSkipIndices)\n+          .ToLocal(&properties)) {\n+    return;\n+  }\n+  args.GetReturnValue().Set(properties);\n+}\n+\n static void GetPromiseDetails(const FunctionCallbackInfo<Value>& args) {\n   // Return undefined if it's not a Promise.\n   if (!args[0]->IsPromise())\n@@ -177,6 +200,8 @@ void Initialize(Local<Object> target,\n   env->SetMethodNoSideEffect(target, \"getProxyDetails\", GetProxyDetails);\n   env->SetMethodNoSideEffect(target, \"safeToString\", SafeToString);\n   env->SetMethodNoSideEffect(target, \"previewEntries\", PreviewEntries);\n+  env->SetMethodNoSideEffect(target, \"getOwnNonIndexProperties\",\n+                                     GetOwnNonIndexProperties);\n \n   env->SetMethod(target, \"startSigintWatchdog\", StartSigintWatchdog);\n   env->SetMethod(target, \"stopSigintWatchdog\", StopSigintWatchdog);"
        },
        {
            "sha": "e857ddf50b49f18e31afa6ec328435648d94f178",
            "filename": "test/parallel/test-assert-deep.js",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/3479b1ca8206c88bac1f1ee8925a2d30759747d7/test%2Fparallel%2Ftest-assert-deep.js",
            "raw_url": "https://github.com/nodejs/node/raw/3479b1ca8206c88bac1f1ee8925a2d30759747d7/test%2Fparallel%2Ftest-assert-deep.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-deep.js?ref=3479b1ca8206c88bac1f1ee8925a2d30759747d7",
            "patch": "@@ -893,6 +893,17 @@ assert.deepStrictEqual(obj1, obj2);\n                '  [\\n    1,\\n+   2\\n-   2,\\n-   3\\n  ]' }\n   );\n   util.inspect.defaultOptions = tmp;\n+\n+  const invalidTrap = new Proxy([1, 2, 3], {\n+    ownKeys() { return []; }\n+  });\n+  assert.throws(\n+    () => assert.deepStrictEqual(invalidTrap, [1, 2, 3]),\n+    {\n+      name: 'TypeError',\n+      message: \"'ownKeys' on proxy: trap result did not include 'length'\"\n+    }\n+  );\n }\n \n // Basic valueOf check."
        }
    ],
    "stats": {
        "total": 117,
        "additions": 73,
        "deletions": 44
    }
}