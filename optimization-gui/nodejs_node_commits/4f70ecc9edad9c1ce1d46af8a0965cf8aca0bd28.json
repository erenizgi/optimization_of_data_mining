{
    "author": "cxw42",
    "message": "doc: clarify Readable paused/flowing!==object mode\n\n- Clarify that a `Readable` stream's reading mode (paused vs. flowing)\n  is independent of its object mode (object vs. non-object).  I am\n  relatively new to Node streams, and was briefly confused while\n  reading the docs by the two uses of the word \"mode\".\n\n- Copyediting: add missing apostrophes; minor grammatical changes\n\nPR-URL: https://github.com/nodejs/node/pull/22619\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Denys Otrishko <shishugi@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "4f70ecc9edad9c1ce1d46af8a0965cf8aca0bd28",
    "files": [
        {
            "sha": "85ba46ebf8cc4d265584a3633b02e256bd54f280",
            "filename": "doc/api/stream.md",
            "status": "modified",
            "additions": 23,
            "deletions": 19,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/4f70ecc9edad9c1ce1d46af8a0965cf8aca0bd28/doc%2Fapi%2Fstream.md",
            "raw_url": "https://github.com/nodejs/node/raw/4f70ecc9edad9c1ce1d46af8a0965cf8aca0bd28/doc%2Fapi%2Fstream.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fstream.md?ref=4f70ecc9edad9c1ce1d46af8a0965cf8aca0bd28",
            "patch": "@@ -70,7 +70,7 @@ buffer that can be retrieved using `writable.writableBuffer` or\n `readable.readableBuffer`, respectively.\n \n The amount of data potentially buffered depends on the `highWaterMark` option\n-passed into the streams constructor. For normal streams, the `highWaterMark`\n+passed into the stream's constructor. For normal streams, the `highWaterMark`\n option specifies a [total number of bytes][hwm-gotcha]. For streams operating\n in object mode, the `highWaterMark` specifies a total number of objects.\n \n@@ -576,15 +576,18 @@ Examples of `Readable` streams include:\n All [`Readable`][] streams implement the interface defined by the\n `stream.Readable` class.\n \n-#### Two Modes\n+#### Two Reading Modes\n \n-`Readable` streams effectively operate in one of two modes: flowing and paused.\n+`Readable` streams effectively operate in one of two modes: flowing and\n+paused. These modes are separate from [object mode][object-mode].\n+A [`Readable`][] stream can be in object mode or not, regardless of whether\n+it is in flowing mode or paused mode.\n \n-When in flowing mode, data is read from the underlying system automatically\n+* In flowing mode, data is read from the underlying system automatically\n and provided to an application as quickly as possible using events via the\n [`EventEmitter`][] interface.\n \n-In paused mode, the [`stream.read()`][stream-read] method must be called\n+* In paused mode, the [`stream.read()`][stream-read] method must be called\n explicitly to read chunks of data from the stream.\n \n All [`Readable`][] streams begin in paused mode but can be switched to flowing\n@@ -633,22 +636,22 @@ within the `Readable` stream implementation.\n Specifically, at any given point in time, every `Readable` is in one of three\n possible states:\n \n-* `readable.readableFlowing = null`\n-* `readable.readableFlowing = false`\n-* `readable.readableFlowing = true`\n+* `readable.readableFlowing === null`\n+* `readable.readableFlowing === false`\n+* `readable.readableFlowing === true`\n \n When `readable.readableFlowing` is `null`, no mechanism for consuming the\n-streams data is provided so the stream will not generate its data. While in this\n-state, attaching a listener for the `'data'` event, calling the\n+stream's data is provided. Therefore, the stream will not generate data.\n+While in this state, attaching a listener for the `'data'` event, calling the\n `readable.pipe()` method, or calling the `readable.resume()` method will switch\n-`readable.readableFlowing` to `true`, causing the `Readable` to begin\n-actively emitting events as data is generated.\n+`readable.readableFlowing` to `true`, causing the `Readable` to begin actively\n+emitting events as data is generated.\n \n Calling `readable.pause()`, `readable.unpipe()`, or receiving backpressure\n will cause the `readable.readableFlowing` to be set as `false`,\n temporarily halting the flowing of events but *not* halting the generation of\n data. While in this state, attaching a listener for the `'data'` event\n-would not cause `readable.readableFlowing` to switch to `true`.\n+will not switch `readable.readableFlowing` to `true`.\n \n ```js\n const { PassThrough, Writable } = require('stream');\n@@ -660,20 +663,20 @@ pass.unpipe(writable);\n // readableFlowing is now false\n \n pass.on('data', (chunk) => { console.log(chunk.toString()); });\n-pass.write('ok'); // will not emit 'data'\n-pass.resume(); // must be called to make 'data' being emitted\n+pass.write('ok');  // will not emit 'data'\n+pass.resume();     // must be called to make stream emit 'data'\n ```\n \n While `readable.readableFlowing` is `false`, data may be accumulating\n-within the streams internal buffer.\n+within the stream's internal buffer.\n \n-#### Choose One\n+#### Choose One API Style\n \n The `Readable` stream API evolved across multiple Node.js versions and provides\n multiple methods of consuming stream data. In general, developers should choose\n *one* of the methods of consuming data and *should never* use multiple methods\n to consume data from a single stream. Specifically, using a combination\n-of `on('data')`, `on('readable')`, `pipe()` or async iterators could\n+of `on('data')`, `on('readable')`, `pipe()`, or async iterators could\n lead to unintuitive behavior.\n \n Use of the `readable.pipe()` method is recommended for most users as it has been\n@@ -832,7 +835,7 @@ In general, the `readable.pipe()` and `'data'` event mechanisms are easier to\n understand than the `'readable'` event. However, handling `'readable'` might\n result in increased throughput.\n \n-If both `'readable'` and [`'data'`][]  are used at the same time, `'readable'`\n+If both `'readable'` and [`'data'`][] are used at the same time, `'readable'`\n takes precedence in controlling the flow, i.e. `'data'` will be emitted\n only when [`stream.read()`][stream-read] is called. The\n `readableFlowing` property would become `false`.\n@@ -2478,3 +2481,4 @@ contain multi-byte characters.\n [readable-destroy]: #stream_readable_destroy_error\n [writable-_destroy]: #stream_writable_destroy_err_callback\n [writable-destroy]: #stream_writable_destroy_error\n+[object-mode]: #stream_object_mode"
        }
    ],
    "stats": {
        "total": 42,
        "additions": 23,
        "deletions": 19
    }
}