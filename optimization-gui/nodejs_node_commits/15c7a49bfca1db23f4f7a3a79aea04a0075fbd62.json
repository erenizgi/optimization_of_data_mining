{
    "author": "addaleax",
    "message": "http2: switch to new runtime-controlled debugging system\n\nRemove `--debug-http2` as a compile-time feature and\nmake all debug statements available using `NODE_DEBUG_NATIVE=http2`\nat runtime.\n\nThis probably makes the debugging-enabled case a bit slower due to\nadditional string concatenations, but switching to a runtime-checking\nsystem makes debugging more flexible and can be applied more easily\nto other parts of the source code as well.\n\nPR-URL: https://github.com/nodejs/node/pull/20987\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Minwoo Jung <minwoo@nodesource.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
    "files": [
        {
            "sha": "c4dda999fd23c85a6c447f6c470549569a82abb3",
            "filename": "configure",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/configure",
            "raw_url": "https://github.com/nodejs/node/raw/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/configure",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/configure?ref=15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
            "patch": "@@ -443,11 +443,6 @@ parser.add_option('--debug-lib',\n     dest='node_debug_lib',\n     help='build lib with DCHECK macros')\n \n-http2_optgroup.add_option('--debug-http2',\n-    action='store_true',\n-    dest='debug_http2',\n-    help='build with http2 debug statements on (default is false)')\n-\n http2_optgroup.add_option('--debug-nghttp2',\n     action='store_true',\n     dest='debug_nghttp2',\n@@ -970,11 +965,6 @@ def configure_node(o):\n \n   o['variables']['node_debug_lib'] = b(options.node_debug_lib)\n \n-  if options.debug_http2:\n-    o['variables']['debug_http2'] = 1\n-  else:\n-    o['variables']['debug_http2'] = 'false'\n-\n   if options.debug_nghttp2:\n     o['variables']['debug_nghttp2'] = 1\n   else:"
        },
        {
            "sha": "acd9f83213021d47eb8d4e4ee0cdccc01be5ba4a",
            "filename": "node.gypi",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/node.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/node.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gypi?ref=15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
            "patch": "@@ -90,10 +90,6 @@\n         'NODE_RELEASE_URLBASE=\"<(node_release_urlbase)\"',\n       ]\n     }],\n-    [\n-      'debug_http2==1', {\n-      'defines': [ 'NODE_DEBUG_HTTP2=1' ]\n-    }],\n     [ 'v8_enable_i18n_support==1', {\n       'defines': [ 'NODE_HAVE_I18N_SUPPORT=1' ],\n       'dependencies': ["
        },
        {
            "sha": "0bfdec9a57e38030bed3b8512ceb10646228fea4",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 93,
            "deletions": 83,
            "changes": 176,
            "blob_url": "https://github.com/nodejs/node/blob/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
            "patch": "@@ -1,4 +1,5 @@\n #include \"aliased_buffer.h\"\n+#include \"debug_utils.h\"\n #include \"node.h\"\n #include \"node_buffer.h\"\n #include \"node_http2.h\"\n@@ -200,7 +201,8 @@ void Http2Session::Http2Settings::Init() {\n #define GRABSETTING(N, trace)                                                 \\\n   if (flags & (1 << IDX_SETTINGS_##N)) {                                      \\\n     uint32_t val = buffer[IDX_SETTINGS_##N];                                  \\\n-    DEBUG_HTTP2SESSION2(session_, \"setting \" trace \": %d\\n\", val);            \\\n+    if (session_ != nullptr)                                                  \\\n+      Debug(session_, \"setting \" trace \": %d\\n\", val);                        \\\n     entries_[n++] =                                                           \\\n         nghttp2_settings_entry {NGHTTP2_SETTINGS_##N, val};                   \\\n   }\n@@ -334,13 +336,14 @@ Http2Priority::Http2Priority(Environment* env,\n   int32_t parent_ = parent->Int32Value(context).ToChecked();\n   int32_t weight_ = weight->Int32Value(context).ToChecked();\n   bool exclusive_ = exclusive->BooleanValue(context).ToChecked();\n-  DEBUG_HTTP2(\"Http2Priority: parent: %d, weight: %d, exclusive: %d\\n\",\n-              parent_, weight_, exclusive_);\n+  Debug(env, DebugCategory::HTTP2STREAM,\n+        \"Http2Priority: parent: %d, weight: %d, exclusive: %d\\n\",\n+        parent_, weight_, exclusive_);\n   nghttp2_priority_spec_init(&spec, parent_, weight_, exclusive_ ? 1 : 0);\n }\n \n \n-inline const char* Http2Session::TypeName() {\n+const char* Http2Session::TypeName() const {\n   switch (session_type_) {\n     case NGHTTP2_SESSION_SERVER: return \"server\";\n     case NGHTTP2_SESSION_CLIENT: return \"client\";\n@@ -495,10 +498,15 @@ Http2Session::Http2Session(Environment* env,\n \n Http2Session::~Http2Session() {\n   CHECK_EQ(flags_ & SESSION_STATE_HAS_SCOPE, 0);\n-  DEBUG_HTTP2SESSION(this, \"freeing nghttp2 session\");\n+  Debug(this, \"freeing nghttp2 session\");\n   nghttp2_session_del(session_);\n }\n \n+std::string Http2Session::diagnostic_name() const {\n+  return std::string(\"Http2Session \") + TypeName() + \" (\" +\n+      std::to_string(static_cast<int64_t>(get_async_id())) + \")\";\n+}\n+\n inline bool HasHttp2Observer(Environment* env) {\n   AliasedBuffer<uint32_t, Uint32Array>& observers =\n       env->performance_state()->observers;\n@@ -575,7 +583,7 @@ void Http2Session::EmitStatistics() {\n \n // Closes the session and frees the associated resources\n void Http2Session::Close(uint32_t code, bool socket_closed) {\n-  DEBUG_HTTP2SESSION(this, \"closing session\");\n+  Debug(this, \"closing session\");\n \n   if (flags_ & SESSION_STATE_CLOSING)\n     return;\n@@ -590,7 +598,7 @@ void Http2Session::Close(uint32_t code, bool socket_closed) {\n   // the peer but the HTTP/2 spec recommends sending it anyway. We'll\n   // make a best effort.\n   if (!socket_closed) {\n-    DEBUG_HTTP2SESSION2(this, \"terminating session with code %d\", code);\n+    Debug(this, \"terminating session with code %d\", code);\n     CHECK_EQ(nghttp2_session_terminate_session(session_, code), 0);\n     SendPendingData();\n   } else if (stream_ != nullptr) {\n@@ -662,15 +670,15 @@ ssize_t Http2Session::OnDWordAlignedPadding(size_t frameLen,\n   // use the max instead, even tho this means the frame will not be\n   // aligned.\n   pad = std::min(maxPayloadLen, pad);\n-  DEBUG_HTTP2SESSION2(this, \"using frame size padding: %d\", pad);\n+  Debug(this, \"using frame size padding: %d\", pad);\n   return pad;\n }\n \n // Used as one of the Padding Strategy functions. Uses the maximum amount\n // of padding allowed for the current frame.\n ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,\n                                             size_t maxPayloadLen) {\n-  DEBUG_HTTP2SESSION2(this, \"using max frame size padding: %d\", maxPayloadLen);\n+  Debug(this, \"using max frame size padding: %d\", maxPayloadLen);\n   return maxPayloadLen;\n }\n \n@@ -681,7 +689,7 @@ ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,\n ssize_t Http2Session::OnCallbackPadding(size_t frameLen,\n                                         size_t maxPayloadLen) {\n   if (frameLen == 0) return 0;\n-  DEBUG_HTTP2SESSION(this, \"using callback to determine padding\");\n+  Debug(this, \"using callback to determine padding\");\n   Isolate* isolate = env()->isolate();\n   HandleScope handle_scope(isolate);\n   Local<Context> context = env()->context();\n@@ -696,7 +704,7 @@ ssize_t Http2Session::OnCallbackPadding(size_t frameLen,\n   uint32_t retval = buffer[PADDING_BUF_RETURN_VALUE];\n   retval = std::min(retval, static_cast<uint32_t>(maxPayloadLen));\n   retval = std::max(retval, static_cast<uint32_t>(frameLen));\n-  DEBUG_HTTP2SESSION2(this, \"using padding size %d\", retval);\n+  Debug(this, \"using padding size %d\", retval);\n   return retval;\n }\n \n@@ -712,9 +720,9 @@ ssize_t Http2Session::Write(const uv_buf_t* bufs, size_t nbufs) {\n   // will trigger a number of other callbacks. Those will, in turn have\n   // multiple side effects.\n   for (size_t n = 0; n < nbufs; n++) {\n-    DEBUG_HTTP2SESSION2(this, \"receiving %d bytes [wants data? %d]\",\n-                        bufs[n].len,\n-                        nghttp2_session_want_read(session_));\n+    Debug(this, \"receiving %d bytes [wants data? %d]\",\n+          bufs[n].len,\n+          nghttp2_session_want_read(session_));\n     ssize_t ret =\n       nghttp2_session_mem_recv(session_,\n                                reinterpret_cast<uint8_t*>(bufs[n].base),\n@@ -751,7 +759,7 @@ int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,\n                                          void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   int32_t id = GetFrameID(frame);\n-  DEBUG_HTTP2SESSION2(session, \"beginning headers for stream %d\", id);\n+  Debug(session, \"beginning headers for stream %d\", id);\n \n   Http2Stream* stream = session->FindStream(id);\n   if (stream == nullptr) {\n@@ -799,8 +807,8 @@ int Http2Session::OnFrameReceive(nghttp2_session* handle,\n                                  void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   session->statistics_.frame_count++;\n-  DEBUG_HTTP2SESSION2(session, \"complete frame received: type: %d\",\n-                      frame->hd.type);\n+  Debug(session, \"complete frame received: type: %d\",\n+        frame->hd.type);\n   switch (frame->hd.type) {\n     case NGHTTP2_DATA:\n       session->HandleDataFrame(frame);\n@@ -837,8 +845,7 @@ int Http2Session::OnInvalidFrame(nghttp2_session* handle,\n                                  void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n \n-  DEBUG_HTTP2SESSION2(session, \"invalid frame received, code: %d\",\n-                      lib_error_code);\n+  Debug(session, \"invalid frame received, code: %d\", lib_error_code);\n \n   // If the error is fatal or if error code is ERR_STREAM_CLOSED... emit error\n   if (nghttp2_is_fatal(lib_error_code) ||\n@@ -866,8 +873,8 @@ int Http2Session::OnFrameNotSent(nghttp2_session* handle,\n                                  void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   Environment* env = session->env();\n-  DEBUG_HTTP2SESSION2(session, \"frame type %d was not sent, code: %d\",\n-                      frame->hd.type, error_code);\n+  Debug(session, \"frame type %d was not sent, code: %d\",\n+        frame->hd.type, error_code);\n   // Do not report if the frame was not sent due to the session closing\n   if (error_code != NGHTTP2_ERR_SESSION_CLOSING &&\n       error_code != NGHTTP2_ERR_STREAM_CLOSED &&\n@@ -906,7 +913,7 @@ int Http2Session::OnStreamClose(nghttp2_session* handle,\n   HandleScope scope(isolate);\n   Local<Context> context = env->context();\n   Context::Scope context_scope(context);\n-  DEBUG_HTTP2SESSION2(session, \"stream %d closed with code: %d\", id, code);\n+  Debug(session, \"stream %d closed with code: %d\", id, code);\n   Http2Stream* stream = session->FindStream(id);\n   // Intentionally ignore the callback if the stream does not exist or has\n   // already been destroyed\n@@ -957,8 +964,8 @@ int Http2Session::OnDataChunkReceived(nghttp2_session* handle,\n                                       size_t len,\n                                       void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n-  DEBUG_HTTP2SESSION2(session, \"buffering data chunk for stream %d, size: \"\n-              \"%d, flags: %d\", id, len, flags);\n+  Debug(session, \"buffering data chunk for stream %d, size: \"\n+        \"%d, flags: %d\", id, len, flags);\n   Environment* env = session->env();\n   HandleScope scope(env->isolate());\n   // We should never actually get a 0-length chunk so this check is\n@@ -1050,7 +1057,7 @@ int Http2Session::OnNghttpError(nghttp2_session* handle,\n   // Unfortunately, this is currently the only way for us to know if\n   // the session errored because the peer is not an http2 peer.\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n-    DEBUG_HTTP2SESSION2(session, \"Error '%.*s'\", len, message);\n+  Debug(session, \"Error '%.*s'\", len, message);\n   if (strncmp(message, BAD_PEER_MESSAGE, len) == 0) {\n     Environment* env = session->env();\n     Isolate* isolate = env->isolate();\n@@ -1109,7 +1116,7 @@ void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {\n   Context::Scope context_scope(context);\n \n   int32_t id = GetFrameID(frame);\n-  DEBUG_HTTP2SESSION2(this, \"handle headers frame for stream %d\", id);\n+  Debug(this, \"handle headers frame for stream %d\", id);\n   Http2Stream* stream = FindStream(id);\n \n   // If the stream has already been destroyed, ignore.\n@@ -1179,7 +1186,7 @@ void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {\n \n   nghttp2_priority priority_frame = frame->priority;\n   int32_t id = GetFrameID(frame);\n-  DEBUG_HTTP2SESSION2(this, \"handle priority frame for stream %d\", id);\n+  Debug(this, \"handle priority frame for stream %d\", id);\n   // Priority frame stream ID should never be <= 0. nghttp2 handles this for us\n   nghttp2_priority_spec spec = priority_frame.pri_spec;\n \n@@ -1198,7 +1205,7 @@ void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {\n // is set), then we'll terminate the readable side of the StreamBase.\n void Http2Session::HandleDataFrame(const nghttp2_frame* frame) {\n   int32_t id = GetFrameID(frame);\n-  DEBUG_HTTP2SESSION2(this, \"handling data frame for stream %d\", id);\n+  Debug(this, \"handling data frame for stream %d\", id);\n   Http2Stream* stream = FindStream(id);\n \n   if (!stream->IsDestroyed() && frame->hd.flags & NGHTTP2_FLAG_END_STREAM)\n@@ -1214,7 +1221,7 @@ void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {\n   Context::Scope context_scope(context);\n \n   nghttp2_goaway goaway_frame = frame->goaway;\n-  DEBUG_HTTP2SESSION(this, \"handling goaway frame\");\n+  Debug(this, \"handling goaway frame\");\n \n   Local<Value> argv[3] = {\n     Integer::NewFromUnsigned(isolate, goaway_frame.error_code),\n@@ -1243,7 +1250,7 @@ void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {\n \n   nghttp2_extension ext = frame->ext;\n   nghttp2_ext_altsvc* altsvc = static_cast<nghttp2_ext_altsvc*>(ext.payload);\n-  DEBUG_HTTP2SESSION(this, \"handling altsvc frame\");\n+  Debug(this, \"handling altsvc frame\");\n \n   Local<Value> argv[3] = {\n     Integer::New(isolate, id),\n@@ -1317,7 +1324,7 @@ void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {\n \n // Callback used when data has been written to the stream.\n void Http2Session::OnStreamAfterWrite(WriteWrap* w, int status) {\n-  DEBUG_HTTP2SESSION2(this, \"write finished with status %d\", status);\n+  Debug(this, \"write finished with status %d\", status);\n \n   // Inform all pending writes about their completion.\n   ClearOutgoing(status);\n@@ -1336,7 +1343,7 @@ void Http2Session::MaybeScheduleWrite() {\n   CHECK_EQ(flags_ & SESSION_STATE_WRITE_SCHEDULED, 0);\n   if (session_ != nullptr && nghttp2_session_want_write(session_)) {\n     HandleScope handle_scope(env()->isolate());\n-    DEBUG_HTTP2SESSION(this, \"scheduling write\");\n+    Debug(this, \"scheduling write\");\n     flags_ |= SESSION_STATE_WRITE_SCHEDULED;\n     env()->SetImmediate([](Environment* env, void* data) {\n       Http2Session* session = static_cast<Http2Session*>(data);\n@@ -1359,7 +1366,7 @@ void Http2Session::MaybeScheduleWrite() {\n \n void Http2Session::MaybeStopReading() {\n   int want_read = nghttp2_session_want_read(session_);\n-  DEBUG_HTTP2SESSION2(this, \"wants read? %d\", want_read);\n+  Debug(this, \"wants read? %d\", want_read);\n   if (want_read == 0)\n     stream_->ReadStop();\n }\n@@ -1422,7 +1429,7 @@ void Http2Session::CopyDataIntoOutgoing(const uint8_t* src, size_t src_length) {\n // This is a potential performance optimization target later.\n // Returns non-zero value if a write is already in progress.\n uint8_t Http2Session::SendPendingData() {\n-  DEBUG_HTTP2SESSION(this, \"sending pending data\");\n+  Debug(this, \"sending pending data\");\n   // Do not attempt to send data on the socket if the destroying flag has\n   // been set. That means everything is shutting down and the socket\n   // will not be usable.\n@@ -1445,7 +1452,7 @@ uint8_t Http2Session::SendPendingData() {\n   // Part One: Gather data from nghttp2\n \n   while ((src_length = nghttp2_session_mem_send(session_, &src)) > 0) {\n-    DEBUG_HTTP2SESSION2(this, \"nghttp2 has %d bytes to send\", src_length);\n+    Debug(this, \"nghttp2 has %d bytes to send\", src_length);\n     CopyDataIntoOutgoing(src, src_length);\n   }\n \n@@ -1521,7 +1528,7 @@ int Http2Session::OnSendData(\n     session->CopyDataIntoOutgoing(&padding_byte, 1);\n   }\n \n-  DEBUG_HTTP2SESSION2(session, \"nghttp2 has %d bytes to send directly\", length);\n+  Debug(session, \"nghttp2 has %d bytes to send directly\", length);\n   while (length > 0) {\n     // nghttp2 thinks that there is data available (length > 0), which means\n     // we told it so, which means that we *should* have data available.\n@@ -1562,7 +1569,7 @@ Http2Stream* Http2Session::SubmitRequest(\n     size_t len,\n     int32_t* ret,\n     int options) {\n-  DEBUG_HTTP2SESSION(this, \"submitting request\");\n+  Debug(this, \"submitting request\");\n   Http2Scope h2scope(this);\n   Http2Stream* stream = nullptr;\n   Http2Stream::Provider::Stream prov(options);\n@@ -1579,7 +1586,7 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   Context::Scope context_scope(env()->context());\n   Http2Scope h2scope(this);\n   CHECK_NOT_NULL(stream_);\n-  DEBUG_HTTP2SESSION2(this, \"receiving %d bytes\", nread);\n+  Debug(this, \"receiving %d bytes\", nread);\n   IncrementCurrentSessionMemory(buf.len);\n   CHECK(stream_buf_ab_.IsEmpty());\n \n@@ -1619,7 +1626,7 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n     ssize_t ret = Write(&stream_buf_, 1);\n \n     if (ret < 0) {\n-      DEBUG_HTTP2SESSION2(this, \"fatal error receiving data: %d\", ret);\n+      Debug(this, \"fatal error receiving data: %d\", ret);\n \n       Local<Value> argv[] = {\n         Integer::New(isolate, ret),\n@@ -1653,7 +1660,7 @@ bool Http2Session::HasWritesOnSocketForStream(Http2Stream* stream) {\n void Http2Session::Consume(Local<External> external) {\n   StreamBase* stream = static_cast<StreamBase*>(external->Value());\n   stream->PushStreamListener(this);\n-  DEBUG_HTTP2SESSION(this, \"i/o stream consumed\");\n+  Debug(this, \"i/o stream consumed\");\n }\n \n \n@@ -1699,16 +1706,22 @@ Http2Stream::Http2Stream(\n \n \n Http2Stream::~Http2Stream() {\n-  DEBUG_HTTP2STREAM(this, \"tearing down stream\");\n+  Debug(this, \"tearing down stream\");\n   if (session_ != nullptr) {\n     session_->RemoveStream(this);\n     session_ = nullptr;\n   }\n }\n \n+std::string Http2Stream::diagnostic_name() const {\n+  return \"HttpStream \" + std::to_string(id()) + \" (\" +\n+      std::to_string(static_cast<int64_t>(get_async_id())) + \") [\" +\n+      session()->diagnostic_name() + \"]\";\n+}\n+\n // Notify the Http2Stream that a new block of HEADERS is being processed.\n void Http2Stream::StartHeaders(nghttp2_headers_category category) {\n-  DEBUG_HTTP2STREAM2(this, \"starting headers, category: %d\", id_, category);\n+  Debug(this, \"starting headers, category: %d\", id_, category);\n   CHECK(!this->IsDestroyed());\n   current_headers_length_ = 0;\n   current_headers_.clear();\n@@ -1724,7 +1737,7 @@ void Http2Stream::Close(int32_t code) {\n   CHECK(!this->IsDestroyed());\n   flags_ |= NGHTTP2_STREAM_FLAG_CLOSED;\n   code_ = code;\n-  DEBUG_HTTP2STREAM2(this, \"closed with code %d\", code);\n+  Debug(this, \"closed with code %d\", code);\n }\n \n int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {\n@@ -1736,7 +1749,7 @@ int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {\n     flags_ |= NGHTTP2_STREAM_FLAG_SHUT;\n     CHECK_NE(nghttp2_session_resume_data(**session_, id_),\n              NGHTTP2_ERR_NOMEM);\n-    DEBUG_HTTP2STREAM(this, \"writable side shutdown\");\n+    Debug(this, \"writable side shutdown\");\n   }\n   req_wrap->Done(0);\n   return 0;\n@@ -1751,7 +1764,7 @@ void Http2Stream::Destroy() {\n     return;\n   flags_ |= NGHTTP2_STREAM_FLAG_DESTROYED;\n \n-  DEBUG_HTTP2STREAM(this, \"destroying stream\");\n+  Debug(this, \"destroying stream\");\n \n   // Wait until the start of the next loop to delete because there\n   // may still be some pending operations queued for this stream.\n@@ -1787,7 +1800,7 @@ void Http2Stream::Destroy() {\n int Http2Stream::SubmitResponse(nghttp2_nv* nva, size_t len, int options) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n-  DEBUG_HTTP2STREAM(this, \"submitting response\");\n+  Debug(this, \"submitting response\");\n   if (options & STREAM_OPTION_GET_TRAILERS)\n     flags_ |= NGHTTP2_STREAM_FLAG_TRAILERS;\n \n@@ -1805,7 +1818,7 @@ int Http2Stream::SubmitResponse(nghttp2_nv* nva, size_t len, int options) {\n int Http2Stream::SubmitInfo(nghttp2_nv* nva, size_t len) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n-  DEBUG_HTTP2STREAM2(this, \"sending %d informational headers\", len);\n+  Debug(this, \"sending %d informational headers\", len);\n   int ret = nghttp2_submit_headers(**session_,\n                                    NGHTTP2_FLAG_NONE,\n                                    id_, nullptr,\n@@ -1815,7 +1828,7 @@ int Http2Stream::SubmitInfo(nghttp2_nv* nva, size_t len) {\n }\n \n void Http2Stream::OnTrailers() {\n-  DEBUG_HTTP2STREAM(this, \"let javascript know we are ready for trailers\");\n+  Debug(this, \"let javascript know we are ready for trailers\");\n   CHECK(!this->IsDestroyed());\n   Isolate* isolate = env()->isolate();\n   HandleScope scope(isolate);\n@@ -1829,7 +1842,7 @@ void Http2Stream::OnTrailers() {\n int Http2Stream::SubmitTrailers(nghttp2_nv* nva, size_t len) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n-  DEBUG_HTTP2STREAM2(this, \"sending %d trailers\", len);\n+  Debug(this, \"sending %d trailers\", len);\n   int ret;\n   // Sending an empty trailers frame poses problems in Safari, Edge & IE.\n   // Instead we can just send an empty data frame with NGHTTP2_FLAG_END_STREAM\n@@ -1849,7 +1862,7 @@ int Http2Stream::SubmitPriority(nghttp2_priority_spec* prispec,\n                                 bool silent) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n-  DEBUG_HTTP2STREAM(this, \"sending priority spec\");\n+  Debug(this, \"sending priority spec\");\n   int ret = silent ?\n       nghttp2_session_change_stream_priority(**session_,\n                                              id_, prispec) :\n@@ -1893,7 +1906,7 @@ Http2Stream* Http2Stream::SubmitPushPromise(nghttp2_nv* nva,\n                                             int options) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n-  DEBUG_HTTP2STREAM(this, \"sending push promise\");\n+  Debug(this, \"sending push promise\");\n   *ret = nghttp2_submit_push_promise(**session_, NGHTTP2_FLAG_NONE,\n                                      id_, nva, len, nullptr);\n   CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);\n@@ -1912,7 +1925,7 @@ int Http2Stream::ReadStart() {\n   flags_ |= NGHTTP2_STREAM_FLAG_READ_START;\n   flags_ &= ~NGHTTP2_STREAM_FLAG_READ_PAUSED;\n \n-  DEBUG_HTTP2STREAM(this, \"reading starting\");\n+  Debug(this, \"reading starting\");\n \n   // Tell nghttp2 about our consumption of the data that was handed\n   // off to JS land.\n@@ -1930,7 +1943,7 @@ int Http2Stream::ReadStop() {\n   if (!IsReading())\n     return 0;\n   flags_ |= NGHTTP2_STREAM_FLAG_READ_PAUSED;\n-  DEBUG_HTTP2STREAM(this, \"reading stopped\");\n+  Debug(this, \"reading stopped\");\n   return 0;\n }\n \n@@ -1955,7 +1968,7 @@ int Http2Stream::DoWrite(WriteWrap* req_wrap,\n     req_wrap->Done(UV_EOF);\n     return 0;\n   }\n-  DEBUG_HTTP2STREAM2(this, \"queuing %d buffers to send\", id_, nbufs);\n+  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n   for (size_t i = 0; i < nbufs; ++i) {\n     // Store the req_wrap on the last write info in the queue, so that it is\n     // only marked as finished once all buffers associated with it are finished.\n@@ -2036,7 +2049,7 @@ ssize_t Http2Stream::Provider::Stream::OnRead(nghttp2_session* handle,\n                                               nghttp2_data_source* source,\n                                               void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n-  DEBUG_HTTP2SESSION2(session, \"reading outbound data for stream %d\", id);\n+  Debug(session, \"reading outbound data for stream %d\", id);\n   Http2Stream* stream = GetStream(session, id, source);\n   if (stream->statistics_.first_byte_sent == 0)\n     stream->statistics_.first_byte_sent = uv_hrtime();\n@@ -2056,10 +2069,9 @@ ssize_t Http2Stream::Provider::Stream::OnRead(nghttp2_session* handle,\n   }\n \n   if (!stream->queue_.empty()) {\n-    DEBUG_HTTP2SESSION2(session, \"stream %d has pending outbound data\", id);\n+    Debug(session, \"stream %d has pending outbound data\", id);\n     amount = std::min(stream->available_outbound_length_, length);\n-    DEBUG_HTTP2SESSION2(session, \"sending %d bytes for data frame on stream %d\",\n-                        amount, id);\n+    Debug(session, \"sending %d bytes for data frame on stream %d\", amount, id);\n     if (amount > 0) {\n       // Just return the length, let Http2Session::OnSendData take care of\n       // actually taking the buffers out of the queue.\n@@ -2070,7 +2082,7 @@ ssize_t Http2Stream::Provider::Stream::OnRead(nghttp2_session* handle,\n \n   if (amount == 0 && stream->IsWritable()) {\n     CHECK(stream->queue_.empty());\n-    DEBUG_HTTP2SESSION2(session, \"deferring stream %d\", id);\n+    Debug(session, \"deferring stream %d\", id);\n     stream->EmitWantsWrite(length);\n     if (stream->available_outbound_length_ > 0 || !stream->IsWritable()) {\n       // EmitWantsWrite() did something interesting synchronously, restart:\n@@ -2080,7 +2092,7 @@ ssize_t Http2Stream::Provider::Stream::OnRead(nghttp2_session* handle,\n   }\n \n   if (stream->queue_.empty() && !stream->IsWritable()) {\n-    DEBUG_HTTP2SESSION2(session, \"no more data for stream %d\", id);\n+    Debug(session, \"no more data for stream %d\", id);\n     *flags |= NGHTTP2_DATA_FLAG_EOF;\n     if (stream->HasTrailers()) {\n       *flags |= NGHTTP2_DATA_FLAG_NO_END_STREAM;\n@@ -2142,11 +2154,11 @@ void Http2Session::SetNextStreamID(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());\n   int32_t id = args[0]->Int32Value(env->context()).ToChecked();\n   if (nghttp2_session_set_next_stream_id(**session, id) < 0) {\n-    DEBUG_HTTP2SESSION2(session, \"failed to set next stream id to %d\", id);\n+    Debug(session, \"failed to set next stream id to %d\", id);\n     return args.GetReturnValue().Set(false);\n   }\n   args.GetReturnValue().Set(true);\n-  DEBUG_HTTP2SESSION2(session, \"set next stream id to %d\", id);\n+  Debug(session, \"set next stream id to %d\", id);\n }\n \n // A TypedArray instance is shared between C++ and JS land to contain the\n@@ -2158,7 +2170,7 @@ void Http2Session::RefreshSettings(const FunctionCallbackInfo<Value>& args) {\n   Http2Session* session;\n   ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());\n   Http2Settings::Update(env, session, fn);\n-  DEBUG_HTTP2SESSION(session, \"settings refreshed for session\");\n+  Debug(session, \"settings refreshed for session\");\n }\n \n // A TypedArray instance is shared between C++ and JS land to contain state\n@@ -2168,7 +2180,7 @@ void Http2Session::RefreshState(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   Http2Session* session;\n   ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());\n-  DEBUG_HTTP2SESSION(session, \"refreshing state\");\n+  Debug(session, \"refreshing state\");\n \n   AliasedBuffer<double, Float64Array>& buffer =\n       env->http2_state()->session_state_buffer;\n@@ -2204,7 +2216,7 @@ void Http2Session::New(const FunctionCallbackInfo<Value>& args) {\n   nghttp2_session_type type = static_cast<nghttp2_session_type>(val);\n   Http2Session* session = new Http2Session(env, args.This(), type);\n   session->get_async_id();  // avoid compiler warning\n-  DEBUG_HTTP2SESSION(session, \"session created\");\n+  Debug(session, \"session created\");\n }\n \n \n@@ -2220,7 +2232,7 @@ void Http2Session::Consume(const FunctionCallbackInfo<Value>& args) {\n void Http2Session::Destroy(const FunctionCallbackInfo<Value>& args) {\n   Http2Session* session;\n   ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());\n-  DEBUG_HTTP2SESSION(session, \"destroying session\");\n+  Debug(session, \"destroying session\");\n   Environment* env = Environment::GetCurrent(args);\n   Local<Context> context = env->context();\n \n@@ -2245,21 +2257,19 @@ void Http2Session::Request(const FunctionCallbackInfo<Value>& args) {\n \n   Headers list(isolate, context, headers);\n \n-  DEBUG_HTTP2SESSION(session, \"request submitted\");\n+  Debug(session, \"request submitted\");\n \n   int32_t ret = 0;\n   Http2Stream* stream =\n       session->Http2Session::SubmitRequest(*priority, *list, list.length(),\n                                            &ret, options);\n \n   if (ret <= 0) {\n-    DEBUG_HTTP2SESSION2(session, \"could not submit request: %s\",\n-                        nghttp2_strerror(ret));\n+    Debug(session, \"could not submit request: %s\", nghttp2_strerror(ret));\n     return args.GetReturnValue().Set(ret);\n   }\n \n-  DEBUG_HTTP2SESSION2(session, \"request submitted, new stream id %d\",\n-                      stream->id());\n+  Debug(session, \"request submitted, new stream id %d\", stream->id());\n   args.GetReturnValue().Set(stream->object());\n }\n \n@@ -2277,7 +2287,7 @@ void Http2Session::Goaway(uint32_t code,\n   // the last proc stream id is the most recently created Http2Stream.\n   if (lastStreamID <= 0)\n     lastStreamID = nghttp2_session_get_last_proc_stream_id(session_);\n-  DEBUG_HTTP2SESSION(this, \"submitting goaway\");\n+  Debug(this, \"submitting goaway\");\n   nghttp2_submit_goaway(session_, NGHTTP2_FLAG_NONE,\n                         lastStreamID, code, data, len);\n }\n@@ -2332,7 +2342,7 @@ void Http2Stream::RstStream(const FunctionCallbackInfo<Value>& args) {\n   Http2Stream* stream;\n   ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());\n   uint32_t code = args[0]->Uint32Value(context).ToChecked();\n-  DEBUG_HTTP2STREAM2(stream, \"sending rst_stream with code %d\", code);\n+  Debug(stream, \"sending rst_stream with code %d\", code);\n   stream->SubmitRstStream(code);\n }\n \n@@ -2352,7 +2362,7 @@ void Http2Stream::Respond(const FunctionCallbackInfo<Value>& args) {\n \n   args.GetReturnValue().Set(\n       stream->SubmitResponse(*list, list.length(), options));\n-  DEBUG_HTTP2STREAM(stream, \"response submitted\");\n+  Debug(stream, \"response submitted\");\n }\n \n \n@@ -2368,7 +2378,7 @@ void Http2Stream::Info(const FunctionCallbackInfo<Value>& args) {\n \n   Headers list(isolate, context, headers);\n   args.GetReturnValue().Set(stream->SubmitInfo(*list, list.length()));\n-  DEBUG_HTTP2STREAM2(stream, \"%d informational headers sent\", list.length());\n+  Debug(stream, \"%d informational headers sent\", list.length());\n }\n \n // Submits trailing headers on the Http2Stream\n@@ -2383,7 +2393,7 @@ void Http2Stream::Trailers(const FunctionCallbackInfo<Value>& args) {\n \n   Headers list(isolate, context, headers);\n   args.GetReturnValue().Set(stream->SubmitTrailers(*list, list.length()));\n-  DEBUG_HTTP2STREAM2(stream, \"%d trailing headers sent\", list.length());\n+  Debug(stream, \"%d trailing headers sent\", list.length());\n }\n \n // Grab the numeric id of the Http2Stream\n@@ -2397,7 +2407,7 @@ void Http2Stream::GetID(const FunctionCallbackInfo<Value>& args) {\n void Http2Stream::Destroy(const FunctionCallbackInfo<Value>& args) {\n   Http2Stream* stream;\n   ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());\n-  DEBUG_HTTP2STREAM(stream, \"destroying stream\");\n+  Debug(stream, \"destroying stream\");\n   stream->Destroy();\n }\n \n@@ -2406,7 +2416,7 @@ void Http2Stream::FlushData(const FunctionCallbackInfo<Value>& args) {\n   Http2Stream* stream;\n   ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());\n   stream->ReadStart();\n-  DEBUG_HTTP2STREAM(stream, \"data flushed to js\");\n+  Debug(stream, \"data flushed to js\");\n }\n \n // Initiate a Push Promise and create the associated Http2Stream\n@@ -2422,16 +2432,16 @@ void Http2Stream::PushPromise(const FunctionCallbackInfo<Value>& args) {\n \n   Headers list(isolate, context, headers);\n \n-  DEBUG_HTTP2STREAM(parent, \"creating push promise\");\n+  Debug(parent, \"creating push promise\");\n \n   int32_t ret = 0;\n   Http2Stream* stream = parent->SubmitPushPromise(*list, list.length(),\n                                                   &ret, options);\n   if (ret <= 0) {\n-    DEBUG_HTTP2STREAM2(parent, \"failed to create push stream: %d\", ret);\n+    Debug(parent, \"failed to create push stream: %d\", ret);\n     return args.GetReturnValue().Set(ret);\n   }\n-  DEBUG_HTTP2STREAM2(parent, \"push stream %d created\", stream->id());\n+  Debug(parent, \"push stream %d created\", stream->id());\n   args.GetReturnValue().Set(stream->object());\n }\n \n@@ -2446,7 +2456,7 @@ void Http2Stream::Priority(const FunctionCallbackInfo<Value>& args) {\n   bool silent = args[3]->BooleanValue(context).ToChecked();\n \n   CHECK_EQ(stream->SubmitPriority(*priority, silent), 0);\n-  DEBUG_HTTP2STREAM(stream, \"priority submitted\");\n+  Debug(stream, \"priority submitted\");\n }\n \n // A TypedArray shared by C++ and JS land is used to communicate state\n@@ -2457,7 +2467,7 @@ void Http2Stream::RefreshState(const FunctionCallbackInfo<Value>& args) {\n   Http2Stream* stream;\n   ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());\n \n-  DEBUG_HTTP2STREAM(stream, \"refreshing state\");\n+  Debug(stream, \"refreshing state\");\n \n   AliasedBuffer<double, Float64Array>& buffer =\n       env->http2_state()->stream_state_buffer;"
        },
        {
            "sha": "824084d0bafdaffd7c8e85d6bf739a19dfa4c807",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 4,
            "deletions": 56,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
            "patch": "@@ -21,61 +21,6 @@ using v8::MaybeLocal;\n \n using performance::PerformanceEntry;\n \n-#ifdef NODE_DEBUG_HTTP2\n-\n-// Adapted from nghttp2 own debug printer\n-static inline void _debug_vfprintf(const char* fmt, va_list args) {\n-  vfprintf(stderr, fmt, args);\n-}\n-\n-void inline debug_vfprintf(const char* format, ...) {\n-  va_list args;\n-  va_start(args, format);\n-  _debug_vfprintf(format, args);\n-  va_end(args);\n-}\n-\n-#define DEBUG_HTTP2(...) debug_vfprintf(__VA_ARGS__);\n-#define DEBUG_HTTP2SESSION(session, message)                                  \\\n-  do {                                                                        \\\n-    if (session != nullptr) {                                                 \\\n-      DEBUG_HTTP2(\"Http2Session %s (%.0lf) \" message \"\\n\",                    \\\n-                  session->TypeName(),                                        \\\n-                  session->get_async_id());                                   \\\n-     }                                                                        \\\n-  } while (0)\n-#define DEBUG_HTTP2SESSION2(session, message, ...)                            \\\n-  do {                                                                        \\\n-    if (session != nullptr) {                                                 \\\n-      DEBUG_HTTP2(\"Http2Session %s (%.0lf) \" message \"\\n\",                    \\\n-                  session->TypeName(),                                        \\\n-                  session->get_async_id(),                                    \\\n-                  __VA_ARGS__);                                               \\\n-    }                                                                         \\\n-  } while (0)\n-#define DEBUG_HTTP2STREAM(stream, message)                                    \\\n-  do {                                                                        \\\n-    DEBUG_HTTP2(\"Http2Stream %d (%.0lf) [Http2Session %s (%.0lf)] \" message   \\\n-                \"\\n\", stream->id(), stream->get_async_id(),                   \\\n-                stream->session()->TypeName(),                                \\\n-                stream->session()->get_async_id());                           \\\n-  } while (0)\n-#define DEBUG_HTTP2STREAM2(stream, message, ...)                              \\\n-  do {                                                                        \\\n-    DEBUG_HTTP2(\"Http2Stream %d (%.0lf) [Http2Session %s (%.0lf)] \" message   \\\n-                \"\\n\", stream->id(), stream->get_async_id(),                   \\\n-                stream->session()->TypeName(),                                \\\n-                stream->session()->get_async_id(),                            \\\n-                __VA_ARGS__);                                                 \\\n-  } while (0)\n-#else\n-#define DEBUG_HTTP2(...) do {} while (0)\n-#define DEBUG_HTTP2SESSION(...) do {} while (0)\n-#define DEBUG_HTTP2SESSION2(...) do {} while (0)\n-#define DEBUG_HTTP2STREAM(...) do {} while (0)\n-#define DEBUG_HTTP2STREAM2(...) do {} while (0)\n-#endif\n-\n // We strictly limit the number of outstanding unacknowledged PINGS a user\n // may send in order to prevent abuse. The current default cap is 10. The\n // user may set a different limit using a per Http2Session configuration\n@@ -557,6 +502,7 @@ class Http2Stream : public AsyncWrap,\n   nghttp2_stream* operator*();\n \n   Http2Session* session() { return session_; }\n+  const Http2Session* session() const { return session_; }\n \n   void EmitStatistics();\n \n@@ -675,6 +621,7 @@ class Http2Stream : public AsyncWrap,\n               uv_stream_t* send_handle) override;\n \n   size_t self_size() const override { return sizeof(*this); }\n+  std::string diagnostic_name() const override;\n \n   // JavaScript API\n   static void GetID(const FunctionCallbackInfo<Value>& args);\n@@ -819,7 +766,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   inline uint32_t GetMaxHeaderPairs() const { return max_header_pairs_; }\n \n-  inline const char* TypeName();\n+  inline const char* TypeName() const;\n \n   inline bool IsDestroyed() {\n     return (flags_ & SESSION_STATE_CLOSED) || session_ == nullptr;\n@@ -849,6 +796,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   ssize_t Write(const uv_buf_t* bufs, size_t nbufs);\n \n   size_t self_size() const override { return sizeof(*this); }\n+  std::string diagnostic_name() const override;\n \n   // Schedule an RstStream for after the current write finishes.\n   inline void AddPendingRstStream(int32_t stream_id) {"
        },
        {
            "sha": "f329a7e57e79dd3f2e0eeab254aa6d0cff72ae91",
            "filename": "test/parallel/test-http2-debug.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/test%2Fparallel%2Ftest-http2-debug.js",
            "raw_url": "https://github.com/nodejs/node/raw/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/test%2Fparallel%2Ftest-http2-debug.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-debug.js?ref=15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
            "patch": "@@ -0,0 +1,18 @@\n+'use strict';\n+require('../common');\n+const assert = require('assert');\n+const child_process = require('child_process');\n+const path = require('path');\n+\n+process.env.NODE_DEBUG_NATIVE = 'http2';\n+const { stdout, stderr } = child_process.spawnSync(process.execPath, [\n+  path.resolve(__dirname, 'test-http2-ping.js')\n+], { encoding: 'utf8' });\n+\n+assert(stderr.match(/Http2Session client \\(\\d+\\) handling data frame for stream \\d+/),\n+       stderr);\n+assert(stderr.match(/HttpStream \\d+ \\(\\d+\\) \\[Http2Session client \\(\\d+\\)\\] reading starting/),\n+       stderr);\n+assert(stderr.match(/HttpStream \\d+ \\(\\d+\\) \\[Http2Session server \\(\\d+\\)\\] tearing down stream/),\n+       stderr);\n+assert.strictEqual(stdout.trim(), '');"
        },
        {
            "sha": "c6921ab19150281a06a8dc5a39c0ea428feb8835",
            "filename": "vcbuild.bat",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/vcbuild.bat",
            "raw_url": "https://github.com/nodejs/node/raw/15c7a49bfca1db23f4f7a3a79aea04a0075fbd62/vcbuild.bat",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/vcbuild.bat?ref=15c7a49bfca1db23f4f7a3a79aea04a0075fbd62",
            "patch": "@@ -114,7 +114,6 @@ if /i \"%1\"==\"enable-vtune\"  set enable_vtune_arg=1&goto arg-ok\n if /i \"%1\"==\"dll\"           set dll=1&goto arg-ok\n if /i \"%1\"==\"static\"           set enable_static=1&goto arg-ok\n if /i \"%1\"==\"no-NODE-OPTIONS\"\tset no_NODE_OPTIONS=1&goto arg-ok\n-if /i \"%1\"==\"debug-http2\"   set debug_http2=1&goto arg-ok\n if /i \"%1\"==\"debug-nghttp2\" set debug_nghttp2=1&goto arg-ok\n if /i \"%1\"==\"link-module\"   set \"link_module= --link-module=%2%link_module%\"&goto arg-ok-2\n if /i \"%1\"==\"no-cctest\"     set no_cctest=1&goto arg-ok"
        }
    ],
    "stats": {
        "total": 269,
        "additions": 115,
        "deletions": 154
    }
}