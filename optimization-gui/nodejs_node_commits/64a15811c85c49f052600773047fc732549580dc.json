{
    "author": "gengjiawen",
    "message": "deps: update acorn to 6.1.0\n\nPR-URL: https://github.com/nodejs/node/pull/26102\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "64a15811c85c49f052600773047fc732549580dc",
    "files": [
        {
            "sha": "430b0b5cd14247163a1c1020611f6ab1eb81d156",
            "filename": "deps/acorn/acorn/CHANGELOG.md",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2FCHANGELOG.md",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2FCHANGELOG.md?ref=64a15811c85c49f052600773047fc732549580dc",
            "patch": "@@ -1,3 +1,13 @@\n+## 6.1.0 (2019-02-08)\n+\n+### Bug fixes\n+\n+Fix scope checking when redefining a `var` as a lexical binding.\n+\n+### New features\n+\n+Split up `parseSubscripts` to use an internal `parseSubscript` method to make it easier to extend with plugins.\n+\n ## 6.0.7 (2019-02-04)\n \n ### Bug fixes"
        },
        {
            "sha": null,
            "filename": "deps/acorn/acorn/bin/acorn",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fbin%2Facorn",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fbin%2Facorn",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fbin%2Facorn?ref=64a15811c85c49f052600773047fc732549580dc"
        },
        {
            "sha": "44d95c5fae74db6f7e2a95da8f28d51125b8dfdb",
            "filename": "deps/acorn/acorn/dist/acorn.js",
            "status": "modified",
            "additions": 49,
            "deletions": 43,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.js?ref=64a15811c85c49f052600773047fc732549580dc",
            "patch": "@@ -607,7 +607,7 @@ pp.strictDirective = function(start) {\n     // Skip semicolon, if any.\n     skipWhiteSpace.lastIndex = start;\n     start += skipWhiteSpace.exec(this$1.input)[0].length;\n-    if (this$1.input[start] === ';')\n+    if (this$1.input[start] === \";\")\n       { start++; }\n   }\n };\n@@ -2139,47 +2139,53 @@ pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n \n   var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n       this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n-  for (var computed = (void 0);;) {\n-    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n-      var node = this$1.startNodeAt(startPos, startLoc);\n-      node.object = base;\n-      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n-      node.computed = !!computed;\n-      if (computed) { this$1.expect(types.bracketR); }\n-      base = this$1.finishNode(node, \"MemberExpression\");\n-    } else if (!noCalls && this$1.eat(types.parenL)) {\n-      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos, oldAwaitIdentPos = this$1.awaitIdentPos;\n-      this$1.yieldPos = 0;\n-      this$1.awaitPos = 0;\n-      this$1.awaitIdentPos = 0;\n-      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n-      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n-        this$1.checkPatternErrors(refDestructuringErrors, false);\n-        this$1.checkYieldAwaitInDefaultParams();\n-        if (this$1.awaitIdentPos > 0)\n-          { this$1.raise(this$1.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n-        this$1.yieldPos = oldYieldPos;\n-        this$1.awaitPos = oldAwaitPos;\n-        this$1.awaitIdentPos = oldAwaitIdentPos;\n-        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n-      }\n-      this$1.checkExpressionErrors(refDestructuringErrors, true);\n-      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n-      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n-      this$1.awaitIdentPos = oldAwaitIdentPos || this$1.awaitIdentPos;\n-      var node$1 = this$1.startNodeAt(startPos, startLoc);\n-      node$1.callee = base;\n-      node$1.arguments = exprList;\n-      base = this$1.finishNode(node$1, \"CallExpression\");\n-    } else if (this$1.type === types.backQuote) {\n-      var node$2 = this$1.startNodeAt(startPos, startLoc);\n-      node$2.tag = base;\n-      node$2.quasi = this$1.parseTemplate({isTagged: true});\n-      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n-    } else {\n-      return base\n+  while (true) {\n+    var element = this$1.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n+    if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n+    base = element;\n+  }\n+};\n+\n+pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n+  var computed = this.eat(types.bracketL);\n+  if (computed || this.eat(types.dot)) {\n+    var node = this.startNodeAt(startPos, startLoc);\n+    node.object = base;\n+    node.property = computed ? this.parseExpression() : this.parseIdent(true);\n+    node.computed = !!computed;\n+    if (computed) { this.expect(types.bracketR); }\n+    base = this.finishNode(node, \"MemberExpression\");\n+  } else if (!noCalls && this.eat(types.parenL)) {\n+    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n+    this.yieldPos = 0;\n+    this.awaitPos = 0;\n+    this.awaitIdentPos = 0;\n+    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n+    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n+      this.checkPatternErrors(refDestructuringErrors, false);\n+      this.checkYieldAwaitInDefaultParams();\n+      if (this.awaitIdentPos > 0)\n+        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n+      this.yieldPos = oldYieldPos;\n+      this.awaitPos = oldAwaitPos;\n+      this.awaitIdentPos = oldAwaitIdentPos;\n+      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n     }\n+    this.checkExpressionErrors(refDestructuringErrors, true);\n+    this.yieldPos = oldYieldPos || this.yieldPos;\n+    this.awaitPos = oldAwaitPos || this.awaitPos;\n+    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n+    var node$1 = this.startNodeAt(startPos, startLoc);\n+    node$1.callee = base;\n+    node$1.arguments = exprList;\n+    base = this.finishNode(node$1, \"CallExpression\");\n+  } else if (this.type === types.backQuote) {\n+    var node$2 = this.startNodeAt(startPos, startLoc);\n+    node$2.tag = base;\n+    node$2.quasi = this.parseTemplate({isTagged: true});\n+    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n   }\n+  return base\n };\n \n // Parse an atomic expression — either a single token that is an\n@@ -2874,7 +2880,7 @@ pp$5.exitScope = function() {\n // > At the top level of a function, or script, function declarations are\n // > treated like var declarations rather than like lexical declarations.\n pp$5.treatFunctionsAsVarInScope = function(scope) {\n-  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP);\n+  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n };\n \n pp$5.declareName = function(name, bindingType, pos) {\n@@ -2900,7 +2906,7 @@ pp$5.declareName = function(name, bindingType, pos) {\n   } else {\n     for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n       var scope$3 = this$1.scopeStack[i];\n-      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name ||\n+      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n           !this$1.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n         redeclared = true;\n         break\n@@ -4955,7 +4961,7 @@ pp$8.readWord = function() {\n //\n // [walk]: util/walk.js\n \n-var version = \"6.0.7\";\n+var version = \"6.1.0\";\n \n // The main exported interface (under `self.acorn` when in the\n // browser) is a `parse` function that takes a code string and"
        },
        {
            "sha": "219dac5954a3be40809ada8c4feac1705b5c9dee",
            "filename": "deps/acorn/acorn/dist/acorn.js.map",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js.map",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.js.map?ref=64a15811c85c49f052600773047fc732549580dc"
        },
        {
            "sha": "0f67d79cd8f79096fa28e70c9aa62bd037b596d6",
            "filename": "deps/acorn/acorn/dist/acorn.mjs",
            "status": "modified",
            "additions": 49,
            "deletions": 43,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs?ref=64a15811c85c49f052600773047fc732549580dc",
            "patch": "@@ -601,7 +601,7 @@ pp.strictDirective = function(start) {\n     // Skip semicolon, if any.\n     skipWhiteSpace.lastIndex = start;\n     start += skipWhiteSpace.exec(this$1.input)[0].length;\n-    if (this$1.input[start] === ';')\n+    if (this$1.input[start] === \";\")\n       { start++; }\n   }\n };\n@@ -2133,47 +2133,53 @@ pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n \n   var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n       this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n-  for (var computed = (void 0);;) {\n-    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n-      var node = this$1.startNodeAt(startPos, startLoc);\n-      node.object = base;\n-      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n-      node.computed = !!computed;\n-      if (computed) { this$1.expect(types.bracketR); }\n-      base = this$1.finishNode(node, \"MemberExpression\");\n-    } else if (!noCalls && this$1.eat(types.parenL)) {\n-      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos, oldAwaitIdentPos = this$1.awaitIdentPos;\n-      this$1.yieldPos = 0;\n-      this$1.awaitPos = 0;\n-      this$1.awaitIdentPos = 0;\n-      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n-      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n-        this$1.checkPatternErrors(refDestructuringErrors, false);\n-        this$1.checkYieldAwaitInDefaultParams();\n-        if (this$1.awaitIdentPos > 0)\n-          { this$1.raise(this$1.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n-        this$1.yieldPos = oldYieldPos;\n-        this$1.awaitPos = oldAwaitPos;\n-        this$1.awaitIdentPos = oldAwaitIdentPos;\n-        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n-      }\n-      this$1.checkExpressionErrors(refDestructuringErrors, true);\n-      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n-      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n-      this$1.awaitIdentPos = oldAwaitIdentPos || this$1.awaitIdentPos;\n-      var node$1 = this$1.startNodeAt(startPos, startLoc);\n-      node$1.callee = base;\n-      node$1.arguments = exprList;\n-      base = this$1.finishNode(node$1, \"CallExpression\");\n-    } else if (this$1.type === types.backQuote) {\n-      var node$2 = this$1.startNodeAt(startPos, startLoc);\n-      node$2.tag = base;\n-      node$2.quasi = this$1.parseTemplate({isTagged: true});\n-      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n-    } else {\n-      return base\n+  while (true) {\n+    var element = this$1.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n+    if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n+    base = element;\n+  }\n+};\n+\n+pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n+  var computed = this.eat(types.bracketL);\n+  if (computed || this.eat(types.dot)) {\n+    var node = this.startNodeAt(startPos, startLoc);\n+    node.object = base;\n+    node.property = computed ? this.parseExpression() : this.parseIdent(true);\n+    node.computed = !!computed;\n+    if (computed) { this.expect(types.bracketR); }\n+    base = this.finishNode(node, \"MemberExpression\");\n+  } else if (!noCalls && this.eat(types.parenL)) {\n+    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n+    this.yieldPos = 0;\n+    this.awaitPos = 0;\n+    this.awaitIdentPos = 0;\n+    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n+    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n+      this.checkPatternErrors(refDestructuringErrors, false);\n+      this.checkYieldAwaitInDefaultParams();\n+      if (this.awaitIdentPos > 0)\n+        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n+      this.yieldPos = oldYieldPos;\n+      this.awaitPos = oldAwaitPos;\n+      this.awaitIdentPos = oldAwaitIdentPos;\n+      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n     }\n+    this.checkExpressionErrors(refDestructuringErrors, true);\n+    this.yieldPos = oldYieldPos || this.yieldPos;\n+    this.awaitPos = oldAwaitPos || this.awaitPos;\n+    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n+    var node$1 = this.startNodeAt(startPos, startLoc);\n+    node$1.callee = base;\n+    node$1.arguments = exprList;\n+    base = this.finishNode(node$1, \"CallExpression\");\n+  } else if (this.type === types.backQuote) {\n+    var node$2 = this.startNodeAt(startPos, startLoc);\n+    node$2.tag = base;\n+    node$2.quasi = this.parseTemplate({isTagged: true});\n+    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n   }\n+  return base\n };\n \n // Parse an atomic expression — either a single token that is an\n@@ -2868,7 +2874,7 @@ pp$5.exitScope = function() {\n // > At the top level of a function, or script, function declarations are\n // > treated like var declarations rather than like lexical declarations.\n pp$5.treatFunctionsAsVarInScope = function(scope) {\n-  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP);\n+  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n };\n \n pp$5.declareName = function(name, bindingType, pos) {\n@@ -2894,7 +2900,7 @@ pp$5.declareName = function(name, bindingType, pos) {\n   } else {\n     for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n       var scope$3 = this$1.scopeStack[i];\n-      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name ||\n+      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n           !this$1.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n         redeclared = true;\n         break\n@@ -4949,7 +4955,7 @@ pp$8.readWord = function() {\n //\n // [walk]: util/walk.js\n \n-var version = \"6.0.7\";\n+var version = \"6.1.0\";\n \n // The main exported interface (under `self.acorn` when in the\n // browser) is a `parse` function that takes a code string and"
        },
        {
            "sha": "e689d6c223b921f8e6a4d96b22b42c4c996366c9",
            "filename": "deps/acorn/acorn/dist/acorn.mjs.map",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs.map",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs.map?ref=64a15811c85c49f052600773047fc732549580dc"
        },
        {
            "sha": "fc42527fd4a8f1be5c2884ed6b0c62cd10a09685",
            "filename": "deps/acorn/acorn/package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/64a15811c85c49f052600773047fc732549580dc/deps%2Facorn%2Facorn%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fpackage.json?ref=64a15811c85c49f052600773047fc732549580dc",
            "patch": "@@ -4,7 +4,7 @@\n   \"homepage\": \"https://github.com/acornjs/acorn\",\n   \"main\": \"dist/acorn.js\",\n   \"module\": \"dist/acorn.mjs\",\n-  \"version\": \"6.0.7\",\n+  \"version\": \"6.1.0\",\n   \"engines\": {\"node\": \">=0.4.0\"},\n   \"maintainers\": [\n     {"
        }
    ],
    "stats": {
        "total": 200,
        "additions": 111,
        "deletions": 89
    }
}