{
    "author": "srl295",
    "message": "deps: icu: apply workaround patch\n\nICU 62.1 had a bug where certain orders of operations would not\nwork with the minimum significant digit setting. Fixed in\nICU 63.1. Applied the following patch from v8.\n\nhttps://chromium-review.googlesource.com/c/chromium/deps/icu/+/1128503\n\nICU Bug:\nhttps://unicode-org.atlassian.net/browse/ICU-20063\n\nFixes: https://github.com/nodejs/node/issues/22156\n\nPR-URL: https://github.com/nodejs/node/pull/23764\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "4194b051e8271efc2f778d02cd8dec7030fb2a68",
    "files": [
        {
            "sha": "c55f554b00f55aec0c3e1431807ab99c5869117f",
            "filename": "test/parallel/test-intl.js",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/4194b051e8271efc2f778d02cd8dec7030fb2a68/test%2Fparallel%2Ftest-intl.js",
            "raw_url": "https://github.com/nodejs/node/raw/4194b051e8271efc2f778d02cd8dec7030fb2a68/test%2Fparallel%2Ftest-intl.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-intl.js?ref=4194b051e8271efc2f778d02cd8dec7030fb2a68",
            "patch": "@@ -99,8 +99,18 @@ if (!common.hasIntl) {\n     assert.strictEqual(localeString, '1/1/1970, 12:00:00 AM');\n   }\n   // number format\n-  const numberFormat = new Intl.NumberFormat(['en']).format(12345.67890);\n-  assert.strictEqual(numberFormat, '12,345.679');\n+  {\n+    const numberFormat = new Intl.NumberFormat(['en']).format(12345.67890);\n+    assert.strictEqual(numberFormat, '12,345.679');\n+  }\n+  // Significant Digits\n+  {\n+    const loc = ['en-US'];\n+    const opts = { maximumSignificantDigits: 4 };\n+    const num = 10.001;\n+    const numberFormat = new Intl.NumberFormat(loc, opts).format(num);\n+    assert.strictEqual(numberFormat, '10');\n+  }\n \n   const collOpts = { sensitivity: 'base', ignorePunctuation: true };\n   const coll = new Intl.Collator(['en'], collOpts);"
        },
        {
            "sha": "8ae773b75c2aa2809c6b3b83e3bd23f18ace6329",
            "filename": "tools/icu/patches/62/source/i18n/decimfmt.cpp",
            "status": "added",
            "additions": 1384,
            "deletions": 0,
            "changes": 1384,
            "blob_url": "https://github.com/nodejs/node/blob/4194b051e8271efc2f778d02cd8dec7030fb2a68/tools%2Ficu%2Fpatches%2F62%2Fsource%2Fi18n%2Fdecimfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/4194b051e8271efc2f778d02cd8dec7030fb2a68/tools%2Ficu%2Fpatches%2F62%2Fsource%2Fi18n%2Fdecimfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Ficu%2Fpatches%2F62%2Fsource%2Fi18n%2Fdecimfmt.cpp?ref=4194b051e8271efc2f778d02cd8dec7030fb2a68",
            "patch": "@@ -0,0 +1,1384 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+#include \"unicode/utypes.h\"\n+\n+#if !UCONFIG_NO_FORMATTING\n+\n+// Allow implicit conversion from char16_t* to UnicodeString for this file:\n+// Helpful in toString methods and elsewhere.\n+#define UNISTR_FROM_STRING_EXPLICIT\n+\n+#include <cmath>\n+#include <cstdlib>\n+#include <stdlib.h>\n+#include \"unicode/errorcode.h\"\n+#include \"unicode/decimfmt.h\"\n+#include \"number_decimalquantity.h\"\n+#include \"number_types.h\"\n+#include \"numparse_impl.h\"\n+#include \"number_mapper.h\"\n+#include \"number_patternstring.h\"\n+#include \"putilimp.h\"\n+#include \"number_utils.h\"\n+#include \"number_utypes.h\"\n+\n+using namespace icu;\n+using namespace icu::number;\n+using namespace icu::number::impl;\n+using namespace icu::numparse;\n+using namespace icu::numparse::impl;\n+using ERoundingMode = icu::DecimalFormat::ERoundingMode;\n+using EPadPosition = icu::DecimalFormat::EPadPosition;\n+\n+// MSVC warns C4805 when comparing bool with UBool\n+// TODO: Move this macro into a better place?\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n+#define UBOOL_TO_BOOL(b) static_cast<bool>(b)\n+#else\n+#define UBOOL_TO_BOOL(b) b\n+#endif\n+\n+\n+UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DecimalFormat)\n+\n+\n+DecimalFormat::DecimalFormat(UErrorCode& status)\n+        : DecimalFormat(nullptr, status) {\n+    // Use the default locale and decimal pattern.\n+    const char* localeName = Locale::getDefault().getName();\n+    LocalPointer<NumberingSystem> ns(NumberingSystem::createInstance(status));\n+    UnicodeString patternString = utils::getPatternForStyle(\n+            localeName,\n+            ns->getName(),\n+            CLDR_PATTERN_STYLE_DECIMAL,\n+            status);\n+    setPropertiesFromPattern(patternString, IGNORE_ROUNDING_IF_CURRENCY, status);\n+    touch(status);\n+}\n+\n+DecimalFormat::DecimalFormat(const UnicodeString& pattern, UErrorCode& status)\n+        : DecimalFormat(nullptr, status) {\n+    setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);\n+    touch(status);\n+}\n+\n+DecimalFormat::DecimalFormat(const UnicodeString& pattern, DecimalFormatSymbols* symbolsToAdopt,\n+                             UErrorCode& status)\n+        : DecimalFormat(symbolsToAdopt, status) {\n+    setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);\n+    touch(status);\n+}\n+\n+DecimalFormat::DecimalFormat(const UnicodeString& pattern, DecimalFormatSymbols* symbolsToAdopt,\n+                             UNumberFormatStyle style, UErrorCode& status)\n+        : DecimalFormat(symbolsToAdopt, status) {\n+    // If choice is a currency type, ignore the rounding information.\n+    if (style == UNumberFormatStyle::UNUM_CURRENCY || style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||\n+        style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||\n+        style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||\n+        style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||\n+        style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {\n+        setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);\n+    } else {\n+        setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);\n+    }\n+    // Note: in Java, CurrencyPluralInfo is set in NumberFormat.java, but in C++, it is not set there,\n+    // so we have to set it here.\n+    if (style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {\n+        LocalPointer<CurrencyPluralInfo> cpi(\n+                new CurrencyPluralInfo(fields->symbols->getLocale(), status),\n+                status);\n+        if (U_FAILURE(status)) { return; }\n+        fields->properties->currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());\n+    }\n+    touch(status);\n+}\n+\n+DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode& status) {\n+    LocalPointer<const DecimalFormatSymbols> adoptedSymbols(symbolsToAdopt);\n+    fields = new DecimalFormatFields();\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+    if (fields == nullptr) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    fields->properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);\n+    fields->exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);\n+    if (adoptedSymbols.isNull()) {\n+        fields->symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);\n+    } else {\n+        fields->symbols.adoptInsteadAndCheckErrorCode(adoptedSymbols.orphan(), status);\n+    }\n+}\n+\n+#if UCONFIG_HAVE_PARSEALLINPUT\n+\n+void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {\n+    if (value == fields->properties->parseAllInput) { return; }\n+    fields->properties->parseAllInput = value;\n+}\n+\n+#endif\n+\n+DecimalFormat&\n+DecimalFormat::setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode& status) {\n+    if (U_FAILURE(status)) { return *this; }\n+\n+    switch (attr) {\n+        case UNUM_LENIENT_PARSE:\n+            setLenient(newValue != 0);\n+            break;\n+\n+        case UNUM_PARSE_INT_ONLY:\n+            setParseIntegerOnly(newValue != 0);\n+            break;\n+\n+        case UNUM_GROUPING_USED:\n+            setGroupingUsed(newValue != 0);\n+            break;\n+\n+        case UNUM_DECIMAL_ALWAYS_SHOWN:\n+            setDecimalSeparatorAlwaysShown(newValue != 0);\n+            break;\n+\n+        case UNUM_MAX_INTEGER_DIGITS:\n+            setMaximumIntegerDigits(newValue);\n+            break;\n+\n+        case UNUM_MIN_INTEGER_DIGITS:\n+            setMinimumIntegerDigits(newValue);\n+            break;\n+\n+        case UNUM_INTEGER_DIGITS:\n+            setMinimumIntegerDigits(newValue);\n+            setMaximumIntegerDigits(newValue);\n+            break;\n+\n+        case UNUM_MAX_FRACTION_DIGITS:\n+            setMaximumFractionDigits(newValue);\n+            break;\n+\n+        case UNUM_MIN_FRACTION_DIGITS:\n+            setMinimumFractionDigits(newValue);\n+            break;\n+\n+        case UNUM_FRACTION_DIGITS:\n+            setMinimumFractionDigits(newValue);\n+            setMaximumFractionDigits(newValue);\n+            break;\n+\n+        case UNUM_SIGNIFICANT_DIGITS_USED:\n+            setSignificantDigitsUsed(newValue != 0);\n+            break;\n+\n+        case UNUM_MAX_SIGNIFICANT_DIGITS:\n+            setMaximumSignificantDigits(newValue);\n+            break;\n+\n+        case UNUM_MIN_SIGNIFICANT_DIGITS:\n+            setMinimumSignificantDigits(newValue);\n+            break;\n+\n+        case UNUM_MULTIPLIER:\n+            setMultiplier(newValue);\n+            break;\n+\n+        case UNUM_SCALE:\n+            setMultiplierScale(newValue);\n+            break;\n+\n+        case UNUM_GROUPING_SIZE:\n+            setGroupingSize(newValue);\n+            break;\n+\n+        case UNUM_ROUNDING_MODE:\n+            setRoundingMode((DecimalFormat::ERoundingMode) newValue);\n+            break;\n+\n+        case UNUM_FORMAT_WIDTH:\n+            setFormatWidth(newValue);\n+            break;\n+\n+        case UNUM_PADDING_POSITION:\n+            /** The position at which padding will take place. */\n+            setPadPosition((DecimalFormat::EPadPosition) newValue);\n+            break;\n+\n+        case UNUM_SECONDARY_GROUPING_SIZE:\n+            setSecondaryGroupingSize(newValue);\n+            break;\n+\n+#if UCONFIG_HAVE_PARSEALLINPUT\n+        case UNUM_PARSE_ALL_INPUT:\n+            setParseAllInput((UNumberFormatAttributeValue) newValue);\n+            break;\n+#endif\n+\n+        case UNUM_PARSE_NO_EXPONENT:\n+            setParseNoExponent((UBool) newValue);\n+            break;\n+\n+        case UNUM_PARSE_DECIMAL_MARK_REQUIRED:\n+            setDecimalPatternMatchRequired((UBool) newValue);\n+            break;\n+\n+        case UNUM_CURRENCY_USAGE:\n+            setCurrencyUsage((UCurrencyUsage) newValue, &status);\n+            break;\n+\n+        case UNUM_MINIMUM_GROUPING_DIGITS:\n+            setMinimumGroupingDigits(newValue);\n+            break;\n+\n+        case UNUM_PARSE_CASE_SENSITIVE:\n+            setParseCaseSensitive(static_cast<UBool>(newValue));\n+            break;\n+\n+        case UNUM_SIGN_ALWAYS_SHOWN:\n+            setSignAlwaysShown(static_cast<UBool>(newValue));\n+            break;\n+\n+        case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:\n+            setFormatFailIfMoreThanMaxDigits(static_cast<UBool>(newValue));\n+            break;\n+\n+        default:\n+            status = U_UNSUPPORTED_ERROR;\n+            break;\n+    }\n+    return *this;\n+}\n+\n+int32_t DecimalFormat::getAttribute(UNumberFormatAttribute attr, UErrorCode& status) const {\n+    if (U_FAILURE(status)) { return -1; }\n+    switch (attr) {\n+        case UNUM_LENIENT_PARSE:\n+            return isLenient();\n+\n+        case UNUM_PARSE_INT_ONLY:\n+            return isParseIntegerOnly();\n+\n+        case UNUM_GROUPING_USED:\n+            return isGroupingUsed();\n+\n+        case UNUM_DECIMAL_ALWAYS_SHOWN:\n+            return isDecimalSeparatorAlwaysShown();\n+\n+        case UNUM_MAX_INTEGER_DIGITS:\n+            return getMaximumIntegerDigits();\n+\n+        case UNUM_MIN_INTEGER_DIGITS:\n+            return getMinimumIntegerDigits();\n+\n+        case UNUM_INTEGER_DIGITS:\n+            // TBD: what should this return?\n+            return getMinimumIntegerDigits();\n+\n+        case UNUM_MAX_FRACTION_DIGITS:\n+            return getMaximumFractionDigits();\n+\n+        case UNUM_MIN_FRACTION_DIGITS:\n+            return getMinimumFractionDigits();\n+\n+        case UNUM_FRACTION_DIGITS:\n+            // TBD: what should this return?\n+            return getMinimumFractionDigits();\n+\n+        case UNUM_SIGNIFICANT_DIGITS_USED:\n+            return areSignificantDigitsUsed();\n+\n+        case UNUM_MAX_SIGNIFICANT_DIGITS:\n+            return getMaximumSignificantDigits();\n+\n+        case UNUM_MIN_SIGNIFICANT_DIGITS:\n+            return getMinimumSignificantDigits();\n+\n+        case UNUM_MULTIPLIER:\n+            return getMultiplier();\n+\n+        case UNUM_SCALE:\n+            return getMultiplierScale();\n+\n+        case UNUM_GROUPING_SIZE:\n+            return getGroupingSize();\n+\n+        case UNUM_ROUNDING_MODE:\n+            return getRoundingMode();\n+\n+        case UNUM_FORMAT_WIDTH:\n+            return getFormatWidth();\n+\n+        case UNUM_PADDING_POSITION:\n+            return getPadPosition();\n+\n+        case UNUM_SECONDARY_GROUPING_SIZE:\n+            return getSecondaryGroupingSize();\n+\n+        case UNUM_PARSE_NO_EXPONENT:\n+            return isParseNoExponent();\n+\n+        case UNUM_PARSE_DECIMAL_MARK_REQUIRED:\n+            return isDecimalPatternMatchRequired();\n+\n+        case UNUM_CURRENCY_USAGE:\n+            return getCurrencyUsage();\n+\n+        case UNUM_MINIMUM_GROUPING_DIGITS:\n+            return getMinimumGroupingDigits();\n+\n+        case UNUM_PARSE_CASE_SENSITIVE:\n+            return isParseCaseSensitive();\n+\n+        case UNUM_SIGN_ALWAYS_SHOWN:\n+            return isSignAlwaysShown();\n+\n+        case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:\n+            return isFormatFailIfMoreThanMaxDigits();\n+\n+        default:\n+            status = U_UNSUPPORTED_ERROR;\n+            break;\n+    }\n+\n+    return -1; /* undefined */\n+}\n+\n+void DecimalFormat::setGroupingUsed(UBool enabled) {\n+    if (UBOOL_TO_BOOL(enabled) == fields->properties->groupingUsed) { return; }\n+    NumberFormat::setGroupingUsed(enabled); // to set field for compatibility\n+    fields->properties->groupingUsed = enabled;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setParseIntegerOnly(UBool value) {\n+    if (UBOOL_TO_BOOL(value) == fields->properties->parseIntegerOnly) { return; }\n+    NumberFormat::setParseIntegerOnly(value); // to set field for compatibility\n+    fields->properties->parseIntegerOnly = value;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setLenient(UBool enable) {\n+    ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;\n+    if (!fields->properties->parseMode.isNull() && mode == fields->properties->parseMode.getNoError()) { return; }\n+    NumberFormat::setLenient(enable); // to set field for compatibility\n+    fields->properties->parseMode = mode;\n+    touchNoError();\n+}\n+\n+DecimalFormat::DecimalFormat(const UnicodeString& pattern, DecimalFormatSymbols* symbolsToAdopt,\n+                             UParseError&, UErrorCode& status)\n+        : DecimalFormat(symbolsToAdopt, status) {\n+    // TODO: What is parseError for?\n+    setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);\n+    touch(status);\n+}\n+\n+DecimalFormat::DecimalFormat(const UnicodeString& pattern, const DecimalFormatSymbols& symbols,\n+                             UErrorCode& status)\n+        : DecimalFormat(new DecimalFormatSymbols(symbols), status) {\n+    setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);\n+    touch(status);\n+}\n+\n+DecimalFormat::DecimalFormat(const DecimalFormat& source) : NumberFormat(source) {\n+    // Note: it is not safe to copy fields->formatter or fWarehouse directly because fields->formatter might have\n+    // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields->formatter from\n+    // the property bag, despite being somewhat slower.\n+    fields = new DecimalFormatFields();\n+    if (fields == nullptr) {\n+        return;\n+    }\n+    fields->properties.adoptInstead(new DecimalFormatProperties(*source.fields->properties));\n+    fields->symbols.adoptInstead(new DecimalFormatSymbols(*source.fields->symbols));\n+    fields->exportedProperties.adoptInstead(new DecimalFormatProperties());\n+    if (fields->properties == nullptr || fields->symbols == nullptr || fields->exportedProperties == nullptr) {\n+        return;\n+    }\n+    touchNoError();\n+}\n+\n+DecimalFormat& DecimalFormat::operator=(const DecimalFormat& rhs) {\n+    *fields->properties = *rhs.fields->properties;\n+    fields->exportedProperties->clear();\n+    fields->symbols.adoptInstead(new DecimalFormatSymbols(*rhs.fields->symbols));\n+    touchNoError();\n+    return *this;\n+}\n+\n+DecimalFormat::~DecimalFormat() {\n+    delete fields->atomicParser.exchange(nullptr);\n+    delete fields->atomicCurrencyParser.exchange(nullptr);\n+\tdelete fields;\n+}\n+\n+Format* DecimalFormat::clone() const {\n+    return new DecimalFormat(*this);\n+}\n+\n+UBool DecimalFormat::operator==(const Format& other) const {\n+    auto* otherDF = dynamic_cast<const DecimalFormat*>(&other);\n+    if (otherDF == nullptr) {\n+        return false;\n+    }\n+    return *fields->properties == *otherDF->fields->properties && *fields->symbols == *otherDF->fields->symbols;\n+}\n+\n+UnicodeString& DecimalFormat::format(double number, UnicodeString& appendTo, FieldPosition& pos) const {\n+    if (pos.getField() == FieldPosition::DONT_CARE && fastFormatDouble(number, appendTo)) {\n+        return appendTo;\n+    }\n+    UErrorCode localStatus = U_ZERO_ERROR;\n+    FormattedNumber output = fields->formatter->formatDouble(number, localStatus);\n+    fieldPositionHelper(output, pos, appendTo.length(), localStatus);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString& DecimalFormat::format(double number, UnicodeString& appendTo, FieldPosition& pos,\n+                                     UErrorCode& status) const {\n+    if (pos.getField() == FieldPosition::DONT_CARE && fastFormatDouble(number, appendTo)) {\n+        return appendTo;\n+    }\n+    FormattedNumber output = fields->formatter->formatDouble(number, status);\n+    fieldPositionHelper(output, pos, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString&\n+DecimalFormat::format(double number, UnicodeString& appendTo, FieldPositionIterator* posIter,\n+                      UErrorCode& status) const {\n+    if (posIter == nullptr && fastFormatDouble(number, appendTo)) {\n+        return appendTo;\n+    }\n+    FormattedNumber output = fields->formatter->formatDouble(number, status);\n+    fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString& DecimalFormat::format(int32_t number, UnicodeString& appendTo, FieldPosition& pos) const {\n+    return format(static_cast<int64_t> (number), appendTo, pos);\n+}\n+\n+UnicodeString& DecimalFormat::format(int32_t number, UnicodeString& appendTo, FieldPosition& pos,\n+                                     UErrorCode& status) const {\n+    return format(static_cast<int64_t> (number), appendTo, pos, status);\n+}\n+\n+UnicodeString&\n+DecimalFormat::format(int32_t number, UnicodeString& appendTo, FieldPositionIterator* posIter,\n+                      UErrorCode& status) const {\n+    return format(static_cast<int64_t> (number), appendTo, posIter, status);\n+}\n+\n+UnicodeString& DecimalFormat::format(int64_t number, UnicodeString& appendTo, FieldPosition& pos) const {\n+    if (pos.getField() == FieldPosition::DONT_CARE && fastFormatInt64(number, appendTo)) {\n+        return appendTo;\n+    }\n+    UErrorCode localStatus = U_ZERO_ERROR;\n+    FormattedNumber output = fields->formatter->formatInt(number, localStatus);\n+    fieldPositionHelper(output, pos, appendTo.length(), localStatus);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString& DecimalFormat::format(int64_t number, UnicodeString& appendTo, FieldPosition& pos,\n+                                     UErrorCode& status) const {\n+    if (pos.getField() == FieldPosition::DONT_CARE && fastFormatInt64(number, appendTo)) {\n+        return appendTo;\n+    }\n+    FormattedNumber output = fields->formatter->formatInt(number, status);\n+    fieldPositionHelper(output, pos, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString&\n+DecimalFormat::format(int64_t number, UnicodeString& appendTo, FieldPositionIterator* posIter,\n+                      UErrorCode& status) const {\n+    if (posIter == nullptr && fastFormatInt64(number, appendTo)) {\n+        return appendTo;\n+    }\n+    FormattedNumber output = fields->formatter->formatInt(number, status);\n+    fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString&\n+DecimalFormat::format(StringPiece number, UnicodeString& appendTo, FieldPositionIterator* posIter,\n+                      UErrorCode& status) const {\n+    FormattedNumber output = fields->formatter->formatDecimal(number, status);\n+    fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString& DecimalFormat::format(const DecimalQuantity& number, UnicodeString& appendTo,\n+                                     FieldPositionIterator* posIter, UErrorCode& status) const {\n+    FormattedNumber output = fields->formatter->formatDecimalQuantity(number, status);\n+    fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+UnicodeString&\n+DecimalFormat::format(const DecimalQuantity& number, UnicodeString& appendTo, FieldPosition& pos,\n+                      UErrorCode& status) const {\n+    FormattedNumber output = fields->formatter->formatDecimalQuantity(number, status);\n+    fieldPositionHelper(output, pos, appendTo.length(), status);\n+    auto appendable = UnicodeStringAppendable(appendTo);\n+    output.appendTo(appendable);\n+    return appendTo;\n+}\n+\n+void DecimalFormat::parse(const UnicodeString& text, Formattable& output,\n+                          ParsePosition& parsePosition) const {\n+    if (parsePosition.getIndex() < 0 || parsePosition.getIndex() >= text.length()) {\n+        return;\n+    }\n+\n+    ErrorCode status;\n+    ParsedNumber result;\n+    // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the\n+    // parseCurrency method (backwards compatibility)\n+    int32_t startIndex = parsePosition.getIndex();\n+    const NumberParserImpl* parser = getParser(status);\n+    if (U_FAILURE(status)) { return; }\n+    parser->parse(text, startIndex, true, result, status);\n+    // TODO: Do we need to check for fImpl->properties->parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?\n+    if (result.success()) {\n+        parsePosition.setIndex(result.charEnd);\n+        result.populateFormattable(output, parser->getParseFlags());\n+    } else {\n+        parsePosition.setErrorIndex(startIndex + result.charEnd);\n+    }\n+}\n+\n+CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString& text, ParsePosition& parsePosition) const {\n+    if (parsePosition.getIndex() < 0 || parsePosition.getIndex() >= text.length()) {\n+        return nullptr;\n+    }\n+\n+    ErrorCode status;\n+    ParsedNumber result;\n+    // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the\n+    // parseCurrency method (backwards compatibility)\n+    int32_t startIndex = parsePosition.getIndex();\n+    const NumberParserImpl* parser = getCurrencyParser(status);\n+    if (U_FAILURE(status)) { return nullptr; }\n+    parser->parse(text, startIndex, true, result, status);\n+    // TODO: Do we need to check for fImpl->properties->parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?\n+    if (result.success()) {\n+        parsePosition.setIndex(result.charEnd);\n+        Formattable formattable;\n+        result.populateFormattable(formattable, parser->getParseFlags());\n+        return new CurrencyAmount(formattable, result.currencyCode, status);\n+    } else {\n+        parsePosition.setErrorIndex(startIndex + result.charEnd);\n+        return nullptr;\n+    }\n+}\n+\n+const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {\n+    return fields->symbols.getAlias();\n+}\n+\n+void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {\n+    if (symbolsToAdopt == nullptr) {\n+        return; // do not allow caller to set fields->symbols to NULL\n+    }\n+    fields->symbols.adoptInstead(symbolsToAdopt);\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols& symbols) {\n+    fields->symbols.adoptInstead(new DecimalFormatSymbols(symbols));\n+    touchNoError();\n+}\n+\n+const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {\n+    return fields->properties->currencyPluralInfo.fPtr.getAlias();\n+}\n+\n+void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {\n+    fields->properties->currencyPluralInfo.fPtr.adoptInstead(toAdopt);\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo& info) {\n+    if (fields->properties->currencyPluralInfo.fPtr.isNull()) {\n+        fields->properties->currencyPluralInfo.fPtr.adoptInstead(info.clone());\n+    } else {\n+        *fields->properties->currencyPluralInfo.fPtr = info; // copy-assignment operator\n+    }\n+    touchNoError();\n+}\n+\n+UnicodeString& DecimalFormat::getPositivePrefix(UnicodeString& result) const {\n+    ErrorCode localStatus;\n+    fields->formatter->getAffixImpl(true, false, result, localStatus);\n+    return result;\n+}\n+\n+void DecimalFormat::setPositivePrefix(const UnicodeString& newValue) {\n+    if (newValue == fields->properties->positivePrefix) { return; }\n+    fields->properties->positivePrefix = newValue;\n+    touchNoError();\n+}\n+\n+UnicodeString& DecimalFormat::getNegativePrefix(UnicodeString& result) const {\n+    ErrorCode localStatus;\n+    fields->formatter->getAffixImpl(true, true, result, localStatus);\n+    return result;\n+}\n+\n+void DecimalFormat::setNegativePrefix(const UnicodeString& newValue) {\n+    if (newValue == fields->properties->negativePrefix) { return; }\n+    fields->properties->negativePrefix = newValue;\n+    touchNoError();\n+}\n+\n+UnicodeString& DecimalFormat::getPositiveSuffix(UnicodeString& result) const {\n+    ErrorCode localStatus;\n+    fields->formatter->getAffixImpl(false, false, result, localStatus);\n+    return result;\n+}\n+\n+void DecimalFormat::setPositiveSuffix(const UnicodeString& newValue) {\n+    if (newValue == fields->properties->positiveSuffix) { return; }\n+    fields->properties->positiveSuffix = newValue;\n+    touchNoError();\n+}\n+\n+UnicodeString& DecimalFormat::getNegativeSuffix(UnicodeString& result) const {\n+    ErrorCode localStatus;\n+    fields->formatter->getAffixImpl(false, true, result, localStatus);\n+    return result;\n+}\n+\n+void DecimalFormat::setNegativeSuffix(const UnicodeString& newValue) {\n+    if (newValue == fields->properties->negativeSuffix) { return; }\n+    fields->properties->negativeSuffix = newValue;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isSignAlwaysShown() const {\n+    return fields->properties->signAlwaysShown;\n+}\n+\n+void DecimalFormat::setSignAlwaysShown(UBool value) {\n+    if (UBOOL_TO_BOOL(value) == fields->properties->signAlwaysShown) { return; }\n+    fields->properties->signAlwaysShown = value;\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getMultiplier(void) const {\n+    if (fields->properties->multiplier != 1) {\n+        return fields->properties->multiplier;\n+    } else if (fields->properties->magnitudeMultiplier != 0) {\n+        return static_cast<int32_t>(uprv_pow10(fields->properties->magnitudeMultiplier));\n+    } else {\n+        return 1;\n+    }\n+}\n+\n+void DecimalFormat::setMultiplier(int32_t multiplier) {\n+    if (multiplier == 0) {\n+        multiplier = 1;     // one being the benign default value for a multiplier.\n+    }\n+\n+    // Try to convert to a magnitude multiplier first\n+    int delta = 0;\n+    int value = multiplier;\n+    while (value != 1) {\n+        delta++;\n+        int temp = value / 10;\n+        if (temp * 10 != value) {\n+            delta = -1;\n+            break;\n+        }\n+        value = temp;\n+    }\n+    if (delta != -1) {\n+        fields->properties->magnitudeMultiplier = delta;\n+        fields->properties->multiplier = 1;\n+    } else {\n+        fields->properties->magnitudeMultiplier = 0;\n+        fields->properties->multiplier = multiplier;\n+    }\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getMultiplierScale() const {\n+    return fields->properties->multiplierScale;\n+}\n+\n+void DecimalFormat::setMultiplierScale(int32_t newValue) {\n+    if (newValue == fields->properties->multiplierScale) { return; }\n+    fields->properties->multiplierScale = newValue;\n+    touchNoError();\n+}\n+\n+double DecimalFormat::getRoundingIncrement(void) const {\n+    return fields->exportedProperties->roundingIncrement;\n+}\n+\n+void DecimalFormat::setRoundingIncrement(double newValue) {\n+    if (newValue == fields->properties->roundingIncrement) { return; }\n+    fields->properties->roundingIncrement = newValue;\n+    touchNoError();\n+}\n+\n+ERoundingMode DecimalFormat::getRoundingMode(void) const {\n+    // UNumberFormatRoundingMode and ERoundingMode have the same values.\n+    return static_cast<ERoundingMode>(fields->exportedProperties->roundingMode.getNoError());\n+}\n+\n+void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {\n+    auto uRoundingMode = static_cast<UNumberFormatRoundingMode>(roundingMode);\n+    if (!fields->properties->roundingMode.isNull() && uRoundingMode == fields->properties->roundingMode.getNoError()) {\n+        return;\n+    }\n+    NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility\n+    fields->properties->roundingMode = uRoundingMode;\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getFormatWidth(void) const {\n+    return fields->properties->formatWidth;\n+}\n+\n+void DecimalFormat::setFormatWidth(int32_t width) {\n+    if (width == fields->properties->formatWidth) { return; }\n+    fields->properties->formatWidth = width;\n+    touchNoError();\n+}\n+\n+UnicodeString DecimalFormat::getPadCharacterString() const {\n+    if (fields->properties->padString.isBogus()) {\n+        // Readonly-alias the static string kFallbackPaddingString\n+        return {TRUE, kFallbackPaddingString, -1};\n+    } else {\n+        return fields->properties->padString;\n+    }\n+}\n+\n+void DecimalFormat::setPadCharacter(const UnicodeString& padChar) {\n+    if (padChar == fields->properties->padString) { return; }\n+    if (padChar.length() > 0) {\n+        fields->properties->padString = UnicodeString(padChar.char32At(0));\n+    } else {\n+        fields->properties->padString.setToBogus();\n+    }\n+    touchNoError();\n+}\n+\n+EPadPosition DecimalFormat::getPadPosition(void) const {\n+    if (fields->properties->padPosition.isNull()) {\n+        return EPadPosition::kPadBeforePrefix;\n+    } else {\n+        // UNumberFormatPadPosition and EPadPosition have the same values.\n+        return static_cast<EPadPosition>(fields->properties->padPosition.getNoError());\n+    }\n+}\n+\n+void DecimalFormat::setPadPosition(EPadPosition padPos) {\n+    auto uPadPos = static_cast<UNumberFormatPadPosition>(padPos);\n+    if (!fields->properties->padPosition.isNull() && uPadPos == fields->properties->padPosition.getNoError()) {\n+        return;\n+    }\n+    fields->properties->padPosition = uPadPos;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isScientificNotation(void) const {\n+    return fields->properties->minimumExponentDigits != -1;\n+}\n+\n+void DecimalFormat::setScientificNotation(UBool useScientific) {\n+    int32_t minExp = useScientific ? 1 : -1;\n+    if (fields->properties->minimumExponentDigits == minExp) { return; }\n+    if (useScientific) {\n+        fields->properties->minimumExponentDigits = 1;\n+    } else {\n+        fields->properties->minimumExponentDigits = -1;\n+    }\n+    touchNoError();\n+}\n+\n+int8_t DecimalFormat::getMinimumExponentDigits(void) const {\n+    return static_cast<int8_t>(fields->properties->minimumExponentDigits);\n+}\n+\n+void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {\n+    if (minExpDig == fields->properties->minimumExponentDigits) { return; }\n+    fields->properties->minimumExponentDigits = minExpDig;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isExponentSignAlwaysShown(void) const {\n+    return fields->properties->exponentSignAlwaysShown;\n+}\n+\n+void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {\n+    if (UBOOL_TO_BOOL(expSignAlways) == fields->properties->exponentSignAlwaysShown) { return; }\n+    fields->properties->exponentSignAlwaysShown = expSignAlways;\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getGroupingSize(void) const {\n+    if (fields->properties->groupingSize < 0) {\n+        return 0;\n+    }\n+    return fields->properties->groupingSize;\n+}\n+\n+void DecimalFormat::setGroupingSize(int32_t newValue) {\n+    if (newValue == fields->properties->groupingSize) { return; }\n+    fields->properties->groupingSize = newValue;\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getSecondaryGroupingSize(void) const {\n+    int grouping2 = fields->properties->secondaryGroupingSize;\n+    if (grouping2 < 0) {\n+        return 0;\n+    }\n+    return grouping2;\n+}\n+\n+void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {\n+    if (newValue == fields->properties->secondaryGroupingSize) { return; }\n+    fields->properties->secondaryGroupingSize = newValue;\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getMinimumGroupingDigits() const {\n+    return fields->properties->minimumGroupingDigits;\n+}\n+\n+void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {\n+    if (newValue == fields->properties->minimumGroupingDigits) { return; }\n+    fields->properties->minimumGroupingDigits = newValue;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {\n+    return fields->properties->decimalSeparatorAlwaysShown;\n+}\n+\n+void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {\n+    if (UBOOL_TO_BOOL(newValue) == fields->properties->decimalSeparatorAlwaysShown) { return; }\n+    fields->properties->decimalSeparatorAlwaysShown = newValue;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {\n+    return fields->properties->decimalPatternMatchRequired;\n+}\n+\n+void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {\n+    if (UBOOL_TO_BOOL(newValue) == fields->properties->decimalPatternMatchRequired) { return; }\n+    fields->properties->decimalPatternMatchRequired = newValue;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isParseNoExponent() const {\n+    return fields->properties->parseNoExponent;\n+}\n+\n+void DecimalFormat::setParseNoExponent(UBool value) {\n+    if (UBOOL_TO_BOOL(value) == fields->properties->parseNoExponent) { return; }\n+    fields->properties->parseNoExponent = value;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isParseCaseSensitive() const {\n+    return fields->properties->parseCaseSensitive;\n+}\n+\n+void DecimalFormat::setParseCaseSensitive(UBool value) {\n+    if (UBOOL_TO_BOOL(value) == fields->properties->parseCaseSensitive) { return; }\n+    fields->properties->parseCaseSensitive = value;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {\n+    return fields->properties->formatFailIfMoreThanMaxDigits;\n+}\n+\n+void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {\n+    if (UBOOL_TO_BOOL(value) == fields->properties->formatFailIfMoreThanMaxDigits) { return; }\n+    fields->properties->formatFailIfMoreThanMaxDigits = value;\n+    touchNoError();\n+}\n+\n+UnicodeString& DecimalFormat::toPattern(UnicodeString& result) const {\n+    // Pull some properties from exportedProperties and others from properties\n+    // to keep affix patterns intact.  In particular, pull rounding properties\n+    // so that CurrencyUsage is reflected properly.\n+    // TODO: Consider putting this logic in number_patternstring.cpp instead.\n+    ErrorCode localStatus;\n+    DecimalFormatProperties tprops(*fields->properties);\n+    bool useCurrency = ((!tprops.currency.isNull()) || !tprops.currencyPluralInfo.fPtr.isNull() ||\n+                        !tprops.currencyUsage.isNull() || AffixUtils::hasCurrencySymbols(\n+            tprops.positivePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(\n+            tprops.positiveSuffixPattern, localStatus) || AffixUtils::hasCurrencySymbols(\n+            tprops.negativePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(\n+            tprops.negativeSuffixPattern, localStatus));\n+    if (useCurrency) {\n+        tprops.minimumFractionDigits = fields->exportedProperties->minimumFractionDigits;\n+        tprops.maximumFractionDigits = fields->exportedProperties->maximumFractionDigits;\n+        tprops.roundingIncrement = fields->exportedProperties->roundingIncrement;\n+    }\n+    result = PatternStringUtils::propertiesToPatternString(tprops, localStatus);\n+    return result;\n+}\n+\n+UnicodeString& DecimalFormat::toLocalizedPattern(UnicodeString& result) const {\n+    ErrorCode localStatus;\n+    result = toPattern(result);\n+    result = PatternStringUtils::convertLocalized(result, *fields->symbols, true, localStatus);\n+    return result;\n+}\n+\n+void DecimalFormat::applyPattern(const UnicodeString& pattern, UParseError&, UErrorCode& status) {\n+    // TODO: What is parseError for?\n+    applyPattern(pattern, status);\n+}\n+\n+void DecimalFormat::applyPattern(const UnicodeString& pattern, UErrorCode& status) {\n+    setPropertiesFromPattern(pattern, IGNORE_ROUNDING_NEVER, status);\n+    touch(status);\n+}\n+\n+void DecimalFormat::applyLocalizedPattern(const UnicodeString& localizedPattern, UParseError&,\n+                                          UErrorCode& status) {\n+    // TODO: What is parseError for?\n+    applyLocalizedPattern(localizedPattern, status);\n+}\n+\n+void DecimalFormat::applyLocalizedPattern(const UnicodeString& localizedPattern, UErrorCode& status) {\n+    if (U_SUCCESS(status)) {\n+        UnicodeString pattern = PatternStringUtils::convertLocalized(\n+                localizedPattern, *fields->symbols, false, status);\n+        applyPattern(pattern, status);\n+    }\n+}\n+\n+void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {\n+    if (newValue == fields->properties->maximumIntegerDigits) { return; }\n+    // For backwards compatibility, conflicting min/max need to keep the most recent setting.\n+    int32_t min = fields->properties->minimumIntegerDigits;\n+    if (min >= 0 && min > newValue) {\n+        fields->properties->minimumIntegerDigits = newValue;\n+    }\n+    fields->properties->maximumIntegerDigits = newValue;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setMinimumIntegerDigits(int32_t newValue) {\n+    if (newValue == fields->properties->minimumIntegerDigits) { return; }\n+    // For backwards compatibility, conflicting min/max need to keep the most recent setting.\n+    int32_t max = fields->properties->maximumIntegerDigits;\n+    if (max >= 0 && max < newValue) {\n+        fields->properties->maximumIntegerDigits = newValue;\n+    }\n+    fields->properties->minimumIntegerDigits = newValue;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setMaximumFractionDigits(int32_t newValue) {\n+    if (newValue == fields->properties->maximumFractionDigits) { return; }\n+    // For backwards compatibility, conflicting min/max need to keep the most recent setting.\n+    int32_t min = fields->properties->minimumFractionDigits;\n+    if (min >= 0 && min > newValue) {\n+        fields->properties->minimumFractionDigits = newValue;\n+    }\n+    fields->properties->maximumFractionDigits = newValue;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setMinimumFractionDigits(int32_t newValue) {\n+    if (newValue == fields->properties->minimumFractionDigits) { return; }\n+    // For backwards compatibility, conflicting min/max need to keep the most recent setting.\n+    int32_t max = fields->properties->maximumFractionDigits;\n+    if (max >= 0 && max < newValue) {\n+        fields->properties->maximumFractionDigits = newValue;\n+    }\n+    fields->properties->minimumFractionDigits = newValue;\n+    touchNoError();\n+}\n+\n+int32_t DecimalFormat::getMinimumSignificantDigits() const {\n+    return fields->exportedProperties->minimumSignificantDigits;\n+}\n+\n+int32_t DecimalFormat::getMaximumSignificantDigits() const {\n+    return fields->exportedProperties->maximumSignificantDigits;\n+}\n+\n+void DecimalFormat::setMinimumSignificantDigits(int32_t value) {\n+    if (value == fields->properties->minimumSignificantDigits) { return; }\n+    int32_t max = fields->properties->maximumSignificantDigits;\n+    if (max >= 0 && max < value) {\n+        fields->properties->maximumSignificantDigits = value;\n+    }\n+    fields->properties->minimumSignificantDigits = value;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setMaximumSignificantDigits(int32_t value) {\n+    if (value == fields->properties->maximumSignificantDigits) { return; }\n+    int32_t min = fields->properties->minimumSignificantDigits;\n+    if (min >= 0 && min > value) {\n+        fields->properties->minimumSignificantDigits = value;\n+    }\n+    fields->properties->maximumSignificantDigits = value;\n+    touchNoError();\n+}\n+\n+UBool DecimalFormat::areSignificantDigitsUsed() const {\n+    return fields->properties->minimumSignificantDigits != -1 || fields->properties->maximumSignificantDigits != -1;\n+}\n+\n+void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {\n+    if (areSignificantDigitsUsed()) return;\n+    // These are the default values from the old implementation.\n+    int32_t minSig = useSignificantDigits ? 1 : -1;\n+    int32_t maxSig = useSignificantDigits ? 6 : -1;\n+    if (fields->properties->minimumSignificantDigits == minSig &&\n+        fields->properties->maximumSignificantDigits == maxSig) {\n+        return;\n+    }\n+    fields->properties->minimumSignificantDigits = minSig;\n+    fields->properties->maximumSignificantDigits = maxSig;\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setCurrency(const char16_t* theCurrency, UErrorCode& ec) {\n+    CurrencyUnit currencyUnit(theCurrency, ec);\n+    if (U_FAILURE(ec)) { return; }\n+    if (!fields->properties->currency.isNull() && fields->properties->currency.getNoError() == currencyUnit) {\n+        return;\n+    }\n+    NumberFormat::setCurrency(theCurrency, ec); // to set field for compatibility\n+    fields->properties->currency = currencyUnit;\n+    // TODO: Set values in fields->symbols, too?\n+    touchNoError();\n+}\n+\n+void DecimalFormat::setCurrency(const char16_t* theCurrency) {\n+    ErrorCode localStatus;\n+    setCurrency(theCurrency, localStatus);\n+}\n+\n+void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {\n+    if (U_FAILURE(*ec)) {\n+        return;\n+    }\n+    if (!fields->properties->currencyUsage.isNull() && newUsage == fields->properties->currencyUsage.getNoError()) {\n+        return;\n+    }\n+    fields->properties->currencyUsage = newUsage;\n+    touch(*ec);\n+}\n+\n+UCurrencyUsage DecimalFormat::getCurrencyUsage() const {\n+    // CurrencyUsage is not exported, so we have to get it from the input property bag.\n+    // TODO: Should we export CurrencyUsage instead?\n+    if (fields->properties->currencyUsage.isNull()) {\n+        return UCURR_USAGE_STANDARD;\n+    }\n+    return fields->properties->currencyUsage.getNoError();\n+}\n+\n+void\n+DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity& output, UErrorCode& status) const {\n+    fields->formatter->formatDouble(number, status).getDecimalQuantity(output, status);\n+}\n+\n+void DecimalFormat::formatToDecimalQuantity(const Formattable& number, DecimalQuantity& output,\n+                                            UErrorCode& status) const {\n+    UFormattedNumberData obj;\n+    number.populateDecimalQuantity(obj.quantity, status);\n+    fields->formatter->formatImpl(&obj, status);\n+    output = std::move(obj.quantity);\n+}\n+\n+const number::LocalizedNumberFormatter& DecimalFormat::toNumberFormatter() const {\n+    return *fields->formatter;\n+}\n+\n+/** Rebuilds the formatter object from the property bag. */\n+void DecimalFormat::touch(UErrorCode& status) {\n+    if (fields->exportedProperties == nullptr) {\n+        // fields->exportedProperties is null only when the formatter is not ready yet.\n+        // The only time when this happens is during legacy deserialization.\n+        return;\n+    }\n+\n+    // In C++, fields->symbols is the source of truth for the locale.\n+    Locale locale = fields->symbols->getLocale();\n+\n+    // Note: The formatter is relatively cheap to create, and we need it to populate fields->exportedProperties,\n+    // so automatically compute it here. The parser is a bit more expensive and is not needed until the\n+    // parse method is called, so defer that until needed.\n+    // TODO: Only update the pieces that changed instead of re-computing the whole formatter?\n+    fields->formatter.adoptInstead(\n+            new LocalizedNumberFormatter(\n+                    NumberPropertyMapper::create(\n+                            *fields->properties, *fields->symbols, fields->warehouse, *fields->exportedProperties, status).locale(\n+                            locale)));\n+\n+    // Do this after fields->exportedProperties are set up\n+    setupFastFormat();\n+\n+    // Delete the parsers if they were made previously\n+    delete fields->atomicParser.exchange(nullptr);\n+    delete fields->atomicCurrencyParser.exchange(nullptr);\n+\n+    // In order for the getters to work, we need to populate some fields in NumberFormat.\n+    NumberFormat::setCurrency(fields->exportedProperties->currency.get(status).getISOCurrency(), status);\n+    NumberFormat::setMaximumIntegerDigits(fields->exportedProperties->maximumIntegerDigits);\n+    NumberFormat::setMinimumIntegerDigits(fields->exportedProperties->minimumIntegerDigits);\n+    NumberFormat::setMaximumFractionDigits(fields->exportedProperties->maximumFractionDigits);\n+    NumberFormat::setMinimumFractionDigits(fields->exportedProperties->minimumFractionDigits);\n+    // fImpl->properties, not fields->exportedProperties, since this information comes from the pattern:\n+    NumberFormat::setGroupingUsed(fields->properties->groupingUsed);\n+}\n+\n+void DecimalFormat::touchNoError() {\n+    UErrorCode localStatus = U_ZERO_ERROR;\n+    touch(localStatus);\n+}\n+\n+void DecimalFormat::setPropertiesFromPattern(const UnicodeString& pattern, int32_t ignoreRounding,\n+                                             UErrorCode& status) {\n+    if (U_SUCCESS(status)) {\n+        // Cast workaround to get around putting the enum in the public header file\n+        auto actualIgnoreRounding = static_cast<IgnoreRounding>(ignoreRounding);\n+        PatternParser::parseToExistingProperties(pattern, *fields->properties,  actualIgnoreRounding, status);\n+    }\n+}\n+\n+const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode& status) const {\n+    if (U_FAILURE(status)) { return nullptr; }\n+\n+    // First try to get the pre-computed parser\n+    auto* ptr = fields->atomicParser.load();\n+    if (ptr != nullptr) {\n+        return ptr;\n+    }\n+\n+    // Try computing the parser on our own\n+    auto* temp = NumberParserImpl::createParserFromProperties(*fields->properties, *fields->symbols, false, status);\n+    if (temp == nullptr) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        // although we may still dereference, call sites should be guarded\n+    }\n+\n+    // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the\n+    // atomic if another thread beat us to computing the parser object.\n+    auto* nonConstThis = const_cast<DecimalFormat*>(this);\n+    if (!nonConstThis->fields->atomicParser.compare_exchange_strong(ptr, temp)) {\n+        // Another thread beat us to computing the parser\n+        delete temp;\n+        return ptr;\n+    } else {\n+        // Our copy of the parser got stored in the atomic\n+        return temp;\n+    }\n+}\n+\n+const numparse::impl::NumberParserImpl* DecimalFormat::getCurrencyParser(UErrorCode& status) const {\n+    if (U_FAILURE(status)) { return nullptr; }\n+\n+    // First try to get the pre-computed parser\n+    auto* ptr = fields->atomicCurrencyParser.load();\n+    if (ptr != nullptr) {\n+        return ptr;\n+    }\n+\n+    // Try computing the parser on our own\n+    auto* temp = NumberParserImpl::createParserFromProperties(*fields->properties, *fields->symbols, true, status);\n+    if (temp == nullptr) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        // although we may still dereference, call sites should be guarded\n+    }\n+\n+    // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the\n+    // atomic if another thread beat us to computing the parser object.\n+    auto* nonConstThis = const_cast<DecimalFormat*>(this);\n+    if (!nonConstThis->fields->atomicCurrencyParser.compare_exchange_strong(ptr, temp)) {\n+        // Another thread beat us to computing the parser\n+        delete temp;\n+        return ptr;\n+    } else {\n+        // Our copy of the parser got stored in the atomic\n+        return temp;\n+    }\n+}\n+\n+void\n+DecimalFormat::fieldPositionHelper(const number::FormattedNumber& formatted, FieldPosition& fieldPosition,\n+                                   int32_t offset, UErrorCode& status) {\n+    // always return first occurrence:\n+    fieldPosition.setBeginIndex(0);\n+    fieldPosition.setEndIndex(0);\n+    bool found = formatted.nextFieldPosition(fieldPosition, status);\n+    if (found && offset != 0) {\n+        FieldPositionOnlyHandler fpoh(fieldPosition);\n+        fpoh.shiftLast(offset);\n+    }\n+}\n+\n+void\n+DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber& formatted, FieldPositionIterator* fpi,\n+                                           int32_t offset, UErrorCode& status) {\n+    if (fpi != nullptr) {\n+        FieldPositionIteratorHandler fpih(fpi, status);\n+        fpih.setShift(offset);\n+        formatted.getAllFieldPositionsImpl(fpih, status);\n+    }\n+}\n+\n+// To debug fast-format, change void(x) to printf(x)\n+#define trace(x) void(x)\n+\n+void DecimalFormat::setupFastFormat() {\n+    // Check the majority of properties:\n+    if (!fields->properties->equalsDefaultExceptFastFormat()) {\n+        trace(\"no fast format: equality\\n\");\n+        fields->canUseFastFormat = false;\n+        return;\n+    }\n+\n+    // Now check the remaining properties.\n+    // Nontrivial affixes:\n+    UBool trivialPP = fields->properties->positivePrefixPattern.isEmpty();\n+    UBool trivialPS = fields->properties->positiveSuffixPattern.isEmpty();\n+    UBool trivialNP = fields->properties->negativePrefixPattern.isBogus() || (\n+            fields->properties->negativePrefixPattern.length() == 1 &&\n+            fields->properties->negativePrefixPattern.charAt(0) == u'-');\n+    UBool trivialNS = fields->properties->negativeSuffixPattern.isEmpty();\n+    if (!trivialPP || !trivialPS || !trivialNP || !trivialNS) {\n+        trace(\"no fast format: affixes\\n\");\n+        fields->canUseFastFormat = false;\n+        return;\n+    }\n+\n+    // Grouping (secondary grouping is forbidden in equalsDefaultExceptFastFormat):\n+    bool groupingUsed = fields->properties->groupingUsed;\n+    int32_t groupingSize = fields->properties->groupingSize;\n+    bool unusualGroupingSize = groupingSize > 0 && groupingSize != 3;\n+    const UnicodeString& groupingString = fields->symbols->getConstSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol);\n+    if (groupingUsed && (unusualGroupingSize || groupingString.length() != 1)) {\n+        trace(\"no fast format: grouping\\n\");\n+        fields->canUseFastFormat = false;\n+        return;\n+    }\n+\n+    // Integer length:\n+    int32_t minInt = fields->exportedProperties->minimumIntegerDigits;\n+    int32_t maxInt = fields->exportedProperties->maximumIntegerDigits;\n+    // Fastpath supports up to only 10 digits (length of INT32_MIN)\n+    if (minInt > 10) {\n+        trace(\"no fast format: integer\\n\");\n+        fields->canUseFastFormat = false;\n+        return;\n+    }\n+\n+    // Fraction length (no fraction part allowed in fast path):\n+    int32_t minFrac = fields->exportedProperties->minimumFractionDigits;\n+    if (minFrac > 0) {\n+        trace(\"no fast format: fraction\\n\");\n+        fields->canUseFastFormat = false;\n+        return;\n+    }\n+\n+    // Other symbols:\n+    const UnicodeString& minusSignString = fields->symbols->getConstSymbol(DecimalFormatSymbols::kMinusSignSymbol);\n+    UChar32 codePointZero = fields->symbols->getCodePointZero();\n+    if (minusSignString.length() != 1 || U16_LENGTH(codePointZero) != 1) {\n+        trace(\"no fast format: symbols\\n\");\n+        fields->canUseFastFormat = false;\n+        return;\n+    }\n+\n+    // Good to go!\n+    trace(\"can use fast format!\\n\");\n+    fields->canUseFastFormat = true;\n+    fields->fastData.cpZero = static_cast<char16_t>(codePointZero);\n+    fields->fastData.cpGroupingSeparator = groupingUsed && groupingSize == 3 ? groupingString.charAt(0) : 0;\n+    fields->fastData.cpMinusSign = minusSignString.charAt(0);\n+    fields->fastData.minInt = (minInt < 0 || minInt > 127) ? 0 : static_cast<int8_t>(minInt);\n+    fields->fastData.maxInt = (maxInt < 0 || maxInt > 127) ? 127 : static_cast<int8_t>(maxInt);\n+}\n+\n+bool DecimalFormat::fastFormatDouble(double input, UnicodeString& output) const {\n+    if (!fields->canUseFastFormat) {\n+        return false;\n+    }\n+    if (std::isnan(input)\n+            || std::trunc(input) != input\n+            || input <= INT32_MIN\n+            || input > INT32_MAX) {\n+        return false;\n+    }\n+    doFastFormatInt32(static_cast<int32_t>(input), std::signbit(input), output);\n+    return true;\n+}\n+\n+bool DecimalFormat::fastFormatInt64(int64_t input, UnicodeString& output) const {\n+    if (!fields->canUseFastFormat) {\n+        return false;\n+    }\n+    if (input <= INT32_MIN || input > INT32_MAX) {\n+        return false;\n+    }\n+    doFastFormatInt32(static_cast<int32_t>(input), input < 0, output);\n+    return true;\n+}\n+\n+void DecimalFormat::doFastFormatInt32(int32_t input, bool isNegative, UnicodeString& output) const {\n+    U_ASSERT(fields->canUseFastFormat);\n+    if (isNegative) {\n+        output.append(fields->fastData.cpMinusSign);\n+        U_ASSERT(input != INT32_MIN);  // handled by callers\n+        input = -input;\n+    }\n+    // Cap at int32_t to make the buffer small and operations fast.\n+    // Longest string: \"2,147,483,648\" (13 chars in length)\n+    static constexpr int32_t localCapacity = 13;\n+    char16_t localBuffer[localCapacity];\n+    char16_t* ptr = localBuffer + localCapacity;\n+    int8_t group = 0;\n+    for (int8_t i = 0; i < fields->fastData.maxInt && (input != 0 || i < fields->fastData.minInt); i++) {\n+        if (group++ == 3 && fields->fastData.cpGroupingSeparator != 0) {\n+            *(--ptr) = fields->fastData.cpGroupingSeparator;\n+            group = 1;\n+        }\n+        std::div_t res = std::div(input, 10);\n+        *(--ptr) = static_cast<char16_t>(fields->fastData.cpZero + res.rem);\n+        input = res.quot;\n+    }\n+    int32_t len = localCapacity - static_cast<int32_t>(ptr - localBuffer);\n+    output.append(ptr, len);\n+}\n+\n+\n+#endif /* #if !UCONFIG_NO_FORMATTING */"
        }
    ],
    "stats": {
        "total": 1398,
        "additions": 1396,
        "deletions": 2
    }
}