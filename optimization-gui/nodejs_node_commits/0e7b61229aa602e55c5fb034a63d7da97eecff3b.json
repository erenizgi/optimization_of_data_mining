{
    "author": "addaleax",
    "message": "src: refactor WriteWrap and ShutdownWraps\n\nEncapsulate stream requests more:\n\n- `WriteWrap` and `ShutdownWrap` classes are now tailored to the\n  streams on which they are used. In particular, for most streams\n  these are now plain `AsyncWrap`s and do not carry the overhead\n  of unused libuv request data.\n- Provide generic `Write()` and `Shutdown()` methods that wrap\n  around the actual implementations, and make *usage* of streams\n  easier, rather than implementing; for example, wrap objects\n  don’t need to be provided by callers anymore.\n- Use `EmitAfterWrite()` and `EmitAfterShutdown()` handlers to\n  call the corresponding JS handlers, rather than always trying\n  to call them. This makes usage of streams by other C++ code\n  easier and leaner.\n\nAlso fix up some tests that were previously not actually testing\nasynchronicity when the comments indicated that they would.\n\nPR-URL: https://github.com/nodejs/node/pull/18676\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "0e7b61229aa602e55c5fb034a63d7da97eecff3b",
    "files": [
        {
            "sha": "4b6dd9c3f2b1450a28c3656dd42ee4ecb4ed9a87",
            "filename": "benchmark/net/tcp-raw-c2s.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/benchmark%2Fnet%2Ftcp-raw-c2s.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/benchmark%2Fnet%2Ftcp-raw-c2s.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnet%2Ftcp-raw-c2s.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -118,7 +118,7 @@ function client(type, len) {\n       fail(err, 'write');\n   }\n \n-  function afterWrite(err, handle, req) {\n+  function afterWrite(err, handle) {\n     if (err)\n       fail(err, 'write');\n "
        },
        {
            "sha": "dfde3d40b50b5563bb032b9b1133caaa67efef43",
            "filename": "benchmark/net/tcp-raw-pipe.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/benchmark%2Fnet%2Ftcp-raw-pipe.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/benchmark%2Fnet%2Ftcp-raw-pipe.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnet%2Ftcp-raw-pipe.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -51,7 +51,7 @@ function main({ dur, len, type }) {\n       if (err)\n         fail(err, 'write');\n \n-      writeReq.oncomplete = function(status, handle, req, err) {\n+      writeReq.oncomplete = function(status, handle, err) {\n         if (err)\n           fail(err, 'write');\n       };\n@@ -130,7 +130,7 @@ function main({ dur, len, type }) {\n       fail(err, 'write');\n   }\n \n-  function afterWrite(err, handle, req) {\n+  function afterWrite(err, handle) {\n     if (err)\n       fail(err, 'write');\n "
        },
        {
            "sha": "fe0bffd8127ec7e7ac7752b9f54574265979b8f9",
            "filename": "benchmark/net/tcp-raw-s2c.js",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/benchmark%2Fnet%2Ftcp-raw-s2c.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/benchmark%2Fnet%2Ftcp-raw-s2c.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnet%2Ftcp-raw-s2c.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -74,14 +74,14 @@ function main({ dur, len, type }) {\n         fail(err, 'write');\n       } else if (!writeReq.async) {\n         process.nextTick(function() {\n-          afterWrite(null, clientHandle, writeReq);\n+          afterWrite(0, clientHandle);\n         });\n       }\n     }\n \n-    function afterWrite(status, handle, req, err) {\n-      if (err)\n-        fail(err, 'write');\n+    function afterWrite(status, handle) {\n+      if (status)\n+        fail(status, 'write');\n \n       while (clientHandle.writeQueueSize === 0)\n         write();"
        },
        {
            "sha": "dc01fb14e6e263e198e09cb2f802b1520a5a6d1c",
            "filename": "lib/internal/http2/core.js",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/lib%2Finternal%2Fhttp2%2Fcore.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/lib%2Finternal%2Fhttp2%2Fcore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fhttp2%2Fcore.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -1399,20 +1399,19 @@ function trackWriteState(stream, bytes) {\n   session[kHandle].chunksSentSinceLastWrite = 0;\n }\n \n-function afterDoStreamWrite(status, handle, req) {\n+function afterDoStreamWrite(status, handle) {\n   const stream = handle[kOwner];\n   const session = stream[kSession];\n \n   stream[kUpdateTimer]();\n \n-  const { bytes } = req;\n+  const { bytes } = this;\n   stream[kState].writeQueueSize -= bytes;\n \n   if (session !== undefined)\n     session[kState].writeQueueSize -= bytes;\n-  if (typeof req.callback === 'function')\n-    req.callback(null);\n-  req.handle = undefined;\n+  if (typeof this.callback === 'function')\n+    this.callback(null);\n }\n \n function streamOnResume() {"
        },
        {
            "sha": "feacab267bea4d9a315fbad1bfd5c649ecbdf138",
            "filename": "lib/internal/wrap_js_stream.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/lib%2Finternal%2Fwrap_js_stream.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/lib%2Finternal%2Fwrap_js_stream.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fwrap_js_stream.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -115,9 +115,9 @@ class JSStreamWrap extends Socket {\n \n     const handle = this._handle;\n \n-    this.stream.end(() => {\n-      // Ensure that write was dispatched\n-      setImmediate(() => {\n+    setImmediate(() => {\n+      // Ensure that write is dispatched asynchronously.\n+      this.stream.end(() => {\n         this.finishShutdown(handle, 0);\n       });\n     });"
        },
        {
            "sha": "1bc28e856df5bd6b644a394a32bab32fb5a84c41",
            "filename": "lib/net.js",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/lib%2Fnet.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/lib%2Fnet.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fnet.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -335,7 +335,7 @@ function onSocketFinish() {\n }\n \n \n-function afterShutdown(status, handle, req) {\n+function afterShutdown(status, handle) {\n   var self = handle.owner;\n \n   debug('afterShutdown destroyed=%j', self.destroyed,\n@@ -869,12 +869,12 @@ protoGetter('bytesWritten', function bytesWritten() {\n });\n \n \n-function afterWrite(status, handle, req, err) {\n+function afterWrite(status, handle, err) {\n   var self = handle.owner;\n   if (self !== process.stderr && self !== process.stdout)\n     debug('afterWrite', status);\n \n-  if (req.async)\n+  if (this.async)\n     self[kLastWriteQueueSize] = 0;\n \n   // callback may come after call to destroy.\n@@ -884,9 +884,9 @@ function afterWrite(status, handle, req, err) {\n   }\n \n   if (status < 0) {\n-    var ex = errnoException(status, 'write', req.error);\n+    var ex = errnoException(status, 'write', this.error);\n     debug('write failure', ex);\n-    self.destroy(ex, req.cb);\n+    self.destroy(ex, this.cb);\n     return;\n   }\n \n@@ -895,8 +895,8 @@ function afterWrite(status, handle, req, err) {\n   if (self !== process.stderr && self !== process.stdout)\n     debug('afterWrite call cb');\n \n-  if (req.cb)\n-    req.cb.call(undefined);\n+  if (this.cb)\n+    this.cb.call(undefined);\n }\n \n "
        },
        {
            "sha": "68b674f4fdbf9172ec651074419db53474a45b0a",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -306,6 +306,7 @@ class ModuleWrap;\n   V(script_context_constructor_template, v8::FunctionTemplate)                \\\n   V(script_data_constructor_function, v8::Function)                           \\\n   V(secure_context_constructor_template, v8::FunctionTemplate)                \\\n+  V(shutdown_wrap_constructor_function, v8::Function)                         \\\n   V(tcp_constructor_template, v8::FunctionTemplate)                           \\\n   V(tick_callback_function, v8::Function)                                     \\\n   V(timers_callback_function, v8::Function)                                   \\"
        },
        {
            "sha": "3ba6a254cfc03e75557d62e1cb66887d5c3df84c",
            "filename": "src/js_stream.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fjs_stream.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fjs_stream.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_stream.cc?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -91,8 +91,6 @@ int JSStream::DoShutdown(ShutdownWrap* req_wrap) {\n     req_wrap->object()\n   };\n \n-  req_wrap->Dispatched();\n-\n   TryCatch try_catch(env()->isolate());\n   Local<Value> value;\n   int value_int = UV_EPROTO;\n@@ -127,8 +125,6 @@ int JSStream::DoWrite(WriteWrap* w,\n     bufs_arr\n   };\n \n-  w->Dispatched();\n-\n   TryCatch try_catch(env()->isolate());\n   Local<Value> value;\n   int value_int = UV_EPROTO;\n@@ -154,9 +150,8 @@ void JSStream::New(const FunctionCallbackInfo<Value>& args) {\n \n template <class Wrap>\n void JSStream::Finish(const FunctionCallbackInfo<Value>& args) {\n-  Wrap* w;\n   CHECK(args[0]->IsObject());\n-  ASSIGN_OR_RETURN_UNWRAP(&w, args[0].As<Object>());\n+  Wrap* w = static_cast<Wrap*>(StreamReq::FromObject(args[0].As<Object>()));\n \n   w->Done(args[1]->Int32Value());\n }"
        },
        {
            "sha": "6f59c119e53a6b094dca619487b58e3b9343824c",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 34,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -1552,18 +1552,9 @@ void Http2Session::SendPendingData() {\n \n   chunks_sent_since_last_write_++;\n \n-  // DoTryWrite may modify both the buffer list start itself and the\n-  // base pointers/length of the individual buffers.\n-  uv_buf_t* writebufs = *bufs;\n-  if (stream_->DoTryWrite(&writebufs, &count) != 0 || count == 0) {\n-    // All writes finished synchronously, nothing more to do here.\n-    ClearOutgoing(0);\n-    return;\n-  }\n-\n-  WriteWrap* req = AllocateSend();\n-  if (stream_->DoWrite(req, writebufs, count, nullptr) != 0) {\n-    req->Dispose();\n+  StreamWriteResult res = underlying_stream()->Write(*bufs, count);\n+  if (!res.async) {\n+    ClearOutgoing(res.err);\n   }\n \n   DEBUG_HTTP2SESSION2(this, \"wants data in return? %d\",\n@@ -1649,15 +1640,6 @@ inline void Http2Session::SetChunksSinceLastWrite(size_t n) {\n   chunks_sent_since_last_write_ = n;\n }\n \n-// Allocates the data buffer used to pass outbound data to the i/o stream.\n-WriteWrap* Http2Session::AllocateSend() {\n-  HandleScope scope(env()->isolate());\n-  Local<Object> obj =\n-      env()->write_wrap_constructor_function()\n-          ->NewInstance(env()->context()).ToLocalChecked();\n-  return WriteWrap::New(env(), obj, static_cast<StreamBase*>(stream_));\n-}\n-\n // Callback used to receive inbound data from the i/o stream\n void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   Http2Scope h2scope(this);\n@@ -1833,20 +1815,15 @@ inline void Http2Stream::Close(int32_t code) {\n   DEBUG_HTTP2STREAM2(this, \"closed with code %d\", code);\n }\n \n-\n-inline void Http2Stream::Shutdown() {\n-  CHECK(!this->IsDestroyed());\n-  Http2Scope h2scope(this);\n-  flags_ |= NGHTTP2_STREAM_FLAG_SHUT;\n-  CHECK_NE(nghttp2_session_resume_data(session_->session(), id_),\n-           NGHTTP2_ERR_NOMEM);\n-  DEBUG_HTTP2STREAM(this, \"writable side shutdown\");\n-}\n-\n int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {\n   CHECK(!this->IsDestroyed());\n-  req_wrap->Dispatched();\n-  Shutdown();\n+  {\n+    Http2Scope h2scope(this);\n+    flags_ |= NGHTTP2_STREAM_FLAG_SHUT;\n+    CHECK_NE(nghttp2_session_resume_data(session_->session(), id_),\n+             NGHTTP2_ERR_NOMEM);\n+    DEBUG_HTTP2STREAM(this, \"writable side shutdown\");\n+  }\n   req_wrap->Done(0);\n   return 0;\n }\n@@ -2038,7 +2015,6 @@ inline int Http2Stream::DoWrite(WriteWrap* req_wrap,\n   CHECK_EQ(send_handle, nullptr);\n   Http2Scope h2scope(this);\n   session_->SetChunksSinceLastWrite();\n-  req_wrap->Dispatched();\n   if (!IsWritable()) {\n     req_wrap->Done(UV_EOF);\n     return 0;"
        },
        {
            "sha": "0e81eaac6ca7fe517d7d9ccefdb05cea1522b036",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -601,9 +601,6 @@ class Http2Stream : public AsyncWrap,\n \n   inline void Close(int32_t code);\n \n-  // Shutdown the writable side of the stream\n-  inline void Shutdown();\n-\n   // Destroy this stream instance and free all held memory.\n   inline void Destroy();\n \n@@ -818,6 +815,10 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   inline void EmitStatistics();\n \n+  inline StreamBase* underlying_stream() {\n+    return static_cast<StreamBase*>(stream_);\n+  }\n+\n   void Start();\n   void Stop();\n   void Close(uint32_t code = NGHTTP2_NO_ERROR,\n@@ -907,8 +908,6 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   template <get_setting fn>\n   static void GetSettings(const FunctionCallbackInfo<Value>& args);\n \n-  WriteWrap* AllocateSend();\n-\n   uv_loop_t* event_loop() const {\n     return env()->event_loop();\n   }"
        },
        {
            "sha": "4a7984e649c733e6ff4d6b643668ef1fcc480c34",
            "filename": "src/req_wrap-inl.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Freq_wrap-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Freq_wrap-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap-inl.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -33,6 +33,11 @@ void ReqWrap<T>::Dispatched() {\n   req_.data = this;\n }\n \n+template <typename T>\n+ReqWrap<T>* ReqWrap<T>::from_req(T* req) {\n+  return ContainerOf(&ReqWrap<T>::req_, req);\n+}\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "656be38dcea943e2f6e7f895d9e209de169e0411",
            "filename": "src/req_wrap.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Freq_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Freq_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -20,6 +20,8 @@ class ReqWrap : public AsyncWrap {\n   inline void Dispatched();  // Call this after the req has been dispatched.\n   T* req() { return &req_; }\n \n+  static ReqWrap* from_req(T* req);\n+\n  private:\n   friend class Environment;\n   friend int GenDebugSymbols();"
        },
        {
            "sha": "b479e04bae4c8a3d548939ec77d46f7a610fd2ed",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 194,
            "deletions": 22,
            "changes": 216,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -25,6 +25,25 @@ using v8::Value;\n \n using AsyncHooks = Environment::AsyncHooks;\n \n+inline void StreamReq::AttachToObject(v8::Local<v8::Object> req_wrap_obj) {\n+  CHECK_EQ(req_wrap_obj->GetAlignedPointerFromInternalField(kStreamReqField),\n+           nullptr);\n+  req_wrap_obj->SetAlignedPointerInInternalField(kStreamReqField, this);\n+}\n+\n+inline StreamReq* StreamReq::FromObject(v8::Local<v8::Object> req_wrap_obj) {\n+  return static_cast<StreamReq*>(\n+      req_wrap_obj->GetAlignedPointerFromInternalField(kStreamReqField));\n+}\n+\n+inline void StreamReq::Dispose() {\n+  object()->SetAlignedPointerInInternalField(kStreamReqField, nullptr);\n+  delete this;\n+}\n+\n+inline v8::Local<v8::Object> StreamReq::object() {\n+  return GetAsyncWrap()->object();\n+}\n \n inline StreamListener::~StreamListener() {\n   if (stream_ != nullptr)\n@@ -36,6 +55,15 @@ inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) {\n   previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));\n }\n \n+inline void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) {\n+  CHECK_NE(previous_listener_, nullptr);\n+  previous_listener_->OnStreamAfterShutdown(w, status);\n+}\n+\n+inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) {\n+  CHECK_NE(previous_listener_, nullptr);\n+  previous_listener_->OnStreamAfterWrite(w, status);\n+}\n \n inline StreamResource::~StreamResource() {\n   while (listener_ != nullptr) {\n@@ -93,6 +121,9 @@ inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) {\n   listener_->OnStreamAfterWrite(w, status);\n }\n \n+inline void StreamResource::EmitAfterShutdown(ShutdownWrap* w, int status) {\n+  listener_->OnStreamAfterShutdown(w, status);\n+}\n \n inline StreamBase::StreamBase(Environment* env) : env_(env) {\n   PushStreamListener(&default_listener_);\n@@ -102,6 +133,150 @@ inline Environment* StreamBase::stream_env() const {\n   return env_;\n }\n \n+inline void StreamBase::AfterWrite(WriteWrap* req_wrap, int status) {\n+  AfterRequest(req_wrap, [&]() {\n+    EmitAfterWrite(req_wrap, status);\n+  });\n+}\n+\n+inline void StreamBase::AfterShutdown(ShutdownWrap* req_wrap, int status) {\n+  AfterRequest(req_wrap, [&]() {\n+    EmitAfterShutdown(req_wrap, status);\n+  });\n+}\n+\n+template<typename Wrap, typename EmitEvent>\n+inline void StreamBase::AfterRequest(Wrap* req_wrap, EmitEvent emit) {\n+  Environment* env = stream_env();\n+\n+  v8::HandleScope handle_scope(env->isolate());\n+  v8::Context::Scope context_scope(env->context());\n+\n+  emit();\n+  req_wrap->Dispose();\n+}\n+\n+inline int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) {\n+  Environment* env = stream_env();\n+  if (req_wrap_obj.IsEmpty()) {\n+    req_wrap_obj =\n+        env->shutdown_wrap_constructor_function()\n+            ->NewInstance(env->context()).ToLocalChecked();\n+  }\n+\n+  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(\n+      env, GetAsyncWrap()->get_async_id());\n+  ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj);\n+  int err = DoShutdown(req_wrap);\n+\n+  if (err != 0) {\n+    req_wrap->Dispose();\n+  }\n+\n+  const char* msg = Error();\n+  if (msg != nullptr) {\n+    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n+    ClearError();\n+  }\n+\n+  return err;\n+}\n+\n+inline StreamWriteResult StreamBase::Write(\n+    uv_buf_t* bufs,\n+    size_t count,\n+    uv_stream_t* send_handle,\n+    v8::Local<v8::Object> req_wrap_obj) {\n+  Environment* env = stream_env();\n+  int err;\n+  if (send_handle == nullptr) {\n+    err = DoTryWrite(&bufs, &count);\n+    if (err != 0 || count == 0) {\n+      return StreamWriteResult { false, err, nullptr };\n+    }\n+  }\n+\n+  if (req_wrap_obj.IsEmpty()) {\n+    req_wrap_obj =\n+        env->write_wrap_constructor_function()\n+            ->NewInstance(env->context()).ToLocalChecked();\n+  }\n+\n+  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(\n+      env, GetAsyncWrap()->get_async_id());\n+  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n+\n+  err = DoWrite(req_wrap, bufs, count, send_handle);\n+  bool async = err == 0;\n+\n+  if (!async) {\n+    req_wrap->Dispose();\n+    req_wrap = nullptr;\n+  }\n+\n+  const char* msg = Error();\n+  if (msg != nullptr) {\n+    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n+    ClearError();\n+  }\n+\n+  req_wrap_obj->Set(env->async(), v8::Boolean::New(env->isolate(), async));\n+\n+  return StreamWriteResult { async, err, req_wrap };\n+}\n+\n+template<typename OtherBase, bool kResetPersistent>\n+SimpleShutdownWrap<OtherBase, kResetPersistent>::SimpleShutdownWrap(\n+    StreamBase* stream,\n+    v8::Local<v8::Object> req_wrap_obj)\n+  : ShutdownWrap(stream, req_wrap_obj),\n+    OtherBase(stream->stream_env(),\n+              req_wrap_obj,\n+              AsyncWrap::PROVIDER_SHUTDOWNWRAP) {\n+  Wrap(req_wrap_obj, static_cast<AsyncWrap*>(this));\n+}\n+\n+template<typename OtherBase, bool kResetPersistent>\n+SimpleShutdownWrap<OtherBase, kResetPersistent>::~SimpleShutdownWrap() {\n+  ClearWrap(static_cast<AsyncWrap*>(this)->object());\n+  if (kResetPersistent) {\n+    auto& persistent = static_cast<AsyncWrap*>(this)->persistent();\n+    CHECK_EQ(persistent.IsEmpty(), false);\n+    persistent.Reset();\n+  }\n+}\n+\n+inline ShutdownWrap* StreamBase::CreateShutdownWrap(\n+    v8::Local<v8::Object> object) {\n+  return new SimpleShutdownWrap<AsyncWrap>(this, object);\n+}\n+\n+template<typename OtherBase, bool kResetPersistent>\n+SimpleWriteWrap<OtherBase, kResetPersistent>::SimpleWriteWrap(\n+    StreamBase* stream,\n+    v8::Local<v8::Object> req_wrap_obj)\n+  : WriteWrap(stream, req_wrap_obj),\n+    OtherBase(stream->stream_env(),\n+              req_wrap_obj,\n+              AsyncWrap::PROVIDER_WRITEWRAP) {\n+  Wrap(req_wrap_obj, static_cast<AsyncWrap*>(this));\n+}\n+\n+template<typename OtherBase, bool kResetPersistent>\n+SimpleWriteWrap<OtherBase, kResetPersistent>::~SimpleWriteWrap() {\n+  ClearWrap(static_cast<AsyncWrap*>(this)->object());\n+  if (kResetPersistent) {\n+    auto& persistent = static_cast<AsyncWrap*>(this)->persistent();\n+    CHECK_EQ(persistent.IsEmpty(), false);\n+    persistent.Reset();\n+  }\n+}\n+\n+inline WriteWrap* StreamBase::CreateWriteWrap(\n+    v8::Local<v8::Object> object) {\n+  return new SimpleWriteWrap<AsyncWrap>(this, object);\n+}\n+\n template <class Base>\n void StreamBase::AddMethods(Environment* env,\n                             Local<FunctionTemplate> t,\n@@ -230,38 +405,35 @@ inline void ShutdownWrap::OnDone(int status) {\n   stream()->AfterShutdown(this, status);\n }\n \n-\n-WriteWrap* WriteWrap::New(Environment* env,\n-                          Local<Object> obj,\n-                          StreamBase* wrap,\n-                          size_t extra) {\n-  size_t storage_size = ROUND_UP(sizeof(WriteWrap), kAlignSize) + extra;\n-  char* storage = new char[storage_size];\n-\n-  return new(storage) WriteWrap(env, obj, wrap, storage_size);\n+inline void WriteWrap::SetAllocatedStorage(char* data, size_t size) {\n+  CHECK_EQ(storage_, nullptr);\n+  storage_ = data;\n+  storage_size_ = size;\n }\n \n-\n-void WriteWrap::Dispose() {\n-  this->~WriteWrap();\n-  delete[] reinterpret_cast<char*>(this);\n-}\n-\n-\n-char* WriteWrap::Extra(size_t offset) {\n-  return reinterpret_cast<char*>(this) +\n-         ROUND_UP(sizeof(*this), kAlignSize) +\n-         offset;\n+inline char* WriteWrap::Storage() {\n+  return storage_;\n }\n \n-size_t WriteWrap::ExtraSize() const {\n-  return storage_size_ - ROUND_UP(sizeof(*this), kAlignSize);\n+inline size_t WriteWrap::StorageSize() const {\n+  return storage_size_;\n }\n \n inline void WriteWrap::OnDone(int status) {\n   stream()->AfterWrite(this, status);\n }\n \n+inline void StreamReq::Done(int status, const char* error_str) {\n+  AsyncWrap* async_wrap = GetAsyncWrap();\n+  Environment* env = async_wrap->env();\n+  if (error_str != nullptr) {\n+    async_wrap->object()->Set(env->error_string(),\n+                              OneByteString(env->isolate(), error_str));\n+  }\n+\n+  OnDone(status);\n+}\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "9ad9fd5bcb4a466d68368b851e25703f32a6f4a6",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 98,
            "deletions": 202,
            "changes": 300,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -34,6 +34,11 @@ template int StreamBase::WriteString<LATIN1>(\n     const FunctionCallbackInfo<Value>& args);\n \n \n+struct Free {\n+  void operator()(char* ptr) const { free(ptr); }\n+};\n+\n+\n int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) {\n   return ReadStart();\n }\n@@ -45,45 +50,10 @@ int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) {\n \n \n int StreamBase::Shutdown(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n   CHECK(args[0]->IsObject());\n   Local<Object> req_wrap_obj = args[0].As<Object>();\n \n-  AsyncWrap* wrap = GetAsyncWrap();\n-  CHECK_NE(wrap, nullptr);\n-  AsyncHooks::DefaultTriggerAsyncIdScope(env, wrap->get_async_id());\n-  ShutdownWrap* req_wrap = new ShutdownWrap(env,\n-                                            req_wrap_obj,\n-                                            this);\n-\n-  int err = DoShutdown(req_wrap);\n-  if (err)\n-    delete req_wrap;\n-  return err;\n-}\n-\n-\n-void StreamBase::AfterShutdown(ShutdownWrap* req_wrap, int status) {\n-  Environment* env = req_wrap->env();\n-\n-  // The wrap and request objects should still be there.\n-  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);\n-\n-  HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n-\n-  Local<Object> req_wrap_obj = req_wrap->object();\n-  Local<Value> argv[3] = {\n-    Integer::New(env->isolate(), status),\n-    GetObject(),\n-    req_wrap_obj\n-  };\n-\n-  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())\n-    req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);\n-\n-  delete req_wrap;\n+  return Shutdown(req_wrap_obj);\n }\n \n \n@@ -104,19 +74,14 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n     count = chunks->Length() >> 1;\n \n   MaybeStackBuffer<uv_buf_t, 16> bufs(count);\n-  uv_buf_t* buf_list = *bufs;\n \n   size_t storage_size = 0;\n   uint32_t bytes = 0;\n   size_t offset;\n-  WriteWrap* req_wrap;\n-  int err;\n \n   if (!all_buffers) {\n     // Determine storage size first\n     for (size_t i = 0; i < count; i++) {\n-      storage_size = ROUND_UP(storage_size, WriteWrap::kAlignSize);\n-\n       Local<Value> chunk = chunks->Get(i * 2);\n \n       if (Buffer::HasInstance(chunk))\n@@ -145,20 +110,11 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n       bufs[i].len = Buffer::Length(chunk);\n       bytes += bufs[i].len;\n     }\n-\n-    // Try writing immediately without allocation\n-    err = DoTryWrite(&buf_list, &count);\n-    if (err != 0 || count == 0)\n-      goto done;\n   }\n \n-  {\n-    AsyncWrap* wrap = GetAsyncWrap();\n-    CHECK_NE(wrap, nullptr);\n-    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(env,\n-                                                         wrap->get_async_id());\n-    req_wrap = WriteWrap::New(env, req_wrap_obj, this, storage_size);\n-  }\n+  std::unique_ptr<char[], Free> storage;\n+  if (storage_size > 0)\n+    storage = std::unique_ptr<char[], Free>(Malloc(storage_size));\n \n   offset = 0;\n   if (!all_buffers) {\n@@ -174,9 +130,8 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n       }\n \n       // Write string\n-      offset = ROUND_UP(offset, WriteWrap::kAlignSize);\n       CHECK_LE(offset, storage_size);\n-      char* str_storage = req_wrap->Extra(offset);\n+      char* str_storage = storage.get() + offset;\n       size_t str_size = storage_size - offset;\n \n       Local<String> string = chunk->ToString(env->context()).ToLocalChecked();\n@@ -192,35 +147,17 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n       offset += str_size;\n       bytes += str_size;\n     }\n-\n-    err = DoTryWrite(&buf_list, &count);\n-    if (err != 0 || count == 0) {\n-      req_wrap->Dispatched();\n-      req_wrap->Dispose();\n-      goto done;\n-    }\n   }\n \n-  err = DoWrite(req_wrap, buf_list, count, nullptr);\n-  req_wrap_obj->Set(env->async(), True(env->isolate()));\n-\n-  if (err)\n-    req_wrap->Dispose();\n-\n- done:\n-  const char* msg = Error();\n-  if (msg != nullptr) {\n-    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n-    ClearError();\n-  }\n+  StreamWriteResult res = Write(*bufs, count, nullptr, req_wrap_obj);\n   req_wrap_obj->Set(env->bytes_string(), Number::New(env->isolate(), bytes));\n-\n-  return err;\n+  if (res.wrap != nullptr && storage) {\n+    res.wrap->SetAllocatedStorage(storage.release(), storage_size);\n+  }\n+  return res.err;\n }\n \n \n-\n-\n int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsObject());\n \n@@ -232,49 +169,20 @@ int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   Local<Object> req_wrap_obj = args[0].As<Object>();\n-  const char* data = Buffer::Data(args[1]);\n-  size_t length = Buffer::Length(args[1]);\n \n-  WriteWrap* req_wrap;\n   uv_buf_t buf;\n-  buf.base = const_cast<char*>(data);\n-  buf.len = length;\n-\n-  // Try writing immediately without allocation\n-  uv_buf_t* bufs = &buf;\n-  size_t count = 1;\n-  int err = DoTryWrite(&bufs, &count);\n-  if (err != 0)\n-    goto done;\n-  if (count == 0)\n-    goto done;\n-  CHECK_EQ(count, 1);\n-\n-  // Allocate, or write rest\n-  {\n-    AsyncWrap* wrap = GetAsyncWrap();\n-    CHECK_NE(wrap, nullptr);\n-    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(env,\n-                                                         wrap->get_async_id());\n-    req_wrap = WriteWrap::New(env, req_wrap_obj, this);\n-  }\n+  buf.base = Buffer::Data(args[1]);\n+  buf.len = Buffer::Length(args[1]);\n \n-  err = DoWrite(req_wrap, bufs, count, nullptr);\n-  req_wrap_obj->Set(env->async(), True(env->isolate()));\n-  req_wrap_obj->Set(env->buffer_string(), args[1]);\n+  StreamWriteResult res = Write(&buf, 1, nullptr, req_wrap_obj);\n \n-  if (err)\n-    req_wrap->Dispose();\n+  if (res.async)\n+    req_wrap_obj->Set(env->context(), env->buffer_string(), args[1]).FromJust();\n+  req_wrap_obj->Set(env->context(), env->bytes_string(),\n+                    Integer::NewFromUnsigned(env->isolate(), buf.len))\n+      .FromJust();\n \n- done:\n-  const char* msg = Error();\n-  if (msg != nullptr) {\n-    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n-    ClearError();\n-  }\n-  req_wrap_obj->Set(env->bytes_string(),\n-                    Integer::NewFromUnsigned(env->isolate(), length));\n-  return err;\n+  return res.err;\n }\n \n \n@@ -305,8 +213,6 @@ int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {\n     return UV_ENOBUFS;\n \n   // Try writing immediately if write size isn't too big\n-  WriteWrap* req_wrap;\n-  char* data;\n   char stack_storage[16384];  // 16kb\n   size_t data_size;\n   uv_buf_t buf;\n@@ -325,115 +231,70 @@ int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {\n     size_t count = 1;\n     err = DoTryWrite(&bufs, &count);\n \n-    // Failure\n-    if (err != 0)\n-      goto done;\n-\n-    // Success\n-    if (count == 0)\n-      goto done;\n+    // Immediate failure or success\n+    if (err != 0 || count == 0) {\n+      req_wrap_obj->Set(env->context(), env->async(), False(env->isolate()))\n+          .FromJust();\n+      req_wrap_obj->Set(env->context(),\n+                        env->bytes_string(),\n+                        Integer::NewFromUnsigned(env->isolate(), data_size))\n+          .FromJust();\n+      return err;\n+    }\n \n     // Partial write\n     CHECK_EQ(count, 1);\n   }\n \n-  {\n-    AsyncWrap* wrap = GetAsyncWrap();\n-    CHECK_NE(wrap, nullptr);\n-    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(env,\n-                                                         wrap->get_async_id());\n-    req_wrap = WriteWrap::New(env, req_wrap_obj, this, storage_size);\n-  }\n-\n-  data = req_wrap->Extra();\n+  std::unique_ptr<char[], Free> data;\n \n   if (try_write) {\n     // Copy partial data\n-    memcpy(data, buf.base, buf.len);\n+    data = std::unique_ptr<char[], Free>(Malloc(buf.len));\n+    memcpy(data.get(), buf.base, buf.len);\n     data_size = buf.len;\n   } else {\n     // Write it\n+    data = std::unique_ptr<char[], Free>(Malloc(storage_size));\n     data_size = StringBytes::Write(env->isolate(),\n-                                   data,\n+                                   data.get(),\n                                    storage_size,\n                                    string,\n                                    enc);\n   }\n \n   CHECK_LE(data_size, storage_size);\n \n-  buf = uv_buf_init(data, data_size);\n-\n-  if (!IsIPCPipe()) {\n-    err = DoWrite(req_wrap, &buf, 1, nullptr);\n-  } else {\n-    uv_handle_t* send_handle = nullptr;\n-\n-    if (!send_handle_obj.IsEmpty()) {\n-      HandleWrap* wrap;\n-      ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);\n-      send_handle = wrap->GetHandle();\n-      // Reference LibuvStreamWrap instance to prevent it from being garbage\n-      // collected before `AfterWrite` is called.\n-      CHECK_EQ(false, req_wrap->persistent().IsEmpty());\n-      req_wrap_obj->Set(env->handle_string(), send_handle_obj);\n-    }\n-\n-    err = DoWrite(\n-        req_wrap,\n-        &buf,\n-        1,\n-        reinterpret_cast<uv_stream_t*>(send_handle));\n+  buf = uv_buf_init(data.get(), data_size);\n+\n+  uv_stream_t* send_handle = nullptr;\n+\n+  if (IsIPCPipe() && !send_handle_obj.IsEmpty()) {\n+    // TODO(addaleax): This relies on the fact that HandleWrap comes first\n+    // as a superclass of each individual subclass.\n+    // There are similar assumptions in other places in the code base.\n+    // A better idea would be having all BaseObject's internal pointers\n+    // refer to the BaseObject* itself; this would require refactoring\n+    // throughout the code base but makes Node rely much less on C++ quirks.\n+    HandleWrap* wrap;\n+    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);\n+    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());\n+    // Reference LibuvStreamWrap instance to prevent it from being garbage\n+    // collected before `AfterWrite` is called.\n+    req_wrap_obj->Set(env->handle_string(), send_handle_obj);\n   }\n \n-  req_wrap_obj->Set(env->async(), True(env->isolate()));\n+  StreamWriteResult res = Write(&buf, 1, send_handle, req_wrap_obj);\n \n-  if (err)\n-    req_wrap->Dispose();\n+  req_wrap_obj->Set(env->context(), env->bytes_string(),\n+                    Integer::NewFromUnsigned(env->isolate(), data_size))\n+      .FromJust();\n \n- done:\n-  const char* msg = Error();\n-  if (msg != nullptr) {\n-    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n-    ClearError();\n+  if (res.wrap != nullptr) {\n+    res.wrap->SetAllocatedStorage(data.release(), data_size);\n   }\n-  req_wrap_obj->Set(env->bytes_string(),\n-                    Integer::NewFromUnsigned(env->isolate(), data_size));\n-  return err;\n-}\n-\n-\n-void StreamBase::AfterWrite(WriteWrap* req_wrap, int status) {\n-  Environment* env = req_wrap->env();\n-\n-  HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n-\n-  // The wrap and request objects should still be there.\n-  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);\n-\n-  // Unref handle property\n-  Local<Object> req_wrap_obj = req_wrap->object();\n-  req_wrap_obj->Delete(env->context(), env->handle_string()).FromJust();\n-  EmitAfterWrite(req_wrap, status);\n-\n-  Local<Value> argv[] = {\n-    Integer::New(env->isolate(), status),\n-    GetObject(),\n-    req_wrap_obj,\n-    Undefined(env->isolate())\n-  };\n-\n-  const char* msg = Error();\n-  if (msg != nullptr) {\n-    argv[3] = OneByteString(env->isolate(), msg);\n-    ClearError();\n-  }\n-\n-  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())\n-    req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);\n \n-  req_wrap->Dispose();\n+  return res.err;\n }\n \n \n@@ -510,4 +371,39 @@ void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   stream->CallJSOnreadMethod(nread, obj);\n }\n \n+\n+void ReportWritesToJSStreamListener::OnStreamAfterReqFinished(\n+    StreamReq* req_wrap, int status) {\n+  StreamBase* stream = static_cast<StreamBase*>(stream_);\n+  Environment* env = stream->stream_env();\n+  AsyncWrap* async_wrap = req_wrap->GetAsyncWrap();\n+  Local<Object> req_wrap_obj = async_wrap->object();\n+\n+  Local<Value> argv[] = {\n+    Integer::New(env->isolate(), status),\n+    stream->GetObject(),\n+    Undefined(env->isolate())\n+  };\n+\n+  const char* msg = stream->Error();\n+  if (msg != nullptr) {\n+    argv[2] = OneByteString(env->isolate(), msg);\n+    stream->ClearError();\n+  }\n+\n+  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())\n+    async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);\n+}\n+\n+void ReportWritesToJSStreamListener::OnStreamAfterWrite(\n+    WriteWrap* req_wrap, int status) {\n+  OnStreamAfterReqFinished(req_wrap, status);\n+}\n+\n+void ReportWritesToJSStreamListener::OnStreamAfterShutdown(\n+    ShutdownWrap* req_wrap, int status) {\n+  OnStreamAfterReqFinished(req_wrap, status);\n+}\n+\n+\n }  // namespace node"
        },
        {
            "sha": "59b8ee7b7221f04ca0ca8ba1a7612a8d5244845c",
            "filename": "src/stream_base.h",
            "status": "modified",
            "additions": 148,
            "deletions": 98,
            "changes": 246,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_base.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_base.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -14,114 +14,75 @@\n namespace node {\n \n // Forward declarations\n+class ShutdownWrap;\n+class WriteWrap;\n class StreamBase;\n class StreamResource;\n \n-template<typename Base>\n+struct StreamWriteResult {\n+  bool async;\n+  int err;\n+  WriteWrap* wrap;\n+};\n+\n+\n class StreamReq {\n  public:\n-  explicit StreamReq(StreamBase* stream) : stream_(stream) {\n+  static constexpr int kStreamReqField = 1;\n+\n+  explicit StreamReq(StreamBase* stream,\n+                     v8::Local<v8::Object> req_wrap_obj) : stream_(stream) {\n+    AttachToObject(req_wrap_obj);\n   }\n \n-  inline void Done(int status, const char* error_str = nullptr) {\n-    Base* req = static_cast<Base*>(this);\n-    Environment* env = req->env();\n-    if (error_str != nullptr) {\n-      req->object()->Set(env->error_string(),\n-                         OneByteString(env->isolate(), error_str));\n-    }\n+  virtual ~StreamReq() {}\n+  virtual AsyncWrap* GetAsyncWrap() = 0;\n+  v8::Local<v8::Object> object();\n \n-    req->OnDone(status);\n-  }\n+  void Done(int status, const char* error_str = nullptr);\n+  void Dispose();\n \n   inline StreamBase* stream() const { return stream_; }\n \n+  static StreamReq* FromObject(v8::Local<v8::Object> req_wrap_obj);\n+\n+ protected:\n+  virtual void OnDone(int status) = 0;\n+\n+  void AttachToObject(v8::Local<v8::Object> req_wrap_obj);\n+\n  private:\n   StreamBase* const stream_;\n };\n \n-class ShutdownWrap : public ReqWrap<uv_shutdown_t>,\n-                     public StreamReq<ShutdownWrap> {\n+class ShutdownWrap : public StreamReq {\n  public:\n-  ShutdownWrap(Environment* env,\n-               v8::Local<v8::Object> req_wrap_obj,\n-               StreamBase* stream)\n-      : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_SHUTDOWNWRAP),\n-        StreamReq<ShutdownWrap>(stream) {\n-    Wrap(req_wrap_obj, this);\n-  }\n+  ShutdownWrap(StreamBase* stream,\n+               v8::Local<v8::Object> req_wrap_obj)\n+    : StreamReq(stream, req_wrap_obj) { }\n \n-  ~ShutdownWrap() {\n-    ClearWrap(object());\n-  }\n-\n-  static ShutdownWrap* from_req(uv_shutdown_t* req) {\n-    return ContainerOf(&ShutdownWrap::req_, req);\n-  }\n-\n-  size_t self_size() const override { return sizeof(*this); }\n-\n-  inline void OnDone(int status);  // Just calls stream()->AfterShutdown()\n+  void OnDone(int status) override;  // Just calls stream()->AfterShutdown()\n };\n \n-class WriteWrap : public ReqWrap<uv_write_t>,\n-                  public StreamReq<WriteWrap> {\n+class WriteWrap : public StreamReq {\n  public:\n-  static inline WriteWrap* New(Environment* env,\n-                               v8::Local<v8::Object> obj,\n-                               StreamBase* stream,\n-                               size_t extra = 0);\n-  inline void Dispose();\n-  inline char* Extra(size_t offset = 0);\n-  inline size_t ExtraSize() const;\n-\n-  size_t self_size() const override { return storage_size_; }\n-\n-  static WriteWrap* from_req(uv_write_t* req) {\n-    return ContainerOf(&WriteWrap::req_, req);\n-  }\n+  char* Storage();\n+  size_t StorageSize() const;\n+  void SetAllocatedStorage(char* data, size_t size);\n \n-  static const size_t kAlignSize = 16;\n-\n-  WriteWrap(Environment* env,\n-            v8::Local<v8::Object> obj,\n-            StreamBase* stream)\n-      : ReqWrap(env, obj, AsyncWrap::PROVIDER_WRITEWRAP),\n-        StreamReq<WriteWrap>(stream),\n-        storage_size_(0) {\n-    Wrap(obj, this);\n-  }\n-\n-  inline void OnDone(int status);  // Just calls stream()->AfterWrite()\n-\n- protected:\n-  WriteWrap(Environment* env,\n-            v8::Local<v8::Object> obj,\n-            StreamBase* stream,\n-            size_t storage_size)\n-      : ReqWrap(env, obj, AsyncWrap::PROVIDER_WRITEWRAP),\n-        StreamReq<WriteWrap>(stream),\n-        storage_size_(storage_size) {\n-    Wrap(obj, this);\n-  }\n+  WriteWrap(StreamBase* stream,\n+            v8::Local<v8::Object> req_wrap_obj)\n+    : StreamReq(stream, req_wrap_obj) { }\n \n   ~WriteWrap() {\n-    ClearWrap(object());\n+    free(storage_);\n   }\n \n-  void* operator new(size_t size) = delete;\n-  void* operator new(size_t size, char* storage) { return storage; }\n-\n-  // This is just to keep the compiler happy. It should never be called, since\n-  // we don't use exceptions in node.\n-  void operator delete(void* ptr, char* storage) { UNREACHABLE(); }\n+  void OnDone(int status) override;  // Just calls stream()->AfterWrite()\n \n  private:\n-  // People should not be using the non-placement new and delete operator on a\n-  // WriteWrap. Ensure this never happens.\n-  void operator delete(void* ptr) { UNREACHABLE(); }\n-\n-  const size_t storage_size_;\n+  char* storage_ = nullptr;\n+  size_t storage_size_ = 0;\n };\n \n \n@@ -147,15 +108,23 @@ class StreamListener {\n   // `OnStreamRead()` is called when data is available on the socket and has\n   // been read into the buffer provided by `OnStreamAlloc()`.\n   // The `buf` argument is the return value of `uv_buf_t`, or may be a buffer\n-  // with base nullpptr in case of an error.\n+  // with base nullptr in case of an error.\n   // `nread` is the number of read bytes (which is at most the buffer length),\n   // or, if negative, a libuv error code.\n   virtual void OnStreamRead(ssize_t nread,\n                             const uv_buf_t& buf) = 0;\n \n-  // This is called once a Write has finished. `status` may be 0 or,\n+  // This is called once a write has finished. `status` may be 0 or,\n   // if negative, a libuv error code.\n-  virtual void OnStreamAfterWrite(WriteWrap* w, int status) {}\n+  // By default, this is simply passed on to the previous listener\n+  // (and raises an assertion if there is none).\n+  virtual void OnStreamAfterWrite(WriteWrap* w, int status);\n+\n+  // This is called once a shutdown has finished. `status` may be 0 or,\n+  // if negative, a libuv error code.\n+  // By default, this is simply passed on to the previous listener\n+  // (and raises an assertion if there is none).\n+  virtual void OnStreamAfterShutdown(ShutdownWrap* w, int status);\n \n   // This is called immediately before the stream is destroyed.\n   virtual void OnStreamDestroy() {}\n@@ -174,9 +143,21 @@ class StreamListener {\n };\n \n \n+// An (incomplete) stream listener class that calls the `.oncomplete()`\n+// method of the JS objects associated with the wrap objects.\n+class ReportWritesToJSStreamListener : public StreamListener {\n+ public:\n+  void OnStreamAfterWrite(WriteWrap* w, int status) override;\n+  void OnStreamAfterShutdown(ShutdownWrap* w, int status) override;\n+\n+ private:\n+  void OnStreamAfterReqFinished(StreamReq* req_wrap, int status);\n+};\n+\n+\n // A default emitter that just pushes data chunks as Buffer instances to\n // JS land via the handle’s .ondata method.\n-class EmitToJSStreamListener : public StreamListener {\n+class EmitToJSStreamListener : public ReportWritesToJSStreamListener {\n  public:\n   void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n };\n@@ -188,20 +169,31 @@ class StreamResource {\n  public:\n   virtual ~StreamResource();\n \n-  virtual int DoShutdown(ShutdownWrap* req_wrap) = 0;\n-  virtual int DoTryWrite(uv_buf_t** bufs, size_t* count);\n-  virtual int DoWrite(WriteWrap* w,\n-                      uv_buf_t* bufs,\n-                      size_t count,\n-                      uv_stream_t* send_handle) = 0;\n+  // These need to be implemented on the readable side of this stream:\n \n   // Start reading from the underlying resource. This is called by the consumer\n-  // when more data is desired.\n+  // when more data is desired. Use `EmitAlloc()` and `EmitData()` to\n+  // pass data along to the consumer.\n   virtual int ReadStart() = 0;\n   // Stop reading from the underlying resource. This is called by the\n   // consumer when its buffers are full and no more data can be handled.\n   virtual int ReadStop() = 0;\n \n+  // These need to be implemented on the writable side of this stream:\n+  // All of these methods may return an error code synchronously.\n+  // In that case, the finish callback should *not* be called.\n+\n+  // Perform a shutdown operation, and call req_wrap->Done() when finished.\n+  virtual int DoShutdown(ShutdownWrap* req_wrap) = 0;\n+  // Try to write as much data as possible synchronously, and modify\n+  // `*bufs` and `*count` accordingly. This is a no-op by default.\n+  virtual int DoTryWrite(uv_buf_t** bufs, size_t* count);\n+  // Perform a write of data, and call req_wrap->Done() when finished.\n+  virtual int DoWrite(WriteWrap* w,\n+                      uv_buf_t* bufs,\n+                      size_t count,\n+                      uv_stream_t* send_handle) = 0;\n+\n   // Optionally, this may provide an error message to be used for\n   // failing writes.\n   virtual const char* Error() const;\n@@ -223,6 +215,8 @@ class StreamResource {\n   void EmitRead(ssize_t nread, const uv_buf_t& buf = uv_buf_init(nullptr, 0));\n   // Call the current listener's OnStreamAfterWrite() method.\n   void EmitAfterWrite(WriteWrap* w, int status);\n+  // Call the current listener's OnStreamAfterShutdown() method.\n+  void EmitAfterShutdown(ShutdownWrap* w, int status);\n \n   StreamListener* listener_ = nullptr;\n   uint64_t bytes_read_ = 0;\n@@ -251,21 +245,40 @@ class StreamBase : public StreamResource {\n \n   void CallJSOnreadMethod(ssize_t nread, v8::Local<v8::Object> buf);\n \n-  // These are called by the respective {Write,Shutdown}Wrap class.\n-  virtual void AfterShutdown(ShutdownWrap* req, int status);\n-  virtual void AfterWrite(WriteWrap* req, int status);\n-\n   // This is named `stream_env` to avoid name clashes, because a lot of\n   // subclasses are also `BaseObject`s.\n   Environment* stream_env() const;\n \n- protected:\n-  explicit StreamBase(Environment* env);\n+  // Shut down the current stream. This request can use an existing\n+  // ShutdownWrap object (that was created in JS), or a new one will be created.\n+  int Shutdown(v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>());\n+\n+  // Write data to the current stream. This request can use an existing\n+  // WriteWrap object (that was created in JS), or a new one will be created.\n+  // This will first try to write synchronously using `DoTryWrite()`, then\n+  // asynchronously using `DoWrite()`.\n+  // If the return value indicates a synchronous completion, no callback will\n+  // be invoked.\n+  StreamWriteResult Write(\n+      uv_buf_t* bufs,\n+      size_t count,\n+      uv_stream_t* send_handle = nullptr,\n+      v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>());\n+\n+  // These can be overridden by subclasses to get more specific wrap instances.\n+  // For example, a subclass Foo could create a FooWriteWrap or FooShutdownWrap\n+  // (inheriting from ShutdownWrap/WriteWrap) that has extra fields, like\n+  // an associated libuv request.\n+  virtual ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object);\n+  virtual WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object);\n \n   // One of these must be implemented\n   virtual AsyncWrap* GetAsyncWrap() = 0;\n   virtual v8::Local<v8::Object> GetObject();\n \n+ protected:\n+  explicit StreamBase(Environment* env);\n+\n   // JS Methods\n   int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args);\n   int ReadStopJS(const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -292,6 +305,43 @@ class StreamBase : public StreamResource {\n  private:\n   Environment* env_;\n   EmitToJSStreamListener default_listener_;\n+\n+  // These are called by the respective {Write,Shutdown}Wrap class.\n+  void AfterShutdown(ShutdownWrap* req, int status);\n+  void AfterWrite(WriteWrap* req, int status);\n+\n+  template <typename Wrap, typename EmitEvent>\n+  void AfterRequest(Wrap* req_wrap, EmitEvent emit);\n+\n+  friend class WriteWrap;\n+  friend class ShutdownWrap;\n+};\n+\n+\n+// These are helpers for creating `ShutdownWrap`/`WriteWrap` instances.\n+// `OtherBase` must have a constructor that matches the `AsyncWrap`\n+// constructors’s (Environment*, Local<Object>, AsyncWrap::Provider) signature\n+// and be a subclass of `AsyncWrap`.\n+template <typename OtherBase, bool kResetPersistentOnDestroy = true>\n+class SimpleShutdownWrap : public ShutdownWrap, public OtherBase {\n+ public:\n+  SimpleShutdownWrap(StreamBase* stream,\n+                     v8::Local<v8::Object> req_wrap_obj);\n+  ~SimpleShutdownWrap();\n+\n+  AsyncWrap* GetAsyncWrap() override { return this; }\n+  size_t self_size() const override { return sizeof(*this); }\n+};\n+\n+template <typename OtherBase, bool kResetPersistentOnDestroy = true>\n+class SimpleWriteWrap : public WriteWrap, public OtherBase {\n+ public:\n+  SimpleWriteWrap(StreamBase* stream,\n+                  v8::Local<v8::Object> req_wrap_obj);\n+  ~SimpleWriteWrap();\n+\n+  AsyncWrap* GetAsyncWrap() override { return this; }\n+  size_t self_size() const override { return sizeof(*this) + StorageSize(); }\n };\n \n }  // namespace node"
        },
        {
            "sha": "e1df9edd39e151390b8d801a26de40beaef1ec09",
            "filename": "src/stream_wrap.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 9,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.cc?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -61,19 +61,22 @@ void LibuvStreamWrap::Initialize(Local<Object> target,\n       [](const FunctionCallbackInfo<Value>& args) {\n     CHECK(args.IsConstructCall());\n     ClearWrap(args.This());\n+    args.This()->SetAlignedPointerInInternalField(\n+        StreamReq::kStreamReqField, nullptr);\n   };\n   Local<FunctionTemplate> sw =\n       FunctionTemplate::New(env->isolate(), is_construct_call_callback);\n-  sw->InstanceTemplate()->SetInternalFieldCount(1);\n+  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kStreamReqField + 1);\n   Local<String> wrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"ShutdownWrap\");\n   sw->SetClassName(wrapString);\n   AsyncWrap::AddWrapMethods(env, sw);\n   target->Set(wrapString, sw->GetFunction());\n+  env->set_shutdown_wrap_constructor_function(sw->GetFunction());\n \n   Local<FunctionTemplate> ww =\n       FunctionTemplate::New(env->isolate(), is_construct_call_callback);\n-  ww->InstanceTemplate()->SetInternalFieldCount(1);\n+  ww->InstanceTemplate()->SetInternalFieldCount(StreamReq::kStreamReqField + 1);\n   Local<String> writeWrapString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"WriteWrap\");\n   ww->SetClassName(writeWrapString);\n@@ -261,8 +264,20 @@ void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));\n }\n \n+typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>, false> LibuvShutdownWrap;\n+typedef SimpleWriteWrap<ReqWrap<uv_write_t>, false> LibuvWriteWrap;\n \n-int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap) {\n+ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) {\n+  return new LibuvShutdownWrap(this, object);\n+}\n+\n+WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) {\n+  return new LibuvWriteWrap(this, object);\n+}\n+\n+\n+int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) {\n+  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);\n   int err;\n   err = uv_shutdown(req_wrap->req(), stream(), AfterUvShutdown);\n   req_wrap->Dispatched();\n@@ -271,7 +286,8 @@ int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap) {\n \n \n void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) {\n-  ShutdownWrap* req_wrap = ShutdownWrap::from_req(req);\n+  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(\n+      LibuvShutdownWrap::from_req(req));\n   CHECK_NE(req_wrap, nullptr);\n   HandleScope scope(req_wrap->env()->isolate());\n   Context::Scope context_scope(req_wrap->env()->context());\n@@ -319,10 +335,11 @@ int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) {\n }\n \n \n-int LibuvStreamWrap::DoWrite(WriteWrap* w,\n-                        uv_buf_t* bufs,\n-                        size_t count,\n-                        uv_stream_t* send_handle) {\n+int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,\n+                             uv_buf_t* bufs,\n+                             size_t count,\n+                             uv_stream_t* send_handle) {\n+  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);\n   int r;\n   if (send_handle == nullptr) {\n     r = uv_write(w->req(), stream(), bufs, count, AfterUvWrite);\n@@ -349,7 +366,8 @@ int LibuvStreamWrap::DoWrite(WriteWrap* w,\n \n \n void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) {\n-  WriteWrap* req_wrap = WriteWrap::from_req(req);\n+  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(\n+      LibuvWriteWrap::from_req(req));\n   CHECK_NE(req_wrap, nullptr);\n   HandleScope scope(req_wrap->env()->isolate());\n   Context::Scope context_scope(req_wrap->env()->context());"
        },
        {
            "sha": "a97e8ba10f91d50f4e06e90ef7d1072f01707bb7",
            "filename": "src/stream_wrap.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Fstream_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -73,6 +73,9 @@ class LibuvStreamWrap : public HandleWrap, public StreamBase {\n     return stream()->type == UV_TCP;\n   }\n \n+  ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override;\n+  WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override;\n+\n  protected:\n   LibuvStreamWrap(Environment* env,\n                   v8::Local<v8::Object> object,"
        },
        {
            "sha": "f2a84b83f32de2a39fd841455259ab6d5c9fffac",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 27,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -285,37 +285,29 @@ void TLSWrap::EncOut() {\n   for (size_t i = 0; i < count; i++)\n     buf[i] = uv_buf_init(data[i], size[i]);\n \n-  int err = stream_->DoTryWrite(&bufs, &count);\n-  if (err != 0) {\n-    InvokeQueued(err);\n-  } else if (count == 0) {\n-    env()->SetImmediate([](Environment* env, void* data) {\n-      NODE_COUNT_NET_BYTES_SENT(write_size_);\n-      static_cast<TLSWrap*>(data)->OnStreamAfterWrite(nullptr, 0);\n-    }, this, object());\n+  StreamWriteResult res = underlying_stream()->Write(bufs, count);\n+  if (res.err != 0) {\n+    InvokeQueued(res.err);\n     return;\n   }\n \n-  Local<Object> req_wrap_obj =\n-      env()->write_wrap_constructor_function()\n-          ->NewInstance(env()->context()).ToLocalChecked();\n-  WriteWrap* write_req = WriteWrap::New(env(),\n-                                        req_wrap_obj,\n-                                        static_cast<StreamBase*>(stream_));\n+  NODE_COUNT_NET_BYTES_SENT(write_size_);\n \n-  err = stream_->DoWrite(write_req, buf, count, nullptr);\n-\n-  // Ignore errors, this should be already handled in js\n-  if (err) {\n-    write_req->Dispose();\n-    InvokeQueued(err);\n-  } else {\n-    NODE_COUNT_NET_BYTES_SENT(write_size_);\n+  if (!res.async) {\n+    // Simulate asynchronous finishing, TLS cannot handle this at the moment.\n+    env()->SetImmediate([](Environment* env, void* data) {\n+      static_cast<TLSWrap*>(data)->OnStreamAfterWrite(nullptr, 0);\n+    }, this, object());\n   }\n }\n \n \n void TLSWrap::OnStreamAfterWrite(WriteWrap* req_wrap, int status) {\n+  // Report back to the previous listener as well. This is only needed for the\n+  // \"empty\" writes that are passed through directly to the underlying stream.\n+  if (req_wrap != nullptr)\n+    previous_listener_->OnStreamAfterWrite(req_wrap, status);\n+\n   if (ssl_ == nullptr)\n     status = UV_ECANCELED;\n \n@@ -513,24 +505,24 @@ AsyncWrap* TLSWrap::GetAsyncWrap() {\n \n \n bool TLSWrap::IsIPCPipe() {\n-  return static_cast<StreamBase*>(stream_)->IsIPCPipe();\n+  return underlying_stream()->IsIPCPipe();\n }\n \n \n int TLSWrap::GetFD() {\n-  return static_cast<StreamBase*>(stream_)->GetFD();\n+  return underlying_stream()->GetFD();\n }\n \n \n bool TLSWrap::IsAlive() {\n   return ssl_ != nullptr &&\n       stream_ != nullptr &&\n-      static_cast<StreamBase*>(stream_)->IsAlive();\n+      underlying_stream()->IsAlive();\n }\n \n \n bool TLSWrap::IsClosing() {\n-  return static_cast<StreamBase*>(stream_)->IsClosing();\n+  return underlying_stream()->IsClosing();\n }\n \n \n@@ -580,14 +572,24 @@ int TLSWrap::DoWrite(WriteWrap* w,\n     // However, if there is any data that should be written to the socket,\n     // the callback should not be invoked immediately\n     if (BIO_pending(enc_out_) == 0) {\n+      // We destroy the current WriteWrap* object and create a new one that\n+      // matches the underlying stream, rather than the TLSWrap itself.\n+\n+      // Note: We cannot simply use w->object() because of the \"optimized\"\n+      // way in which we read persistent handles; the JS object itself might be\n+      // destroyed by w->Dispose(), and the Local<Object> we have is not a\n+      // \"real\" handle in the sense the V8 is aware of its existence.\n+      Local<Object> req_wrap_obj =\n+          w->GetAsyncWrap()->persistent().Get(env()->isolate());\n+      w->Dispose();\n+      w = underlying_stream()->CreateWriteWrap(req_wrap_obj);\n       return stream_->DoWrite(w, bufs, count, send_handle);\n     }\n   }\n \n   // Store the current write wrap\n   CHECK_EQ(current_write_, nullptr);\n   current_write_ = w;\n-  w->Dispatched();\n \n   // Write queued data\n   if (empty) {\n@@ -677,6 +679,11 @@ void TLSWrap::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n }\n \n \n+ShutdownWrap* TLSWrap::CreateShutdownWrap(Local<Object> req_wrap_object) {\n+  return underlying_stream()->CreateShutdownWrap(req_wrap_object);\n+}\n+\n+\n int TLSWrap::DoShutdown(ShutdownWrap* req_wrap) {\n   crypto::MarkPopErrorOnReturn mark_pop_error_on_return;\n "
        },
        {
            "sha": "afd19c027e7007cbbbd8bfc83f4e19613114f76d",
            "filename": "src/tls_wrap.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Ftls_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/src%2Ftls_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.h?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -65,6 +65,8 @@ class TLSWrap : public AsyncWrap,\n   int ReadStart() override;\n   int ReadStop() override;\n \n+  ShutdownWrap* CreateShutdownWrap(\n+      v8::Local<v8::Object> req_wrap_object) override;\n   int DoShutdown(ShutdownWrap* req_wrap) override;\n   int DoWrite(WriteWrap* w,\n               uv_buf_t* bufs,\n@@ -78,6 +80,10 @@ class TLSWrap : public AsyncWrap,\n   size_t self_size() const override { return sizeof(*this); }\n \n  protected:\n+  inline StreamBase* underlying_stream() {\n+    return static_cast<StreamBase*>(stream_);\n+  }\n+\n   static const int kClearOutChunkSize = 16384;\n \n   // Maximum number of bytes for hello parser"
        },
        {
            "sha": "9f5560a385086a5bfe2a8597716757bdcd1b1f9d",
            "filename": "test/parallel/test-tcp-wrap-connect.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/0e7b61229aa602e55c5fb034a63d7da97eecff3b/test%2Fparallel%2Ftest-tcp-wrap-connect.js",
            "raw_url": "https://github.com/nodejs/node/raw/0e7b61229aa602e55c5fb034a63d7da97eecff3b/test%2Fparallel%2Ftest-tcp-wrap-connect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tcp-wrap-connect.js?ref=0e7b61229aa602e55c5fb034a63d7da97eecff3b",
            "patch": "@@ -23,10 +23,10 @@ function makeConnection() {\n     const err = client.shutdown(shutdownReq);\n     assert.strictEqual(err, 0);\n \n-    shutdownReq.oncomplete = function(status, client_, req_) {\n+    shutdownReq.oncomplete = function(status, client_, error) {\n       assert.strictEqual(0, status);\n       assert.strictEqual(client, client_);\n-      assert.strictEqual(shutdownReq, req_);\n+      assert.strictEqual(error, undefined);\n       shutdownCount++;\n       client.close();\n     };"
        }
    ],
    "stats": {
        "total": 983,
        "additions": 556,
        "deletions": 427
    }
}