{
    "author": "BridgeAR",
    "message": "events: simplify stack compare function\n\nThis simplifies the `longestSeqContainedIn()` logic by checking for\nthe first identical occurance of at least three frames instead of\nthe longest one.\nIt also removes an unused argument.\n\nPR-URL: https://github.com/nodejs/node/pull/24744\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "a76750b49e70fbf32711d68608db3e320f19b359",
    "files": [
        {
            "sha": "10cec4bd69d4d1e45ff4d8a881d54e397f5acf72",
            "filename": "lib/events.js",
            "status": "modified",
            "additions": 20,
            "deletions": 21,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/a76750b49e70fbf32711d68608db3e320f19b359/lib%2Fevents.js",
            "raw_url": "https://github.com/nodejs/node/raw/a76750b49e70fbf32711d68608db3e320f19b359/lib%2Fevents.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fevents.js?ref=a76750b49e70fbf32711d68608db3e320f19b359",
            "patch": "@@ -103,30 +103,29 @@ EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n   return $getMaxListeners(this);\n };\n \n-// Returns the longest sequence of `a` that fully appears in `b`,\n-// of length at least 3.\n-// This is a lazy approach but should work well enough, given that stack\n-// frames are usually unequal or otherwise appear in groups, and that\n-// we only run this code in case of an unhandled exception.\n-function longestSeqContainedIn(a, b) {\n-  for (var len = a.length; len >= 3; --len) {\n-    for (var i = 0; i < a.length - len; ++i) {\n-      // Attempt to find a[i:i+len] in b\n-      for (var j = 0; j < b.length - len; ++j) {\n-        let matches = true;\n-        for (var k = 0; k < len; ++k) {\n-          if (a[i + k] !== b[j + k]) {\n-            matches = false;\n-            break;\n-          }\n+// Returns the length and line number of the first sequence of `a` that fully\n+// appears in `b` with a length of at least 4.\n+function identicalSequenceRange(a, b) {\n+  for (var i = 0; i < a.length - 3; i++) {\n+    // Find the first entry of b that matches the current entry of a.\n+    const pos = b.indexOf(a[i]);\n+    if (pos !== -1) {\n+      const rest = b.length - pos;\n+      if (rest > 3) {\n+        let len = 1;\n+        const maxLen = Math.min(a.length - i, rest);\n+        // Count the number of consecutive entries.\n+        while (maxLen > len && a[i + len] === b[pos + len]) {\n+          len++;\n+        }\n+        if (len > 3) {\n+          return [len, i];\n         }\n-        if (matches)\n-          return [ len, i, j ];\n       }\n     }\n   }\n \n-  return [ 0, 0, 0 ];\n+  return [0, 0];\n }\n \n function enhanceStackTrace(err, own) {\n@@ -135,9 +134,9 @@ function enhanceStackTrace(err, own) {\n   const errStack = err.stack.split('\\n').slice(1);\n   const ownStack = own.stack.split('\\n').slice(1);\n \n-  const [ len, off ] = longestSeqContainedIn(ownStack, errStack);\n+  const [ len, off ] = identicalSequenceRange(ownStack, errStack);\n   if (len > 0) {\n-    ownStack.splice(off + 1, len - 1,\n+    ownStack.splice(off + 1, len - 2,\n                     '    [... lines matching original stack trace ...]');\n   }\n   // Do this last, because it is the only operation with side effects."
        }
    ],
    "stats": {
        "total": 41,
        "additions": 20,
        "deletions": 21
    }
}