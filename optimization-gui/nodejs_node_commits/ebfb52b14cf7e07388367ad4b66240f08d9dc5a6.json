{
    "author": "addaleax",
    "message": "src: minor refactor of node_trace_events.cc\n\nAvoid unnecessary copies/extra operations & align with our style guide,\nand add protection against throwing getters.\n\nPR-URL: https://github.com/nodejs/node/pull/21867\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Eugene Ostroukhov <eostroukhov@google.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>",
    "sha": "ebfb52b14cf7e07388367ad4b66240f08d9dc5a6",
    "files": [
        {
            "sha": "06063a449b93d85854a1370e1512baa21bff9dc7",
            "filename": "src/node_trace_events.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 15,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/ebfb52b14cf7e07388367ad4b66240f08d9dc5a6/src%2Fnode_trace_events.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ebfb52b14cf7e07388367ad4b66240f08d9dc5a6/src%2Fnode_trace_events.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_trace_events.cc?ref=ebfb52b14cf7e07388367ad4b66240f08d9dc5a6",
            "patch": "@@ -25,7 +25,7 @@ class NodeCategorySet : public BaseObject {\n   static void Enable(const FunctionCallbackInfo<Value>& args);\n   static void Disable(const FunctionCallbackInfo<Value>& args);\n \n-  const std::set<std::string>& GetCategories() { return categories_; }\n+  const std::set<std::string>& GetCategories() const { return categories_; }\n \n   void MemoryInfo(MemoryTracker* tracker) const override {\n     tracker->TrackThis(this);\n@@ -37,8 +37,8 @@ class NodeCategorySet : public BaseObject {\n  private:\n   NodeCategorySet(Environment* env,\n                   Local<Object> wrap,\n-                  std::set<std::string> categories) :\n-        BaseObject(env, wrap), categories_(categories) {\n+                  std::set<std::string>&& categories) :\n+        BaseObject(env, wrap), categories_(std::move(categories)) {\n     MakeWeak();\n   }\n \n@@ -52,12 +52,14 @@ void NodeCategorySet::New(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsArray());\n   Local<Array> cats = args[0].As<Array>();\n   for (size_t n = 0; n < cats->Length(); n++) {\n-    Local<Value> category = cats->Get(env->context(), n).ToLocalChecked();\n+    Local<Value> category;\n+    if (!cats->Get(env->context(), n).ToLocal(&category)) return;\n     Utf8Value val(env->isolate(), category);\n+    if (!*val) return;\n     categories.emplace(*val);\n   }\n   CHECK_NOT_NULL(env->tracing_agent());\n-  new NodeCategorySet(env, args.This(), categories);\n+  new NodeCategorySet(env, args.This(), std::move(categories));\n }\n \n void NodeCategorySet::Enable(const FunctionCallbackInfo<Value>& args) {\n@@ -91,13 +93,15 @@ void GetEnabledCategories(const FunctionCallbackInfo<Value>& args) {\n     args.GetReturnValue().Set(\n       String::NewFromUtf8(env->isolate(),\n                           categories.c_str(),\n-                          v8::NewStringType::kNormal).ToLocalChecked());\n+                          v8::NewStringType::kNormal,\n+                          categories.size()).ToLocalChecked());\n   }\n }\n \n // The tracing APIs require category groups to be pointers to long-lived\n // strings. Those strings are stored here.\n-static std::unordered_set<std::string> categoryGroups;\n+static std::unordered_set<std::string> category_groups;\n+static Mutex category_groups_mutex;\n \n // Gets a pointer to the category-enabled flags for a tracing category group,\n // if tracing is enabled for it.\n@@ -107,14 +111,15 @@ static const uint8_t* GetCategoryGroupEnabled(const char* category_group) {\n }\n \n static const char* GetCategoryGroup(Environment* env,\n-                                    const Local<Value> categoryValue) {\n-  CHECK(categoryValue->IsString());\n+                                    const Local<Value> category_value) {\n+  CHECK(category_value->IsString());\n \n-  Utf8Value category(env->isolate(), categoryValue);\n+  Utf8Value category(env->isolate(), category_value);\n+  Mutex::ScopedLock lock(category_groups_mutex);\n   // If the value already exists in the set, insertion.first will point\n   // to the existing value. Thus, this will maintain a long lived pointer\n   // to the category c-string.\n-  auto insertion = categoryGroups.insert(category.out());\n+  auto insertion = category_groups.insert(category.out());\n \n   // The returned insertion is a pair whose first item is the object that was\n   // inserted or that blocked the insertion and second item is a boolean\n@@ -133,7 +138,7 @@ static void Emit(const FunctionCallbackInfo<Value>& args) {\n   // enabled.\n   const char* category_group = GetCategoryGroup(env, args[1]);\n   const uint8_t* category_group_enabled =\n-    GetCategoryGroupEnabled(category_group);\n+      GetCategoryGroupEnabled(category_group);\n   if (*category_group_enabled == 0) return;\n \n   // get trace_event phase\n@@ -142,8 +147,8 @@ static void Emit(const FunctionCallbackInfo<Value>& args) {\n \n   // get trace_event name\n   CHECK(args[2]->IsString());\n-  Utf8Value nameValue(env->isolate(), args[2]);\n-  const char* name = nameValue.out();\n+  Utf8Value name_value(env->isolate(), args[2]);\n+  const char* name = name_value.out();\n \n   // get trace_event id\n   int64_t id = 0;\n@@ -212,7 +217,7 @@ static void CategoryGroupEnabled(const FunctionCallbackInfo<Value>& args) {\n \n   const char* category_group = GetCategoryGroup(env, args[0]);\n   const uint8_t* category_group_enabled =\n-    GetCategoryGroupEnabled(category_group);\n+      GetCategoryGroupEnabled(category_group);\n   args.GetReturnValue().Set(*category_group_enabled > 0);\n }\n "
        }
    ],
    "stats": {
        "total": 35,
        "additions": 20,
        "deletions": 15
    }
}