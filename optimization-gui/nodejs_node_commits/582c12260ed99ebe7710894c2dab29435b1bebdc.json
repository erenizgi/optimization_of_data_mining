{
    "author": "targos",
    "message": "deps: update acorn to 6.0.7\n\nacorn and acorn-walk are now published as two different packages. Put\nthem both in subdirectories of `deps/acorn`.\nAdapt the REPL's recoverable error detection to use the new API for\nextending acorn parsers.\n\nPR-URL: https://github.com/nodejs/node/pull/25844\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "582c12260ed99ebe7710894c2dab29435b1bebdc",
    "files": [
        {
            "sha": "b605ab4fbc9cd9fadca1dd172f52ed8451b84a95",
            "filename": "deps/acorn/AUTHORS",
            "status": "removed",
            "additions": 0,
            "deletions": 77,
            "changes": 77,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2FAUTHORS?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,77 +0,0 @@\n-List of Acorn contributors. Updated before every release.\n-\n-Adrian Heine\n-Adrian Rakovsky\n-Alistair Braidwood\n-Amila Welihinda\n-Andres Suarez\n-Angelo\n-Aparajita Fishman\n-Arian Stolwijk\n-Artem Govorov\n-Boopesh Mahendran\n-Bradley Heinz\n-Brandon Mills\n-Charles Hughes\n-Charmander\n-Chris McKnight\n-Conrad Irwin\n-Daniel Tschinder\n-David Bonnet\n-Domenico Matteo\n-ehmicky\n-Eugene Obrezkov\n-Felix Maier\n-Forbes Lindesay\n-Gilad Peleg\n-impinball\n-Ingvar Stepanyan\n-Jackson Ray Hamilton\n-Jesse McCarthy\n-Jiaxing Wang\n-Joel Kemp\n-Johannes Herr\n-John-David Dalton\n-Jordan Klassen\n-Jürg Lehni\n-Kai Cataldo\n-keeyipchan\n-Keheliya Gallaba\n-Kevin Irish\n-Kevin Kwok\n-krator\n-laosb\n-Marek\n-Marijn Haverbeke\n-Martin Carlberg\n-Mat Garcia\n-Mathias Bynens\n-Mathieu 'p01' Henri\n-Matthew Bastien\n-Max Schaefer\n-Max Zerzouri\n-Mihai Bazon\n-Mike Rennie\n-naoh\n-Nicholas C. Zakas\n-Nick Fitzgerald\n-Olivier Thomann\n-Oskar Schöldström\n-Paul Harper\n-Peter Rust\n-PlNG\n-Prayag Verma\n-ReadmeCritic\n-r-e-d\n-Richard Gibson\n-Rich Harris\n-Sebastian McKenzie\n-Shahar Soel\n-Sheel Bedi\n-Simen Bekkhus\n-Teddy Katz\n-Timothy Gu\n-Toru Nagashima\n-Victor Homyakov\n-Wexpo Lyu\n-zsjforcn"
        },
        {
            "sha": "26dd86125847701ff640d66fdda2b605e9192467",
            "filename": "deps/acorn/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 467,
            "changes": 467,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2FREADME.md?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,467 +0,0 @@\n-# Acorn\n-\n-[![Build Status](https://travis-ci.org/acornjs/acorn.svg?branch=master)](https://travis-ci.org/acornjs/acorn)\n-[![NPM version](https://img.shields.io/npm/v/acorn.svg)](https://www.npmjs.com/package/acorn)\n-[![CDNJS](https://img.shields.io/cdnjs/v/acorn.svg)](https://cdnjs.com/libraries/acorn)  \n-[Author funding status: ![maintainer happiness](https://marijnhaverbeke.nl/fund/status_s.png?force)](https://marijnhaverbeke.nl/fund/)\n-\n-A tiny, fast JavaScript parser, written completely in JavaScript.\n-\n-## Community\n-\n-Acorn is open source software released under an\n-[MIT license](https://github.com/acornjs/acorn/blob/master/LICENSE).\n-\n-You are welcome to\n-[report bugs](https://github.com/acornjs/acorn/issues) or create pull\n-requests on [github](https://github.com/acornjs/acorn). For questions\n-and discussion, please use the\n-[Tern discussion forum](https://discuss.ternjs.net).\n-\n-## Installation\n-\n-The easiest way to install acorn is with [`npm`][npm].\n-\n-[npm]: https://www.npmjs.com/\n-\n-```sh\n-npm install acorn\n-```\n-\n-Alternately, you can download the source and build acorn yourself:\n-\n-```sh\n-git clone https://github.com/acornjs/acorn.git\n-cd acorn\n-npm install\n-npm run build\n-```\n-\n-## Components\n-\n-When run in a CommonJS (node.js) or AMD environment, exported values\n-appear in the interfaces exposed by the individual files, as usual.\n-When loaded in the browser (Acorn works in any JS-enabled browser more\n-recent than IE5) without any kind of module management, a single\n-global object `acorn` will be defined, and all the exported properties\n-will be added to that.\n-\n-### Main parser\n-\n-This is implemented in `dist/acorn.js`, and is what you get when you\n-`require(\"acorn\")` in node.js.\n-\n-**parse**`(input, options)` is used to parse a JavaScript program.\n-The `input` parameter is a string, `options` can be undefined or an\n-object setting some of the options listed below. The return value will\n-be an abstract syntax tree object as specified by the\n-[ESTree spec][estree].\n-\n-When  encountering   a  syntax   error,  the   parser  will   raise  a\n-`SyntaxError` object with a meaningful  message. The error object will\n-have a `pos` property that indicates the character offset at which the\n-error occurred,  and a `loc`  object that contains a  `{line, column}`\n-object referring to that same position.\n-\n-[estree]: https://github.com/estree/estree\n-\n-- **ecmaVersion**: Indicates the ECMAScript version to parse. Must be\n-  either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018) or 10 (2019, partial\n-  support). This influences support for strict mode, the set of\n-  reserved words, and support for new syntax features. Default is 7.\n-\n-  **NOTE**: Only 'stage 4' (finalized) ECMAScript features are being\n-  implemented by Acorn.\n-\n-- **sourceType**: Indicate the mode the code should be parsed in. Can be\n-  either `\"script\"` or `\"module\"`. This influences global strict mode\n-  and parsing of `import` and `export` declarations.\n-\n-- **onInsertedSemicolon**: If given a callback, that callback will be\n-  called whenever a missing semicolon is inserted by the parser. The\n-  callback will be given the character offset of the point where the\n-  semicolon is inserted as argument, and if `locations` is on, also a\n-  `{line, column}` object representing this position.\n-\n-- **onTrailingComma**: Like `onInsertedSemicolon`, but for trailing\n-  commas.\n-\n-- **allowReserved**: If `false`, using a reserved word will generate\n-  an error. Defaults to `true` for `ecmaVersion` 3, `false` for higher\n-  versions. When given the value `\"never\"`, reserved words and\n-  keywords can also not be used as property names (as in Internet\n-  Explorer's old parser).\n-\n-- **allowReturnOutsideFunction**: By default, a return statement at\n-  the top level raises an error. Set this to `true` to accept such\n-  code.\n-\n-- **allowImportExportEverywhere**: By default, `import` and `export`\n-  declarations can only appear at a program's top level. Setting this\n-  option to `true` allows them anywhere where a statement is allowed.\n-\n-- **allowAwaitOutsideFunction**: By default, `await` expressions can only appear inside `async` functions. Setting this option to `true` allows to have top-level `await` expressions. They are still not allowed in non-`async` functions, though.\n-\n-- **allowHashBang**: When this is enabled (off by default), if the\n-  code starts with the characters `#!` (as in a shellscript), the\n-  first line will be treated as a comment.\n-\n-- **locations**: When `true`, each node has a `loc` object attached\n-  with `start` and `end` subobjects, each of which contains the\n-  one-based line and zero-based column numbers in `{line, column}`\n-  form. Default is `false`.\n-\n-- **onToken**: If a function is passed for this option, each found\n-  token will be passed in same format as tokens returned from\n-  `tokenizer().getToken()`.\n-\n-  If array is passed, each found token is pushed to it.\n-\n-  Note that you are not allowed to call the parser from the\n-  callback—that will corrupt its internal state.\n-\n-- **onComment**: If a function is passed for this option, whenever a\n-  comment is encountered the function will be called with the\n-  following parameters:\n-\n-  - `block`: `true` if the comment is a block comment, false if it\n-    is a line comment.\n-  - `text`: The content of the comment.\n-  - `start`: Character offset of the start of the comment.\n-  - `end`: Character offset of the end of the comment.\n-\n-  When the `locations` options is on, the `{line, column}` locations\n-  of the comment’s start and end are passed as two additional\n-  parameters.\n-\n-  If array is passed for this option, each found comment is pushed\n-  to it as object in Esprima format:\n-\n-  ```javascript\n-  {\n-    \"type\": \"Line\" | \"Block\",\n-    \"value\": \"comment text\",\n-    \"start\": Number,\n-    \"end\": Number,\n-    // If `locations` option is on:\n-    \"loc\": {\n-      \"start\": {line: Number, column: Number}\n-      \"end\": {line: Number, column: Number}\n-    },\n-    // If `ranges` option is on:\n-    \"range\": [Number, Number]\n-  }\n-  ```\n-\n-  Note that you are not allowed to call the parser from the\n-  callback—that will corrupt its internal state.\n-\n-- **ranges**: Nodes have their start and end characters offsets\n-  recorded in `start` and `end` properties (directly on the node,\n-  rather than the `loc` object, which holds line/column data. To also\n-  add a [semi-standardized][range] `range` property holding a\n-  `[start, end]` array with the same numbers, set the `ranges` option\n-  to `true`.\n-\n-- **program**: It is possible to parse multiple files into a single\n-  AST by passing the tree produced by parsing the first file as the\n-  `program` option in subsequent parses. This will add the toplevel\n-  forms of the parsed file to the \"Program\" (top) node of an existing\n-  parse tree.\n-\n-- **sourceFile**: When the `locations` option is `true`, you can pass\n-  this option to add a `source` attribute in every node’s `loc`\n-  object. Note that the contents of this option are not examined or\n-  processed in any way; you are free to use whatever format you\n-  choose.\n-\n-- **directSourceFile**: Like `sourceFile`, but a `sourceFile` property\n-  will be added (regardless of the `location` option) directly to the\n-  nodes, rather than the `loc` object.\n-\n-- **preserveParens**: If this option is `true`, parenthesized expressions\n-  are represented by (non-standard) `ParenthesizedExpression` nodes\n-  that have a single `expression` property containing the expression\n-  inside parentheses.\n-\n-[range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n-\n-**parseExpressionAt**`(input, offset, options)` will parse a single\n-expression in a string, and return its AST. It will not complain if\n-there is more of the string left after the expression.\n-\n-**getLineInfo**`(input, offset)` can be used to get a `{line,\n-column}` object for a given program string and character offset.\n-\n-**tokenizer**`(input, options)` returns an object with a `getToken`\n-method that can be called repeatedly to get the next token, a `{start,\n-end, type, value}` object (with added `loc` property when the\n-`locations` option is enabled and `range` property when the `ranges`\n-option is enabled). When the token's type is `tokTypes.eof`, you\n-should stop calling the method, since it will keep returning that same\n-token forever.\n-\n-In ES6 environment, returned result can be used as any other\n-protocol-compliant iterable:\n-\n-```javascript\n-for (let token of acorn.tokenizer(str)) {\n-  // iterate over the tokens\n-}\n-\n-// transform code to array of tokens:\n-var tokens = [...acorn.tokenizer(str)];\n-```\n-\n-**tokTypes** holds an object mapping names to the token type objects\n-that end up in the `type` properties of tokens.\n-\n-#### Note on using with [Escodegen][escodegen]\n-\n-Escodegen supports generating comments from AST, attached in\n-Esprima-specific format. In order to simulate same format in\n-Acorn, consider following example:\n-\n-```javascript\n-var comments = [], tokens = [];\n-\n-var ast = acorn.parse('var x = 42; // answer', {\n-\t// collect ranges for each node\n-\tranges: true,\n-\t// collect comments in Esprima's format\n-\tonComment: comments,\n-\t// collect token ranges\n-\tonToken: tokens\n-});\n-\n-// attach comments using collected information\n-escodegen.attachComments(ast, comments, tokens);\n-\n-// generate code\n-console.log(escodegen.generate(ast, {comment: true}));\n-// > 'var x = 42;    // answer'\n-```\n-\n-[escodegen]: https://github.com/estools/escodegen\n-\n-### dist/acorn_loose.js ###\n-\n-This file implements an error-tolerant parser. It exposes a single\n-function. The loose parser is accessible in node.js via `require(\"acorn/dist/acorn_loose\")`.\n-\n-**parse_dammit**`(input, options)` takes the same arguments and\n-returns the same syntax tree as the `parse` function in `acorn.js`,\n-but never raises an error, and will do its best to parse syntactically\n-invalid code in as meaningful a way as it can. It'll insert identifier\n-nodes with name `\"✖\"` as placeholders in places where it can't make\n-sense of the input. Depends on `acorn.js`, because it uses the same\n-tokenizer.\n-\n-### dist/walk.js ###\n-\n-Implements an abstract syntax tree walker. Will store its interface in\n-`acorn.walk` when loaded without a module system.\n-\n-**simple**`(node, visitors, base, state)` does a 'simple' walk over\n-a tree. `node` should be the AST node to walk, and `visitors` an\n-object with properties whose names correspond to node types in the\n-[ESTree spec][estree]. The properties should contain functions\n-that will be called with the node object and, if applicable the state\n-at that point. The last two arguments are optional. `base` is a walker\n-algorithm, and `state` is a start state. The default walker will\n-simply visit all statements and expressions and not produce a\n-meaningful state. (An example of a use of state is to track scope at\n-each point in the tree.)\n-\n-```js\n-const acorn = require(\"acorn\")\n-const walk = require(\"acorn/dist/walk\")\n-\n-walk.simple(acorn.parse(\"let x = 10\"), {\n-  Literal(node) {\n-    console.log(`Found a literal: ${node.value}`)\n-  }\n-})\n-```\n-\n-**ancestor**`(node, visitors, base, state)` does a 'simple' walk over\n-a tree, building up an array of ancestor nodes (including the current node)\n-and passing the array to the callbacks as a third parameter.\n-\n-```js\n-const acorn = require(\"acorn\")\n-const walk = require(\"acorn/dist/walk\")\n-\n-walk.ancestor(acorn.parse(\"foo('hi')\"), {\n-  Literal(_, ancestors) {\n-    console.log(\"This literal's ancestors are:\",\n-                ancestors.map(n => n.type))\n-  }\n-})\n-```\n-\n-**recursive**`(node, state, functions, base)` does a 'recursive'\n-walk, where the walker functions are responsible for continuing the\n-walk on the child nodes of their target node. `state` is the start\n-state, and `functions` should contain an object that maps node types\n-to walker functions. Such functions are called with `(node, state, c)`\n-arguments, and can cause the walk to continue on a sub-node by calling\n-the `c` argument on it with `(node, state)` arguments. The optional\n-`base` argument provides the fallback walker functions for node types\n-that aren't handled in the `functions` object. If not given, the\n-default walkers will be used.\n-\n-**make**`(functions, base)` builds a new walker object by using the\n-walker functions in `functions` and filling in the missing ones by\n-taking defaults from `base`.\n-\n-**full**`(node, callback, base, state)` does a 'full'\n-walk over a tree, calling the callback with the arguments (node, state, type)\n-for each node\n-\n-**fullAncestor**`(node, callback, base, state)` does a 'full' walk over\n-a tree, building up an array of ancestor nodes (including the current node)\n-and passing the array to the callbacks as a third parameter.\n-\n-```js\n-const acorn = require(\"acorn\")\n-const walk = require(\"acorn/dist/walk\")\n-\n-walk.full(acorn.parse(\"1 + 1\"), node => {\n-  console.log(`There's a ${node.type} node at ${node.ch}`)\n-})\n-```\n-\n-**findNodeAt**`(node, start, end, test, base, state)` tries to\n-locate a node in a tree at the given start and/or end offsets, which\n-satisfies the predicate `test`. `start` and `end` can be either `null`\n-(as wildcard) or a number. `test` may be a string (indicating a node\n-type) or a function that takes `(nodeType, node)` arguments and\n-returns a boolean indicating whether this node is interesting. `base`\n-and `state` are optional, and can be used to specify a custom walker.\n-Nodes are tested from inner to outer, so if two nodes match the\n-boundaries, the inner one will be preferred.\n-\n-**findNodeAround**`(node, pos, test, base, state)` is a lot like\n-`findNodeAt`, but will match any node that exists 'around' (spanning)\n-the given position.\n-\n-**findNodeAfter**`(node, pos, test, base, state)` is similar to\n-`findNodeAround`, but will match all nodes *after* the given position\n-(testing outer nodes before inner nodes).\n-\n-## Command line interface\n-\n-The `bin/acorn` utility can be used to parse a file from the command\n-line. It accepts as arguments its input file and the following\n-options:\n-\n-- `--ecma3|--ecma5|--ecma6|--ecma7|--ecma8|--ecma9|--ecma10`: Sets the ECMAScript version\n-  to parse. Default is version 7.\n-\n-- `--module`: Sets the parsing mode to `\"module\"`. Is set to `\"script\"` otherwise.\n-\n-- `--locations`: Attaches a \"loc\" object to each node with \"start\" and\n-  \"end\" subobjects, each of which contains the one-based line and\n-  zero-based column numbers in `{line, column}` form.\n-\n-- `--allow-hash-bang`: If the code starts with the characters #! (as in a shellscript), the first line will be treated as a comment.\n-\n-- `--compact`: No whitespace is used in the AST output.\n-\n-- `--silent`: Do not output the AST, just return the exit status.\n-\n-- `--help`: Print the usage information and quit.\n-\n-The utility spits out the syntax tree as JSON data.\n-\n-## Build system\n-\n-Acorn is written in ECMAScript 6, as a set of small modules, in the\n-project's `src` directory, and compiled down to bigger ECMAScript 3\n-files in `dist` using [Browserify](http://browserify.org) and\n-[Babel](http://babeljs.io/). If you are already using Babel, you can\n-consider including the modules directly.\n-\n-The command-line test runner (`npm test`) uses the ES6 modules. The\n-browser-based test page (`test/index.html`) uses the compiled modules.\n-The `bin/build-acorn.js` script builds the latter from the former.\n-\n-If you are working on Acorn, you'll probably want to try the code out\n-directly, without an intermediate build step. In your scripts, you can\n-register the Babel require shim like this:\n-\n-    require(\"babel-core/register\")\n-\n-That will allow you to directly `require` the ES6 modules.\n-\n-## Plugins\n-\n-Acorn is designed support allow plugins which, within reasonable\n-bounds, redefine the way the parser works. Plugins can add new token\n-types and new tokenizer contexts (if necessary), and extend methods in\n-the parser object. This is not a clean, elegant API—using it requires\n-an understanding of Acorn's internals, and plugins are likely to break\n-whenever those internals are significantly changed. But still, it is\n-_possible_, in this way, to create parsers for JavaScript dialects\n-without forking all of Acorn. And in principle it is even possible to\n-combine such plugins, so that if you have, for example, a plugin for\n-parsing types and a plugin for parsing JSX-style XML literals, you\n-could load them both and parse code with both JSX tags and types.\n-\n-A plugin should register itself by adding a property to\n-`acorn.plugins`, which holds a function. Calling `acorn.parse`, a\n-`plugins` option can be passed, holding an object mapping plugin names\n-to configuration values (or just `true` for plugins that don't take\n-options). After the parser object has been created, the initialization\n-functions for the chosen plugins are called with `(parser,\n-configValue)` arguments. They are expected to use the `parser.extend`\n-method to extend parser methods. For example, the `readToken` method\n-could be extended like this:\n-\n-```javascript\n-parser.extend(\"readToken\", function(nextMethod) {\n-  return function(code) {\n-    console.log(\"Reading a token!\")\n-    return nextMethod.call(this, code)\n-  }\n-})\n-```\n-\n-The `nextMethod` argument passed to `extend`'s second argument is the\n-previous value of this method, and should usually be called through to\n-whenever the extended method does not handle the call itself.\n-\n-Similarly, the loose parser allows plugins to register themselves via\n-`acorn.pluginsLoose`.  The extension mechanism is the same as for the\n-normal parser:\n-\n-```javascript\n-looseParser.extend(\"readToken\", function(nextMethod) {\n-  return function() {\n-    console.log(\"Reading a token in the loose parser!\")\n-    return nextMethod.call(this)\n-  }\n-})\n-```\n-\n-### Existing plugins\n-\n- - [`acorn-jsx`](https://github.com/RReverser/acorn-jsx): Parse [Facebook JSX syntax extensions](https://github.com/facebook/jsx)\n- - [`acorn-objj`](https://github.com/cappuccino/acorn-objj): [Objective-J](http://www.cappuccino-project.org/learn/objective-j.html) language parser built as Acorn plugin\n- \n- Plugins for ECMAScript proposals:\n-\n- - [`acorn-stage3`](https://github.com/acornjs/acorn-stage3): Parse most stage 3 proposals, bundling:\n-   - [`acorn-async-iteration`](https://github.com/acornjs/acorn-async-iteration): Parse [async iteration proposal](https://github.com/tc39/proposal-async-iteration)\n-   - [`acorn-bigint`](https://github.com/acornjs/acorn-bigint): Parse [BigInt proposal](https://github.com/tc39/proposal-bigint)\n-   - [`acorn-class-fields`](https://github.com/acornjs/acorn-class-fields): Parse [class fields proposal](https://github.com/tc39/proposal-class-fields)\n-   - [`acorn-dynamic-import`](https://github.com/kesne/acorn-dynamic-import): Parse [import() proposal](https://github.com/tc39/proposal-dynamic-import)\n-   - [`acorn-import-meta`](https://github.com/acornjs/acorn-import-meta): Parse [import.meta proposal](https://github.com/tc39/proposal-import-meta)\n-   - [`acorn-numeric-separator`](https://github.com/acornjs/acorn-numeric-separator): Parse [numeric separator proposal](https://github.com/tc39/proposal-numeric-separator)\n-   - [`acorn-optional-catch-binding`](https://github.com/acornjs/acorn-optional-catch-binding): Parse [optional catch binding proposal](https://github.com/tc39/proposal-optional-catch-binding)\n-   - [`acorn-private-methods`](https://github.com/acornjs/acorn-private-methods): parse [private methods, getters and setters proposal](https://github.com/tc39/proposal-private-methods)\n-   - [`acorn5-object-spread`](https://github.com/adrianheine/acorn5-object-spread): Parse [Object Rest/Spread Properties proposal](https://github.com/tc39/proposal-object-rest-spread)\n- - [`acorn-object-rest-spread`](https://github.com/victor-homyakov/acorn-object-rest-spread): Parse [Object Rest/Spread Properties proposal](https://github.com/tc39/proposal-object-rest-spread)\n- - [`acorn-es7`](https://github.com/angelozerr/acorn-es7): Parse [decorator syntax proposal](https://github.com/wycats/javascript-decorators)\n- - [`acorn-static-class-property-initializer`](https://github.com/victor-homyakov/acorn-static-class-property-initializer): Partial support for static class properties from [ES Class Fields & Static Properties Proposal](https://github.com/tc39/proposal-class-public-fields) to support static property initializers in [React components written as ES6+ classes](https://babeljs.io/blog/2015/06/07/react-on-es6-plus)"
        },
        {
            "sha": "525950b5183bcf1a084150f137bddb9f4539c947",
            "filename": "deps/acorn/acorn-walk/CHANGELOG.md",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2FCHANGELOG.md",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2FCHANGELOG.md?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,97 @@\n+## 6.1.0 (2018-09-28)\n+\n+### New features\n+\n+The walker now walks `TemplateElement` nodes.\n+\n+## 6.0.1 (2018-09-14)\n+\n+### Bug fixes\n+\n+Fix bad \"main\" field in package.json.\n+\n+## 6.0.0 (2018-09-14)\n+\n+### Breaking changes\n+\n+This is now a separate package, `acorn-walk`, rather than part of the main `acorn` package.\n+\n+The `ScopeBody` and `ScopeExpression` meta-node-types are no longer supported.\n+\n+## 5.7.1 (2018-06-15)\n+\n+### Bug fixes\n+\n+Make sure the walker and bin files are rebuilt on release (the previous release didn't get the up-to-date versions).\n+\n+## 5.7.0 (2018-06-15)\n+\n+### Bug fixes\n+\n+Fix crash in walker when walking a binding-less catch node.\n+\n+## 5.6.2 (2018-06-05)\n+\n+### Bug fixes\n+\n+In the walker, go back to allowing the `baseVisitor` argument to be null to default to the default base everywhere.\n+\n+## 5.6.1 (2018-06-01)\n+\n+### Bug fixes\n+\n+Fix regression when passing `null` as fourth argument to `walk.recursive`.\n+\n+## 5.6.0 (2018-05-31)\n+\n+### Bug fixes\n+\n+Fix a bug in the walker that caused a crash when walking an object pattern spread.\n+\n+## 5.5.1 (2018-03-06)\n+\n+### Bug fixes\n+\n+Fix regression in walker causing property values in object patterns to be walked as expressions.\n+\n+## 5.5.0 (2018-02-27)\n+\n+### Bug fixes\n+\n+Support object spread in the AST walker.\n+\n+## 5.4.1 (2018-02-02)\n+\n+### Bug fixes\n+\n+5.4.0 somehow accidentally included an old version of walk.js.\n+\n+## 5.2.0 (2017-10-30)\n+\n+### Bug fixes\n+\n+The `full` and `fullAncestor` walkers no longer visit nodes multiple times.\n+\n+## 5.1.0 (2017-07-05)\n+\n+### New features\n+\n+New walker functions `full` and `fullAncestor`.\n+\n+## 3.2.0 (2016-06-07)\n+\n+### New features\n+\n+Make it possible to use `visit.ancestor` with a walk state.\n+\n+## 3.1.0 (2016-04-18)\n+\n+### New features\n+\n+The walker now allows defining handlers for `CatchClause` nodes.\n+\n+## 2.5.2 (2015-10-27)\n+\n+### Fixes\n+\n+Fix bug where the walker walked an exported `let` statement as an expression."
        },
        {
            "sha": "2c0632b6a7c63bd701c60f1daa8b8fa9bea56a81",
            "filename": "deps/acorn/acorn-walk/LICENSE",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2FLICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2FLICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2FLICENSE?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "previous_filename": "deps/acorn/LICENSE"
        },
        {
            "sha": "2b94bec31eccfb90fd7c05ee027fd6823f4b842d",
            "filename": "deps/acorn/acorn-walk/README.md",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2FREADME.md?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,126 @@\n+# Acorn AST walker\n+\n+An abstract syntax tree walker for the\n+[ESTree](https://github.com/estree/estree) format.\n+\n+## Community\n+\n+Acorn is open source software released under an\n+[MIT license](https://github.com/acornjs/acorn/blob/master/LICENSE).\n+\n+You are welcome to\n+[report bugs](https://github.com/acornjs/acorn/issues) or create pull\n+requests on [github](https://github.com/acornjs/acorn). For questions\n+and discussion, please use the\n+[Tern discussion forum](https://discuss.ternjs.net).\n+\n+## Installation\n+\n+The easiest way to install acorn is from [`npm`](https://www.npmjs.com/):\n+\n+```sh\n+npm install acorn-walk\n+```\n+\n+Alternately, you can download the source and build acorn yourself:\n+\n+```sh\n+git clone https://github.com/acornjs/acorn.git\n+cd acorn\n+npm install\n+```\n+\n+## Interface\n+\n+An algorithm for recursing through a syntax tree is stored as an\n+object, with a property for each tree node type holding a function\n+that will recurse through such a node. There are several ways to run\n+such a walker.\n+\n+**simple**`(node, visitors, base, state)` does a 'simple' walk over a\n+tree. `node` should be the AST node to walk, and `visitors` an object\n+with properties whose names correspond to node types in the [ESTree\n+spec](https://github.com/estree/estree). The properties should contain\n+functions that will be called with the node object and, if applicable\n+the state at that point. The last two arguments are optional. `base`\n+is a walker algorithm, and `state` is a start state. The default\n+walker will simply visit all statements and expressions and not\n+produce a meaningful state. (An example of a use of state is to track\n+scope at each point in the tree.)\n+\n+```js\n+const acorn = require(\"acorn\")\n+const walk = require(\"acorn-walk\")\n+\n+walk.simple(acorn.parse(\"let x = 10\"), {\n+  Literal(node) {\n+    console.log(`Found a literal: ${node.value}`)\n+  }\n+})\n+```\n+\n+**ancestor**`(node, visitors, base, state)` does a 'simple' walk over\n+a tree, building up an array of ancestor nodes (including the current node)\n+and passing the array to the callbacks as a third parameter.\n+\n+```js\n+const acorn = require(\"acorn\")\n+const walk = require(\"acorn-walk\")\n+\n+walk.ancestor(acorn.parse(\"foo('hi')\"), {\n+  Literal(_, ancestors) {\n+    console.log(\"This literal's ancestors are:\", ancestors.map(n => n.type))\n+  }\n+})\n+```\n+\n+**recursive**`(node, state, functions, base)` does a 'recursive'\n+walk, where the walker functions are responsible for continuing the\n+walk on the child nodes of their target node. `state` is the start\n+state, and `functions` should contain an object that maps node types\n+to walker functions. Such functions are called with `(node, state, c)`\n+arguments, and can cause the walk to continue on a sub-node by calling\n+the `c` argument on it with `(node, state)` arguments. The optional\n+`base` argument provides the fallback walker functions for node types\n+that aren't handled in the `functions` object. If not given, the\n+default walkers will be used.\n+\n+**make**`(functions, base)` builds a new walker object by using the\n+walker functions in `functions` and filling in the missing ones by\n+taking defaults from `base`.\n+\n+**full**`(node, callback, base, state)` does a 'full' walk over a\n+tree, calling the callback with the arguments (node, state, type) for\n+each node\n+\n+**fullAncestor**`(node, callback, base, state)` does a 'full' walk\n+over a tree, building up an array of ancestor nodes (including the\n+current node) and passing the array to the callbacks as a third\n+parameter.\n+\n+```js\n+const acorn = require(\"acorn\")\n+const walk = require(\"acorn-walk\")\n+\n+walk.full(acorn.parse(\"1 + 1\"), node => {\n+  console.log(`There's a ${node.type} node at ${node.ch}`)\n+})\n+```\n+\n+**findNodeAt**`(node, start, end, test, base, state)` tries to locate\n+a node in a tree at the given start and/or end offsets, which\n+satisfies the predicate `test`. `start` and `end` can be either `null`\n+(as wildcard) or a number. `test` may be a string (indicating a node\n+type) or a function that takes `(nodeType, node)` arguments and\n+returns a boolean indicating whether this node is interesting. `base`\n+and `state` are optional, and can be used to specify a custom walker.\n+Nodes are tested from inner to outer, so if two nodes match the\n+boundaries, the inner one will be preferred.\n+\n+**findNodeAround**`(node, pos, test, base, state)` is a lot like\n+`findNodeAt`, but will match any node that exists 'around' (spanning)\n+the given position.\n+\n+**findNodeAfter**`(node, pos, test, base, state)` is similar to\n+`findNodeAround`, but will match all nodes *after* the given position\n+(testing outer nodes before inner nodes)."
        },
        {
            "sha": "322a58d9fabcb3aa0d421ba92b535845a3001474",
            "filename": "deps/acorn/acorn-walk/dist/walk.js",
            "status": "renamed",
            "additions": 22,
            "deletions": 9,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -15,8 +15,8 @@\n //     });\n //\n // to do something with all expressions. All Parser API node types\n-// can be used to identify node types, as well as Expression,\n-// Statement, and ScopeBody, which denote categories of nodes.\n+// can be used to identify node types, as well as Expression and\n+// Statement, which denote categories of nodes.\n //\n // The base argument can be used to pass a custom (recursive)\n // walker, and state can be used to give this walked an initial\n@@ -245,7 +245,7 @@ base.TryStatement = function (node, st, c) {\n };\n base.CatchClause = function (node, st, c) {\n   if (node.param) { c(node.param, st, \"Pattern\"); }\n-  c(node.body, st, \"ScopeBody\");\n+  c(node.body, st, \"Statement\");\n };\n base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n   c(node.test, st, \"Expression\");\n@@ -290,12 +290,8 @@ base.Function = function (node, st, c) {\n \n     c(param, st, \"Pattern\");\n   }\n-  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n+  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n };\n-// FIXME drop these node types in next major version\n-// (They are awkward, and in ES6 every block can be a scope.)\n-base.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); };\n-base.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); };\n \n base.Pattern = function (node, st, c) {\n   if (node.type === \"Identifier\")\n@@ -346,14 +342,30 @@ base.ObjectExpression = function (node, st, c) {\n   }\n };\n base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n-base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n+base.SequenceExpression = function (node, st, c) {\n   for (var i = 0, list = node.expressions; i < list.length; i += 1)\n     {\n     var expr = list[i];\n \n     c(expr, st, \"Expression\");\n   }\n };\n+base.TemplateLiteral = function (node, st, c) {\n+  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n+    {\n+    var quasi = list[i];\n+\n+    c(quasi, st);\n+  }\n+\n+  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n+    {\n+    var expr = list$1[i$1];\n+\n+    c(expr, st, \"Expression\");\n+  }\n+};\n+base.TemplateElement = ignore;\n base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n   c(node.argument, st, \"Expression\");\n };\n@@ -441,3 +453,4 @@ exports.base = base;\n Object.defineProperty(exports, '__esModule', { value: true });\n \n })));\n+//# sourceMappingURL=walk.js.map",
            "previous_filename": "deps/acorn/dist/walk.js"
        },
        {
            "sha": "5590a2924f2de66a03537a953db88876fe15fde9",
            "filename": "deps/acorn/acorn-walk/dist/walk.js.map",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.js.map",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.js.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.js.map?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"walk.js\",\"sources\":[\"../src/index.js\"],\"sourcesContent\":[\"// AST walker module for Mozilla Parser API compatible trees\\n\\n// A simple walk is one where you simply specify callbacks to be\\n// called on specific nodes. The last two arguments are optional. A\\n// simple use would be\\n//\\n//     walk.simple(myTree, {\\n//         Expression: function(node) { ... }\\n//     });\\n//\\n// to do something with all expressions. All Parser API node types\\n// can be used to identify node types, as well as Expression and\\n// Statement, which denote categories of nodes.\\n//\\n// The base argument can be used to pass a custom (recursive)\\n// walker, and state can be used to give this walked an initial\\n// state.\\n\\nexport function simple(node, visitors, baseVisitor, state, override) {\\n  if (!baseVisitor) baseVisitor = base\\n  ;(function c(node, st, override) {\\n    let type = override || node.type, found = visitors[type]\\n    baseVisitor[type](node, st, c)\\n    if (found) found(node, st)\\n  })(node, state, override)\\n}\\n\\n// An ancestor walk keeps an array of ancestor nodes (including the\\n// current node) and passes them to the callback as third parameter\\n// (and also as state parameter when no other state is present).\\nexport function ancestor(node, visitors, baseVisitor, state) {\\n  let ancestors = []\\n  if (!baseVisitor) baseVisitor = base\\n  ;(function c(node, st, override) {\\n    let type = override || node.type, found = visitors[type]\\n    let isNew = node !== ancestors[ancestors.length - 1]\\n    if (isNew) ancestors.push(node)\\n    baseVisitor[type](node, st, c)\\n    if (found) found(node, st || ancestors, ancestors)\\n    if (isNew) ancestors.pop()\\n  })(node, state)\\n}\\n\\n// A recursive walk is one where your functions override the default\\n// walkers. They can modify and replace the state parameter that's\\n// threaded through the walk, and can opt how and whether to walk\\n// their child nodes (by calling their third argument on these\\n// nodes).\\nexport function recursive(node, state, funcs, baseVisitor, override) {\\n  let visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\\n  ;(function c(node, st, override) {\\n    visitor[override || node.type](node, st, c)\\n  })(node, state, override)\\n}\\n\\nfunction makeTest(test) {\\n  if (typeof test === \\\"string\\\")\\n    return type => type === test\\n  else if (!test)\\n    return () => true\\n  else\\n    return test\\n}\\n\\nclass Found {\\n  constructor(node, state) { this.node = node; this.state = state }\\n}\\n\\n// A full walk triggers the callback on each node\\nexport function full(node, callback, baseVisitor, state, override) {\\n  if (!baseVisitor) baseVisitor = base\\n  ;(function c(node, st, override) {\\n    let type = override || node.type\\n    baseVisitor[type](node, st, c)\\n    if (!override) callback(node, st, type)\\n  })(node, state, override)\\n}\\n\\n// An fullAncestor walk is like an ancestor walk, but triggers\\n// the callback on each node\\nexport function fullAncestor(node, callback, baseVisitor, state) {\\n  if (!baseVisitor) baseVisitor = base\\n  let ancestors = []\\n  ;(function c(node, st, override) {\\n    let type = override || node.type\\n    let isNew = node !== ancestors[ancestors.length - 1]\\n    if (isNew) ancestors.push(node)\\n    baseVisitor[type](node, st, c)\\n    if (!override) callback(node, st || ancestors, ancestors, type)\\n    if (isNew) ancestors.pop()\\n  })(node, state)\\n}\\n\\n// Find a node with a given start, end, and type (all are optional,\\n// null can be used as wildcard). Returns a {node, state} object, or\\n// undefined when it doesn't find a matching node.\\nexport function findNodeAt(node, start, end, test, baseVisitor, state) {\\n  if (!baseVisitor) baseVisitor = base\\n  test = makeTest(test)\\n  try {\\n    (function c(node, st, override) {\\n      let type = override || node.type\\n      if ((start == null || node.start <= start) &&\\n          (end == null || node.end >= end))\\n        baseVisitor[type](node, st, c)\\n      if ((start == null || node.start === start) &&\\n          (end == null || node.end === end) &&\\n          test(type, node))\\n        throw new Found(node, st)\\n    })(node, state)\\n  } catch (e) {\\n    if (e instanceof Found) return e\\n    throw e\\n  }\\n}\\n\\n// Find the innermost node of a given type that contains the given\\n// position. Interface similar to findNodeAt.\\nexport function findNodeAround(node, pos, test, baseVisitor, state) {\\n  test = makeTest(test)\\n  if (!baseVisitor) baseVisitor = base\\n  try {\\n    (function c(node, st, override) {\\n      let type = override || node.type\\n      if (node.start > pos || node.end < pos) return\\n      baseVisitor[type](node, st, c)\\n      if (test(type, node)) throw new Found(node, st)\\n    })(node, state)\\n  } catch (e) {\\n    if (e instanceof Found) return e\\n    throw e\\n  }\\n}\\n\\n// Find the outermost matching node after a given position.\\nexport function findNodeAfter(node, pos, test, baseVisitor, state) {\\n  test = makeTest(test)\\n  if (!baseVisitor) baseVisitor = base\\n  try {\\n    (function c(node, st, override) {\\n      if (node.end < pos) return\\n      let type = override || node.type\\n      if (node.start >= pos && test(type, node)) throw new Found(node, st)\\n      baseVisitor[type](node, st, c)\\n    })(node, state)\\n  } catch (e) {\\n    if (e instanceof Found) return e\\n    throw e\\n  }\\n}\\n\\n// Find the outermost matching node before a given position.\\nexport function findNodeBefore(node, pos, test, baseVisitor, state) {\\n  test = makeTest(test)\\n  if (!baseVisitor) baseVisitor = base\\n  let max\\n  ;(function c(node, st, override) {\\n    if (node.start > pos) return\\n    let type = override || node.type\\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\\n      max = new Found(node, st)\\n    baseVisitor[type](node, st, c)\\n  })(node, state)\\n  return max\\n}\\n\\n// Fallback to an Object.create polyfill for older environments.\\nconst create = Object.create || function(proto) {\\n  function Ctor() {}\\n  Ctor.prototype = proto\\n  return new Ctor\\n}\\n\\n// Used to create a custom walker. Will fill in all missing node\\n// type properties with the defaults.\\nexport function make(funcs, baseVisitor) {\\n  let visitor = create(baseVisitor || base)\\n  for (let type in funcs) visitor[type] = funcs[type]\\n  return visitor\\n}\\n\\nfunction skipThrough(node, st, c) { c(node, st) }\\nfunction ignore(_node, _st, _c) {}\\n\\n// Node walkers.\\n\\nexport const base = {}\\n\\nbase.Program = base.BlockStatement = (node, st, c) => {\\n  for (let stmt of node.body)\\n    c(stmt, st, \\\"Statement\\\")\\n}\\nbase.Statement = skipThrough\\nbase.EmptyStatement = ignore\\nbase.ExpressionStatement = base.ParenthesizedExpression =\\n  (node, st, c) => c(node.expression, st, \\\"Expression\\\")\\nbase.IfStatement = (node, st, c) => {\\n  c(node.test, st, \\\"Expression\\\")\\n  c(node.consequent, st, \\\"Statement\\\")\\n  if (node.alternate) c(node.alternate, st, \\\"Statement\\\")\\n}\\nbase.LabeledStatement = (node, st, c) => c(node.body, st, \\\"Statement\\\")\\nbase.BreakStatement = base.ContinueStatement = ignore\\nbase.WithStatement = (node, st, c) => {\\n  c(node.object, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.SwitchStatement = (node, st, c) => {\\n  c(node.discriminant, st, \\\"Expression\\\")\\n  for (let cs of node.cases) {\\n    if (cs.test) c(cs.test, st, \\\"Expression\\\")\\n    for (let cons of cs.consequent)\\n      c(cons, st, \\\"Statement\\\")\\n  }\\n}\\nbase.SwitchCase = (node, st, c) => {\\n  if (node.test) c(node.test, st, \\\"Expression\\\")\\n  for (let cons of node.consequent)\\n    c(cons, st, \\\"Statement\\\")\\n}\\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = (node, st, c) => {\\n  if (node.argument) c(node.argument, st, \\\"Expression\\\")\\n}\\nbase.ThrowStatement = base.SpreadElement =\\n  (node, st, c) => c(node.argument, st, \\\"Expression\\\")\\nbase.TryStatement = (node, st, c) => {\\n  c(node.block, st, \\\"Statement\\\")\\n  if (node.handler) c(node.handler, st)\\n  if (node.finalizer) c(node.finalizer, st, \\\"Statement\\\")\\n}\\nbase.CatchClause = (node, st, c) => {\\n  if (node.param) c(node.param, st, \\\"Pattern\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.WhileStatement = base.DoWhileStatement = (node, st, c) => {\\n  c(node.test, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.ForStatement = (node, st, c) => {\\n  if (node.init) c(node.init, st, \\\"ForInit\\\")\\n  if (node.test) c(node.test, st, \\\"Expression\\\")\\n  if (node.update) c(node.update, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.ForInStatement = base.ForOfStatement = (node, st, c) => {\\n  c(node.left, st, \\\"ForInit\\\")\\n  c(node.right, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.ForInit = (node, st, c) => {\\n  if (node.type === \\\"VariableDeclaration\\\") c(node, st)\\n  else c(node, st, \\\"Expression\\\")\\n}\\nbase.DebuggerStatement = ignore\\n\\nbase.FunctionDeclaration = (node, st, c) => c(node, st, \\\"Function\\\")\\nbase.VariableDeclaration = (node, st, c) => {\\n  for (let decl of node.declarations)\\n    c(decl, st)\\n}\\nbase.VariableDeclarator = (node, st, c) => {\\n  c(node.id, st, \\\"Pattern\\\")\\n  if (node.init) c(node.init, st, \\\"Expression\\\")\\n}\\n\\nbase.Function = (node, st, c) => {\\n  if (node.id) c(node.id, st, \\\"Pattern\\\")\\n  for (let param of node.params)\\n    c(param, st, \\\"Pattern\\\")\\n  c(node.body, st, node.expression ? \\\"Expression\\\" : \\\"Statement\\\")\\n}\\n\\nbase.Pattern = (node, st, c) => {\\n  if (node.type === \\\"Identifier\\\")\\n    c(node, st, \\\"VariablePattern\\\")\\n  else if (node.type === \\\"MemberExpression\\\")\\n    c(node, st, \\\"MemberPattern\\\")\\n  else\\n    c(node, st)\\n}\\nbase.VariablePattern = ignore\\nbase.MemberPattern = skipThrough\\nbase.RestElement = (node, st, c) => c(node.argument, st, \\\"Pattern\\\")\\nbase.ArrayPattern = (node, st, c) => {\\n  for (let elt of node.elements) {\\n    if (elt) c(elt, st, \\\"Pattern\\\")\\n  }\\n}\\nbase.ObjectPattern = (node, st, c) => {\\n  for (let prop of node.properties) {\\n    if (prop.type === \\\"Property\\\") {\\n      if (prop.computed) c(prop.key, st, \\\"Expression\\\")\\n      c(prop.value, st, \\\"Pattern\\\")\\n    } else if (prop.type === \\\"RestElement\\\") {\\n      c(prop.argument, st, \\\"Pattern\\\")\\n    }\\n  }\\n}\\n\\nbase.Expression = skipThrough\\nbase.ThisExpression = base.Super = base.MetaProperty = ignore\\nbase.ArrayExpression = (node, st, c) => {\\n  for (let elt of node.elements) {\\n    if (elt) c(elt, st, \\\"Expression\\\")\\n  }\\n}\\nbase.ObjectExpression = (node, st, c) => {\\n  for (let prop of node.properties)\\n    c(prop, st)\\n}\\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\\nbase.SequenceExpression = (node, st, c) => {\\n  for (let expr of node.expressions)\\n    c(expr, st, \\\"Expression\\\")\\n}\\nbase.TemplateLiteral = (node, st, c) => {\\n  for (let quasi of node.quasis)\\n    c(quasi, st)\\n\\n  for (let expr of node.expressions)\\n    c(expr, st, \\\"Expression\\\")\\n}\\nbase.TemplateElement = ignore\\nbase.UnaryExpression = base.UpdateExpression = (node, st, c) => {\\n  c(node.argument, st, \\\"Expression\\\")\\n}\\nbase.BinaryExpression = base.LogicalExpression = (node, st, c) => {\\n  c(node.left, st, \\\"Expression\\\")\\n  c(node.right, st, \\\"Expression\\\")\\n}\\nbase.AssignmentExpression = base.AssignmentPattern = (node, st, c) => {\\n  c(node.left, st, \\\"Pattern\\\")\\n  c(node.right, st, \\\"Expression\\\")\\n}\\nbase.ConditionalExpression = (node, st, c) => {\\n  c(node.test, st, \\\"Expression\\\")\\n  c(node.consequent, st, \\\"Expression\\\")\\n  c(node.alternate, st, \\\"Expression\\\")\\n}\\nbase.NewExpression = base.CallExpression = (node, st, c) => {\\n  c(node.callee, st, \\\"Expression\\\")\\n  if (node.arguments)\\n    for (let arg of node.arguments)\\n      c(arg, st, \\\"Expression\\\")\\n}\\nbase.MemberExpression = (node, st, c) => {\\n  c(node.object, st, \\\"Expression\\\")\\n  if (node.computed) c(node.property, st, \\\"Expression\\\")\\n}\\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = (node, st, c) => {\\n  if (node.declaration)\\n    c(node.declaration, st, node.type === \\\"ExportNamedDeclaration\\\" || node.declaration.id ? \\\"Statement\\\" : \\\"Expression\\\")\\n  if (node.source) c(node.source, st, \\\"Expression\\\")\\n}\\nbase.ExportAllDeclaration = (node, st, c) => {\\n  c(node.source, st, \\\"Expression\\\")\\n}\\nbase.ImportDeclaration = (node, st, c) => {\\n  for (let spec of node.specifiers)\\n    c(spec, st)\\n  c(node.source, st, \\\"Expression\\\")\\n}\\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\\n\\nbase.TaggedTemplateExpression = (node, st, c) => {\\n  c(node.tag, st, \\\"Expression\\\")\\n  c(node.quasi, st, \\\"Expression\\\")\\n}\\nbase.ClassDeclaration = base.ClassExpression = (node, st, c) => c(node, st, \\\"Class\\\")\\nbase.Class = (node, st, c) => {\\n  if (node.id) c(node.id, st, \\\"Pattern\\\")\\n  if (node.superClass) c(node.superClass, st, \\\"Expression\\\")\\n  c(node.body, st)\\n}\\nbase.ClassBody = (node, st, c) => {\\n  for (let elt of node.body)\\n    c(elt, st)\\n}\\nbase.MethodDefinition = base.Property = (node, st, c) => {\\n  if (node.computed) c(node.key, st, \\\"Expression\\\")\\n  c(node.value, st, \\\"Expression\\\")\\n}\\n\"],\"names\":[\"let\",\"const\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
        },
        {
            "sha": "0f4100b8c87c57236cdb4228fc617b85245fa92c",
            "filename": "deps/acorn/acorn-walk/dist/walk.mjs",
            "status": "renamed",
            "additions": 22,
            "deletions": 9,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.mjs?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -9,8 +9,8 @@\n //     });\n //\n // to do something with all expressions. All Parser API node types\n-// can be used to identify node types, as well as Expression,\n-// Statement, and ScopeBody, which denote categories of nodes.\n+// can be used to identify node types, as well as Expression and\n+// Statement, which denote categories of nodes.\n //\n // The base argument can be used to pass a custom (recursive)\n // walker, and state can be used to give this walked an initial\n@@ -239,7 +239,7 @@ base.TryStatement = function (node, st, c) {\n };\n base.CatchClause = function (node, st, c) {\n   if (node.param) { c(node.param, st, \"Pattern\"); }\n-  c(node.body, st, \"ScopeBody\");\n+  c(node.body, st, \"Statement\");\n };\n base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n   c(node.test, st, \"Expression\");\n@@ -284,12 +284,8 @@ base.Function = function (node, st, c) {\n \n     c(param, st, \"Pattern\");\n   }\n-  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n+  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n };\n-// FIXME drop these node types in next major version\n-// (They are awkward, and in ES6 every block can be a scope.)\n-base.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); };\n-base.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); };\n \n base.Pattern = function (node, st, c) {\n   if (node.type === \"Identifier\")\n@@ -340,14 +336,30 @@ base.ObjectExpression = function (node, st, c) {\n   }\n };\n base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n-base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n+base.SequenceExpression = function (node, st, c) {\n   for (var i = 0, list = node.expressions; i < list.length; i += 1)\n     {\n     var expr = list[i];\n \n     c(expr, st, \"Expression\");\n   }\n };\n+base.TemplateLiteral = function (node, st, c) {\n+  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n+    {\n+    var quasi = list[i];\n+\n+    c(quasi, st);\n+  }\n+\n+  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n+    {\n+    var expr = list$1[i$1];\n+\n+    c(expr, st, \"Expression\");\n+  }\n+};\n+base.TemplateElement = ignore;\n base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n   c(node.argument, st, \"Expression\");\n };\n@@ -421,3 +433,4 @@ base.MethodDefinition = base.Property = function (node, st, c) {\n };\n \n export { simple, ancestor, recursive, full, fullAncestor, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };\n+//# sourceMappingURL=walk.mjs.map",
            "previous_filename": "deps/acorn/dist/walk.es.js"
        },
        {
            "sha": "2a94219c3bada4f34ef01bf7b5503f2dd9bf4128",
            "filename": "deps/acorn/acorn-walk/dist/walk.mjs.map",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.mjs.map",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.mjs.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2Fdist%2Fwalk.mjs.map?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"walk.mjs\",\"sources\":[\"../src/index.js\"],\"sourcesContent\":[\"// AST walker module for Mozilla Parser API compatible trees\\n\\n// A simple walk is one where you simply specify callbacks to be\\n// called on specific nodes. The last two arguments are optional. A\\n// simple use would be\\n//\\n//     walk.simple(myTree, {\\n//         Expression: function(node) { ... }\\n//     });\\n//\\n// to do something with all expressions. All Parser API node types\\n// can be used to identify node types, as well as Expression and\\n// Statement, which denote categories of nodes.\\n//\\n// The base argument can be used to pass a custom (recursive)\\n// walker, and state can be used to give this walked an initial\\n// state.\\n\\nexport function simple(node, visitors, baseVisitor, state, override) {\\n  if (!baseVisitor) baseVisitor = base\\n  ;(function c(node, st, override) {\\n    let type = override || node.type, found = visitors[type]\\n    baseVisitor[type](node, st, c)\\n    if (found) found(node, st)\\n  })(node, state, override)\\n}\\n\\n// An ancestor walk keeps an array of ancestor nodes (including the\\n// current node) and passes them to the callback as third parameter\\n// (and also as state parameter when no other state is present).\\nexport function ancestor(node, visitors, baseVisitor, state) {\\n  let ancestors = []\\n  if (!baseVisitor) baseVisitor = base\\n  ;(function c(node, st, override) {\\n    let type = override || node.type, found = visitors[type]\\n    let isNew = node !== ancestors[ancestors.length - 1]\\n    if (isNew) ancestors.push(node)\\n    baseVisitor[type](node, st, c)\\n    if (found) found(node, st || ancestors, ancestors)\\n    if (isNew) ancestors.pop()\\n  })(node, state)\\n}\\n\\n// A recursive walk is one where your functions override the default\\n// walkers. They can modify and replace the state parameter that's\\n// threaded through the walk, and can opt how and whether to walk\\n// their child nodes (by calling their third argument on these\\n// nodes).\\nexport function recursive(node, state, funcs, baseVisitor, override) {\\n  let visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\\n  ;(function c(node, st, override) {\\n    visitor[override || node.type](node, st, c)\\n  })(node, state, override)\\n}\\n\\nfunction makeTest(test) {\\n  if (typeof test === \\\"string\\\")\\n    return type => type === test\\n  else if (!test)\\n    return () => true\\n  else\\n    return test\\n}\\n\\nclass Found {\\n  constructor(node, state) { this.node = node; this.state = state }\\n}\\n\\n// A full walk triggers the callback on each node\\nexport function full(node, callback, baseVisitor, state, override) {\\n  if (!baseVisitor) baseVisitor = base\\n  ;(function c(node, st, override) {\\n    let type = override || node.type\\n    baseVisitor[type](node, st, c)\\n    if (!override) callback(node, st, type)\\n  })(node, state, override)\\n}\\n\\n// An fullAncestor walk is like an ancestor walk, but triggers\\n// the callback on each node\\nexport function fullAncestor(node, callback, baseVisitor, state) {\\n  if (!baseVisitor) baseVisitor = base\\n  let ancestors = []\\n  ;(function c(node, st, override) {\\n    let type = override || node.type\\n    let isNew = node !== ancestors[ancestors.length - 1]\\n    if (isNew) ancestors.push(node)\\n    baseVisitor[type](node, st, c)\\n    if (!override) callback(node, st || ancestors, ancestors, type)\\n    if (isNew) ancestors.pop()\\n  })(node, state)\\n}\\n\\n// Find a node with a given start, end, and type (all are optional,\\n// null can be used as wildcard). Returns a {node, state} object, or\\n// undefined when it doesn't find a matching node.\\nexport function findNodeAt(node, start, end, test, baseVisitor, state) {\\n  if (!baseVisitor) baseVisitor = base\\n  test = makeTest(test)\\n  try {\\n    (function c(node, st, override) {\\n      let type = override || node.type\\n      if ((start == null || node.start <= start) &&\\n          (end == null || node.end >= end))\\n        baseVisitor[type](node, st, c)\\n      if ((start == null || node.start === start) &&\\n          (end == null || node.end === end) &&\\n          test(type, node))\\n        throw new Found(node, st)\\n    })(node, state)\\n  } catch (e) {\\n    if (e instanceof Found) return e\\n    throw e\\n  }\\n}\\n\\n// Find the innermost node of a given type that contains the given\\n// position. Interface similar to findNodeAt.\\nexport function findNodeAround(node, pos, test, baseVisitor, state) {\\n  test = makeTest(test)\\n  if (!baseVisitor) baseVisitor = base\\n  try {\\n    (function c(node, st, override) {\\n      let type = override || node.type\\n      if (node.start > pos || node.end < pos) return\\n      baseVisitor[type](node, st, c)\\n      if (test(type, node)) throw new Found(node, st)\\n    })(node, state)\\n  } catch (e) {\\n    if (e instanceof Found) return e\\n    throw e\\n  }\\n}\\n\\n// Find the outermost matching node after a given position.\\nexport function findNodeAfter(node, pos, test, baseVisitor, state) {\\n  test = makeTest(test)\\n  if (!baseVisitor) baseVisitor = base\\n  try {\\n    (function c(node, st, override) {\\n      if (node.end < pos) return\\n      let type = override || node.type\\n      if (node.start >= pos && test(type, node)) throw new Found(node, st)\\n      baseVisitor[type](node, st, c)\\n    })(node, state)\\n  } catch (e) {\\n    if (e instanceof Found) return e\\n    throw e\\n  }\\n}\\n\\n// Find the outermost matching node before a given position.\\nexport function findNodeBefore(node, pos, test, baseVisitor, state) {\\n  test = makeTest(test)\\n  if (!baseVisitor) baseVisitor = base\\n  let max\\n  ;(function c(node, st, override) {\\n    if (node.start > pos) return\\n    let type = override || node.type\\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\\n      max = new Found(node, st)\\n    baseVisitor[type](node, st, c)\\n  })(node, state)\\n  return max\\n}\\n\\n// Fallback to an Object.create polyfill for older environments.\\nconst create = Object.create || function(proto) {\\n  function Ctor() {}\\n  Ctor.prototype = proto\\n  return new Ctor\\n}\\n\\n// Used to create a custom walker. Will fill in all missing node\\n// type properties with the defaults.\\nexport function make(funcs, baseVisitor) {\\n  let visitor = create(baseVisitor || base)\\n  for (let type in funcs) visitor[type] = funcs[type]\\n  return visitor\\n}\\n\\nfunction skipThrough(node, st, c) { c(node, st) }\\nfunction ignore(_node, _st, _c) {}\\n\\n// Node walkers.\\n\\nexport const base = {}\\n\\nbase.Program = base.BlockStatement = (node, st, c) => {\\n  for (let stmt of node.body)\\n    c(stmt, st, \\\"Statement\\\")\\n}\\nbase.Statement = skipThrough\\nbase.EmptyStatement = ignore\\nbase.ExpressionStatement = base.ParenthesizedExpression =\\n  (node, st, c) => c(node.expression, st, \\\"Expression\\\")\\nbase.IfStatement = (node, st, c) => {\\n  c(node.test, st, \\\"Expression\\\")\\n  c(node.consequent, st, \\\"Statement\\\")\\n  if (node.alternate) c(node.alternate, st, \\\"Statement\\\")\\n}\\nbase.LabeledStatement = (node, st, c) => c(node.body, st, \\\"Statement\\\")\\nbase.BreakStatement = base.ContinueStatement = ignore\\nbase.WithStatement = (node, st, c) => {\\n  c(node.object, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.SwitchStatement = (node, st, c) => {\\n  c(node.discriminant, st, \\\"Expression\\\")\\n  for (let cs of node.cases) {\\n    if (cs.test) c(cs.test, st, \\\"Expression\\\")\\n    for (let cons of cs.consequent)\\n      c(cons, st, \\\"Statement\\\")\\n  }\\n}\\nbase.SwitchCase = (node, st, c) => {\\n  if (node.test) c(node.test, st, \\\"Expression\\\")\\n  for (let cons of node.consequent)\\n    c(cons, st, \\\"Statement\\\")\\n}\\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = (node, st, c) => {\\n  if (node.argument) c(node.argument, st, \\\"Expression\\\")\\n}\\nbase.ThrowStatement = base.SpreadElement =\\n  (node, st, c) => c(node.argument, st, \\\"Expression\\\")\\nbase.TryStatement = (node, st, c) => {\\n  c(node.block, st, \\\"Statement\\\")\\n  if (node.handler) c(node.handler, st)\\n  if (node.finalizer) c(node.finalizer, st, \\\"Statement\\\")\\n}\\nbase.CatchClause = (node, st, c) => {\\n  if (node.param) c(node.param, st, \\\"Pattern\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.WhileStatement = base.DoWhileStatement = (node, st, c) => {\\n  c(node.test, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.ForStatement = (node, st, c) => {\\n  if (node.init) c(node.init, st, \\\"ForInit\\\")\\n  if (node.test) c(node.test, st, \\\"Expression\\\")\\n  if (node.update) c(node.update, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.ForInStatement = base.ForOfStatement = (node, st, c) => {\\n  c(node.left, st, \\\"ForInit\\\")\\n  c(node.right, st, \\\"Expression\\\")\\n  c(node.body, st, \\\"Statement\\\")\\n}\\nbase.ForInit = (node, st, c) => {\\n  if (node.type === \\\"VariableDeclaration\\\") c(node, st)\\n  else c(node, st, \\\"Expression\\\")\\n}\\nbase.DebuggerStatement = ignore\\n\\nbase.FunctionDeclaration = (node, st, c) => c(node, st, \\\"Function\\\")\\nbase.VariableDeclaration = (node, st, c) => {\\n  for (let decl of node.declarations)\\n    c(decl, st)\\n}\\nbase.VariableDeclarator = (node, st, c) => {\\n  c(node.id, st, \\\"Pattern\\\")\\n  if (node.init) c(node.init, st, \\\"Expression\\\")\\n}\\n\\nbase.Function = (node, st, c) => {\\n  if (node.id) c(node.id, st, \\\"Pattern\\\")\\n  for (let param of node.params)\\n    c(param, st, \\\"Pattern\\\")\\n  c(node.body, st, node.expression ? \\\"Expression\\\" : \\\"Statement\\\")\\n}\\n\\nbase.Pattern = (node, st, c) => {\\n  if (node.type === \\\"Identifier\\\")\\n    c(node, st, \\\"VariablePattern\\\")\\n  else if (node.type === \\\"MemberExpression\\\")\\n    c(node, st, \\\"MemberPattern\\\")\\n  else\\n    c(node, st)\\n}\\nbase.VariablePattern = ignore\\nbase.MemberPattern = skipThrough\\nbase.RestElement = (node, st, c) => c(node.argument, st, \\\"Pattern\\\")\\nbase.ArrayPattern = (node, st, c) => {\\n  for (let elt of node.elements) {\\n    if (elt) c(elt, st, \\\"Pattern\\\")\\n  }\\n}\\nbase.ObjectPattern = (node, st, c) => {\\n  for (let prop of node.properties) {\\n    if (prop.type === \\\"Property\\\") {\\n      if (prop.computed) c(prop.key, st, \\\"Expression\\\")\\n      c(prop.value, st, \\\"Pattern\\\")\\n    } else if (prop.type === \\\"RestElement\\\") {\\n      c(prop.argument, st, \\\"Pattern\\\")\\n    }\\n  }\\n}\\n\\nbase.Expression = skipThrough\\nbase.ThisExpression = base.Super = base.MetaProperty = ignore\\nbase.ArrayExpression = (node, st, c) => {\\n  for (let elt of node.elements) {\\n    if (elt) c(elt, st, \\\"Expression\\\")\\n  }\\n}\\nbase.ObjectExpression = (node, st, c) => {\\n  for (let prop of node.properties)\\n    c(prop, st)\\n}\\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\\nbase.SequenceExpression = (node, st, c) => {\\n  for (let expr of node.expressions)\\n    c(expr, st, \\\"Expression\\\")\\n}\\nbase.TemplateLiteral = (node, st, c) => {\\n  for (let quasi of node.quasis)\\n    c(quasi, st)\\n\\n  for (let expr of node.expressions)\\n    c(expr, st, \\\"Expression\\\")\\n}\\nbase.TemplateElement = ignore\\nbase.UnaryExpression = base.UpdateExpression = (node, st, c) => {\\n  c(node.argument, st, \\\"Expression\\\")\\n}\\nbase.BinaryExpression = base.LogicalExpression = (node, st, c) => {\\n  c(node.left, st, \\\"Expression\\\")\\n  c(node.right, st, \\\"Expression\\\")\\n}\\nbase.AssignmentExpression = base.AssignmentPattern = (node, st, c) => {\\n  c(node.left, st, \\\"Pattern\\\")\\n  c(node.right, st, \\\"Expression\\\")\\n}\\nbase.ConditionalExpression = (node, st, c) => {\\n  c(node.test, st, \\\"Expression\\\")\\n  c(node.consequent, st, \\\"Expression\\\")\\n  c(node.alternate, st, \\\"Expression\\\")\\n}\\nbase.NewExpression = base.CallExpression = (node, st, c) => {\\n  c(node.callee, st, \\\"Expression\\\")\\n  if (node.arguments)\\n    for (let arg of node.arguments)\\n      c(arg, st, \\\"Expression\\\")\\n}\\nbase.MemberExpression = (node, st, c) => {\\n  c(node.object, st, \\\"Expression\\\")\\n  if (node.computed) c(node.property, st, \\\"Expression\\\")\\n}\\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = (node, st, c) => {\\n  if (node.declaration)\\n    c(node.declaration, st, node.type === \\\"ExportNamedDeclaration\\\" || node.declaration.id ? \\\"Statement\\\" : \\\"Expression\\\")\\n  if (node.source) c(node.source, st, \\\"Expression\\\")\\n}\\nbase.ExportAllDeclaration = (node, st, c) => {\\n  c(node.source, st, \\\"Expression\\\")\\n}\\nbase.ImportDeclaration = (node, st, c) => {\\n  for (let spec of node.specifiers)\\n    c(spec, st)\\n  c(node.source, st, \\\"Expression\\\")\\n}\\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\\n\\nbase.TaggedTemplateExpression = (node, st, c) => {\\n  c(node.tag, st, \\\"Expression\\\")\\n  c(node.quasi, st, \\\"Expression\\\")\\n}\\nbase.ClassDeclaration = base.ClassExpression = (node, st, c) => c(node, st, \\\"Class\\\")\\nbase.Class = (node, st, c) => {\\n  if (node.id) c(node.id, st, \\\"Pattern\\\")\\n  if (node.superClass) c(node.superClass, st, \\\"Expression\\\")\\n  c(node.body, st)\\n}\\nbase.ClassBody = (node, st, c) => {\\n  for (let elt of node.body)\\n    c(elt, st)\\n}\\nbase.MethodDefinition = base.Property = (node, st, c) => {\\n  if (node.computed) c(node.key, st, \\\"Expression\\\")\\n  c(node.value, st, \\\"Expression\\\")\\n}\\n\"],\"names\":[\"let\",\"const\"],\"mappings\":\"AAAA;;;;;;;;;;;;;;;;;;AAkBA,AAAO,SAAS,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,QAAQ,EAAE;EACnE,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,IAAI;GACnC,EAAA,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;IAC/BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAC;IACxD,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;IAC9B,IAAI,KAAK,EAAE,EAAA,KAAK,CAAC,IAAI,EAAE,EAAE,EAAC,EAAA;GAC3B,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAC;CAC1B;;;;;AAKD,AAAO,SAAS,QAAQ,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE;EAC3DA,IAAI,SAAS,GAAG,GAAE;EAClB,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,IAAI;GACnC,EAAA,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;IAC/BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAC;IACxDA,IAAI,KAAK,GAAG,IAAI,KAAK,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAC;IACpD,IAAI,KAAK,EAAE,EAAA,SAAS,CAAC,IAAI,CAAC,IAAI,EAAC,EAAA;IAC/B,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;IAC9B,IAAI,KAAK,EAAE,EAAA,KAAK,CAAC,IAAI,EAAE,EAAE,IAAI,SAAS,EAAE,SAAS,EAAC,EAAA;IAClD,IAAI,KAAK,EAAE,EAAA,SAAS,CAAC,GAAG,GAAE,EAAA;GAC3B,EAAE,IAAI,EAAE,KAAK,EAAC;CAChB;;;;;;;AAOD,AAAO,SAAS,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE;EACnEA,IAAI,OAAO,GAAG,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,WAAW,IAAI,SAAS,CAAC,GAAG,WAAW,CACxE,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;IAC/B,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;GAC5C,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAC;CAC1B;;AAED,SAAS,QAAQ,CAAC,IAAI,EAAE;EACtB,IAAI,OAAO,IAAI,KAAK,QAAQ;IAC1B,EAAA,OAAO,UAAA,IAAI,EAAC,SAAG,IAAI,KAAK,IAAI,GAAA,EAAA;OACzB,IAAI,CAAC,IAAI;IACZ,EAAA,OAAO,YAAG,SAAG,IAAI,GAAA,EAAA;;IAEjB,EAAA,OAAO,IAAI,EAAA;CACd;;AAED,IAAM,KAAK,GAAC,cACC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,MAAK,EAAE,CAAA;;;AAInE,AAAO,SAAS,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,QAAQ,EAAE;EACjE,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,IAAI;GACnC,EAAA,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;IAC/BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAI;IAChC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;IAC9B,IAAI,CAAC,QAAQ,EAAE,EAAA,QAAQ,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,EAAC,EAAA;GACxC,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAC;CAC1B;;;;AAID,AAAO,SAAS,YAAY,CAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE;EAC/D,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,KAAI,EAAA;EACpCA,IAAI,SAAS,GAAG,EAAE,CACjB,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;IAC/BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAI;IAChCA,IAAI,KAAK,GAAG,IAAI,KAAK,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAC;IACpD,IAAI,KAAK,EAAE,EAAA,SAAS,CAAC,IAAI,CAAC,IAAI,EAAC,EAAA;IAC/B,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;IAC9B,IAAI,CAAC,QAAQ,EAAE,EAAA,QAAQ,CAAC,IAAI,EAAE,EAAE,IAAI,SAAS,EAAE,SAAS,EAAE,IAAI,EAAC,EAAA;IAC/D,IAAI,KAAK,EAAE,EAAA,SAAS,CAAC,GAAG,GAAE,EAAA;GAC3B,EAAE,IAAI,EAAE,KAAK,EAAC;CAChB;;;;;AAKD,AAAO,SAAS,UAAU,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE;EACrE,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,KAAI,EAAA;EACpC,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAC;EACrB,IAAI;IACF,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;MAC9BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAI;MAChC,IAAI,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK;WACpC,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC;QAClC,EAAA,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC,EAAA;MAChC,IAAI,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK;WACrC,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC;UACjC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;QAClB,EAAA,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,EAAA;KAC5B,EAAE,IAAI,EAAE,KAAK,EAAC;GAChB,CAAC,OAAO,CAAC,EAAE;IACV,IAAI,CAAC,YAAY,KAAK,EAAE,EAAA,OAAO,CAAC,EAAA;IAChC,MAAM,CAAC;GACR;CACF;;;;AAID,AAAO,SAAS,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE;EAClE,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAC;EACrB,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,KAAI,EAAA;EACpC,IAAI;IACF,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;MAC9BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAI;MAChC,IAAI,IAAI,CAAC,KAAK,GAAG,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,EAAE,EAAA,MAAM,EAAA;MAC9C,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;MAC9B,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAA,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,EAAA;KAChD,EAAE,IAAI,EAAE,KAAK,EAAC;GAChB,CAAC,OAAO,CAAC,EAAE;IACV,IAAI,CAAC,YAAY,KAAK,EAAE,EAAA,OAAO,CAAC,EAAA;IAChC,MAAM,CAAC;GACR;CACF;;;AAGD,AAAO,SAAS,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE;EACjE,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAC;EACrB,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,KAAI,EAAA;EACpC,IAAI;IACF,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;MAC9B,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,EAAE,EAAA,MAAM,EAAA;MAC1BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAI;MAChC,IAAI,IAAI,CAAC,KAAK,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAA,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,EAAA;MACpE,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;KAC/B,EAAE,IAAI,EAAE,KAAK,EAAC;GAChB,CAAC,OAAO,CAAC,EAAE;IACV,IAAI,CAAC,YAAY,KAAK,EAAE,EAAA,OAAO,CAAC,EAAA;IAChC,MAAM,CAAC;GACR;CACF;;;AAGD,AAAO,SAAS,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE;EAClE,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAC;EACrB,IAAI,CAAC,WAAW,EAAE,EAAA,WAAW,GAAG,KAAI,EAAA;EACpCA,IAAI,GAAG,CACN,CAAC,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE;IAC/B,IAAI,IAAI,CAAC,KAAK,GAAG,GAAG,EAAE,EAAA,MAAM,EAAA;IAC5BA,IAAI,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAI;IAChC,IAAI,IAAI,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;MAC1E,EAAA,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,EAAC,EAAA;IAC3B,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAC;GAC/B,EAAE,IAAI,EAAE,KAAK,EAAC;EACf,OAAO,GAAG;CACX;;;AAGDC,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,SAAS,KAAK,EAAE;EAC9C,SAAS,IAAI,GAAG,EAAE;EAClB,IAAI,CAAC,SAAS,GAAG,MAAK;EACtB,OAAO,IAAI,IAAI;EAChB;;;;AAID,AAAO,SAAS,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE;EACvCD,IAAI,OAAO,GAAG,MAAM,CAAC,WAAW,IAAI,IAAI,EAAC;EACzC,KAAKA,IAAI,IAAI,IAAI,KAAK,EAAE,EAAA,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,EAAC,EAAA;EACnD,OAAO,OAAO;CACf;;AAED,SAAS,WAAW,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,EAAE,EAAC,EAAE;AACjD,SAAS,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE;;;;AAIlC,AAAOC,IAAM,IAAI,GAAG,GAAE;;AAEtB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,cAAc,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACjD,KAAa,kBAAI,IAAI,CAAC,IAAI,yBAAA;IAArB;IAAAD,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;GAAA;EAC3B;AACD,IAAI,CAAC,SAAS,GAAG,YAAW;AAC5B,IAAI,CAAC,cAAc,GAAG,OAAM;AAC5B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,uBAAuB;EACrD,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,SAAG,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,EAAE,YAAY,CAAC,IAAA;AACvD,IAAI,CAAC,WAAW,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC/B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC;EAC9B,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,EAAE,WAAW,EAAC;EACnC,IAAI,IAAI,CAAC,SAAS,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,EAAE,WAAW,EAAC,EAAA;EACvD;AACD,IAAI,CAAC,gBAAgB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,SAAG,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,CAAC,IAAA;AACtE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,iBAAiB,GAAG,OAAM;AACrD,IAAI,CAAC,aAAa,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACjC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC;EAChC,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;EAC9B;AACD,IAAI,CAAC,eAAe,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACnC,CAAC,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,EAAE,YAAY,EAAC;EACtC,KAAW,kBAAI,IAAI,CAAC,KAAK,yBAAA,EAAE;IAAtBA,IAAI,EAAE;;IACT,IAAI,EAAE,CAAC,IAAI,EAAE,EAAA,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;IACzC,KAAa,sBAAI,EAAE,CAAC,UAAU,+BAAA;MAAzB;MAAAA,IAAI,IAAI;;MACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;KAAA;GAC3B;EACF;AACD,IAAI,CAAC,UAAU,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC9B,IAAI,IAAI,CAAC,IAAI,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EAC7C,KAAa,kBAAI,IAAI,CAAC,UAAU,yBAAA;IAA3B;IAAAA,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;GAAA;EAC3B;AACD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACjF,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EACtD;AACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,aAAa;EACtC,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,SAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,YAAY,CAAC,IAAA;AACrD,IAAI,CAAC,YAAY,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAChC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,WAAW,EAAC;EAC9B,IAAI,IAAI,CAAC,OAAO,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAC,EAAA;EACrC,IAAI,IAAI,CAAC,SAAS,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,EAAE,WAAW,EAAC,EAAA;EACvD;AACD,IAAI,CAAC,WAAW,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC/B,IAAI,IAAI,CAAC,KAAK,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,SAAS,EAAC,EAAA;EAC5C,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;EAC9B;AACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,gBAAgB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC1D,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC;EAC9B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;EAC9B;AACD,IAAI,CAAC,YAAY,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAChC,IAAI,IAAI,CAAC,IAAI,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,SAAS,EAAC,EAAA;EAC1C,IAAI,IAAI,CAAC,IAAI,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EAC7C,IAAI,IAAI,CAAC,MAAM,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EACjD,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;EAC9B;AACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACxD,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,SAAS,EAAC;EAC3B,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,YAAY,EAAC;EAC/B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,WAAW,EAAC;EAC9B;AACD,IAAI,CAAC,OAAO,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC3B,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,EAAE,EAAA,CAAC,CAAC,IAAI,EAAE,EAAE,EAAC,EAAA;OAC/C,EAAA,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EAC/B;AACD,IAAI,CAAC,iBAAiB,GAAG,OAAM;;AAE/B,IAAI,CAAC,mBAAmB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,SAAG,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,UAAU,CAAC,IAAA;AACnE,IAAI,CAAC,mBAAmB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACvC,KAAa,kBAAI,IAAI,CAAC,YAAY,yBAAA;IAA7B;IAAAA,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAC;GAAA;EACd;AACD,IAAI,CAAC,kBAAkB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACtC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,SAAS,EAAC;EACzB,IAAI,IAAI,CAAC,IAAI,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EAC9C;;AAED,IAAI,CAAC,QAAQ,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC5B,IAAI,IAAI,CAAC,EAAE,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,SAAS,EAAC,EAAA;EACtC,KAAc,kBAAI,IAAI,CAAC,MAAM,yBAAA;IAAxB;IAAAA,IAAI,KAAK;;IACZ,CAAC,CAAC,KAAK,EAAE,EAAE,EAAE,SAAS,EAAC;GAAA;EACzB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,CAAC,UAAU,GAAG,YAAY,GAAG,WAAW,EAAC;EAC/D;;AAED,IAAI,CAAC,OAAO,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC3B,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY;IAC5B,EAAA,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,iBAAiB,EAAC,EAAA;OAC3B,IAAI,IAAI,CAAC,IAAI,KAAK,kBAAkB;IACvC,EAAA,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,eAAe,EAAC,EAAA;;IAE5B,EAAA,CAAC,CAAC,IAAI,EAAE,EAAE,EAAC,EAAA;EACd;AACD,IAAI,CAAC,eAAe,GAAG,OAAM;AAC7B,IAAI,CAAC,aAAa,GAAG,YAAW;AAChC,IAAI,CAAC,WAAW,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,SAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,SAAS,CAAC,IAAA;AACnE,IAAI,CAAC,YAAY,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAChC,KAAY,kBAAI,IAAI,CAAC,QAAQ,yBAAA,EAAE;IAA1BA,IAAI,GAAG;;IACV,IAAI,GAAG,EAAE,EAAA,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,SAAS,EAAC,EAAA;GAC/B;EACF;AACD,IAAI,CAAC,aAAa,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACjC,KAAa,kBAAI,IAAI,CAAC,UAAU,yBAAA,EAAE;IAA7BA,IAAI,IAAI;;IACX,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;MAC5B,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;MAChD,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,SAAS,EAAC;KAC7B,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,aAAa,EAAE;MACtC,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,SAAS,EAAC;KAChC;GACF;EACF;;AAED,IAAI,CAAC,UAAU,GAAG,YAAW;AAC7B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,GAAG,OAAM;AAC7D,IAAI,CAAC,eAAe,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACnC,KAAY,kBAAI,IAAI,CAAC,QAAQ,yBAAA,EAAE;IAA1BA,IAAI,GAAG;;IACV,IAAI,GAAG,EAAE,EAAA,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;GAClC;EACF;AACD,IAAI,CAAC,gBAAgB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACpC,KAAa,kBAAI,IAAI,CAAC,UAAU,yBAAA;IAA3B;IAAAA,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAC;GAAA;EACd;AACD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,oBAAmB;AACjF,IAAI,CAAC,kBAAkB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACtC,KAAa,kBAAI,IAAI,CAAC,WAAW,yBAAA;IAA5B;IAAAA,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC;GAAA;EAC5B;AACD,IAAI,CAAC,eAAe,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACnC,KAAc,kBAAI,IAAI,CAAC,MAAM,yBAAA;IAAxB;IAAAA,IAAI,KAAK;;IACZ,CAAC,CAAC,KAAK,EAAE,EAAE,EAAC;GAAA;;EAEd,KAAa,sBAAI,IAAI,CAAC,WAAW,+BAAA;IAA5B;IAAAA,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC;GAAA;EAC5B;AACD,IAAI,CAAC,eAAe,GAAG,OAAM;AAC7B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,gBAAgB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC3D,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,YAAY,EAAC;EACnC;AACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC7D,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC;EAC9B,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,YAAY,EAAC;EAChC;AACD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,iBAAiB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACjE,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,SAAS,EAAC;EAC3B,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,YAAY,EAAC;EAChC;AACD,IAAI,CAAC,qBAAqB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACzC,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC;EAC9B,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,EAAE,YAAY,EAAC;EACpC,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,EAAE,YAAY,EAAC;EACpC;AACD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,cAAc,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACvD,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC;EAChC,IAAI,IAAI,CAAC,SAAS;IAChB,EAAA,KAAY,kBAAI,IAAI,CAAC,SAAS,yBAAA;MAAzB;QAAAA,IAAI,GAAG;;QACV,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,YAAY,EAAC;OAAA,EAAA;EAC7B;AACD,IAAI,CAAC,gBAAgB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACpC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC;EAChC,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EACtD;AACD,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,wBAAwB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC1E,IAAI,IAAI,CAAC,WAAW;IAClB,EAAA,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,EAAE,IAAI,CAAC,IAAI,KAAK,wBAAwB,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE,GAAG,WAAW,GAAG,YAAY,EAAC,EAAA;EACrH,IAAI,IAAI,CAAC,MAAM,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EAClD;AACD,IAAI,CAAC,oBAAoB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACxC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC;EACjC;AACD,IAAI,CAAC,iBAAiB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACrC,KAAa,kBAAI,IAAI,CAAC,UAAU,yBAAA;IAA3B;IAAAA,IAAI,IAAI;;IACX,CAAC,CAAC,IAAI,EAAE,EAAE,EAAC;GAAA;EACb,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,YAAY,EAAC;EACjC;AACD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,GAAG,OAAM;;AAE5H,IAAI,CAAC,wBAAwB,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC5C,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,EAAE,YAAY,EAAC;EAC7B,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,YAAY,EAAC;EAChC;AACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,eAAe,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,SAAG,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,OAAO,CAAC,IAAA;AACpF,IAAI,CAAC,KAAK,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACzB,IAAI,IAAI,CAAC,EAAE,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,SAAS,EAAC,EAAA;EACtC,IAAI,IAAI,CAAC,UAAU,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EACzD,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAC;EACjB;AACD,IAAI,CAAC,SAAS,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EAC7B,KAAY,kBAAI,IAAI,CAAC,IAAI,yBAAA;IAApB;IAAAA,IAAI,GAAG;;IACV,CAAC,CAAC,GAAG,EAAE,EAAE,EAAC;GAAA;EACb;AACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,QAAQ,GAAG,UAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE;EACpD,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAA,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,EAAE,YAAY,EAAC,EAAA;EAChD,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,YAAY,EAAC;CAChC;;;;\"}\n\\ No newline at end of file"
        },
        {
            "sha": "aee3f2584d2de286e695f82fcbe4cf9b88227c79",
            "filename": "deps/acorn/acorn-walk/package.json",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn-walk%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn-walk%2Fpackage.json?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,33 @@\n+{\n+  \"name\": \"acorn-walk\",\n+  \"description\": \"ECMAScript (ESTree) AST walker\",\n+  \"homepage\": \"https://github.com/acornjs/acorn\",\n+  \"main\": \"dist/walk.js\",\n+  \"module\": \"dist/walk.mjs\",\n+  \"version\": \"6.1.1\",\n+  \"engines\": {\"node\": \">=0.4.0\"},\n+  \"maintainers\": [\n+    {\n+      \"name\": \"Marijn Haverbeke\",\n+      \"email\": \"marijnh@gmail.com\",\n+      \"web\": \"https://marijnhaverbeke.nl\"\n+    },\n+    {\n+      \"name\": \"Ingvar Stepanyan\",\n+      \"email\": \"me@rreverser.com\",\n+      \"web\": \"https://rreverser.com/\"\n+    },\n+    {\n+      \"name\": \"Adrian Heine\",\n+      \"web\": \"http://adrianheine.de\"\n+    }\n+  ],\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/acornjs/acorn.git\"\n+  },\n+  \"scripts\": {\n+    \"prepare\": \"cd ..; npm run build:walk\"\n+  },\n+  \"license\": \"MIT\"\n+}"
        },
        {
            "sha": "254406af611d76b6541f614d9ddc43d7666b030b",
            "filename": "deps/acorn/acorn/CHANGELOG.md",
            "status": "renamed",
            "additions": 114,
            "deletions": 116,
            "changes": 230,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2FCHANGELOG.md",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2FCHANGELOG.md?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -1,46 +1,122 @@\n-## 5.7.2 (2018-08-24)\n+## 6.0.7 (2019-02-04)\n \n ### Bug fixes\n \n-Properly handle `allowAwaitOutsideFunction` in for statements.\n+Check that exported bindings are defined.\n \n-Treat function declarations at the top level of modules like let bindings.\n+Don't treat `\\u180e` as a whitespace character.\n \n-Don't allow async function declarations as the only statement under a label.\n+Check for duplicate parameter names in methods.\n+\n+Don't allow shorthand properties when they are generators or async methods.\n+\n+Forbid binding `await` in async arrow function's parameter list.\n \n-## 5.7.1 (2018-06-15)\n+## 6.0.6 (2019-01-30)\n \n ### Bug fixes\n \n-Make sure the walker and bin files are rebuilt on release (the previous release didn't get the up-to-date versions).\n+The content of class declarations and expressions is now always parsed in strict mode.\n \n-## 5.7.0 (2018-06-15)\n+Don't allow `let` or `const` to bind the variable name `let`.\n+\n+Treat class declarations as lexical.\n+\n+Don't allow a generator function declaration as the sole body of an `if` or `else`.\n+\n+Ignore `\"use strict\"` when after an empty statement.\n+\n+Allow string line continuations with special line terminator characters.\n+\n+Treat `for` bodies as part of the `for` scope when checking for conflicting bindings.\n+\n+Fix bug with parsing `yield` in a `for` loop initializer.\n+\n+Implement special cases around scope checking for functions.\n+\n+## 6.0.5 (2019-01-02)\n \n ### Bug fixes\n \n-Fix crash in walker when walking a binding-less catch node.\n+Fix TypeScript type for `Parser.extend` and add `allowAwaitOutsideFunction` to options type.\n \n-### New features\n+Don't treat `let` as a keyword when the next token is `{` on the next line.\n \n-Upgraded to Unicode 11.\n+Fix bug that broke checking for parentheses around an object pattern in a destructuring assignment when `preserveParens` was on.\n \n-## 5.6.2 (2018-06-05)\n+## 6.0.4 (2018-11-05)\n \n ### Bug fixes\n \n-In the walker, go back to allowing the `baseVisitor` argument to be null to default to the default base everywhere.\n+Further improvements to tokenizing regular expressions in corner cases.\n \n-## 5.6.1 (2018-06-01)\n+## 6.0.3 (2018-11-04)\n \n ### Bug fixes\n \n-Fix regression when passing `null` as fourth argument to `walk.recursive`.\n+Fix bug in tokenizing an expression-less return followed by a function followed by a regular expression.\n \n-## 5.6.0 (2018-05-31)\n+Remove stray symlink in the package tarball.\n+\n+## 6.0.2 (2018-09-26)\n+\n+### Bug fixes\n+\n+Fix bug where default expressions could fail to parse inside an object destructuring assignment expression.\n+\n+## 6.0.1 (2018-09-14)\n \n ### Bug fixes\n \n-Fix a bug in the walker that caused a crash when walking an object pattern spread.\n+Fix wrong value in `version` export.\n+\n+## 6.0.0 (2018-09-14)\n+\n+### Bug fixes\n+\n+Better handle variable-redefinition checks for catch bindings and functions directly under if statements.\n+\n+Forbid `new.target` in top-level arrow functions.\n+\n+Fix issue with parsing a regexp after `yield` in some contexts.\n+\n+### New features\n+\n+The package now comes with TypeScript definitions.\n+\n+### Breaking changes\n+\n+The default value of the `ecmaVersion` option is now 9 (2018).\n+\n+Plugins work differently, and will have to be rewritten to work with this version.\n+\n+The loose parser and walker have been moved into separate packages (`acorn-loose` and `acorn-walk`).\n+\n+## 5.7.3 (2018-09-10)\n+\n+### Bug fixes\n+\n+Fix failure to tokenize regexps after expressions like `x.of`.\n+\n+Better error message for unterminated template literals.\n+\n+## 5.7.2 (2018-08-24)\n+\n+### Bug fixes\n+\n+Properly handle `allowAwaitOutsideFunction` in for statements.\n+\n+Treat function declarations at the top level of modules like let bindings.\n+\n+Don't allow async function declarations as the only statement under a label.\n+\n+## 5.7.0 (2018-06-15)\n+\n+### New features\n+\n+Upgraded to Unicode 11.\n+\n+## 5.6.0 (2018-05-31)\n \n ### New features\n \n@@ -66,28 +142,16 @@ A republish of the code in 5.5.1 in an attempt to solve an issue with the file t\n \n ### Bug fixes\n \n-Fix regression in walker causing property values in object patterns to be walked as expressions.\n-\n Fix misleading error message for octal escapes in template strings.\n \n ## 5.5.0 (2018-02-27)\n \n-### Bug fixes\n-\n-Support object spread in the AST walker.\n-\n ### New features\n \n The identifier character categorization is now based on Unicode version 10.\n \n Acorn will now validate the content of regular expressions, including new ES9 features.\n \n-## 5.4.1 (2018-02-02)\n-\n-### Bug fixes\n-\n-5.4.0 somehow accidentally included an old version of walk.js.\n-\n ## 5.4.0 (2018-02-01)\n \n ### Bug fixes\n@@ -138,8 +202,6 @@ Fix token context tracking for `class` and `function` in property-name position.\n \n Make sure `%*` isn't parsed as a valid operator.\n \n-The `full` and `fullAncestor` walkers no longer visit nodes multiple times.\n-\n Allow shorthand properties `get` and `set` to be followed by default values.\n \n Disallow `super` when not in callee or object position.\n@@ -176,14 +238,10 @@ Don't error when `yield` is used as a property name.\n \n Allow `async` as a shorthand object property.\n \n-Make the ES module version of the loose parser actually work.\n-\n ### New features\n \n Implement the [template literal revision proposal](https://github.com/tc39/proposal-template-literal-revision) for ES9.\n \n-New walker functions `full` and `fullAncestor`.\n-\n ## 5.0.3 (2017-04-01)\n \n ### Bug fixes\n@@ -222,43 +280,35 @@ Allow all forms of member expressions to be parenthesized as lvalue.\n \n ### Bug fixes\n \n-Don't expect semicolons after default-exported functions or classes,\n-even when they are expressions.\n+Don't expect semicolons after default-exported functions or classes, even when they are expressions.\n \n-Check for use of `'use strict'` directives in non-simple parameter\n-functions, even when already in strict mode.\n+Check for use of `'use strict'` directives in non-simple parameter functions, even when already in strict mode.\n \n ## 4.0.9 (2017-02-06)\n \n ### Bug fixes\n \n-Fix incorrect error raised for parenthesized simple assignment\n-targets, so that `(x) = 1` parses again.\n+Fix incorrect error raised for parenthesized simple assignment targets, so that `(x) = 1` parses again.\n \n ## 4.0.8 (2017-02-03)\n \n ### Bug fixes\n \n-Solve spurious parenthesized pattern errors by temporarily erring on\n-the side of accepting programs that our delayed errors don't handle\n-correctly yet.\n+Solve spurious parenthesized pattern errors by temporarily erring on the side of accepting programs that our delayed errors don't handle correctly yet.\n \n ## 4.0.7 (2017-02-02)\n \n ### Bug fixes\n \n Accept invalidly rejected code like `(x).y = 2` again.\n \n-Don't raise an error when a function _inside_ strict code has a\n-non-simple parameter list.\n+Don't raise an error when a function _inside_ strict code has a non-simple parameter list.\n \n ## 4.0.6 (2017-02-02)\n \n ### Bug fixes\n \n-Fix exponential behavior (manifesting itself as a complete hang for\n-even relatively small source files) introduced by the new 'use strict'\n-check.\n+Fix exponential behavior (manifesting itself as a complete hang for even relatively small source files) introduced by the new 'use strict' check.\n \n ## 4.0.5 (2017-02-02)\n \n@@ -280,17 +330,14 @@ Disallow labeled declarations.\n \n ### Bug fixes\n \n-Fix issue with loading acorn_loose.js with an AMD loader.\n-\n Fix crash when `export` was followed by a keyword that can't be\n exported.\n \n ## 4.0.3 (2016-08-16)\n \n ### Bug fixes\n \n-Allow regular function declarations inside single-statement `if`\n-branches in loose mode. Forbid them entirely in strict mode.\n+Allow regular function declarations inside single-statement `if` branches in loose mode. Forbid them entirely in strict mode.\n \n Properly parse properties named `async` in ES2017 mode.\n \n@@ -302,8 +349,7 @@ Fix bug where reserved words were broken in ES2017 mode.\n \n Don't ignore period or 'e' characters after octal numbers.\n \n-Fix broken parsing for call expressions in default parameter values\n-of arrow functions.\n+Fix broken parsing for call expressions in default parameter values of arrow functions.\n \n ## 4.0.1 (2016-08-08)\n \n@@ -317,17 +363,15 @@ Fix false positives in duplicated export name errors.\n \n The default `ecmaVersion` option value is now 7.\n \n-A number of internal method signatures changed, so plugins might need\n-to be updated.\n+A number of internal method signatures changed, so plugins might need to be updated.\n \n ### Bug fixes\n \n The parser now raises errors on duplicated export names.\n \n `arguments` and `eval` can now be used in shorthand properties.\n \n-Duplicate parameter names in non-simple argument lists now always\n-produce an error.\n+Duplicate parameter names in non-simple argument lists now always produce an error.\n \n ### New features\n \n@@ -336,8 +380,7 @@ The `ecmaVersion` option now also accepts year-style version numbers\n \n Support for `async`/`await` syntax when `ecmaVersion` is >= 8.\n \n-Support for trailing commas in call expressions when `ecmaVersion`\n-is >= 8.\n+Support for trailing commas in call expressions when `ecmaVersion` is >= 8.\n \n ## 3.3.0 (2016-07-25)\n \n@@ -349,8 +392,7 @@ Fix parser crash when parsing an array pattern with a hole.\n \n ### New features\n \n-Implement check against complex argument lists in functions that\n-enable strict mode in ES7.\n+Implement check against complex argument lists in functions that enable strict mode in ES7.\n \n ## 3.2.0 (2016-06-07)\n \n@@ -361,97 +403,64 @@ environment.\n \n Properly reject shorthand properties whose name is a keyword.\n \n-Don't crash when the loose parser is called without options object.\n-\n ### New features\n \n-Visitors created with `visit.make` now have their base as _prototype_,\n-rather than copying properties into a fresh object.\n-\n-Make it possible to use `visit.ancestor` with a walk state.\n+Visitors created with `visit.make` now have their base as _prototype_, rather than copying properties into a fresh object.\n \n ## 3.1.0 (2016-04-18)\n \n ### Bug fixes\n \n-Fix issue where the loose parser created invalid TemplateElement nodes\n-for unclosed template literals.\n-\n-Properly tokenize the division operator directly after a function\n-expression.\n+Properly tokenize the division operator directly after a function expression.\n \n Allow trailing comma in destructuring arrays.\n \n-### New features\n-\n-The walker now allows defining handlers for `CatchClause` nodes.\n-\n ## 3.0.4 (2016-02-25)\n \n ### Fixes\n \n-Allow update expressions as left-hand-side of the ES7 exponential\n-operator.\n+Allow update expressions as left-hand-side of the ES7 exponential operator.\n \n ## 3.0.2 (2016-02-10)\n \n ### Fixes\n \n-Fix bug that accidentally made `undefined` a reserved word when\n-parsing ES7.\n+Fix bug that accidentally made `undefined` a reserved word when parsing ES7.\n \n ## 3.0.0 (2016-02-10)\n \n ### Breaking changes\n \n The default value of the `ecmaVersion` option is now 6 (used to be 5).\n \n-Support for comprehension syntax (which was dropped from the draft\n-spec) has been removed.\n+Support for comprehension syntax (which was dropped from the draft spec) has been removed.\n \n ### Fixes\n \n-`let` and `yield` are now “contextual keywords”, meaning you can\n-mostly use them as identifiers in ES5 non-strict code.\n+`let` and `yield` are now “contextual keywords”, meaning you can mostly use them as identifiers in ES5 non-strict code.\n \n-A parenthesized class or function expression after `export default` is\n-now parsed correctly.\n+A parenthesized class or function expression after `export default` is now parsed correctly.\n \n ### New features\n \n-When `ecmaVersion` is set to 7, Acorn will parse the exponentiation\n-operator (`**`).\n+When `ecmaVersion` is set to 7, Acorn will parse the exponentiation operator (`**`).\n \n The identifier character ranges are now based on Unicode 8.0.0.\n \n-Plugins can now override the `raiseRecoverable` method to override the\n-way non-critical errors are handled.\n+Plugins can now override the `raiseRecoverable` method to override the way non-critical errors are handled.\n \n ## 2.7.0 (2016-01-04)\n \n ### Fixes\n \n Stop allowing rest parameters in setters.\n \n-Make sure the loose parser always attaches a `local` property to\n-`ImportNamespaceSpecifier` nodes.\n-\n Disallow `y` rexexp flag in ES5.\n \n Disallow `\\00` and `\\000` escapes in strict mode.\n \n Raise an error when an import name is a reserved word.\n \n-## 2.6.4 (2015-11-12)\n-\n-### Fixes\n-\n-Fix crash in loose parser when parsing invalid object pattern.\n-\n-### New features\n-\n-Support plugins in the loose parser.\n-\n ## 2.6.2 (2015-11-10)\n \n ### Fixes\n@@ -472,28 +481,17 @@ Forbid using a comma after a rest pattern in an array destructuring.\n \n Support parsing stdin in command-line tool.\n \n-## 2.5.2 (2015-10-27)\n-\n-### Fixes\n-\n-Fix bug where the walker walked an exported `let` statement as an\n-expression.\n-\n ## 2.5.0 (2015-10-27)\n \n ### Fixes\n \n Fix tokenizer support in the command-line tool.\n \n-In the loose parser, don't allow non-string-literals as import\n-sources.\n-\n Stop allowing `new.target` outside of functions.\n \n Remove legacy `guard` and `guardedHandler` properties from try nodes.\n \n-Stop allowing multiple `__proto__` properties on an object literal in\n-strict mode.\n+Stop allowing multiple `__proto__` properties on an object literal in strict mode.\n \n Don't allow rest parameters to be non-identifier patterns.\n ",
            "previous_filename": "deps/acorn/CHANGELOG.md"
        },
        {
            "sha": "2c0632b6a7c63bd701c60f1daa8b8fa9bea56a81",
            "filename": "deps/acorn/acorn/LICENSE",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2FLICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2FLICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2FLICENSE?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,19 @@\n+Copyright (C) 2012-2018 by various contributors (see AUTHORS)\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
        },
        {
            "sha": "9ffacdbc9e9552dd8f4c95441dac8738a0031cb9",
            "filename": "deps/acorn/acorn/README.md",
            "status": "added",
            "additions": 269,
            "deletions": 0,
            "changes": 269,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2FREADME.md?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,269 @@\n+# Acorn\n+\n+A tiny, fast JavaScript parser written in JavaScript.\n+\n+## Community\n+\n+Acorn is open source software released under an\n+[MIT license](https://github.com/acornjs/acorn/blob/master/acorn/LICENSE).\n+\n+You are welcome to\n+[report bugs](https://github.com/acornjs/acorn/issues) or create pull\n+requests on [github](https://github.com/acornjs/acorn). For questions\n+and discussion, please use the\n+[Tern discussion forum](https://discuss.ternjs.net).\n+\n+## Installation\n+\n+The easiest way to install acorn is from [`npm`](https://www.npmjs.com/):\n+\n+```sh\n+npm install acorn\n+```\n+\n+Alternately, you can download the source and build acorn yourself:\n+\n+```sh\n+git clone https://github.com/acornjs/acorn.git\n+cd acorn\n+npm install\n+```\n+\n+## Interface\n+\n+**parse**`(input, options)` is the main interface to the library. The\n+`input` parameter is a string, `options` can be undefined or an object\n+setting some of the options listed below. The return value will be an\n+abstract syntax tree object as specified by the [ESTree\n+spec](https://github.com/estree/estree).\n+\n+```javascript\n+let acorn = require(\"acorn\");\n+console.log(acorn.parse(\"1 + 1\"));\n+```\n+\n+When encountering a syntax error, the parser will raise a\n+`SyntaxError` object with a meaningful message. The error object will\n+have a `pos` property that indicates the string offset at which the\n+error occurred, and a `loc` object that contains a `{line, column}`\n+object referring to that same position.\n+\n+Options can be provided by passing a second argument, which should be\n+an object containing any of these fields:\n+\n+- **ecmaVersion**: Indicates the ECMAScript version to parse. Must be\n+  either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018) or 10 (2019, partial\n+  support). This influences support for strict mode, the set of\n+  reserved words, and support for new syntax features. Default is 7.\n+\n+  **NOTE**: Only 'stage 4' (finalized) ECMAScript features are being\n+  implemented by Acorn. Other proposed new features can be implemented\n+  through plugins.\n+\n+- **sourceType**: Indicate the mode the code should be parsed in. Can be\n+  either `\"script\"` or `\"module\"`. This influences global strict mode\n+  and parsing of `import` and `export` declarations.\n+\n+- **onInsertedSemicolon**: If given a callback, that callback will be\n+  called whenever a missing semicolon is inserted by the parser. The\n+  callback will be given the character offset of the point where the\n+  semicolon is inserted as argument, and if `locations` is on, also a\n+  `{line, column}` object representing this position.\n+\n+- **onTrailingComma**: Like `onInsertedSemicolon`, but for trailing\n+  commas.\n+\n+- **allowReserved**: If `false`, using a reserved word will generate\n+  an error. Defaults to `true` for `ecmaVersion` 3, `false` for higher\n+  versions. When given the value `\"never\"`, reserved words and\n+  keywords can also not be used as property names (as in Internet\n+  Explorer's old parser).\n+\n+- **allowReturnOutsideFunction**: By default, a return statement at\n+  the top level raises an error. Set this to `true` to accept such\n+  code.\n+\n+- **allowImportExportEverywhere**: By default, `import` and `export`\n+  declarations can only appear at a program's top level. Setting this\n+  option to `true` allows them anywhere where a statement is allowed.\n+\n+- **allowAwaitOutsideFunction**: By default, `await` expressions can\n+  only appear inside `async` functions. Setting this option to\n+  `true` allows to have top-level `await` expressions. They are\n+  still not allowed in non-`async` functions, though.\n+\n+- **allowHashBang**: When this is enabled (off by default), if the\n+  code starts with the characters `#!` (as in a shellscript), the\n+  first line will be treated as a comment.\n+\n+- **locations**: When `true`, each node has a `loc` object attached\n+  with `start` and `end` subobjects, each of which contains the\n+  one-based line and zero-based column numbers in `{line, column}`\n+  form. Default is `false`.\n+\n+- **onToken**: If a function is passed for this option, each found\n+  token will be passed in same format as tokens returned from\n+  `tokenizer().getToken()`.\n+\n+  If array is passed, each found token is pushed to it.\n+\n+  Note that you are not allowed to call the parser from the\n+  callback—that will corrupt its internal state.\n+\n+- **onComment**: If a function is passed for this option, whenever a\n+  comment is encountered the function will be called with the\n+  following parameters:\n+\n+  - `block`: `true` if the comment is a block comment, false if it\n+    is a line comment.\n+  - `text`: The content of the comment.\n+  - `start`: Character offset of the start of the comment.\n+  - `end`: Character offset of the end of the comment.\n+\n+  When the `locations` options is on, the `{line, column}` locations\n+  of the comment’s start and end are passed as two additional\n+  parameters.\n+\n+  If array is passed for this option, each found comment is pushed\n+  to it as object in Esprima format:\n+\n+  ```javascript\n+  {\n+    \"type\": \"Line\" | \"Block\",\n+    \"value\": \"comment text\",\n+    \"start\": Number,\n+    \"end\": Number,\n+    // If `locations` option is on:\n+    \"loc\": {\n+      \"start\": {line: Number, column: Number}\n+      \"end\": {line: Number, column: Number}\n+    },\n+    // If `ranges` option is on:\n+    \"range\": [Number, Number]\n+  }\n+  ```\n+\n+  Note that you are not allowed to call the parser from the\n+  callback—that will corrupt its internal state.\n+\n+- **ranges**: Nodes have their start and end characters offsets\n+  recorded in `start` and `end` properties (directly on the node,\n+  rather than the `loc` object, which holds line/column data. To also\n+  add a\n+  [semi-standardized](https://bugzilla.mozilla.org/show_bug.cgi?id=745678)\n+  `range` property holding a `[start, end]` array with the same\n+  numbers, set the `ranges` option to `true`.\n+\n+- **program**: It is possible to parse multiple files into a single\n+  AST by passing the tree produced by parsing the first file as the\n+  `program` option in subsequent parses. This will add the toplevel\n+  forms of the parsed file to the \"Program\" (top) node of an existing\n+  parse tree.\n+\n+- **sourceFile**: When the `locations` option is `true`, you can pass\n+  this option to add a `source` attribute in every node’s `loc`\n+  object. Note that the contents of this option are not examined or\n+  processed in any way; you are free to use whatever format you\n+  choose.\n+\n+- **directSourceFile**: Like `sourceFile`, but a `sourceFile` property\n+  will be added (regardless of the `location` option) directly to the\n+  nodes, rather than the `loc` object.\n+\n+- **preserveParens**: If this option is `true`, parenthesized expressions\n+  are represented by (non-standard) `ParenthesizedExpression` nodes\n+  that have a single `expression` property containing the expression\n+  inside parentheses.\n+\n+**parseExpressionAt**`(input, offset, options)` will parse a single\n+expression in a string, and return its AST. It will not complain if\n+there is more of the string left after the expression.\n+\n+**tokenizer**`(input, options)` returns an object with a `getToken`\n+method that can be called repeatedly to get the next token, a `{start,\n+end, type, value}` object (with added `loc` property when the\n+`locations` option is enabled and `range` property when the `ranges`\n+option is enabled). When the token's type is `tokTypes.eof`, you\n+should stop calling the method, since it will keep returning that same\n+token forever.\n+\n+In ES6 environment, returned result can be used as any other\n+protocol-compliant iterable:\n+\n+```javascript\n+for (let token of acorn.tokenizer(str)) {\n+  // iterate over the tokens\n+}\n+\n+// transform code to array of tokens:\n+var tokens = [...acorn.tokenizer(str)];\n+```\n+\n+**tokTypes** holds an object mapping names to the token type objects\n+that end up in the `type` properties of tokens.\n+\n+**getLineInfo**`(input, offset)` can be used to get a `{line,\n+column}` object for a given program string and offset.\n+\n+### The `Parser` class\n+\n+Instances of the **`Parser`** class contain all the state and logic\n+that drives a parse. It has static methods `parse`,\n+`parseExpressionAt`, and `tokenizer` that match the top-level\n+functions by the same name.\n+\n+When extending the parser with plugins, you need to call these methods\n+on the extended version of the class. To extend a parser with plugins,\n+you can use its static `extend` method.\n+\n+```javascript\n+var acorn = require(\"acorn\");\n+var jsx = require(\"acorn-jsx\");\n+var JSXParser = acorn.Parser.extend(jsx());\n+JSXParser.parse(\"foo(<bar/>)\");\n+```\n+\n+The `extend` method takes any number of plugin values, and returns a\n+new `Parser` class that includes the extra parser logic provided by\n+the plugins.\n+\n+## Command line interface\n+\n+The `bin/acorn` utility can be used to parse a file from the command\n+line. It accepts as arguments its input file and the following\n+options:\n+\n+- `--ecma3|--ecma5|--ecma6|--ecma7|--ecma8|--ecma9|--ecma10`: Sets the ECMAScript version\n+  to parse. Default is version 9.\n+\n+- `--module`: Sets the parsing mode to `\"module\"`. Is set to `\"script\"` otherwise.\n+\n+- `--locations`: Attaches a \"loc\" object to each node with \"start\" and\n+  \"end\" subobjects, each of which contains the one-based line and\n+  zero-based column numbers in `{line, column}` form.\n+\n+- `--allow-hash-bang`: If the code starts with the characters #! (as\n+  in a shellscript), the first line will be treated as a comment.\n+\n+- `--compact`: No whitespace is used in the AST output.\n+\n+- `--silent`: Do not output the AST, just return the exit status.\n+\n+- `--help`: Print the usage information and quit.\n+\n+The utility spits out the syntax tree as JSON data.\n+\n+## Existing plugins\n+\n+ - [`acorn-jsx`](https://github.com/RReverser/acorn-jsx): Parse [Facebook JSX syntax extensions](https://github.com/facebook/jsx)\n+\n+Plugins for ECMAScript proposals:\n+\n+ - [`acorn-stage3`](https://github.com/acornjs/acorn-stage3): Parse most stage 3 proposals, bundling:\n+   - [`acorn-async-iteration`](https://github.com/acornjs/acorn-async-iteration): Parse [async iteration proposal](https://github.com/tc39/proposal-async-iteration)\n+   - [`acorn-bigint`](https://github.com/acornjs/acorn-bigint): Parse [BigInt proposal](https://github.com/tc39/proposal-bigint)\n+   - [`acorn-class-fields`](https://github.com/acornjs/acorn-class-fields): Parse [class fields proposal](https://github.com/tc39/proposal-class-fields)\n+   - [`acorn-dynamic-import`](https://github.com/kesne/acorn-dynamic-import): Parse [import() proposal](https://github.com/tc39/proposal-dynamic-import)\n+   - [`acorn-import-meta`](https://github.com/acornjs/acorn-import-meta): Parse [import.meta proposal](https://github.com/tc39/proposal-import-meta)\n+   - [`acorn-numeric-separator`](https://github.com/acornjs/acorn-numeric-separator): Parse [numeric separator proposal](https://github.com/tc39/proposal-numeric-separator)\n+   - [`acorn-private-methods`](https://github.com/acornjs/acorn-private-methods): parse [private methods, getters and setters proposal](https://github.com/tc39/proposal-private-methods)n"
        },
        {
            "sha": "cf7df46890fdd48bbaa57fb0478c142bc4409f21",
            "filename": "deps/acorn/acorn/bin/acorn",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fbin%2Facorn",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fbin%2Facorn",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fbin%2Facorn?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -1,4 +1,4 @@\n #!/usr/bin/env node\n 'use strict';\n \n-require('./_acorn.js');\n+require('../dist/bin.js');",
            "previous_filename": "deps/acorn/bin/acorn"
        },
        {
            "sha": "c6f9841b809a48230b694d0e36295c73c6390e53",
            "filename": "deps/acorn/acorn/dist/acorn.d.ts",
            "status": "added",
            "additions": 209,
            "deletions": 0,
            "changes": 209,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.d.ts",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.d.ts",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.d.ts?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,209 @@\n+export as namespace acorn\n+export = acorn\n+\n+declare namespace acorn {\n+  function parse(input: string, options?: Options): Node\n+\n+  function parseExpressionAt(input: string, pos?: number, options?: Options): Node\n+\n+  function tokenizer(input: string, options?: Options): {\n+    getToken(): Token\n+    [Symbol.iterator](): Iterator<Token>\n+  }\n+\n+  interface Options {\n+    ecmaVersion?: 3 | 5 | 6 | 7 | 8 | 9 | 10 | 2015 | 2016 | 2017 | 2018 | 2019\n+    sourceType?: 'script' | 'module'\n+    onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void\n+    onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void\n+    allowReserved?: boolean\n+    allowReturnOutsideFunction?: boolean\n+    allowImportExportEverywhere?: boolean\n+    allowAwaitOutsideFunction?: boolean\n+    allowHashBang?: boolean\n+    locations?: boolean\n+    onToken?: ((token: Token) => any) | Token[]\n+    onComment?: ((\n+      isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,\n+      endLoc?: Position\n+    ) => void) | Comment[]\n+    ranges?: boolean\n+    program?: Node\n+    sourceFile?: string\n+    directSourceFile?: string\n+    preserveParens?: boolean\n+  }\n+\n+  class Parser {\n+    constructor(options: Options, input: string, startPos?: number)\n+    parse(): Node\n+    static parse(input: string, options?: Options): Node\n+    static parseExpressionAt(input: string, pos: number, options?: Options): Node\n+    static tokenizer(input: string, options?: Options): {\n+      getToken(): Token\n+      [Symbol.iterator](): Iterator<Token>\n+    }\n+    static extend(...plugins: ((BaseParser: typeof Parser) => typeof Parser)[]): typeof Parser\n+  }\n+\n+  interface Position { line: number; column: number; offset: number }\n+\n+  const defaultOptions: Options\n+\n+  function getLineInfo(input: string, offset: number): Position\n+\n+  class SourceLocation {\n+    start: Position\n+    end: Position\n+    source?: string | null\n+    constructor(p: Parser, start: Position, end: Position)\n+  }\n+\n+  class Node {\n+    type: string\n+    start: number\n+    end: number\n+    loc?: SourceLocation\n+    sourceFile?: string\n+    range?: [number, number]\n+    constructor(parser: Parser, pos: number, loc?: SourceLocation)\n+  }\n+\n+  class TokenType {\n+    label: string\n+    keyword: string\n+    beforeExpr: boolean\n+    startsExpr: boolean\n+    isLoop: boolean\n+    isAssign: boolean\n+    prefix: boolean\n+    postfix: boolean\n+    binop: number\n+    updateContext?: (prevType: TokenType) => void\n+    constructor(label: string, conf?: any)\n+  }\n+\n+  const tokTypes: {\n+    num: TokenType\n+    regexp: TokenType\n+    string: TokenType\n+    name: TokenType\n+    eof: TokenType\n+    bracketL: TokenType\n+    bracketR: TokenType\n+    braceL: TokenType\n+    braceR: TokenType\n+    parenL: TokenType\n+    parenR: TokenType\n+    comma: TokenType\n+    semi: TokenType\n+    colon: TokenType\n+    dot: TokenType\n+    question: TokenType\n+    arrow: TokenType\n+    template: TokenType\n+    ellipsis: TokenType\n+    backQuote: TokenType\n+    dollarBraceL: TokenType\n+    eq: TokenType\n+    assign: TokenType\n+    incDec: TokenType\n+    prefix: TokenType\n+    logicalOR: TokenType\n+    logicalAND: TokenType\n+    bitwiseOR: TokenType\n+    bitwiseXOR: TokenType\n+    bitwiseAND: TokenType\n+    equality: TokenType\n+    relational: TokenType\n+    bitShift: TokenType\n+    plusMin: TokenType\n+    modulo: TokenType\n+    star: TokenType\n+    slash: TokenType\n+    starstar: TokenType\n+    _break: TokenType\n+    _case: TokenType\n+    _catch: TokenType\n+    _continue: TokenType\n+    _debugger: TokenType\n+    _default: TokenType\n+    _do: TokenType\n+    _else: TokenType\n+    _finally: TokenType\n+    _for: TokenType\n+    _function: TokenType\n+    _if: TokenType\n+    _return: TokenType\n+    _switch: TokenType\n+    _throw: TokenType\n+    _try: TokenType\n+    _var: TokenType\n+    _const: TokenType\n+    _while: TokenType\n+    _with: TokenType\n+    _new: TokenType\n+    _this: TokenType\n+    _super: TokenType\n+    _class: TokenType\n+    _extends: TokenType\n+    _export: TokenType\n+    _import: TokenType\n+    _null: TokenType\n+    _true: TokenType\n+    _false: TokenType\n+    _in: TokenType\n+    _instanceof: TokenType\n+    _typeof: TokenType\n+    _void: TokenType\n+    _delete: TokenType\n+  }\n+\n+  class TokContext {\n+    constructor(token: string, isExpr: boolean, preserveSpace: boolean, override?: (p: Parser) => void)\n+  }\n+\n+  const tokContexts: {\n+    b_stat: TokContext\n+    b_expr: TokContext\n+    b_tmpl: TokContext\n+    p_stat: TokContext\n+    p_expr: TokContext\n+    q_tmpl: TokContext\n+    f_expr: TokContext\n+  }\n+\n+  function isIdentifierStart(code: number, astral?: boolean): boolean\n+\n+  function isIdentifierChar(code: number, astral?: boolean): boolean\n+\n+  interface AbstractToken {\n+  }\n+\n+  interface Comment extends AbstractToken {\n+    type: string\n+    value: string\n+    start: number\n+    end: number\n+    loc?: SourceLocation\n+    range?: [number, number]\n+  }\n+\n+  class Token {\n+    type: TokenType\n+    value: any\n+    start: number\n+    end: number\n+    loc?: SourceLocation\n+    range?: [number, number]\n+    constructor(p: Parser)\n+  }\n+\n+  function isNewLine(code: number): boolean\n+\n+  const lineBreak: RegExp\n+\n+  const lineBreakG: RegExp\n+\n+  const version: string\n+}"
        },
        {
            "sha": "913c072e1e00874a5d2e700cbb335b86098ab9d2",
            "filename": "deps/acorn/acorn/dist/acorn.js",
            "status": "renamed",
            "additions": 410,
            "deletions": 742,
            "changes": 1152,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -254,7 +254,7 @@ function isNewLine(code, ecma2019String) {\n   return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n }\n \n-var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n+var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n \n var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n \n@@ -272,6 +272,10 @@ var isArray = Array.isArray || (function (obj) { return (\n   toString.call(obj) === \"[object Array]\"\n ); });\n \n+function wordsRegexp(words) {\n+  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n+}\n+\n // These are used when `options.locations` is on, for the\n // `startLoc` and `endLoc` properties.\n \n@@ -313,18 +317,19 @@ function getLineInfo(input, offset) {\n // the parser process. These options are recognized:\n \n var defaultOptions = {\n-  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n-  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n-  // for strict mode, the set of reserved words, and support for\n-  // new syntax features. The default is 7.\n-  ecmaVersion: 7,\n+  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n+  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n+  // (2019). This influences support for strict mode, the set of\n+  // reserved words, and support for new syntax features. The default\n+  // is 9.\n+  ecmaVersion: 9,\n   // `sourceType` indicates the mode the code should be parsed in.\n   // Can be either `\"script\"` or `\"module\"`. This influences global\n   // strict mode and parsing of `import` and `export` declarations.\n   sourceType: \"script\",\n   // `onInsertedSemicolon` can be a callback that will be called\n   // when a semicolon is automatically inserted. It will be passed\n-  // th position of the comma as an offset, and if `locations` is\n+  // the position of the comma as an offset, and if `locations` is\n   // enabled, it is given the location as a `{line, column}` object\n   // as second argument.\n   onInsertedSemicolon: null,\n@@ -393,8 +398,7 @@ var defaultOptions = {\n   directSourceFile: null,\n   // When enabled, parenthesized expressions are represented by\n   // (non-standard) ParenthesizedExpression nodes\n-  preserveParens: false,\n-  plugins: {}\n+  preserveParens: false\n };\n \n // Interpret and default an options object\n@@ -437,37 +441,50 @@ function pushComment(options, array) {\n   }\n }\n \n-// Registered plugins\n-var plugins = {};\n-\n-function keywordRegexp(words) {\n-  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n+// Each scope gets a bitset that may contain these flags\n+var SCOPE_TOP = 1;\n+var SCOPE_FUNCTION = 2;\n+var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;\n+var SCOPE_ASYNC = 4;\n+var SCOPE_GENERATOR = 8;\n+var SCOPE_ARROW = 16;\n+var SCOPE_SIMPLE_CATCH = 32;\n+var SCOPE_SUPER = 64;\n+var SCOPE_DIRECT_SUPER = 128;\n+\n+function functionFlags(async, generator) {\n+  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n }\n \n+// Used in checkLVal and declareName to determine the type of a binding\n+var BIND_NONE = 0;\n+var BIND_VAR = 1;\n+var BIND_LEXICAL = 2;\n+var BIND_FUNCTION = 3;\n+var BIND_SIMPLE_CATCH = 4;\n+var BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n+\n var Parser = function Parser(options, input, startPos) {\n   this.options = options = getOptions(options);\n   this.sourceFile = options.sourceFile;\n-  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n+  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n   var reserved = \"\";\n   if (!options.allowReserved) {\n     for (var v = options.ecmaVersion;; v--)\n       { if (reserved = reservedWords[v]) { break } }\n     if (options.sourceType === \"module\") { reserved += \" await\"; }\n   }\n-  this.reservedWords = keywordRegexp(reserved);\n+  this.reservedWords = wordsRegexp(reserved);\n   var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n-  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n-  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n+  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n+  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n   this.input = String(input);\n \n   // Used to signal to callers of `readWord1` whether the word\n   // contained any escape sequences. This is needed because words with\n   // escape sequences must not be interpreted as keywords.\n   this.containsEsc = false;\n \n-  // Load plugins\n-  this.loadPlugins(options.plugins);\n-\n   // Set up token state\n \n   // The current position of the tokenizer in the input.\n@@ -508,64 +525,90 @@ var Parser = function Parser(options, input, startPos) {\n   // Used to signify the start of a potential arrow function\n   this.potentialArrowAt = -1;\n \n-  // Flags to track whether we are in a function, a generator, an async function.\n-  this.inFunction = this.inGenerator = this.inAsync = false;\n   // Positions to delayed-check that yield/await does not exist in default parameters.\n-  this.yieldPos = this.awaitPos = 0;\n+  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n   // Labels in scope.\n   this.labels = [];\n+  // Thus-far undefined exports.\n+  this.undefinedExports = {};\n \n   // If enabled, skip leading hashbang line.\n   if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n     { this.skipLineComment(2); }\n \n   // Scope tracking for duplicate variable names (see scope.js)\n   this.scopeStack = [];\n-  this.enterFunctionScope();\n+  this.enterScope(SCOPE_TOP);\n \n   // For RegExp validation\n   this.regexpState = null;\n };\n \n-// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n-Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\n-Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n+var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n \n-Parser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n+Parser.prototype.parse = function parse () {\n+  var node = this.options.program || this.startNode();\n+  this.nextToken();\n+  return this.parseTopLevel(node)\n };\n \n-Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n+prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n+prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n+prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n+prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n+prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n+prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n \n-  for (var name in pluginConfigs) {\n-    var plugin = plugins[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n+// Switch to a getter for 7.0.0.\n+Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n+\n+Parser.extend = function extend () {\n+    var plugins = [], len = arguments.length;\n+    while ( len-- ) plugins[ len ] = arguments[ len ];\n+\n+  var cls = this;\n+  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n+  return cls\n };\n \n-Parser.prototype.parse = function parse () {\n-  var node = this.options.program || this.startNode();\n-  this.nextToken();\n-  return this.parseTopLevel(node)\n+Parser.parse = function parse (input, options) {\n+  return new this(options, input).parse()\n+};\n+\n+Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n+  var parser = new this(options, input, pos);\n+  parser.nextToken();\n+  return parser.parseExpression()\n };\n \n+Parser.tokenizer = function tokenizer (input, options) {\n+  return new this(options, input)\n+};\n+\n+Object.defineProperties( Parser.prototype, prototypeAccessors );\n+\n var pp = Parser.prototype;\n \n // ## Parser utilities\n \n-var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\n+var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n pp.strictDirective = function(start) {\n   var this$1 = this;\n \n   for (;;) {\n+    // Try to find string literal.\n     skipWhiteSpace.lastIndex = start;\n     start += skipWhiteSpace.exec(this$1.input)[0].length;\n     var match = literal.exec(this$1.input.slice(start));\n     if (!match) { return false }\n     if ((match[1] || match[2]) === \"use strict\") { return true }\n     start += match[0].length;\n+\n+    // Skip semicolon, if any.\n+    skipWhiteSpace.lastIndex = start;\n+    start += skipWhiteSpace.exec(this$1.input)[0].length;\n+    if (this$1.input[start] === ';')\n+      { start++; }\n   }\n };\n \n@@ -703,9 +746,16 @@ pp$1.parseTopLevel = function(node) {\n   var exports = {};\n   if (!node.body) { node.body = []; }\n   while (this.type !== types.eof) {\n-    var stmt = this$1.parseStatement(true, true, exports);\n+    var stmt = this$1.parseStatement(null, true, exports);\n     node.body.push(stmt);\n   }\n+  if (this.inModule)\n+    { for (var i = 0, list = Object.keys(this$1.undefinedExports); i < list.length; i += 1)\n+      {\n+        var name = list[i];\n+\n+        this$1.raiseRecoverable(this$1.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n+      } }\n   this.adaptDirectivePrologue(node.body);\n   this.next();\n   if (this.options.ecmaVersion >= 6) {\n@@ -717,12 +767,19 @@ pp$1.parseTopLevel = function(node) {\n var loopLabel = {kind: \"loop\"};\n var switchLabel = {kind: \"switch\"};\n \n-pp$1.isLet = function() {\n+pp$1.isLet = function(context) {\n   if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n   skipWhiteSpace.lastIndex = this.pos;\n   var skip = skipWhiteSpace.exec(this.input);\n   var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n-  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\n+  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n+  // Statement) is allowed here. If context is not empty then only a Statement\n+  // is allowed. However, `let [` is an explicit negative lookahead for\n+  // ExpressionStatement, so special-case it first.\n+  if (nextCh === 91) { return true } // '['\n+  if (context) { return false }\n+\n+  if (nextCh === 123) { return true } // '{'\n   if (isIdentifierStart(nextCh, true)) {\n     var pos = next + 1;\n     while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n@@ -754,10 +811,10 @@ pp$1.isAsyncFunction = function() {\n // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n // does not help.\n \n-pp$1.parseStatement = function(declaration, topLevel, exports) {\n+pp$1.parseStatement = function(context, topLevel, exports) {\n   var starttype = this.type, node = this.startNode(), kind;\n \n-  if (this.isLet()) {\n+  if (this.isLet(context)) {\n     starttype = types._var;\n     kind = \"let\";\n   }\n@@ -772,10 +829,13 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._do: return this.parseDoStatement(node)\n   case types._for: return this.parseForStatement(node)\n   case types._function:\n-    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n-    return this.parseFunctionStatement(node, false)\n+    // Function as sole body of either an if statement or a labeled statement\n+    // works, but not when it is part of a labeled statement that is the sole\n+    // body of an if statement.\n+    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n+    return this.parseFunctionStatement(node, false, !context)\n   case types._class:\n-    if (!declaration) { this.unexpected(); }\n+    if (context) { this.unexpected(); }\n     return this.parseClass(node, true)\n   case types._if: return this.parseIfStatement(node)\n   case types._return: return this.parseReturnStatement(node)\n@@ -784,11 +844,11 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._try: return this.parseTryStatement(node)\n   case types._const: case types._var:\n     kind = kind || this.value;\n-    if (!declaration && kind !== \"var\") { this.unexpected(); }\n+    if (context && kind !== \"var\") { this.unexpected(); }\n     return this.parseVarStatement(node, kind)\n   case types._while: return this.parseWhileStatement(node)\n   case types._with: return this.parseWithStatement(node)\n-  case types.braceL: return this.parseBlock()\n+  case types.braceL: return this.parseBlock(true, node)\n   case types.semi: return this.parseEmptyStatement(node)\n   case types._export:\n   case types._import:\n@@ -807,14 +867,14 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n     // Identifier node, we switch to interpreting it as a label.\n   default:\n     if (this.isAsyncFunction()) {\n-      if (!declaration) { this.unexpected(); }\n+      if (context) { this.unexpected(); }\n       this.next();\n-      return this.parseFunctionStatement(node, true)\n+      return this.parseFunctionStatement(node, true, !context)\n     }\n \n     var maybeName = this.value, expr = this.parseExpression();\n     if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n-      { return this.parseLabeledStatement(node, maybeName, expr) }\n+      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n     else { return this.parseExpressionStatement(node, expr) }\n   }\n };\n@@ -854,7 +914,7 @@ pp$1.parseDebuggerStatement = function(node) {\n pp$1.parseDoStatement = function(node) {\n   this.next();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"do\");\n   this.labels.pop();\n   this.expect(types._while);\n   node.test = this.parseParenExpression();\n@@ -877,7 +937,7 @@ pp$1.parseForStatement = function(node) {\n   this.next();\n   var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n   this.labels.push(loopLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n   this.expect(types.parenL);\n   if (this.type === types.semi) {\n     if (awaitAt > -1) { this.unexpected(awaitAt); }\n@@ -919,17 +979,17 @@ pp$1.parseForStatement = function(node) {\n   return this.parseFor(node, init)\n };\n \n-pp$1.parseFunctionStatement = function(node, isAsync) {\n+pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n   this.next();\n-  return this.parseFunction(node, true, false, isAsync)\n+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n };\n \n pp$1.parseIfStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   // allow function declarations in branches, but only in non-strict mode\n-  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n-  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n+  node.consequent = this.parseStatement(\"if\");\n+  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n   return this.finishNode(node, \"IfStatement\")\n };\n \n@@ -955,7 +1015,7 @@ pp$1.parseSwitchStatement = function(node) {\n   node.cases = [];\n   this.expect(types.braceL);\n   this.labels.push(switchLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n \n   // Statements under must be grouped (by label) in SwitchCase\n   // nodes. `cur` is used to keep the node that we are currently\n@@ -979,10 +1039,10 @@ pp$1.parseSwitchStatement = function(node) {\n       this$1.expect(types.colon);\n     } else {\n       if (!cur) { this$1.unexpected(); }\n-      cur.consequent.push(this$1.parseStatement(true));\n+      cur.consequent.push(this$1.parseStatement(null));\n     }\n   }\n-  this.exitLexicalScope();\n+  this.exitScope();\n   if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n   this.next(); // Closing brace\n   this.labels.pop();\n@@ -1011,16 +1071,17 @@ pp$1.parseTryStatement = function(node) {\n     this.next();\n     if (this.eat(types.parenL)) {\n       clause.param = this.parseBindingAtom();\n-      this.enterLexicalScope();\n-      this.checkLVal(clause.param, \"let\");\n+      var simple = clause.param.type === \"Identifier\";\n+      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n+      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n       this.expect(types.parenR);\n     } else {\n       if (this.options.ecmaVersion < 10) { this.unexpected(); }\n       clause.param = null;\n-      this.enterLexicalScope();\n+      this.enterScope(0);\n     }\n     clause.body = this.parseBlock(false);\n-    this.exitLexicalScope();\n+    this.exitScope();\n     node.handler = this.finishNode(clause, \"CatchClause\");\n   }\n   node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n@@ -1040,7 +1101,7 @@ pp$1.parseWhileStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"while\");\n   this.labels.pop();\n   return this.finishNode(node, \"WhileStatement\")\n };\n@@ -1049,7 +1110,7 @@ pp$1.parseWithStatement = function(node) {\n   if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n   this.next();\n   node.object = this.parseParenExpression();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"with\");\n   return this.finishNode(node, \"WithStatement\")\n };\n \n@@ -1058,7 +1119,7 @@ pp$1.parseEmptyStatement = function(node) {\n   return this.finishNode(node, \"EmptyStatement\")\n };\n \n-pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n+pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n   var this$1 = this;\n \n   for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n@@ -1078,11 +1139,7 @@ pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n     } else { break }\n   }\n   this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n-  node.body = this.parseStatement(true);\n-  if (node.body.type === \"ClassDeclaration\" ||\n-      node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n-      node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n-    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n+  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n   this.labels.pop();\n   node.label = expr;\n   return this.finishNode(node, \"LabeledStatement\")\n@@ -1098,23 +1155,19 @@ pp$1.parseExpressionStatement = function(node, expr) {\n // strict\"` declarations when `allowStrict` is true (used for\n // function bodies).\n \n-pp$1.parseBlock = function(createNewLexicalScope) {\n+pp$1.parseBlock = function(createNewLexicalScope, node) {\n   var this$1 = this;\n   if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n+  if ( node === void 0 ) node = this.startNode();\n \n-  var node = this.startNode();\n   node.body = [];\n   this.expect(types.braceL);\n-  if (createNewLexicalScope) {\n-    this.enterLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.enterScope(0); }\n   while (!this.eat(types.braceR)) {\n-    var stmt = this$1.parseStatement(true);\n+    var stmt = this$1.parseStatement(null);\n     node.body.push(stmt);\n   }\n-  if (createNewLexicalScope) {\n-    this.exitLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.exitScope(); }\n   return this.finishNode(node, \"BlockStatement\")\n };\n \n@@ -1129,8 +1182,8 @@ pp$1.parseFor = function(node, init) {\n   this.expect(types.semi);\n   node.update = this.type === types.parenR ? null : this.parseExpression();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"for\");\n+  this.exitScope();\n   this.labels.pop();\n   return this.finishNode(node, \"ForStatement\")\n };\n@@ -1150,8 +1203,8 @@ pp$1.parseForIn = function(node, init) {\n   node.left = init;\n   node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"for\");\n+  this.exitScope();\n   this.labels.pop();\n   return this.finishNode(node, type)\n };\n@@ -1182,48 +1235,57 @@ pp$1.parseVar = function(node, isFor, kind) {\n };\n \n pp$1.parseVarId = function(decl, kind) {\n-  decl.id = this.parseBindingAtom(kind);\n-  this.checkLVal(decl.id, kind, false);\n+  if ((kind === \"const\" || kind === \"let\") && this.isContextual(\"let\")) {\n+    this.raiseRecoverable(this.start, \"let is disallowed as a lexically bound name\");\n+  }\n+  decl.id = this.parseBindingAtom();\n+  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n };\n \n+var FUNC_STATEMENT = 1;\n+var FUNC_HANGING_STATEMENT = 2;\n+var FUNC_NULLABLE_ID = 4;\n+\n // Parse a function declaration or literal (depending on the\n-// `isStatement` parameter).\n+// `statement & FUNC_STATEMENT`).\n \n-pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n+// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n+pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n   this.initFunction(node);\n-  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n-    { node.generator = this.eat(types.star); }\n+  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n+    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n+      { this.unexpected(); }\n+    node.generator = this.eat(types.star);\n+  }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  if (isStatement) {\n-    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n-    if (node.id) {\n-      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n-    }\n+  if (statement & FUNC_STATEMENT) {\n+    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n+    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n+      // If it is a regular function declaration in sloppy mode, then it is\n+      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n+      // mode depends on properties of the current scope (see\n+      // treatFunctionsAsVar).\n+      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n   }\n \n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.awaitIdentPos = 0;\n+  this.enterScope(functionFlags(node.async, node.generator));\n \n-  if (!isStatement)\n+  if (!(statement & FUNC_STATEMENT))\n     { node.id = this.type === types.name ? this.parseIdent() : null; }\n \n   this.parseFunctionParams(node);\n-  this.parseFunctionBody(node, allowExpressionBody);\n+  this.parseFunctionBody(node, allowExpressionBody, false);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n+  this.awaitIdentPos = oldAwaitIdentPos;\n+  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n };\n \n pp$1.parseFunctionParams = function(node) {\n@@ -1240,24 +1302,33 @@ pp$1.parseClass = function(node, isStatement) {\n \n   this.next();\n \n+  // ecma-262 14.6 Class Definitions\n+  // A class definition is always strict mode code.\n+  var oldStrict = this.strict;\n+  this.strict = true;\n+\n   this.parseClassId(node, isStatement);\n   this.parseClassSuper(node);\n   var classBody = this.startNode();\n   var hadConstructor = false;\n   classBody.body = [];\n   this.expect(types.braceL);\n   while (!this.eat(types.braceR)) {\n-    var member = this$1.parseClassMember(classBody);\n-    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n-      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n-      hadConstructor = true;\n+    var element = this$1.parseClassElement(node.superClass !== null);\n+    if (element) {\n+      classBody.body.push(element);\n+      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n+        if (hadConstructor) { this$1.raise(element.start, \"Duplicate constructor in the same class\"); }\n+        hadConstructor = true;\n+      }\n     }\n   }\n   node.body = this.finishNode(classBody, \"ClassBody\");\n+  this.strict = oldStrict;\n   return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n };\n \n-pp$1.parseClassMember = function(classBody) {\n+pp$1.parseClassElement = function(constructorAllowsSuper) {\n   var this$1 = this;\n \n   if (this.eat(types.semi)) { return null }\n@@ -1293,16 +1364,18 @@ pp$1.parseClassMember = function(classBody) {\n   }\n   if (!method.key) { this.parsePropertyName(method); }\n   var key = method.key;\n+  var allowsDirectSuper = false;\n   if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n       key.type === \"Literal\" && key.value === \"constructor\")) {\n     if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n     if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n     if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n     method.kind = \"constructor\";\n+    allowsDirectSuper = constructorAllowsSuper;\n   } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n     this.raise(key.start, \"Classes may not have a static property named prototype\");\n   }\n-  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n+  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n   if (method.kind === \"get\" && method.value.params.length !== 0)\n     { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n   if (method.kind === \"set\" && method.value.params.length !== 1)\n@@ -1312,13 +1385,21 @@ pp$1.parseClassMember = function(classBody) {\n   return method\n };\n \n-pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n-  method.value = this.parseMethod(isGenerator, isAsync);\n-  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n+pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n+  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n+  return this.finishNode(method, \"MethodDefinition\")\n };\n \n pp$1.parseClassId = function(node, isStatement) {\n-  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n+  if (this.type === types.name) {\n+    node.id = this.parseIdent();\n+    if (isStatement === true)\n+      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n+  } else {\n+    if (isStatement === true)\n+      { this.unexpected(); }\n+    node.id = null;\n+  }\n };\n \n pp$1.parseClassSuper = function(node) {\n@@ -1346,7 +1427,7 @@ pp$1.parseExport = function(node, exports) {\n       var fNode = this.startNode();\n       this.next();\n       if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n     } else if (this.type === types._class) {\n       var cNode = this.startNode();\n       node.declaration = this.parseClass(cNode, \"nullableID\");\n@@ -1358,7 +1439,7 @@ pp$1.parseExport = function(node, exports) {\n   }\n   // export var|const|let|function|class ...\n   if (this.shouldParseExportStatement()) {\n-    node.declaration = this.parseStatement(true);\n+    node.declaration = this.parseStatement(null);\n     if (node.declaration.type === \"VariableDeclaration\")\n       { this.checkVariableExport(exports, node.declaration.declarations); }\n     else\n@@ -1372,11 +1453,13 @@ pp$1.parseExport = function(node, exports) {\n       if (this.type !== types.string) { this.unexpected(); }\n       node.source = this.parseExprAtom();\n     } else {\n-      // check for keywords used as local names\n       for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n+        // check for keywords used as local names\n         var spec = list[i];\n \n         this$1.checkUnreserved(spec.local);\n+        // check if export is defined\n+        this$1.checkLocalExport(spec.local);\n       }\n \n       node.source = null;\n@@ -1493,7 +1576,7 @@ pp$1.parseImportSpecifiers = function() {\n     // import defaultObj, { x, y as z } from '...'\n     var node = this.startNode();\n     node.local = this.parseIdent();\n-    this.checkLVal(node.local, \"let\");\n+    this.checkLVal(node.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n     if (!this.eat(types.comma)) { return nodes }\n   }\n@@ -1502,7 +1585,7 @@ pp$1.parseImportSpecifiers = function() {\n     this.next();\n     this.expectContextual(\"as\");\n     node$1.local = this.parseIdent();\n-    this.checkLVal(node$1.local, \"let\");\n+    this.checkLVal(node$1.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n     return nodes\n   }\n@@ -1521,7 +1604,7 @@ pp$1.parseImportSpecifiers = function() {\n       this$1.checkUnreserved(node$2.imported);\n       node$2.local = node$2.imported;\n     }\n-    this$1.checkLVal(node$2.local, \"let\");\n+    this$1.checkLVal(node$2.local, BIND_LEXICAL);\n     nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n   }\n   return nodes\n@@ -1555,7 +1638,7 @@ pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n     switch (node.type) {\n     case \"Identifier\":\n       if (this.inAsync && node.name === \"await\")\n-        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n+        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n       break\n \n     case \"ObjectPattern\":\n@@ -1614,7 +1697,7 @@ pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n       break\n \n     case \"ParenthesizedExpression\":\n-      this.toAssignable(node.expression, isBinding);\n+      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n       break\n \n     case \"MemberExpression\":\n@@ -1736,6 +1819,7 @@ pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n \n pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n   var this$1 = this;\n+  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n \n   switch (expr.type) {\n   case \"Identifier\":\n@@ -1746,19 +1830,7 @@ pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n         { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n       checkClashes[expr.name] = true;\n     }\n-    if (bindingType && bindingType !== \"none\") {\n-      if (\n-        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n-        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n-      ) {\n-        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n-      }\n-      if (bindingType === \"var\") {\n-        this.declareVarName(expr.name);\n-      } else {\n-        this.declareLexicalName(expr.name);\n-      }\n-    }\n+    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n     break\n \n   case \"MemberExpression\":\n@@ -1907,13 +1979,19 @@ pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n // operators like `+=`.\n \n pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n-  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n+  if (this.isContextual(\"yield\")) {\n+    if (this.inGenerator) { return this.parseYield(noIn) }\n+    // The tokenizer will assume an expression is allowed after\n+    // `yield`, but this isn't that kind of yield\n+    else { this.exprAllowed = false; }\n+  }\n \n-  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n   if (refDestructuringErrors) {\n     oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n     oldTrailingComma = refDestructuringErrors.trailingComma;\n-    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n+    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n+    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n   } else {\n     refDestructuringErrors = new DestructuringErrors;\n     ownDestructuringErrors = true;\n@@ -1939,6 +2017,7 @@ pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n   }\n   if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n   if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n+  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n   return left\n };\n \n@@ -2069,20 +2148,25 @@ pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n       if (computed) { this$1.expect(types.bracketR); }\n       base = this$1.finishNode(node, \"MemberExpression\");\n     } else if (!noCalls && this$1.eat(types.parenL)) {\n-      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n+      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos, oldAwaitIdentPos = this$1.awaitIdentPos;\n       this$1.yieldPos = 0;\n       this$1.awaitPos = 0;\n+      this$1.awaitIdentPos = 0;\n       var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n       if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n         this$1.checkPatternErrors(refDestructuringErrors, false);\n         this$1.checkYieldAwaitInDefaultParams();\n+        if (this$1.awaitIdentPos > 0)\n+          { this$1.raise(this$1.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n         this$1.yieldPos = oldYieldPos;\n         this$1.awaitPos = oldAwaitPos;\n+        this$1.awaitIdentPos = oldAwaitIdentPos;\n         return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n       }\n       this$1.checkExpressionErrors(refDestructuringErrors, true);\n       this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n       this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n+      this$1.awaitIdentPos = oldAwaitIdentPos || this$1.awaitIdentPos;\n       var node$1 = this$1.startNodeAt(startPos, startLoc);\n       node$1.callee = base;\n       node$1.arguments = exprList;\n@@ -2104,13 +2188,19 @@ pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n // or `{}`.\n \n pp$3.parseExprAtom = function(refDestructuringErrors) {\n+  // If a division operator appears in an expression position, the\n+  // tokenizer got confused, and we force it to read a regexp instead.\n+  if (this.type === types.slash) { this.readRegexp(); }\n+\n   var node, canBeArrow = this.potentialArrowAt === this.start;\n   switch (this.type) {\n   case types._super:\n-    if (!this.inFunction)\n-      { this.raise(this.start, \"'super' outside of function or class\"); }\n+    if (!this.allowSuper)\n+      { this.raise(this.start, \"'super' keyword outside a method\"); }\n     node = this.startNode();\n     this.next();\n+    if (this.type === types.parenL && !this.allowDirectSuper)\n+      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n     // The `super` keyword can appear at below:\n     // SuperProperty:\n     //     super [ Expression ]\n@@ -2128,14 +2218,14 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n \n   case types.name:\n     var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n-    var id = this.parseIdent(this.type !== types.name);\n+    var id = this.parseIdent(false);\n     if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n-      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n+      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n     if (canBeArrow && !this.canInsertSemicolon()) {\n       if (this.eat(types.arrow))\n         { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n       if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n-        id = this.parseIdent();\n+        id = this.parseIdent(false);\n         if (this.canInsertSemicolon() || !this.eat(types.arrow))\n           { this.unexpected(); }\n         return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n@@ -2181,7 +2271,7 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n   case types._function:\n     node = this.startNode();\n     this.next();\n-    return this.parseFunction(node, false)\n+    return this.parseFunction(node, 0)\n \n   case types._class:\n     return this.parseClass(this.startNode(), false)\n@@ -2224,6 +2314,7 @@ pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n     var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n     this.yieldPos = 0;\n     this.awaitPos = 0;\n+    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n     while (this.type !== types.parenR) {\n       first ? first = false : this$1.expect(types.comma);\n       if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n@@ -2300,7 +2391,7 @@ pp$3.parseNew = function() {\n     node.property = this.parseIdent(true);\n     if (node.property.name !== \"target\" || containsEsc)\n       { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n-    if (!this.inFunction)\n+    if (!this.inNonArrowFunction())\n       { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n     return this.finishNode(node, \"MetaProperty\")\n   }\n@@ -2347,6 +2438,7 @@ pp$3.parseTemplate = function(ref) {\n   var curElt = this.parseTemplateElement({isTagged: isTagged});\n   node.quasis = [curElt];\n   while (!curElt.tail) {\n+    if (this$1.type === types.eof) { this$1.raise(this$1.pos, \"Unterminated template literal\"); }\n     this$1.expect(types.dollarBraceL);\n     node.expressions.push(this$1.parseExpression());\n     this$1.expect(types.braceR);\n@@ -2466,7 +2558,10 @@ pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startP\n         { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n     }\n   } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n+    if (isGenerator || isAsync) { this.unexpected(); }\n     this.checkUnreserved(prop.key);\n+    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n+      { this.awaitIdentPos = startPos; }\n     prop.kind = \"init\";\n     if (isPattern) {\n       prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n@@ -2499,77 +2594,62 @@ pp$3.parsePropertyName = function(prop) {\n \n pp$3.initFunction = function(node) {\n   node.id = null;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n+  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n+  if (this.options.ecmaVersion >= 8) { node.async = false; }\n };\n \n // Parse object or class method.\n \n-pp$3.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n+  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n \n   this.initFunction(node);\n   if (this.options.ecmaVersion >= 6)\n     { node.generator = isGenerator; }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.awaitIdentPos = 0;\n+  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n \n   this.expect(types.parenL);\n   node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n   this.checkYieldAwaitInDefaultParams();\n-  this.parseFunctionBody(node, false);\n+  this.parseFunctionBody(node, false, true);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n+  this.awaitIdentPos = oldAwaitIdentPos;\n   return this.finishNode(node, \"FunctionExpression\")\n };\n \n // Parse arrow function expression with given parameters.\n \n pp$3.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n \n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n   this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n+  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n \n-  this.inGenerator = false;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n+  this.awaitIdentPos = 0;\n \n   node.params = this.toAssignableList(params, true);\n-  this.parseFunctionBody(node, true);\n+  this.parseFunctionBody(node, true, false);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n+  this.awaitIdentPos = oldAwaitIdentPos;\n   return this.finishNode(node, \"ArrowFunctionExpression\")\n };\n \n // Parse function body and check parameters.\n \n-pp$3.parseFunctionBody = function(node, isArrowFunction) {\n+pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n   var isExpression = isArrowFunction && this.type !== types.braceL;\n   var oldStrict = this.strict, useStrict = false;\n \n@@ -2595,18 +2675,16 @@ pp$3.parseFunctionBody = function(node, isArrowFunction) {\n \n     // Add the params to varDeclaredNames to ensure that an error is thrown\n     // if a let/const declaration in the function clashes with one of the params.\n-    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n+    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n     node.body = this.parseBlock(false);\n     node.expression = false;\n     this.adaptDirectivePrologue(node.body.body);\n     this.labels = oldLabels;\n   }\n-  this.exitFunctionScope();\n+  this.exitScope();\n \n-  if (this.strict && node.id) {\n-    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n-    this.checkLVal(node.id, \"none\");\n-  }\n+  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n+  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n   this.strict = oldStrict;\n };\n \n@@ -2631,7 +2709,7 @@ pp$3.checkParams = function(node, allowDuplicates) {\n     {\n     var param = list[i];\n \n-    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n+    this$1.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n   }\n };\n \n@@ -2672,17 +2750,17 @@ pp$3.checkUnreserved = function(ref) {\n   var name = ref.name;\n \n   if (this.inGenerator && name === \"yield\")\n-    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n+    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n   if (this.inAsync && name === \"await\")\n-    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n-  if (this.isKeyword(name))\n+    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n+  if (this.keywords.test(name))\n     { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n   if (this.options.ecmaVersion < 6 &&\n     this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n   var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n   if (re.test(name)) {\n     if (!this.inAsync && name === \"await\")\n-      { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\n+      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n     this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n   }\n };\n@@ -2712,13 +2790,17 @@ pp$3.parseIdent = function(liberal, isBinding) {\n   }\n   this.next();\n   this.finishNode(node, \"Identifier\");\n-  if (!liberal) { this.checkUnreserved(node); }\n+  if (!liberal) {\n+    this.checkUnreserved(node);\n+    if (node.name === \"await\" && !this.awaitIdentPos)\n+      { this.awaitIdentPos = node.start; }\n+  }\n   return node\n };\n \n // Parses yield expression inside generator.\n \n-pp$3.parseYield = function() {\n+pp$3.parseYield = function(noIn) {\n   if (!this.yieldPos) { this.yieldPos = this.start; }\n \n   var node = this.startNode();\n@@ -2728,7 +2810,7 @@ pp$3.parseYield = function() {\n     node.argument = null;\n   } else {\n     node.delegate = this.eat(types.star);\n-    node.argument = this.parseMaybeAssign();\n+    node.argument = this.parseMaybeAssign(noIn);\n   }\n   return this.finishNode(node, \"YieldExpression\")\n };\n@@ -2768,79 +2850,99 @@ pp$4.curPosition = function() {\n \n var pp$5 = Parser.prototype;\n \n-// Object.assign polyfill\n-var assign = Object.assign || function(target) {\n-  var sources = [], len = arguments.length - 1;\n-  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n-\n-  for (var i = 0, list = sources; i < list.length; i += 1) {\n-    var source = list[i];\n-\n-    for (var key in source) {\n-      if (has(source, key)) {\n-        target[key] = source[key];\n-      }\n-    }\n-  }\n-  return target\n+var Scope = function Scope(flags) {\n+  this.flags = flags;\n+  // A list of var-declared names in the current lexical scope\n+  this.var = [];\n+  // A list of lexically-declared names in the current lexical scope\n+  this.lexical = [];\n+  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n+  this.functions = [];\n };\n \n // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n \n-pp$5.enterFunctionScope = function() {\n-  // var: a hash of var-declared names in the current lexical scope\n-  // lexical: a hash of lexically-declared names in the current lexical scope\n-  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n-  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n-  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n+pp$5.enterScope = function(flags) {\n+  this.scopeStack.push(new Scope(flags));\n };\n \n-pp$5.exitFunctionScope = function() {\n+pp$5.exitScope = function() {\n   this.scopeStack.pop();\n };\n \n-pp$5.enterLexicalScope = function() {\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n-  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n-\n-  this.scopeStack.push(childScope);\n-  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n+// The spec says:\n+// > At the top level of a function, or script, function declarations are\n+// > treated like var declarations rather than like lexical declarations.\n+pp$5.treatFunctionsAsVarInScope = function(scope) {\n+  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP);\n };\n \n-pp$5.exitLexicalScope = function() {\n-  var childScope = this.scopeStack.pop();\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.declareName = function(name, bindingType, pos) {\n+  var this$1 = this;\n \n-  assign(parentScope.childVar, childScope.var, childScope.childVar);\n+  var redeclared = false;\n+  if (bindingType === BIND_LEXICAL) {\n+    var scope = this.currentScope();\n+    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n+    scope.lexical.push(name);\n+    if (this.inModule && (scope.flags & SCOPE_TOP))\n+      { delete this.undefinedExports[name]; }\n+  } else if (bindingType === BIND_SIMPLE_CATCH) {\n+    var scope$1 = this.currentScope();\n+    scope$1.lexical.push(name);\n+  } else if (bindingType === BIND_FUNCTION) {\n+    var scope$2 = this.currentScope();\n+    if (this.treatFunctionsAsVar)\n+      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n+    else\n+      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n+    scope$2.functions.push(name);\n+  } else {\n+    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n+      var scope$3 = this$1.scopeStack[i];\n+      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name ||\n+          !this$1.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n+        redeclared = true;\n+        break\n+      }\n+      scope$3.var.push(name);\n+      if (this$1.inModule && (scope$3.flags & SCOPE_TOP))\n+        { delete this$1.undefinedExports[name]; }\n+      if (scope$3.flags & SCOPE_VAR) { break }\n+    }\n+  }\n+  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n };\n \n-/**\n- * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n- * in the current lexical scope or any of the parent lexical scopes in this function.\n- */\n-pp$5.canDeclareVarName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.checkLocalExport = function(id) {\n+  // scope.functions must be empty as Module code is always strict.\n+  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n+      this.scopeStack[0].var.indexOf(id.name) === -1) {\n+    this.undefinedExports[id.name] = id;\n+  }\n+};\n \n-  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n+pp$5.currentScope = function() {\n+  return this.scopeStack[this.scopeStack.length - 1]\n };\n \n-/**\n- * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n- * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n- * any child lexical scopes in this function.\n- */\n-pp$5.canDeclareLexicalName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.currentVarScope = function() {\n+  var this$1 = this;\n \n-  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n+  for (var i = this.scopeStack.length - 1;; i--) {\n+    var scope = this$1.scopeStack[i];\n+    if (scope.flags & SCOPE_VAR) { return scope }\n+  }\n };\n \n-pp$5.declareVarName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n-};\n+// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n+pp$5.currentThisScope = function() {\n+  var this$1 = this;\n \n-pp$5.declareLexicalName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n+  for (var i = this.scopeStack.length - 1;; i--) {\n+    var scope = this$1.scopeStack[i];\n+    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n+  }\n };\n \n var Node = function Node(parser, pos, loc) {\n@@ -2936,7 +3038,7 @@ pp$7.braceIsBlock = function(prevType) {\n     { return true }\n   if (prevType === types.braceL)\n     { return parent === types$1.b_stat }\n-  if (prevType === types._var || prevType === types.name)\n+  if (prevType === types._var || prevType === types._const || prevType === types.name)\n     { return false }\n   return !this.exprAllowed\n };\n@@ -2998,6 +3100,7 @@ types.incDec.updateContext = function() {\n \n types._function.updateContext = types._class.updateContext = function(prevType) {\n   if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n+      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n       !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n     { this.context.push(types$1.f_expr); }\n   else\n@@ -3026,481 +3129,59 @@ types.star.updateContext = function(prevType) {\n \n types.name.updateContext = function(prevType) {\n   var allowed = false;\n-  if (this.options.ecmaVersion >= 6) {\n+  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n     if (this.value === \"of\" && !this.exprAllowed ||\n         this.value === \"yield\" && this.inGeneratorContext())\n       { allowed = true; }\n   }\n   this.exprAllowed = allowed;\n };\n \n-var data = {\n-  \"$LONE\": [\n-    \"ASCII\",\n-    \"ASCII_Hex_Digit\",\n-    \"AHex\",\n-    \"Alphabetic\",\n-    \"Alpha\",\n-    \"Any\",\n-    \"Assigned\",\n-    \"Bidi_Control\",\n-    \"Bidi_C\",\n-    \"Bidi_Mirrored\",\n-    \"Bidi_M\",\n-    \"Case_Ignorable\",\n-    \"CI\",\n-    \"Cased\",\n-    \"Changes_When_Casefolded\",\n-    \"CWCF\",\n-    \"Changes_When_Casemapped\",\n-    \"CWCM\",\n-    \"Changes_When_Lowercased\",\n-    \"CWL\",\n-    \"Changes_When_NFKC_Casefolded\",\n-    \"CWKCF\",\n-    \"Changes_When_Titlecased\",\n-    \"CWT\",\n-    \"Changes_When_Uppercased\",\n-    \"CWU\",\n-    \"Dash\",\n-    \"Default_Ignorable_Code_Point\",\n-    \"DI\",\n-    \"Deprecated\",\n-    \"Dep\",\n-    \"Diacritic\",\n-    \"Dia\",\n-    \"Emoji\",\n-    \"Emoji_Component\",\n-    \"Emoji_Modifier\",\n-    \"Emoji_Modifier_Base\",\n-    \"Emoji_Presentation\",\n-    \"Extender\",\n-    \"Ext\",\n-    \"Grapheme_Base\",\n-    \"Gr_Base\",\n-    \"Grapheme_Extend\",\n-    \"Gr_Ext\",\n-    \"Hex_Digit\",\n-    \"Hex\",\n-    \"IDS_Binary_Operator\",\n-    \"IDSB\",\n-    \"IDS_Trinary_Operator\",\n-    \"IDST\",\n-    \"ID_Continue\",\n-    \"IDC\",\n-    \"ID_Start\",\n-    \"IDS\",\n-    \"Ideographic\",\n-    \"Ideo\",\n-    \"Join_Control\",\n-    \"Join_C\",\n-    \"Logical_Order_Exception\",\n-    \"LOE\",\n-    \"Lowercase\",\n-    \"Lower\",\n-    \"Math\",\n-    \"Noncharacter_Code_Point\",\n-    \"NChar\",\n-    \"Pattern_Syntax\",\n-    \"Pat_Syn\",\n-    \"Pattern_White_Space\",\n-    \"Pat_WS\",\n-    \"Quotation_Mark\",\n-    \"QMark\",\n-    \"Radical\",\n-    \"Regional_Indicator\",\n-    \"RI\",\n-    \"Sentence_Terminal\",\n-    \"STerm\",\n-    \"Soft_Dotted\",\n-    \"SD\",\n-    \"Terminal_Punctuation\",\n-    \"Term\",\n-    \"Unified_Ideograph\",\n-    \"UIdeo\",\n-    \"Uppercase\",\n-    \"Upper\",\n-    \"Variation_Selector\",\n-    \"VS\",\n-    \"White_Space\",\n-    \"space\",\n-    \"XID_Continue\",\n-    \"XIDC\",\n-    \"XID_Start\",\n-    \"XIDS\"\n-  ],\n-  \"General_Category\": [\n-    \"Cased_Letter\",\n-    \"LC\",\n-    \"Close_Punctuation\",\n-    \"Pe\",\n-    \"Connector_Punctuation\",\n-    \"Pc\",\n-    \"Control\",\n-    \"Cc\",\n-    \"cntrl\",\n-    \"Currency_Symbol\",\n-    \"Sc\",\n-    \"Dash_Punctuation\",\n-    \"Pd\",\n-    \"Decimal_Number\",\n-    \"Nd\",\n-    \"digit\",\n-    \"Enclosing_Mark\",\n-    \"Me\",\n-    \"Final_Punctuation\",\n-    \"Pf\",\n-    \"Format\",\n-    \"Cf\",\n-    \"Initial_Punctuation\",\n-    \"Pi\",\n-    \"Letter\",\n-    \"L\",\n-    \"Letter_Number\",\n-    \"Nl\",\n-    \"Line_Separator\",\n-    \"Zl\",\n-    \"Lowercase_Letter\",\n-    \"Ll\",\n-    \"Mark\",\n-    \"M\",\n-    \"Combining_Mark\",\n-    \"Math_Symbol\",\n-    \"Sm\",\n-    \"Modifier_Letter\",\n-    \"Lm\",\n-    \"Modifier_Symbol\",\n-    \"Sk\",\n-    \"Nonspacing_Mark\",\n-    \"Mn\",\n-    \"Number\",\n-    \"N\",\n-    \"Open_Punctuation\",\n-    \"Ps\",\n-    \"Other\",\n-    \"C\",\n-    \"Other_Letter\",\n-    \"Lo\",\n-    \"Other_Number\",\n-    \"No\",\n-    \"Other_Punctuation\",\n-    \"Po\",\n-    \"Other_Symbol\",\n-    \"So\",\n-    \"Paragraph_Separator\",\n-    \"Zp\",\n-    \"Private_Use\",\n-    \"Co\",\n-    \"Punctuation\",\n-    \"P\",\n-    \"punct\",\n-    \"Separator\",\n-    \"Z\",\n-    \"Space_Separator\",\n-    \"Zs\",\n-    \"Spacing_Mark\",\n-    \"Mc\",\n-    \"Surrogate\",\n-    \"Cs\",\n-    \"Symbol\",\n-    \"S\",\n-    \"Titlecase_Letter\",\n-    \"Lt\",\n-    \"Unassigned\",\n-    \"Cn\",\n-    \"Uppercase_Letter\",\n-    \"Lu\"\n-  ],\n-  \"Script\": [\n-    \"Adlam\",\n-    \"Adlm\",\n-    \"Ahom\",\n-    \"Anatolian_Hieroglyphs\",\n-    \"Hluw\",\n-    \"Arabic\",\n-    \"Arab\",\n-    \"Armenian\",\n-    \"Armn\",\n-    \"Avestan\",\n-    \"Avst\",\n-    \"Balinese\",\n-    \"Bali\",\n-    \"Bamum\",\n-    \"Bamu\",\n-    \"Bassa_Vah\",\n-    \"Bass\",\n-    \"Batak\",\n-    \"Batk\",\n-    \"Bengali\",\n-    \"Beng\",\n-    \"Bhaiksuki\",\n-    \"Bhks\",\n-    \"Bopomofo\",\n-    \"Bopo\",\n-    \"Brahmi\",\n-    \"Brah\",\n-    \"Braille\",\n-    \"Brai\",\n-    \"Buginese\",\n-    \"Bugi\",\n-    \"Buhid\",\n-    \"Buhd\",\n-    \"Canadian_Aboriginal\",\n-    \"Cans\",\n-    \"Carian\",\n-    \"Cari\",\n-    \"Caucasian_Albanian\",\n-    \"Aghb\",\n-    \"Chakma\",\n-    \"Cakm\",\n-    \"Cham\",\n-    \"Cherokee\",\n-    \"Cher\",\n-    \"Common\",\n-    \"Zyyy\",\n-    \"Coptic\",\n-    \"Copt\",\n-    \"Qaac\",\n-    \"Cuneiform\",\n-    \"Xsux\",\n-    \"Cypriot\",\n-    \"Cprt\",\n-    \"Cyrillic\",\n-    \"Cyrl\",\n-    \"Deseret\",\n-    \"Dsrt\",\n-    \"Devanagari\",\n-    \"Deva\",\n-    \"Duployan\",\n-    \"Dupl\",\n-    \"Egyptian_Hieroglyphs\",\n-    \"Egyp\",\n-    \"Elbasan\",\n-    \"Elba\",\n-    \"Ethiopic\",\n-    \"Ethi\",\n-    \"Georgian\",\n-    \"Geor\",\n-    \"Glagolitic\",\n-    \"Glag\",\n-    \"Gothic\",\n-    \"Goth\",\n-    \"Grantha\",\n-    \"Gran\",\n-    \"Greek\",\n-    \"Grek\",\n-    \"Gujarati\",\n-    \"Gujr\",\n-    \"Gurmukhi\",\n-    \"Guru\",\n-    \"Han\",\n-    \"Hani\",\n-    \"Hangul\",\n-    \"Hang\",\n-    \"Hanunoo\",\n-    \"Hano\",\n-    \"Hatran\",\n-    \"Hatr\",\n-    \"Hebrew\",\n-    \"Hebr\",\n-    \"Hiragana\",\n-    \"Hira\",\n-    \"Imperial_Aramaic\",\n-    \"Armi\",\n-    \"Inherited\",\n-    \"Zinh\",\n-    \"Qaai\",\n-    \"Inscriptional_Pahlavi\",\n-    \"Phli\",\n-    \"Inscriptional_Parthian\",\n-    \"Prti\",\n-    \"Javanese\",\n-    \"Java\",\n-    \"Kaithi\",\n-    \"Kthi\",\n-    \"Kannada\",\n-    \"Knda\",\n-    \"Katakana\",\n-    \"Kana\",\n-    \"Kayah_Li\",\n-    \"Kali\",\n-    \"Kharoshthi\",\n-    \"Khar\",\n-    \"Khmer\",\n-    \"Khmr\",\n-    \"Khojki\",\n-    \"Khoj\",\n-    \"Khudawadi\",\n-    \"Sind\",\n-    \"Lao\",\n-    \"Laoo\",\n-    \"Latin\",\n-    \"Latn\",\n-    \"Lepcha\",\n-    \"Lepc\",\n-    \"Limbu\",\n-    \"Limb\",\n-    \"Linear_A\",\n-    \"Lina\",\n-    \"Linear_B\",\n-    \"Linb\",\n-    \"Lisu\",\n-    \"Lycian\",\n-    \"Lyci\",\n-    \"Lydian\",\n-    \"Lydi\",\n-    \"Mahajani\",\n-    \"Mahj\",\n-    \"Malayalam\",\n-    \"Mlym\",\n-    \"Mandaic\",\n-    \"Mand\",\n-    \"Manichaean\",\n-    \"Mani\",\n-    \"Marchen\",\n-    \"Marc\",\n-    \"Masaram_Gondi\",\n-    \"Gonm\",\n-    \"Meetei_Mayek\",\n-    \"Mtei\",\n-    \"Mende_Kikakui\",\n-    \"Mend\",\n-    \"Meroitic_Cursive\",\n-    \"Merc\",\n-    \"Meroitic_Hieroglyphs\",\n-    \"Mero\",\n-    \"Miao\",\n-    \"Plrd\",\n-    \"Modi\",\n-    \"Mongolian\",\n-    \"Mong\",\n-    \"Mro\",\n-    \"Mroo\",\n-    \"Multani\",\n-    \"Mult\",\n-    \"Myanmar\",\n-    \"Mymr\",\n-    \"Nabataean\",\n-    \"Nbat\",\n-    \"New_Tai_Lue\",\n-    \"Talu\",\n-    \"Newa\",\n-    \"Nko\",\n-    \"Nkoo\",\n-    \"Nushu\",\n-    \"Nshu\",\n-    \"Ogham\",\n-    \"Ogam\",\n-    \"Ol_Chiki\",\n-    \"Olck\",\n-    \"Old_Hungarian\",\n-    \"Hung\",\n-    \"Old_Italic\",\n-    \"Ital\",\n-    \"Old_North_Arabian\",\n-    \"Narb\",\n-    \"Old_Permic\",\n-    \"Perm\",\n-    \"Old_Persian\",\n-    \"Xpeo\",\n-    \"Old_South_Arabian\",\n-    \"Sarb\",\n-    \"Old_Turkic\",\n-    \"Orkh\",\n-    \"Oriya\",\n-    \"Orya\",\n-    \"Osage\",\n-    \"Osge\",\n-    \"Osmanya\",\n-    \"Osma\",\n-    \"Pahawh_Hmong\",\n-    \"Hmng\",\n-    \"Palmyrene\",\n-    \"Palm\",\n-    \"Pau_Cin_Hau\",\n-    \"Pauc\",\n-    \"Phags_Pa\",\n-    \"Phag\",\n-    \"Phoenician\",\n-    \"Phnx\",\n-    \"Psalter_Pahlavi\",\n-    \"Phlp\",\n-    \"Rejang\",\n-    \"Rjng\",\n-    \"Runic\",\n-    \"Runr\",\n-    \"Samaritan\",\n-    \"Samr\",\n-    \"Saurashtra\",\n-    \"Saur\",\n-    \"Sharada\",\n-    \"Shrd\",\n-    \"Shavian\",\n-    \"Shaw\",\n-    \"Siddham\",\n-    \"Sidd\",\n-    \"SignWriting\",\n-    \"Sgnw\",\n-    \"Sinhala\",\n-    \"Sinh\",\n-    \"Sora_Sompeng\",\n-    \"Sora\",\n-    \"Soyombo\",\n-    \"Soyo\",\n-    \"Sundanese\",\n-    \"Sund\",\n-    \"Syloti_Nagri\",\n-    \"Sylo\",\n-    \"Syriac\",\n-    \"Syrc\",\n-    \"Tagalog\",\n-    \"Tglg\",\n-    \"Tagbanwa\",\n-    \"Tagb\",\n-    \"Tai_Le\",\n-    \"Tale\",\n-    \"Tai_Tham\",\n-    \"Lana\",\n-    \"Tai_Viet\",\n-    \"Tavt\",\n-    \"Takri\",\n-    \"Takr\",\n-    \"Tamil\",\n-    \"Taml\",\n-    \"Tangut\",\n-    \"Tang\",\n-    \"Telugu\",\n-    \"Telu\",\n-    \"Thaana\",\n-    \"Thaa\",\n-    \"Thai\",\n-    \"Tibetan\",\n-    \"Tibt\",\n-    \"Tifinagh\",\n-    \"Tfng\",\n-    \"Tirhuta\",\n-    \"Tirh\",\n-    \"Ugaritic\",\n-    \"Ugar\",\n-    \"Vai\",\n-    \"Vaii\",\n-    \"Warang_Citi\",\n-    \"Wara\",\n-    \"Yi\",\n-    \"Yiii\",\n-    \"Zanabazar_Square\",\n-    \"Zanb\"\n-  ]\n-};\n-Array.prototype.push.apply(data.$LONE, data.General_Category);\n-data.gc = data.General_Category;\n-data.sc = data.Script_Extensions = data.scx = data.Script;\n+// This file contains Unicode properties extracted from the ECMAScript\n+// specification. The lists are extracted like so:\n+// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n+\n+// #table-binary-unicode-properties\n+var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n+var unicodeBinaryProperties = {\n+  9: ecma9BinaryProperties,\n+  10: ecma9BinaryProperties + \" Extended_Pictographic\"\n+};\n+\n+// #table-unicode-general-category-values\n+var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n+\n+// #table-unicode-script-values\n+var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n+var unicodeScriptValues = {\n+  9: ecma9ScriptValues,\n+  10: ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\"\n+};\n+\n+var data = {};\n+function buildUnicodeData(ecmaVersion) {\n+  var d = data[ecmaVersion] = {\n+    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n+    nonBinary: {\n+      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n+      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n+    }\n+  };\n+  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n+\n+  d.nonBinary.gc = d.nonBinary.General_Category;\n+  d.nonBinary.sc = d.nonBinary.Script;\n+  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n+}\n+buildUnicodeData(9);\n+buildUnicodeData(10);\n \n var pp$9 = Parser.prototype;\n \n var RegExpValidationState = function RegExpValidationState(parser) {\n   this.parser = parser;\n   this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n+  this.unicodeProperties = data[parser.options.ecmaVersion >= 10 ? 10 : parser.options.ecmaVersion];\n   this.source = \"\";\n   this.flags = \"\";\n   this.start = 0;\n@@ -4284,14 +3965,14 @@ pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\n   return false\n };\n pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n-  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n-    state.raise(\"Invalid property name\");\n-  }\n+  if (!has(state.unicodeProperties.nonBinary, name))\n+    { state.raise(\"Invalid property name\"); }\n+  if (!state.unicodeProperties.nonBinary[name].test(value))\n+    { state.raise(\"Invalid property value\"); }\n };\n pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n-  if (data.$LONE.indexOf(nameOrValue) === -1) {\n-    state.raise(\"Invalid property name\");\n-  }\n+  if (!state.unicodeProperties.binary.test(nameOrValue))\n+    { state.raise(\"Invalid property name\"); }\n };\n \n // UnicodePropertyName ::\n@@ -5191,6 +4872,11 @@ pp$8.readEscapedChar = function(inTemplate) {\n       }\n       return String.fromCharCode(octal)\n     }\n+    if (isNewLine(ch)) {\n+      // Unicode new line characters after \\ get removed from output in both\n+      // template literals and strings\n+      return \"\"\n+    }\n     return String.fromCharCode(ch)\n   }\n };\n@@ -5267,14 +4953,9 @@ pp$8.readWord = function() {\n //\n // [ghbt]: https://github.com/acornjs/acorn/issues\n //\n-// This file defines the main parser interface. The library also comes\n-// with a [error-tolerant parser][dammit] and an\n-// [abstract syntax tree walker][walk], defined in other files.\n-//\n-// [dammit]: acorn_loose.js\n // [walk]: util/walk.js\n \n-var version = \"5.7.2\";\n+var version = \"6.0.7\";\n \n // The main exported interface (under `self.acorn` when in the\n // browser) is a `parse` function that takes a code string and\n@@ -5284,43 +4965,29 @@ var version = \"5.7.2\";\n // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n \n function parse(input, options) {\n-  return new Parser(options, input).parse()\n+  return Parser.parse(input, options)\n }\n \n // This function tries to parse a single expression at a given\n // offset in a string. Useful for parsing mixed-language formats\n // that embed JavaScript expressions.\n \n function parseExpressionAt(input, pos, options) {\n-  var p = new Parser(options, input, pos);\n-  p.nextToken();\n-  return p.parseExpression()\n+  return Parser.parseExpressionAt(input, pos, options)\n }\n \n // Acorn is organized as a tokenizer and a recursive-descent parser.\n // The `tokenizer` export provides an interface to the tokenizer.\n \n function tokenizer(input, options) {\n-  return new Parser(options, input)\n-}\n-\n-// This is a terrible kludge to support the existing, pre-ES6\n-// interface where the loose parser module retroactively adds exports\n-// to this module.\n- // eslint-disable-line camelcase\n-function addLooseExports(parse, Parser$$1, plugins$$1) {\n-  exports.parse_dammit = parse; // eslint-disable-line camelcase\n-  exports.LooseParser = Parser$$1;\n-  exports.pluginsLoose = plugins$$1;\n+  return Parser.tokenizer(input, options)\n }\n \n exports.version = version;\n exports.parse = parse;\n exports.parseExpressionAt = parseExpressionAt;\n exports.tokenizer = tokenizer;\n-exports.addLooseExports = addLooseExports;\n exports.Parser = Parser;\n-exports.plugins = plugins;\n exports.defaultOptions = defaultOptions;\n exports.Position = Position;\n exports.SourceLocation = SourceLocation;\n@@ -5342,3 +5009,4 @@ exports.nonASCIIwhitespace = nonASCIIwhitespace;\n Object.defineProperty(exports, '__esModule', { value: true });\n \n })));\n+//# sourceMappingURL=acorn.js.map",
            "previous_filename": "deps/acorn/dist/acorn.js"
        },
        {
            "sha": "9f9ed77cccdfdf7367239f2735411c95ee55cc40",
            "filename": "deps/acorn/acorn/dist/acorn.js.map",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js.map",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.js.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.js.map?ref=582c12260ed99ebe7710894c2dab29435b1bebdc"
        },
        {
            "sha": "379fdc5f302fee485482a0311e2d89e49bcec459",
            "filename": "deps/acorn/acorn/dist/acorn.mjs",
            "status": "renamed",
            "additions": 411,
            "deletions": 743,
            "changes": 1154,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -248,7 +248,7 @@ function isNewLine(code, ecma2019String) {\n   return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n }\n \n-var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n+var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n \n var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n \n@@ -266,6 +266,10 @@ var isArray = Array.isArray || (function (obj) { return (\n   toString.call(obj) === \"[object Array]\"\n ); });\n \n+function wordsRegexp(words) {\n+  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n+}\n+\n // These are used when `options.locations` is on, for the\n // `startLoc` and `endLoc` properties.\n \n@@ -307,18 +311,19 @@ function getLineInfo(input, offset) {\n // the parser process. These options are recognized:\n \n var defaultOptions = {\n-  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n-  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n-  // for strict mode, the set of reserved words, and support for\n-  // new syntax features. The default is 7.\n-  ecmaVersion: 7,\n+  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n+  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n+  // (2019). This influences support for strict mode, the set of\n+  // reserved words, and support for new syntax features. The default\n+  // is 9.\n+  ecmaVersion: 9,\n   // `sourceType` indicates the mode the code should be parsed in.\n   // Can be either `\"script\"` or `\"module\"`. This influences global\n   // strict mode and parsing of `import` and `export` declarations.\n   sourceType: \"script\",\n   // `onInsertedSemicolon` can be a callback that will be called\n   // when a semicolon is automatically inserted. It will be passed\n-  // th position of the comma as an offset, and if `locations` is\n+  // the position of the comma as an offset, and if `locations` is\n   // enabled, it is given the location as a `{line, column}` object\n   // as second argument.\n   onInsertedSemicolon: null,\n@@ -387,8 +392,7 @@ var defaultOptions = {\n   directSourceFile: null,\n   // When enabled, parenthesized expressions are represented by\n   // (non-standard) ParenthesizedExpression nodes\n-  preserveParens: false,\n-  plugins: {}\n+  preserveParens: false\n };\n \n // Interpret and default an options object\n@@ -431,37 +435,50 @@ function pushComment(options, array) {\n   }\n }\n \n-// Registered plugins\n-var plugins = {};\n-\n-function keywordRegexp(words) {\n-  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n+// Each scope gets a bitset that may contain these flags\n+var SCOPE_TOP = 1;\n+var SCOPE_FUNCTION = 2;\n+var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;\n+var SCOPE_ASYNC = 4;\n+var SCOPE_GENERATOR = 8;\n+var SCOPE_ARROW = 16;\n+var SCOPE_SIMPLE_CATCH = 32;\n+var SCOPE_SUPER = 64;\n+var SCOPE_DIRECT_SUPER = 128;\n+\n+function functionFlags(async, generator) {\n+  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n }\n \n+// Used in checkLVal and declareName to determine the type of a binding\n+var BIND_NONE = 0;\n+var BIND_VAR = 1;\n+var BIND_LEXICAL = 2;\n+var BIND_FUNCTION = 3;\n+var BIND_SIMPLE_CATCH = 4;\n+var BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n+\n var Parser = function Parser(options, input, startPos) {\n   this.options = options = getOptions(options);\n   this.sourceFile = options.sourceFile;\n-  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n+  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n   var reserved = \"\";\n   if (!options.allowReserved) {\n     for (var v = options.ecmaVersion;; v--)\n       { if (reserved = reservedWords[v]) { break } }\n     if (options.sourceType === \"module\") { reserved += \" await\"; }\n   }\n-  this.reservedWords = keywordRegexp(reserved);\n+  this.reservedWords = wordsRegexp(reserved);\n   var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n-  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n-  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n+  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n+  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n   this.input = String(input);\n \n   // Used to signal to callers of `readWord1` whether the word\n   // contained any escape sequences. This is needed because words with\n   // escape sequences must not be interpreted as keywords.\n   this.containsEsc = false;\n \n-  // Load plugins\n-  this.loadPlugins(options.plugins);\n-\n   // Set up token state\n \n   // The current position of the tokenizer in the input.\n@@ -502,64 +519,90 @@ var Parser = function Parser(options, input, startPos) {\n   // Used to signify the start of a potential arrow function\n   this.potentialArrowAt = -1;\n \n-  // Flags to track whether we are in a function, a generator, an async function.\n-  this.inFunction = this.inGenerator = this.inAsync = false;\n   // Positions to delayed-check that yield/await does not exist in default parameters.\n-  this.yieldPos = this.awaitPos = 0;\n+  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n   // Labels in scope.\n   this.labels = [];\n+  // Thus-far undefined exports.\n+  this.undefinedExports = {};\n \n   // If enabled, skip leading hashbang line.\n   if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n     { this.skipLineComment(2); }\n \n   // Scope tracking for duplicate variable names (see scope.js)\n   this.scopeStack = [];\n-  this.enterFunctionScope();\n+  this.enterScope(SCOPE_TOP);\n \n   // For RegExp validation\n   this.regexpState = null;\n };\n \n-// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n-Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\n-Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n+var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n \n-Parser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n+Parser.prototype.parse = function parse () {\n+  var node = this.options.program || this.startNode();\n+  this.nextToken();\n+  return this.parseTopLevel(node)\n };\n \n-Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n+prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n+prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n+prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n+prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n+prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n+prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n \n-  for (var name in pluginConfigs) {\n-    var plugin = plugins[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n+// Switch to a getter for 7.0.0.\n+Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n+\n+Parser.extend = function extend () {\n+    var plugins = [], len = arguments.length;\n+    while ( len-- ) plugins[ len ] = arguments[ len ];\n+\n+  var cls = this;\n+  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n+  return cls\n };\n \n-Parser.prototype.parse = function parse () {\n-  var node = this.options.program || this.startNode();\n-  this.nextToken();\n-  return this.parseTopLevel(node)\n+Parser.parse = function parse (input, options) {\n+  return new this(options, input).parse()\n+};\n+\n+Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n+  var parser = new this(options, input, pos);\n+  parser.nextToken();\n+  return parser.parseExpression()\n };\n \n+Parser.tokenizer = function tokenizer (input, options) {\n+  return new this(options, input)\n+};\n+\n+Object.defineProperties( Parser.prototype, prototypeAccessors );\n+\n var pp = Parser.prototype;\n \n // ## Parser utilities\n \n-var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\n+var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n pp.strictDirective = function(start) {\n   var this$1 = this;\n \n   for (;;) {\n+    // Try to find string literal.\n     skipWhiteSpace.lastIndex = start;\n     start += skipWhiteSpace.exec(this$1.input)[0].length;\n     var match = literal.exec(this$1.input.slice(start));\n     if (!match) { return false }\n     if ((match[1] || match[2]) === \"use strict\") { return true }\n     start += match[0].length;\n+\n+    // Skip semicolon, if any.\n+    skipWhiteSpace.lastIndex = start;\n+    start += skipWhiteSpace.exec(this$1.input)[0].length;\n+    if (this$1.input[start] === ';')\n+      { start++; }\n   }\n };\n \n@@ -697,9 +740,16 @@ pp$1.parseTopLevel = function(node) {\n   var exports = {};\n   if (!node.body) { node.body = []; }\n   while (this.type !== types.eof) {\n-    var stmt = this$1.parseStatement(true, true, exports);\n+    var stmt = this$1.parseStatement(null, true, exports);\n     node.body.push(stmt);\n   }\n+  if (this.inModule)\n+    { for (var i = 0, list = Object.keys(this$1.undefinedExports); i < list.length; i += 1)\n+      {\n+        var name = list[i];\n+\n+        this$1.raiseRecoverable(this$1.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n+      } }\n   this.adaptDirectivePrologue(node.body);\n   this.next();\n   if (this.options.ecmaVersion >= 6) {\n@@ -711,12 +761,19 @@ pp$1.parseTopLevel = function(node) {\n var loopLabel = {kind: \"loop\"};\n var switchLabel = {kind: \"switch\"};\n \n-pp$1.isLet = function() {\n+pp$1.isLet = function(context) {\n   if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n   skipWhiteSpace.lastIndex = this.pos;\n   var skip = skipWhiteSpace.exec(this.input);\n   var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n-  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\n+  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n+  // Statement) is allowed here. If context is not empty then only a Statement\n+  // is allowed. However, `let [` is an explicit negative lookahead for\n+  // ExpressionStatement, so special-case it first.\n+  if (nextCh === 91) { return true } // '['\n+  if (context) { return false }\n+\n+  if (nextCh === 123) { return true } // '{'\n   if (isIdentifierStart(nextCh, true)) {\n     var pos = next + 1;\n     while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n@@ -748,10 +805,10 @@ pp$1.isAsyncFunction = function() {\n // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n // does not help.\n \n-pp$1.parseStatement = function(declaration, topLevel, exports) {\n+pp$1.parseStatement = function(context, topLevel, exports) {\n   var starttype = this.type, node = this.startNode(), kind;\n \n-  if (this.isLet()) {\n+  if (this.isLet(context)) {\n     starttype = types._var;\n     kind = \"let\";\n   }\n@@ -766,10 +823,13 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._do: return this.parseDoStatement(node)\n   case types._for: return this.parseForStatement(node)\n   case types._function:\n-    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n-    return this.parseFunctionStatement(node, false)\n+    // Function as sole body of either an if statement or a labeled statement\n+    // works, but not when it is part of a labeled statement that is the sole\n+    // body of an if statement.\n+    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n+    return this.parseFunctionStatement(node, false, !context)\n   case types._class:\n-    if (!declaration) { this.unexpected(); }\n+    if (context) { this.unexpected(); }\n     return this.parseClass(node, true)\n   case types._if: return this.parseIfStatement(node)\n   case types._return: return this.parseReturnStatement(node)\n@@ -778,11 +838,11 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._try: return this.parseTryStatement(node)\n   case types._const: case types._var:\n     kind = kind || this.value;\n-    if (!declaration && kind !== \"var\") { this.unexpected(); }\n+    if (context && kind !== \"var\") { this.unexpected(); }\n     return this.parseVarStatement(node, kind)\n   case types._while: return this.parseWhileStatement(node)\n   case types._with: return this.parseWithStatement(node)\n-  case types.braceL: return this.parseBlock()\n+  case types.braceL: return this.parseBlock(true, node)\n   case types.semi: return this.parseEmptyStatement(node)\n   case types._export:\n   case types._import:\n@@ -801,14 +861,14 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n     // Identifier node, we switch to interpreting it as a label.\n   default:\n     if (this.isAsyncFunction()) {\n-      if (!declaration) { this.unexpected(); }\n+      if (context) { this.unexpected(); }\n       this.next();\n-      return this.parseFunctionStatement(node, true)\n+      return this.parseFunctionStatement(node, true, !context)\n     }\n \n     var maybeName = this.value, expr = this.parseExpression();\n     if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n-      { return this.parseLabeledStatement(node, maybeName, expr) }\n+      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n     else { return this.parseExpressionStatement(node, expr) }\n   }\n };\n@@ -848,7 +908,7 @@ pp$1.parseDebuggerStatement = function(node) {\n pp$1.parseDoStatement = function(node) {\n   this.next();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"do\");\n   this.labels.pop();\n   this.expect(types._while);\n   node.test = this.parseParenExpression();\n@@ -871,7 +931,7 @@ pp$1.parseForStatement = function(node) {\n   this.next();\n   var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n   this.labels.push(loopLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n   this.expect(types.parenL);\n   if (this.type === types.semi) {\n     if (awaitAt > -1) { this.unexpected(awaitAt); }\n@@ -913,17 +973,17 @@ pp$1.parseForStatement = function(node) {\n   return this.parseFor(node, init)\n };\n \n-pp$1.parseFunctionStatement = function(node, isAsync) {\n+pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n   this.next();\n-  return this.parseFunction(node, true, false, isAsync)\n+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n };\n \n pp$1.parseIfStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   // allow function declarations in branches, but only in non-strict mode\n-  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n-  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n+  node.consequent = this.parseStatement(\"if\");\n+  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n   return this.finishNode(node, \"IfStatement\")\n };\n \n@@ -949,7 +1009,7 @@ pp$1.parseSwitchStatement = function(node) {\n   node.cases = [];\n   this.expect(types.braceL);\n   this.labels.push(switchLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n \n   // Statements under must be grouped (by label) in SwitchCase\n   // nodes. `cur` is used to keep the node that we are currently\n@@ -973,10 +1033,10 @@ pp$1.parseSwitchStatement = function(node) {\n       this$1.expect(types.colon);\n     } else {\n       if (!cur) { this$1.unexpected(); }\n-      cur.consequent.push(this$1.parseStatement(true));\n+      cur.consequent.push(this$1.parseStatement(null));\n     }\n   }\n-  this.exitLexicalScope();\n+  this.exitScope();\n   if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n   this.next(); // Closing brace\n   this.labels.pop();\n@@ -1005,16 +1065,17 @@ pp$1.parseTryStatement = function(node) {\n     this.next();\n     if (this.eat(types.parenL)) {\n       clause.param = this.parseBindingAtom();\n-      this.enterLexicalScope();\n-      this.checkLVal(clause.param, \"let\");\n+      var simple = clause.param.type === \"Identifier\";\n+      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n+      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n       this.expect(types.parenR);\n     } else {\n       if (this.options.ecmaVersion < 10) { this.unexpected(); }\n       clause.param = null;\n-      this.enterLexicalScope();\n+      this.enterScope(0);\n     }\n     clause.body = this.parseBlock(false);\n-    this.exitLexicalScope();\n+    this.exitScope();\n     node.handler = this.finishNode(clause, \"CatchClause\");\n   }\n   node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n@@ -1034,7 +1095,7 @@ pp$1.parseWhileStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"while\");\n   this.labels.pop();\n   return this.finishNode(node, \"WhileStatement\")\n };\n@@ -1043,7 +1104,7 @@ pp$1.parseWithStatement = function(node) {\n   if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n   this.next();\n   node.object = this.parseParenExpression();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"with\");\n   return this.finishNode(node, \"WithStatement\")\n };\n \n@@ -1052,7 +1113,7 @@ pp$1.parseEmptyStatement = function(node) {\n   return this.finishNode(node, \"EmptyStatement\")\n };\n \n-pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n+pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n   var this$1 = this;\n \n   for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n@@ -1072,11 +1133,7 @@ pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n     } else { break }\n   }\n   this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n-  node.body = this.parseStatement(true);\n-  if (node.body.type === \"ClassDeclaration\" ||\n-      node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n-      node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n-    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n+  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n   this.labels.pop();\n   node.label = expr;\n   return this.finishNode(node, \"LabeledStatement\")\n@@ -1092,23 +1149,19 @@ pp$1.parseExpressionStatement = function(node, expr) {\n // strict\"` declarations when `allowStrict` is true (used for\n // function bodies).\n \n-pp$1.parseBlock = function(createNewLexicalScope) {\n+pp$1.parseBlock = function(createNewLexicalScope, node) {\n   var this$1 = this;\n   if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n+  if ( node === void 0 ) node = this.startNode();\n \n-  var node = this.startNode();\n   node.body = [];\n   this.expect(types.braceL);\n-  if (createNewLexicalScope) {\n-    this.enterLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.enterScope(0); }\n   while (!this.eat(types.braceR)) {\n-    var stmt = this$1.parseStatement(true);\n+    var stmt = this$1.parseStatement(null);\n     node.body.push(stmt);\n   }\n-  if (createNewLexicalScope) {\n-    this.exitLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.exitScope(); }\n   return this.finishNode(node, \"BlockStatement\")\n };\n \n@@ -1123,8 +1176,8 @@ pp$1.parseFor = function(node, init) {\n   this.expect(types.semi);\n   node.update = this.type === types.parenR ? null : this.parseExpression();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"for\");\n+  this.exitScope();\n   this.labels.pop();\n   return this.finishNode(node, \"ForStatement\")\n };\n@@ -1144,8 +1197,8 @@ pp$1.parseForIn = function(node, init) {\n   node.left = init;\n   node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"for\");\n+  this.exitScope();\n   this.labels.pop();\n   return this.finishNode(node, type)\n };\n@@ -1176,48 +1229,57 @@ pp$1.parseVar = function(node, isFor, kind) {\n };\n \n pp$1.parseVarId = function(decl, kind) {\n-  decl.id = this.parseBindingAtom(kind);\n-  this.checkLVal(decl.id, kind, false);\n+  if ((kind === \"const\" || kind === \"let\") && this.isContextual(\"let\")) {\n+    this.raiseRecoverable(this.start, \"let is disallowed as a lexically bound name\");\n+  }\n+  decl.id = this.parseBindingAtom();\n+  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n };\n \n+var FUNC_STATEMENT = 1;\n+var FUNC_HANGING_STATEMENT = 2;\n+var FUNC_NULLABLE_ID = 4;\n+\n // Parse a function declaration or literal (depending on the\n-// `isStatement` parameter).\n+// `statement & FUNC_STATEMENT`).\n \n-pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n+// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n+pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n   this.initFunction(node);\n-  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n-    { node.generator = this.eat(types.star); }\n+  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n+    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n+      { this.unexpected(); }\n+    node.generator = this.eat(types.star);\n+  }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  if (isStatement) {\n-    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n-    if (node.id) {\n-      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n-    }\n+  if (statement & FUNC_STATEMENT) {\n+    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n+    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n+      // If it is a regular function declaration in sloppy mode, then it is\n+      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n+      // mode depends on properties of the current scope (see\n+      // treatFunctionsAsVar).\n+      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n   }\n \n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.awaitIdentPos = 0;\n+  this.enterScope(functionFlags(node.async, node.generator));\n \n-  if (!isStatement)\n+  if (!(statement & FUNC_STATEMENT))\n     { node.id = this.type === types.name ? this.parseIdent() : null; }\n \n   this.parseFunctionParams(node);\n-  this.parseFunctionBody(node, allowExpressionBody);\n+  this.parseFunctionBody(node, allowExpressionBody, false);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n+  this.awaitIdentPos = oldAwaitIdentPos;\n+  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n };\n \n pp$1.parseFunctionParams = function(node) {\n@@ -1234,24 +1296,33 @@ pp$1.parseClass = function(node, isStatement) {\n \n   this.next();\n \n+  // ecma-262 14.6 Class Definitions\n+  // A class definition is always strict mode code.\n+  var oldStrict = this.strict;\n+  this.strict = true;\n+\n   this.parseClassId(node, isStatement);\n   this.parseClassSuper(node);\n   var classBody = this.startNode();\n   var hadConstructor = false;\n   classBody.body = [];\n   this.expect(types.braceL);\n   while (!this.eat(types.braceR)) {\n-    var member = this$1.parseClassMember(classBody);\n-    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n-      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n-      hadConstructor = true;\n+    var element = this$1.parseClassElement(node.superClass !== null);\n+    if (element) {\n+      classBody.body.push(element);\n+      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n+        if (hadConstructor) { this$1.raise(element.start, \"Duplicate constructor in the same class\"); }\n+        hadConstructor = true;\n+      }\n     }\n   }\n   node.body = this.finishNode(classBody, \"ClassBody\");\n+  this.strict = oldStrict;\n   return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n };\n \n-pp$1.parseClassMember = function(classBody) {\n+pp$1.parseClassElement = function(constructorAllowsSuper) {\n   var this$1 = this;\n \n   if (this.eat(types.semi)) { return null }\n@@ -1287,16 +1358,18 @@ pp$1.parseClassMember = function(classBody) {\n   }\n   if (!method.key) { this.parsePropertyName(method); }\n   var key = method.key;\n+  var allowsDirectSuper = false;\n   if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n       key.type === \"Literal\" && key.value === \"constructor\")) {\n     if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n     if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n     if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n     method.kind = \"constructor\";\n+    allowsDirectSuper = constructorAllowsSuper;\n   } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n     this.raise(key.start, \"Classes may not have a static property named prototype\");\n   }\n-  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n+  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n   if (method.kind === \"get\" && method.value.params.length !== 0)\n     { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n   if (method.kind === \"set\" && method.value.params.length !== 1)\n@@ -1306,13 +1379,21 @@ pp$1.parseClassMember = function(classBody) {\n   return method\n };\n \n-pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n-  method.value = this.parseMethod(isGenerator, isAsync);\n-  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n+pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n+  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n+  return this.finishNode(method, \"MethodDefinition\")\n };\n \n pp$1.parseClassId = function(node, isStatement) {\n-  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n+  if (this.type === types.name) {\n+    node.id = this.parseIdent();\n+    if (isStatement === true)\n+      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n+  } else {\n+    if (isStatement === true)\n+      { this.unexpected(); }\n+    node.id = null;\n+  }\n };\n \n pp$1.parseClassSuper = function(node) {\n@@ -1340,7 +1421,7 @@ pp$1.parseExport = function(node, exports) {\n       var fNode = this.startNode();\n       this.next();\n       if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n     } else if (this.type === types._class) {\n       var cNode = this.startNode();\n       node.declaration = this.parseClass(cNode, \"nullableID\");\n@@ -1352,7 +1433,7 @@ pp$1.parseExport = function(node, exports) {\n   }\n   // export var|const|let|function|class ...\n   if (this.shouldParseExportStatement()) {\n-    node.declaration = this.parseStatement(true);\n+    node.declaration = this.parseStatement(null);\n     if (node.declaration.type === \"VariableDeclaration\")\n       { this.checkVariableExport(exports, node.declaration.declarations); }\n     else\n@@ -1366,11 +1447,13 @@ pp$1.parseExport = function(node, exports) {\n       if (this.type !== types.string) { this.unexpected(); }\n       node.source = this.parseExprAtom();\n     } else {\n-      // check for keywords used as local names\n       for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n+        // check for keywords used as local names\n         var spec = list[i];\n \n         this$1.checkUnreserved(spec.local);\n+        // check if export is defined\n+        this$1.checkLocalExport(spec.local);\n       }\n \n       node.source = null;\n@@ -1487,7 +1570,7 @@ pp$1.parseImportSpecifiers = function() {\n     // import defaultObj, { x, y as z } from '...'\n     var node = this.startNode();\n     node.local = this.parseIdent();\n-    this.checkLVal(node.local, \"let\");\n+    this.checkLVal(node.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n     if (!this.eat(types.comma)) { return nodes }\n   }\n@@ -1496,7 +1579,7 @@ pp$1.parseImportSpecifiers = function() {\n     this.next();\n     this.expectContextual(\"as\");\n     node$1.local = this.parseIdent();\n-    this.checkLVal(node$1.local, \"let\");\n+    this.checkLVal(node$1.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n     return nodes\n   }\n@@ -1515,7 +1598,7 @@ pp$1.parseImportSpecifiers = function() {\n       this$1.checkUnreserved(node$2.imported);\n       node$2.local = node$2.imported;\n     }\n-    this$1.checkLVal(node$2.local, \"let\");\n+    this$1.checkLVal(node$2.local, BIND_LEXICAL);\n     nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n   }\n   return nodes\n@@ -1549,7 +1632,7 @@ pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n     switch (node.type) {\n     case \"Identifier\":\n       if (this.inAsync && node.name === \"await\")\n-        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n+        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n       break\n \n     case \"ObjectPattern\":\n@@ -1608,7 +1691,7 @@ pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n       break\n \n     case \"ParenthesizedExpression\":\n-      this.toAssignable(node.expression, isBinding);\n+      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n       break\n \n     case \"MemberExpression\":\n@@ -1730,6 +1813,7 @@ pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n \n pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n   var this$1 = this;\n+  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n \n   switch (expr.type) {\n   case \"Identifier\":\n@@ -1740,19 +1824,7 @@ pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n         { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n       checkClashes[expr.name] = true;\n     }\n-    if (bindingType && bindingType !== \"none\") {\n-      if (\n-        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n-        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n-      ) {\n-        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n-      }\n-      if (bindingType === \"var\") {\n-        this.declareVarName(expr.name);\n-      } else {\n-        this.declareLexicalName(expr.name);\n-      }\n-    }\n+    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n     break\n \n   case \"MemberExpression\":\n@@ -1901,13 +1973,19 @@ pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n // operators like `+=`.\n \n pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n-  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n+  if (this.isContextual(\"yield\")) {\n+    if (this.inGenerator) { return this.parseYield(noIn) }\n+    // The tokenizer will assume an expression is allowed after\n+    // `yield`, but this isn't that kind of yield\n+    else { this.exprAllowed = false; }\n+  }\n \n-  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n   if (refDestructuringErrors) {\n     oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n     oldTrailingComma = refDestructuringErrors.trailingComma;\n-    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n+    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n+    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n   } else {\n     refDestructuringErrors = new DestructuringErrors;\n     ownDestructuringErrors = true;\n@@ -1933,6 +2011,7 @@ pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n   }\n   if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n   if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n+  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n   return left\n };\n \n@@ -2063,20 +2142,25 @@ pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n       if (computed) { this$1.expect(types.bracketR); }\n       base = this$1.finishNode(node, \"MemberExpression\");\n     } else if (!noCalls && this$1.eat(types.parenL)) {\n-      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n+      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos, oldAwaitIdentPos = this$1.awaitIdentPos;\n       this$1.yieldPos = 0;\n       this$1.awaitPos = 0;\n+      this$1.awaitIdentPos = 0;\n       var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n       if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n         this$1.checkPatternErrors(refDestructuringErrors, false);\n         this$1.checkYieldAwaitInDefaultParams();\n+        if (this$1.awaitIdentPos > 0)\n+          { this$1.raise(this$1.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n         this$1.yieldPos = oldYieldPos;\n         this$1.awaitPos = oldAwaitPos;\n+        this$1.awaitIdentPos = oldAwaitIdentPos;\n         return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n       }\n       this$1.checkExpressionErrors(refDestructuringErrors, true);\n       this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n       this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n+      this$1.awaitIdentPos = oldAwaitIdentPos || this$1.awaitIdentPos;\n       var node$1 = this$1.startNodeAt(startPos, startLoc);\n       node$1.callee = base;\n       node$1.arguments = exprList;\n@@ -2098,13 +2182,19 @@ pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n // or `{}`.\n \n pp$3.parseExprAtom = function(refDestructuringErrors) {\n+  // If a division operator appears in an expression position, the\n+  // tokenizer got confused, and we force it to read a regexp instead.\n+  if (this.type === types.slash) { this.readRegexp(); }\n+\n   var node, canBeArrow = this.potentialArrowAt === this.start;\n   switch (this.type) {\n   case types._super:\n-    if (!this.inFunction)\n-      { this.raise(this.start, \"'super' outside of function or class\"); }\n+    if (!this.allowSuper)\n+      { this.raise(this.start, \"'super' keyword outside a method\"); }\n     node = this.startNode();\n     this.next();\n+    if (this.type === types.parenL && !this.allowDirectSuper)\n+      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n     // The `super` keyword can appear at below:\n     // SuperProperty:\n     //     super [ Expression ]\n@@ -2122,14 +2212,14 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n \n   case types.name:\n     var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n-    var id = this.parseIdent(this.type !== types.name);\n+    var id = this.parseIdent(false);\n     if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n-      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n+      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n     if (canBeArrow && !this.canInsertSemicolon()) {\n       if (this.eat(types.arrow))\n         { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n       if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n-        id = this.parseIdent();\n+        id = this.parseIdent(false);\n         if (this.canInsertSemicolon() || !this.eat(types.arrow))\n           { this.unexpected(); }\n         return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n@@ -2175,7 +2265,7 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n   case types._function:\n     node = this.startNode();\n     this.next();\n-    return this.parseFunction(node, false)\n+    return this.parseFunction(node, 0)\n \n   case types._class:\n     return this.parseClass(this.startNode(), false)\n@@ -2218,6 +2308,7 @@ pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n     var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n     this.yieldPos = 0;\n     this.awaitPos = 0;\n+    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n     while (this.type !== types.parenR) {\n       first ? first = false : this$1.expect(types.comma);\n       if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n@@ -2294,7 +2385,7 @@ pp$3.parseNew = function() {\n     node.property = this.parseIdent(true);\n     if (node.property.name !== \"target\" || containsEsc)\n       { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n-    if (!this.inFunction)\n+    if (!this.inNonArrowFunction())\n       { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n     return this.finishNode(node, \"MetaProperty\")\n   }\n@@ -2341,6 +2432,7 @@ pp$3.parseTemplate = function(ref) {\n   var curElt = this.parseTemplateElement({isTagged: isTagged});\n   node.quasis = [curElt];\n   while (!curElt.tail) {\n+    if (this$1.type === types.eof) { this$1.raise(this$1.pos, \"Unterminated template literal\"); }\n     this$1.expect(types.dollarBraceL);\n     node.expressions.push(this$1.parseExpression());\n     this$1.expect(types.braceR);\n@@ -2460,7 +2552,10 @@ pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startP\n         { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n     }\n   } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n+    if (isGenerator || isAsync) { this.unexpected(); }\n     this.checkUnreserved(prop.key);\n+    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n+      { this.awaitIdentPos = startPos; }\n     prop.kind = \"init\";\n     if (isPattern) {\n       prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n@@ -2493,77 +2588,62 @@ pp$3.parsePropertyName = function(prop) {\n \n pp$3.initFunction = function(node) {\n   node.id = null;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n+  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n+  if (this.options.ecmaVersion >= 8) { node.async = false; }\n };\n \n // Parse object or class method.\n \n-pp$3.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n+  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n \n   this.initFunction(node);\n   if (this.options.ecmaVersion >= 6)\n     { node.generator = isGenerator; }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.awaitIdentPos = 0;\n+  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n \n   this.expect(types.parenL);\n   node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n   this.checkYieldAwaitInDefaultParams();\n-  this.parseFunctionBody(node, false);\n+  this.parseFunctionBody(node, false, true);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n+  this.awaitIdentPos = oldAwaitIdentPos;\n   return this.finishNode(node, \"FunctionExpression\")\n };\n \n // Parse arrow function expression with given parameters.\n \n pp$3.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n \n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n   this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n+  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n \n-  this.inGenerator = false;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n+  this.awaitIdentPos = 0;\n \n   node.params = this.toAssignableList(params, true);\n-  this.parseFunctionBody(node, true);\n+  this.parseFunctionBody(node, true, false);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n+  this.awaitIdentPos = oldAwaitIdentPos;\n   return this.finishNode(node, \"ArrowFunctionExpression\")\n };\n \n // Parse function body and check parameters.\n \n-pp$3.parseFunctionBody = function(node, isArrowFunction) {\n+pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n   var isExpression = isArrowFunction && this.type !== types.braceL;\n   var oldStrict = this.strict, useStrict = false;\n \n@@ -2589,18 +2669,16 @@ pp$3.parseFunctionBody = function(node, isArrowFunction) {\n \n     // Add the params to varDeclaredNames to ensure that an error is thrown\n     // if a let/const declaration in the function clashes with one of the params.\n-    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n+    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n     node.body = this.parseBlock(false);\n     node.expression = false;\n     this.adaptDirectivePrologue(node.body.body);\n     this.labels = oldLabels;\n   }\n-  this.exitFunctionScope();\n+  this.exitScope();\n \n-  if (this.strict && node.id) {\n-    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n-    this.checkLVal(node.id, \"none\");\n-  }\n+  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n+  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n   this.strict = oldStrict;\n };\n \n@@ -2625,7 +2703,7 @@ pp$3.checkParams = function(node, allowDuplicates) {\n     {\n     var param = list[i];\n \n-    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n+    this$1.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n   }\n };\n \n@@ -2666,17 +2744,17 @@ pp$3.checkUnreserved = function(ref) {\n   var name = ref.name;\n \n   if (this.inGenerator && name === \"yield\")\n-    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n+    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n   if (this.inAsync && name === \"await\")\n-    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n-  if (this.isKeyword(name))\n+    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n+  if (this.keywords.test(name))\n     { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n   if (this.options.ecmaVersion < 6 &&\n     this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n   var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n   if (re.test(name)) {\n     if (!this.inAsync && name === \"await\")\n-      { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\n+      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n     this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n   }\n };\n@@ -2706,13 +2784,17 @@ pp$3.parseIdent = function(liberal, isBinding) {\n   }\n   this.next();\n   this.finishNode(node, \"Identifier\");\n-  if (!liberal) { this.checkUnreserved(node); }\n+  if (!liberal) {\n+    this.checkUnreserved(node);\n+    if (node.name === \"await\" && !this.awaitIdentPos)\n+      { this.awaitIdentPos = node.start; }\n+  }\n   return node\n };\n \n // Parses yield expression inside generator.\n \n-pp$3.parseYield = function() {\n+pp$3.parseYield = function(noIn) {\n   if (!this.yieldPos) { this.yieldPos = this.start; }\n \n   var node = this.startNode();\n@@ -2722,7 +2804,7 @@ pp$3.parseYield = function() {\n     node.argument = null;\n   } else {\n     node.delegate = this.eat(types.star);\n-    node.argument = this.parseMaybeAssign();\n+    node.argument = this.parseMaybeAssign(noIn);\n   }\n   return this.finishNode(node, \"YieldExpression\")\n };\n@@ -2762,79 +2844,99 @@ pp$4.curPosition = function() {\n \n var pp$5 = Parser.prototype;\n \n-// Object.assign polyfill\n-var assign = Object.assign || function(target) {\n-  var sources = [], len = arguments.length - 1;\n-  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n-\n-  for (var i = 0, list = sources; i < list.length; i += 1) {\n-    var source = list[i];\n-\n-    for (var key in source) {\n-      if (has(source, key)) {\n-        target[key] = source[key];\n-      }\n-    }\n-  }\n-  return target\n+var Scope = function Scope(flags) {\n+  this.flags = flags;\n+  // A list of var-declared names in the current lexical scope\n+  this.var = [];\n+  // A list of lexically-declared names in the current lexical scope\n+  this.lexical = [];\n+  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n+  this.functions = [];\n };\n \n // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n \n-pp$5.enterFunctionScope = function() {\n-  // var: a hash of var-declared names in the current lexical scope\n-  // lexical: a hash of lexically-declared names in the current lexical scope\n-  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n-  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n-  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n+pp$5.enterScope = function(flags) {\n+  this.scopeStack.push(new Scope(flags));\n };\n \n-pp$5.exitFunctionScope = function() {\n+pp$5.exitScope = function() {\n   this.scopeStack.pop();\n };\n \n-pp$5.enterLexicalScope = function() {\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n-  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n-\n-  this.scopeStack.push(childScope);\n-  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n+// The spec says:\n+// > At the top level of a function, or script, function declarations are\n+// > treated like var declarations rather than like lexical declarations.\n+pp$5.treatFunctionsAsVarInScope = function(scope) {\n+  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP);\n };\n \n-pp$5.exitLexicalScope = function() {\n-  var childScope = this.scopeStack.pop();\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.declareName = function(name, bindingType, pos) {\n+  var this$1 = this;\n \n-  assign(parentScope.childVar, childScope.var, childScope.childVar);\n+  var redeclared = false;\n+  if (bindingType === BIND_LEXICAL) {\n+    var scope = this.currentScope();\n+    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n+    scope.lexical.push(name);\n+    if (this.inModule && (scope.flags & SCOPE_TOP))\n+      { delete this.undefinedExports[name]; }\n+  } else if (bindingType === BIND_SIMPLE_CATCH) {\n+    var scope$1 = this.currentScope();\n+    scope$1.lexical.push(name);\n+  } else if (bindingType === BIND_FUNCTION) {\n+    var scope$2 = this.currentScope();\n+    if (this.treatFunctionsAsVar)\n+      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n+    else\n+      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n+    scope$2.functions.push(name);\n+  } else {\n+    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n+      var scope$3 = this$1.scopeStack[i];\n+      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name ||\n+          !this$1.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n+        redeclared = true;\n+        break\n+      }\n+      scope$3.var.push(name);\n+      if (this$1.inModule && (scope$3.flags & SCOPE_TOP))\n+        { delete this$1.undefinedExports[name]; }\n+      if (scope$3.flags & SCOPE_VAR) { break }\n+    }\n+  }\n+  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n };\n \n-/**\n- * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n- * in the current lexical scope or any of the parent lexical scopes in this function.\n- */\n-pp$5.canDeclareVarName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.checkLocalExport = function(id) {\n+  // scope.functions must be empty as Module code is always strict.\n+  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n+      this.scopeStack[0].var.indexOf(id.name) === -1) {\n+    this.undefinedExports[id.name] = id;\n+  }\n+};\n \n-  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n+pp$5.currentScope = function() {\n+  return this.scopeStack[this.scopeStack.length - 1]\n };\n \n-/**\n- * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n- * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n- * any child lexical scopes in this function.\n- */\n-pp$5.canDeclareLexicalName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.currentVarScope = function() {\n+  var this$1 = this;\n \n-  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n+  for (var i = this.scopeStack.length - 1;; i--) {\n+    var scope = this$1.scopeStack[i];\n+    if (scope.flags & SCOPE_VAR) { return scope }\n+  }\n };\n \n-pp$5.declareVarName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n-};\n+// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n+pp$5.currentThisScope = function() {\n+  var this$1 = this;\n \n-pp$5.declareLexicalName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n+  for (var i = this.scopeStack.length - 1;; i--) {\n+    var scope = this$1.scopeStack[i];\n+    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n+  }\n };\n \n var Node = function Node(parser, pos, loc) {\n@@ -2930,7 +3032,7 @@ pp$7.braceIsBlock = function(prevType) {\n     { return true }\n   if (prevType === types.braceL)\n     { return parent === types$1.b_stat }\n-  if (prevType === types._var || prevType === types.name)\n+  if (prevType === types._var || prevType === types._const || prevType === types.name)\n     { return false }\n   return !this.exprAllowed\n };\n@@ -2992,6 +3094,7 @@ types.incDec.updateContext = function() {\n \n types._function.updateContext = types._class.updateContext = function(prevType) {\n   if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n+      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n       !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n     { this.context.push(types$1.f_expr); }\n   else\n@@ -3020,481 +3123,59 @@ types.star.updateContext = function(prevType) {\n \n types.name.updateContext = function(prevType) {\n   var allowed = false;\n-  if (this.options.ecmaVersion >= 6) {\n+  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n     if (this.value === \"of\" && !this.exprAllowed ||\n         this.value === \"yield\" && this.inGeneratorContext())\n       { allowed = true; }\n   }\n   this.exprAllowed = allowed;\n };\n \n-var data = {\n-  \"$LONE\": [\n-    \"ASCII\",\n-    \"ASCII_Hex_Digit\",\n-    \"AHex\",\n-    \"Alphabetic\",\n-    \"Alpha\",\n-    \"Any\",\n-    \"Assigned\",\n-    \"Bidi_Control\",\n-    \"Bidi_C\",\n-    \"Bidi_Mirrored\",\n-    \"Bidi_M\",\n-    \"Case_Ignorable\",\n-    \"CI\",\n-    \"Cased\",\n-    \"Changes_When_Casefolded\",\n-    \"CWCF\",\n-    \"Changes_When_Casemapped\",\n-    \"CWCM\",\n-    \"Changes_When_Lowercased\",\n-    \"CWL\",\n-    \"Changes_When_NFKC_Casefolded\",\n-    \"CWKCF\",\n-    \"Changes_When_Titlecased\",\n-    \"CWT\",\n-    \"Changes_When_Uppercased\",\n-    \"CWU\",\n-    \"Dash\",\n-    \"Default_Ignorable_Code_Point\",\n-    \"DI\",\n-    \"Deprecated\",\n-    \"Dep\",\n-    \"Diacritic\",\n-    \"Dia\",\n-    \"Emoji\",\n-    \"Emoji_Component\",\n-    \"Emoji_Modifier\",\n-    \"Emoji_Modifier_Base\",\n-    \"Emoji_Presentation\",\n-    \"Extender\",\n-    \"Ext\",\n-    \"Grapheme_Base\",\n-    \"Gr_Base\",\n-    \"Grapheme_Extend\",\n-    \"Gr_Ext\",\n-    \"Hex_Digit\",\n-    \"Hex\",\n-    \"IDS_Binary_Operator\",\n-    \"IDSB\",\n-    \"IDS_Trinary_Operator\",\n-    \"IDST\",\n-    \"ID_Continue\",\n-    \"IDC\",\n-    \"ID_Start\",\n-    \"IDS\",\n-    \"Ideographic\",\n-    \"Ideo\",\n-    \"Join_Control\",\n-    \"Join_C\",\n-    \"Logical_Order_Exception\",\n-    \"LOE\",\n-    \"Lowercase\",\n-    \"Lower\",\n-    \"Math\",\n-    \"Noncharacter_Code_Point\",\n-    \"NChar\",\n-    \"Pattern_Syntax\",\n-    \"Pat_Syn\",\n-    \"Pattern_White_Space\",\n-    \"Pat_WS\",\n-    \"Quotation_Mark\",\n-    \"QMark\",\n-    \"Radical\",\n-    \"Regional_Indicator\",\n-    \"RI\",\n-    \"Sentence_Terminal\",\n-    \"STerm\",\n-    \"Soft_Dotted\",\n-    \"SD\",\n-    \"Terminal_Punctuation\",\n-    \"Term\",\n-    \"Unified_Ideograph\",\n-    \"UIdeo\",\n-    \"Uppercase\",\n-    \"Upper\",\n-    \"Variation_Selector\",\n-    \"VS\",\n-    \"White_Space\",\n-    \"space\",\n-    \"XID_Continue\",\n-    \"XIDC\",\n-    \"XID_Start\",\n-    \"XIDS\"\n-  ],\n-  \"General_Category\": [\n-    \"Cased_Letter\",\n-    \"LC\",\n-    \"Close_Punctuation\",\n-    \"Pe\",\n-    \"Connector_Punctuation\",\n-    \"Pc\",\n-    \"Control\",\n-    \"Cc\",\n-    \"cntrl\",\n-    \"Currency_Symbol\",\n-    \"Sc\",\n-    \"Dash_Punctuation\",\n-    \"Pd\",\n-    \"Decimal_Number\",\n-    \"Nd\",\n-    \"digit\",\n-    \"Enclosing_Mark\",\n-    \"Me\",\n-    \"Final_Punctuation\",\n-    \"Pf\",\n-    \"Format\",\n-    \"Cf\",\n-    \"Initial_Punctuation\",\n-    \"Pi\",\n-    \"Letter\",\n-    \"L\",\n-    \"Letter_Number\",\n-    \"Nl\",\n-    \"Line_Separator\",\n-    \"Zl\",\n-    \"Lowercase_Letter\",\n-    \"Ll\",\n-    \"Mark\",\n-    \"M\",\n-    \"Combining_Mark\",\n-    \"Math_Symbol\",\n-    \"Sm\",\n-    \"Modifier_Letter\",\n-    \"Lm\",\n-    \"Modifier_Symbol\",\n-    \"Sk\",\n-    \"Nonspacing_Mark\",\n-    \"Mn\",\n-    \"Number\",\n-    \"N\",\n-    \"Open_Punctuation\",\n-    \"Ps\",\n-    \"Other\",\n-    \"C\",\n-    \"Other_Letter\",\n-    \"Lo\",\n-    \"Other_Number\",\n-    \"No\",\n-    \"Other_Punctuation\",\n-    \"Po\",\n-    \"Other_Symbol\",\n-    \"So\",\n-    \"Paragraph_Separator\",\n-    \"Zp\",\n-    \"Private_Use\",\n-    \"Co\",\n-    \"Punctuation\",\n-    \"P\",\n-    \"punct\",\n-    \"Separator\",\n-    \"Z\",\n-    \"Space_Separator\",\n-    \"Zs\",\n-    \"Spacing_Mark\",\n-    \"Mc\",\n-    \"Surrogate\",\n-    \"Cs\",\n-    \"Symbol\",\n-    \"S\",\n-    \"Titlecase_Letter\",\n-    \"Lt\",\n-    \"Unassigned\",\n-    \"Cn\",\n-    \"Uppercase_Letter\",\n-    \"Lu\"\n-  ],\n-  \"Script\": [\n-    \"Adlam\",\n-    \"Adlm\",\n-    \"Ahom\",\n-    \"Anatolian_Hieroglyphs\",\n-    \"Hluw\",\n-    \"Arabic\",\n-    \"Arab\",\n-    \"Armenian\",\n-    \"Armn\",\n-    \"Avestan\",\n-    \"Avst\",\n-    \"Balinese\",\n-    \"Bali\",\n-    \"Bamum\",\n-    \"Bamu\",\n-    \"Bassa_Vah\",\n-    \"Bass\",\n-    \"Batak\",\n-    \"Batk\",\n-    \"Bengali\",\n-    \"Beng\",\n-    \"Bhaiksuki\",\n-    \"Bhks\",\n-    \"Bopomofo\",\n-    \"Bopo\",\n-    \"Brahmi\",\n-    \"Brah\",\n-    \"Braille\",\n-    \"Brai\",\n-    \"Buginese\",\n-    \"Bugi\",\n-    \"Buhid\",\n-    \"Buhd\",\n-    \"Canadian_Aboriginal\",\n-    \"Cans\",\n-    \"Carian\",\n-    \"Cari\",\n-    \"Caucasian_Albanian\",\n-    \"Aghb\",\n-    \"Chakma\",\n-    \"Cakm\",\n-    \"Cham\",\n-    \"Cherokee\",\n-    \"Cher\",\n-    \"Common\",\n-    \"Zyyy\",\n-    \"Coptic\",\n-    \"Copt\",\n-    \"Qaac\",\n-    \"Cuneiform\",\n-    \"Xsux\",\n-    \"Cypriot\",\n-    \"Cprt\",\n-    \"Cyrillic\",\n-    \"Cyrl\",\n-    \"Deseret\",\n-    \"Dsrt\",\n-    \"Devanagari\",\n-    \"Deva\",\n-    \"Duployan\",\n-    \"Dupl\",\n-    \"Egyptian_Hieroglyphs\",\n-    \"Egyp\",\n-    \"Elbasan\",\n-    \"Elba\",\n-    \"Ethiopic\",\n-    \"Ethi\",\n-    \"Georgian\",\n-    \"Geor\",\n-    \"Glagolitic\",\n-    \"Glag\",\n-    \"Gothic\",\n-    \"Goth\",\n-    \"Grantha\",\n-    \"Gran\",\n-    \"Greek\",\n-    \"Grek\",\n-    \"Gujarati\",\n-    \"Gujr\",\n-    \"Gurmukhi\",\n-    \"Guru\",\n-    \"Han\",\n-    \"Hani\",\n-    \"Hangul\",\n-    \"Hang\",\n-    \"Hanunoo\",\n-    \"Hano\",\n-    \"Hatran\",\n-    \"Hatr\",\n-    \"Hebrew\",\n-    \"Hebr\",\n-    \"Hiragana\",\n-    \"Hira\",\n-    \"Imperial_Aramaic\",\n-    \"Armi\",\n-    \"Inherited\",\n-    \"Zinh\",\n-    \"Qaai\",\n-    \"Inscriptional_Pahlavi\",\n-    \"Phli\",\n-    \"Inscriptional_Parthian\",\n-    \"Prti\",\n-    \"Javanese\",\n-    \"Java\",\n-    \"Kaithi\",\n-    \"Kthi\",\n-    \"Kannada\",\n-    \"Knda\",\n-    \"Katakana\",\n-    \"Kana\",\n-    \"Kayah_Li\",\n-    \"Kali\",\n-    \"Kharoshthi\",\n-    \"Khar\",\n-    \"Khmer\",\n-    \"Khmr\",\n-    \"Khojki\",\n-    \"Khoj\",\n-    \"Khudawadi\",\n-    \"Sind\",\n-    \"Lao\",\n-    \"Laoo\",\n-    \"Latin\",\n-    \"Latn\",\n-    \"Lepcha\",\n-    \"Lepc\",\n-    \"Limbu\",\n-    \"Limb\",\n-    \"Linear_A\",\n-    \"Lina\",\n-    \"Linear_B\",\n-    \"Linb\",\n-    \"Lisu\",\n-    \"Lycian\",\n-    \"Lyci\",\n-    \"Lydian\",\n-    \"Lydi\",\n-    \"Mahajani\",\n-    \"Mahj\",\n-    \"Malayalam\",\n-    \"Mlym\",\n-    \"Mandaic\",\n-    \"Mand\",\n-    \"Manichaean\",\n-    \"Mani\",\n-    \"Marchen\",\n-    \"Marc\",\n-    \"Masaram_Gondi\",\n-    \"Gonm\",\n-    \"Meetei_Mayek\",\n-    \"Mtei\",\n-    \"Mende_Kikakui\",\n-    \"Mend\",\n-    \"Meroitic_Cursive\",\n-    \"Merc\",\n-    \"Meroitic_Hieroglyphs\",\n-    \"Mero\",\n-    \"Miao\",\n-    \"Plrd\",\n-    \"Modi\",\n-    \"Mongolian\",\n-    \"Mong\",\n-    \"Mro\",\n-    \"Mroo\",\n-    \"Multani\",\n-    \"Mult\",\n-    \"Myanmar\",\n-    \"Mymr\",\n-    \"Nabataean\",\n-    \"Nbat\",\n-    \"New_Tai_Lue\",\n-    \"Talu\",\n-    \"Newa\",\n-    \"Nko\",\n-    \"Nkoo\",\n-    \"Nushu\",\n-    \"Nshu\",\n-    \"Ogham\",\n-    \"Ogam\",\n-    \"Ol_Chiki\",\n-    \"Olck\",\n-    \"Old_Hungarian\",\n-    \"Hung\",\n-    \"Old_Italic\",\n-    \"Ital\",\n-    \"Old_North_Arabian\",\n-    \"Narb\",\n-    \"Old_Permic\",\n-    \"Perm\",\n-    \"Old_Persian\",\n-    \"Xpeo\",\n-    \"Old_South_Arabian\",\n-    \"Sarb\",\n-    \"Old_Turkic\",\n-    \"Orkh\",\n-    \"Oriya\",\n-    \"Orya\",\n-    \"Osage\",\n-    \"Osge\",\n-    \"Osmanya\",\n-    \"Osma\",\n-    \"Pahawh_Hmong\",\n-    \"Hmng\",\n-    \"Palmyrene\",\n-    \"Palm\",\n-    \"Pau_Cin_Hau\",\n-    \"Pauc\",\n-    \"Phags_Pa\",\n-    \"Phag\",\n-    \"Phoenician\",\n-    \"Phnx\",\n-    \"Psalter_Pahlavi\",\n-    \"Phlp\",\n-    \"Rejang\",\n-    \"Rjng\",\n-    \"Runic\",\n-    \"Runr\",\n-    \"Samaritan\",\n-    \"Samr\",\n-    \"Saurashtra\",\n-    \"Saur\",\n-    \"Sharada\",\n-    \"Shrd\",\n-    \"Shavian\",\n-    \"Shaw\",\n-    \"Siddham\",\n-    \"Sidd\",\n-    \"SignWriting\",\n-    \"Sgnw\",\n-    \"Sinhala\",\n-    \"Sinh\",\n-    \"Sora_Sompeng\",\n-    \"Sora\",\n-    \"Soyombo\",\n-    \"Soyo\",\n-    \"Sundanese\",\n-    \"Sund\",\n-    \"Syloti_Nagri\",\n-    \"Sylo\",\n-    \"Syriac\",\n-    \"Syrc\",\n-    \"Tagalog\",\n-    \"Tglg\",\n-    \"Tagbanwa\",\n-    \"Tagb\",\n-    \"Tai_Le\",\n-    \"Tale\",\n-    \"Tai_Tham\",\n-    \"Lana\",\n-    \"Tai_Viet\",\n-    \"Tavt\",\n-    \"Takri\",\n-    \"Takr\",\n-    \"Tamil\",\n-    \"Taml\",\n-    \"Tangut\",\n-    \"Tang\",\n-    \"Telugu\",\n-    \"Telu\",\n-    \"Thaana\",\n-    \"Thaa\",\n-    \"Thai\",\n-    \"Tibetan\",\n-    \"Tibt\",\n-    \"Tifinagh\",\n-    \"Tfng\",\n-    \"Tirhuta\",\n-    \"Tirh\",\n-    \"Ugaritic\",\n-    \"Ugar\",\n-    \"Vai\",\n-    \"Vaii\",\n-    \"Warang_Citi\",\n-    \"Wara\",\n-    \"Yi\",\n-    \"Yiii\",\n-    \"Zanabazar_Square\",\n-    \"Zanb\"\n-  ]\n-};\n-Array.prototype.push.apply(data.$LONE, data.General_Category);\n-data.gc = data.General_Category;\n-data.sc = data.Script_Extensions = data.scx = data.Script;\n+// This file contains Unicode properties extracted from the ECMAScript\n+// specification. The lists are extracted like so:\n+// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n+\n+// #table-binary-unicode-properties\n+var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n+var unicodeBinaryProperties = {\n+  9: ecma9BinaryProperties,\n+  10: ecma9BinaryProperties + \" Extended_Pictographic\"\n+};\n+\n+// #table-unicode-general-category-values\n+var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n+\n+// #table-unicode-script-values\n+var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n+var unicodeScriptValues = {\n+  9: ecma9ScriptValues,\n+  10: ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\"\n+};\n+\n+var data = {};\n+function buildUnicodeData(ecmaVersion) {\n+  var d = data[ecmaVersion] = {\n+    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n+    nonBinary: {\n+      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n+      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n+    }\n+  };\n+  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n+\n+  d.nonBinary.gc = d.nonBinary.General_Category;\n+  d.nonBinary.sc = d.nonBinary.Script;\n+  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n+}\n+buildUnicodeData(9);\n+buildUnicodeData(10);\n \n var pp$9 = Parser.prototype;\n \n var RegExpValidationState = function RegExpValidationState(parser) {\n   this.parser = parser;\n   this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n+  this.unicodeProperties = data[parser.options.ecmaVersion >= 10 ? 10 : parser.options.ecmaVersion];\n   this.source = \"\";\n   this.flags = \"\";\n   this.start = 0;\n@@ -4278,14 +3959,14 @@ pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\n   return false\n };\n pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n-  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n-    state.raise(\"Invalid property name\");\n-  }\n+  if (!has(state.unicodeProperties.nonBinary, name))\n+    { state.raise(\"Invalid property name\"); }\n+  if (!state.unicodeProperties.nonBinary[name].test(value))\n+    { state.raise(\"Invalid property value\"); }\n };\n pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n-  if (data.$LONE.indexOf(nameOrValue) === -1) {\n-    state.raise(\"Invalid property name\");\n-  }\n+  if (!state.unicodeProperties.binary.test(nameOrValue))\n+    { state.raise(\"Invalid property name\"); }\n };\n \n // UnicodePropertyName ::\n@@ -5185,6 +4866,11 @@ pp$8.readEscapedChar = function(inTemplate) {\n       }\n       return String.fromCharCode(octal)\n     }\n+    if (isNewLine(ch)) {\n+      // Unicode new line characters after \\ get removed from output in both\n+      // template literals and strings\n+      return \"\"\n+    }\n     return String.fromCharCode(ch)\n   }\n };\n@@ -5261,14 +4947,9 @@ pp$8.readWord = function() {\n //\n // [ghbt]: https://github.com/acornjs/acorn/issues\n //\n-// This file defines the main parser interface. The library also comes\n-// with a [error-tolerant parser][dammit] and an\n-// [abstract syntax tree walker][walk], defined in other files.\n-//\n-// [dammit]: acorn_loose.js\n // [walk]: util/walk.js\n \n-var version = \"5.7.2\";\n+var version = \"6.0.7\";\n \n // The main exported interface (under `self.acorn` when in the\n // browser) is a `parse` function that takes a code string and\n@@ -5278,36 +4959,23 @@ var version = \"5.7.2\";\n // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n \n function parse(input, options) {\n-  return new Parser(options, input).parse()\n+  return Parser.parse(input, options)\n }\n \n // This function tries to parse a single expression at a given\n // offset in a string. Useful for parsing mixed-language formats\n // that embed JavaScript expressions.\n \n function parseExpressionAt(input, pos, options) {\n-  var p = new Parser(options, input, pos);\n-  p.nextToken();\n-  return p.parseExpression()\n+  return Parser.parseExpressionAt(input, pos, options)\n }\n \n // Acorn is organized as a tokenizer and a recursive-descent parser.\n // The `tokenizer` export provides an interface to the tokenizer.\n \n function tokenizer(input, options) {\n-  return new Parser(options, input)\n-}\n-\n-// This is a terrible kludge to support the existing, pre-ES6\n-// interface where the loose parser module retroactively adds exports\n-// to this module.\n-var parse_dammit;\n-var LooseParser;\n-var pluginsLoose; // eslint-disable-line camelcase\n-function addLooseExports(parse, Parser$$1, plugins$$1) {\n-  parse_dammit = parse; // eslint-disable-line camelcase\n-  LooseParser = Parser$$1;\n-  pluginsLoose = plugins$$1;\n+  return Parser.tokenizer(input, options)\n }\n \n-export { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n+export { version, parse, parseExpressionAt, tokenizer, Parser, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n+//# sourceMappingURL=acorn.mjs.map",
            "previous_filename": "deps/acorn/dist/acorn.es.js"
        },
        {
            "sha": "77a7a8b8bfa4d9ad6a64b65d7d6aae577cfc30f9",
            "filename": "deps/acorn/acorn/dist/acorn.mjs.map",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs.map",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Facorn.mjs.map?ref=582c12260ed99ebe7710894c2dab29435b1bebdc"
        },
        {
            "sha": "f8961ce87eacc7fbd4470c4bcb1e3c58ba025945",
            "filename": "deps/acorn/acorn/dist/bin.js",
            "status": "renamed",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Fbin.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fdist%2Fbin.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fdist%2Fbin.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -1,9 +1,8 @@\n-#!/usr/bin/env node\n 'use strict';\n \n var path = require('path');\n var fs = require('fs');\n-var acorn = require('../dist/acorn.js');\n+var acorn = require('./acorn.js');\n \n var infile;\n var forceFile;",
            "previous_filename": "deps/acorn/bin/_acorn.js"
        },
        {
            "sha": "41f15082bb83087bab65be82807e0e29ccbecb4c",
            "filename": "deps/acorn/acorn/package.json",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/deps%2Facorn%2Facorn%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Facorn%2Fpackage.json?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -0,0 +1,34 @@\n+{\n+  \"name\": \"acorn\",\n+  \"description\": \"ECMAScript parser\",\n+  \"homepage\": \"https://github.com/acornjs/acorn\",\n+  \"main\": \"dist/acorn.js\",\n+  \"module\": \"dist/acorn.mjs\",\n+  \"version\": \"6.0.7\",\n+  \"engines\": {\"node\": \">=0.4.0\"},\n+  \"maintainers\": [\n+    {\n+      \"name\": \"Marijn Haverbeke\",\n+      \"email\": \"marijnh@gmail.com\",\n+      \"web\": \"https://marijnhaverbeke.nl\"\n+    },\n+    {\n+      \"name\": \"Ingvar Stepanyan\",\n+      \"email\": \"me@rreverser.com\",\n+      \"web\": \"https://rreverser.com/\"\n+    },\n+    {\n+      \"name\": \"Adrian Heine\",\n+      \"web\": \"http://adrianheine.de\"\n+    }\n+  ],\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/acornjs/acorn.git\"\n+  },\n+  \"license\": \"MIT\",\n+  \"scripts\": {\n+    \"prepare\": \"cd ..; npm run build:main && npm run build:bin\"\n+  },\n+  \"bin\": {\"acorn\": \"./bin/acorn\"}\n+}"
        },
        {
            "sha": "150429a1f20957dbe02911afe5deb7b214a79c00",
            "filename": "deps/acorn/bin/run_test262.js",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fbin%2Frun_test262.js",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fbin%2Frun_test262.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Fbin%2Frun_test262.js?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,21 +0,0 @@\n-const fs = require(\"fs\")\n-const path = require(\"path\")\n-const run = require(\"test262-parser-runner\")\n-const parse = require(\"..\").parse\n-\n-const unsupportedFeatures = [\n-  \"BigInt\",\n-  \"class-fields\",\n-  \"class-fields-private\",\n-  \"class-fields-public\",\n-  \"numeric-separator-literal\"\n-];\n-\n-run(\n-  (content, {sourceType}) => parse(content, {sourceType, ecmaVersion: 10}),\n-  {\n-    testsDirectory: path.dirname(require.resolve(\"test262/package.json\")),\n-    skip: test => (test.attrs.features && unsupportedFeatures.some(f => test.attrs.features.includes(f))),\n-    whitelist: fs.readFileSync(\"./bin/test262.whitelist\", \"utf8\").split(\"\\n\").filter(v => v)\n-  }\n-)"
        },
        {
            "sha": "c8c6ce4a82774ba060d0eab4beaa74408c6101e8",
            "filename": "deps/acorn/bin/test262.whitelist",
            "status": "removed",
            "additions": 0,
            "deletions": 404,
            "changes": 404,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fbin%2Ftest262.whitelist",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fbin%2Ftest262.whitelist",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Fbin%2Ftest262.whitelist?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,404 +0,0 @@\n-annexB/language/function-code/block-decl-func-no-skip-try.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err-block.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-no-else-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-no-skip-try.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err-try.js (default)\n-annexB/language/function-code/switch-case-func-no-skip-try.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err-block.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err-try.js (default)\n-annexB/language/function-code/switch-dflt-func-no-skip-try.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err-block.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err-try.js (default)\n-annexB/language/global-code/block-decl-global-no-skip-try.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err-block.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-no-else-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-no-skip-try.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err-try.js (default)\n-annexB/language/global-code/switch-case-global-no-skip-try.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err-block.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err-try.js (default)\n-annexB/language/global-code/switch-dflt-global-no-skip-try.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err-block.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err-try.js (default)\n-annexB/language/statements/try/catch-redeclared-for-in-var.js (default)\n-annexB/language/statements/try/catch-redeclared-for-in-var.js (strict mode)\n-annexB/language/statements/try/catch-redeclared-for-var.js (default)\n-annexB/language/statements/try/catch-redeclared-for-var.js (strict mode)\n-annexB/language/statements/try/catch-redeclared-var-statement-captured.js (default)\n-annexB/language/statements/try/catch-redeclared-var-statement-captured.js (strict mode)\n-annexB/language/statements/try/catch-redeclared-var-statement.js (default)\n-annexB/language/statements/try/catch-redeclared-var-statement.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/expressions/async-arrow-function/early-errors-arrow-await-in-formals-default.js (default)\n-language/expressions/async-arrow-function/early-errors-arrow-await-in-formals-default.js (strict mode)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-call.js (default)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-call.js (strict mode)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-property.js (default)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-property.js (strict mode)\n-language/expressions/async-function/early-errors-expression-body-contains-super-call.js (default)\n-language/expressions/async-function/early-errors-expression-body-contains-super-call.js (strict mode)\n-language/expressions/async-function/early-errors-expression-body-contains-super-property.js (default)\n-language/expressions/async-function/early-errors-expression-body-contains-super-property.js (strict mode)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-call.js (default)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-call.js (strict mode)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-property.js (default)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-property.js (strict mode)\n-language/expressions/class/method-param-dflt-yield.js (default)\n-language/expressions/class/static-method-param-dflt-yield.js (default)\n-language/expressions/function/early-body-super-call.js (default)\n-language/expressions/function/early-body-super-call.js (strict mode)\n-language/expressions/function/early-body-super-prop.js (default)\n-language/expressions/function/early-body-super-prop.js (strict mode)\n-language/expressions/function/early-params-super-call.js (default)\n-language/expressions/function/early-params-super-call.js (strict mode)\n-language/expressions/function/early-params-super-prop.js (default)\n-language/expressions/function/early-params-super-prop.js (strict mode)\n-language/expressions/object/method-definition/early-errors-object-method-body-contains-super-call.js (default)\n-language/expressions/object/method-definition/early-errors-object-method-body-contains-super-call.js (strict mode)\n-language/expressions/object/method-definition/early-errors-object-method-duplicate-parameters.js (default)\n-language/expressions/object/method-definition/early-errors-object-method-formals-contains-super-call.js (default)\n-language/expressions/object/method-definition/early-errors-object-method-formals-contains-super-call.js (strict mode)\n-language/expressions/object/method-definition/generator-super-call-body.js (default)\n-language/expressions/object/method-definition/generator-super-call-body.js (strict mode)\n-language/expressions/object/method-definition/generator-super-call-param.js (default)\n-language/expressions/object/method-definition/generator-super-call-param.js (strict mode)\n-language/expressions/object/prop-def-invalid-async-prefix.js (default)\n-language/expressions/object/prop-def-invalid-async-prefix.js (strict mode)\n-language/expressions/yield/in-iteration-stmt.js (default)\n-language/expressions/yield/in-iteration-stmt.js (strict mode)\n-language/expressions/yield/star-in-iteration-stmt.js (default)\n-language/expressions/yield/star-in-iteration-stmt.js (strict mode)\n-language/global-code/new.target-arrow.js (default)\n-language/global-code/new.target-arrow.js (strict mode)\n-language/global-code/super-call-arrow.js (default)\n-language/global-code/super-call-arrow.js (strict mode)\n-language/global-code/super-prop-arrow.js (default)\n-language/global-code/super-prop-arrow.js (strict mode)\n-language/module-code/early-export-global.js (default)\n-language/module-code/early-export-global.js (strict mode)\n-language/module-code/early-export-unresolvable.js (default)\n-language/module-code/early-export-unresolvable.js (strict mode)\n-language/statements/async-function/early-errors-declaration-body-contains-super-call.js (default)\n-language/statements/async-function/early-errors-declaration-body-contains-super-call.js (strict mode)\n-language/statements/async-function/early-errors-declaration-body-contains-super-property.js (default)\n-language/statements/async-function/early-errors-declaration-body-contains-super-property.js (strict mode)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-call.js (default)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-call.js (strict mode)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-property.js (default)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-property.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-call.js (default)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-call.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-property.js (default)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-property.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-call.js (default)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-call.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-property.js (default)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-property.js (strict mode)\n-language/statements/class/definition/early-errors-class-method-arguments-in-formal-parameters.js (default)\n-language/statements/class/definition/early-errors-class-method-body-contains-super-call.js (default)\n-language/statements/class/definition/early-errors-class-method-body-contains-super-call.js (strict mode)\n-language/statements/class/definition/early-errors-class-method-duplicate-parameters.js (default)\n-language/statements/class/definition/early-errors-class-method-eval-in-formal-parameters.js (default)\n-language/statements/class/definition/early-errors-class-method-formals-contains-super-call.js (default)\n-language/statements/class/definition/early-errors-class-method-formals-contains-super-call.js (strict mode)\n-language/statements/class/definition/methods-gen-yield-as-function-expression-binding-identifier.js (default)\n-language/statements/class/definition/methods-gen-yield-as-identifier-in-nested-function.js (default)\n-language/statements/class/method-param-yield.js (default)\n-language/statements/class/static-method-param-yield.js (default)\n-language/statements/class/strict-mode/with.js (default)\n-language/statements/class/syntax/early-errors/class-body-has-direct-super-missing-class-heritage.js (default)\n-language/statements/class/syntax/early-errors/class-body-has-direct-super-missing-class-heritage.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-method-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-method-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-special-method-generator-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-special-method-generator-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-special-method-get-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-special-method-get-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-special-method-set-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-special-method-set-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-static-method-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-static-method-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-static-method-get-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-static-method-get-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-static-method-set-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-static-method-set-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-block-duplicate-binding.js (default)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-block-duplicate-binding.js (strict mode)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-scriptbody-duplicate-binding.js (default)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-scriptbody-duplicate-binding.js (strict mode)\n-language/statements/const/syntax/const-declaring-let-split-across-two-lines.js (default)\n-language/statements/do-while/labelled-fn-stmt.js (default)\n-language/statements/for/head-let-bound-names-in-stmt.js (default)\n-language/statements/for/head-let-bound-names-in-stmt.js (strict mode)\n-language/statements/for-in/head-const-bound-names-in-stmt.js (default)\n-language/statements/for-in/head-const-bound-names-in-stmt.js (strict mode)\n-language/statements/for-in/head-const-bound-names-let.js (default)\n-language/statements/for-in/head-let-bound-names-in-stmt.js (default)\n-language/statements/for-in/head-let-bound-names-in-stmt.js (strict mode)\n-language/statements/for-in/head-let-bound-names-let.js (default)\n-language/statements/for-in/labelled-fn-stmt-const.js (default)\n-language/statements/for-in/labelled-fn-stmt-let.js (default)\n-language/statements/for-in/labelled-fn-stmt-lhs.js (default)\n-language/statements/for-in/labelled-fn-stmt-var.js (default)\n-language/statements/for-in/let-block-with-newline.js (default)\n-language/statements/for-in/let-identifier-with-newline.js (default)\n-language/statements/for/labelled-fn-stmt-expr.js (default)\n-language/statements/for/labelled-fn-stmt-let.js (default)\n-language/statements/for/labelled-fn-stmt-var.js (default)\n-language/statements/for/let-block-with-newline.js (default)\n-language/statements/for/let-identifier-with-newline.js (default)\n-language/statements/for-of/head-const-bound-names-in-stmt.js (default)\n-language/statements/for-of/head-const-bound-names-in-stmt.js (strict mode)\n-language/statements/for-of/head-const-bound-names-let.js (default)\n-language/statements/for-of/head-let-bound-names-in-stmt.js (default)\n-language/statements/for-of/head-let-bound-names-in-stmt.js (strict mode)\n-language/statements/for-of/head-let-bound-names-let.js (default)\n-language/statements/for-of/labelled-fn-stmt-const.js (default)\n-language/statements/for-of/labelled-fn-stmt-let.js (default)\n-language/statements/for-of/labelled-fn-stmt-lhs.js (default)\n-language/statements/for-of/labelled-fn-stmt-var.js (default)\n-language/statements/for-of/let-block-with-newline.js (default)\n-language/statements/for-of/let-identifier-with-newline.js (default)\n-language/statements/for-await-of/let-block-with-newline.js (default)\n-language/statements/for-await-of/let-identifier-with-newline.js (default)\n-language/statements/function/early-body-super-call.js (default)\n-language/statements/function/early-body-super-call.js (strict mode)\n-language/statements/function/early-body-super-prop.js (default)\n-language/statements/function/early-body-super-prop.js (strict mode)\n-language/statements/function/early-params-super-call.js (default)\n-language/statements/function/early-params-super-call.js (strict mode)\n-language/statements/function/early-params-super-prop.js (default)\n-language/statements/function/early-params-super-prop.js (strict mode)\n-language/statements/if/if-gen-else-gen.js (default)\n-language/statements/if/if-gen-else-stmt.js (default)\n-language/statements/if/if-gen-no-else.js (default)\n-language/statements/if/if-stmt-else-gen.js (default)\n-language/statements/if/labelled-fn-stmt-first.js (default)\n-language/statements/if/labelled-fn-stmt-lone.js (default)\n-language/statements/if/labelled-fn-stmt-second.js (default)\n-language/statements/if/let-block-with-newline.js (default)\n-language/statements/if/let-identifier-with-newline.js (default)\n-language/statements/labeled/let-block-with-newline.js (default)\n-language/statements/labeled/let-identifier-with-newline.js (default)\n-language/statements/let/syntax/identifier-let-disallowed-as-boundname.js (default)\n-language/statements/let/syntax/let-let-declaration-split-across-two-lines.js (default)\n-language/statements/let/syntax/let-let-declaration-with-initializer-split-across-two-lines.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/while/labelled-fn-stmt.js (default)\n-language/statements/while/let-block-with-newline.js (default)\n-language/statements/while/let-identifier-with-newline.js (default)\n-language/statements/with/labelled-fn-stmt.js (default)\n-language/statements/with/let-block-with-newline.js (default)\n-language/statements/with/let-identifier-with-newline.js (default)\n-language/white-space/mongolian-vowel-separator.js (default)\n-language/white-space/mongolian-vowel-separator.js (strict mode)"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "deps/acorn/dist/.keep",
            "status": "removed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fdist%2F.keep",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fdist%2F.keep",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Fdist%2F.keep?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6"
        },
        {
            "sha": "89d38a1c29d581bde4e21364bfdd0f05f672aec8",
            "filename": "deps/acorn/dist/acorn_loose.es.js",
            "status": "removed",
            "additions": 0,
            "deletions": 1424,
            "changes": 1424,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fdist%2Facorn_loose.es.js",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fdist%2Facorn_loose.es.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Fdist%2Facorn_loose.es.js?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,1424 +0,0 @@\n-import { Node, SourceLocation, Token, addLooseExports, defaultOptions, getLineInfo, isNewLine, lineBreak, lineBreakG, tokTypes, tokenizer } from './acorn.es';\n-\n-function noop() {}\n-\n-// Registered plugins\n-var pluginsLoose = {};\n-\n-var LooseParser = function LooseParser(input, options) {\n-  if ( options === void 0 ) options = {};\n-\n-  this.toks = tokenizer(input, options);\n-  this.options = this.toks.options;\n-  this.input = this.toks.input;\n-  this.tok = this.last = {type: tokTypes.eof, start: 0, end: 0};\n-  this.tok.validateRegExpFlags = noop;\n-  this.tok.validateRegExpPattern = noop;\n-  if (this.options.locations) {\n-    var here = this.toks.curPosition();\n-    this.tok.loc = new SourceLocation(this.toks, here, here);\n-  }\n-  this.ahead = []; // Tokens ahead\n-  this.context = []; // Indentation contexted\n-  this.curIndent = 0;\n-  this.curLineStart = 0;\n-  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n-  this.inAsync = false;\n-  this.inFunction = false;\n-  // Load plugins\n-  this.options.pluginsLoose = options.pluginsLoose || {};\n-  this.loadPlugins(this.options.pluginsLoose);\n-};\n-\n-LooseParser.prototype.startNode = function startNode () {\n-  return new Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n-};\n-\n-LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n-  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n-};\n-\n-LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n-  if (this.options.locations) {\n-    return new Node(this.toks, pos[0], pos[1])\n-  } else {\n-    return new Node(this.toks, pos)\n-  }\n-};\n-\n-LooseParser.prototype.finishNode = function finishNode (node, type) {\n-  node.type = type;\n-  node.end = this.last.end;\n-  if (this.options.locations)\n-    { node.loc.end = this.last.loc.end; }\n-  if (this.options.ranges)\n-    { node.range[1] = this.last.end; }\n-  return node\n-};\n-\n-LooseParser.prototype.dummyNode = function dummyNode (type) {\n-  var dummy = this.startNode();\n-  dummy.type = type;\n-  dummy.end = dummy.start;\n-  if (this.options.locations)\n-    { dummy.loc.end = dummy.loc.start; }\n-  if (this.options.ranges)\n-    { dummy.range[1] = dummy.start; }\n-  this.last = {type: tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyIdent = function dummyIdent () {\n-  var dummy = this.dummyNode(\"Identifier\");\n-  dummy.name = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyString = function dummyString () {\n-  var dummy = this.dummyNode(\"Literal\");\n-  dummy.value = dummy.raw = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.eat = function eat (type) {\n-  if (this.tok.type === type) {\n-    this.next();\n-    return true\n-  } else {\n-    return false\n-  }\n-};\n-\n-LooseParser.prototype.isContextual = function isContextual (name) {\n-  return this.tok.type === tokTypes.name && this.tok.value === name\n-};\n-\n-LooseParser.prototype.eatContextual = function eatContextual (name) {\n-  return this.tok.value === name && this.eat(tokTypes.name)\n-};\n-\n-LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n-  return this.tok.type === tokTypes.eof || this.tok.type === tokTypes.braceR ||\n-    lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n-};\n-\n-LooseParser.prototype.semicolon = function semicolon () {\n-  return this.eat(tokTypes.semi)\n-};\n-\n-LooseParser.prototype.expect = function expect (type) {\n-    var this$1 = this;\n-\n-  if (this.eat(type)) { return true }\n-  for (var i = 1; i <= 2; i++) {\n-    if (this$1.lookAhead(i).type === type) {\n-      for (var j = 0; j < i; j++) { this$1.next(); }\n-      return true\n-    }\n-  }\n-};\n-\n-LooseParser.prototype.pushCx = function pushCx () {\n-  this.context.push(this.curIndent);\n-};\n-\n-LooseParser.prototype.popCx = function popCx () {\n-  this.curIndent = this.context.pop();\n-};\n-\n-LooseParser.prototype.lineEnd = function lineEnd (pos) {\n-  while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n-  return pos\n-};\n-\n-LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n-    var this$1 = this;\n-\n-  for (var count = 0;; ++pos) {\n-    var ch = this$1.input.charCodeAt(pos);\n-    if (ch === 32) { ++count; }\n-    else if (ch === 9) { count += this$1.options.tabSize; }\n-    else { return count }\n-  }\n-};\n-\n-LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n-  if (this.tok.type === closeTok || this.tok.type === tokTypes.eof) { return true }\n-  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n-    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n-     this.indentationAfter(this.nextLineStart) < indent)\n-};\n-\n-LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n-    var this$1 = this;\n-\n-  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n-    var ch = this$1.input.charCodeAt(p);\n-    if (ch !== 9 && ch !== 32) { return false }\n-  }\n-  return true\n-};\n-\n-LooseParser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n-};\n-\n-LooseParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n-\n-  for (var name in pluginConfigs) {\n-    var plugin = pluginsLoose[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n-};\n-\n-LooseParser.prototype.parse = function parse () {\n-  this.next();\n-  return this.parseTopLevel()\n-};\n-\n-var lp = LooseParser.prototype;\n-\n-function isSpace(ch) {\n-  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)\n-}\n-\n-lp.next = function() {\n-  var this$1 = this;\n-\n-  this.last = this.tok;\n-  if (this.ahead.length)\n-    { this.tok = this.ahead.shift(); }\n-  else\n-    { this.tok = this.readToken(); }\n-\n-  if (this.tok.start >= this.nextLineStart) {\n-    while (this.tok.start >= this.nextLineStart) {\n-      this$1.curLineStart = this$1.nextLineStart;\n-      this$1.nextLineStart = this$1.lineEnd(this$1.curLineStart) + 1;\n-    }\n-    this.curIndent = this.indentationAfter(this.curLineStart);\n-  }\n-};\n-\n-lp.readToken = function() {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    try {\n-      this$1.toks.next();\n-      if (this$1.toks.type === tokTypes.dot &&\n-          this$1.input.substr(this$1.toks.end, 1) === \".\" &&\n-          this$1.options.ecmaVersion >= 6) {\n-        this$1.toks.end++;\n-        this$1.toks.type = tokTypes.ellipsis;\n-      }\n-      return new Token(this$1.toks)\n-    } catch (e) {\n-      if (!(e instanceof SyntaxError)) { throw e }\n-\n-      // Try to skip some text, based on the error message, and then continue\n-      var msg = e.message, pos = e.raisedAt, replace = true;\n-      if (/unterminated/i.test(msg)) {\n-        pos = this$1.lineEnd(e.pos + 1);\n-        if (/string/.test(msg)) {\n-          replace = {start: e.pos, end: pos, type: tokTypes.string, value: this$1.input.slice(e.pos + 1, pos)};\n-        } else if (/regular expr/i.test(msg)) {\n-          var re = this$1.input.slice(e.pos, pos);\n-          try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n-          replace = {start: e.pos, end: pos, type: tokTypes.regexp, value: re};\n-        } else if (/template/.test(msg)) {\n-          replace = {\n-            start: e.pos,\n-            end: pos,\n-            type: tokTypes.template,\n-            value: this$1.input.slice(e.pos, pos)\n-          };\n-        } else {\n-          replace = false;\n-        }\n-      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n-        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n-      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n-        while (pos < this.input.length) {\n-          var ch = this$1.input.charCodeAt(pos++);\n-          if (ch === 34 || ch === 39 || isNewLine(ch)) { break }\n-        }\n-      } else if (/unexpected character/i.test(msg)) {\n-        pos++;\n-        replace = false;\n-      } else if (/regular expression/i.test(msg)) {\n-        replace = true;\n-      } else {\n-        throw e\n-      }\n-      this$1.resetTo(pos);\n-      if (replace === true) { replace = {start: pos, end: pos, type: tokTypes.name, value: \"✖\"}; }\n-      if (replace) {\n-        if (this$1.options.locations)\n-          { replace.loc = new SourceLocation(\n-            this$1.toks,\n-            getLineInfo(this$1.input, replace.start),\n-            getLineInfo(this$1.input, replace.end)); }\n-        return replace\n-      }\n-    }\n-  }\n-};\n-\n-lp.resetTo = function(pos) {\n-  var this$1 = this;\n-\n-  this.toks.pos = pos;\n-  var ch = this.input.charAt(pos - 1);\n-  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n-    /[enwfd]/.test(ch) &&\n-    /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n-\n-  if (this.options.locations) {\n-    this.toks.curLine = 1;\n-    this.toks.lineStart = lineBreakG.lastIndex = 0;\n-    var match;\n-    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n-      ++this$1.toks.curLine;\n-      this$1.toks.lineStart = match.index + match[0].length;\n-    }\n-  }\n-};\n-\n-lp.lookAhead = function(n) {\n-  var this$1 = this;\n-\n-  while (n > this.ahead.length)\n-    { this$1.ahead.push(this$1.readToken()); }\n-  return this.ahead[n - 1]\n-};\n-\n-function isDummy(node) { return node.name === \"✖\" }\n-\n-var lp$1 = LooseParser.prototype;\n-\n-lp$1.parseTopLevel = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNodeAt(this.options.locations ? [0, getLineInfo(this.input, 0)] : 0);\n-  node.body = [];\n-  while (this.tok.type !== tokTypes.eof) { node.body.push(this$1.parseStatement()); }\n-  this.toks.adaptDirectivePrologue(node.body);\n-  this.last = this.tok;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.sourceType = this.options.sourceType;\n-  }\n-  return this.finishNode(node, \"Program\")\n-};\n-\n-lp$1.parseStatement = function() {\n-  var this$1 = this;\n-\n-  var starttype = this.tok.type, node = this.startNode(), kind;\n-\n-  if (this.toks.isLet()) {\n-    starttype = tokTypes._var;\n-    kind = \"let\";\n-  }\n-\n-  switch (starttype) {\n-  case tokTypes._break: case tokTypes._continue:\n-    this.next();\n-    var isBreak = starttype === tokTypes._break;\n-    if (this.semicolon() || this.canInsertSemicolon()) {\n-      node.label = null;\n-    } else {\n-      node.label = this.tok.type === tokTypes.name ? this.parseIdent() : null;\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n-\n-  case tokTypes._debugger:\n-    this.next();\n-    this.semicolon();\n-    return this.finishNode(node, \"DebuggerStatement\")\n-\n-  case tokTypes._do:\n-    this.next();\n-    node.body = this.parseStatement();\n-    node.test = this.eat(tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n-    this.semicolon();\n-    return this.finishNode(node, \"DoWhileStatement\")\n-\n-  case tokTypes._for:\n-    this.next(); // `for` keyword\n-    var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n-\n-    this.pushCx();\n-    this.expect(tokTypes.parenL);\n-    if (this.tok.type === tokTypes.semi) { return this.parseFor(node, null) }\n-    var isLet = this.toks.isLet();\n-    if (isLet || this.tok.type === tokTypes._var || this.tok.type === tokTypes._const) {\n-      var init$1 = this.parseVar(true, isLet ? \"let\" : this.tok.value);\n-      if (init$1.declarations.length === 1 && (this.tok.type === tokTypes._in || this.isContextual(\"of\"))) {\n-        if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n-          node.await = isAwait;\n-        }\n-        return this.parseForIn(node, init$1)\n-      }\n-      return this.parseFor(node, init$1)\n-    }\n-    var init = this.parseExpression(true);\n-    if (this.tok.type === tokTypes._in || this.isContextual(\"of\")) {\n-      if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n-        node.await = isAwait;\n-      }\n-      return this.parseForIn(node, this.toAssignable(init))\n-    }\n-    return this.parseFor(node, init)\n-\n-  case tokTypes._function:\n-    this.next();\n-    return this.parseFunction(node, true)\n-\n-  case tokTypes._if:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.consequent = this.parseStatement();\n-    node.alternate = this.eat(tokTypes._else) ? this.parseStatement() : null;\n-    return this.finishNode(node, \"IfStatement\")\n-\n-  case tokTypes._return:\n-    this.next();\n-    if (this.eat(tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n-    else { node.argument = this.parseExpression(); this.semicolon(); }\n-    return this.finishNode(node, \"ReturnStatement\")\n-\n-  case tokTypes._switch:\n-    var blockIndent = this.curIndent, line = this.curLineStart;\n-    this.next();\n-    node.discriminant = this.parseParenExpression();\n-    node.cases = [];\n-    this.pushCx();\n-    this.expect(tokTypes.braceL);\n-\n-    var cur;\n-    while (!this.closes(tokTypes.braceR, blockIndent, line, true)) {\n-      if (this$1.tok.type === tokTypes._case || this$1.tok.type === tokTypes._default) {\n-        var isCase = this$1.tok.type === tokTypes._case;\n-        if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n-        node.cases.push(cur = this$1.startNode());\n-        cur.consequent = [];\n-        this$1.next();\n-        if (isCase) { cur.test = this$1.parseExpression(); }\n-        else { cur.test = null; }\n-        this$1.expect(tokTypes.colon);\n-      } else {\n-        if (!cur) {\n-          node.cases.push(cur = this$1.startNode());\n-          cur.consequent = [];\n-          cur.test = null;\n-        }\n-        cur.consequent.push(this$1.parseStatement());\n-      }\n-    }\n-    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n-    this.popCx();\n-    this.eat(tokTypes.braceR);\n-    return this.finishNode(node, \"SwitchStatement\")\n-\n-  case tokTypes._throw:\n-    this.next();\n-    node.argument = this.parseExpression();\n-    this.semicolon();\n-    return this.finishNode(node, \"ThrowStatement\")\n-\n-  case tokTypes._try:\n-    this.next();\n-    node.block = this.parseBlock();\n-    node.handler = null;\n-    if (this.tok.type === tokTypes._catch) {\n-      var clause = this.startNode();\n-      this.next();\n-      if (this.eat(tokTypes.parenL)) {\n-        clause.param = this.toAssignable(this.parseExprAtom(), true);\n-        this.expect(tokTypes.parenR);\n-      } else {\n-        clause.param = null;\n-      }\n-      clause.body = this.parseBlock();\n-      node.handler = this.finishNode(clause, \"CatchClause\");\n-    }\n-    node.finalizer = this.eat(tokTypes._finally) ? this.parseBlock() : null;\n-    if (!node.handler && !node.finalizer) { return node.block }\n-    return this.finishNode(node, \"TryStatement\")\n-\n-  case tokTypes._var:\n-  case tokTypes._const:\n-    return this.parseVar(false, kind || this.tok.value)\n-\n-  case tokTypes._while:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WhileStatement\")\n-\n-  case tokTypes._with:\n-    this.next();\n-    node.object = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WithStatement\")\n-\n-  case tokTypes.braceL:\n-    return this.parseBlock()\n-\n-  case tokTypes.semi:\n-    this.next();\n-    return this.finishNode(node, \"EmptyStatement\")\n-\n-  case tokTypes._class:\n-    return this.parseClass(true)\n-\n-  case tokTypes._import:\n-    return this.parseImport()\n-\n-  case tokTypes._export:\n-    return this.parseExport()\n-\n-  default:\n-    if (this.toks.isAsyncFunction()) {\n-      this.next();\n-      this.next();\n-      return this.parseFunction(node, true, true)\n-    }\n-    var expr = this.parseExpression();\n-    if (isDummy(expr)) {\n-      this.next();\n-      if (this.tok.type === tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n-      return this.parseStatement()\n-    } else if (starttype === tokTypes.name && expr.type === \"Identifier\" && this.eat(tokTypes.colon)) {\n-      node.body = this.parseStatement();\n-      node.label = expr;\n-      return this.finishNode(node, \"LabeledStatement\")\n-    } else {\n-      node.expression = expr;\n-      this.semicolon();\n-      return this.finishNode(node, \"ExpressionStatement\")\n-    }\n-  }\n-};\n-\n-lp$1.parseBlock = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.pushCx();\n-  this.expect(tokTypes.braceL);\n-  var blockIndent = this.curIndent, line = this.curLineStart;\n-  node.body = [];\n-  while (!this.closes(tokTypes.braceR, blockIndent, line, true))\n-    { node.body.push(this$1.parseStatement()); }\n-  this.popCx();\n-  this.eat(tokTypes.braceR);\n-  return this.finishNode(node, \"BlockStatement\")\n-};\n-\n-lp$1.parseFor = function(node, init) {\n-  node.init = init;\n-  node.test = node.update = null;\n-  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.semi) { node.test = this.parseExpression(); }\n-  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.parenR) { node.update = this.parseExpression(); }\n-  this.popCx();\n-  this.expect(tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, \"ForStatement\")\n-};\n-\n-lp$1.parseForIn = function(node, init) {\n-  var type = this.tok.type === tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n-  this.next();\n-  node.left = init;\n-  node.right = this.parseExpression();\n-  this.popCx();\n-  this.expect(tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, type)\n-};\n-\n-lp$1.parseVar = function(noIn, kind) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.kind = kind;\n-  this.next();\n-  node.declarations = [];\n-  do {\n-    var decl = this$1.startNode();\n-    decl.id = this$1.options.ecmaVersion >= 6 ? this$1.toAssignable(this$1.parseExprAtom(), true) : this$1.parseIdent();\n-    decl.init = this$1.eat(tokTypes.eq) ? this$1.parseMaybeAssign(noIn) : null;\n-    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n-  } while (this.eat(tokTypes.comma))\n-  if (!node.declarations.length) {\n-    var decl$1 = this.startNode();\n-    decl$1.id = this.dummyIdent();\n-    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n-  }\n-  if (!noIn) { this.semicolon(); }\n-  return this.finishNode(node, \"VariableDeclaration\")\n-};\n-\n-lp$1.parseClass = function(isStatement) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  else { node.id = null; }\n-  node.superClass = this.eat(tokTypes._extends) ? this.parseExpression() : null;\n-  node.body = this.startNode();\n-  node.body.body = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(tokTypes.braceR, indent, line)) {\n-    if (this$1.semicolon()) { continue }\n-    var method = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0);\n-    if (this$1.options.ecmaVersion >= 6) {\n-      method.static = false;\n-      isGenerator = this$1.eat(tokTypes.star);\n-    }\n-    this$1.parsePropertyName(method);\n-    if (isDummy(method.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(tokTypes.comma); continue }\n-    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n-        (this$1.tok.type !== tokTypes.parenL && this$1.tok.type !== tokTypes.braceL)) {\n-      method.static = true;\n-      isGenerator = this$1.eat(tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      method.static = false;\n-    }\n-    if (!method.computed &&\n-        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.tok.type !== tokTypes.parenL &&\n-        !this$1.canInsertSemicolon()) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (this$1.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n-        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n-        this$1.tok.type !== tokTypes.parenL && this$1.tok.type !== tokTypes.braceL) {\n-      method.kind = method.key.name;\n-      this$1.parsePropertyName(method);\n-      method.value = this$1.parseMethod(false);\n-    } else {\n-      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n-        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n-          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n-        method.kind = \"constructor\";\n-      } else {\n-        method.kind = \"method\";\n-      }\n-      method.value = this$1.parseMethod(isGenerator, isAsync);\n-    }\n-    node.body.body.push(this$1.finishNode(method, \"MethodDefinition\"));\n-  }\n-  this.popCx();\n-  if (!this.eat(tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  this.semicolon();\n-  this.finishNode(node.body, \"ClassBody\");\n-  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n-};\n-\n-lp$1.parseFunction = function(node, isStatement, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = this.eat(tokTypes.star);\n-  }\n-  if (this.options.ecmaVersion >= 8) {\n-    node.async = !!isAsync;\n-  }\n-  if (this.tok.type === tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n-};\n-\n-lp$1.parseExport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.eat(tokTypes.star)) {\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n-    return this.finishNode(node, \"ExportAllDeclaration\")\n-  }\n-  if (this.eat(tokTypes._default)) {\n-    // export default (function foo() {}) // This is FunctionExpression.\n-    var isAsync;\n-    if (this.tok.type === tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n-      var fNode = this.startNode();\n-      this.next();\n-      if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n-    } else if (this.tok.type === tokTypes._class) {\n-      node.declaration = this.parseClass(\"nullableID\");\n-    } else {\n-      node.declaration = this.parseMaybeAssign();\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, \"ExportDefaultDeclaration\")\n-  }\n-  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n-    node.declaration = this.parseStatement();\n-    node.specifiers = [];\n-    node.source = null;\n-  } else {\n-    node.declaration = null;\n-    node.specifiers = this.parseExportSpecifierList();\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n-    this.semicolon();\n-  }\n-  return this.finishNode(node, \"ExportNamedDeclaration\")\n-};\n-\n-lp$1.parseImport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === tokTypes.string) {\n-    node.specifiers = [];\n-    node.source = this.parseExprAtom();\n-  } else {\n-    var elt;\n-    if (this.tok.type === tokTypes.name && this.tok.value !== \"from\") {\n-      elt = this.startNode();\n-      elt.local = this.parseIdent();\n-      this.finishNode(elt, \"ImportDefaultSpecifier\");\n-      this.eat(tokTypes.comma);\n-    }\n-    node.specifiers = this.parseImportSpecifierList();\n-    node.source = this.eatContextual(\"from\") && this.tok.type === tokTypes.string ? this.parseExprAtom() : this.dummyString();\n-    if (elt) { node.specifiers.unshift(elt); }\n-  }\n-  this.semicolon();\n-  return this.finishNode(node, \"ImportDeclaration\")\n-};\n-\n-lp$1.parseImportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  if (this.tok.type === tokTypes.star) {\n-    var elt = this.startNode();\n-    this.next();\n-    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n-    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n-  } else {\n-    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-    this.pushCx();\n-    this.eat(tokTypes.braceL);\n-    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-    while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-      var elt$1 = this$1.startNode();\n-      if (this$1.eat(tokTypes.star)) {\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : this$1.dummyIdent();\n-        this$1.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n-      } else {\n-        if (this$1.isContextual(\"from\")) { break }\n-        elt$1.imported = this$1.parseIdent();\n-        if (isDummy(elt$1.imported)) { break }\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt$1.imported;\n-        this$1.finishNode(elt$1, \"ImportSpecifier\");\n-      }\n-      elts.push(elt$1);\n-      this$1.eat(tokTypes.comma);\n-    }\n-    this.eat(tokTypes.braceR);\n-    this.popCx();\n-  }\n-  return elts\n-};\n-\n-lp$1.parseExportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-  this.pushCx();\n-  this.eat(tokTypes.braceL);\n-  if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-  while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-    if (this$1.isContextual(\"from\")) { break }\n-    var elt = this$1.startNode();\n-    elt.local = this$1.parseIdent();\n-    if (isDummy(elt.local)) { break }\n-    elt.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt.local;\n-    this$1.finishNode(elt, \"ExportSpecifier\");\n-    elts.push(elt);\n-    this$1.eat(tokTypes.comma);\n-  }\n-  this.eat(tokTypes.braceR);\n-  this.popCx();\n-  return elts\n-};\n-\n-var lp$2 = LooseParser.prototype;\n-\n-lp$2.checkLVal = function(expr) {\n-  if (!expr) { return expr }\n-  switch (expr.type) {\n-  case \"Identifier\":\n-  case \"MemberExpression\":\n-    return expr\n-\n-  case \"ParenthesizedExpression\":\n-    expr.expression = this.checkLVal(expr.expression);\n-    return expr\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseExpression = function(noIn) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseMaybeAssign(noIn);\n-  if (this.tok.type === tokTypes.comma) {\n-    var node = this.startNodeAt(start);\n-    node.expressions = [expr];\n-    while (this.eat(tokTypes.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn)); }\n-    return this.finishNode(node, \"SequenceExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseParenExpression = function() {\n-  this.pushCx();\n-  this.expect(tokTypes.parenL);\n-  var val = this.parseExpression();\n-  this.popCx();\n-  this.expect(tokTypes.parenR);\n-  return val\n-};\n-\n-lp$2.parseMaybeAssign = function(noIn) {\n-  if (this.toks.isContextual(\"yield\")) {\n-    var node = this.startNode();\n-    this.next();\n-    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== tokTypes.star && !this.tok.type.startsExpr)) {\n-      node.delegate = false;\n-      node.argument = null;\n-    } else {\n-      node.delegate = this.eat(tokTypes.star);\n-      node.argument = this.parseMaybeAssign();\n-    }\n-    return this.finishNode(node, \"YieldExpression\")\n-  }\n-\n-  var start = this.storeCurrentPos();\n-  var left = this.parseMaybeConditional(noIn);\n-  if (this.tok.type.isAssign) {\n-    var node$1 = this.startNodeAt(start);\n-    node$1.operator = this.tok.value;\n-    node$1.left = this.tok.type === tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n-    this.next();\n-    node$1.right = this.parseMaybeAssign(noIn);\n-    return this.finishNode(node$1, \"AssignmentExpression\")\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeConditional = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseExprOps(noIn);\n-  if (this.eat(tokTypes.question)) {\n-    var node = this.startNodeAt(start);\n-    node.test = expr;\n-    node.consequent = this.parseMaybeAssign();\n-    node.alternate = this.expect(tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n-    return this.finishNode(node, \"ConditionalExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseExprOps = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var indent = this.curIndent, line = this.curLineStart;\n-  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n-};\n-\n-lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n-  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n-  var prec = this.tok.type.binop;\n-  if (prec != null && (!noIn || this.tok.type !== tokTypes._in)) {\n-    if (prec > minPrec) {\n-      var node = this.startNodeAt(start);\n-      node.left = left;\n-      node.operator = this.tok.value;\n-      this.next();\n-      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n-        node.right = this.dummyIdent();\n-      } else {\n-        var rightStart = this.storeCurrentPos();\n-        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n-      }\n-      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n-      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n-    }\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeUnary = function(sawUnary) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos(), expr;\n-  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n-    (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n-  ) {\n-    expr = this.parseAwait();\n-    sawUnary = true;\n-  } else if (this.tok.type.prefix) {\n-    var node = this.startNode(), update = this.tok.type === tokTypes.incDec;\n-    if (!update) { sawUnary = true; }\n-    node.operator = this.tok.value;\n-    node.prefix = true;\n-    this.next();\n-    node.argument = this.parseMaybeUnary(true);\n-    if (update) { node.argument = this.checkLVal(node.argument); }\n-    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n-  } else if (this.tok.type === tokTypes.ellipsis) {\n-    var node$1 = this.startNode();\n-    this.next();\n-    node$1.argument = this.parseMaybeUnary(sawUnary);\n-    expr = this.finishNode(node$1, \"SpreadElement\");\n-  } else {\n-    expr = this.parseExprSubscripts();\n-    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.operator = this$1.tok.value;\n-      node$2.prefix = false;\n-      node$2.argument = this$1.checkLVal(expr);\n-      this$1.next();\n-      expr = this$1.finishNode(node$2, \"UpdateExpression\");\n-    }\n-  }\n-\n-  if (!sawUnary && this.eat(tokTypes.starstar)) {\n-    var node$3 = this.startNodeAt(start);\n-    node$3.operator = \"**\";\n-    node$3.left = expr;\n-    node$3.right = this.parseMaybeUnary(false);\n-    return this.finishNode(node$3, \"BinaryExpression\")\n-  }\n-\n-  return expr\n-};\n-\n-lp$2.parseExprSubscripts = function() {\n-  var start = this.storeCurrentPos();\n-  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n-};\n-\n-lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine()) {\n-      if (this$1.tok.type === tokTypes.dot && this$1.curIndent === startIndent)\n-        { --startIndent; }\n-      else\n-        { return base }\n-    }\n-\n-    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this$1.canInsertSemicolon();\n-\n-    if (this$1.eat(tokTypes.dot)) {\n-      var node = this$1.startNodeAt(start);\n-      node.object = base;\n-      if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine())\n-        { node.property = this$1.dummyIdent(); }\n-      else\n-        { node.property = this$1.parsePropertyAccessor() || this$1.dummyIdent(); }\n-      node.computed = false;\n-      base = this$1.finishNode(node, \"MemberExpression\");\n-    } else if (this$1.tok.type === tokTypes.bracketL) {\n-      this$1.pushCx();\n-      this$1.next();\n-      var node$1 = this$1.startNodeAt(start);\n-      node$1.object = base;\n-      node$1.property = this$1.parseExpression();\n-      node$1.computed = true;\n-      this$1.popCx();\n-      this$1.expect(tokTypes.bracketR);\n-      base = this$1.finishNode(node$1, \"MemberExpression\");\n-    } else if (!noCalls && this$1.tok.type === tokTypes.parenL) {\n-      var exprList = this$1.parseExprList(tokTypes.parenR);\n-      if (maybeAsyncArrow && this$1.eat(tokTypes.arrow))\n-        { return this$1.parseArrowExpression(this$1.startNodeAt(start), exprList, true) }\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.callee = base;\n-      node$2.arguments = exprList;\n-      base = this$1.finishNode(node$2, \"CallExpression\");\n-    } else if (this$1.tok.type === tokTypes.backQuote) {\n-      var node$3 = this$1.startNodeAt(start);\n-      node$3.tag = base;\n-      node$3.quasi = this$1.parseTemplate();\n-      base = this$1.finishNode(node$3, \"TaggedTemplateExpression\");\n-    } else {\n-      return base\n-    }\n-  }\n-};\n-\n-lp$2.parseExprAtom = function() {\n-  var node;\n-  switch (this.tok.type) {\n-  case tokTypes._this:\n-  case tokTypes._super:\n-    var type = this.tok.type === tokTypes._this ? \"ThisExpression\" : \"Super\";\n-    node = this.startNode();\n-    this.next();\n-    return this.finishNode(node, type)\n-\n-  case tokTypes.name:\n-    var start = this.storeCurrentPos();\n-    var id = this.parseIdent();\n-    var isAsync = false;\n-    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n-      if (this.eat(tokTypes._function))\n-        { return this.parseFunction(this.startNodeAt(start), false, true) }\n-      if (this.tok.type === tokTypes.name) {\n-        id = this.parseIdent();\n-        isAsync = true;\n-      }\n-    }\n-    return this.eat(tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n-\n-  case tokTypes.regexp:\n-    node = this.startNode();\n-    var val = this.tok.value;\n-    node.regex = {pattern: val.pattern, flags: val.flags};\n-    node.value = val.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case tokTypes.num: case tokTypes.string:\n-    node = this.startNode();\n-    node.value = this.tok.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case tokTypes._null: case tokTypes._true: case tokTypes._false:\n-    node = this.startNode();\n-    node.value = this.tok.type === tokTypes._null ? null : this.tok.type === tokTypes._true;\n-    node.raw = this.tok.type.keyword;\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case tokTypes.parenL:\n-    var parenStart = this.storeCurrentPos();\n-    this.next();\n-    var inner = this.parseExpression();\n-    this.expect(tokTypes.parenR);\n-    if (this.eat(tokTypes.arrow)) {\n-      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n-      var params = inner.expressions || [inner];\n-      if (params.length && isDummy(params[params.length - 1]))\n-        { params.pop(); }\n-      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n-    }\n-    if (this.options.preserveParens) {\n-      var par = this.startNodeAt(parenStart);\n-      par.expression = inner;\n-      inner = this.finishNode(par, \"ParenthesizedExpression\");\n-    }\n-    return inner\n-\n-  case tokTypes.bracketL:\n-    node = this.startNode();\n-    node.elements = this.parseExprList(tokTypes.bracketR, true);\n-    return this.finishNode(node, \"ArrayExpression\")\n-\n-  case tokTypes.braceL:\n-    return this.parseObj()\n-\n-  case tokTypes._class:\n-    return this.parseClass(false)\n-\n-  case tokTypes._function:\n-    node = this.startNode();\n-    this.next();\n-    return this.parseFunction(node, false)\n-\n-  case tokTypes._new:\n-    return this.parseNew()\n-\n-  case tokTypes.backQuote:\n-    return this.parseTemplate()\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseNew = function() {\n-  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n-  var meta = this.parseIdent(true);\n-  if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {\n-    node.meta = meta;\n-    node.property = this.parseIdent(true);\n-    return this.finishNode(node, \"MetaProperty\")\n-  }\n-  var start = this.storeCurrentPos();\n-  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n-  if (this.tok.type === tokTypes.parenL) {\n-    node.arguments = this.parseExprList(tokTypes.parenR);\n-  } else {\n-    node.arguments = [];\n-  }\n-  return this.finishNode(node, \"NewExpression\")\n-};\n-\n-lp$2.parseTemplateElement = function() {\n-  var elem = this.startNode();\n-\n-  // The loose parser accepts invalid unicode escapes even in untagged templates.\n-  if (this.tok.type === tokTypes.invalidTemplate) {\n-    elem.value = {\n-      raw: this.tok.value,\n-      cooked: null\n-    };\n-  } else {\n-    elem.value = {\n-      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n-      cooked: this.tok.value\n-    };\n-  }\n-  this.next();\n-  elem.tail = this.tok.type === tokTypes.backQuote;\n-  return this.finishNode(elem, \"TemplateElement\")\n-};\n-\n-lp$2.parseTemplate = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  node.expressions = [];\n-  var curElt = this.parseTemplateElement();\n-  node.quasis = [curElt];\n-  while (!curElt.tail) {\n-    this$1.next();\n-    node.expressions.push(this$1.parseExpression());\n-    if (this$1.expect(tokTypes.braceR)) {\n-      curElt = this$1.parseTemplateElement();\n-    } else {\n-      curElt = this$1.startNode();\n-      curElt.value = {cooked: \"\", raw: \"\"};\n-      curElt.tail = true;\n-      this$1.finishNode(curElt, \"TemplateElement\");\n-    }\n-    node.quasis.push(curElt);\n-  }\n-  this.expect(tokTypes.backQuote);\n-  return this.finishNode(node, \"TemplateLiteral\")\n-};\n-\n-lp$2.parseObj = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.properties = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(tokTypes.braceR, indent, line)) {\n-    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n-    if (this$1.options.ecmaVersion >= 9 && this$1.eat(tokTypes.ellipsis)) {\n-      prop.argument = this$1.parseMaybeAssign();\n-      node.properties.push(this$1.finishNode(prop, \"SpreadElement\"));\n-      this$1.eat(tokTypes.comma);\n-      continue\n-    }\n-    if (this$1.options.ecmaVersion >= 6) {\n-      start = this$1.storeCurrentPos();\n-      prop.method = false;\n-      prop.shorthand = false;\n-      isGenerator = this$1.eat(tokTypes.star);\n-    }\n-    this$1.parsePropertyName(prop);\n-    if (this$1.toks.isAsyncProp(prop)) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(tokTypes.star);\n-      this$1.parsePropertyName(prop);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (isDummy(prop.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(tokTypes.comma); continue }\n-    if (this$1.eat(tokTypes.colon)) {\n-      prop.kind = \"init\";\n-      prop.value = this$1.parseMaybeAssign();\n-    } else if (this$1.options.ecmaVersion >= 6 && (this$1.tok.type === tokTypes.parenL || this$1.tok.type === tokTypes.braceL)) {\n-      prop.kind = \"init\";\n-      prop.method = true;\n-      prop.value = this$1.parseMethod(isGenerator, isAsync);\n-    } else if (this$1.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n-               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n-               (this$1.tok.type !== tokTypes.comma && this$1.tok.type !== tokTypes.braceR && this$1.tok.type !== tokTypes.eq)) {\n-      prop.kind = prop.key.name;\n-      this$1.parsePropertyName(prop);\n-      prop.value = this$1.parseMethod(false);\n-    } else {\n-      prop.kind = \"init\";\n-      if (this$1.options.ecmaVersion >= 6) {\n-        if (this$1.eat(tokTypes.eq)) {\n-          var assign = this$1.startNodeAt(start);\n-          assign.operator = \"=\";\n-          assign.left = prop.key;\n-          assign.right = this$1.parseMaybeAssign();\n-          prop.value = this$1.finishNode(assign, \"AssignmentExpression\");\n-        } else {\n-          prop.value = prop.key;\n-        }\n-      } else {\n-        prop.value = this$1.dummyIdent();\n-      }\n-      prop.shorthand = true;\n-    }\n-    node.properties.push(this$1.finishNode(prop, \"Property\"));\n-    this$1.eat(tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return this.finishNode(node, \"ObjectExpression\")\n-};\n-\n-lp$2.parsePropertyName = function(prop) {\n-  if (this.options.ecmaVersion >= 6) {\n-    if (this.eat(tokTypes.bracketL)) {\n-      prop.computed = true;\n-      prop.key = this.parseExpression();\n-      this.expect(tokTypes.bracketR);\n-      return\n-    } else {\n-      prop.computed = false;\n-    }\n-  }\n-  var key = (this.tok.type === tokTypes.num || this.tok.type === tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n-  prop.key = key || this.dummyIdent();\n-};\n-\n-lp$2.parsePropertyAccessor = function() {\n-  if (this.tok.type === tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n-};\n-\n-lp$2.parseIdent = function() {\n-  var name = this.tok.type === tokTypes.name ? this.tok.value : this.tok.type.keyword;\n-  if (!name) { return this.dummyIdent() }\n-  var node = this.startNode();\n-  this.next();\n-  node.name = name;\n-  return this.finishNode(node, \"Identifier\")\n-};\n-\n-lp$2.initFunction = function(node) {\n-  node.id = null;\n-  node.params = [];\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n-};\n-\n-// Convert existing expression atom to assignable pattern\n-// if possible.\n-\n-lp$2.toAssignable = function(node, binding) {\n-  var this$1 = this;\n-\n-  if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) {\n-    // Okay\n-  } else if (node.type === \"ParenthesizedExpression\") {\n-    this.toAssignable(node.expression, binding);\n-  } else if (this.options.ecmaVersion < 6) {\n-    return this.dummyIdent()\n-  } else if (node.type === \"ObjectExpression\") {\n-    node.type = \"ObjectPattern\";\n-    for (var i = 0, list = node.properties; i < list.length; i += 1)\n-      {\n-      var prop = list[i];\n-\n-      this$1.toAssignable(prop, binding);\n-    }\n-  } else if (node.type === \"ArrayExpression\") {\n-    node.type = \"ArrayPattern\";\n-    this.toAssignableList(node.elements, binding);\n-  } else if (node.type === \"Property\") {\n-    this.toAssignable(node.value, binding);\n-  } else if (node.type === \"SpreadElement\") {\n-    node.type = \"RestElement\";\n-    this.toAssignable(node.argument, binding);\n-  } else if (node.type === \"AssignmentExpression\") {\n-    node.type = \"AssignmentPattern\";\n-    delete node.operator;\n-  } else {\n-    return this.dummyIdent()\n-  }\n-  return node\n-};\n-\n-lp$2.toAssignableList = function(exprList, binding) {\n-  var this$1 = this;\n-\n-  for (var i = 0, list = exprList; i < list.length; i += 1)\n-    {\n-    var expr = list[i];\n-\n-    this$1.toAssignable(expr, binding);\n-  }\n-  return exprList\n-};\n-\n-lp$2.parseFunctionParams = function(params) {\n-  params = this.parseExprList(tokTypes.parenR);\n-  return this.toAssignableList(params, true)\n-};\n-\n-lp$2.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6)\n-    { node.generator = !!isGenerator; }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"FunctionExpression\")\n-};\n-\n-lp$2.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.toAssignableList(params, true);\n-  node.expression = this.tok.type !== tokTypes.braceL;\n-  if (node.expression) {\n-    node.body = this.parseMaybeAssign();\n-  } else {\n-    node.body = this.parseBlock();\n-    this.toks.adaptDirectivePrologue(node.body.body);\n-  }\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"ArrowFunctionExpression\")\n-};\n-\n-lp$2.parseExprList = function(close, allowEmpty) {\n-  var this$1 = this;\n-\n-  this.pushCx();\n-  var indent = this.curIndent, line = this.curLineStart, elts = [];\n-  this.next(); // Opening bracket\n-  while (!this.closes(close, indent + 1, line)) {\n-    if (this$1.eat(tokTypes.comma)) {\n-      elts.push(allowEmpty ? null : this$1.dummyIdent());\n-      continue\n-    }\n-    var elt = this$1.parseMaybeAssign();\n-    if (isDummy(elt)) {\n-      if (this$1.closes(close, indent, line)) { break }\n-      this$1.next();\n-    } else {\n-      elts.push(elt);\n-    }\n-    this$1.eat(tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(close)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return elts\n-};\n-\n-lp$2.parseAwait = function() {\n-  var node = this.startNode();\n-  this.next();\n-  node.argument = this.parseMaybeUnary();\n-  return this.finishNode(node, \"AwaitExpression\")\n-};\n-\n-// Acorn: Loose parser\n-//\n-// This module provides an alternative parser (`parse_dammit`) that\n-// exposes that same interface as `parse`, but will try to parse\n-// anything as JavaScript, repairing syntax error the best it can.\n-// There are circumstances in which it will raise an error and give\n-// up, but they are very rare. The resulting AST will be a mostly\n-// valid JavaScript AST (as per the [Mozilla parser API][api], except\n-// that:\n-//\n-// - Return outside functions is allowed\n-//\n-// - Label consistency (no conflicts, break only to existing labels)\n-//   is not enforced.\n-//\n-// - Bogus Identifier nodes with a name of `\"✖\"` are inserted whenever\n-//   the parser got too confused to return anything meaningful.\n-//\n-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n-//\n-// The expected use for this is to *first* try `acorn.parse`, and only\n-// if that fails switch to `parse_dammit`. The loose parser might\n-// parse badly indented code incorrectly, so **don't** use it as\n-// your default parser.\n-//\n-// Quite a lot of acorn.js is duplicated here. The alternative was to\n-// add a *lot* of extra cruft to that file, making it less readable\n-// and slower. Copying and editing the code allowed me to make\n-// invasive changes and simplifications without creating a complicated\n-// tangle.\n-\n-defaultOptions.tabSize = 4;\n-\n-// eslint-disable-next-line camelcase\n-function parse_dammit(input, options) {\n-  return new LooseParser(input, options).parse()\n-}\n-\n-addLooseExports(parse_dammit, LooseParser, pluginsLoose);\n-\n-export { parse_dammit, LooseParser, pluginsLoose };"
        },
        {
            "sha": "e1dc7a44d463c2aac2716a59cc646bb606bc4165",
            "filename": "deps/acorn/dist/acorn_loose.js",
            "status": "removed",
            "additions": 0,
            "deletions": 1434,
            "changes": 1434,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fdist%2Facorn_loose.js",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fdist%2Facorn_loose.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Fdist%2Facorn_loose.js?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,1434 +0,0 @@\n-(function (global, factory) {\n-\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./acorn')) :\n-\ttypeof define === 'function' && define.amd ? define(['exports', './acorn'], factory) :\n-\t(factory((global.acorn = global.acorn || {}, global.acorn.loose = {}),global.acorn));\n-}(this, (function (exports,__acorn) { 'use strict';\n-\n-function noop() {}\n-\n-// Registered plugins\n-var pluginsLoose = {};\n-\n-var LooseParser = function LooseParser(input, options) {\n-  if ( options === void 0 ) options = {};\n-\n-  this.toks = __acorn.tokenizer(input, options);\n-  this.options = this.toks.options;\n-  this.input = this.toks.input;\n-  this.tok = this.last = {type: __acorn.tokTypes.eof, start: 0, end: 0};\n-  this.tok.validateRegExpFlags = noop;\n-  this.tok.validateRegExpPattern = noop;\n-  if (this.options.locations) {\n-    var here = this.toks.curPosition();\n-    this.tok.loc = new __acorn.SourceLocation(this.toks, here, here);\n-  }\n-  this.ahead = []; // Tokens ahead\n-  this.context = []; // Indentation contexted\n-  this.curIndent = 0;\n-  this.curLineStart = 0;\n-  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n-  this.inAsync = false;\n-  this.inFunction = false;\n-  // Load plugins\n-  this.options.pluginsLoose = options.pluginsLoose || {};\n-  this.loadPlugins(this.options.pluginsLoose);\n-};\n-\n-LooseParser.prototype.startNode = function startNode () {\n-  return new __acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n-};\n-\n-LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n-  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n-};\n-\n-LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n-  if (this.options.locations) {\n-    return new __acorn.Node(this.toks, pos[0], pos[1])\n-  } else {\n-    return new __acorn.Node(this.toks, pos)\n-  }\n-};\n-\n-LooseParser.prototype.finishNode = function finishNode (node, type) {\n-  node.type = type;\n-  node.end = this.last.end;\n-  if (this.options.locations)\n-    { node.loc.end = this.last.loc.end; }\n-  if (this.options.ranges)\n-    { node.range[1] = this.last.end; }\n-  return node\n-};\n-\n-LooseParser.prototype.dummyNode = function dummyNode (type) {\n-  var dummy = this.startNode();\n-  dummy.type = type;\n-  dummy.end = dummy.start;\n-  if (this.options.locations)\n-    { dummy.loc.end = dummy.loc.start; }\n-  if (this.options.ranges)\n-    { dummy.range[1] = dummy.start; }\n-  this.last = {type: __acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyIdent = function dummyIdent () {\n-  var dummy = this.dummyNode(\"Identifier\");\n-  dummy.name = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyString = function dummyString () {\n-  var dummy = this.dummyNode(\"Literal\");\n-  dummy.value = dummy.raw = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.eat = function eat (type) {\n-  if (this.tok.type === type) {\n-    this.next();\n-    return true\n-  } else {\n-    return false\n-  }\n-};\n-\n-LooseParser.prototype.isContextual = function isContextual (name) {\n-  return this.tok.type === __acorn.tokTypes.name && this.tok.value === name\n-};\n-\n-LooseParser.prototype.eatContextual = function eatContextual (name) {\n-  return this.tok.value === name && this.eat(__acorn.tokTypes.name)\n-};\n-\n-LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n-  return this.tok.type === __acorn.tokTypes.eof || this.tok.type === __acorn.tokTypes.braceR ||\n-    __acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n-};\n-\n-LooseParser.prototype.semicolon = function semicolon () {\n-  return this.eat(__acorn.tokTypes.semi)\n-};\n-\n-LooseParser.prototype.expect = function expect (type) {\n-    var this$1 = this;\n-\n-  if (this.eat(type)) { return true }\n-  for (var i = 1; i <= 2; i++) {\n-    if (this$1.lookAhead(i).type === type) {\n-      for (var j = 0; j < i; j++) { this$1.next(); }\n-      return true\n-    }\n-  }\n-};\n-\n-LooseParser.prototype.pushCx = function pushCx () {\n-  this.context.push(this.curIndent);\n-};\n-\n-LooseParser.prototype.popCx = function popCx () {\n-  this.curIndent = this.context.pop();\n-};\n-\n-LooseParser.prototype.lineEnd = function lineEnd (pos) {\n-  while (pos < this.input.length && !__acorn.isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n-  return pos\n-};\n-\n-LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n-    var this$1 = this;\n-\n-  for (var count = 0;; ++pos) {\n-    var ch = this$1.input.charCodeAt(pos);\n-    if (ch === 32) { ++count; }\n-    else if (ch === 9) { count += this$1.options.tabSize; }\n-    else { return count }\n-  }\n-};\n-\n-LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n-  if (this.tok.type === closeTok || this.tok.type === __acorn.tokTypes.eof) { return true }\n-  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n-    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n-     this.indentationAfter(this.nextLineStart) < indent)\n-};\n-\n-LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n-    var this$1 = this;\n-\n-  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n-    var ch = this$1.input.charCodeAt(p);\n-    if (ch !== 9 && ch !== 32) { return false }\n-  }\n-  return true\n-};\n-\n-LooseParser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n-};\n-\n-LooseParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n-\n-  for (var name in pluginConfigs) {\n-    var plugin = pluginsLoose[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n-};\n-\n-LooseParser.prototype.parse = function parse () {\n-  this.next();\n-  return this.parseTopLevel()\n-};\n-\n-var lp = LooseParser.prototype;\n-\n-function isSpace(ch) {\n-  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || __acorn.isNewLine(ch)\n-}\n-\n-lp.next = function() {\n-  var this$1 = this;\n-\n-  this.last = this.tok;\n-  if (this.ahead.length)\n-    { this.tok = this.ahead.shift(); }\n-  else\n-    { this.tok = this.readToken(); }\n-\n-  if (this.tok.start >= this.nextLineStart) {\n-    while (this.tok.start >= this.nextLineStart) {\n-      this$1.curLineStart = this$1.nextLineStart;\n-      this$1.nextLineStart = this$1.lineEnd(this$1.curLineStart) + 1;\n-    }\n-    this.curIndent = this.indentationAfter(this.curLineStart);\n-  }\n-};\n-\n-lp.readToken = function() {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    try {\n-      this$1.toks.next();\n-      if (this$1.toks.type === __acorn.tokTypes.dot &&\n-          this$1.input.substr(this$1.toks.end, 1) === \".\" &&\n-          this$1.options.ecmaVersion >= 6) {\n-        this$1.toks.end++;\n-        this$1.toks.type = __acorn.tokTypes.ellipsis;\n-      }\n-      return new __acorn.Token(this$1.toks)\n-    } catch (e) {\n-      if (!(e instanceof SyntaxError)) { throw e }\n-\n-      // Try to skip some text, based on the error message, and then continue\n-      var msg = e.message, pos = e.raisedAt, replace = true;\n-      if (/unterminated/i.test(msg)) {\n-        pos = this$1.lineEnd(e.pos + 1);\n-        if (/string/.test(msg)) {\n-          replace = {start: e.pos, end: pos, type: __acorn.tokTypes.string, value: this$1.input.slice(e.pos + 1, pos)};\n-        } else if (/regular expr/i.test(msg)) {\n-          var re = this$1.input.slice(e.pos, pos);\n-          try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n-          replace = {start: e.pos, end: pos, type: __acorn.tokTypes.regexp, value: re};\n-        } else if (/template/.test(msg)) {\n-          replace = {\n-            start: e.pos,\n-            end: pos,\n-            type: __acorn.tokTypes.template,\n-            value: this$1.input.slice(e.pos, pos)\n-          };\n-        } else {\n-          replace = false;\n-        }\n-      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n-        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n-      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n-        while (pos < this.input.length) {\n-          var ch = this$1.input.charCodeAt(pos++);\n-          if (ch === 34 || ch === 39 || __acorn.isNewLine(ch)) { break }\n-        }\n-      } else if (/unexpected character/i.test(msg)) {\n-        pos++;\n-        replace = false;\n-      } else if (/regular expression/i.test(msg)) {\n-        replace = true;\n-      } else {\n-        throw e\n-      }\n-      this$1.resetTo(pos);\n-      if (replace === true) { replace = {start: pos, end: pos, type: __acorn.tokTypes.name, value: \"✖\"}; }\n-      if (replace) {\n-        if (this$1.options.locations)\n-          { replace.loc = new __acorn.SourceLocation(\n-            this$1.toks,\n-            __acorn.getLineInfo(this$1.input, replace.start),\n-            __acorn.getLineInfo(this$1.input, replace.end)); }\n-        return replace\n-      }\n-    }\n-  }\n-};\n-\n-lp.resetTo = function(pos) {\n-  var this$1 = this;\n-\n-  this.toks.pos = pos;\n-  var ch = this.input.charAt(pos - 1);\n-  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n-    /[enwfd]/.test(ch) &&\n-    /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n-\n-  if (this.options.locations) {\n-    this.toks.curLine = 1;\n-    this.toks.lineStart = __acorn.lineBreakG.lastIndex = 0;\n-    var match;\n-    while ((match = __acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n-      ++this$1.toks.curLine;\n-      this$1.toks.lineStart = match.index + match[0].length;\n-    }\n-  }\n-};\n-\n-lp.lookAhead = function(n) {\n-  var this$1 = this;\n-\n-  while (n > this.ahead.length)\n-    { this$1.ahead.push(this$1.readToken()); }\n-  return this.ahead[n - 1]\n-};\n-\n-function isDummy(node) { return node.name === \"✖\" }\n-\n-var lp$1 = LooseParser.prototype;\n-\n-lp$1.parseTopLevel = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNodeAt(this.options.locations ? [0, __acorn.getLineInfo(this.input, 0)] : 0);\n-  node.body = [];\n-  while (this.tok.type !== __acorn.tokTypes.eof) { node.body.push(this$1.parseStatement()); }\n-  this.toks.adaptDirectivePrologue(node.body);\n-  this.last = this.tok;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.sourceType = this.options.sourceType;\n-  }\n-  return this.finishNode(node, \"Program\")\n-};\n-\n-lp$1.parseStatement = function() {\n-  var this$1 = this;\n-\n-  var starttype = this.tok.type, node = this.startNode(), kind;\n-\n-  if (this.toks.isLet()) {\n-    starttype = __acorn.tokTypes._var;\n-    kind = \"let\";\n-  }\n-\n-  switch (starttype) {\n-  case __acorn.tokTypes._break: case __acorn.tokTypes._continue:\n-    this.next();\n-    var isBreak = starttype === __acorn.tokTypes._break;\n-    if (this.semicolon() || this.canInsertSemicolon()) {\n-      node.label = null;\n-    } else {\n-      node.label = this.tok.type === __acorn.tokTypes.name ? this.parseIdent() : null;\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n-\n-  case __acorn.tokTypes._debugger:\n-    this.next();\n-    this.semicolon();\n-    return this.finishNode(node, \"DebuggerStatement\")\n-\n-  case __acorn.tokTypes._do:\n-    this.next();\n-    node.body = this.parseStatement();\n-    node.test = this.eat(__acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n-    this.semicolon();\n-    return this.finishNode(node, \"DoWhileStatement\")\n-\n-  case __acorn.tokTypes._for:\n-    this.next(); // `for` keyword\n-    var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n-\n-    this.pushCx();\n-    this.expect(__acorn.tokTypes.parenL);\n-    if (this.tok.type === __acorn.tokTypes.semi) { return this.parseFor(node, null) }\n-    var isLet = this.toks.isLet();\n-    if (isLet || this.tok.type === __acorn.tokTypes._var || this.tok.type === __acorn.tokTypes._const) {\n-      var init$1 = this.parseVar(true, isLet ? \"let\" : this.tok.value);\n-      if (init$1.declarations.length === 1 && (this.tok.type === __acorn.tokTypes._in || this.isContextual(\"of\"))) {\n-        if (this.options.ecmaVersion >= 9 && this.tok.type !== __acorn.tokTypes._in) {\n-          node.await = isAwait;\n-        }\n-        return this.parseForIn(node, init$1)\n-      }\n-      return this.parseFor(node, init$1)\n-    }\n-    var init = this.parseExpression(true);\n-    if (this.tok.type === __acorn.tokTypes._in || this.isContextual(\"of\")) {\n-      if (this.options.ecmaVersion >= 9 && this.tok.type !== __acorn.tokTypes._in) {\n-        node.await = isAwait;\n-      }\n-      return this.parseForIn(node, this.toAssignable(init))\n-    }\n-    return this.parseFor(node, init)\n-\n-  case __acorn.tokTypes._function:\n-    this.next();\n-    return this.parseFunction(node, true)\n-\n-  case __acorn.tokTypes._if:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.consequent = this.parseStatement();\n-    node.alternate = this.eat(__acorn.tokTypes._else) ? this.parseStatement() : null;\n-    return this.finishNode(node, \"IfStatement\")\n-\n-  case __acorn.tokTypes._return:\n-    this.next();\n-    if (this.eat(__acorn.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n-    else { node.argument = this.parseExpression(); this.semicolon(); }\n-    return this.finishNode(node, \"ReturnStatement\")\n-\n-  case __acorn.tokTypes._switch:\n-    var blockIndent = this.curIndent, line = this.curLineStart;\n-    this.next();\n-    node.discriminant = this.parseParenExpression();\n-    node.cases = [];\n-    this.pushCx();\n-    this.expect(__acorn.tokTypes.braceL);\n-\n-    var cur;\n-    while (!this.closes(__acorn.tokTypes.braceR, blockIndent, line, true)) {\n-      if (this$1.tok.type === __acorn.tokTypes._case || this$1.tok.type === __acorn.tokTypes._default) {\n-        var isCase = this$1.tok.type === __acorn.tokTypes._case;\n-        if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n-        node.cases.push(cur = this$1.startNode());\n-        cur.consequent = [];\n-        this$1.next();\n-        if (isCase) { cur.test = this$1.parseExpression(); }\n-        else { cur.test = null; }\n-        this$1.expect(__acorn.tokTypes.colon);\n-      } else {\n-        if (!cur) {\n-          node.cases.push(cur = this$1.startNode());\n-          cur.consequent = [];\n-          cur.test = null;\n-        }\n-        cur.consequent.push(this$1.parseStatement());\n-      }\n-    }\n-    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n-    this.popCx();\n-    this.eat(__acorn.tokTypes.braceR);\n-    return this.finishNode(node, \"SwitchStatement\")\n-\n-  case __acorn.tokTypes._throw:\n-    this.next();\n-    node.argument = this.parseExpression();\n-    this.semicolon();\n-    return this.finishNode(node, \"ThrowStatement\")\n-\n-  case __acorn.tokTypes._try:\n-    this.next();\n-    node.block = this.parseBlock();\n-    node.handler = null;\n-    if (this.tok.type === __acorn.tokTypes._catch) {\n-      var clause = this.startNode();\n-      this.next();\n-      if (this.eat(__acorn.tokTypes.parenL)) {\n-        clause.param = this.toAssignable(this.parseExprAtom(), true);\n-        this.expect(__acorn.tokTypes.parenR);\n-      } else {\n-        clause.param = null;\n-      }\n-      clause.body = this.parseBlock();\n-      node.handler = this.finishNode(clause, \"CatchClause\");\n-    }\n-    node.finalizer = this.eat(__acorn.tokTypes._finally) ? this.parseBlock() : null;\n-    if (!node.handler && !node.finalizer) { return node.block }\n-    return this.finishNode(node, \"TryStatement\")\n-\n-  case __acorn.tokTypes._var:\n-  case __acorn.tokTypes._const:\n-    return this.parseVar(false, kind || this.tok.value)\n-\n-  case __acorn.tokTypes._while:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WhileStatement\")\n-\n-  case __acorn.tokTypes._with:\n-    this.next();\n-    node.object = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WithStatement\")\n-\n-  case __acorn.tokTypes.braceL:\n-    return this.parseBlock()\n-\n-  case __acorn.tokTypes.semi:\n-    this.next();\n-    return this.finishNode(node, \"EmptyStatement\")\n-\n-  case __acorn.tokTypes._class:\n-    return this.parseClass(true)\n-\n-  case __acorn.tokTypes._import:\n-    return this.parseImport()\n-\n-  case __acorn.tokTypes._export:\n-    return this.parseExport()\n-\n-  default:\n-    if (this.toks.isAsyncFunction()) {\n-      this.next();\n-      this.next();\n-      return this.parseFunction(node, true, true)\n-    }\n-    var expr = this.parseExpression();\n-    if (isDummy(expr)) {\n-      this.next();\n-      if (this.tok.type === __acorn.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n-      return this.parseStatement()\n-    } else if (starttype === __acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(__acorn.tokTypes.colon)) {\n-      node.body = this.parseStatement();\n-      node.label = expr;\n-      return this.finishNode(node, \"LabeledStatement\")\n-    } else {\n-      node.expression = expr;\n-      this.semicolon();\n-      return this.finishNode(node, \"ExpressionStatement\")\n-    }\n-  }\n-};\n-\n-lp$1.parseBlock = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.pushCx();\n-  this.expect(__acorn.tokTypes.braceL);\n-  var blockIndent = this.curIndent, line = this.curLineStart;\n-  node.body = [];\n-  while (!this.closes(__acorn.tokTypes.braceR, blockIndent, line, true))\n-    { node.body.push(this$1.parseStatement()); }\n-  this.popCx();\n-  this.eat(__acorn.tokTypes.braceR);\n-  return this.finishNode(node, \"BlockStatement\")\n-};\n-\n-lp$1.parseFor = function(node, init) {\n-  node.init = init;\n-  node.test = node.update = null;\n-  if (this.eat(__acorn.tokTypes.semi) && this.tok.type !== __acorn.tokTypes.semi) { node.test = this.parseExpression(); }\n-  if (this.eat(__acorn.tokTypes.semi) && this.tok.type !== __acorn.tokTypes.parenR) { node.update = this.parseExpression(); }\n-  this.popCx();\n-  this.expect(__acorn.tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, \"ForStatement\")\n-};\n-\n-lp$1.parseForIn = function(node, init) {\n-  var type = this.tok.type === __acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n-  this.next();\n-  node.left = init;\n-  node.right = this.parseExpression();\n-  this.popCx();\n-  this.expect(__acorn.tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, type)\n-};\n-\n-lp$1.parseVar = function(noIn, kind) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.kind = kind;\n-  this.next();\n-  node.declarations = [];\n-  do {\n-    var decl = this$1.startNode();\n-    decl.id = this$1.options.ecmaVersion >= 6 ? this$1.toAssignable(this$1.parseExprAtom(), true) : this$1.parseIdent();\n-    decl.init = this$1.eat(__acorn.tokTypes.eq) ? this$1.parseMaybeAssign(noIn) : null;\n-    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n-  } while (this.eat(__acorn.tokTypes.comma))\n-  if (!node.declarations.length) {\n-    var decl$1 = this.startNode();\n-    decl$1.id = this.dummyIdent();\n-    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n-  }\n-  if (!noIn) { this.semicolon(); }\n-  return this.finishNode(node, \"VariableDeclaration\")\n-};\n-\n-lp$1.parseClass = function(isStatement) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === __acorn.tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  else { node.id = null; }\n-  node.superClass = this.eat(__acorn.tokTypes._extends) ? this.parseExpression() : null;\n-  node.body = this.startNode();\n-  node.body.body = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(__acorn.tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(__acorn.tokTypes.braceR, indent, line)) {\n-    if (this$1.semicolon()) { continue }\n-    var method = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0);\n-    if (this$1.options.ecmaVersion >= 6) {\n-      method.static = false;\n-      isGenerator = this$1.eat(__acorn.tokTypes.star);\n-    }\n-    this$1.parsePropertyName(method);\n-    if (isDummy(method.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(__acorn.tokTypes.comma); continue }\n-    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n-        (this$1.tok.type !== __acorn.tokTypes.parenL && this$1.tok.type !== __acorn.tokTypes.braceL)) {\n-      method.static = true;\n-      isGenerator = this$1.eat(__acorn.tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      method.static = false;\n-    }\n-    if (!method.computed &&\n-        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.tok.type !== __acorn.tokTypes.parenL &&\n-        !this$1.canInsertSemicolon()) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(__acorn.tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (this$1.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n-        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n-        this$1.tok.type !== __acorn.tokTypes.parenL && this$1.tok.type !== __acorn.tokTypes.braceL) {\n-      method.kind = method.key.name;\n-      this$1.parsePropertyName(method);\n-      method.value = this$1.parseMethod(false);\n-    } else {\n-      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n-        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n-          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n-        method.kind = \"constructor\";\n-      } else {\n-        method.kind = \"method\";\n-      }\n-      method.value = this$1.parseMethod(isGenerator, isAsync);\n-    }\n-    node.body.body.push(this$1.finishNode(method, \"MethodDefinition\"));\n-  }\n-  this.popCx();\n-  if (!this.eat(__acorn.tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  this.semicolon();\n-  this.finishNode(node.body, \"ClassBody\");\n-  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n-};\n-\n-lp$1.parseFunction = function(node, isStatement, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = this.eat(__acorn.tokTypes.star);\n-  }\n-  if (this.options.ecmaVersion >= 8) {\n-    node.async = !!isAsync;\n-  }\n-  if (this.tok.type === __acorn.tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n-};\n-\n-lp$1.parseExport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.eat(__acorn.tokTypes.star)) {\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n-    return this.finishNode(node, \"ExportAllDeclaration\")\n-  }\n-  if (this.eat(__acorn.tokTypes._default)) {\n-    // export default (function foo() {}) // This is FunctionExpression.\n-    var isAsync;\n-    if (this.tok.type === __acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n-      var fNode = this.startNode();\n-      this.next();\n-      if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n-    } else if (this.tok.type === __acorn.tokTypes._class) {\n-      node.declaration = this.parseClass(\"nullableID\");\n-    } else {\n-      node.declaration = this.parseMaybeAssign();\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, \"ExportDefaultDeclaration\")\n-  }\n-  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n-    node.declaration = this.parseStatement();\n-    node.specifiers = [];\n-    node.source = null;\n-  } else {\n-    node.declaration = null;\n-    node.specifiers = this.parseExportSpecifierList();\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n-    this.semicolon();\n-  }\n-  return this.finishNode(node, \"ExportNamedDeclaration\")\n-};\n-\n-lp$1.parseImport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === __acorn.tokTypes.string) {\n-    node.specifiers = [];\n-    node.source = this.parseExprAtom();\n-  } else {\n-    var elt;\n-    if (this.tok.type === __acorn.tokTypes.name && this.tok.value !== \"from\") {\n-      elt = this.startNode();\n-      elt.local = this.parseIdent();\n-      this.finishNode(elt, \"ImportDefaultSpecifier\");\n-      this.eat(__acorn.tokTypes.comma);\n-    }\n-    node.specifiers = this.parseImportSpecifierList();\n-    node.source = this.eatContextual(\"from\") && this.tok.type === __acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n-    if (elt) { node.specifiers.unshift(elt); }\n-  }\n-  this.semicolon();\n-  return this.finishNode(node, \"ImportDeclaration\")\n-};\n-\n-lp$1.parseImportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  if (this.tok.type === __acorn.tokTypes.star) {\n-    var elt = this.startNode();\n-    this.next();\n-    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n-    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n-  } else {\n-    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-    this.pushCx();\n-    this.eat(__acorn.tokTypes.braceL);\n-    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-    while (!this.closes(__acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-      var elt$1 = this$1.startNode();\n-      if (this$1.eat(__acorn.tokTypes.star)) {\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : this$1.dummyIdent();\n-        this$1.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n-      } else {\n-        if (this$1.isContextual(\"from\")) { break }\n-        elt$1.imported = this$1.parseIdent();\n-        if (isDummy(elt$1.imported)) { break }\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt$1.imported;\n-        this$1.finishNode(elt$1, \"ImportSpecifier\");\n-      }\n-      elts.push(elt$1);\n-      this$1.eat(__acorn.tokTypes.comma);\n-    }\n-    this.eat(__acorn.tokTypes.braceR);\n-    this.popCx();\n-  }\n-  return elts\n-};\n-\n-lp$1.parseExportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-  this.pushCx();\n-  this.eat(__acorn.tokTypes.braceL);\n-  if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-  while (!this.closes(__acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-    if (this$1.isContextual(\"from\")) { break }\n-    var elt = this$1.startNode();\n-    elt.local = this$1.parseIdent();\n-    if (isDummy(elt.local)) { break }\n-    elt.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt.local;\n-    this$1.finishNode(elt, \"ExportSpecifier\");\n-    elts.push(elt);\n-    this$1.eat(__acorn.tokTypes.comma);\n-  }\n-  this.eat(__acorn.tokTypes.braceR);\n-  this.popCx();\n-  return elts\n-};\n-\n-var lp$2 = LooseParser.prototype;\n-\n-lp$2.checkLVal = function(expr) {\n-  if (!expr) { return expr }\n-  switch (expr.type) {\n-  case \"Identifier\":\n-  case \"MemberExpression\":\n-    return expr\n-\n-  case \"ParenthesizedExpression\":\n-    expr.expression = this.checkLVal(expr.expression);\n-    return expr\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseExpression = function(noIn) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseMaybeAssign(noIn);\n-  if (this.tok.type === __acorn.tokTypes.comma) {\n-    var node = this.startNodeAt(start);\n-    node.expressions = [expr];\n-    while (this.eat(__acorn.tokTypes.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn)); }\n-    return this.finishNode(node, \"SequenceExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseParenExpression = function() {\n-  this.pushCx();\n-  this.expect(__acorn.tokTypes.parenL);\n-  var val = this.parseExpression();\n-  this.popCx();\n-  this.expect(__acorn.tokTypes.parenR);\n-  return val\n-};\n-\n-lp$2.parseMaybeAssign = function(noIn) {\n-  if (this.toks.isContextual(\"yield\")) {\n-    var node = this.startNode();\n-    this.next();\n-    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== __acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n-      node.delegate = false;\n-      node.argument = null;\n-    } else {\n-      node.delegate = this.eat(__acorn.tokTypes.star);\n-      node.argument = this.parseMaybeAssign();\n-    }\n-    return this.finishNode(node, \"YieldExpression\")\n-  }\n-\n-  var start = this.storeCurrentPos();\n-  var left = this.parseMaybeConditional(noIn);\n-  if (this.tok.type.isAssign) {\n-    var node$1 = this.startNodeAt(start);\n-    node$1.operator = this.tok.value;\n-    node$1.left = this.tok.type === __acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n-    this.next();\n-    node$1.right = this.parseMaybeAssign(noIn);\n-    return this.finishNode(node$1, \"AssignmentExpression\")\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeConditional = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseExprOps(noIn);\n-  if (this.eat(__acorn.tokTypes.question)) {\n-    var node = this.startNodeAt(start);\n-    node.test = expr;\n-    node.consequent = this.parseMaybeAssign();\n-    node.alternate = this.expect(__acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n-    return this.finishNode(node, \"ConditionalExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseExprOps = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var indent = this.curIndent, line = this.curLineStart;\n-  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n-};\n-\n-lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n-  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n-  var prec = this.tok.type.binop;\n-  if (prec != null && (!noIn || this.tok.type !== __acorn.tokTypes._in)) {\n-    if (prec > minPrec) {\n-      var node = this.startNodeAt(start);\n-      node.left = left;\n-      node.operator = this.tok.value;\n-      this.next();\n-      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n-        node.right = this.dummyIdent();\n-      } else {\n-        var rightStart = this.storeCurrentPos();\n-        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n-      }\n-      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n-      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n-    }\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeUnary = function(sawUnary) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos(), expr;\n-  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n-    (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n-  ) {\n-    expr = this.parseAwait();\n-    sawUnary = true;\n-  } else if (this.tok.type.prefix) {\n-    var node = this.startNode(), update = this.tok.type === __acorn.tokTypes.incDec;\n-    if (!update) { sawUnary = true; }\n-    node.operator = this.tok.value;\n-    node.prefix = true;\n-    this.next();\n-    node.argument = this.parseMaybeUnary(true);\n-    if (update) { node.argument = this.checkLVal(node.argument); }\n-    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n-  } else if (this.tok.type === __acorn.tokTypes.ellipsis) {\n-    var node$1 = this.startNode();\n-    this.next();\n-    node$1.argument = this.parseMaybeUnary(sawUnary);\n-    expr = this.finishNode(node$1, \"SpreadElement\");\n-  } else {\n-    expr = this.parseExprSubscripts();\n-    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.operator = this$1.tok.value;\n-      node$2.prefix = false;\n-      node$2.argument = this$1.checkLVal(expr);\n-      this$1.next();\n-      expr = this$1.finishNode(node$2, \"UpdateExpression\");\n-    }\n-  }\n-\n-  if (!sawUnary && this.eat(__acorn.tokTypes.starstar)) {\n-    var node$3 = this.startNodeAt(start);\n-    node$3.operator = \"**\";\n-    node$3.left = expr;\n-    node$3.right = this.parseMaybeUnary(false);\n-    return this.finishNode(node$3, \"BinaryExpression\")\n-  }\n-\n-  return expr\n-};\n-\n-lp$2.parseExprSubscripts = function() {\n-  var start = this.storeCurrentPos();\n-  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n-};\n-\n-lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine()) {\n-      if (this$1.tok.type === __acorn.tokTypes.dot && this$1.curIndent === startIndent)\n-        { --startIndent; }\n-      else\n-        { return base }\n-    }\n-\n-    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this$1.canInsertSemicolon();\n-\n-    if (this$1.eat(__acorn.tokTypes.dot)) {\n-      var node = this$1.startNodeAt(start);\n-      node.object = base;\n-      if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine())\n-        { node.property = this$1.dummyIdent(); }\n-      else\n-        { node.property = this$1.parsePropertyAccessor() || this$1.dummyIdent(); }\n-      node.computed = false;\n-      base = this$1.finishNode(node, \"MemberExpression\");\n-    } else if (this$1.tok.type === __acorn.tokTypes.bracketL) {\n-      this$1.pushCx();\n-      this$1.next();\n-      var node$1 = this$1.startNodeAt(start);\n-      node$1.object = base;\n-      node$1.property = this$1.parseExpression();\n-      node$1.computed = true;\n-      this$1.popCx();\n-      this$1.expect(__acorn.tokTypes.bracketR);\n-      base = this$1.finishNode(node$1, \"MemberExpression\");\n-    } else if (!noCalls && this$1.tok.type === __acorn.tokTypes.parenL) {\n-      var exprList = this$1.parseExprList(__acorn.tokTypes.parenR);\n-      if (maybeAsyncArrow && this$1.eat(__acorn.tokTypes.arrow))\n-        { return this$1.parseArrowExpression(this$1.startNodeAt(start), exprList, true) }\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.callee = base;\n-      node$2.arguments = exprList;\n-      base = this$1.finishNode(node$2, \"CallExpression\");\n-    } else if (this$1.tok.type === __acorn.tokTypes.backQuote) {\n-      var node$3 = this$1.startNodeAt(start);\n-      node$3.tag = base;\n-      node$3.quasi = this$1.parseTemplate();\n-      base = this$1.finishNode(node$3, \"TaggedTemplateExpression\");\n-    } else {\n-      return base\n-    }\n-  }\n-};\n-\n-lp$2.parseExprAtom = function() {\n-  var node;\n-  switch (this.tok.type) {\n-  case __acorn.tokTypes._this:\n-  case __acorn.tokTypes._super:\n-    var type = this.tok.type === __acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n-    node = this.startNode();\n-    this.next();\n-    return this.finishNode(node, type)\n-\n-  case __acorn.tokTypes.name:\n-    var start = this.storeCurrentPos();\n-    var id = this.parseIdent();\n-    var isAsync = false;\n-    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n-      if (this.eat(__acorn.tokTypes._function))\n-        { return this.parseFunction(this.startNodeAt(start), false, true) }\n-      if (this.tok.type === __acorn.tokTypes.name) {\n-        id = this.parseIdent();\n-        isAsync = true;\n-      }\n-    }\n-    return this.eat(__acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n-\n-  case __acorn.tokTypes.regexp:\n-    node = this.startNode();\n-    var val = this.tok.value;\n-    node.regex = {pattern: val.pattern, flags: val.flags};\n-    node.value = val.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case __acorn.tokTypes.num: case __acorn.tokTypes.string:\n-    node = this.startNode();\n-    node.value = this.tok.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case __acorn.tokTypes._null: case __acorn.tokTypes._true: case __acorn.tokTypes._false:\n-    node = this.startNode();\n-    node.value = this.tok.type === __acorn.tokTypes._null ? null : this.tok.type === __acorn.tokTypes._true;\n-    node.raw = this.tok.type.keyword;\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case __acorn.tokTypes.parenL:\n-    var parenStart = this.storeCurrentPos();\n-    this.next();\n-    var inner = this.parseExpression();\n-    this.expect(__acorn.tokTypes.parenR);\n-    if (this.eat(__acorn.tokTypes.arrow)) {\n-      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n-      var params = inner.expressions || [inner];\n-      if (params.length && isDummy(params[params.length - 1]))\n-        { params.pop(); }\n-      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n-    }\n-    if (this.options.preserveParens) {\n-      var par = this.startNodeAt(parenStart);\n-      par.expression = inner;\n-      inner = this.finishNode(par, \"ParenthesizedExpression\");\n-    }\n-    return inner\n-\n-  case __acorn.tokTypes.bracketL:\n-    node = this.startNode();\n-    node.elements = this.parseExprList(__acorn.tokTypes.bracketR, true);\n-    return this.finishNode(node, \"ArrayExpression\")\n-\n-  case __acorn.tokTypes.braceL:\n-    return this.parseObj()\n-\n-  case __acorn.tokTypes._class:\n-    return this.parseClass(false)\n-\n-  case __acorn.tokTypes._function:\n-    node = this.startNode();\n-    this.next();\n-    return this.parseFunction(node, false)\n-\n-  case __acorn.tokTypes._new:\n-    return this.parseNew()\n-\n-  case __acorn.tokTypes.backQuote:\n-    return this.parseTemplate()\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseNew = function() {\n-  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n-  var meta = this.parseIdent(true);\n-  if (this.options.ecmaVersion >= 6 && this.eat(__acorn.tokTypes.dot)) {\n-    node.meta = meta;\n-    node.property = this.parseIdent(true);\n-    return this.finishNode(node, \"MetaProperty\")\n-  }\n-  var start = this.storeCurrentPos();\n-  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n-  if (this.tok.type === __acorn.tokTypes.parenL) {\n-    node.arguments = this.parseExprList(__acorn.tokTypes.parenR);\n-  } else {\n-    node.arguments = [];\n-  }\n-  return this.finishNode(node, \"NewExpression\")\n-};\n-\n-lp$2.parseTemplateElement = function() {\n-  var elem = this.startNode();\n-\n-  // The loose parser accepts invalid unicode escapes even in untagged templates.\n-  if (this.tok.type === __acorn.tokTypes.invalidTemplate) {\n-    elem.value = {\n-      raw: this.tok.value,\n-      cooked: null\n-    };\n-  } else {\n-    elem.value = {\n-      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n-      cooked: this.tok.value\n-    };\n-  }\n-  this.next();\n-  elem.tail = this.tok.type === __acorn.tokTypes.backQuote;\n-  return this.finishNode(elem, \"TemplateElement\")\n-};\n-\n-lp$2.parseTemplate = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  node.expressions = [];\n-  var curElt = this.parseTemplateElement();\n-  node.quasis = [curElt];\n-  while (!curElt.tail) {\n-    this$1.next();\n-    node.expressions.push(this$1.parseExpression());\n-    if (this$1.expect(__acorn.tokTypes.braceR)) {\n-      curElt = this$1.parseTemplateElement();\n-    } else {\n-      curElt = this$1.startNode();\n-      curElt.value = {cooked: \"\", raw: \"\"};\n-      curElt.tail = true;\n-      this$1.finishNode(curElt, \"TemplateElement\");\n-    }\n-    node.quasis.push(curElt);\n-  }\n-  this.expect(__acorn.tokTypes.backQuote);\n-  return this.finishNode(node, \"TemplateLiteral\")\n-};\n-\n-lp$2.parseObj = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.properties = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(__acorn.tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(__acorn.tokTypes.braceR, indent, line)) {\n-    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n-    if (this$1.options.ecmaVersion >= 9 && this$1.eat(__acorn.tokTypes.ellipsis)) {\n-      prop.argument = this$1.parseMaybeAssign();\n-      node.properties.push(this$1.finishNode(prop, \"SpreadElement\"));\n-      this$1.eat(__acorn.tokTypes.comma);\n-      continue\n-    }\n-    if (this$1.options.ecmaVersion >= 6) {\n-      start = this$1.storeCurrentPos();\n-      prop.method = false;\n-      prop.shorthand = false;\n-      isGenerator = this$1.eat(__acorn.tokTypes.star);\n-    }\n-    this$1.parsePropertyName(prop);\n-    if (this$1.toks.isAsyncProp(prop)) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(__acorn.tokTypes.star);\n-      this$1.parsePropertyName(prop);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (isDummy(prop.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(__acorn.tokTypes.comma); continue }\n-    if (this$1.eat(__acorn.tokTypes.colon)) {\n-      prop.kind = \"init\";\n-      prop.value = this$1.parseMaybeAssign();\n-    } else if (this$1.options.ecmaVersion >= 6 && (this$1.tok.type === __acorn.tokTypes.parenL || this$1.tok.type === __acorn.tokTypes.braceL)) {\n-      prop.kind = \"init\";\n-      prop.method = true;\n-      prop.value = this$1.parseMethod(isGenerator, isAsync);\n-    } else if (this$1.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n-               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n-               (this$1.tok.type !== __acorn.tokTypes.comma && this$1.tok.type !== __acorn.tokTypes.braceR && this$1.tok.type !== __acorn.tokTypes.eq)) {\n-      prop.kind = prop.key.name;\n-      this$1.parsePropertyName(prop);\n-      prop.value = this$1.parseMethod(false);\n-    } else {\n-      prop.kind = \"init\";\n-      if (this$1.options.ecmaVersion >= 6) {\n-        if (this$1.eat(__acorn.tokTypes.eq)) {\n-          var assign = this$1.startNodeAt(start);\n-          assign.operator = \"=\";\n-          assign.left = prop.key;\n-          assign.right = this$1.parseMaybeAssign();\n-          prop.value = this$1.finishNode(assign, \"AssignmentExpression\");\n-        } else {\n-          prop.value = prop.key;\n-        }\n-      } else {\n-        prop.value = this$1.dummyIdent();\n-      }\n-      prop.shorthand = true;\n-    }\n-    node.properties.push(this$1.finishNode(prop, \"Property\"));\n-    this$1.eat(__acorn.tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(__acorn.tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return this.finishNode(node, \"ObjectExpression\")\n-};\n-\n-lp$2.parsePropertyName = function(prop) {\n-  if (this.options.ecmaVersion >= 6) {\n-    if (this.eat(__acorn.tokTypes.bracketL)) {\n-      prop.computed = true;\n-      prop.key = this.parseExpression();\n-      this.expect(__acorn.tokTypes.bracketR);\n-      return\n-    } else {\n-      prop.computed = false;\n-    }\n-  }\n-  var key = (this.tok.type === __acorn.tokTypes.num || this.tok.type === __acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n-  prop.key = key || this.dummyIdent();\n-};\n-\n-lp$2.parsePropertyAccessor = function() {\n-  if (this.tok.type === __acorn.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n-};\n-\n-lp$2.parseIdent = function() {\n-  var name = this.tok.type === __acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n-  if (!name) { return this.dummyIdent() }\n-  var node = this.startNode();\n-  this.next();\n-  node.name = name;\n-  return this.finishNode(node, \"Identifier\")\n-};\n-\n-lp$2.initFunction = function(node) {\n-  node.id = null;\n-  node.params = [];\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n-};\n-\n-// Convert existing expression atom to assignable pattern\n-// if possible.\n-\n-lp$2.toAssignable = function(node, binding) {\n-  var this$1 = this;\n-\n-  if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) {\n-    // Okay\n-  } else if (node.type === \"ParenthesizedExpression\") {\n-    this.toAssignable(node.expression, binding);\n-  } else if (this.options.ecmaVersion < 6) {\n-    return this.dummyIdent()\n-  } else if (node.type === \"ObjectExpression\") {\n-    node.type = \"ObjectPattern\";\n-    for (var i = 0, list = node.properties; i < list.length; i += 1)\n-      {\n-      var prop = list[i];\n-\n-      this$1.toAssignable(prop, binding);\n-    }\n-  } else if (node.type === \"ArrayExpression\") {\n-    node.type = \"ArrayPattern\";\n-    this.toAssignableList(node.elements, binding);\n-  } else if (node.type === \"Property\") {\n-    this.toAssignable(node.value, binding);\n-  } else if (node.type === \"SpreadElement\") {\n-    node.type = \"RestElement\";\n-    this.toAssignable(node.argument, binding);\n-  } else if (node.type === \"AssignmentExpression\") {\n-    node.type = \"AssignmentPattern\";\n-    delete node.operator;\n-  } else {\n-    return this.dummyIdent()\n-  }\n-  return node\n-};\n-\n-lp$2.toAssignableList = function(exprList, binding) {\n-  var this$1 = this;\n-\n-  for (var i = 0, list = exprList; i < list.length; i += 1)\n-    {\n-    var expr = list[i];\n-\n-    this$1.toAssignable(expr, binding);\n-  }\n-  return exprList\n-};\n-\n-lp$2.parseFunctionParams = function(params) {\n-  params = this.parseExprList(__acorn.tokTypes.parenR);\n-  return this.toAssignableList(params, true)\n-};\n-\n-lp$2.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6)\n-    { node.generator = !!isGenerator; }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"FunctionExpression\")\n-};\n-\n-lp$2.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.toAssignableList(params, true);\n-  node.expression = this.tok.type !== __acorn.tokTypes.braceL;\n-  if (node.expression) {\n-    node.body = this.parseMaybeAssign();\n-  } else {\n-    node.body = this.parseBlock();\n-    this.toks.adaptDirectivePrologue(node.body.body);\n-  }\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"ArrowFunctionExpression\")\n-};\n-\n-lp$2.parseExprList = function(close, allowEmpty) {\n-  var this$1 = this;\n-\n-  this.pushCx();\n-  var indent = this.curIndent, line = this.curLineStart, elts = [];\n-  this.next(); // Opening bracket\n-  while (!this.closes(close, indent + 1, line)) {\n-    if (this$1.eat(__acorn.tokTypes.comma)) {\n-      elts.push(allowEmpty ? null : this$1.dummyIdent());\n-      continue\n-    }\n-    var elt = this$1.parseMaybeAssign();\n-    if (isDummy(elt)) {\n-      if (this$1.closes(close, indent, line)) { break }\n-      this$1.next();\n-    } else {\n-      elts.push(elt);\n-    }\n-    this$1.eat(__acorn.tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(close)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return elts\n-};\n-\n-lp$2.parseAwait = function() {\n-  var node = this.startNode();\n-  this.next();\n-  node.argument = this.parseMaybeUnary();\n-  return this.finishNode(node, \"AwaitExpression\")\n-};\n-\n-// Acorn: Loose parser\n-//\n-// This module provides an alternative parser (`parse_dammit`) that\n-// exposes that same interface as `parse`, but will try to parse\n-// anything as JavaScript, repairing syntax error the best it can.\n-// There are circumstances in which it will raise an error and give\n-// up, but they are very rare. The resulting AST will be a mostly\n-// valid JavaScript AST (as per the [Mozilla parser API][api], except\n-// that:\n-//\n-// - Return outside functions is allowed\n-//\n-// - Label consistency (no conflicts, break only to existing labels)\n-//   is not enforced.\n-//\n-// - Bogus Identifier nodes with a name of `\"✖\"` are inserted whenever\n-//   the parser got too confused to return anything meaningful.\n-//\n-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n-//\n-// The expected use for this is to *first* try `acorn.parse`, and only\n-// if that fails switch to `parse_dammit`. The loose parser might\n-// parse badly indented code incorrectly, so **don't** use it as\n-// your default parser.\n-//\n-// Quite a lot of acorn.js is duplicated here. The alternative was to\n-// add a *lot* of extra cruft to that file, making it less readable\n-// and slower. Copying and editing the code allowed me to make\n-// invasive changes and simplifications without creating a complicated\n-// tangle.\n-\n-__acorn.defaultOptions.tabSize = 4;\n-\n-// eslint-disable-next-line camelcase\n-function parse_dammit(input, options) {\n-  return new LooseParser(input, options).parse()\n-}\n-\n-__acorn.addLooseExports(parse_dammit, LooseParser, pluginsLoose);\n-\n-exports.parse_dammit = parse_dammit;\n-exports.LooseParser = LooseParser;\n-exports.pluginsLoose = pluginsLoose;\n-\n-Object.defineProperty(exports, '__esModule', { value: true });\n-\n-})));"
        },
        {
            "sha": "80da6501a8b971e71e89e8b21433b5c01297d455",
            "filename": "deps/acorn/package.json",
            "status": "removed",
            "additions": 0,
            "deletions": 60,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/39171d755d3e81f03ac0fd716cd80c2e20882fb6/deps%2Facorn%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Facorn%2Fpackage.json?ref=39171d755d3e81f03ac0fd716cd80c2e20882fb6",
            "patch": "@@ -1,60 +0,0 @@\n-{\n-  \"name\": \"acorn\",\n-  \"description\": \"ECMAScript parser\",\n-  \"homepage\": \"https://github.com/acornjs/acorn\",\n-  \"main\": \"dist/acorn.js\",\n-  \"module\": \"dist/acorn.es.js\",\n-  \"version\": \"5.7.2\",\n-  \"engines\": {\n-    \"node\": \">=0.4.0\"\n-  },\n-  \"maintainers\": [\n-    {\n-      \"name\": \"Marijn Haverbeke\",\n-      \"email\": \"marijnh@gmail.com\",\n-      \"web\": \"http://marijnhaverbeke.nl\"\n-    },\n-    {\n-      \"name\": \"Ingvar Stepanyan\",\n-      \"email\": \"me@rreverser.com\",\n-      \"web\": \"http://rreverser.com/\"\n-    },\n-    {\n-      \"name\": \"Adrian Heine\",\n-      \"email\": \"http://adrianheine.de\"\n-    }\n-  ],\n-  \"repository\": {\n-    \"type\": \"git\",\n-    \"url\": \"https://github.com/acornjs/acorn.git\"\n-  },\n-  \"license\": \"MIT\",\n-  \"scripts\": {\n-    \"prepare\": \"npm run build && node test/run.js && node test/lint.js\",\n-    \"test\": \"node test/run.js && node test/lint.js\",\n-    \"pretest\": \"npm run build:main && npm run build:loose\",\n-    \"test:test262\": \"node bin/run_test262.js\",\n-    \"build\": \"npm run build:main && npm run build:walk && npm run build:loose && npm run build:bin\",\n-    \"build:main\": \"rollup -c rollup/config.main.js\",\n-    \"build:walk\": \"rollup -c rollup/config.walk.js\",\n-    \"build:loose\": \"rollup -c rollup/config.loose.js && rollup -c rollup/config.loose_es.js\",\n-    \"build:bin\": \"rollup -c rollup/config.bin.js\",\n-    \"lint\": \"eslint src/\"\n-  },\n-  \"bin\": {\n-    \"acorn\": \"./bin/acorn\"\n-  },\n-  \"devDependencies\": {\n-    \"eslint\": \"^4.10.0\",\n-    \"eslint-config-standard\": \"^10.2.1\",\n-    \"eslint-plugin-import\": \"^2.2.0\",\n-    \"eslint-plugin-node\": \"^5.2.1\",\n-    \"eslint-plugin-promise\": \"^3.5.0\",\n-    \"eslint-plugin-standard\": \"^3.0.1\",\n-    \"rollup\": \"^0.45.0\",\n-    \"rollup-plugin-buble\": \"^0.16.0\",\n-    \"test262\": \"git+https://github.com/tc39/test262.git#3bfad28cc302fd4455badcfcbca7c5bb7ce41a72\",\n-    \"test262-parser-runner\": \"^0.4.0\",\n-    \"unicode-11.0.0\": \"^0.7.7\"\n-  }\n-}"
        },
        {
            "sha": "013ae6e674faecc94416c35fd9f8a252ca1235f2",
            "filename": "lib/assert.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Fassert.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Fassert.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fassert.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -200,8 +200,8 @@ function getCode(fd, line, column) {\n function parseCode(code, offset) {\n   // Lazy load acorn.\n   if (parseExpressionAt === undefined) {\n-    ({ parseExpressionAt } = require('internal/deps/acorn/dist/acorn'));\n-    ({ findNodeAround } = require('internal/deps/acorn/dist/walk'));\n+    ({ parseExpressionAt } = require('internal/deps/acorn/acorn/dist/acorn'));\n+    ({ findNodeAround } = require('internal/deps/acorn/acorn-walk/dist/walk'));\n   }\n   let node;\n   let start = 0;"
        },
        {
            "sha": "bcc94ef18642664afbc50a8924abb7921219d631",
            "filename": "lib/internal/repl/await.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Finternal%2Frepl%2Fawait.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Finternal%2Frepl%2Fawait.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Frepl%2Fawait.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -1,7 +1,7 @@\n 'use strict';\n \n-const acorn = require('internal/deps/acorn/dist/acorn');\n-const walk = require('internal/deps/acorn/dist/walk');\n+const acorn = require('internal/deps/acorn/acorn/dist/acorn');\n+const walk = require('internal/deps/acorn/acorn-walk/dist/walk');\n \n const noop = () => {};\n const visitorsWithoutAncestors = {"
        },
        {
            "sha": "bb5af0ec225aa1fc5f535dacc6f48e192c41278b",
            "filename": "lib/internal/repl/recoverable.js",
            "status": "modified",
            "additions": 13,
            "deletions": 18,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Finternal%2Frepl%2Frecoverable.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Finternal%2Frepl%2Frecoverable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Frepl%2Frecoverable.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -1,7 +1,7 @@\n 'use strict';\n \n-const acorn = require('internal/deps/acorn/dist/acorn');\n-const { tokTypes: tt } = acorn;\n+const acorn = require('internal/deps/acorn/acorn/dist/acorn');\n+const { tokTypes: tt, Parser: AcornParser } = acorn;\n \n // If the error is that we've unexpectedly ended the input,\n // then let the user try to recover by adding more input.\n@@ -26,17 +26,13 @@ function isRecoverableError(e, code) {\n   //       change these messages in the future, this will lead to a test\n   //       failure, indicating that this code needs to be updated.\n   //\n-  acorn.plugins.replRecoverable = (parser) => {\n-    parser.extend('nextToken', (nextToken) => {\n-      return function() {\n-        Reflect.apply(nextToken, this, []);\n-\n+  const RecoverableParser = AcornParser.extend((Parser) => {\n+    return class extends Parser {\n+      nextToken() {\n+        super.nextToken();\n         if (this.type === tt.eof) recoverable = true;\n-      };\n-    });\n-\n-    parser.extend('raise', (raise) => {\n-      return function(pos, message) {\n+      }\n+      raise(pos, message) {\n         switch (message) {\n           case 'Unterminated template':\n           case 'Unterminated comment':\n@@ -48,11 +44,10 @@ function isRecoverableError(e, code) {\n             // See https://www.ecma-international.org/ecma-262/#sec-line-terminators\n             recoverable = /\\\\(?:\\r\\n?|\\n|\\u2028|\\u2029)$/.test(token);\n         }\n-\n-        Reflect.apply(raise, this, [pos, message]);\n-      };\n-    });\n-  };\n+        super.raise(pos, message);\n+      }\n+    };\n+  });\n \n   // For similar reasons as `defaultEval`, wrap expressions starting with a\n   // curly brace with parenthesis.  Note: only the open parenthesis is added\n@@ -63,7 +58,7 @@ function isRecoverableError(e, code) {\n   // Try to parse the code with acorn.  If the parse fails, ignore the acorn\n   // error and return the recoverable status.\n   try {\n-    acorn.parse(code, { plugins: { replRecoverable: true }, ecmaVersion: 10 });\n+    RecoverableParser.parse(code, { ecmaVersion: 10 });\n \n     // Odd case: the underlying JS engine (V8, Chakra) rejected this input\n     // but Acorn detected no issue.  Presume that additional text won't"
        },
        {
            "sha": "f1b269b801905fcbd2fd35fb8e464a3f4064c23f",
            "filename": "lib/repl.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Frepl.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/lib%2Frepl.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Frepl.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -50,7 +50,7 @@ const {\n const {\n   isIdentifierStart,\n   isIdentifierChar\n-} = require('internal/deps/acorn/dist/acorn');\n+} = require('internal/deps/acorn/acorn/dist/acorn');\n const internalUtil = require('internal/util');\n const util = require('util');\n const Stream = require('stream');"
        },
        {
            "sha": "4b3318e8afa9d524bb0cb2af472823ee96b32bc0",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -219,8 +219,8 @@\n       'deps/node-inspect/lib/_inspect.js',\n       'deps/node-inspect/lib/internal/inspect_client.js',\n       'deps/node-inspect/lib/internal/inspect_repl.js',\n-      'deps/acorn/dist/acorn.js',\n-      'deps/acorn/dist/walk.js',\n+      'deps/acorn/acorn/dist/acorn.js',\n+      'deps/acorn/acorn-walk/dist/walk.js',\n     ],\n     'conditions': [\n       [ 'node_shared==\"true\"', {"
        },
        {
            "sha": "514d22e8dcd37501961f7a16e66c7255adf2c55e",
            "filename": "tools/doc/apilinks.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/tools%2Fdoc%2Fapilinks.js",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/tools%2Fdoc%2Fapilinks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fapilinks.js?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -18,7 +18,7 @@\n //    `function X(...) {...}`). Over time, we expect to handle more\n //    cases (example: ES2015 class definitions).\n \n-const acorn = require('../../deps/acorn');\n+const acorn = require('../../deps/acorn/acorn');\n const fs = require('fs');\n const path = require('path');\n const child_process = require('child_process');"
        },
        {
            "sha": "1c884508e3f5e93b39ae0af6011be433e59ce70f",
            "filename": "tools/license-builder.sh",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/582c12260ed99ebe7710894c2dab29435b1bebdc/tools%2Flicense-builder.sh",
            "raw_url": "https://github.com/nodejs/node/raw/582c12260ed99ebe7710894c2dab29435b1bebdc/tools%2Flicense-builder.sh",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Flicense-builder.sh?ref=582c12260ed99ebe7710894c2dab29435b1bebdc",
            "patch": "@@ -29,7 +29,7 @@ fi\n \n \n # Dependencies bundled in distributions\n-addlicense \"Acorn\" \"deps/acorn\" \"$(cat ${rootdir}/deps/acorn/LICENSE)\"\n+addlicense \"Acorn\" \"deps/acorn\" \"$(cat ${rootdir}/deps/acorn/acorn/LICENSE)\"\n addlicense \"c-ares\" \"deps/cares\" \"$(tail -n +3 ${rootdir}/deps/cares/LICENSE.md)\"\n addlicense \"HTTP Parser\" \"deps/http_parser\" \"$(cat deps/http_parser/LICENSE-MIT)\"\n if [ -f \"${rootdir}/deps/icu/LICENSE\" ]; then"
        }
    ],
    "stats": {
        "total": 7330,
        "additions": 1794,
        "deletions": 5536
    }
}