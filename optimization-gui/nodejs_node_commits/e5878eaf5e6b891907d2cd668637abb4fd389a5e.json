{
    "author": "sam-github",
    "message": "test: test TLS client authentication\n\nTLS client authentication should be tested, including failure scenarios.\n\nPR-URL: https://github.com/nodejs/node/pull/24733\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "e5878eaf5e6b891907d2cd668637abb4fd389a5e",
    "files": [
        {
            "sha": "44ad2bdf2d352686a84f02f14ae277c011fa944c",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/e5878eaf5e6b891907d2cd668637abb4fd389a5e/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/e5878eaf5e6b891907d2cd668637abb4fd389a5e/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=e5878eaf5e6b891907d2cd668637abb4fd389a5e",
            "patch": "@@ -1092,6 +1092,8 @@ changes:\n     certificate can match or chain to.\n     For self-signed certificates, the certificate is its own CA, and must be\n     provided.\n+    For PEM encoded certificates, supported types are \"X509 CERTIFICATE\", and\n+    \"CERTIFICATE\".\n   * `cert` {string|string[]|Buffer|Buffer[]} Cert chains in PEM format. One cert\n     chain should be provided per private key. Each cert chain should consist of\n     the PEM formatted certificate for a provided private `key`, followed by the"
        },
        {
            "sha": "764bea77033d28fdb1e15f7cf4351e27726588bb",
            "filename": "test/fixtures/tls-connect.js",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/e5878eaf5e6b891907d2cd668637abb4fd389a5e/test%2Ffixtures%2Ftls-connect.js",
            "raw_url": "https://github.com/nodejs/node/raw/e5878eaf5e6b891907d2cd668637abb4fd389a5e/test%2Ffixtures%2Ftls-connect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Ffixtures%2Ftls-connect.js?ref=e5878eaf5e6b891907d2cd668637abb4fd389a5e",
            "patch": "@@ -26,15 +26,18 @@ const keys = exports.keys = {\n   agent5: load('agent5', 'ca2'),\n   agent6: load('agent6', 'ca1'),\n   agent7: load('agent7', 'fake-cnnic-root'),\n+  agent10: load('agent10', 'ca2'),\n+  ec10: load('ec10', 'ca5'),\n   ec: load('ec', 'ec'),\n };\n \n-function load(cert, issuer) {\n-  issuer = issuer || cert; // Assume self-signed if no issuer\n+// root is the self-signed root of the trust chain, not an intermediate ca.\n+function load(cert, root) {\n+  root = root || cert; // Assume self-signed if no issuer\n   const id = {\n     key: fixtures.readKey(cert + '-key.pem', 'binary'),\n     cert: fixtures.readKey(cert + '-cert.pem', 'binary'),\n-    ca: fixtures.readKey(issuer + '-cert.pem', 'binary'),\n+    ca: fixtures.readKey(root + '-cert.pem', 'binary'),\n   };\n   return id;\n }"
        },
        {
            "sha": "1701981692280e2f1f3a420cc31f32bf2817428a",
            "filename": "test/parallel/test-tls-client-auth.js",
            "status": "added",
            "additions": 331,
            "deletions": 0,
            "changes": 331,
            "blob_url": "https://github.com/nodejs/node/blob/e5878eaf5e6b891907d2cd668637abb4fd389a5e/test%2Fparallel%2Ftest-tls-client-auth.js",
            "raw_url": "https://github.com/nodejs/node/raw/e5878eaf5e6b891907d2cd668637abb4fd389a5e/test%2Fparallel%2Ftest-tls-client-auth.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-client-auth.js?ref=e5878eaf5e6b891907d2cd668637abb4fd389a5e",
            "patch": "@@ -0,0 +1,331 @@\n+'use strict';\n+\n+require('../common');\n+const fixtures = require('../common/fixtures');\n+\n+const {\n+  assert, connect, keys\n+} = require(fixtures.path('tls-connect'));\n+\n+// Use ec10 and agent10, they are the only identities with intermediate CAs.\n+const client = keys.ec10;\n+const server = keys.agent10;\n+\n+// The certificates aren't for \"localhost\", so override the identity check.\n+function checkServerIdentity(hostname, cert) {\n+  assert.strictEqual(hostname, 'localhost');\n+  assert.strictEqual(cert.subject.CN, 'agent10.example.com');\n+}\n+\n+// Split out the single end-entity cert and the subordinate CA for later use.\n+split(client.cert, client);\n+split(server.cert, server);\n+\n+function split(file, into) {\n+  const certs = /([^]*END CERTIFICATE-----\\r?\\n)(-----BEGIN[^]*)/.exec(file);\n+  assert.strictEqual(certs.length, 3);\n+  into.single = certs[1];\n+  into.subca = certs[2];\n+}\n+\n+// Typical setup, nothing special, complete cert chains sent to peer.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.cert,\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// As above, but without requesting client's cert.\n+connect({\n+  client: {\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// Request cert from client that doesn't have one.\n+connect({\n+  client: {\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'ECONNRESET');\n+  return cleanup();\n+});\n+\n+// Typical configuration error, incomplete cert chains sent, we have to know the\n+// peer's subordinate CAs in order to verify the peer.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.single,\n+    ca: [server.ca, server.subca],\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.single,\n+    ca: [client.ca, client.subca],\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// Like above, but provide root CA and subordinate CA as multi-PEM.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.single,\n+    ca: server.ca + '\\n' + server.subca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.single,\n+    ca: client.ca + '\\n' + client.subca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// Like above, but provide multi-PEM in an array.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.single,\n+    ca: [server.ca + '\\n' + server.subca],\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.single,\n+    ca: [client.ca + '\\n' + client.subca],\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// Fail to complete server's chain\n+connect({\n+  client: {\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.single,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'UNABLE_TO_VERIFY_LEAF_SIGNATURE');\n+  return cleanup();\n+});\n+\n+// Fail to complete client's chain.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.single,\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(pair.client.error);\n+  assert.ifError(pair.server.error);\n+  assert.strictEqual(err.code, 'ECONNRESET');\n+  return cleanup();\n+});\n+\n+// Fail to find CA for server.\n+connect({\n+  client: {\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY');\n+  return cleanup();\n+});\n+\n+// Server sent their CA, but CA cannot be trusted if it is not locally known.\n+connect({\n+  client: {\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert + '\\n' + server.ca,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'SELF_SIGNED_CERT_IN_CHAIN');\n+  return cleanup();\n+});\n+\n+// Server sent their CA, wrongly, but its OK since we know the CA locally.\n+connect({\n+  client: {\n+    checkServerIdentity,\n+    ca: server.ca,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert + '\\n' + server.ca,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// Fail to complete client's chain.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.single,\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'ECONNRESET');\n+  return cleanup();\n+});\n+\n+// Fail to find CA for client.\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.cert,\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'ECONNRESET');\n+  return cleanup();\n+});\n+\n+// Confirm lack of support for \"BEGIN TRUSTED CERTIFICATE\".\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.cert,\n+    ca: server.ca.replace(/CERTIFICATE/g, 'TRUSTED CERTIFICATE'),\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY');\n+  return cleanup();\n+});\n+\n+// Confirm lack of support for \"BEGIN TRUSTED CERTIFICATE\".\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.cert,\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca.replace(/CERTIFICATE/g, 'TRUSTED CERTIFICATE'),\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.strictEqual(err.code, 'ECONNRESET');\n+  return cleanup();\n+});\n+\n+// Confirm support for \"BEGIN X509 CERTIFICATE\".\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.cert,\n+    ca: server.ca.replace(/CERTIFICATE/g, 'X509 CERTIFICATE'),\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca,\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});\n+\n+// Confirm support for \"BEGIN X509 CERTIFICATE\".\n+connect({\n+  client: {\n+    key: client.key,\n+    cert: client.cert,\n+    ca: server.ca,\n+    checkServerIdentity,\n+  },\n+  server: {\n+    key: server.key,\n+    cert: server.cert,\n+    ca: client.ca.replace(/CERTIFICATE/g, 'X509 CERTIFICATE'),\n+    requestCert: true,\n+  },\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  return cleanup();\n+});"
        }
    ],
    "stats": {
        "total": 342,
        "additions": 339,
        "deletions": 3
    }
}