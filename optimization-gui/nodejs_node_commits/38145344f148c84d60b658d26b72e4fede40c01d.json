{
    "author": "rpetrich",
    "message": "src: fix race on modpending\n\nFixes a rare race condition on modpending when two native modules are\nloaded simultaneously on different threads by storing it thread-\nlocally.\n\nPR-URL: https://github.com/nodejs/node/pull/21611\nReviewed-By: Gabriel Schulhof <gabriel.schulhof@intel.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>",
    "sha": "38145344f148c84d60b658d26b72e4fede40c01d",
    "files": [
        {
            "sha": "fb4b5703f8c7112a65e7cb66bc6a9a379f2032b0",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/38145344f148c84d60b658d26b72e4fede40c01d/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/38145344f148c84d60b658d26b72e4fede40c01d/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=38145344f148c84d60b658d26b72e4fede40c01d",
            "patch": "@@ -187,7 +187,8 @@ static int v8_thread_pool_size = v8_default_thread_pool_size;\n static bool prof_process = false;\n static bool v8_is_profiling = false;\n static bool node_is_initialized = false;\n-static node_module* modpending;\n+static uv_once_t init_modpending_once = UV_ONCE_INIT;\n+static uv_key_t thread_local_modpending;\n static node_module* modlist_builtin;\n static node_module* modlist_internal;\n static node_module* modlist_linked;\n@@ -1253,7 +1254,7 @@ extern \"C\" void node_module_register(void* m) {\n     mp->nm_link = modlist_linked;\n     modlist_linked = mp;\n   } else {\n-    modpending = mp;\n+    uv_key_set(&thread_local_modpending, mp);\n   }\n }\n \n@@ -1367,6 +1368,10 @@ inline napi_addon_register_func GetNapiInitializerCallback(DLib* dlib) {\n       reinterpret_cast<napi_addon_register_func>(dlib->GetSymbolAddress(name));\n }\n \n+void InitModpendingOnce() {\n+  CHECK_EQ(0, uv_key_create(&thread_local_modpending));\n+}\n+\n // DLOpen is process.dlopen(module, filename, flags).\n // Used to load 'module.node' dynamically shared objects.\n //\n@@ -1377,7 +1382,8 @@ static void DLOpen(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   auto context = env->context();\n \n-  CHECK_NULL(modpending);\n+  uv_once(&init_modpending_once, InitModpendingOnce);\n+  CHECK_NULL(uv_key_get(&thread_local_modpending));\n \n   if (args.Length() < 2) {\n     env->ThrowError(\"process.dlopen needs at least 2 arguments.\");\n@@ -1405,8 +1411,9 @@ static void DLOpen(const FunctionCallbackInfo<Value>& args) {\n   // Objects containing v14 or later modules will have registered themselves\n   // on the pending list.  Activate all of them now.  At present, only one\n   // module per object is supported.\n-  node_module* const mp = modpending;\n-  modpending = nullptr;\n+  node_module* const mp = static_cast<node_module*>(\n+      uv_key_get(&thread_local_modpending));\n+  uv_key_set(&thread_local_modpending, nullptr);\n \n   if (!is_opened) {\n     Local<String> errmsg = OneByteString(env->isolate(), dlib.errmsg_.c_str());"
        }
    ],
    "stats": {
        "total": 17,
        "additions": 12,
        "deletions": 5
    }
}