{
    "author": "danbev",
    "message": "src: make pointers lean left in node_crypto.cc\n\nPR-URL: https://github.com/nodejs/node/pull/20799\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "a0eb1e41191680551322ad607a619eb570a40291",
    "files": [
        {
            "sha": "3babec6e32fc057016ebdae045a18f5c26c8e436",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/a0eb1e41191680551322ad607a619eb570a40291/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a0eb1e41191680551322ad607a619eb570a40291/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=a0eb1e41191680551322ad607a619eb570a40291",
            "patch": "@@ -153,7 +153,7 @@ template int SSLWrap<TLSWrap>::SelectALPNCallback(\n #endif  // TLSEXT_TYPE_application_layer_protocol_negotiation\n \n \n-static int PasswordCallback(char *buf, int size, int rwflag, void *u) {\n+static int PasswordCallback(char* buf, int size, int rwflag, void* u) {\n   if (u) {\n     size_t buflen = static_cast<size_t>(size);\n     size_t len = strlen(static_cast<const char*>(u));\n@@ -206,7 +206,7 @@ static ENGINE* LoadEngineById(const char* engine_id, char (*errmsg)[1024]) {\n // for the OpenSSL CLI, but works poorly for Node.js because it involves\n // synchronous interaction with the controlling terminal, something we never\n // want, and use this function to avoid it.\n-static int NoPasswordCallback(char *buf, int size, int rwflag, void *u) {\n+static int NoPasswordCallback(char* buf, int size, int rwflag, void* u) {\n   return 0;\n }\n \n@@ -726,7 +726,7 @@ static X509_STORE* NewRootCertStore() {\n   if (root_certs_vector.empty()) {\n     for (size_t i = 0; i < arraysize(root_certs); i++) {\n       BIO* bp = NodeBIO::NewFixed(root_certs[i], strlen(root_certs[i]));\n-      X509 *x509 = PEM_read_bio_X509(bp, nullptr, NoPasswordCallback, nullptr);\n+      X509* x509 = PEM_read_bio_X509(bp, nullptr, NoPasswordCallback, nullptr);\n       BIO_free(bp);\n \n       // Parse errors from the built-in roots are fatal.\n@@ -743,7 +743,7 @@ static X509_STORE* NewRootCertStore() {\n   if (ssl_openssl_cert_store) {\n     X509_STORE_set_default_paths(store);\n   } else {\n-    for (X509 *cert : root_certs_vector) {\n+    for (X509* cert : root_certs_vector) {\n       X509_up_ref(cert);\n       X509_STORE_add_cert(store, cert);\n     }\n@@ -1994,7 +1994,7 @@ void SSLWrap<Base>::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {\n   if (sess == nullptr)\n     return;\n \n-  const unsigned char *ticket;\n+  const unsigned char* ticket;\n   size_t length;\n   SSL_SESSION_get0_ticket(sess, &ticket, &length);\n \n@@ -2771,7 +2771,7 @@ static bool IsValidGCMTagLength(unsigned int tag_len) {\n   return tag_len == 4 || tag_len == 8 || (tag_len >= 12 && tag_len <= 16);\n }\n \n-bool CipherBase::InitAuthenticated(const char *cipher_type, int iv_len,\n+bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n                                    unsigned int auth_tag_len) {\n   CHECK(IsAuthenticatedMode());\n \n@@ -3079,7 +3079,7 @@ void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-bool CipherBase::Final(unsigned char** out, int *out_len) {\n+bool CipherBase::Final(unsigned char** out, int* out_len) {\n   if (!ctx_)\n     return false;\n "
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}