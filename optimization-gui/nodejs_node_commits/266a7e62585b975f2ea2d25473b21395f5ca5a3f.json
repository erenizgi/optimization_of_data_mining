{
    "author": "addaleax",
    "message": "src: use V8 graph heap snapshot API\n\nTransition to a newer, more flexible API for\nheap snapshot creation.\n\nThis addresses a currently pending deprecation in the V8 API.\n\nPR-URL: https://github.com/nodejs/node/pull/21741\nFixes: https://github.com/nodejs/node/issues/21633\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "266a7e62585b975f2ea2d25473b21395f5ca5a3f",
    "files": [
        {
            "sha": "7ef3dafdf992c5f59c675b2bce2ccdc310d3a852",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 95,
            "changes": 100,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -32,7 +32,6 @@ using v8::Function;\n using v8::FunctionCallbackInfo;\n using v8::FunctionTemplate;\n using v8::HandleScope;\n-using v8::HeapProfiler;\n using v8::Integer;\n using v8::Isolate;\n using v8::Local;\n@@ -43,7 +42,6 @@ using v8::ObjectTemplate;\n using v8::Promise;\n using v8::PromiseHookType;\n using v8::PropertyCallbackInfo;\n-using v8::RetainedObjectInfo;\n using v8::String;\n using v8::Uint32;\n using v8::Undefined;\n@@ -61,87 +59,6 @@ static const char* const provider_names[] = {\n };\n \n \n-// Report correct information in a heapdump.\n-\n-class RetainedAsyncInfo: public RetainedObjectInfo {\n- public:\n-  explicit RetainedAsyncInfo(uint16_t class_id, AsyncWrap* wrap);\n-\n-  void Dispose() override;\n-  bool IsEquivalent(RetainedObjectInfo* other) override;\n-  intptr_t GetHash() override;\n-  const char* GetLabel() override;\n-  intptr_t GetSizeInBytes() override;\n-\n- private:\n-  const char* label_;\n-  const AsyncWrap* wrap_;\n-  const size_t length_;\n-};\n-\n-\n-static int OwnMemory(AsyncWrap* async_wrap) {\n-  MemoryTracker tracker;\n-  tracker.set_track_only_self(true);\n-  tracker.Track(async_wrap);\n-  return tracker.accumulated_size();\n-}\n-\n-\n-RetainedAsyncInfo::RetainedAsyncInfo(uint16_t class_id, AsyncWrap* wrap)\n-    : label_(provider_names[class_id - NODE_ASYNC_ID_OFFSET]),\n-      wrap_(wrap),\n-      length_(OwnMemory(wrap)) {\n-}\n-\n-\n-void RetainedAsyncInfo::Dispose() {\n-  delete this;\n-}\n-\n-\n-bool RetainedAsyncInfo::IsEquivalent(RetainedObjectInfo* other) {\n-  return label_ == other->GetLabel() &&\n-          wrap_ == static_cast<RetainedAsyncInfo*>(other)->wrap_;\n-}\n-\n-\n-intptr_t RetainedAsyncInfo::GetHash() {\n-  return reinterpret_cast<intptr_t>(wrap_);\n-}\n-\n-\n-const char* RetainedAsyncInfo::GetLabel() {\n-  return label_;\n-}\n-\n-\n-intptr_t RetainedAsyncInfo::GetSizeInBytes() {\n-  return length_;\n-}\n-\n-\n-RetainedObjectInfo* WrapperInfo(uint16_t class_id, Local<Value> wrapper) {\n-  // No class_id should be the provider type of NONE.\n-  CHECK_GT(class_id, NODE_ASYNC_ID_OFFSET);\n-  // And make sure the class_id doesn't extend past the last provider.\n-  CHECK_LE(class_id - NODE_ASYNC_ID_OFFSET, AsyncWrap::PROVIDERS_LENGTH);\n-  CHECK(wrapper->IsObject());\n-  CHECK(!wrapper.IsEmpty());\n-\n-  Local<Object> object = wrapper.As<Object>();\n-  CHECK_GT(object->InternalFieldCount(), 0);\n-\n-  AsyncWrap* wrap;\n-  ASSIGN_OR_RETURN_UNWRAP(&wrap, object, nullptr);\n-\n-  return new RetainedAsyncInfo(class_id, wrap);\n-}\n-\n-\n-// end RetainedAsyncInfo\n-\n-\n struct AsyncWrapObject : public AsyncWrap {\n   static inline void New(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n@@ -616,16 +533,6 @@ void AsyncWrap::Initialize(Local<Object> target,\n }\n \n \n-void LoadAsyncWrapperInfo(Environment* env) {\n-  HeapProfiler* heap_profiler = env->isolate()->GetHeapProfiler();\n-#define V(PROVIDER)                                                           \\\n-  heap_profiler->SetWrapperClassInfoProvider(                                 \\\n-      (NODE_ASYNC_ID_OFFSET + AsyncWrap::PROVIDER_ ## PROVIDER), WrapperInfo);\n-  NODE_ASYNC_PROVIDER_TYPES(V)\n-#undef V\n-}\n-\n-\n AsyncWrap::AsyncWrap(Environment* env,\n                      Local<Object> object,\n                      ProviderType provider,\n@@ -814,9 +721,12 @@ void EmitAsyncDestroy(Isolate* isolate, async_context asyncContext) {\n       Environment::GetCurrent(isolate), asyncContext.async_id);\n }\n \n+std::string AsyncWrap::MemoryInfoName() const {\n+  return provider_names[provider_type()];\n+}\n+\n std::string AsyncWrap::diagnostic_name() const {\n-  return std::string(provider_names[provider_type()]) +\n-      \" (\" + std::to_string(env()->thread_id()) + \":\" +\n+  return MemoryInfoName() + \" (\" + std::to_string(env()->thread_id()) + \":\" +\n       std::to_string(static_cast<int64_t>(async_id_)) + \")\";\n }\n "
        },
        {
            "sha": "f748dc801dab772bd8331ec8e72ac24126c99d0c",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -174,6 +174,7 @@ class AsyncWrap : public BaseObject {\n       v8::Local<v8::Value>* argv);\n \n   virtual std::string diagnostic_name() const;\n+  std::string MemoryInfoName() const override;\n \n   static void WeakCallback(const v8::WeakCallbackInfo<DestroyParam> &info);\n \n@@ -204,8 +205,6 @@ class AsyncWrap : public BaseObject {\n   double trigger_async_id_;\n };\n \n-void LoadAsyncWrapperInfo(Environment* env);\n-\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "5a6e765681f24bb6447bc04bb35163c5e23b981c",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -144,9 +144,15 @@ Environment::Environment(IsolateData* isolate_data,\n   std::string debug_cats;\n   SafeGetenv(\"NODE_DEBUG_NATIVE\", &debug_cats);\n   set_debug_categories(debug_cats, true);\n+\n+  isolate()->GetHeapProfiler()->AddBuildEmbedderGraphCallback(\n+      BuildEmbedderGraph, this);\n }\n \n Environment::~Environment() {\n+  isolate()->GetHeapProfiler()->RemoveBuildEmbedderGraphCallback(\n+      BuildEmbedderGraph, this);\n+\n   // Make sure there are no re-used libuv wrapper objects.\n   // CleanupHandles() should have removed all of them.\n   CHECK(file_handle_read_wrap_freelist_.empty());\n@@ -217,7 +223,6 @@ void Environment::Start(int argc,\n   set_process_object(process_object);\n \n   SetupProcessObject(this, argc, argv, exec_argc, exec_argv);\n-  LoadAsyncWrapperInfo(this);\n \n   static uv_once_t init_once = UV_ONCE_INIT;\n   uv_once(&init_once, InitThreadLocalOnce);\n@@ -734,6 +739,16 @@ void Environment::stop_sub_worker_contexts() {\n   }\n }\n \n+void Environment::BuildEmbedderGraph(v8::Isolate* isolate,\n+                                     v8::EmbedderGraph* graph,\n+                                     void* data) {\n+  MemoryTracker tracker(isolate, graph);\n+  static_cast<Environment*>(data)->ForEachBaseObject([&](BaseObject* obj) {\n+    tracker.Track(obj);\n+  });\n+}\n+\n+\n // Not really any better place than env.cc at this moment.\n void BaseObject::DeleteMe(void* data) {\n   BaseObject* self = static_cast<BaseObject*>(data);"
        },
        {
            "sha": "120048fe009b036e253291fe6dd47be113e9a746",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -861,6 +861,10 @@ class Environment {\n   inline void RemoveCleanupHook(void (*fn)(void*), void* arg);\n   void RunCleanup();\n \n+  static void BuildEmbedderGraph(v8::Isolate* isolate,\n+                                 v8::EmbedderGraph* graph,\n+                                 void* data);\n+\n  private:\n   inline void CreateImmediate(native_immediate_callback cb,\n                               void* data,"
        },
        {
            "sha": "568a4364f9c64d47816e5032a21fa199ffed46dc",
            "filename": "src/memory_tracker-inl.h",
            "status": "modified",
            "additions": 98,
            "deletions": 7,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fmemory_tracker-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fmemory_tracker-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmemory_tracker-inl.h?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -7,23 +7,68 @@\n \n namespace node {\n \n+class MemoryRetainerNode : public v8::EmbedderGraph::Node {\n+ public:\n+  explicit inline MemoryRetainerNode(MemoryTracker* tracker,\n+                                     const MemoryRetainer* retainer,\n+                                     const char* name)\n+     : retainer_(retainer) {\n+    if (retainer_ != nullptr) {\n+      v8::HandleScope handle_scope(tracker->isolate());\n+      v8::Local<v8::Object> obj = retainer_->WrappedObject();\n+      if (!obj.IsEmpty())\n+        wrapper_node_ = tracker->graph()->V8Node(obj);\n+\n+      name_ = retainer_->MemoryInfoName();\n+    }\n+    if (name_.empty() && name != nullptr) {\n+      name_ = name;\n+    }\n+  }\n+\n+  const char* Name() override { return name_.c_str(); }\n+  const char* NamePrefix() override { return \"Node /\"; }\n+  size_t SizeInBytes() override { return size_; }\n+  // TODO(addaleax): Merging this with the \"official\" WrapperNode() method\n+  // seems to lose accuracy, e.g. SizeInBytes() is disregarded.\n+  // Figure out whether to do anything about that.\n+  Node* JSWrapperNode() { return wrapper_node_; }\n+\n+  bool IsRootNode() override {\n+    return retainer_ != nullptr && retainer_->IsRootNode();\n+  }\n+\n+ private:\n+  friend class MemoryTracker;\n+\n+  Node* wrapper_node_ = nullptr;\n+  const MemoryRetainer* retainer_;\n+  std::string name_;\n+  size_t size_ = 0;\n+};\n+\n template <typename T>\n void MemoryTracker::TrackThis(const T* obj) {\n-  accumulated_size_ += sizeof(T);\n+  CurrentNode()->size_ = sizeof(T);\n }\n \n void MemoryTracker::TrackFieldWithSize(const char* name, size_t size) {\n-  accumulated_size_ += size;\n+  if (size > 0)\n+    AddNode(name)->size_ = size;\n }\n \n void MemoryTracker::TrackField(const char* name, const MemoryRetainer& value) {\n   TrackField(name, &value);\n }\n \n void MemoryTracker::TrackField(const char* name, const MemoryRetainer* value) {\n-  if (track_only_self_ || value == nullptr || seen_.count(value) > 0) return;\n-  seen_.insert(value);\n-  Track(value);\n+  if (track_only_self_ || value == nullptr) return;\n+  auto it = seen_.find(value);\n+  if (it != seen_.end()) {\n+    graph_->AddEdge(CurrentNode(), it->second);\n+  } else {\n+    Track(value, name);\n+  }\n }\n \n template <typename T>\n@@ -36,8 +81,10 @@ template <typename T, typename Iterator>\n void MemoryTracker::TrackField(const char* name, const T& value) {\n   if (value.begin() == value.end()) return;\n   size_t index = 0;\n+  PushNode(name);\n   for (Iterator it = value.begin(); it != value.end(); ++it)\n     TrackField(std::to_string(index++).c_str(), *it);\n+  PopNode();\n }\n \n template <typename T>\n@@ -56,13 +103,15 @@ void MemoryTracker::TrackField(const char* name, const std::queue<T>& value) {\n template <typename T, typename test_for_number, typename dummy>\n void MemoryTracker::TrackField(const char* name, const T& value) {\n   // For numbers, creating new nodes is not worth the overhead.\n-  TrackFieldWithSize(name, sizeof(T));\n+  CurrentNode()->size_ += sizeof(T);\n }\n \n template <typename T, typename U>\n void MemoryTracker::TrackField(const char* name, const std::pair<T, U>& value) {\n+  PushNode(name);\n   TrackField(\"first\", value.first);\n   TrackField(\"second\", value.second);\n+  PopNode();\n }\n \n template <typename T>\n@@ -74,10 +123,13 @@ void MemoryTracker::TrackField(const char* name,\n template <typename T, typename Traits>\n void MemoryTracker::TrackField(const char* name,\n                                const v8::Persistent<T, Traits>& value) {\n+  TrackField(name, value.Get(isolate_));\n }\n \n template <typename T>\n void MemoryTracker::TrackField(const char* name, const v8::Local<T>& value) {\n+  if (!value.IsEmpty())\n+    graph_->AddEdge(CurrentNode(), graph_->V8Node(value));\n }\n \n template <typename T>\n@@ -96,8 +148,47 @@ void MemoryTracker::TrackField(const char* name,\n   TrackField(name, value.GetJSArray());\n }\n \n-void MemoryTracker::Track(const MemoryRetainer* value) {\n+void MemoryTracker::Track(const MemoryRetainer* value, const char* name) {\n+  v8::HandleScope handle_scope(isolate_);\n+  MemoryRetainerNode* n = PushNode(name, value);\n   value->MemoryInfo(this);\n+  CHECK_EQ(CurrentNode(), n);\n+  CHECK_NE(n->size_, 0);\n+  PopNode();\n+}\n+\n+MemoryRetainerNode* MemoryTracker::CurrentNode() const {\n+  if (node_stack_.empty()) return nullptr;\n+  return node_stack_.top();\n+}\n+\n+MemoryRetainerNode* MemoryTracker::AddNode(\n+    const char* name, const MemoryRetainer* retainer) {\n+  MemoryRetainerNode* n = new MemoryRetainerNode(this, retainer, name);\n+  graph_->AddNode(std::unique_ptr<v8::EmbedderGraph::Node>(n));\n+  if (retainer != nullptr)\n+    seen_[retainer] = n;\n+\n+  if (CurrentNode() != nullptr)\n+    graph_->AddEdge(CurrentNode(), n);\n+\n+  if (n->JSWrapperNode() != nullptr) {\n+    graph_->AddEdge(n, n->JSWrapperNode());\n+    graph_->AddEdge(n->JSWrapperNode(), n);\n+  }\n+\n+  return n;\n+}\n+\n+MemoryRetainerNode* MemoryTracker::PushNode(\n+    const char* name, const MemoryRetainer* retainer) {\n+  MemoryRetainerNode* n = AddNode(name, retainer);\n+  node_stack_.push(n);\n+  return n;\n+}\n+\n+void MemoryTracker::PopNode() {\n+  node_stack_.pop();\n }\n \n }  // namespace node"
        },
        {
            "sha": "d0f9e0dcad8f1ef86c74023bfc4511de08e38c98",
            "filename": "src/memory_tracker.h",
            "status": "modified",
            "additions": 28,
            "deletions": 7,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fmemory_tracker.h",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Fmemory_tracker.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmemory_tracker.h?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -3,15 +3,19 @@\n \n #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n-#include <unordered_set>\n+#include <unordered_map>\n #include <queue>\n+#include <stack>\n+#include <string>\n #include <limits>\n #include <uv.h>\n-#include <aliased_buffer.h>\n+#include \"aliased_buffer.h\"\n+#include \"v8-profiler.h\"\n \n namespace node {\n \n class MemoryTracker;\n+class MemoryRetainerNode;\n \n namespace crypto {\n class NodeBIO;\n@@ -29,6 +33,8 @@ class MemoryRetainer {\n   }\n \n   virtual bool IsRootNode() const { return false; }\n+\n+  virtual std::string MemoryInfoName() const { return std::string(); }\n };\n \n class MemoryTracker {\n@@ -67,17 +73,32 @@ class MemoryTracker {\n   inline void TrackField(const char* name,\n                          const AliasedBuffer<NativeT, V8T>& value);\n \n-  inline void Track(const MemoryRetainer* value);\n-  inline size_t accumulated_size() const { return accumulated_size_; }\n+  inline void Track(const MemoryRetainer* value, const char* name = nullptr);\n \n   inline void set_track_only_self(bool value) { track_only_self_ = value; }\n+  inline v8::EmbedderGraph* graph() { return graph_; }\n+  inline v8::Isolate* isolate() { return isolate_; }\n \n-  inline MemoryTracker() {}\n+  inline explicit MemoryTracker(v8::Isolate* isolate,\n+                                v8::EmbedderGraph* graph)\n+    : isolate_(isolate), graph_(graph) {}\n \n  private:\n+  typedef std::unordered_map<const MemoryRetainer*, MemoryRetainerNode*>\n+      NodeMap;\n+\n+  inline MemoryRetainerNode* CurrentNode() const;\n+  inline MemoryRetainerNode* AddNode(const char* name,\n+                                     const MemoryRetainer* retainer = nullptr);\n+  inline MemoryRetainerNode* PushNode(const char* name,\n+                                      const MemoryRetainer* retainer = nullptr);\n+  inline void PopNode();\n+\n   bool track_only_self_ = false;\n-  size_t accumulated_size_ = 0;\n-  std::unordered_set<const MemoryRetainer*> seen_;\n+  v8::Isolate* isolate_;\n+  v8::EmbedderGraph* graph_;\n+  std::stack<MemoryRetainerNode*> node_stack_;\n+  NodeMap seen_;\n };\n \n }  // namespace node"
        },
        {
            "sha": "3efa6adb4edb0e254c6cb1c7f0d19911646c3d30",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -758,6 +758,8 @@ void TLSWrap::DestroySSL(const FunctionCallbackInfo<Value>& args) {\n \n   // Destroy the SSL structure and friends\n   wrap->SSLWrap<TLSWrap>::DestroySSL();\n+  wrap->enc_in_ = nullptr;\n+  wrap->enc_out_ = nullptr;\n \n   if (wrap->stream_ != nullptr)\n     wrap->stream_->RemoveStreamListener(wrap);\n@@ -868,8 +870,10 @@ void TLSWrap::MemoryInfo(MemoryTracker* tracker) const {\n   tracker->TrackThis(this);\n   tracker->TrackField(\"error\", error_);\n   tracker->TrackField(\"pending_cleartext_input\", pending_cleartext_input_);\n-  tracker->TrackField(\"enc_in\", crypto::NodeBIO::FromBIO(enc_in_));\n-  tracker->TrackField(\"enc_out\", crypto::NodeBIO::FromBIO(enc_out_));\n+  if (enc_in_ != nullptr)\n+    tracker->TrackField(\"enc_in\", crypto::NodeBIO::FromBIO(enc_in_));\n+  if (enc_out_ != nullptr)\n+    tracker->TrackField(\"enc_out\", crypto::NodeBIO::FromBIO(enc_out_));\n }\n \n "
        },
        {
            "sha": "5f4fd3f70733059f29bda96e2894725b7b092eea",
            "filename": "src/tls_wrap.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Ftls_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/266a7e62585b975f2ea2d25473b21395f5ca5a3f/src%2Ftls_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.h?ref=266a7e62585b975f2ea2d25473b21395f5ca5a3f",
            "patch": "@@ -143,8 +143,8 @@ class TLSWrap : public AsyncWrap,\n   static int SelectSNIContextCallback(SSL* s, int* ad, void* arg);\n \n   crypto::SecureContext* sc_;\n-  BIO* enc_in_;\n-  BIO* enc_out_;\n+  BIO* enc_in_ = nullptr;\n+  BIO* enc_out_ = nullptr;\n   std::vector<uv_buf_t> pending_cleartext_input_;\n   size_t write_size_;\n   WriteWrap* current_write_ = nullptr;"
        }
    ],
    "stats": {
        "total": 276,
        "additions": 160,
        "deletions": 116
    }
}