{
    "author": "Trott",
    "message": "doc: remove example labels from buffer.md\n\nRemove instances of `Example:` that introduce code that is\nself-evidently example code. Move descriptive text about examples into\ncomments in the code. Wrap adjacent text to 80 characters.\n\nPR-URL: https://github.com/nodejs/node/pull/19582\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>",
    "sha": "acacf85fecae4a2b72e7cce2dff3a1ac21d40f97",
    "files": [
        {
            "sha": "ae72b49a87110d5e15332295ef3d267c02c0d910",
            "filename": "doc/api/buffer.md",
            "status": "modified",
            "additions": 22,
            "deletions": 73,
            "changes": 95,
            "blob_url": "https://github.com/nodejs/node/blob/acacf85fecae4a2b72e7cce2dff3a1ac21d40f97/doc%2Fapi%2Fbuffer.md",
            "raw_url": "https://github.com/nodejs/node/raw/acacf85fecae4a2b72e7cce2dff3a1ac21d40f97/doc%2Fapi%2Fbuffer.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fbuffer.md?ref=acacf85fecae4a2b72e7cce2dff3a1ac21d40f97",
            "patch": "@@ -120,8 +120,6 @@ impact* on performance. Use of the `--zero-fill-buffers` option is recommended\n only when necessary to enforce that newly allocated `Buffer` instances cannot\n contain potentially sensitive data.\n \n-Example:\n-\n ```txt\n $ node --zero-fill-buffers\n > Buffer.allocUnsafe(5);\n@@ -157,8 +155,6 @@ such as UTF-8, UCS2, Base64, or even Hex-encoded data. It is possible to\n convert back and forth between `Buffer` instances and ordinary JavaScript strings\n by using an explicit character encoding.\n \n-Example:\n-\n ```js\n const buf = Buffer.from('hello world', 'ascii');\n \n@@ -229,8 +225,6 @@ elements, and not as a byte array of the target type. That is,\n It is possible to create a new `Buffer` that shares the same allocated memory as\n a [`TypedArray`] instance by using the TypeArray object's `.buffer` property.\n \n-Example:\n-\n ```js\n const arr = new Uint16Array(2);\n \n@@ -259,8 +253,6 @@ Note that when creating a `Buffer` using a [`TypedArray`]'s `.buffer`, it is\n possible to use only a portion of the underlying [`ArrayBuffer`] by passing in\n `byteOffset` and `length` parameters.\n \n-Example:\n-\n ```js\n const arr = new Uint16Array(20);\n const buf = Buffer.from(arr.buffer, 0, 16);\n@@ -289,8 +281,6 @@ function:\n `Buffer` instances can be iterated over using the [`ECMAScript 2015`] (ES6) `for..of`\n syntax.\n \n-Example:\n-\n ```js\n const buf = Buffer.from([1, 2, 3]);\n \n@@ -329,8 +319,6 @@ changes:\n \n Allocates a new `Buffer` using an `array` of octets.\n \n-Example:\n-\n ```js\n // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'\n const buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n@@ -370,8 +358,6 @@ share the same allocated memory as the [`TypedArray`].\n The optional `byteOffset` and `length` arguments specify a memory range within\n the `arrayBuffer` that will be shared by the `Buffer`.\n \n-Example:\n-\n ```js\n const arr = new Uint16Array(2);\n \n@@ -409,8 +395,6 @@ changes:\n \n Copies the passed `buffer` data onto a new `Buffer` instance.\n \n-Example:\n-\n ```js\n const buf1 = new Buffer('buffer');\n const buf2 = new Buffer(buf1);\n@@ -453,8 +437,6 @@ created in this way is *not initialized*. The contents of a newly created\n [`Buffer.alloc(size)`][`Buffer.alloc()`] instead to initialize a `Buffer`\n to zeroes.\n \n-Example:\n-\n ```js\n const buf = new Buffer(10);\n \n@@ -522,8 +504,6 @@ changes:\n Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the\n `Buffer` will be *zero-filled*.\n \n-Example:\n-\n ```js\n const buf = Buffer.alloc(5);\n \n@@ -538,8 +518,6 @@ thrown. A zero-length `Buffer` will be created if `size` is 0.\n If `fill` is specified, the allocated `Buffer` will be initialized by calling\n [`buf.fill(fill)`][`buf.fill()`].\n \n-Example:\n-\n ```js\n const buf = Buffer.alloc(5, 'a');\n \n@@ -550,8 +528,6 @@ console.log(buf);\n If both `fill` and `encoding` are specified, the allocated `Buffer` will be\n initialized by calling [`buf.fill(fill, encoding)`][`buf.fill()`].\n \n-Example:\n-\n ```js\n const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\n \n@@ -585,8 +561,6 @@ initialized*. The contents of the newly created `Buffer` are unknown and\n *may contain sensitive data*. Use [`Buffer.alloc()`] instead to initialize\n `Buffer` instances to zeroes.\n \n-Example:\n-\n ```js\n const buf = Buffer.allocUnsafe(10);\n \n@@ -643,8 +617,6 @@ memory from a pool for an indeterminate amount of time, it may be appropriate\n to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` then\n copy out the relevant bits.\n \n-Example:\n-\n ```js\n // Need to keep around a few small chunks of memory\n const store = [];\n@@ -694,8 +666,6 @@ For `'base64'` and `'hex'`, this function assumes valid input. For strings that\n contain non-Base64/Hex-encoded data (e.g. whitespace), the return value might be\n greater than the length of a `Buffer` created from the string.\n \n-Example:\n-\n ```js\n const str = '\\u00bd + \\u00bc = \\u00be';\n \n@@ -724,8 +694,6 @@ Compares `buf1` to `buf2` typically for the purpose of sorting arrays of\n `Buffer` instances. This is equivalent to calling\n [`buf1.compare(buf2)`][`buf.compare()`].\n \n-Example:\n-\n ```js\n const buf1 = Buffer.from('1234');\n const buf2 = Buffer.from('0123');\n@@ -765,9 +733,9 @@ If `totalLength` is provided, it is coerced to an unsigned integer. If the\n combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is\n truncated to `totalLength`.\n \n-Example: Create a single `Buffer` from a list of three `Buffer` instances\n-\n ```js\n+// Create a single `Buffer` from a list of three `Buffer` instances.\n+\n const buf1 = Buffer.alloc(10);\n const buf2 = Buffer.alloc(14);\n const buf3 = Buffer.alloc(18);\n@@ -793,8 +761,6 @@ added: v5.10.0\n \n Allocates a new `Buffer` using an `array` of octets.\n \n-Example:\n-\n ```js\n // Creates a new Buffer containing UTF-8 bytes of the string 'buffer'\n const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n@@ -818,8 +784,6 @@ memory. For example, when passed a reference to the `.buffer` property of a\n [`TypedArray`] instance, the newly created `Buffer` will share the same\n allocated memory as the [`TypedArray`].\n \n-Example:\n-\n ```js\n const arr = new Uint16Array(2);\n \n@@ -842,8 +806,6 @@ console.log(buf);\n The optional `byteOffset` and `length` arguments specify a memory range within\n the `arrayBuffer` that will be shared by the `Buffer`.\n \n-Example:\n-\n ```js\n const ab = new ArrayBuffer(10);\n const buf = Buffer.from(ab, 0, 2);\n@@ -864,8 +826,6 @@ added: v5.10.0\n \n Copies the passed `buffer` data onto a new `Buffer` instance.\n \n-Example:\n-\n ```js\n const buf1 = Buffer.from('buffer');\n const buf2 = Buffer.from(buf1);\n@@ -984,9 +944,9 @@ This operator is inherited from `Uint8Array`, so its behavior on out-of-bounds\n access is the same as `UInt8Array` - that is, getting returns `undefined` and\n setting does nothing.\n \n-Example: Copy an ASCII string into a `Buffer`, one byte at a time\n-\n ```js\n+// Copy an ASCII string into a `Buffer` one byte at a time.\n+\n const str = 'Node.js';\n const buf = Buffer.allocUnsafe(str.length);\n \n@@ -1098,10 +1058,8 @@ added: v0.1.90\n Copies data from a region of `buf` to a region in `target` even if the `target`\n memory region overlaps with `buf`.\n \n-Example: Create two `Buffer` instances, `buf1` and `buf2`, and copy `buf1` from\n-byte 16 through byte 19 into `buf2`, starting at the 8th byte in `buf2`\n-\n ```js\n+// Create two `Buffer` instances.\n const buf1 = Buffer.allocUnsafe(26);\n const buf2 = Buffer.allocUnsafe(26).fill('!');\n \n@@ -1110,16 +1068,17 @@ for (let i = 0; i < 26; i++) {\n   buf1[i] = i + 97;\n }\n \n+// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`\n buf1.copy(buf2, 8, 16, 20);\n \n console.log(buf2.toString('ascii', 0, 25));\n // Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n ```\n \n-Example: Create a single `Buffer` and copy data from one region to an\n-overlapping region within the same `Buffer`\n-\n ```js\n+// Create a `Buffer` and copy data from one region to an overlapping region\n+// within the same `Buffer`.\n+\n const buf = Buffer.allocUnsafe(26);\n \n for (let i = 0; i < 26; i++) {\n@@ -1143,9 +1102,9 @@ added: v1.1.0\n Creates and returns an [iterator] of `[index, byte]` pairs from the contents of\n `buf`.\n \n-Example: Log the entire contents of a `Buffer`\n-\n ```js\n+// Log the entire contents of a `Buffer`.\n+\n const buf = Buffer.from('buffer');\n \n for (const pair of buf.entries()) {\n@@ -1217,9 +1176,9 @@ Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\n the entire `buf` will be filled. This is meant to be a small simplification to\n allow the creation and filling of a `Buffer` to be done on a single line.\n \n-Example: Fill a `Buffer` with the ASCII character `'h'`\n-\n ```js\n+// Fill a `Buffer` with the ASCII character 'h'.\n+\n const b = Buffer.allocUnsafe(50).fill('h');\n \n console.log(b.toString());\n@@ -1231,9 +1190,9 @@ console.log(b.toString());\n If the final write of a `fill()` operation falls on a multi-byte character,\n then only the first bytes of that character that fit into `buf` are written.\n \n-Example: Fill a `Buffer` with a two-byte character\n-\n ```js\n+// Fill a `Buffer` with a two-byte character.\n+\n console.log(Buffer.allocUnsafe(3).fill('\\u0222'));\n // Prints: <Buffer c8 a2 c8>\n ```\n@@ -1374,8 +1333,6 @@ added: v1.1.0\n \n Creates and returns an [iterator] of `buf` keys (indices).\n \n-Example:\n-\n ```js\n const buf = Buffer.from('buffer');\n \n@@ -1476,9 +1433,9 @@ added: v0.1.90\n Returns the amount of memory allocated for `buf` in bytes. Note that this\n does not necessarily reflect the amount of \"usable\" data within `buf`.\n \n-Example: Create a `Buffer` and write a shorter ASCII string to it\n-\n ```js\n+// Create a `Buffer` and write a shorter ASCII string to it.\n+\n const buf = Buffer.alloc(1234);\n \n console.log(buf.length);\n@@ -1850,10 +1807,10 @@ that of `end` equal to [`buf.length`].\n Modifying the new `Buffer` slice will modify the memory in the original `Buffer`\n because the allocated memory of the two objects overlap.\n \n-Example: Create a `Buffer` with the ASCII alphabet, take a slice, and then modify\n-one byte from the original `Buffer`\n-\n ```js\n+// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n+// from the original `Buffer`.\n+\n const buf1 = Buffer.allocUnsafe(26);\n \n for (let i = 0; i < 26; i++) {\n@@ -1985,8 +1942,6 @@ added: v0.9.2\n Returns a JSON representation of `buf`. [`JSON.stringify()`] implicitly calls\n this function when stringifying a `Buffer` instance.\n \n-Example:\n-\n ```js\n const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\n const json = JSON.stringify(buf);\n@@ -2096,8 +2051,6 @@ The `length` parameter is the number of bytes to write. If `buf` did not contain\n enough space to fit the entire string, only a partial amount of `string` will\n be written. However, partially encoded characters will not be written.\n \n-Example:\n-\n ```js\n const buf = Buffer.allocUnsafe(256);\n \n@@ -2517,8 +2470,6 @@ In the case where a developer may need to retain a small chunk of memory from a\n pool for an indeterminate amount of time, it may be appropriate to create an\n un-pooled `Buffer` instance using `SlowBuffer` then copy out the relevant bits.\n \n-Example:\n-\n ```js\n // Need to keep around a few small chunks of memory\n const store = [];\n@@ -2553,10 +2504,8 @@ Allocates a new `Buffer` of `size` bytes.  If the `size` is larger than\n thrown. A zero-length `Buffer` will be created if `size` is 0.\n \n The underlying memory for `SlowBuffer` instances is *not initialized*. The\n-contents of a newly created `SlowBuffer` are unknown and may contain\n-sensitive data. Use [`buf.fill(0)`][`buf.fill()`] to initialize a `SlowBuffer` to zeroes.\n-\n-Example:\n+contents of a newly created `SlowBuffer` are unknown and may contain sensitive\n+data. Use [`buf.fill(0)`][`buf.fill()`] to initialize a `SlowBuffer` to zeroes.\n \n ```js\n const { SlowBuffer } = require('buffer');"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 22,
        "deletions": 73
    }
}