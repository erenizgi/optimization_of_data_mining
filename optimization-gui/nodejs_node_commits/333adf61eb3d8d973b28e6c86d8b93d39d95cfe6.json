{
    "author": "BridgeAR",
    "message": "crypto: fix error handling\n\nThis fixes multiple cases where the wrong error was returned in\ncase of e.g. a overflow / wrong type.\n\nPR-URL: https://github.com/nodejs/node/pull/19445\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "333adf61eb3d8d973b28e6c86d8b93d39d95cfe6",
    "files": [
        {
            "sha": "9f444cdcb7aac87469ac73e4420b733c164b7f23",
            "filename": "lib/internal/crypto/random.js",
            "status": "modified",
            "additions": 29,
            "deletions": 26,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/333adf61eb3d8d973b28e6c86d8b93d39d95cfe6/lib%2Finternal%2Fcrypto%2Frandom.js",
            "raw_url": "https://github.com/nodejs/node/raw/333adf61eb3d8d973b28e6c86d8b93d39d95cfe6/lib%2Finternal%2Fcrypto%2Frandom.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Frandom.js?ref=333adf61eb3d8d973b28e6c86d8b93d39d95cfe6",
            "patch": "@@ -13,37 +13,44 @@ const {\n \n const { kMaxLength } = require('buffer');\n const kMaxUint32 = Math.pow(2, 32) - 1;\n+const kMaxPossibleLength = Math.min(kMaxLength, kMaxUint32);\n \n-function assertOffset(offset, length) {\n-  if (typeof offset !== 'number' || Number.isNaN(offset)) {\n-    throw new ERR_INVALID_ARG_TYPE('offset', 'number');\n+function assertOffset(offset, elementSize, length) {\n+  if (typeof offset !== 'number') {\n+    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n   }\n \n-  if (offset > kMaxUint32 || offset < 0) {\n-    throw new ERR_INVALID_ARG_TYPE('offset', 'uint32');\n-  }\n+  offset *= elementSize;\n \n-  if (offset > kMaxLength || offset > length) {\n-    throw new ERR_OUT_OF_RANGE('offset');\n+  const maxLength = Math.min(length, kMaxPossibleLength);\n+  if (Number.isNaN(offset) || offset > maxLength || offset < 0) {\n+    throw new ERR_OUT_OF_RANGE('offset', `>= 0 && <= ${maxLength}`, offset);\n   }\n+\n+  return offset;\n }\n \n-function assertSize(size, offset = 0, length = Infinity) {\n-  if (typeof size !== 'number' || Number.isNaN(size)) {\n-    throw new ERR_INVALID_ARG_TYPE('size', 'number');\n+function assertSize(size, elementSize, offset, length) {\n+  if (typeof size !== 'number') {\n+    throw new ERR_INVALID_ARG_TYPE('size', 'number', size);\n   }\n \n-  if (size > kMaxUint32 || size < 0) {\n-    throw new ERR_INVALID_ARG_TYPE('size', 'uint32');\n+  size *= elementSize;\n+\n+  if (Number.isNaN(size) || size > kMaxPossibleLength || size < 0) {\n+    throw new ERR_OUT_OF_RANGE('size',\n+                               `>= 0 && <= ${kMaxPossibleLength}`, size);\n   }\n \n-  if (size + offset > length || size > kMaxLength) {\n-    throw new ERR_OUT_OF_RANGE('size');\n+  if (size + offset > length) {\n+    throw new ERR_OUT_OF_RANGE('size + offset', `<= ${length}`, size + offset);\n   }\n+\n+  return size;\n }\n \n function randomBytes(size, cb) {\n-  assertSize(size);\n+  assertSize(size, 1, 0, Infinity);\n   if (cb !== undefined && typeof cb !== 'function')\n     throw new ERR_INVALID_CALLBACK();\n   return _randomBytes(size, cb);\n@@ -56,17 +63,14 @@ function randomFillSync(buf, offset = 0, size) {\n \n   const elementSize = buf.BYTES_PER_ELEMENT || 1;\n \n-  offset *= elementSize;\n-  assertOffset(offset, buf.byteLength);\n+  offset = assertOffset(offset, elementSize, buf.byteLength);\n \n   if (size === undefined) {\n     size = buf.byteLength - offset;\n   } else {\n-    size *= elementSize;\n+    size = assertSize(size, elementSize, offset, buf.byteLength);\n   }\n \n-  assertSize(size, offset, buf.byteLength);\n-\n   return _randomFill(buf, offset, size);\n }\n \n@@ -83,20 +87,19 @@ function randomFill(buf, offset, size, cb) {\n     size = buf.bytesLength;\n   } else if (typeof size === 'function') {\n     cb = size;\n-    offset *= elementSize;\n     size = buf.byteLength - offset;\n   } else if (typeof cb !== 'function') {\n     throw new ERR_INVALID_CALLBACK();\n   }\n+\n+  offset = assertOffset(offset, elementSize, buf.byteLength);\n+\n   if (size === undefined) {\n     size = buf.byteLength - offset;\n   } else {\n-    size *= elementSize;\n+    size = assertSize(size, elementSize, offset, buf.byteLength);\n   }\n \n-  assertOffset(offset, buf.byteLength);\n-  assertSize(size, offset, buf.byteLength);\n-\n   return _randomFill(buf, offset, size, cb);\n }\n "
        },
        {
            "sha": "77801f6d53eef2f8d7618aa90b6363835abc314a",
            "filename": "test/parallel/test-crypto-random.js",
            "status": "modified",
            "additions": 82,
            "deletions": 243,
            "changes": 325,
            "blob_url": "https://github.com/nodejs/node/blob/333adf61eb3d8d973b28e6c86d8b93d39d95cfe6/test%2Fparallel%2Ftest-crypto-random.js",
            "raw_url": "https://github.com/nodejs/node/raw/333adf61eb3d8d973b28e6c86d8b93d39d95cfe6/test%2Fparallel%2Ftest-crypto-random.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-random.js?ref=333adf61eb3d8d973b28e6c86d8b93d39d95cfe6",
            "patch": "@@ -27,42 +27,49 @@ if (!common.hasCrypto)\n \n const assert = require('assert');\n const crypto = require('crypto');\n+const { kMaxLength } = require('buffer');\n+\n+const kMaxUint32 = Math.pow(2, 32) - 1;\n+const kMaxPossibleLength = Math.min(kMaxLength, kMaxUint32);\n \n crypto.DEFAULT_ENCODING = 'buffer';\n \n // bump, we register a lot of exit listeners\n process.setMaxListeners(256);\n \n-[crypto.randomBytes, crypto.pseudoRandomBytes].forEach(function(f) {\n-  [-1, undefined, null, false, true, {}, []].forEach(function(value) {\n-\n-    common.expectsError(\n-      () => f(value),\n-      {\n+{\n+  [crypto.randomBytes, crypto.pseudoRandomBytes].forEach((f) => {\n+    [undefined, null, false, true, {}, []].forEach((value) => {\n+      const errObj = {\n         code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: /^The \"size\" argument must be of type (number|uint32)$/\n-      }\n-    );\n+        name: 'TypeError [ERR_INVALID_ARG_TYPE]',\n+        message: 'The \"size\" argument must be of type number. ' +\n+                `Received type ${typeof value}`\n+      };\n+      assert.throws(() => f(value), errObj);\n+      assert.throws(() => f(value, common.mustNotCall()), errObj);\n+    });\n \n-    common.expectsError(\n-      () => f(value, common.mustNotCall()),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: /^The \"size\" argument must be of type (number|uint32)$/\n-      }\n-    );\n-  });\n+    [-1, NaN, 2 ** 32].forEach((value) => {\n+      const errObj = {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"size\" is out of range. It must be >= 0 && <= ' +\n+                 `${kMaxPossibleLength}. Received ${value}`\n+      };\n+      assert.throws(() => f(value), errObj);\n+      assert.throws(() => f(value, common.mustNotCall()), errObj);\n+    });\n \n-  [0, 1, 2, 4, 16, 256, 1024, 101.2].forEach(function(len) {\n-    f(len, common.mustCall(function(ex, buf) {\n-      assert.strictEqual(ex, null);\n-      assert.strictEqual(buf.length, Math.floor(len));\n-      assert.ok(Buffer.isBuffer(buf));\n-    }));\n+    [0, 1, 2, 4, 16, 256, 1024, 101.2].forEach((len) => {\n+      f(len, common.mustCall((ex, buf) => {\n+        assert.strictEqual(ex, null);\n+        assert.strictEqual(buf.length, Math.floor(len));\n+        assert.ok(Buffer.isBuffer(buf));\n+      }));\n+    });\n   });\n-});\n+}\n \n {\n   const buf = Buffer.alloc(10);\n@@ -181,252 +188,84 @@ process.setMaxListeners(256);\n }\n \n {\n-  const bufs = [\n+  [\n     Buffer.alloc(10),\n     new Uint8Array(new Array(10).fill(0))\n-  ];\n-\n-  const max = require('buffer').kMaxLength + 1;\n-\n-  for (const buf of bufs) {\n+  ].forEach((buf) => {\n     const len = Buffer.byteLength(buf);\n     assert.strictEqual(len, 10, `Expected byteLength of 10, got ${len}`);\n \n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, 'test'),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"offset\" argument must be of type number'\n-      }\n-    );\n+    const typeErrObj = {\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      name: 'TypeError [ERR_INVALID_ARG_TYPE]',\n+      message: 'The \"offset\" argument must be of type number. ' +\n+               'Received type string'\n+    };\n \n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, NaN),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"offset\" argument must be of type number'\n-      }\n-    );\n+    assert.throws(() => crypto.randomFillSync(buf, 'test'), typeErrObj);\n \n-    common.expectsError(\n+    assert.throws(\n       () => crypto.randomFill(buf, 'test', common.mustNotCall()),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"offset\" argument must be of type number'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFill(buf, NaN, common.mustNotCall()),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"offset\" argument must be of type number'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, 11),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"offset\" is out of range.'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, max),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"offset\" is out of range.'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFill(buf, 11, common.mustNotCall()),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"offset\" is out of range.'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFill(buf, max, common.mustNotCall()),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"offset\" is out of range.'\n-      }\n-    );\n+      typeErrObj);\n \n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, 0, 'test'),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"size\" argument must be of type number'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, 0, NaN),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"size\" argument must be of type number'\n-      }\n-    );\n+    typeErrObj.message = 'The \"size\" argument must be of type number. ' +\n+                     'Received type string';\n+    assert.throws(() => crypto.randomFillSync(buf, 0, 'test'), typeErrObj);\n \n-    common.expectsError(\n+    assert.throws(\n       () => crypto.randomFill(buf, 0, 'test', common.mustNotCall()),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"size\" argument must be of type number'\n-      }\n+      typeErrObj\n     );\n \n-    common.expectsError(\n-      () => crypto.randomFill(buf, 0, NaN, common.mustNotCall()),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"size\" argument must be of type number'\n-      }\n-    );\n+    [NaN, kMaxPossibleLength + 1, -10, (-1 >>> 0) + 1].forEach((offsetSize) => {\n+      const errObj = {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"offset\" is out of range. ' +\n+                 `It must be >= 0 && <= 10. Received ${offsetSize}`\n+      };\n \n-    {\n-      const size = (-1 >>> 0) + 1;\n-\n-      common.expectsError(\n-        () => crypto.randomFillSync(buf, 0, -10),\n-        {\n-          code: 'ERR_INVALID_ARG_TYPE',\n-          type: TypeError,\n-          message: 'The \"size\" argument must be of type uint32'\n-        }\n-      );\n+      assert.throws(() => crypto.randomFillSync(buf, offsetSize), errObj);\n \n-      common.expectsError(\n-        () => crypto.randomFillSync(buf, 0, size),\n-        {\n-          code: 'ERR_INVALID_ARG_TYPE',\n-          type: TypeError,\n-          message: 'The \"size\" argument must be of type uint32'\n-        }\n-      );\n+      assert.throws(\n+        () => crypto.randomFill(buf, offsetSize, common.mustNotCall()),\n+        errObj);\n \n-      common.expectsError(\n-        () => crypto.randomFill(buf, 0, -10, common.mustNotCall()),\n-        {\n-          code: 'ERR_INVALID_ARG_TYPE',\n-          type: TypeError,\n-          message: 'The \"size\" argument must be of type uint32'\n-        }\n-      );\n+      errObj.message = 'The value of \"size\" is out of range. It must be >= ' +\n+                       `0 && <= ${kMaxPossibleLength}. Received ${offsetSize}`;\n+      assert.throws(() => crypto.randomFillSync(buf, 1, offsetSize), errObj);\n \n-      common.expectsError(\n-        () => crypto.randomFill(buf, 0, size, common.mustNotCall()),\n-        {\n-          code: 'ERR_INVALID_ARG_TYPE',\n-          type: TypeError,\n-          message: 'The \"size\" argument must be of type uint32'\n-        }\n+      assert.throws(\n+        () => crypto.randomFill(buf, 1, offsetSize, common.mustNotCall()),\n+        errObj\n       );\n-    }\n-\n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, -10),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"offset\" argument must be of type uint32'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFill(buf, -10, common.mustNotCall()),\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: TypeError,\n-        message: 'The \"offset\" argument must be of type uint32'\n-      }\n-    );\n+    });\n \n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, 1, 10),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"size\" is out of range.'\n-      }\n-    );\n+    const rangeErrObj = {\n+      code: 'ERR_OUT_OF_RANGE',\n+      name: 'RangeError [ERR_OUT_OF_RANGE]',\n+      message: 'The value of \"size + offset\" is out of range. ' +\n+               'It must be <= 10. Received 11'\n+    };\n+    assert.throws(() => crypto.randomFillSync(buf, 1, 10), rangeErrObj);\n \n-    common.expectsError(\n+    assert.throws(\n       () => crypto.randomFill(buf, 1, 10, common.mustNotCall()),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"size\" is out of range.'\n-      }\n+      rangeErrObj\n     );\n-\n-    common.expectsError(\n-      () => crypto.randomFillSync(buf, 0, 12),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"size\" is out of range.'\n-      }\n-    );\n-\n-    common.expectsError(\n-      () => crypto.randomFill(buf, 0, 12, common.mustNotCall()),\n-      {\n-        code: 'ERR_OUT_OF_RANGE',\n-        type: RangeError,\n-        message: 'The value of \"size\" is out of range.'\n-      }\n-    );\n-\n-    {\n-      // Offset is too big\n-      const offset = (-1 >>> 0) + 1;\n-      common.expectsError(\n-        () => crypto.randomFillSync(buf, offset, 10),\n-        {\n-          code: 'ERR_INVALID_ARG_TYPE',\n-          type: TypeError,\n-          message: 'The \"offset\" argument must be of type uint32'\n-        }\n-      );\n-\n-      common.expectsError(\n-        () => crypto.randomFill(buf, offset, 10, common.mustNotCall()),\n-        {\n-          code: 'ERR_INVALID_ARG_TYPE',\n-          type: TypeError,\n-          message: 'The \"offset\" argument must be of type uint32'\n-        }\n-      );\n-    }\n-  }\n+  });\n }\n \n // https://github.com/nodejs/node-v0.x-archive/issues/5126,\n // \"FATAL ERROR: v8::Object::SetIndexedPropertiesToExternalArrayData() length\n // exceeds max acceptable value\"\n-common.expectsError(\n+assert.throws(\n   () => crypto.randomBytes((-1 >>> 0) + 1),\n   {\n-    code: 'ERR_INVALID_ARG_TYPE',\n-    type: TypeError,\n-    message: 'The \"size\" argument must be of type uint32'\n+    code: 'ERR_OUT_OF_RANGE',\n+    name: 'RangeError [ERR_OUT_OF_RANGE]',\n+    message: 'The value of \"size\" is out of range. ' +\n+             `It must be >= 0 && <= ${kMaxPossibleLength}. Received 4294967296`\n   }\n );\n "
        }
    ],
    "stats": {
        "total": 380,
        "additions": 111,
        "deletions": 269
    }
}