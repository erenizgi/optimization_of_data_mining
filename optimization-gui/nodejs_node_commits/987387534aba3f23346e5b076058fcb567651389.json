{
    "author": "addaleax",
    "message": "src: minor refactor to string_search.h\n\n- Use `std::max` instead of a custom variant\n- Use member method pointers to avoid an extra layer of indirection\n- Stop transferring `Vector` into the `node` namespace\n\nPR-URL: https://github.com/nodejs/node/pull/20546\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "987387534aba3f23346e5b076058fcb567651389",
    "files": [
        {
            "sha": "6a45eb366623d9a77f7dcc6162db04e22a0c6afd",
            "filename": "src/string_search.h",
            "status": "modified",
            "additions": 54,
            "deletions": 91,
            "changes": 145,
            "blob_url": "https://github.com/nodejs/node/blob/987387534aba3f23346e5b076058fcb567651389/src%2Fstring_search.h",
            "raw_url": "https://github.com/nodejs/node/raw/987387534aba3f23346e5b076058fcb567651389/src%2Fstring_search.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_search.h?ref=987387534aba3f23346e5b076058fcb567651389",
            "patch": "@@ -9,18 +9,11 @@\n \n #include \"node_internals.h\"\n #include <string.h>\n+#include <algorithm>\n \n namespace node {\n namespace stringsearch {\n \n-\n-// Returns the maximum of the two parameters.\n-template <typename T>\n-T Max(T a, T b) {\n-  return a < b ? b : a;\n-}\n-\n-\n static const uint32_t kMaxOneByteCharCodeU = 0xff;\n \n template <typename T>\n@@ -98,7 +91,9 @@ class StringSearchBase {\n template <typename Char>\n class StringSearch : private StringSearchBase {\n  public:\n-  explicit StringSearch(Vector<const Char> pattern)\n+  typedef stringsearch::Vector<const Char> Vector;\n+\n+  explicit StringSearch(Vector pattern)\n       : pattern_(pattern), start_(0) {\n     if (pattern.length() >= kBMMaxShift) {\n       start_ = pattern.length() - kBMMaxShift;\n@@ -108,17 +103,17 @@ class StringSearch : private StringSearchBase {\n     CHECK_GT(pattern_length, 0);\n     if (pattern_length < kBMMinPatternLength) {\n       if (pattern_length == 1) {\n-        strategy_ = &SingleCharSearch;\n+        strategy_ = &StringSearch::SingleCharSearch;\n         return;\n       }\n-      strategy_ = &LinearSearch;\n+      strategy_ = &StringSearch::LinearSearch;\n       return;\n     }\n-    strategy_ = &InitialSearch;\n+    strategy_ = &StringSearch::InitialSearch;\n   }\n \n-  size_t Search(Vector<const Char> subject, size_t index) {\n-    return strategy_(this, subject, index);\n+  size_t Search(Vector subject, size_t index) {\n+    return (this->*strategy_)(subject, index);\n   }\n \n   static inline int AlphabetSize() {\n@@ -136,31 +131,12 @@ class StringSearch : private StringSearchBase {\n   }\n \n  private:\n-  typedef size_t (*SearchFunction)(\n-      StringSearch<Char>*,\n-      Vector<const Char>,\n-      size_t);\n-\n-  static size_t SingleCharSearch(StringSearch<Char>* search,\n-                                 Vector<const Char> subject,\n-                                 size_t start_index);\n-\n-  static size_t LinearSearch(StringSearch<Char>* search,\n-                             Vector<const Char> subject,\n-                             size_t start_index);\n-\n-  static size_t InitialSearch(StringSearch<Char>* search,\n-                              Vector<const Char> subject,\n-                              size_t start_index);\n-\n-  static size_t BoyerMooreHorspoolSearch(\n-      StringSearch<Char>* search,\n-      Vector<const Char> subject,\n-      size_t start_index);\n-\n-  static size_t BoyerMooreSearch(StringSearch<Char>* search,\n-                                 Vector<const Char> subject,\n-                                 size_t start_index);\n+  typedef size_t (StringSearch::*SearchFunction)(Vector, size_t);\n+  size_t SingleCharSearch(Vector subject, size_t start_index);\n+  size_t LinearSearch(Vector subject, size_t start_index);\n+  size_t InitialSearch(Vector subject, size_t start_index);\n+  size_t BoyerMooreHorspoolSearch(Vector subject, size_t start_index);\n+  size_t BoyerMooreSearch(Vector subject, size_t start_index);\n \n   void PopulateBoyerMooreHorspoolTable();\n \n@@ -197,7 +173,7 @@ class StringSearch : private StringSearchBase {\n   }\n \n   // The pattern to search for.\n-  Vector<const Char> pattern_;\n+  Vector pattern_;\n   // Pointer to implementation of the search.\n   SearchFunction strategy_;\n   // Cache value of Max(0, pattern_length() - kBMMaxShift)\n@@ -213,8 +189,8 @@ inline T AlignDown(T value, U alignment) {\n \n \n inline uint8_t GetHighestValueByte(uint16_t character) {\n-  return Max(static_cast<uint8_t>(character & 0xFF),\n-             static_cast<uint8_t>(character >> 8));\n+  return std::max(static_cast<uint8_t>(character & 0xFF),\n+                  static_cast<uint8_t>(character >> 8));\n }\n \n \n@@ -319,11 +295,10 @@ inline size_t FindFirstCharacter(Vector<const uint8_t> pattern,\n \n template <typename Char>\n size_t StringSearch<Char>::SingleCharSearch(\n-    StringSearch<Char>* search,\n-    Vector<const Char> subject,\n+    Vector subject,\n     size_t index) {\n-  CHECK_EQ(1, search->pattern_.length());\n-  return FindFirstCharacter(search->pattern_, subject, index);\n+  CHECK_EQ(1, pattern_.length());\n+  return FindFirstCharacter(pattern_, subject, index);\n }\n \n //---------------------------------------------------------------------\n@@ -333,22 +308,19 @@ size_t StringSearch<Char>::SingleCharSearch(\n // Simple linear search for short patterns. Never bails out.\n template <typename Char>\n size_t StringSearch<Char>::LinearSearch(\n-    StringSearch<Char>* search,\n-    Vector<const Char> subject,\n+    Vector subject,\n     size_t index) {\n-  Vector<const Char> pattern = search->pattern_;\n-  CHECK_GT(pattern.length(), 1);\n-  const size_t pattern_length = pattern.length();\n-  const size_t n = subject.length() - pattern_length;\n+  CHECK_GT(pattern_.length(), 1);\n+  const size_t n = subject.length() - pattern_.length();\n   for (size_t i = index; i <= n; i++) {\n-    i = FindFirstCharacter(pattern, subject, i);\n+    i = FindFirstCharacter(pattern_, subject, i);\n     if (i == subject.length())\n       return subject.length();\n     CHECK_LE(i, n);\n \n     bool matches = true;\n-    for (size_t j = 1; j < pattern_length; j++) {\n-      if (pattern[j] != subject[i + j]) {\n+    for (size_t j = 1; j < pattern_.length(); j++) {\n+      if (pattern_[j] != subject[i + j]) {\n         matches = false;\n         break;\n       }\n@@ -366,19 +338,17 @@ size_t StringSearch<Char>::LinearSearch(\n \n template <typename Char>\n size_t StringSearch<Char>::BoyerMooreSearch(\n-    StringSearch<Char>* search,\n-    Vector<const Char> subject,\n+    Vector subject,\n     size_t start_index) {\n-  Vector<const Char> pattern = search->pattern_;\n   const size_t subject_length = subject.length();\n-  const size_t pattern_length = pattern.length();\n+  const size_t pattern_length = pattern_.length();\n   // Only preprocess at most kBMMaxShift last characters of pattern.\n-  size_t start = search->start_;\n+  size_t start = start_;\n \n-  int* bad_char_occurrence = search->bad_char_table();\n-  int* good_suffix_shift = search->good_suffix_shift_table();\n+  int* bad_char_occurrence = bad_char_table();\n+  int* good_suffix_shift = good_suffix_shift_table();\n \n-  Char last_char = pattern[pattern_length - 1];\n+  Char last_char = pattern_[pattern_length - 1];\n   size_t index = start_index;\n   // Continue search from i.\n   while (index <= subject_length - pattern_length) {\n@@ -391,7 +361,7 @@ size_t StringSearch<Char>::BoyerMooreSearch(\n         return subject.length();\n       }\n     }\n-    while (pattern[j] == (c = subject[index + j])) {\n+    while (pattern_[j] == (c = subject[index + j])) {\n       if (j == 0) {\n         return index;\n       }\n@@ -420,7 +390,6 @@ size_t StringSearch<Char>::BoyerMooreSearch(\n template <typename Char>\n void StringSearch<Char>::PopulateBoyerMooreTable() {\n   const size_t pattern_length = pattern_.length();\n-  Vector<const Char> pattern = pattern_;\n   // Only look at the last kBMMaxShift characters of pattern (from start_\n   // to pattern_length).\n   const size_t start = start_;\n@@ -448,8 +417,8 @@ void StringSearch<Char>::PopulateBoyerMooreTable() {\n   {\n     size_t i = pattern_length;\n     while (i > start) {\n-      Char c = pattern[i - 1];\n-      while (suffix <= pattern_length && c != pattern[suffix - 1]) {\n+      Char c = pattern_[i - 1];\n+      while (suffix <= pattern_length && c != pattern_[suffix - 1]) {\n         if (static_cast<size_t>(shift_table[suffix]) == length) {\n           shift_table[suffix] = suffix - i;\n         }\n@@ -458,7 +427,7 @@ void StringSearch<Char>::PopulateBoyerMooreTable() {\n       suffix_table[--i] = --suffix;\n       if (suffix == pattern_length) {\n         // No suffix to extend, so we check against last_char only.\n-        while ((i > start) && (pattern[i - 1] != last_char)) {\n+        while ((i > start) && (pattern_[i - 1] != last_char)) {\n           if (static_cast<size_t>(shift_table[pattern_length]) == length) {\n             shift_table[pattern_length] = pattern_length - i;\n           }\n@@ -489,17 +458,15 @@ void StringSearch<Char>::PopulateBoyerMooreTable() {\n \n template <typename Char>\n size_t StringSearch<Char>::BoyerMooreHorspoolSearch(\n-    StringSearch<Char>* search,\n-    Vector<const Char> subject,\n+    Vector subject,\n     size_t start_index) {\n-  Vector<const Char> pattern = search->pattern_;\n   const size_t subject_length = subject.length();\n-  const size_t pattern_length = pattern.length();\n-  int* char_occurrences = search->bad_char_table();\n+  const size_t pattern_length = pattern_.length();\n+  int* char_occurrences = bad_char_table();\n   int64_t badness = -pattern_length;\n \n   // How bad we are doing without a good-suffix table.\n-  Char last_char = pattern[pattern_length - 1];\n+  Char last_char = pattern_[pattern_length - 1];\n   int last_char_shift =\n       pattern_length - 1 -\n       CharOccurrence(char_occurrences, static_cast<Char>(last_char));\n@@ -519,7 +486,7 @@ size_t StringSearch<Char>::BoyerMooreHorspoolSearch(\n       }\n     }\n     j--;\n-    while (pattern[j] == (subject[index + j])) {\n+    while (pattern_[j] == (subject[index + j])) {\n       if (j == 0) {\n         return index;\n       }\n@@ -532,9 +499,9 @@ size_t StringSearch<Char>::BoyerMooreHorspoolSearch(\n     // compared to reading each character exactly once.\n     badness += (pattern_length - j) - last_char_shift;\n     if (badness > 0) {\n-      search->PopulateBoyerMooreTable();\n-      search->strategy_ = &BoyerMooreSearch;\n-      return BoyerMooreSearch(search, subject, index);\n+      PopulateBoyerMooreTable();\n+      strategy_ = &StringSearch::BoyerMooreSearch;\n+      return BoyerMooreSearch(subject, index);\n     }\n   }\n   return subject.length();\n@@ -575,11 +542,9 @@ void StringSearch<Char>::PopulateBoyerMooreHorspoolTable() {\n // isn't found very early in the subject. Upgrades to BoyerMooreHorspool.\n template <typename Char>\n size_t StringSearch<Char>::InitialSearch(\n-    StringSearch<Char>* search,\n-    Vector<const Char> subject,\n+    Vector subject,\n     size_t index) {\n-  Vector<const Char> pattern = search->pattern_;\n-  const size_t pattern_length = pattern.length();\n+  const size_t pattern_length = pattern_.length();\n   // Badness is a count of how much work we have done.  When we have\n   // done enough work we decide it's probably worth switching to a better\n   // algorithm.\n@@ -590,13 +555,13 @@ size_t StringSearch<Char>::InitialSearch(\n   for (size_t i = index, n = subject.length() - pattern_length; i <= n; i++) {\n     badness++;\n     if (badness <= 0) {\n-      i = FindFirstCharacter(pattern, subject, i);\n+      i = FindFirstCharacter(pattern_, subject, i);\n       if (i == subject.length())\n         return subject.length();\n       CHECK_LE(i, n);\n       size_t j = 1;\n       do {\n-        if (pattern[j] != subject[i + j]) {\n+        if (pattern_[j] != subject[i + j]) {\n           break;\n         }\n         j++;\n@@ -606,9 +571,9 @@ size_t StringSearch<Char>::InitialSearch(\n       }\n       badness += j;\n     } else {\n-      search->PopulateBoyerMooreHorspoolTable();\n-      search->strategy_ = &BoyerMooreHorspoolSearch;\n-      return BoyerMooreHorspoolSearch(search, subject, i);\n+      PopulateBoyerMooreHorspoolTable();\n+      strategy_ = &StringSearch::BoyerMooreHorspoolSearch;\n+      return BoyerMooreHorspoolSearch(subject, i);\n     }\n   }\n   return subject.length();\n@@ -629,7 +594,6 @@ size_t SearchString(Vector<const Char> subject,\n }  // namespace node\n \n namespace node {\n-using node::stringsearch::Vector;\n \n template <typename Char>\n size_t SearchString(const Char* haystack,\n@@ -643,9 +607,8 @@ size_t SearchString(const Char* haystack,\n   // code, create two vectors that are reversed views into the input strings.\n   // For example, v_needle[0] would return the *last* character of the needle.\n   // So we're searching for the first instance of rev(needle) in rev(haystack)\n-  Vector<const Char> v_needle = Vector<const Char>(\n-      needle, needle_length, is_forward);\n-  Vector<const Char> v_haystack = Vector<const Char>(\n+  stringsearch::Vector<const Char> v_needle(needle, needle_length, is_forward);\n+  stringsearch::Vector<const Char> v_haystack(\n       haystack, haystack_length, is_forward);\n   size_t diff = haystack_length - needle_length;\n   size_t relative_start_index;"
        }
    ],
    "stats": {
        "total": 145,
        "additions": 54,
        "deletions": 91
    }
}