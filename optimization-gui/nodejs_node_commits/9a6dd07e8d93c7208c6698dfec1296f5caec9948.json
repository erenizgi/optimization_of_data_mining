{
    "author": "vsemozhetbyt",
    "message": "tools: overhaul tools/doc/json.js\n\nModernize:\n* Replace `var` with `const` / `let`.\n* Wrap `switch` cases with `const`/`let` in blocks.\n* Replace common functions with arrow functions.\n* Replace string concatenation with template literals.\n* Shorthand object literals.\n* Use destructuring and spread.\n\nOptimize:\n* Move RegExp declaration out of loops.\n* Replace `.match()` with `.test()` in boolean context.\n* Replace RegExp with string when string suffices.\n* Make RegExp more strict to reject unrelated cases.\n* Make RegExp do the trimming to eliminate many `.trim()` calls.\n* Cache retrieved object properties.\n* Remove conditions that cannot be false.\n* Remove code that seems obsolete\n  (it means a state that cannot happen or is not typical).\n\nClarify:\n* Sync code examples in comments with the actual source state.\n* Expand some one-letter variable names.\n* Rename confusingly similar variables.\n* Move variable declarations closer to their context.\n* Remove non-actual commented out code.\n* Unify blank lines between top-level blocks.\n\nFix:\n* Fix conditions that cannot be true.\n\nGuard:\n* Throw on unexpected state more often.\n\nPR-URL: https://github.com/nodejs/node/pull/19832\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "9a6dd07e8d93c7208c6698dfec1296f5caec9948",
    "files": [
        {
            "sha": "b1a04c69380ddaf4d7b4198a9290c86b5750383b",
            "filename": "tools/doc/json.js",
            "status": "modified",
            "additions": 184,
            "deletions": 188,
            "changes": 372,
            "blob_url": "https://github.com/nodejs/node/blob/9a6dd07e8d93c7208c6698dfec1296f5caec9948/tools%2Fdoc%2Fjson.js",
            "raw_url": "https://github.com/nodejs/node/raw/9a6dd07e8d93c7208c6698dfec1296f5caec9948/tools%2Fdoc%2Fjson.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fjson.js?ref=9a6dd07e8d93c7208c6698dfec1296f5caec9948",
            "patch": "@@ -31,49 +31,47 @@ const marked = require('marked');\n \n // Customized heading without id attribute.\n const renderer = new marked.Renderer();\n-renderer.heading = function(text, level) {\n-  return `<h${level}>${text}</h${level}>\\n`;\n-};\n-marked.setOptions({\n-  renderer: renderer\n-});\n+renderer.heading = (text, level) => `<h${level}>${text}</h${level}>\\n`;\n+marked.setOptions({ renderer });\n+\n \n function doJSON(input, filename, cb) {\n   const root = { source: filename };\n   const stack = [root];\n-  var depth = 0;\n-  var current = root;\n-  var state = null;\n+  let depth = 0;\n+  let current = root;\n+  let state = null;\n+\n+  const exampleHeading = /^example/i;\n+  const metaExpr = /<!--([^=]+)=([^-]+)-->\\n*/g;\n+  const stabilityExpr = /^Stability: ([0-5])(?:\\s*-\\s*)?(.*)$/;\n+\n   const lexed = marked.lexer(input);\n-  lexed.forEach(function(tok) {\n-    const type = tok.type;\n-    var text = tok.text;\n+  lexed.forEach((tok) => {\n+    const { type } = tok;\n+    let { text } = tok;\n \n-    // <!-- type = module -->\n+    // <!-- name=module -->\n     // This is for cases where the markdown semantic structure is lacking.\n     if (type === 'paragraph' || type === 'html') {\n-      var metaExpr = /<!--([^=]+)=([^-]+)-->\\n*/g;\n-      text = text.replace(metaExpr, function(_0, k, v) {\n-        current[k.trim()] = v.trim();\n+      text = text.replace(metaExpr, (_0, key, value) => {\n+        current[key.trim()] = value.trim();\n         return '';\n       });\n       text = text.trim();\n       if (!text) return;\n     }\n \n-    if (type === 'heading' &&\n-        !text.trim().match(/^example/i)) {\n+    if (type === 'heading' && !exampleHeading.test(text.trim())) {\n       if (tok.depth - depth > 1) {\n-        return cb(new Error('Inappropriate heading level\\n' +\n-                            JSON.stringify(tok)));\n+        return cb(\n+          new Error(`Inappropriate heading level\\n${JSON.stringify(tok)}`));\n       }\n \n       // Sometimes we have two headings with a single blob of description.\n       // Treat as a clone.\n-      if (current &&\n-          state === 'AFTERHEADING' &&\n-          depth === tok.depth) {\n-        var clone = current;\n+      if (state === 'AFTERHEADING' && depth === tok.depth) {\n+        const clone = current;\n         current = newSection(tok);\n         current.clone = clone;\n         // Don't keep it around on the stack.\n@@ -86,15 +84,15 @@ function doJSON(input, filename, cb) {\n         // root is always considered the level=0 section,\n         // and the lowest heading is 1, so this should always\n         // result in having a valid parent node.\n-        var d = tok.depth;\n-        while (d <= depth) {\n+        let closingDepth = tok.depth;\n+        while (closingDepth <= depth) {\n           finishSection(stack.pop(), stack[stack.length - 1]);\n-          d++;\n+          closingDepth++;\n         }\n         current = newSection(tok);\n       }\n \n-      depth = tok.depth;\n+      ({ depth } = tok);\n       stack.push(current);\n       state = 'AFTERHEADING';\n       return;\n@@ -109,9 +107,13 @@ function doJSON(input, filename, cb) {\n     // A list: starting with list_start, ending with list_end,\n     // maybe containing other nested lists in each item.\n     //\n+    // A metadata:\n+    // <!-- YAML\n+    // added: v1.0.0\n+    // -->\n+    //\n     // If one of these isn't found, then anything that comes\n     // between here and the next heading should be parsed as the desc.\n-    var stability;\n     if (state === 'AFTERHEADING') {\n       if (type === 'blockquote_start') {\n         state = 'AFTERHEADING_BLOCKQUOTE';\n@@ -156,8 +158,8 @@ function doJSON(input, filename, cb) {\n         return;\n       }\n \n-      if (type === 'paragraph' &&\n-          (stability = text.match(/^Stability: ([0-5])(?:\\s*-\\s*)?(.*)$/))) {\n+      let stability;\n+      if (type === 'paragraph' && (stability = text.match(stabilityExpr))) {\n         current.stability = parseInt(stability[1], 10);\n         current.stabilityText = stability[2].trim();\n         return;\n@@ -167,7 +169,6 @@ function doJSON(input, filename, cb) {\n     current.desc = current.desc || [];\n     current.desc.links = lexed.links;\n     current.desc.push(tok);\n-\n   });\n \n   // Finish any sections left open.\n@@ -181,69 +182,67 @@ function doJSON(input, filename, cb) {\n \n // Go from something like this:\n //\n-// [ { type: 'list_item_start' },\n-//   { type: 'text',\n-//     text: '`settings` Object, Optional' },\n-//   { type: 'list_start', ordered: false },\n-//   { type: 'list_item_start' },\n-//   { type: 'text',\n-//     text: 'exec: String, file path to worker file. Default: `__filename`' },\n-//   { type: 'list_item_end' },\n-//   { type: 'list_item_start' },\n-//   { type: 'text',\n-//     text: 'args: Array, string arguments passed to worker.' },\n-//   { type: 'text',\n-//     text: 'Default: `process.argv.slice(2)`' },\n-//   { type: 'list_item_end' },\n-//   { type: 'list_item_start' },\n-//   { type: 'text',\n-//     text: 'silent: Boolean, whether to send output to parent\\'s stdio.' },\n-//   { type: 'text', text: 'Default: `false`' },\n-//   { type: 'space' },\n-//   { type: 'list_item_end' },\n-//   { type: 'list_end' },\n-//   { type: 'list_item_end' },\n-//   { type: 'list_end' } ]\n+// [ { type: \"list_item_start\" },\n+//   { type: \"text\",\n+//     text: \"`options` {Object|string}\" },\n+//   { type: \"list_start\",\n+//     ordered: false },\n+//   { type: \"list_item_start\" },\n+//   { type: \"text\",\n+//     text: \"`encoding` {string|null} **Default:** `'utf8'`\" },\n+//   { type: \"list_item_end\" },\n+//   { type: \"list_item_start\" },\n+//   { type: \"text\",\n+//     text: \"`mode` {integer} **Default:** `0o666`\" },\n+//   { type: \"list_item_end\" },\n+//   { type: \"list_item_start\" },\n+//   { type: \"text\",\n+//     text: \"`flag` {string} **Default:** `'a'`\" },\n+//   { type: \"space\" },\n+//   { type: \"list_item_end\" },\n+//   { type: \"list_end\" },\n+//   { type: \"list_item_end\" } ]\n //\n // to something like:\n //\n-// [ { name: 'settings',\n-//     type: 'object',\n-//     optional: true,\n-//     settings:\n-//      [ { name: 'exec',\n-//          type: 'string',\n-//          desc: 'file path to worker file',\n-//          default: '__filename' },\n-//        { name: 'args',\n-//          type: 'array',\n-//          default: 'process.argv.slice(2)',\n-//          desc: 'string arguments passed to worker.' },\n-//        { name: 'silent',\n-//          type: 'boolean',\n-//          desc: 'whether to send output to parent\\'s stdio.',\n-//          default: 'false' } ] } ]\n+// [ { textRaw: \"`options` {Object|string} \",\n+//     options: [\n+//       { textRaw: \"`encoding` {string|null} **Default:** `'utf8'` \",\n+//         name: \"encoding\",\n+//         type: \"string|null\",\n+//         default: \"`'utf8'`\" },\n+//       { textRaw: \"`mode` {integer} **Default:** `0o666` \",\n+//         name: \"mode\",\n+//         type: \"integer\",\n+//         default: \"`0o666`\" },\n+//       { textRaw: \"`flag` {string} **Default:** `'a'` \",\n+//         name: \"flag\",\n+//         type: \"string\",\n+//         default: \"`'a'`\" } ],\n+//     name: \"options\",\n+//     type: \"Object|string\",\n+//     optional: true } ]\n \n function processList(section) {\n-  const list = section.list;\n+  const { list } = section;\n   const values = [];\n-  var current;\n   const stack = [];\n+  let current;\n \n   // For now, *just* build the hierarchical list.\n-  list.forEach(function(tok) {\n-    const type = tok.type;\n+  list.forEach((tok) => {\n+    const { type } = tok;\n     if (type === 'space') return;\n     if (type === 'list_item_start' || type === 'loose_item_start') {\n-      var n = {};\n+      const item = {};\n       if (!current) {\n-        values.push(n);\n-        current = n;\n+        values.push(item);\n+        current = item;\n       } else {\n         current.options = current.options || [];\n         stack.push(current);\n-        current.options.push(n);\n-        current = n;\n+        current.options.push(item);\n+        current = item;\n       }\n     } else if (type === 'list_item_end') {\n       if (!current) {\n@@ -277,33 +276,35 @@ function processList(section) {\n   switch (section.type) {\n     case 'ctor':\n     case 'classMethod':\n-    case 'method':\n+    case 'method': {\n       // Each item is an argument, unless the name is 'return',\n       // in which case it's the return value.\n       section.signatures = section.signatures || [];\n-      var sig = {};\n+      const sig = {};\n       section.signatures.push(sig);\n-      sig.params = values.filter(function(v) {\n-        if (v.name === 'return') {\n-          sig.return = v;\n+      sig.params = values.filter((value) => {\n+        if (value.name === 'return') {\n+          sig.return = value;\n           return false;\n         }\n         return true;\n       });\n       parseSignature(section.textRaw, sig);\n       break;\n+    }\n \n-    case 'property':\n+    case 'property': {\n       // There should be only one item, which is the value.\n       // Copy the data up to the section.\n-      var value = values[0] || {};\n+      const value = values[0] || {};\n       delete value.name;\n       section.typeof = value.type || section.typeof;\n       delete value.type;\n-      Object.keys(value).forEach(function(k) {\n-        section[k] = value[k];\n+      Object.keys(value).forEach((key) => {\n+        section[key] = value[key];\n       });\n       break;\n+    }\n \n     case 'event':\n       // Event: each item is an argument.\n@@ -313,117 +314,111 @@ function processList(section) {\n     default:\n       if (section.list.length > 0) {\n         section.desc = section.desc || [];\n-        for (var i = 0; i < section.list.length; i++) {\n-          section.desc.push(section.list[i]);\n-        }\n+        section.desc.push(...section.list);\n       }\n   }\n \n-  // section.listParsed = values;\n   delete section.list;\n }\n \n-const paramExpr = /\\((.*)\\);?$/;\n \n-// textRaw = \"someobject.someMethod(a[, b=100][, c])\"\n+const paramExpr = /\\((.+)\\);?$/;\n+\n+// text: \"someobject.someMethod(a[, b=100][, c])\"\n function parseSignature(text, sig) {\n-  var params = text.match(paramExpr);\n-  if (!params) return;\n-  params = params[1];\n-  params = params.split(/,/);\n-  var optionalLevel = 0;\n+  let [, sigParams] = text.match(paramExpr) || [];\n+  if (!sigParams) return;\n+  sigParams = sigParams.split(',');\n+  let optionalLevel = 0;\n   const optionalCharDict = { '[': 1, ' ': 0, ']': -1 };\n-  params.forEach(function(p, i) {\n-    p = p.trim();\n-    if (!p) return;\n-    var param = sig.params[i];\n-    var optional = false;\n-    var def;\n+  sigParams.forEach((sigParam, i) => {\n+    sigParam = sigParam.trim();\n+    if (!sigParam) {\n+      throw new Error(`Empty parameter slot: ${text}`);\n+    }\n+    let listParam = sig.params[i];\n+    let optional = false;\n+    let defaultValue;\n \n     // For grouped optional params such as someMethod(a[, b[, c]]).\n-    var pos;\n-    for (pos = 0; pos < p.length; pos++) {\n-      if (optionalCharDict[p[pos]] === undefined) { break; }\n-      optionalLevel += optionalCharDict[p[pos]];\n+    let pos;\n+    for (pos = 0; pos < sigParam.length; pos++) {\n+      const levelChange = optionalCharDict[sigParam[pos]];\n+      if (levelChange === undefined) break;\n+      optionalLevel += levelChange;\n     }\n-    p = p.substring(pos);\n+    sigParam = sigParam.substring(pos);\n     optional = (optionalLevel > 0);\n-    for (pos = p.length - 1; pos >= 0; pos--) {\n-      if (optionalCharDict[p[pos]] === undefined) { break; }\n-      optionalLevel += optionalCharDict[p[pos]];\n+    for (pos = sigParam.length - 1; pos >= 0; pos--) {\n+      const levelChange = optionalCharDict[sigParam[pos]];\n+      if (levelChange === undefined) break;\n+      optionalLevel += levelChange;\n     }\n-    p = p.substring(0, pos + 1);\n+    sigParam = sigParam.substring(0, pos + 1);\n \n-    const eq = p.indexOf('=');\n+    const eq = sigParam.indexOf('=');\n     if (eq !== -1) {\n-      def = p.substr(eq + 1);\n-      p = p.substr(0, eq);\n+      defaultValue = sigParam.substr(eq + 1);\n+      sigParam = sigParam.substr(0, eq);\n     }\n-    if (!param) {\n-      param = sig.params[i] = { name: p };\n+    if (!listParam) {\n+      listParam = sig.params[i] = { name: sigParam };\n     }\n     // At this point, the name should match.\n-    if (p !== param.name) {\n-      console.error('Warning: invalid param \"%s\"', p);\n-      console.error(` > ${JSON.stringify(param)}`);\n-      console.error(` > ${text}`);\n+    if (sigParam !== listParam.name) {\n+      throw new Error(\n+        `Warning: invalid param \"${sigParam}\"\\n` +\n+        ` > ${JSON.stringify(listParam)}\\n` +\n+        ` > ${text}`\n+      );\n     }\n-    if (optional) param.optional = true;\n-    if (def !== undefined) param.default = def;\n+    if (optional) listParam.optional = true;\n+    if (defaultValue !== undefined) listParam.default = defaultValue.trim();\n   });\n }\n \n \n+const returnExpr = /^returns?\\s*:?\\s*/i;\n+const nameExpr = /^['`\"]?([^'`\": {]+)['`\"]?\\s*:?\\s*/;\n+const typeExpr = /^\\{([^}]+)\\}\\s*/;\n+const leadingHyphen = /^-\\s*/;\n+const defaultExpr = /\\s*\\*\\*Default:\\*\\*\\s*([^]+)$/i;\n+\n function parseListItem(item) {\n   if (item.options) item.options.forEach(parseListItem);\n-  if (!item.textRaw) return;\n+  if (!item.textRaw) {\n+    throw new Error(`Empty list item: ${JSON.stringify(item)}`);\n+  }\n \n   // The goal here is to find the name, type, default, and optional.\n   // Anything left over is 'desc'.\n-  var text = item.textRaw.trim();\n-  // text = text.replace(/^(Argument|Param)s?\\s*:?\\s*/i, '');\n+  let text = item.textRaw.trim();\n \n-  text = text.replace(/^, /, '').trim();\n-  const retExpr = /^returns?\\s*:?\\s*/i;\n-  const ret = text.match(retExpr);\n-  if (ret) {\n+  if (returnExpr.test(text)) {\n     item.name = 'return';\n-    text = text.replace(retExpr, '');\n+    text = text.replace(returnExpr, '');\n   } else {\n-    var nameExpr = /^['`\"]?([^'`\": {]+)['`\"]?\\s*:?\\s*/;\n-    var name = text.match(nameExpr);\n+    const [, name] = text.match(nameExpr) || [];\n     if (name) {\n-      item.name = name[1];\n+      item.name = name;\n       text = text.replace(nameExpr, '');\n     }\n   }\n \n-  text = text.trim();\n-  const defaultExpr = /\\s*\\*\\*Default:\\*\\*\\s*([^]+)$/i;\n-  const def = text.match(defaultExpr);\n-  if (def) {\n-    item.default = def[1].replace(/\\.$/, '');\n-    text = text.replace(defaultExpr, '');\n-  }\n-\n-  text = text.trim();\n-  const typeExpr = /^\\{([^}]+)\\}/;\n-  const type = text.match(typeExpr);\n+  const [, type] = text.match(typeExpr) || [];\n   if (type) {\n-    item.type = type[1];\n+    item.type = type;\n     text = text.replace(typeExpr, '');\n   }\n \n-  text = text.trim();\n-  const optExpr = /^Optional\\.|(?:, )?Optional$/;\n-  const optional = text.match(optExpr);\n-  if (optional) {\n-    item.optional = true;\n-    text = text.replace(optExpr, '');\n+  text = text.replace(leadingHyphen, '');\n+\n+  const [, defaultValue] = text.match(defaultExpr) || [];\n+  if (defaultValue) {\n+    item.default = defaultValue.replace(/\\.$/, '');\n+    text = text.replace(defaultExpr, '');\n   }\n \n-  text = text.replace(/^\\s*-\\s*/, '');\n-  text = text.trim();\n   if (text) item.desc = text;\n }\n \n@@ -437,7 +432,7 @@ function finishSection(section, parent) {\n \n   if (!section.type) {\n     section.type = 'module';\n-    if (parent && (parent.type === 'misc')) {\n+    if (parent.type === 'misc') {\n       section.type = 'misc';\n     }\n     section.displayName = section.name;\n@@ -458,37 +453,40 @@ function finishSection(section, parent) {\n   // Merge them into the parent.\n   if (section.type === 'class' && section.ctors) {\n     section.signatures = section.signatures || [];\n-    var sigs = section.signatures;\n-    section.ctors.forEach(function(ctor) {\n+    const sigs = section.signatures;\n+    section.ctors.forEach((ctor) => {\n       ctor.signatures = ctor.signatures || [{}];\n-      ctor.signatures.forEach(function(sig) {\n+      ctor.signatures.forEach((sig) => {\n         sig.desc = ctor.desc;\n       });\n-      sigs.push.apply(sigs, ctor.signatures);\n+      sigs.push(...ctor.signatures);\n     });\n     delete section.ctors;\n   }\n \n   // Properties are a bit special.\n   // Their \"type\" is the type of object, not \"property\".\n   if (section.properties) {\n-    section.properties.forEach(function(p) {\n-      if (p.typeof) p.type = p.typeof;\n-      else delete p.type;\n-      delete p.typeof;\n+    section.properties.forEach((prop) => {\n+      if (prop.typeof) {\n+        prop.type = prop.typeof;\n+        delete prop.typeof;\n+      } else {\n+        delete prop.type;\n+      }\n     });\n   }\n \n   // Handle clones.\n   if (section.clone) {\n-    var clone = section.clone;\n+    const { clone } = section;\n     delete section.clone;\n     delete clone.clone;\n     deepCopy(section, clone);\n     finishSection(clone, parent);\n   }\n \n-  var plur;\n+  let plur;\n   if (section.type.slice(-1) === 's') {\n     plur = `${section.type}es`;\n   } else if (section.type.slice(-1) === 'y') {\n@@ -501,8 +499,8 @@ function finishSection(section, parent) {\n   // collection of stuff, like the \"globals\" section.\n   // Make the children top-level items.\n   if (section.type === 'misc') {\n-    Object.keys(section).forEach(function(k) {\n-      switch (k) {\n+    Object.keys(section).forEach((key) => {\n+      switch (key) {\n         case 'textRaw':\n         case 'name':\n         case 'type':\n@@ -513,10 +511,10 @@ function finishSection(section, parent) {\n           if (parent.type === 'misc') {\n             return;\n           }\n-          if (Array.isArray(k) && parent[k]) {\n-            parent[k] = parent[k].concat(section[k]);\n-          } else if (!parent[k]) {\n-            parent[k] = section[k];\n+          if (parent[key] && Array.isArray(parent[key])) {\n+            parent[key] = parent[key].concat(section[key]);\n+          } else if (!parent[key]) {\n+            parent[key] = section[key];\n           }\n       }\n     });\n@@ -530,28 +528,26 @@ function finishSection(section, parent) {\n // Not a general purpose deep copy.\n // But sufficient for these basic things.\n function deepCopy(src, dest) {\n-  Object.keys(src).filter(function(k) {\n-    return !dest.hasOwnProperty(k);\n-  }).forEach(function(k) {\n-    dest[k] = deepCopy_(src[k]);\n-  });\n+  Object.keys(src)\n+    .filter((key) => !dest.hasOwnProperty(key))\n+    .forEach((key) => { dest[key] = cloneValue(src[key]); });\n }\n \n-function deepCopy_(src) {\n+function cloneValue(src) {\n   if (!src) return src;\n   if (Array.isArray(src)) {\n-    const c = new Array(src.length);\n-    src.forEach(function(v, i) {\n-      c[i] = deepCopy_(v);\n+    const clone = new Array(src.length);\n+    src.forEach((value, i) => {\n+      clone[i] = cloneValue(value);\n     });\n-    return c;\n+    return clone;\n   }\n   if (typeof src === 'object') {\n-    const c = {};\n-    Object.keys(src).forEach(function(k) {\n-      c[k] = deepCopy_(src[k]);\n+    const clone = {};\n+    Object.keys(src).forEach((key) => {\n+      clone[key] = cloneValue(src[key]);\n     });\n-    return c;\n+    return clone;\n   }\n   return src;\n }"
        }
    ],
    "stats": {
        "total": 372,
        "additions": 184,
        "deletions": 188
    }
}