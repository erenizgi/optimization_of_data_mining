{
    "author": "addaleax",
    "message": "http2: use native pipe instead of synchronous I/O\n\nThis resolves the issue of using synchronous I/O for\n`respondWithFile()` and `respondWithFD()`, and enables\nscenarios in which the underlying file does not need\nto be a regular file.\n\nPR-URL: https://github.com/nodejs/node/pull/18936\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "1eb6b01fca598194f59f8f4cac499825e6769363",
    "files": [
        {
            "sha": "607ae3fd2d297d0b61d3de3b23cbe11decb2b83a",
            "filename": "lib/internal/http2/core.js",
            "status": "modified",
            "additions": 49,
            "deletions": 11,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/1eb6b01fca598194f59f8f4cac499825e6769363/lib%2Finternal%2Fhttp2%2Fcore.js",
            "raw_url": "https://github.com/nodejs/node/raw/1eb6b01fca598194f59f8f4cac499825e6769363/lib%2Finternal%2Fhttp2%2Fcore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fhttp2%2Fcore.js?ref=1eb6b01fca598194f59f8f4cac499825e6769363",
            "patch": "@@ -4,9 +4,13 @@\n \n require('internal/util').assertCrypto();\n \n+const { internalBinding } = require('internal/bootstrap_loaders');\n const { async_id_symbol } = require('internal/async_hooks').symbols;\n+const { UV_EOF } = process.binding('uv');\n const http = require('http');\n const binding = process.binding('http2');\n+const { FileHandle } = process.binding('fs');\n+const { StreamPipe } = internalBinding('stream_pipe');\n const assert = require('assert');\n const { Buffer } = require('buffer');\n const EventEmitter = require('events');\n@@ -65,6 +69,7 @@ const { onServerStream,\n const { utcDate } = require('internal/http');\n const { promisify } = require('internal/util');\n const { isArrayBufferView } = require('internal/util/types');\n+const { defaultTriggerAsyncIdScope } = require('internal/async_hooks');\n const { _connectionListener: httpConnectionListener } = require('http');\n const { createPromise, promiseResolve } = process.binding('util');\n const debug = util.debuglog('http2');\n@@ -345,9 +350,7 @@ function onStreamClose(code) {\n     stream.end();\n   }\n \n-  if (state.fd !== undefined)\n-    tryClose(state.fd);\n-\n+  state.fd = -1;\n   // Defer destroy we actually emit end.\n   if (stream._readableState.endEmitted || code !== NGHTTP2_NO_ERROR) {\n     // If errored or ended, we can destroy immediately.\n@@ -1928,6 +1931,26 @@ function processHeaders(headers) {\n   return headers;\n }\n \n+function onFileCloseError(stream, err) {\n+  stream.emit(err);\n+}\n+\n+function onFileUnpipe() {\n+  const stream = this.sink[kOwner];\n+  if (stream.ownsFd)\n+    this.source.close().catch(onFileCloseError.bind(stream));\n+  else\n+    this.source.releaseFD();\n+}\n+\n+// This is only called once the pipe has returned back control, so\n+// it only has to handle errors and End-of-File.\n+function onPipedFileHandleRead(err) {\n+  if (err < 0 && err !== UV_EOF) {\n+    this.stream.close(NGHTTP2_INTERNAL_ERROR);\n+  }\n+}\n+\n function processRespondWithFD(self, fd, headers, offset = 0, length = -1,\n                               streamOptions = 0) {\n   const state = self[kState];\n@@ -1940,18 +1963,32 @@ function processRespondWithFD(self, fd, headers, offset = 0, length = -1,\n     return;\n   }\n \n-\n-  // Close the writable side of the stream\n+  // Close the writable side of the stream, but only as far as the writable\n+  // stream implementation is concerned.\n+  self._final = null;\n   self.end();\n \n-  const ret = self[kHandle].respondFD(fd, headersList,\n-                                      offset, length,\n-                                      streamOptions);\n+  const ret = self[kHandle].respond(headersList, streamOptions);\n \n   if (ret < 0) {\n     self.destroy(new NghttpError(ret));\n     return;\n   }\n+\n+  defaultTriggerAsyncIdScope(self[async_id_symbol], startFilePipe,\n+                             self, fd, offset, length);\n+}\n+\n+function startFilePipe(self, fd, offset, length) {\n+  const handle = new FileHandle(fd, offset, length);\n+  handle.onread = onPipedFileHandleRead;\n+  handle.stream = self;\n+\n+  const pipe = new StreamPipe(handle._externalStream,\n+                              self[kHandle]._externalStream);\n+  pipe.onunpipe = onFileUnpipe;\n+  pipe.start();\n+\n   // exact length of the file doesn't matter here, since the\n   // stream is closing anyway - just use 1 to signify that\n   // a write does exist\n@@ -2270,8 +2307,9 @@ class ServerHttp2Stream extends Http2Stream {\n       throw new ERR_INVALID_ARG_TYPE('fd', 'number');\n \n     debug(`Http2Stream ${this[kID]} [Http2Session ` +\n-          `${sessionName(session[kType])}]: initiating response`);\n+          `${sessionName(session[kType])}]: initiating response from fd`);\n     this[kUpdateTimer]();\n+    this.ownsFd = false;\n \n     headers = processHeaders(headers);\n     const statusCode = headers[HTTP2_HEADER_STATUS] |= 0;\n@@ -2333,9 +2371,9 @@ class ServerHttp2Stream extends Http2Stream {\n \n     const session = this[kSession];\n     debug(`Http2Stream ${this[kID]} [Http2Session ` +\n-          `${sessionName(session[kType])}]: initiating response`);\n+          `${sessionName(session[kType])}]: initiating response from file`);\n     this[kUpdateTimer]();\n-\n+    this.ownsFd = true;\n \n     headers = processHeaders(headers);\n     const statusCode = headers[HTTP2_HEADER_STATUS] |= 0;"
        },
        {
            "sha": "68a684025ce4a0bed70ec01817b679bedab3cc3b",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 125,
            "changes": 125,
            "blob_url": "https://github.com/nodejs/node/blob/1eb6b01fca598194f59f8f4cac499825e6769363/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1eb6b01fca598194f59f8f4cac499825e6769363/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=1eb6b01fca598194f59f8f4cac499825e6769363",
            "patch": "@@ -1888,28 +1888,6 @@ inline int Http2Stream::SubmitResponse(nghttp2_nv* nva,\n }\n \n \n-// Initiate a response that contains data read from a file descriptor.\n-inline int Http2Stream::SubmitFile(int fd,\n-                                   nghttp2_nv* nva, size_t len,\n-                                   int64_t offset,\n-                                   int64_t length,\n-                                   int options) {\n-  CHECK(!this->IsDestroyed());\n-  Http2Scope h2scope(this);\n-  DEBUG_HTTP2STREAM(this, \"submitting file\");\n-  if (options & STREAM_OPTION_GET_TRAILERS)\n-    flags_ |= NGHTTP2_STREAM_FLAG_TRAILERS;\n-\n-  if (offset > 0) fd_offset_ = offset;\n-  if (length > -1) fd_length_ = length;\n-\n-  Http2Stream::Provider::FD prov(this, options, fd);\n-  int ret = nghttp2_submit_response(session_->session(), id_, nva, len, *prov);\n-  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);\n-  return ret;\n-}\n-\n-\n // Submit informational headers for a stream.\n inline int Http2Stream::SubmitInfo(nghttp2_nv* nva, size_t len) {\n   CHECK(!this->IsDestroyed());\n@@ -2085,87 +2063,6 @@ Http2Stream::Provider::~Provider() {\n   provider_.source.ptr = nullptr;\n }\n \n-// The FD Provider pulls data from a file descriptor using libuv. All of the\n-// data transfer occurs in C++, without any chunks being passed through JS\n-// land.\n-Http2Stream::Provider::FD::FD(Http2Stream* stream, int options, int fd)\n-    : Http2Stream::Provider(stream, options) {\n-  CHECK(!stream->IsDestroyed());\n-  provider_.source.fd = fd;\n-  provider_.read_callback = Http2Stream::Provider::FD::OnRead;\n-}\n-\n-Http2Stream::Provider::FD::FD(int options, int fd)\n-    : Http2Stream::Provider(options) {\n-  provider_.source.fd = fd;\n-  provider_.read_callback = Http2Stream::Provider::FD::OnRead;\n-}\n-\n-ssize_t Http2Stream::Provider::FD::OnRead(nghttp2_session* handle,\n-                                          int32_t id,\n-                                          uint8_t* buf,\n-                                          size_t length,\n-                                          uint32_t* flags,\n-                                          nghttp2_data_source* source,\n-                                          void* user_data) {\n-  Http2Session* session = static_cast<Http2Session*>(user_data);\n-  Http2Stream* stream = session->FindStream(id);\n-  if (stream->statistics_.first_byte_sent == 0)\n-    stream->statistics_.first_byte_sent = uv_hrtime();\n-\n-  DEBUG_HTTP2SESSION2(session, \"reading outbound file data for stream %d\", id);\n-  CHECK_EQ(id, stream->id());\n-\n-  int fd = source->fd;\n-  int64_t offset = stream->fd_offset_;\n-  ssize_t numchars = 0;\n-\n-  if (stream->fd_length_ >= 0 &&\n-      stream->fd_length_ < static_cast<int64_t>(length))\n-    length = stream->fd_length_;\n-\n-  uv_buf_t data;\n-  data.base = reinterpret_cast<char*>(buf);\n-  data.len = length;\n-\n-  uv_fs_t read_req;\n-\n-  if (length > 0) {\n-    // TODO(addaleax): Never use synchronous I/O on the main thread.\n-    numchars = uv_fs_read(session->event_loop(),\n-                          &read_req,\n-                          fd, &data, 1,\n-                          offset, nullptr);\n-    uv_fs_req_cleanup(&read_req);\n-  }\n-\n-  // Close the stream with an error if reading fails\n-  if (numchars < 0)\n-    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n-\n-  // Update the read offset for the next read\n-  stream->fd_offset_ += numchars;\n-  stream->fd_length_ -= numchars;\n-\n-  DEBUG_HTTP2SESSION2(session, \"sending %d bytes\", numchars);\n-\n-  // if numchars < length, assume that we are done.\n-  if (static_cast<size_t>(numchars) < length || length <= 0) {\n-    DEBUG_HTTP2SESSION2(session, \"no more data for stream %d\", id);\n-    *flags |= NGHTTP2_DATA_FLAG_EOF;\n-    session->GetTrailers(stream, flags);\n-    // If the stream or session gets destroyed during the GetTrailers\n-    // callback, check that here and close down the stream\n-    if (stream->IsDestroyed())\n-      return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n-    if (session->IsDestroyed())\n-      return NGHTTP2_ERR_CALLBACK_FAILURE;\n-  }\n-\n-  stream->statistics_.sent_bytes += numchars;\n-  return numchars;\n-}\n-\n // The Stream Provider pulls data from a linked list of uv_buf_t structs\n // built via the StreamBase API and the Streams js API.\n Http2Stream::Provider::Stream::Stream(int options)\n@@ -2508,27 +2405,6 @@ void Http2Stream::Respond(const FunctionCallbackInfo<Value>& args) {\n   DEBUG_HTTP2STREAM(stream, \"response submitted\");\n }\n \n-// Initiates a response on the Http2Stream using a file descriptor to provide\n-// outbound DATA frames.\n-void Http2Stream::RespondFD(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  Local<Context> context = env->context();\n-  Isolate* isolate = env->isolate();\n-  Http2Stream* stream;\n-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());\n-\n-  int fd = args[0]->Int32Value(context).ToChecked();\n-  Local<Array> headers = args[1].As<Array>();\n-\n-  int64_t offset = args[2]->IntegerValue(context).ToChecked();\n-  int64_t length = args[3]->IntegerValue(context).ToChecked();\n-  int options = args[4]->IntegerValue(context).ToChecked();\n-\n-  Headers list(isolate, context, headers);\n-  args.GetReturnValue().Set(stream->SubmitFile(fd, *list, list.length(),\n-                                               offset, length, options));\n-  DEBUG_HTTP2STREAM2(stream, \"file response submitted for fd %d\", fd);\n-}\n \n // Submits informational headers on the Http2Stream\n void Http2Stream::Info(const FunctionCallbackInfo<Value>& args) {\n@@ -2891,7 +2767,6 @@ void Initialize(Local<Object> target,\n   env->SetProtoMethod(stream, \"priority\", Http2Stream::Priority);\n   env->SetProtoMethod(stream, \"pushPromise\", Http2Stream::PushPromise);\n   env->SetProtoMethod(stream, \"info\", Http2Stream::Info);\n-  env->SetProtoMethod(stream, \"respondFD\", Http2Stream::RespondFD);\n   env->SetProtoMethod(stream, \"respond\", Http2Stream::Respond);\n   env->SetProtoMethod(stream, \"rstStream\", Http2Stream::RstStream);\n   env->SetProtoMethod(stream, \"refreshState\", Http2Stream::RefreshState);"
        },
        {
            "sha": "0fac6cca00f4db27c0a6feff5378f97ce7585fb6",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/1eb6b01fca598194f59f8f4cac499825e6769363/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/1eb6b01fca598194f59f8f4cac499825e6769363/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=1eb6b01fca598194f59f8f4cac499825e6769363",
            "patch": "@@ -580,13 +580,6 @@ class Http2Stream : public AsyncWrap,\n                             size_t len,\n                             int options);\n \n-  // Send data read from a file descriptor as the response on this stream.\n-  inline int SubmitFile(int fd,\n-                        nghttp2_nv* nva, size_t len,\n-                        int64_t offset,\n-                        int64_t length,\n-                        int options);\n-\n   // Submit informational headers for this stream\n   inline int SubmitInfo(nghttp2_nv* nva, size_t len);\n \n@@ -709,7 +702,6 @@ class Http2Stream : public AsyncWrap,\n   static void PushPromise(const FunctionCallbackInfo<Value>& args);\n   static void RefreshState(const FunctionCallbackInfo<Value>& args);\n   static void Info(const FunctionCallbackInfo<Value>& args);\n-  static void RespondFD(const FunctionCallbackInfo<Value>& args);\n   static void Respond(const FunctionCallbackInfo<Value>& args);\n   static void RstStream(const FunctionCallbackInfo<Value>& args);\n \n@@ -753,8 +745,6 @@ class Http2Stream : public AsyncWrap,\n   // waiting to be written out to the socket.\n   std::queue<nghttp2_stream_write> queue_;\n   size_t available_outbound_length_ = 0;\n-  int64_t fd_offset_ = 0;\n-  int64_t fd_length_ = -1;\n \n   Http2StreamListener stream_listener_;\n \n@@ -780,20 +770,6 @@ class Http2Stream::Provider {\n   bool empty_ = false;\n };\n \n-class Http2Stream::Provider::FD : public Http2Stream::Provider {\n- public:\n-  FD(int options, int fd);\n-  FD(Http2Stream* stream, int options, int fd);\n-\n-  static ssize_t OnRead(nghttp2_session* session,\n-                        int32_t id,\n-                        uint8_t* buf,\n-                        size_t length,\n-                        uint32_t* flags,\n-                        nghttp2_data_source* source,\n-                        void* user_data);\n-};\n-\n class Http2Stream::Provider::Stream : public Http2Stream::Provider {\n  public:\n   Stream(Http2Stream* stream, int options);"
        },
        {
            "sha": "3a671a3e36490aa2ad71f3165cbe99f2fa8ed217",
            "filename": "test/parallel/test-http2-respond-with-fd-errors.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/1eb6b01fca598194f59f8f4cac499825e6769363/test%2Fparallel%2Ftest-http2-respond-with-fd-errors.js",
            "raw_url": "https://github.com/nodejs/node/raw/1eb6b01fca598194f59f8f4cac499825e6769363/test%2Fparallel%2Ftest-http2-respond-with-fd-errors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-respond-with-fd-errors.js?ref=1eb6b01fca598194f59f8f4cac499825e6769363",
            "patch": "@@ -46,8 +46,8 @@ const tests = specificTests.concat(genericTests);\n \n let currentError;\n \n-// mock respondFD because we only care about testing error handling\n-Http2Stream.prototype.respondFD = () => currentError.ngError;\n+// mock `respond` because we only care about testing error handling\n+Http2Stream.prototype.respond = () => currentError.ngError;\n \n const server = http2.createServer();\n server.on('stream', common.mustCall((stream, headers) => {"
        }
    ],
    "stats": {
        "total": 213,
        "additions": 51,
        "deletions": 162
    }
}