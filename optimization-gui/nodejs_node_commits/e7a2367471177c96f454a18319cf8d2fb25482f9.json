{
    "author": "addaleax",
    "message": "worker: implement `MessagePort` and `MessageChannel`\n\nImplement `MessagePort` and `MessageChannel` along the lines of\nthe DOM classes of the same names. `MessagePort`s initially\nsupport transferring only `ArrayBuffer`s.\n\nThanks to Stephen Belanger for reviewing this change in its\noriginal form, to Benjamin Gruenbaum for reviewing the\nadded tests in their original form, and to Olivia Hugger\nfor reviewing the documentation in its original form.\n\nRefs: https://github.com/ayojs/ayo/pull/98\n\nPR-URL: https://github.com/nodejs/node/pull/20876\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Shingo Inoue <leko.noor@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "e7a2367471177c96f454a18319cf8d2fb25482f9",
    "files": [
        {
            "sha": "1b2fdea26e46eb6633e018103f9cacad4578b1ea",
            "filename": "doc/api/_toc.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2F_toc.md",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2F_toc.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2F_toc.md?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -53,6 +53,7 @@\n * [Utilities](util.html)\n * [V8](v8.html)\n * [VM](vm.html)\n+* [Worker](worker.html)\n * [ZLIB](zlib.html)\n \n <div class=\"line\"></div>"
        },
        {
            "sha": "6f0a21dd0921054a0e69bf1dacbb4e171a0a232a",
            "filename": "doc/api/all.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2Fall.md",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2Fall.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fall.md?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -46,4 +46,5 @@\n @include util\n @include v8\n @include vm\n+@include worker\n @include zlib"
        },
        {
            "sha": "f3e5939f258576dd2755dd4f16fcc2da09bb36c1",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -650,12 +650,23 @@ Used when a child process is being forked without specifying an IPC channel.\n Used when the main process is trying to read data from the child process's\n STDERR / STDOUT, and the data's length is longer than the `maxBuffer` option.\n \n+<a id=\"ERR_CLOSED_MESSAGE_PORT\"></a>\n+### ERR_CLOSED_MESSAGE_PORT\n+\n+There was an attempt to use a `MessagePort` instance in a closed\n+state, usually after `.close()` has been called.\n+\n <a id=\"ERR_CONSOLE_WRITABLE_STREAM\"></a>\n ### ERR_CONSOLE_WRITABLE_STREAM\n \n `Console` was instantiated without `stdout` stream, or `Console` has a\n non-writable `stdout` or `stderr` stream.\n \n+<a id=\"ERR_CONSTRUCT_CALL_REQUIRED\"></a>\n+### ERR_CONSTRUCT_CALL_REQUIRED\n+\n+A constructor for a class was called without `new`.\n+\n <a id=\"ERR_CPU_USAGE\"></a>\n ### ERR_CPU_USAGE\n \n@@ -1203,6 +1214,11 @@ urlSearchParams.has.call(buf, 'foo');\n // Throws a TypeError with code 'ERR_INVALID_THIS'\n ```\n \n+<a id=\"ERR_INVALID_TRANSFER_OBJECT\"></a>\n+### ERR_INVALID_TRANSFER_OBJECT\n+\n+An invalid transfer object was passed to `postMessage()`.\n+\n <a id=\"ERR_INVALID_TUPLE\"></a>\n ### ERR_INVALID_TUPLE\n "
        },
        {
            "sha": "4724714cd62f263e791460e9508ae8e7f4dc9726",
            "filename": "doc/api/worker.md",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2Fworker.md",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/doc%2Fapi%2Fworker.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fworker.md?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,146 @@\n+# Worker\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+## Class: MessageChannel\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Instances of the `worker.MessageChannel` class represent an asynchronous,\n+two-way communications channel.\n+The `MessageChannel` has no methods of its own. `new MessageChannel()`\n+yields an object with `port1` and `port2` properties, which refer to linked\n+[`MessagePort`][] instances.\n+\n+```js\n+const { MessageChannel } = require('worker');\n+\n+const { port1, port2 } = new MessageChannel();\n+port1.on('message', (message) => console.log('received', message));\n+port2.postMessage({ foo: 'bar' });\n+// prints: received { foo: 'bar' }\n+```\n+\n+## Class: MessagePort\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Extends: {EventEmitter}\n+\n+Instances of the `worker.MessagePort` class represent one end of an\n+asynchronous, two-way communications channel. It can be used to transfer\n+structured data, memory regions and other `MessagePort`s between different\n+[`Worker`][]s.\n+\n+With the exception of `MessagePort`s being [`EventEmitter`][]s rather\n+than `EventTarget`s, this implementation matches [browser `MessagePort`][]s.\n+\n+### Event: 'close'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+The `'close'` event is emitted once either side of the channel has been\n+disconnected.\n+\n+### Event: 'message'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {any} The transmitted value\n+\n+The `'message'` event is emitted for any incoming message, containing the cloned\n+input of [`port.postMessage()`][].\n+\n+Listeners on this event will receive a clone of the `value` parameter as passed\n+to `postMessage()` and no further arguments.\n+\n+### port.close()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Disables further sending of messages on either side of the connection.\n+This method can be called once you know that no further communication\n+will happen over this `MessagePort`.\n+\n+### port.postMessage(value[, transferList])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {any}\n+* `transferList` {Object[]}\n+\n+Sends a JavaScript value to the receiving side of this channel.\n+`value` will be transferred in a way which is compatible with\n+the [HTML structured clone algorithm][]. In particular, it may contain circular\n+references and objects like typed arrays that the `JSON` API is not able\n+to stringify.\n+\n+`transferList` may be a list of `ArrayBuffer` objects.\n+After transferring, they will not be usable on the sending side of the channel\n+anymore (even if they are not contained in `value`).\n+\n+`value` may still contain `ArrayBuffer` instances that are not in\n+`transferList`; in that case, the underlying memory is copied rather than moved.\n+\n+For more information on the serialization and deserialization mechanisms\n+behind this API, see the [serialization API of the `v8` module][v8.serdes].\n+\n+Because the object cloning uses the structured clone algorithm,\n+non-enumerable properties, property accessors, and object prototypes are\n+not preserved. In particular, [`Buffer`][] objects will be read as\n+plain [`Uint8Array`][]s on the receiving side.\n+\n+The message object will be cloned immediately, and can be modified after\n+posting without having side effects.\n+\n+### port.ref()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Opposite of `unref()`. Calling `ref()` on a previously `unref()`ed port will\n+*not* let the program exit if it's the only active handle left (the default\n+behavior). If the port is `ref()`ed, calling `ref()` again will have no effect.\n+\n+If listeners are attached or removed using `.on('message')`, the port will\n+be `ref()`ed and `unref()`ed automatically depending on whether\n+listeners for the event exist.\n+\n+### port.start()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Starts receiving messages on this `MessagePort`. When using this port\n+as an event emitter, this will be called automatically once `'message'`\n+listeners are attached.\n+\n+### port.unref()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Calling `unref()` on a port will allow the thread to exit if this is the only\n+active handle in the event system. If the port is already `unref()`ed calling\n+`unref()` again will have no effect.\n+\n+If listeners are attached or removed using `.on('message')`, the port will\n+be `ref()`ed and `unref()`ed automatically depending on whether\n+listeners for the event exist.\n+\n+[`Buffer`]: buffer.html\n+[`EventEmitter`]: events.html\n+[`MessagePort`]: #worker_class_messageport\n+[`port.postMessage()`]: #worker_port_postmessage_value_transferlist\n+[v8.serdes]: v8.html#v8_serialization_api\n+[`Uint8Array`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n+[browser `MessagePort`]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\n+[HTML structured clone algorithm]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm"
        },
        {
            "sha": "417e8594e14aab9773e52fd007bd016f4fada3ea",
            "filename": "lib/internal/bootstrap/loaders.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Floaders.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -194,7 +194,8 @@\n     };\n \n     NativeModule.isInternal = function(id) {\n-      return id.startsWith('internal/');\n+      return id.startsWith('internal/') ||\n+          (id === 'worker' && !process.binding('config').experimentalWorker);\n     };\n   }\n "
        },
        {
            "sha": "55eaed7d376506124a46a1f4f8166566ad7e680b",
            "filename": "lib/internal/modules/cjs/helpers.js",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Finternal%2Fmodules%2Fcjs%2Fhelpers.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Finternal%2Fmodules%2Fcjs%2Fhelpers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fmodules%2Fcjs%2Fhelpers.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -105,6 +105,11 @@ const builtinLibs = [\n   'v8', 'vm', 'zlib'\n ];\n \n+if (process.binding('config').experimentalWorker) {\n+  builtinLibs.push('worker');\n+  builtinLibs.sort();\n+}\n+\n if (typeof process.binding('inspector').open === 'function') {\n   builtinLibs.push('inspector');\n   builtinLibs.sort();"
        },
        {
            "sha": "73f7525aa73cc26e20e98728d90e2b91644dabb7",
            "filename": "lib/internal/worker.js",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Finternal%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Finternal%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fworker.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,105 @@\n+'use strict';\n+\n+const EventEmitter = require('events');\n+const util = require('util');\n+\n+const { internalBinding } = require('internal/bootstrap/loaders');\n+const { MessagePort, MessageChannel } = internalBinding('messaging');\n+const { handle_onclose } = internalBinding('symbols');\n+\n+util.inherits(MessagePort, EventEmitter);\n+\n+const kOnMessageListener = Symbol('kOnMessageListener');\n+\n+const debug = util.debuglog('worker');\n+\n+// A MessagePort consists of a handle (that wraps around an\n+// uv_async_t) which can receive information from other threads and emits\n+// .onmessage events, and a function used for sending data to a MessagePort\n+// in some other thread.\n+MessagePort.prototype[kOnMessageListener] = function onmessage(payload) {\n+  debug('received message', payload);\n+  // Emit the deserialized object to userland.\n+  this.emit('message', payload);\n+};\n+\n+// This is for compatibility with the Web's MessagePort API. It makes sense to\n+// provide it as an `EventEmitter` in Node.js, but if somebody overrides\n+// `onmessage`, we'll switch over to the Web API model.\n+Object.defineProperty(MessagePort.prototype, 'onmessage', {\n+  enumerable: true,\n+  configurable: true,\n+  get() {\n+    return this[kOnMessageListener];\n+  },\n+  set(value) {\n+    this[kOnMessageListener] = value;\n+    if (typeof value === 'function') {\n+      this.ref();\n+      this.start();\n+    } else {\n+      this.unref();\n+      this.stop();\n+    }\n+  }\n+});\n+\n+// This is called from inside the `MessagePort` constructor.\n+function oninit() {\n+  setupPortReferencing(this, this, 'message');\n+}\n+\n+Object.defineProperty(MessagePort.prototype, 'oninit', {\n+  enumerable: true,\n+  writable: false,\n+  value: oninit\n+});\n+\n+// This is called after the underlying `uv_async_t` has been closed.\n+function onclose() {\n+  if (typeof this.onclose === 'function') {\n+    // Not part of the Web standard yet, but there aren't many reasonable\n+    // alternatives in a non-EventEmitter usage setting.\n+    // Refs: https://github.com/whatwg/html/issues/1766\n+    this.onclose();\n+  }\n+  this.emit('close');\n+}\n+\n+Object.defineProperty(MessagePort.prototype, handle_onclose, {\n+  enumerable: false,\n+  writable: false,\n+  value: onclose\n+});\n+\n+const originalClose = MessagePort.prototype.close;\n+MessagePort.prototype.close = function(cb) {\n+  if (typeof cb === 'function')\n+    this.once('close', cb);\n+  originalClose.call(this);\n+};\n+\n+function setupPortReferencing(port, eventEmitter, eventName) {\n+  // Keep track of whether there are any workerMessage listeners:\n+  // If there are some, ref() the channel so it keeps the event loop alive.\n+  // If there are none or all are removed, unref() the channel so the worker\n+  // can shutdown gracefully.\n+  port.unref();\n+  eventEmitter.on('newListener', (name) => {\n+    if (name === eventName && eventEmitter.listenerCount(eventName) === 0) {\n+      port.ref();\n+      port.start();\n+    }\n+  });\n+  eventEmitter.on('removeListener', (name) => {\n+    if (name === eventName && eventEmitter.listenerCount(eventName) === 0) {\n+      port.stop();\n+      port.unref();\n+    }\n+  });\n+}\n+\n+module.exports = {\n+  MessagePort,\n+  MessageChannel\n+};"
        },
        {
            "sha": "d67fb4efe40a3392827574165d43567028b10c3d",
            "filename": "lib/worker.js",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/lib%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fworker.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,5 @@\n+'use strict';\n+\n+const { MessagePort, MessageChannel } = require('internal/worker');\n+\n+module.exports = { MessagePort, MessageChannel };"
        },
        {
            "sha": "9a8dbf00cd9f157354e2ec8e49b554dcbda4c515",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -78,6 +78,7 @@\n       'lib/util.js',\n       'lib/v8.js',\n       'lib/vm.js',\n+      'lib/worker.js',\n       'lib/zlib.js',\n       'lib/internal/assert.js',\n       'lib/internal/async_hooks.js',\n@@ -156,6 +157,7 @@\n       'lib/internal/validators.js',\n       'lib/internal/stream_base_commons.js',\n       'lib/internal/vm/module.js',\n+      'lib/internal/worker.js',\n       'lib/internal/streams/lazy_transform.js',\n       'lib/internal/streams/async_iterator.js',\n       'lib/internal/streams/buffer_list.js',\n@@ -334,6 +336,7 @@\n         'src/node_file.cc',\n         'src/node_http2.cc',\n         'src/node_http_parser.cc',\n+        'src/node_messaging.cc',\n         'src/node_os.cc',\n         'src/node_platform.cc',\n         'src/node_perf.cc',\n@@ -391,6 +394,7 @@\n         'src/node_http2_state.h',\n         'src/node_internals.h',\n         'src/node_javascript.h',\n+        'src/node_messaging.h',\n         'src/node_mutex.h',\n         'src/node_perf.h',\n         'src/node_perf_common.h',"
        },
        {
            "sha": "cf269a4c1f5e1ec05afedfced6f1d75c6850da00",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -49,6 +49,7 @@ namespace node {\n   V(HTTP2SETTINGS)                                                            \\\n   V(HTTPPARSER)                                                               \\\n   V(JSSTREAM)                                                                 \\\n+  V(MESSAGEPORT)                                                              \\\n   V(PIPECONNECTWRAP)                                                          \\\n   V(PIPESERVERWRAP)                                                           \\\n   V(PIPEWRAP)                                                                 \\"
        },
        {
            "sha": "d87c39c5186bd75a7f4a53b08cd48c384a3d9060",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -193,6 +193,7 @@ struct PackageConfig {\n   V(main_string, \"main\")                                                      \\\n   V(max_buffer_string, \"maxBuffer\")                                           \\\n   V(message_string, \"message\")                                                \\\n+  V(message_port_constructor_string, \"MessagePort\")                           \\\n   V(minttl_string, \"minttl\")                                                  \\\n   V(modulus_string, \"modulus\")                                                \\\n   V(name_string, \"name\")                                                      \\\n@@ -212,6 +213,7 @@ struct PackageConfig {\n   V(onhandshakedone_string, \"onhandshakedone\")                                \\\n   V(onhandshakestart_string, \"onhandshakestart\")                              \\\n   V(onheaders_string, \"onheaders\")                                            \\\n+  V(oninit_string, \"oninit\")                                                  \\\n   V(onmessage_string, \"onmessage\")                                            \\\n   V(onnewsession_string, \"onnewsession\")                                      \\\n   V(onocspresponse_string, \"onocspresponse\")                                  \\\n@@ -242,6 +244,8 @@ struct PackageConfig {\n   V(pipe_target_string, \"pipeTarget\")                                         \\\n   V(pipe_source_string, \"pipeSource\")                                         \\\n   V(port_string, \"port\")                                                      \\\n+  V(port1_string, \"port1\")                                                    \\\n+  V(port2_string, \"port2\")                                                    \\\n   V(preference_string, \"preference\")                                          \\\n   V(priority_string, \"priority\")                                              \\\n   V(promise_string, \"promise\")                                                \\\n@@ -323,6 +327,7 @@ struct PackageConfig {\n   V(http2stream_constructor_template, v8::ObjectTemplate)                     \\\n   V(immediate_callback_function, v8::Function)                                \\\n   V(inspector_console_api_object, v8::Object)                                 \\\n+  V(message_port_constructor_template, v8::FunctionTemplate)                  \\\n   V(pbkdf2_constructor_template, v8::ObjectTemplate)                          \\\n   V(pipe_constructor_template, v8::FunctionTemplate)                          \\\n   V(performance_entry_callback, v8::Function)                                 \\"
        },
        {
            "sha": "baa97281b064a7892dfa006de501502d8fd9ba49",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -253,6 +253,11 @@ bool config_experimental_modules = false;\n // that is used by lib/vm.js\n bool config_experimental_vm_modules = false;\n \n+// Set in node.cc by ParseArgs when --experimental-worker is used.\n+// Used in node_config.cc to set a constant on process.binding('config')\n+// that is used by lib/worker.js\n+bool config_experimental_worker = false;\n+\n // Set in node.cc by ParseArgs when --experimental-repl-await is used.\n // Used in node_config.cc to set a constant on process.binding('config')\n // that is used by lib/repl.js.\n@@ -3094,6 +3099,7 @@ static void PrintHelp() {\n          \"  --experimental-vm-modules  experimental ES Module support\\n\"\n          \"                             in vm module\\n\"\n #endif  // defined(NODE_HAVE_I18N_SUPPORT)\n+         \"  --experimental-worker      experimental threaded Worker support\\n\"\n #if HAVE_OPENSSL && NODE_FIPS_MODE\n          \"  --force-fips               force FIPS crypto (cannot be disabled)\\n\"\n #endif  // HAVE_OPENSSL && NODE_FIPS_MODE\n@@ -3257,6 +3263,7 @@ static void CheckIfAllowedInEnv(const char* exe, bool is_env,\n     \"--experimental-modules\",\n     \"--experimental-repl-await\",\n     \"--experimental-vm-modules\",\n+    \"--experimental-worker\",\n     \"--force-fips\",\n     \"--icu-data-dir\",\n     \"--inspect\",\n@@ -3454,6 +3461,8 @@ static void ParseArgs(int* argc,\n       new_v8_argc += 1;\n     } else if (strcmp(arg, \"--experimental-vm-modules\") == 0) {\n       config_experimental_vm_modules = true;\n+    } else if (strcmp(arg, \"--experimental-worker\") == 0) {\n+      config_experimental_worker = true;\n     } else if (strcmp(arg, \"--experimental-repl-await\") == 0) {\n       config_experimental_repl_await = true;\n     }  else if (strcmp(arg, \"--loader\") == 0) {"
        },
        {
            "sha": "dd5ee666486874123dd42b8155789154db3a2fab",
            "filename": "src/node_config.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_config.cc",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_config.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_config.cc?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -91,6 +91,9 @@ static void Initialize(Local<Object> target,\n   if (config_experimental_vm_modules)\n     READONLY_BOOLEAN_PROPERTY(\"experimentalVMModules\");\n \n+  if (config_experimental_worker)\n+    READONLY_BOOLEAN_PROPERTY(\"experimentalWorker\");\n+\n   if (config_experimental_repl_await)\n     READONLY_BOOLEAN_PROPERTY(\"experimentalREPLAwait\");\n "
        },
        {
            "sha": "81169d241bc226ed5a6279833d0e0546ea353805",
            "filename": "src/node_errors.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_errors.h",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_errors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.h?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -23,9 +23,12 @@ namespace node {\n #define ERRORS_WITH_CODE(V)                                                  \\\n   V(ERR_BUFFER_OUT_OF_BOUNDS, RangeError)                                    \\\n   V(ERR_BUFFER_TOO_LARGE, Error)                                             \\\n+  V(ERR_CLOSED_MESSAGE_PORT, Error)                                          \\\n+  V(ERR_CONSTRUCT_CALL_REQUIRED, Error)                                      \\\n   V(ERR_INDEX_OUT_OF_RANGE, RangeError)                                      \\\n   V(ERR_INVALID_ARG_VALUE, TypeError)                                        \\\n   V(ERR_INVALID_ARG_TYPE, TypeError)                                         \\\n+  V(ERR_INVALID_TRANSFER_OBJECT, TypeError)                                  \\\n   V(ERR_MEMORY_ALLOCATION_FAILED, Error)                                     \\\n   V(ERR_MISSING_ARGS, TypeError)                                             \\\n   V(ERR_MISSING_MODULE, Error)                                               \\\n@@ -54,7 +57,10 @@ namespace node {\n // Errors with predefined static messages\n \n #define PREDEFINED_ERROR_MESSAGES(V)                                         \\\n+  V(ERR_CLOSED_MESSAGE_PORT, \"Cannot send data on closed MessagePort\")       \\\n+  V(ERR_CONSTRUCT_CALL_REQUIRED, \"Cannot call constructor without `new`\")    \\\n   V(ERR_INDEX_OUT_OF_RANGE, \"Index out of range\")                            \\\n+  V(ERR_INVALID_TRANSFER_OBJECT, \"Found invalid object in transferList\")     \\\n   V(ERR_MEMORY_ALLOCATION_FAILED, \"Failed to allocate memory\")               \\\n   V(ERR_SCRIPT_EXECUTION_INTERRUPTED,                                        \\\n     \"Script execution was interrupted by `SIGINT`\")"
        },
        {
            "sha": "a5d8ed0e5d3ad712a60f94924168149c9b58e0b5",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -114,6 +114,7 @@ struct sockaddr;\n     V(http_parser)                                                            \\\n     V(inspector)                                                              \\\n     V(js_stream)                                                              \\\n+    V(messaging)                                                              \\\n     V(module_wrap)                                                            \\\n     V(os)                                                                     \\\n     V(performance)                                                            \\\n@@ -189,6 +190,11 @@ extern bool config_experimental_modules;\n // that is used by lib/vm.js\n extern bool config_experimental_vm_modules;\n \n+// Set in node.cc by ParseArgs when --experimental-vm-modules is used.\n+// Used in node_config.cc to set a constant on process.binding('config')\n+// that is used by lib/vm.js\n+extern bool config_experimental_worker;\n+\n // Set in node.cc by ParseArgs when --experimental-repl-await is used.\n // Used in node_config.cc to set a constant on process.binding('config')\n // that is used by lib/repl.js."
        },
        {
            "sha": "c6e701c7d94426d323a070d5547694472d9c4687",
            "filename": "src/node_messaging.cc",
            "status": "added",
            "additions": 548,
            "deletions": 0,
            "changes": 548,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_messaging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_messaging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.cc?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,548 @@\n+#include \"node_messaging.h\"\n+#include \"node_internals.h\"\n+#include \"node_buffer.h\"\n+#include \"node_errors.h\"\n+#include \"util.h\"\n+#include \"util-inl.h\"\n+#include \"async_wrap.h\"\n+#include \"async_wrap-inl.h\"\n+\n+using v8::Array;\n+using v8::ArrayBuffer;\n+using v8::ArrayBufferCreationMode;\n+using v8::Context;\n+using v8::EscapableHandleScope;\n+using v8::Exception;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::FunctionTemplate;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Just;\n+using v8::Local;\n+using v8::Maybe;\n+using v8::MaybeLocal;\n+using v8::Nothing;\n+using v8::Object;\n+using v8::String;\n+using v8::Value;\n+using v8::ValueDeserializer;\n+using v8::ValueSerializer;\n+\n+namespace node {\n+namespace worker {\n+\n+Message::Message(MallocedBuffer<char>&& buffer)\n+    : main_message_buf_(std::move(buffer)) {}\n+\n+namespace {\n+\n+// This is used to tell V8 how to read transferred host objects, like other\n+// `MessagePort`s and `SharedArrayBuffer`s, and make new JS objects out of them.\n+class DeserializerDelegate : public ValueDeserializer::Delegate {\n+ public:\n+  DeserializerDelegate(Message* m, Environment* env)\n+    : env_(env), msg_(m) {}\n+\n+  ValueDeserializer* deserializer = nullptr;\n+\n+ private:\n+  Environment* env_;\n+  Message* msg_;\n+};\n+\n+}  // anonymous namespace\n+\n+MaybeLocal<Value> Message::Deserialize(Environment* env,\n+                                       Local<Context> context) {\n+  EscapableHandleScope handle_scope(env->isolate());\n+  Context::Scope context_scope(context);\n+\n+  DeserializerDelegate delegate(this, env);\n+  ValueDeserializer deserializer(\n+      env->isolate(),\n+      reinterpret_cast<const uint8_t*>(main_message_buf_.data),\n+      main_message_buf_.size,\n+      &delegate);\n+  delegate.deserializer = &deserializer;\n+\n+  // Attach all transfered ArrayBuffers to their new Isolate.\n+  for (uint32_t i = 0; i < array_buffer_contents_.size(); ++i) {\n+    Local<ArrayBuffer> ab =\n+        ArrayBuffer::New(env->isolate(),\n+                         array_buffer_contents_[i].release(),\n+                         array_buffer_contents_[i].size,\n+                         ArrayBufferCreationMode::kInternalized);\n+    deserializer.TransferArrayBuffer(i, ab);\n+  }\n+  array_buffer_contents_.clear();\n+\n+  if (deserializer.ReadHeader(context).IsNothing())\n+    return MaybeLocal<Value>();\n+  return handle_scope.Escape(\n+      deserializer.ReadValue(context).FromMaybe(Local<Value>()));\n+}\n+\n+namespace {\n+\n+// This tells V8 how to serialize objects that it does not understand\n+// (e.g. C++ objects) into the output buffer, in a way that our own\n+// DeserializerDelegate understands how to unpack.\n+class SerializerDelegate : public ValueSerializer::Delegate {\n+ public:\n+  SerializerDelegate(Environment* env, Local<Context> context, Message* m)\n+      : env_(env), context_(context), msg_(m) {}\n+\n+  void ThrowDataCloneError(Local<String> message) override {\n+    env_->isolate()->ThrowException(Exception::Error(message));\n+  }\n+\n+  ValueSerializer* serializer = nullptr;\n+\n+ private:\n+  Environment* env_;\n+  Local<Context> context_;\n+  Message* msg_;\n+\n+  friend class worker::Message;\n+};\n+\n+}  // anynomous namespace\n+\n+Maybe<bool> Message::Serialize(Environment* env,\n+                               Local<Context> context,\n+                               Local<Value> input,\n+                               Local<Value> transfer_list_v) {\n+  HandleScope handle_scope(env->isolate());\n+  Context::Scope context_scope(context);\n+\n+  // Verify that we're not silently overwriting an existing message.\n+  CHECK(main_message_buf_.is_empty());\n+\n+  SerializerDelegate delegate(env, context, this);\n+  ValueSerializer serializer(env->isolate(), &delegate);\n+  delegate.serializer = &serializer;\n+\n+  std::vector<Local<ArrayBuffer>> array_buffers;\n+  if (transfer_list_v->IsArray()) {\n+    Local<Array> transfer_list = transfer_list_v.As<Array>();\n+    uint32_t length = transfer_list->Length();\n+    for (uint32_t i = 0; i < length; ++i) {\n+      Local<Value> entry;\n+      if (!transfer_list->Get(context, i).ToLocal(&entry))\n+        return Nothing<bool>();\n+      // Currently, we support ArrayBuffers.\n+      if (entry->IsArrayBuffer()) {\n+        Local<ArrayBuffer> ab = entry.As<ArrayBuffer>();\n+        // If we cannot render the ArrayBuffer unusable in this Isolate and\n+        // take ownership of its memory, copying the buffer will have to do.\n+        if (!ab->IsNeuterable() || ab->IsExternal())\n+          continue;\n+        // We simply use the array index in the `array_buffers` list as the\n+        // ID that we write into the serialized buffer.\n+        uint32_t id = array_buffers.size();\n+        array_buffers.push_back(ab);\n+        serializer.TransferArrayBuffer(id, ab);\n+        continue;\n+      }\n+\n+      THROW_ERR_INVALID_TRANSFER_OBJECT(env);\n+      return Nothing<bool>();\n+    }\n+  }\n+\n+  serializer.WriteHeader();\n+  if (serializer.WriteValue(context, input).IsNothing()) {\n+    return Nothing<bool>();\n+  }\n+\n+  for (Local<ArrayBuffer> ab : array_buffers) {\n+    // If serialization succeeded, we want to take ownership of\n+    // (a.k.a. externalize) the underlying memory region and render\n+    // it inaccessible in this Isolate.\n+    ArrayBuffer::Contents contents = ab->Externalize();\n+    ab->Neuter();\n+    array_buffer_contents_.push_back(\n+        MallocedBuffer<char> { static_cast<char*>(contents.Data()),\n+                               contents.ByteLength() });\n+  }\n+\n+  // The serializer gave us a buffer allocated using `malloc()`.\n+  std::pair<uint8_t*, size_t> data = serializer.Release();\n+  main_message_buf_ =\n+      MallocedBuffer<char>(reinterpret_cast<char*>(data.first), data.second);\n+  return Just(true);\n+}\n+\n+MessagePortData::MessagePortData(MessagePort* owner) : owner_(owner) { }\n+\n+MessagePortData::~MessagePortData() {\n+  CHECK_EQ(owner_, nullptr);\n+  Disentangle();\n+}\n+\n+void MessagePortData::AddToIncomingQueue(Message&& message) {\n+  // This function will be called by other threads.\n+  Mutex::ScopedLock lock(mutex_);\n+  incoming_messages_.emplace_back(std::move(message));\n+\n+  if (owner_ != nullptr)\n+    owner_->TriggerAsync();\n+}\n+\n+bool MessagePortData::IsSiblingClosed() const {\n+  Mutex::ScopedLock lock(*sibling_mutex_);\n+  return sibling_ == nullptr;\n+}\n+\n+void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) {\n+  CHECK_EQ(a->sibling_, nullptr);\n+  CHECK_EQ(b->sibling_, nullptr);\n+  a->sibling_ = b;\n+  b->sibling_ = a;\n+  a->sibling_mutex_ = b->sibling_mutex_;\n+}\n+\n+void MessagePortData::PingOwnerAfterDisentanglement() {\n+  Mutex::ScopedLock lock(mutex_);\n+  if (owner_ != nullptr)\n+    owner_->TriggerAsync();\n+}\n+\n+void MessagePortData::Disentangle() {\n+  // Grab a copy of the sibling mutex, then replace it so that each sibling\n+  // has its own sibling_mutex_ now.\n+  std::shared_ptr<Mutex> sibling_mutex = sibling_mutex_;\n+  Mutex::ScopedLock sibling_lock(*sibling_mutex);\n+  sibling_mutex_ = std::make_shared<Mutex>();\n+\n+  MessagePortData* sibling = sibling_;\n+  if (sibling_ != nullptr) {\n+    sibling_->sibling_ = nullptr;\n+    sibling_ = nullptr;\n+  }\n+\n+  // We close MessagePorts after disentanglement, so we trigger the\n+  // corresponding uv_async_t to let them know that this happened.\n+  PingOwnerAfterDisentanglement();\n+  if (sibling != nullptr) {\n+    sibling->PingOwnerAfterDisentanglement();\n+  }\n+}\n+\n+MessagePort::~MessagePort() {\n+  if (data_)\n+    data_->owner_ = nullptr;\n+}\n+\n+MessagePort::MessagePort(Environment* env,\n+                         Local<Context> context,\n+                         Local<Object> wrap)\n+  : HandleWrap(env,\n+               wrap,\n+               reinterpret_cast<uv_handle_t*>(new uv_async_t()),\n+               AsyncWrap::PROVIDER_MESSAGEPORT),\n+    data_(new MessagePortData(this)) {\n+  auto onmessage = [](uv_async_t* handle) {\n+    // Called when data has been put into the queue.\n+    MessagePort* channel = static_cast<MessagePort*>(handle->data);\n+    channel->OnMessage();\n+  };\n+  CHECK_EQ(uv_async_init(env->event_loop(),\n+                         async(),\n+                         onmessage), 0);\n+  async()->data = static_cast<void*>(this);\n+\n+  Local<Value> fn;\n+  if (!wrap->Get(context, env->oninit_string()).ToLocal(&fn))\n+    return;\n+\n+  if (fn->IsFunction()) {\n+    Local<Function> init = fn.As<Function>();\n+    USE(init->Call(context, wrap, 0, nullptr));\n+  }\n+}\n+\n+void MessagePort::AddToIncomingQueue(Message&& message) {\n+  data_->AddToIncomingQueue(std::move(message));\n+}\n+\n+uv_async_t* MessagePort::async() {\n+  return reinterpret_cast<uv_async_t*>(GetHandle());\n+}\n+\n+void MessagePort::TriggerAsync() {\n+  CHECK_EQ(uv_async_send(async()), 0);\n+}\n+\n+void MessagePort::New(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  if (!args.IsConstructCall()) {\n+    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);\n+    return;\n+  }\n+\n+  Local<Context> context = args.This()->CreationContext();\n+  Context::Scope context_scope(context);\n+\n+  new MessagePort(env, context, args.This());\n+}\n+\n+MessagePort* MessagePort::New(\n+    Environment* env,\n+    Local<Context> context,\n+    std::unique_ptr<MessagePortData> data) {\n+  Context::Scope context_scope(context);\n+  Local<Function> ctor;\n+  if (!GetMessagePortConstructor(env, context).ToLocal(&ctor))\n+    return nullptr;\n+  MessagePort* port = nullptr;\n+\n+  // Construct a new instance, then assign the listener instance and possibly\n+  // the MessagePortData to it.\n+  Local<Object> instance;\n+  if (!ctor->NewInstance(context).ToLocal(&instance))\n+    return nullptr;\n+  ASSIGN_OR_RETURN_UNWRAP(&port, instance, nullptr);\n+  if (data) {\n+    port->Detach();\n+    port->data_ = std::move(data);\n+    port->data_->owner_ = port;\n+    // If the existing MessagePortData object had pending messages, this is\n+    // the easiest way to run that queue.\n+    port->TriggerAsync();\n+  }\n+  return port;\n+}\n+\n+void MessagePort::OnMessage() {\n+  HandleScope handle_scope(env()->isolate());\n+  Local<Context> context = object()->CreationContext();\n+\n+  // data_ can only ever be modified by the owner thread, so no need to lock.\n+  // However, the message port may be transferred while it is processing\n+  // messages, so we need to check that this handle still owns its `data_` field\n+  // on every iteration.\n+  while (data_) {\n+    Message received;\n+    {\n+      // Get the head of the message queue.\n+      Mutex::ScopedLock lock(data_->mutex_);\n+      if (!data_->receiving_messages_)\n+        break;\n+      if (data_->incoming_messages_.empty())\n+        break;\n+      received = std::move(data_->incoming_messages_.front());\n+      data_->incoming_messages_.pop_front();\n+    }\n+\n+    if (!env()->can_call_into_js()) {\n+      // In this case there is nothing to do but to drain the current queue.\n+      continue;\n+    }\n+\n+    {\n+      // Call the JS .onmessage() callback.\n+      HandleScope handle_scope(env()->isolate());\n+      Context::Scope context_scope(context);\n+      Local<Value> args[] = {\n+        received.Deserialize(env(), context).FromMaybe(Local<Value>())\n+      };\n+\n+      if (args[0].IsEmpty() ||\n+          !object()->Has(context, env()->onmessage_string()).FromMaybe(false) ||\n+          MakeCallback(env()->onmessage_string(), 1, args).IsEmpty()) {\n+        // Re-schedule OnMessage() execution in case of failure.\n+        if (data_)\n+          TriggerAsync();\n+        return;\n+      }\n+    }\n+  }\n+\n+  if (data_ && data_->IsSiblingClosed()) {\n+    Close();\n+  }\n+}\n+\n+bool MessagePort::IsSiblingClosed() const {\n+  CHECK(data_);\n+  return data_->IsSiblingClosed();\n+}\n+\n+void MessagePort::OnClose() {\n+  if (data_) {\n+    data_->owner_ = nullptr;\n+    data_->Disentangle();\n+  }\n+  data_.reset();\n+  delete async();\n+}\n+\n+std::unique_ptr<MessagePortData> MessagePort::Detach() {\n+  Mutex::ScopedLock lock(data_->mutex_);\n+  data_->owner_ = nullptr;\n+  return std::move(data_);\n+}\n+\n+\n+void MessagePort::Send(Message&& message) {\n+  Mutex::ScopedLock lock(*data_->sibling_mutex_);\n+  if (data_->sibling_ == nullptr)\n+    return;\n+  data_->sibling_->AddToIncomingQueue(std::move(message));\n+}\n+\n+void MessagePort::Send(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Message msg;\n+  if (msg.Serialize(env, object()->CreationContext(), args[0], args[1])\n+          .IsNothing()) {\n+    return;\n+  }\n+  Send(std::move(msg));\n+}\n+\n+void MessagePort::PostMessage(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  MessagePort* port;\n+  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());\n+  if (!port->data_) {\n+    return THROW_ERR_CLOSED_MESSAGE_PORT(env);\n+  }\n+  if (args.Length() == 0) {\n+    return THROW_ERR_MISSING_ARGS(env, \"Not enough arguments to \"\n+                                       \"MessagePort.postMessage\");\n+  }\n+  port->Send(args);\n+}\n+\n+void MessagePort::Start() {\n+  Mutex::ScopedLock lock(data_->mutex_);\n+  data_->receiving_messages_ = true;\n+  if (!data_->incoming_messages_.empty())\n+    TriggerAsync();\n+}\n+\n+void MessagePort::Stop() {\n+  Mutex::ScopedLock lock(data_->mutex_);\n+  data_->receiving_messages_ = false;\n+}\n+\n+void MessagePort::Start(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  MessagePort* port;\n+  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());\n+  if (!port->data_) {\n+    THROW_ERR_CLOSED_MESSAGE_PORT(env);\n+    return;\n+  }\n+  port->Start();\n+}\n+\n+void MessagePort::Stop(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  MessagePort* port;\n+  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());\n+  if (!port->data_) {\n+    THROW_ERR_CLOSED_MESSAGE_PORT(env);\n+    return;\n+  }\n+  port->Stop();\n+}\n+\n+size_t MessagePort::self_size() const {\n+  Mutex::ScopedLock lock(data_->mutex_);\n+  size_t sz = sizeof(*this) + sizeof(*data_);\n+  for (const Message& msg : data_->incoming_messages_)\n+    sz += sizeof(msg) + msg.main_message_buf_.size;\n+  return sz;\n+}\n+\n+void MessagePort::Entangle(MessagePort* a, MessagePort* b) {\n+  Entangle(a, b->data_.get());\n+}\n+\n+void MessagePort::Entangle(MessagePort* a, MessagePortData* b) {\n+  MessagePortData::Entangle(a->data_.get(), b);\n+}\n+\n+MaybeLocal<Function> GetMessagePortConstructor(\n+    Environment* env, Local<Context> context) {\n+  // Factor generating the MessagePort JS constructor into its own piece\n+  // of code, because it is needed early on in the child environment setup.\n+  Local<FunctionTemplate> templ = env->message_port_constructor_template();\n+  if (!templ.IsEmpty())\n+    return templ->GetFunction(context);\n+\n+  {\n+    Local<FunctionTemplate> m = env->NewFunctionTemplate(MessagePort::New);\n+    m->SetClassName(env->message_port_constructor_string());\n+    m->InstanceTemplate()->SetInternalFieldCount(1);\n+\n+    AsyncWrap::AddWrapMethods(env, m);\n+\n+    env->SetProtoMethod(m, \"postMessage\", MessagePort::PostMessage);\n+    env->SetProtoMethod(m, \"start\", MessagePort::Start);\n+    env->SetProtoMethod(m, \"stop\", MessagePort::Stop);\n+    env->SetProtoMethod(m, \"close\", HandleWrap::Close);\n+    env->SetProtoMethod(m, \"unref\", HandleWrap::Unref);\n+    env->SetProtoMethod(m, \"ref\", HandleWrap::Ref);\n+    env->SetProtoMethod(m, \"hasRef\", HandleWrap::HasRef);\n+\n+    env->set_message_port_constructor_template(m);\n+  }\n+\n+  return GetMessagePortConstructor(env, context);\n+}\n+\n+namespace {\n+\n+static void MessageChannel(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  if (!args.IsConstructCall()) {\n+    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);\n+    return;\n+  }\n+\n+  Local<Context> context = args.This()->CreationContext();\n+  Context::Scope context_scope(context);\n+\n+  MessagePort* port1 = MessagePort::New(env, context);\n+  MessagePort* port2 = MessagePort::New(env, context);\n+  MessagePort::Entangle(port1, port2);\n+\n+  args.This()->Set(env->context(), env->port1_string(), port1->object())\n+      .FromJust();\n+  args.This()->Set(env->context(), env->port2_string(), port2->object())\n+      .FromJust();\n+}\n+\n+static void InitMessaging(Local<Object> target,\n+                          Local<Value> unused,\n+                          Local<Context> context,\n+                          void* priv) {\n+  Environment* env = Environment::GetCurrent(context);\n+\n+  {\n+    Local<String> message_channel_string =\n+        FIXED_ONE_BYTE_STRING(env->isolate(), \"MessageChannel\");\n+    Local<FunctionTemplate> templ = env->NewFunctionTemplate(MessageChannel);\n+    templ->SetClassName(message_channel_string);\n+    target->Set(env->context(),\n+                message_channel_string,\n+                templ->GetFunction(context).ToLocalChecked()).FromJust();\n+  }\n+\n+  target->Set(context,\n+              env->message_port_constructor_string(),\n+              GetMessagePortConstructor(env, context).ToLocalChecked())\n+                  .FromJust();\n+}\n+\n+}  // anonymous namespace\n+\n+}  // namespace worker\n+}  // namespace node\n+\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(messaging, node::worker::InitMessaging)"
        },
        {
            "sha": "7bd60163ea167c929ea315bfe94755b1fcd4b729",
            "filename": "src/node_messaging.h",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_messaging.h",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Fnode_messaging.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.h?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,167 @@\n+#ifndef SRC_NODE_MESSAGING_H_\n+#define SRC_NODE_MESSAGING_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"env.h\"\n+#include \"node_mutex.h\"\n+#include <list>\n+#include <memory>\n+\n+namespace node {\n+namespace worker {\n+\n+class MessagePortData;\n+class MessagePort;\n+\n+// Represents a single communication message.\n+class Message {\n+ public:\n+  explicit Message(MallocedBuffer<char>&& payload = MallocedBuffer<char>());\n+\n+  Message(Message&& other) = default;\n+  Message& operator=(Message&& other) = default;\n+  Message& operator=(const Message&) = delete;\n+  Message(const Message&) = delete;\n+\n+  // Deserialize the contained JS value. May only be called once, and only\n+  // after Serialize() has been called (e.g. by another thread).\n+  v8::MaybeLocal<v8::Value> Deserialize(Environment* env,\n+                                        v8::Local<v8::Context> context);\n+\n+  // Serialize a JS value, and optionally transfer objects, into this message.\n+  // The Message object retains ownership of all transferred objects until\n+  // deserialization.\n+  v8::Maybe<bool> Serialize(Environment* env,\n+                            v8::Local<v8::Context> context,\n+                            v8::Local<v8::Value> input,\n+                            v8::Local<v8::Value> transfer_list);\n+\n+ private:\n+  MallocedBuffer<char> main_message_buf_;\n+  std::vector<MallocedBuffer<char>> array_buffer_contents_;\n+\n+  friend class MessagePort;\n+};\n+\n+// This contains all data for a `MessagePort` instance that is not tied to\n+// a specific Environment/Isolate/event loop, for easier transfer between those.\n+class MessagePortData {\n+ public:\n+  explicit MessagePortData(MessagePort* owner);\n+  ~MessagePortData();\n+\n+  MessagePortData(MessagePortData&& other) = delete;\n+  MessagePortData& operator=(MessagePortData&& other) = delete;\n+  MessagePortData(const MessagePortData& other) = delete;\n+  MessagePortData& operator=(const MessagePortData& other) = delete;\n+\n+  // Add a message to the incoming queue and notify the receiver.\n+  // This may be called from any thread.\n+  void AddToIncomingQueue(Message&& message);\n+\n+  // Returns true if and only this MessagePort is currently not entangled\n+  // with another message port.\n+  bool IsSiblingClosed() const;\n+\n+  // Turns `a` and `b` into siblings, i.e. connects the sending side of one\n+  // to the receiving side of the other. This is not thread-safe.\n+  static void Entangle(MessagePortData* a, MessagePortData* b);\n+\n+  // Removes any possible sibling. This is thread-safe (it acquires both\n+  // `sibling_mutex_` and `mutex_`), and has to be because it is called once\n+  // the corresponding JS handle handle wants to close\n+  // which can happen on either side of a worker.\n+  void Disentangle();\n+\n+ private:\n+  // After disentangling this message port, the owner handle (if any)\n+  // is asynchronously triggered, so that it can close down naturally.\n+  void PingOwnerAfterDisentanglement();\n+\n+  // This mutex protects all fields below it, with the exception of\n+  // sibling_.\n+  mutable Mutex mutex_;\n+  bool receiving_messages_ = false;\n+  std::list<Message> incoming_messages_;\n+  MessagePort* owner_ = nullptr;\n+  // This mutex protects the sibling_ field and is shared between two entangled\n+  // MessagePorts. If both mutexes are acquired, this one needs to be\n+  // acquired first.\n+  std::shared_ptr<Mutex> sibling_mutex_ = std::make_shared<Mutex>();\n+  MessagePortData* sibling_ = nullptr;\n+\n+  friend class MessagePort;\n+};\n+\n+// A message port that receives messages from other threads, including\n+// the uv_async_t handle that is used to notify the current event loop of\n+// new incoming messages.\n+class MessagePort : public HandleWrap {\n+ public:\n+  // Create a new MessagePort. The `context` argument specifies the Context\n+  // instance that is used for creating the values emitted from this port.\n+  MessagePort(Environment* env,\n+              v8::Local<v8::Context> context,\n+              v8::Local<v8::Object> wrap);\n+  ~MessagePort();\n+\n+  // Create a new message port instance, optionally over an existing\n+  // `MessagePortData` object.\n+  static MessagePort* New(Environment* env,\n+                          v8::Local<v8::Context> context,\n+                          std::unique_ptr<MessagePortData> data = nullptr);\n+\n+  // Send a message, i.e. deliver it into the sibling's incoming queue.\n+  // If there is no sibling, i.e. this port is closed,\n+  // this message is silently discarded.\n+  void Send(Message&& message);\n+  void Send(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  // Deliver a single message into this port's incoming queue.\n+  void AddToIncomingQueue(Message&& message);\n+\n+  // Start processing messages on this port as a receiving end.\n+  void Start();\n+  // Stop processing messages on this port as a receiving end.\n+  void Stop();\n+\n+  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void PostMessage(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Stop(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+  // Turns `a` and `b` into siblings, i.e. connects the sending side of one\n+  // to the receiving side of the other. This is not thread-safe.\n+  static void Entangle(MessagePort* a, MessagePort* b);\n+  static void Entangle(MessagePort* a, MessagePortData* b);\n+\n+  // Detach this port's data for transferring. After this, the MessagePortData\n+  // is no longer associated with this handle, although it can still receive\n+  // messages.\n+  std::unique_ptr<MessagePortData> Detach();\n+\n+  bool IsSiblingClosed() const;\n+\n+  size_t self_size() const override;\n+\n+ private:\n+  void OnClose() override;\n+  void OnMessage();\n+  void TriggerAsync();\n+  inline uv_async_t* async();\n+\n+  std::unique_ptr<MessagePortData> data_ = nullptr;\n+\n+  friend class MessagePortData;\n+};\n+\n+v8::MaybeLocal<v8::Function> GetMessagePortConstructor(\n+    Environment* env, v8::Local<v8::Context> context);\n+\n+}  // namespace worker\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+\n+#endif  // SRC_NODE_MESSAGING_H_"
        },
        {
            "sha": "fade27458f3e165d20ffde9c16a5c12194ae28db",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -436,8 +436,11 @@ struct MallocedBuffer {\n     return ret;\n   }\n \n+  inline bool is_empty() const { return data == nullptr; }\n+\n   MallocedBuffer() : data(nullptr) {}\n   explicit MallocedBuffer(size_t size) : data(Malloc<T>(size)), size(size) {}\n+  MallocedBuffer(char* data, size_t size) : data(data), size(size) {}\n   MallocedBuffer(MallocedBuffer&& other) : data(other.data), size(other.size) {\n     other.data = nullptr;\n   }"
        },
        {
            "sha": "0facaa1d835ea8716d3e5504520d8ce37a638703",
            "filename": "test/parallel/test-message-channel.js",
            "status": "added",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fparallel%2Ftest-message-channel.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fparallel%2Ftest-message-channel.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-message-channel.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,26 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { MessageChannel } = require('worker');\n+\n+{\n+  const channel = new MessageChannel();\n+\n+  channel.port1.on('message', common.mustCall(({ typedArray }) => {\n+    assert.deepStrictEqual(typedArray, new Uint8Array([0, 1, 2, 3, 4]));\n+  }));\n+\n+  const typedArray = new Uint8Array([0, 1, 2, 3, 4]);\n+  channel.port2.postMessage({ typedArray }, [ typedArray.buffer ]);\n+  assert.strictEqual(typedArray.buffer.byteLength, 0);\n+  channel.port2.close();\n+}\n+\n+{\n+  const channel = new MessageChannel();\n+\n+  channel.port1.on('close', common.mustCall());\n+  channel.port2.on('close', common.mustCall());\n+  channel.port2.close();\n+}"
        },
        {
            "sha": "4abeb585b4fb154a6bb260a58a8023a695cdb8a6",
            "filename": "test/parallel/test-message-port-arraybuffer.js",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fparallel%2Ftest-message-port-arraybuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fparallel%2Ftest-message-port-arraybuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-message-port-arraybuffer.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,20 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+\n+const { MessageChannel } = require('worker');\n+\n+{\n+  const { port1, port2 } = new MessageChannel();\n+\n+  const arrayBuffer = new ArrayBuffer(40);\n+  const typedArray = new Uint32Array(arrayBuffer);\n+  typedArray[0] = 0x12345678;\n+\n+  port1.postMessage(typedArray, [ arrayBuffer ]);\n+  port2.on('message', common.mustCall((received) => {\n+    assert.strictEqual(received[0], 0x12345678);\n+    port2.close(common.mustCall());\n+  }));\n+}"
        },
        {
            "sha": "8a7f3805200fa394c0626756f22a10cfc3cc57e1",
            "filename": "test/parallel/test-message-port.js",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fparallel%2Ftest-message-port.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fparallel%2Ftest-message-port.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-message-port.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -0,0 +1,56 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+\n+const { MessageChannel, MessagePort } = require('worker');\n+\n+{\n+  const { port1, port2 } = new MessageChannel();\n+  assert(port1 instanceof MessagePort);\n+  assert(port2 instanceof MessagePort);\n+\n+  const input = { a: 1 };\n+  port1.postMessage(input);\n+  port2.on('message', common.mustCall((received) => {\n+    assert.deepStrictEqual(received, input);\n+    port2.close(common.mustCall());\n+  }));\n+}\n+\n+{\n+  const { port1, port2 } = new MessageChannel();\n+\n+  const input = { a: 1 };\n+  port1.postMessage(input);\n+  // Check that the message still gets delivered if `port2` has its\n+  // `on('message')` handler attached at a later point in time.\n+  setImmediate(() => {\n+    port2.on('message', common.mustCall((received) => {\n+      assert.deepStrictEqual(received, input);\n+      port2.close(common.mustCall());\n+    }));\n+  });\n+}\n+\n+{\n+  const { port1, port2 } = new MessageChannel();\n+\n+  const input = { a: 1 };\n+\n+  const dummy = common.mustNotCall();\n+  // Check that the message still gets delivered if `port2` has its\n+  // `on('message')` handler attached at a later point in time, even if a\n+  // listener was removed previously.\n+  port2.addListener('message', dummy);\n+  setImmediate(() => {\n+    port2.removeListener('message', dummy);\n+    port1.postMessage(input);\n+    setImmediate(() => {\n+      port2.on('message', common.mustCall((received) => {\n+        assert.deepStrictEqual(received, input);\n+        port2.close(common.mustCall());\n+      }));\n+    });\n+  });\n+}"
        },
        {
            "sha": "84a3e3b1f4dc05992cdc2fc4998b3f2fa4034f1c",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -35,7 +35,9 @@ common.crashOnUnhandledRejection();\n     delete providers.HTTP2STREAM;\n     delete providers.HTTP2PING;\n     delete providers.HTTP2SETTINGS;\n+    // TODO(addaleax): Test for these\n     delete providers.STREAMPIPE;\n+    delete providers.MESSAGEPORT;\n \n     const objKeys = Object.keys(providers);\n     if (objKeys.length > 0)"
        },
        {
            "sha": "be72893832373a28ce0ef7c2666dc9906a228790",
            "filename": "tools/doc/type-parser.js",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/e7a2367471177c96f454a18319cf8d2fb25482f9/tools%2Fdoc%2Ftype-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7a2367471177c96f454a18319cf8d2fb25482f9/tools%2Fdoc%2Ftype-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Ftype-parser.js?ref=e7a2367471177c96f454a18319cf8d2fb25482f9",
            "patch": "@@ -117,7 +117,9 @@ const customTypesMap = {\n   'Tracing': 'tracing.html#tracing_tracing_object',\n \n   'URL': 'url.html#url_the_whatwg_url_api',\n-  'URLSearchParams': 'url.html#url_class_urlsearchparams'\n+  'URLSearchParams': 'url.html#url_class_urlsearchparams',\n+\n+  'MessagePort': 'worker.html#worker_class_messageport'\n };\n \n const arrayPart = /(?:\\[])+$/;"
        }
    ],
    "stats": {
        "total": 1142,
        "additions": 1140,
        "deletions": 2
    }
}