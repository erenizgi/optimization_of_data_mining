{
    "author": "antsmartian",
    "message": "util: handle null prototype on inspect\n\nThis makes sure the `null` prototype is always detected properly.\n\nPR-URL: https://github.com/nodejs/node/pull/22331\nFixes: https://github.com/nodejs/node/issues/22141\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>",
    "sha": "f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2",
    "files": [
        {
            "sha": "81d0f52fbf31cf061af39f6b72028118b16ffc9d",
            "filename": "lib/internal/util/inspect.js",
            "status": "modified",
            "additions": 64,
            "deletions": 23,
            "changes": 87,
            "blob_url": "https://github.com/nodejs/node/blob/f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2/lib%2Finternal%2Futil%2Finspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2/lib%2Finternal%2Futil%2Finspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Finspect.js?ref=f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2",
            "patch": "@@ -326,6 +326,7 @@ function getEmptyFormatArray() {\n }\n \n function getConstructorName(obj) {\n+  let firstProto;\n   while (obj) {\n     const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n     if (descriptor !== undefined &&\n@@ -335,25 +336,35 @@ function getConstructorName(obj) {\n     }\n \n     obj = Object.getPrototypeOf(obj);\n+    if (firstProto === undefined) {\n+      firstProto = obj;\n+    }\n+  }\n+\n+  if (firstProto === null) {\n+    return null;\n   }\n+  // TODO(BridgeAR): Improve prototype inspection.\n+  // We could use inspect on the prototype itself to improve the output.\n \n   return '';\n }\n \n function getPrefix(constructor, tag, fallback) {\n+  if (constructor === null) {\n+    if (tag !== '') {\n+      return `[${fallback}: null prototype] [${tag}] `;\n+    }\n+    return `[${fallback}: null prototype] `;\n+  }\n+\n   if (constructor !== '') {\n     if (tag !== '' && constructor !== tag) {\n       return `${constructor} [${tag}] `;\n     }\n     return `${constructor} `;\n   }\n \n-  if (tag !== '')\n-    return `[${tag}] `;\n-\n-  if (fallback !== undefined)\n-    return `${fallback} `;\n-\n   return '';\n }\n \n@@ -427,21 +438,49 @@ function findTypedConstructor(value) {\n   }\n }\n \n+let lazyNullPrototypeCache;\n+// Creates a subclass and name\n+// the constructor as `${clazz} : null prototype`\n+function clazzWithNullPrototype(clazz, name) {\n+  if (lazyNullPrototypeCache === undefined) {\n+    lazyNullPrototypeCache = new Map();\n+  } else {\n+    const cachedClass = lazyNullPrototypeCache.get(clazz);\n+    if (cachedClass !== undefined) {\n+      return cachedClass;\n+    }\n+  }\n+  class NullPrototype extends clazz {\n+    get [Symbol.toStringTag]() {\n+      return '';\n+    }\n+  }\n+  Object.defineProperty(NullPrototype.prototype.constructor, 'name',\n+                        { value: `[${name}: null prototype]` });\n+  lazyNullPrototypeCache.set(clazz, NullPrototype);\n+  return NullPrototype;\n+}\n+\n function noPrototypeIterator(ctx, value, recurseTimes) {\n   let newVal;\n-  // TODO: Create a Subclass in case there's no prototype and show\n-  // `null-prototype`.\n   if (isSet(value)) {\n-    const clazz = Object.getPrototypeOf(value) || Set;\n+    const clazz = Object.getPrototypeOf(value) ||\n+      clazzWithNullPrototype(Set, 'Set');\n     newVal = new clazz(setValues(value));\n   } else if (isMap(value)) {\n-    const clazz = Object.getPrototypeOf(value) || Map;\n+    const clazz = Object.getPrototypeOf(value) ||\n+      clazzWithNullPrototype(Map, 'Map');\n     newVal = new clazz(mapEntries(value));\n   } else if (Array.isArray(value)) {\n-    const clazz = Object.getPrototypeOf(value) || Array;\n+    const clazz = Object.getPrototypeOf(value) ||\n+      clazzWithNullPrototype(Array, 'Array');\n     newVal = new clazz(value.length || 0);\n   } else if (isTypedArray(value)) {\n-    const clazz = findTypedConstructor(value) || Uint8Array;\n+    let clazz = Object.getPrototypeOf(value);\n+    if (!clazz) {\n+      const constructor = findTypedConstructor(value);\n+      clazz = clazzWithNullPrototype(constructor, constructor.name);\n+    }\n     newVal = new clazz(value);\n   }\n   if (newVal) {\n@@ -527,29 +566,32 @@ function formatRaw(ctx, value, recurseTimes) {\n     if (Array.isArray(value)) {\n       keys = getOwnNonIndexProperties(value, filter);\n       // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n-      const prefix = getPrefix(constructor, tag);\n+      const prefix = getPrefix(constructor, tag, 'Array');\n       braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n       if (value.length === 0 && keys.length === 0)\n         return `${braces[0]}]`;\n       extrasType = kArrayExtrasType;\n       formatter = formatArray;\n     } else if (isSet(value)) {\n       keys = getKeys(value, ctx.showHidden);\n-      const prefix = getPrefix(constructor, tag);\n+      const prefix = getPrefix(constructor, tag, 'Set');\n       if (value.size === 0 && keys.length === 0)\n         return `${prefix}{}`;\n       braces = [`${prefix}{`, '}'];\n       formatter = formatSet;\n     } else if (isMap(value)) {\n       keys = getKeys(value, ctx.showHidden);\n-      const prefix = getPrefix(constructor, tag);\n+      const prefix = getPrefix(constructor, tag, 'Map');\n       if (value.size === 0 && keys.length === 0)\n         return `${prefix}{}`;\n       braces = [`${prefix}{`, '}'];\n       formatter = formatMap;\n     } else if (isTypedArray(value)) {\n       keys = getOwnNonIndexProperties(value, filter);\n-      braces = [`${getPrefix(constructor, tag)}[`, ']'];\n+      const prefix = constructor !== null ?\n+        getPrefix(constructor, tag) :\n+        getPrefix(constructor, tag, findTypedConstructor(value).name);\n+      braces = [`${prefix}[`, ']'];\n       if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n         return `${braces[0]}]`;\n       formatter = formatTypedArray;\n@@ -575,7 +617,7 @@ function formatRaw(ctx, value, recurseTimes) {\n           return '[Arguments] {}';\n         braces[0] = '[Arguments] {';\n       } else if (tag !== '') {\n-        braces[0] = `${getPrefix(constructor, tag)}{`;\n+        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;\n         if (keys.length === 0) {\n           return `${braces[0]}}`;\n         }\n@@ -622,13 +664,12 @@ function formatRaw(ctx, value, recurseTimes) {\n         base = `[${base.slice(0, stackStart)}]`;\n       }\n     } else if (isAnyArrayBuffer(value)) {\n-      let prefix = getPrefix(constructor, tag);\n-      if (prefix === '') {\n-        prefix = isArrayBuffer(value) ? 'ArrayBuffer ' : 'SharedArrayBuffer ';\n-      }\n       // Fast path for ArrayBuffer and SharedArrayBuffer.\n       // Can't do the same for DataView because it has a non-primitive\n       // .buffer property that we need to recurse for.\n+      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n+        'SharedArrayBuffer';\n+      const prefix = getPrefix(constructor, tag, arrayType);\n       if (keys.length === 0)\n         return prefix +\n               `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n@@ -693,9 +734,9 @@ function formatRaw(ctx, value, recurseTimes) {\n       } else if (keys.length === 0) {\n         if (isExternal(value))\n           return ctx.stylize('[External]', 'special');\n-        return `${getPrefix(constructor, tag)}{}`;\n+        return `${getPrefix(constructor, tag, 'Object')}{}`;\n       } else {\n-        braces[0] = `${getPrefix(constructor, tag)}{`;\n+        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;\n       }\n     }\n   }"
        },
        {
            "sha": "c0fc3219ce736feda2d1c0ee719ba407784483e8",
            "filename": "test/parallel/test-util-inspect.js",
            "status": "modified",
            "additions": 78,
            "deletions": 20,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2/test%2Fparallel%2Ftest-util-inspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2/test%2Fparallel%2Ftest-util-inspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect.js?ref=f4e4ef5cadf462c38353497c8e16c9cc3b64a5f2",
            "patch": "@@ -25,7 +25,7 @@\n const common = require('../common');\n const assert = require('assert');\n const { internalBinding } = require('internal/test/binding');\n-const { JSStream } = internalBinding('js_stream');\n+const JSStream = process.binding('js_stream').JSStream;\n const util = require('util');\n const vm = require('vm');\n const { previewEntries } = internalBinding('util');\n@@ -261,15 +261,15 @@ assert.strictEqual(\n     name: { value: 'Tim', enumerable: true },\n     hidden: { value: 'secret' }\n   }), { showHidden: true }),\n-  \"{ name: 'Tim', [hidden]: 'secret' }\"\n+  \"[Object: null prototype] { name: 'Tim', [hidden]: 'secret' }\"\n );\n \n assert.strictEqual(\n   util.inspect(Object.create(null, {\n     name: { value: 'Tim', enumerable: true },\n     hidden: { value: 'secret' }\n   })),\n-  \"{ name: 'Tim' }\"\n+  \"[Object: null prototype] { name: 'Tim' }\"\n );\n \n // Dynamic properties.\n@@ -505,11 +505,17 @@ assert.strictEqual(util.inspect(-5e-324), '-5e-324');\n       set: function() {}\n     }\n   });\n-  assert.strictEqual(util.inspect(getter, true), '{ [a]: [Getter] }');\n-  assert.strictEqual(util.inspect(setter, true), '{ [b]: [Setter] }');\n+  assert.strictEqual(\n+    util.inspect(getter, true),\n+    '[Object: null prototype] { [a]: [Getter] }'\n+  );\n+  assert.strictEqual(\n+    util.inspect(setter, true),\n+    '[Object: null prototype] { [b]: [Setter] }'\n+  );\n   assert.strictEqual(\n     util.inspect(getterAndSetter, true),\n-    '{ [c]: [Getter/Setter] }'\n+    '[Object: null prototype] { [c]: [Getter/Setter] }'\n   );\n }\n \n@@ -1084,7 +1090,7 @@ if (typeof Symbol !== 'undefined') {\n \n {\n   const x = Object.create(null);\n-  assert.strictEqual(util.inspect(x), '{}');\n+  assert.strictEqual(util.inspect(x), '[Object: null prototype] {}');\n }\n \n {\n@@ -1224,7 +1230,7 @@ util.inspect(process);\n \n   assert.strictEqual(util.inspect(\n     Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } })),\n-                     '[foo] {}');\n+                     '[Object: null prototype] [foo] {}');\n \n   assert.strictEqual(util.inspect(new Foo()), \"Foo [bar] { foo: 'bar' }\");\n \n@@ -1574,20 +1580,12 @@ assert.strictEqual(util.inspect('\"\\''), '`\"\\'`');\n // eslint-disable-next-line no-template-curly-in-string\n assert.strictEqual(util.inspect('\"\\'${a}'), \"'\\\"\\\\'${a}'\");\n \n-// Verify the output in case the value has no prototype.\n-// Sadly, these cases can not be fully inspected :(\n-[\n-  [/a/, '/undefined/undefined'],\n-  [new DataView(new ArrayBuffer(2)),\n-   'DataView {\\n  byteLength: undefined,\\n  byteOffset: undefined,\\n  ' +\n-     'buffer: undefined }'],\n-  [new SharedArrayBuffer(2), 'SharedArrayBuffer { byteLength: undefined }']\n-].forEach(([value, expected]) => {\n+{\n   assert.strictEqual(\n-    util.inspect(Object.setPrototypeOf(value, null)),\n-    expected\n+    util.inspect(Object.setPrototypeOf(/a/, null)),\n+    '/undefined/undefined'\n   );\n-});\n+}\n \n // Verify that throwing in valueOf and having no prototype still produces nice\n // results.\n@@ -1623,6 +1621,39 @@ assert.strictEqual(util.inspect('\"\\'${a}'), \"'\\\"\\\\'${a}'\");\n     }\n   });\n   assert.strictEqual(util.inspect(value), expected);\n+  value.foo = 'bar';\n+  assert.notStrictEqual(util.inspect(value), expected);\n+  delete value.foo;\n+  value[Symbol('foo')] = 'yeah';\n+  assert.notStrictEqual(util.inspect(value), expected);\n+});\n+\n+[\n+  [[1, 3, 4], '[Array: null prototype] [ 1, 3, 4 ]'],\n+  [new Set([1, 2]), '[Set: null prototype] { 1, 2 }'],\n+  [new Map([[1, 2]]), '[Map: null prototype] { 1 => 2 }'],\n+  [new Promise((resolve) => setTimeout(resolve, 10)),\n+   '[Promise: null prototype] { <pending> }'],\n+  [new WeakSet(), '[WeakSet: null prototype] { <items unknown> }'],\n+  [new WeakMap(), '[WeakMap: null prototype] { <items unknown> }'],\n+  [new Uint8Array(2), '[Uint8Array: null prototype] [ 0, 0 ]'],\n+  [new Uint16Array(2), '[Uint16Array: null prototype] [ 0, 0 ]'],\n+  [new Uint32Array(2), '[Uint32Array: null prototype] [ 0, 0 ]'],\n+  [new Int8Array(2), '[Int8Array: null prototype] [ 0, 0 ]'],\n+  [new Int16Array(2), '[Int16Array: null prototype] [ 0, 0 ]'],\n+  [new Int32Array(2), '[Int32Array: null prototype] [ 0, 0 ]'],\n+  [new Float32Array(2), '[Float32Array: null prototype] [ 0, 0 ]'],\n+  [new Float64Array(2), '[Float64Array: null prototype] [ 0, 0 ]'],\n+  [new BigInt64Array(2), '[BigInt64Array: null prototype] [ 0n, 0n ]'],\n+  [new BigUint64Array(2), '[BigUint64Array: null prototype] [ 0n, 0n ]'],\n+  [new ArrayBuffer(16), '[ArrayBuffer: null prototype] ' +\n+   '{ byteLength: undefined }'],\n+  [new DataView(new ArrayBuffer(16)),\n+   '[DataView: null prototype] {\\n  byteLength: undefined,\\n  ' +\n+    'byteOffset: undefined,\\n  buffer: undefined }'],\n+  [new SharedArrayBuffer(2), '[SharedArrayBuffer: null prototype] ' +\n+  '{ byteLength: undefined }']\n+].forEach(([value, expected]) => {\n   assert.strictEqual(\n     util.inspect(Object.setPrototypeOf(value, null)),\n     expected\n@@ -1706,3 +1737,30 @@ assert.strictEqual(\n     '[ 3, 2, 1, [Symbol(a)]: false, [Symbol(b)]: true, a: 1, b: 2, c: 3 ]'\n   );\n }\n+\n+// Manipulate the prototype to one that we can not handle.\n+{\n+  let obj = { a: true };\n+  let value = (function() { return function() {}; })();\n+  Object.setPrototypeOf(value, null);\n+  Object.setPrototypeOf(obj, value);\n+  assert.strictEqual(util.inspect(obj), '{ a: true }');\n+\n+  obj = { a: true };\n+  value = [];\n+  Object.setPrototypeOf(value, null);\n+  Object.setPrototypeOf(obj, value);\n+  assert.strictEqual(util.inspect(obj), '{ a: true }');\n+}\n+\n+// Check that the fallback always works.\n+{\n+  const obj = new Set([1, 2]);\n+  const iterator = obj[Symbol.iterator];\n+  Object.setPrototypeOf(obj, null);\n+  Object.defineProperty(obj, Symbol.iterator, {\n+    value: iterator,\n+    configurable: true\n+  });\n+  assert.strictEqual(util.inspect(obj), '[Set: null prototype] { 1, 2 }');\n+}"
        }
    ],
    "stats": {
        "total": 185,
        "additions": 142,
        "deletions": 43
    }
}