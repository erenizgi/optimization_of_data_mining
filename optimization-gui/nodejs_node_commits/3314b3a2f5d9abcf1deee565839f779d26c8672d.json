{
    "author": "kenny-y",
    "message": "benchmark: add n-api function args benchmark\n\nThis benchmark suite is added to measure the performance of n-api\nfunction call with various type/number of arguments. The cases in\nthis suite are carefully selected to efficiently show the performance\ntrend.\n\nPR-URL: https://github.com/nodejs/node/pull/21555\nReviewed-By: Gabriel Schulhof <gabriel.schulhof@intel.com>\nReviewed-By: Kyle Farnung <kfarnung@microsoft.com>",
    "sha": "3314b3a2f5d9abcf1deee565839f779d26c8672d",
    "files": [
        {
            "sha": "634eec5151dc44ea49aa5c3e20eb98efc02b853b",
            "filename": "Makefile",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/3314b3a2f5d9abcf1deee565839f779d26c8672d/Makefile",
            "raw_url": "https://github.com/nodejs/node/raw/3314b3a2f5d9abcf1deee565839f779d26c8672d/Makefile",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/Makefile?ref=3314b3a2f5d9abcf1deee565839f779d26c8672d",
            "patch": "@@ -305,6 +305,15 @@ benchmark/napi/function_call/build/Release/binding.node: all \\\n \t\t--directory=\"$(shell pwd)/benchmark/napi/function_call\" \\\n \t\t--nodedir=\"$(shell pwd)\"\n \n+benchmark/napi/function_args/build/Release/binding.node: all \\\n+\t\tbenchmark/napi/function_args/napi_binding.c \\\n+\t\tbenchmark/napi/function_args/binding.cc \\\n+\t\tbenchmark/napi/function_args/binding.gyp\n+\t$(NODE) deps/npm/node_modules/node-gyp/bin/node-gyp rebuild \\\n+\t\t--python=\"$(PYTHON)\" \\\n+\t\t--directory=\"$(shell pwd)/benchmark/napi/function_args\" \\\n+\t\t--nodedir=\"$(shell pwd)\"\n+\n # Implicitly depends on $(NODE_EXE).  We don't depend on it explicitly because\n # it always triggers a rebuild due to it being a .PHONY rule.  See the comment\n # near the build-addons rule for more background."
        },
        {
            "sha": "567609b1234a9b8806c5a05da6c866e480aa148d",
            "filename": "benchmark/napi/function_args/.gitignore",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2F.gitignore",
            "raw_url": "https://github.com/nodejs/node/raw/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2F.gitignore",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnapi%2Ffunction_args%2F.gitignore?ref=3314b3a2f5d9abcf1deee565839f779d26c8672d",
            "patch": "@@ -0,0 +1 @@\n+build/"
        },
        {
            "sha": "11eb394a6a98f5c6b0ecf27938ecc795bd45e4aa",
            "filename": "benchmark/napi/function_args/binding.cc",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/nodejs/node/blob/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Fbinding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Fbinding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnapi%2Ffunction_args%2Fbinding.cc?ref=3314b3a2f5d9abcf1deee565839f779d26c8672d",
            "patch": "@@ -0,0 +1,142 @@\n+#include <v8.h>\n+#include <node.h>\n+#include <assert.h>\n+\n+using v8::Isolate;\n+using v8::Context;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::Value;\n+using v8::Number;\n+using v8::String;\n+using v8::Object;\n+using v8::Array;\n+using v8::ArrayBufferView;\n+using v8::ArrayBuffer;\n+using v8::FunctionCallbackInfo;\n+\n+void CallWithString(const FunctionCallbackInfo<Value>& args) {\n+  assert(args.Length() == 1 && args[0]->IsString());\n+  if (args.Length() == 1 && args[0]->IsString()) {\n+    Local<String> str = args[0].As<String>();\n+    const int32_t length = str->Utf8Length() + 1;\n+    char* buf = new char[length];\n+    str->WriteUtf8(buf, length);\n+    delete [] buf;\n+  }\n+}\n+\n+void CallWithArray(const FunctionCallbackInfo<Value>& args) {\n+  assert(args.Length() == 1 && args[0]->IsArray());\n+  if (args.Length() == 1 && args[0]->IsArray()) {\n+    const Local<Array> array = args[0].As<Array>();\n+    uint32_t length = array->Length();\n+    for (uint32_t i = 0; i < length; ++ i) {\n+      Local<Value> v;\n+      v = array->Get(i);\n+    }\n+  }\n+}\n+\n+void CallWithNumber(const FunctionCallbackInfo<Value>& args) {\n+  assert(args.Length() == 1 && args[0]->IsNumber());\n+  if (args.Length() == 1 && args[0]->IsNumber()) {\n+    args[0].As<Number>()->Value();\n+  }\n+}\n+\n+void CallWithObject(const FunctionCallbackInfo<Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  Local<Context> context = isolate->GetCurrentContext();\n+\n+  assert(args.Length() == 1 && args[0]->IsObject());\n+  if (args.Length() == 1 && args[0]->IsObject()) {\n+    Local<Object> obj = args[0].As<Object>();\n+\n+    MaybeLocal<String> map_key = String::NewFromUtf8(isolate,\n+        \"map\", v8::NewStringType::kNormal);\n+    assert(!map_key.IsEmpty());\n+    MaybeLocal<Value> map_maybe = obj->Get(context,\n+        map_key.ToLocalChecked());\n+    assert(!map_maybe.IsEmpty());\n+    Local<Value> map;\n+    map = map_maybe.ToLocalChecked();\n+\n+    MaybeLocal<String> operand_key = String::NewFromUtf8(isolate,\n+        \"operand\", v8::NewStringType::kNormal);\n+    assert(!operand_key.IsEmpty());\n+    MaybeLocal<Value> operand_maybe = obj->Get(context,\n+        operand_key.ToLocalChecked());\n+    assert(!operand_maybe.IsEmpty());\n+    Local<Value> operand;\n+    operand = operand_maybe.ToLocalChecked();\n+\n+    MaybeLocal<String> data_key = String::NewFromUtf8(isolate,\n+        \"data\", v8::NewStringType::kNormal);\n+    assert(!data_key.IsEmpty());\n+    MaybeLocal<Value> data_maybe = obj->Get(context,\n+        data_key.ToLocalChecked());\n+    assert(!data_maybe.IsEmpty());\n+    Local<Value> data;\n+    data = data_maybe.ToLocalChecked();\n+\n+    MaybeLocal<String> reduce_key = String::NewFromUtf8(isolate,\n+        \"reduce\", v8::NewStringType::kNormal);\n+    assert(!reduce_key.IsEmpty());\n+    MaybeLocal<Value> reduce_maybe = obj->Get(context,\n+        reduce_key.ToLocalChecked());\n+    assert(!reduce_maybe.IsEmpty());\n+    Local<Value> reduce;\n+    reduce = reduce_maybe.ToLocalChecked();\n+  }\n+}\n+\n+void CallWithTypedarray(const FunctionCallbackInfo<Value>& args) {\n+  assert(args.Length() == 1 && args[0]->IsArrayBufferView());\n+  if (args.Length() == 1 && args[0]->IsArrayBufferView()) {\n+    assert(args[0]->IsArrayBufferView());\n+    Local<ArrayBufferView> view = args[0].As<ArrayBufferView>();\n+    const size_t byte_offset = view->ByteOffset();\n+    const size_t byte_length = view->ByteLength();\n+    assert(byte_length > 0);\n+    assert(view->HasBuffer());\n+    Local<ArrayBuffer> buffer;\n+    buffer = view->Buffer();\n+    ArrayBuffer::Contents contents;\n+    contents = buffer->GetContents();\n+    const uint32_t* data = reinterpret_cast<uint32_t*>(\n+        static_cast<uint8_t*>(contents.Data()) + byte_offset);\n+    assert(data);\n+  }\n+}\n+\n+void CallWithArguments(const FunctionCallbackInfo<Value>& args) {\n+  assert(args.Length() > 1 && args[0]->IsNumber());\n+  if (args.Length() > 1 && args[0]->IsNumber()) {\n+    int32_t loop = args[0].As<v8::Uint32>()->Value();\n+    for (int32_t i = 1; i < loop; ++i) {\n+      assert(i < args.Length());\n+      assert(args[i]->IsUint32());\n+      args[i].As<v8::Uint32>()->Value();\n+    }\n+  }\n+}\n+\n+void Initialize(Local<Object> target) {\n+  NODE_SET_METHOD(target, \"callWithString\", CallWithString);\n+  NODE_SET_METHOD(target, \"callWithLongString\", CallWithString);\n+\n+  NODE_SET_METHOD(target, \"callWithArray\", CallWithArray);\n+  NODE_SET_METHOD(target, \"callWithLargeArray\", CallWithArray);\n+  NODE_SET_METHOD(target, \"callWithHugeArray\", CallWithArray);\n+\n+  NODE_SET_METHOD(target, \"callWithNumber\", CallWithNumber);\n+  NODE_SET_METHOD(target, \"callWithObject\", CallWithObject);\n+  NODE_SET_METHOD(target, \"callWithTypedarray\", CallWithTypedarray);\n+\n+  NODE_SET_METHOD(target, \"callWith10Numbers\", CallWithArguments);\n+  NODE_SET_METHOD(target, \"callWith100Numbers\", CallWithArguments);\n+  NODE_SET_METHOD(target, \"callWith1000Numbers\", CallWithArguments);\n+}\n+\n+NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)"
        },
        {
            "sha": "ac122ed1a07962a116f6c41ce5f13184802632f7",
            "filename": "benchmark/napi/function_args/binding.gyp",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Fbinding.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Fbinding.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnapi%2Ffunction_args%2Fbinding.gyp?ref=3314b3a2f5d9abcf1deee565839f779d26c8672d",
            "patch": "@@ -0,0 +1,12 @@\n+{\n+  'targets': [\n+    {\n+      'target_name': 'napi_binding',\n+      'sources': [ 'napi_binding.c' ]\n+    },\n+    {\n+      'target_name': 'binding',\n+      'sources': [ 'binding.cc' ]\n+    }\n+  ]\n+}"
        },
        {
            "sha": "c8f281a3429fdedd38b2511f432e7abcd0df6f42",
            "filename": "benchmark/napi/function_args/index.js",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Findex.js",
            "raw_url": "https://github.com/nodejs/node/raw/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Findex.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnapi%2Ffunction_args%2Findex.js?ref=3314b3a2f5d9abcf1deee565839f779d26c8672d",
            "patch": "@@ -0,0 +1,99 @@\n+// show the difference between calling a V8 binding C++ function\n+// relative to a comparable N-API C++ function,\n+// in various types/numbers of arguments.\n+// Reports n of calls per second.\n+'use strict';\n+\n+const common = require('../../common.js');\n+\n+let v8;\n+let napi;\n+\n+try {\n+  v8 = require('./build/Release/binding');\n+} catch (err) {\n+  // eslint-disable-next-line no-path-concat\n+  console.error(__filename + ': V8 Binding failed to load');\n+  process.exit(0);\n+}\n+\n+try {\n+  napi = require('./build/Release/napi_binding');\n+} catch (err) {\n+  // eslint-disable-next-line no-path-concat\n+  console.error(__filename + ': NAPI-Binding failed to load');\n+  process.exit(0);\n+}\n+\n+const argsTypes = ['String', 'Number', 'Object', 'Array', 'Typedarray',\n+                   '10Numbers', '100Numbers', '1000Numbers'];\n+\n+const generateArgs = (argType) => {\n+  let args = [];\n+\n+  if (argType === 'String') {\n+    args.push('The quick brown fox jumps over the lazy dog');\n+  } else if (argType === 'LongString') {\n+    args.push(Buffer.alloc(32768, '42').toString());\n+  } else if (argType === 'Number') {\n+    args.push(Math.floor(314158964 * Math.random()));\n+  } else if (argType === 'Object') {\n+    args.push({\n+      map: 'add',\n+      operand: 10,\n+      data: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n+      reduce: 'add',\n+    });\n+  } else if (argType === 'Array') {\n+    const arr = [];\n+    for (let i = 0; i < 50; ++i) {\n+      arr.push(Math.random() * 10e9);\n+    }\n+    args.push(arr);\n+  } else if (argType === 'Typedarray') {\n+    const arr = new Uint32Array(1000);\n+    for (let i = 0; i < 1000; ++i) {\n+      arr[i] = Math.random() * 4294967296;\n+    }\n+    args.push(arr);\n+  } else if (argType === '10Numbers') {\n+    args.push(10);\n+    for (let i = 0; i < 9; ++i) {\n+      args = [...args, ...generateArgs('Number')];\n+    }\n+  } else if (argType === '100Numbers') {\n+    args.push(100);\n+    for (let i = 0; i < 99; ++i) {\n+      args = [...args, ...generateArgs('Number')];\n+    }\n+  } else if (argType === '1000Numbers') {\n+    args.push(1000);\n+    for (let i = 0; i < 999; ++i) {\n+      args = [...args, ...generateArgs('Number')];\n+    }\n+  }\n+\n+  return args;\n+};\n+\n+const bench = common.createBenchmark(main, {\n+  type: argsTypes,\n+  engine: ['v8', 'napi'],\n+  n: [1, 1e1, 1e2, 1e3, 1e4, 1e5],\n+});\n+\n+function main({ n, engine, type }) {\n+  const bindings = engine === 'v8' ? v8 : napi;\n+  const methodName = 'callWith' + type;\n+  const fn = bindings[methodName];\n+\n+  if (fn) {\n+    const args = generateArgs(type);\n+\n+    bench.start();\n+    for (var i = 0; i < n; i++) {\n+      fn.apply(null, args);\n+    }\n+    bench.end(n);\n+  }\n+}"
        },
        {
            "sha": "b697644ca441e98f540b51092dbd68d22263cc2b",
            "filename": "benchmark/napi/function_args/napi_binding.c",
            "status": "added",
            "additions": 229,
            "deletions": 0,
            "changes": 229,
            "blob_url": "https://github.com/nodejs/node/blob/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Fnapi_binding.c",
            "raw_url": "https://github.com/nodejs/node/raw/3314b3a2f5d9abcf1deee565839f779d26c8672d/benchmark%2Fnapi%2Ffunction_args%2Fnapi_binding.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fnapi%2Ffunction_args%2Fnapi_binding.c?ref=3314b3a2f5d9abcf1deee565839f779d26c8672d",
            "patch": "@@ -0,0 +1,229 @@\n+#include <node_api.h>\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+static napi_value CallWithString(napi_env env, napi_callback_info info) {\n+  napi_status status;\n+\n+  size_t argc = 1;\n+  napi_value args[1];\n+  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);\n+  assert(status == napi_ok);\n+\n+  napi_valuetype types[1];\n+  status = napi_typeof(env, args[0], types);\n+  assert(status == napi_ok);\n+\n+  assert(types[0] == napi_string);\n+  if (types[0] == napi_string) {\n+    size_t len = 0;\n+    // Get the length\n+    status = napi_get_value_string_utf8(env, args[0], NULL, 0, &len);\n+    assert(status == napi_ok);\n+    char* buf = (char*)malloc(len + 1);\n+    status = napi_get_value_string_utf8(env, args[0], buf, len + 1, &len);\n+    assert(status == napi_ok);\n+    free(buf);\n+  }\n+\n+  return NULL;\n+}\n+\n+static napi_value CallWithArray(napi_env env, napi_callback_info info) {\n+  napi_status status;\n+\n+  size_t argc = 1;\n+  napi_value args[1];\n+  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);\n+  assert(status == napi_ok);\n+\n+  napi_value array = args[0];\n+  bool is_array = false;\n+  status = napi_is_array(env, array, &is_array);\n+  assert(status == napi_ok);\n+\n+  assert(is_array);\n+  if (is_array) {\n+    uint32_t length;\n+    status = napi_get_array_length(env, array, &length);\n+    assert(status == napi_ok);\n+\n+    for (uint32_t i = 0; i < length; ++i) {\n+      napi_value v;\n+      status = napi_get_element(env, array, i, &v);\n+      assert(status == napi_ok);\n+    }\n+  }\n+\n+  return NULL;\n+}\n+\n+static napi_value CallWithNumber(napi_env env, napi_callback_info info) {\n+  napi_status status;\n+\n+  size_t argc = 1;\n+  napi_value args[1];\n+  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);\n+  assert(status == napi_ok);\n+\n+  napi_valuetype types[1];\n+  status = napi_typeof(env, args[0], types);\n+  assert(status == napi_ok);\n+\n+  assert(types[0] == napi_number);\n+  if (types[0] == napi_number) {\n+    double value = 0.0;\n+    status = napi_get_value_double(env, args[0], &value);\n+    assert(status == napi_ok);\n+  }\n+\n+  return NULL;\n+}\n+\n+static napi_value CallWithObject(napi_env env, napi_callback_info info) {\n+  napi_status status;\n+\n+  size_t argc = 1;\n+  napi_value args[1];\n+  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);\n+  assert(status == napi_ok);\n+\n+  napi_valuetype types[1];\n+  status = napi_typeof(env, args[0], types);\n+  assert(status == napi_ok);\n+\n+  assert(argc == 1 && types[0] == napi_object);\n+  if (argc == 1 && types[0] == napi_object) {\n+    napi_value value;\n+\n+    status = napi_get_named_property(env, args[0], \"map\", &value);\n+    assert(status == napi_ok);\n+\n+    status = napi_get_named_property(env, args[0], \"operand\", &value);\n+    assert(status == napi_ok);\n+\n+    status = napi_get_named_property(env, args[0], \"data\", &value);\n+    assert(status == napi_ok);\n+\n+    status = napi_get_named_property(env, args[0], \"reduce\", &value);\n+    assert(status == napi_ok);\n+  }\n+\n+  return NULL;\n+}\n+\n+static napi_value CallWithTypedarray(napi_env env, napi_callback_info info) {\n+  napi_status status;\n+\n+  size_t argc = 1;\n+  napi_value args[1];\n+  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);\n+  assert(status == napi_ok);\n+\n+  bool is_typedarray = false;\n+  status = napi_is_typedarray(env, args[0], &is_typedarray);\n+  assert(status == napi_ok);\n+\n+  assert(is_typedarray);\n+  if (is_typedarray) {\n+    napi_typedarray_type type;\n+    napi_value input_buffer;\n+    size_t byte_offset = 0;\n+    size_t length = 0;\n+    status = napi_get_typedarray_info(env, args[0], &type, &length,\n+        NULL, &input_buffer, &byte_offset);\n+    assert(status == napi_ok);\n+    assert(length > 0);\n+\n+    void* data = NULL;\n+    size_t byte_length = 0;\n+    status = napi_get_arraybuffer_info(env,\n+        input_buffer, &data, &byte_length);\n+    assert(status == napi_ok);\n+\n+    uint32_t* input_integers = (uint32_t*)((uint8_t*)(data) + byte_offset);\n+    assert(input_integers);\n+  }\n+\n+  return NULL;\n+}\n+\n+static napi_value CallWithArguments(napi_env env, napi_callback_info info) {\n+  napi_status status;\n+\n+  size_t argc = 1;\n+  napi_value args[1000];\n+  // Get the length\n+  status = napi_get_cb_info(env, info, &argc, NULL, NULL, NULL);\n+  assert(status == napi_ok);\n+\n+  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);\n+  assert(status == napi_ok);\n+  assert(argc <= 1000);\n+\n+  napi_valuetype types[1];\n+  status = napi_typeof(env, args[0], types);\n+  assert(status == napi_ok);\n+\n+  assert(argc > 1 && types[0] == napi_number);\n+  if (argc > 1 && types[0] == napi_number) {\n+    uint32_t loop = 0;\n+    status = napi_get_value_uint32(env, args[0], &loop);\n+    assert(status == napi_ok);\n+\n+    for (uint32_t i = 1; i < loop; ++i) {\n+      assert(i < argc);\n+      status = napi_typeof(env, args[i], types);\n+      assert(status == napi_ok);\n+      assert(types[0] == napi_number);\n+\n+      uint32_t value = 0;\n+      status = napi_get_value_uint32(env, args[i], &value);\n+      assert(status == napi_ok);\n+    }\n+  }\n+\n+  return NULL;\n+}\n+\n+\n+#define EXPORT_FUNC(env, exports, name, func)       \\\n+  do {                                              \\\n+    napi_status status;                             \\\n+    napi_value js_func;                             \\\n+    status = napi_create_function((env),            \\\n+                                  (name),           \\\n+                                  NAPI_AUTO_LENGTH, \\\n+                                  (func),           \\\n+                                  NULL,             \\\n+                                  &js_func);        \\\n+    assert(status == napi_ok);                      \\\n+    status = napi_set_named_property((env),         \\\n+                                     (exports),     \\\n+                                     (name),        \\\n+                                     js_func);      \\\n+    assert(status == napi_ok);                      \\\n+  } while (0);\n+\n+\n+NAPI_MODULE_INIT() {\n+  EXPORT_FUNC(env, exports, \"callWithString\", CallWithString);\n+  EXPORT_FUNC(env, exports, \"callWithLongString\", CallWithString);\n+\n+  EXPORT_FUNC(env, exports, \"callWithArray\", CallWithArray);\n+  EXPORT_FUNC(env, exports, \"callWithLargeArray\", CallWithArray);\n+  EXPORT_FUNC(env, exports, \"callWithHugeArray\", CallWithArray);\n+\n+  EXPORT_FUNC(env, exports, \"callWithNumber\", CallWithNumber);\n+\n+  EXPORT_FUNC(env, exports, \"callWithObject\", CallWithObject);\n+  EXPORT_FUNC(env, exports, \"callWithTypedarray\", CallWithTypedarray);\n+\n+  EXPORT_FUNC(env, exports, \"callWith10Numbers\", CallWithArguments);\n+  EXPORT_FUNC(env, exports, \"callWith100Numbers\", CallWithArguments);\n+  EXPORT_FUNC(env, exports, \"callWith1000Numbers\", CallWithArguments);\n+\n+  return exports;\n+}"
        }
    ],
    "stats": {
        "total": 492,
        "additions": 492,
        "deletions": 0
    }
}