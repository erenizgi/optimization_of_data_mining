{
    "author": "addaleax",
    "message": "worker: set up child Isolate inside Worker thread\n\nRefs: https://github.com/nodejs/node/issues/24016\n\nPR-URL: https://github.com/nodejs/node/pull/26011\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "5bc6e493c0642dd65e458026b8145f266d7d5417",
    "files": [
        {
            "sha": "8d7aad70e600e404bee91ae6ba521db46a432403",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=5bc6e493c0642dd65e458026b8145f266d7d5417",
            "patch": "@@ -885,12 +885,14 @@ bool Agent::IsActive() {\n   return io_ != nullptr || client_->IsActive();\n }\n \n-void Agent::AddWorkerInspector(int thread_id,\n-                               const std::string& url,\n-                               Agent* agent) {\n-  CHECK_NOT_NULL(client_);\n-  agent->parent_handle_ =\n-      client_->getWorkerManager()->NewParentHandle(thread_id, url);\n+void Agent::SetParentHandle(\n+    std::unique_ptr<ParentInspectorHandle> parent_handle) {\n+  parent_handle_ = std::move(parent_handle);\n+}\n+\n+std::unique_ptr<ParentInspectorHandle> Agent::GetParentHandle(\n+    int thread_id, const std::string& url) {\n+  return client_->getWorkerManager()->NewParentHandle(thread_id, url);\n }\n \n void Agent::WaitForConnect() {"
        },
        {
            "sha": "905b1e2841ebc8551154ae29b33435cea551d60b",
            "filename": "src/inspector_agent.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Finspector_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Finspector_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.h?ref=5bc6e493c0642dd65e458026b8145f266d7d5417",
            "patch": "@@ -85,7 +85,9 @@ class Agent {\n   void EnableAsyncHook();\n   void DisableAsyncHook();\n \n-  void AddWorkerInspector(int thread_id, const std::string& url, Agent* agent);\n+  void SetParentHandle(std::unique_ptr<ParentInspectorHandle> parent_handle);\n+  std::unique_ptr<ParentInspectorHandle> GetParentHandle(\n+      int thread_id, const std::string& url);\n \n   // Called to create inspector sessions that can be used from the main thread.\n   // The inspector responds by using the delegate to send messages back."
        },
        {
            "sha": "ebd1924b8f2479cb38422aeb9154c73570a17c91",
            "filename": "src/node_worker.cc",
            "status": "modified",
            "additions": 176,
            "deletions": 157,
            "changes": 333,
            "blob_url": "https://github.com/nodejs/node/blob/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Fnode_worker.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Fnode_worker.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.cc?ref=5bc6e493c0642dd65e458026b8145f266d7d5417",
            "patch": "@@ -8,6 +8,10 @@\n #include \"async_wrap.h\"\n #include \"async_wrap-inl.h\"\n \n+#if NODE_USE_V8_PLATFORM && HAVE_INSPECTOR\n+#include \"inspector/worker_inspector.h\"  // ParentInspectorHandle\n+#endif\n+\n #include <string>\n #include <vector>\n \n@@ -35,34 +39,21 @@ namespace worker {\n namespace {\n \n #if NODE_USE_V8_PLATFORM && HAVE_INSPECTOR\n-void StartWorkerInspector(Environment* child, const std::string& url) {\n+void StartWorkerInspector(\n+    Environment* child,\n+    std::unique_ptr<inspector::ParentInspectorHandle> parent_handle,\n+    const std::string& url) {\n+  child->inspector_agent()->SetParentHandle(std::move(parent_handle));\n   child->inspector_agent()->Start(url,\n                                   child->options()->debug_options(),\n                                   child->inspector_host_port(),\n                                   false);\n }\n \n-void AddWorkerInspector(Environment* parent,\n-                        Environment* child,\n-                        int id,\n-                        const std::string& url) {\n-  parent->inspector_agent()->AddWorkerInspector(id, url,\n-                                                child->inspector_agent());\n-}\n-\n void WaitForWorkerInspectorToStop(Environment* child) {\n   child->inspector_agent()->WaitForDisconnect();\n   child->inspector_agent()->Stop();\n }\n-\n-#else\n-// No-ops\n-void StartWorkerInspector(Environment* child, const std::string& url) {}\n-void AddWorkerInspector(Environment* parent,\n-                        Environment* child,\n-                        int id,\n-                        const std::string& url) {}\n-void WaitForWorkerInspectorToStop(Environment* child) {}\n #endif\n \n }  // anonymous namespace\n@@ -71,9 +62,13 @@ Worker::Worker(Environment* env,\n                Local<Object> wrap,\n                const std::string& url,\n                std::shared_ptr<PerIsolateOptions> per_isolate_opts)\n-    : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER), url_(url),\n+    : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER),\n+      url_(url),\n+      per_isolate_opts_(per_isolate_opts),\n+      platform_(env->isolate_data()->platform()),\n+      profiler_idle_notifier_started_(env->profiler_idle_notifier_started()),\n       thread_id_(Environment::AllocateThreadId()) {\n-  Debug(this, \"Creating new worker instance at %p\", static_cast<void*>(this));\n+  Debug(this, \"Creating new worker instance with thread id %llu\", thread_id_);\n \n   // Set up everything that needs to be set up in the parent environment.\n   parent_port_ = MessagePort::New(env, env->context());\n@@ -89,72 +84,97 @@ Worker::Worker(Environment* env,\n                 env->message_port_string(),\n                 parent_port_->object()).FromJust();\n \n-  array_buffer_allocator_.reset(CreateArrayBufferAllocator());\n-\n-  CHECK_EQ(uv_loop_init(&loop_), 0);\n-  isolate_ = NewIsolate(array_buffer_allocator_.get(), &loop_);\n-  CHECK_NOT_NULL(isolate_);\n-\n-  {\n-    // Enter an environment capable of executing code in the child Isolate\n-    // (and only in it).\n-    Locker locker(isolate_);\n-    Isolate::Scope isolate_scope(isolate_);\n-    HandleScope handle_scope(isolate_);\n-\n-    isolate_data_.reset(CreateIsolateData(isolate_,\n-                                          &loop_,\n-                                          env->isolate_data()->platform(),\n-                                          array_buffer_allocator_.get()));\n-    if (per_isolate_opts != nullptr) {\n-      isolate_data_->set_options(per_isolate_opts);\n-    }\n-    CHECK(isolate_data_);\n-\n-    Local<Context> context = NewContext(isolate_);\n-    Context::Scope context_scope(context);\n-\n-    // TODO(addaleax): Use CreateEnvironment(), or generally another public API.\n-    env_.reset(new Environment(\n-        isolate_data_.get(), context, Flags::kNoFlags, thread_id_));\n-    CHECK_NOT_NULL(env_);\n-    env_->set_abort_on_uncaught_exception(false);\n-    env_->set_worker_context(this);\n-\n-    env_->Start(env->profiler_idle_notifier_started());\n-    env_->ProcessCliArgs(std::vector<std::string>{},\n-                            std::vector<std::string>{});\n-    // Done while on the parent thread\n-    AddWorkerInspector(env, env_.get(), thread_id_, url_);\n-  }\n-\n-  // The new isolate won't be bothered on this thread again.\n-  isolate_->DiscardThreadSpecificMetadata();\n-\n-  wrap->Set(env->context(),\n-            env->thread_id_string(),\n-            Number::New(env->isolate(), static_cast<double>(thread_id_)))\n+  object()->Set(env->context(),\n+                env->thread_id_string(),\n+                Number::New(env->isolate(), static_cast<double>(thread_id_)))\n       .FromJust();\n \n-  Debug(this,\n-        \"Set up worker at %p with id %llu\",\n-        static_cast<void*>(this),\n-        thread_id_);\n+#if NODE_USE_V8_PLATFORM && HAVE_INSPECTOR\n+  inspector_parent_handle_ =\n+      env->inspector_agent()->GetParentHandle(thread_id_, url);\n+#endif\n+\n+  Debug(this, \"Preparation for worker %llu finished\", thread_id_);\n }\n \n bool Worker::is_stopped() const {\n   Mutex::ScopedLock stopped_lock(stopped_mutex_);\n   return stopped_;\n }\n \n+// This class contains data that is only relevant to the child thread itself,\n+// and only while it is running.\n+// (Eventually, the Environment instance should probably also be moved here.)\n+class WorkerThreadData {\n+ public:\n+  explicit WorkerThreadData(Worker* w)\n+    : w_(w),\n+      array_buffer_allocator_(CreateArrayBufferAllocator()) {\n+    CHECK_EQ(uv_loop_init(&loop_), 0);\n+\n+    Isolate* isolate = NewIsolate(array_buffer_allocator_.get(), &loop_);\n+    CHECK_NOT_NULL(isolate);\n+\n+    {\n+      Locker locker(isolate);\n+      Isolate::Scope isolate_scope(isolate);\n+      HandleScope handle_scope(isolate);\n+      isolate_data_.reset(CreateIsolateData(isolate,\n+                                            &loop_,\n+                                            w_->platform_,\n+                                            array_buffer_allocator_.get()));\n+      CHECK(isolate_data_);\n+      if (w_->per_isolate_opts_)\n+        isolate_data_->set_options(std::move(w_->per_isolate_opts_));\n+    }\n+\n+    Mutex::ScopedLock lock(w_->mutex_);\n+    w_->isolate_ = isolate;\n+  }\n+\n+  ~WorkerThreadData() {\n+    Debug(w_, \"Worker %llu dispose isolate\", w_->thread_id_);\n+    Isolate* isolate;\n+    {\n+      Mutex::ScopedLock lock(w_->mutex_);\n+      isolate = w_->isolate_;\n+      w_->isolate_ = nullptr;\n+    }\n+\n+    w_->platform_->CancelPendingDelayedTasks(isolate);\n+\n+    isolate_data_.reset();\n+    w_->platform_->UnregisterIsolate(isolate);\n+\n+    isolate->Dispose();\n+\n+    // Need to run the loop one more time to close the platform's uv_async_t\n+    uv_run(&loop_, UV_RUN_ONCE);\n+\n+    CheckedUvLoopClose(&loop_);\n+  }\n+\n+ private:\n+  Worker* const w_;\n+  uv_loop_t loop_;\n+  DeleteFnPtr<ArrayBufferAllocator, FreeArrayBufferAllocator>\n+    array_buffer_allocator_;\n+  DeleteFnPtr<IsolateData, FreeIsolateData> isolate_data_;\n+\n+  friend class Worker;\n+};\n+\n void Worker::Run() {\n   std::string name = \"WorkerThread \";\n   name += std::to_string(thread_id_);\n   TRACE_EVENT_METADATA1(\n       \"__metadata\", \"thread_name\", \"name\",\n       TRACE_STR_COPY(name.c_str()));\n-  MultiIsolatePlatform* platform = isolate_data_->platform();\n-  CHECK_NOT_NULL(platform);\n+  CHECK_NOT_NULL(platform_);\n+\n+  Debug(this, \"Creating isolate for worker with id %llu\", thread_id_);\n+\n+  WorkerThreadData data(this);\n \n   Debug(this, \"Starting worker with id %llu\", thread_id_);\n   {\n@@ -163,10 +183,73 @@ void Worker::Run() {\n     SealHandleScope outer_seal(isolate_);\n     bool inspector_started = false;\n \n+    DeleteFnPtr<Environment, FreeEnvironment> env_;\n+    OnScopeLeave cleanup_env([&]() {\n+      if (!env_) return;\n+      env_->set_can_call_into_js(false);\n+      Isolate::DisallowJavascriptExecutionScope disallow_js(isolate_,\n+          Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);\n+\n+      // Grab the parent-to-child channel and render is unusable.\n+      MessagePort* child_port;\n+      {\n+        Mutex::ScopedLock lock(mutex_);\n+        child_port = child_port_;\n+        child_port_ = nullptr;\n+      }\n+\n+      {\n+        Context::Scope context_scope(env_->context());\n+        if (child_port != nullptr)\n+          child_port->Close();\n+        env_->stop_sub_worker_contexts();\n+        env_->RunCleanup();\n+        RunAtExit(env_.get());\n+#if NODE_USE_V8_PLATFORM && HAVE_INSPECTOR\n+        if (inspector_started)\n+          WaitForWorkerInspectorToStop(env_.get());\n+#endif\n+\n+        {\n+          Mutex::ScopedLock stopped_lock(stopped_mutex_);\n+          stopped_ = true;\n+        }\n+\n+        env_->RunCleanup();\n+\n+        // This call needs to be made while the `Environment` is still alive\n+        // because we assume that it is available for async tracking in the\n+        // NodePlatform implementation.\n+        platform_->DrainTasks(isolate_);\n+      }\n+    });\n+\n     {\n-      Context::Scope context_scope(env_->context());\n       HandleScope handle_scope(isolate_);\n+      Local<Context> context = NewContext(isolate_);\n+      if (is_stopped()) return;\n+\n+      CHECK(!context.IsEmpty());\n+      Context::Scope context_scope(context);\n+      {\n+        // TODO(addaleax): Use CreateEnvironment(), or generally another\n+        // public API.\n+        env_.reset(new Environment(data.isolate_data_.get(),\n+                                   context,\n+                                   Environment::kNoFlags,\n+                                   thread_id_));\n+        CHECK_NOT_NULL(env_);\n+        env_->set_abort_on_uncaught_exception(false);\n+        env_->set_worker_context(this);\n+\n+        env_->Start(profiler_idle_notifier_started_);\n+        env_->ProcessCliArgs(std::vector<std::string>{},\n+                             std::vector<std::string>{});\n+      }\n+\n+      Debug(this, \"Created Environment for worker with id %llu\", thread_id_);\n \n+      if (is_stopped()) return;\n       {\n         HandleScope handle_scope(isolate_);\n         Mutex::ScopedLock lock(mutex_);\n@@ -182,8 +265,13 @@ void Worker::Run() {\n         Debug(this, \"Created message port for worker %llu\", thread_id_);\n       }\n \n-      if (!is_stopped()) {\n-        StartWorkerInspector(env_.get(), url_);\n+      if (is_stopped()) return;\n+      {\n+#if NODE_USE_V8_PLATFORM && HAVE_INSPECTOR\n+        StartWorkerInspector(env_.get(),\n+                             std::move(inspector_parent_handle_),\n+                             url_);\n+#endif\n         inspector_started = true;\n \n         HandleScope handle_scope(isolate_);\n@@ -198,27 +286,28 @@ void Worker::Run() {\n         Debug(this, \"Loaded environment for worker %llu\", thread_id_);\n       }\n \n+      if (is_stopped()) return;\n       {\n         SealHandleScope seal(isolate_);\n         bool more;\n         env_->performance_state()->Mark(\n             node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);\n         do {\n           if (is_stopped()) break;\n-          uv_run(&loop_, UV_RUN_DEFAULT);\n+          uv_run(&data.loop_, UV_RUN_DEFAULT);\n           if (is_stopped()) break;\n \n-          platform->DrainTasks(isolate_);\n+          platform_->DrainTasks(isolate_);\n \n-          more = uv_loop_alive(&loop_);\n+          more = uv_loop_alive(&data.loop_);\n           if (more && !is_stopped())\n             continue;\n \n           EmitBeforeExit(env_.get());\n \n           // Emit `beforeExit` if the loop became alive either after emitting\n           // event, or after running some callbacks.\n-          more = uv_loop_alive(&loop_);\n+          more = uv_loop_alive(&data.loop_);\n         } while (more == true);\n         env_->performance_state()->Mark(\n             node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);\n@@ -237,79 +326,11 @@ void Worker::Run() {\n       Debug(this, \"Exiting thread for worker %llu with exit code %d\",\n             thread_id_, exit_code_);\n     }\n-\n-    env_->set_can_call_into_js(false);\n-    Isolate::DisallowJavascriptExecutionScope disallow_js(isolate_,\n-        Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);\n-\n-    // Grab the parent-to-child channel and render is unusable.\n-    MessagePort* child_port;\n-    {\n-      Mutex::ScopedLock lock(mutex_);\n-      child_port = child_port_;\n-      child_port_ = nullptr;\n-    }\n-\n-    {\n-      Context::Scope context_scope(env_->context());\n-      child_port->Close();\n-      env_->stop_sub_worker_contexts();\n-      env_->RunCleanup();\n-      RunAtExit(env_.get());\n-      if (inspector_started)\n-        WaitForWorkerInspectorToStop(env_.get());\n-\n-      {\n-        Mutex::ScopedLock stopped_lock(stopped_mutex_);\n-        stopped_ = true;\n-      }\n-\n-      env_->RunCleanup();\n-\n-      // This call needs to be made while the `Environment` is still alive\n-      // because we assume that it is available for async tracking in the\n-      // NodePlatform implementation.\n-      platform->DrainTasks(isolate_);\n-    }\n-\n-    env_.reset();\n-  }\n-\n-  DisposeIsolate();\n-\n-  {\n-    Mutex::ScopedLock lock(mutex_);\n-    CHECK(thread_exit_async_);\n-    scheduled_on_thread_stopped_ = true;\n-    uv_async_send(thread_exit_async_.get());\n   }\n \n   Debug(this, \"Worker %llu thread stops\", thread_id_);\n }\n \n-void Worker::DisposeIsolate() {\n-  if (env_) {\n-    CHECK_NOT_NULL(isolate_);\n-    Locker locker(isolate_);\n-    Isolate::Scope isolate_scope(isolate_);\n-    env_.reset();\n-  }\n-\n-  if (isolate_ == nullptr)\n-    return;\n-\n-  Debug(this, \"Worker %llu dispose isolate\", thread_id_);\n-  CHECK(isolate_data_);\n-  MultiIsolatePlatform* platform = isolate_data_->platform();\n-  platform->CancelPendingDelayedTasks(isolate_);\n-\n-  isolate_data_.reset();\n-  platform->UnregisterIsolate(isolate_);\n-\n-  isolate_->Dispose();\n-  isolate_ = nullptr;\n-}\n-\n void Worker::JoinThread() {\n   if (thread_joined_)\n     return;\n@@ -340,7 +361,6 @@ void Worker::OnThreadStopped() {\n       CHECK(stopped_);\n     }\n \n-    CHECK_NULL(child_port_);\n     parent_port_ = nullptr;\n   }\n \n@@ -370,16 +390,9 @@ Worker::~Worker() {\n \n   CHECK(stopped_);\n   CHECK(thread_joined_);\n-  CHECK_NULL(child_port_);\n \n   // This has most likely already happened within the worker thread -- this\n   // is just in case Worker creation failed early.\n-  DisposeIsolate();\n-\n-  // Need to run the loop one more time to close the platform's uv_async_t\n-  uv_run(&loop_, UV_RUN_ONCE);\n-\n-  CheckedUvLoopClose(&loop_);\n \n   Debug(this, \"Worker %llu destroyed\", thread_id_);\n }\n@@ -476,7 +489,13 @@ void Worker::StartThread(const FunctionCallbackInfo<Value>& args) {\n   }), 0);\n \n   CHECK_EQ(uv_thread_create(&w->tid_, [](void* arg) {\n-    static_cast<Worker*>(arg)->Run();\n+    Worker* w = static_cast<Worker*>(arg);\n+    w->Run();\n+\n+    Mutex::ScopedLock lock(w->mutex_);\n+    CHECK(w->thread_exit_async_);\n+    w->scheduled_on_thread_stopped_ = true;\n+    uv_async_send(w->thread_exit_async_.get());\n   }, static_cast<void*>(w)), 0);\n }\n \n@@ -510,12 +529,12 @@ void Worker::Exit(int code) {\n   Debug(this, \"Worker %llu called Exit(%d)\", thread_id_, code);\n \n   if (!stopped_) {\n-    CHECK_NOT_NULL(env_);\n     stopped_ = true;\n     exit_code_ = code;\n     if (child_port_ != nullptr)\n       child_port_->StopEventLoop();\n-    isolate_->TerminateExecution();\n+    if (isolate_ != nullptr)\n+      isolate_->TerminateExecution();\n   }\n }\n "
        },
        {
            "sha": "4d7a7335ca6d63a92cd2a232ef8eece88fa41f6d",
            "filename": "src/node_worker.h",
            "status": "modified",
            "additions": 14,
            "deletions": 8,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Fnode_worker.h",
            "raw_url": "https://github.com/nodejs/node/raw/5bc6e493c0642dd65e458026b8145f266d7d5417/src%2Fnode_worker.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.h?ref=5bc6e493c0642dd65e458026b8145f266d7d5417",
            "patch": "@@ -9,6 +9,8 @@\n namespace node {\n namespace worker {\n \n+class WorkerThreadData;\n+\n // A worker thread, as represented in its parent thread.\n class Worker : public AsyncWrap {\n  public:\n@@ -49,17 +51,19 @@ class Worker : public AsyncWrap {\n \n  private:\n   void OnThreadStopped();\n-  void DisposeIsolate();\n \n-  uv_loop_t loop_;\n-  DeleteFnPtr<IsolateData, FreeIsolateData> isolate_data_;\n-  DeleteFnPtr<Environment, FreeEnvironment> env_;\n   const std::string url_;\n+\n+  std::shared_ptr<PerIsolateOptions> per_isolate_opts_;\n+  MultiIsolatePlatform* platform_;\n   v8::Isolate* isolate_ = nullptr;\n-  DeleteFnPtr<ArrayBufferAllocator, FreeArrayBufferAllocator>\n-      array_buffer_allocator_;\n+  bool profiler_idle_notifier_started_;\n   uv_thread_t tid_;\n \n+#if NODE_USE_V8_PLATFORM && HAVE_INSPECTOR\n+  std::unique_ptr<inspector::ParentInspectorHandle> inspector_parent_handle_;\n+#endif\n+\n   // This mutex protects access to all variables listed below it.\n   mutable Mutex mutex_;\n \n@@ -79,12 +83,14 @@ class Worker : public AsyncWrap {\n \n   std::unique_ptr<MessagePortData> child_port_data_;\n \n-  // The child port is always kept alive by the child Environment's persistent\n-  // handle to it.\n+  // The child port is kept alive by the child Environment's persistent\n+  // handle to it, as long as that child Environment exists.\n   MessagePort* child_port_ = nullptr;\n   // This is always kept alive because the JS object associated with the Worker\n   // instance refers to it via its [kPort] property.\n   MessagePort* parent_port_ = nullptr;\n+\n+  friend class WorkerThreadData;\n };\n \n }  // namespace worker"
        }
    ],
    "stats": {
        "total": 373,
        "additions": 201,
        "deletions": 172
    }
}