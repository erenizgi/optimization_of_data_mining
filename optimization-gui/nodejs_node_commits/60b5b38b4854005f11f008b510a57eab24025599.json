{
    "author": "BridgeAR",
    "message": "buffer: do not always use defaults\n\nThe Buffer#(read|write)U?Int(B|L)E functions should not use a default\nvalue. This is very likely a bug and it was never documented that\nway.\n\nBesides that this also improves the tests by adding more tests and by\nrefactoring them to less code lines.\n\nPR-URL: https://github.com/nodejs/node/pull/20054\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Khaidi Chu <i@2333.moe>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Сковорода Никита Андреевич <chalkerx@gmail.com>",
    "sha": "60b5b38b4854005f11f008b510a57eab24025599",
    "files": [
        {
            "sha": "54e13ff30bcb4e9e4f5d70e357567170a7b3aea1",
            "filename": "lib/internal/buffer.js",
            "status": "modified",
            "additions": 20,
            "deletions": 12,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/60b5b38b4854005f11f008b510a57eab24025599/lib%2Finternal%2Fbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/60b5b38b4854005f11f008b510a57eab24025599/lib%2Finternal%2Fbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbuffer.js?ref=60b5b38b4854005f11f008b510a57eab24025599",
            "patch": "@@ -59,6 +59,8 @@ function boundsError(value, length, type) {\n \n // Read integers.\n function readUIntLE(offset, byteLength) {\n+  if (offset === undefined)\n+    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n   if (byteLength === 6)\n     return readUInt48LE(this, offset);\n   if (byteLength === 5)\n@@ -69,7 +71,7 @@ function readUIntLE(offset, byteLength) {\n     return this.readUInt32LE(offset);\n   if (byteLength === 2)\n     return this.readUInt16LE(offset);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return this.readUInt8(offset);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -146,6 +148,8 @@ function readUInt8(offset = 0) {\n }\n \n function readUIntBE(offset, byteLength) {\n+  if (offset === undefined)\n+    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n   if (byteLength === 6)\n     return readUInt48BE(this, offset);\n   if (byteLength === 5)\n@@ -156,7 +160,7 @@ function readUIntBE(offset, byteLength) {\n     return this.readUInt32BE(offset);\n   if (byteLength === 2)\n     return this.readUInt16BE(offset);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return this.readUInt8(offset);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -224,6 +228,8 @@ function readUInt16BE(offset = 0) {\n }\n \n function readIntLE(offset, byteLength) {\n+  if (offset === undefined)\n+    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n   if (byteLength === 6)\n     return readInt48LE(this, offset);\n   if (byteLength === 5)\n@@ -234,7 +240,7 @@ function readIntLE(offset, byteLength) {\n     return this.readInt32LE(offset);\n   if (byteLength === 2)\n     return this.readInt16LE(offset);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return this.readInt8(offset);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -314,6 +320,8 @@ function readInt8(offset = 0) {\n }\n \n function readIntBE(offset, byteLength) {\n+  if (offset === undefined)\n+    throw new ERR_INVALID_ARG_TYPE('offset', 'number', offset);\n   if (byteLength === 6)\n     return readInt48BE(this, offset);\n   if (byteLength === 5)\n@@ -324,7 +332,7 @@ function readIntBE(offset, byteLength) {\n     return this.readInt32BE(offset);\n   if (byteLength === 2)\n     return this.readInt16BE(offset);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return this.readInt8(offset);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -460,7 +468,7 @@ function readDoubleForwards(offset = 0) {\n }\n \n // Write integers.\n-function writeUIntLE(value, offset = 0, byteLength) {\n+function writeUIntLE(value, offset, byteLength) {\n   if (byteLength === 6)\n     return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);\n   if (byteLength === 5)\n@@ -471,7 +479,7 @@ function writeUIntLE(value, offset = 0, byteLength) {\n     return writeU_Int32LE(this, value, offset, 0, 0xffffffff);\n   if (byteLength === 2)\n     return writeU_Int16LE(this, value, offset, 0, 0xffff);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return writeU_Int8(this, value, offset, 0, 0xff);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -571,7 +579,7 @@ function writeUInt8(value, offset = 0) {\n   return writeU_Int8(this, value, offset, 0, 0xff);\n }\n \n-function writeUIntBE(value, offset = 0, byteLength) {\n+function writeUIntBE(value, offset, byteLength) {\n   if (byteLength === 6)\n     return writeU_Int48BE(this, value, offset, 0, 0xffffffffffffff);\n   if (byteLength === 5)\n@@ -582,7 +590,7 @@ function writeUIntBE(value, offset = 0, byteLength) {\n     return writeU_Int32BE(this, value, offset, 0, 0xffffffff);\n   if (byteLength === 2)\n     return writeU_Int16BE(this, value, offset, 0, 0xffff);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return writeU_Int8(this, value, offset, 0, 0xff);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -663,7 +671,7 @@ function writeUInt16BE(value, offset = 0) {\n   return writeU_Int16BE(this, value, offset, 0, 0xffffffff);\n }\n \n-function writeIntLE(value, offset = 0, byteLength) {\n+function writeIntLE(value, offset, byteLength) {\n   if (byteLength === 6)\n     return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);\n   if (byteLength === 5)\n@@ -674,7 +682,7 @@ function writeIntLE(value, offset = 0, byteLength) {\n     return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);\n   if (byteLength === 2)\n     return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return writeU_Int8(this, value, offset, -0x80, 0x7f);\n \n   boundsError(byteLength, 6, 'byteLength');\n@@ -692,7 +700,7 @@ function writeInt8(value, offset = 0) {\n   return writeU_Int8(this, value, offset, -0x80, 0x7f);\n }\n \n-function writeIntBE(value, offset = 0, byteLength) {\n+function writeIntBE(value, offset, byteLength) {\n   if (byteLength === 6)\n     return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);\n   if (byteLength === 5)\n@@ -703,7 +711,7 @@ function writeIntBE(value, offset = 0, byteLength) {\n     return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);\n   if (byteLength === 2)\n     return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);\n-  if (byteLength === 1 || byteLength === undefined)\n+  if (byteLength === 1)\n     return writeU_Int8(this, value, offset, -0x80, 0x7f);\n \n   boundsError(byteLength, 6, 'byteLength');"
        },
        {
            "sha": "1fdfd0145fd7020f733aade81f1046b5530b504d",
            "filename": "test/parallel/test-buffer-read.js",
            "status": "modified",
            "additions": 20,
            "deletions": 67,
            "changes": 87,
            "blob_url": "https://github.com/nodejs/node/blob/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-read.js",
            "raw_url": "https://github.com/nodejs/node/raw/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-read.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-read.js?ref=60b5b38b4854005f11f008b510a57eab24025599",
            "patch": "@@ -51,91 +51,44 @@ read(buf, 'readUInt32LE', [1], 0xcfea48fd);\n read(buf, 'readUIntBE', [2, 2], 0x48ea);\n read(buf, 'readUIntLE', [2, 2], 0xea48);\n \n-// invalid byteLength parameter for readUIntBE() and readUIntLE()\n-common.expectsError(() => { buf.readUIntBE(2, 0); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readUIntLE(2, 7); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-\n-// attempt to overflow buffers, similar to previous bug in array buffers\n+// Attempt to overflow buffers, similar to previous bug in array buffers\n assert.throws(() => Buffer.allocUnsafe(8).readFloatBE(0xffffffff),\n               RangeError);\n assert.throws(() => Buffer.allocUnsafe(8).readFloatLE(0xffffffff),\n               RangeError);\n \n-// ensure negative values can't get past offset\n+// Ensure negative values can't get past offset\n assert.throws(() => Buffer.allocUnsafe(8).readFloatBE(-1), RangeError);\n assert.throws(() => Buffer.allocUnsafe(8).readFloatLE(-1), RangeError);\n \n-// offset checks\n+// Offset checks\n {\n   const buf = Buffer.allocUnsafe(0);\n \n   assert.throws(() => buf.readUInt8(0), RangeError);\n   assert.throws(() => buf.readInt8(0), RangeError);\n }\n \n-{\n-  const buf = Buffer.from([0xFF]);\n-\n-  assert.strictEqual(buf.readUInt8(0), 255);\n-  assert.strictEqual(buf.readInt8(0), -1);\n-}\n-\n-[16, 32].forEach((bits) => {\n-  const buf = Buffer.allocUnsafe(bits / 8 - 1);\n-\n-  assert.throws(() => buf[`readUInt${bits}BE`](0),\n-                RangeError,\n-                `readUInt${bits}BE()`);\n-\n-  assert.throws(() => buf[`readUInt${bits}LE`](0),\n-                RangeError,\n-                `readUInt${bits}LE()`);\n-\n-  assert.throws(() => buf[`readInt${bits}BE`](0),\n-                RangeError,\n-                `readInt${bits}BE()`);\n-\n-  assert.throws(() => buf[`readInt${bits}LE`](0),\n-                RangeError,\n-                `readInt${bits}LE()`);\n+[16, 32].forEach((bit) => {\n+  const buf = Buffer.allocUnsafe(bit / 8 - 1);\n+  [`Int${bit}B`, `Int${bit}L`, `UInt${bit}B`, `UInt${bit}L`].forEach((fn) => {\n+    assert.throws(\n+      () => buf[`read${fn}E`](0),\n+      {\n+        name: 'RangeError [ERR_BUFFER_OUT_OF_BOUNDS]',\n+        message: 'Attempt to write outside buffer bounds'\n+      }\n+    );\n+  });\n });\n \n [16, 32].forEach((bits) => {\n   const buf = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]);\n+  ['LE', 'BE'].forEach((endian) => {\n+    assert.strictEqual(buf[`readUInt${bits}${endian}`](0),\n+                       (0xFFFFFFFF >>> (32 - bits)));\n \n-  assert.strictEqual(buf[`readUInt${bits}BE`](0),\n-                     (0xFFFFFFFF >>> (32 - bits)));\n-\n-  assert.strictEqual(buf[`readUInt${bits}LE`](0),\n-                     (0xFFFFFFFF >>> (32 - bits)));\n-\n-  assert.strictEqual(buf[`readInt${bits}BE`](0),\n-                     (0xFFFFFFFF >> (32 - bits)));\n-\n-  assert.strictEqual(buf[`readInt${bits}LE`](0),\n-                     (0xFFFFFFFF >> (32 - bits)));\n+    assert.strictEqual(buf[`readInt${bits}${endian}`](0),\n+                       (0xFFFFFFFF >> (32 - bits)));\n+  });\n });\n-\n-// Test for common read(U)IntLE/BE\n-{\n-  const buf = Buffer.from([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]);\n-\n-  assert.strictEqual(buf.readUIntLE(0, 1), 0x01);\n-  assert.strictEqual(buf.readUIntBE(0, 1), 0x01);\n-  assert.strictEqual(buf.readUIntLE(0, 3), 0x030201);\n-  assert.strictEqual(buf.readUIntBE(0, 3), 0x010203);\n-  assert.strictEqual(buf.readUIntLE(0, 5), 0x0504030201);\n-  assert.strictEqual(buf.readUIntBE(0, 5), 0x0102030405);\n-  assert.strictEqual(buf.readUIntLE(0, 6), 0x060504030201);\n-  assert.strictEqual(buf.readUIntBE(0, 6), 0x010203040506);\n-  assert.strictEqual(buf.readIntLE(0, 1), 0x01);\n-  assert.strictEqual(buf.readIntBE(0, 1), 0x01);\n-  assert.strictEqual(buf.readIntLE(0, 3), 0x030201);\n-  assert.strictEqual(buf.readIntBE(0, 3), 0x010203);\n-  assert.strictEqual(buf.readIntLE(0, 5), 0x0504030201);\n-  assert.strictEqual(buf.readIntBE(0, 5), 0x0102030405);\n-  assert.strictEqual(buf.readIntLE(0, 6), 0x060504030201);\n-  assert.strictEqual(buf.readIntBE(0, 6), 0x010203040506);\n-}"
        },
        {
            "sha": "d417f88b82fe73c6d6d3f506394cfab5e54c2038",
            "filename": "test/parallel/test-buffer-readint.js",
            "status": "modified",
            "additions": 19,
            "deletions": 28,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-readint.js",
            "raw_url": "https://github.com/nodejs/node/raw/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-readint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-readint.js?ref=60b5b38b4854005f11f008b510a57eab24025599",
            "patch": "@@ -46,18 +46,14 @@ const assert = require('assert');\n \n // Test 8 bit signed integers\n {\n-  const data = Buffer.alloc(4);\n+  const data = Buffer.from([0x23, 0xab, 0x7c, 0xef]);\n \n-  data[0] = 0x23;\n   assert.strictEqual(data.readInt8(0), 0x23);\n \n   data[0] = 0xff;\n   assert.strictEqual(data.readInt8(0), -1);\n \n   data[0] = 0x87;\n-  data[1] = 0xab;\n-  data[2] = 0x7c;\n-  data[3] = 0xef;\n   assert.strictEqual(data.readInt8(0), -121);\n   assert.strictEqual(data.readInt8(1), -85);\n   assert.strictEqual(data.readInt8(2), 124);\n@@ -66,10 +62,8 @@ const assert = require('assert');\n \n // Test 16 bit integers\n {\n-  const buffer = Buffer.alloc(6);\n+  const buffer = Buffer.from([0x16, 0x79, 0x65, 0x6e, 0x69, 0x78]);\n \n-  buffer[0] = 0x16;\n-  buffer[1] = 0x79;\n   assert.strictEqual(buffer.readInt16BE(0), 0x1679);\n   assert.strictEqual(buffer.readInt16LE(0), 0x7916);\n \n@@ -80,10 +74,6 @@ const assert = require('assert');\n \n   buffer[0] = 0x77;\n   buffer[1] = 0x65;\n-  buffer[2] = 0x65;\n-  buffer[3] = 0x6e;\n-  buffer[4] = 0x69;\n-  buffer[5] = 0x78;\n   assert.strictEqual(buffer.readInt16BE(0), 0x7765);\n   assert.strictEqual(buffer.readInt16BE(1), 0x6565);\n   assert.strictEqual(buffer.readInt16BE(2), 0x656e);\n@@ -98,12 +88,8 @@ const assert = require('assert');\n \n // Test 32 bit integers\n {\n-  const buffer = Buffer.alloc(6);\n+  const buffer = Buffer.from([0x43, 0x53, 0x16, 0x79, 0x36, 0x17]);\n \n-  buffer[0] = 0x43;\n-  buffer[1] = 0x53;\n-  buffer[2] = 0x16;\n-  buffer[3] = 0x79;\n   assert.strictEqual(buffer.readInt32BE(0), 0x43531679);\n   assert.strictEqual(buffer.readInt32LE(0), 0x79165343);\n \n@@ -118,8 +104,6 @@ const assert = require('assert');\n   buffer[1] = 0xc3;\n   buffer[2] = 0x95;\n   buffer[3] = 0xa9;\n-  buffer[4] = 0x36;\n-  buffer[5] = 0x17;\n   assert.strictEqual(buffer.readInt32BE(0), 0x42c395a9);\n   assert.strictEqual(buffer.readInt32BE(1), -1013601994);\n   assert.strictEqual(buffer.readInt32BE(2), -1784072681);\n@@ -130,17 +114,24 @@ const assert = require('assert');\n \n // Test Int\n {\n-  const buffer = Buffer.alloc(8);\n+  const buffer = Buffer.from([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);\n+\n+  assert.strictEqual(buffer.readIntLE(0, 1), 0x01);\n+  assert.strictEqual(buffer.readIntBE(0, 1), 0x01);\n+  assert.strictEqual(buffer.readIntLE(0, 3), 0x030201);\n+  assert.strictEqual(buffer.readIntBE(0, 3), 0x010203);\n+  assert.strictEqual(buffer.readIntLE(0, 5), 0x0504030201);\n+  assert.strictEqual(buffer.readIntBE(0, 5), 0x0102030405);\n+  assert.strictEqual(buffer.readIntLE(0, 6), 0x060504030201);\n+  assert.strictEqual(buffer.readIntBE(0, 6), 0x010203040506);\n+  assert.strictEqual(buffer.readIntLE(1, 6), 0x070605040302);\n+  assert.strictEqual(buffer.readIntBE(1, 6), 0x020304050607);\n+  assert.strictEqual(buffer.readIntLE(2, 6), 0x080706050403);\n+  assert.strictEqual(buffer.readIntBE(2, 6), 0x030405060708);\n \n   // Check byteLength.\n   ['readIntBE', 'readIntLE'].forEach((fn) => {\n-\n-    // Verify that default offset & byteLength works fine.\n-    buffer[fn](undefined, undefined);\n-    buffer[fn](undefined);\n-    buffer[fn]();\n-\n-    ['', '0', null, {}, [], () => {}, true, false].forEach((len) => {\n+    ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((len) => {\n       assert.throws(\n         () => buffer[fn](0, len),\n         { code: 'ERR_INVALID_ARG_TYPE' });\n@@ -171,7 +162,7 @@ const assert = require('assert');\n   // Test 1 to 6 bytes.\n   for (let i = 1; i < 6; i++) {\n     ['readIntBE', 'readIntLE'].forEach((fn) => {\n-      ['', '0', null, {}, [], () => {}, true, false].forEach((o) => {\n+      ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((o) => {\n         assert.throws(\n           () => buffer[fn](o, i),\n           {"
        },
        {
            "sha": "d2c07e4de87f89b0ae7a901387d93fb9ee682711",
            "filename": "test/parallel/test-buffer-readuint.js",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/nodejs/node/blob/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-readuint.js",
            "raw_url": "https://github.com/nodejs/node/raw/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-readuint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-readuint.js?ref=60b5b38b4854005f11f008b510a57eab24025599",
            "patch": "@@ -0,0 +1,165 @@\n+'use strict';\n+\n+require('../common');\n+const assert = require('assert');\n+\n+// Test OOB\n+{\n+  const buffer = Buffer.alloc(4);\n+\n+  ['UInt8', 'UInt16BE', 'UInt16LE', 'UInt32BE', 'UInt32LE'].forEach((fn) => {\n+\n+    // Verify that default offset works fine.\n+    buffer[`read${fn}`](undefined);\n+    buffer[`read${fn}`]();\n+\n+    ['', '0', null, {}, [], () => {}, true, false].forEach((o) => {\n+      assert.throws(\n+        () => buffer[`read${fn}`](o),\n+        {\n+          code: 'ERR_INVALID_ARG_TYPE',\n+          name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+        });\n+    });\n+\n+    [Infinity, -1, -4294967295].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[`read${fn}`](offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]'\n+        });\n+    });\n+\n+    [NaN, 1.01].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[`read${fn}`](offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"offset\" is out of range. ' +\n+                   `It must be an integer. Received ${offset}`\n+        });\n+    });\n+  });\n+}\n+\n+// Test 8 bit unsigned integers\n+{\n+  const data = Buffer.from([0xff, 0x2a, 0x2a, 0x2a]);\n+  assert.strictEqual(255, data.readUInt8(0));\n+  assert.strictEqual(42, data.readUInt8(1));\n+  assert.strictEqual(42, data.readUInt8(2));\n+  assert.strictEqual(42, data.readUInt8(3));\n+}\n+\n+// Test 16 bit unsigned integers\n+{\n+  const data = Buffer.from([0x00, 0x2a, 0x42, 0x3f]);\n+  assert.strictEqual(0x2a, data.readUInt16BE(0));\n+  assert.strictEqual(0x2a42, data.readUInt16BE(1));\n+  assert.strictEqual(0x423f, data.readUInt16BE(2));\n+  assert.strictEqual(0x2a00, data.readUInt16LE(0));\n+  assert.strictEqual(0x422a, data.readUInt16LE(1));\n+  assert.strictEqual(0x3f42, data.readUInt16LE(2));\n+\n+  data[0] = 0xfe;\n+  data[1] = 0xfe;\n+  assert.strictEqual(0xfefe, data.readUInt16BE(0));\n+  assert.strictEqual(0xfefe, data.readUInt16LE(0));\n+}\n+\n+// Test 32 bit unsigned integers\n+{\n+  const data = Buffer.from([0x32, 0x65, 0x42, 0x56, 0x23, 0xff]);\n+  assert.strictEqual(0x32654256, data.readUInt32BE(0));\n+  assert.strictEqual(0x65425623, data.readUInt32BE(1));\n+  assert.strictEqual(0x425623ff, data.readUInt32BE(2));\n+  assert.strictEqual(0x56426532, data.readUInt32LE(0));\n+  assert.strictEqual(0x23564265, data.readUInt32LE(1));\n+  assert.strictEqual(0xff235642, data.readUInt32LE(2));\n+}\n+\n+// Test UInt\n+{\n+  const buffer = Buffer.from([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);\n+\n+  assert.strictEqual(buffer.readUIntLE(0, 1), 0x01);\n+  assert.strictEqual(buffer.readUIntBE(0, 1), 0x01);\n+  assert.strictEqual(buffer.readUIntLE(0, 3), 0x030201);\n+  assert.strictEqual(buffer.readUIntBE(0, 3), 0x010203);\n+  assert.strictEqual(buffer.readUIntLE(0, 5), 0x0504030201);\n+  assert.strictEqual(buffer.readUIntBE(0, 5), 0x0102030405);\n+  assert.strictEqual(buffer.readUIntLE(0, 6), 0x060504030201);\n+  assert.strictEqual(buffer.readUIntBE(0, 6), 0x010203040506);\n+  assert.strictEqual(buffer.readUIntLE(1, 6), 0x070605040302);\n+  assert.strictEqual(buffer.readUIntBE(1, 6), 0x020304050607);\n+  assert.strictEqual(buffer.readUIntLE(2, 6), 0x080706050403);\n+  assert.strictEqual(buffer.readUIntBE(2, 6), 0x030405060708);\n+\n+  // Check byteLength.\n+  ['readUIntBE', 'readUIntLE'].forEach((fn) => {\n+    ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((len) => {\n+      assert.throws(\n+        () => buffer[fn](0, len),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [Infinity, -1].forEach((byteLength) => {\n+      assert.throws(\n+        () => buffer[fn](0, byteLength),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be >= 1 and <= 6. Received ${byteLength}`\n+        });\n+    });\n+\n+    [NaN, 1.01].forEach((byteLength) => {\n+      assert.throws(\n+        () => buffer[fn](0, byteLength),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be an integer. Received ${byteLength}`\n+        });\n+    });\n+  });\n+\n+  // Test 1 to 6 bytes.\n+  for (let i = 1; i < 6; i++) {\n+    ['readUIntBE', 'readUIntLE'].forEach((fn) => {\n+      ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((o) => {\n+        assert.throws(\n+          () => buffer[fn](o, i),\n+          {\n+            code: 'ERR_INVALID_ARG_TYPE',\n+            name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+          });\n+      });\n+\n+      [Infinity, -1, -4294967295].forEach((offset) => {\n+        assert.throws(\n+          () => buffer[fn](offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be >= 0 and <= ${8 - i}. Received ${offset}`\n+          });\n+      });\n+\n+      [NaN, 1.01].forEach((offset) => {\n+        assert.throws(\n+          () => buffer[fn](offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be an integer. Received ${offset}`\n+          });\n+      });\n+    });\n+  }\n+}"
        },
        {
            "sha": "fb91aa11b6f9955da497386999c5e246fdec7f9f",
            "filename": "test/parallel/test-buffer-writeint.js",
            "status": "modified",
            "additions": 5,
            "deletions": 11,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-writeint.js",
            "raw_url": "https://github.com/nodejs/node/raw/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-writeint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writeint.js?ref=60b5b38b4854005f11f008b510a57eab24025599",
            "patch": "@@ -168,25 +168,19 @@ const errorOutOfBounds = common.expectsError({\n \n   // Check byteLength.\n   ['writeIntBE', 'writeIntLE'].forEach((fn) => {\n-\n-    // Verify that default offset & byteLength works fine.\n-    data[fn](undefined, undefined);\n-    data[fn](undefined);\n-    data[fn]();\n-\n-    ['', '0', null, {}, [], () => {}, true, false].forEach((bl) => {\n+    ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((bl) => {\n       assert.throws(\n         () => data[fn](23, 0, bl),\n         { code: 'ERR_INVALID_ARG_TYPE' });\n     });\n \n-    [Infinity, -1].forEach((offset) => {\n+    [Infinity, -1].forEach((byteLength) => {\n       assert.throws(\n-        () => data[fn](23, 0, offset),\n+        () => data[fn](23, 0, byteLength),\n         {\n           code: 'ERR_OUT_OF_RANGE',\n           message: 'The value of \"byteLength\" is out of range. ' +\n-                   `It must be >= 1 and <= 6. Received ${offset}`\n+                   `It must be >= 1 and <= 6. Received ${byteLength}`\n         }\n       );\n     });\n@@ -220,7 +214,7 @@ const errorOutOfBounds = common.expectsError({\n         });\n       });\n \n-      ['', '0', null, {}, [], () => {}, true, false].forEach((o) => {\n+      ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((o) => {\n         assert.throws(\n           () => data[fn](min, o, i),\n           {"
        },
        {
            "sha": "8fe7783e71be049b5ab5685371f8bbf971d79f6a",
            "filename": "test/parallel/test-buffer-writeuint.js",
            "status": "modified",
            "additions": 4,
            "deletions": 10,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-writeuint.js",
            "raw_url": "https://github.com/nodejs/node/raw/60b5b38b4854005f11f008b510a57eab24025599/test%2Fparallel%2Ftest-buffer-writeuint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writeuint.js?ref=60b5b38b4854005f11f008b510a57eab24025599",
            "patch": "@@ -117,25 +117,19 @@ const assert = require('assert');\n \n   // Check byteLength.\n   ['writeUIntBE', 'writeUIntLE'].forEach((fn) => {\n-\n-    // Verify that default offset & byteLength works fine.\n-    data[fn](undefined, undefined);\n-    data[fn](undefined);\n-    data[fn]();\n-\n-    ['', '0', null, {}, [], () => {}, true, false].forEach((bl) => {\n+    ['', '0', null, {}, [], () => {}, true, false, undefined].forEach((bl) => {\n       assert.throws(\n         () => data[fn](23, 0, bl),\n         { code: 'ERR_INVALID_ARG_TYPE' });\n     });\n \n-    [Infinity, -1].forEach((offset) => {\n+    [Infinity, -1].forEach((byteLength) => {\n       assert.throws(\n-        () => data[fn](23, 0, offset),\n+        () => data[fn](23, 0, byteLength),\n         {\n           code: 'ERR_OUT_OF_RANGE',\n           message: 'The value of \"byteLength\" is out of range. ' +\n-                   `It must be >= 1 and <= 6. Received ${offset}`\n+                   `It must be >= 1 and <= 6. Received ${byteLength}`\n         }\n       );\n     });"
        },
        {
            "sha": "d5a1ba8fe2f524a145f38c7b3549c5fe73cb92a6",
            "filename": "test/parallel/test-readuint.js",
            "status": "removed",
            "additions": 0,
            "deletions": 110,
            "changes": 110,
            "blob_url": "https://github.com/nodejs/node/blob/198eb9c5d6ac6a90dadb8c58396f9b35eaf6f5ce/test%2Fparallel%2Ftest-readuint.js",
            "raw_url": "https://github.com/nodejs/node/raw/198eb9c5d6ac6a90dadb8c58396f9b35eaf6f5ce/test%2Fparallel%2Ftest-readuint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-readuint.js?ref=198eb9c5d6ac6a90dadb8c58396f9b35eaf6f5ce",
            "patch": "@@ -1,110 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * A battery of tests to help us read a series of uints\n- */\n-\n-require('../common');\n-const assert = require('assert');\n-\n-/*\n- * We need to check the following things:\n- *  - We are correctly resolving big endian (doesn't mean anything for 8 bit)\n- *  - Correctly resolving little endian (doesn't mean anything for 8 bit)\n- *  - Correctly using the offsets\n- *  - Correctly interpreting values that are beyond the signed range as unsigned\n- */\n-function test8(clazz) {\n-  const data = new clazz(4);\n-\n-  data[0] = 23;\n-  data[1] = 23;\n-  data[2] = 23;\n-  data[3] = 23;\n-  assert.strictEqual(23, data.readUInt8(0));\n-  assert.strictEqual(23, data.readUInt8(1));\n-  assert.strictEqual(23, data.readUInt8(2));\n-  assert.strictEqual(23, data.readUInt8(3));\n-\n-  data[0] = 255; /* If it became a signed int, would be -1 */\n-  assert.strictEqual(255, data.readUInt8(0));\n-}\n-\n-\n-/*\n- * Test 16 bit unsigned integers. We need to verify the same set as 8 bit, only\n- * now some of the issues actually matter:\n- *  - We are correctly resolving big endian\n- *  - Correctly resolving little endian\n- *  - Correctly using the offsets\n- *  - Correctly interpreting values that are beyond the signed range as unsigned\n- */\n-function test16(clazz) {\n-  const data = new clazz(4);\n-\n-  data[0] = 0;\n-  data[1] = 0x23;\n-  data[2] = 0x42;\n-  data[3] = 0x3f;\n-  assert.strictEqual(0x23, data.readUInt16BE(0));\n-  assert.strictEqual(0x2342, data.readUInt16BE(1));\n-  assert.strictEqual(0x423f, data.readUInt16BE(2));\n-  assert.strictEqual(0x2300, data.readUInt16LE(0));\n-  assert.strictEqual(0x4223, data.readUInt16LE(1));\n-  assert.strictEqual(0x3f42, data.readUInt16LE(2));\n-\n-  data[0] = 0xfe;\n-  data[1] = 0xfe;\n-  assert.strictEqual(0xfefe, data.readUInt16BE(0));\n-  assert.strictEqual(0xfefe, data.readUInt16LE(0));\n-}\n-\n-\n-/*\n- * Test 32 bit unsigned integers. We need to verify the same set as 8 bit, only\n- * now some of the issues actually matter:\n- *  - We are correctly resolving big endian\n- *  - Correctly using the offsets\n- *  - Correctly interpreting values that are beyond the signed range as unsigned\n- */\n-function test32(clazz) {\n-  const data = new clazz(8);\n-\n-  data[0] = 0x32;\n-  data[1] = 0x65;\n-  data[2] = 0x42;\n-  data[3] = 0x56;\n-  data[4] = 0x23;\n-  data[5] = 0xff;\n-  assert.strictEqual(0x32654256, data.readUInt32BE(0));\n-  assert.strictEqual(0x65425623, data.readUInt32BE(1));\n-  assert.strictEqual(0x425623ff, data.readUInt32BE(2));\n-  assert.strictEqual(0x56426532, data.readUInt32LE(0));\n-  assert.strictEqual(0x23564265, data.readUInt32LE(1));\n-  assert.strictEqual(0xff235642, data.readUInt32LE(2));\n-}\n-\n-\n-test8(Buffer);\n-test16(Buffer);\n-test32(Buffer);"
        }
    ],
    "stats": {
        "total": 471,
        "additions": 233,
        "deletions": 238
    }
}