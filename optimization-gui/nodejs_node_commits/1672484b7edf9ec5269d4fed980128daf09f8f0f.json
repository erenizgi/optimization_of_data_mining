{
    "author": "Trott",
    "message": "doc: remove _optional_ designation for tls options\n\nOptions are, by definition, optional. Remove specification of some\noptions as \"optional\".\n\nPR-URL: https://github.com/nodejs/node/pull/22545\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: George Adams <george.adams@uk.ibm.com>",
    "sha": "1672484b7edf9ec5269d4fed980128daf09f8f0f",
    "files": [
        {
            "sha": "6ac4739081dc060a1521e6ce66f4404d56a56126",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 59,
            "deletions": 61,
            "changes": 120,
            "blob_url": "https://github.com/nodejs/node/blob/1672484b7edf9ec5269d4fed980128daf09f8f0f/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/1672484b7edf9ec5269d4fed980128daf09f8f0f/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=1672484b7edf9ec5269d4fed980128daf09f8f0f",
            "patch": "@@ -376,8 +376,8 @@ more information.\n added: v0.3.2\n -->\n \n-* `callback` {Function} An optional listener callback that will be registered to\n-  listen for the server instance's `'close'` event.\n+* `callback` {Function} A listener callback that will be registered to listen\n+for the server instance's `'close'` event.\n \n The `server.close()` method stops the server from accepting new connections.\n \n@@ -458,24 +458,24 @@ changes:\n   * `isServer`: The SSL/TLS protocol is asymmetrical, TLSSockets must know if\n     they are to behave as a server or a client. If `true` the TLS socket will be\n     instantiated as a server. **Default:** `false`.\n-  * `server` {net.Server} An optional [`net.Server`][] instance.\n+  * `server` {net.Server} A [`net.Server`][] instance.\n   * `requestCert`: Whether to authenticate the remote peer by requesting a\n      certificate. Clients always request a server certificate. Servers\n-     (`isServer` is true) may optionally set `requestCert` to true to request a\n-     client certificate.\n-  * `rejectUnauthorized`: Optional, see [`tls.createServer()`][]\n-  * `ALPNProtocols`: Optional, see [`tls.createServer()`][]\n-  * `SNICallback`: Optional, see [`tls.createServer()`][]\n-  * `session` {Buffer} An optional `Buffer` instance containing a TLS session.\n+     (`isServer` is true) may set `requestCert` to true to request a client\n+     certificate.\n+  * `rejectUnauthorized`: See [`tls.createServer()`][]\n+  * `ALPNProtocols`: See [`tls.createServer()`][]\n+  * `SNICallback`: See [`tls.createServer()`][]\n+  * `session` {Buffer} A `Buffer` instance containing a TLS session.\n   * `requestOCSP` {boolean} If `true`, specifies that the OCSP status request\n     extension will be added to the client hello and an `'OCSPResponse'` event\n     will be emitted on the socket before establishing a secure communication\n-  * `secureContext`: Optional TLS context object created with\n+  * `secureContext`: TLS context object created with\n     [`tls.createSecureContext()`][]. If a `secureContext` is _not_ provided, one\n     will be created by passing the entire `options` object to\n     `tls.createSecureContext()`.\n-  * ...: Optional [`tls.createSecureContext()`][] options that are used if the\n-    `secureContext` option is missing, otherwise they are ignored.\n+  * ...: [`tls.createSecureContext()`][] options that are used if the\n+    `secureContext` option is missing. Otherwise, they are ignored.\n \n Construct a new `tls.TLSSocket` object from an existing TCP socket.\n \n@@ -903,13 +903,13 @@ changes:\n     TLS connection. When a server offers a DH parameter with a size less\n     than `minDHSize`, the TLS connection is destroyed and an error is thrown.\n     **Default:** `1024`.\n-  * `secureContext`: Optional TLS context object created with\n+  * `secureContext`: TLS context object created with\n     [`tls.createSecureContext()`][]. If a `secureContext` is _not_ provided, one\n     will be created by passing the entire `options` object to\n     `tls.createSecureContext()`.\n   * `lookup`: {Function} Custom lookup function. **Default:**\n     [`dns.lookup()`][].\n-  * ...: Optional [`tls.createSecureContext()`][] options that are used if the\n+  * ...: [`tls.createSecureContext()`][] options that are used if the\n     `secureContext` option is missing, otherwise they are ignored.\n * `callback` {Function}\n \n@@ -993,7 +993,7 @@ added: v0.11.3\n -->\n \n * `port` {number} Default value for `options.port`.\n-* `host` {string} Optional default value for `options.host`.\n+* `host` {string} Default value for `options.host`.\n * `options` {Object} See [`tls.connect()`][].\n * `callback` {Function} See [`tls.connect()`][].\n \n@@ -1037,23 +1037,23 @@ changes:\n     certificate can match or chain to.\n     For self-signed certificates, the certificate is its own CA, and must be\n     provided.\n-  * `cert` {string|string[]|Buffer|Buffer[]} Optional cert chains in PEM format.\n-    One cert chain should be provided per private key. Each cert chain should\n-    consist of the PEM formatted certificate for a provided private `key`,\n-    followed by the PEM formatted intermediate certificates (if any), in order,\n-    and not including the root CA (the root CA must be pre-known to the peer,\n-    see `ca`). When providing multiple cert chains, they do not have to be in\n-    the same order as their private keys in `key`. If the intermediate\n-    certificates are not provided, the peer will not be able to validate the\n-    certificate, and the handshake will fail.\n-  * `ciphers` {string} Optional cipher suite specification, replacing the\n-    default. For more information, see [modifying the default cipher suite][].\n-    Permitted ciphers can be obtained via [`tls.getCiphers()`][]. Cipher names\n-    must be uppercased in order for OpenSSL to accept them.\n-  * `clientCertEngine` {string} Optional name of an OpenSSL engine which can\n-    provide the client certificate.\n-  * `crl` {string|string[]|Buffer|Buffer[]} Optional PEM formatted\n-    CRLs (Certificate Revocation Lists).\n+  * `cert` {string|string[]|Buffer|Buffer[]} Cert chains in PEM format. One cert\n+    chain should be provided per private key. Each cert chain should consist of\n+    the PEM formatted certificate for a provided private `key`, followed by the\n+    PEM formatted intermediate certificates (if any), in order, and not\n+    including the root CA (the root CA must be pre-known to the peer, see `ca`).\n+    When providing multiple cert chains, they do not have to be in the same\n+    order as their private keys in `key`. If the intermediate certificates are\n+    not provided, the peer will not be able to validate the certificate, and the\n+    handshake will fail.\n+  * `ciphers` {string} Cipher suite specification, replacing the default. For\n+    more information, see [modifying the default cipher suite][]. Permitted\n+    ciphers can be obtained via [`tls.getCiphers()`][]. Cipher names must be\n+    uppercased in order for OpenSSL to accept them.\n+  * `clientCertEngine` {string} Name of an OpenSSL engine which can provide the\n+    client certificate.\n+  * `crl` {string|string[]|Buffer|Buffer[]} PEM formatted CRLs (Certificate\n+    Revocation Lists).\n   * `dhparam` {string|Buffer} Diffie Hellman parameters, required for\n     [Perfect Forward Secrecy][]. Use `openssl dhparam` to create the parameters.\n     The key length must be greater than or equal to 1024 bits, otherwise an\n@@ -1071,19 +1071,19 @@ changes:\n     preferences instead of the client's. When `true`, causes\n     `SSL_OP_CIPHER_SERVER_PREFERENCE` to be set in `secureOptions`, see\n     [OpenSSL Options][] for more information.\n-  * `key` {string|string[]|Buffer|Buffer[]|Object[]} Optional private keys in\n-    PEM format. PEM allows the option of private keys being encrypted. Encrypted\n-    keys will be decrypted with `options.passphrase`. Multiple keys using\n-    different algorithms can be provided either as an array of unencrypted key\n-    strings or buffers, or an array of objects in the form `{pem:\n-    <string|buffer>[, passphrase: <string>]}`. The object form can only occur in\n-    an array. `object.passphrase` is optional. Encrypted keys will be decrypted\n-    with `object.passphrase` if provided, or `options.passphrase` if it is not.\n-  * `passphrase` {string} Optional shared passphrase used for a single private\n-    key and/or a PFX.\n-  * `pfx` {string|string[]|Buffer|Buffer[]|Object[]} Optional PFX or PKCS12\n-    encoded private key and certificate chain. `pfx` is an alternative to\n-    providing `key` and `cert` individually. PFX is usually encrypted, if it is,\n+  * `key` {string|string[]|Buffer|Buffer[]|Object[]} Private keys in PEM format.\n+    PEM allows the option of private keys being encrypted. Encrypted keys will\n+    be decrypted with `options.passphrase`. Multiple keys using different\n+    algorithms can be provided either as an array of unencrypted key strings or\n+    buffers, or an array of objects in the form `{pem: <string|buffer>[,\n+    passphrase: <string>]}`. The object form can only occur in an array.\n+    `object.passphrase` is optional. Encrypted keys will be decrypted with\n+    `object.passphrase` if provided, or `options.passphrase` if it is not.\n+  * `passphrase` {string} Shared passphrase used for a single private key and/or\n+    a PFX.\n+  * `pfx` {string|string[]|Buffer|Buffer[]|Object[]} PFX or PKCS12 encoded\n+    private key and certificate chain. `pfx` is an alternative to providing\n+    `key` and `cert` individually. PFX is usually encrypted, if it is,\n     `passphrase` will be used to decrypt it. Multiple PFX can be provided either\n     as an array of unencrypted PFX buffers, or an array of objects in the form\n     `{buf: <string|buffer>[, passphrase: <string>]}`. The object form can only\n@@ -1094,12 +1094,11 @@ changes:\n     which is not usually necessary. This should be used carefully if at all!\n     Value is a numeric bitmask of the `SSL_OP_*` options from\n     [OpenSSL Options][].\n-  * `secureProtocol` {string} Optional SSL method to use. The possible values\n-    are listed as [SSL_METHODS][], use the function names as strings.\n-    For example, `'TLSv1_2_method'` to force TLS version 1.2. **Default:**\n-    `'TLS_method'`.\n-  * `sessionIdContext` {string} Optional opaque identifier used by servers to\n-    ensure session state is not shared between applications. Unused by clients.\n+  * `secureProtocol` {string} SSL method to use. The possible values are listed\n+    as [SSL_METHODS][], use the function names as strings. For example,\n+    `'TLSv1_2_method'` to force TLS version 1.2. **Default:** `'TLS_method'`.\n+  * `sessionIdContext` {string} Opaque identifier used by servers to ensure\n+    session state is not shared between applications. Unused by clients.\n \n [`tls.createServer()`][] sets the default value of the `honorCipherOrder` option\n to `true`, other APIs that create secure contexts leave it unset.\n@@ -1140,8 +1139,8 @@ changes:\n     first byte is the length of the next protocol name. Passing an array is\n     usually much simpler, e.g. `['hello', 'world']`.\n     (Protocols should be ordered by their priority.)\n-  * `clientCertEngine` {string} Optional name of an OpenSSL engine which can\n-    provide the client certificate.\n+  * `clientCertEngine` {string} Name of an OpenSSL engine which can provide the\n+    client certificate.\n   * `handshakeTimeout` {number} Abort the connection if the SSL/TLS handshake\n     does not finish in the specified number of milliseconds.\n     A `'tlsClientError'` is emitted on the `tls.Server` object whenever\n@@ -1324,16 +1323,15 @@ changes:\n * `rejectUnauthorized` {boolean} If not `false` a server automatically reject\n   clients with invalid certificates. Only applies when `isServer` is `true`.\n * `options`\n-  * `secureContext`: An optional TLS context object from\n-     [`tls.createSecureContext()`][]\n+  * `secureContext`: A TLS context object from [`tls.createSecureContext()`][]\n   * `isServer`: If `true` the TLS socket will be instantiated in server-mode.\n     **Default:** `false`.\n-  * `server` {net.Server} An optional [`net.Server`][] instance\n-  * `requestCert`: Optional, see [`tls.createServer()`][]\n-  * `rejectUnauthorized`: Optional, see [`tls.createServer()`][]\n-  * `ALPNProtocols`: Optional, see [`tls.createServer()`][]\n-  * `SNICallback`: Optional, see [`tls.createServer()`][]\n-  * `session` {Buffer} An optional `Buffer` instance containing a TLS session.\n+  * `server` {net.Server} A [`net.Server`][] instance\n+  * `requestCert`: See [`tls.createServer()`][]\n+  * `rejectUnauthorized`: See [`tls.createServer()`][]\n+  * `ALPNProtocols`: See [`tls.createServer()`][]\n+  * `SNICallback`: See [`tls.createServer()`][]\n+  * `session` {Buffer} A `Buffer` instance containing a TLS session.\n   * `requestOCSP` {boolean} If `true`, specifies that the OCSP status request\n     extension will be added to the client hello and an `'OCSPResponse'` event\n     will be emitted on the socket before establishing a secure communication."
        }
    ],
    "stats": {
        "total": 120,
        "additions": 59,
        "deletions": 61
    }
}