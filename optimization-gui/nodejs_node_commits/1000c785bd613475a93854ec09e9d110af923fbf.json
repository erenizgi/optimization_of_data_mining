{
    "author": "Trott",
    "message": "benchmark: refactor deepequal-map\n\nThis is a minor refactor of benchmark/assert/deepequal-map.js to\nreduce exceptions that need to be made for lint compliance.\n\nPR-URL: https://github.com/nodejs/node/pull/21030\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "1000c785bd613475a93854ec09e9d110af923fbf",
    "files": [
        {
            "sha": "c6c7173fe8ed6d1a9dd49292a386ccb4dfce7d6a",
            "filename": "benchmark/assert/deepequal-map.js",
            "status": "modified",
            "additions": 16,
            "deletions": 17,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/1000c785bd613475a93854ec09e9d110af923fbf/benchmark%2Fassert%2Fdeepequal-map.js",
            "raw_url": "https://github.com/nodejs/node/raw/1000c785bd613475a93854ec09e9d110af923fbf/benchmark%2Fassert%2Fdeepequal-map.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fassert%2Fdeepequal-map.js?ref=1000c785bd613475a93854ec09e9d110af923fbf",
            "patch": "@@ -1,9 +1,8 @@\n 'use strict';\n \n-/* eslint-disable no-restricted-properties */\n-\n const common = require('../common.js');\n-const assert = require('assert');\n+const { deepEqual, deepStrictEqual, notDeepEqual, notDeepStrictEqual } =\n+  require('assert');\n \n const bench = common.createBenchmark(main, {\n   n: [5e2],\n@@ -47,74 +46,74 @@ function main({ n, len, method }) {\n       // Empty string falls through to next line as default, mostly for tests.\n     case 'deepEqual_primitiveOnly':\n       values = array.map((_, i) => [`str_${i}`, 123]);\n-      benchmark(assert.deepEqual, n, values);\n+      benchmark(deepEqual, n, values);\n       break;\n     case 'deepStrictEqual_primitiveOnly':\n       values = array.map((_, i) => [`str_${i}`, 123]);\n-      benchmark(assert.deepStrictEqual, n, values);\n+      benchmark(deepStrictEqual, n, values);\n       break;\n     case 'deepEqual_objectOnly':\n       values = array.map((_, i) => [[`str_${i}`, 1], 123]);\n-      benchmark(assert.deepEqual, n, values);\n+      benchmark(deepEqual, n, values);\n       break;\n     case 'deepStrictEqual_objectOnly':\n       values = array.map((_, i) => [[`str_${i}`, 1], 123]);\n-      benchmark(assert.deepStrictEqual, n, values);\n+      benchmark(deepStrictEqual, n, values);\n       break;\n     case 'deepEqual_mixed':\n       values = array.map((_, i) => [i % 2 ? [`str_${i}`, 1] : `str_${i}`, 123]);\n-      benchmark(assert.deepEqual, n, values);\n+      benchmark(deepEqual, n, values);\n       break;\n     case 'deepStrictEqual_mixed':\n       values = array.map((_, i) => [i % 2 ? [`str_${i}`, 1] : `str_${i}`, 123]);\n-      benchmark(assert.deepStrictEqual, n, values);\n+      benchmark(deepStrictEqual, n, values);\n       break;\n     case 'deepEqual_looseMatches':\n       values = array.map((_, i) => [i, i]);\n       values2 = values.slice().map((v) => [String(v[0]), String(v[1])]);\n-      benchmark(assert.deepEqual, n, values, values2);\n+      benchmark(deepEqual, n, values, values2);\n       break;\n     case 'notDeepEqual_primitiveOnly':\n       values = array.map((_, i) => [`str_${i}`, 123]);\n       values2 = values.slice(0);\n       values2[Math.floor(len / 2)] = ['w00t', 123];\n-      benchmark(assert.notDeepEqual, n, values, values2);\n+      benchmark(notDeepEqual, n, values, values2);\n       break;\n     case 'notDeepStrictEqual_primitiveOnly':\n       values = array.map((_, i) => [`str_${i}`, 123]);\n       values2 = values.slice(0);\n       values2[Math.floor(len / 2)] = ['w00t', 123];\n-      benchmark(assert.notDeepStrictEqual, n, values, values2);\n+      benchmark(notDeepStrictEqual, n, values, values2);\n       break;\n     case 'notDeepEqual_objectOnly':\n       values = array.map((_, i) => [[`str_${i}`, 1], 123]);\n       values2 = values.slice(0);\n       values2[Math.floor(len / 2)] = [['w00t'], 123];\n-      benchmark(assert.notDeepEqual, n, values, values2);\n+      benchmark(notDeepEqual, n, values, values2);\n       break;\n     case 'notDeepStrictEqual_objectOnly':\n       values = array.map((_, i) => [[`str_${i}`, 1], 123]);\n       values2 = values.slice(0);\n       values2[Math.floor(len / 2)] = [['w00t'], 123];\n-      benchmark(assert.notDeepStrictEqual, n, values, values2);\n+      benchmark(notDeepStrictEqual, n, values, values2);\n       break;\n     case 'notDeepEqual_mixed':\n       values = array.map((_, i) => [i % 2 ? [`str_${i}`, 1] : `str_${i}`, 123]);\n       values2 = values.slice(0);\n       values2[0] = ['w00t', 123];\n-      benchmark(assert.notDeepEqual, n, values, values2);\n+      benchmark(notDeepEqual, n, values, values2);\n       break;\n     case 'notDeepStrictEqual_mixed':\n       values = array.map((_, i) => [i % 2 ? [`str_${i}`, 1] : `str_${i}`, 123]);\n       values2 = values.slice(0);\n       values2[0] = ['w00t', 123];\n-      benchmark(assert.notDeepStrictEqual, n, values, values2);\n+      benchmark(notDeepStrictEqual, n, values, values2);\n       break;\n     case 'notDeepEqual_looseMatches':\n       values = array.map((_, i) => [i, i]);\n       values2 = values.slice().map((v) => [String(v[0]), String(v[1])]);\n       values2[len - 1] = [String(len + 1), String(len + 1)];\n-      benchmark(assert.notDeepEqual, n, values, values2);\n+      benchmark(notDeepEqual, n, values, values2);\n       break;\n     default:\n       throw new Error(`Unsupported method ${method}`);"
        }
    ],
    "stats": {
        "total": 33,
        "additions": 16,
        "deletions": 17
    }
}