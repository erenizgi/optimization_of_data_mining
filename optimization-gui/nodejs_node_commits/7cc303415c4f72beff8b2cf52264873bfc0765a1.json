{
    "author": "BridgeAR",
    "message": "lib: lazy loaded\n\nThis makes sure the async hooks and more is only loaded in case it\nis actually necessary.\n\nPR-URL: https://github.com/nodejs/node/pull/20567\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>",
    "sha": "7cc303415c4f72beff8b2cf52264873bfc0765a1",
    "files": [
        {
            "sha": "5d509e4e37b6c9a5902a5c4b0538b5f795bf053d",
            "filename": "lib/internal/bootstrap/node.js",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/7cc303415c4f72beff8b2cf52264873bfc0765a1/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "raw_url": "https://github.com/nodejs/node/raw/7cc303415c4f72beff8b2cf52264873bfc0765a1/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fnode.js?ref=7cc303415c4f72beff8b2cf52264873bfc0765a1",
            "patch": "@@ -64,7 +64,17 @@\n     if (global.__coverage__)\n       NativeModule.require('internal/process/write-coverage').setup();\n \n-    NativeModule.require('internal/trace_events_async_hooks').setup();\n+\n+    {\n+      const traceEvents = process.binding('trace_events');\n+      const traceEventCategory = 'node,node.async_hooks';\n+\n+      if (traceEvents.categoryGroupEnabled(traceEventCategory)) {\n+        NativeModule.require('internal/trace_events_async_hooks')\n+          .setup(traceEvents, traceEventCategory);\n+      }\n+    }\n+\n \n     if (process.config.variables.v8_enable_inspector) {\n       NativeModule.require('internal/inspector_async_hook').setup();"
        },
        {
            "sha": "011dc6bbead18751de75e5e677a7218f1dcc72e7",
            "filename": "lib/internal/trace_events_async_hooks.js",
            "status": "modified",
            "additions": 60,
            "deletions": 68,
            "changes": 128,
            "blob_url": "https://github.com/nodejs/node/blob/7cc303415c4f72beff8b2cf52264873bfc0765a1/lib%2Finternal%2Ftrace_events_async_hooks.js",
            "raw_url": "https://github.com/nodejs/node/raw/7cc303415c4f72beff8b2cf52264873bfc0765a1/lib%2Finternal%2Ftrace_events_async_hooks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ftrace_events_async_hooks.js?ref=7cc303415c4f72beff8b2cf52264873bfc0765a1",
            "patch": "@@ -1,71 +1,63 @@\n 'use strict';\n \n-const trace_events = process.binding('trace_events');\n-const async_wrap = process.binding('async_wrap');\n-const async_hooks = require('async_hooks');\n-\n-// Use small letters such that chrome://tracing groups by the name.\n-// The behavior is not only useful but the same as the events emitted using\n-// the specific C++ macros.\n-const BEFORE_EVENT = 'b'.charCodeAt(0);\n-const END_EVENT = 'e'.charCodeAt(0);\n-\n-// In trace_events it is not only the id but also the name that needs to be\n-// repeated. Since async_hooks doesn't expose the provider type in the\n-// non-init events, use a map to manually map the asyncId to the type name.\n-const typeMemory = new Map();\n-\n-const trace_event_category = 'node,node.async_hooks';\n-\n-// It is faster to emit trace_events directly from C++. Thus, this happens in\n-// async_wrap.cc. However, events emitted from the JavaScript API or the\n-// Embedder C++ API can't be emitted from async_wrap.cc. Thus they are\n-// emitted using the JavaScript API. To prevent emitting the same event\n-// twice the async_wrap.Providers list is used to filter the events.\n-const nativeProviders = new Set(Object.keys(async_wrap.Providers));\n-\n-const hook = async_hooks.createHook({\n-  init(asyncId, type, triggerAsyncId, resource) {\n-    if (nativeProviders.has(type)) return;\n-\n-    typeMemory.set(asyncId, type);\n-    trace_events.emit(BEFORE_EVENT, trace_event_category,\n-                      type, asyncId,\n-                      'triggerAsyncId', triggerAsyncId,\n-                      'executionAsyncId', async_hooks.executionAsyncId());\n-  },\n-\n-  before(asyncId) {\n-    const type = typeMemory.get(asyncId);\n-    if (type === undefined) return;\n-\n-    trace_events.emit(BEFORE_EVENT, trace_event_category,\n-                      type + '_CALLBACK', asyncId);\n-  },\n-\n-  after(asyncId) {\n-    const type = typeMemory.get(asyncId);\n-    if (type === undefined) return;\n-\n-    trace_events.emit(END_EVENT, trace_event_category,\n-                      type + '_CALLBACK', asyncId);\n-  },\n-\n-  destroy(asyncId) {\n-    const type = typeMemory.get(asyncId);\n-    if (type === undefined) return;\n-\n-    trace_events.emit(END_EVENT, trace_event_category,\n-                      type, asyncId);\n-\n-    // cleanup asyncId to type map\n-    typeMemory.delete(asyncId);\n-  }\n-});\n-\n-\n-exports.setup = function() {\n-  if (trace_events.categoryGroupEnabled(trace_event_category)) {\n-    hook.enable();\n-  }\n+exports.setup = function(traceEvents, traceEventCategory) {\n+  const async_wrap = process.binding('async_wrap');\n+  const async_hooks = require('async_hooks');\n+\n+  // Use small letters such that chrome://tracing groups by the name.\n+  // The behavior is not only useful but the same as the events emitted using\n+  // the specific C++ macros.\n+  const BEFORE_EVENT = 'b'.charCodeAt(0);\n+  const END_EVENT = 'e'.charCodeAt(0);\n+\n+  // In traceEvents it is not only the id but also the name that needs to be\n+  // repeated. Since async_hooks doesn't expose the provider type in the\n+  // non-init events, use a map to manually map the asyncId to the type name.\n+  const typeMemory = new Map();\n+\n+  // It is faster to emit traceEvents directly from C++. Thus, this happens\n+  // in async_wrap.cc. However, events emitted from the JavaScript API or the\n+  // Embedder C++ API can't be emitted from async_wrap.cc. Thus they are\n+  // emitted using the JavaScript API. To prevent emitting the same event\n+  // twice the async_wrap.Providers list is used to filter the events.\n+  const nativeProviders = new Set(Object.keys(async_wrap.Providers));\n+\n+  async_hooks.createHook({\n+    init(asyncId, type, triggerAsyncId, resource) {\n+      if (nativeProviders.has(type)) return;\n+\n+      typeMemory.set(asyncId, type);\n+      traceEvents.emit(BEFORE_EVENT, traceEventCategory,\n+                       type, asyncId,\n+                       'triggerAsyncId', triggerAsyncId,\n+                       'executionAsyncId', async_hooks.executionAsyncId());\n+    },\n+\n+    before(asyncId) {\n+      const type = typeMemory.get(asyncId);\n+      if (type === undefined) return;\n+\n+      traceEvents.emit(BEFORE_EVENT, traceEventCategory,\n+                       type + '_CALLBACK', asyncId);\n+    },\n+\n+    after(asyncId) {\n+      const type = typeMemory.get(asyncId);\n+      if (type === undefined) return;\n+\n+      traceEvents.emit(END_EVENT, traceEventCategory,\n+                       type + '_CALLBACK', asyncId);\n+    },\n+\n+    destroy(asyncId) {\n+      const type = typeMemory.get(asyncId);\n+      if (type === undefined) return;\n+\n+      traceEvents.emit(END_EVENT, traceEventCategory,\n+                       type, asyncId);\n+\n+      // cleanup asyncId to type map\n+      typeMemory.delete(asyncId);\n+    }\n+  }).enable();\n };"
        }
    ],
    "stats": {
        "total": 140,
        "additions": 71,
        "deletions": 69
    }
}