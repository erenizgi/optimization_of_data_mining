{
    "author": "tniessen",
    "message": "src: add CHECK_NULL/CHECK_NOT_NULL macros\n\nThis change introduces CHECK_NULL and CHECK_NOT_NULL macros\nsimilar to their definition in v8 and replaces instances of\nCHECK/CHECK_EQ/CHECK_NE with these where it seems appropriate.\n\nPR-URL: https://github.com/nodejs/node/pull/20914\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "39f209649fc290fe92cc3b87edfffa6a854ecb03",
    "files": [
        {
            "sha": "51db615f703f8513b50de8ef27d12cbadf573e45",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -310,7 +310,7 @@ static void PromiseHook(PromiseHookType type, Local<Promise> promise,\n     }\n   }\n \n-  CHECK_NE(wrap, nullptr);\n+  CHECK_NOT_NULL(wrap);\n   if (type == PromiseHookType::kBefore) {\n     env->async_hooks()->push_async_ids(\n       wrap->get_async_id(), wrap->get_trigger_async_id());"
        },
        {
            "sha": "3021307c065511bf0deb8cf0b29ab1d103693c64",
            "filename": "src/connection_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fconnection_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fconnection_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fconnection_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -34,7 +34,7 @@ template <typename WrapType, typename UVType>\n void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle,\n                                                     int status) {\n   WrapType* wrap_data = static_cast<WrapType*>(handle->data);\n-  CHECK_NE(wrap_data, nullptr);\n+  CHECK_NOT_NULL(wrap_data);\n   CHECK_EQ(&wrap_data->handle_, reinterpret_cast<UVType*>(handle));\n \n   Environment* env = wrap_data->env();\n@@ -78,7 +78,7 @@ template <typename WrapType, typename UVType>\n void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req,\n                                                     int status) {\n   ConnectWrap* req_wrap = static_cast<ConnectWrap*>(req->data);\n-  CHECK_NE(req_wrap, nullptr);\n+  CHECK_NOT_NULL(req_wrap);\n   WrapType* wrap = static_cast<WrapType*>(req->handle->data);\n   CHECK_EQ(req_wrap->env(), wrap->env());\n   Environment* env = wrap->env();"
        },
        {
            "sha": "a965bd195ef850b2ca02fcffbe46f4247c1f939d",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -473,22 +473,22 @@ inline double Environment::get_default_trigger_async_id() {\n }\n \n inline double* Environment::heap_statistics_buffer() const {\n-  CHECK_NE(heap_statistics_buffer_, nullptr);\n+  CHECK_NOT_NULL(heap_statistics_buffer_);\n   return heap_statistics_buffer_;\n }\n \n inline void Environment::set_heap_statistics_buffer(double* pointer) {\n-  CHECK_EQ(heap_statistics_buffer_, nullptr);  // Should be set only once.\n+  CHECK_NULL(heap_statistics_buffer_);  // Should be set only once.\n   heap_statistics_buffer_ = pointer;\n }\n \n inline double* Environment::heap_space_statistics_buffer() const {\n-  CHECK_NE(heap_space_statistics_buffer_, nullptr);\n+  CHECK_NOT_NULL(heap_space_statistics_buffer_);\n   return heap_space_statistics_buffer_;\n }\n \n inline void Environment::set_heap_space_statistics_buffer(double* pointer) {\n-  CHECK_EQ(heap_space_statistics_buffer_, nullptr);  // Should be set only once.\n+  CHECK_NULL(heap_space_statistics_buffer_);  // Should be set only once.\n   heap_space_statistics_buffer_ = pointer;\n }\n \n@@ -497,7 +497,7 @@ inline char* Environment::http_parser_buffer() const {\n }\n \n inline void Environment::set_http_parser_buffer(char* buffer) {\n-  CHECK_EQ(http_parser_buffer_, nullptr);  // Should be set only once.\n+  CHECK_NULL(http_parser_buffer_);  // Should be set only once.\n   http_parser_buffer_ = buffer;\n }\n "
        },
        {
            "sha": "2fa4432c54d4e95e44153257cf2b45d535fee40c",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -80,7 +80,7 @@ IsolateData::~IsolateData() {\n v8::CpuProfiler* IsolateData::GetCpuProfiler() {\n   if (cpu_profiler_ != nullptr) return cpu_profiler_;\n   cpu_profiler_ = v8::CpuProfiler::New(isolate());\n-  CHECK_NE(cpu_profiler_, nullptr);\n+  CHECK_NOT_NULL(cpu_profiler_);\n   return cpu_profiler_;\n }\n "
        },
        {
            "sha": "a9ac67957335b3bf4cfe5f96420834c83a8cc5f7",
            "filename": "src/fs_event_wrap.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Ffs_event_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Ffs_event_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ffs_event_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -88,7 +88,7 @@ FSEventWrap::~FSEventWrap() {\n \n void FSEventWrap::GetInitialized(const FunctionCallbackInfo<Value>& args) {\n   FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());\n-  CHECK(wrap != nullptr);\n+  CHECK_NOT_NULL(wrap);\n   args.GetReturnValue().Set(wrap->initialized_);\n }\n \n@@ -133,14 +133,14 @@ void FSEventWrap::Start(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());\n-  CHECK_NE(wrap, nullptr);\n+  CHECK_NOT_NULL(wrap);\n   CHECK(!wrap->initialized_);\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 4);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   unsigned int flags = 0;\n   if (args[2]->IsTrue())\n@@ -233,7 +233,7 @@ void FSEventWrap::OnEvent(uv_fs_event_t* handle, const char* filename,\n \n void FSEventWrap::Close(const FunctionCallbackInfo<Value>& args) {\n   FSEventWrap* wrap = Unwrap<FSEventWrap>(args.Holder());\n-  CHECK_NE(wrap, nullptr);\n+  CHECK_NOT_NULL(wrap);\n   CHECK(wrap->initialized_);\n \n   wrap->initialized_ = false;"
        },
        {
            "sha": "058a665e5630abb0bc084960efd07531388249c8",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -317,7 +317,7 @@ class InspectorTimerHandle {\n   InspectorTimerHandle(const InspectorTimerHandle&) = delete;\n \n   ~InspectorTimerHandle() {\n-    CHECK_NE(timer_, nullptr);\n+    CHECK_NOT_NULL(timer_);\n     timer_->Stop();\n     timer_ = nullptr;\n   }\n@@ -562,7 +562,7 @@ bool Agent::StartIoThread(bool wait_for_connect) {\n   if (io_ != nullptr)\n     return true;\n \n-  CHECK_NE(client_, nullptr);\n+  CHECK_NOT_NULL(client_);\n \n   io_ = std::unique_ptr<InspectorIo>(\n       new InspectorIo(parent_env_, platform_, path_, debug_options_,\n@@ -613,7 +613,7 @@ std::unique_ptr<InspectorSession> Agent::Connect(\n }\n \n void Agent::WaitForDisconnect() {\n-  CHECK_NE(client_, nullptr);\n+  CHECK_NOT_NULL(client_);\n   // TODO(addaleax): Maybe this should use an at-exit hook for the Environment\n   // or something similar?\n   client_->contextDestroyed(parent_env_->context());"
        },
        {
            "sha": "4db26bee273b9a4e8cdfc1611b56a3189f3b7664",
            "filename": "src/inspector_io.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Finspector_io.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Finspector_io.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -34,7 +34,7 @@ std::string ScriptPath(uv_loop_t* loop, const std::string& script_name) {\n     uv_fs_t req;\n     req.ptr = nullptr;\n     if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {\n-      CHECK_NE(req.ptr, nullptr);\n+      CHECK_NOT_NULL(req.ptr);\n       script_path = std::string(static_cast<char*>(req.ptr));\n     }\n     uv_fs_req_cleanup(&req);"
        },
        {
            "sha": "1350269cf2c4b00b31616a22662ba8ce835fa001",
            "filename": "src/inspector_socket.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Finspector_socket.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Finspector_socket.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -599,7 +599,7 @@ class HttpHandler : public ProtocolHandler {\n ProtocolHandler::ProtocolHandler(InspectorSocket* inspector,\n                                  TcpHolder::Pointer tcp)\n                                  : inspector_(inspector), tcp_(std::move(tcp)) {\n-  CHECK_NE(nullptr, tcp_);\n+  CHECK_NOT_NULL(tcp_);\n   tcp_->SetHandler(this);\n }\n "
        },
        {
            "sha": "c766c322e3017a34a04cf138ba4376162f7b19eb",
            "filename": "src/js_stream.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fjs_stream.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fjs_stream.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_stream.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -104,7 +104,7 @@ int JSStream::DoWrite(WriteWrap* w,\n                       uv_buf_t* bufs,\n                       size_t count,\n                       uv_stream_t* send_handle) {\n-  CHECK_EQ(send_handle, nullptr);\n+  CHECK_NULL(send_handle);\n \n   HandleScope scope(env()->isolate());\n   Context::Scope context_scope(env()->context());"
        },
        {
            "sha": "05daa2bb85ebe0e877e4005e90e3a7b8d8b62c21",
            "filename": "src/module_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fmodule_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fmodule_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -106,7 +106,7 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n       ContextifyContext* sandbox =\n           ContextifyContext::ContextFromContextifiedSandbox(\n               env, args[2].As<Object>());\n-      CHECK_NE(sandbox, nullptr);\n+      CHECK_NOT_NULL(sandbox);\n       context = sandbox->context();\n     }\n "
        },
        {
            "sha": "008e7ed599ed708a6fdd634c2565630da0a02540",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -1964,7 +1964,7 @@ static void DLOpen(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   auto context = env->context();\n \n-  CHECK_EQ(modpending, nullptr);\n+  CHECK_NULL(modpending);\n \n   if (args.Length() < 2) {\n     env->ThrowError(\"process.dlopen needs at least 2 arguments.\");\n@@ -2231,8 +2231,8 @@ static Local<Object> InitModule(Environment* env,\n                                  Local<String> module) {\n   Local<Object> exports = Object::New(env->isolate());\n   // Internal bindings don't have a \"module\" object, only exports.\n-  CHECK_EQ(mod->nm_register_func, nullptr);\n-  CHECK_NE(mod->nm_context_register_func, nullptr);\n+  CHECK_NULL(mod->nm_register_func);\n+  CHECK_NOT_NULL(mod->nm_context_register_func);\n   Local<Value> unused = Undefined(env->isolate());\n   mod->nm_context_register_func(exports,\n                                 unused,\n@@ -4075,7 +4075,7 @@ void AtExit(void (*cb)(void* arg), void* arg) {\n \n \n void AtExit(Environment* env, void (*cb)(void* arg), void* arg) {\n-  CHECK_NE(env, nullptr);\n+  CHECK_NOT_NULL(env);\n   env->AtExit(cb, arg);\n }\n \n@@ -4336,7 +4336,7 @@ inline int Start(uv_loop_t* event_loop,\n \n   {\n     Mutex::ScopedLock scoped_lock(node_isolate_mutex);\n-    CHECK_EQ(node_isolate, nullptr);\n+    CHECK_NULL(node_isolate);\n     node_isolate = isolate;\n   }\n "
        },
        {
            "sha": "9465145ac37eb9dcfd5e323789bf18dd75f30c94",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -140,7 +140,7 @@ CallbackInfo::CallbackInfo(Isolate* isolate,\n   ArrayBuffer::Contents obj_c = object->GetContents();\n   CHECK_EQ(data_, static_cast<char*>(obj_c.Data()));\n   if (object->ByteLength() != 0)\n-    CHECK_NE(data_, nullptr);\n+    CHECK_NOT_NULL(data_);\n \n   persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);\n   persistent_.SetWrapperClassId(BUFFER_ID);\n@@ -329,7 +329,7 @@ MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {\n \n   void* new_data;\n   if (length > 0) {\n-    CHECK_NE(data, nullptr);\n+    CHECK_NOT_NULL(data);\n     new_data = node::UncheckedMalloc(length);\n     if (new_data == nullptr)\n       return Local<Object>();\n@@ -408,7 +408,7 @@ MaybeLocal<Object> New(Isolate* isolate, char* data, size_t length) {\n \n MaybeLocal<Object> New(Environment* env, char* data, size_t length) {\n   if (length > 0) {\n-    CHECK_NE(data, nullptr);\n+    CHECK_NOT_NULL(data);\n     CHECK(length <= kMaxLength);\n   }\n "
        },
        {
            "sha": "a8dfce8355885dc08398558b92e8e1531fceb21e",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -655,7 +655,7 @@ class ContextifyScript : public BaseObject {\n         ContextifyContext* sandbox =\n             ContextifyContext::ContextFromContextifiedSandbox(\n                 env, args[6].As<Object>());\n-        CHECK_NE(sandbox, nullptr);\n+        CHECK_NOT_NULL(sandbox);\n         parsing_context = sandbox->context();\n       }\n     } else {\n@@ -785,7 +785,7 @@ class ContextifyScript : public BaseObject {\n     // Get the context from the sandbox\n     ContextifyContext* contextify_context =\n         ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);\n-    CHECK_NE(contextify_context, nullptr);\n+    CHECK_NOT_NULL(contextify_context);\n \n     if (contextify_context->context().IsEmpty())\n       return;"
        },
        {
            "sha": "bedc84b56bfac20c9cb128460006cf618dc4a9f2",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -730,7 +730,7 @@ static X509_STORE* NewRootCertStore() {\n       BIO_free(bp);\n \n       // Parse errors from the built-in roots are fatal.\n-      CHECK_NE(x509, nullptr);\n+      CHECK_NOT_NULL(x509);\n \n       root_certs_vector.push_back(x509);\n     }\n@@ -1578,7 +1578,7 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n     int rv;\n \n     ext = X509_get_ext(cert, index);\n-    CHECK_NE(ext, nullptr);\n+    CHECK_NOT_NULL(ext);\n \n     if (!SafeX509ExtPrint(bio.get(), ext)) {\n       rv = X509V3_EXT_print(bio.get(), ext, 0, 0);\n@@ -3377,7 +3377,7 @@ void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {\n \n \n SignBase::Error SignBase::Init(const char* sign_type) {\n-  CHECK_EQ(mdctx_, nullptr);\n+  CHECK_NULL(mdctx_);\n   // Historically, \"dss1\" and \"DSS1\" were DSA aliases for SHA-1\n   // exposed through the public API.\n   if (strcmp(sign_type, \"dss1\") == 0 ||\n@@ -4232,7 +4232,7 @@ void DiffieHellman::SetKey(const v8::FunctionCallbackInfo<Value>& args,\n   BIGNUM* num =\n       BN_bin2bn(reinterpret_cast<unsigned char*>(Buffer::Data(args[0])),\n                 Buffer::Length(args[0]), nullptr);\n-  CHECK_NE(num, nullptr);\n+  CHECK_NOT_NULL(num);\n   CHECK_EQ(1, set_field(dh->dh_.get(), num));\n }\n \n@@ -4490,7 +4490,7 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {\n   USE(&mark_pop_error_on_return);\n \n   const BIGNUM* priv_key = EC_KEY_get0_private_key(ecdh->key_.get());\n-  CHECK_NE(priv_key, nullptr);\n+  CHECK_NOT_NULL(priv_key);\n \n   ECPointPointer pub(EC_POINT_new(ecdh->group_));\n   CHECK(pub);\n@@ -5001,7 +5001,7 @@ void VerifySpkac(const FunctionCallbackInfo<Value>& args) {\n     return args.GetReturnValue().Set(verify_result);\n \n   char* data = Buffer::Data(args[0]);\n-  CHECK_NE(data, nullptr);\n+  CHECK_NOT_NULL(data);\n \n   verify_result = VerifySpkac(data, length);\n \n@@ -5046,7 +5046,7 @@ void ExportPublicKey(const FunctionCallbackInfo<Value>& args) {\n     return args.GetReturnValue().SetEmptyString();\n \n   char* data = Buffer::Data(args[0]);\n-  CHECK_NE(data, nullptr);\n+  CHECK_NOT_NULL(data);\n \n   size_t pkey_size;\n   char* pkey = ExportPublicKey(data, length, &pkey_size);\n@@ -5078,7 +5078,7 @@ void ExportChallenge(const FunctionCallbackInfo<Value>& args) {\n     return args.GetReturnValue().SetEmptyString();\n \n   char* data = Buffer::Data(args[0]);\n-  CHECK_NE(data, nullptr);\n+  CHECK_NOT_NULL(data);\n \n   OpenSSLBuffer cert = ExportChallenge(data, len);\n   if (!cert)"
        },
        {
            "sha": "0bc808aa17d2be34b6157170d4eda72958083038",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -621,7 +621,7 @@ class ECDH : public BaseObject {\n         key_(std::move(key)),\n         group_(EC_KEY_get0_group(key_.get())) {\n     MakeWeak();\n-    CHECK_NE(group_, nullptr);\n+    CHECK_NOT_NULL(group_);\n   }\n \n   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);"
        },
        {
            "sha": "094bb9cc1f8822aa61fd74d38b6fa9d6d8e5fea8",
            "filename": "src/node_crypto_bio.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto_bio.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto_bio.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto_bio.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -518,7 +518,7 @@ NodeBIO::~NodeBIO() {\n \n \n NodeBIO* NodeBIO::FromBIO(BIO* bio) {\n-  CHECK_NE(BIO_get_data(bio), nullptr);\n+  CHECK_NOT_NULL(BIO_get_data(bio));\n   return static_cast<NodeBIO*>(BIO_get_data(bio));\n }\n "
        },
        {
            "sha": "c5c595c7606cf93e0f2cdfe2542ac1ecb96072a4",
            "filename": "src/node_crypto_clienthello-inl.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto_clienthello-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_crypto_clienthello-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto_clienthello-inl.h?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -65,7 +65,7 @@ inline void ClientHelloParser::Start(ClientHelloParser::OnHelloCb onhello_cb,\n     return;\n   Reset();\n \n-  CHECK_NE(onhello_cb, nullptr);\n+  CHECK_NOT_NULL(onhello_cb);\n \n   state_ = kWaiting;\n   onhello_cb_ = onhello_cb;"
        },
        {
            "sha": "789269d71228299fd6f9e4c6b6568700318f26dc",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 26,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -223,7 +223,7 @@ inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n     CloseReq* req = new CloseReq(env(), promise, object());\n     auto AfterClose = uv_fs_callback_t{[](uv_fs_t* req) {\n       CloseReq* close = static_cast<CloseReq*>(req->data);\n-      CHECK_NE(close, nullptr);\n+      CHECK_NOT_NULL(close);\n       close->file_handle()->AfterClose();\n       Isolate* isolate = close->env()->isolate();\n       if (req->result < 0) {\n@@ -619,7 +619,7 @@ inline FSReqBase* AsyncDestCall(Environment* env,\n     const FunctionCallbackInfo<Value>& args,\n     const char* syscall, const char* dest, size_t len,\n     enum encoding enc, uv_fs_cb after, Func fn, Args... fn_args) {\n-  CHECK_NE(req_wrap, nullptr);\n+  CHECK_NOT_NULL(req_wrap);\n   req_wrap->Init(syscall, dest, len, enc);\n   int err = req_wrap->Dispatch(fn, fn_args..., after);\n   if (err < 0) {\n@@ -690,7 +690,7 @@ void Access(const FunctionCallbackInfo<Value>& args) {\n   int mode = args[1].As<Int32>()->Value();\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n   if (req_wrap_async != nullptr) {  // access(path, mode, req)\n@@ -823,7 +823,7 @@ static void Stat(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 2);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n   if (req_wrap_async != nullptr) {  // stat(path, req)\n@@ -852,7 +852,7 @@ static void LStat(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 2);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n   if (req_wrap_async != nullptr) {  // lstat(path, req)\n@@ -911,9 +911,9 @@ static void Symlink(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 4);\n \n   BufferValue target(env->isolate(), args[0]);\n-  CHECK_NE(*target, nullptr);\n+  CHECK_NOT_NULL(*target);\n   BufferValue path(env->isolate(), args[1]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[2]->IsInt32());\n   int flags = args[2].As<Int32>()->Value();\n@@ -939,10 +939,10 @@ static void Link(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue src(env->isolate(), args[0]);\n-  CHECK_NE(*src, nullptr);\n+  CHECK_NOT_NULL(*src);\n \n   BufferValue dest(env->isolate(), args[1]);\n-  CHECK_NE(*dest, nullptr);\n+  CHECK_NOT_NULL(*dest);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n   if (req_wrap_async != nullptr) {  // link(src, dest, req)\n@@ -965,7 +965,7 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n@@ -1007,9 +1007,9 @@ static void Rename(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue old_path(env->isolate(), args[0]);\n-  CHECK_NE(*old_path, nullptr);\n+  CHECK_NOT_NULL(*old_path);\n   BufferValue new_path(env->isolate(), args[1]);\n-  CHECK_NE(*new_path, nullptr);\n+  CHECK_NOT_NULL(*new_path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n   if (req_wrap_async != nullptr) {\n@@ -1103,7 +1103,7 @@ static void Unlink(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 2);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n   if (req_wrap_async != nullptr) {\n@@ -1125,7 +1125,7 @@ static void RMDir(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 2);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);  // rmdir(path, req)\n   if (req_wrap_async != nullptr) {\n@@ -1148,7 +1148,7 @@ static void MKDir(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsInt32());\n   const int mode = args[1].As<Int32>()->Value();\n@@ -1174,7 +1174,7 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n@@ -1217,7 +1217,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n@@ -1299,7 +1299,7 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsInt32());\n   const int flags = args[1].As<Int32>()->Value();\n@@ -1329,7 +1329,7 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsInt32());\n   const int flags = args[1].As<Int32>()->Value();\n@@ -1364,10 +1364,10 @@ static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue src(env->isolate(), args[0]);\n-  CHECK_NE(*src, nullptr);\n+  CHECK_NOT_NULL(*src);\n \n   BufferValue dest(env->isolate(), args[1]);\n-  CHECK_NE(*dest, nullptr);\n+  CHECK_NOT_NULL(*dest);\n \n   CHECK(args[2]->IsInt32());\n   const int flags = args[2].As<Int32>()->Value();\n@@ -1536,7 +1536,7 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   if (is_async) {  // write(fd, string, pos, enc, req)\n-    CHECK_NE(req_wrap_async, nullptr);\n+    CHECK_NOT_NULL(req_wrap_async);\n     len = StringBytes::StorageSize(env->isolate(), value, enc);\n     FSReqBase::FSReqBuffer& stack_buffer =\n         req_wrap_async->Init(\"write\", len, enc);\n@@ -1646,7 +1646,7 @@ static void Chmod(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 2);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsInt32());\n   int mode = args[1].As<Int32>()->Value();\n@@ -1706,7 +1706,7 @@ static void Chown(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsUint32());\n   const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Uint32>()->Value());\n@@ -1769,7 +1769,7 @@ static void UTimes(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsNumber());\n   const double atime = args[1].As<Number>()->Value();\n@@ -1827,7 +1827,7 @@ static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 2);\n \n   BufferValue tmpl(env->isolate(), args[0]);\n-  CHECK_NE(*tmpl, nullptr);\n+  CHECK_NOT_NULL(*tmpl);\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n "
        },
        {
            "sha": "42d7555fba2c51b98ee7848b9b7f435790f2b5d4",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -36,7 +36,7 @@ inline Http2Stream* GetStream(Http2Session* session,\n   Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);\n   if (stream == nullptr)\n     stream = session->FindStream(id);\n-  CHECK_NE(stream, nullptr);\n+  CHECK_NOT_NULL(stream);\n   CHECK_EQ(id, stream->id());\n   return stream;\n }\n@@ -780,7 +780,7 @@ int Http2Session::OnHeaderCallback(nghttp2_session* handle,\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   int32_t id = GetFrameID(frame);\n   Http2Stream* stream = session->FindStream(id);\n-  CHECK_NE(stream, nullptr);\n+  CHECK_NOT_NULL(stream);\n   // If the stream has already been destroyed, ignore.\n   if (!stream->IsDestroyed() && !stream->AddHeader(name, value, flags)) {\n     // This will only happen if the connected peer sends us more\n@@ -1578,7 +1578,7 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   HandleScope handle_scope(env()->isolate());\n   Context::Scope context_scope(env()->context());\n   Http2Scope h2scope(this);\n-  CHECK_NE(stream_, nullptr);\n+  CHECK_NOT_NULL(stream_);\n   DEBUG_HTTP2SESSION2(this, \"receiving %d bytes\", nread);\n   IncrementCurrentSessionMemory(buf.len);\n   CHECK(stream_buf_ab_.IsEmpty());\n@@ -1592,7 +1592,7 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n     // Only pass data on if nread > 0\n \n     // Makre sure that there was no read previously active.\n-    CHECK_EQ(stream_buf_.base, nullptr);\n+    CHECK_NULL(stream_buf_.base);\n     CHECK_EQ(stream_buf_.len, 0);\n \n     // Remember the current buffer, so that OnDataChunkReceived knows the\n@@ -1949,7 +1949,7 @@ int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                          size_t nbufs,\n                          uv_stream_t* send_handle) {\n   CHECK(!this->IsDestroyed());\n-  CHECK_EQ(send_handle, nullptr);\n+  CHECK_NULL(send_handle);\n   Http2Scope h2scope(this);\n   if (!IsWritable()) {\n     req_wrap->Done(UV_EOF);"
        },
        {
            "sha": "7d96466c3933fcc6136cd8b1ccd1193d21eacce5",
            "filename": "src/node_http_parser.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_http_parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_http_parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http_parser.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -406,7 +406,7 @@ class Parser : public AsyncWrap, public StreamListener {\n     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());\n     CHECK(parser->current_buffer_.IsEmpty());\n     CHECK_EQ(parser->current_buffer_len_, 0);\n-    CHECK_EQ(parser->current_buffer_data_, nullptr);\n+    CHECK_NULL(parser->current_buffer_data_);\n     CHECK_EQ(Buffer::HasInstance(args[0]), true);\n \n     Local<Object> buffer_obj = args[0].As<Object>();\n@@ -487,7 +487,7 @@ class Parser : public AsyncWrap, public StreamListener {\n     CHECK(args[0]->IsExternal());\n     Local<External> stream_obj = args[0].As<External>();\n     StreamBase* stream = static_cast<StreamBase*>(stream_obj->Value());\n-    CHECK_NE(stream, nullptr);\n+    CHECK_NOT_NULL(stream);\n     stream->PushStreamListener(parser);\n   }\n "
        },
        {
            "sha": "4ace513810f1b8c92c5dd7e431c8eb4a6091529f",
            "filename": "src/node_i18n.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_i18n.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_i18n.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_i18n.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -127,7 +127,7 @@ struct Converter {\n \n   explicit Converter(UConverter* converter,\n                      const char* sub = nullptr) : conv(converter) {\n-    CHECK_NE(conv, nullptr);\n+    CHECK_NOT_NULL(conv);\n     UErrorCode status = U_ZERO_ERROR;\n     if (sub != nullptr) {\n       ucnv_setSubstChars(conv, sub, strlen(sub), &status);"
        },
        {
            "sha": "3749c2e21f2ad962c75b5bd3ca733f5bbfe76bb2",
            "filename": "src/node_stat_watcher.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_stat_watcher.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_stat_watcher.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_stat_watcher.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -125,7 +125,7 @@ bool StatWatcher::IsActive() {\n \n void StatWatcher::IsActive(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   StatWatcher* wrap = Unwrap<StatWatcher>(args.This());\n-  CHECK(wrap != nullptr);\n+  CHECK_NOT_NULL(wrap);\n   args.GetReturnValue().Set(wrap->IsActive());\n }\n \n@@ -134,7 +134,7 @@ void StatWatcher::Start(const FunctionCallbackInfo<Value>& args) {\n   CHECK_EQ(args.Length(), 3);\n \n   StatWatcher* wrap = Unwrap<StatWatcher>(args.Holder());\n-  CHECK_NE(wrap, nullptr);\n+  CHECK_NOT_NULL(wrap);\n   if (wrap->IsActive()) {\n     return;\n   }\n@@ -143,7 +143,7 @@ void StatWatcher::Start(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(argc, 3);\n \n   node::Utf8Value path(args.GetIsolate(), args[0]);\n-  CHECK_NE(*path, nullptr);\n+  CHECK_NOT_NULL(*path);\n \n   bool persistent = true;\n   if (args[1]->IsFalse()) {\n@@ -171,7 +171,7 @@ void StatWatcher::Start(const FunctionCallbackInfo<Value>& args) {\n \n void StatWatcher::Stop(const FunctionCallbackInfo<Value>& args) {\n   StatWatcher* wrap = Unwrap<StatWatcher>(args.Holder());\n-  CHECK_NE(wrap, nullptr);\n+  CHECK_NOT_NULL(wrap);\n   if (!wrap->IsActive()) {\n     return;\n   }"
        },
        {
            "sha": "13a3dbce1b26b815b6f7e6dd618039ab31dcb3bf",
            "filename": "src/node_trace_events.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_trace_events.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fnode_trace_events.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_trace_events.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -49,15 +49,15 @@ void NodeCategorySet::New(const FunctionCallbackInfo<Value>& args) {\n     Utf8Value val(env->isolate(), category);\n     categories.emplace(*val);\n   }\n-  CHECK_NE(env->tracing_agent(), nullptr);\n+  CHECK_NOT_NULL(env->tracing_agent());\n   new NodeCategorySet(env, args.This(), categories);\n }\n \n void NodeCategorySet::Enable(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   NodeCategorySet* category_set;\n   ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());\n-  CHECK_NE(category_set, nullptr);\n+  CHECK_NOT_NULL(category_set);\n   const auto& categories = category_set->GetCategories();\n   if (!category_set->enabled_ && !categories.empty()) {\n     env->tracing_agent()->Enable(categories);\n@@ -69,7 +69,7 @@ void NodeCategorySet::Disable(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   NodeCategorySet* category_set;\n   ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());\n-  CHECK_NE(category_set, nullptr);\n+  CHECK_NOT_NULL(category_set);\n   const auto& categories = category_set->GetCategories();\n   if (category_set->enabled_ && !categories.empty()) {\n     env->tracing_agent()->Disable(categories);"
        },
        {
            "sha": "54345b231bccce3230e9ceab48b899a0f841b5c7",
            "filename": "src/process_wrap.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fprocess_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fprocess_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fprocess_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -126,7 +126,7 @@ class ProcessWrap : public HandleWrap {\n         Local<Object> handle =\n             stdio->Get(context, handle_key).ToLocalChecked().As<Object>();\n         uv_stream_t* stream = HandleToStream(env, handle);\n-        CHECK_NE(stream, nullptr);\n+        CHECK_NOT_NULL(stream);\n \n         options->stdio[i].flags = UV_INHERIT_STREAM;\n         options->stdio[i].data.stream = stream;\n@@ -197,7 +197,7 @@ class ProcessWrap : public HandleWrap {\n         node::Utf8Value arg(env->isolate(),\n                             js_argv->Get(context, i).ToLocalChecked());\n         options.args[i] = strdup(*arg);\n-        CHECK_NE(options.args[i], nullptr);\n+        CHECK_NOT_NULL(options.args[i]);\n       }\n       options.args[argc] = nullptr;\n     }\n@@ -223,7 +223,7 @@ class ProcessWrap : public HandleWrap {\n         node::Utf8Value pair(env->isolate(),\n                              env_opt->Get(context, i).ToLocalChecked());\n         options.env[i] = strdup(*pair);\n-        CHECK_NE(options.env[i], nullptr);\n+        CHECK_NOT_NULL(options.env[i]);\n       }\n       options.env[envc] = nullptr;\n     }\n@@ -294,7 +294,7 @@ class ProcessWrap : public HandleWrap {\n                      int64_t exit_status,\n                      int term_signal) {\n     ProcessWrap* wrap = static_cast<ProcessWrap*>(handle->data);\n-    CHECK_NE(wrap, nullptr);\n+    CHECK_NOT_NULL(wrap);\n     CHECK_EQ(&wrap->process_, handle);\n \n     Environment* env = wrap->env();"
        },
        {
            "sha": "4f9da1c4f35d9e8de6cde0411847915b047d0447",
            "filename": "src/req_wrap-inl.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Freq_wrap-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Freq_wrap-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap-inl.h?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -123,7 +123,7 @@ struct MakeLibuvRequestCallback<ReqT, void(*)(ReqT*, Args...)> {\n   }\n \n   static F For(ReqWrap<ReqT>* req_wrap, F v) {\n-    CHECK_EQ(req_wrap->original_callback_, nullptr);\n+    CHECK_NULL(req_wrap->original_callback_);\n     req_wrap->original_callback_ =\n         reinterpret_cast<typename ReqWrap<ReqT>::callback_t>(v);\n     return Wrapper;"
        },
        {
            "sha": "8bc50c7586c23b2e4de1d77bfbff057f99479f0b",
            "filename": "src/spawn_sync.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fspawn_sync.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fspawn_sync.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fspawn_sync.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -149,7 +149,7 @@ int SyncProcessStdioPipe::Start() {\n \n   if (readable()) {\n     if (input_buffer_.len > 0) {\n-      CHECK_NE(input_buffer_.base, nullptr);\n+      CHECK_NOT_NULL(input_buffer_.base);\n \n       int r = uv_write(&write_req_,\n                        uv_stream(),\n@@ -547,7 +547,7 @@ void SyncProcessRunner::CloseStdioPipes() {\n \n   if (stdio_pipes_initialized_) {\n     CHECK(stdio_pipes_);\n-    CHECK_NE(uv_loop_, nullptr);\n+    CHECK_NOT_NULL(uv_loop_);\n \n     for (uint32_t i = 0; i < stdio_count_; i++) {\n       if (stdio_pipes_[i])\n@@ -564,7 +564,7 @@ void SyncProcessRunner::CloseKillTimer() {\n \n   if (kill_timer_initialized_) {\n     CHECK_GT(timeout_, 0);\n-    CHECK_NE(uv_loop_, nullptr);\n+    CHECK_NOT_NULL(uv_loop_);\n \n     uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);\n     uv_ref(uv_timer_handle);"
        },
        {
            "sha": "4509825a60d184bd30325030d88c3a42a31a7bf1",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -51,17 +51,17 @@ inline StreamListener::~StreamListener() {\n }\n \n inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) {\n-  CHECK_NE(previous_listener_, nullptr);\n+  CHECK_NOT_NULL(previous_listener_);\n   previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));\n }\n \n inline void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) {\n-  CHECK_NE(previous_listener_, nullptr);\n+  CHECK_NOT_NULL(previous_listener_);\n   previous_listener_->OnStreamAfterShutdown(w, status);\n }\n \n inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) {\n-  CHECK_NE(previous_listener_, nullptr);\n+  CHECK_NOT_NULL(previous_listener_);\n   previous_listener_->OnStreamAfterWrite(w, status);\n }\n \n@@ -79,8 +79,8 @@ inline StreamResource::~StreamResource() {\n }\n \n inline void StreamResource::PushStreamListener(StreamListener* listener) {\n-  CHECK_NE(listener, nullptr);\n-  CHECK_EQ(listener->stream_, nullptr);\n+  CHECK_NOT_NULL(listener);\n+  CHECK_NULL(listener->stream_);\n \n   listener->previous_listener_ = listener_;\n   listener->stream_ = this;\n@@ -89,7 +89,7 @@ inline void StreamResource::PushStreamListener(StreamListener* listener) {\n }\n \n inline void StreamResource::RemoveStreamListener(StreamListener* listener) {\n-  CHECK_NE(listener, nullptr);\n+  CHECK_NOT_NULL(listener);\n \n   StreamListener* previous;\n   StreamListener* current;\n@@ -98,7 +98,7 @@ inline void StreamResource::RemoveStreamListener(StreamListener* listener) {\n   for (current = listener_, previous = nullptr;\n        /* No loop condition because we want a crash if listener is not found */\n        ; previous = current, current = current->previous_listener_) {\n-    CHECK_NE(current, nullptr);\n+    CHECK_NOT_NULL(current);\n     if (current == listener) {\n       if (previous != nullptr)\n         previous->previous_listener_ = current->previous_listener_;\n@@ -415,7 +415,7 @@ inline void ShutdownWrap::OnDone(int status) {\n }\n \n inline void WriteWrap::SetAllocatedStorage(char* data, size_t size) {\n-  CHECK_EQ(storage_, nullptr);\n+  CHECK_NULL(storage_);\n   storage_ = data;\n   storage_size_ = size;\n }"
        },
        {
            "sha": "71fe5db9758c0011b5f1a548670a18029485f0f0",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -318,7 +318,7 @@ void StreamBase::CallJSOnreadMethod(ssize_t nread, Local<Object> buf) {\n     argv[1] = Undefined(env->isolate());\n \n   AsyncWrap* wrap = GetAsyncWrap();\n-  CHECK_NE(wrap, nullptr);\n+  CHECK_NOT_NULL(wrap);\n   wrap->MakeCallback(env->onread_string(), arraysize(argv), argv);\n }\n \n@@ -360,7 +360,7 @@ uv_buf_t StreamListener::OnStreamAlloc(size_t suggested_size) {\n \n \n void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n-  CHECK_NE(stream_, nullptr);\n+  CHECK_NOT_NULL(stream_);\n   StreamBase* stream = static_cast<StreamBase*>(stream_);\n   Environment* env = stream->stream_env();\n   HandleScope handle_scope(env->isolate());"
        },
        {
            "sha": "bfe7d4297257a08f5993da8ae0fc83d37b2c02e2",
            "filename": "src/stream_pipe.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_pipe.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_pipe.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -19,8 +19,8 @@ StreamPipe::StreamPipe(StreamBase* source,\n     : AsyncWrap(source->stream_env(), obj, AsyncWrap::PROVIDER_STREAMPIPE) {\n   MakeWeak();\n \n-  CHECK_NE(sink, nullptr);\n-  CHECK_NE(source, nullptr);\n+  CHECK_NOT_NULL(sink);\n+  CHECK_NOT_NULL(source);\n \n   source->PushStreamListener(&readable_listener_);\n   sink->PushStreamListener(&writable_listener_);\n@@ -120,7 +120,7 @@ void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,\n     free(buf.base);\n     pipe->is_eof_ = true;\n     stream()->ReadStop();\n-    CHECK_NE(previous_listener_, nullptr);\n+    CHECK_NOT_NULL(previous_listener_);\n     previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));\n     // If were not writing, close now. Otherwise, well do that in\n     // `OnStreamAfterWrite()`.\n@@ -164,7 +164,7 @@ void StreamPipe::WritableListener::OnStreamAfterWrite(WriteWrap* w,\n   }\n \n   if (status != 0) {\n-    CHECK_NE(previous_listener_, nullptr);\n+    CHECK_NOT_NULL(previous_listener_);\n     StreamListener* prev = previous_listener_;\n     pipe->Unpipe();\n     prev->OnStreamAfterWrite(w, status);\n@@ -175,7 +175,7 @@ void StreamPipe::WritableListener::OnStreamAfterWrite(WriteWrap* w,\n void StreamPipe::WritableListener::OnStreamAfterShutdown(ShutdownWrap* w,\n                                                          int status) {\n   StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);\n-  CHECK_NE(previous_listener_, nullptr);\n+  CHECK_NOT_NULL(previous_listener_);\n   StreamListener* prev = previous_listener_;\n   pipe->Unpipe();\n   prev->OnStreamAfterShutdown(w, status);\n@@ -205,13 +205,13 @@ void StreamPipe::WritableListener::OnStreamWantsWrite(size_t suggested_size) {\n }\n \n uv_buf_t StreamPipe::WritableListener::OnStreamAlloc(size_t suggested_size) {\n-  CHECK_NE(previous_listener_, nullptr);\n+  CHECK_NOT_NULL(previous_listener_);\n   return previous_listener_->OnStreamAlloc(suggested_size);\n }\n \n void StreamPipe::WritableListener::OnStreamRead(ssize_t nread,\n                                                 const uv_buf_t& buf) {\n-  CHECK_NE(previous_listener_, nullptr);\n+  CHECK_NOT_NULL(previous_listener_);\n   return previous_listener_->OnStreamRead(nread, buf);\n }\n "
        },
        {
            "sha": "c35df11febb9d248bbe7a61a740611248539d895",
            "filename": "src/stream_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstream_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -287,7 +287,7 @@ int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) {\n void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) {\n   LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(\n       LibuvShutdownWrap::from_req(req));\n-  CHECK_NE(req_wrap, nullptr);\n+  CHECK_NOT_NULL(req_wrap);\n   HandleScope scope(req_wrap->env()->isolate());\n   Context::Scope context_scope(req_wrap->env()->context());\n   req_wrap->Done(status);\n@@ -367,7 +367,7 @@ int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,\n void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) {\n   LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(\n       LibuvWriteWrap::from_req(req));\n-  CHECK_NE(req_wrap, nullptr);\n+  CHECK_NOT_NULL(req_wrap);\n   HandleScope scope(req_wrap->env()->isolate());\n   Context::Scope context_scope(req_wrap->env()->context());\n   req_wrap->Done(status);"
        },
        {
            "sha": "dcc99a09f9b3cdbe69ce05baca2023dc694850f6",
            "filename": "src/string_decoder.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstring_decoder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Fstring_decoder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_decoder.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -266,7 +266,7 @@ namespace {\n void DecodeData(const FunctionCallbackInfo<Value>& args) {\n   StringDecoder* decoder =\n       reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));\n-  CHECK_NE(decoder, nullptr);\n+  CHECK_NOT_NULL(decoder);\n   size_t nread = Buffer::Length(args[1]);\n   MaybeLocal<String> ret =\n       decoder->DecodeData(args.GetIsolate(), Buffer::Data(args[1]), &nread);\n@@ -277,7 +277,7 @@ void DecodeData(const FunctionCallbackInfo<Value>& args) {\n void FlushData(const FunctionCallbackInfo<Value>& args) {\n   StringDecoder* decoder =\n       reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));\n-  CHECK_NE(decoder, nullptr);\n+  CHECK_NOT_NULL(decoder);\n   MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());\n   if (!ret.IsEmpty())\n     args.GetReturnValue().Set(ret.ToLocalChecked());"
        },
        {
            "sha": "e74ee02aaa92d9ca32e6ca344aa25634edd9a86e",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -71,7 +71,7 @@ TLSWrap::TLSWrap(Environment* env,\n   MakeWeak();\n \n   // sc comes from an Unwrap. Make sure it was assigned.\n-  CHECK_NE(sc, nullptr);\n+  CHECK_NOT_NULL(sc);\n \n   // We've our own session callbacks\n   SSL_CTX_sess_set_get_cb(sc_->ctx_.get(),\n@@ -169,7 +169,7 @@ void TLSWrap::Wrap(const FunctionCallbackInfo<Value>& args) {\n                                   SSLWrap<TLSWrap>::kClient;\n \n   StreamBase* stream = static_cast<StreamBase*>(stream_obj->Value());\n-  CHECK_NE(stream, nullptr);\n+  CHECK_NOT_NULL(stream);\n \n   TLSWrap* res = new TLSWrap(env, kind, stream, Unwrap<SecureContext>(sc));\n \n@@ -563,7 +563,7 @@ int TLSWrap::DoWrite(WriteWrap* w,\n                      uv_buf_t* bufs,\n                      size_t count,\n                      uv_stream_t* send_handle) {\n-  CHECK_EQ(send_handle, nullptr);\n+  CHECK_NULL(send_handle);\n \n   if (ssl_ == nullptr) {\n     ClearError();\n@@ -585,7 +585,7 @@ int TLSWrap::DoWrite(WriteWrap* w,\n     // However, if there is any data that should be written to the socket,\n     // the callback should not be invoked immediately\n     if (BIO_pending(enc_out_) == 0) {\n-      CHECK_EQ(current_empty_write_, nullptr);\n+      CHECK_NULL(current_empty_write_);\n       current_empty_write_ = w;\n       StreamWriteResult res =\n           underlying_stream()->Write(bufs, count, send_handle);\n@@ -600,7 +600,7 @@ int TLSWrap::DoWrite(WriteWrap* w,\n   }\n \n   // Store the current write wrap\n-  CHECK_EQ(current_write_, nullptr);\n+  CHECK_NULL(current_write_);\n   current_write_ = w;\n \n   // Write queued data\n@@ -638,7 +638,7 @@ int TLSWrap::DoWrite(WriteWrap* w,\n \n \n uv_buf_t TLSWrap::OnStreamAlloc(size_t suggested_size) {\n-  CHECK_NE(ssl_, nullptr);\n+  CHECK_NOT_NULL(ssl_);\n \n   size_t size = suggested_size;\n   char* base = crypto::NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);\n@@ -709,7 +709,7 @@ void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {\n   CHECK_EQ(args.Length(), 2);\n   CHECK(args[0]->IsBoolean());\n   CHECK(args[1]->IsBoolean());\n-  CHECK_NE(wrap->ssl_, nullptr);\n+  CHECK_NOT_NULL(wrap->ssl_);\n \n   int verify_mode;\n   if (wrap->is_server()) {\n@@ -737,7 +737,7 @@ void TLSWrap::EnableSessionCallbacks(\n     const FunctionCallbackInfo<Value>& args) {\n   TLSWrap* wrap;\n   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n-  CHECK_NE(wrap->ssl_, nullptr);\n+  CHECK_NOT_NULL(wrap->ssl_);\n   wrap->enable_session_callbacks();\n   crypto::NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);\n   wrap->hello_parser_.Start(SSLWrap<TLSWrap>::OnClientHello,\n@@ -784,7 +784,7 @@ void TLSWrap::GetServername(const FunctionCallbackInfo<Value>& args) {\n   TLSWrap* wrap;\n   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n \n-  CHECK_NE(wrap->ssl_, nullptr);\n+  CHECK_NOT_NULL(wrap->ssl_);\n \n   const char* servername = SSL_get_servername(wrap->ssl_.get(),\n                                               TLSEXT_NAMETYPE_host_name);\n@@ -807,7 +807,7 @@ void TLSWrap::SetServername(const FunctionCallbackInfo<Value>& args) {\n   CHECK(!wrap->started_);\n   CHECK(wrap->is_client());\n \n-  CHECK_NE(wrap->ssl_, nullptr);\n+  CHECK_NOT_NULL(wrap->ssl_);\n \n #ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n   node::Utf8Value servername(env->isolate(), args[0].As<String>());\n@@ -847,7 +847,7 @@ int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {\n   p->sni_context_.Reset(env->isolate(), ctx);\n \n   SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());\n-  CHECK_NE(sc, nullptr);\n+  CHECK_NOT_NULL(sc);\n   p->SetSNIContext(sc);\n   return SSL_TLSEXT_ERR_OK;\n }"
        },
        {
            "sha": "069f6d428e7751f6bb94883be22ec4abde5b27fd",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/39f209649fc290fe92cc3b87edfffa6a854ecb03/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=39f209649fc290fe92cc3b87edfffa6a854ecb03",
            "patch": "@@ -129,6 +129,8 @@ void DumpBacktrace(FILE* fp);\n #define CHECK_LE(a, b) CHECK((a) <= (b))\n #define CHECK_LT(a, b) CHECK((a) < (b))\n #define CHECK_NE(a, b) CHECK((a) != (b))\n+#define CHECK_NULL(val) CHECK((val) == nullptr)\n+#define CHECK_NOT_NULL(val) CHECK((val) != nullptr)\n #define CHECK_IMPLIES(a, b) CHECK(!(a) || (b))\n \n #define UNREACHABLE() ABORT()"
        }
    ],
    "stats": {
        "total": 246,
        "additions": 124,
        "deletions": 122
    }
}