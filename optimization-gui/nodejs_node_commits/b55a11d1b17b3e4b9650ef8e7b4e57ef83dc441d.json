{
    "author": "apapirovski",
    "message": "http2: fix responses to long payload reqs\n\nWhen a request with a long payload is received, http2 does\nnot allow a response that does not process all the incoming\npayload. Add a conditional Http2Stream.close call that runs\nonly if the user hasn't attempted to read the stream.\n\nPR-URL: https://github.com/nodejs/node/pull/20084\nFixes: https://github.com/nodejs/node/issues/20060\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
    "files": [
        {
            "sha": "be5d08a0b0a1f53c912d8315acd24023864a89de",
            "filename": "lib/internal/http2/core.js",
            "status": "modified",
            "additions": 98,
            "deletions": 83,
            "changes": 181,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/lib%2Finternal%2Fhttp2%2Fcore.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/lib%2Finternal%2Fhttp2%2Fcore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fhttp2%2Fcore.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -206,6 +206,7 @@ const STREAM_FLAGS_CLOSED = 0x2;\n const STREAM_FLAGS_HEADERS_SENT = 0x4;\n const STREAM_FLAGS_HEAD_REQUEST = 0x8;\n const STREAM_FLAGS_ABORTED = 0x10;\n+const STREAM_FLAGS_HAS_TRAILERS = 0x20;\n \n const SESSION_FLAGS_PENDING = 0x0;\n const SESSION_FLAGS_READY = 0x1;\n@@ -330,26 +331,13 @@ function onStreamClose(code) {\n   if (stream.destroyed)\n     return;\n \n-  const state = stream[kState];\n-\n   debug(`Http2Stream ${stream[kID]} [Http2Session ` +\n         `${sessionName(stream[kSession][kType])}]: closed with code ${code}`);\n \n-  if (!stream.closed) {\n-    // Clear timeout and remove timeout listeners\n-    stream.setTimeout(0);\n-    stream.removeAllListeners('timeout');\n+  if (!stream.closed)\n+    closeStream(stream, code, false);\n \n-    // Set the state flags\n-    state.flags |= STREAM_FLAGS_CLOSED;\n-    state.rstCode = code;\n-\n-    // Close the writable side of the stream\n-    abort(stream);\n-    stream.end();\n-  }\n-\n-  state.fd = -1;\n+  stream[kState].fd = -1;\n   // Defer destroy we actually emit end.\n   if (stream._readableState.endEmitted || code !== NGHTTP2_NO_ERROR) {\n     // If errored or ended, we can destroy immediately.\n@@ -504,7 +492,7 @@ function requestOnConnect(headers, options) {\n \n   // At this point, the stream should have already been destroyed during\n   // the session.destroy() method. Do nothing else.\n-  if (session.destroyed)\n+  if (session === undefined || session.destroyed)\n     return;\n \n   // If the session was closed while waiting for the connect, destroy\n@@ -1412,6 +1400,9 @@ class ClientHttp2Session extends Http2Session {\n     if (options.endStream)\n       stream.end();\n \n+    if (options.waitForTrailers)\n+      stream[kState].flags |= STREAM_FLAGS_HAS_TRAILERS;\n+\n     const onConnect = requestOnConnect.bind(stream, headersList, options);\n     if (this.connecting) {\n       this.on('connect', onConnect);\n@@ -1445,32 +1436,70 @@ function afterDoStreamWrite(status, handle) {\n }\n \n function streamOnResume() {\n-  if (!this.destroyed && !this.pending)\n+  if (!this.destroyed && !this.pending) {\n+    if (!this[kState].didRead)\n+      this[kState].didRead = true;\n     this[kHandle].readStart();\n+  }\n }\n \n function streamOnPause() {\n   if (!this.destroyed && !this.pending)\n     this[kHandle].readStop();\n }\n \n-// If the writable side of the Http2Stream is still open, emit the\n-// 'aborted' event and set the aborted flag.\n-function abort(stream) {\n-  if (!stream.aborted &&\n-      !(stream._writableState.ended || stream._writableState.ending)) {\n-    stream[kState].flags |= STREAM_FLAGS_ABORTED;\n-    stream.emit('aborted');\n-  }\n-}\n-\n function afterShutdown() {\n   this.callback();\n   const stream = this.handle[kOwner];\n   if (stream)\n     stream[kMaybeDestroy]();\n }\n \n+function closeStream(stream, code, shouldSubmitRstStream = true) {\n+  const state = stream[kState];\n+  state.flags |= STREAM_FLAGS_CLOSED;\n+  state.rstCode = code;\n+\n+  // Clear timeout and remove timeout listeners\n+  stream.setTimeout(0);\n+  stream.removeAllListeners('timeout');\n+\n+  const { ending, finished } = stream._writableState;\n+\n+  if (!ending) {\n+    // If the writable side of the Http2Stream is still open, emit the\n+    // 'aborted' event and set the aborted flag.\n+    if (!stream.aborted) {\n+      state.flags |= STREAM_FLAGS_ABORTED;\n+      stream.emit('aborted');\n+    }\n+\n+    // Close the writable side.\n+    stream.end();\n+  }\n+\n+  if (shouldSubmitRstStream) {\n+    const finishFn = finishCloseStream.bind(stream, code);\n+    if (!ending || finished || code !== NGHTTP2_NO_ERROR)\n+      finishFn();\n+    else\n+      stream.once('finish', finishFn);\n+  }\n+}\n+\n+function finishCloseStream(code) {\n+  const rstStreamFn = submitRstStream.bind(this, code);\n+  // If the handle has not yet been assigned, queue up the request to\n+  // ensure that the RST_STREAM frame is sent after the stream ID has\n+  // been determined.\n+  if (this.pending) {\n+    this.push(null);\n+    this.once('ready', rstStreamFn);\n+    return;\n+  }\n+  rstStreamFn();\n+}\n+\n // An Http2Stream is a Duplex stream that is backed by a\n // node::http2::Http2Stream handle implementing StreamBase.\n class Http2Stream extends Duplex {\n@@ -1490,6 +1519,7 @@ class Http2Stream extends Duplex {\n     this[kTimeout] = null;\n \n     this[kState] = {\n+      didRead: false,\n       flags: STREAM_FLAGS_PENDING,\n       rstCode: NGHTTP2_NO_ERROR,\n       writeQueueSize: 0,\n@@ -1756,6 +1786,8 @@ class Http2Stream extends Duplex {\n       throw headersList;\n     this[kSentTrailers] = headers;\n \n+    this[kState].flags &= ~STREAM_FLAGS_HAS_TRAILERS;\n+\n     const ret = this[kHandle].trailers(headersList);\n     if (ret < 0)\n       this.destroy(new NghttpError(ret));\n@@ -1786,38 +1818,13 @@ class Http2Stream extends Duplex {\n     if (callback !== undefined && typeof callback !== 'function')\n       throw new ERR_INVALID_CALLBACK();\n \n-    // Clear timeout and remove timeout listeners\n-    this.setTimeout(0);\n-    this.removeAllListeners('timeout');\n-\n-    // Close the writable\n-    abort(this);\n-    this.end();\n-\n     if (this.closed)\n       return;\n \n-    const state = this[kState];\n-    state.flags |= STREAM_FLAGS_CLOSED;\n-    state.rstCode = code;\n-\n-    if (callback !== undefined) {\n+    if (callback !== undefined)\n       this.once('close', callback);\n-    }\n-\n-    if (this[kHandle] === undefined)\n-      return;\n \n-    const rstStreamFn = submitRstStream.bind(this, code);\n-    // If the handle has not yet been assigned, queue up the request to\n-    // ensure that the RST_STREAM frame is sent after the stream ID has\n-    // been determined.\n-    if (this.pending) {\n-      this.push(null);\n-      this.once('ready', rstStreamFn);\n-      return;\n-    }\n-    rstStreamFn();\n+    closeStream(this, code);\n   }\n \n   // Called by this.destroy().\n@@ -1832,26 +1839,19 @@ class Http2Stream extends Duplex {\n     debug(`Http2Stream ${this[kID] || '<pending>'} [Http2Session ` +\n           `${sessionName(session[kType])}]: destroying stream`);\n     const state = this[kState];\n-    const code = state.rstCode =\n-      err != null ?\n-        NGHTTP2_INTERNAL_ERROR :\n-        state.rstCode || NGHTTP2_NO_ERROR;\n-    if (handle !== undefined) {\n-      // If the handle exists, we need to close, then destroy the handle\n-      this.close(code);\n-      if (!this._readableState.ended && !this._readableState.ending)\n-        this.push(null);\n+    const code = err != null ?\n+      NGHTTP2_INTERNAL_ERROR : (state.rstCode || NGHTTP2_NO_ERROR);\n+\n+    const hasHandle = handle !== undefined;\n+\n+    if (!this.closed)\n+      closeStream(this, code, hasHandle);\n+    this.push(null);\n+\n+    if (hasHandle) {\n       handle.destroy();\n       session[kState].streams.delete(id);\n     } else {\n-      // Clear timeout and remove timeout listeners\n-      this.setTimeout(0);\n-      this.removeAllListeners('timeout');\n-\n-      state.flags |= STREAM_FLAGS_CLOSED;\n-      abort(this);\n-      this.end();\n-      this.push(null);\n       session[kState].pendingStreams.delete(this);\n     }\n \n@@ -1884,13 +1884,23 @@ class Http2Stream extends Duplex {\n     }\n \n     // TODO(mcollina): remove usage of _*State properties\n-    if (this._readableState.ended &&\n-        this._writableState.ended &&\n-        this._writableState.pendingcb === 0 &&\n-        this.closed) {\n-      this.destroy();\n-      // This should return, but eslint complains.\n-      // return\n+    if (this._writableState.ended && this._writableState.pendingcb === 0) {\n+      if (this._readableState.ended && this.closed) {\n+        this.destroy();\n+        return;\n+      }\n+\n+      // We've submitted a response from our server session, have not attempted\n+      // to process any incoming data, and have no trailers. This means we can\n+      // attempt to gracefully close the session.\n+      const state = this[kState];\n+      if (this.headersSent &&\n+          this[kSession][kType] === NGHTTP2_SESSION_SERVER &&\n+          !(state.flags & STREAM_FLAGS_HAS_TRAILERS) &&\n+          !state.didRead &&\n+          !this._readableState.resumeScheduled) {\n+        this.close();\n+      }\n     }\n   }\n }\n@@ -2095,7 +2105,6 @@ function afterOpen(session, options, headers, streamOptions, err, fd) {\n   }\n   if (this.destroyed || this.closed) {\n     tryClose(fd);\n-    abort(this);\n     return;\n   }\n   state.fd = fd;\n@@ -2224,8 +2233,10 @@ class ServerHttp2Stream extends Http2Stream {\n     if (options.endStream)\n       streamOptions |= STREAM_OPTION_EMPTY_PAYLOAD;\n \n-    if (options.waitForTrailers)\n+    if (options.waitForTrailers) {\n       streamOptions |= STREAM_OPTION_GET_TRAILERS;\n+      state.flags |= STREAM_FLAGS_HAS_TRAILERS;\n+    }\n \n     headers = processHeaders(headers);\n     const statusCode = headers[HTTP2_HEADER_STATUS] |= 0;\n@@ -2285,8 +2296,10 @@ class ServerHttp2Stream extends Http2Stream {\n     }\n \n     let streamOptions = 0;\n-    if (options.waitForTrailers)\n+    if (options.waitForTrailers) {\n       streamOptions |= STREAM_OPTION_GET_TRAILERS;\n+      this[kState].flags |= STREAM_FLAGS_HAS_TRAILERS;\n+    }\n \n     if (typeof fd !== 'number')\n       throw new ERR_INVALID_ARG_TYPE('fd', 'number', fd);\n@@ -2346,8 +2359,10 @@ class ServerHttp2Stream extends Http2Stream {\n     }\n \n     let streamOptions = 0;\n-    if (options.waitForTrailers)\n+    if (options.waitForTrailers) {\n       streamOptions |= STREAM_OPTION_GET_TRAILERS;\n+      this[kState].flags |= STREAM_FLAGS_HAS_TRAILERS;\n+    }\n \n     const session = this[kSession];\n     debug(`Http2Stream ${this[kID]} [Http2Session ` +"
        },
        {
            "sha": "05d9243ee30ec043234bb751b02d30a959a85a23",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 52,
            "deletions": 17,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -1364,16 +1364,35 @@ void Http2Session::MaybeScheduleWrite() {\n // storage for data and metadata that was associated with these writes.\n void Http2Session::ClearOutgoing(int status) {\n   CHECK_NE(flags_ & SESSION_STATE_SENDING, 0);\n-  flags_ &= ~SESSION_STATE_SENDING;\n \n-  for (const nghttp2_stream_write& wr : outgoing_buffers_) {\n-    WriteWrap* wrap = wr.req_wrap;\n-    if (wrap != nullptr)\n-      wrap->Done(status);\n+  if (outgoing_buffers_.size() > 0) {\n+    outgoing_storage_.clear();\n+\n+    for (const nghttp2_stream_write& wr : outgoing_buffers_) {\n+      WriteWrap* wrap = wr.req_wrap;\n+      if (wrap != nullptr)\n+        wrap->Done(status);\n+    }\n+\n+    outgoing_buffers_.clear();\n   }\n \n-  outgoing_buffers_.clear();\n-  outgoing_storage_.clear();\n+  flags_ &= ~SESSION_STATE_SENDING;\n+\n+  // Now that we've finished sending queued data, if there are any pending\n+  // RstStreams we should try sending again and then flush them one by one.\n+  if (pending_rst_streams_.size() > 0) {\n+    std::vector<int32_t> current_pending_rst_streams;\n+    pending_rst_streams_.swap(current_pending_rst_streams);\n+\n+    SendPendingData();\n+\n+    for (int32_t stream_id : current_pending_rst_streams) {\n+      Http2Stream* stream = FindStream(stream_id);\n+      if (stream != nullptr)\n+        stream->FlushRstStream();\n+    }\n+  }\n }\n \n // Queue a given block of data for sending. This always creates a copy,\n@@ -1397,18 +1416,19 @@ void Http2Session::CopyDataIntoOutgoing(const uint8_t* src, size_t src_length) {\n // chunk out to the i/o socket to be sent. This is a particularly hot method\n // that will generally be called at least twice be event loop iteration.\n // This is a potential performance optimization target later.\n-void Http2Session::SendPendingData() {\n+// Returns non-zero value if a write is already in progress.\n+uint8_t Http2Session::SendPendingData() {\n   DEBUG_HTTP2SESSION(this, \"sending pending data\");\n   // Do not attempt to send data on the socket if the destroying flag has\n   // been set. That means everything is shutting down and the socket\n   // will not be usable.\n   if (IsDestroyed())\n-    return;\n+    return 0;\n   flags_ &= ~SESSION_STATE_WRITE_SCHEDULED;\n \n   // SendPendingData should not be called recursively.\n   if (flags_ & SESSION_STATE_SENDING)\n-    return;\n+    return 1;\n   // This is cleared by ClearOutgoing().\n   flags_ |= SESSION_STATE_SENDING;\n \n@@ -1432,15 +1452,15 @@ void Http2Session::SendPendingData() {\n     // does take care of things like closing the individual streams after\n     // a socket has been torn down, so we still need to call it.\n     ClearOutgoing(UV_ECANCELED);\n-    return;\n+    return 0;\n   }\n \n   // Part Two: Pass Data to the underlying stream\n \n   size_t count = outgoing_buffers_.size();\n   if (count == 0) {\n-    flags_ &= ~SESSION_STATE_SENDING;\n-    return;\n+    ClearOutgoing(0);\n+    return 0;\n   }\n   MaybeStackBuffer<uv_buf_t, 32> bufs;\n   bufs.AllocateSufficientStorage(count);\n@@ -1471,6 +1491,8 @@ void Http2Session::SendPendingData() {\n \n   DEBUG_HTTP2SESSION2(this, \"wants data in return? %d\",\n                       nghttp2_session_want_read(session_));\n+\n+  return 0;\n }\n \n \n@@ -1830,12 +1852,25 @@ int Http2Stream::SubmitPriority(nghttp2_priority_spec* prispec,\n // peer.\n void Http2Stream::SubmitRstStream(const uint32_t code) {\n   CHECK(!this->IsDestroyed());\n+  code_ = code;\n+  // If possible, force a purge of any currently pending data here to make sure\n+  // it is sent before closing the stream. If it returns non-zero then we need\n+  // to wait until the current write finishes and try again to avoid nghttp2\n+  // behaviour where it prioritizes RstStream over everything else.\n+  if (session_->SendPendingData() != 0) {\n+    session_->AddPendingRstStream(id_);\n+    return;\n+  }\n+\n+  FlushRstStream();\n+}\n+\n+void Http2Stream::FlushRstStream() {\n+  if (IsDestroyed())\n+    return;\n   Http2Scope h2scope(this);\n-  // Force a purge of any currently pending data here to make sure\n-  // it is sent before closing the stream.\n-  session_->SendPendingData();\n   CHECK_EQ(nghttp2_submit_rst_stream(**session_, NGHTTP2_FLAG_NONE,\n-                                     id_, code), 0);\n+                                     id_, code_), 0);\n }\n \n "
        },
        {
            "sha": "da404841450f274b723fdf746d839226851a41ff",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -591,6 +591,8 @@ class Http2Stream : public AsyncWrap,\n   // Submits an RST_STREAM frame using the given code\n   void SubmitRstStream(const uint32_t code);\n \n+  void FlushRstStream();\n+\n   // Submits a PUSH_PROMISE frame with this stream as the parent.\n   Http2Stream* SubmitPushPromise(\n       nghttp2_nv* nva,\n@@ -797,7 +799,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   bool Ping(v8::Local<v8::Function> function);\n \n-  void SendPendingData();\n+  uint8_t SendPendingData();\n \n   // Submits a new request. If the request is a success, assigned\n   // will be a pointer to the Http2Stream instance assigned.\n@@ -845,6 +847,11 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   size_t self_size() const override { return sizeof(*this); }\n \n+  // Schedule an RstStream for after the current write finishes.\n+  inline void AddPendingRstStream(int32_t stream_id) {\n+    pending_rst_streams_.emplace_back(stream_id);\n+  }\n+\n   // Handle reads/writes from the underlying network transport.\n   void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n   void OnStreamAfterWrite(WriteWrap* w, int status) override;\n@@ -1049,6 +1056,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   std::vector<nghttp2_stream_write> outgoing_buffers_;\n   std::vector<uint8_t> outgoing_storage_;\n+  std::vector<int32_t> pending_rst_streams_;\n \n   void CopyDataIntoOutgoing(const uint8_t* src, size_t src_length);\n   void ClearOutgoing(int status);"
        },
        {
            "sha": "3d0d0af42375c3e696731294deea165f132a5797",
            "filename": "test/fixtures/person-large.jpg",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Ffixtures%2Fperson-large.jpg",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Ffixtures%2Fperson-large.jpg",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Ffixtures%2Fperson-large.jpg?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d"
        },
        {
            "sha": "e641335e75128733a42b9155061a2eed7d2fdad1",
            "filename": "test/parallel/test-http2-client-destroy.js",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-client-destroy.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -124,3 +124,21 @@ const Countdown = require('../common/countdown');\n     req.on('error', () => {});\n   }));\n }\n+\n+// test destroy before connect\n+{\n+  const server = h2.createServer();\n+  server.on('stream', common.mustNotCall());\n+\n+  server.listen(0, common.mustCall(() => {\n+    const client = h2.connect(`http://localhost:${server.address().port}`);\n+\n+    server.on('connection', common.mustCall(() => {\n+      server.close();\n+      client.close();\n+    }));\n+\n+    const req = client.request();\n+    req.destroy();\n+  }));\n+}"
        },
        {
            "sha": "33e22130aad19b6b06dbee89647994c417dca22d",
            "filename": "test/parallel/test-http2-client-rststream-before-connect.js",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-rststream-before-connect.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-rststream-before-connect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-client-rststream-before-connect.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -63,8 +63,14 @@ server.listen(0, common.mustCall(() => {\n     message: 'Stream closed with error code NGHTTP2_PROTOCOL_ERROR'\n   }));\n \n-  req.on('response', common.mustCall());\n-  req.resume();\n+  // The `response` event should not fire as the server should receive the\n+  // RST_STREAM frame before it ever has a chance to reply.\n+  req.on('response', common.mustNotCall());\n+\n+  // The `end` event should still fire as we close the readable stream by\n+  // pushing a `null` chunk.\n   req.on('end', common.mustCall());\n+\n+  req.resume();\n   req.end();\n }));"
        },
        {
            "sha": "ece7cbdf233f1f2bdb1ea009be7d5e2105a548e6",
            "filename": "test/parallel/test-http2-client-upload-reject.js",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-upload-reject.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-upload-reject.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-client-upload-reject.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -0,0 +1,48 @@\n+'use strict';\n+\n+// Verifies that uploading data from a client works\n+\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+const assert = require('assert');\n+const http2 = require('http2');\n+const fs = require('fs');\n+const fixtures = require('../common/fixtures');\n+\n+const loc = fixtures.path('person-large.jpg');\n+\n+assert(fs.existsSync(loc));\n+\n+fs.readFile(loc, common.mustCall((err, data) => {\n+  assert.ifError(err);\n+\n+  const server = http2.createServer();\n+\n+  server.on('stream', common.mustCall((stream) => {\n+    stream.on('close', common.mustCall(() => {\n+      assert.strictEqual(stream.rstCode, 0);\n+    }));\n+\n+    stream.respond({ ':status': 400 });\n+    stream.end();\n+  }));\n+\n+  server.listen(0, common.mustCall(() => {\n+    const client = http2.connect(`http://localhost:${server.address().port}`);\n+\n+    const req = client.request({ ':method': 'POST' });\n+    req.on('response', common.mustCall((headers) => {\n+      assert.strictEqual(headers[':status'], 400);\n+    }));\n+\n+    req.resume();\n+    req.on('end', common.mustCall(() => {\n+      server.close();\n+      client.close();\n+    }));\n+\n+    const str = fs.createReadStream(loc);\n+    str.pipe(req);\n+  }));\n+}));"
        },
        {
            "sha": "78c6d47cbb4f4484fc4464c1b0a0cb4a7fc97a85",
            "filename": "test/parallel/test-http2-client-upload.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-upload.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-client-upload.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-client-upload.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -11,7 +11,7 @@ const fs = require('fs');\n const fixtures = require('../common/fixtures');\n const Countdown = require('../common/countdown');\n \n-const loc = fixtures.path('person.jpg');\n+const loc = fixtures.path('person-large.jpg');\n let fileData;\n \n assert(fs.existsSync(loc));"
        },
        {
            "sha": "f9dee357d6da7b6ce86157b9bc4a4311a52f6aba",
            "filename": "test/parallel/test-http2-large-write-close.js",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-large-write-close.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-large-write-close.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-large-write-close.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -0,0 +1,44 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+const assert = require('assert');\n+const fixtures = require('../common/fixtures');\n+const http2 = require('http2');\n+\n+const content = Buffer.alloc(1e5, 0x44);\n+\n+const server = http2.createSecureServer({\n+  key: fixtures.readKey('agent1-key.pem'),\n+  cert: fixtures.readKey('agent1-cert.pem')\n+});\n+server.on('stream', common.mustCall((stream) => {\n+  stream.respond({\n+    'Content-Type': 'application/octet-stream',\n+    'Content-Length': (content.length.toString() * 2),\n+    'Vary': 'Accept-Encoding'\n+  });\n+\n+  stream.write(content);\n+  stream.write(content);\n+  stream.end();\n+  stream.close();\n+}));\n+\n+server.listen(0, common.mustCall(() => {\n+  const client = http2.connect(`https://localhost:${server.address().port}`,\n+                               { rejectUnauthorized: false });\n+\n+  const req = client.request({ ':path': '/' });\n+  req.end();\n+\n+  let receivedBufferLength = 0;\n+  req.on('data', common.mustCallAtLeast((buf) => {\n+    receivedBufferLength += buf.length;\n+  }, 1));\n+  req.on('close', common.mustCall(() => {\n+    assert.strictEqual(receivedBufferLength, content.length * 2);\n+    client.close();\n+    server.close();\n+  }));\n+}));"
        },
        {
            "sha": "5dd8ad0f6d883bf8a184e8e77684841fd4ecb7df",
            "filename": "test/parallel/test-http2-perf_hooks.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-perf_hooks.js",
            "raw_url": "https://github.com/nodejs/node/raw/b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d/test%2Fparallel%2Ftest-http2-perf_hooks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-perf_hooks.js?ref=b55a11d1b17b3e4b9650ef8e7b4e57ef83dc441d",
            "patch": "@@ -26,7 +26,7 @@ const obs = new PerformanceObserver(common.mustCall((items) => {\n       switch (entry.type) {\n         case 'server':\n           assert.strictEqual(entry.streamCount, 1);\n-          assert.strictEqual(entry.framesReceived, 5);\n+          assert(entry.framesReceived >= 3);\n           break;\n         case 'client':\n           assert.strictEqual(entry.streamCount, 1);"
        }
    ],
    "stats": {
        "total": 384,
        "additions": 279,
        "deletions": 105
    }
}