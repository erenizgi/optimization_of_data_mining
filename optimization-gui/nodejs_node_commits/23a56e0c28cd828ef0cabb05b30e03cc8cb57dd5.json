{
    "author": "apapirovski",
    "message": "timers: use only a single TimerWrap instance\n\nHang all timer lists off a single TimerWrap and use the PriorityQueue\nto manage expiration priorities. This makes the Timers code clearer,\nconsumes significantly less resources and improves performance.\n\nPR-URL: https://github.com/nodejs/node/pull/20555\nFixes: https://github.com/nodejs/node/issues/16105\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
    "files": [
        {
            "sha": "1daf68bde0ed515c864039241a4c513bd623fc1b",
            "filename": "benchmark/timers/timers-cancel-unpooled.js",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/benchmark%2Ftimers%2Ftimers-cancel-unpooled.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/benchmark%2Ftimers%2Ftimers-cancel-unpooled.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ftimers%2Ftimers-cancel-unpooled.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -4,18 +4,26 @@ const assert = require('assert');\n \n const bench = common.createBenchmark(main, {\n   n: [1e6],\n+  direction: ['start', 'end']\n });\n \n-function main({ n }) {\n+function main({ n, direction }) {\n \n   const timersList = [];\n   for (var i = 0; i < n; i++) {\n     timersList.push(setTimeout(cb, i + 1));\n   }\n \n+  var j;\n   bench.start();\n-  for (var j = 0; j < n + 1; j++) {\n-    clearTimeout(timersList[j]);\n+  if (direction === 'start') {\n+    for (j = 0; j < n; j++) {\n+      clearTimeout(timersList[j]);\n+    }\n+  } else {\n+    for (j = n - 1; j >= 0; j--) {\n+      clearTimeout(timersList[j]);\n+    }\n   }\n   bench.end(n);\n }"
        },
        {
            "sha": "232cc7c31aff167586237066c561059193d1055f",
            "filename": "benchmark/timers/timers-insert-unpooled.js",
            "status": "modified",
            "additions": 12,
            "deletions": 4,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/benchmark%2Ftimers%2Ftimers-insert-unpooled.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/benchmark%2Ftimers%2Ftimers-insert-unpooled.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ftimers%2Ftimers-insert-unpooled.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -4,18 +4,26 @@ const assert = require('assert');\n \n const bench = common.createBenchmark(main, {\n   n: [1e6],\n+  direction: ['start', 'end']\n });\n \n-function main({ n }) {\n+function main({ direction, n }) {\n   const timersList = [];\n \n+  var i;\n   bench.start();\n-  for (var i = 0; i < n; i++) {\n-    timersList.push(setTimeout(cb, i + 1));\n+  if (direction === 'start') {\n+    for (i = 1; i <= n; i++) {\n+      timersList.push(setTimeout(cb, i));\n+    }\n+  } else {\n+    for (i = n; i > 0; i--) {\n+      timersList.push(setTimeout(cb, i));\n+    }\n   }\n   bench.end(n);\n \n-  for (var j = 0; j < n + 1; j++) {\n+  for (var j = 0; j < n; j++) {\n     clearTimeout(timersList[j]);\n   }\n }"
        },
        {
            "sha": "44ebc65dc1d4aa9d896157a1ac9c1ae1d658c5d4",
            "filename": "lib/internal/timers.js",
            "status": "modified",
            "additions": 8,
            "deletions": 14,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/lib%2Finternal%2Ftimers.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/lib%2Finternal%2Ftimers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ftimers.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -19,14 +19,15 @@ const {\n // Timeout values > TIMEOUT_MAX are set to 1.\n const TIMEOUT_MAX = 2 ** 31 - 1;\n \n-const unrefedSymbol = Symbol('unrefed');\n+const kRefed = Symbol('refed');\n \n module.exports = {\n   TIMEOUT_MAX,\n   kTimeout: Symbol('timeout'), // For hiding Timeouts on other internals.\n   async_id_symbol,\n   trigger_async_id_symbol,\n   Timeout,\n+  kRefed,\n   initAsyncResource,\n   setUnrefTimeout,\n   validateTimerDuration\n@@ -50,7 +51,7 @@ function initAsyncResource(resource, type) {\n \n // Timer constructor function.\n // The entire prototype is defined in lib/timers.js\n-function Timeout(callback, after, args, isRepeat, isUnrefed) {\n+function Timeout(callback, after, args, isRepeat) {\n   after *= 1; // coalesce to number or NaN\n   if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n     if (after > TIMEOUT_MAX) {\n@@ -62,7 +63,6 @@ function Timeout(callback, after, args, isRepeat, isUnrefed) {\n     after = 1; // schedule on next tick, follows browser behavior\n   }\n \n-  this._called = false;\n   this._idleTimeout = after;\n   this._idlePrev = this;\n   this._idleNext = this;\n@@ -75,22 +75,16 @@ function Timeout(callback, after, args, isRepeat, isUnrefed) {\n   this._repeat = isRepeat ? after : null;\n   this._destroyed = false;\n \n-  this[unrefedSymbol] = isUnrefed;\n+  this[kRefed] = null;\n \n   initAsyncResource(this, 'Timeout');\n }\n \n Timeout.prototype.refresh = function() {\n-  if (this._handle) {\n-    // Would be more ideal with uv_timer_again(), however that API does not\n-    // cause libuv's sorted timers data structure (a binary heap at the time\n-    // of writing) to re-sort itself. This causes ordering inconsistencies.\n-    this._handle.start(this._idleTimeout);\n-  } else if (this[unrefedSymbol]) {\n-    getTimers()._unrefActive(this);\n-  } else {\n+  if (this[kRefed])\n     getTimers().active(this);\n-  }\n+  else\n+    getTimers()._unrefActive(this);\n \n   return this;\n };\n@@ -122,7 +116,7 @@ function setUnrefTimeout(callback, after, arg1, arg2, arg3) {\n       break;\n   }\n \n-  const timer = new Timeout(callback, after, args, false, true);\n+  const timer = new Timeout(callback, after, args, false);\n   getTimers()._unrefActive(timer);\n \n   return timer;"
        },
        {
            "sha": "3d200344a4589a3a6fd369da7087a8775ba1d77e",
            "filename": "lib/timers.js",
            "status": "modified",
            "additions": 177,
            "deletions": 198,
            "changes": 375,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/lib%2Ftimers.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/lib%2Ftimers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ftimers.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -26,16 +26,17 @@ const {\n   setupTimers,\n } = process.binding('timer_wrap');\n const L = require('internal/linkedlist');\n+const PriorityQueue = require('internal/priority_queue');\n const {\n   async_id_symbol,\n   trigger_async_id_symbol,\n   Timeout,\n+  kRefed,\n   initAsyncResource,\n   validateTimerDuration\n } = require('internal/timers');\n const internalUtil = require('internal/util');\n const { createPromise, promiseResolve } = process.binding('util');\n-const assert = require('assert');\n const util = require('util');\n const { ERR_INVALID_CALLBACK } = require('internal/errors').codes;\n const debug = util.debuglog('timer');\n@@ -55,8 +56,6 @@ const kHasOutstanding = 2;\n const [immediateInfo, toggleImmediateRef] =\n   setupTimers(processImmediate, processTimers);\n \n-const kRefed = Symbol('refed');\n-\n // HOW and WHY the timers implementation works the way it does.\n //\n // Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n@@ -85,20 +84,17 @@ const kRefed = Symbol('refed');\n //\n // Object maps are kept which contain linked lists keyed by their duration in\n // milliseconds.\n-// The linked lists within also have some meta-properties, one of which is a\n-// TimerWrap C++ handle, which makes the call after the duration to process the\n-// list it is attached to.\n //\n /* eslint-disable node-core/non-ascii-character */\n //\n // ╔════ > Object Map\n // ║\n // ╠══\n-// ║ refedLists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n-// ╚══          ┌─────────┘\n+// ║ lists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n+// ╚══          ┌────┘\n //              │\n // ╔══          │\n-// ║ TimersList { _idleNext: { }, _idlePrev: (self), _timer: (TimerWrap) }\n+// ║ TimersList { _idleNext: { }, _idlePrev: (self) }\n // ║         ┌────────────────┘\n // ║    ╔══  │                              ^\n // ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n@@ -126,36 +122,73 @@ const kRefed = Symbol('refed');\n // always be due to timeout at a later time.\n //\n // Less-than constant time operations are thus contained in two places:\n-// TimerWrap's backing libuv timers implementation (a performant heap-based\n-// queue), and the object map lookup of a specific list by the duration of\n-// timers within (or creation of a new list).\n-// However, these operations combined have shown to be trivial in comparison to\n-// other alternative timers architectures.\n+// The PriorityQueue — an efficient binary heap implementation that does all\n+// operations in worst-case O(log n) time — which manages the order of expiring\n+// Timeout lists and the object map lookup of a specific list by the duration of\n+// timers within (or creation of a new list). However, these operations combined\n+// have shown to be trivial in comparison to other timers architectures.\n \n \n-// Object maps containing linked lists of timers, keyed and sorted by their\n+// Object map containing linked lists of timers, keyed and sorted by their\n // duration in milliseconds.\n //\n-// The difference between these two objects is that the former contains timers\n-// that will keep the process open if they are the only thing left, while the\n-// latter will not.\n-//\n // - key = time in milliseconds\n // - value = linked list\n-const refedLists = Object.create(null);\n-const unrefedLists = Object.create(null);\n+const lists = Object.create(null);\n+\n+// This is a priority queue with a custom sorting function that first compares\n+// the expiry times of two lists and if they're the same then compares their\n+// individual IDs to determine which list was created first.\n+const queue = new PriorityQueue(compareTimersLists, setPosition);\n+\n+function compareTimersLists(a, b) {\n+  const expiryDiff = a.expiry - b.expiry;\n+  if (expiryDiff === 0) {\n+    if (a.id < b.id)\n+      return -1;\n+    if (a.id > b.id)\n+      return 1;\n+  }\n+  return expiryDiff;\n+}\n+\n+function setPosition(node, pos) {\n+  node.priorityQueuePosition = pos;\n+}\n \n+let handle = null;\n+let nextExpiry = Infinity;\n+\n+let timerListId = Number.MIN_SAFE_INTEGER;\n+let refCount = 0;\n+\n+function incRefCount() {\n+  if (refCount++ === 0)\n+    handle.ref();\n+}\n+\n+function decRefCount() {\n+  if (--refCount === 0)\n+    handle.unref();\n+}\n+\n+function createHandle(refed) {\n+  debug('initial run, creating TimerWrap handle');\n+  handle = new TimerWrap();\n+  if (!refed)\n+    handle.unref();\n+}\n \n // Schedule or re-schedule a timer.\n // The item must have been enroll()'d first.\n const active = exports.active = function(item) {\n-  insert(item, false);\n+  insert(item, true, TimerWrap.now());\n };\n \n // Internal APIs that need timeouts should use `_unrefActive()` instead of\n // `active()` so that they do not unnecessarily keep the process open.\n exports._unrefActive = function(item) {\n-  insert(item, true);\n+  insert(item, false, TimerWrap.now());\n };\n \n \n@@ -164,56 +197,83 @@ exports._unrefActive = function(item) {\n // Appends a timer onto the end of an existing timers list, or creates a new\n // TimerWrap backed list if one does not already exist for the specified timeout\n // duration.\n-function insert(item, unrefed, start) {\n+function insert(item, refed, start) {\n   const msecs = item._idleTimeout;\n-  if (msecs < 0 || msecs === undefined) return;\n-\n-  if (typeof start === 'number') {\n-    item._idleStart = start;\n-  } else {\n-    item._idleStart = TimerWrap.now();\n-  }\n+  if (msecs < 0 || msecs === undefined)\n+    return;\n \n-  const lists = unrefed === true ? unrefedLists : refedLists;\n+  item._idleStart = start;\n \n   // Use an existing list if there is one, otherwise we need to make a new one.\n   var list = lists[msecs];\n   if (list === undefined) {\n     debug('no %d list was found in insert, creating a new one', msecs);\n-    lists[msecs] = list = new TimersList(msecs, unrefed);\n+    const expiry = start + msecs;\n+    lists[msecs] = list = new TimersList(expiry, msecs);\n+    queue.insert(list);\n+\n+    if (nextExpiry > expiry) {\n+      if (handle === null)\n+        createHandle(refed);\n+      handle.start(msecs);\n+      nextExpiry = expiry;\n+    }\n   }\n \n   if (!item[async_id_symbol] || item._destroyed) {\n     item._destroyed = false;\n     initAsyncResource(item, 'Timeout');\n   }\n \n+  if (refed === !item[kRefed]) {\n+    if (refed)\n+      incRefCount();\n+    else\n+      decRefCount();\n+  }\n+  item[kRefed] = refed;\n+\n   L.append(list, item);\n-  assert(!L.isEmpty(list)); // list is not empty\n }\n \n-function TimersList(msecs, unrefed) {\n+function TimersList(expiry, msecs) {\n   this._idleNext = this; // Create the list with the linkedlist properties to\n   this._idlePrev = this; // prevent any unnecessary hidden class changes.\n-  this._unrefed = unrefed;\n+  this.expiry = expiry;\n+  this.id = timerListId++;\n   this.msecs = msecs;\n-\n-  const timer = this._timer = new TimerWrap();\n-  timer._list = this;\n-\n-  if (unrefed === true)\n-    timer.unref();\n-  timer.start(msecs);\n+  this.priorityQueuePosition = null;\n }\n \n+const { _tickCallback: runNextTicks } = process;\n function processTimers(now) {\n-  if (this.owner)\n-    return unrefdHandle(this.owner, now);\n-  return listOnTimeout(this, now);\n+  debug('process timer lists %d', now);\n+  nextExpiry = Infinity;\n+\n+  let list, ran;\n+  while (list = queue.peek()) {\n+    if (list.expiry > now)\n+      break;\n+    if (ran)\n+      runNextTicks();\n+    listOnTimeout(list, now);\n+    ran = true;\n+  }\n+\n+  if (refCount > 0)\n+    handle.ref();\n+  else\n+    handle.unref();\n+\n+  if (list !== undefined) {\n+    nextExpiry = list.expiry;\n+    handle.start(Math.max(nextExpiry - TimerWrap.now(), 1));\n+  }\n+\n+  return true;\n }\n \n-function listOnTimeout(handle, now) {\n-  const list = handle._list;\n+function listOnTimeout(list, now) {\n   const msecs = list.msecs;\n \n   debug('timeout callback %d', msecs);\n@@ -226,122 +286,105 @@ function listOnTimeout(handle, now) {\n     // Check if this loop iteration is too early for the next timer.\n     // This happens if there are more timers scheduled for later in the list.\n     if (diff < msecs) {\n-      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);\n-      if (timeRemaining <= 0) {\n-        timeRemaining = 1;\n-      }\n-      handle.start(timeRemaining);\n+      list.expiry = timer._idleStart + msecs;\n+      list.id = timerListId++;\n+      queue.percolateDown(1);\n       debug('%d list wait because diff is %d', msecs, diff);\n-      return true;\n+      return;\n     }\n \n     // The actual logic for when a timeout happens.\n-\n     L.remove(timer);\n-    assert(timer !== L.peek(list));\n+\n+    const asyncId = timer[async_id_symbol];\n \n     if (!timer._onTimeout) {\n-      if (destroyHooksExist() && !timer._destroyed &&\n-            typeof timer[async_id_symbol] === 'number') {\n-        emitDestroy(timer[async_id_symbol]);\n+      if (timer[kRefed])\n+        refCount--;\n+      timer[kRefed] = null;\n+\n+      if (destroyHooksExist() && !timer._destroyed) {\n+        emitDestroy(asyncId);\n         timer._destroyed = true;\n       }\n       continue;\n     }\n \n+    emitBefore(asyncId, timer[trigger_async_id_symbol]);\n+\n     tryOnTimeout(timer);\n+\n+    emitAfter(asyncId);\n   }\n \n   // If `L.peek(list)` returned nothing, the list was either empty or we have\n   // called all of the timer timeouts.\n-  // As such, we can remove the list and clean up the TimerWrap C++ handle.\n+  // As such, we can remove the list from the object map and the PriorityQueue.\n   debug('%d list empty', msecs);\n-  assert(L.isEmpty(list));\n-\n-  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and\n-  // recreated since the reference to `list` was created. Make sure they're\n-  // the same instance of the list before destroying.\n-  if (list._unrefed === true && list === unrefedLists[msecs]) {\n-    delete unrefedLists[msecs];\n-  } else if (list === refedLists[msecs]) {\n-    delete refedLists[msecs];\n-  }\n-\n-  // Do not close the underlying handle if its ownership has changed\n-  // (e.g it was unrefed in its callback).\n-  if (!handle.owner)\n-    handle.close();\n \n-  return true;\n+  // The current list may have been removed and recreated since the reference\n+  // to `list` was created. Make sure they're the same instance of the list\n+  // before destroying.\n+  if (list === lists[msecs]) {\n+    delete lists[msecs];\n+    queue.shift();\n+  }\n }\n \n \n // An optimization so that the try/finally only de-optimizes (since at least v8\n // 4.7) what is in this smaller function.\n function tryOnTimeout(timer, start) {\n-  timer._called = true;\n-  const timerAsyncId = (typeof timer[async_id_symbol] === 'number') ?\n-    timer[async_id_symbol] : null;\n-  var threw = true;\n-  if (timerAsyncId !== null)\n-    emitBefore(timerAsyncId, timer[trigger_async_id_symbol]);\n   if (start === undefined && timer._repeat)\n     start = TimerWrap.now();\n   try {\n     ontimeout(timer);\n-    threw = false;\n   } finally {\n-    if (timerAsyncId !== null) {\n-      if (!threw)\n-        emitAfter(timerAsyncId);\n-      if (timer._repeat) {\n-        rearm(timer, start);\n-      } else if (destroyHooksExist() && !timer._destroyed) {\n-        emitDestroy(timerAsyncId);\n+    if (timer._repeat) {\n+      rearm(timer, start);\n+    } else {\n+      if (timer[kRefed])\n+        refCount--;\n+      timer[kRefed] = null;\n+\n+      if (destroyHooksExist() && !timer._destroyed) {\n+        emitDestroy(timer[async_id_symbol]);\n         timer._destroyed = true;\n       }\n     }\n   }\n }\n \n \n-// A convenience function for re-using TimerWrap handles more easily.\n-//\n-// This mostly exists to fix https://github.com/nodejs/node/issues/1264.\n-// Handles in libuv take at least one `uv_run` to be registered as unreferenced.\n-// Re-using an existing handle allows us to skip that, so that a second `uv_run`\n-// will return no active handles, even when running `setTimeout(fn).unref()`.\n-function reuse(item) {\n-  L.remove(item);\n-\n-  const list = refedLists[item._idleTimeout];\n-  // if empty - reuse the watcher\n-  if (list !== undefined && L.isEmpty(list)) {\n-    debug('reuse hit');\n-    list._timer.stop();\n-    delete refedLists[item._idleTimeout];\n-    return list._timer;\n-  }\n-\n-  return null;\n-}\n-\n-\n // Remove a timer. Cancels the timeout and resets the relevant timer properties.\n function unenroll(item) {\n   // Fewer checks may be possible, but these cover everything.\n   if (destroyHooksExist() &&\n-      typeof item[async_id_symbol] === 'number' &&\n+      item[async_id_symbol] !== undefined &&\n       !item._destroyed) {\n     emitDestroy(item[async_id_symbol]);\n     item._destroyed = true;\n   }\n \n-  const handle = reuse(item);\n-  if (handle !== null) {\n-    debug('unenroll: list empty');\n-    handle.close();\n+  L.remove(item);\n+\n+  // We only delete refed lists because unrefed ones are incredibly likely\n+  // to come from http and be recreated shortly after.\n+  // TODO: Long-term this could instead be handled by creating an internal\n+  // clearTimeout that makes it clear that the list should not be deleted.\n+  // That function could then be used by http and other similar modules.\n+  if (item[kRefed]) {\n+    const list = lists[item._idleTimeout];\n+    if (list !== undefined && L.isEmpty(list)) {\n+      debug('unenroll: list empty');\n+      queue.removeAt(list.priorityQueuePosition);\n+      delete lists[list.msecs];\n+    }\n+\n+    decRefCount();\n   }\n+  item[kRefed] = null;\n+\n   // if active is called later, then we want to make sure not to insert again\n   item._idleTimeout = -1;\n }\n@@ -403,15 +446,15 @@ function setTimeout(callback, after, arg1, arg2, arg3) {\n       break;\n   }\n \n-  const timeout = new Timeout(callback, after, args, false, false);\n+  const timeout = new Timeout(callback, after, args, false);\n   active(timeout);\n \n   return timeout;\n }\n \n setTimeout[internalUtil.promisify.custom] = function(after, value) {\n   const promise = createPromise();\n-  const timeout = new Timeout(promise, after, [value], false, false);\n+  const timeout = new Timeout(promise, after, [value], false);\n   active(timeout);\n \n   return promise;\n@@ -430,36 +473,20 @@ function ontimeout(timer) {\n     Reflect.apply(timer._onTimeout, timer, args);\n }\n \n-function rearm(timer, start = TimerWrap.now()) {\n+function rearm(timer, start) {\n   // // Do not re-arm unenroll'd or closed timers.\n-  if (timer._idleTimeout === -1) return;\n-\n-  // If timer is unref'd (or was - it's permanently removed from the list.)\n-  if (timer._handle && timer instanceof Timeout) {\n-    timer._handle.start(timer._repeat);\n-  } else {\n-    timer._idleTimeout = timer._repeat;\n+  if (timer._idleTimeout === -1)\n+    return;\n \n-    const duration = TimerWrap.now() - start;\n-    if (duration >= timer._repeat) {\n-      // If callback duration >= timer._repeat,\n-      // add 1 ms to avoid blocking eventloop\n-      insert(timer, false, start + duration - timer._repeat + 1);\n-    } else {\n-      insert(timer, false, start);\n-    }\n-  }\n+  timer._idleTimeout = timer._repeat;\n+  insert(timer, timer[kRefed], start);\n }\n \n \n const clearTimeout = exports.clearTimeout = function clearTimeout(timer) {\n   if (timer && timer._onTimeout) {\n     timer._onTimeout = null;\n-    if (timer instanceof Timeout) {\n-      timer.close(); // for after === 0\n-    } else {\n-      unenroll(timer);\n-    }\n+    unenroll(timer);\n   }\n };\n \n@@ -490,7 +517,7 @@ exports.setInterval = function setInterval(callback, repeat, arg1, arg2, arg3) {\n       break;\n   }\n \n-  const timeout = new Timeout(callback, repeat, args, true, false);\n+  const timeout = new Timeout(callback, repeat, args, true);\n   active(timeout);\n \n   return timeout;\n@@ -503,73 +530,25 @@ exports.clearInterval = function clearInterval(timer) {\n   clearTimeout(timer);\n };\n \n-function unrefdHandle(timer, now) {\n-  try {\n-    // Don't attempt to call the callback if it is not a function.\n-    if (typeof timer._onTimeout === 'function') {\n-      tryOnTimeout(timer, now);\n-    }\n-  } finally {\n-    // Make sure we clean up if the callback is no longer a function\n-    // even if the timer is an interval.\n-    if (!timer._repeat || typeof timer._onTimeout !== 'function') {\n-      timer.close();\n-    }\n-  }\n-\n-  return true;\n-}\n-\n \n Timeout.prototype.unref = function() {\n-  if (this._handle) {\n-    this._handle.unref();\n-  } else if (typeof this._onTimeout === 'function') {\n-    const now = TimerWrap.now();\n-    if (!this._idleStart) this._idleStart = now;\n-    var delay = this._idleStart + this._idleTimeout - now;\n-    if (delay < 0) delay = 0;\n-\n-    // Prevent running cb again when unref() is called during the same cb\n-    if (this._called && !this._repeat) {\n-      unenroll(this);\n-      return;\n-    }\n-\n-    const handle = reuse(this);\n-    if (handle !== null) {\n-      handle._list = undefined;\n-    }\n-\n-    this._handle = handle || new TimerWrap();\n-    this._handle.owner = this;\n-    this._handle.start(delay);\n-    this._handle.unref();\n+  if (this[kRefed]) {\n+    this[kRefed] = false;\n+    decRefCount();\n   }\n   return this;\n };\n \n Timeout.prototype.ref = function() {\n-  if (this._handle)\n-    this._handle.ref();\n+  if (this[kRefed] === false) {\n+    this[kRefed] = true;\n+    incRefCount();\n+  }\n   return this;\n };\n \n Timeout.prototype.close = function() {\n-  this._onTimeout = null;\n-  if (this._handle) {\n-    if (destroyHooksExist() &&\n-        typeof this[async_id_symbol] === 'number' &&\n-        !this._destroyed) {\n-      emitDestroy(this[async_id_symbol]);\n-      this._destroyed = true;\n-    }\n-\n-    this._idleTimeout = -1;\n-    this._handle.close();\n-  } else {\n-    unenroll(this);\n-  }\n+  clearTimeout(this);\n   return this;\n };\n "
        },
        {
            "sha": "1a5a22c25ee0379d346e1d28361822c019be5a3f",
            "filename": "src/timer_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 18,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/src%2Ftimer_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/src%2Ftimer_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftimer_wrap.cc?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -62,7 +62,6 @@ class TimerWrap : public HandleWrap {\n     env->SetProtoMethod(constructor, \"hasRef\", HandleWrap::HasRef);\n \n     env->SetProtoMethod(constructor, \"start\", Start);\n-    env->SetProtoMethod(constructor, \"stop\", Stop);\n \n     target->Set(timerString, constructor->GetFunction());\n \n@@ -125,32 +124,17 @@ class TimerWrap : public HandleWrap {\n     args.GetReturnValue().Set(err);\n   }\n \n-  static void Stop(const FunctionCallbackInfo<Value>& args) {\n-    TimerWrap* wrap;\n-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n-\n-    CHECK(HandleWrap::IsAlive(wrap));\n-\n-    int err = uv_timer_stop(&wrap->handle_);\n-    args.GetReturnValue().Set(err);\n-  }\n-\n   static void OnTimeout(uv_timer_t* handle) {\n     TimerWrap* wrap = static_cast<TimerWrap*>(handle->data);\n     Environment* env = wrap->env();\n     HandleScope handle_scope(env->isolate());\n     Context::Scope context_scope(env->context());\n     Local<Value> ret;\n-    Local<Value> args[1];\n+    Local<Value> args[] = { env->GetNow() };\n     do {\n-      args[0] = env->GetNow();\n       ret = wrap->MakeCallback(env->timers_callback_function(), 1, args)\n                 .ToLocalChecked();\n-    } while (ret->IsUndefined() &&\n-             !env->tick_info()->has_thrown() &&\n-             wrap->object()->Get(env->context(),\n-                                 env->owner_string()).ToLocalChecked()\n-                                                     ->IsUndefined());\n+    } while (ret->IsUndefined() && !env->tick_info()->has_thrown());\n   }\n \n   static void Now(const FunctionCallbackInfo<Value>& args) {"
        },
        {
            "sha": "eab19be1df10f0d18f39cc4d10db1bbd82e53216",
            "filename": "test/async-hooks/test-timerwrap.setInterval.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fasync-hooks%2Ftest-timerwrap.setInterval.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fasync-hooks%2Ftest-timerwrap.setInterval.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-timerwrap.setInterval.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -51,6 +51,6 @@ function onexit() {\n   hooks.disable();\n   hooks.sanityCheck('TIMERWRAP');\n \n-  checkInvocations(t, { init: 1, before: 3, after: 3, destroy: 1 },\n+  checkInvocations(t, { init: 1, before: 3, after: 3 },\n                    't: when process exits');\n }"
        },
        {
            "sha": "fcaf6bfc0aabc3e3c7a7ed9c9496e7f8ea0dc4f1",
            "filename": "test/async-hooks/test-timerwrap.setTimeout.js",
            "status": "modified",
            "additions": 3,
            "deletions": 20,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fasync-hooks%2Ftest-timerwrap.setTimeout.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fasync-hooks%2Ftest-timerwrap.setTimeout.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-timerwrap.setTimeout.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -23,43 +23,28 @@ checkInvocations(t1, { init: 1 }, 't1: when first timer installed');\n function ontimeout() {\n   checkInvocations(t1, { init: 1, before: 1 }, 't1: when first timer fired');\n \n-  // install second timeout with same TIMEOUT to see timer wrap being reused\n   setTimeout(onsecondTimeout, TIMEOUT);\n   const as = hooks.activitiesOfTypes('TIMERWRAP');\n   assert.strictEqual(as.length, 1);\n   checkInvocations(t1, { init: 1, before: 1 },\n                    't1: when second timer installed');\n }\n \n-// even though we install 3 timers we only have two timerwrap resources created\n-// as one is reused for the two timers with the same timeout\n-let t2;\n-\n function onsecondTimeout() {\n-  let as = hooks.activitiesOfTypes('TIMERWRAP');\n+  const as = hooks.activitiesOfTypes('TIMERWRAP');\n   assert.strictEqual(as.length, 1);\n   checkInvocations(t1, { init: 1, before: 2, after: 1 },\n                    't1: when second timer fired');\n \n   // install third timeout with different TIMEOUT\n   setTimeout(onthirdTimeout, TIMEOUT + 1);\n-  as = hooks.activitiesOfTypes('TIMERWRAP');\n-  assert.strictEqual(as.length, 2);\n-  t2 = as[1];\n-  assert.strictEqual(t2.type, 'TIMERWRAP');\n-  assert.strictEqual(typeof t2.uid, 'number');\n-  assert.strictEqual(typeof t2.triggerAsyncId, 'number');\n   checkInvocations(t1, { init: 1, before: 2, after: 1 },\n                    't1: when third timer installed');\n-  checkInvocations(t2, { init: 1 },\n-                   't2: when third timer installed');\n }\n \n function onthirdTimeout() {\n-  checkInvocations(t1, { init: 1, before: 2, after: 2, destroy: 1 },\n+  checkInvocations(t1, { init: 1, before: 3, after: 2 },\n                    't1: when third timer fired');\n-  checkInvocations(t2, { init: 1, before: 1 },\n-                   't2: when third timer fired');\n   tick(2);\n }\n \n@@ -69,8 +54,6 @@ function onexit() {\n   hooks.disable();\n   hooks.sanityCheck('TIMERWRAP');\n \n-  checkInvocations(t1, { init: 1, before: 2, after: 2, destroy: 1 },\n+  checkInvocations(t1, { init: 1, before: 3, after: 3 },\n                    't1: when process exits');\n-  checkInvocations(t2, { init: 1, before: 1, after: 1, destroy: 1 },\n-                   't2: when process exits');\n }"
        },
        {
            "sha": "0b6afe83df21152ba220af2553b21a63a8b36ea1",
            "filename": "test/parallel/test-handle-wrap-isrefed.js",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-handle-wrap-isrefed.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-handle-wrap-isrefed.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-handle-wrap-isrefed.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -112,19 +112,23 @@ const dgram = require('dgram');\n \n // timers\n {\n+  const { Timer } = process.binding('timer_wrap');\n+  strictEqual(process._getActiveHandles().filter(\n+    (handle) => (handle instanceof Timer)).length, 0);\n   const timer = setTimeout(() => {}, 500);\n-  timer.unref();\n-  strictEqual(Object.getPrototypeOf(timer._handle).hasOwnProperty('hasRef'),\n+  const handles = process._getActiveHandles().filter(\n+    (handle) => (handle instanceof Timer));\n+  strictEqual(handles.length, 1);\n+  const handle = handles[0];\n+  strictEqual(Object.getPrototypeOf(handle).hasOwnProperty('hasRef'),\n               true, 'timer_wrap: hasRef() missing');\n-  strictEqual(timer._handle.hasRef(),\n+  strictEqual(handle.hasRef(), true);\n+  timer.unref();\n+  strictEqual(handle.hasRef(),\n               false, 'timer_wrap: unref() ineffective');\n   timer.ref();\n-  strictEqual(timer._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               true, 'timer_wrap: ref() ineffective');\n-  timer._handle.close(common.mustCall(() =>\n-    strictEqual(timer._handle.hasRef(),\n-                false, 'timer_wrap: not unrefed on close')));\n }\n \n-\n // see also test/pseudo-tty/test-handle-wrap-isrefed-tty.js"
        },
        {
            "sha": "1db1d18c3a0d7a161499ef8dbc2b541b7c8e9dc2",
            "filename": "test/parallel/test-timers-next-tick.js",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-timers-next-tick.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-timers-next-tick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-next-tick.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -0,0 +1,15 @@\n+'use strict';\n+\n+const common = require('../common');\n+\n+// This test documents an internal implementation detail of the Timers:\n+// since timers of different durations are stored in separate lists,\n+// a nextTick queue will clear after each list of timers. While this\n+// behaviour is not documented it could be relied on by Node's users.\n+\n+setTimeout(common.mustCall(() => {\n+  process.nextTick(() => { clearTimeout(t2); });\n+}), 1);\n+const t2 = setTimeout(common.mustNotCall(), 2);\n+\n+common.busyLoop(5);"
        },
        {
            "sha": "3e04cb6c4cbc42743acf02f02ff45d5b6a208697",
            "filename": "test/parallel/test-timers-same-timeout-wrong-list-deleted.js",
            "status": "modified",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-timers-same-timeout-wrong-list-deleted.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-timers-same-timeout-wrong-list-deleted.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-same-timeout-wrong-list-deleted.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -12,8 +12,6 @@\n  */\n \n const common = require('../common');\n-const assert = require('assert');\n-const Timer = process.binding('timer_wrap').Timer;\n \n const TIMEOUT = common.platformTimeout(100);\n \n@@ -30,41 +28,9 @@ const handle1 = setTimeout(common.mustCall(function() {\n     // erroneously deleted. If we are able to cancel the timer successfully,\n     // the bug is fixed.\n     clearTimeout(handle2);\n-\n-    setImmediate(common.mustCall(function() {\n-      setImmediate(common.mustCall(function() {\n-        const activeTimers = getActiveTimers();\n-\n-        // Make sure our clearTimeout succeeded. One timer finished and\n-        // the other was canceled, so none should be active.\n-        assert.strictEqual(activeTimers.length, 0, 'Timers remain.');\n-      }));\n-    }));\n   }), 1);\n \n-  // Make sure our timers got added to the list.\n-  const activeTimers = getActiveTimers();\n-  const shortTimer = activeTimers.find(function(handle) {\n-    return handle._list.msecs === 1;\n-  });\n-  const longTimers = activeTimers.filter(function(handle) {\n-    return handle._list.msecs === TIMEOUT;\n-  });\n-\n-  // Make sure our clearTimeout succeeded. One timer finished and\n-  // the other was canceled, so none should be active.\n-  assert.strictEqual(activeTimers.length, 3,\n-                     'There should be 3 timers in the list.');\n-  assert(shortTimer instanceof Timer, 'The shorter timer is not in the list.');\n-  assert.strictEqual(longTimers.length, 2,\n-                     'Both longer timers should be in the list.');\n-\n   // When this callback completes, `listOnTimeout` should now look at the\n   // correct list and refrain from removing the new TIMEOUT list which\n   // contains the reference to the newer timer.\n }), TIMEOUT);\n-\n-function getActiveTimers() {\n-  const activeHandles = process._getActiveHandles();\n-  return activeHandles.filter((handle) => handle instanceof Timer);\n-}"
        },
        {
            "sha": "6b83e2e09e34a59c5c3659bfe46fa9474c72b648",
            "filename": "test/parallel/test-timers-timeout-to-interval.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-timers-timeout-to-interval.js",
            "raw_url": "https://github.com/nodejs/node/raw/23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5/test%2Fparallel%2Ftest-timers-timeout-to-interval.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-timeout-to-interval.js?ref=23a56e0c28cd828ef0cabb05b30e03cc8cb57dd5",
            "patch": "@@ -8,5 +8,5 @@ const t = setTimeout(common.mustCall(() => {\n   if (t._repeat) {\n     clearInterval(t);\n   }\n-  t._repeat = true;\n+  t._repeat = 1;\n }, 2), 1);"
        },
        {
            "sha": "afecf7f15ce1b523d87b9afc3e324cb26bc39a4d",
            "filename": "test/parallel/test-timers-unref-leak.js",
            "status": "removed",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6f6f7f749bd6847278836832542116f371ab3aa6/test%2Fparallel%2Ftest-timers-unref-leak.js",
            "raw_url": "https://github.com/nodejs/node/raw/6f6f7f749bd6847278836832542116f371ab3aa6/test%2Fparallel%2Ftest-timers-unref-leak.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-unref-leak.js?ref=6f6f7f749bd6847278836832542116f371ab3aa6",
            "patch": "@@ -1,14 +0,0 @@\n-'use strict';\n-const common = require('../common');\n-\n-const timeout = setTimeout(common.mustCall(), 10);\n-timeout.unref();\n-\n-// Wrap `close` method to check if the handle was closed\n-const close = timeout._handle.close;\n-timeout._handle.close = common.mustCall(function() {\n-  return close.apply(this, arguments);\n-});\n-\n-// Just to keep process alive and let previous timer's handle die\n-setTimeout(() => {}, 50);"
        },
        {
            "sha": "33b2da2f9e214fca0959f9745fa487e7170e1e49",
            "filename": "test/parallel/test-timers-unref-reuse-no-exposed-list.js",
            "status": "removed",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6f6f7f749bd6847278836832542116f371ab3aa6/test%2Fparallel%2Ftest-timers-unref-reuse-no-exposed-list.js",
            "raw_url": "https://github.com/nodejs/node/raw/6f6f7f749bd6847278836832542116f371ab3aa6/test%2Fparallel%2Ftest-timers-unref-reuse-no-exposed-list.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-unref-reuse-no-exposed-list.js?ref=6f6f7f749bd6847278836832542116f371ab3aa6",
            "patch": "@@ -1,14 +0,0 @@\n-'use strict';\n-\n-require('../common');\n-const assert = require('assert');\n-\n-const timer1 = setTimeout(() => {}, 1).unref();\n-assert.strictEqual(timer1._handle._list, undefined,\n-                   'timer1._handle._list should be undefined');\n-\n-// Check that everything works even if the handle was not re-used.\n-setTimeout(() => {}, 1);\n-const timer2 = setTimeout(() => {}, 1).unref();\n-assert.strictEqual(timer2._handle._list, undefined,\n-                   'timer2._handle._list should be undefined');"
        }
    ],
    "stats": {
        "total": 571,
        "additions": 242,
        "deletions": 329
    }
}