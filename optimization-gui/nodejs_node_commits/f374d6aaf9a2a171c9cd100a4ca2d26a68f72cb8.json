{
    "author": "TimothyGu",
    "message": "messaging: fix edge cases with transferring ports\n\nCurrently, transferring the port on which postMessage is called causes a\nsegmentation fault, and transferring the target port causes a subsequent\nport.onmessage setting to throw, or a deadlock if onmessage is set\nbefore the postMessage. Fix both of these behaviors and align the\nmethods more closely with the normative definitions in the HTML\nStandard.\n\nAlso, per spec postMessage must not throw just because the ports are\ndisentangled. Implement that behavior.\n\nPR-URL: https://github.com/nodejs/node/pull/21540\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8",
    "files": [
        {
            "sha": "712add06d3e2bcbc1da024ce92a1b0a5c6c4a0f3",
            "filename": "src/node_messaging.cc",
            "status": "modified",
            "additions": 76,
            "deletions": 23,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/src%2Fnode_messaging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/src%2Fnode_messaging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.cc?ref=f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8",
            "patch": "@@ -144,7 +144,7 @@ void Message::AddMessagePort(std::unique_ptr<MessagePortData>&& data) {\n \n namespace {\n \n-void ThrowDataCloneError(Environment* env, Local<String> message) {\n+void ThrowDataCloneException(Environment* env, Local<String> message) {\n   Local<Value> argv[] = {\n     message,\n     FIXED_ONE_BYTE_STRING(env->isolate(), \"DataCloneError\")\n@@ -168,7 +168,7 @@ class SerializerDelegate : public ValueSerializer::Delegate {\n       : env_(env), context_(context), msg_(m) {}\n \n   void ThrowDataCloneError(Local<String> message) override {\n-    ThrowDataCloneError(env_, message);\n+    ThrowDataCloneException(env_, message);\n   }\n \n   Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override {\n@@ -239,7 +239,8 @@ class SerializerDelegate : public ValueSerializer::Delegate {\n Maybe<bool> Message::Serialize(Environment* env,\n                                Local<Context> context,\n                                Local<Value> input,\n-                               Local<Value> transfer_list_v) {\n+                               Local<Value> transfer_list_v,\n+                               Local<Object> source_port) {\n   HandleScope handle_scope(env->isolate());\n   Context::Scope context_scope(context);\n \n@@ -273,8 +274,23 @@ Maybe<bool> Message::Serialize(Environment* env,\n         continue;\n       } else if (env->message_port_constructor_template()\n                     ->HasInstance(entry)) {\n+        // Check if the source MessagePort is being transferred.\n+        if (!source_port.IsEmpty() && entry == source_port) {\n+          ThrowDataCloneException(\n+              env,\n+              FIXED_ONE_BYTE_STRING(env->isolate(),\n+                                    \"Transfer list contains source port\"));\n+          return Nothing<bool>();\n+        }\n         MessagePort* port = Unwrap<MessagePort>(entry.As<Object>());\n-        CHECK_NE(port, nullptr);\n+        if (port == nullptr || port->IsDetached()) {\n+          ThrowDataCloneException(\n+              env,\n+              FIXED_ONE_BYTE_STRING(\n+                  env->isolate(),\n+                  \"MessagePort in transfer list is already detached\"));\n+          return Nothing<bool>();\n+        }\n         delegate.ports_.push_back(port);\n         continue;\n       }\n@@ -410,6 +426,10 @@ uv_async_t* MessagePort::async() {\n   return reinterpret_cast<uv_async_t*>(GetHandle());\n }\n \n+bool MessagePort::IsDetached() const {\n+  return data_ == nullptr || IsHandleClosing();\n+}\n+\n void MessagePort::TriggerAsync() {\n   if (IsHandleClosing()) return;\n   CHECK_EQ(uv_async_send(async()), 0);\n@@ -552,36 +572,69 @@ std::unique_ptr<MessagePortData> MessagePort::Detach() {\n }\n \n \n-void MessagePort::Send(Message&& message) {\n-  Mutex::ScopedLock lock(*data_->sibling_mutex_);\n-  if (data_->sibling_ == nullptr)\n-    return;\n-  data_->sibling_->AddToIncomingQueue(std::move(message));\n-}\n+Maybe<bool> MessagePort::PostMessage(Environment* env,\n+                                     Local<Value> message_v,\n+                                     Local<Value> transfer_v) {\n+  Isolate* isolate = env->isolate();\n+  Local<Object> obj = object(isolate);\n+  Local<Context> context = obj->CreationContext();\n \n-void MessagePort::Send(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  Local<Context> context = object(env->isolate())->CreationContext();\n   Message msg;\n-  if (msg.Serialize(env, context, args[0], args[1])\n-          .IsNothing()) {\n-    return;\n+\n+  // Per spec, we need to both check if transfer list has the source port, and\n+  // serialize the input message, even if the MessagePort is closed or detached.\n+\n+  Maybe<bool> serialization_maybe =\n+      msg.Serialize(env, context, message_v, transfer_v, obj);\n+  if (data_ == nullptr) {\n+    return serialization_maybe;\n+  }\n+  if (serialization_maybe.IsNothing()) {\n+    return Nothing<bool>();\n+  }\n+\n+  Mutex::ScopedLock lock(*data_->sibling_mutex_);\n+  bool doomed = false;\n+\n+  // Check if the target port is posted to itself.\n+  if (data_->sibling_ != nullptr) {\n+    for (const auto& port_data : msg.message_ports()) {\n+      if (data_->sibling_ == port_data.get()) {\n+        doomed = true;\n+        ProcessEmitWarning(env, \"The target port was posted to itself, and \"\n+                                \"the communication channel was lost\");\n+        break;\n+      }\n+    }\n   }\n-  Send(std::move(msg));\n+\n+  if (data_->sibling_ == nullptr || doomed)\n+    return Just(true);\n+\n+  data_->sibling_->AddToIncomingQueue(std::move(msg));\n+  return Just(true);\n }\n \n void MessagePort::PostMessage(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n-  MessagePort* port;\n-  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());\n-  if (!port->data_) {\n-    return THROW_ERR_CLOSED_MESSAGE_PORT(env);\n-  }\n   if (args.Length() == 0) {\n     return THROW_ERR_MISSING_ARGS(env, \"Not enough arguments to \"\n                                        \"MessagePort.postMessage\");\n   }\n-  port->Send(args);\n+\n+  MessagePort* port = Unwrap<MessagePort>(args.This());\n+  // Even if the backing MessagePort object has already been deleted, we still\n+  // want to serialize the message to ensure spec-compliant behavior w.r.t.\n+  // transfers.\n+  if (port == nullptr) {\n+    Message msg;\n+    Local<Object> obj = args.This();\n+    Local<Context> context = obj->CreationContext();\n+    USE(msg.Serialize(env, context, args[0], args[1], obj));\n+    return;\n+  }\n+\n+  port->PostMessage(env, args[0], args[1]);\n }\n \n void MessagePort::Start() {"
        },
        {
            "sha": "62ae633b9e0b8d9a17e6f0ae375e31421ca8f3c9",
            "filename": "src/node_messaging.h",
            "status": "modified",
            "additions": 26,
            "deletions": 5,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/src%2Fnode_messaging.h",
            "raw_url": "https://github.com/nodejs/node/raw/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/src%2Fnode_messaging.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.h?ref=f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8",
            "patch": "@@ -32,10 +32,14 @@ class Message {\n   // Serialize a JS value, and optionally transfer objects, into this message.\n   // The Message object retains ownership of all transferred objects until\n   // deserialization.\n+  // The source_port parameter, if provided, will make Serialize() throw a\n+  // \"DataCloneError\" DOMException if source_port is found in transfer_list.\n   v8::Maybe<bool> Serialize(Environment* env,\n                             v8::Local<v8::Context> context,\n                             v8::Local<v8::Value> input,\n-                            v8::Local<v8::Value> transfer_list);\n+                            v8::Local<v8::Value> transfer_list,\n+                            v8::Local<v8::Object> source_port =\n+                                v8::Local<v8::Object>());\n \n   // Internal method of Message that is called when a new SharedArrayBuffer\n   // object is encountered in the incoming value's structure.\n@@ -44,6 +48,13 @@ class Message {\n   // and that transfers ownership of `data` to this message.\n   void AddMessagePort(std::unique_ptr<MessagePortData>&& data);\n \n+  // The MessagePorts that will be transferred, as recorded by Serialize().\n+  // Used for warning user about posting the target MessagePort to itself,\n+  // which will as a side effect destroy the communication channel.\n+  const std::vector<std::unique_ptr<MessagePortData>>& message_ports() const {\n+    return message_ports_;\n+  }\n+\n  private:\n   MallocedBuffer<char> main_message_buf_;\n   std::vector<MallocedBuffer<char>> array_buffer_contents_;\n@@ -122,10 +133,11 @@ class MessagePort : public HandleWrap {\n                           std::unique_ptr<MessagePortData> data = nullptr);\n \n   // Send a message, i.e. deliver it into the sibling's incoming queue.\n-  // If there is no sibling, i.e. this port is closed,\n-  // this message is silently discarded.\n-  void Send(Message&& message);\n-  void Send(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  // If this port is closed, or if there is no sibling, this message is\n+  // serialized with transfers, then silently discarded.\n+  v8::Maybe<bool> PostMessage(Environment* env,\n+                              v8::Local<v8::Value> message,\n+                              v8::Local<v8::Value> transfer);\n   // Deliver a single message into this port's incoming queue.\n   void AddToIncomingQueue(Message&& message);\n \n@@ -157,6 +169,15 @@ class MessagePort : public HandleWrap {\n   void Close(\n       v8::Local<v8::Value> close_callback = v8::Local<v8::Value>()) override;\n \n+  // Returns true if either data_ has been freed, or if the handle is being\n+  // closed. Equivalent to the [[Detached]] internal slot in the HTML Standard.\n+  //\n+  // If checking if a JavaScript MessagePort object is detached, this method\n+  // alone is often not enough, since the backing C++ MessagePort object may\n+  // have been deleted already. For all intents and purposes, an object with a\n+  // NULL pointer to the C++ MessagePort object is also detached.\n+  inline bool IsDetached() const;\n+\n   size_t self_size() const override;\n \n  private:"
        },
        {
            "sha": "435a3789fca7247f1ad6bba563705793dae19c3e",
            "filename": "test/parallel/test-worker-message-port-transfer-closed.js",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/test%2Fparallel%2Ftest-worker-message-port-transfer-closed.js",
            "raw_url": "https://github.com/nodejs/node/raw/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/test%2Fparallel%2Ftest-worker-message-port-transfer-closed.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-message-port-transfer-closed.js?ref=f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8",
            "patch": "@@ -0,0 +1,54 @@\n+// Flags: --experimental-worker\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const { MessageChannel } = require('worker_threads');\n+\n+// This tests various behaviors around transferring MessagePorts with closing\n+// or closed handles.\n+\n+const { port1, port2 } = new MessageChannel();\n+\n+const arrayBuf = new ArrayBuffer(10);\n+port1.onmessage = common.mustNotCall();\n+port2.onmessage = common.mustNotCall();\n+\n+function testSingle(closedPort, potentiallyOpenPort) {\n+  assert.throws(common.mustCall(() => {\n+    potentiallyOpenPort.postMessage(null, [arrayBuf, closedPort]);\n+  }), common.mustCall((err) => {\n+    assert.strictEqual(err.name, 'DataCloneError');\n+    assert.strictEqual(err.message,\n+                       'MessagePort in transfer list is already detached');\n+    assert.strictEqual(err.code, 25);\n+    assert.ok(err instanceof Error);\n+\n+    const DOMException = err.constructor;\n+    assert.ok(err instanceof DOMException);\n+    assert.strictEqual(DOMException.name, 'DOMException');\n+\n+    return true;\n+  }));\n+\n+  // arrayBuf must not be transferred, even though it is present earlier in the\n+  // transfer list than the closedPort.\n+  assert.strictEqual(arrayBuf.byteLength, 10);\n+}\n+\n+function testBothClosed() {\n+  testSingle(port1, port2);\n+  testSingle(port2, port1);\n+}\n+\n+// Even though the port handles may not be completely closed in C++ land, the\n+// observable behavior must be that the closing/detachment is synchronous and\n+// instant.\n+\n+port1.close(common.mustCall(testBothClosed));\n+testSingle(port1, port2);\n+port2.close(common.mustCall(testBothClosed));\n+testBothClosed();\n+\n+setTimeout(common.mustNotCall('The communication channel is still open'),\n+           common.platformTimeout(1000)).unref();"
        },
        {
            "sha": "1855023cdfae04fed4b5904ae0f885878c7e0ed7",
            "filename": "test/parallel/test-worker-message-port-transfer-self.js",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/test%2Fparallel%2Ftest-worker-message-port-transfer-self.js",
            "raw_url": "https://github.com/nodejs/node/raw/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/test%2Fparallel%2Ftest-worker-message-port-transfer-self.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-message-port-transfer-self.js?ref=f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8",
            "patch": "@@ -0,0 +1,33 @@\n+// Flags: --experimental-worker\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const { MessageChannel } = require('worker_threads');\n+\n+const { port1, port2 } = new MessageChannel();\n+\n+assert.throws(common.mustCall(() => {\n+  port1.postMessage(null, [port1]);\n+}), common.mustCall((err) => {\n+  assert.strictEqual(err.name, 'DataCloneError');\n+  assert.strictEqual(err.message, 'Transfer list contains source port');\n+  assert.strictEqual(err.code, 25);\n+  assert.ok(err instanceof Error);\n+\n+  const DOMException = err.constructor;\n+  assert.ok(err instanceof DOMException);\n+  assert.strictEqual(DOMException.name, 'DOMException');\n+\n+  return true;\n+}));\n+\n+// The failed transfer should not affect the ports in anyway.\n+port2.onmessage = common.mustCall((message) => {\n+  assert.strictEqual(message, 2);\n+  port1.close();\n+\n+  setTimeout(common.mustNotCall('The communication channel is still open'),\n+             common.platformTimeout(1000)).unref();\n+});\n+port1.postMessage(2);"
        },
        {
            "sha": "8e6354d8269771684fdf2ae9dd29f05daa55ccfa",
            "filename": "test/parallel/test-worker-message-port-transfer-target.js",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/test%2Fparallel%2Ftest-worker-message-port-transfer-target.js",
            "raw_url": "https://github.com/nodejs/node/raw/f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8/test%2Fparallel%2Ftest-worker-message-port-transfer-target.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-message-port-transfer-target.js?ref=f374d6aaf9a2a171c9cd100a4ca2d26a68f72cb8",
            "patch": "@@ -0,0 +1,24 @@\n+// Flags: --experimental-worker\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const { MessageChannel } = require('worker_threads');\n+\n+const { port1, port2 } = new MessageChannel();\n+\n+const arrayBuf = new ArrayBuffer(10);\n+\n+common.expectWarning('Warning',\n+                     'The target port was posted to itself, and the ' +\n+                     'communication channel was lost',\n+                     common.noWarnCode);\n+port2.onmessage = common.mustNotCall();\n+port2.postMessage(null, [port1, arrayBuf]);\n+\n+// arrayBuf must be transferred, despite the fact that port2 never received the\n+// message.\n+assert.strictEqual(arrayBuf.byteLength, 0);\n+\n+setTimeout(common.mustNotCall('The communication channel is still open'),\n+           common.platformTimeout(1000)).unref();"
        }
    ],
    "stats": {
        "total": 241,
        "additions": 213,
        "deletions": 28
    }
}