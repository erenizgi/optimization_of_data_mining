{
    "author": "unknown",
    "message": "fs: implement mkdir recursive (mkdirp)\n\nImplements mkdirp functionality in node_file.cc. The Benefit\nof implementing in C++ layer is that the logic is more easily\nshared between the Promise and callback implementation and\nthere are notable performance improvements.\n\nThis commit is part of the Tooling Group Initiative.\n\nRefs: https://github.com/nodejs/user-feedback/pull/70\n\nPR-URL: https://github.com/nodejs/node/pull/21875\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Jon Moss <me@jonathanmoss.me>\nReviewed-By: Ron Korving <ron@ronkorving.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Sam Ruby <rubys@intertwingly.net>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
    "files": [
        {
            "sha": "96a792c35a48e4b47aa35a9831d317ebd1577791",
            "filename": "benchmark/fs/bench-mkdirp.js",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/benchmark%2Ffs%2Fbench-mkdirp.js",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/benchmark%2Ffs%2Fbench-mkdirp.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ffs%2Fbench-mkdirp.js?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -0,0 +1,23 @@\n+'use strict';\n+\n+const common = require('../common');\n+const fs = require('fs');\n+const tmpdir = require('../../test/common/tmpdir');\n+tmpdir.refresh();\n+let dirc = 0;\n+\n+const bench = common.createBenchmark(main, {\n+  n: [1e4],\n+});\n+\n+function main({ n }) {\n+  bench.start();\n+  (function r(cntr) {\n+    if (cntr-- <= 0)\n+      return bench.end(n);\n+    const pathname = `${tmpdir.path}/${++dirc}/${++dirc}/${++dirc}/${++dirc}`;\n+    fs.mkdir(pathname, { createParents: true }, (err) => {\n+      r(cntr);\n+    });\n+  }(n));\n+}"
        },
        {
            "sha": "1f71a537e3eb462769bf9c4fabfbe7a3f1430443",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 28,
            "deletions": 7,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -2047,7 +2047,7 @@ changes:\n \n Synchronous lstat(2).\n \n-## fs.mkdir(path[, mode], callback)\n+## fs.mkdir(path[, options], callback)\n <!-- YAML\n added: v0.1.8\n changes:\n@@ -2066,16 +2066,29 @@ changes:\n -->\n \n * `path` {string|Buffer|URL}\n-* `mode` {integer} Not supported on Windows. **Default:** `0o777`.\n+* `options` {Object|integer}\n+  * `recursive` {boolean} **Default:** `false`\n+  * `mode` {integer} Not supported on Windows. **Default:** `0o777`.\n * `callback` {Function}\n   * `err` {Error}\n \n Asynchronously creates a directory. No arguments other than a possible exception\n are given to the completion callback.\n \n+The optional `options` argument can be an integer specifying mode (permission\n+and sticky bits), or an object with a `mode` property and a `recursive`\n+property indicating whether parent folders should be created.\n+\n+```js\n+// Creates /tmp/a/apple, regardless of whether `/tmp` and /tmp/a exist.\n+fs.mkdir('/tmp/a/apple', { recursive: true }, (err) => {\n+  if (err) throw err;\n+});\n+```\n+\n See also: mkdir(2).\n \n-## fs.mkdirSync(path[, mode])\n+## fs.mkdirSync(path[, options])\n <!-- YAML\n added: v0.1.21\n changes:\n@@ -2086,7 +2099,9 @@ changes:\n -->\n \n * `path` {string|Buffer|URL}\n-* `mode` {integer} Not supported on Windows. **Default:** `0o777`.\n+* `options` {Object|integer}\n+  * `recursive` {boolean} **Default:** `false`\n+  * `mode` {integer} Not supported on Windows. **Default:** `0o777`.\n \n Synchronously creates a directory. Returns `undefined`.\n This is the synchronous version of [`fs.mkdir()`][].\n@@ -3979,18 +3994,24 @@ changes:\n Asynchronous lstat(2). The `Promise` is resolved with the [`fs.Stats`][] object\n for the given symbolic link `path`.\n \n-### fsPromises.mkdir(path[, mode])\n+### fsPromises.mkdir(path[, options])\n <!-- YAML\n added: v10.0.0\n -->\n \n * `path` {string|Buffer|URL}\n-* `mode` {integer} **Default:** `0o777`\n+* `options` {Object|integer}\n+  * `recursive` {boolean} **Default:** `false`\n+  * `mode` {integer} Not supported on Windows. **Default:** `0o777`.\n * Returns: {Promise}\n \n Asynchronously creates a directory then resolves the `Promise` with no\n arguments upon success.\n \n+The optional `options` argument can be an integer specifying mode (permission\n+and sticky bits), or an object with a `mode` property and a `recursive`\n+property indicating whether parent folders should be created.\n+\n ### fsPromises.mkdtemp(prefix[, options])\n <!-- YAML\n added: v10.0.0\n@@ -4627,7 +4648,7 @@ the file contents.\n [`fs.ftruncate()`]: #fs_fs_ftruncate_fd_len_callback\n [`fs.futimes()`]: #fs_fs_futimes_fd_atime_mtime_callback\n [`fs.lstat()`]: #fs_fs_lstat_path_options_callback\n-[`fs.mkdir()`]: #fs_fs_mkdir_path_mode_callback\n+[`fs.mkdir()`]: #fs_fs_mkdir_path_options_callback\n [`fs.mkdtemp()`]: #fs_fs_mkdtemp_prefix_options_callback\n [`fs.open()`]: #fs_fs_open_path_flags_mode_callback\n [`fs.read()`]: #fs_fs_read_fd_buffer_offset_length_position_callback"
        },
        {
            "sha": "bb8c17bbbb543625ba9b44cf0d2761b35ccb59a3",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 32,
            "deletions": 13,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -721,29 +721,48 @@ function fsyncSync(fd) {\n   handleErrorFromBinding(ctx);\n }\n \n-function mkdir(path, mode, callback) {\n+function mkdir(path, options, callback) {\n+  if (typeof options === 'function') {\n+    callback = options;\n+    options = {};\n+  } else if (typeof options === 'number' || typeof options === 'string') {\n+    options = { mode: options };\n+  }\n+  const {\n+    recursive = false,\n+    mode = 0o777\n+  } = options || {};\n+  callback = makeCallback(callback);\n   path = getPathFromURL(path);\n-  validatePath(path);\n \n-  if (arguments.length < 3) {\n-    callback = makeCallback(mode);\n-    mode = 0o777;\n-  } else {\n-    callback = makeCallback(callback);\n-    mode = validateMode(mode, 'mode', 0o777);\n-  }\n+  validatePath(path);\n+  if (typeof recursive !== 'boolean')\n+    throw new ERR_INVALID_ARG_TYPE('recursive', 'boolean', recursive);\n \n   const req = new FSReqCallback();\n   req.oncomplete = callback;\n-  binding.mkdir(pathModule.toNamespacedPath(path), mode, req);\n+  binding.mkdir(pathModule.toNamespacedPath(path),\n+                validateMode(mode, 'mode', 0o777), recursive, req);\n }\n \n-function mkdirSync(path, mode) {\n+function mkdirSync(path, options) {\n+  if (typeof options === 'number' || typeof options === 'string') {\n+    options = { mode: options };\n+  }\n   path = getPathFromURL(path);\n+  const {\n+    recursive = false,\n+    mode = 0o777\n+  } = options || {};\n+\n   validatePath(path);\n-  mode = validateMode(mode, 'mode', 0o777);\n+  if (typeof recursive !== 'boolean')\n+    throw new ERR_INVALID_ARG_TYPE('recursive', 'boolean', recursive);\n+\n   const ctx = { path };\n-  binding.mkdir(pathModule.toNamespacedPath(path), mode, undefined, ctx);\n+  binding.mkdir(pathModule.toNamespacedPath(path),\n+                validateMode(mode, 'mode', 0o777), recursive, undefined,\n+                ctx);\n   handleErrorFromBinding(ctx);\n }\n "
        },
        {
            "sha": "e8cb2317fa4288a22f2f5d2cfa76e8830492b9c2",
            "filename": "lib/internal/fs/promises.js",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/lib%2Finternal%2Ffs%2Fpromises.js",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/lib%2Finternal%2Ffs%2Fpromises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fpromises.js?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -289,11 +289,23 @@ async function fsync(handle) {\n   return binding.fsync(handle.fd, kUsePromises);\n }\n \n-async function mkdir(path, mode) {\n+async function mkdir(path, options) {\n+  if (typeof options === 'number' || typeof options === 'string') {\n+    options = { mode: options };\n+  }\n+  const {\n+    recursive = false,\n+    mode = 0o777\n+  } = options || {};\n   path = getPathFromURL(path);\n+\n   validatePath(path);\n-  mode = validateMode(mode, 'mode', 0o777);\n-  return binding.mkdir(pathModule.toNamespacedPath(path), mode, kUsePromises);\n+  if (typeof recursive !== 'boolean')\n+    throw new ERR_INVALID_ARG_TYPE('recursive', 'boolean', recursive);\n+\n+  return binding.mkdir(pathModule.toNamespacedPath(path),\n+                       validateMode(mode, 'mode', 0o777), recursive,\n+                       kUsePromises);\n }\n \n async function readdir(path, options) {"
        },
        {
            "sha": "714dec157bcedc6d307e406dfc51171e42f2f191",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 151,
            "deletions": 7,
            "changes": 158,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -76,6 +76,16 @@ using v8::Value;\n # define MIN(a, b) ((a) < (b) ? (a) : (b))\n #endif\n \n+#ifndef S_ISDIR\n+# define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)\n+#endif\n+\n+#ifdef __POSIX__\n+const char* kPathSeparator = \"/\";\n+#else\n+const char* kPathSeparator = \"\\\\/\";\n+#endif\n+\n #define GET_OFFSET(a) ((a)->IsNumber() ? (a).As<Integer>()->Value() : -1)\n #define TRACE_NAME(name) \"fs.sync.\" #name\n #define GET_TRACE_ENABLED                                                  \\\n@@ -1148,28 +1158,162 @@ static void RMDir(const FunctionCallbackInfo<Value>& args) {\n   }\n }\n \n+int MKDirpSync(uv_loop_t* loop, uv_fs_t* req, const std::string& path, int mode,\n+               uv_fs_cb cb = nullptr) {\n+  FSContinuationData continuation_data(req, mode, cb);\n+  continuation_data.PushPath(std::move(path));\n+\n+  while (continuation_data.paths.size() > 0) {\n+    std::string next_path = continuation_data.PopPath();\n+    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);\n+    while (true) {\n+      switch (err) {\n+        case 0:\n+          if (continuation_data.paths.size() == 0) {\n+            return 0;\n+          }\n+          break;\n+        case UV_ENOENT: {\n+          std::string dirname = next_path.substr(0,\n+                                        next_path.find_last_of(kPathSeparator));\n+          if (dirname != next_path) {\n+            continuation_data.PushPath(std::move(next_path));\n+            continuation_data.PushPath(std::move(dirname));\n+          } else if (continuation_data.paths.size() == 0) {\n+            err = UV_EEXIST;\n+            continue;\n+          }\n+          break;\n+        }\n+        case UV_EPERM: {\n+          return err;\n+        }\n+        default:\n+          uv_fs_req_cleanup(req);\n+          err = uv_fs_stat(loop, req, next_path.c_str(), nullptr);\n+          if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) return UV_EEXIST;\n+          if (err < 0) return err;\n+          break;\n+      }\n+      break;\n+    }\n+    uv_fs_req_cleanup(req);\n+  }\n+\n+  return 0;\n+}\n+\n+int MKDirpAsync(uv_loop_t* loop,\n+                uv_fs_t* req,\n+                const char* path,\n+                int mode,\n+                uv_fs_cb cb) {\n+  FSReqBase* req_wrap = FSReqBase::from_req(req);\n+  // on the first iteration of algorithm, stash state information.\n+  if (req_wrap->continuation_data == nullptr) {\n+    req_wrap->continuation_data = std::unique_ptr<FSContinuationData>{\n+      new FSContinuationData(req, mode, cb)};\n+    req_wrap->continuation_data->PushPath(std::move(path));\n+  }\n+\n+  // on each iteration of algorithm, mkdir directory on top of stack.\n+  std::string next_path = req_wrap->continuation_data->PopPath();\n+  int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode,\n+                        uv_fs_callback_t{[](uv_fs_t* req) {\n+    FSReqBase* req_wrap = FSReqBase::from_req(req);\n+    Environment* env = req_wrap->env();\n+    uv_loop_t* loop = env->event_loop();\n+    std::string path = req->path;\n+    int err = req->result;\n+\n+    while (true) {\n+      switch (err) {\n+        case 0: {\n+          if (req_wrap->continuation_data->paths.size() == 0) {\n+            req_wrap->continuation_data->Done(0);\n+          } else {\n+            uv_fs_req_cleanup(req);\n+            MKDirpAsync(loop, req, path.c_str(),\n+                        req_wrap->continuation_data->mode, nullptr);\n+          }\n+          break;\n+        }\n+        case UV_ENOENT: {\n+          std::string dirname = path.substr(0,\n+                                            path.find_last_of(kPathSeparator));\n+          if (dirname != path) {\n+            req_wrap->continuation_data->PushPath(std::move(path));\n+            req_wrap->continuation_data->PushPath(std::move(dirname));\n+          } else if (req_wrap->continuation_data->paths.size() == 0) {\n+            err = UV_EEXIST;\n+            continue;\n+          }\n+          uv_fs_req_cleanup(req);\n+          MKDirpAsync(loop, req, path.c_str(),\n+                      req_wrap->continuation_data->mode, nullptr);\n+          break;\n+        }\n+        case UV_EPERM: {\n+          req_wrap->continuation_data->Done(err);\n+          break;\n+        }\n+        default:\n+          if (err == UV_EEXIST &&\n+              req_wrap->continuation_data->paths.size() > 0) {\n+            uv_fs_req_cleanup(req);\n+            MKDirpAsync(loop, req, path.c_str(),\n+                        req_wrap->continuation_data->mode, nullptr);\n+          } else {\n+            // verify that the path pointed to is actually a directory.\n+            uv_fs_req_cleanup(req);\n+            int err = uv_fs_stat(loop, req, path.c_str(),\n+                                 uv_fs_callback_t{[](uv_fs_t* req) {\n+              FSReqBase* req_wrap = FSReqBase::from_req(req);\n+              int err = req->result;\n+              if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) err = UV_EEXIST;\n+              req_wrap->continuation_data->Done(err);\n+            }});\n+            if (err < 0) req_wrap->continuation_data->Done(err);\n+          }\n+          break;\n+      }\n+      break;\n+    }\n+  }});\n+\n+  return err;\n+}\n+\n static void MKDir(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   const int argc = args.Length();\n-  CHECK_GE(argc, 3);\n+  CHECK_GE(argc, 4);\n \n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsInt32());\n   const int mode = args[1].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n+  CHECK(args[2]->IsBoolean());\n+  bool mkdirp = args[2]->IsTrue();\n+\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[3]);\n   if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)\n-    AsyncCall(env, req_wrap_async, args, \"mkdir\", UTF8, AfterNoArgs,\n-              uv_fs_mkdir, *path, mode);\n+    AsyncCall(env, req_wrap_async, args, \"mkdir\", UTF8,\n+              AfterNoArgs, mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);\n   } else {  // mkdir(path, mode, undefined, ctx)\n-    CHECK_EQ(argc, 4);\n+    CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n     FS_SYNC_TRACE_BEGIN(mkdir);\n-    SyncCall(env, args[3], &req_wrap_sync, \"mkdir\",\n-             uv_fs_mkdir, *path, mode);\n+    if (mkdirp) {\n+      SyncCall(env, args[4], &req_wrap_sync, \"mkdir\",\n+               MKDirpSync, *path, mode);\n+    } else {\n+      SyncCall(env, args[4], &req_wrap_sync, \"mkdir\",\n+               uv_fs_mkdir, *path, mode);\n+    }\n     FS_SYNC_TRACE_END(mkdir);\n   }\n }"
        },
        {
            "sha": "af62be0feca0d466d0730ff8527d6d9d89438c06",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -21,10 +21,50 @@ using v8::Value;\n \n namespace fs {\n \n+// structure used to store state during a complex operation, e.g., mkdirp.\n+class FSContinuationData : public MemoryRetainer {\n+ public:\n+  FSContinuationData(uv_fs_t* req, int mode, uv_fs_cb done_cb)\n+      : req(req), mode(mode), done_cb(done_cb) {\n+  }\n+\n+  uv_fs_t* req;\n+  int mode;\n+  std::vector<std::string> paths;\n+\n+  void PushPath(std::string&& path) {\n+    paths.emplace_back(std::move(path));\n+  }\n+\n+  void PushPath(const std::string& path) {\n+    paths.push_back(path);\n+  }\n+\n+  std::string PopPath() {\n+    CHECK_GT(paths.size(), 0);\n+    std::string path = std::move(paths.back());\n+    paths.pop_back();\n+    return path;\n+  }\n+\n+  void Done(int result) {\n+    req->result = result;\n+    done_cb(req);\n+  }\n+\n+  void MemoryInfo(MemoryTracker* tracker) const override {\n+    tracker->TrackThis(this);\n+    tracker->TrackField(\"paths\", paths);\n+  }\n+\n+ private:\n+  uv_fs_cb done_cb;\n+};\n \n class FSReqBase : public ReqWrap<uv_fs_t> {\n  public:\n   typedef MaybeStackBuffer<char, 64> FSReqBuffer;\n+  std::unique_ptr<FSContinuationData> continuation_data = nullptr;\n \n   FSReqBase(Environment* env, Local<Object> req, AsyncWrap::ProviderType type,\n             bool use_bigint)\n@@ -97,6 +137,7 @@ class FSReqCallback : public FSReqBase {\n \n   void MemoryInfo(MemoryTracker* tracker) const override {\n     tracker->TrackThis(this);\n+    tracker->TrackField(\"continuation_data\", continuation_data);\n   }\n \n   ADD_MEMORY_INFO_NAME(FSReqCallback)\n@@ -162,6 +203,7 @@ class FSReqPromise : public FSReqBase {\n   void MemoryInfo(MemoryTracker* tracker) const override {\n     tracker->TrackThis(this);\n     tracker->TrackField(\"stats_field_array\", stats_field_array_);\n+    tracker->TrackField(\"continuation_data\", continuation_data);\n   }\n \n   ADD_MEMORY_INFO_NAME(FSReqPromise)"
        },
        {
            "sha": "024fdced9c44aeecb8eded66e5126319192c795f",
            "filename": "test/parallel/test-fs-mkdir.js",
            "status": "modified",
            "additions": 104,
            "deletions": 3,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/test%2Fparallel%2Ftest-fs-mkdir.js",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/test%2Fparallel%2Ftest-fs-mkdir.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-mkdir.js?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -23,12 +23,18 @@\n const common = require('../common');\n const assert = require('assert');\n const fs = require('fs');\n+const path = require('path');\n \n const tmpdir = require('../common/tmpdir');\n tmpdir.refresh();\n \n+let dirc = 0;\n+function nextdir() {\n+  return `test${++dirc}`;\n+}\n+\n {\n-  const pathname = `${tmpdir.path}/test1`;\n+  const pathname = path.join(tmpdir.path, nextdir());\n \n   fs.mkdir(pathname, common.mustCall(function(err) {\n     assert.strictEqual(err, null);\n@@ -37,7 +43,7 @@ tmpdir.refresh();\n }\n \n {\n-  const pathname = `${tmpdir.path}/test2`;\n+  const pathname = path.join(tmpdir.path, nextdir());\n \n   fs.mkdir(pathname, 0o777, common.mustCall(function(err) {\n     assert.strictEqual(err, null);\n@@ -46,7 +52,7 @@ tmpdir.refresh();\n }\n \n {\n-  const pathname = `${tmpdir.path}/test3`;\n+  const pathname = path.join(tmpdir.path, nextdir());\n \n   fs.mkdirSync(pathname);\n \n@@ -71,6 +77,101 @@ tmpdir.refresh();\n   );\n });\n \n+// mkdirpSync when both top-level, and sub-folders do not exist.\n+{\n+  const pathname = path.join(tmpdir.path, nextdir(), nextdir());\n+\n+  fs.mkdirSync(pathname, { recursive: true });\n+\n+  const exists = fs.existsSync(pathname);\n+  assert.strictEqual(exists, true);\n+  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);\n+}\n+\n+// mkdirpSync when folder already exists.\n+{\n+  const pathname = path.join(tmpdir.path, nextdir(), nextdir());\n+\n+  fs.mkdirSync(pathname, { recursive: true });\n+  // should not cause an error.\n+  fs.mkdirSync(pathname, { recursive: true });\n+\n+  const exists = fs.existsSync(pathname);\n+  assert.strictEqual(exists, true);\n+  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);\n+}\n+\n+// mkdirpSync ../\n+{\n+  const pathname = `${tmpdir.path}/${nextdir()}/../${nextdir()}/${nextdir()}`;\n+  fs.mkdirSync(pathname, { recursive: true });\n+  const exists = fs.existsSync(pathname);\n+  assert.strictEqual(exists, true);\n+  assert.strictEqual(fs.statSync(pathname).isDirectory(), true);\n+}\n+\n+// mkdirpSync when path is a file.\n+{\n+  const pathname = path.join(tmpdir.path, nextdir(), nextdir());\n+\n+  fs.mkdirSync(path.dirname(pathname));\n+  fs.writeFileSync(pathname, '', 'utf8');\n+\n+  try {\n+    fs.mkdirSync(pathname, { recursive: true });\n+    throw new Error('unreachable');\n+  } catch (err) {\n+    assert.notStrictEqual(err.message, 'unreachable');\n+    assert.strictEqual(err.code, 'EEXIST');\n+    assert.strictEqual(err.syscall, 'mkdir');\n+  }\n+}\n+\n+// mkdirp when folder does not yet exist.\n+{\n+  const pathname = path.join(tmpdir.path, nextdir(), nextdir());\n+\n+  fs.mkdir(pathname, { recursive: true }, common.mustCall(function(err) {\n+    assert.strictEqual(err, null);\n+    assert.strictEqual(fs.existsSync(pathname), true);\n+    assert.strictEqual(fs.statSync(pathname).isDirectory(), true);\n+  }));\n+}\n+\n+// mkdirp when path is a file.\n+{\n+  const pathname = path.join(tmpdir.path, nextdir(), nextdir());\n+\n+  fs.mkdirSync(path.dirname(pathname));\n+  fs.writeFileSync(pathname, '', 'utf8');\n+  fs.mkdir(pathname, { recursive: true }, (err) => {\n+    assert.strictEqual(err.code, 'EEXIST');\n+    assert.strictEqual(err.syscall, 'mkdir');\n+    assert.strictEqual(fs.statSync(pathname).isDirectory(), false);\n+  });\n+}\n+\n+// mkdirpSync dirname loop\n+// XXX: windows and smartos have issues removing a directory that you're in.\n+if (common.isMainThread && (common.isLinux || common.isOSX)) {\n+  const pathname = path.join(tmpdir.path, nextdir());\n+  fs.mkdirSync(pathname);\n+  process.chdir(pathname);\n+  fs.rmdirSync(pathname);\n+  try {\n+    fs.mkdirSync('X', { recursive: true });\n+    throw new Error('unreachable');\n+  } catch (err) {\n+    assert.notStrictEqual(err.message, 'unreachable');\n+    assert.strictEqual(err.code, 'ENOENT');\n+    assert.strictEqual(err.syscall, 'mkdir');\n+  }\n+  fs.mkdir('X', { recursive: true }, (err) => {\n+    assert.strictEqual(err.code, 'ENOENT');\n+    assert.strictEqual(err.syscall, 'mkdir');\n+  });\n+}\n+\n // Keep the event loop alive so the async mkdir() requests\n // have a chance to run (since they don't ref the event loop).\n process.nextTick(() => {});"
        },
        {
            "sha": "bcfaaf3890d3776792ddf55759e62239a4d19424",
            "filename": "test/parallel/test-fs-promises.js",
            "status": "modified",
            "additions": 46,
            "deletions": 3,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/test%2Fparallel%2Ftest-fs-promises.js",
            "raw_url": "https://github.com/nodejs/node/raw/bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57/test%2Fparallel%2Ftest-fs-promises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises.js?ref=bdef1b1eb45e2953e1ff68f0cc9a68ec83573e57",
            "patch": "@@ -29,11 +29,17 @@ const {\n   symlink,\n   truncate,\n   unlink,\n-  utimes\n+  utimes,\n+  writeFile\n } = fsPromises;\n \n const tmpDir = tmpdir.path;\n \n+let dirc = 0;\n+function nextdir() {\n+  return `test${++dirc}`;\n+}\n+\n // fs.promises should not be enumerable as long as it causes a warning to be\n // emitted.\n assert.strictEqual(Object.keys(fs).includes('promises'), false);\n@@ -201,12 +207,49 @@ function verifyStatObject(stat) {\n     await mkdir(newdir);\n     stats = await stat(newdir);\n     assert(stats.isDirectory());\n-\n     const list = await readdir(tmpDir);\n     assert.deepStrictEqual(list, ['baz2.js', 'dir']);\n-\n     await rmdir(newdir);\n \n+    // mkdirp when folder does not yet exist.\n+    {\n+      const dir = path.join(tmpDir, nextdir(), nextdir());\n+      await mkdir(dir, { recursive: true });\n+      stats = await stat(dir);\n+      assert(stats.isDirectory());\n+    }\n+\n+    // mkdirp when path is a file.\n+    {\n+      const dir = path.join(tmpDir, nextdir(), nextdir());\n+      await mkdir(path.dirname(dir));\n+      await writeFile(dir);\n+      try {\n+        await mkdir(dir, { recursive: true });\n+        throw new Error('unreachable');\n+      } catch (err) {\n+        assert.notStrictEqual(err.message, 'unreachable');\n+        assert.strictEqual(err.code, 'EEXIST');\n+        assert.strictEqual(err.syscall, 'mkdir');\n+      }\n+    }\n+\n+    // mkdirp ./\n+    {\n+      const dir = path.resolve(tmpDir, `${nextdir()}/./${nextdir()}`);\n+      await mkdir(dir, { recursive: true });\n+      stats = await stat(dir);\n+      assert(stats.isDirectory());\n+    }\n+\n+    // mkdirp ../\n+    {\n+      const dir = path.resolve(tmpDir, `${nextdir()}/../${nextdir()}`);\n+      await mkdir(dir, { recursive: true });\n+      stats = await stat(dir);\n+      assert(stats.isDirectory());\n+    }\n+\n     await mkdtemp(path.resolve(tmpDir, 'FOO'));\n     assert.rejects(\n       // mkdtemp() expects to get a string prefix."
        }
    ],
    "stats": {
        "total": 477,
        "additions": 441,
        "deletions": 36
    }
}