{
    "author": "BridgeAR",
    "message": "test: harden sequential/test-performance\n\n1) This adds a better error logging so we are able to address further\n   failures easier.\n2) It adds a extra epsilon so the test runs into less issues in case\n   the machine is under heavy load.\n3) The epsilon in increased if the CPU is under heavy load.\n4) The total startup epsilon was reduced due to recent startup time\n   improvements.\n\nPR-URL: https://github.com/nodejs/node/pull/22404\nFixes: https://github.com/nodejs/node/issues/19197\nRefs: https://github.com/nodejs/reliability/issues/14\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "c35ce5635cc368a5cadca0dd38098117c45679c9",
    "files": [
        {
            "sha": "72b78bea583bf05135518b701b0466939f6942ff",
            "filename": "test/sequential/test-performance.js",
            "status": "modified",
            "additions": 51,
            "deletions": 18,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/c35ce5635cc368a5cadca0dd38098117c45679c9/test%2Fsequential%2Ftest-performance.js",
            "raw_url": "https://github.com/nodejs/node/raw/c35ce5635cc368a5cadca0dd38098117c45679c9/test%2Fsequential%2Ftest-performance.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-performance.js?ref=c35ce5635cc368a5cadca0dd38098117c45679c9",
            "patch": "@@ -11,11 +11,11 @@ assert(performance);\n assert(performance.nodeTiming);\n assert.strictEqual(typeof performance.timeOrigin, 'number');\n // Use a fairly large epsilon value, since we can only guarantee that the node\n-// process started up in 20 seconds.\n-assert(Math.abs(performance.timeOrigin - Date.now()) < 20000);\n+// process started up in 15 seconds.\n+assert(Math.abs(performance.timeOrigin - Date.now()) < 15000);\n \n const inited = performance.now();\n-assert(inited < 20000);\n+assert(inited < 15000);\n \n {\n   // Should work without throwing any errors\n@@ -56,12 +56,43 @@ assert(inited < 20000);\n assert.strictEqual(performance.nodeTiming.name, 'node');\n assert.strictEqual(performance.nodeTiming.entryType, 'node');\n \n+let timeoutDelay = 111; // An extra of 111 ms for the first call.\n+\n+function checkDelay(cb) {\n+  const defaultTimeout = 1;\n+  const timer = setInterval(checkDelay, defaultTimeout);\n+  const timeouts = 10;\n+\n+  const now = getTime();\n+  let resolved = 0;\n+\n+  function checkDelay() {\n+    resolved++;\n+    if (resolved === timeouts) {\n+      clearInterval(timer);\n+      timeoutDelay = getTime() - now;\n+      cb();\n+    }\n+  }\n+}\n+\n+function getTime() {\n+  const ts = process.hrtime();\n+  return Math.ceil((ts[0] * 1e3) + (ts[1] / 1e6));\n+}\n+\n function checkNodeTiming(props) {\n+  console.log(props);\n+\n   for (const prop of Object.keys(props)) {\n     if (props[prop].around !== undefined) {\n       assert.strictEqual(typeof performance.nodeTiming[prop], 'number');\n       const delta = performance.nodeTiming[prop] - props[prop].around;\n-      assert(Math.abs(delta) < 1000);\n+      const delay = 1000 + timeoutDelay;\n+      assert(\n+        Math.abs(delta) < delay,\n+        `${prop}: ${Math.abs(delta)} >= ${delay}`\n+      );\n     } else {\n       assert.strictEqual(performance.nodeTiming[prop], props[prop],\n                          `mismatch for performance property ${prop}: ` +\n@@ -83,20 +114,22 @@ checkNodeTiming({\n   loopExit: -1\n });\n \n-setTimeout(() => {\n-  checkNodeTiming({\n-    name: 'node',\n-    entryType: 'node',\n-    startTime: 0,\n-    duration: { around: performance.now() },\n-    nodeStart: { around: 0 },\n-    v8Start: { around: 0 },\n-    bootstrapComplete: { around: inited },\n-    environment: { around: 0 },\n-    loopStart: { around: inited },\n-    loopExit: -1\n-  });\n-}, 2000);\n+checkDelay(() => {\n+  setTimeout(() => {\n+    checkNodeTiming({\n+      name: 'node',\n+      entryType: 'node',\n+      startTime: 0,\n+      duration: { around: performance.now() },\n+      nodeStart: { around: 0 },\n+      v8Start: { around: 0 },\n+      bootstrapComplete: { around: inited },\n+      environment: { around: 0 },\n+      loopStart: { around: inited },\n+      loopExit: -1\n+    });\n+  }, 1000);\n+});\n \n process.on('exit', () => {\n   checkNodeTiming({"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 51,
        "deletions": 18
    }
}