{
    "author": "BridgeAR",
    "message": "assert: fix loose set and map comparison\n\nThe fast path did not anticipate different ways to express a loose\nequal string value (e.g., 1n == '+0001'). This is now fixed with the\ndownside that all primitives that could theoretically have equal\nentries must go through a full comparison.\n\nOnly some strings, symbols, undefined, null and NaN can be detected\nin a fast path as those entries have a strictly limited set of\npossible equal entries.\n\nPR-URL: https://github.com/nodejs/node/pull/22495\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Rich Trott <rtrott@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>",
    "sha": "be5e3964b316da013d02ee743420e5fd9cb50c76",
    "files": [
        {
            "sha": "bcbe12181bfbfc39e952652ee655e3d51eb55b24",
            "filename": "lib/internal/util/comparisons.js",
            "status": "modified",
            "additions": 77,
            "deletions": 104,
            "changes": 181,
            "blob_url": "https://github.com/nodejs/node/blob/be5e3964b316da013d02ee743420e5fd9cb50c76/lib%2Finternal%2Futil%2Fcomparisons.js",
            "raw_url": "https://github.com/nodejs/node/raw/be5e3964b316da013d02ee743420e5fd9cb50c76/lib%2Finternal%2Futil%2Fcomparisons.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Fcomparisons.js?ref=be5e3964b316da013d02ee743420e5fd9cb50c76",
            "patch": "@@ -374,23 +374,52 @@ function setHasEqualElement(set, val1, strict, memo) {\n   return false;\n }\n \n-// Note: we currently run this multiple times for each loose key!\n-// This is done to prevent slowing down the average case.\n-function setHasLoosePrim(a, b, val) {\n-  const altValues = findLooseMatchingPrimitives(val);\n-  if (altValues === undefined)\n-    return false;\n+// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\n+// Sadly it is not possible to detect corresponding values properly in case the\n+// type is a string, number, bigint or boolean. The reason is that those values\n+// can match lots of different string values (e.g., 1n == '+00001').\n+function findLooseMatchingPrimitives(prim) {\n+  switch (typeof prim) {\n+    case 'undefined':\n+      return null;\n+    case 'object': // Only pass in null as object!\n+      return undefined;\n+    case 'symbol':\n+      return false;\n+    case 'string':\n+      prim = +prim;\n+      // Loose equal entries exist only if the string is possible to convert to\n+      // a regular number and not NaN.\n+      // Fall through\n+    case 'number':\n+      if (Number.isNaN(prim)) {\n+        return false;\n+      }\n+  }\n+  return true;\n+}\n \n-  let matches = 1;\n-  for (var i = 0; i < altValues.length; i++) {\n-    if (b.has(altValues[i])) {\n-      matches--;\n-    }\n-    if (a.has(altValues[i])) {\n-      matches++;\n-    }\n+function setMightHaveLoosePrim(a, b, prim) {\n+  const altValue = findLooseMatchingPrimitives(prim);\n+  if (altValue != null)\n+    return altValue;\n+\n+  return b.has(altValue) && !a.has(altValue);\n+}\n+\n+function mapMightHaveLoosePrim(a, b, prim, item, memo) {\n+  const altValue = findLooseMatchingPrimitives(prim);\n+  if (altValue != null) {\n+    return altValue;\n+  }\n+  const curB = b.get(altValue);\n+  if (curB === undefined && !b.has(altValue) ||\n+      !innerDeepEqual(item, curB, false, memo)) {\n+    return false;\n   }\n-  return matches === 0;\n+  const curA = a.get(altValue);\n+  return curA === undefined && a.has(altValue) ||\n+         innerDeepEqual(item, curA, false, memo);\n }\n \n function setEquiv(a, b, strict, memo) {\n@@ -410,8 +439,19 @@ function setEquiv(a, b, strict, memo) {\n       // hunting for something thats deep-(strict-)equal to it. To make this\n       // O(n log n) complexity we have to copy these values in a new set first.\n       set.add(val);\n-    } else if (!b.has(val) && (strict || !setHasLoosePrim(a, b, val))) {\n-      return false;\n+    } else if (!b.has(val)) {\n+      if (strict)\n+        return false;\n+\n+      // Fast path to detect missing string, symbol, undefined and null values.\n+      if (!setMightHaveLoosePrim(a, b, val)) {\n+        return false;\n+      }\n+\n+      if (set === null) {\n+        set = new Set();\n+      }\n+      set.add(val);\n     }\n   }\n \n@@ -422,96 +462,18 @@ function setEquiv(a, b, strict, memo) {\n       if (typeof val === 'object' && val !== null) {\n         if (!setHasEqualElement(set, val, strict, memo))\n           return false;\n-      } else if (!a.has(val) && (strict || !setHasLoosePrim(b, a, val))) {\n+      } else if (!strict &&\n+                 !a.has(val) &&\n+                 !setHasEqualElement(set, val, strict, memo)) {\n         return false;\n       }\n     }\n+    return set.size === 0;\n   }\n \n   return true;\n }\n \n-// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\n-function findLooseMatchingPrimitives(prim) {\n-  switch (typeof prim) {\n-    case 'number':\n-      if (prim === 0) {\n-        return ['', '0', false];\n-      }\n-      if (prim === 1) {\n-        return ['1', true];\n-      }\n-      return ['' + prim];\n-    case 'string':\n-      if (prim === '' || prim === '0') {\n-        return [0, false];\n-      }\n-      if (prim === '1') {\n-        return [1, true];\n-      }\n-      const number = +prim;\n-      if ('' + number === prim) {\n-        return [number];\n-      }\n-      return;\n-    case 'undefined':\n-      return [null];\n-    case 'object': // Only pass in null as object!\n-      return [undefined];\n-    case 'boolean':\n-      if (prim === false) {\n-        return ['', '0', 0];\n-      }\n-      return ['1', 1];\n-  }\n-}\n-\n-// This is a ugly but relatively fast way to determine if a loose equal entry\n-// currently has a correspondent matching entry. Otherwise checking for such\n-// values would be way more expensive (O(n^2)).\n-// Note: we currently run this multiple times for each loose key!\n-// This is done to prevent slowing down the average case.\n-function mapHasLoosePrim(a, b, key1, memo, item1, item2) {\n-  const altKeys = findLooseMatchingPrimitives(key1);\n-  if (altKeys === undefined)\n-    return false;\n-\n-  const setA = new Set();\n-  const setB = new Set();\n-\n-  let keyCount = 1;\n-\n-  setA.add(item1);\n-  if (b.has(key1)) {\n-    keyCount--;\n-    setB.add(item2);\n-  }\n-\n-  for (var i = 0; i < altKeys.length; i++) {\n-    const key2 = altKeys[i];\n-    if (a.has(key2)) {\n-      keyCount++;\n-      setA.add(a.get(key2));\n-    }\n-    if (b.has(key2)) {\n-      keyCount--;\n-      setB.add(b.get(key2));\n-    }\n-  }\n-  if (keyCount !== 0 || setA.size !== setB.size)\n-    return false;\n-\n-  for (const val of setA) {\n-    if (typeof val === 'object' && val !== null) {\n-      if (!setHasEqualElement(setB, val, false, memo))\n-        return false;\n-    } else if (!setB.has(val) && !setHasLoosePrim(setA, setB, val)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n function mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n   // To be able to handle cases like:\n   //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n@@ -541,9 +503,17 @@ function mapEquiv(a, b, strict, memo) {\n       // almost all possible cases.\n       const item2 = b.get(key);\n       if ((item2 === undefined && !b.has(key) ||\n-        !innerDeepEqual(item1, item2, strict, memo)) &&\n-        (strict || !mapHasLoosePrim(a, b, key, memo, item1, item2))) {\n-        return false;\n+          !innerDeepEqual(item1, item2, strict, memo))) {\n+        if (strict)\n+          return false;\n+        // Fast path to detect missing string, symbol, undefined and null\n+        // keys.\n+        if (!mapMightHaveLoosePrim(a, b, key, item1, memo))\n+          return false;\n+        if (set === null) {\n+          set = new Set();\n+        }\n+        set.add(key);\n       }\n     }\n   }\n@@ -553,11 +523,14 @@ function mapEquiv(a, b, strict, memo) {\n       if (typeof key === 'object' && key !== null) {\n         if (!mapHasEqualEntry(set, a, key, item, strict, memo))\n           return false;\n-      } else if (!a.has(key) &&\n-        (strict || !mapHasLoosePrim(b, a, key, memo, item))) {\n+      } else if (!strict &&\n+                 (!a.has(key) ||\n+                   !innerDeepEqual(a.get(key), item, false, memo)) &&\n+                 !mapHasEqualEntry(set, a, key, item, false, memo)) {\n         return false;\n       }\n     }\n+    return set.size === 0;\n   }\n \n   return true;"
        },
        {
            "sha": "1d8f8fae123318e875284285272ac815393f0b9f",
            "filename": "test/parallel/test-assert-deep.js",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/be5e3964b316da013d02ee743420e5fd9cb50c76/test%2Fparallel%2Ftest-assert-deep.js",
            "raw_url": "https://github.com/nodejs/node/raw/be5e3964b316da013d02ee743420e5fd9cb50c76/test%2Fparallel%2Ftest-assert-deep.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-deep.js?ref=be5e3964b316da013d02ee743420e5fd9cb50c76",
            "patch": "@@ -369,13 +369,13 @@ assertDeepAndStrictEqual(\n   new Map([[null, 3]])\n );\n assertOnlyDeepEqual(\n-  new Map([[null, undefined]]),\n-  new Map([[undefined, null]])\n+  new Map([[undefined, null], ['+000', 2n]]),\n+  new Map([[null, undefined], [false, '2']]),\n );\n \n assertOnlyDeepEqual(\n-  new Set([null, '']),\n-  new Set([undefined, 0])\n+  new Set([null, '', 1n, 5, 2n, false]),\n+  new Set([undefined, 0, 5n, true, '2', '-000'])\n );\n assertNotDeepOrStrict(\n   new Set(['']),"
        }
    ],
    "stats": {
        "total": 189,
        "additions": 81,
        "deletions": 108
    }
}