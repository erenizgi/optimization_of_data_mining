{
    "author": "BridgeAR",
    "message": "util: improve inspect performance\n\nThis improves a slow code part in `util.inspect` by directly\nretrieving the `Symbol.toStringTag` and by optimizing some code\npaths.\n\nPR-URL: https://github.com/nodejs/node/pull/20009\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Yuta Hiroto <hello@hiroppy.me>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "ad1d1057f9362558fcc76b603458374f5f5a31c5",
    "files": [
        {
            "sha": "3cd370258bf72c92c8096fd422eca7c393d1ebaa",
            "filename": "lib/internal/util.js",
            "status": "modified",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/ad1d1057f9362558fcc76b603458374f5f5a31c5/lib%2Finternal%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/ad1d1057f9362558fcc76b603458374f5f5a31c5/lib%2Finternal%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil.js?ref=ad1d1057f9362558fcc76b603458374f5f5a31c5",
            "patch": "@@ -252,43 +252,6 @@ function getSystemErrorName(err) {\n   return entry ? entry[0] : `Unknown system error ${err}`;\n }\n \n-// getConstructorOf is wrapped into this to save iterations\n-function getIdentificationOf(obj) {\n-  const original = obj;\n-  let constructor;\n-  let tag;\n-\n-  while (obj) {\n-    if (constructor === undefined) {\n-      const desc = Object.getOwnPropertyDescriptor(obj, 'constructor');\n-      if (desc !== undefined &&\n-          typeof desc.value === 'function' &&\n-          desc.value.name !== '')\n-        constructor = desc.value.name;\n-    }\n-\n-    if (tag === undefined) {\n-      const desc = Object.getOwnPropertyDescriptor(obj, Symbol.toStringTag);\n-      if (desc !== undefined) {\n-        if (typeof desc.value === 'string') {\n-          tag = desc.value;\n-        } else if (desc.get !== undefined) {\n-          tag = desc.get.call(original);\n-          if (typeof tag !== 'string')\n-            tag = undefined;\n-        }\n-      }\n-    }\n-\n-    if (constructor !== undefined && tag !== undefined)\n-      break;\n-\n-    obj = Object.getPrototypeOf(obj);\n-  }\n-\n-  return { constructor, tag };\n-}\n-\n const kCustomPromisifiedSymbol = Symbol('util.promisify.custom');\n const kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n \n@@ -431,7 +394,6 @@ module.exports = {\n   filterDuplicateStrings,\n   getConstructorOf,\n   getSystemErrorName,\n-  getIdentificationOf,\n   isError,\n   isInsideNodeModules,\n   join,"
        },
        {
            "sha": "91404d254dc9a4bc9a5cdab282e71e822ee6e7e6",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 53,
            "deletions": 21,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/ad1d1057f9362558fcc76b603458374f5f5a31c5/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/ad1d1057f9362558fcc76b603458374f5f5a31c5/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=ad1d1057f9362558fcc76b603458374f5f5a31c5",
            "patch": "@@ -72,7 +72,6 @@ const {\n   customInspectSymbol,\n   deprecate,\n   getSystemErrorName: internalErrorName,\n-  getIdentificationOf,\n   isError,\n   promisify,\n   join,\n@@ -396,6 +395,35 @@ function stylizeNoColor(str, styleType) {\n   return str;\n }\n \n+function getConstructorName(obj) {\n+  while (obj) {\n+    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n+    if (descriptor !== undefined &&\n+        typeof descriptor.value === 'function' &&\n+        descriptor.value.name !== '') {\n+      return descriptor.value.name;\n+    }\n+\n+    obj = Object.getPrototypeOf(obj);\n+  }\n+\n+  return '';\n+}\n+\n+function getPrefix(constructor, tag) {\n+  if (constructor !== '') {\n+    if (tag !== '' && constructor !== tag) {\n+      return `${constructor} [${tag}] `;\n+    }\n+    return `${constructor} `;\n+  }\n+\n+  if (tag !== '')\n+    return `[${tag}] `;\n+\n+  return '';\n+}\n+\n function formatValue(ctx, value, recurseTimes, ln) {\n   // Primitive types cannot have properties\n   if (typeof value !== 'object' && typeof value !== 'function') {\n@@ -475,15 +503,10 @@ function formatValue(ctx, value, recurseTimes, ln) {\n \n   const keyLength = keys.length + symbols.length;\n \n-  const { constructor, tag } = getIdentificationOf(value);\n-  let prefix = '';\n-  if (constructor && tag && constructor !== tag)\n-    prefix = `${constructor} [${tag}] `;\n-  else if (constructor)\n-    prefix = `${constructor} `;\n-  else if (tag)\n-    prefix = `[${tag}] `;\n-\n+  const constructor = getConstructorName(value);\n+  let tag = value[Symbol.toStringTag];\n+  if (typeof tag !== 'string')\n+    tag = '';\n   let base = '';\n   let formatter = formatObject;\n   let braces;\n@@ -496,22 +519,25 @@ function formatValue(ctx, value, recurseTimes, ln) {\n     noIterator = false;\n     if (Array.isArray(value)) {\n       // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n+      const prefix = getPrefix(constructor, tag);\n       braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n       if (value.length === 0 && keyLength === 0)\n         return `${braces[0]}]`;\n       formatter = formatArray;\n     } else if (isSet(value)) {\n+      const prefix = getPrefix(constructor, tag);\n       if (value.size === 0 && keyLength === 0)\n         return `${prefix}{}`;\n       braces = [`${prefix}{`, '}'];\n       formatter = formatSet;\n     } else if (isMap(value)) {\n+      const prefix = getPrefix(constructor, tag);\n       if (value.size === 0 && keyLength === 0)\n         return `${prefix}{}`;\n       braces = [`${prefix}{`, '}'];\n       formatter = formatMap;\n     } else if (isTypedArray(value)) {\n-      braces = [`${prefix}[`, ']'];\n+      braces = [`${getPrefix(constructor, tag)}[`, ']'];\n       formatter = formatTypedArray;\n     } else if (isMapIterator(value)) {\n       braces = [`[${tag}] {`, '}'];\n@@ -543,11 +569,16 @@ function formatValue(ctx, value, recurseTimes, ln) {\n   }\n   if (noIterator) {\n     braces = ['{', '}'];\n-    if (prefix === 'Object ') {\n+    if (constructor === 'Object') {\n       if (isArgumentsObject(value)) {\n         braces[0] = '[Arguments] {';\n         if (keyLength === 0)\n           return '[Arguments] {}';\n+      } else if (tag !== '') {\n+        braces[0] = `${getPrefix(constructor, tag)}{`;\n+        if (keyLength === 0) {\n+          return `${braces[0]}}`;\n+        }\n       } else if (keyLength === 0) {\n         return '{}';\n       }\n@@ -579,27 +610,28 @@ function formatValue(ctx, value, recurseTimes, ln) {\n       // Fast path for ArrayBuffer and SharedArrayBuffer.\n       // Can't do the same for DataView because it has a non-primitive\n       // .buffer property that we need to recurse for.\n+      const prefix = getPrefix(constructor, tag);\n       if (keyLength === 0)\n         return prefix +\n               `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n       braces[0] = `${prefix}{`;\n       keys.unshift('byteLength');\n     } else if (isDataView(value)) {\n-      braces[0] = `${prefix}{`;\n+      braces[0] = `${getPrefix(constructor, tag)}{`;\n       // .buffer goes last, it's not a primitive like the others.\n       keys.unshift('byteLength', 'byteOffset', 'buffer');\n     } else if (isPromise(value)) {\n-      braces[0] = `${prefix}{`;\n+      braces[0] = `${getPrefix(constructor, tag)}{`;\n       formatter = formatPromise;\n     } else if (isWeakSet(value)) {\n-      braces[0] = `${prefix}{`;\n+      braces[0] = `${getPrefix(constructor, tag)}{`;\n       if (ctx.showHidden) {\n         formatter = formatWeakSet;\n       } else {\n         extra = '[items unknown]';\n       }\n     } else if (isWeakMap(value)) {\n-      braces[0] = `${prefix}{`;\n+      braces[0] = `${getPrefix(constructor, tag)}{`;\n       if (ctx.showHidden) {\n         formatter = formatWeakMap;\n       } else {\n@@ -638,9 +670,9 @@ function formatValue(ctx, value, recurseTimes, ln) {\n       } else if (keyLength === 0) {\n         if (isExternal(value))\n           return ctx.stylize('[External]', 'special');\n-        return `${prefix}{}`;\n+        return `${getPrefix(constructor, tag)}{}`;\n       } else {\n-        braces[0] = `${prefix}{`;\n+        braces[0] = `${getPrefix(constructor, tag)}{`;\n       }\n     }\n   }\n@@ -675,8 +707,8 @@ function formatNumber(fn, value) {\n function formatPrimitive(fn, value, ctx) {\n   if (typeof value === 'string') {\n     if (ctx.compact === false &&\n-      value.length > MIN_LINE_LENGTH &&\n-      ctx.indentationLvl + value.length > ctx.breakLength) {\n+      ctx.indentationLvl + value.length > ctx.breakLength &&\n+      value.length > MIN_LINE_LENGTH) {\n       // eslint-disable-next-line max-len\n       const minLineLength = Math.max(ctx.breakLength - ctx.indentationLvl, MIN_LINE_LENGTH);\n       // eslint-disable-next-line max-len\n@@ -695,9 +727,9 @@ function formatPrimitive(fn, value, ctx) {\n         // eslint-disable-next-line max-len, node-core/no-unescaped-regexp-dot\n         readableRegExps[divisor] = new RegExp(`(.|\\\\n){1,${divisor}}(\\\\s|$)|(\\\\n|.)+?(\\\\s|$)`, 'gm');\n       }\n-      const indent = ' '.repeat(ctx.indentationLvl);\n       const matches = value.match(readableRegExps[divisor]);\n       if (matches.length > 1) {\n+        const indent = ' '.repeat(ctx.indentationLvl);\n         res += `${fn(strEscape(matches[0]), 'string')} +\\n`;\n         for (var i = 1; i < matches.length - 1; i++) {\n           res += `${indent}  ${fn(strEscape(matches[i]), 'string')} +\\n`;"
        }
    ],
    "stats": {
        "total": 112,
        "additions": 53,
        "deletions": 59
    }
}