{
    "author": "BridgeAR",
    "message": "buffer: improve Buffer#fill performance\n\n1) This improves the performance for Buffer#fill by using shortcuts.\n2) It also ports throwing errors to JS. That way they contain the\nproper error code.\n3) Using negative `end` values will from now on result in an error\ninstead of just doing nothing.\n4) Passing in `null` as encoding is from now on accepted as 'utf8'.\n\nPR-URL: https://github.com/nodejs/node/pull/18790\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "177b7314cf62f6c268eef9f71657aba9c93385ed",
    "files": [
        {
            "sha": "510848c3b0463599290dc0ae1b323d8271171b68",
            "filename": "doc/api/buffer.md",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/177b7314cf62f6c268eef9f71657aba9c93385ed/doc%2Fapi%2Fbuffer.md",
            "raw_url": "https://github.com/nodejs/node/raw/177b7314cf62f6c268eef9f71657aba9c93385ed/doc%2Fapi%2Fbuffer.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fbuffer.md?ref=177b7314cf62f6c268eef9f71657aba9c93385ed",
            "patch": "@@ -1202,6 +1202,9 @@ console.log(buf1.equals(buf3));\n <!-- YAML\n added: v0.5.0\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18790\n+    description: Negative `end` values throw an `ERR_INDEX_OUT_OF_RANGE` error.\n   - version: REPLACEME\n     pr-url: https://github.com/nodejs/node/pull/18129\n     description: Attempting to fill a non-zero length buffer with a zero length"
        },
        {
            "sha": "07bd63c0ae5b97b8ce4b43e88dc90e3225618456",
            "filename": "lib/buffer.js",
            "status": "modified",
            "additions": 46,
            "deletions": 42,
            "changes": 88,
            "blob_url": "https://github.com/nodejs/node/blob/177b7314cf62f6c268eef9f71657aba9c93385ed/lib%2Fbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/177b7314cf62f6c268eef9f71657aba9c93385ed/lib%2Fbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fbuffer.js?ref=177b7314cf62f6c268eef9f71657aba9c93385ed",
            "patch": "@@ -254,16 +254,8 @@ function assertSize(size) {\n  **/\n Buffer.alloc = function alloc(size, fill, encoding) {\n   assertSize(size);\n-  if (size > 0 && fill !== undefined) {\n-    // Since we are filling anyway, don't zero fill initially.\n-    // Only pay attention to encoding if it's a string. This\n-    // prevents accidentally sending in a number that would\n-    // be interpreted as a start offset.\n-    if (typeof encoding !== 'string')\n-      encoding = undefined;\n-    const ret = createUnsafeBuffer(size);\n-    if (fill_(ret, fill, encoding) > 0)\n-      return ret;\n+  if (fill !== undefined && size > 0) {\n+    return _fill(createUnsafeBuffer(size), fill, encoding);\n   }\n   return new FastBuffer(size);\n };\n@@ -834,14 +826,12 @@ Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n //    buffer.fill(buffer[, offset[, end]])\n //    buffer.fill(string[, offset[, end]][, encoding])\n Buffer.prototype.fill = function fill(val, start, end, encoding) {\n-  fill_(this, val, start, end, encoding);\n-  return this;\n+  return _fill(this, val, start, end, encoding);\n };\n \n-function fill_(buf, val, start, end, encoding) {\n-  // Handle string cases:\n+function _fill(buf, val, start, end, encoding) {\n   if (typeof val === 'string') {\n-    if (typeof start === 'string') {\n+    if (start === undefined || typeof start === 'string') {\n       encoding = start;\n       start = 0;\n       end = buf.length;\n@@ -850,46 +840,60 @@ function fill_(buf, val, start, end, encoding) {\n       end = buf.length;\n     }\n \n-    if (encoding !== undefined && typeof encoding !== 'string') {\n-      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'encoding',\n-                                 'string', encoding);\n-    }\n-    var normalizedEncoding = normalizeEncoding(encoding);\n+    const normalizedEncoding = normalizeEncoding(encoding);\n     if (normalizedEncoding === undefined) {\n+      if (typeof encoding !== 'string') {\n+        throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'encoding', 'string',\n+                                   encoding);\n+      }\n       throw new errors.TypeError('ERR_UNKNOWN_ENCODING', encoding);\n     }\n \n     if (val.length === 0) {\n-      // Previously, if val === '', the Buffer would not fill,\n-      // which is rather surprising.\n+      // If val === '' default to zero.\n       val = 0;\n     } else if (val.length === 1) {\n-      var code = val.charCodeAt(0);\n-      if ((normalizedEncoding === 'utf8' && code < 128) ||\n-          normalizedEncoding === 'latin1') {\n-        // Fast path: If `val` fits into a single byte, use that numeric value.\n-        val = code;\n+      // Fast path: If `val` fits into a single byte, use that numeric value.\n+      if (normalizedEncoding === 'utf8') {\n+        const code = val.charCodeAt(0);\n+        if (code < 128) {\n+          val = code;\n+        }\n+      } else if (normalizedEncoding === 'latin1') {\n+        val = val.charCodeAt(0);\n       }\n     }\n-  } else if (typeof val === 'number') {\n-    val = val & 255;\n+  } else {\n+    encoding = undefined;\n   }\n \n-  // Invalid ranges are not set to a default, so can range check early.\n-  if (start < 0 || end > buf.length)\n-    throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n-\n-  if (end <= start)\n-    return 0;\n-\n-  start = start >>> 0;\n-  end = end === undefined ? buf.length : end >>> 0;\n-  const fillLength = bindingFill(buf, val, start, end, encoding);\n+  if (start === undefined) {\n+    start = 0;\n+    end = buf.length;\n+  } else {\n+    // Invalid ranges are not set to a default, so can range check early.\n+    if (end === undefined) {\n+      if (start < 0)\n+        throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n+      end = buf.length;\n+    } else {\n+      if (start < 0 || end > buf.length || end < 0)\n+        throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n+      end = end >>> 0;\n+    }\n+    start = start >>> 0;\n+    if (start >= end)\n+      return buf;\n+  }\n \n-  if (fillLength === -1)\n-    throw new errors.TypeError('ERR_INVALID_ARG_VALUE', 'value', val);\n+  const res = bindingFill(buf, val, start, end, encoding);\n+  if (res < 0) {\n+    if (res === -1)\n+      throw new errors.TypeError('ERR_INVALID_ARG_VALUE', 'value', val);\n+    throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n+  }\n \n-  return fillLength;\n+  return buf;\n }\n \n "
        },
        {
            "sha": "2516b84f342cea5c8e29df734bd89b3baf4f5292",
            "filename": "lib/internal/util.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/177b7314cf62f6c268eef9f71657aba9c93385ed/lib%2Finternal%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/177b7314cf62f6c268eef9f71657aba9c93385ed/lib%2Finternal%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil.js?ref=177b7314cf62f6c268eef9f71657aba9c93385ed",
            "patch": "@@ -102,7 +102,7 @@ function assertCrypto() {\n // function in order to avoid the performance hit.\n // Return undefined if there is no match.\n function normalizeEncoding(enc) {\n-  if (!enc) return 'utf8';\n+  if (enc == null || enc === '') return 'utf8';\n   let retried;\n   while (true) {\n     switch (enc) {"
        },
        {
            "sha": "c44aa692cdacfe609a7a15f6db67820128489a5e",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 11,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/177b7314cf62f6c268eef9f71657aba9c93385ed/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/177b7314cf62f6c268eef9f71657aba9c93385ed/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=177b7314cf62f6c268eef9f71657aba9c93385ed",
            "patch": "@@ -571,10 +571,10 @@ void Fill(const FunctionCallbackInfo<Value>& args) {\n   Local<String> str_obj;\n   size_t str_length;\n   enum encoding enc;\n-  THROW_AND_RETURN_IF_OOB(start <= end);\n-  THROW_AND_RETURN_IF_OOB(fill_length + start <= ts_obj_length);\n \n-  args.GetReturnValue().Set(static_cast<double>(fill_length));\n+  // OOB Check. Throw the error in JS.\n+  if (start > end || fill_length + start > ts_obj_length)\n+    return args.GetReturnValue().Set(-2);\n \n   // First check if Buffer has been passed.\n   if (Buffer::HasInstance(args[1])) {\n@@ -593,29 +593,24 @@ void Fill(const FunctionCallbackInfo<Value>& args) {\n \n   str_obj = args[1]->ToString(env->context()).ToLocalChecked();\n   enc = ParseEncoding(env->isolate(), args[4], UTF8);\n-  str_length =\n-      enc == UTF8 ? str_obj->Utf8Length() :\n-      enc == UCS2 ? str_obj->Length() * sizeof(uint16_t) : str_obj->Length();\n-\n-  if (str_length == 0) {\n-    args.GetReturnValue().Set(0);\n-    return;\n-  }\n \n   // Can't use StringBytes::Write() in all cases. For example if attempting\n   // to write a two byte character into a one byte Buffer.\n   if (enc == UTF8) {\n+    str_length = str_obj->Utf8Length();\n     node::Utf8Value str(env->isolate(), args[1]);\n     memcpy(ts_obj_data + start, *str, MIN(str_length, fill_length));\n \n   } else if (enc == UCS2) {\n+    str_length = str_obj->Length() * sizeof(uint16_t);\n     node::TwoByteValue str(env->isolate(), args[1]);\n     if (IsBigEndian())\n       SwapBytes16(reinterpret_cast<char*>(&str[0]), str_length);\n \n     memcpy(ts_obj_data + start, *str, MIN(str_length, fill_length));\n \n   } else {\n+    str_length = str_obj->Length();\n     // Write initial String to Buffer, then use that memory to copy remainder\n     // of string. Correct the string length for cases like HEX where less than\n     // the total string length is written."
        },
        {
            "sha": "bab12796806d8c9b75dc3ab1f1285a39d61464e6",
            "filename": "test/parallel/test-buffer-fill.js",
            "status": "modified",
            "additions": 20,
            "deletions": 78,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/177b7314cf62f6c268eef9f71657aba9c93385ed/test%2Fparallel%2Ftest-buffer-fill.js",
            "raw_url": "https://github.com/nodejs/node/raw/177b7314cf62f6c268eef9f71657aba9c93385ed/test%2Fparallel%2Ftest-buffer-fill.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-fill.js?ref=177b7314cf62f6c268eef9f71657aba9c93385ed",
            "patch": "@@ -19,16 +19,12 @@ testBufs('\\u0222aa', 2);\n testBufs('\\u0222aa', 8);\n testBufs('a\\u0234b\\u0235c\\u0236', 4);\n testBufs('a\\u0234b\\u0235c\\u0236', 12);\n-testBufs('abc', 4, -1);\n testBufs('abc', 4, 1);\n testBufs('abc', 5, 1);\n-testBufs('\\u0222aa', 2, -1);\n testBufs('\\u0222aa', 8, 1);\n-testBufs('a\\u0234b\\u0235c\\u0236', 4, -1);\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 1);\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 1);\n \n-\n // UTF8\n testBufs('abc', 'utf8');\n testBufs('\\u0222aa', 'utf8');\n@@ -40,17 +36,13 @@ testBufs('\\u0222aa', 2, 'utf8');\n testBufs('\\u0222aa', 8, 'utf8');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 'utf8');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 'utf8');\n-testBufs('abc', 4, -1, 'utf8');\n testBufs('abc', 4, 1, 'utf8');\n testBufs('abc', 5, 1, 'utf8');\n-testBufs('\\u0222aa', 2, -1, 'utf8');\n testBufs('\\u0222aa', 8, 1, 'utf8');\n-testBufs('a\\u0234b\\u0235c\\u0236', 4, -1, 'utf8');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 1, 'utf8');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 1, 'utf8');\n assert.strictEqual(Buffer.allocUnsafe(1).fill(0).fill('\\u0222')[0], 0xc8);\n \n-\n // BINARY\n testBufs('abc', 'binary');\n testBufs('\\u0222aa', 'binary');\n@@ -62,16 +54,12 @@ testBufs('\\u0222aa', 2, 'binary');\n testBufs('\\u0222aa', 8, 'binary');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 'binary');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 'binary');\n-testBufs('abc', 4, -1, 'binary');\n testBufs('abc', 4, 1, 'binary');\n testBufs('abc', 5, 1, 'binary');\n-testBufs('\\u0222aa', 2, -1, 'binary');\n testBufs('\\u0222aa', 8, 1, 'binary');\n-testBufs('a\\u0234b\\u0235c\\u0236', 4, -1, 'binary');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 1, 'binary');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 1, 'binary');\n \n-\n // LATIN1\n testBufs('abc', 'latin1');\n testBufs('\\u0222aa', 'latin1');\n@@ -83,16 +71,12 @@ testBufs('\\u0222aa', 2, 'latin1');\n testBufs('\\u0222aa', 8, 'latin1');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 'latin1');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 'latin1');\n-testBufs('abc', 4, -1, 'latin1');\n testBufs('abc', 4, 1, 'latin1');\n testBufs('abc', 5, 1, 'latin1');\n-testBufs('\\u0222aa', 2, -1, 'latin1');\n testBufs('\\u0222aa', 8, 1, 'latin1');\n-testBufs('a\\u0234b\\u0235c\\u0236', 4, -1, 'latin1');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 1, 'latin1');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 1, 'latin1');\n \n-\n // UCS2\n testBufs('abc', 'ucs2');\n testBufs('\\u0222aa', 'ucs2');\n@@ -103,17 +87,13 @@ testBufs('\\u0222aa', 2, 'ucs2');\n testBufs('\\u0222aa', 8, 'ucs2');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 'ucs2');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 'ucs2');\n-testBufs('abc', 4, -1, 'ucs2');\n testBufs('abc', 4, 1, 'ucs2');\n testBufs('abc', 5, 1, 'ucs2');\n-testBufs('\\u0222aa', 2, -1, 'ucs2');\n testBufs('\\u0222aa', 8, 1, 'ucs2');\n-testBufs('a\\u0234b\\u0235c\\u0236', 4, -1, 'ucs2');\n testBufs('a\\u0234b\\u0235c\\u0236', 4, 1, 'ucs2');\n testBufs('a\\u0234b\\u0235c\\u0236', 12, 1, 'ucs2');\n assert.strictEqual(Buffer.allocUnsafe(1).fill('\\u0222', 'ucs2')[0], 0x22);\n \n-\n // HEX\n testBufs('616263', 'hex');\n testBufs('c8a26161', 'hex');\n@@ -125,12 +105,9 @@ testBufs('c8a26161', 2, 'hex');\n testBufs('c8a26161', 8, 'hex');\n testBufs('61c8b462c8b563c8b6', 4, 'hex');\n testBufs('61c8b462c8b563c8b6', 12, 'hex');\n-testBufs('616263', 4, -1, 'hex');\n testBufs('616263', 4, 1, 'hex');\n testBufs('616263', 5, 1, 'hex');\n-testBufs('c8a26161', 2, -1, 'hex');\n testBufs('c8a26161', 8, 1, 'hex');\n-testBufs('61c8b462c8b563c8b6', 4, -1, 'hex');\n testBufs('61c8b462c8b563c8b6', 4, 1, 'hex');\n testBufs('61c8b462c8b563c8b6', 12, 1, 'hex');\n \n@@ -162,44 +139,37 @@ testBufs('yKJhYQ==', 2, 'ucs2');\n testBufs('yKJhYQ==', 8, 'ucs2');\n testBufs('Yci0Ysi1Y8i2', 4, 'ucs2');\n testBufs('Yci0Ysi1Y8i2', 12, 'ucs2');\n-testBufs('YWJj', 4, -1, 'ucs2');\n testBufs('YWJj', 4, 1, 'ucs2');\n testBufs('YWJj', 5, 1, 'ucs2');\n-testBufs('yKJhYQ==', 2, -1, 'ucs2');\n testBufs('yKJhYQ==', 8, 1, 'ucs2');\n-testBufs('Yci0Ysi1Y8i2', 4, -1, 'ucs2');\n testBufs('Yci0Ysi1Y8i2', 4, 1, 'ucs2');\n testBufs('Yci0Ysi1Y8i2', 12, 1, 'ucs2');\n \n-\n // Buffer\n function deepStrictEqualValues(buf, arr) {\n   for (const [index, value] of buf.entries()) {\n     assert.deepStrictEqual(value, arr[index]);\n   }\n }\n \n-\n const buf2Fill = Buffer.allocUnsafe(1).fill(2);\n deepStrictEqualValues(genBuffer(4, [buf2Fill]), [2, 2, 2, 2]);\n deepStrictEqualValues(genBuffer(4, [buf2Fill, 1]), [0, 2, 2, 2]);\n deepStrictEqualValues(genBuffer(4, [buf2Fill, 1, 3]), [0, 2, 2, 0]);\n deepStrictEqualValues(genBuffer(4, [buf2Fill, 1, 1]), [0, 0, 0, 0]);\n-deepStrictEqualValues(genBuffer(4, [buf2Fill, 1, -1]), [0, 0, 0, 0]);\n const hexBufFill = Buffer.allocUnsafe(2).fill(0).fill('0102', 'hex');\n deepStrictEqualValues(genBuffer(4, [hexBufFill]), [1, 2, 1, 2]);\n deepStrictEqualValues(genBuffer(4, [hexBufFill, 1]), [0, 1, 2, 1]);\n deepStrictEqualValues(genBuffer(4, [hexBufFill, 1, 3]), [0, 1, 2, 0]);\n deepStrictEqualValues(genBuffer(4, [hexBufFill, 1, 1]), [0, 0, 0, 0]);\n-deepStrictEqualValues(genBuffer(4, [hexBufFill, 1, -1]), [0, 0, 0, 0]);\n-\n \n // Check exceptions\n [\n   [0, -1],\n   [0, 0, buf1.length + 1],\n   ['', -1],\n-  ['', 0, buf1.length + 1]\n+  ['', 0, buf1.length + 1],\n+  ['', 1, -1],\n ].forEach((args) => {\n   common.expectsError(\n     () => buf1.fill(...args),\n@@ -218,7 +188,7 @@ common.expectsError(\n \n [\n   ['a', 0, 0, NaN],\n-  ['a', 0, 0, null]\n+  ['a', 0, 0, false]\n ].forEach((args) => {\n   common.expectsError(\n     () => buf1.fill(...args),\n@@ -356,42 +326,10 @@ Buffer.alloc(8, '');\n   assert.strictEqual(buf.toString(), 'էէէէէ');\n }\n \n-// Testing public API. Make sure \"start\" is properly checked, even if it's\n-// magically mangled using Symbol.toPrimitive.\n-{\n-  let elseWasLast = false;\n-  common.expectsError(() => {\n-    let ctr = 0;\n-    const start = {\n-      [Symbol.toPrimitive]() {\n-        // We use this condition to get around the check in lib/buffer.js\n-        if (ctr <= 0) {\n-          elseWasLast = false;\n-          ctr = ctr + 1;\n-          return 0;\n-        } else {\n-          elseWasLast = true;\n-          // Once buffer.js calls the C++ implementation of fill, return -1\n-          return -1;\n-        }\n-      }\n-    };\n-    Buffer.alloc(1).fill(Buffer.alloc(1), start, 1);\n-  }, {\n-    code: undefined, type: RangeError, message: 'Index out of range'\n-  });\n-  // Make sure -1 is making it to Buffer::Fill().\n-  assert.ok(elseWasLast,\n-            'internal API changed, -1 no longer in correct location');\n-}\n-\n // Testing process.binding. Make sure \"start\" is properly checked for -1 wrap\n // around.\n-common.expectsError(() => {\n-  process.binding('buffer').fill(Buffer.alloc(1), 1, -1, 0, 1);\n-}, {\n-  code: undefined, type: RangeError, message: 'Index out of range'\n-});\n+assert.strictEqual(\n+  process.binding('buffer').fill(Buffer.alloc(1), 1, -1, 0, 1), -2);\n \n // Make sure \"end\" is properly checked, even if it's magically mangled using\n // Symbol.toPrimitive.\n@@ -402,20 +340,21 @@ common.expectsError(() => {\n     const end = {\n       [Symbol.toPrimitive]() {\n         // We use this condition to get around the check in lib/buffer.js\n-        if (ctr <= 1) {\n+        if (ctr === 0) {\n           elseWasLast = false;\n-          ctr = ctr + 1;\n+          ctr++;\n           return 1;\n-        } else {\n-          elseWasLast = true;\n-          // Once buffer.js calls the C++ implementation of fill, return -1\n-          return -1;\n         }\n+        elseWasLast = true;\n+        // Once buffer.js calls the C++ implementation of fill, return -1\n+        return -1;\n       }\n     };\n     Buffer.alloc(1).fill(Buffer.alloc(1), 0, end);\n   }, {\n-    code: undefined, type: RangeError, message: 'Index out of range'\n+    code: 'ERR_INDEX_OUT_OF_RANGE',\n+    type: RangeError,\n+    message: 'Index out of range'\n   });\n   // Make sure -1 is making it to Buffer::Fill().\n   assert.ok(elseWasLast,\n@@ -424,9 +363,8 @@ common.expectsError(() => {\n \n // Testing process.binding. Make sure \"end\" is properly checked for -1 wrap\n // around.\n-common.expectsError(() => {\n-  process.binding('buffer').fill(Buffer.alloc(1), 1, 1, -2, 1);\n-}, { code: undefined, type: RangeError, message: 'Index out of range' });\n+assert.strictEqual(\n+  process.binding('buffer').fill(Buffer.alloc(1), 1, 1, -2, 1), -2);\n \n // Test that bypassing 'length' won't cause an abort.\n common.expectsError(() => {\n@@ -436,7 +374,11 @@ common.expectsError(() => {\n     enumerable: true\n   });\n   buf.fill('');\n-}, { code: undefined, type: RangeError, message: 'Index out of range' });\n+}, {\n+  code: 'ERR_INDEX_OUT_OF_RANGE',\n+  type: RangeError,\n+  message: 'Index out of range'\n+});\n \n assert.deepStrictEqual(\n   Buffer.allocUnsafeSlow(16).fill('ab', 'utf16le'),"
        },
        {
            "sha": "081255cef02f2af5ba73cb78dbe5291d8d8535b5",
            "filename": "test/parallel/test-internal-util-normalizeencoding.js",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/177b7314cf62f6c268eef9f71657aba9c93385ed/test%2Fparallel%2Ftest-internal-util-normalizeencoding.js",
            "raw_url": "https://github.com/nodejs/node/raw/177b7314cf62f6c268eef9f71657aba9c93385ed/test%2Fparallel%2Ftest-internal-util-normalizeencoding.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-internal-util-normalizeencoding.js?ref=177b7314cf62f6c268eef9f71657aba9c93385ed",
            "patch": "@@ -6,6 +6,8 @@ const assert = require('assert');\n const util = require('internal/util');\n \n const tests = [\n+  [undefined, 'utf8'],\n+  [null, 'utf8'],\n   ['', 'utf8'],\n   ['utf8', 'utf8'],\n   ['utf-8', 'utf8'],\n@@ -23,17 +25,20 @@ const tests = [\n   ['binary', 'latin1'],\n   ['BINARY', 'latin1'],\n   ['latin1', 'latin1'],\n+  ['LaTiN1', 'latin1'],\n   ['base64', 'base64'],\n   ['BASE64', 'base64'],\n   ['hex', 'hex'],\n   ['HEX', 'hex'],\n   ['foo', undefined],\n   [1, undefined],\n-  [false, 'utf8'],\n-  [undefined, 'utf8'],\n+  [false, undefined],\n+  [NaN, undefined],\n+  [0, undefined],\n   [[], undefined],\n ];\n \n-tests.forEach((i) => {\n-  assert.strictEqual(util.normalizeEncoding(i[0]), i[1]);\n+tests.forEach((e, i) => {\n+  const res = util.normalizeEncoding(e[0]);\n+  assert.strictEqual(res, e[1], `#${i} failed: expected ${e[1]}, got ${res}`);\n });"
        }
    ],
    "stats": {
        "total": 221,
        "additions": 85,
        "deletions": 136
    }
}