{
    "author": "subhankarshah",
    "message": "For HloValues that are marked for block prefetching, if their uses are immediately proceeded by a slice, perform the prefetch with a sliced copy rather than a full copy. When adding such HloValues to MSA's finalized value's list, we also need to add the slice, so we don't revisit it later.\n\nPiperOrigin-RevId: 802808628",
    "sha": "a868bf69e5b41f9c1f045ab2644062d9857c2ece",
    "files": [
        {
            "sha": "12f8f629eeda2735cea6671177984c358a1fad1a",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.cc",
            "status": "modified",
            "additions": 125,
            "deletions": 60,
            "changes": 185,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc?ref=a868bf69e5b41f9c1f045ab2644062d9857c2ece",
            "patch": "@@ -2025,14 +2025,14 @@ int64_t MsaAlgorithm::MaxReservedScopedMemory() {\n   return max_reserved_scoped_memory;\n }\n \n-std::optional<int64_t> MsaAlgorithm::EarliestBlockAllocatedWeightStartTime(\n+std::optional<int64_t> MsaAlgorithm::EarliestBlockPrefetchStartTime(\n     int64_t earliest_start_time_candidate, int64_t first_use_time,\n     int64_t last_use_time, int64_t buffer_size,\n-    int64_t block_allocated_weights_bytes_limit,\n+    int64_t block_prefetching_limit_bytes,\n     std::vector<int64_t>& prefetch_end_times) {\n   auto can_find_chunk_within_limit =\n       [&](int64_t start_time, int64_t end_time, int64_t buffer_size,\n-          int64_t block_allocated_weights_bytes_limit) {\n+          int64_t block_prefetching_limit_bytes) {\n         MsaBufferInterval interval =\n             MsaBufferInterval{/*buffer=*/nullptr,\n                               /*size=*/buffer_size,\n@@ -2041,12 +2041,10 @@ std::optional<int64_t> MsaAlgorithm::EarliestBlockAllocatedWeightStartTime(\n                               /*colocations=*/{},\n                               /*need_allocation=*/true};\n         Chunk chunk_candidate = FindChunkCandidate(interval);\n-        return chunk_candidate.chunk_end() <=\n-               block_allocated_weights_bytes_limit;\n+        return chunk_candidate.chunk_end() <= block_prefetching_limit_bytes;\n       };\n   if (can_find_chunk_within_limit(earliest_start_time_candidate, last_use_time,\n-                                  buffer_size,\n-                                  block_allocated_weights_bytes_limit)) {\n+                                  buffer_size, block_prefetching_limit_bytes)) {\n     return earliest_start_time_candidate;\n   }\n   // Find the first start_time = end_time + 1, where end_time comes from the\n@@ -2059,39 +2057,58 @@ std::optional<int64_t> MsaAlgorithm::EarliestBlockAllocatedWeightStartTime(\n   for (auto it = it_begin; it != it_end; ++it) {\n     int64_t start_time = *it + 1;\n     if (can_find_chunk_within_limit(start_time, last_use_time, buffer_size,\n-                                    block_allocated_weights_bytes_limit)) {\n+                                    block_prefetching_limit_bytes)) {\n       return start_time;\n     }\n   }\n   return std::nullopt;\n }\n \n-void MsaAlgorithm::AllocateBlockAllocatedWeights() {\n-  if (options_.reserved_bytes_for_block_allocated_weights == 0) {\n+void MsaAlgorithm::ProcessBlockPrefetches() {\n+  if (options_.reserved_bytes_for_block_prefetches == 0) {\n     return;\n   }\n-  // Get all block allocated weight values in ascending order of first use time.\n-  std::vector<const HloValue*> block_allocated_weight_values;\n-  for (const HloPosition& position :\n-       options_.block_allocated_weights_positions) {\n+  // List of all block prefetched values. If a block prefetched value is sliced,\n+  // we also add the sliced value to block_prefetched_values. We will try\n+  // to perform an async slice to prefetch for the slice's uses.\n+  std::vector<const HloValue*> block_prefetched_values;\n+  absl::flat_hash_map<const HloValue*, const HloValue*>\n+      sliced_value_to_original_value;\n+  for (const HloPosition& position : options_.block_prefetched_positions) {\n     const HloValue* value =\n         &alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n             position.instruction, position.index);\n-    block_allocated_weight_values.push_back(value);\n+    block_prefetched_values.push_back(value);\n+    // As mentioned above, we also track slices of block prefetched values.\n+    for (const HloUse& use : value->GetUses()) {\n+      if (use.instruction->opcode() == HloOpcode::kSlice) {\n+        const HloValue* slice_value =\n+            &alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n+                use.instruction, {});\n+        block_prefetched_values.push_back(slice_value);\n+        sliced_value_to_original_value[slice_value] = value;\n+      }\n+    }\n   }\n \n   const auto& instruction_schedule = hlo_live_range_.instruction_schedule();\n   struct LiveRange {\n     int64_t first_use_time;\n     int64_t last_use_time;\n   };\n-  // Compute the live ranges for each block allocated weight value.\n+  // Compute the live ranges for each block prefetched value\n   absl::flat_hash_map<const HloValue*, LiveRange> value_to_live_ranges;\n-  for (const HloValue* value : block_allocated_weight_values) {\n+  for (const HloValue* value : block_prefetched_values) {\n     LiveRange& live_range = value_to_live_ranges[value];\n     live_range.first_use_time = std::numeric_limits<int64_t>::max();\n     live_range.last_use_time = -1;\n+    bool is_original_value = !sliced_value_to_original_value.contains(value);\n     for (const HloUse& use : value->GetUses()) {\n+      // We skip slices here because they have been explicitly added to\n+      // block_prefetched_values and will be handled in the outer for loop.\n+      if (is_original_value && use.instruction->opcode() == HloOpcode::kSlice) {\n+        continue;\n+      }\n       auto it = instruction_schedule.find(use.instruction);\n       if (it == instruction_schedule.end()) {\n         continue;\n@@ -2100,60 +2117,82 @@ void MsaAlgorithm::AllocateBlockAllocatedWeights() {\n           std::min(live_range.first_use_time, it->second);\n       live_range.last_use_time = std::max(live_range.last_use_time, it->second);\n     }\n+    if (live_range.last_use_time == -1) {\n+      // If the value does not have any direct uses other than slices, we can\n+      // finalize it. Note, slices are handled separately as part of\n+      // block_prefetched_values.\n+      finalized_values_.insert(value);\n+    }\n   }\n \n-  absl::c_sort(block_allocated_weight_values,\n+  // Erase all the values from block_prefetched_values that are not used\n+  // directly and have been finalized.\n+  block_prefetched_values.erase(\n+      std::remove_if(\n+          block_prefetched_values.begin(), block_prefetched_values.end(),\n+          [&](const HloValue* value) {\n+            return value_to_live_ranges.at(value).last_use_time == -1;\n+          }),\n+      block_prefetched_values.end());\n+\n+  // Sort block prefetched value values in ascending order of first use time.\n+  absl::c_sort(block_prefetched_values,\n                [&](const HloValue* a, const HloValue* b) {\n                  return value_to_live_ranges.at(a).first_use_time <\n                         value_to_live_ranges.at(b).first_use_time;\n                });\n \n   // Block allocations can also happen in the fragmented scoped memory, so we\n-  // need to account for the max reserved scoped memory in the block allocated\n-  // weights limit.\n+  // need to account for the max reserved scoped memory in the block prefetched\n+  // memory limit.\n   int64_t max_reserved_scoped_memory = MaxReservedScopedMemory();\n-  int64_t block_allocated_weights_bytes_limit =\n-      max_reserved_scoped_memory +\n-      options_.reserved_bytes_for_block_allocated_weights;\n-  CHECK_LE(block_allocated_weights_bytes_limit, options_.max_size_in_bytes);\n-  VLOG(1) << \"Block allocated weights bytes limit: \"\n-          << block_allocated_weights_bytes_limit;\n+  int64_t block_prefetching_limit_bytes =\n+      max_reserved_scoped_memory + options_.reserved_bytes_for_block_prefetches;\n+  CHECK_LE(block_prefetching_limit_bytes, options_.max_size_in_bytes);\n+  VLOG(1) << \"block prefetched values bytes limit: \"\n+          << block_prefetching_limit_bytes;\n \n   // To ensure fifo ordering, we need to ensure that the prefetch start time of\n-  // each block allocated weight is greater than or equal to the previous\n-  // previewed block allocated weight's prefetch start time. We are traversing\n-  // these is ascending order of use time, so the previous weight's prefetch\n-  // start time will always be less than or equal to the current weight's use\n-  // time.\n+  // each block prefetched value is greater than or equal to the previous block\n+  // prefetched value's prefetch start time. We are traversing these is\n+  // ascending order of use time, so the previous prefetchs start time will\n+  // always be less than or equal to the current prefetchs use time.\n   int64_t previous_start_time = -1;\n   int64_t max_in_flight_prefetches_allowed =\n-      options_.max_outstanding_prefetches_for_block_allocations;\n+      options_.max_outstanding_block_prefetches;\n   std::vector<int64_t> prefetch_end_times;\n \n-  for (const HloValue* value : block_allocated_weight_values) {\n-    LiveRange live_range = value_to_live_ranges.at(value);\n+  absl::flat_hash_map<const HloValue*, Allocation*> value_to_pinned_allocation;\n+\n+  for (const HloValue* maybe_sliced_value : block_prefetched_values) {\n+    LiveRange live_range = value_to_live_ranges.at(maybe_sliced_value);\n     int64_t first_use_time = live_range.first_use_time;\n     int64_t last_use_time = live_range.last_use_time;\n+    auto it = sliced_value_to_original_value.find(maybe_sliced_value);\n+    const HloValue* original_value;\n+    if (it != sliced_value_to_original_value.end()) {\n+      original_value = it->second;\n+    } else {\n+      original_value = maybe_sliced_value;\n+    }\n     int64_t definition_time =\n-        instruction_schedule.at(value->defining_instruction());\n+        instruction_schedule.at(original_value->defining_instruction());\n     int64_t end_time = last_use_time;\n-    int64_t buffer_size = buffer_intervals_.at(value).size;\n+    int64_t buffer_size = buffer_intervals_.at(maybe_sliced_value).size;\n     int64_t earliest_start_time_candidate =\n         std::max(definition_time, previous_start_time);\n     CHECK_LE(earliest_start_time_candidate, first_use_time);\n     // Find the earliest start time for which a chunk can be allocated for the\n-    // block allocated weight.\n-    std::optional<int64_t> optional_start_time =\n-        EarliestBlockAllocatedWeightStartTime(\n-            earliest_start_time_candidate, first_use_time, end_time,\n-            buffer_size, block_allocated_weights_bytes_limit,\n-            prefetch_end_times);\n+    // block prefetched value.\n+    std::optional<int64_t> optional_start_time = EarliestBlockPrefetchStartTime(\n+        earliest_start_time_candidate, first_use_time, end_time, buffer_size,\n+        block_prefetching_limit_bytes, prefetch_end_times);\n \n     if (!optional_start_time.has_value()) {\n-      LOG(WARNING) << \"Could not find a chunk for block allocated weight: \"\n-                   << value->defining_position().ToString()\n+      LOG(WARNING) << \"Could not find a chunk for block prefetched value: \"\n+                   << maybe_sliced_value->defining_position().ToString()\n                    << \" buffer size: \" << buffer_size\n-                   << \" within limit: \" << block_allocated_weights_bytes_limit;\n+                   << \" within limit: \" << block_prefetching_limit_bytes;\n       continue;\n     }\n     int64_t start_time = optional_start_time.value();\n@@ -2168,39 +2207,57 @@ void MsaAlgorithm::AllocateBlockAllocatedWeights() {\n \n     if (n_in_flight_prefetches > max_in_flight_prefetches_allowed) {\n       LOG(WARNING)\n-          << \"Block allocated weight exceeds max prefetches in flight: \"\n-          << value->defining_position().ToString() << \" \"\n+          << \"block prefetched value exceeds max prefetches in flight: \"\n+          << maybe_sliced_value->defining_position().ToString() << \" \"\n           << n_in_flight_prefetches << \" \" << max_in_flight_prefetches_allowed;\n       continue;\n     }\n \n-    MsaBufferInterval interval = MsaBufferInterval{/*buffer=*/value,\n+    MsaBufferInterval interval = MsaBufferInterval{/*buffer=*/original_value,\n                                                    /*size=*/buffer_size,\n                                                    /*start=*/start_time,\n                                                    /*end=*/end_time,\n                                                    /*colocations=*/{},\n                                                    /*need_allocation=*/true};\n     Chunk chunk_candidate = FindChunkCandidate(interval);\n-    // The chunk candidate should always be within the block allocated weights\n+    // The chunk candidate should always be within the block prefetched values\n     // limit, otherwise we would have returned earlier.\n-    CHECK_LE(chunk_candidate.chunk_end(), block_allocated_weights_bytes_limit);\n+    CHECK_LE(chunk_candidate.chunk_end(), block_prefetching_limit_bytes);\n+\n+    // Add a pinned allocation in the default memory to serve as the prev\n+    // allocation for the copy allocation or extend the existing pinned\n+    // allocation.\n+    auto pinned_allocation_it = value_to_pinned_allocation.find(original_value);\n+    Allocation* pinned_allocation;\n+    if (pinned_allocation_it == value_to_pinned_allocation.end()) {\n+      allocations_->push_back(std::make_unique<PinnedAllocation>(\n+          original_value->defining_position(), MemorySpace::kDefault,\n+          kDummyChunk, definition_time, end_time));\n+      value_to_pinned_allocation[original_value] = allocations_->back().get();\n+      pinned_allocation = allocations_->back().get();\n+    } else {\n+      pinned_allocation = pinned_allocation_it->second;\n+      pinned_allocation->Extend(end_time);\n+    }\n \n-    // Add a pinned allocation in the default memory as the prev allocation\n-    // for the copy allocation.\n-    allocations_->push_back(std::make_unique<PinnedAllocation>(\n-        value->defining_position(), MemorySpace::kDefault, kDummyChunk,\n-        definition_time, end_time));\n+    HloInstruction* sync_mem_op = nullptr;\n+    if (original_value != maybe_sliced_value) {\n+      sync_mem_op = maybe_sliced_value->defining_instruction();\n+    }\n \n+    // Add an async slice copy for the block prefetched value value.\n     AddAsyncCopyOrOtherMemOp(\n-        /*prev_allocation=*/*(allocations_->back().get()),\n+        /*prev_allocation=*/*pinned_allocation,\n         /*memory_space=*/MemorySpace::kAlternate,\n         /*chunk=*/chunk_candidate,\n         /*exclusive_start_time=*/InclusiveToExclusiveStartTime(start_time),\n         /*end_time=*/end_time,\n         /*copy_done_schedule_before_time=*/first_use_time,\n         /*allocations=*/allocations_,\n         /*aliased_offset=*/nullptr,\n-        /*resource=*/0.0);\n+        /*resource=*/0.0,\n+        /*cross_program_prefetch_index=*/std::nullopt,\n+        /*sync_mem_op=*/sync_mem_op);\n \n     previous_start_time = start_time;\n     auto const sorted_position = std::lower_bound(\n@@ -2216,14 +2273,22 @@ void MsaAlgorithm::AllocateBlockAllocatedWeights() {\n \n     // Commit the chunk to the alternate memory.\n     AddToPendingChunks(interval, chunk_candidate);\n-    for (const HloUse& use : value->GetUses()) {\n+\n+    for (const HloUse& use : maybe_sliced_value->GetUses()) {\n+      if (original_value == maybe_sliced_value &&\n+          use.instruction->opcode() == HloOpcode::kSlice) {\n+        // The use is a slice of the original value, so we don't need to add it\n+        // to the alternate memory map or to the uses of the copy allocation.\n+        continue;\n+      }\n       allocations_->back()->AddUse(use);\n       // Add entries to operands in alternate memory map.\n       operands_in_alternate_memory_map_[use.instruction].insert(\n           std::make_pair(use.operand_number, use.operand_index));\n     }\n+\n     // Add the value to the finalized values set.\n-    finalized_values_.insert(value);\n+    finalized_values_.insert(maybe_sliced_value);\n     // Add a repack allocation block to the repack allocation blocks list.\n     repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(\n         start_time, end_time, chunk_candidate.size, chunk_candidate.offset,\n@@ -2248,7 +2313,7 @@ absl::StatusOr<HeapSimulator::Result<HloValue>> MsaAlgorithm::Finish() {\n                                                                  : \"disabled\");\n \n   AllocateReservedScopedAllocations();\n-  AllocateBlockAllocatedWeights();\n+  ProcessBlockPrefetches();\n   std::vector<MsaBufferInterval> sorted_buffer_intervals =\n       GetSortedBufferIntervals();\n "
        },
        {
            "sha": "89cadcb1effa88457e83f34434f704b659ab6a38",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.h",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h?ref=a868bf69e5b41f9c1f045ab2644062d9857c2ece",
            "patch": "@@ -334,20 +334,21 @@ class MsaAlgorithm : public GlobalDecreasingSizeBestFitHeap<HloValue> {\n \n   absl::StatusOr<HeapSimulator::Result<HloValue>> Finish() override;\n \n-  // Finalizes allocations for block-allocated weights.\n-  void AllocateBlockAllocatedWeights();\n+  // Processes all block prefetches.\n+  void ProcessBlockPrefetches();\n \n   // Returns the maximum amount of scoped memory that is reserved at any time in\n   // the program.\n   int64_t MaxReservedScopedMemory();\n \n-  // Returns the earliest time that chunk can be reserved for a block-allocated\n-  // weight where the start time is between [definition_time, use_time] and\n-  // use_time and the end time is the use_time. The chunk.end() should be less\n-  // than the block_allocated_weights_bytes_limit.\n-  std::optional<int64_t> EarliestBlockAllocatedWeightStartTime(\n-      int64_t definition_time, int64_t first_use_time, int64_t last_use_time,\n-      int64_t buffer_size, int64_t block_allocated_weights_bytes_limit,\n+  // Returns the earliest time that chunk can be reserved for a block prefetch\n+  // where the start time is between [definition_time, use_time] and use_time\n+  // and the end time is the use_time. The chunk.end() should be within the\n+  // block_prefetching_limit_bytes.\n+  std::optional<int64_t> EarliestBlockPrefetchStartTime(\n+      int64_t earliest_start_time_candidate, int64_t first_use_time,\n+      int64_t last_use_time, int64_t buffer_size,\n+      int64_t block_prefetching_limit_bytes,\n       std::vector<int64_t>& prefetch_end_times);\n \n  protected:"
        },
        {
            "sha": "128c7b64842419f507ac3240f7a4020ad277f2b1",
            "filename": "third_party/xla/xla/service/memory_space_assignment/memory_space_assignment_test.cc",
            "status": "modified",
            "additions": 379,
            "deletions": 61,
            "changes": 440,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc?ref=a868bf69e5b41f9c1f045ab2644062d9857c2ece",
            "patch": "@@ -5540,11 +5540,11 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto msa_sort_order_overrides,\n                           ParseTextProto<MsaSortOrderOverrides>(text_proto));\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options,\n                                      std::nullopt, std::nullopt,\n                                      msa_sort_order_overrides);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n   EXPECT_EQ(\n       FindInstruction(module.get(), \"tanh0\")->shape().layout().memory_space(),\n       kAlternateMemorySpace);\n@@ -5589,11 +5589,11 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto msa_sort_order_overrides,\n                           ParseTextProto<MsaSortOrderOverrides>(text_proto));\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options,\n                                      std::nullopt, std::nullopt,\n                                      msa_sort_order_overrides);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n   EXPECT_EQ(FindInstruction(module.get(), \"negate4\")\n                 ->operand(1)\n                 ->shape()\n@@ -5645,11 +5645,11 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto msa_sort_order_overrides,\n                           ParseTextProto<MsaSortOrderOverrides>(text_proto));\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options,\n                                      std::nullopt, std::nullopt,\n                                      msa_sort_order_overrides);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n   EXPECT_EQ(\n       FindInstruction(module.get(), \"tanh0\")->shape().layout().memory_space(),\n       kDefaultMemorySpace);\n@@ -5704,11 +5704,11 @@ ROOT tuple = (f32[3,4]{1,0}, f32[3,4]{1,0}) tuple(tanh4, negate4)\n   TF_ASSERT_OK_AND_ASSIGN(auto msa_sort_order_overrides,\n                           ParseTextProto<MsaSortOrderOverrides>(text_proto));\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options,\n                                      std::nullopt, std::nullopt,\n                                      msa_sort_order_overrides);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n   EXPECT_EQ(\n       FindInstruction(module.get(), \"tanh0\")->shape().layout().memory_space(),\n       kAlternateMemorySpace);\n@@ -5769,11 +5769,11 @@ ROOT tuple = (f32[3,4]{1,0}, f32[3,4]{1,0}) tuple(tanh4, negate4)\n   TF_ASSERT_OK_AND_ASSIGN(auto msa_sort_order_overrides,\n                           ParseTextProto<MsaSortOrderOverrides>(text_proto));\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options,\n                                      std::nullopt, std::nullopt,\n                                      msa_sort_order_overrides);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n   EXPECT_EQ(\n       FindInstruction(module.get(), \"negate0\")->shape().layout().memory_space(),\n       kAlternateMemorySpace);\n@@ -5847,9 +5847,9 @@ ENTRY main {\n   HloPosition negate1_position{negate1, {}};\n   options.buffer_colorings = {{negate1_position, kAlternateMemorySpace}};\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), options);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n \n   EXPECT_EQ(\n       FindInstruction(module.get(), \"negate1\")->shape().layout().memory_space(),\n@@ -5948,9 +5948,9 @@ ENTRY main {\n   HloPosition negate1_position{negate1, {}};\n   options.buffer_colorings = {{negate1_position, kAlternateMemorySpace}};\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), options);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n \n   EXPECT_EQ(\n       FindInstruction(module.get(), \"negate1\")->shape().layout().memory_space(),\n@@ -14600,8 +14600,7 @@ TEST_F(MemorySpaceAssignmentTest,\n                                    ::testing::Not(\"bitcast.1\")))));\n }\n \n-TEST_F(MemorySpaceAssignmentTest,\n-       TestBlockAllocatedWeightsNotEnoughReservedBytes) {\n+TEST_F(MemorySpaceAssignmentTest, TestBlockPrefetchingNotEnoughReservedBytes) {\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -14633,7 +14632,8 @@ ENTRY entry {\n                           ParseAndReturnVerifiedModule(hlo_string));\n   Options memory_space_options = DefaultMemorySpaceOptions();\n   memory_space_options.max_size_in_bytes = 24;\n-  memory_space_options.reserved_bytes_for_block_allocated_weights = 23;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 23;\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n \n   HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n   HloPosition p0_position{p0, {}};\n@@ -14647,13 +14647,13 @@ ENTRY entry {\n   HloPosition p4_position{p4, {}};\n   HloInstruction* p5 = FindInstruction(module.get(), \"p5\");\n   HloPosition p5_position{p5, {}};\n-  memory_space_options.block_allocated_weights_positions = {\n-      p0_position, p1_position, p2_position,\n-      p3_position, p4_position, p5_position};\n+  memory_space_options.block_prefetched_positions = {p0_position, p1_position,\n+                                                     p2_position, p3_position,\n+                                                     p4_position, p5_position};\n \n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n \n   HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n   EXPECT_EQ(negate0->operand(0)->shape().layout().memory_space(),\n@@ -14675,7 +14675,7 @@ ENTRY entry {\n             kDefaultMemorySpace);\n }\n \n-TEST_F(MemorySpaceAssignmentTest, TestSingleBufferedBlockAllocatedWeights) {\n+TEST_F(MemorySpaceAssignmentTest, TestSingleBufferedBlockPrefetching) {\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -14707,7 +14707,7 @@ ENTRY entry {\n                           ParseAndReturnVerifiedModule(hlo_string));\n   Options memory_space_options = DefaultMemorySpaceOptions();\n   memory_space_options.max_size_in_bytes = 24;\n-  memory_space_options.reserved_bytes_for_block_allocated_weights = 24;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 24;\n \n   HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n   HloPosition p0_position{p0, {}};\n@@ -14721,13 +14721,13 @@ ENTRY entry {\n   HloPosition p4_position{p4, {}};\n   HloInstruction* p5 = FindInstruction(module.get(), \"p5\");\n   HloPosition p5_position{p5, {}};\n-  memory_space_options.block_allocated_weights_positions = {\n-      p5_position, p4_position, p3_position,\n-      p2_position, p1_position, p0_position};\n-  memory_space_options.max_outstanding_prefetches_for_block_allocations = 10;\n-  XLA_LOG_LINES(INFO, \"Before MSA: \\n\" + module->ToString());\n+  memory_space_options.block_prefetched_positions = {p5_position, p4_position,\n+                                                     p3_position, p2_position,\n+                                                     p1_position, p0_position};\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n-  XLA_LOG_LINES(INFO, \"After MSA: \\n\" + module->ToString());\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n \n   HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n   EXPECT_EQ(negate0->operand(0)->shape().layout().memory_space(),\n@@ -14749,7 +14749,7 @@ ENTRY entry {\n             kAlternateMemorySpace);\n }\n \n-TEST_F(MemorySpaceAssignmentTest, TestBlockAllocatedWeightsDoubleBuffered) {\n+TEST_F(MemorySpaceAssignmentTest, TestBlockPrefetchingDoubleBuffered) {\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -14781,7 +14781,7 @@ ENTRY entry {\n                           ParseAndReturnVerifiedModule(hlo_string));\n   Options memory_space_options = DefaultMemorySpaceOptions();\n   memory_space_options.max_size_in_bytes = 48;\n-  memory_space_options.reserved_bytes_for_block_allocated_weights = 48;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 48;\n   HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n   HloPosition p0_position{p0, {}};\n   HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n@@ -14794,10 +14794,10 @@ ENTRY entry {\n   HloPosition p4_position{p4, {}};\n   HloInstruction* p5 = FindInstruction(module.get(), \"p5\");\n   HloPosition p5_position{p5, {}};\n-  memory_space_options.block_allocated_weights_positions = {\n-      p5_position, p4_position, p3_position,\n-      p2_position, p1_position, p0_position};\n-  memory_space_options.max_outstanding_prefetches_for_block_allocations = 10;\n+  memory_space_options.block_prefetched_positions = {p5_position, p4_position,\n+                                                     p3_position, p2_position,\n+                                                     p1_position, p0_position};\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n   XLA_VLOG_LINES(3, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n   XLA_VLOG_LINES(3, \"After MSA: \\n\" + module->ToString());\n@@ -14821,12 +14821,12 @@ ENTRY entry {\n             kAlternateMemorySpace);\n }\n \n-TEST_F(MemorySpaceAssignmentTest, TestBlockAllocationsWithMultipleUses) {\n-  // When allowing multiple uses of block allocated weights, we only prefetch\n-  // the weight once, making sure that the prefetches are scheduled before the\n-  // first use time. This was a bug in the original implementation of block\n-  // allocations. This test case tests the fix. In this test the parameters p0\n-  // and p1 have multiple uses, we test that we prefetch them exactly once.\n+TEST_F(MemorySpaceAssignmentTest, TestBlockPrefetchesWithMultipleUses) {\n+  // When allowing multiple uses of block prefetches, we only prefetch once,\n+  // making sure that the prefetches are scheduled before the first use time.\n+  // This was a bug in the original implementation of block prefetching. This\n+  // test case tests the fix. In this test the parameters p0 and p1 have\n+  // multiple uses, we test that we prefetch them exactly once.\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -14858,7 +14858,7 @@ ENTRY entry {\n                           ParseAndReturnVerifiedModule(hlo_string));\n   Options memory_space_options = DefaultMemorySpaceOptions();\n   memory_space_options.max_size_in_bytes = 72;\n-  memory_space_options.reserved_bytes_for_block_allocated_weights = 72;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 72;\n   HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n   HloPosition p0_position{p0, {}};\n   HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n@@ -14871,10 +14871,10 @@ ENTRY entry {\n   HloPosition p4_position{p4, {}};\n   HloInstruction* p5 = FindInstruction(module.get(), \"p5\");\n   HloPosition p5_position{p5, {}};\n-  memory_space_options.block_allocated_weights_positions = {\n-      p5_position, p4_position, p3_position,\n-      p2_position, p1_position, p0_position};\n-  memory_space_options.max_outstanding_prefetches_for_block_allocations = 10;\n+  memory_space_options.block_prefetched_positions = {p5_position, p4_position,\n+                                                     p3_position, p2_position,\n+                                                     p1_position, p0_position};\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n   XLA_VLOG_LINES(3, \"Before MSA: \\n\" + module->ToString());\n   AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n   XLA_VLOG_LINES(3, \"After MSA: \\n\" + module->ToString());\n@@ -14919,7 +14919,7 @@ ENTRY entry {\n }\n \n TEST_F(MemorySpaceAssignmentTest,\n-       TestBlockAllocatedWeightsDoubleBufferedWithColoring) {\n+       TestBlockPrefetchingDoubleBufferedWithColoring) {\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -14951,7 +14951,7 @@ ENTRY entry {\n                           ParseAndReturnVerifiedModule(hlo_string));\n   Options memory_space_options = DefaultMemorySpaceOptions();\n   memory_space_options.max_size_in_bytes = 48;\n-  memory_space_options.reserved_bytes_for_block_allocated_weights = 48;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 48;\n   HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n   HloPosition p0_position{p0, {}};\n   HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n@@ -14964,10 +14964,10 @@ ENTRY entry {\n   HloPosition p4_position{p4, {}};\n   HloInstruction* p5 = FindInstruction(module.get(), \"p5\");\n   HloPosition p5_position{p5, {}};\n-  memory_space_options.block_allocated_weights_positions = {\n-      p5_position, p4_position, p3_position,\n-      p2_position, p1_position, p0_position};\n-  memory_space_options.max_outstanding_prefetches_for_block_allocations = 10;\n+  memory_space_options.block_prefetched_positions = {p5_position, p4_position,\n+                                                     p3_position, p2_position,\n+                                                     p1_position, p0_position};\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n   HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n   HloUse add15_negate14_use{add15, 1, {}};\n   memory_space_options.buffer_colorings = {\n@@ -14999,7 +14999,7 @@ ENTRY entry {\n }\n \n TEST_F(MemorySpaceAssignmentTest,\n-       TestBlockAllocatedWeightsDoubleBufferedWithColoringWithAliasAnalysis) {\n+       TestBlockPrefetchingDoubleBufferedWithColoringWithAliasAnalysis) {\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -15031,8 +15031,8 @@ ENTRY entry {\n                           ParseAndReturnVerifiedModule(hlo_string));\n   Options memory_space_options = DefaultMemorySpaceOptions();\n   memory_space_options.max_size_in_bytes = 48;\n-  memory_space_options.reserved_bytes_for_block_allocated_weights = 48;\n-  absl::flat_hash_set<HloPosition> block_allocated_weights_positions;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 48;\n+  absl::flat_hash_set<HloPosition> block_prefetched_positions;\n   TF_ASSERT_OK_AND_ASSIGN(auto alias_analysis,\n                           HloAliasAnalysis::Run(module.get(), &alias_info_));\n   const HloModule& hlo_module = alias_analysis->dataflow_analysis().module();\n@@ -15055,14 +15055,12 @@ ENTRY entry {\n                       << buffer->ToString();\n               continue;\n             }\n-            block_allocated_weights_positions.insert(\n-                value->defining_position());\n+            block_prefetched_positions.insert(value->defining_position());\n           }\n         });\n   }\n-  memory_space_options.block_allocated_weights_positions =\n-      block_allocated_weights_positions;\n-  memory_space_options.max_outstanding_prefetches_for_block_allocations = 10;\n+  memory_space_options.block_prefetched_positions = block_prefetched_positions;\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n   HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n   HloUse add15_negate14_use{add15, 1, {}};\n   memory_space_options.buffer_colorings = {\n@@ -15093,6 +15091,326 @@ ENTRY entry {\n             kAlternateMemorySpace);\n }\n \n+TEST_F(SlicedPrefetchTest, TestBlockPrefetchingAsyncSlicePrefetches) {\n+  // Test block prefetches convert slices to async sliced prefetches. Each\n+  // program input has two slices.\n+  absl::string_view hlo_string = R\"(\n+HloModule module, is_scheduled=true\n+\n+ENTRY entry {\n+  p0 = f32[4,3]{1,0} parameter(0)\n+  p1 = f32[4,3]{1,0} parameter(1)\n+  p2 = f32[4,3]{1,0} parameter(2)\n+  slice0 = f32[2,3]{1,0} slice(p0), slice={[0:2], [0:3]}\n+  slice1 = f32[2,3]{1,0} slice(p1), slice={[0:2], [0:3]}\n+  slice2 = f32[2,3]{1,0} slice(p2), slice={[0:2], [0:3]}\n+  slice3 = f32[2,3]{1,0} slice(p0), slice={[2:4], [0:3]}\n+  slice4 = f32[2,3]{1,0} slice(p1), slice={[2:4], [0:3]}\n+  slice5 = f32[2,3]{1,0} slice(p2), slice={[2:4], [0:3]}\n+  negate0 = f32[2,3]{1,0} negate(slice0)\n+  negate1 = f32[2,3]{1,0} negate(negate0)\n+  negate2 = f32[2,3]{1,0} negate(negate1)\n+  add3 = f32[2,3]{1,0} add(slice1, negate2)\n+  negate4 = f32[2,3]{1,0} negate(add3)\n+  negate5 = f32[2,3]{1,0} negate(negate4)\n+  add6 = f32[2,3]{1,0} add(slice2, negate5)\n+  negate7 = f32[2,3]{1,0} negate(add6)\n+  negate8 = f32[2,3]{1,0} negate(negate7)\n+  add9 = f32[2,3]{1,0} add(slice3, negate8)\n+  negate10 = f32[2,3]{1,0} negate(add9)\n+  negate11 = f32[2,3]{1,0} negate(negate10)\n+  add12 = f32[2,3]{1,0} add(slice4, negate11)\n+  negate13 = f32[2,3]{1,0} negate(add12)\n+  negate14 = f32[2,3]{1,0} negate(negate13)\n+  ROOT add15 = f32[2,3]{1,0} add(slice5, negate14)\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  Options memory_space_options = DefaultMemorySpaceOptions();\n+  memory_space_options.max_size_in_bytes = 48;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 24;\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n+\n+  HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n+  HloPosition p0_position{p0, {}};\n+  HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n+  HloPosition p1_position{p1, {}};\n+  HloInstruction* p2 = FindInstruction(module.get(), \"p2\");\n+  HloPosition p2_position{p2, {}};\n+  memory_space_options.block_prefetched_positions = {p0_position, p1_position,\n+                                                     p2_position};\n+\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n+  AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n+\n+  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n+  const HloInstruction* negate0_operand0 = negate0->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(negate0_operand0));\n+  EXPECT_EQ(negate0_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add3 = FindInstruction(module.get(), \"add3\");\n+  const HloInstruction* add3_operand0 = add3->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add3_operand0));\n+  EXPECT_EQ(add3_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add6 = FindInstruction(module.get(), \"add6\");\n+  const HloInstruction* add6_operand0 = add6->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add6_operand0));\n+  EXPECT_EQ(add6_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add9 = FindInstruction(module.get(), \"add9\");\n+  const HloInstruction* add9_operand0 = add9->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add9_operand0));\n+  EXPECT_EQ(add9_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add12 = FindInstruction(module.get(), \"add12\");\n+  const HloInstruction* add12_operand0 = add12->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add12_operand0));\n+  EXPECT_EQ(add12_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n+  const HloInstruction* add15_operand0 = add15->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add15_operand0));\n+  EXPECT_EQ(add15_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+\n+  // Check there are no additional prefetches apart from block prefetches.\n+  const std::vector<HloInstruction*>& instructions =\n+      module->schedule().sequence(module->entry_computation()).instructions();\n+  int64_t num_prefetches =\n+      absl::c_count_if(instructions, [&](const HloInstruction* instruction) {\n+        return instruction->shape().has_layout() &&\n+               instruction->shape().layout().memory_space() ==\n+                   kAlternateMemorySpace &&\n+               (IsAsyncSliceDone(instruction) ||\n+                instruction->opcode() == HloOpcode::kCopyDone);\n+      });\n+  EXPECT_EQ(num_prefetches, 6);\n+}\n+\n+TEST_F(SlicedPrefetchTest, TestBlockPrefetchingAsyncSliceWithMultipleUses) {\n+  // Same as above, but slice 1 has multiple uses and p0 has multiple uses apart\n+  // from the slice.\n+  absl::string_view hlo_string = R\"(\n+HloModule module, is_scheduled=true\n+\n+ENTRY entry {\n+  p0 = f32[4,3]{1,0} parameter(0)\n+  p1 = f32[4,3]{1,0} parameter(1)\n+  p2 = f32[4,3]{1,0} parameter(2)\n+  slice0 = f32[2,3]{1,0} slice(p0), slice={[0:2], [0:3]}\n+  slice1 = f32[2,3]{1,0} slice(p1), slice={[0:2], [0:3]}\n+  slice2 = f32[2,3]{1,0} slice(p2), slice={[0:2], [0:3]}\n+  slice3 = f32[2,3]{1,0} slice(p0), slice={[2:4], [0:3]}\n+  slice4 = f32[2,3]{1,0} slice(p1), slice={[2:4], [0:3]}\n+  slice5 = f32[2,3]{1,0} slice(p2), slice={[2:4], [0:3]}\n+  negate0 = f32[2,3]{1,0} negate(slice0)\n+  negate1 = f32[2,3]{1,0} negate(negate0)\n+  negate2 = f32[2,3]{1,0} negate(negate1)\n+  add3 = f32[2,3]{1,0} add(slice1, negate2)\n+  negate4 = f32[2,3]{1,0} negate(add3)\n+  negate5 = f32[2,3]{1,0} negate(negate4)\n+  add6 = f32[2,3]{1,0} add(slice2, negate5)\n+  negate7 = f32[2,3]{1,0} negate(add6)\n+  negate8 = f32[2,3]{1,0} negate(negate7)\n+  add9 = f32[2,3]{1,0} add(slice3, negate8)\n+  negate10 = f32[2,3]{1,0} negate(add9)\n+  add11 = f32[2,3]{1,0} add(slice1, negate10)\n+  add12 = f32[2,3]{1,0} add(slice4, add11)\n+  negate13 = f32[2,3]{1,0} negate(add12)\n+  negate14 = f32[2,3]{1,0} negate(negate13)\n+  add15 = f32[2,3]{1,0} add(slice5, negate14)\n+  negate16 = f32[4,3]{1,0} negate(p0)\n+  add17 = f32[4,3]{1,0} add(p0, negate16)\n+  ROOT tuple = (f32[4,3]{1,0}, f32[2,3]{1,0}) tuple(add17, add15)\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  Options memory_space_options = DefaultMemorySpaceOptions();\n+  memory_space_options.max_size_in_bytes = 96;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 96;\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n+\n+  HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n+  HloPosition p0_position{p0, {}};\n+  HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n+  HloPosition p1_position{p1, {}};\n+  HloInstruction* p2 = FindInstruction(module.get(), \"p2\");\n+  HloPosition p2_position{p2, {}};\n+  memory_space_options.block_prefetched_positions = {p0_position, p1_position,\n+                                                     p2_position};\n+\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n+  AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n+\n+  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n+  const HloInstruction* negate0_operand0 = negate0->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(negate0_operand0));\n+  EXPECT_EQ(negate0_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add3 = FindInstruction(module.get(), \"add3\");\n+  const HloInstruction* add3_operand0 = add3->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add3_operand0));\n+  EXPECT_EQ(add3_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add6 = FindInstruction(module.get(), \"add6\");\n+  const HloInstruction* add6_operand0 = add6->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add6_operand0));\n+  EXPECT_EQ(add6_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add9 = FindInstruction(module.get(), \"add9\");\n+  const HloInstruction* add9_operand0 = add9->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add9_operand0));\n+  EXPECT_EQ(add9_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add11 = FindInstruction(module.get(), \"add11\");\n+  const HloInstruction* add11_operand0 = add11->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add11_operand0));\n+  EXPECT_EQ(add11_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add12 = FindInstruction(module.get(), \"add12\");\n+  const HloInstruction* add12_operand0 = add12->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add12_operand0));\n+  EXPECT_EQ(add12_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n+  const HloInstruction* add15_operand0 = add15->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add15_operand0));\n+  EXPECT_EQ(add15_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* negate16 = FindInstruction(module.get(), \"negate16\");\n+  const HloInstruction* negate16_operand0 = negate16->operand(0);\n+  EXPECT_TRUE(negate16_operand0->opcode() == HloOpcode::kCopyDone);\n+  EXPECT_EQ(negate16_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add17 = FindInstruction(module.get(), \"add17\");\n+  const HloInstruction* add17_operand0 = add17->operand(0);\n+  EXPECT_TRUE(add17_operand0->opcode() == HloOpcode::kCopyDone);\n+  EXPECT_EQ(add17_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+\n+  // Check slice1 is only prefetched once.\n+  EXPECT_EQ(add3_operand0, add11_operand0);\n+\n+  // Check p0 is only prefetched once.\n+  EXPECT_EQ(negate16_operand0, add17_operand0);\n+\n+  // Check there are no additional prefetches apart from block prefetches.\n+  const std::vector<HloInstruction*>& instructions =\n+      module->schedule().sequence(module->entry_computation()).instructions();\n+  int64_t num_prefetches =\n+      absl::c_count_if(instructions, [&](const HloInstruction* instruction) {\n+        return instruction->shape().has_layout() &&\n+               instruction->shape().layout().memory_space() ==\n+                   kAlternateMemorySpace &&\n+               (IsAsyncSliceDone(instruction) ||\n+                instruction->opcode() == HloOpcode::kCopyDone);\n+      });\n+  EXPECT_EQ(num_prefetches, 7);\n+}\n+\n+TEST_F(SlicedPrefetchTest,\n+       TestBlockPrefetchingDoubleBufferedAsyncSlicePrefetches) {\n+  // The block prefetching memory is twice the size of the slices. This will\n+  // result in double buffering of the slices i.e. having 2 live async slice\n+  // copies at a given time.\n+  absl::string_view hlo_string = R\"(\n+HloModule module, is_scheduled=true\n+\n+ENTRY entry {\n+  p0 = f32[4,3]{1,0} parameter(0)\n+  p1 = f32[4,3]{1,0} parameter(1)\n+  p2 = f32[4,3]{1,0} parameter(2)\n+  slice0 = f32[2,3]{1,0} slice(p0), slice={[0:2], [0:3]}\n+  slice1 = f32[2,3]{1,0} slice(p1), slice={[0:2], [0:3]}\n+  slice2 = f32[2,3]{1,0} slice(p2), slice={[0:2], [0:3]}\n+  slice3 = f32[2,3]{1,0} slice(p0), slice={[2:4], [0:3]}\n+  slice4 = f32[2,3]{1,0} slice(p1), slice={[2:4], [0:3]}\n+  slice5 = f32[2,3]{1,0} slice(p2), slice={[2:4], [0:3]}\n+  negate0 = f32[2,3]{1,0} negate(slice0)\n+  negate1 = f32[2,3]{1,0} negate(negate0)\n+  negate2 = f32[2,3]{1,0} negate(negate1)\n+  add3 = f32[2,3]{1,0} add(slice1, negate2)\n+  negate4 = f32[2,3]{1,0} negate(add3)\n+  negate5 = f32[2,3]{1,0} negate(negate4)\n+  add6 = f32[2,3]{1,0} add(slice2, negate5)\n+  negate7 = f32[2,3]{1,0} negate(add6)\n+  negate8 = f32[2,3]{1,0} negate(negate7)\n+  add9 = f32[2,3]{1,0} add(slice3, negate8)\n+  negate10 = f32[2,3]{1,0} negate(add9)\n+  negate11 = f32[2,3]{1,0} negate(negate10)\n+  add12 = f32[2,3]{1,0} add(slice4, negate11)\n+  negate13 = f32[2,3]{1,0} negate(add12)\n+  negate14 = f32[2,3]{1,0} negate(negate13)\n+  ROOT add15 = f32[2,3]{1,0} add(slice5, negate14)\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  Options memory_space_options = DefaultMemorySpaceOptions();\n+  memory_space_options.max_size_in_bytes = 48;\n+  memory_space_options.reserved_bytes_for_block_prefetches = 48;\n+  memory_space_options.max_outstanding_block_prefetches = 10;\n+\n+  HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n+  HloPosition p0_position{p0, {}};\n+  HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n+  HloPosition p1_position{p1, {}};\n+  HloInstruction* p2 = FindInstruction(module.get(), \"p2\");\n+  HloPosition p2_position{p2, {}};\n+  memory_space_options.block_prefetched_positions = {p0_position, p1_position,\n+                                                     p2_position};\n+\n+  XLA_VLOG_LINES(1, \"Before MSA: \\n\" + module->ToString());\n+  AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n+  XLA_VLOG_LINES(1, \"After MSA: \\n\" + module->ToString());\n+\n+  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n+  const HloInstruction* negate0_operand0 = negate0->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(negate0_operand0));\n+  EXPECT_EQ(negate0_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add3 = FindInstruction(module.get(), \"add3\");\n+  const HloInstruction* add3_operand0 = add3->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add3_operand0));\n+  EXPECT_EQ(add3_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add6 = FindInstruction(module.get(), \"add6\");\n+  const HloInstruction* add6_operand0 = add6->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add6_operand0));\n+  EXPECT_EQ(add6_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add9 = FindInstruction(module.get(), \"add9\");\n+  const HloInstruction* add9_operand0 = add9->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add9_operand0));\n+  EXPECT_EQ(add9_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add12 = FindInstruction(module.get(), \"add12\");\n+  const HloInstruction* add12_operand0 = add12->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add12_operand0));\n+  EXPECT_EQ(add12_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n+  const HloInstruction* add15_operand0 = add15->operand(0);\n+  EXPECT_TRUE(IsAsyncSliceDone(add15_operand0));\n+  EXPECT_EQ(add15_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+\n+  // Check there are no additional prefetches apart from block prefetches.\n+  const std::vector<HloInstruction*>& instructions =\n+      module->schedule().sequence(module->entry_computation()).instructions();\n+  int64_t num_prefetches =\n+      absl::c_count_if(instructions, [&](const HloInstruction* instruction) {\n+        return instruction->shape().has_layout() &&\n+               instruction->shape().layout().memory_space() ==\n+                   kAlternateMemorySpace &&\n+               (IsAsyncSliceDone(instruction) ||\n+                instruction->opcode() == HloOpcode::kCopyDone);\n+      });\n+  EXPECT_EQ(num_prefetches, 6);\n+}\n+\n TEST_F(MemorySpaceAssignmentTest, NoPrefetchWithBandwidthLimitingAsyncStart) {\n   // The negate chain is long enough for asynchronous copy to be inserted\n   // between p1 and add. The prefetch will not happen because the bandwidth"
        },
        {
            "sha": "06be8964ea5bcb2d8afb34287bf965b246af7021",
            "filename": "third_party/xla/xla/service/memory_space_assignment/options.h",
            "status": "modified",
            "additions": 6,
            "deletions": 9,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Foptions.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a868bf69e5b41f9c1f045ab2644062d9857c2ece/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Foptions.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Foptions.h?ref=a868bf69e5b41f9c1f045ab2644062d9857c2ece",
            "patch": "@@ -27,8 +27,6 @@ limitations under the License.\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n@@ -412,16 +410,15 @@ struct Options {\n   // alternate memory first, and then run the rest of the algorithm.\n   bool explicit_pinning_mode = false;\n \n-  // If set, this is the maximum number of concurrent prefetches allowed for\n-  // block allocations.\n-  int64_t max_outstanding_prefetches_for_block_allocations = 0;\n+  // If set, this is the maximum number of concurrent block prefetches allowed.\n+  int64_t max_outstanding_block_prefetches = 0;\n \n   // If set, this is the size of scoped alternate memory that we require MSA to\n-  // allocate for block allocated weights.\n-  uint64_t reserved_bytes_for_block_allocated_weights = 0;\n+  // allocate for block prefetches.\n+  uint64_t reserved_bytes_for_block_prefetches = 0;\n \n-  // The list of defining positions of block allocated weights.\n-  absl::flat_hash_set<HloPosition> block_allocated_weights_positions;\n+  // List of hlo positions for block prefetches.\n+  absl::flat_hash_set<HloPosition> block_prefetched_positions;\n \n   // Determines the bandwidth adjustment factor for an async start instruction.\n   // The available bandwidth for instructions between this and the async done"
        }
    ],
    "stats": {
        "total": 659,
        "additions": 520,
        "deletions": 139
    }
}