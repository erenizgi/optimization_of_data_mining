{
    "author": "beckerhe",
    "message": "Add serialization for ffi::Attribute\n\n`ffi::Attribute` and related types are members of the `CustomCallThunk`. Therefore we need to be able to serialize these types to proto message if we wanna be able to serialize instances of CustomCallThunk.\n\nSo this change is adding proto message representation of the types and adds functions `ToProto` and `FromProto` to each of them. Most of the types are currently defined as type aliases of some `std::variant` instantiation. This changes replaces the aliases by classes which inherit from the std::variant type. These new types then get the proto serialization functions.\n\nPiperOrigin-RevId: 826035931",
    "sha": "772ed8bbc785ce04d1c8ad02156d4f9a63788708",
    "files": [
        {
            "sha": "b23ec419759a40bf5d620e8b070bb8a53f432186",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=772ed8bbc785ce04d1c8ad02156d4f9a63788708",
            "patch": "@@ -1,4 +1,5 @@\n load(\"//xla:xla.default.bzl\", \"xla_cc_test\")\n+load(\"//xla/tsl/platform:build_config.bzl\", \"tf_proto_library\")\n load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_library\")\n \n package(\n@@ -198,8 +199,10 @@ cc_library(\n     srcs = [\"attribute_map.cc\"],\n     hdrs = [\"attribute_map.h\"],\n     deps = [\n+        \":attribute_map_proto_cc\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n@@ -211,6 +214,24 @@ cc_library(\n     ],\n )\n \n+xla_cc_test(\n+    name = \"attribute_map_test\",\n+    srcs = [\"attribute_map_test.cc\"],\n+    deps = [\n+        \":attribute_map\",\n+        \"//xla/tsl/util/proto:parse_text_proto\",\n+        \"//xla/tsl/util/proto:proto_matchers\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n+tf_proto_library(\n+    name = \"attribute_map_proto\",\n+    srcs = [\"attribute_map.proto\"],\n+)\n+\n xla_cc_test(\n     name = \"ffi_test\",\n     srcs = [\"ffi_test.cc\"],"
        },
        {
            "sha": "3085ee3a6235b78aba174d9701dd8c14fc9e91ed",
            "filename": "third_party/xla/xla/ffi/attribute_map.cc",
            "status": "modified",
            "additions": 333,
            "deletions": 0,
            "changes": 333,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.cc?ref=772ed8bbc785ce04d1c8ad02156d4f9a63788708",
            "patch": "@@ -16,10 +16,15 @@ limitations under the License.\n #include \"xla/ffi/attribute_map.h\"\n \n #include <cstdint>\n+#include <limits>\n #include <memory>\n+#include <string>\n+#include <type_traits>\n #include <utility>\n+#include <variant>\n #include <vector>\n \n+#include \"absl/algorithm/container.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n@@ -32,6 +37,27 @@ limitations under the License.\n #include \"xla/tsl/platform/statusor.h\"\n \n namespace xla::ffi {\n+template <typename OutputVariant, typename... InputTypes>\n+static OutputVariant Convert(std::variant<InputTypes...> input) {\n+  return std::visit(\n+      [](auto&& value) -> OutputVariant {\n+        return std::forward<decltype(value)>(value);\n+      },\n+      std::move(input));\n+}\n+\n+// Checks if the given value is in the range of the given integer type.\n+// Note that only works for integer types where all values can be represented as\n+// int32_t.\n+template <typename T>\n+static bool IsInRange(int32_t value) {\n+  static_assert(\n+      std::numeric_limits<T>::is_integer && (sizeof(T) < sizeof(int32_t)),\n+      \"All values of T must be representable as int32_t.\");\n+  return value >= std::numeric_limits<T>::min() &&\n+         value <= std::numeric_limits<T>::max();\n+}\n+\n static absl::StatusOr<Attribute> ConvertBoolAttr(absl::string_view name,\n                                                  mlir::BoolAttr boolean) {\n   return static_cast<bool>(boolean.getValue());\n@@ -198,4 +224,311 @@ absl::StatusOr<AttributesMap> BuildAttributesMap(mlir::DictionaryAttr dict) {\n   return attributes;\n }\n \n+AttributesMapProto AttributesDictionary::ToProto() const {\n+  if (attrs != nullptr) {\n+    return attrs->ToProto();\n+  }\n+  return AttributesMapProto();\n+}\n+\n+absl::StatusOr<AttributesDictionary> AttributesDictionary::FromProto(\n+    const AttributesMapProto& proto) {\n+  TF_ASSIGN_OR_RETURN(auto attrs, AttributesMap::FromProto(proto));\n+  return AttributesDictionary{std::make_shared<AttributesMap>(attrs)};\n+}\n+\n+AttributesMapProto AttributesMap::ToProto() const {\n+  AttributesMapProto proto;\n+  for (const auto& [key, value] : *this) {\n+    (*proto.mutable_attrs())[key] = value.ToProto();\n+  }\n+  return proto;\n+}\n+\n+absl::StatusOr<AttributesMap> AttributesMap::FromProto(\n+    const AttributesMapProto& proto) {\n+  AttributesMap result;\n+  for (const auto& [key, value] : proto.attrs()) {\n+    TF_ASSIGN_OR_RETURN(result[key], Attribute::FromProto(value));\n+  }\n+  return result;\n+}\n+\n+absl::StatusOr<Attribute> Attribute::FromProto(const AttributeProto& proto) {\n+  Attribute attribute;\n+  switch (proto.value_case()) {\n+    case AttributeProto::kScalar:\n+      return Scalar::FromProto(proto.scalar());\n+    case AttributeProto::kArray:\n+      return Array::FromProto(proto.array());\n+    case AttributeProto::kStr:\n+      return Attribute(proto.str());\n+    case AttributeProto::kDict:\n+      return AttributesDictionary::FromProto(proto.dict());\n+    default:\n+      return absl::InvalidArgumentError(\"Unsupported attribute type\");\n+  }\n+}\n+\n+xla::ffi::AttributeProto Attribute::ToProto() const {\n+  AttributeProto proto;\n+  std::visit(\n+      [&](auto&& value) {\n+        using U = std::decay_t<decltype(value)>;\n+        if constexpr (std::is_same_v<U, Scalar>) {\n+          *proto.mutable_scalar() = value.ToProto();\n+        } else if constexpr (std::is_same_v<U, Array>) {\n+          *proto.mutable_array() = value.ToProto();\n+        } else if constexpr (std::is_same_v<U, std::string>) {\n+          proto.set_str(value);\n+        } else if constexpr (std::is_same_v<U, AttributesDictionary>) {\n+          *proto.mutable_dict() = value.ToProto();\n+        } else {\n+          static_assert(false, \"Unsupported attribute type\");\n+        }\n+      },\n+      AsVariant());\n+  return proto;\n+}\n+\n+ScalarProto Scalar::ToProto() const {\n+  ScalarProto proto;\n+  std::visit(\n+      [&](auto&& value) {\n+        using U = std::decay_t<decltype(value)>;\n+        if constexpr (std::is_same_v<U, bool>) {\n+          proto.set_b(value);\n+        } else if constexpr (std::is_same_v<U, int8_t>) {\n+          proto.set_i8(value);\n+        } else if constexpr (std::is_same_v<U, int16_t>) {\n+          proto.set_i16(value);\n+        } else if constexpr (std::is_same_v<U, int32_t>) {\n+          proto.set_i32(value);\n+        } else if constexpr (std::is_same_v<U, int64_t>) {\n+          proto.set_i64(value);\n+        } else if constexpr (std::is_same_v<U, uint8_t>) {\n+          proto.set_u8(value);\n+        } else if constexpr (std::is_same_v<U, uint16_t>) {\n+          proto.set_u16(value);\n+        } else if constexpr (std::is_same_v<U, uint32_t>) {\n+          proto.set_u32(value);\n+        } else if constexpr (std::is_same_v<U, uint64_t>) {\n+          proto.set_u64(value);\n+        } else if constexpr (std::is_same_v<U, float>) {\n+          proto.set_f32(value);\n+        } else if constexpr (std::is_same_v<U, double>) {\n+          proto.set_f64(value);\n+        } else {\n+          static_assert(false, \"Unsupported scalar type\");\n+        }\n+      },\n+      AsVariant());\n+  return proto;\n+}\n+\n+absl::StatusOr<Scalar> Scalar::FromProto(const ScalarProto& proto) {\n+  switch (proto.value_case()) {\n+    case ScalarProto::kB:\n+      return proto.b();\n+    case ScalarProto::kI8:\n+      if (!IsInRange<int8_t>(proto.i8())) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for int8_t\");\n+      }\n+      return static_cast<int8_t>(proto.i8());\n+    case ScalarProto::kI16:\n+      if (!IsInRange<int16_t>(proto.i16())) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for int16_t\");\n+      }\n+      return static_cast<int16_t>(proto.i16());\n+    case ScalarProto::kI32:\n+      return proto.i32();\n+    case ScalarProto::kI64:\n+      return proto.i64();\n+    case ScalarProto::kU8:\n+      if (!IsInRange<uint8_t>(proto.u8())) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for uint8_t\");\n+      }\n+      return static_cast<uint8_t>(proto.u8());\n+    case ScalarProto::kU16:\n+      if (!IsInRange<uint16_t>(proto.u16())) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for uint16_t\");\n+      }\n+      return static_cast<uint16_t>(proto.u16());\n+    case ScalarProto::kU32:\n+      return proto.u32();\n+    case ScalarProto::kU64:\n+      return proto.u64();\n+    case ScalarProto::kF32:\n+      return proto.f32();\n+    case ScalarProto::kF64:\n+      return proto.f64();\n+    default:\n+      return absl::InvalidArgumentError(\"Unsupported scalar type\");\n+  }\n+}\n+\n+ArrayProto Array::ToProto() const {\n+  ArrayProto proto;\n+  std::visit(\n+      [&](auto&& value) {\n+        using U = std::decay_t<decltype(value)>;\n+        if constexpr (std::is_same_v<U, std::vector<int8_t>>) {\n+          proto.mutable_i8()->mutable_values()->Assign(value.begin(),\n+                                                       value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<int16_t>>) {\n+          proto.mutable_i16()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<int32_t>>) {\n+          proto.mutable_i32()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<int64_t>>) {\n+          proto.mutable_i64()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<uint8_t>>) {\n+          proto.mutable_u8()->mutable_values()->Assign(value.begin(),\n+                                                       value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<uint16_t>>) {\n+          proto.mutable_u16()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<uint32_t>>) {\n+          proto.mutable_u32()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<uint64_t>>) {\n+          proto.mutable_u64()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<float>>) {\n+          proto.mutable_f32()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else if constexpr (std::is_same_v<U, std::vector<double>>) {\n+          proto.mutable_f64()->mutable_values()->Assign(value.begin(),\n+                                                        value.end());\n+        } else {\n+          static_assert(false, \"Unsupported array type\");\n+        }\n+      },\n+      AsVariant());\n+  return proto;\n+}\n+\n+absl::StatusOr<Array> Array::FromProto(const ArrayProto& proto) {\n+  switch (proto.value_case()) {\n+    case ArrayProto::kI8:\n+      if (!absl::c_all_of(proto.i8().values(), IsInRange<int8_t>)) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for int8_t\");\n+      }\n+      return std::vector<int8_t>(proto.i8().values().begin(),\n+                                 proto.i8().values().end());\n+    case ArrayProto::kI16:\n+      if (!absl::c_all_of(proto.i16().values(), IsInRange<int16_t>)) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for int16_t\");\n+      }\n+      return std::vector<int16_t>(proto.i16().values().begin(),\n+                                  proto.i16().values().end());\n+    case ArrayProto::kI32:\n+      return std::vector<int32_t>(proto.i32().values().begin(),\n+                                  proto.i32().values().end());\n+    case ArrayProto::kI64:\n+      return std::vector<int64_t>(proto.i64().values().begin(),\n+                                  proto.i64().values().end());\n+    case ArrayProto::kU8:\n+      if (!absl::c_all_of(proto.u8().values(), IsInRange<uint8_t>)) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for uint8_t\");\n+      }\n+      return std::vector<uint8_t>(proto.u8().values().begin(),\n+                                  proto.u8().values().end());\n+    case ArrayProto::kU16:\n+      if (!absl::c_all_of(proto.u16().values(), IsInRange<uint16_t>)) {\n+        return absl::InvalidArgumentError(\n+            \"Integer value out of range for uint16_t\");\n+      }\n+      return std::vector<uint16_t>(proto.u16().values().begin(),\n+                                   proto.u16().values().end());\n+    case ArrayProto::kU32:\n+      return std::vector<uint32_t>(proto.u32().values().begin(),\n+                                   proto.u32().values().end());\n+    case ArrayProto::kU64:\n+      return std::vector<uint64_t>(proto.u64().values().begin(),\n+                                   proto.u64().values().end());\n+    case ArrayProto::kF32:\n+      return std::vector<float>(proto.f32().values().begin(),\n+                                proto.f32().values().end());\n+    case ArrayProto::kF64:\n+      return std::vector<double>(proto.f64().values().begin(),\n+                                 proto.f64().values().end());\n+    default:\n+      return absl::InvalidArgumentError(\"Unsupported array type\");\n+  }\n+}\n+\n+FlatAttributeProto FlatAttribute::ToProto() const {\n+  FlatAttributeProto proto;\n+  std::visit(\n+      [&](auto&& value) {\n+        using U = std::decay_t<decltype(value)>;\n+        if constexpr (std::is_same_v<U, Scalar>) {\n+          *proto.mutable_scalar() = value.ToProto();\n+        } else if constexpr (std::is_same_v<U, Array>) {\n+          *proto.mutable_array() = value.ToProto();\n+        } else if constexpr (std::is_same_v<U, std::string>) {\n+          proto.set_str(value);\n+        } else {\n+          static_assert(false, \"Unsupported flat attribute type\");\n+        }\n+      },\n+      AsVariant());\n+  return proto;\n+}\n+\n+absl::StatusOr<FlatAttribute> FlatAttribute::FromProto(\n+    const FlatAttributeProto& proto) {\n+  switch (proto.value_case()) {\n+    case FlatAttributeProto::kScalar:\n+      return Scalar::FromProto(proto.scalar());\n+    case FlatAttributeProto::kArray:\n+      return Array::FromProto(proto.array());\n+    case FlatAttributeProto::kStr:\n+      return proto.str();\n+    default:\n+      return absl::InvalidArgumentError(\"Unsupported flat attribute type\");\n+  }\n+}\n+\n+FlatAttributesMapProto FlatAttributesMap::ToProto() const {\n+  FlatAttributesMapProto proto;\n+  for (const auto& [key, value] : *this) {\n+    (*proto.mutable_attrs())[key] = value.ToProto();\n+  }\n+  return proto;\n+}\n+\n+absl::StatusOr<FlatAttributesMap> FlatAttributesMap::FromProto(\n+    const FlatAttributesMapProto& proto) {\n+  FlatAttributesMap result;\n+  for (const auto& [key, value] : proto.attrs()) {\n+    TF_ASSIGN_OR_RETURN(result[key], FlatAttribute::FromProto(value));\n+  }\n+  return result;\n+}\n+\n+Attribute::Attribute(const FlatAttribute& flat)\n+    : Attribute(Convert<Attribute>(flat)) {}\n+\n+bool operator==(const AttributesDictionary& lhs,\n+                const AttributesDictionary& rhs) {\n+  if (lhs.attrs == nullptr) {\n+    return rhs.attrs == nullptr;\n+  }\n+  if (rhs.attrs == nullptr) {\n+    return false;\n+  }\n+  return *lhs.attrs == *rhs.attrs;\n+}\n+\n }  // namespace xla::ffi"
        },
        {
            "sha": "ff593f9c00eed3734a80d139979b116c9984584f",
            "filename": "third_party/xla/xla/ffi/attribute_map.h",
            "status": "modified",
            "additions": 118,
            "deletions": 17,
            "changes": 135,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.h?ref=772ed8bbc785ce04d1c8ad02156d4f9a63788708",
            "patch": "@@ -25,6 +25,7 @@ limitations under the License.\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/status/statusor.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n+#include \"xla/ffi/attribute_map.pb.h\"\n \n namespace xla::ffi {\n namespace internal {\n@@ -38,38 +39,138 @@ struct AppendType<std::variant<Ts...>, T> {\n };\n }  // namespace internal\n \n+using ScalarBase =\n+    std::variant<bool, int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t,\n+                 uint32_t, uint64_t, float, double>;\n+\n // A single scalar value.\n-using Scalar = std::variant<bool, int8_t, int16_t, int32_t, int64_t, uint8_t,\n-                            uint16_t, uint32_t, uint64_t, float, double>;\n+class Scalar : public ScalarBase {\n+ public:\n+  using ScalarBase::ScalarBase;\n+\n+  ScalarProto ToProto() const;\n+\n+  // Older versions of libstdc++ don't implement P2162R2, therefore we need\n+  // these explicit casts to be able to use std::visit.\n+  const ScalarBase& AsVariant() const { return *this; }\n+  ScalarBase& AsVariant() { return *this; }\n+\n+  static absl::StatusOr<Scalar> FromProto(const ScalarProto& proto);\n+};\n+\n+using ArrayBase = std::variant<std::vector<int8_t>, std::vector<int16_t>,\n+                               std::vector<int32_t>, std::vector<int64_t>,\n+                               std::vector<uint8_t>, std::vector<uint16_t>,\n+                               std::vector<uint32_t>, std::vector<uint64_t>,\n+                               std::vector<float>, std::vector<double>>;\n \n // An array of elements of the same Scalar type.\n-using Array = std::variant<std::vector<int8_t>, std::vector<int16_t>,\n-                           std::vector<int32_t>, std::vector<int64_t>,\n-                           std::vector<uint8_t>, std::vector<uint16_t>,\n-                           std::vector<uint32_t>, std::vector<uint64_t>,\n-                           std::vector<float>, std::vector<double>>;\n+class Array : public ArrayBase {\n+ public:\n+  using ArrayBase::ArrayBase;\n+\n+  ArrayProto ToProto() const;\n+\n+  // Older versions of libstdc++ don't implement P2162R2, therefore we need\n+  // these explicit casts to be able to use std::visit.\n+  const ArrayBase& AsVariant() const { return *this; }\n+  ArrayBase& AsVariant() { return *this; }\n+\n+  static absl::StatusOr<Array> FromProto(const ArrayProto& proto);\n+};\n+\n+using FlatAttributeBase = std::variant<Scalar, Array, std::string>;\n \n // Attributes that do not support nested dictionaries.\n-using FlatAttribute = std::variant<Scalar, Array, std::string>;\n+class FlatAttribute : public FlatAttributeBase {\n+ public:\n+  using FlatAttributeBase::FlatAttributeBase;\n+\n+  FlatAttributeProto ToProto() const;\n+\n+  // Older versions of libstdc++ don't implement P2162R2, therefore we need\n+  // these explicit casts to be able to use std::visit.\n+  const FlatAttributeBase& AsVariant() const { return *this; }\n+  FlatAttributeBase& AsVariant() { return *this; }\n+\n+  static absl::StatusOr<FlatAttribute> FromProto(\n+      const FlatAttributeProto& proto);\n+};\n+\n+using FlatAttributesMapBase = absl::flat_hash_map<std::string, FlatAttribute>;\n \n // A map that maps from an arbitrary name (string key) to a flat attribute.\n-using FlatAttributesMap = absl::flat_hash_map<std::string, FlatAttribute>;\n+class FlatAttributesMap : public FlatAttributesMapBase {\n+ public:\n+  using FlatAttributesMapBase::FlatAttributesMapBase;\n \n-// Forward declaration of the recursive type.\n-struct AttributesDictionary;\n+  FlatAttributesMapProto ToProto() const;\n \n-// Attributes that support arbitrary nesting.\n-using Attribute =\n-    internal::AppendType<FlatAttribute, AttributesDictionary>::Type;\n+  // Older versions of libstdc++ don't implement P2162R2, therefore we need\n+  // these explicit casts to be able to use std::visit.\n+  const FlatAttributesMapBase& AsVariant() const { return *this; }\n+  FlatAttributesMapBase& AsVariant() { return *this; }\n \n-// AttributesMap is a map from an arbitrary name (string key) to an attribute.\n-using AttributesMap = absl::flat_hash_map<std::string, Attribute>;\n+  static absl::StatusOr<FlatAttributesMap> FromProto(\n+      const FlatAttributesMapProto& proto);\n+};\n \n // Dictionary is just a wrapper around `AttributesMap`. We need an indirection\n // through `std::shared_ptr` to be able to define recursive `std::variant`. We\n // use shared pointer to keep `AttributesMap` copyable.\n struct AttributesDictionary {\n-  std::shared_ptr<AttributesMap> attrs;\n+  std::shared_ptr<class AttributesMap> attrs;\n+\n+  AttributesMapProto ToProto() const;\n+\n+  static absl::StatusOr<AttributesDictionary> FromProto(\n+      const AttributesMapProto& proto);\n+\n+  friend bool operator==(const AttributesDictionary& lhs,\n+                         const AttributesDictionary& rhs);\n+\n+  friend bool operator!=(const AttributesDictionary& lhs,\n+                         const AttributesDictionary& rhs) {\n+    return !(lhs == rhs);\n+  }\n+};\n+\n+using AttributeBase =\n+    internal::AppendType<FlatAttributeBase, AttributesDictionary>::Type;\n+\n+// Attributes that support arbitrary nesting.\n+class Attribute : public AttributeBase {\n+ public:\n+  using AttributeBase::AttributeBase;\n+\n+  explicit Attribute(const FlatAttribute& flat);\n+\n+  xla::ffi::AttributeProto ToProto() const;\n+\n+  // Older versions of libstdc++ don't implement P2162R2, therefore we need\n+  // these explicit casts to be able to use std::visit.\n+  const AttributeBase& AsVariant() const { return *this; }\n+  AttributeBase& AsVariant() { return *this; }\n+\n+  static absl::StatusOr<Attribute> FromProto(const AttributeProto& proto);\n+};\n+\n+using AttributesMapBase = absl::flat_hash_map<std::string, Attribute>;\n+\n+// AttributesMap is a map from an arbitrary name (string key) to an attribute.\n+class AttributesMap : public AttributesMapBase {\n+ public:\n+  using AttributesMapBase::AttributesMapBase;\n+\n+  AttributesMapProto ToProto() const;\n+\n+  // Older versions of libstdc++ don't implement P2162R2, therefore we need\n+  // these explicit casts to be able to use std::visit.\n+  const AttributesMapBase& AsVariant() const { return *this; }\n+  AttributesMapBase& AsVariant() { return *this; }\n+\n+  static absl::StatusOr<AttributesMap> FromProto(\n+      const AttributesMapProto& proto);\n };\n \n // Converts MLIR dictionary attribute attached to a custom call operation to a"
        },
        {
            "sha": "1f3bbef5b63b3795431b11974f109d33b9492566",
            "filename": "third_party/xla/xla/ffi/attribute_map.proto",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.proto?ref=772ed8bbc785ce04d1c8ad02156d4f9a63788708",
            "patch": "@@ -0,0 +1,102 @@\n+syntax = \"proto3\";\n+\n+package xla.ffi;\n+\n+option java_multiple_files = true;\n+option java_outer_classname = \"AttributeMap\";\n+\n+message ScalarProto {\n+  oneof value {\n+    bool b = 1;\n+    int32 i8 = 2;\n+    int32 i16 = 3;\n+    int32 i32 = 4;\n+    int64 i64 = 5;\n+    uint32 u8 = 6;\n+    uint32 u16 = 7;\n+    uint32 u32 = 8;\n+    uint64 u64 = 9;\n+    float f32 = 10;\n+    double f64 = 11;\n+  }\n+}\n+\n+message ArrayProto {\n+  message Int8ArrayProto {\n+    repeated int32 values = 1;\n+  }\n+\n+  message Int16ArrayProto {\n+    repeated int32 values = 1;\n+  }\n+\n+  message Int32ArrayProto {\n+    repeated int32 values = 1;\n+  }\n+\n+  message Int64ArrayProto {\n+    repeated int64 values = 1;\n+  }\n+\n+  message Uint8ArrayProto {\n+    repeated uint32 values = 1;\n+  }\n+\n+  message Uint16ArrayProto {\n+    repeated uint32 values = 1;\n+  }\n+\n+  message Uint32ArrayProto {\n+    repeated uint32 values = 1;\n+  }\n+\n+  message Uint64ArrayProto {\n+    repeated uint64 values = 1;\n+  }\n+\n+  message FloatArrayProto {\n+    repeated float values = 1;\n+  }\n+\n+  message DoubleArrayProto {\n+    repeated double values = 1;\n+  }\n+\n+  oneof value {\n+    Int8ArrayProto i8 = 1;\n+    Int16ArrayProto i16 = 2;\n+    Int32ArrayProto i32 = 3;\n+    Int64ArrayProto i64 = 4;\n+    Uint8ArrayProto u8 = 5;\n+    Uint16ArrayProto u16 = 6;\n+    Uint32ArrayProto u32 = 7;\n+    Uint64ArrayProto u64 = 8;\n+    FloatArrayProto f32 = 9;\n+    DoubleArrayProto f64 = 10;\n+  }\n+}\n+\n+message FlatAttributeProto {\n+  oneof value {\n+    ScalarProto scalar = 1;\n+    ArrayProto array = 2;\n+    string str = 3;\n+  }\n+}\n+\n+message FlatAttributesMapProto {\n+  map<string, FlatAttributeProto> attrs = 1;\n+}\n+\n+message AttributeProto {\n+  oneof value {\n+    ScalarProto scalar = 1;\n+    ArrayProto array = 2;\n+    string str = 3;\n+    AttributesMapProto dict = 4;\n+  }\n+}\n+\n+message AttributesMapProto {\n+  map<string, AttributeProto> attrs = 1;\n+}"
        },
        {
            "sha": "78b577f85180f6d4cc1b007a20f50af771fee1c6",
            "filename": "third_party/xla/xla/ffi/attribute_map_test.cc",
            "status": "added",
            "additions": 287,
            "deletions": 0,
            "changes": 287,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map_test.cc?ref=772ed8bbc785ce04d1c8ad02156d4f9a63788708",
            "patch": "@@ -0,0 +1,287 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/ffi/attribute_map.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"xla/tsl/util/proto/parse_text_proto.h\"\n+#include \"xla/tsl/util/proto/proto_matchers.h\"\n+\n+namespace xla::ffi {\n+namespace {\n+using absl_testing::IsOkAndHolds;\n+using absl_testing::StatusIs;\n+using ::testing::HasSubstr;\n+using tsl::proto_testing::EqualsProto;\n+using tsl::proto_testing::ParseTextProtoOrDie;\n+\n+TEST(ScalarTest, ProtoConversion) {\n+  EXPECT_THAT(Scalar(true).ToProto(), EqualsProto(R\"pb(\n+                b: 1\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                b: 1\n+              )pb\")),\n+              IsOkAndHolds(Scalar(true)));\n+\n+  EXPECT_THAT(Scalar(int8_t{42}).ToProto(), EqualsProto(R\"pb(\n+                i8: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                i8: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(int8_t{42})));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                i8: 128\n+              )pb\")),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Integer value out of range for int8_t\")));\n+\n+  EXPECT_THAT(Scalar(int16_t{42}).ToProto(), EqualsProto(R\"pb(\n+                i16: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                i16: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(int16_t{42})));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                i16: 32768\n+              )pb\")),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Integer value out of range for int16_t\")));\n+\n+  EXPECT_THAT(Scalar(int32_t{42}).ToProto(), EqualsProto(R\"pb(\n+                i32: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                i32: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(int32_t{42})));\n+\n+  EXPECT_THAT(Scalar(int64_t{42}).ToProto(), EqualsProto(R\"pb(\n+                i64: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                i64: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(int64_t{42})));\n+\n+  EXPECT_THAT(Scalar(uint8_t{42}).ToProto(), EqualsProto(R\"pb(\n+                u8: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                u8: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(uint8_t{42})));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                u8: 256\n+              )pb\")),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Integer value out of range for uint8_t\")));\n+\n+  EXPECT_THAT(Scalar(uint16_t{42}).ToProto(), EqualsProto(R\"pb(\n+                u16: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                u16: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(uint16_t{42})));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                u16: 65536\n+              )pb\")),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Integer value out of range for uint16_t\")));\n+\n+  EXPECT_THAT(Scalar(uint32_t{42}).ToProto(), EqualsProto(R\"pb(\n+                u32: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                u32: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(uint32_t{42})));\n+\n+  EXPECT_THAT(Scalar(uint64_t{42}).ToProto(), EqualsProto(R\"pb(\n+                u64: 42\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                u64: 42\n+              )pb\")),\n+              IsOkAndHolds(Scalar(uint64_t{42})));\n+\n+  EXPECT_THAT(Scalar(float{42.0f}).ToProto(), EqualsProto(R\"pb(\n+                f32: 42.0\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                f32: 42.0\n+              )pb\")),\n+              IsOkAndHolds(Scalar(float{42.0f})));\n+\n+  EXPECT_THAT(Scalar(double{42.0}).ToProto(), EqualsProto(R\"pb(\n+                f64: 42.0\n+              )pb\"));\n+  EXPECT_THAT(Scalar::FromProto(ParseTextProtoOrDie<ScalarProto>(R\"pb(\n+                f64: 42.0\n+              )pb\")),\n+              IsOkAndHolds(Scalar(double{42.0})));\n+}\n+\n+TEST(ArrayTest, ProtoConversion) {\n+  EXPECT_THAT(Array(std::vector<int8_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                i8: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                i8: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<int8_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<int16_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                i16: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                i16: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<int16_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<int32_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                i32: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                i32: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<int32_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<int64_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                i64: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                i64: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<int64_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<uint8_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                u8: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                u8: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<uint8_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<uint16_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                u16: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                u16: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<uint16_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<uint32_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                u32: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                u32: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<uint32_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<uint64_t>{42, 43}).ToProto(), EqualsProto(R\"pb(\n+                u64: { values: 42 values: 43 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                u64: { values: 42 values: 43 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<uint64_t>{42, 43})));\n+\n+  EXPECT_THAT(Array(std::vector<float>{42.0f, 43.0f}).ToProto(),\n+              EqualsProto(R\"pb(\n+                f32: { values: 42.0 values: 43.0 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                f32: { values: 42.0 values: 43.0 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<float>{42.0f, 43.0f})));\n+\n+  EXPECT_THAT(Array(std::vector<double>{42.0, 43.0}).ToProto(),\n+              EqualsProto(R\"pb(\n+                f64: { values: 42.0 values: 43.0 }\n+              )pb\"));\n+  EXPECT_THAT(Array::FromProto(ParseTextProtoOrDie<ArrayProto>(R\"pb(\n+                f64: { values: 42.0 values: 43.0 }\n+              )pb\")),\n+              IsOkAndHolds(Array(std::vector<double>{42.0, 43.0})));\n+}\n+\n+TEST(FlatAttributeTest, ProtoConversion) {\n+  EXPECT_THAT(FlatAttribute(Scalar(true)).ToProto(), EqualsProto(R\"pb(\n+                scalar: { b: 1 }\n+              )pb\"));\n+  EXPECT_THAT(FlatAttribute::FromProto(ParseTextProtoOrDie<FlatAttributeProto>(\n+                  R\"pb(\n+                    scalar: { b: 1 }\n+                  )pb\")),\n+              IsOkAndHolds(FlatAttribute(Scalar(true))));\n+  EXPECT_THAT(FlatAttribute(Array(std::vector<int8_t>{42, 43})).ToProto(),\n+              EqualsProto(R\"pb(\n+                array: { i8: { values: 42 values: 43 } }\n+              )pb\"));\n+  EXPECT_THAT(FlatAttribute::FromProto(ParseTextProtoOrDie<FlatAttributeProto>(\n+                  R\"pb(\n+                    array: { i8: { values: 42 values: 43 } }\n+                  )pb\")),\n+              IsOkAndHolds(FlatAttribute(Array(std::vector<int8_t>{42, 43}))));\n+\n+  EXPECT_THAT(FlatAttribute(std::string(\"foo\")).ToProto(), EqualsProto(R\"pb(\n+                str: \"foo\"\n+              )pb\"));\n+  EXPECT_THAT(FlatAttribute::FromProto(ParseTextProtoOrDie<FlatAttributeProto>(\n+                  R\"pb(\n+                    str: \"foo\"\n+                  )pb\")),\n+              IsOkAndHolds(FlatAttribute(std::string(\"foo\"))));\n+}\n+\n+TEST(AttributesMapTest, ProtoConversion) {\n+  AttributesMap attrs = {{std::string(\"foo\"), Attribute(Scalar(true))}};\n+\n+  EXPECT_THAT(AttributesMap::FromProto(attrs.ToProto()), IsOkAndHolds(attrs));\n+}\n+\n+TEST(DictionaryTest, ProtoConversion) {\n+  AttributesMap attrs = {{std::string(\"foo\"), Attribute(Scalar(true))}};\n+  AttributesDictionary dict{};\n+  dict.attrs = std::make_shared<AttributesMap>(attrs);\n+\n+  EXPECT_THAT(AttributesDictionary::FromProto(dict.ToProto()),\n+              IsOkAndHolds(dict));\n+}\n+\n+TEST(AttributeTest, ProtoConversion) {\n+  AttributesDictionary dict{};\n+  dict.attrs = std::make_shared<AttributesMap>(\n+      AttributesMap{{std::string(\"foo\"), Attribute(Scalar(true))}});\n+  Attribute attr(std::move(dict));\n+\n+  EXPECT_THAT(Attribute::FromProto(attr.ToProto()), IsOkAndHolds(attr));\n+}\n+\n+}  // namespace\n+}  // namespace xla::ffi"
        },
        {
            "sha": "ad7c71c98f8cd6ad472d745200c417e764a75c11",
            "filename": "third_party/xla/xla/ffi/call_frame.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/772ed8bbc785ce04d1c8ad02156d4f9a63788708/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.cc?ref=772ed8bbc785ce04d1c8ad02156d4f9a63788708",
            "patch": "@@ -442,7 +442,7 @@ struct CallFrame::FixUpAttribute {\n       array.array.size = value.size();\n       array.array.data = value.data();\n     };\n-    std::visit(visitor, array.value);\n+    std::visit(visitor, array.value.AsVariant());\n   }\n \n   void operator()(CallFrame::Scalar& scalar) {\n@@ -451,7 +451,7 @@ struct CallFrame::FixUpAttribute {\n       scalar.scalar.dtype = internal::NativeTypeToCApiDataType<T>();\n       scalar.scalar.value = &value;\n     };\n-    std::visit(visitor, scalar.value);\n+    std::visit(visitor, scalar.value.AsVariant());\n   }\n \n   void operator()(CallFrame::String& str) {\n@@ -506,7 +506,8 @@ std::unique_ptr<CallFrame::Attributes> CallFrame::CreateAttrs(\n   // Convert call frame builder attributes to a collection of named attributes.\n   attrs->attributes.reserve(battrs.size());\n   for (auto& [name, battr] : battrs) {\n-    NamedAttribute attr = {String{name}, std::visit(ConvertAttribute(), battr)};\n+    NamedAttribute attr = {String{name},\n+                           std::visit(ConvertAttribute(), battr.AsVariant())};\n     attrs->attributes.push_back(std::move(attr));\n   }\n "
        }
    ],
    "stats": {
        "total": 885,
        "additions": 865,
        "deletions": 20
    }
}