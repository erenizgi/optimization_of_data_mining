{
    "author": "seantalts",
    "message": "[XLA:CPU] Link Eigen IR module into XLA JITted code. Attempt 2.\n\nNow with flags to disable sanitizers in Eigen generated LLVM IR.\n\nPiperOrigin-RevId: 840770629",
    "sha": "e750c4df886f3aaa805fec49f87f88d2db4c4295",
    "files": [
        {
            "sha": "645c76b8f1afd94599eece5639f0a898f1b9b2dd",
            "filename": "third_party/xla/xla/codegen/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -171,6 +171,7 @@ cc_library(\n         \"//xla/codegen/intrinsic:tanh\",\n         \"//xla/codegen/intrinsic:type\",\n         \"//xla/codegen/intrinsic:vec_name_mangler\",\n+        \"//xla/codegen/intrinsic/cpp:_cpp_gen_intrinsics\",\n         \"//xla/service/llvm_ir:llvm_util\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\","
        },
        {
            "sha": "847e5f6e3ccb07427d775f7b3fcce416016202f6",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/BUILD",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -89,3 +89,37 @@ xla_cc_test(\n         \"@com_google_googletest//:gtest_main\",\n     ],\n )\n+\n+cc_library(\n+    name = \"_cpp_gen_intrinsics\",\n+    srcs = [\"cpp_gen_intrinsics.cc\"],\n+    hdrs = [\"cpp_gen_intrinsics.h\"],\n+    deps = [\n+        \":eigen_unary_ll\",\n+        \"//xla/codegen/intrinsic\",\n+        \"//xla/service/llvm_ir:llvm_util\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@llvm-project//llvm:IRReader\",\n+        \"@llvm-project//llvm:Linker\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//llvm:Target\",\n+        \"@llvm-project//llvm:TransformUtils\",\n+        \"@llvm-project//llvm:ir_headers\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"_intrinsic_declarations\",\n+    hdrs = [\"intrinsic_declarations.h\"],\n+    deps = [\n+        \":_cpp_gen_intrinsics\",\n+        \"//xla:xla_data_proto_cc\",\n+        \"//xla/codegen/intrinsic\",\n+        \"//xla/codegen/intrinsic:type\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@llvm-project//llvm:ir_headers\",\n+    ],\n+)"
        },
        {
            "sha": "5fd098d2e33427679d5561fa1fe1521cfb2ea4e5",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cc_to_llvm_ir.bzl",
            "status": "modified",
            "additions": 56,
            "deletions": 30,
            "changes": 86,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -25,14 +25,19 @@ def _cc_ir_header_impl(ctx):\n     compilation_contexts = [dep[CcInfo].compilation_context for dep in ctx.attr.deps]\n     output_header = ctx.outputs.out_header\n \n-    ir_file = ctx.actions.declare_file(\"{}.ll\".format(ctx.label.name))\n-\n     cxx_flags = [\n         \"-S\",\n         \"-emit-llvm\",\n         \"-O3\",\n+        \"-DNDEBUG\",\n+        \"-mprefer-vector-width=512\",\n         \"-DEIGEN_VECTORIZE_GENERIC\",\n+        \"-fno-sanitize=all\",\n+        \"-fno-stack-protector\",\n+        \"-fno-coverage-mapping\",\n+        \"-fno-profile-instr-generate\",\n     ]\n+\n     compilation_outputs = cc_common.compile(\n         actions = ctx.actions,\n         feature_configuration = feature_configuration,\n@@ -43,48 +48,69 @@ def _cc_ir_header_impl(ctx):\n         name = \"{}_compiler\".format(ctx.label.name),\n     )\n \n-    # Copy the compiler's output to our declared intermediate file.\n-    if len(compilation_outputs[1].pic_objects) > 0:\n-        temp_ir_output = compilation_outputs[1].pic_objects[0]\n-    else:\n-        temp_ir_output = compilation_outputs[1].objects[0]\n-    ctx.actions.run_shell(\n-        inputs = [temp_ir_output],\n-        outputs = [ir_file],\n-        command = \"cp {} {}\".format(temp_ir_output.path, ir_file.path),\n-        mnemonic = \"CopyLLVMIR\",\n-    )\n-\n-    # Prepare the C++ variable definition for the header.\n-    ir_definition = 'inline constexpr char k{base_name}Ir[] = R\"IR($(cat {input}))IR\";'.format(\n-        base_name = to_camel_case(ctx.attr.base_name),\n-        input = ir_file.path,\n-    )\n+    # Windows builds may produce objects and not pic_objects.\n+    # We accept either, preferring pic_objects if available.\n+    objs = compilation_outputs[1].pic_objects\n+    if not objs:\n+        objs = compilation_outputs[1].objects\n+        if not objs:\n+            objs_str = \"\"\n+            for objs in compilation_outputs:\n+                objs_str += \"\\n\"\n+                for obj in objs:\n+                    objs_str += \", \" + str(obj)\n+            fail(\"No objects found in compilation_outputs. Compilation outputs: {}\".format(objs_str))\n+\n+    temp_ir_output = objs[0]\n \n     # Generate the final C++ header file.\n+    # We use a python one-liner to perform a binary-safe copy.\n+    # 1. 'wb' mode writes the C++ preamble.\n+    # 2. We read the input as binary ('rb').\n+    # 3. We check for the UTF-8 BOM (\\xef\\xbb\\xbf) and strip it if present.\n+    #    NOTE: We use double backslashes (\\\\x) so Starlark passes the literal characters\n+    #    to Python, allowing Python to interpret the hex escape sequence.\n+    # 4. We append the rest of the file and the C++ closing syntax.\n     ctx.actions.run_shell(\n-        inputs = [ir_file],\n+        inputs = [temp_ir_output],\n         outputs = [output_header],\n         mnemonic = \"EmbeddingLLVMIR\",\n         command = \"\"\"\n-cat <<EOF > {output}\n+set -e\n+input_path=$1\n+output_path=$2\n+variable_name=$3\n+namespace=$4\n+\n+# 1. Write the header start\n+cat <<EOF > \"$output_path\"\n #pragma once\n \n // Generated by cc_ir_header rule. DO NOT EDIT.\n \n-namespace {namespace} {{\n+namespace $namespace {\n+\n+inline constexpr char ${variable_name}[] = R\"IR(\n+EOF\n+\n+# 2. Append the IR content using Python for binary safety and BOM stripping.\n+python -c \"import sys; d = open(sys.argv[1], 'rb').read(); d = d[3:] if d.startswith(b'\\\\xef\\\\xbb\\\\xbf') else d; open(sys.argv[2], 'ab').write(d)\" \"$input_path\" \"$output_path\"\n \n-{defs}\n+# 3. Append the header end\n+cat <<EOF >> \"$output_path\"\n+)IR\";\n \n-}} // namespace {namespace}\n+} // namespace $namespace\n EOF\n-\"\"\".format(\n-            output = output_header.path,\n-            defs = ir_definition,\n-            namespace = ctx.attr.namespace,\n-        ),\n-        progress_message = \"Embedding LLVM IR into header for %s\" % ctx.label,\n+\"\"\",\n+        arguments = [\n+            temp_ir_output.path,\n+            output_header.path,\n+            \"k{}Ir\".format(to_camel_case(ctx.attr.base_name)),\n+            ctx.attr.namespace,\n+        ],\n     )\n+\n     compilation_context = cc_common.create_compilation_context(headers = depset([output_header]))\n     cc_info = CcInfo(compilation_context = compilation_context)\n "
        },
        {
            "sha": "3984fc9d63250a868837bef592251ab9fb58f1ec",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.cc",
            "status": "added",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.cc?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -0,0 +1,89 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/IR/Attributes.h\"\n+#include \"llvm/IR/Function.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"llvm/IRReader/IRReader.h\"\n+#include \"llvm/Linker/Linker.h\"\n+#include \"llvm/Support/MemoryBufferRef.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n+#include \"xla/codegen/intrinsic/cpp/eigen_unary_ll.h\"\n+#include \"xla/codegen/intrinsic/intrinsic.h\"\n+#include \"xla/service/llvm_ir/llvm_util.h\"\n+\n+namespace xla::codegen {\n+\n+std::string GetCppGenIrString(const intrinsics::IntrinsicOptions& options) {\n+  return ::llvm_ir::kEigenUnaryLlIr;\n+}\n+\n+void CppGenIntrinsicLibrary::LinkIntoModule(llvm::Module& dst_module) const {\n+  llvm::SMDiagnostic err;\n+  llvm::LLVMContext& context = dst_module.getContext();\n+  auto lib_module = llvm::parseIR(llvm::MemoryBufferRef(ir_text_, source_name_),\n+                                  err, context);\n+  CHECK(lib_module != nullptr)\n+      << \"Failed to parse IR: \" << err.getMessage().str() << \"\\n\"\n+      << ir_text_;\n+\n+  llvm::Linker linker(dst_module);\n+\n+  std::vector<std::string> lib_functions;\n+  for (const auto& func : *lib_module) {\n+    if (!func.isDeclaration()) {\n+      lib_functions.push_back(func.getName().str());\n+    }\n+  }\n+  const llvm::DataLayout& hostDataLayout = dst_module.getDataLayout();\n+  lib_module->setDataLayout(hostDataLayout);\n+  if (linker.linkModules(dst_module, std::move(lib_module))) {\n+    LOG(FATAL) << \"LLVM Linker failed to link CppGen library.\";\n+  }\n+  for (const auto& func : lib_functions) {\n+    llvm::Function* linked_func = dst_module.getFunction(func);\n+    if (linked_func && !linked_func->isDeclaration()) {\n+      linked_func->setLinkage(llvm::Function::InternalLinkage);\n+      linked_func->addFnAttr(llvm::Attribute::AlwaysInline);\n+    }\n+  }\n+}\n+llvm::Function* GetCppGenFunction(llvm::Module* module,\n+                                  absl::string_view name) {\n+  llvm::Function* func = module->getFunction(name);\n+  CHECK(func != nullptr)\n+      << \"CppGen function '\" << name\n+      << \"' was not found in the module. Ensure the \"\n+         \"function name is correct and the library \"\n+         \"containing it was linked by IntrinsicFunctionLib.\\n\"\n+      << llvm_ir::DumpToString(module);\n+  ;\n+  if (!func->isDeclaration()) {\n+    func->setLinkage(llvm::Function::InternalLinkage);\n+    func->addFnAttr(llvm::Attribute::AlwaysInline);\n+  }\n+  return func;\n+}\n+}  // namespace xla::codegen"
        },
        {
            "sha": "63dc72d770ca975d69e960aea727210497ca1071",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h",
            "status": "added",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.h?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -0,0 +1,60 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_CODEGEN_INTRINSIC_CPP_CPP_GEN_INTRINSICS_H_\n+#define XLA_CODEGEN_INTRINSIC_CPP_CPP_GEN_INTRINSICS_H_\n+\n+#include <string>\n+\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/IR/Attributes.h\"\n+#include \"llvm/IR/Function.h\"\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"llvm/IRReader/IRReader.h\"\n+#include \"llvm/Target/TargetMachine.h\"\n+#include \"llvm/Transforms/Utils/Cloning.h\"\n+#include \"llvm/Transforms/Utils/ValueMapper.h\"\n+#include \"xla/codegen/intrinsic/intrinsic.h\"\n+\n+namespace xla::codegen {\n+\n+std::string GetCppGenIrString(const intrinsics::IntrinsicOptions& options);\n+\n+// Helper for Intrinsic<T> classes that use CppGen backend for some types.\n+// Looks up a function by name in the module (assuming it was linked from\n+// a CppGen library) and configures its linkage and attributes for inlining.\n+llvm::Function* GetCppGenFunction(llvm::Module* module, absl::string_view name);\n+\n+class CppGenIntrinsicLibrary {\n+ public:\n+  explicit CppGenIntrinsicLibrary(absl::string_view ir_text,\n+                                  absl::string_view source_name)\n+      : ir_text_(ir_text), source_name_(source_name) {}\n+\n+  // Links the CppGen library into the given module. This will insert all\n+  // of the function definitions in the ir_text into the dst_module and set\n+  // internal linkage and the alwaysinline attribute on each of them so they\n+  // can be inlined and removed later.\n+  void LinkIntoModule(llvm::Module& dst_module) const;\n+\n+ private:\n+  std::string ir_text_;\n+  std::string source_name_;\n+};\n+\n+}  // namespace xla::codegen\n+\n+#endif  // XLA_CODEGEN_INTRINSIC_CPP_CPP_GEN_INTRINSICS_H_"
        },
        {
            "sha": "e2a263b8b6272e83088b2e94352c2c726bf5622b",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -36,12 +36,33 @@ inline VecType VectorTanh(const VecType x) {\n // XLA entrypoints, renamed with asm in header file.\n //===--------------------------------------------------------------------===//\n \n+using FloatArrayType = Eigen::Array<float, 16, 1>;\n+\n // Single precision\n float tanh_f32(float x) { return Eigen::internal::ptanh_float(x); }\n+Vec4f tanh_v4f32(Vec4f x) {\n+  FloatArrayType buffer;\n+  *reinterpret_cast<Vec4f*>(&buffer) = x;\n+  buffer = buffer.tanh();\n+  return *reinterpret_cast<Vec4f*>(&buffer);\n+}\n+Vec8f tanh_v8f32(Vec8f x) {\n+  FloatArrayType buffer;\n+  *reinterpret_cast<Vec8f*>(&buffer) = x;\n+  buffer = buffer.tanh();\n+  return *reinterpret_cast<Vec8f*>(&buffer);\n+}\n Vec16f tanh_v16f32(Vec16f x) { return VectorTanh(x); }\n \n // Double precision\n+using DoubleArrayType = Eigen::Array<double, 8, 1>;\n double tanh_f64(double x) { return Eigen::internal::ptanh_double(x); }\n+Vec4d tanh_v4f64(Vec4d x) {\n+  DoubleArrayType buffer;\n+  *reinterpret_cast<Vec4d*>(&buffer) = x;\n+  buffer = buffer.tanh();\n+  return *reinterpret_cast<Vec4d*>(&buffer);\n+}\n Vec8d tanh_v8f64(Vec8d x) { return VectorTanh(x); }\n \n }  // namespace xla::codegen"
        },
        {
            "sha": "af1457de8b4db23de30a9ce09696fa5d6b84ed82",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary.h",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.h?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -20,12 +20,17 @@ limitations under the License.\n namespace xla::codegen {\n \n // Single precision\n-float tanh_f32(float x) asm(\"xla.tanh.f32\");\n-Vec16f tanh_v16f32(Vec16f x) asm(\"xla.tanh.v16f32\");\n+// Right now these are unused and we rename them to avoid shadowing the current\n+// tanh implementation.\n+float tanh_f32(float x) asm(\"xla.unused.tanh.f32\");\n+Vec4f tanh_v4f32(Vec4f x) asm(\"xla.unused.tanh.v4f32\");\n+Vec8f tanh_v8f32(Vec8f x) asm(\"xla.unused.tanh.v8f32\");\n+Vec16f tanh_v16f32(Vec16f x) asm(\"xla.unused.tanh.v16f32\");\n \n // Double precision\n-double tanh_f64(double x) asm(\"xla.tanh.f64\");\n-Vec8d tanh_v8f64(Vec8d x) asm(\"xla.tanh.v8f64\");\n+double tanh_f64(double x) asm(\"xla.unused.tanh.f64\");\n+Vec4d tanh_v4f64(Vec4d x) asm(\"xla.unused.tanh.v4f64\");\n+Vec8d tanh_v8f64(Vec8d x) asm(\"xla.unused.tanh.v8f64\");\n \n }  // namespace xla::codegen\n "
        },
        {
            "sha": "7f784069748d2ff9d80ab79d2c257b4d4e4a1aa4",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary_test.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 5,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -16,7 +16,6 @@ limitations under the License.\n #include \"xla/codegen/intrinsic/cpp/eigen_unary.h\"\n \n #include <cmath>\n-#include <string>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n@@ -30,13 +29,56 @@ using ::testing::ContainsRegex;\n using ::testing::Not;\n using ::xla::codegen::intrinsic::NearUlps;\n \n-constexpr int kTanhUlps = 4;\n+constexpr int kTanhUlps = 5;\n \n TEST(EigenUnaryTest, FastTanhfIsCorrect) {\n-  Vec16f x = {1.0f,  2.0f,  -1.0f, 4.0f,   8.0f,   16.0f,  32.0f, 64.0f,\n+  Vec16f x = {1.0f,  2.0f,  -1.0f, 4.0f,   8.0f,   16.0f,  32.0f, 200.0f,\n               -2.0f, -4.0f, -8.0f, -16.0f, -32.0f, -64.0f, 0.0f,  0.5f};\n   Vec16f y = tanh_v16f32(x);\n   for (int i = 0; i < 16; ++i) {\n+    EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps))\n+        << x[i] << \" \" << std::tanh(x[i]);\n+  }\n+}\n+\n+TEST(EigenUnaryTest, FastTanhdIsCorrect) {\n+  Vec4d x = {1.0, 2.0, -1.0, 4.0};\n+  Vec4d y = tanh_v4f64(x);\n+  for (int i = 0; i < 4; ++i) {\n+    EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps));\n+  }\n+}\n+\n+TEST(EigenUnaryTest, LinspaceInputsTanhfCorrectness) {\n+  constexpr float start = -100.0f;\n+  constexpr float end = 100.0f;\n+  constexpr int steps = 1000 * 16;\n+  constexpr float step = (end - start) / steps;\n+\n+  for (int i = 0; i < steps; i += 16) {\n+    Vec16f x;\n+    for (int j = 0; j < 16; ++j) {\n+      x[j] = start + (i + j) * step;\n+    }\n+    Vec16f y = tanh_v16f32(x);\n+    for (int j = 0; j < 16; ++j) {\n+      EXPECT_THAT(y[j], NearUlps(std::tanh(x[j]), kTanhUlps));\n+    }\n+  }\n+}\n+\n+TEST(EigenUnaryTest, v4f32TanhIsCorrect) {\n+  Vec4f x = {1.0f, 2.0f, -1.0f, 4.0f};\n+  Vec4f y = tanh_v4f32(x);\n+  for (int i = 0; i < 4; ++i) {\n+    EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps));\n+  }\n+}\n+\n+TEST(EigenUnaryTest, v8f32TanhIsCorrect) {\n+  Vec8f x = {1.0f, 2.0f, -1.0f, 4.0f, 8.0f, 16.0f, 32.0f, 64.0f};\n+  Vec8f y = tanh_v8f32(x);\n+  for (int i = 0; i < 8; ++i) {\n     EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps));\n   }\n }\n@@ -56,8 +98,8 @@ TEST(EigenUnaryTest, FastTanhfIsVectorized) {\n   EXPECT_THAT(ir, ContainsRegex(\"<16 x float>.*0x3E4DF2A3C0000000\"));\n   EXPECT_THAT(ir, Not(ContainsRegex(\"llvm.x86\")));\n   EXPECT_THAT(ir, Not(ContainsRegex(\"llvm.aarch64\")));\n-  EXPECT_THAT(ir, ContainsRegex(\"xla.tanh.v16f32\"));\n-  EXPECT_THAT(ir, ContainsRegex(\"xla.tanh.v8f64\"));\n+  EXPECT_THAT(ir, ContainsRegex(\"xla.unused.tanh.v16f32\"));\n+  EXPECT_THAT(ir, ContainsRegex(\"xla.unused.tanh.v8f64\"));\n }\n \n }  // namespace"
        },
        {
            "sha": "f452f2c256226b15e72e7c15121094896107f099",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/intrinsic_declarations.h",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fintrinsic_declarations.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fintrinsic_declarations.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fintrinsic_declarations.h?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -0,0 +1,53 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_CODEGEN_INTRINSIC_CPP_INTRINSIC_DECLARATIONS_H_\n+#define XLA_CODEGEN_INTRINSIC_CPP_INTRINSIC_DECLARATIONS_H_\n+\n+#include <vector>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/IR/Attributes.h\"\n+#include \"llvm/IR/Function.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n+#include \"xla/codegen/intrinsic/intrinsic.h\"\n+#include \"xla/codegen/intrinsic/type.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla::codegen::intrinsics {\n+\n+class EigenTanh : public Intrinsic<EigenTanh> {\n+ public:\n+  static constexpr absl::string_view kName = \"tanh\";\n+\n+  static std::vector<std::vector<Type>> SupportedVectorTypes(\n+      absl::string_view features) {\n+    return {\n+        {Type::S(xla::F32)},     {Type::V(xla::F32, 4)}, {Type::V(xla::F32, 8)},\n+        {Type::V(xla::F32, 16)}, {Type::S(xla::F64)},    {Type::V(xla::F64, 4)},\n+        {Type::V(xla::F64, 8)},\n+    };\n+  }\n+\n+  static absl::StatusOr<llvm::Function*> CreateDefinition(\n+      llvm::Module* module, const IntrinsicOptions& options, Type type) {\n+    return GetCppGenFunction(module, Name(type));\n+  }\n+};\n+}  // namespace xla::codegen::intrinsics\n+\n+#endif  // XLA_CODEGEN_INTRINSIC_CPP_INTRINSIC_DECLARATIONS_H_"
        },
        {
            "sha": "3ee474cf80d2241b2a03daff08a0f3cd406327a8",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 9,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -52,6 +52,7 @@ limitations under the License.\n #include \"llvm/Passes/StandardInstrumentations.h\"\n #include \"llvm/Support/Casting.h\"\n #include \"llvm/Support/TypeSize.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/GlobalDCE.h\"\n #include \"llvm/Transforms/IPO/SCCP.h\"\n@@ -60,7 +61,9 @@ limitations under the License.\n #include \"llvm/Transforms/Scalar/DCE.h\"\n #include \"llvm/Transforms/Scalar/EarlyCSE.h\"\n #include \"llvm/Transforms/Scalar/SCCP.h\"\n+#include \"llvm/Transforms/Utils/Cloning.h\"\n #include \"llvm/Transforms/Utils/ModuleUtils.h\"\n+#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n #include \"xla/codegen/intrinsic/erf.h\"\n #include \"xla/codegen/intrinsic/exp.h\"\n #include \"xla/codegen/intrinsic/fptrunc.h\"\n@@ -72,6 +75,7 @@ limitations under the License.\n #include \"xla/codegen/intrinsic/tanh.h\"\n #include \"xla/codegen/intrinsic/type.h\"\n #include \"xla/codegen/intrinsic/vec_name_mangler.h\"\n+#include \"xla/codegen/intrinsic_function.h\"\n #include \"xla/service/llvm_ir/llvm_util.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -143,8 +147,16 @@ class IntrinsicAdapter : public IntrinsicFunction {\n   }\n };\n \n-IntrinsicFunctionLib::IntrinsicFunctionLib(IntrinsicOptions options)\n+IntrinsicFunctionLib::IntrinsicFunctionLib(const IntrinsicOptions& options)\n     : options_(options) {\n+  if (options.device_type == intrinsics::DeviceType::kIntelCpu ||\n+      options.device_type == intrinsics::DeviceType::kAmdCpu ||\n+      options.device_type == intrinsics::DeviceType::kArmCpu) {\n+    auto eigen_lib = std::make_unique<CppGenIntrinsicLibrary>(\n+        GetCppGenIrString(options), \"eigen\");\n+    ir_libraries_.push_back(std::move(eigen_lib));\n+  }\n+\n   intrinsic_functions_.push_back(\n       std::make_unique<IntrinsicAdapter<intrinsics::Ldexp>>());\n   intrinsic_functions_.push_back(\n@@ -217,10 +229,12 @@ std::vector<llvm::VecDesc> IntrinsicFunctionLib::Vectorizations() {\n   for (const auto& math_func : intrinsic_functions_) {\n     // For each floating point type supported, we add all vector widths to every\n     // other vector width as a possible vectorization.\n-    for (const auto& target_types :\n-         math_func->SupportedVectorTypes(options_.features)) {\n-      for (const auto& vector_types :\n-           math_func->SupportedVectorTypes(options_.features)) {\n+    std::vector<std::vector<Type>> supported_types =\n+        math_func->SupportedVectorTypes(options_.features);\n+    for (int i = 0; i < supported_types.size(); ++i) {\n+      const std::vector<Type>& target_types = supported_types[i];\n+      for (int j = 0; j < supported_types.size(); ++j) {\n+        const std::vector<Type>& vector_types = supported_types[j];\n         if (!ElementTypesMatch(target_types, vector_types) ||\n             target_types.front().is_vector()) {\n           continue;\n@@ -229,6 +243,8 @@ std::vector<llvm::VecDesc> IntrinsicFunctionLib::Vectorizations() {\n             math_func->GenerateVectorizedFunctionName(target_types));\n         absl::string_view vec_name = intrinsic::StringInterner::Get().Intern(\n             math_func->GenerateVectorizedFunctionName(vector_types));\n+        CHECK(targets_.find(vec_name) == targets_.end())\n+            << \"Duplicate implementations for \" << vec_name;\n         targets_[vec_name] = math_func->FunctionName();\n         if (target_name == vec_name) {\n           continue;\n@@ -275,16 +291,21 @@ void CreateDefinitionAndReplaceDeclaration(llvm::Module& module,\n \n absl::flat_hash_set<absl::string_view>\n IntrinsicFunctionLib::DefineIntrinsicFunctions(llvm::Module& module) {\n+  bool ir_libraries_linked = false;\n   // Find each called target function, generate the definition and insert it\n   // into the module.\n-  // Keep track of the function names we replaced so we can remove them from\n-  // llvm.compiler.used later.\n   absl::flat_hash_set<absl::string_view> replaced_functions;\n   for (const auto& [function_name, signatures] :\n        GetCalledApproximatableFunctions(module, targets_)) {\n     for (const auto& math_func : intrinsic_functions_) {\n       if (math_func->FunctionName() == function_name) {\n         for (const auto& signature : signatures) {\n+          if (!ir_libraries_linked) {\n+            for (const auto& lib : ir_libraries_) {\n+              lib->LinkIntoModule(module);\n+            }\n+          }\n+\n           CreateDefinitionAndReplaceDeclaration(module, signature, options_,\n                                                 *math_func);\n           replaced_functions.insert(signature);\n@@ -293,8 +314,9 @@ IntrinsicFunctionLib::DefineIntrinsicFunctions(llvm::Module& module) {\n     }\n   }\n \n-  CHECK(!llvm::verifyModule(module)) << \"Module is invalid after optimization\\n\"\n-                                     << llvm_ir::DumpToString(&module);\n+  CHECK(!llvm::verifyModule(module, &llvm::errs()))\n+      << \"Module is invalid after optimization\\n\"\n+      << llvm_ir::DumpToString(&module);\n   return replaced_functions;\n }\n "
        },
        {
            "sha": "2c69dc29a310b374df8ff7a436be6d815c67961d",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/IR/Module.h\"\n+#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n #include \"xla/codegen/intrinsic/intrinsic.h\"\n #include \"xla/codegen/intrinsic_function.h\"\n #include \"xla/xla_data.pb.h\"\n@@ -41,7 +42,7 @@ namespace xla::codegen {\n // Retains storage of the strings required for VecDescs in the instance.\n class IntrinsicFunctionLib {\n  public:\n-  explicit IntrinsicFunctionLib(intrinsics::IntrinsicOptions options);\n+  explicit IntrinsicFunctionLib(const intrinsics::IntrinsicOptions& options);\n \n   // Returns a vector of vectorization information for functions that have\n   // vectorized approximations. This enables LLVM vectorization\n@@ -62,6 +63,7 @@ class IntrinsicFunctionLib {\n   std::vector<std::unique_ptr<IntrinsicFunction>> intrinsic_functions_;\n   absl::flat_hash_map<absl::string_view, absl::string_view> targets_;\n   const intrinsics::IntrinsicOptions options_;\n+  std::vector<std::unique_ptr<CppGenIntrinsicLibrary>> ir_libraries_;\n };\n \n }  // namespace xla::codegen"
        },
        {
            "sha": "e74cc41a9b5f03e4433a63795a819771202aa9a4",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e750c4df886f3aaa805fec49f87f88d2db4c4295/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib_test.cc?ref=e750c4df886f3aaa805fec49f87f88d2db4c4295",
            "patch": "@@ -20,7 +20,6 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n-#include \"absl/strings/match.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n@@ -45,7 +44,7 @@ TEST(IntrinsicLibTest, ExpVectorizations) {\n   std::vector<llvm::VecDesc> vec_descs = lib.Vectorizations();\n   std::vector<std::string> vec_descs_str;\n   for (const auto& vec_desc : vec_descs) {\n-    if (absl::StrContains(vec_desc.getScalarFnName().str(), \"xla.exp\")) {\n+    if (vec_desc.getScalarFnName().starts_with(\"xla.exp\")) {\n       vec_descs_str.push_back(ToString(vec_desc));\n     }\n   }\n@@ -55,7 +54,6 @@ TEST(IntrinsicLibTest, ExpVectorizations) {\n                                  \"xla.exp.f64:xla.exp.v4f64:4:_ZGV_LLVM_N4v\",\n                                  \"xla.exp.f64:xla.exp.v8f64:8:_ZGV_LLVM_N8v\"));\n }\n-\n }  // namespace\n \n }  // namespace xla::codegen::intrinsics"
        }
    ],
    "stats": {
        "total": 457,
        "additions": 405,
        "deletions": 52
    }
}