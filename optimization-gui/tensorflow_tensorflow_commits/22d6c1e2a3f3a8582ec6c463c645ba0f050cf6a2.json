{
    "author": "tensorflower-gardener",
    "message": "Add a runtime executable version method to IFRT API.\n\nExecutable and Compiler return an opaque string that can later be used by Compiler to verify if a serialized executable would be compatible.\n\nPiperOrigin-RevId: 806459626",
    "sha": "22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
    "files": [
        {
            "sha": "6bd622d0506374a1802eecbbd15cc1cf3a8de77a",
            "filename": "third_party/xla/xla/backends/cpu/nanort/ifrt_client.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client.cc?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -907,6 +907,11 @@ class NanoExecutable final\n     return absl::UnimplementedError(\"Fingerprint is not implemented.\");\n   }\n \n+  absl::StatusOr<std::unique_ptr<xla::ifrt::ExecutableVersion>>\n+  executable_version() const override {\n+    return absl::UnimplementedError(\"executable_version is not implemented.\");\n+  }\n+\n   absl::StatusOr<std::string> Serialize() const override {\n     return absl::UnimplementedError(\"Serialize is not implemented.\");\n   }\n@@ -1180,6 +1185,12 @@ class NanoCompiler final\n     return absl::UnimplementedError(\"Partial compilation is not implemented.\");\n   }\n \n+  absl::Status IsExecutableVersionCompatible(\n+      const xla::ifrt::ExecutableVersion& executable_version,\n+      const xla::ifrt::DeviceListRef& devices) const override {\n+    return absl::UnimplementedError(\"Not implemented\");\n+  }\n+\n   absl::StatusOr<ifrt::LoadedExecutableRef> DeserializeLoadedExecutable(\n       absl::string_view serialized,\n       std::unique_ptr<ifrt::DeserializeExecutableOptions> options) override {"
        },
        {
            "sha": "2aa86d18ad36ccfab5a9a1c1aa7002f496e6f945",
            "filename": "third_party/xla/xla/python/compile_only_ifrt/client.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fcompile_only_ifrt%2Fclient.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fcompile_only_ifrt%2Fclient.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fcompile_only_ifrt%2Fclient.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -171,6 +171,12 @@ class CompileOnlyIfrtCompiler final\n     return Unimplemented(\"Compile not implemented.\");\n   }\n \n+  absl::Status IsExecutableVersionCompatible(\n+      const xla::ifrt::ExecutableVersion& executable_version,\n+      const xla::ifrt::DeviceListRef& devices) const override {\n+    return absl::UnimplementedError(\"Not implemented\");\n+  }\n+\n   absl::StatusOr<ifrt::LoadedExecutableRef> DeserializeLoadedExecutable(\n       absl::string_view serialized,\n       std::unique_ptr<ifrt::DeserializeExecutableOptions> options) override {"
        },
        {
            "sha": "e839487c88c9d809f4af9edd61a1362b463f548b",
            "filename": "third_party/xla/xla/python/ifrt/compiler.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fcompiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fcompiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fcompiler.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -17,12 +17,14 @@ limitations under the License.\n #define XLA_PYTHON_IFRT_COMPILER_H_\n \n #include <memory>\n+#include <string>\n #include <utility>\n \n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/executable.h\"\n #include \"xla/python/ifrt/executable_serdes.h\"\n #include \"xla/python/ifrt/program.h\"\n@@ -70,6 +72,12 @@ class Compiler : public llvm::RTTIExtends<Compiler, llvm::RTTIRoot> {\n       std::unique_ptr<Program> program,\n       std::unique_ptr<CompileOptions> options) = 0;\n \n+  // Checks if an executable version is compatible if the executable would be\n+  // loaded onto specified `devices`.\n+  virtual absl::Status IsExecutableVersionCompatible(\n+      const ExecutableVersion& executable_version,\n+      const DeviceListRef& devices) const = 0;\n+\n   // Deserializes a serialized executable as produced by\n   // `LoadedExecutable::Serialize()`. The compatibility of `serialized` is\n   // implementation specific."
        },
        {
            "sha": "2e3c10971c45aae0a4935bb19677accdcb6cf547",
            "filename": "third_party/xla/xla/python/ifrt/executable.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.cc?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -29,6 +29,7 @@ namespace ifrt {\n \n char Executable::ID = 0;\n char LoadedExecutable::ID = 0;\n+[[maybe_unused]] char ExecutableVersion::ID = 0;\n \n absl::StatusOr<ExecuteOptionsProto> ExecuteOptions::ToProto(\n     SerDesVersion version) const {"
        },
        {
            "sha": "9ed31faacc422d8921fc46cac0d377f17a5a247a",
            "filename": "third_party/xla/xla/python/ifrt/executable.h",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -36,6 +36,7 @@ limitations under the License.\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/execute_options.pb.h\"\n #include \"xla/python/ifrt/future.h\"\n+#include \"xla/python/ifrt/serdes.h\"\n #include \"xla/python/ifrt/serdes_default_version_accessor.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n #include \"xla/python/ifrt/user_context.h\"\n@@ -48,6 +49,15 @@ class Client;\n struct CompileOptions;\n struct DeserializeExecutableOptions;\n \n+struct ExecutableVersion : llvm::RTTIExtends<ExecutableVersion, Serializable> {\n+  // Returns true iff this version is compatible with `other`. The logic for\n+  // checking the version compatibility is an implementation detail of\n+  // `ExecutableVersion` subclasses.\n+  virtual bool IsCompatibleWith(const ExecutableVersion& other) const = 0;\n+\n+  static char ID;  // NOLINT\n+};\n+\n // Wraps a computation that has been partially compiled and can be loaded.\n class Executable : public llvm::RTTIExtends<Executable, llvm::RTTIRoot> {\n  public:\n@@ -158,6 +168,11 @@ class LoadedExecutable\n   // Returns a fingerprint of this executable.\n   virtual absl::StatusOr<std::optional<std::string>> Fingerprint() const = 0;\n \n+  // Returns the executable version that can be used for verifying the\n+  // compatibility with a runtime.\n+  virtual absl::StatusOr<std::unique_ptr<ExecutableVersion>>\n+  executable_version() const = 0;\n+\n   // Serializes this executable into a string. The compatibility of the\n   // serialized executable is implementation-specific.\n   virtual absl::StatusOr<std::string> Serialize() const = 0;"
        },
        {
            "sha": "9731e016e6922608f713c91c6ec6b0c40b1b8e12",
            "filename": "third_party/xla/xla/python/ifrt/mock.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -208,6 +208,10 @@ class MockCompiler : public llvm::RTTIExtends<MockCompiler, Compiler> {\n               (std::unique_ptr<Program> program,\n                std::unique_ptr<CompileOptions> options),\n               (final));\n+  MOCK_METHOD(absl::Status, IsExecutableVersionCompatible,\n+              (const xla::ifrt::ExecutableVersion& executable_version,\n+               const xla::ifrt::DeviceListRef& devices),\n+              (const, final));\n   MOCK_METHOD(absl::StatusOr<LoadedExecutableRef>, DeserializeLoadedExecutable,\n               (absl::string_view serialized,\n                std::unique_ptr<DeserializeExecutableOptions> options),\n@@ -299,6 +303,8 @@ class MockLoadedExecutable\n   MOCK_METHOD(absl::string_view, name, (), (const, final));\n   MOCK_METHOD(absl::StatusOr<std::optional<std::string>>, Fingerprint, (),\n               (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::unique_ptr<xla::ifrt::ExecutableVersion>>,\n+              executable_version, (), (const, final));\n   MOCK_METHOD(absl::StatusOr<std::string>, Serialize, (), (const, final));\n   MOCK_METHOD(UserContextRef, user_context, (), (const, final));\n   MOCK_METHOD(Future<>, GetReadyFuture, (), (const, override));"
        },
        {
            "sha": "4381912f04a42ac8bca6a50639497d3a51679fd4",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/compiler.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -19,11 +19,13 @@\n \n #include <memory>\n \n+#include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/python/ifrt/client.h\"\n #include \"xla/python/ifrt/compiler.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/executable.h\"\n #include \"xla/python/ifrt/program.h\"\n #include \"xla/python/ifrt/topology.h\"\n@@ -47,6 +49,12 @@ class Compiler final : public llvm::RTTIExtends<Compiler, xla::ifrt::Compiler> {\n       std::unique_ptr<Program> program, const Topology& topology,\n       std::unique_ptr<CompileOptions> options) override;\n \n+  absl::Status IsExecutableVersionCompatible(\n+      const xla::ifrt::ExecutableVersion& executable_version,\n+      const xla::ifrt::DeviceListRef& devices) const override {\n+    return absl::UnimplementedError(\"Not implemented\");\n+  }\n+\n   absl::StatusOr<xla::ifrt::LoadedExecutableRef> DeserializeLoadedExecutable(\n       absl::string_view serialized,\n       std::unique_ptr<xla::ifrt::DeserializeExecutableOptions> options)"
        },
        {
            "sha": "6b7823cdecc7561eb8db75e5542e75a522cd9560",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/executable.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -72,6 +72,10 @@ class LoadedExecutable final\n   xla::ifrt::Client* client() const override;\n   absl::string_view name() const override;\n   absl::StatusOr<std::optional<std::string>> Fingerprint() const override;\n+  absl::StatusOr<std::unique_ptr<xla::ifrt::ExecutableVersion>>\n+  executable_version() const override {\n+    return absl::UnimplementedError(\"Not implemented\");\n+  }\n   absl::StatusOr<std::string> Serialize() const override;\n   xla::ifrt::UserContextRef user_context() const override {\n     return user_context_;"
        },
        {
            "sha": "b40310d36a493245487fb094b0652efa0a5248ea",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/BUILD",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -124,6 +124,40 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"xla_executable_version\",\n+    srcs = [\"xla_executable_version.cc\"],\n+    hdrs = [\"xla_executable_version.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    deps = [\n+        \":executable_metadata_proto_cc\",\n+        \"//xla/python/ifrt\",\n+        \"//xla/python/ifrt:serdes_default_version_accessor\",\n+        \"//xla/python/ifrt:serdes_version\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@llvm-project//llvm:Support\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"xla_executable_version_serdes\",\n+    srcs = [\"xla_executable_version_serdes.cc\"],\n+    compatible_with = get_compatible_with_portable(),\n+    deps = [\n+        \":executable_metadata_proto_cc\",\n+        \":xla_executable_version\",\n+        \"//xla/python/ifrt:serdes\",\n+        \"//xla/python/ifrt:serdes_version\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@llvm-project//llvm:Support\",\n+    ],\n+    alwayslink = True,\n+)\n+\n tf_proto_library(\n     name = \"executable_metadata_proto\",\n     srcs = [\"executable_metadata.proto\"],\n@@ -155,6 +189,7 @@ cc_library(\n         \"//xla/python/ifrt:test_util\",\n         \"//xla/python/ifrt:user_context\",\n         \"//xla/python/ifrt/hlo:hlo_program\",\n+        \"//xla/python/pjrt_ifrt:xla_executable_version\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n@@ -276,6 +311,7 @@ cc_library(\n         \":pjrt_attribute_map_util\",\n         \":pjrt_dtype\",\n         \":transfer_server_interface\",\n+        \":xla_executable_version_serdes\",\n         \":xla_ifrt\",\n         \"//xla:literal\",\n         \"//xla:shape_util\","
        },
        {
            "sha": "ec8bf93bc8772139f34364519381a742a44c792a",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/executable_metadata.proto",
            "status": "modified",
            "additions": 16,
            "deletions": 8,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fexecutable_metadata.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fexecutable_metadata.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fexecutable_metadata.proto?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -22,6 +22,17 @@ import \"xla/python/ifrt/layout.proto\";\n import \"xla/python/ifrt/shape.proto\";\n import \"xla/xla_data.proto\";\n \n+// Proto equivalent of C++ `XlaExecutableVersion`.\n+message SerializedXlaExecutableVersion {\n+  // Serialization and deserialization version.\n+  int32 version_number = 1;\n+  // ID that identifies the platform (CPU/GPU/TPU). This corresponds to\n+  // xla::PjRtPlatformId.\n+  fixed64 platform_id = 2;\n+  // Opaque string that identifies the runtime ABI version.\n+  bytes runtime_abi_version = 3;\n+}\n+\n // This is the definition of a standard format for serializing XLA executables\n // in IFRT in a way that is portable across IFRT runtimes that support XLA.\n //\n@@ -46,21 +57,18 @@ import \"xla/xla_data.proto\";\n // runtimes are validated in\n // tensorflow/compiler/xla/python/pjrt_ifrt/xla_executable_impl_test_lib.cc.\n message SerializedXlaExecutableMetadata {\n+  reserved 3, 4;\n+\n   // IFRT version\n   int32 ifrt_version_number = 1;\n \n+  // The runtime ABI version at the time this executable was created.\n+  SerializedXlaExecutableVersion executable_version = 9;\n+\n   // IFRT runtime that created this executable. Loading executables across\n   // runtimes are supported.\n   string runtime_name = 2;\n \n-  // ID that identifies the platform (CPU/GPU/TPU). This corresponds to\n-  // xla::PjRtPlatformId.\n-  fixed64 platform_id = 3;\n-\n-  // ABI version of the runtime that this executable is compatible with.\n-  // Note: Also present within the serialized executable for PjRt TPU.\n-  bytes runtime_abi_version = 4;\n-\n   // Name of the computation that this executable represents. This is not a\n   // unique identifier of the computation. Only to be used for debugging and\n   // logging purposes."
        },
        {
            "sha": "99c21d2d368ed888faf752e49ad8b17b79477dc3",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_compiler.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_compiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_compiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_compiler.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -18,10 +18,12 @@ limitations under the License.\n \n #include <memory>\n \n+#include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/python/ifrt/compiler.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/executable.h\"\n #include \"xla/python/ifrt/program.h\"\n #include \"xla/python/ifrt/topology.h\"\n@@ -51,6 +53,12 @@ class PjRtCompiler final : public llvm::RTTIExtends<PjRtCompiler, Compiler> {\n       std::unique_ptr<Program> program, const Topology& topology,\n       std::unique_ptr<CompileOptions> options) override;\n \n+  absl::Status IsExecutableVersionCompatible(\n+      const xla::ifrt::ExecutableVersion& executable_version,\n+      const xla::ifrt::DeviceListRef& devices) const override {\n+    return absl::UnimplementedError(\"Not implemented\");\n+  }\n+\n   absl::StatusOr<LoadedExecutableRef> DeserializeLoadedExecutable(\n       absl::string_view serialized,\n       std::unique_ptr<DeserializeExecutableOptions> options) override;"
        },
        {
            "sha": "08eabaf52cc8a83cac898d890418e4a9a9cb6fe6",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_executable.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_executable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_executable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_executable.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -47,7 +47,6 @@ limitations under the License.\n #include \"xla/python/pjrt_ifrt/pjrt_attribute_map_util.h\"\n #include \"xla/python/pjrt_ifrt/pjrt_client.h\"\n #include \"xla/python/pjrt_ifrt/pjrt_host_callback.h\"\n-#include \"xla/python/pjrt_ifrt/xla_compiler.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n@@ -262,6 +261,11 @@ class PjRtLoadedExecutable final\n \n   absl::StatusOr<std::optional<std::string>> Fingerprint() const override;\n \n+  absl::StatusOr<std::unique_ptr<xla::ifrt::ExecutableVersion>>\n+  executable_version() const override {\n+    return absl::UnimplementedError(\"Not implemented\");\n+  }\n+\n   absl::StatusOr<std::string> Serialize() const override;\n \n   int num_devices() const override {"
        },
        {
            "sha": "fce05461f6c88dc8266b95d3abeb8ed3cec72b87",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/xla_executable_impl_test_lib.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -52,6 +52,7 @@ limitations under the License.\n #include \"xla/python/pjrt_ifrt/executable_metadata.pb.h\"\n #include \"xla/python/pjrt_ifrt/pjrt_layout.h\"\n #include \"xla/python/pjrt_ifrt/xla_compiler.h\"\n+#include \"xla/python/pjrt_ifrt/xla_executable_version.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n@@ -73,6 +74,7 @@ using ::testing::Not;\n using ::testing::Optional;\n using ::testing::SizeIs;\n using ::testing::UnorderedElementsAre;\n+using ::tsl::proto_testing::EqualsProto;\n using ::tsl::proto_testing::EquivToProto;\n \n // Serialized `ModuleOp` that does add 1.\n@@ -626,12 +628,16 @@ TEST(ExecutableTest, ExecutableSerialization) {\n   ASSERT_TRUE(google::protobuf::util::ParseDelimitedFromZeroCopyStream(\n       &metadata, &input_stream, nullptr));\n \n-  // TODO(b/409317760): Compare version number to the runtime version number\n-  // when version query API is available.\n-  EXPECT_EQ(metadata.ifrt_version_number(), 0);\n-  EXPECT_FALSE(metadata.runtime_abi_version().empty());\n+  TF_ASSERT_OK_AND_ASSIGN(auto executable_version,\n+                          loaded_executable->executable_version());\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto xla_executable_version,\n+      xla::ifrt::ToXlaExecutableVersion(std::move(executable_version)));\n+  TF_ASSERT_OK_AND_ASSIGN(auto serialized_xla_executable_version,\n+                          xla_executable_version->ToProto());\n+  EXPECT_THAT(metadata.executable_version(),\n+              EqualsProto(serialized_xla_executable_version));\n \n-  EXPECT_NE(metadata.platform_id(), 0);\n   EXPECT_EQ(metadata.computation_name(), \"add_sub\");\n \n   int kNumOutputs = 2;"
        },
        {
            "sha": "1dd76b36961a08c8d8280beef15754d6dfa157f9",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/xla_executable_version.cc",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version.cc?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -0,0 +1,98 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/pjrt_ifrt/xla_executable_version.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"llvm/Support/Casting.h\"\n+#include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/python/pjrt_ifrt/executable_metadata.pb.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+[[maybe_unused]] char XlaExecutableVersion::ID = 0;\n+\n+XlaExecutableVersion::XlaExecutableVersion(uint64_t platform_id,\n+                                           std::string runtime_abi_version)\n+    : platform_id(platform_id),\n+      runtime_abi_version(std::move(runtime_abi_version)) {}\n+\n+bool XlaExecutableVersion::IsCompatibleWith(\n+    const ExecutableVersion& other) const {\n+  if (this == &other) {\n+    return true;\n+  }\n+  if (auto other_xla_executable_version =\n+          llvm::dyn_cast<XlaExecutableVersion>(&other)) {\n+    return platform_id == other_xla_executable_version->platform_id &&\n+           runtime_abi_version ==\n+               other_xla_executable_version->runtime_abi_version;\n+  }\n+  return false;\n+}\n+\n+absl::StatusOr<SerializedXlaExecutableVersion> XlaExecutableVersion::ToProto(\n+    SerDesVersion version) const {\n+  if (version.version_number() < SerDesVersionNumber(0)) {\n+    return absl::FailedPreconditionError(\n+        absl::StrCat(\"Unsupported \", version.version_number(),\n+                     \" for XlaExecutableVersion serialization\"));\n+  }\n+\n+  SerializedXlaExecutableVersion executable_version_proto;\n+  executable_version_proto.set_version_number(SerDesVersionNumber(0).value());\n+  executable_version_proto.set_platform_id(platform_id);\n+  executable_version_proto.set_runtime_abi_version(runtime_abi_version);\n+\n+  return executable_version_proto;\n+}\n+\n+absl::StatusOr<std::unique_ptr<XlaExecutableVersion>>\n+XlaExecutableVersion::FromProto(const SerializedXlaExecutableVersion& proto) {\n+  const SerDesVersionNumber version_number(proto.version_number());\n+  if (version_number != SerDesVersionNumber(0)) {\n+    return absl::FailedPreconditionError(\n+        absl::StrCat(\"Unsupported \", version_number,\n+                     \" for XlaExecutableVersion deserialization\"));\n+  }\n+  return std::make_unique<XlaExecutableVersion>(proto.platform_id(),\n+                                                proto.runtime_abi_version());\n+}\n+\n+absl::StatusOr<std::unique_ptr<XlaExecutableVersion>> ToXlaExecutableVersion(\n+    std::unique_ptr<ExecutableVersion> executable_version) {\n+  if (!executable_version) {\n+    return absl::InvalidArgumentError(\"executable_version is null\");\n+  }\n+  if (auto* xla_executable_version =\n+          llvm::dyn_cast<XlaExecutableVersion>(executable_version.get())) {\n+    executable_version.release();\n+    return std::unique_ptr<XlaExecutableVersion>(xla_executable_version);\n+  }\n+  return absl::InvalidArgumentError(\n+      \"executable_version is not XlaExecutableVersion\");\n+}\n+\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "0db586995d06d99e13ad4566cee574ff61c96083",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/xla_executable_version.h",
            "status": "added",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version.h?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -0,0 +1,60 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PYTHON_PJRT_IFRT_XLA_EXECUTABLE_VERSION_H_\n+#define XLA_PYTHON_PJRT_IFRT_XLA_EXECUTABLE_VERSION_H_\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/serdes_default_version_accessor.h\"\n+#include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/python/pjrt_ifrt/executable_metadata.pb.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+struct XlaExecutableVersion\n+    : llvm::RTTIExtends<XlaExecutableVersion, ExecutableVersion> {\n+  XlaExecutableVersion() = default;\n+  XlaExecutableVersion(uint64_t platform_id, std::string runtime_abi_version);\n+\n+  // ID that identifies the platform (CPU/GPU/TPU). This corresponds to\n+  // xla::PjRtPlatformId.\n+  uint64_t platform_id;\n+  // Opaque string that identifies the runtime ABI version.\n+  std::string runtime_abi_version;\n+\n+  bool IsCompatibleWith(const ExecutableVersion& other) const override;\n+\n+  absl::StatusOr<SerializedXlaExecutableVersion> ToProto(\n+      SerDesVersion version = SerDesVersion::current()) const;\n+  static absl::StatusOr<std::unique_ptr<XlaExecutableVersion>> FromProto(\n+      const SerializedXlaExecutableVersion& proto);\n+\n+  static char ID;  // NOLINT\n+};\n+\n+absl::StatusOr<std::unique_ptr<XlaExecutableVersion>> ToXlaExecutableVersion(\n+    std::unique_ptr<ExecutableVersion> executable_version);\n+\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_PJRT_IFRT_XLA_EXECUTABLE_VERSION_H_"
        },
        {
            "sha": "564f06fbab639611d471dc170f8c7ab91b1e47ee",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/xla_executable_version_serdes.cc",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version_serdes.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version_serdes.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_version_serdes.cc?ref=22d6c1e2a3f3a8582ec6c463c645ba0f050cf6a2",
            "patch": "@@ -0,0 +1,84 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/Support/Casting.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/serdes.h\"\n+#include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/python/pjrt_ifrt/executable_metadata.pb.h\"\n+#include \"xla/python/pjrt_ifrt/xla_executable_version.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace {\n+\n+class XlaExecutableVersionSerDes\n+    : public llvm::RTTIExtends<XlaExecutableVersionSerDes, SerDes> {\n+ public:\n+  absl::string_view type_name() const override {\n+    return \"xla::ifrt::XlaExecutableVersion\";\n+  }\n+\n+  absl::StatusOr<std::string> Serialize(\n+      const Serializable& serializable,\n+      std::unique_ptr<SerializeOptions> options) override {\n+    const SerDesVersion version = GetRequestedSerDesVersion(options.get());\n+\n+    const XlaExecutableVersion& executable_version =\n+        llvm::cast<XlaExecutableVersion>(serializable);\n+\n+    absl::StatusOr<SerializedXlaExecutableVersion> executable_version_proto =\n+        executable_version.ToProto(version);\n+    if (!executable_version_proto.ok()) {\n+      return executable_version_proto.status();\n+    }\n+\n+    return executable_version_proto.value().SerializeAsString();\n+  }\n+\n+  absl::StatusOr<std::unique_ptr<Serializable>> Deserialize(\n+      const std::string& serialized,\n+      std::unique_ptr<DeserializeOptions> options) override {\n+    SerializedXlaExecutableVersion executable_version_proto;\n+    if (!executable_version_proto.ParseFromString(serialized)) {\n+      return absl::InvalidArgumentError(\n+          \"Failed to parse ExecutableVersionProto\");\n+    }\n+    return XlaExecutableVersion::FromProto(executable_version_proto);\n+  }\n+\n+  XlaExecutableVersionSerDes() = default;\n+  ~XlaExecutableVersionSerDes() override = default;\n+\n+  static char ID;  // NOLINT\n+};\n+\n+}  // namespace\n+\n+[[maybe_unused]] char XlaExecutableVersionSerDes::ID = 0;\n+\n+bool register_executable_version_serdes = ([]{\n+    RegisterSerDes<XlaExecutableVersion>(\n+      std::make_unique<XlaExecutableVersionSerDes>());\n+}(), true);\n+\n+}  // namespace ifrt\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 391,
        "additions": 377,
        "deletions": 14
    }
}