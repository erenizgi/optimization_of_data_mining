{
    "author": "pschuh",
    "message": "Update PremappedCopierState::FlushReadyWorkItemsInOrder to ensure on_done gests\ndestroyed as part of invocation.\n\nPiperOrigin-RevId: 827739079",
    "sha": "3f42c015233a229a50c169b4a155f280c77a69fa",
    "files": [
        {
            "sha": "f4cda2bd3488e8cab31a340fa1bf97f827185c49",
            "filename": "third_party/xla/xla/python/transfer/streaming_ifrt.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3f42c015233a229a50c169b4a155f280c77a69fa/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fstreaming_ifrt.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3f42c015233a229a50c169b4a155f280c77a69fa/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fstreaming_ifrt.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fstreaming_ifrt.cc?ref=3f42c015233a229a50c169b4a155f280c77a69fa",
            "patch": "@@ -201,12 +201,13 @@ void PremappedCopierState::FlushReadyWorkItemsInOrder() {\n     }\n     currently_flushing_ = true;\n     mu_.unlock();\n-    if (work_item->result_status.ok()) {\n-      std::move(work_item->on_done)(this, work_item->dest_buffer,\n-                                    work_item->work);\n-    } else {\n-      std::move(work_item->on_done)(this, work_item->result_status,\n-                                    work_item->work);\n+    {\n+      auto on_done_fn = std::move(work_item->on_done);\n+      if (work_item->result_status.ok()) {\n+        std::move(on_done_fn)(this, work_item->dest_buffer, work_item->work);\n+      } else {\n+        std::move(on_done_fn)(this, work_item->result_status, work_item->work);\n+      }\n     }\n     mu_.lock();\n     currently_flushing_ = false;"
        },
        {
            "sha": "c1d57b2da99daa07197e8bc231972a091d828d2e",
            "filename": "third_party/xla/xla/python/transfer/streaming_ifrt_test.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 18,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3f42c015233a229a50c169b4a155f280c77a69fa/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fstreaming_ifrt_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3f42c015233a229a50c169b4a155f280c77a69fa/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fstreaming_ifrt_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fstreaming_ifrt_test.cc?ref=3f42c015233a229a50c169b4a155f280c77a69fa",
            "patch": "@@ -165,20 +165,23 @@ TEST(PremappedCopierState, FreeCycle) {\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto scratch, AllocateAndMapPjrtMemory(pjrt_client, 1024 * 1024 * 16));\n   auto cstate = std::make_shared<PremappedCopierState>(scratch, 4, 4096);\n-  void* buffer_to_return = nullptr;\n-  cstate->ScheduleCopy({/*copy_fn=*/[](void* dst, int64_t offset,\n-                                       int64_t transfer_size) -> xla::Future<> {\n-                          return xla::Future<>(absl::OkStatus());\n-                        },\n-                        /*buffer_id=*/0,\n-                        /*offset=*/100,\n-                        /*size=*/100},\n-                       [&buffer_to_return](PremappedCopierState* state,\n-                                           absl::StatusOr<void*> buf,\n-                                           const DmaCopyChunk& chunk) {\n-                         TF_CHECK_OK(buf.status());\n-                         buffer_to_return = buf.value();\n-                       });\n+  std::vector<void*> buffers_to_return;\n+  for (size_t i = 0; i < 2; ++i) {\n+    cstate->ScheduleCopy(\n+        {/*copy_fn=*/[](void* dst, int64_t offset,\n+                        int64_t transfer_size) -> xla::Future<> {\n+           return xla::Future<>(absl::OkStatus());\n+         },\n+         /*buffer_id=*/0,\n+         /*offset=*/100,\n+         /*size=*/100},\n+        [&buffers_to_return](PremappedCopierState* state,\n+                             absl::StatusOr<void*> buf,\n+                             const DmaCopyChunk& chunk) {\n+          TF_CHECK_OK(buf.status());\n+          buffers_to_return.push_back(buf.value());\n+        });\n+  }\n   class BufferReturner {\n    public:\n     explicit BufferReturner(absl::AnyInvocable<void() &&> on_done)\n@@ -190,17 +193,19 @@ TEST(PremappedCopierState, FreeCycle) {\n   };\n   cstate->ScheduleCopy(\n       {/*copy_fn=*/[buffer = std::make_unique<BufferReturner>(\n-                        [buffer_to_return, cstate]() {\n-                          cstate->ReturnBuffer(buffer_to_return);\n+                        [b = buffers_to_return[0], cstate]() {\n+                          cstate->ReturnBuffer(b);\n                         })](void* dst, int64_t offset,\n                             int64_t transfer_size) -> xla::Future<> {\n          return xla::Future<>(absl::OkStatus());\n        },\n        /*buffer_id=*/0,\n        /*offset=*/100,\n        /*size=*/100},\n-      [](PremappedCopierState* state, absl::StatusOr<void*> buf,\n-         const DmaCopyChunk& chunk) {\n+      [buffer = std::make_unique<BufferReturner>(\n+           [b = buffers_to_return[1], cstate]() { cstate->ReturnBuffer(b); })](\n+          PremappedCopierState* state, absl::StatusOr<void*> buf,\n+          const DmaCopyChunk& chunk) {\n         TF_CHECK_OK(buf.status());\n         state->ReturnBuffer(buf.value());\n       });"
        }
    ],
    "stats": {
        "total": 54,
        "additions": 30,
        "deletions": 24
    }
}