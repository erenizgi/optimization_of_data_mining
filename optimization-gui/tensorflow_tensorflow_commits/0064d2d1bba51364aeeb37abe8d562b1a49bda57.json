{
    "author": "mkuperst",
    "message": "Rolling forward with fix.\n\nReverts eefde231948bd6bee00f1d8f9e521b0f7ce22e50\n\nPiperOrigin-RevId: 819210668",
    "sha": "0064d2d1bba51364aeeb37abe8d562b1a49bda57",
    "files": [
        {
            "sha": "5c79393d3033c8b46d828ae11e721b665a3ae86e",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module_group.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.cc?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -87,10 +87,8 @@ HloModuleGroupProto HloModuleGroup::ToProto() const {\n   return HloModuleGroup(std::move(module));\n }\n \n-void HloModuleGroup::ReplaceModule(int index,\n-                                   std::unique_ptr<HloModule> module) {\n-  CHECK_EQ(index, 0);\n-  module_->MoveMetadataToModule(module.get());\n+void HloModuleGroup::AddModule(std::unique_ptr<HloModule> module) {\n+  CHECK_EQ(module_, nullptr);\n   module_ = std::move(module);\n }\n "
        },
        {
            "sha": "63fba3704d07f7e987b8d1951905599e25d10c7c",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module_group.h",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.h?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -54,9 +54,8 @@ class HloModuleGroup {\n     return *module_;\n   }\n \n-  // Replaces the existing module at the given index with the given module. The\n-  // existing module is discarded.\n-  void ReplaceModule(int index, std::unique_ptr<HloModule> module);\n+  // Adds a module to the group, taking ownership of it.\n+  void AddModule(std::unique_ptr<HloModule> module);\n \n   // Moves all modules from the group into the returned vector. After this\n   // method runs, the module group will be empty."
        },
        {
            "sha": "bb9773a3282ae7f5c6da020aa885a0011fbd0faa",
            "filename": "third_party/xla/xla/hlo/pass/README.md",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2FREADME.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2FREADME.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2FREADME.md?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -13,9 +13,8 @@ Defines the foundational classes for HLO passes:\n * `HloPassInterface`: Abstract base class for all HLO passes.\n * `HloModulePass`: Subclass for passes that operate on individual HloModules.\n \n-Provides core methods like `Run`, `RunOnModuleGroup`, and\n-`RunOnChangedComputations` that passes must implement to perform their\n-transformations.\n+Provides core methods like `Run`, and`RunOnChangedComputations` that passes must\n+implement to perform their transformations.\n \n ### `hlo_pass_fix.h`\n "
        },
        {
            "sha": "8f143319d767f39f920ca49946f6cfdcd037c1ca",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_fix.h",
            "status": "modified",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_fix.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_fix.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_fix.h?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -73,46 +73,6 @@ class HloPassFix : public Pass {\n     return !run_state.changed.empty();\n   }\n \n-  using HloPassInterface::RunOnModuleGroup;\n-  absl::StatusOr<bool> RunOnModuleGroup(\n-      HloModuleGroup* module_group,\n-      const absl::flat_hash_set<absl::string_view>& execution_threads)\n-      override {\n-    bool changed = false;\n-    bool changed_this_iteration = true;\n-    int64_t iteration_count = 0;\n-    VLOG(3) << \"Running HloPassFix.\";\n-    while (changed_this_iteration) {\n-      TF_ASSIGN_OR_RETURN(\n-          changed_this_iteration,\n-          Pass::RunOnModuleGroup(module_group, execution_threads));\n-      changed |= changed_this_iteration;\n-      VLOG(3) << \"changed_this_iteration: \" << changed_this_iteration;\n-      ++iteration_count;\n-      if (iteration_count == iteration_limit_) {\n-        const DebugOptions& debug_options =\n-            module_group->module(0).config().debug_options();\n-        if (debug_options\n-                .xla_unsupported_crash_on_hlo_pass_fix_max_iterations()) {\n-          LOG(FATAL) << \"Unexpectedly high number of iterations \"\n-                     << iteration_count << \" in HLO pass '\" << Pass::name()\n-                     << \"' for module group '\" << module_group->name() << \"'\";\n-        }\n-        VLOG(1) << \"Unexpectedly high number of iterations in HLO passes, \"\n-                   \"exiting fixed point loop.\";\n-        if (debug_options\n-                .xla_unsupported_crash_on_hlo_pass_silent_hlo_change()) {\n-          // When crash on silent HLO changes is enabled, we can't lie about not\n-          // changing the module, as that will lead to an immediate crash.\n-          return changed;\n-        }\n-        // Return false in case this is fixed point is nested.\n-        return false;\n-      }\n-    }\n-    return changed;\n-  }\n-\n  private:\n   absl::Status RunToFixPoint(\n       HloModule* module, RunState* run_state,"
        },
        {
            "sha": "ccb35667a8620787757f99a31438d3b4433d5f80",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_interface.h",
            "status": "modified",
            "additions": 12,
            "deletions": 29,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_interface.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_interface.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_interface.h?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n #define XLA_HLO_PASS_HLO_PASS_INTERFACE_H_\n \n #include <cstdint>\n+#include <memory>\n #include <string>\n \n #include \"absl/container/flat_hash_set.h\"\n@@ -88,6 +89,17 @@ class HloPassInterface {\n       HloModule* module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) = 0;\n \n+  // Same as above, except that this API allows the pass to return a *different*\n+  // module, rather than modifying the module in-place.\n+  absl::StatusOr<bool> Run(std::unique_ptr<HloModule>& module_ptr) {\n+    return Run(module_ptr, /*execution_threads=*/{});\n+  }\n+  virtual absl::StatusOr<bool> Run(\n+      std::unique_ptr<HloModule>& module_ptr,\n+      const absl::flat_hash_set<absl::string_view>& execution_threads) {\n+    return Run(module_ptr.get(), execution_threads);\n+  }\n+\n   // Run the pass on computation on changed computations from last iteration in\n   // given HLO module for specified execution_threads, with caller provided\n   // RunState which holds the state information across multiple iterations.\n@@ -107,21 +119,6 @@ class HloPassInterface {\n     return absl::OkStatus();\n   }\n \n-  // Run the pass on the given HLO module group for specified\n-  // `execution_threads`. Empty `execution_threads` list means all execution\n-  // threads are included. Returns whether it modified the module group.\n-  // Ideally, the module group variant would be named \"Run\" as well, but C++\n-  // does not handle overloaded virtual methods well.\n-  //\n-  // See the caveat about C++ hiding overloaded functions in the Run function\n-  // above.\n-  absl::StatusOr<bool> RunOnModuleGroup(HloModuleGroup* module_group) {\n-    return RunOnModuleGroup(module_group, /*execution_threads=*/{});\n-  }\n-  virtual absl::StatusOr<bool> RunOnModuleGroup(\n-      HloModuleGroup* module_group,\n-      const absl::flat_hash_set<absl::string_view>& execution_threads) = 0;\n-\n   virtual bool IsPassPipeline() const { return false; }\n \n   // If an HloPassMetadata has previously been created, it adds a (key, value)\n@@ -141,20 +138,6 @@ class HloPassInterface {\n // Base class for passes which are module-scoped.\n class HloModulePass : public HloPassInterface {\n  public:\n-  // Runs the pass on a module group by iterating through each module in the\n-  // group.\n-  absl::StatusOr<bool> RunOnModuleGroup(\n-      HloModuleGroup* module_group,\n-      const absl::flat_hash_set<absl::string_view>& execution_threads)\n-      override {\n-    bool changed = false;\n-    for (HloModule* module : module_group->modules()) {\n-      TF_ASSIGN_OR_RETURN(bool module_changed, Run(module, execution_threads));\n-      changed |= module_changed;\n-    }\n-    return changed;\n-  };\n-\n   // Update the layout of a Shape to one that is supported by a given backend.\n   // One can call this function after modifying the Shape in case that modifying\n   // the Shape requires changes to the layout for the given Backend."
        },
        {
            "sha": "f41411f003edfd8e2a434366b4be6a0722708fbd",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_pipeline.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 65,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline.cc?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #include \"xla/hlo/pass/hlo_pass_pipeline.h\"\n \n #include <cstddef>\n+#include <memory>\n #include <optional>\n #include <string>\n #include <vector>\n@@ -81,42 +82,17 @@ void RecordPassEndMetadata(HloModule& module, const std::string& pass_name,\n     LOG(FATAL) << status;\n   }\n }\n-\n-absl::Status AttemptRecordPassEndMetadata(HloModuleGroup& module_group,\n-                                          const std::string& pass_name,\n-                                          bool module_changed) {\n-  for (HloModule* module : module_group.modules()) {\n-    for (HloModule* other_module : module_group.modules()) {\n-      TF_RETURN_IF_ERROR(\n-          module->metadata()->add_current_pass_module_group_module_id(\n-              other_module->unique_id()));\n-    }\n-    TF_RETURN_IF_ERROR(\n-        AttemptRecordPassEndMetadata(*module, pass_name, module_changed));\n-  }\n-  return absl::OkStatus();\n-}\n-\n-void RecordPassEndMetadata(HloModuleGroup& module_group,\n-                           const std::string& pass_name, bool module_changed) {\n-  absl::Status status =\n-      AttemptRecordPassEndMetadata(module_group, pass_name, module_changed);\n-  if (!status.ok()) {\n-    LOG(FATAL) << status;\n-  }\n-}\n-\n }  // namespace\n \n template <typename HloT>\n absl::Status HloPassPipeline::RunInvariantCheckers(\n-    HloT* hlo, absl::string_view after_pass_name,\n+    HloT hlo, absl::string_view after_pass_name,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n   tsl::profiler::TraceMe traceme(\"RunInvariantCheckers\");\n   for (auto& invariant_checker : invariant_checkers_) {\n     VLOG(1) << \"    Invariant checker \" << invariant_checker->name();\n     absl::StatusOr<bool> changed_status =\n-        RunHelper(invariant_checker.get(), hlo, execution_threads);\n+        RunHelper<HloT>(invariant_checker.get(), hlo, execution_threads);\n     VLOG(1) << \"    Invariant checker done \" << invariant_checker->name();\n     if (!changed_status.ok()) {\n       VLOG(2) << \"Failed invariant check:\";\n@@ -136,15 +112,9 @@ namespace {\n std::string UniqueId(const HloModule& mod) {\n   return std::to_string(mod.unique_id());\n }\n-std::string UniqueId(const HloModuleGroup& group) {\n-  return absl::StrJoin(group.modules(), \"-\",\n-                       [](std::string* out, const HloModule* mod) {\n-                         out->append(std::to_string(mod->unique_id()));\n-                       });\n-}\n \n template <typename HloT>\n-static void VerifyPassChangedReport(const HloT* hlo, bool pass_changed,\n+static void VerifyPassChangedReport(const HloT hlo, bool pass_changed,\n                                     const DebugOptions& debug_options,\n                                     absl::string_view pass_name,\n                                     absl::string_view pipeline_name,\n@@ -173,7 +143,7 @@ static void VerifyPassChangedReport(const HloT* hlo, bool pass_changed,\n \n template <typename HloT>\n absl::StatusOr<bool> HloPassPipeline::RunPassesInternal(\n-    HloT* hlo, const DebugOptions& debug_options,\n+    HloT hlo, const DebugOptions& debug_options,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n   auto passes = GetEnabledPasses(debug_options);\n   // Copy string by value since debug options could get clobbered in an hlo\n@@ -188,7 +158,7 @@ absl::StatusOr<bool> HloPassPipeline::RunPassesInternal(\n   }};\n \n   TF_RETURN_IF_ERROR(\n-      RunInvariantCheckers(hlo, kPipelineStart, execution_threads));\n+      RunInvariantCheckers<HloT>(hlo, kPipelineStart, execution_threads));\n \n   RecordPassStartMetadata(*hlo, std::string(kPipelineStart), pipeline_name);\n   MaybeDumpHloAndSaveFilenames(*hlo,\n@@ -222,15 +192,15 @@ absl::StatusOr<bool> HloPassPipeline::RunPassesInternal(\n       compilation_stats_->StartPass(pass_name);\n     }\n     RecordPassStartMetadata(*hlo, pass_name, pipeline_name);\n-    auto status_or_changed = RunHelper(pass, hlo, execution_threads);\n+    auto status_or_changed = RunHelper<HloT>(pass, hlo, execution_threads);\n     if (auto status = status_or_changed.status(); !status.ok()) {\n       compilation_stats_->RecordPassError(\n           pass_name, absl::StatusCodeToString(status.code()));\n     }\n     TF_ASSIGN_OR_RETURN(bool pass_changed, status_or_changed);\n     if (verify_pass_changed_report) {\n-      VerifyPassChangedReport(hlo, pass_changed, debug_options, pass_name,\n-                              pipeline_name, hash_before.value());\n+      VerifyPassChangedReport<HloT>(hlo, pass_changed, debug_options, pass_name,\n+                                    pipeline_name, hash_before.value());\n     }\n     if (!dump_regex.empty() && (pass_changed || dump_regex != \".*\")) {\n       MaybeDumpHloAndSaveFilenames(*hlo,\n@@ -243,7 +213,8 @@ absl::StatusOr<bool> HloPassPipeline::RunPassesInternal(\n     changed |= pass_changed;\n     if (pass_changed) {\n       VLOG(3) << \"  Pass caused changes \" << pass_name;\n-      auto status = RunInvariantCheckers(hlo, pass_name, execution_threads);\n+      auto status =\n+          RunInvariantCheckers<HloT>(hlo, pass_name, execution_threads);\n       if (!status.ok()) {\n         compilation_stats_->RecordPassError(\n             pass_name, absl::StatusCodeToString(status.code()));\n@@ -326,14 +297,6 @@ void HloPassPipeline::MaybeDumpHloAndSaveFilenames(\n   }\n }\n \n-void HloPassPipeline::MaybeDumpHloAndSaveFilenames(\n-    HloModuleGroup& module_group, absl::string_view after_pass_name,\n-    absl::string_view before_pass_name) {\n-  for (HloModule* module : module_group.modules()) {\n-    MaybeDumpHloAndSaveFilenames(*module, after_pass_name, before_pass_name);\n-  }\n-}\n-\n absl::StatusOr<bool> HloPassPipeline::Run(\n     HloModule* module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n@@ -348,28 +311,19 @@ absl::StatusOr<bool> HloPassPipeline::Run(\n   return RunPassesInternal(module, debug_options, execution_threads);\n }\n \n-absl::StatusOr<bool> HloPassPipeline::RunOnModuleGroup(\n-    HloModuleGroup* module_group,\n+absl::StatusOr<bool> HloPassPipeline::Run(\n+    std::unique_ptr<HloModule>& module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n   run_called_ = true;\n \n-  VLOG(1) << \"Running HLO pass pipeline on module group \"\n-          << module_group->name() << \": \" << name();\n-\n-  if (module_group->modules().empty()) {\n-    VLOG(1) << \"Module group is empty. Nothing to do.\";\n-    return false;\n-  }\n-\n-  if (module_group->modules().size() > 1) {\n-    return absl::UnimplementedError(\n-        \"HloPassPipeline::RunOnModuleGroup only supports module groups with a \"\n-        \"single module.\");\n-  }\n+  VLOG(1) << \"Running HLO pass pipeline on module \" << module->name() << \": \"\n+          << name();\n \n+  tsl::profiler::TraceMe traceme(name());\n   // Copy debug options by value as passes may modify module config.\n-  DebugOptions debug_options = module_group->module(0).config().debug_options();\n-  return RunPassesInternal(module_group, debug_options, execution_threads);\n+  DebugOptions debug_options = module->config().debug_options();\n+  return RunPassesInternal<std::unique_ptr<HloModule>&>(module, debug_options,\n+                                                        execution_threads);\n }\n \n }  // namespace xla"
        },
        {
            "sha": "091b6049a02e163c4d7f82c9d50efdadc5fafbe1",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_pipeline.h",
            "status": "modified",
            "additions": 13,
            "deletions": 24,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline.h?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -91,9 +91,8 @@ class HloPassPipeline : public HloPassInterface {\n   absl::StatusOr<bool> Run(\n       HloModule* module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n-  using HloPassInterface::RunOnModuleGroup;\n-  absl::StatusOr<bool> RunOnModuleGroup(\n-      HloModuleGroup* module_group,\n+  absl::StatusOr<bool> Run(\n+      std::unique_ptr<HloModule>& module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n \n   bool IsPassPipeline() const override { return true; }\n@@ -109,56 +108,46 @@ class HloPassPipeline : public HloPassInterface {\n   std::vector<HloPassInterface*> GetEnabledPasses(\n       const DebugOptions& debug_options);\n \n-  // Maybe dumps the given module or module group depending on flag values\n-  // contained in DebugOptions of module config. If it is dumped, saves the\n-  // filenames of the dumps into module metadata.\n-  void MaybeDumpHloAndSaveFilenames(HloModuleGroup& module_group,\n-                                    absl::string_view after_pass_name,\n-                                    absl::string_view before_pass_name);\n+  // Maybe dumps the given module depending on flag values contained in\n+  // DebugOptions of module config. If it is dumped, saves the filenames of the\n+  // dumps into module metadata.\n   void MaybeDumpHloAndSaveFilenames(HloModule& module,\n                                     absl::string_view after_pass_name,\n                                     absl::string_view before_pass_name);\n \n   // Runs the invariant checker on the given HLO for specified\n   // `execution_threads`. Empty `execution_threads` means all execution threads\n-  // are included. HloT can be either HloModule or HloModuleGroup.\n+  // are included.\n+\n   template <typename HloT>\n-  absl::Status RunInvariantCheckers(HloT* hlo,\n+  absl::Status RunInvariantCheckers(HloT hlo,\n                                     absl::string_view after_pass_name) {\n     return RunInvariantCheckers(hlo, after_pass_name, /*execution_threads=*/{});\n   }\n   template <typename HloT>\n   absl::Status RunInvariantCheckers(\n-      HloT* hlo, absl::string_view after_pass_name,\n+      HloT hlo, absl::string_view after_pass_name,\n       const absl::flat_hash_set<absl::string_view>& execution_threads);\n \n-  // Helper which runs the given pass on the given HLO. HloT can be either\n-  // HloModule or HloModuleGroup.\n+  // Helper which runs the given pass on the given HLO.\n   template <typename HloT>\n   absl::StatusOr<bool> RunPassesInternal(\n-      HloT* hlo, const DebugOptions& debug_options,\n+      HloT hlo, const DebugOptions& debug_options,\n       const absl::flat_hash_set<absl::string_view>& execution_threads);\n \n   // Helpers which run the given passes on the given HLO construct. Only\n   // computations with specified `execution_threads` are considered by the pass,\n   // empty thread list means all `execution_threads` are considered. These\n   // helpers enable templating of the core of the pipeline logic by providing\n   // HloModule and HloModuleGroup specific methods with the same name.\n+  template <typename HloT>\n   static absl::StatusOr<bool> RunHelper(\n-      HloPassInterface* pass, HloModule* module,\n+      HloPassInterface* pass, HloT module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) {\n     TF_ASSIGN_OR_RETURN(bool changed, pass->Run(module, execution_threads));\n     module->Cleanup();\n     return changed;\n   }\n-  static absl::StatusOr<bool> RunHelper(\n-      HloPassInterface* pass, HloModuleGroup* module_group,\n-      const absl::flat_hash_set<absl::string_view>& execution_threads) {\n-    TF_ASSIGN_OR_RETURN(\n-        bool changed, pass->RunOnModuleGroup(module_group, execution_threads));\n-    module_group->Cleanup();\n-    return changed;\n-  }\n \n   const std::string name_;\n   std::vector<std::unique_ptr<HloPassInterface>> passes_;"
        },
        {
            "sha": "7a4bf0891c613d7763041eb5c62e18ac205ed011",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_pipeline_test.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 29,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline_test.cc?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -265,19 +265,17 @@ ENTRY main {\n   ROOT baz = f32[] multiply(a, b)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloModuleGroup module_group,\n-                          ParseModuleGroup(module_0_str));\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(module_0_str));\n \n   HloPassPipeline pipeline(TestName());\n   pipeline.AddPass<BazToQuxModulePass>();\n   pipeline.AddPass<FooToBarModulePass>();\n \n-  HloInstruction* root0 =\n-      module_group.module(0).entry_computation()->root_instruction();\n+  HloInstruction* root0 = module->entry_computation()->root_instruction();\n   EXPECT_EQ(root0->name(), \"baz\");\n \n-  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n-                          pipeline.RunOnModuleGroup(&module_group));\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed, pipeline.Run(module.get()));\n   EXPECT_TRUE(changed);\n \n   EXPECT_EQ(root0->name(), \"qux\");\n@@ -333,38 +331,32 @@ ENTRY main {\n   }\n }\n \n-// Test that metadata is set when a module group goes through a pass pipeline.\n+// Test that metadata is set when a module goes through a pass pipeline.\n TEST_F(HloPassPipelineTest, SetHloModuleMetadata) {\n-  HloModuleGroup module_group(CreateNewVerifiedModule());\n+  std::unique_ptr<VerifiedHloModule> module = CreateNewVerifiedModule();\n \n   HloPassPipeline pipeline(TestName());\n   pipeline.AddPass<BazToQuxModulePass>();\n   pipeline.AddPass<FooToBarModulePass>();\n-  TF_ASSERT_OK(pipeline.RunOnModuleGroup(&module_group).status());\n-  ASSERT_THAT(module_group.modules(), SizeIs(1));\n+  TF_ASSERT_OK(pipeline.Run(module.get()).status());\n \n   std::vector<std::string> pass_names = {\"pipeline-start\", \"baz2qux\",\n                                          \"foo2bar\"};\n   std::string pipeline_name = std::string(pipeline.name());\n-  for (const HloModule* module : module_group.modules()) {\n-    const HloModuleMetadataProto& metadata = module->metadata().proto();\n-    EXPECT_EQ(metadata.canonical_module_id(), module->unique_id());\n-    EXPECT_EQ(metadata.module_group_name(), module_group.name());\n-\n-    ASSERT_THAT(metadata.pass_metadata(), SizeIs(3));\n-    for (int pass = 0; pass < metadata.pass_metadata().size(); pass++) {\n-      const HloPassMetadata& pass_metadata = metadata.pass_metadata(pass);\n-      EXPECT_NE(pass_metadata.pass_id(), 0);\n-      EXPECT_THAT(pass_metadata.pass_name(), StrEq(pass_names[pass]));\n-      EXPECT_THAT(pass_metadata.pipeline_name(), StrEq(pipeline_name));\n-      EXPECT_FALSE(pass_metadata.module_changed());\n-      EXPECT_EQ(pass_metadata.module_id(), module->unique_id());\n-      EXPECT_THAT(pass_metadata.module_group_module_ids(),\n-                  ElementsAre(module_group.module(0).unique_id()));\n-      EXPECT_GT(pass_metadata.start_timestamp_usec(), 0);\n-      EXPECT_LE(pass_metadata.start_timestamp_usec(),\n-                pass_metadata.end_timestamp_usec());\n-    }\n+  const HloModuleMetadataProto& metadata = module->metadata()->proto();\n+  EXPECT_EQ(metadata.canonical_module_id(), module->unique_id());\n+\n+  ASSERT_THAT(metadata.pass_metadata(), SizeIs(3));\n+  for (int pass = 0; pass < metadata.pass_metadata().size(); pass++) {\n+    const HloPassMetadata& pass_metadata = metadata.pass_metadata(pass);\n+    EXPECT_NE(pass_metadata.pass_id(), 0);\n+    EXPECT_THAT(pass_metadata.pass_name(), StrEq(pass_names[pass]));\n+    EXPECT_THAT(pass_metadata.pipeline_name(), StrEq(pipeline_name));\n+    EXPECT_FALSE(pass_metadata.module_changed());\n+    EXPECT_EQ(pass_metadata.module_id(), module->unique_id());\n+    EXPECT_GT(pass_metadata.start_timestamp_usec(), 0);\n+    EXPECT_LE(pass_metadata.start_timestamp_usec(),\n+              pass_metadata.end_timestamp_usec());\n   }\n }\n \n@@ -401,5 +393,7 @@ ENTRY main {\n   TF_EXPECT_OK(status);\n }\n \n+// TODO: Add test.\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "77cdec0818510622af3ac363f4d696616d2b3a72",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/tuple_simplifier.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Ftuple_simplifier.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Ftuple_simplifier.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Ftuple_simplifier.h?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -37,7 +37,6 @@ class TupleSimplifier : public HloModulePass {\n   // Runs tuple simplification on the given module. Returns whether the module\n   // was changed.\n   using HloPassInterface::Run;\n-  using HloPassInterface::RunOnModuleGroup;\n   absl::StatusOr<bool> Run(\n       HloModule* module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) override;"
        },
        {
            "sha": "039e0f4d815512b6ea46d0ea0166497339b2809f",
            "filename": "third_party/xla/xla/service/hlo_module_group_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_module_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_module_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_module_group_test.cc?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -69,32 +69,6 @@ ENTRY %entry (x: f32[], y: f32[]) -> f32[] {\n   std::vector<std::unique_ptr<HloModule>> modules = group.ConsumeModules();\n   EXPECT_EQ(modules.size(), 1);\n }\n-\n-// Test that metadata is transferred when a module is replaced.\n-TEST_F(HloModuleGroupTest, ReplaceModuleMetadata) {\n-  auto old_module = CreateNewVerifiedModule();\n-  int old_module_id = old_module->unique_id();\n-  old_module->metadata()->RecordPassStart();\n-  TF_EXPECT_OK(old_module->metadata()->set_current_pass_name(\"fake pass\"));\n-\n-  HloModuleGroup group(std::move(old_module));\n-  EXPECT_EQ(group.module(0).metadata()->proto().module_group_name(),\n-            group.name());\n-\n-  auto new_module = CreateNewVerifiedModule();\n-  group.ReplaceModule(0, std::move(new_module));\n-\n-  EXPECT_NE(group.module(0).unique_id(), old_module_id);\n-  const HloModuleMetadataProto& module_metadata =\n-      group.module(0).metadata()->proto();\n-  EXPECT_EQ(module_metadata.canonical_module_id(), old_module_id);\n-\n-  const HloPassMetadata& pass_metadata =\n-      *module_metadata.pass_metadata().rbegin();\n-  EXPECT_THAT(pass_metadata,\n-              Property(&HloPassMetadata::pass_name, StrEq(\"fake pass\")));\n-}\n-\n }  // namespace\n \n }  // namespace xla"
        },
        {
            "sha": "965e587ee3562903dde7bb6d3caac45d486df66b",
            "filename": "third_party/xla/xla/service/hlo_verifier.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0064d2d1bba51364aeeb37abe8d562b1a49bda57/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.h?ref=0064d2d1bba51364aeeb37abe8d562b1a49bda57",
            "patch": "@@ -491,7 +491,6 @@ class HloVerifier : public HloModulePass {\n \n   // Never returns true; no instructions are ever modified by this pass.\n   using HloPassInterface::Run;\n-  using HloPassInterface::RunOnModuleGroup;\n   absl::StatusOr<bool> Run(\n       HloModule* module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) override;"
        }
    ],
    "stats": {
        "total": 298,
        "additions": 73,
        "deletions": 225
    }
}