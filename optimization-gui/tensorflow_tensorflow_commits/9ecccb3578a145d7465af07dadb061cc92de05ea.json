{
    "author": "DottsGit",
    "message": "Enhance decode_image tests to cover additional channel configurations\n\n- Added tests for 0 (auto-detection), 2 (grayscale + alpha), and 4 (RGBA) channels.\n- Updated assertions to reflect new expected shapes based on channel count.\n- Improved comments for clarity on test cases.",
    "sha": "9ecccb3578a145d7465af07dadb061cc92de05ea",
    "files": [
        {
            "sha": "fea571da7d771036a3433afb1a3d3d4af83905cf",
            "filename": "tensorflow/python/ops/image_ops_test.py",
            "status": "modified",
            "additions": 26,
            "deletions": 4,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9ecccb3578a145d7465af07dadb061cc92de05ea/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9ecccb3578a145d7465af07dadb061cc92de05ea/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py?ref=9ecccb3578a145d7465af07dadb061cc92de05ea",
            "patch": "@@ -6660,22 +6660,44 @@ def process_image_fixed(image_bytes):\n       self.assertTrue(shape_list[1] is None or shape_list[1] == 2)\n \n       # Test different channel configurations.\n-      for channels in [1, 3, 4]:\n-        if channels == 1:\n+      for channels in [0, 1, 2, 3, 4]:\n+        if channels == 0:\n+          # Use auto-detection with RGB JPEG.\n+          test_bytes = jpeg_bytes\n+        elif channels == 1:\n           # Create grayscale test image.\n           gray_image = constant_op.constant([[128, 64], [192, 32]], \n                                            dtype=dtypes.uint8)\n           gray_image = array_ops.expand_dims(gray_image, -1)\n           test_bytes = gen_image_ops.encode_png(gray_image)\n+        elif channels == 2:\n+          # Create grayscale + alpha test image using PNG.\n+          gray_alpha_image = constant_op.constant([[[128, 255],\n+                                                    [64, 128]], \n+                                                   [[192, 64],\n+                                                    [32, 192]]], \n+                                                  dtype=dtypes.uint8)\n+          test_bytes = gen_image_ops.encode_png(gray_alpha_image)\n+        elif channels == 4:\n+          # Create RGBA test image using PNG (JPEG doesn't support 4 channels).\n+          rgba_image = constant_op.constant([[[255, 0, 0, 255],\n+                                              [0, 255, 0, 128]], \n+                                             [[0, 0, 255, 64],\n+                                              [255, 255, 0, 192]]], \n+                                           dtype=dtypes.uint8)\n+          test_bytes = gen_image_ops.encode_png(rgba_image)\n         else:\n-          # Use RGB JPEG for multi-channel tests.\n+          # Use RGB JPEG for 3-channel tests.\n           test_bytes = jpeg_bytes\n \n         decoded = image_ops.decode_image(test_bytes, channels=channels,\n                                          expand_animations=False)\n         self.assertEqual(decoded.shape.rank, 3)\n         \n-        if channels <= 3:\n+        if channels == 0:\n+          # Auto-detection case - shape depends on the image format used.\n+          expected_shape = [None, None, None]\n+        elif channels <= 4:\n           expected_shape = [None, None, channels]\n         else:\n           expected_shape = [None, None, None]"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 26,
        "deletions": 4
    }
}