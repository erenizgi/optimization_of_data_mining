{
    "author": "ezhulenev",
    "message": "[xla:cpu] Remove unused runtime_key_value_sort\n\nKeep an empty target to avoid updating many BUILD files. Will be removed after all targets are migrated.\n\nPiperOrigin-RevId: 832476578",
    "sha": "a089b328c95d76b3cd35f1baf5b9e62d9743781c",
    "files": [
        {
            "sha": "66330dcc41706f44f28dce3488eea3f24690d61a",
            "filename": "third_party/xla/xla/service/cpu/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a089b328c95d76b3cd35f1baf5b9e62d9743781c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a089b328c95d76b3cd35f1baf5b9e62d9743781c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD?ref=a089b328c95d76b3cd35f1baf5b9e62d9743781c",
            "patch": "@@ -52,7 +52,6 @@ filegroup(\n     name = \"runtime_srcs\",\n     srcs = [\n         # Single-threaded support.\n-        \"runtime_key_value_sort.cc\",\n         \"runtime_single_threaded_conv2d.cc\",\n         \"runtime_single_threaded_conv3d.cc\",\n         \"runtime_single_threaded_matmul_c128.cc\",\n@@ -84,7 +83,6 @@ filegroup(\n     name = \"runtime_hdrs\",\n     srcs = [\n         # Single-threaded support.\n-        \"runtime_key_value_sort.h\",\n         \"runtime_single_threaded_conv2d.h\",\n         \"runtime_single_threaded_conv3d.h\",\n         \"runtime_single_threaded_matmul.h\",\n@@ -1186,15 +1184,7 @@ cc_library(\n \n cc_library(\n     name = \"runtime_key_value_sort\",\n-    srcs = [\"runtime_key_value_sort.cc\"],\n-    hdrs = [\"runtime_key_value_sort.h\"],\n-    copts = runtime_copts(),\n     visibility = [\"//visibility:public\"],\n-    deps = [\n-        \"@com_google_absl//absl/base:core_headers\",\n-        \"@com_google_absl//absl/base:dynamic_annotations\",\n-        \"@eigen_archive//:eigen3\",\n-    ],\n )\n \n cc_library("
        },
        {
            "sha": "a63007ae046106e1c21aef8b38e630fd9713a1e5",
            "filename": "third_party/xla/xla/service/cpu/runtime_key_value_sort.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 113,
            "changes": 113,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6a93fd3b078190c95a3ea023bc3fa14d779815a4/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_key_value_sort.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6a93fd3b078190c95a3ea023bc3fa14d779815a4/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_key_value_sort.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_key_value_sort.cc?ref=6a93fd3b078190c95a3ea023bc3fa14d779815a4",
            "patch": "@@ -1,113 +0,0 @@\n-/* Copyright 2018 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-#include \"xla/service/cpu/runtime_key_value_sort.h\"\n-\n-#include <algorithm>\n-#include <cstdint>\n-#include <cstring>\n-#include <memory>\n-#include <numeric>\n-#include <string>\n-\n-#include \"absl/base/attributes.h\"\n-#include \"absl/base/dynamic_annotations.h\"\n-#include \"unsupported/Eigen/CXX11/Tensor\"\n-\n-ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY void __xla_cpu_runtime_KeyValueSort(\n-    int64_t a, int64_t b, int64_t c, char** values, int32_t values_count,\n-    int32_t* values_primitive_type_size_in_bytes, bool is_stable,\n-    char* run_options, int64_t* prof_counters,\n-    void (*less_than)(char*, char*, char**, char**, int64_t*)) {\n-  // 'values' and 'values_primitive_type_size_in_bytes' are managed by the JIT\n-  // code, so msan can't tell they are initialized.\n-  ABSL_ANNOTATE_MEMORY_IS_INITIALIZED(values, values_count * sizeof(char*));\n-  ABSL_ANNOTATE_MEMORY_IS_INITIALIZED(values_primitive_type_size_in_bytes,\n-                                      values_count * sizeof(int32_t));\n-\n-  // High-level idea of the iteration/sorting logic:\n-  // Conceptually we have a 3-dimensional shape [a, b, c]. b corresponds to the\n-  // dimension to sort, c is the product of the more minor dimensions (set to 1\n-  // if b is the most minor dimension), and a is the product of the more major\n-  // dimensions (set to 1 if b is the most major dimension). There are a * c\n-  // many rows that we need to sort. We iterate through these, calculate a\n-  // 'base_offset' value which points to the first element in that row, and add\n-  // i * c for accessing the 'i'-th element in that row.\n-\n-  int64_t sort_dimension_elements = b;\n-  int64_t num_iteration_elements = a * c;\n-  int64_t sort_dimension_offset = c;\n-\n-  std::unique_ptr<int64_t[]> indices(new int64_t[sort_dimension_elements]);\n-  std::unique_ptr<char*[]> comparison_values(new char*[2 * values_count]);\n-  std::iota(indices.get(), indices.get() + sort_dimension_elements, 0);\n-  std::unique_ptr<std::string[]> reordered_values(\n-      new std::string[sort_dimension_elements]);\n-  for (int64_t index = 0; index < num_iteration_elements; ++index) {\n-    // If the sort should be stable, we have to reinitialize indices to iota to\n-    // guarantee that we still keep the relative order in case of ties.\n-    if (is_stable && index > 0) {\n-      std::iota(indices.get(), indices.get() + sort_dimension_elements, 0);\n-    }\n-    // 'index' can be split into two values which index into the 'c' dimension\n-    // and the 'a' dimension, respectively. 'index' % 'c' is the index into the\n-    // 'c' dimension, 'index' / 'c' is the index into the 'a' dimension. When\n-    // calculating the base offset, we need to multiply the index into the 'a'\n-    // dimension with 'b' * 'c'.\n-    // 'index' / 'c' * 'c' * 'b' = ('index' - 'index' % 'c') * 'b'.\n-    int64_t base_offset =\n-        index % sort_dimension_offset +\n-        (index - index % sort_dimension_offset) * sort_dimension_elements;\n-    auto compare_function = [&](int64_t a, int64_t b) -> bool {\n-      for (int32_t i = 0; i < values_count; ++i) {\n-        int64_t memory_index_lhs = (base_offset + a * sort_dimension_offset) *\n-                                   values_primitive_type_size_in_bytes[i];\n-        int64_t memory_index_rhs = (base_offset + b * sort_dimension_offset) *\n-                                   values_primitive_type_size_in_bytes[i];\n-        comparison_values[i * 2] = values[i] + memory_index_lhs;\n-        comparison_values[i * 2 + 1] = values[i] + memory_index_rhs;\n-      }\n-      char result = 0;  // Overwritten by less_than.\n-      less_than(&result, run_options, comparison_values.get(), nullptr,\n-                prof_counters);\n-      return result != 0u;\n-    };\n-    if (is_stable) {\n-      std::stable_sort(indices.get(), indices.get() + sort_dimension_elements,\n-                       compare_function);\n-    } else {\n-      std::sort(indices.get(), indices.get() + sort_dimension_elements,\n-                compare_function);\n-    }\n-\n-    // Reorder the values according to the order defined by 'indices'.\n-    for (int32_t idx = 0; idx < values_count; ++idx) {\n-      for (int64_t i = 0; i < sort_dimension_elements; ++i) {\n-        int64_t memory_index =\n-            (base_offset + indices[i] * sort_dimension_offset) *\n-            values_primitive_type_size_in_bytes[idx];\n-\n-        reordered_values[i] =\n-            std::string(values[idx] + memory_index,\n-                        values_primitive_type_size_in_bytes[idx]);\n-      }\n-      for (int64_t i = 0; i < sort_dimension_elements; ++i) {\n-        int64_t memory_index = (base_offset + i * sort_dimension_offset) *\n-                               values_primitive_type_size_in_bytes[idx];\n-        memcpy(values[idx] + memory_index, reordered_values[i].c_str(),\n-               values_primitive_type_size_in_bytes[idx]);\n-      }\n-    }\n-  }\n-}"
        },
        {
            "sha": "dfd99f64cf2209e7a4cf4a98b44c1377dbe4b40e",
            "filename": "third_party/xla/xla/service/cpu/runtime_key_value_sort.h",
            "status": "removed",
            "additions": 0,
            "deletions": 46,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6a93fd3b078190c95a3ea023bc3fa14d779815a4/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_key_value_sort.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6a93fd3b078190c95a3ea023bc3fa14d779815a4/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_key_value_sort.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_key_value_sort.h?ref=6a93fd3b078190c95a3ea023bc3fa14d779815a4",
            "patch": "@@ -1,46 +0,0 @@\n-/* Copyright 2018 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef XLA_SERVICE_CPU_RUNTIME_KEY_VALUE_SORT_H_\n-#define XLA_SERVICE_CPU_RUNTIME_KEY_VALUE_SORT_H_\n-\n-#include <stdint.h>\n-\n-#include \"unsupported/Eigen/CXX11/Tensor\"\n-\n-extern \"C\" {\n-\n-// Each entry in 'values' represents a 3-dimensional shape with dimensions\n-// [a, b, c]. The 'b' dimension of each shape is sorted into ascending order\n-// according to the results of comparisons using the provided 'less_than'\n-// function. 'values_count' must be > 0 and specifies the number of entries in\n-// 'values' and 'values_primitive_type_size_in_bytes'. The size of the primitive\n-// type of the i-th shape has exactly 'values_primitive_type_size_in_bytes[i]'\n-// bytes. 'is_stable' specifies whether the sorting should be stable.\n-// 'run_options' and 'prof_counters' are passed through to the less-than\n-// function, which expects the following arguments:\n-// - pointer to the return value buffer (char*)\n-// - xla::ExecutableRunOptions = 'run_options' (char*)\n-// - pointers to the parameter buffers (char**)\n-// - pointers to the buffer tables = nullptr for thread local functions (char**)\n-// - profile counters = 'prof_counters' (int64_t*)\n-extern void __xla_cpu_runtime_KeyValueSort(\n-    int64_t a, int64_t b, int64_t c, char** values, int32_t values_count,\n-    int32_t* values_primitive_type_size_in_bytes, bool is_stable,\n-    char* run_options, int64_t* prof_counters,\n-    void (*less_than)(char*, char*, char**, char**, int64_t*));\n-}\n-\n-#endif  // XLA_SERVICE_CPU_RUNTIME_KEY_VALUE_SORT_H_"
        }
    ],
    "stats": {
        "total": 169,
        "additions": 0,
        "deletions": 169
    }
}