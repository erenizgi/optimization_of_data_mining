{
    "author": "lhutton1",
    "message": "[mlir][tosa] Update rounding mode, nan propagation and resize mode to enums (#99500)\n\nAligns with LLVM updates to convert string attributes to enums.\n\nChange-Id: I99bc0634b0c7700e10e362986a23c003a18d6b40",
    "sha": "2204898ecbc886d058082779884a83728a46562f",
    "files": [
        {
            "sha": "02e9c0649e3f78f28930e2f10e1d22f77ba17d0d",
            "filename": "tensorflow/compiler/mlir/tosa/tests/convert-tfl-uint8.mlir",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Fconvert-tfl-uint8.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Fconvert-tfl-uint8.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Fconvert-tfl-uint8.mlir?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -22,7 +22,7 @@ func.func @test_add_u8(%arg0: tensor<14x19x!quant.uniform<u8:f32, 0.015603500418\n // CHECK-DAG: %[[shift:.+]] = \"tosa.const\"() <{values = dense<30> : tensor<1xi8>}> : () -> tensor<1xi8>\n // CHECK-DAG: %[[input_zp:.+]] = \"tosa.const\"() <{values = dense<-128> : tensor<1xi8>}> : () -> tensor<1xi8>\n // CHECK-DAG: %[[output_zp:.+]] = \"tosa.const\"() <{values = dense<0> : tensor<1xi8>}> : () -> tensor<1xi8>\n-// CHECK-DAG: tosa.rescale %arg0, %[[multiplier]], %[[shift]], %[[input_zp]], %[[output_zp]] {input_unsigned = true, output_unsigned = false, per_channel = false, rounding_mode = \"SINGLE_ROUND\", scale32 = true}\n+// CHECK-DAG: tosa.rescale %arg0, %[[multiplier]], %[[shift]], %[[input_zp]], %[[output_zp]] {input_unsigned = true, output_unsigned = false, per_channel = false, rounding_mode = SINGLE_ROUND, scale32 = true}\n // CHECK: tfl.cast\n func.func @test_cast_ui8(%arg0: tensor<1x256x256x3x!quant.uniform<u8:f32, 0.015603500418365002:128>>) -> tensor<1x256x256x3xf32> {\n   %0 = \"tfl.cast\"(%arg0) : (tensor<1x256x256x3x!quant.uniform<u8:f32, 0.015603500418365002:128>>) -> tensor<1x256x256x3xf32>"
        },
        {
            "sha": "4de58646a7c8acd50782589dc1e1a354145646ae",
            "filename": "tensorflow/compiler/mlir/tosa/tests/tfl-to-tosa-pipeline.mlir",
            "status": "modified",
            "additions": 90,
            "deletions": 90,
            "changes": 180,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Ftfl-to-tosa-pipeline.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Ftfl-to-tosa-pipeline.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Ftfl-to-tosa-pipeline.mlir?ref=2204898ecbc886d058082779884a83728a46562f"
        },
        {
            "sha": "4c85d15ca1e383b3f09b19cf846ec6833eef7bac",
            "filename": "tensorflow/compiler/mlir/tosa/tests/tfl-to-tosa-stateful.mlir",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Ftfl-to-tosa-stateful.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Ftfl-to-tosa-stateful.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftests%2Ftfl-to-tosa-stateful.mlir?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -45,10 +45,10 @@ module attributes {tf_saved_model.semantics, tfl.description = \"Test.\", tfl.sche\n // CHECK: %[[VAL_5:.*]] = \"tosa.const\"() <{values = dense<1073741824> : tensor<1xi32>}> : () -> tensor<1xi32>\n // CHECK: %[[VAL_6:.*]] = tosa.variable_read @Variable : tensor<2x3xi8>\n // CHECK: %[[VAL_7:.*]] = builtin.unrealized_conversion_cast %[[VAL_6]] : tensor<2x3xi8> to tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>\n-// CHECK: %[[VAL_8:.*]] = tosa.rescale %[[VAL_7]], %[[VAL_5]], %[[VAL_4]], %[[VAL_3]], %[[VAL_2]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = \"DOUBLE_ROUND\", scale32 = true} : (tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>, tensor<1xi32>, tensor<1xi8>, tensor<1xi8>, tensor<1xi32>) -> tensor<2x3xi32>\n-// CHECK: %[[VAL_9:.*]] = tosa.rescale %[[VAL_0]], %[[VAL_5]], %[[VAL_4]], %[[VAL_3]], %[[VAL_2]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = \"DOUBLE_ROUND\", scale32 = true} : (tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>, tensor<1xi32>, tensor<1xi8>, tensor<1xi8>, tensor<1xi32>) -> tensor<2x3xi32>\n+// CHECK: %[[VAL_8:.*]] = tosa.rescale %[[VAL_7]], %[[VAL_5]], %[[VAL_4]], %[[VAL_3]], %[[VAL_2]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = DOUBLE_ROUND, scale32 = true} : (tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>, tensor<1xi32>, tensor<1xi8>, tensor<1xi8>, tensor<1xi32>) -> tensor<2x3xi32>\n+// CHECK: %[[VAL_9:.*]] = tosa.rescale %[[VAL_0]], %[[VAL_5]], %[[VAL_4]], %[[VAL_3]], %[[VAL_2]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = DOUBLE_ROUND, scale32 = true} : (tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>, tensor<1xi32>, tensor<1xi8>, tensor<1xi8>, tensor<1xi32>) -> tensor<2x3xi32>\n // CHECK: %[[VAL_10:.*]] = tosa.add %[[VAL_8]], %[[VAL_9]] : (tensor<2x3xi32>, tensor<2x3xi32>) -> tensor<2x3xi32>\n-// CHECK: %[[VAL_11:.*]] = tosa.rescale %[[VAL_10]], %[[VAL_5]], %[[VAL_1]], %[[VAL_2]], %[[VAL_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = \"DOUBLE_ROUND\", scale32 = true} : (tensor<2x3xi32>, tensor<1xi32>, tensor<1xi8>, tensor<1xi32>, tensor<1xi8>) -> tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>\n+// CHECK: %[[VAL_11:.*]] = tosa.rescale %[[VAL_10]], %[[VAL_5]], %[[VAL_1]], %[[VAL_2]], %[[VAL_3]] {input_unsigned = false, output_unsigned = false, per_channel = false, rounding_mode = DOUBLE_ROUND, scale32 = true} : (tensor<2x3xi32>, tensor<1xi32>, tensor<1xi8>, tensor<1xi32>, tensor<1xi8>) -> tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>\n // CHECK: %[[VAL_12:.*]] = builtin.unrealized_conversion_cast %[[VAL_11]] : tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>> to tensor<2x3xi8>\n // CHECK: tosa.variable_write @Variable, %[[VAL_12]] : tensor<2x3xi8>\n // CHECK: return %[[VAL_11]] : tensor<2x3x!quant.uniform<i8:f32, 1.000000e-01:2>>"
        },
        {
            "sha": "afd66102b8a29c07e9e09cc27554335cba2dc21e",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/convert_tfl_uint8.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Fconvert_tfl_uint8.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Fconvert_tfl_uint8.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Fconvert_tfl_uint8.cc?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -231,11 +231,13 @@ LogicalResult convert_graph_uint8_tensor(mlir::MLIRContext &context,\n       auto rescale_output_zp = tosa::getConstTensorInt<int8_t>(\n           builder, loc, {static_cast<int8_t>(rescale_output_zp_val)});\n \n+      const auto rounding_mode_attr = tosa::RoundingModeAttr::get(\n+          builder.getContext(), tosa::RoundingMode::SINGLE_ROUND);\n       auto rescale_op = builder.create<tosa::RescaleOp>(\n           loc, rescaled_type, arg, multiplier, shift, rescale_input_zp,\n           rescale_output_zp,\n           /* scale32 = */ builder.getBoolAttr(true),\n-          /* rounding_mode = */ builder.getStringAttr(\"SINGLE_ROUND\"),\n+          /* rounding_mode = */ rounding_mode_attr,\n           /* per_channel = */ builder.getBoolAttr(false),\n           /* input_unsigned = */ builder.getBoolAttr(true),     // uint8_t ->\n           /* output_unsigned = */ builder.getBoolAttr(false));  // int8_t\n@@ -324,11 +326,13 @@ LogicalResult convert_graph_uint8_tensor(mlir::MLIRContext &context,\n       auto rescale_output_zp = tosa::getConstTensorInt<int8_t>(\n           builder, loc, {static_cast<int8_t>(uint8_zp_val)});\n \n+      const auto rounding_mode_attr = tosa::RoundingModeAttr::get(\n+        builder.getContext(), tosa::RoundingMode::SINGLE_ROUND);\n       auto rescale_op = builder.create<tosa::RescaleOp>(\n           loc, uint8_output_type, input_val, multiplier, shift,\n           rescale_input_zp, rescale_output_zp,\n           /* scale32 = */ builder.getBoolAttr(true),\n-          /* rounding_mode = */ builder.getStringAttr(\"SINGLE_ROUND\"),\n+          /* rounding_mode = */ rounding_mode_attr,\n           /* per_channel = */ builder.getBoolAttr(false),\n           /* input_unsigned = */ builder.getBoolAttr(false),   // int8_t ->\n           /* output_unsigned = */ builder.getBoolAttr(true));  // uint8_t"
        },
        {
            "sha": "803061fe56adaf8369e1550a510d1571ab416782",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/legalize_common.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 26,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_common.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_common.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_common.cc?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -657,7 +657,7 @@ std::optional<Value> convertMultiplyOp(PatternRewriter& rewriter, Operation* op,\n         rewriter, op, rescale_type, op1_rescale_lhs, op2_rescale_rhs);\n     return buildRescale(rewriter, op, output_type, op3_mul_op1_op2.getResult(),\n                         output_rescale_scale, 0, output_qtype.getZeroPoint(),\n-                        \"DOUBLE_ROUND\", scale32);\n+                        tosa::RoundingMode::DOUBLE_ROUND, scale32);\n   }\n \n   return CreateMulOpAndInfer(rewriter, op, output_type, input_lhs_val,\n@@ -833,7 +833,7 @@ std::optional<Value> convertConcatV2Op(PatternRewriter& rewriter, Operation* op,\n             operand_type.getShape(), result_quant_type);\n         Value rescale_op = buildRescale(\n             rewriter, op, rescale_type, v, operand_scale / result_scale,\n-            operand_zeropoint, result_zeropoint, \"SINGLE_ROUND\", true);\n+            operand_zeropoint, result_zeropoint, tosa::RoundingMode::SINGLE_ROUND, true);\n         values_rescaled.push_back(rescale_op);\n       } else {\n         values_rescaled.push_back(v);\n@@ -1611,6 +1611,9 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n   int32_t input_rank = input_type.getRank();\n   ArrayRef<int64_t> logits_shape = output_type.getShape();\n \n+  const auto propagate_attr = tosa::NanPropagationModeAttr::get(\n+    rewriter.getContext(), tosa::NanPropagationMode::PROPAGATE);\n+\n   if (mlir::isa<mlir::quant::QuantizedType>(input_type.getElementType()) &&\n       mlir::isa<mlir::quant::QuantizedType>(output_type.getElementType())) {\n     SmallVector<int64_t> rsum_shape_v(input_type.getShape().begin(),\n@@ -1641,12 +1644,12 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n       // Step 1. get x - max(x)\n       Value op1_rescale_in =\n           buildRescale(rewriter, op, int32_logits_type, logits_value, 1.0f,\n-                       in_quant_type.getZeroPoint(), 0, \"SINGLE_ROUND\", true);\n+                       in_quant_type.getZeroPoint(), 0, tosa::RoundingMode::SINGLE_ROUND, true);\n \n       auto op2_reducemax_op1 = CreateOpAndInfer<tosa::ReduceMaxOp>(\n           rewriter, op->getLoc(), int32_rsum_type, op1_rescale_in,\n           rewriter.getI32IntegerAttr(input_rank - 1),\n-          rewriter.getStringAttr(\"PROPAGATE\"));\n+          propagate_attr);\n \n       auto op3_sub_op1_op2 = CreateOpAndInfer<tosa::SubOp>(\n           rewriter, op->getLoc(), int32_logits_type, op1_rescale_in,\n@@ -1666,7 +1669,7 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n \n       Value op4_rescale_op3 =\n           buildRescale(rewriter, op, int16_logits_type,\n-                       op3_sub_op1_op2.getResult(), 128.0, 0, 0, \"SINGLE_ROUND\", true);\n+                       op3_sub_op1_op2.getResult(), 128.0, 0, 0, tosa::RoundingMode::SINGLE_ROUND, true);\n \n       // Input is 9.7, where lower 7 bits are all zeros.\n       // Output is 23 bits, where lower 7 bits should be all zeros as well,\n@@ -1834,18 +1837,18 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n \n       return buildRescale(rewriter, op, output_type,\n                           op28_rshift_op26_op27.getResult(), 1.0, 0,\n-                          out_quant_type.getZeroPoint(), \"SINGLE_ROUND\", true);\n+                          out_quant_type.getZeroPoint(), tosa::RoundingMode::SINGLE_ROUND, true);\n \n     } else if (in_quant_type.getStorageTypeIntegralWidth() == 16) {\n       // Step 1. get x - max(x)\n       Value op1_rescale_in =\n           buildRescale(rewriter, op, int32_logits_type, logits_value, 1.0f,\n-                       in_quant_type.getZeroPoint(), 0, \"SINGLE_ROUND\", true);\n+                       in_quant_type.getZeroPoint(), 0, tosa::RoundingMode::SINGLE_ROUND, true);\n \n       auto op2_reducemax_op1 = CreateOpAndInfer<tosa::ReduceMaxOp>(\n           rewriter, op->getLoc(), int32_rsum_type, op1_rescale_in,\n           rewriter.getI32IntegerAttr(input_rank - 1),\n-          rewriter.getStringAttr(\"PROPAGATE\"));\n+          propagate_attr);\n \n       // output range is [-65535, 0]\n       auto op3_sub_op1_op2 = CreateOpAndInfer<tosa::SubOp>(\n@@ -1864,7 +1867,7 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n       Value op4_rescale_op3 = buildRescale(\n           rewriter, op, int32_logits_type, op3_sub_op1_op2.getResult(),\n           /*scale=*/input_diff_scale, /*input_zp=*/0, /*output_zp=*/0,\n-          /*rounding_mode=*/\"DOUBLE_ROUND\", /*scale32=*/true);\n+          /*rounding_mode=*/tosa::RoundingMode::DOUBLE_ROUND, /*scale32=*/true);\n       auto op5_add_op4 = CreateOpAndInfer<tosa::AddOp>(\n           rewriter, op->getLoc(), int32_logits_type, op4_rescale_op3,\n           getTosaConstTensorSingleI32(rewriter, op, 32767, input_rank));\n@@ -1963,7 +1966,7 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n       return buildRescale(rewriter, op, output_type,\n                           op21_rshift_op19_op20.getResult(),\n                           (1.0 / out_quant_type.getScale()) * (1.0 / 32768.0),\n-                          0, out_quant_type.getZeroPoint(), \"SINGLE_ROUND\", true);\n+                          0, out_quant_type.getZeroPoint(), tosa::RoundingMode::SINGLE_ROUND, true);\n     } else {\n       (void)rewriter.notifyMatchFailure(op, \"unknown quantization bitwidth\");\n       return std::nullopt;\n@@ -1991,7 +1994,7 @@ std::optional<Value> convertSoftmaxOp(PatternRewriter& rewriter, Operation* op,\n     auto max_logits = CreateOpAndInfer<tosa::ReduceMaxOp>(\n         rewriter, op->getLoc(), rsum_type, logits_value,\n         rewriter.getI32IntegerAttr(input_rank - 1),\n-        rewriter.getStringAttr(\"PROPAGATE\"));\n+        propagate_attr);\n     auto normalized_logits =\n         CreateOpAndInfer<tosa::SubOp>(rewriter, op->getLoc(), logits_type,\n                                       logits_value, max_logits.getResult());\n@@ -3040,7 +3043,7 @@ std::optional<Value> convertReduceOpCommon(\n     bool is_quantized, int32_t input_scale_multiplier,\n     int32_t input_scale_shift, int64_t input_zp,\n     int32_t output_scale_multiplier, int32_t output_scale_shift,\n-    int64_t output_zp, bool keep_dims, StringRef nan_mode = \"\") {\n+    int64_t output_zp, bool keep_dims, std::optional<tosa::NanPropagationMode> nan_mode = std::nullopt) {\n   RankedTensorType input_type =\n       dyn_cast<RankedTensorType>(input_value.getType());\n   if (!input_type) return std::nullopt;\n@@ -3087,13 +3090,15 @@ std::optional<Value> convertReduceOpCommon(\n \n     if constexpr (std::is_same_v<tosa::ReduceMaxOp, T> ||\n                   std::is_same_v<tosa::ReduceMinOp, T>) {\n-      if (nan_mode != \"PROPAGATE\" && nan_mode != \"IGNORE\") {\n+      if (!nan_mode) {\n         (void)rewriter.notifyMatchFailure(\n             op, \"invalid NaN mode: must be either 'PROPAGATE' or 'IGNORE'\");\n         return std::nullopt;\n       }\n+      const auto nan_mode_attr = tosa::NanPropagationModeAttr::get(\n+          rewriter.getContext(), *nan_mode);\n       val = CreateOpAndInfer<T>(rewriter, op->getLoc(), reduce_type, val,\n-                                axis_attr, rewriter.getStringAttr(nan_mode))\n+                                axis_attr, nan_mode_attr)\n                 .getResult();\n     } else {\n       val = CreateOpAndInfer<T>(rewriter, op->getLoc(), reduce_type, val,\n@@ -3103,7 +3108,8 @@ std::optional<Value> convertReduceOpCommon(\n   }\n \n   if (is_quantized) {\n-    std::string rounding_mode = IsTFLDoubleRoundingMode() ? \"DOUBLE_ROUND\" : \"SINGLE_ROUND\";\n+    const tosa::RoundingMode rounding_mode = IsTFLDoubleRoundingMode() ?\n+        tosa::RoundingMode::DOUBLE_ROUND : tosa::RoundingMode::SINGLE_ROUND;\n     UnrankedTensorType output_rescale_type =\n         UnrankedTensorType::get(output_type.getElementType());\n     val = buildRescale(rewriter, op, output_rescale_type, val,\n@@ -3150,7 +3156,7 @@ std::optional<Value> convertReduceOpCommon(\n     PatternRewriter& rewriter, Operation* op, RankedTensorType output_type,\n     Value input_value, ElementsAttr axes_elems, Type reduce_element_type,\n     bool is_quantized, double input_scale, int64_t input_zp,\n-    double output_scale, int64_t output_zp, bool keep_dims, StringRef nan_mode = \"\") {\n+    double output_scale, int64_t output_zp, bool keep_dims, std::optional<tosa::NanPropagationMode> nan_mode = std::nullopt) {\n   const int32_t scale_width = 32;\n \n   int32_t input_scale_multiplier;\n@@ -3208,7 +3214,7 @@ std::optional<Value> convertReduceMinOp(PatternRewriter& rewriter,\n                                         Value input_value,\n                                         ElementsAttr axes_elems,\n                                         bool keep_dims,\n-                                        StringRef nan_mode) {\n+                                        std::optional<tosa::NanPropagationMode> nan_mode) {\n   RankedTensorType input_type =\n       dyn_cast<RankedTensorType>(input_value.getType());\n   if (!input_type) return std::nullopt;\n@@ -3225,7 +3231,7 @@ std::optional<Value> convertReduceMaxOp(PatternRewriter& rewriter,\n                                         Value input_value,\n                                         ElementsAttr axes_elems,\n                                         bool keep_dims,\n-                                        StringRef nan_mode) {\n+                                        std::optional<tosa::NanPropagationMode> nan_mode) {\n   RankedTensorType input_type =\n       dyn_cast<RankedTensorType>(input_value.getType());\n   if (!input_type) return std::nullopt;\n@@ -3432,11 +3438,11 @@ std::optional<Value> convertReduceMeanOp(PatternRewriter& rewriter,\n // Lowers ResizeBilinear and ResizeNearestNeighbor to TOSA resize.\n std::optional<Value> convertResizeOp(PatternRewriter& rewriter, Operation* op,\n                                      RankedTensorType output_type,\n-                                     Value input_value, StringRef mode,\n+                                     Value input_value, tosa::ResizeMode mode,\n                                      bool align_corners,\n                                      bool half_pixel_centers) {\n-  const bool is_bilinear = mode == \"BILINEAR\";\n-  const bool is_nearest = mode == \"NEAREST_NEIGHBOR\";\n+  const bool is_bilinear = mode == tosa::ResizeMode::BILINEAR;\n+  const bool is_nearest = mode == tosa::ResizeMode::NEAREST_NEIGHBOR;\n   RankedTensorType input_type =\n       dyn_cast<RankedTensorType>(input_value.getType());\n   if (!input_type) return std::nullopt;\n@@ -3553,7 +3559,9 @@ std::optional<Value> convertResizeOp(PatternRewriter& rewriter, Operation* op,\n   auto offset = getTosaConstShape(rewriter, op->getLoc(), {offset_y, offset_x});\n   auto border = getTosaConstShape(rewriter, op->getLoc(), {border_y, border_x});\n \n-  StringAttr resize_mode = rewriter.getStringAttr(mode);\n+\n+  const auto resize_mode_attr = tosa::ResizeModeAttr::get(\n+      rewriter.getContext(), mode);\n \n   auto isInt16Range = [](int x) {\n     return (x <= std::numeric_limits<int16_t>::max()) &&\n@@ -3598,7 +3606,7 @@ std::optional<Value> convertResizeOp(PatternRewriter& rewriter, Operation* op,\n \n       auto resize_op = CreateOpAndInfer<tosa::ResizeOp>(\n           rewriter, op->getLoc(), output_acc_type, input_value, scale, offset,\n-          border, resize_mode);\n+          border, resize_mode_attr);\n \n #ifdef RESIZE_BILINEAR_LOWER_SYMMETRIC_ROUNDING\n       // TFLite resize_bilinear always assume input and output tensors have\n@@ -3641,14 +3649,14 @@ std::optional<Value> convertResizeOp(PatternRewriter& rewriter, Operation* op,\n       // This should be the expected lowering, but is +-1 within compared to\n       // TFLite reference.\n       return buildRescale(rewriter, op, output_type, resize_op.getResult(),\n-                          1.0 / (scale_y_n * scale_x_n), 0, 0, \"SINGLE_ROUND\",\n+                          1.0 / (scale_y_n * scale_x_n), 0, 0, tosa::RoundingMode::SINGLE_ROUND,\n                           is_scale32);\n #endif\n \n     } else if (is_nearest) {\n       auto resize_op = CreateOpAndInfer<tosa::ResizeOp>(\n           rewriter, op->getLoc(), output_type, input_value, scale, offset,\n-          border, resize_mode);\n+          border, resize_mode_attr);\n       return resize_op.getResult();\n     } else {\n       (void)rewriter.notifyMatchFailure(\n@@ -3658,7 +3666,7 @@ std::optional<Value> convertResizeOp(PatternRewriter& rewriter, Operation* op,\n   } else {\n     auto resize_op = CreateOpAndInfer<tosa::ResizeOp>(\n         rewriter, op->getLoc(), output_type, input_value, scale, offset, border,\n-        resize_mode);\n+        resize_mode_attr);\n \n     return resize_op.getResult();\n   }"
        },
        {
            "sha": "de818d9630dea19be1482c89ca8baf30e92529b0",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/legalize_common.h",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_common.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_common.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_common.h?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -20,7 +20,8 @@ limitations under the License.\n #include <optional>\n \n #include \"mlir/IR/PatternMatch.h\"  // from @llvm-project\n-#include \"mlir/Support/LLVM.h\"  // from @llvm-project\n+#include \"mlir/Support/LLVM.h\"     // from @llvm-project\n+#include \"mlir/Dialect/Tosa/IR/TosaOps.h\"  // from @llvm-project\n \n // This file contains legalizations common to mapping both TensorFlow and\n // TensorFlow Lite to TOSA.\n@@ -197,7 +198,7 @@ std::optional<Value> convertReduceMinOp(PatternRewriter& rewriter,\n                                         Value input_value,\n                                         ElementsAttr axes_elems,\n                                         bool keep_dims,\n-                                        StringRef nan_mode = \"PROPAGATE\");\n+                                        std::optional<tosa::NanPropagationMode> nan_mode = tosa::NanPropagationMode::PROPAGATE);\n \n // Lowers ReduceMax to a sequence of TOSA ops.\n std::optional<Value> convertReduceMaxOp(PatternRewriter& rewriter,\n@@ -206,7 +207,7 @@ std::optional<Value> convertReduceMaxOp(PatternRewriter& rewriter,\n                                         Value input_value,\n                                         ElementsAttr axes_elems,\n                                         bool keep_dims,\n-                                        StringRef nan_mode = \"PROPAGATE\");\n+                                        std::optional<tosa::NanPropagationMode> nan_mode = tosa::NanPropagationMode::PROPAGATE);\n \n // Lowers ReduceProd to a sequence of TOSA ops.\n std::optional<Value> convertReduceProdOp(PatternRewriter& rewriter,\n@@ -235,7 +236,7 @@ std::optional<Value> convertReduceMeanOp(PatternRewriter& rewriter,\n // Lowers ResizeBilinear and ResizeNearestNeighbor to TOSA resize.\n std::optional<Value> convertResizeOp(PatternRewriter& rewriter, Operation* op,\n                                      RankedTensorType output_type,\n-                                     Value input_value, StringRef mode,\n+                                     Value input_value, tosa::ResizeMode mode,\n                                      bool align_corners,\n                                      bool half_pixel_centers);\n "
        },
        {
            "sha": "9d227f75bad616a7b0996ab45909b58f5495e17e",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/legalize_tf.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_tf.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_tf.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_tf.cc?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -525,10 +525,11 @@ LogicalResult ConvertTFArgMaxOp::matchAndRewrite(\n   }\n \n   IntegerAttr axis_attr = rewriter.getI32IntegerAttr(axis);\n-\n+  const auto nan_propagate_attr = tosa::NanPropagationModeAttr::get(\n+      rewriter.getContext(), tosa::NanPropagationMode::PROPAGATE);\n   CreateReplaceOpAndInfer<tosa::ArgMaxOp>(rewriter, op, output_type,\n                                           tf_argmax_op.getInput(), axis_attr,\n-                                          rewriter.getStringAttr(\"PROPAGATE\"));\n+                                          nan_propagate_attr);\n \n   return success();\n }\n@@ -1847,7 +1848,8 @@ LogicalResult ConvertTFResizeBilinearOp::matchAndRewrite(\n \n   std::optional<Value> result = convertResizeOp(\n       rewriter, op, output_type, tf_resize_op.getImages(),\n-      StringRef(\"BILINEAR\"), tf_resize_op.getAlignCornersAttr().getValue(),\n+      tosa::ResizeMode::BILINEAR,\n+      tf_resize_op.getAlignCornersAttr().getValue(),\n       tf_resize_op.getHalfPixelCentersAttr().getValue());\n \n   if (!result) return failure();\n@@ -1868,7 +1870,7 @@ LogicalResult ConvertTFResizeNearestNeighborOp::matchAndRewrite(\n \n   std::optional<Value> result =\n       convertResizeOp(rewriter, op, output_type, tf_resize_op.getImages(),\n-                      StringRef(\"NEAREST_NEIGHBOR\"),\n+                      tosa::ResizeMode::NEAREST_NEIGHBOR,\n                       tf_resize_op.getAlignCornersAttr().getValue(),\n                       tf_resize_op.getHalfPixelCentersAttr().getValue());\n "
        },
        {
            "sha": "37a9f4234d992a3307e4bc16c3fd5a70c01854d2",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/legalize_tfl.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 17,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_tfl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_tfl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_tfl.cc?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -353,7 +353,7 @@ LogicalResult ConvertTFLReluOp::matchAndRewrite(\n         buildRescale(rewriter, op, output_type, tfl_relu_op.getX(),\n                      input_qtype.getScale() / output_qtype.getScale(),\n                      input_qtype.getZeroPoint(), output_qtype.getZeroPoint(),\n-                     /*double_round=*/\"SINGLE_ROUND\", /*scale32=*/true);\n+                     /*double_round=*/tosa::RoundingMode::SINGLE_ROUND, /*scale32=*/true);\n   }\n \n   auto element_type = input_type.getElementType();\n@@ -423,7 +423,7 @@ LogicalResult ConvertTFLRelu1Op::matchAndRewrite(\n         buildRescale(rewriter, op, output_type, tfl_relu1_op.getX(),\n                      input_qtype.getScale() / output_qtype.getScale(),\n                      input_qtype.getZeroPoint(), output_qtype.getZeroPoint(),\n-                     /*double_round=*/\"SINGLE_ROUND\", /*scale32=*/true);\n+                     /*double_round=*/tosa::RoundingMode::SINGLE_ROUND, /*scale32=*/true);\n   }\n \n   auto element_type = input_type.getElementType();\n@@ -490,7 +490,7 @@ LogicalResult ConvertTFLRelu0To1Op::matchAndRewrite(\n         buildRescale(rewriter, op, output_type, tfl_relu0to1_op.getX(),\n                      input_qtype.getScale() / output_qtype.getScale(),\n                      input_qtype.getZeroPoint(), output_qtype.getZeroPoint(),\n-                     /*double_round=*/\"SINGLE_ROUND\", /*scale32=*/true);\n+                     /*double_round=*/tosa::RoundingMode::SINGLE_ROUND, /*scale32=*/true);\n   }\n \n   auto element_type = input_type.getElementType();\n@@ -557,7 +557,7 @@ LogicalResult ConvertTFLRelu6Op::matchAndRewrite(\n         buildRescale(rewriter, op, output_type, tfl_relu6_op.getX(),\n                      input_qtype.getScale() / output_qtype.getScale(),\n                      input_qtype.getZeroPoint(), output_qtype.getZeroPoint(),\n-                     /*double_round=*/\"SINGLE_ROUND\", /*scale32=*/true);\n+                     /*double_round=*/tosa::RoundingMode::SINGLE_ROUND, /*scale32=*/true);\n   }\n \n   auto element_type = input_type.getElementType();\n@@ -3249,7 +3249,8 @@ LogicalResult ConvertTFLResizeBilinearOp::matchAndRewrite(\n \n   std::optional<Value> result = convertResizeOp(\n       rewriter, op, output_type, tfl_resize_op.getInput(),\n-      StringRef(\"BILINEAR\"), tfl_resize_op.getAlignCornersAttr().getValue(),\n+      tosa::ResizeMode::BILINEAR,\n+      tfl_resize_op.getAlignCornersAttr().getValue(),\n       tfl_resize_op.getHalfPixelCentersAttr().getValue());\n \n   if (!result) return failure();\n@@ -3270,7 +3271,7 @@ LogicalResult ConvertTFLResizeNearestNeighborOp::matchAndRewrite(\n \n   std::optional<Value> result =\n       convertResizeOp(rewriter, op, output_type, tfl_resize_op.getInput(),\n-                      StringRef(\"NEAREST_NEIGHBOR\"),\n+                      tosa::ResizeMode::NEAREST_NEIGHBOR,\n                       tfl_resize_op.getAlignCornersAttr().getValue(),\n                       tfl_resize_op.getHalfPixelCentersAttr().getValue());\n \n@@ -3756,7 +3757,7 @@ LogicalResult ConvertTFLLogisticOp::matchAndRewrite(\n \n       Value op2_rescale_op1 =\n           buildRescale(rewriter, op, output_type, op1_table_in.getResult(),\n-                       1.0 / 128.0, 0, 0, \"SINGLE_ROUND\", true);\n+                       1.0 / 128.0, 0, 0, tosa::RoundingMode::SINGLE_ROUND, true);\n \n       rewriter.replaceOp(op, {op2_rescale_op1});\n     }\n@@ -3824,7 +3825,7 @@ LogicalResult ConvertTFLTanhOp::matchAndRewrite(\n \n       Value op2_rescale_op1 =\n           buildRescale(rewriter, op, output_type, op1_table_in.getResult(),\n-                       1.0 / 128.0, 0, 0, \"SINGLE_ROUND\", true);\n+                       1.0 / 128.0, 0, 0, tosa::RoundingMode::SINGLE_ROUND, true);\n \n       rewriter.replaceOp(op, {op2_rescale_op1});\n     }\n@@ -3900,7 +3901,7 @@ static LogicalResult LegalizeQuantizedPrelu(Operation* op,\n   // Initalize the negative values to the slope of leaky ReLU.\n   Value op_rescale_slope_in = buildRescale(\n       rewriter, op, output_type, input, scale_alpha, input_qtype.getZeroPoint(),\n-      output_qtype.getZeroPoint(), \"DOUBLE_ROUND\", true);\n+      output_qtype.getZeroPoint(), tosa::RoundingMode::DOUBLE_ROUND, true);\n \n   // Perform an element-wise multiplication on rescaled alpha and input for\n   // PReLU.\n@@ -3917,11 +3918,11 @@ static LogicalResult LegalizeQuantizedPrelu(Operation* op,\n \n   op_rescale_slope_in =\n       buildRescale(rewriter, op, output_type, op_mul, scale_alpha,\n-                   /* input_zp = */ 0, output_qtype.getZeroPoint(), \"DOUBLE_ROUND\", true);\n+                   /* input_zp = */ 0, output_qtype.getZeroPoint(), tosa::RoundingMode::DOUBLE_ROUND, true);\n \n   Value op_rescale_identity_in = buildRescale(\n       rewriter, op, output_type, input, scale_identity,\n-      input_qtype.getZeroPoint(), output_qtype.getZeroPoint(), \"DOUBLE_ROUND\", true);\n+      input_qtype.getZeroPoint(), output_qtype.getZeroPoint(), tosa::RoundingMode::DOUBLE_ROUND, true);\n \n   CreateReplaceOpAndInfer<tosa::SelectOp>(rewriter, op, output_type, op_ge,\n                                           op_rescale_identity_in,\n@@ -3985,11 +3986,11 @@ static LogicalResult LegalizeQuantizedLeakyRelu(Operation* op,\n \n   Value op_rescale_alpha_in =\n       buildRescale(rewriter, op, rescale_type, input, scale_alpha,\n-                   input_qtype.getZeroPoint(), 0, \"DOUBLE_ROUND\", true);\n+                   input_qtype.getZeroPoint(), 0, tosa::RoundingMode::DOUBLE_ROUND, true);\n \n   Value op_rescale_identity_in =\n       buildRescale(rewriter, op, rescale_type, input, scale_identity,\n-                   input_qtype.getZeroPoint(), 0, \"DOUBLE_ROUND\", true);\n+                   input_qtype.getZeroPoint(), 0, tosa::RoundingMode::DOUBLE_ROUND, true);\n \n   Value result_int32;\n   if (alpha <= 1.0) {\n@@ -4191,7 +4192,7 @@ LogicalResult ConvertTFLQuantizeOp::matchAndRewrite(\n     Value rescale_op =\n         buildRescale(rewriter, op, output_type, tfl_quantize_op.getInput(),\n                      rescale_scale, input_element_type.getZeroPoint(),\n-                     element_type.getZeroPoint(), \"DOUBLE_ROUND\", true);\n+                     element_type.getZeroPoint(), tosa::RoundingMode::DOUBLE_ROUND, true);\n \n     rewriter.replaceOp(op, {rescale_op});\n     return success();\n@@ -4531,9 +4532,11 @@ LogicalResult ConvertTFLArgMaxOp::matchAndRewrite(\n     dim += input_type.getRank();\n   }\n \n+  const auto propagate_nan_attr = tosa::NanPropagationModeAttr::get(\n+      rewriter.getContext(), tosa::NanPropagationMode::PROPAGATE);\n   CreateReplaceOpAndInfer<tosa::ArgMaxOp>(\n       rewriter, op, arg_max_op.getType(), arg_max_op.getInput(),\n-      rewriter.getI32IntegerAttr(dim), rewriter.getStringAttr(\"PROPAGATE\"));\n+      rewriter.getI32IntegerAttr(dim), propagate_nan_attr);\n \n   return success();\n }\n@@ -4599,16 +4602,18 @@ LogicalResult ConvertTFLArgMinOp::matchAndRewrite(\n   // double check input/output type cast consistency\n   assert(input_type_casted == (output_zp != 0));\n \n+  const auto propagate_nan_attr = tosa::NanPropagationModeAttr::get(\n+      rewriter.getContext(), tosa::NanPropagationMode::PROPAGATE);\n   Value result = CreateOpAndInfer<tosa::ArgMaxOp>(\n       rewriter, loc, output_ty, input, rewriter.getI32IntegerAttr(dim),\n-      rewriter.getStringAttr(\"PROPAGATE\"));\n+      propagate_nan_attr);\n \n   if (output_zp != 0) {\n     // rescale result to output_zp\n     result = buildRescale(rewriter, op, arg_min_op.getType(), result,\n                           /* sclae = */ 1.0,\n                           /* input_zp = */ 0,\n-                          /* output_zp = */ output_zp, \"SINGLE_ROUND\", true);\n+                          /* output_zp = */ output_zp, tosa::RoundingMode::SINGLE_ROUND, true);\n   }\n \n   rewriter.replaceOp(op, {result});"
        },
        {
            "sha": "d1f6772ae6c5fa457208d2be85f61e212b28d64d",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/legalize_utils.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_utils.cc?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -353,7 +353,7 @@ Value buildRescaleMultiplier(bool scale32, OpBuilder& builder, Location loc,\n Value buildRescale(PatternRewriter& rewriter, Operation* op,\n                    ShapedType output_type, Value input_val,\n                    int32_t scale_multiplier, int32_t scale_shift,\n-                   int64_t input_zp, int64_t output_zp, StringRef rounding_mode,\n+                   int64_t input_zp, int64_t output_zp, tosa::RoundingMode rounding_mode,\n                    bool scale32) {\n   bool input_unsigned = input_val.getType().isUnsignedInteger();\n   bool output_unsigned = output_type.isUnsignedInteger();\n@@ -377,10 +377,12 @@ Value buildRescale(PatternRewriter& rewriter, Operation* op,\n   if (!output_zp_val.has_value())\n     op->emitError(\"Failed to create output zero-point tensor for RescaleOp.\");\n \n+  const auto rounding_mode_attr = tosa::RoundingModeAttr::get(\n+      rewriter.getContext(), rounding_mode);\n   auto rescale_op = CreateOpAndInfer<tosa::RescaleOp>(\n       rewriter, loc, output_type, input_val, multiplier_val, shift_val,\n       input_zp_val.value(), output_zp_val.value(),\n-      rewriter.getBoolAttr(scale32), rewriter.getStringAttr(rounding_mode),\n+      rewriter.getBoolAttr(scale32), rounding_mode_attr,\n       rewriter.getBoolAttr(false), rewriter.getBoolAttr(input_unsigned),\n       rewriter.getBoolAttr(output_unsigned));\n \n@@ -390,7 +392,7 @@ Value buildRescale(PatternRewriter& rewriter, Operation* op,\n // Create a TOSA rescale op from TFLite scaling, zero points and rounding mode\n Value buildRescale(PatternRewriter& rewriter, Operation* op,\n                    ShapedType output_type, Value input_val, double scale,\n-                   int64_t input_zp, int64_t output_zp, StringRef rounding_mode,\n+                   int64_t input_zp, int64_t output_zp, tosa::RoundingMode rounding_mode,\n                    bool scale32) {\n   int32_t multiplier;\n   int32_t shift;\n@@ -420,8 +422,8 @@ Value buildRescaleToInt32(PatternRewriter& rewriter, Operation* op,\n   assert(input_type);\n   auto output_type = input_type.clone(rewriter.getI32Type());\n \n-  std::string rounding_mode =\n-      IsTFLDoubleRoundingMode() ? \"DOUBLE_ROUND\" : \"SINGLE_ROUND\";\n+  const tosa::RoundingMode rounding_mode =\n+      IsTFLDoubleRoundingMode() ? tosa::RoundingMode::DOUBLE_ROUND : tosa::RoundingMode::SINGLE_ROUND;\n \n   return buildRescale(rewriter, op, output_type, input_val,\n                       input_scale_multiplier, input_scale_shift, input_zp,\n@@ -453,8 +455,8 @@ Value buildRescaleFromInt32(PatternRewriter& rewriter, Operation* op,\n   assert(input_type && input_type.getElementType().isInteger(32) &&\n          \"expected rescale input element type to be i32\");\n \n-  std::string rounding_mode =\n-      IsTFLDoubleRoundingMode() ? \"DOUBLE_ROUND\" : \"SINGLE_ROUND\";\n+  const tosa::RoundingMode rounding_mode =\n+      IsTFLDoubleRoundingMode() ? tosa::RoundingMode::DOUBLE_ROUND : tosa::RoundingMode::SINGLE_ROUND;\n \n   // Potentially check input_shape == output_shape here\n   return buildRescale(rewriter, op, output_type, input_val, output_scale,\n@@ -479,7 +481,10 @@ Value buildRescaleOpConvOutput(PatternRewriter& rewriter, Operation* op,\n   bool scale32 = isScale32(output_qtype);\n   int32_t scale_width = scale32 ? 32 : 16;\n   // Only use double round if we are doing 32 bit scaling\n-  std::string rounding_mode = scale32 ? \"DOUBLE_ROUND\" : \"SINGLE_ROUND\";\n+  const tosa::RoundingMode rounding_mode = scale32 ? tosa::RoundingMode::DOUBLE_ROUND\n+      : tosa::RoundingMode::SINGLE_ROUND;\n+  const auto rounding_mode_attr = tosa::RoundingModeAttr::get(\n+      rewriter.getContext(), rounding_mode);\n \n   bool input_unsigned = input_qtype.isUnsignedInteger();\n   bool output_unsigned = output_qtype.isUnsignedInteger();\n@@ -519,7 +524,7 @@ Value buildRescaleOpConvOutput(PatternRewriter& rewriter, Operation* op,\n     auto rescale_op = CreateOpAndInfer<tosa::RescaleOp>(\n         rewriter, loc, output_type, conv_val, multiplier_val, shift_val,\n         input_zp_val.value(), output_zp_val.value(),\n-        rewriter.getBoolAttr(scale32), rewriter.getStringAttr(rounding_mode),\n+        rewriter.getBoolAttr(scale32), rounding_mode_attr,\n         rewriter.getBoolAttr(false), rewriter.getBoolAttr(input_unsigned),\n         rewriter.getBoolAttr(output_unsigned));\n \n@@ -571,7 +576,7 @@ Value buildRescaleOpConvOutput(PatternRewriter& rewriter, Operation* op,\n     auto rescale_op = CreateOpAndInfer<tosa::RescaleOp>(\n         rewriter, loc, output_type, conv_val, multiplier_val, shift_val,\n         input_zp_val.value(), output_zp_val.value(),\n-        rewriter.getBoolAttr(scale32), rewriter.getStringAttr(rounding_mode),\n+        rewriter.getBoolAttr(scale32), rounding_mode_attr,\n         rewriter.getBoolAttr(true), rewriter.getBoolAttr(input_unsigned),\n         rewriter.getBoolAttr(output_unsigned));\n "
        },
        {
            "sha": "20908312f407185431ca768c5569abc71a45a15f",
            "filename": "tensorflow/compiler/mlir/tosa/transforms/legalize_utils.h",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2204898ecbc886d058082779884a83728a46562f/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftosa%2Ftransforms%2Flegalize_utils.h?ref=2204898ecbc886d058082779884a83728a46562f",
            "patch": "@@ -67,13 +67,13 @@ std::optional<Value> buildReshapeWithDynamicDims(PatternRewriter& rewriter,\n Value buildRescale(PatternRewriter& rewriter, Operation* op,\n                    ShapedType output_type, Value input_val,\n                    int32_t scale_multiplier, int32_t scale_shit,\n-                   int64_t input_zp, int64_t output_zp, StringRef rounding_mode,\n+                   int64_t input_zp, int64_t output_zp, tosa::RoundingMode rounding_mode,\n                    bool scale32);\n \n // Create a TOSA rescale op from TFLite scaling, zero points and rounding mode\n Value buildRescale(PatternRewriter& rewriter, Operation* op,\n                    ShapedType output_type, Value input_val, double scale,\n-                   int64_t input_zp, int64_t output_zp, StringRef rounding_mode,\n+                   int64_t input_zp, int64_t output_zp, tosa::RoundingMode rounding_mode,\n                    bool scale32);\n \n // Removes the zero point and cast to int32, no need to handle roundings modes\n@@ -253,7 +253,7 @@ void CreateReplaceOpAndInfer(PatternRewriter& rewriter, Operation* op,\n // Nan propagation mode is only applied to maximum and mininum.\n template <typename TOSA_OP>\n LogicalResult ConvertBinaryOp(Operation* op, PatternRewriter& rewriter,\n-                              StringRef nan_mode = \"\") {\n+                              std::optional<tosa::NanPropagationMode> nan_mode = std::nullopt) {\n   TensorType output_type = dyn_cast<TensorType>(op->getResults()[0].getType());\n   if (!output_type) return failure();\n \n@@ -266,10 +266,12 @@ LogicalResult ConvertBinaryOp(Operation* op, PatternRewriter& rewriter,\n \n   if constexpr (std::is_same_v<tosa::ReduceMaxOp, TOSA_OP> ||\n                 std::is_same_v<tosa::ReduceMinOp, TOSA_OP>) {\n-    if (nan_mode != \"PROPAGATE\" && nan_mode != \"IGNORE\") {\n+    if (!nan_mode) {\n       (void)rewriter.notifyMatchFailure(op, \"invalid NaN mode: must be either 'PROPAGATE' or 'IGNORE'\");\n       return failure();\n     }\n+    const auto nan_mode_attr = tosa::NanPropagationModeAttr::get(\n+        rewriter.getContext(), *nan_mode);\n     CreateReplaceOpAndInfer<TOSA_OP>(rewriter, op, output_type, x, y, nan_mode);\n   } else\n     CreateReplaceOpAndInfer<TOSA_OP>(rewriter, op, output_type, x, y);"
        }
    ],
    "stats": {
        "total": 349,
        "additions": 188,
        "deletions": 161
    }
}