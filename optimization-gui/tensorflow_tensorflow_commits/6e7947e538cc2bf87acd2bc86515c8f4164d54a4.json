{
    "author": "tensorflower-gardener",
    "message": "Integrate LLVM at llvm/llvm-project@ac66ae45cd22\n\nUpdates LLVM usage to match\n[ac66ae45cd22](https://github.com/llvm/llvm-project/commit/ac66ae45cd22)\n\nPiperOrigin-RevId: 840746128",
    "sha": "6e7947e538cc2bf87acd2bc86515c8f4164d54a4",
    "files": [
        {
            "sha": "f04aa96dd598020e8f6489854eb9ea80cd395e6a",
            "filename": "third_party/xla/third_party/llvm/generated.patch",
            "status": "modified",
            "additions": 1133,
            "deletions": 31,
            "changes": 1164,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch?ref=6e7947e538cc2bf87acd2bc86515c8f4164d54a4",
            "patch": "@@ -1,35 +1,1137 @@\n Auto generated patch. Do not edit or delete it, even if empty.\n-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n---- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n-+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n-@@ -1163,6 +1163,7 @@\n-   // (X >= Y) ? INT_MAX : (X + C) --> sadd.sat(X, C)\n-   // where Y is INT_MAX - C or INT_MAX - C - 1, and C > 0\n-   if ((Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE) &&\n-+      isa<Constant>(Cmp1) &&\n-       match(FVal, m_Add(m_Specific(Cmp0), m_StrictlyPositive(C)))) {\n-     APInt IntMax =\n-         APInt::getSignedMaxValue(Cmp1->getType()->getScalarSizeInBits());\n-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/InstCombine/saturating-add-sub.ll b/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n---- a/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n-+++ b/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n-@@ -2671,3 +2671,19 @@\n-   %s = select i1 %cmp, i8 127, i8 %d\n-   ret i8 %s\n+diff -ruN --strip-trailing-cr a/clang/docs/LanguageExtensions.rst b/clang/docs/LanguageExtensions.rst\n+--- a/clang/docs/LanguageExtensions.rst\n++++ b/clang/docs/LanguageExtensions.rst\n+@@ -1833,23 +1833,6 @@\n+ \n+ Clang provides a few builtin aliases to improve the throughput of certain metaprogramming facilities.\n+ \n+-__builtin_common_reference\n+---------------------------\n+-\n+-.. code-block:: c++\n+-\n+-  template <template <class, class, template <class> class, template <class> class> class BasicCommonReferenceT,\n+-            template <class... Args> CommonTypeT,\n+-            template <class> HasTypeMember,\n+-            class HasNoTypeMember,\n+-            class... Ts>\n+-  using __builtin_common_reference = ...;\n+-\n+-This alias is used for implementing ``std::common_reference``. If ``std::common_reference`` should contain a ``type``\n+-member, it is an alias to ``HasTypeMember<TheCommonReference>``. Otherwse it is an alias to ``HasNoTypeMember``. The\n+-``CommonTypeT`` is usually ``std::common_type_t``. ``BasicCommonReferenceT`` is usually an alias template to\n+-``basic_common_reference<T, U, TX, UX>::type``.\n+-\n+ __builtin_common_type\n+ ---------------------\n+ \n+diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/BuiltinTemplates.td b/clang/include/clang/Basic/BuiltinTemplates.td\n+--- a/clang/include/clang/Basic/BuiltinTemplates.td\n++++ b/clang/include/clang/Basic/BuiltinTemplates.td\n+@@ -10,11 +10,11 @@\n+   string Name = name;\n  }\n+ \n+-class Template<list<TemplateArg> args, string name = \"\"> : TemplateArg<name> {\n++class Template<list<TemplateArg> args, string name> : TemplateArg<name> {\n+   list<TemplateArg> Args = args;\n+ }\n+ \n+-class Class<string name = \"\", bit is_variadic = 0> : TemplateArg<name> {\n++class Class<string name, bit is_variadic = 0> : TemplateArg<name> {\n+   bit IsVariadic = is_variadic;\n+ }\n+ \n+@@ -56,32 +56,6 @@\n+    Class<\"HasNoTypeMember\">,\n+    Class<\"Ts\", /*is_variadic=*/1>]>;\n+ \n+-// template <template <class,\"\n+-//                     class,\"\n+-//                     template <class> class,\"\n+-//                     template <class> class> class BasicCommonReferenceT,\"\n+-//           template <class... Args> class CommonTypeT,\"\n+-//           template <class> class HasTypeMember,\"\n+-//           class HasNoTypeMember,\"\n+-//           class... Ts>\"\n+-def __builtin_common_reference : CPlusPlusBuiltinTemplate<\n+-            [Template<[Class<>,\n+-                       Class<>,\n+-                       Template<[Class<>]>,\n+-                       Template<[Class<>]>], \"BasicCommonReferenceT\">,\n+-             Template<[Class<\"Args\", /*is_variadic=*/1>], \"CommonTypeT\">,\n+-             Template<[Class<>], \"HasTypeMember\">,\n+-             Class<\"HasNoTypeMember\">,\n+-             Class<\"Ts\", /*is_variadic=*/1>]>;\n+-\n+-foreach Ref = [\"\", \"lvalue\", \"rvalue\"] in {\n+-  foreach Const = [\"\", \"const\"] in {\n+-    foreach Volatile = [\"\", \"volatile\"] in {\n+-      def __clang_internal_xref_#Ref#Const#Volatile : CPlusPlusBuiltinTemplate<[Class<>]>;\n+-    }\n+-  }\n+-}\n+-\n+ // template <uint32_t Opcode,\n+ //           uint32_t Size,\n+ //           uint32_t Alignment,\n+diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h\n+--- a/clang/include/clang/Sema/Sema.h\n++++ b/clang/include/clang/Sema/Sema.h\n+@@ -15322,17 +15322,6 @@\n+   QualType BuiltinDecay(QualType BaseType, SourceLocation Loc);\n+   QualType BuiltinAddReference(QualType BaseType, UTTKind UKind,\n+                                SourceLocation Loc);\n+-\n+-  QualType BuiltinAddRValueReference(QualType BaseType, SourceLocation Loc) {\n+-    return BuiltinAddReference(BaseType, UnaryTransformType::AddRvalueReference,\n+-                               Loc);\n+-  }\n+-\n+-  QualType BuiltinAddLValueReference(QualType BaseType, SourceLocation Loc) {\n+-    return BuiltinAddReference(BaseType, UnaryTransformType::AddLvalueReference,\n+-                               Loc);\n+-  }\n+-\n+   QualType BuiltinRemoveExtent(QualType BaseType, UTTKind UKind,\n+                                SourceLocation Loc);\n+   QualType BuiltinRemoveReference(QualType BaseType, UTTKind UKind,\n+@@ -15347,9 +15336,6 @@\n+   QualType BuiltinChangeSignedness(QualType BaseType, UTTKind UKind,\n+                                    SourceLocation Loc);\n+ \n+-  bool BuiltinIsConvertible(QualType From, QualType To, SourceLocation Loc,\n+-                            bool CheckNothrow = false);\n+-\n+   bool BuiltinIsBaseOf(SourceLocation RhsTLoc, QualType LhsT, QualType RhsT);\n+ \n+   /// Ensure that the type T is a literal type.\n+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplate.cpp b/clang/lib/Sema/SemaTemplate.cpp\n+--- a/clang/lib/Sema/SemaTemplate.cpp\n++++ b/clang/lib/Sema/SemaTemplate.cpp\n+@@ -3212,36 +3212,6 @@\n+   }\n+ }\n+ \n+-static QualType InstantiateTemplate(Sema &S, ElaboratedTypeKeyword Keyword,\n+-                                    TemplateName Template,\n+-                                    ArrayRef<TemplateArgument> Args,\n+-                                    SourceLocation Loc) {\n+-  TemplateArgumentListInfo ArgList;\n+-  for (auto Arg : Args) {\n+-    if (Arg.getKind() == TemplateArgument::Type) {\n+-      ArgList.addArgument(TemplateArgumentLoc(\n+-          Arg, S.Context.getTrivialTypeSourceInfo(Arg.getAsType())));\n+-    } else {\n+-      ArgList.addArgument(\n+-          S.getTrivialTemplateArgumentLoc(Arg, QualType(), Loc));\n+-    }\n+-  }\n+-\n+-  EnterExpressionEvaluationContext UnevaluatedContext(\n+-      S, Sema::ExpressionEvaluationContext::Unevaluated);\n+-  Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n+-  Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n+-\n+-  QualType Instantiation =\n+-      S.CheckTemplateIdType(Keyword, Template, Loc, ArgList, /*Scope=*/nullptr,\n+-                            /*ForNestedNameSpecifier=*/false);\n+-\n+-  if (SFINAE.hasErrorOccurred())\n+-    return QualType();\n+-\n+-  return Instantiation;\n+-}\n+-\n+ static QualType builtinCommonTypeImpl(Sema &S, ElaboratedTypeKeyword Keyword,\n+                                       TemplateName BaseTemplate,\n+                                       SourceLocation TemplateLoc,\n+@@ -3254,7 +3224,25 @@\n+       return builtinCommonTypeImpl(S, Keyword, BaseTemplate, TemplateLoc,\n+                                    {T1, T2});\n+ \n+-    return InstantiateTemplate(S, Keyword, BaseTemplate, {T1, T2}, TemplateLoc);\n++    TemplateArgumentListInfo Args;\n++    Args.addArgument(TemplateArgumentLoc(\n++        T1, S.Context.getTrivialTypeSourceInfo(T1.getAsType())));\n++    Args.addArgument(TemplateArgumentLoc(\n++        T2, S.Context.getTrivialTypeSourceInfo(T2.getAsType())));\n++\n++    EnterExpressionEvaluationContext UnevaluatedContext(\n++        S, Sema::ExpressionEvaluationContext::Unevaluated);\n++    Sema::SFINAETrap SFINAE(S, /*ForValidityCheck=*/true);\n++    Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n++\n++    QualType BaseTemplateInst = S.CheckTemplateIdType(\n++        Keyword, BaseTemplate, TemplateLoc, Args,\n++        /*Scope=*/nullptr, /*ForNestedNameSpecifier=*/false);\n++\n++    if (SFINAE.hasErrorOccurred())\n++      return QualType();\n++\n++    return BaseTemplateInst;\n+   };\n+ \n+   // Note A: For the common_type trait applied to a template parameter pack T of\n+@@ -3361,233 +3349,6 @@\n+   }\n+ }\n+ \n+-static QualType CopyCV(QualType From, QualType To) {\n+-  if (From.isConstQualified())\n+-    To.addConst();\n+-  if (From.isVolatileQualified())\n+-    To.addVolatile();\n+-  return To;\n+-}\n+-\n+-// Let COND-RES(X, Y) be\n+-//  decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()())\n+-static QualType CondRes(Sema &S, QualType X, QualType Y, SourceLocation Loc) {\n+-  EnterExpressionEvaluationContext UnevaluatedContext(\n+-      S, Sema::ExpressionEvaluationContext::Unevaluated);\n+-  Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n+-  Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n+-\n+-  // false\n+-  OpaqueValueExpr CondExpr(SourceLocation(), S.Context.BoolTy, VK_PRValue);\n+-  ExprResult Cond = &CondExpr;\n+-\n+-  // declval<X(&)()>()()\n+-  OpaqueValueExpr LHSExpr(Loc, X.getNonLValueExprType(S.Context),\n+-                          Expr::getValueKindForType(X));\n+-  ExprResult LHS = &LHSExpr;\n+-\n+-  // declval<Y(&)()>()()\n+-  OpaqueValueExpr RHSExpr(Loc, Y.getNonLValueExprType(S.Context),\n+-                          Expr::getValueKindForType(Y));\n+-  ExprResult RHS = &RHSExpr;\n+-\n+-  ExprValueKind VK = VK_PRValue;\n+-  ExprObjectKind OK = OK_Ordinary;\n+-\n+-  // decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()())\n+-  QualType Result = S.CheckConditionalOperands(Cond, LHS, RHS, VK, OK, Loc);\n+-\n+-  if (SFINAE.hasErrorOccurred())\n+-    return QualType();\n+-  if (VK == VK_LValue)\n+-    return S.BuiltinAddLValueReference(Result, Loc);\n+-  if (VK == VK_XValue)\n+-    return S.BuiltinAddRValueReference(Result, Loc);\n+-  return Result;\n+-}\n+-\n+-static QualType CommonRef(Sema &S, QualType A, QualType B, SourceLocation Loc) {\n+-  // Given types A and B, let X be remove_reference_t<A>, let Y be\n+-  // remove_reference_t<B>, and let COMMON-​REF(A, B) be:\n+-  assert(A->isReferenceType() && B->isReferenceType() &&\n+-         \"A and B have to be ref qualified for a COMMON-REF\");\n+-  auto X = A.getNonReferenceType();\n+-  auto Y = B.getNonReferenceType();\n+-\n+-  // If A and B are both lvalue reference types, COMMON-REF(A, B) is\n+-  // COND-RES(COPYCV(X, Y) &, COPYCV(​Y, X) &) if that type exists and is a\n+-  // reference type.\n+-  if (A->isLValueReferenceType() && B->isLValueReferenceType()) {\n+-    auto CR = CondRes(S, S.BuiltinAddLValueReference(CopyCV(X, Y), Loc),\n+-                      S.BuiltinAddLValueReference(CopyCV(Y, X), Loc), Loc);\n+-    if (CR.isNull() || !CR->isReferenceType())\n+-      return QualType();\n+-    return CR;\n+-  }\n+-\n+-  // Otherwise, let C be remove_reference_t<COMMON-REF(X&, Y&)>&&. If A and B\n+-  // are both rvalue reference types, C is well-formed, and\n+-  // is_convertible_v<A, C> && is_convertible_v<B, C> is true, then\n+-  // COMMON-REF(A, B) is C.\n+-  if (A->isRValueReferenceType() && B->isRValueReferenceType()) {\n+-    auto C = CommonRef(S, S.BuiltinAddLValueReference(X, Loc),\n+-                       S.BuiltinAddLValueReference(Y, Loc), Loc);\n+-    if (C.isNull())\n+-      return QualType();\n+-\n+-    C = C.getNonReferenceType();\n+-\n+-    if (S.BuiltinIsConvertible(A, C, Loc) && S.BuiltinIsConvertible(B, C, Loc))\n+-      return S.BuiltinAddRValueReference(C, Loc);\n+-    return QualType();\n+-  }\n+-\n+-  // Otherwise, if A is an lvalue reference and B is an rvalue reference, then\n+-  // COMMON-REF(A, B) is COMMON-REF(B, A).\n+-  if (A->isLValueReferenceType() && B->isRValueReferenceType())\n+-    std::swap(A, B);\n+-\n+-  // Otherwise, let D be COMMON-REF(const X&, Y&). If A is an rvalue reference\n+-  // and B is an lvalue reference and D is well-formed and\n+-  // is_convertible_v<A, D> is true, then COMMON-REF(A, B) is D.\n+-  if (A->isRValueReferenceType() && B->isLValueReferenceType()) {\n+-    auto X2 = X;\n+-    X2.addConst();\n+-    auto D = CommonRef(S, S.BuiltinAddLValueReference(X2, Loc),\n+-                       S.BuiltinAddLValueReference(Y, Loc), Loc);\n+-    if (!D.isNull() && S.BuiltinIsConvertible(A, D, Loc))\n+-      return D;\n+-    return QualType();\n+-  }\n+-\n+-  // Otherwise, COMMON-REF(A, B) is ill-formed.\n+-  // This is implemented by returning from the individual branches above.\n+-\n+-  llvm_unreachable(\"The above cases should be exhaustive\");\n+-}\n+-\n+-static QualType builtinCommonReferenceImpl(Sema &S,\n+-                                           ElaboratedTypeKeyword Keyword,\n+-                                           TemplateName CommonReference,\n+-                                           TemplateName CommonType,\n+-                                           SourceLocation TemplateLoc,\n+-                                           ArrayRef<TemplateArgument> Ts) {\n+-  switch (Ts.size()) {\n+-  // If sizeof...(T) is zero, there shall be no member type.\n+-  case 0:\n+-    return QualType();\n+-\n+-  // Otherwise, if sizeof...(T) is one, let T0 denote the sole type in the\n+-  // pack T. The member typedef type shall denote the same type as T0.\n+-  case 1:\n+-    return Ts[0].getAsType();\n+-\n+-  // Otherwise, if sizeof...(T) is two, let T1 and T2 denote the two types in\n+-  // the pack T. Then\n+-  case 2: {\n+-    auto T1 = Ts[0].getAsType();\n+-    auto T2 = Ts[1].getAsType();\n+-\n+-    // Let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is\n+-    // well-formed, and is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> &&\n+-    // is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is true, then the\n+-    // member typedef type denotes R.\n+-    if (T1->isReferenceType() && T2->isReferenceType()) {\n+-      QualType R = CommonRef(S, T1, T2, TemplateLoc);\n+-      if (!R.isNull()) {\n+-        if (S.BuiltinIsConvertible(S.BuiltinAddPointer(T1, TemplateLoc),\n+-                                   S.BuiltinAddPointer(R, TemplateLoc),\n+-                                   TemplateLoc) &&\n+-            S.BuiltinIsConvertible(S.BuiltinAddPointer(T2, TemplateLoc),\n+-                                   S.BuiltinAddPointer(R, TemplateLoc),\n+-                                   TemplateLoc)) {\n+-          return R;\n+-        }\n+-      }\n+-    }\n+-\n+-    // Otherwise, if basic_common_reference<remove_cvref_t<T1>,\n+-    // remove_cvref_t<T2>, ​XREF(​T1), XREF(T2)>​::​type is well-formed,\n+-    // then the member typedef type denotes that type.\n+-    {\n+-      auto getXRef = [&](QualType T) {\n+-        BuiltinTemplateDecl *Quals[12] = {\n+-            S.Context.get__clang_internal_xref_Decl(),\n+-            S.Context.get__clang_internal_xref_constDecl(),\n+-            S.Context.get__clang_internal_xref_volatileDecl(),\n+-            S.Context.get__clang_internal_xref_constvolatileDecl(),\n+-            S.Context.get__clang_internal_xref_lvalueDecl(),\n+-            S.Context.get__clang_internal_xref_lvalueconstDecl(),\n+-            S.Context.get__clang_internal_xref_lvaluevolatileDecl(),\n+-            S.Context.get__clang_internal_xref_lvalueconstvolatileDecl(),\n+-            S.Context.get__clang_internal_xref_rvalueDecl(),\n+-            S.Context.get__clang_internal_xref_rvalueconstDecl(),\n+-            S.Context.get__clang_internal_xref_rvaluevolatileDecl(),\n+-            S.Context.get__clang_internal_xref_rvalueconstvolatileDecl(),\n+-        };\n+-        size_t Index = 0;\n+-        if (T->isLValueReferenceType()) {\n+-          T = T.getNonReferenceType();\n+-          Index += 4;\n+-        } else if (T->isRValueReferenceType()) {\n+-          T = T.getNonReferenceType();\n+-          Index += 8;\n+-        }\n+-        if (T.isConstQualified())\n+-          Index += 1;\n+-\n+-        if (T.isVolatileQualified())\n+-          Index += 2;\n+-\n+-        return Quals[Index];\n+-      };\n+-\n+-      auto BCR = InstantiateTemplate(S, Keyword, CommonReference,\n+-                                     {S.BuiltinRemoveCVRef(T1, TemplateLoc),\n+-                                      S.BuiltinRemoveCVRef(T2, TemplateLoc),\n+-                                      TemplateName{getXRef(T1)},\n+-                                      TemplateName{getXRef(T2)}},\n+-                                     TemplateLoc);\n+-      if (!BCR.isNull())\n+-        return BCR;\n+-    }\n+-\n+-    // Otherwise, if COND-RES(T1, T2) is well-formed, then the member typedef\n+-    // type denotes that type.\n+-    if (auto CR = CondRes(S, T1, T2, TemplateLoc); !CR.isNull())\n+-      return CR;\n+-\n+-    // Otherwise, if common_type_t<T1, T2> is well-formed, then the member\n+-    // typedef type denotes that type.\n+-    if (auto CT =\n+-            InstantiateTemplate(S, Keyword, CommonType, {T1, T2}, TemplateLoc);\n+-        !CT.isNull())\n+-      return CT;\n+-\n+-    // Otherwise, there shall be no member type.\n+-    return QualType();\n+-  }\n+-\n+-  // Otherwise, if sizeof...(T) is greater than two, let T1, T2, and Rest,\n+-  // respectively, denote the first, second, and (pack of) remaining types\n+-  // comprising T. Let C be the type common_reference_t<T1, T2>. Then:\n+-  default: {\n+-    auto T1 = Ts[0];\n+-    auto T2 = Ts[1];\n+-    auto Rest = Ts.drop_front(2);\n+-    auto C = builtinCommonReferenceImpl(S, Keyword, CommonReference, CommonType,\n+-                                        TemplateLoc, {T1, T2});\n+-    if (C.isNull())\n+-      return QualType();\n+-    llvm::SmallVector<TemplateArgument, 4> Args;\n+-    Args.emplace_back(C);\n+-    Args.append(Rest.begin(), Rest.end());\n+-    return builtinCommonReferenceImpl(S, Keyword, CommonReference, CommonType,\n+-                                      TemplateLoc, Args);\n+-  }\n+-  }\n+-}\n+-\n+ static bool isInVkNamespace(const RecordType *RT) {\n+   DeclContext *DC = RT->getDecl()->getDeclContext();\n+   if (!DC)\n+@@ -3746,89 +3507,6 @@\n+     return HasNoTypeMember;\n+   }\n+ \n+-  case BTK__builtin_common_reference: {\n+-    assert(Converted.size() == 5);\n+-    if (llvm::any_of(Converted, [](auto &C) { return C.isDependent(); }))\n+-      return QualType();\n+-\n+-    TemplateName BasicCommonReference = Converted[0].getAsTemplate();\n+-    TemplateName CommonType = Converted[1].getAsTemplate();\n+-    TemplateName HasTypeMember = Converted[2].getAsTemplate();\n+-    QualType HasNoTypeMember = Converted[3].getAsType();\n+-    ArrayRef<TemplateArgument> Ts = Converted[4].getPackAsArray();\n+-    if (auto CR =\n+-            builtinCommonReferenceImpl(SemaRef, Keyword, BasicCommonReference,\n+-                                       CommonType, TemplateLoc, Ts);\n+-        !CR.isNull()) {\n+-      TemplateArgumentListInfo TAs;\n+-      TAs.addArgument(TemplateArgumentLoc(\n+-          TemplateArgument(CR), SemaRef.Context.getTrivialTypeSourceInfo(\n+-                                    CR, TemplateArgs[1].getLocation())));\n+-      return SemaRef.CheckTemplateIdType(Keyword, HasTypeMember, TemplateLoc,\n+-                                         TAs, /*Scope=*/nullptr,\n+-                                         /*ForNestedNameSpecifier=*/false);\n+-    }\n+-    return HasNoTypeMember;\n+-  }\n+-\n+-  case BTK__clang_internal_xref_:\n+-  case BTK__clang_internal_xref_const:\n+-  case BTK__clang_internal_xref_volatile:\n+-  case BTK__clang_internal_xref_constvolatile:\n+-  case BTK__clang_internal_xref_lvalue:\n+-  case BTK__clang_internal_xref_lvalueconst:\n+-  case BTK__clang_internal_xref_lvaluevolatile:\n+-  case BTK__clang_internal_xref_lvalueconstvolatile:\n+-  case BTK__clang_internal_xref_rvalue:\n+-  case BTK__clang_internal_xref_rvalueconst:\n+-  case BTK__clang_internal_xref_rvaluevolatile:\n+-  case BTK__clang_internal_xref_rvalueconstvolatile: {\n+-    if (llvm::any_of(Converted, [](auto &C) { return C.isDependent(); }))\n+-      return QualType();\n+-\n+-    auto BTK = BTD->getBuiltinTemplateKind();\n+-    auto anyOf = [&](auto... Vals) { return ((BTK == Vals) || ...); };\n+-\n+-    bool AddCV = anyOf(BTK__clang_internal_xref_constvolatile,\n+-                       BTK__clang_internal_xref_lvalueconstvolatile,\n+-                       BTK__clang_internal_xref_rvalueconstvolatile);\n+-\n+-    bool AddConst = AddCV || anyOf(BTK__clang_internal_xref_const,\n+-                                   BTK__clang_internal_xref_lvalueconst,\n+-                                   BTK__clang_internal_xref_rvalueconst);\n+-\n+-    bool AddVolatile = AddCV || anyOf(BTK__clang_internal_xref_volatile,\n+-                                      BTK__clang_internal_xref_lvaluevolatile,\n+-                                      BTK__clang_internal_xref_rvaluevolatile);\n+-\n+-    bool AddLValue = anyOf(BTK__clang_internal_xref_lvalue,\n+-                           BTK__clang_internal_xref_lvalueconst,\n+-                           BTK__clang_internal_xref_lvaluevolatile,\n+-                           BTK__clang_internal_xref_lvalueconstvolatile);\n+-\n+-    bool AddRValue = anyOf(BTK__clang_internal_xref_rvalue,\n+-                           BTK__clang_internal_xref_rvalueconst,\n+-                           BTK__clang_internal_xref_rvaluevolatile,\n+-                           BTK__clang_internal_xref_rvalueconstvolatile);\n+-\n+-    assert(Converted.size() == 1);\n+-\n+-    QualType T = Converted[0].getAsType();\n+-\n+-    if (AddConst)\n+-      T.addConst();\n+-\n+-    if (AddVolatile)\n+-      T.addVolatile();\n+-\n+-    if (AddLValue)\n+-      T = SemaRef.BuiltinAddLValueReference(T, TemplateLoc);\n+-    else if (AddRValue)\n+-      T = SemaRef.BuiltinAddRValueReference(T, TemplateLoc);\n+-\n+-    return T;\n+-  }\n+-\n+   case BTK__hlsl_spirv_type: {\n+     assert(Converted.size() == 4);\n+ \n+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp\n+--- a/clang/lib/Sema/SemaType.cpp\n++++ b/clang/lib/Sema/SemaType.cpp\n+@@ -32,8 +32,6 @@\n+ #include \"clang/Lex/Preprocessor.h\"\n+ #include \"clang/Sema/DeclSpec.h\"\n+ #include \"clang/Sema/DelayedDiagnostic.h\"\n+-#include \"clang/Sema/EnterExpressionEvaluationContext.h\"\n+-#include \"clang/Sema/Initialization.h\"\n+ #include \"clang/Sema/Lookup.h\"\n+ #include \"clang/Sema/ParsedAttr.h\"\n+ #include \"clang/Sema/ParsedTemplate.h\"\n+@@ -10074,81 +10072,6 @@\n+   return Context.getQualifiedType(Underlying, BaseType.getQualifiers());\n+ }\n+ \n+-bool Sema::BuiltinIsConvertible(QualType From, QualType To, SourceLocation Loc,\n+-                                bool CheckNothrow) {\n+-  if (To->isVoidType())\n+-    return From->isVoidType();\n+-\n+-  // [meta.rel]\n+-  // From and To shall be complete types, cv void, or arrays of unknown bound.\n+-  if ((!From->isIncompleteArrayType() && !From->isVoidType() &&\n+-       RequireCompleteType(\n+-           Loc, From, diag::err_incomplete_type_used_in_type_trait_expr)) ||\n+-      (!To->isIncompleteArrayType() && !To->isVoidType() &&\n+-       RequireCompleteType(Loc, To,\n+-                           diag::err_incomplete_type_used_in_type_trait_expr)))\n+-    return false;\n+-\n+-  // C++11 [meta.rel]p4:\n+-  //   Given the following function prototype:\n+-  //\n+-  //     template <class T>\n+-  //       typename add_rvalue_reference<T>::type create();\n+-  //\n+-  //   the predicate condition for a template specialization\n+-  //   is_convertible<From, To> shall be satisfied if and only if\n+-  //   the return expression in the following code would be\n+-  //   well-formed, including any implicit conversions to the return\n+-  //   type of the function:\n+-  //\n+-  //     To test() {\n+-  //       return create<From>();\n+-  //     }\n+-  //\n+-  //   Access checking is performed as if in a context unrelated to To and\n+-  //   From. Only the validity of the immediate context of the expression\n+-  //   of the return-statement (including conversions to the return type)\n+-  //   is considered.\n+-  //\n+-  // We model the initialization as a copy-initialization of a temporary\n+-  // of the appropriate type, which for this expression is identical to the\n+-  // return statement (since NRVO doesn't apply).\n+-\n+-  // Functions aren't allowed to return function or array types.\n+-  if (To->isFunctionType() || To->isArrayType())\n+-    return false;\n+-\n+-  // A function definition requires a non-abstract return type.\n+-  if (isAbstractType(Loc, To))\n+-    return false;\n+-\n+-  From = BuiltinAddRValueReference(From, Loc);\n+-\n+-  // Build a fake source and destination for initialization.\n+-  InitializedEntity ToEntity(InitializedEntity::InitializeTemporary(To));\n+-  OpaqueValueExpr FromExpr(Loc, From.getNonLValueExprType(Context),\n+-                           Expr::getValueKindForType(From));\n+-  InitializationKind Kind =\n+-      InitializationKind::CreateCopy(Loc, SourceLocation());\n+-\n+-  // Perform the initialization in an unevaluated context within a SFINAE\n+-  // trap at translation unit scope.\n+-  EnterExpressionEvaluationContext Unevaluated(\n+-      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n+-  Sema::SFINAETrap SFINAE(*this, /*AccessCheckingSFINAE=*/true);\n+-  Sema::ContextRAII TUContext(*this, Context.getTranslationUnitDecl());\n+-  Expr *FromExprPtr = &FromExpr;\n+-  InitializationSequence Init(*this, ToEntity, Kind, FromExprPtr);\n+-  if (Init.Failed())\n+-    return false;\n+-\n+-  ExprResult Result = Init.Perform(*this, ToEntity, Kind, FromExprPtr);\n+-  if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n+-    return false;\n+-\n+-  return !CheckNothrow || canThrow(Result.get()) == CT_Cannot;\n+-}\n+-\n+ QualType Sema::BuildUnaryTransformType(QualType BaseType, UTTKind UKind,\n+                                        SourceLocation Loc) {\n+   if (BaseType->isDependentType())\n+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTypeTraits.cpp b/clang/lib/Sema/SemaTypeTraits.cpp\n+--- a/clang/lib/Sema/SemaTypeTraits.cpp\n++++ b/clang/lib/Sema/SemaTypeTraits.cpp\n+@@ -1212,6 +1212,76 @@\n+                                     const TypeSourceInfo *Rhs,\n+                                     SourceLocation KeyLoc);\n+ \n++static ExprResult CheckConvertibilityForTypeTraits(\n++    Sema &Self, const TypeSourceInfo *Lhs, const TypeSourceInfo *Rhs,\n++    SourceLocation KeyLoc, llvm::BumpPtrAllocator &OpaqueExprAllocator) {\n++\n++  QualType LhsT = Lhs->getType();\n++  QualType RhsT = Rhs->getType();\n++\n++  // C++0x [meta.rel]p4:\n++  //   Given the following function prototype:\n++  //\n++  //     template <class T>\n++  //       typename add_rvalue_reference<T>::type create();\n++  //\n++  //   the predicate condition for a template specialization\n++  //   is_convertible<From, To> shall be satisfied if and only if\n++  //   the return expression in the following code would be\n++  //   well-formed, including any implicit conversions to the return\n++  //   type of the function:\n++  //\n++  //     To test() {\n++  //       return create<From>();\n++  //     }\n++  //\n++  //   Access checking is performed as if in a context unrelated to To and\n++  //   From. Only the validity of the immediate context of the expression\n++  //   of the return-statement (including conversions to the return type)\n++  //   is considered.\n++  //\n++  // We model the initialization as a copy-initialization of a temporary\n++  // of the appropriate type, which for this expression is identical to the\n++  // return statement (since NRVO doesn't apply).\n++\n++  // Functions aren't allowed to return function or array types.\n++  if (RhsT->isFunctionType() || RhsT->isArrayType())\n++    return ExprError();\n++\n++  // A function definition requires a complete, non-abstract return type.\n++  if (!Self.isCompleteType(Rhs->getTypeLoc().getBeginLoc(), RhsT) ||\n++      Self.isAbstractType(Rhs->getTypeLoc().getBeginLoc(), RhsT))\n++    return ExprError();\n++\n++  // Compute the result of add_rvalue_reference.\n++  if (LhsT->isObjectType() || LhsT->isFunctionType())\n++    LhsT = Self.Context.getRValueReferenceType(LhsT);\n++\n++  // Build a fake source and destination for initialization.\n++  InitializedEntity To(InitializedEntity::InitializeTemporary(RhsT));\n++  Expr *From = new (OpaqueExprAllocator.Allocate<OpaqueValueExpr>())\n++      OpaqueValueExpr(KeyLoc, LhsT.getNonLValueExprType(Self.Context),\n++                      Expr::getValueKindForType(LhsT));\n++  InitializationKind Kind =\n++      InitializationKind::CreateCopy(KeyLoc, SourceLocation());\n++\n++  // Perform the initialization in an unevaluated context within a SFINAE\n++  // trap at translation unit scope.\n++  EnterExpressionEvaluationContext Unevaluated(\n++      Self, Sema::ExpressionEvaluationContext::Unevaluated);\n++  Sema::SFINAETrap SFINAE(Self, /*ForValidityCheck=*/true);\n++  Sema::ContextRAII TUContext(Self, Self.Context.getTranslationUnitDecl());\n++  InitializationSequence Init(Self, To, Kind, From);\n++  if (Init.Failed())\n++    return ExprError();\n++\n++  ExprResult Result = Init.Perform(Self, To, Kind, From);\n++  if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n++    return ExprError();\n +\n-+; Make sure we don't crash in this case.\n-+define i32 @pr153053_strict_pred_with_nonconstant_rhs(i32 %x, i32 %y) {\n-+; CHECK-LABEL: @pr153053_strict_pred_with_nonconstant_rhs(\n-+; CHECK-NEXT:  entry:\n-+; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]\n-+; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1\n-+; CHECK-NEXT:    [[RES:%.*]] = select i1 [[CMP]], i32 [[ADD]], i32 2147483647\n-+; CHECK-NEXT:    ret i32 [[RES]]\n-+;\n-+entry:\n-+  %cmp = icmp slt i32 %x, %y\n-+  %add = add i32 %x, 1\n-+  %res = select i1 %cmp, i32 %add, i32 2147483647\n-+  ret i32 %res\n++  return Result;\n +}\n++\n+ static APValue EvaluateSizeTTypeTrait(Sema &S, TypeTrait Kind,\n+                                       SourceLocation KWLoc,\n+                                       ArrayRef<TypeSourceInfo *> Args,\n+@@ -1372,8 +1442,9 @@\n+           S.Context.getPointerType(T.getNonReferenceType()));\n+       TypeSourceInfo *UPtr = S.Context.CreateTypeSourceInfo(\n+           S.Context.getPointerType(U.getNonReferenceType()));\n+-      return S.BuiltinIsConvertible(UPtr->getType(), TPtr->getType(),\n+-                                    RParenLoc);\n++      return !CheckConvertibilityForTypeTraits(S, UPtr, TPtr, RParenLoc,\n++                                               OpaqueExprAllocator)\n++                  .isInvalid();\n+     }\n+ \n+     if (Kind == clang::TT_IsNothrowConstructible)\n+@@ -1624,9 +1695,20 @@\n+   }\n+   case BTT_IsConvertible:\n+   case BTT_IsConvertibleTo:\n+-  case BTT_IsNothrowConvertible:\n+-    return Self.BuiltinIsConvertible(LhsT, RhsT, KeyLoc,\n+-                                     BTT == BTT_IsNothrowConvertible);\n++  case BTT_IsNothrowConvertible: {\n++    if (RhsT->isVoidType())\n++      return LhsT->isVoidType();\n++    llvm::BumpPtrAllocator OpaqueExprAllocator;\n++    ExprResult Result = CheckConvertibilityForTypeTraits(Self, Lhs, Rhs, KeyLoc,\n++                                                         OpaqueExprAllocator);\n++    if (Result.isInvalid())\n++      return false;\n++\n++    if (BTT != BTT_IsNothrowConvertible)\n++      return true;\n++\n++    return Self.canThrow(Result.get()) == CT_Cannot;\n++  }\n+ \n+   case BTT_IsAssignable:\n+   case BTT_IsNothrowAssignable:\n+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/type-trait-common-reference.cpp b/clang/test/SemaCXX/type-trait-common-reference.cpp\n+--- a/clang/test/SemaCXX/type-trait-common-reference.cpp\n++++ b/clang/test/SemaCXX/type-trait-common-reference.cpp\n+@@ -1,136 +0,0 @@\n+-// RUN: %clang_cc1 -triple x86_64-apple-darwin10 -fsyntax-only -verify -std=c++17 -Wno-vla-cxx-extension %s\n+-// RUN: %clang_cc1 -triple x86_64-apple-darwin10 -fsyntax-only -verify -std=c++20 -Wno-vla-cxx-extension %s\n+-\n+-#if !__has_builtin(__builtin_common_reference)\n+-#  error\n+-#endif\n+-\n+-// expected-note@*:* {{template <template <class, class, template <class> class, template <class> class> class, template <class ...> class, template <class> class, class, class ...>}}\n+-\n+-void test() {\n+-  __builtin_common_reference<> a; // expected-error {{too few template arguments for template '__builtin_common_reference'}}\n+-  __builtin_common_reference<1> b; // expected-error {{template argument for template template parameter must be a class template or type alias template}}\n+-  __builtin_common_reference<int, 1> c; // expected-error {{template argument for template template parameter must be a class template or type alias template}}\n+-}\n+-\n+-struct empty_type {};\n+-\n+-template <class T>\n+-struct type_identity {\n+-  using type = T;\n+-};\n+-\n+-template <class...>\n+-struct common_type;\n+-\n+-template <class... Args>\n+-using common_type_t = typename common_type<Args...>::type;\n+-\n+-template <class, class, template <class> class, template <class> class>\n+-struct basic_common_reference {};\n+-\n+-template <class T, class U, template <class> class TX, template <class> class UX>\n+-using basic_common_reference_t = typename basic_common_reference<T, U, TX, UX>::type;\n+-\n+-void test_vla() {\n+-  int i = 4;\n+-  int VLA[i];\n+-  __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, decltype(VLA)> d; // expected-error {{variably modified type 'decltype(VLA)' (aka 'int[i]') cannot be used as a template argument}}\n+-}\n+-\n+-template <class... Args>\n+-using common_reference_base = __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, Args...>;\n+-\n+-template <class... Args>\n+-struct common_reference : common_reference_base<Args...> {};\n+-\n+-template <class... Args>\n+-using common_reference_t = typename __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, Args...>::type;\n+-\n+-struct Incomplete;\n+-\n+-template<>\n+-struct common_type<Incomplete, Incomplete>;\n+-\n+-static_assert(__is_same(common_reference_base<>, empty_type));\n+-\n+-static_assert(__is_same(common_reference_base<Incomplete>, type_identity<Incomplete>));\n+-static_assert(__is_same(common_reference_base<char>, type_identity<char>));\n+-static_assert(__is_same(common_reference_base<int>, type_identity<int>));\n+-static_assert(__is_same(common_reference_base<const int>, type_identity<const int>));\n+-static_assert(__is_same(common_reference_base<volatile int>, type_identity<volatile int>));\n+-static_assert(__is_same(common_reference_base<const volatile int>, type_identity<const volatile int>));\n+-static_assert(__is_same(common_reference_base<int[]>, type_identity<int[]>));\n+-static_assert(__is_same(common_reference_base<const int[]>, type_identity<const int[]>));\n+-static_assert(__is_same(common_reference_base<void(&)()>, type_identity<void(&)()>));\n+-\n+-static_assert(__is_same(common_reference_base<int[], int[]>, type_identity<int*>));\n+-static_assert(__is_same(common_reference_base<int, int>, type_identity<int>));\n+-static_assert(__is_same(common_reference_base<int, long>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<long, int>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<long, long>, type_identity<long>));\n+-\n+-static_assert(__is_same(common_reference_base<const int, long>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<const volatile int, long>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<int, const long>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<int, const volatile long>, type_identity<long>));\n+-\n+-static_assert(__is_same(common_reference_base<int*, long*>, empty_type));\n+-static_assert(__is_same(common_reference_base<const unsigned int *const &, const unsigned int *const &>, type_identity<const unsigned int *const &>));\n+-\n+-static_assert(__is_same(common_reference_base<int, long, float>, type_identity<float>));\n+-static_assert(__is_same(common_reference_base<unsigned, char, long>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<long long, long long, long>, type_identity<long long>));\n+-\n+-static_assert(__is_same(common_reference_base<int [[clang::address_space(1)]]>, type_identity<int [[clang::address_space(1)]]>));\n+-static_assert(__is_same(common_reference_base<int [[clang::address_space(1)]], int>, type_identity<int>));\n+-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], int>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], int [[clang::address_space(1)]]>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], long [[clang::address_space(1)]]>, type_identity<long>));\n+-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], long [[clang::address_space(2)]]>, type_identity<long>));\n+-\n+-struct S {};\n+-struct T : S {};\n+-struct U {};\n+-\n+-static_assert(__is_same(common_reference_base<S&&, T&&>, type_identity<S&&>));\n+-\n+-static_assert(__is_same(common_reference_base<int S::*, int S::*>, type_identity<int S::*>));\n+-static_assert(__is_same(common_reference_base<int S::*, int T::*>, type_identity<int T::*>));\n+-static_assert(__is_same(common_reference_base<int S::*, long S::*>, empty_type));\n+-\n+-static_assert(__is_same(common_reference_base<int (S::*)(), int (S::*)()>, type_identity<int (S::*)()>));\n+-static_assert(__is_same(common_reference_base<int (S::*)(), int (T::*)()>, type_identity<int (T::*)()>));\n+-static_assert(__is_same(common_reference_base<int (S::*)(), long (S::*)()>, empty_type));\n+-\n+-static_assert(__is_same(common_reference_base<int&, int&>, type_identity<int&>));\n+-static_assert(__is_same(common_reference_base<int&, const int&>, type_identity<const int&>));\n+-static_assert(__is_same(common_reference_base<volatile int&, const int&>, type_identity<const volatile int&>));\n+-\n+-template <class T, class U>\n+-struct my_pair;\n+-\n+-template <class T1, class U1, class T2, class U2, template <class> class TX, template <class> class UX>\n+-struct basic_common_reference<my_pair<T1, U1>, my_pair<T2, U2>, TX, UX> {\n+-  using type = my_pair<common_reference_t<TX<T1>, UX<T2>>, common_reference_t<TX<U1>, UX<U2>>>;\n+-};\n+-\n+-static_assert(__is_same(common_reference_base<my_pair<const int&, int&>, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, volatile int&>>));\n+-static_assert(__is_same(common_reference_base<const my_pair<int, int>&, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, const volatile int&>>));\n+-static_assert(__is_same(common_reference_base<const int&, const volatile int&>, type_identity<const volatile int&>));\n+-static_assert(__is_same(common_reference_base<int&&, const volatile int&>, type_identity<int>));\n+-static_assert(__is_same(common_reference_base<my_pair<int, int>&&, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, int>>));\n+-static_assert(__is_same(common_reference_base<my_pair<int, int>&&, my_pair<int&, int>&&>, type_identity<my_pair<const int&, int&&>>));\n+-\n+-struct conversion_operator {\n+-  operator volatile int&&() volatile;\n+-};\n+-\n+-static_assert(__is_same(common_reference_base<volatile conversion_operator&&, volatile int&&>, type_identity<volatile int&&>));\n+-\n+-struct reference_wrapper {\n+-  reference_wrapper(int&);\n+-  operator int&() const;\n+-};\n+-\n+-static_assert(__is_same(common_reference_base<const reference_wrapper&, int&>, empty_type));\n+diff -ruN --strip-trailing-cr a/libcxx/include/__locale_dir/num.h b/libcxx/include/__locale_dir/num.h\n+--- a/libcxx/include/__locale_dir/num.h\n++++ b/libcxx/include/__locale_dir/num.h\n+@@ -436,6 +436,7 @@\n+         ++__first;\n+         if (__first == __last) {\n+           __err |= ios_base::eofbit;\n++          __v = 0;\n+           return __first;\n+         }\n+         // __c2 == 'x' || __c2 == 'X'\n+@@ -444,6 +445,7 @@\n+           ++__first;\n+         } else {\n+           __base = 8;\n++          __parsed_num = true; // We only swallowed '0', so we've started to parse a number\n+         }\n+       } else {\n+         __base = 10;\n+diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap.in b/libcxx/include/module.modulemap.in\n+--- a/libcxx/include/module.modulemap.in\n++++ b/libcxx/include/module.modulemap.in\n+@@ -1517,7 +1517,6 @@\n+       header \"__iterator/iterator_traits.h\"\n+       export std_core.type_traits.integral_constant\n+       export std_core.type_traits.is_convertible\n+-      export std_core.type_traits.nat\n+     }\n+     module iterator_with_data         { header \"__iterator/iterator_with_data.h\" }\n+     module iterator                   { header \"__iterator/iterator.h\" }\n+diff -ruN --strip-trailing-cr a/libcxx/include/__type_traits/common_reference.h b/libcxx/include/__type_traits/common_reference.h\n+--- a/libcxx/include/__type_traits/common_reference.h\n++++ b/libcxx/include/__type_traits/common_reference.h\n+@@ -18,37 +18,16 @@\n+ #include <__type_traits/is_reference.h>\n+ #include <__type_traits/remove_cvref.h>\n+ #include <__type_traits/remove_reference.h>\n+-#include <__type_traits/type_identity.h>\n+ #include <__utility/declval.h>\n+ \n+ #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n+ #  pragma GCC system_header\n+ #endif\n+ \n+-#if _LIBCPP_STD_VER >= 20\n+-\n+ _LIBCPP_BEGIN_NAMESPACE_STD\n+ \n+-template <class...>\n+-struct _LIBCPP_NO_SPECIALIZATIONS common_reference;\n+-\n+-template <class... _Types>\n+-using common_reference_t = typename common_reference<_Types...>::type;\n+-\n+-template <class, class, template <class> class, template <class> class>\n+-struct basic_common_reference {};\n+-\n+-#  if __has_builtin(__builtin_common_reference)\n+-\n+-template <class _Tp, class _Up, template <class> class _Tx, template <class> class _Ux>\n+-using __basic_common_reference_t = basic_common_reference<_Tp, _Up, _Tx, _Ux>::type;\n+-\n+-template <class... _Args>\n+-struct _LIBCPP_NO_SPECIALIZATIONS common_reference\n+-    : __builtin_common_reference<__basic_common_reference_t, common_type_t, type_identity, __empty, _Args...> {};\n+-\n+-#  else\n+-\n++// common_reference\n++#if _LIBCPP_STD_VER >= 20\n+ // Let COND_RES(X, Y) be:\n+ template <class _Xp, class _Yp>\n+ using __cond_res _LIBCPP_NODEBUG = decltype(false ? std::declval<_Xp (&)()>()() : std::declval<_Yp (&)()>()());\n+@@ -130,10 +109,19 @@\n+ \n+ // Note C: For the common_reference trait applied to a parameter pack [...]\n+ \n++template <class...>\n++struct _LIBCPP_NO_SPECIALIZATIONS common_reference;\n++\n++template <class... _Types>\n++using common_reference_t = typename common_reference<_Types...>::type;\n++\n++template <class, class, template <class> class, template <class> class>\n++struct basic_common_reference {};\n++\n+ _LIBCPP_DIAGNOSTIC_PUSH\n+-#    if __has_warning(\"-Winvalid-specialization\")\n++#  if __has_warning(\"-Winvalid-specialization\")\n+ _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(\"-Winvalid-specialization\")\n+-#    endif\n++#  endif\n+ // bullet 1 - sizeof...(T) == 0\n+ template <>\n+ struct common_reference<> {};\n+@@ -207,10 +195,8 @@\n+ template <class...>\n+ struct _LIBCPP_NO_SPECIALIZATIONS common_reference {};\n+ \n+-#  endif // __has_builtin(__builtin_common_reference)\n++#endif // _LIBCPP_STD_VER >= 20\n+ \n+ _LIBCPP_END_NAMESPACE_STD\n+ \n+-#endif // _LIBCPP_STD_VER >= 20\n+-\n+ #endif // _LIBCPP___TYPE_TRAITS_COMMON_REFERENCE_H\n+diff -ruN --strip-trailing-cr a/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp b/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n+--- a/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n++++ b/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n+@@ -670,5 +670,101 @@\n+       assert(v == std::numeric_limits<long>::min());\n+     }\n+ \n++  { // Check that auto-detection of the base works properly\n++    ios.flags(ios.flags() & ~std::ios::basefield);\n++    { // zeroes\n++      {\n++        v                          = -1;\n++        const char str[]           = \"0\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 1), ios, err, v);\n++        assert(base(iter) == str + 1);\n++        assert(err == ios.eofbit);\n++        assert(v == 0);\n++      }\n++      {\n++        v                          = -1;\n++        const char str[]           = \"00\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n++        assert(base(iter) == str + 2);\n++        assert(err == ios.eofbit);\n++        assert(v == 0);\n++      }\n++      {\n++        v                          = -1;\n++        const char str[]           = \"0x0\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n++        assert(base(iter) == str + 3);\n++        assert(err == ios.eofbit);\n++        assert(v == 0);\n++      }\n++      {\n++        v                          = -1;\n++        const char str[]           = \"0X0\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n++        assert(base(iter) == str + 3);\n++        assert(err == ios.eofbit);\n++        assert(v == 0);\n++      }\n++    }\n++    { // first character after base is out of range\n++      {\n++        v                          = -1;\n++        const char str[]           = \"08\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n++        assert(base(iter) == str + 1);\n++        assert(err == ios.goodbit);\n++        assert(v == 0);\n++      }\n++      {\n++        v                          = -1;\n++        const char str[]           = \"1a\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n++        assert(base(iter) == str + 1);\n++        assert(err == ios.goodbit);\n++        assert(v == 1);\n++      }\n++      {\n++        v                          = -1;\n++        const char str[]           = \"0xg\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n++        assert(base(iter) == str + 2);\n++        assert(err == ios.failbit);\n++        assert(v == 0);\n++      }\n++      {\n++        v                          = -1;\n++        const char str[]           = \"0Xg\";\n++        std::ios_base::iostate err = ios.goodbit;\n++\n++        cpp17_input_iterator<const char*> iter =\n++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n++        assert(base(iter) == str + 2);\n++        assert(err == ios.failbit);\n++        assert(v == 0);\n++      }\n++    }\n++  }\n++\n+   return 0;\n+ }\n+diff -ruN --strip-trailing-cr a/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td b/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n+--- a/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n++++ b/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n+@@ -948,8 +948,7 @@\n+     auto [id, args] = NVVM::MBarrierArriveExpectTxOp::getIntrinsicIDAndArgs(\n+                       *op, moduleTranslation, builder);\n+ \n+-    int addrSpace = llvm::cast<LLVMPointerType>(op.getAddr().getType()).getAddressSpace();\n+-    if (addrSpace != NVVM::NVVMMemorySpace::SharedCluster)\n++    if (op.getNumResults() > 0)\n+       $res = createIntrinsicCall(builder, id, args);\n+     else\n+       createIntrinsicCall(builder, id, args);\n+@@ -985,9 +984,7 @@\n+   string llvmBuilder = [{\n+     auto [id, args] = NVVM::MBarrierArriveDropExpectTxOp::getIntrinsicIDAndArgs(\n+                       *op, moduleTranslation, builder);\n+-\n+-    int addrSpace = llvm::cast<LLVMPointerType>(op.getAddr().getType()).getAddressSpace();\n+-    if (addrSpace != NVVM::NVVMMemorySpace::SharedCluster)\n++    if (op.getNumResults() > 0)\n+       $res = createIntrinsicCall(builder, id, args);\n+     else\n+       createIntrinsicCall(builder, id, args);\n+diff -ruN --strip-trailing-cr a/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir b/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n+--- a/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n++++ b/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n+@@ -44,6 +44,7 @@\n+   gpu.host_register %2 : memref<*xf64>\n+   gpu.host_register %20 : memref<*xf64>\n+   gpu.host_register %33 : memref<*xf64>\n++  gpu.host_register %34 : memref<*xf64>\n+ \n+   gpu.launch blocks(%bx, %by, %bz) in (%grid_x = %c1, %grid_y = %c1, %grid_z = %c1)\n+              threads(%tx, %ty, %tz) in (%block_x = %c32, %block_y = %c1, %block_z = %c1) {\n+diff -ruN --strip-trailing-cr a/utils/bazel/configure.bzl b/utils/bazel/configure.bzl\n+--- a/utils/bazel/configure.bzl\n++++ b/utils/bazel/configure.bzl\n+@@ -27,7 +27,6 @@\n+     \"XCore\",\n+ ]\n+ \n+-\n+ MAX_TRAVERSAL_STEPS = 1000000  # \"big number\" upper bound on total visited dirs\n+ \n+ def _overlay_directories(repository_ctx):\n+@@ -44,7 +43,9 @@\n+     for _ in range(MAX_TRAVERSAL_STEPS):\n+         rel_dir = stack.pop()\n+ \n+-        overlay_dirs = set()\n++        # TODO: `set()` is only available in bazel 8.1.\n++        # Use `set()` after downstream users are on more recent versions.\n++        overlay_dirs = {}\n+ \n+         # Symlink overlay files, overlay dirs will be handled in future iterations.\n+         for entry in overlay_root.get_child(rel_dir).readdir():\n+@@ -53,7 +54,7 @@\n+ \n+             if entry.is_dir:\n+                 stack.append(full_rel_path)\n+-                overlay_dirs.add(name)\n++                overlay_dirs[name] = None\n+             else:\n+                 src_path = overlay_root.get_child(full_rel_path)\n+                 dst_path = target_root.get_child(full_rel_path)\n+@@ -62,7 +63,7 @@\n+         # Symlink source dirs (if not themselves overlaid) and files.\n+         for src_entry in src_root.get_child(rel_dir).readdir():\n+             name = src_entry.basename\n+-            if name in overlay_dirs:\n++            if name in overlay_dirs.keys():\n+                 # Skip: overlay has a directory with this name\n+                 continue\n+ "
        },
        {
            "sha": "f8f483c261a19d2cadc9b125ff7734517d9b6f9f",
            "filename": "third_party/xla/third_party/llvm/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl?ref=6e7947e538cc2bf87acd2bc86515c8f4164d54a4",
            "patch": "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n \n def repo(name):\n     \"\"\"Imports LLVM.\"\"\"\n-    LLVM_COMMIT = \"0bd2f12753604cd072ae0935820ba9a23bb17ccc\"\n-    LLVM_SHA256 = \"e60e866c649331e41907124f8b3537ecea10acf49da7c5a344d78089df492f0e\"\n+    LLVM_COMMIT = \"ac66ae45cd22a7958ace645a035831000bfcbf51\"\n+    LLVM_SHA256 = \"3bb51316595bbe99da8bee121f1fc39993176afc5b55f72a5d5010214dcd24a8\"\n \n     tf_http_archive(\n         name = name,"
        },
        {
            "sha": "3c7eafc1a8600ab92d720736f2cb131a4250a95b",
            "filename": "third_party/xla/third_party/shardy/temporary.patch",
            "status": "modified",
            "additions": 1447,
            "deletions": 39,
            "changes": 1486,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch?ref=6e7947e538cc2bf87acd2bc86515c8f4164d54a4",
            "patch": "@@ -1,55 +1,1463 @@\n+diff --git a/shardy/integrations/python/jax/mpmd/README.md b/shardy/integrations/python/jax/mpmd/README.md\n+deleted file mode 100644\n+index 02f1996..0000000\n+--- a/shardy/integrations/python/jax/mpmd/README.md\n++++ /dev/null\n+@@ -1,98 +0,0 @@\n+-<!-- Copyright 2025 The MPMD Authors.\n+-Licensed under the Apache License, Version 2.0 (the \"License\");\n+-you may not use this file except in compliance with the License.\n+-You may obtain a copy of the License at\n+-    http://www.apache.org/licenses/LICENSE-2.0\n+-Unless required by applicable law or agreed to in writing, software\n+-distributed under the License is distributed on an \"AS IS\" BASIS,\n+-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+-See the License for the specific language governing permissions and\n+-limitations under the License.\n+-============================================================================== -->\n+-\n+-# Shardy MPMD\n+-\n+-Shardy MPMD JAX integration for multi-program multi-data parallelism.\n+-\n+-## Development Setup\n+-\n+-To set up a development environment:\n+-\n+-1.  **Clone the repository:**\n+-\n+-    ```bash\n+-    git clone https://github.com/openxla/shardy.git\n+-    cd shardy/shardy/integrations/python/jax/mpmd\n+-    ```\n+-\n+-2.  **Create and activate a virtual environment:**\n+-\n+-    ```bash\n+-    python3 -m venv sdy_venv\n+-    source sdy_venv/bin/activate\n+-    ```\n+-\n+-3.  **Install the package in editable mode with dev dependencies:**\n+-\n+-    ```bash\n+-    pip install -e '.[dev]'\n+-    ```\n+-\n+-4.  **Run unit tests:**\n+-\n+-    ```bash\n+-    pytest jit_test.py\n+-    ```\n+-\n+-## Usage\n+-\n+-Here is a simple \"Hello World\" example demonstrating how to use Shardy MPMD to define a 2-stage pipeline.\n+-\n+-See also https://github.com/openxla/shardy/blob/main/rfcs/2025-06-18-mpmd-rfc-read-only-colab.ipynb\n+-(We'll convert this to a runnable colab soon...)\n+-\n+-```python\n+-import jax\n+-import jax.numpy as jnp\n+-import numpy as np\n+-from shardy.integrations.python.jax import mpmd\n+-from shardy.integrations.python.jax.mpmd import stages\n+-\n+-def mpmd_hello_world():\n+-  # 1. Define the MPMD function\n+-  def mpmd_fn(w1, w2, x):\n+-    # Stage 1: Matrix multiplication on mesh1\n+-    stage1 = mpmd.named_computation(lambda a: a @ w1, name='stage1')(x)\n+-    # Stage 2: Matrix multiplication on mesh2\n+-    stage2 = mpmd.named_computation(lambda a: a @ w2, name='stage2')(stage1)\n+-    return stage2\n+-\n+-  # 2. Define the configuration (topology and mesh assignment)\n+-  # In a real scenario, you would define your mesh topology here.\n+-  # This example assumes a helper or existing topology.\n+-  # For demonstration, we'll use a mock topology setup.\n+-  # topology = ...\n+-  # mpmd_config = mpmd.make_config(\n+-  #     topology,\n+-  #     {'stage1': 'mesh1', 'stage2': 'mesh2'}\n+-  # )\n+-\n+-  # NOTE: For this example to run, you need a valid topology.\n+-  # See tests/jit_test.py for full setup details.\n+-\n+-  # 3. JIT compile and lower\n+-  # lowered: stages.MpmdLowered = mpmd.jit(mpmd_fn, mpmd_config).lower(\n+-  #     np.ones((3, 5), dtype=jnp.float32),\n+-  #     np.ones((5, 7), dtype=jnp.float32),\n+-  #     np.ones((10, 3), dtype=jnp.float32),\n+-  # )\n+-\n+-  # 4. Compile (requires Pathways backend)\n+-  # compiled = lowered.compile()\n+-```\n+-\n+-## Concepts\n+-\n+--   **`mpmd.named_computation`**: Wraps a function to be executed on a specific named mesh.\n+--   **`mpmd.make_config`**: Creates a configuration object binding stage names to mesh names in the topology.\n+--   **`mpmd.jit`**: JIT compiles the MPMD function, handling the partitioning and communication between stages.\n+diff --git a/shardy/integrations/python/jax/mpmd/jit.py b/shardy/integrations/python/jax/mpmd/jit.py\n+index ff84bd8..d1b2417 100644\n+--- a/shardy/integrations/python/jax/mpmd/jit.py\n++++ b/shardy/integrations/python/jax/mpmd/jit.py\n+@@ -23,7 +23,7 @@ from absl import logging\n+ import jax\n+ from jax.experimental import layout as jax_layout\n+ from jax.interpreters import mlir\n+-from jaxlib import _sdy_mpmd as jaxlib_mpmd\n++from jax.jaxlib import _sdy_mpmd as jaxlib_mpmd\n+ import jaxtyping\n+ import numpy as np\n+ import typing_extensions\n+diff --git a/shardy/integrations/python/jax/mpmd/jit_test.py b/shardy/integrations/python/jax/mpmd/jit_test.py\n+index 73bc0c8..c5f7f35 100644\n+--- a/shardy/integrations/python/jax/mpmd/jit_test.py\n++++ b/shardy/integrations/python/jax/mpmd/jit_test.py\n+@@ -20,6 +20,7 @@ import functools\n+ from absl.testing import absltest\n+ from absl.testing import parameterized\n+ import chex\n++from flax.core import scope\n+ import jax\n+ from jax import sharding\n+ import jax.numpy as jnp\n+@@ -33,6 +34,7 @@ from shardy.integrations.python.jax.mpmd import types as mpmd_types\n+ \n+ \n+ PyTree = jaxtyping.PyTree\n++VariableDict = scope.VariableDict\n+ \n+ \n+ def _replicated(\n+diff --git a/shardy/integrations/python/jax/mpmd/pyproject.toml b/shardy/integrations/python/jax/mpmd/pyproject.toml\n+deleted file mode 100644\n+index 244f753..0000000\n+--- a/shardy/integrations/python/jax/mpmd/pyproject.toml\n++++ /dev/null\n+@@ -1,81 +0,0 @@\n+-# Copyright 2025 The MPMD Authors.\n+-# Licensed under the Apache License, Version 2.0 (the \"License\");\n+-# you may not use this file except in compliance with the License.\n+-# You may obtain a copy of the License at\n+-#     http://www.apache.org/licenses/LICENSE-2.0\n+-# Unless required by applicable law or agreed to in writing, software\n+-# distributed under the License is distributed on an \"AS IS\" BASIS,\n+-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+-# See the License for the specific language governing permissions and\n+-# limitations under the License.\n+-# ==============================================================================\n+-\n+-[build-system]\n+-requires = [\"setuptools\", \"wheel\"]\n+-build-backend = \"setuptools.build_meta\"\n+-\n+-[project]\n+-name = \"shardy-mpmd\"\n+-version = \"0.0.1\"\n+-description = \"Shardy MPMD JAX integration for multi-program multi-data parallelism\"\n+-readme = \"README.md\"\n+-requires-python = \">=3.11\"\n+-license = {text = \"Apache-2.0\"}\n+-authors = [{name = \"The MPMD Authors\"}]\n+-classifiers = [\n+-    \"Development Status :: 4 - Beta\",\n+-    \"Intended Audience :: Developers\",\n+-    \"Intended Audience :: Science/Research\",\n+-    \"License :: OSI Approved :: Apache Software License\",\n+-    \"Programming Language :: Python :: 3\",\n+-    \"Programming Language :: Python :: 3.11\",\n+-    \"Programming Language :: Python :: 3.12\",\n+-]\n+-\n+-dependencies = [\n+-    \"jax>=0.8.0\",\n+-    \"jaxlib>=0.8.0\",\n+-    \"jaxtyping>=0.3.3\",\n+-    \"numpy>=1.24.0\",\n+-    \"absl-py>=1.0.0\",\n+-    \"typing_extensions>=4.0.0\",\n+-]\n+-\n+-[project.optional-dependencies]\n+-dev = [\n+-    \"pytest>=7.0.0\",\n+-    \"pytest-xdist\",\n+-    \"chex\",\n+-    \"pyink\",\n+-]\n+-\n+-[tool.setuptools]\n+-packages = [\"shardy.integrations.python.jax.mpmd\"]\n+-package-dir = {\"shardy.integrations.python.jax.mpmd\" = \".\"}\n+-\n+-[tool.mypy]\n+-show_error_codes = true\n+-no_implicit_optional = true\n+-warn_redundant_casts = true\n+-allow_redefinition = true\n+-\n+-[[tool.mypy.overrides]]\n+-module = [\n+-    \"jax.*\",\n+-    \"jaxlib.*\",\n+-    \"numpy.*\",\n+-    \"absl.*\",\n+-]\n+-ignore_missing_imports = true\n+-\n+-[tool.pytest.ini_options]\n+-testpaths = [\"**/*_test.py\"]\n+-python_files = \"*_test.py\"\n+-addopts = \"--import-mode=importlib\"\n+-pythonpath = [\"../../../../..\"]\n+-\n+-[tool.pyink]\n+-line-length = 80\n+-target-version = [\"py311\"]\n+-pyink-indentation = 2\n+-pyink-use-majority-quotes = true\n+diff --git a/shardy/integrations/python/jax/mpmd/stages.py b/shardy/integrations/python/jax/mpmd/stages.py\n+index f606296..5020d52 100644\n+--- a/shardy/integrations/python/jax/mpmd/stages.py\n++++ b/shardy/integrations/python/jax/mpmd/stages.py\n+@@ -28,7 +28,7 @@ from jax._src.interpreters import pxla\n+ from jax.experimental import layout\n+ import jax.extend.backend as jax_backend\n+ from jax.interpreters import mlir as jax_mlir\n+-from jaxlib import _sdy_mpmd as jaxlib_mpmd\n++from jax.jaxlib import _sdy_mpmd as jaxlib_mpmd\n+ import jaxtyping\n+ import numpy as np\n+ \n+diff --git a/shardy/integrations/python/jax/mpmd/types.py b/shardy/integrations/python/jax/mpmd/types.py\n+index eb9b4ad..7dfa3aa 100644\n+--- a/shardy/integrations/python/jax/mpmd/types.py\n++++ b/shardy/integrations/python/jax/mpmd/types.py\n+@@ -18,6 +18,7 @@\n+ from collections.abc import Mapping, Sequence\n+ import dataclasses\n+ import enum\n++from typing import Any\n+ \n+ import jax\n+ import jaxtyping\n+diff --git a/shardy/integrations/python/jax/mpmd/utils.py b/shardy/integrations/python/jax/mpmd/utils.py\n+index 4269763..41e9e05 100644\n+--- a/shardy/integrations/python/jax/mpmd/utils.py\n++++ b/shardy/integrations/python/jax/mpmd/utils.py\n+@@ -20,7 +20,7 @@ import functools\n+ from typing import Any, TypeVar\n+ \n+ import jax\n+-from jaxlib import _sdy_mpmd as mpmd_utils\n++from jax.jaxlib import _sdy_mpmd as mpmd_utils\n+ import jaxtyping\n+ \n+ PyTree = jaxtyping.PyTree\n+diff --git a/shardy/integrations/python/jax/mpmd/utils_test.py b/shardy/integrations/python/jax/mpmd/utils_test.py\n+index 9716bfd..b1d3c94 100644\n+--- a/shardy/integrations/python/jax/mpmd/utils_test.py\n++++ b/shardy/integrations/python/jax/mpmd/utils_test.py\n+@@ -18,7 +18,7 @@ from absl.testing import absltest\n+ from absl.testing import parameterized\n+ import chex\n+ import jax\n+-from jaxlib import _sdy_mpmd as mpmd_utils\n++from jax.jaxlib import _sdy_mpmd as mpmd_utils\n+ import numpy as np\n+ from shardy.integrations.python.jax.mpmd import utils\n+ \n diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch\n-index 509398d..f8d638a 100644\n+index f8d638a..f04aa96 100644\n --- a/third_party/llvm/generated.patch\n +++ b/third_party/llvm/generated.patch\n-@@ -1 +1,35 @@\n+@@ -1,35 +1,1137 @@\n  Auto generated patch. Do not edit or delete it, even if empty.\n-+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n-+--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n-++++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n-+@@ -1163,6 +1163,7 @@\n-+   // (X >= Y) ? INT_MAX : (X + C) --> sadd.sat(X, C)\n-+   // where Y is INT_MAX - C or INT_MAX - C - 1, and C > 0\n-+   if ((Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE) &&\n-++      isa<Constant>(Cmp1) &&\n-+       match(FVal, m_Add(m_Specific(Cmp0), m_StrictlyPositive(C)))) {\n-+     APInt IntMax =\n-+         APInt::getSignedMaxValue(Cmp1->getType()->getScalarSizeInBits());\n-+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/InstCombine/saturating-add-sub.ll b/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n-+--- a/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n-++++ b/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n-+@@ -2671,3 +2671,19 @@\n-+   %s = select i1 %cmp, i8 127, i8 %d\n-+   ret i8 %s\n+-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+---- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+-+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+-@@ -1163,6 +1163,7 @@\n+-   // (X >= Y) ? INT_MAX : (X + C) --> sadd.sat(X, C)\n+-   // where Y is INT_MAX - C or INT_MAX - C - 1, and C > 0\n+-   if ((Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE) &&\n+-+      isa<Constant>(Cmp1) &&\n+-       match(FVal, m_Add(m_Specific(Cmp0), m_StrictlyPositive(C)))) {\n+-     APInt IntMax =\n+-         APInt::getSignedMaxValue(Cmp1->getType()->getScalarSizeInBits());\n+-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/InstCombine/saturating-add-sub.ll b/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n+---- a/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n+-+++ b/llvm/test/Transforms/InstCombine/saturating-add-sub.ll\n+-@@ -2671,3 +2671,19 @@\n+-   %s = select i1 %cmp, i8 127, i8 %d\n+-   ret i8 %s\n++diff -ruN --strip-trailing-cr a/clang/docs/LanguageExtensions.rst b/clang/docs/LanguageExtensions.rst\n++--- a/clang/docs/LanguageExtensions.rst\n+++++ b/clang/docs/LanguageExtensions.rst\n++@@ -1833,23 +1833,6 @@\n++ \n++ Clang provides a few builtin aliases to improve the throughput of certain metaprogramming facilities.\n++ \n++-__builtin_common_reference\n++---------------------------\n++-\n++-.. code-block:: c++\n++-\n++-  template <template <class, class, template <class> class, template <class> class> class BasicCommonReferenceT,\n++-            template <class... Args> CommonTypeT,\n++-            template <class> HasTypeMember,\n++-            class HasNoTypeMember,\n++-            class... Ts>\n++-  using __builtin_common_reference = ...;\n++-\n++-This alias is used for implementing ``std::common_reference``. If ``std::common_reference`` should contain a ``type``\n++-member, it is an alias to ``HasTypeMember<TheCommonReference>``. Otherwse it is an alias to ``HasNoTypeMember``. The\n++-``CommonTypeT`` is usually ``std::common_type_t``. ``BasicCommonReferenceT`` is usually an alias template to\n++-``basic_common_reference<T, U, TX, UX>::type``.\n++-\n++ __builtin_common_type\n++ ---------------------\n++ \n++diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/BuiltinTemplates.td b/clang/include/clang/Basic/BuiltinTemplates.td\n++--- a/clang/include/clang/Basic/BuiltinTemplates.td\n+++++ b/clang/include/clang/Basic/BuiltinTemplates.td\n++@@ -10,11 +10,11 @@\n++   string Name = name;\n+  }\n++ \n++-class Template<list<TemplateArg> args, string name = \"\"> : TemplateArg<name> {\n+++class Template<list<TemplateArg> args, string name> : TemplateArg<name> {\n++   list<TemplateArg> Args = args;\n++ }\n++ \n++-class Class<string name = \"\", bit is_variadic = 0> : TemplateArg<name> {\n+++class Class<string name, bit is_variadic = 0> : TemplateArg<name> {\n++   bit IsVariadic = is_variadic;\n + }\n++ \n++@@ -56,32 +56,6 @@\n++    Class<\"HasNoTypeMember\">,\n++    Class<\"Ts\", /*is_variadic=*/1>]>;\n++ \n++-// template <template <class,\"\n++-//                     class,\"\n++-//                     template <class> class,\"\n++-//                     template <class> class> class BasicCommonReferenceT,\"\n++-//           template <class... Args> class CommonTypeT,\"\n++-//           template <class> class HasTypeMember,\"\n++-//           class HasNoTypeMember,\"\n++-//           class... Ts>\"\n++-def __builtin_common_reference : CPlusPlusBuiltinTemplate<\n++-            [Template<[Class<>,\n++-                       Class<>,\n++-                       Template<[Class<>]>,\n++-                       Template<[Class<>]>], \"BasicCommonReferenceT\">,\n++-             Template<[Class<\"Args\", /*is_variadic=*/1>], \"CommonTypeT\">,\n++-             Template<[Class<>], \"HasTypeMember\">,\n++-             Class<\"HasNoTypeMember\">,\n++-             Class<\"Ts\", /*is_variadic=*/1>]>;\n++-\n++-foreach Ref = [\"\", \"lvalue\", \"rvalue\"] in {\n++-  foreach Const = [\"\", \"const\"] in {\n++-    foreach Volatile = [\"\", \"volatile\"] in {\n++-      def __clang_internal_xref_#Ref#Const#Volatile : CPlusPlusBuiltinTemplate<[Class<>]>;\n++-    }\n++-  }\n++-}\n++-\n++ // template <uint32_t Opcode,\n++ //           uint32_t Size,\n++ //           uint32_t Alignment,\n++diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h\n++--- a/clang/include/clang/Sema/Sema.h\n+++++ b/clang/include/clang/Sema/Sema.h\n++@@ -15322,17 +15322,6 @@\n++   QualType BuiltinDecay(QualType BaseType, SourceLocation Loc);\n++   QualType BuiltinAddReference(QualType BaseType, UTTKind UKind,\n++                                SourceLocation Loc);\n++-\n++-  QualType BuiltinAddRValueReference(QualType BaseType, SourceLocation Loc) {\n++-    return BuiltinAddReference(BaseType, UnaryTransformType::AddRvalueReference,\n++-                               Loc);\n++-  }\n++-\n++-  QualType BuiltinAddLValueReference(QualType BaseType, SourceLocation Loc) {\n++-    return BuiltinAddReference(BaseType, UnaryTransformType::AddLvalueReference,\n++-                               Loc);\n++-  }\n++-\n++   QualType BuiltinRemoveExtent(QualType BaseType, UTTKind UKind,\n++                                SourceLocation Loc);\n++   QualType BuiltinRemoveReference(QualType BaseType, UTTKind UKind,\n++@@ -15347,9 +15336,6 @@\n++   QualType BuiltinChangeSignedness(QualType BaseType, UTTKind UKind,\n++                                    SourceLocation Loc);\n++ \n++-  bool BuiltinIsConvertible(QualType From, QualType To, SourceLocation Loc,\n++-                            bool CheckNothrow = false);\n++-\n++   bool BuiltinIsBaseOf(SourceLocation RhsTLoc, QualType LhsT, QualType RhsT);\n++ \n++   /// Ensure that the type T is a literal type.\n++diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplate.cpp b/clang/lib/Sema/SemaTemplate.cpp\n++--- a/clang/lib/Sema/SemaTemplate.cpp\n+++++ b/clang/lib/Sema/SemaTemplate.cpp\n++@@ -3212,36 +3212,6 @@\n++   }\n++ }\n++ \n++-static QualType InstantiateTemplate(Sema &S, ElaboratedTypeKeyword Keyword,\n++-                                    TemplateName Template,\n++-                                    ArrayRef<TemplateArgument> Args,\n++-                                    SourceLocation Loc) {\n++-  TemplateArgumentListInfo ArgList;\n++-  for (auto Arg : Args) {\n++-    if (Arg.getKind() == TemplateArgument::Type) {\n++-      ArgList.addArgument(TemplateArgumentLoc(\n++-          Arg, S.Context.getTrivialTypeSourceInfo(Arg.getAsType())));\n++-    } else {\n++-      ArgList.addArgument(\n++-          S.getTrivialTemplateArgumentLoc(Arg, QualType(), Loc));\n++-    }\n++-  }\n++-\n++-  EnterExpressionEvaluationContext UnevaluatedContext(\n++-      S, Sema::ExpressionEvaluationContext::Unevaluated);\n++-  Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n++-  Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n++-\n++-  QualType Instantiation =\n++-      S.CheckTemplateIdType(Keyword, Template, Loc, ArgList, /*Scope=*/nullptr,\n++-                            /*ForNestedNameSpecifier=*/false);\n++-\n++-  if (SFINAE.hasErrorOccurred())\n++-    return QualType();\n++-\n++-  return Instantiation;\n++-}\n++-\n++ static QualType builtinCommonTypeImpl(Sema &S, ElaboratedTypeKeyword Keyword,\n++                                       TemplateName BaseTemplate,\n++                                       SourceLocation TemplateLoc,\n++@@ -3254,7 +3224,25 @@\n++       return builtinCommonTypeImpl(S, Keyword, BaseTemplate, TemplateLoc,\n++                                    {T1, T2});\n++ \n++-    return InstantiateTemplate(S, Keyword, BaseTemplate, {T1, T2}, TemplateLoc);\n+++    TemplateArgumentListInfo Args;\n+++    Args.addArgument(TemplateArgumentLoc(\n+++        T1, S.Context.getTrivialTypeSourceInfo(T1.getAsType())));\n+++    Args.addArgument(TemplateArgumentLoc(\n+++        T2, S.Context.getTrivialTypeSourceInfo(T2.getAsType())));\n+++\n+++    EnterExpressionEvaluationContext UnevaluatedContext(\n+++        S, Sema::ExpressionEvaluationContext::Unevaluated);\n+++    Sema::SFINAETrap SFINAE(S, /*ForValidityCheck=*/true);\n+++    Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n+++\n+++    QualType BaseTemplateInst = S.CheckTemplateIdType(\n+++        Keyword, BaseTemplate, TemplateLoc, Args,\n+++        /*Scope=*/nullptr, /*ForNestedNameSpecifier=*/false);\n+++\n+++    if (SFINAE.hasErrorOccurred())\n+++      return QualType();\n+++\n+++    return BaseTemplateInst;\n++   };\n++ \n++   // Note A: For the common_type trait applied to a template parameter pack T of\n++@@ -3361,233 +3349,6 @@\n++   }\n++ }\n++ \n++-static QualType CopyCV(QualType From, QualType To) {\n++-  if (From.isConstQualified())\n++-    To.addConst();\n++-  if (From.isVolatileQualified())\n++-    To.addVolatile();\n++-  return To;\n++-}\n++-\n++-// Let COND-RES(X, Y) be\n++-//  decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()())\n++-static QualType CondRes(Sema &S, QualType X, QualType Y, SourceLocation Loc) {\n++-  EnterExpressionEvaluationContext UnevaluatedContext(\n++-      S, Sema::ExpressionEvaluationContext::Unevaluated);\n++-  Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n++-  Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n++-\n++-  // false\n++-  OpaqueValueExpr CondExpr(SourceLocation(), S.Context.BoolTy, VK_PRValue);\n++-  ExprResult Cond = &CondExpr;\n++-\n++-  // declval<X(&)()>()()\n++-  OpaqueValueExpr LHSExpr(Loc, X.getNonLValueExprType(S.Context),\n++-                          Expr::getValueKindForType(X));\n++-  ExprResult LHS = &LHSExpr;\n++-\n++-  // declval<Y(&)()>()()\n++-  OpaqueValueExpr RHSExpr(Loc, Y.getNonLValueExprType(S.Context),\n++-                          Expr::getValueKindForType(Y));\n++-  ExprResult RHS = &RHSExpr;\n++-\n++-  ExprValueKind VK = VK_PRValue;\n++-  ExprObjectKind OK = OK_Ordinary;\n++-\n++-  // decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()())\n++-  QualType Result = S.CheckConditionalOperands(Cond, LHS, RHS, VK, OK, Loc);\n++-\n++-  if (SFINAE.hasErrorOccurred())\n++-    return QualType();\n++-  if (VK == VK_LValue)\n++-    return S.BuiltinAddLValueReference(Result, Loc);\n++-  if (VK == VK_XValue)\n++-    return S.BuiltinAddRValueReference(Result, Loc);\n++-  return Result;\n++-}\n++-\n++-static QualType CommonRef(Sema &S, QualType A, QualType B, SourceLocation Loc) {\n++-  // Given types A and B, let X be remove_reference_t<A>, let Y be\n++-  // remove_reference_t<B>, and let COMMON-​REF(A, B) be:\n++-  assert(A->isReferenceType() && B->isReferenceType() &&\n++-         \"A and B have to be ref qualified for a COMMON-REF\");\n++-  auto X = A.getNonReferenceType();\n++-  auto Y = B.getNonReferenceType();\n++-\n++-  // If A and B are both lvalue reference types, COMMON-REF(A, B) is\n++-  // COND-RES(COPYCV(X, Y) &, COPYCV(​Y, X) &) if that type exists and is a\n++-  // reference type.\n++-  if (A->isLValueReferenceType() && B->isLValueReferenceType()) {\n++-    auto CR = CondRes(S, S.BuiltinAddLValueReference(CopyCV(X, Y), Loc),\n++-                      S.BuiltinAddLValueReference(CopyCV(Y, X), Loc), Loc);\n++-    if (CR.isNull() || !CR->isReferenceType())\n++-      return QualType();\n++-    return CR;\n++-  }\n++-\n++-  // Otherwise, let C be remove_reference_t<COMMON-REF(X&, Y&)>&&. If A and B\n++-  // are both rvalue reference types, C is well-formed, and\n++-  // is_convertible_v<A, C> && is_convertible_v<B, C> is true, then\n++-  // COMMON-REF(A, B) is C.\n++-  if (A->isRValueReferenceType() && B->isRValueReferenceType()) {\n++-    auto C = CommonRef(S, S.BuiltinAddLValueReference(X, Loc),\n++-                       S.BuiltinAddLValueReference(Y, Loc), Loc);\n++-    if (C.isNull())\n++-      return QualType();\n++-\n++-    C = C.getNonReferenceType();\n++-\n++-    if (S.BuiltinIsConvertible(A, C, Loc) && S.BuiltinIsConvertible(B, C, Loc))\n++-      return S.BuiltinAddRValueReference(C, Loc);\n++-    return QualType();\n++-  }\n++-\n++-  // Otherwise, if A is an lvalue reference and B is an rvalue reference, then\n++-  // COMMON-REF(A, B) is COMMON-REF(B, A).\n++-  if (A->isLValueReferenceType() && B->isRValueReferenceType())\n++-    std::swap(A, B);\n++-\n++-  // Otherwise, let D be COMMON-REF(const X&, Y&). If A is an rvalue reference\n++-  // and B is an lvalue reference and D is well-formed and\n++-  // is_convertible_v<A, D> is true, then COMMON-REF(A, B) is D.\n++-  if (A->isRValueReferenceType() && B->isLValueReferenceType()) {\n++-    auto X2 = X;\n++-    X2.addConst();\n++-    auto D = CommonRef(S, S.BuiltinAddLValueReference(X2, Loc),\n++-                       S.BuiltinAddLValueReference(Y, Loc), Loc);\n++-    if (!D.isNull() && S.BuiltinIsConvertible(A, D, Loc))\n++-      return D;\n++-    return QualType();\n++-  }\n++-\n++-  // Otherwise, COMMON-REF(A, B) is ill-formed.\n++-  // This is implemented by returning from the individual branches above.\n++-\n++-  llvm_unreachable(\"The above cases should be exhaustive\");\n++-}\n++-\n++-static QualType builtinCommonReferenceImpl(Sema &S,\n++-                                           ElaboratedTypeKeyword Keyword,\n++-                                           TemplateName CommonReference,\n++-                                           TemplateName CommonType,\n++-                                           SourceLocation TemplateLoc,\n++-                                           ArrayRef<TemplateArgument> Ts) {\n++-  switch (Ts.size()) {\n++-  // If sizeof...(T) is zero, there shall be no member type.\n++-  case 0:\n++-    return QualType();\n++-\n++-  // Otherwise, if sizeof...(T) is one, let T0 denote the sole type in the\n++-  // pack T. The member typedef type shall denote the same type as T0.\n++-  case 1:\n++-    return Ts[0].getAsType();\n++-\n++-  // Otherwise, if sizeof...(T) is two, let T1 and T2 denote the two types in\n++-  // the pack T. Then\n++-  case 2: {\n++-    auto T1 = Ts[0].getAsType();\n++-    auto T2 = Ts[1].getAsType();\n++-\n++-    // Let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is\n++-    // well-formed, and is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> &&\n++-    // is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is true, then the\n++-    // member typedef type denotes R.\n++-    if (T1->isReferenceType() && T2->isReferenceType()) {\n++-      QualType R = CommonRef(S, T1, T2, TemplateLoc);\n++-      if (!R.isNull()) {\n++-        if (S.BuiltinIsConvertible(S.BuiltinAddPointer(T1, TemplateLoc),\n++-                                   S.BuiltinAddPointer(R, TemplateLoc),\n++-                                   TemplateLoc) &&\n++-            S.BuiltinIsConvertible(S.BuiltinAddPointer(T2, TemplateLoc),\n++-                                   S.BuiltinAddPointer(R, TemplateLoc),\n++-                                   TemplateLoc)) {\n++-          return R;\n++-        }\n++-      }\n++-    }\n++-\n++-    // Otherwise, if basic_common_reference<remove_cvref_t<T1>,\n++-    // remove_cvref_t<T2>, ​XREF(​T1), XREF(T2)>​::​type is well-formed,\n++-    // then the member typedef type denotes that type.\n++-    {\n++-      auto getXRef = [&](QualType T) {\n++-        BuiltinTemplateDecl *Quals[12] = {\n++-            S.Context.get__clang_internal_xref_Decl(),\n++-            S.Context.get__clang_internal_xref_constDecl(),\n++-            S.Context.get__clang_internal_xref_volatileDecl(),\n++-            S.Context.get__clang_internal_xref_constvolatileDecl(),\n++-            S.Context.get__clang_internal_xref_lvalueDecl(),\n++-            S.Context.get__clang_internal_xref_lvalueconstDecl(),\n++-            S.Context.get__clang_internal_xref_lvaluevolatileDecl(),\n++-            S.Context.get__clang_internal_xref_lvalueconstvolatileDecl(),\n++-            S.Context.get__clang_internal_xref_rvalueDecl(),\n++-            S.Context.get__clang_internal_xref_rvalueconstDecl(),\n++-            S.Context.get__clang_internal_xref_rvaluevolatileDecl(),\n++-            S.Context.get__clang_internal_xref_rvalueconstvolatileDecl(),\n++-        };\n++-        size_t Index = 0;\n++-        if (T->isLValueReferenceType()) {\n++-          T = T.getNonReferenceType();\n++-          Index += 4;\n++-        } else if (T->isRValueReferenceType()) {\n++-          T = T.getNonReferenceType();\n++-          Index += 8;\n++-        }\n++-        if (T.isConstQualified())\n++-          Index += 1;\n++-\n++-        if (T.isVolatileQualified())\n++-          Index += 2;\n++-\n++-        return Quals[Index];\n++-      };\n++-\n++-      auto BCR = InstantiateTemplate(S, Keyword, CommonReference,\n++-                                     {S.BuiltinRemoveCVRef(T1, TemplateLoc),\n++-                                      S.BuiltinRemoveCVRef(T2, TemplateLoc),\n++-                                      TemplateName{getXRef(T1)},\n++-                                      TemplateName{getXRef(T2)}},\n++-                                     TemplateLoc);\n++-      if (!BCR.isNull())\n++-        return BCR;\n++-    }\n++-\n++-    // Otherwise, if COND-RES(T1, T2) is well-formed, then the member typedef\n++-    // type denotes that type.\n++-    if (auto CR = CondRes(S, T1, T2, TemplateLoc); !CR.isNull())\n++-      return CR;\n++-\n++-    // Otherwise, if common_type_t<T1, T2> is well-formed, then the member\n++-    // typedef type denotes that type.\n++-    if (auto CT =\n++-            InstantiateTemplate(S, Keyword, CommonType, {T1, T2}, TemplateLoc);\n++-        !CT.isNull())\n++-      return CT;\n++-\n++-    // Otherwise, there shall be no member type.\n++-    return QualType();\n++-  }\n++-\n++-  // Otherwise, if sizeof...(T) is greater than two, let T1, T2, and Rest,\n++-  // respectively, denote the first, second, and (pack of) remaining types\n++-  // comprising T. Let C be the type common_reference_t<T1, T2>. Then:\n++-  default: {\n++-    auto T1 = Ts[0];\n++-    auto T2 = Ts[1];\n++-    auto Rest = Ts.drop_front(2);\n++-    auto C = builtinCommonReferenceImpl(S, Keyword, CommonReference, CommonType,\n++-                                        TemplateLoc, {T1, T2});\n++-    if (C.isNull())\n++-      return QualType();\n++-    llvm::SmallVector<TemplateArgument, 4> Args;\n++-    Args.emplace_back(C);\n++-    Args.append(Rest.begin(), Rest.end());\n++-    return builtinCommonReferenceImpl(S, Keyword, CommonReference, CommonType,\n++-                                      TemplateLoc, Args);\n++-  }\n++-  }\n++-}\n++-\n++ static bool isInVkNamespace(const RecordType *RT) {\n++   DeclContext *DC = RT->getDecl()->getDeclContext();\n++   if (!DC)\n++@@ -3746,89 +3507,6 @@\n++     return HasNoTypeMember;\n++   }\n++ \n++-  case BTK__builtin_common_reference: {\n++-    assert(Converted.size() == 5);\n++-    if (llvm::any_of(Converted, [](auto &C) { return C.isDependent(); }))\n++-      return QualType();\n++-\n++-    TemplateName BasicCommonReference = Converted[0].getAsTemplate();\n++-    TemplateName CommonType = Converted[1].getAsTemplate();\n++-    TemplateName HasTypeMember = Converted[2].getAsTemplate();\n++-    QualType HasNoTypeMember = Converted[3].getAsType();\n++-    ArrayRef<TemplateArgument> Ts = Converted[4].getPackAsArray();\n++-    if (auto CR =\n++-            builtinCommonReferenceImpl(SemaRef, Keyword, BasicCommonReference,\n++-                                       CommonType, TemplateLoc, Ts);\n++-        !CR.isNull()) {\n++-      TemplateArgumentListInfo TAs;\n++-      TAs.addArgument(TemplateArgumentLoc(\n++-          TemplateArgument(CR), SemaRef.Context.getTrivialTypeSourceInfo(\n++-                                    CR, TemplateArgs[1].getLocation())));\n++-      return SemaRef.CheckTemplateIdType(Keyword, HasTypeMember, TemplateLoc,\n++-                                         TAs, /*Scope=*/nullptr,\n++-                                         /*ForNestedNameSpecifier=*/false);\n++-    }\n++-    return HasNoTypeMember;\n++-  }\n++-\n++-  case BTK__clang_internal_xref_:\n++-  case BTK__clang_internal_xref_const:\n++-  case BTK__clang_internal_xref_volatile:\n++-  case BTK__clang_internal_xref_constvolatile:\n++-  case BTK__clang_internal_xref_lvalue:\n++-  case BTK__clang_internal_xref_lvalueconst:\n++-  case BTK__clang_internal_xref_lvaluevolatile:\n++-  case BTK__clang_internal_xref_lvalueconstvolatile:\n++-  case BTK__clang_internal_xref_rvalue:\n++-  case BTK__clang_internal_xref_rvalueconst:\n++-  case BTK__clang_internal_xref_rvaluevolatile:\n++-  case BTK__clang_internal_xref_rvalueconstvolatile: {\n++-    if (llvm::any_of(Converted, [](auto &C) { return C.isDependent(); }))\n++-      return QualType();\n++-\n++-    auto BTK = BTD->getBuiltinTemplateKind();\n++-    auto anyOf = [&](auto... Vals) { return ((BTK == Vals) || ...); };\n++-\n++-    bool AddCV = anyOf(BTK__clang_internal_xref_constvolatile,\n++-                       BTK__clang_internal_xref_lvalueconstvolatile,\n++-                       BTK__clang_internal_xref_rvalueconstvolatile);\n++-\n++-    bool AddConst = AddCV || anyOf(BTK__clang_internal_xref_const,\n++-                                   BTK__clang_internal_xref_lvalueconst,\n++-                                   BTK__clang_internal_xref_rvalueconst);\n++-\n++-    bool AddVolatile = AddCV || anyOf(BTK__clang_internal_xref_volatile,\n++-                                      BTK__clang_internal_xref_lvaluevolatile,\n++-                                      BTK__clang_internal_xref_rvaluevolatile);\n++-\n++-    bool AddLValue = anyOf(BTK__clang_internal_xref_lvalue,\n++-                           BTK__clang_internal_xref_lvalueconst,\n++-                           BTK__clang_internal_xref_lvaluevolatile,\n++-                           BTK__clang_internal_xref_lvalueconstvolatile);\n++-\n++-    bool AddRValue = anyOf(BTK__clang_internal_xref_rvalue,\n++-                           BTK__clang_internal_xref_rvalueconst,\n++-                           BTK__clang_internal_xref_rvaluevolatile,\n++-                           BTK__clang_internal_xref_rvalueconstvolatile);\n++-\n++-    assert(Converted.size() == 1);\n++-\n++-    QualType T = Converted[0].getAsType();\n++-\n++-    if (AddConst)\n++-      T.addConst();\n++-\n++-    if (AddVolatile)\n++-      T.addVolatile();\n++-\n++-    if (AddLValue)\n++-      T = SemaRef.BuiltinAddLValueReference(T, TemplateLoc);\n++-    else if (AddRValue)\n++-      T = SemaRef.BuiltinAddRValueReference(T, TemplateLoc);\n++-\n++-    return T;\n++-  }\n++-\n++   case BTK__hlsl_spirv_type: {\n++     assert(Converted.size() == 4);\n++ \n++diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp\n++--- a/clang/lib/Sema/SemaType.cpp\n+++++ b/clang/lib/Sema/SemaType.cpp\n++@@ -32,8 +32,6 @@\n++ #include \"clang/Lex/Preprocessor.h\"\n++ #include \"clang/Sema/DeclSpec.h\"\n++ #include \"clang/Sema/DelayedDiagnostic.h\"\n++-#include \"clang/Sema/EnterExpressionEvaluationContext.h\"\n++-#include \"clang/Sema/Initialization.h\"\n++ #include \"clang/Sema/Lookup.h\"\n++ #include \"clang/Sema/ParsedAttr.h\"\n++ #include \"clang/Sema/ParsedTemplate.h\"\n++@@ -10074,81 +10072,6 @@\n++   return Context.getQualifiedType(Underlying, BaseType.getQualifiers());\n++ }\n++ \n++-bool Sema::BuiltinIsConvertible(QualType From, QualType To, SourceLocation Loc,\n++-                                bool CheckNothrow) {\n++-  if (To->isVoidType())\n++-    return From->isVoidType();\n++-\n++-  // [meta.rel]\n++-  // From and To shall be complete types, cv void, or arrays of unknown bound.\n++-  if ((!From->isIncompleteArrayType() && !From->isVoidType() &&\n++-       RequireCompleteType(\n++-           Loc, From, diag::err_incomplete_type_used_in_type_trait_expr)) ||\n++-      (!To->isIncompleteArrayType() && !To->isVoidType() &&\n++-       RequireCompleteType(Loc, To,\n++-                           diag::err_incomplete_type_used_in_type_trait_expr)))\n++-    return false;\n++-\n++-  // C++11 [meta.rel]p4:\n++-  //   Given the following function prototype:\n++-  //\n++-  //     template <class T>\n++-  //       typename add_rvalue_reference<T>::type create();\n++-  //\n++-  //   the predicate condition for a template specialization\n++-  //   is_convertible<From, To> shall be satisfied if and only if\n++-  //   the return expression in the following code would be\n++-  //   well-formed, including any implicit conversions to the return\n++-  //   type of the function:\n++-  //\n++-  //     To test() {\n++-  //       return create<From>();\n++-  //     }\n++-  //\n++-  //   Access checking is performed as if in a context unrelated to To and\n++-  //   From. Only the validity of the immediate context of the expression\n++-  //   of the return-statement (including conversions to the return type)\n++-  //   is considered.\n++-  //\n++-  // We model the initialization as a copy-initialization of a temporary\n++-  // of the appropriate type, which for this expression is identical to the\n++-  // return statement (since NRVO doesn't apply).\n++-\n++-  // Functions aren't allowed to return function or array types.\n++-  if (To->isFunctionType() || To->isArrayType())\n++-    return false;\n++-\n++-  // A function definition requires a non-abstract return type.\n++-  if (isAbstractType(Loc, To))\n++-    return false;\n++-\n++-  From = BuiltinAddRValueReference(From, Loc);\n++-\n++-  // Build a fake source and destination for initialization.\n++-  InitializedEntity ToEntity(InitializedEntity::InitializeTemporary(To));\n++-  OpaqueValueExpr FromExpr(Loc, From.getNonLValueExprType(Context),\n++-                           Expr::getValueKindForType(From));\n++-  InitializationKind Kind =\n++-      InitializationKind::CreateCopy(Loc, SourceLocation());\n++-\n++-  // Perform the initialization in an unevaluated context within a SFINAE\n++-  // trap at translation unit scope.\n++-  EnterExpressionEvaluationContext Unevaluated(\n++-      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n++-  Sema::SFINAETrap SFINAE(*this, /*AccessCheckingSFINAE=*/true);\n++-  Sema::ContextRAII TUContext(*this, Context.getTranslationUnitDecl());\n++-  Expr *FromExprPtr = &FromExpr;\n++-  InitializationSequence Init(*this, ToEntity, Kind, FromExprPtr);\n++-  if (Init.Failed())\n++-    return false;\n++-\n++-  ExprResult Result = Init.Perform(*this, ToEntity, Kind, FromExprPtr);\n++-  if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n++-    return false;\n++-\n++-  return !CheckNothrow || canThrow(Result.get()) == CT_Cannot;\n++-}\n++-\n++ QualType Sema::BuildUnaryTransformType(QualType BaseType, UTTKind UKind,\n++                                        SourceLocation Loc) {\n++   if (BaseType->isDependentType())\n++diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTypeTraits.cpp b/clang/lib/Sema/SemaTypeTraits.cpp\n++--- a/clang/lib/Sema/SemaTypeTraits.cpp\n+++++ b/clang/lib/Sema/SemaTypeTraits.cpp\n++@@ -1212,6 +1212,76 @@\n++                                     const TypeSourceInfo *Rhs,\n++                                     SourceLocation KeyLoc);\n++ \n+++static ExprResult CheckConvertibilityForTypeTraits(\n+++    Sema &Self, const TypeSourceInfo *Lhs, const TypeSourceInfo *Rhs,\n+++    SourceLocation KeyLoc, llvm::BumpPtrAllocator &OpaqueExprAllocator) {\n+++\n+++  QualType LhsT = Lhs->getType();\n+++  QualType RhsT = Rhs->getType();\n+++\n+++  // C++0x [meta.rel]p4:\n+++  //   Given the following function prototype:\n+++  //\n+++  //     template <class T>\n+++  //       typename add_rvalue_reference<T>::type create();\n+++  //\n+++  //   the predicate condition for a template specialization\n+++  //   is_convertible<From, To> shall be satisfied if and only if\n+++  //   the return expression in the following code would be\n+++  //   well-formed, including any implicit conversions to the return\n+++  //   type of the function:\n+++  //\n+++  //     To test() {\n+++  //       return create<From>();\n+++  //     }\n+++  //\n+++  //   Access checking is performed as if in a context unrelated to To and\n+++  //   From. Only the validity of the immediate context of the expression\n+++  //   of the return-statement (including conversions to the return type)\n+++  //   is considered.\n+++  //\n+++  // We model the initialization as a copy-initialization of a temporary\n+++  // of the appropriate type, which for this expression is identical to the\n+++  // return statement (since NRVO doesn't apply).\n+++\n+++  // Functions aren't allowed to return function or array types.\n+++  if (RhsT->isFunctionType() || RhsT->isArrayType())\n+++    return ExprError();\n ++\n-++; Make sure we don't crash in this case.\n-++define i32 @pr153053_strict_pred_with_nonconstant_rhs(i32 %x, i32 %y) {\n-++; CHECK-LABEL: @pr153053_strict_pred_with_nonconstant_rhs(\n-++; CHECK-NEXT:  entry:\n-++; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]\n-++; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1\n-++; CHECK-NEXT:    [[RES:%.*]] = select i1 [[CMP]], i32 [[ADD]], i32 2147483647\n-++; CHECK-NEXT:    ret i32 [[RES]]\n-++;\n-++entry:\n-++  %cmp = icmp slt i32 %x, %y\n-++  %add = add i32 %x, 1\n-++  %res = select i1 %cmp, i32 %add, i32 2147483647\n-++  ret i32 %res\n-++}\n+++  // A function definition requires a complete, non-abstract return type.\n+++  if (!Self.isCompleteType(Rhs->getTypeLoc().getBeginLoc(), RhsT) ||\n+++      Self.isAbstractType(Rhs->getTypeLoc().getBeginLoc(), RhsT))\n+++    return ExprError();\n+++\n+++  // Compute the result of add_rvalue_reference.\n+++  if (LhsT->isObjectType() || LhsT->isFunctionType())\n+++    LhsT = Self.Context.getRValueReferenceType(LhsT);\n+++\n+++  // Build a fake source and destination for initialization.\n+++  InitializedEntity To(InitializedEntity::InitializeTemporary(RhsT));\n+++  Expr *From = new (OpaqueExprAllocator.Allocate<OpaqueValueExpr>())\n+++      OpaqueValueExpr(KeyLoc, LhsT.getNonLValueExprType(Self.Context),\n+++                      Expr::getValueKindForType(LhsT));\n+++  InitializationKind Kind =\n+++      InitializationKind::CreateCopy(KeyLoc, SourceLocation());\n+++\n+++  // Perform the initialization in an unevaluated context within a SFINAE\n+++  // trap at translation unit scope.\n+++  EnterExpressionEvaluationContext Unevaluated(\n+++      Self, Sema::ExpressionEvaluationContext::Unevaluated);\n+++  Sema::SFINAETrap SFINAE(Self, /*ForValidityCheck=*/true);\n+++  Sema::ContextRAII TUContext(Self, Self.Context.getTranslationUnitDecl());\n+++  InitializationSequence Init(Self, To, Kind, From);\n+++  if (Init.Failed())\n+++    return ExprError();\n+++\n+++  ExprResult Result = Init.Perform(Self, To, Kind, From);\n+++  if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n+++    return ExprError();\n+ +\n+-+; Make sure we don't crash in this case.\n+-+define i32 @pr153053_strict_pred_with_nonconstant_rhs(i32 %x, i32 %y) {\n+-+; CHECK-LABEL: @pr153053_strict_pred_with_nonconstant_rhs(\n+-+; CHECK-NEXT:  entry:\n+-+; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]\n+-+; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1\n+-+; CHECK-NEXT:    [[RES:%.*]] = select i1 [[CMP]], i32 [[ADD]], i32 2147483647\n+-+; CHECK-NEXT:    ret i32 [[RES]]\n+-+;\n+-+entry:\n+-+  %cmp = icmp slt i32 %x, %y\n+-+  %add = add i32 %x, 1\n+-+  %res = select i1 %cmp, i32 %add, i32 2147483647\n+-+  ret i32 %res\n+++  return Result;\n+ +}\n+++\n++ static APValue EvaluateSizeTTypeTrait(Sema &S, TypeTrait Kind,\n++                                       SourceLocation KWLoc,\n++                                       ArrayRef<TypeSourceInfo *> Args,\n++@@ -1372,8 +1442,9 @@\n++           S.Context.getPointerType(T.getNonReferenceType()));\n++       TypeSourceInfo *UPtr = S.Context.CreateTypeSourceInfo(\n++           S.Context.getPointerType(U.getNonReferenceType()));\n++-      return S.BuiltinIsConvertible(UPtr->getType(), TPtr->getType(),\n++-                                    RParenLoc);\n+++      return !CheckConvertibilityForTypeTraits(S, UPtr, TPtr, RParenLoc,\n+++                                               OpaqueExprAllocator)\n+++                  .isInvalid();\n++     }\n++ \n++     if (Kind == clang::TT_IsNothrowConstructible)\n++@@ -1624,9 +1695,20 @@\n++   }\n++   case BTT_IsConvertible:\n++   case BTT_IsConvertibleTo:\n++-  case BTT_IsNothrowConvertible:\n++-    return Self.BuiltinIsConvertible(LhsT, RhsT, KeyLoc,\n++-                                     BTT == BTT_IsNothrowConvertible);\n+++  case BTT_IsNothrowConvertible: {\n+++    if (RhsT->isVoidType())\n+++      return LhsT->isVoidType();\n+++    llvm::BumpPtrAllocator OpaqueExprAllocator;\n+++    ExprResult Result = CheckConvertibilityForTypeTraits(Self, Lhs, Rhs, KeyLoc,\n+++                                                         OpaqueExprAllocator);\n+++    if (Result.isInvalid())\n+++      return false;\n+++\n+++    if (BTT != BTT_IsNothrowConvertible)\n+++      return true;\n+++\n+++    return Self.canThrow(Result.get()) == CT_Cannot;\n+++  }\n++ \n++   case BTT_IsAssignable:\n++   case BTT_IsNothrowAssignable:\n++diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/type-trait-common-reference.cpp b/clang/test/SemaCXX/type-trait-common-reference.cpp\n++--- a/clang/test/SemaCXX/type-trait-common-reference.cpp\n+++++ b/clang/test/SemaCXX/type-trait-common-reference.cpp\n++@@ -1,136 +0,0 @@\n++-// RUN: %clang_cc1 -triple x86_64-apple-darwin10 -fsyntax-only -verify -std=c++17 -Wno-vla-cxx-extension %s\n++-// RUN: %clang_cc1 -triple x86_64-apple-darwin10 -fsyntax-only -verify -std=c++20 -Wno-vla-cxx-extension %s\n++-\n++-#if !__has_builtin(__builtin_common_reference)\n++-#  error\n++-#endif\n++-\n++-// expected-note@*:* {{template <template <class, class, template <class> class, template <class> class> class, template <class ...> class, template <class> class, class, class ...>}}\n++-\n++-void test() {\n++-  __builtin_common_reference<> a; // expected-error {{too few template arguments for template '__builtin_common_reference'}}\n++-  __builtin_common_reference<1> b; // expected-error {{template argument for template template parameter must be a class template or type alias template}}\n++-  __builtin_common_reference<int, 1> c; // expected-error {{template argument for template template parameter must be a class template or type alias template}}\n++-}\n++-\n++-struct empty_type {};\n++-\n++-template <class T>\n++-struct type_identity {\n++-  using type = T;\n++-};\n++-\n++-template <class...>\n++-struct common_type;\n++-\n++-template <class... Args>\n++-using common_type_t = typename common_type<Args...>::type;\n++-\n++-template <class, class, template <class> class, template <class> class>\n++-struct basic_common_reference {};\n++-\n++-template <class T, class U, template <class> class TX, template <class> class UX>\n++-using basic_common_reference_t = typename basic_common_reference<T, U, TX, UX>::type;\n++-\n++-void test_vla() {\n++-  int i = 4;\n++-  int VLA[i];\n++-  __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, decltype(VLA)> d; // expected-error {{variably modified type 'decltype(VLA)' (aka 'int[i]') cannot be used as a template argument}}\n++-}\n++-\n++-template <class... Args>\n++-using common_reference_base = __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, Args...>;\n++-\n++-template <class... Args>\n++-struct common_reference : common_reference_base<Args...> {};\n++-\n++-template <class... Args>\n++-using common_reference_t = typename __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, Args...>::type;\n++-\n++-struct Incomplete;\n++-\n++-template<>\n++-struct common_type<Incomplete, Incomplete>;\n++-\n++-static_assert(__is_same(common_reference_base<>, empty_type));\n++-\n++-static_assert(__is_same(common_reference_base<Incomplete>, type_identity<Incomplete>));\n++-static_assert(__is_same(common_reference_base<char>, type_identity<char>));\n++-static_assert(__is_same(common_reference_base<int>, type_identity<int>));\n++-static_assert(__is_same(common_reference_base<const int>, type_identity<const int>));\n++-static_assert(__is_same(common_reference_base<volatile int>, type_identity<volatile int>));\n++-static_assert(__is_same(common_reference_base<const volatile int>, type_identity<const volatile int>));\n++-static_assert(__is_same(common_reference_base<int[]>, type_identity<int[]>));\n++-static_assert(__is_same(common_reference_base<const int[]>, type_identity<const int[]>));\n++-static_assert(__is_same(common_reference_base<void(&)()>, type_identity<void(&)()>));\n++-\n++-static_assert(__is_same(common_reference_base<int[], int[]>, type_identity<int*>));\n++-static_assert(__is_same(common_reference_base<int, int>, type_identity<int>));\n++-static_assert(__is_same(common_reference_base<int, long>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<long, int>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<long, long>, type_identity<long>));\n++-\n++-static_assert(__is_same(common_reference_base<const int, long>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<const volatile int, long>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<int, const long>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<int, const volatile long>, type_identity<long>));\n++-\n++-static_assert(__is_same(common_reference_base<int*, long*>, empty_type));\n++-static_assert(__is_same(common_reference_base<const unsigned int *const &, const unsigned int *const &>, type_identity<const unsigned int *const &>));\n++-\n++-static_assert(__is_same(common_reference_base<int, long, float>, type_identity<float>));\n++-static_assert(__is_same(common_reference_base<unsigned, char, long>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<long long, long long, long>, type_identity<long long>));\n++-\n++-static_assert(__is_same(common_reference_base<int [[clang::address_space(1)]]>, type_identity<int [[clang::address_space(1)]]>));\n++-static_assert(__is_same(common_reference_base<int [[clang::address_space(1)]], int>, type_identity<int>));\n++-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], int>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], int [[clang::address_space(1)]]>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], long [[clang::address_space(1)]]>, type_identity<long>));\n++-static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], long [[clang::address_space(2)]]>, type_identity<long>));\n++-\n++-struct S {};\n++-struct T : S {};\n++-struct U {};\n++-\n++-static_assert(__is_same(common_reference_base<S&&, T&&>, type_identity<S&&>));\n++-\n++-static_assert(__is_same(common_reference_base<int S::*, int S::*>, type_identity<int S::*>));\n++-static_assert(__is_same(common_reference_base<int S::*, int T::*>, type_identity<int T::*>));\n++-static_assert(__is_same(common_reference_base<int S::*, long S::*>, empty_type));\n++-\n++-static_assert(__is_same(common_reference_base<int (S::*)(), int (S::*)()>, type_identity<int (S::*)()>));\n++-static_assert(__is_same(common_reference_base<int (S::*)(), int (T::*)()>, type_identity<int (T::*)()>));\n++-static_assert(__is_same(common_reference_base<int (S::*)(), long (S::*)()>, empty_type));\n++-\n++-static_assert(__is_same(common_reference_base<int&, int&>, type_identity<int&>));\n++-static_assert(__is_same(common_reference_base<int&, const int&>, type_identity<const int&>));\n++-static_assert(__is_same(common_reference_base<volatile int&, const int&>, type_identity<const volatile int&>));\n++-\n++-template <class T, class U>\n++-struct my_pair;\n++-\n++-template <class T1, class U1, class T2, class U2, template <class> class TX, template <class> class UX>\n++-struct basic_common_reference<my_pair<T1, U1>, my_pair<T2, U2>, TX, UX> {\n++-  using type = my_pair<common_reference_t<TX<T1>, UX<T2>>, common_reference_t<TX<U1>, UX<U2>>>;\n++-};\n++-\n++-static_assert(__is_same(common_reference_base<my_pair<const int&, int&>, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, volatile int&>>));\n++-static_assert(__is_same(common_reference_base<const my_pair<int, int>&, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, const volatile int&>>));\n++-static_assert(__is_same(common_reference_base<const int&, const volatile int&>, type_identity<const volatile int&>));\n++-static_assert(__is_same(common_reference_base<int&&, const volatile int&>, type_identity<int>));\n++-static_assert(__is_same(common_reference_base<my_pair<int, int>&&, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, int>>));\n++-static_assert(__is_same(common_reference_base<my_pair<int, int>&&, my_pair<int&, int>&&>, type_identity<my_pair<const int&, int&&>>));\n++-\n++-struct conversion_operator {\n++-  operator volatile int&&() volatile;\n++-};\n++-\n++-static_assert(__is_same(common_reference_base<volatile conversion_operator&&, volatile int&&>, type_identity<volatile int&&>));\n++-\n++-struct reference_wrapper {\n++-  reference_wrapper(int&);\n++-  operator int&() const;\n++-};\n++-\n++-static_assert(__is_same(common_reference_base<const reference_wrapper&, int&>, empty_type));\n++diff -ruN --strip-trailing-cr a/libcxx/include/__locale_dir/num.h b/libcxx/include/__locale_dir/num.h\n++--- a/libcxx/include/__locale_dir/num.h\n+++++ b/libcxx/include/__locale_dir/num.h\n++@@ -436,6 +436,7 @@\n++         ++__first;\n++         if (__first == __last) {\n++           __err |= ios_base::eofbit;\n+++          __v = 0;\n++           return __first;\n++         }\n++         // __c2 == 'x' || __c2 == 'X'\n++@@ -444,6 +445,7 @@\n++           ++__first;\n++         } else {\n++           __base = 8;\n+++          __parsed_num = true; // We only swallowed '0', so we've started to parse a number\n++         }\n++       } else {\n++         __base = 10;\n++diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap.in b/libcxx/include/module.modulemap.in\n++--- a/libcxx/include/module.modulemap.in\n+++++ b/libcxx/include/module.modulemap.in\n++@@ -1517,7 +1517,6 @@\n++       header \"__iterator/iterator_traits.h\"\n++       export std_core.type_traits.integral_constant\n++       export std_core.type_traits.is_convertible\n++-      export std_core.type_traits.nat\n++     }\n++     module iterator_with_data         { header \"__iterator/iterator_with_data.h\" }\n++     module iterator                   { header \"__iterator/iterator.h\" }\n++diff -ruN --strip-trailing-cr a/libcxx/include/__type_traits/common_reference.h b/libcxx/include/__type_traits/common_reference.h\n++--- a/libcxx/include/__type_traits/common_reference.h\n+++++ b/libcxx/include/__type_traits/common_reference.h\n++@@ -18,37 +18,16 @@\n++ #include <__type_traits/is_reference.h>\n++ #include <__type_traits/remove_cvref.h>\n++ #include <__type_traits/remove_reference.h>\n++-#include <__type_traits/type_identity.h>\n++ #include <__utility/declval.h>\n++ \n++ #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n++ #  pragma GCC system_header\n++ #endif\n++ \n++-#if _LIBCPP_STD_VER >= 20\n++-\n++ _LIBCPP_BEGIN_NAMESPACE_STD\n++ \n++-template <class...>\n++-struct _LIBCPP_NO_SPECIALIZATIONS common_reference;\n++-\n++-template <class... _Types>\n++-using common_reference_t = typename common_reference<_Types...>::type;\n++-\n++-template <class, class, template <class> class, template <class> class>\n++-struct basic_common_reference {};\n++-\n++-#  if __has_builtin(__builtin_common_reference)\n++-\n++-template <class _Tp, class _Up, template <class> class _Tx, template <class> class _Ux>\n++-using __basic_common_reference_t = basic_common_reference<_Tp, _Up, _Tx, _Ux>::type;\n++-\n++-template <class... _Args>\n++-struct _LIBCPP_NO_SPECIALIZATIONS common_reference\n++-    : __builtin_common_reference<__basic_common_reference_t, common_type_t, type_identity, __empty, _Args...> {};\n++-\n++-#  else\n++-\n+++// common_reference\n+++#if _LIBCPP_STD_VER >= 20\n++ // Let COND_RES(X, Y) be:\n++ template <class _Xp, class _Yp>\n++ using __cond_res _LIBCPP_NODEBUG = decltype(false ? std::declval<_Xp (&)()>()() : std::declval<_Yp (&)()>()());\n++@@ -130,10 +109,19 @@\n++ \n++ // Note C: For the common_reference trait applied to a parameter pack [...]\n++ \n+++template <class...>\n+++struct _LIBCPP_NO_SPECIALIZATIONS common_reference;\n+++\n+++template <class... _Types>\n+++using common_reference_t = typename common_reference<_Types...>::type;\n+++\n+++template <class, class, template <class> class, template <class> class>\n+++struct basic_common_reference {};\n+++\n++ _LIBCPP_DIAGNOSTIC_PUSH\n++-#    if __has_warning(\"-Winvalid-specialization\")\n+++#  if __has_warning(\"-Winvalid-specialization\")\n++ _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(\"-Winvalid-specialization\")\n++-#    endif\n+++#  endif\n++ // bullet 1 - sizeof...(T) == 0\n++ template <>\n++ struct common_reference<> {};\n++@@ -207,10 +195,8 @@\n++ template <class...>\n++ struct _LIBCPP_NO_SPECIALIZATIONS common_reference {};\n++ \n++-#  endif // __has_builtin(__builtin_common_reference)\n+++#endif // _LIBCPP_STD_VER >= 20\n++ \n++ _LIBCPP_END_NAMESPACE_STD\n++ \n++-#endif // _LIBCPP_STD_VER >= 20\n++-\n++ #endif // _LIBCPP___TYPE_TRAITS_COMMON_REFERENCE_H\n++diff -ruN --strip-trailing-cr a/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp b/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n++--- a/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n+++++ b/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n++@@ -670,5 +670,101 @@\n++       assert(v == std::numeric_limits<long>::min());\n++     }\n++ \n+++  { // Check that auto-detection of the base works properly\n+++    ios.flags(ios.flags() & ~std::ios::basefield);\n+++    { // zeroes\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"0\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 1), ios, err, v);\n+++        assert(base(iter) == str + 1);\n+++        assert(err == ios.eofbit);\n+++        assert(v == 0);\n+++      }\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"00\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n+++        assert(base(iter) == str + 2);\n+++        assert(err == ios.eofbit);\n+++        assert(v == 0);\n+++      }\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"0x0\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n+++        assert(base(iter) == str + 3);\n+++        assert(err == ios.eofbit);\n+++        assert(v == 0);\n+++      }\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"0X0\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n+++        assert(base(iter) == str + 3);\n+++        assert(err == ios.eofbit);\n+++        assert(v == 0);\n+++      }\n+++    }\n+++    { // first character after base is out of range\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"08\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n+++        assert(base(iter) == str + 1);\n+++        assert(err == ios.goodbit);\n+++        assert(v == 0);\n+++      }\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"1a\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n+++        assert(base(iter) == str + 1);\n+++        assert(err == ios.goodbit);\n+++        assert(v == 1);\n+++      }\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"0xg\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n+++        assert(base(iter) == str + 2);\n+++        assert(err == ios.failbit);\n+++        assert(v == 0);\n+++      }\n+++      {\n+++        v                          = -1;\n+++        const char str[]           = \"0Xg\";\n+++        std::ios_base::iostate err = ios.goodbit;\n+++\n+++        cpp17_input_iterator<const char*> iter =\n+++            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n+++        assert(base(iter) == str + 2);\n+++        assert(err == ios.failbit);\n+++        assert(v == 0);\n+++      }\n+++    }\n+++  }\n+++\n++   return 0;\n++ }\n++diff -ruN --strip-trailing-cr a/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td b/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n++--- a/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n+++++ b/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n++@@ -948,8 +948,7 @@\n++     auto [id, args] = NVVM::MBarrierArriveExpectTxOp::getIntrinsicIDAndArgs(\n++                       *op, moduleTranslation, builder);\n++ \n++-    int addrSpace = llvm::cast<LLVMPointerType>(op.getAddr().getType()).getAddressSpace();\n++-    if (addrSpace != NVVM::NVVMMemorySpace::SharedCluster)\n+++    if (op.getNumResults() > 0)\n++       $res = createIntrinsicCall(builder, id, args);\n++     else\n++       createIntrinsicCall(builder, id, args);\n++@@ -985,9 +984,7 @@\n++   string llvmBuilder = [{\n++     auto [id, args] = NVVM::MBarrierArriveDropExpectTxOp::getIntrinsicIDAndArgs(\n++                       *op, moduleTranslation, builder);\n++-\n++-    int addrSpace = llvm::cast<LLVMPointerType>(op.getAddr().getType()).getAddressSpace();\n++-    if (addrSpace != NVVM::NVVMMemorySpace::SharedCluster)\n+++    if (op.getNumResults() > 0)\n++       $res = createIntrinsicCall(builder, id, args);\n++     else\n++       createIntrinsicCall(builder, id, args);\n++diff -ruN --strip-trailing-cr a/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir b/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n++--- a/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n+++++ b/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n++@@ -44,6 +44,7 @@\n++   gpu.host_register %2 : memref<*xf64>\n++   gpu.host_register %20 : memref<*xf64>\n++   gpu.host_register %33 : memref<*xf64>\n+++  gpu.host_register %34 : memref<*xf64>\n++ \n++   gpu.launch blocks(%bx, %by, %bz) in (%grid_x = %c1, %grid_y = %c1, %grid_z = %c1)\n++              threads(%tx, %ty, %tz) in (%block_x = %c32, %block_y = %c1, %block_z = %c1) {\n++diff -ruN --strip-trailing-cr a/utils/bazel/configure.bzl b/utils/bazel/configure.bzl\n++--- a/utils/bazel/configure.bzl\n+++++ b/utils/bazel/configure.bzl\n++@@ -27,7 +27,6 @@\n++     \"XCore\",\n++ ]\n++ \n++-\n++ MAX_TRAVERSAL_STEPS = 1000000  # \"big number\" upper bound on total visited dirs\n++ \n++ def _overlay_directories(repository_ctx):\n++@@ -44,7 +43,9 @@\n++     for _ in range(MAX_TRAVERSAL_STEPS):\n++         rel_dir = stack.pop()\n++ \n++-        overlay_dirs = set()\n+++        # TODO: `set()` is only available in bazel 8.1.\n+++        # Use `set()` after downstream users are on more recent versions.\n+++        overlay_dirs = {}\n++ \n++         # Symlink overlay files, overlay dirs will be handled in future iterations.\n++         for entry in overlay_root.get_child(rel_dir).readdir():\n++@@ -53,7 +54,7 @@\n++ \n++             if entry.is_dir:\n++                 stack.append(full_rel_path)\n++-                overlay_dirs.add(name)\n+++                overlay_dirs[name] = None\n++             else:\n++                 src_path = overlay_root.get_child(full_rel_path)\n++                 dst_path = target_root.get_child(full_rel_path)\n++@@ -62,7 +63,7 @@\n++         # Symlink source dirs (if not themselves overlaid) and files.\n++         for src_entry in src_root.get_child(rel_dir).readdir():\n++             name = src_entry.basename\n++-            if name in overlay_dirs:\n+++            if name in overlay_dirs.keys():\n++                 # Skip: overlay has a directory with this name\n++                 continue\n++ \n diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl\n-index daf3e74..807db4f 100644\n+index 9e0bf3d..f8f483c 100644\n --- a/third_party/llvm/workspace.bzl\n +++ b/third_party/llvm/workspace.bzl\n @@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n  \n  def repo(name):\n      \"\"\"Imports LLVM.\"\"\"\n--    LLVM_COMMIT = \"0c2701fe7fa002e1befc5f86c268a7964f96d286\"\n--    LLVM_SHA256 = \"50b0cb64adf161b4441ee32453f2eb9a015263e4eb3c036548f0207cbe3d0707\"\n-+    LLVM_COMMIT = \"0bd2f12753604cd072ae0935820ba9a23bb17ccc\"\n-+    LLVM_SHA256 = \"e60e866c649331e41907124f8b3537ecea10acf49da7c5a344d78089df492f0e\"\n+-    LLVM_COMMIT = \"0bd2f12753604cd072ae0935820ba9a23bb17ccc\"\n+-    LLVM_SHA256 = \"e60e866c649331e41907124f8b3537ecea10acf49da7c5a344d78089df492f0e\"\n++    LLVM_COMMIT = \"ac66ae45cd22a7958ace645a035831000bfcbf51\"\n++    LLVM_SHA256 = \"3bb51316595bbe99da8bee121f1fc39993176afc5b55f72a5d5010214dcd24a8\"\n  \n      tf_http_archive(\n          name = name,"
        },
        {
            "sha": "5ce38746d2ce30e07ff103210cbf0414ae24728e",
            "filename": "third_party/xla/third_party/shardy/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e7947e538cc2bf87acd2bc86515c8f4164d54a4/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl?ref=6e7947e538cc2bf87acd2bc86515c8f4164d54a4",
            "patch": "@@ -3,8 +3,8 @@\n load(\"//third_party:repo.bzl\", \"tf_http_archive\", \"tf_mirror_urls\")\n \n def repo():\n-    SHARDY_COMMIT = \"23359578eec0292a45958f560b19ea574d98e669\"\n-    SHARDY_SHA256 = \"47d53e6f02f6b752ec237237978144ab8ccd291c8b84e97cb349198bec4153b2\"\n+    SHARDY_COMMIT = \"3b103e71626e7a68d859f9dad077a07b35f2314d\"\n+    SHARDY_SHA256 = \"53d3a8bd1eb6402b4e514ad4b4fad1e28cf907aac688c479e75d7d95e4b2df33\"\n \n     tf_http_archive(\n         name = \"shardy\","
        }
    ],
    "stats": {
        "total": 2658,
        "additions": 2584,
        "deletions": 74
    }
}