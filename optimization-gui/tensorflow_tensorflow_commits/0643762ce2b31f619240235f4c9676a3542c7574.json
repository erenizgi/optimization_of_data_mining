{
    "author": "pschuh",
    "message": "rollforward: Redefine defined_status_ to just be tsl::AsyncValueRef<EventPool::Handle>\nand treat the definition event specially (to avoid some locking).\n\nCrucially this allows in the future making event_ an indirect async value\nin order to implement the PjRtDeviceEventPromise API.\n\nReverts fd32c1a1d90c23ad22be146a3388117b5229d810\n\nPiperOrigin-RevId: 798372919",
    "sha": "0643762ce2b31f619240235f4c9676a3542c7574",
    "files": [
        {
            "sha": "d41115b2a99676e33cb6da9d062e523d923dbeac",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 47,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0643762ce2b31f619240235f4c9676a3542c7574/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0643762ce2b31f619240235f4c9676a3542c7574/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc?ref=0643762ce2b31f619240235f4c9676a3542c7574",
            "patch": "@@ -52,39 +52,34 @@ namespace xla {\n \n void BufferSequencingEvent::SetSequencingEvent(EventPool::Handle event,\n                                                se::Stream* stream) {\n-  {\n-    absl::MutexLock lock(&mu_);\n-    CHECK(!event_.event());\n-    event_ = std::move(event);\n-    CHECK(streams_defined_on_.empty());\n-    streams_defined_on_.push_back(stream);\n-    sequence_number_.store(event_.sequence_number(), std::memory_order_seq_cst);\n-  }\n-  defined_status_.emplace(absl::OkStatus());\n+  EventState state;\n+  state.event = std::move(event);\n+  state.definition_stream = stream;\n+  event_.emplace(std::move(state));\n }\n \n void BufferSequencingEvent::SetDefinedStatus(absl::Status status) {\n   CHECK(!status.ok());\n-  defined_status_.emplace(status);\n-}\n-\n-bool BufferSequencingEvent::EventHasBeenRecorded() const {\n-  return event_.event() != nullptr;\n+  event_.SetError(status);\n }\n \n uint64_t BufferSequencingEvent::sequence_number() const {\n-  uint64_t seq = sequence_number_.load(std::memory_order_seq_cst);\n-  return seq;\n+  return event_->event.sequence_number();\n }\n \n void BufferSequencingEvent::WaitForEventOnStream(se::Stream* stream) {\n-  absl::MutexLock lock(&mu_);\n-\n   // We cannot wait for an event until ThenRecordEvent has been called; on GPU\n   // newly created events are deemed to have already happened past.\n-  mu_.Await(\n-      absl::Condition(this, &BufferSequencingEvent::EventHasBeenRecorded));\n+  tsl::BlockUntilReady(event_);\n+\n+  if (event_.IsError()) {\n+    return;\n+  }\n+  if (event_->definition_stream == stream) {\n+    return;\n+  }\n \n+  absl::MutexLock lock(&mu_);\n   // The set of defined streams is expected to be very small indeed (usually\n   // 1-2), so a simple linear scan should be fast enough.\n   if (std::find(streams_defined_on_.begin(), streams_defined_on_.end(),\n@@ -93,31 +88,30 @@ void BufferSequencingEvent::WaitForEventOnStream(se::Stream* stream) {\n     return;\n   }\n \n-  stream->WaitFor(event_.event()).IgnoreError();\n+  stream->WaitFor(event_->event.event()).IgnoreError();\n   streams_defined_on_.push_back(stream);\n }\n \n absl::Status BufferSequencingEvent::WaitForEventOnExternalStream(\n     std::intptr_t stream) {\n-  absl::MutexLock lock(&mu_);\n-\n-  // We cannot wait for an event until ThenRecordEvent has been called; on GPU\n-  // newly created events are deemed to have already happened past.\n-  // TODO(skyewm): do we need this? WaitForEventOnExternalStream is only\n-  // implemented for GPU.\n-  mu_.Await(\n-      absl::Condition(this, &BufferSequencingEvent::EventHasBeenRecorded));\n-\n-  return event_.event()->WaitForEventOnExternalStream(stream);\n+  tsl::BlockUntilReady(event_);\n+  if (const auto* error = event_.GetErrorIfPresent()) {\n+    return *error;\n+  }\n+  return event_->event.event()->WaitForEventOnExternalStream(stream);\n }\n \n bool BufferSequencingEvent::IsPredeterminedErrorOrDefinedOn(\n     se::Stream* stream) {\n-  tsl::BlockUntilReady(defined_status_);\n-  CHECK(defined_status_.IsConcrete());\n+  tsl::BlockUntilReady(event_);\n+  CHECK(event_.IsAvailable());\n \n   // IsPredeterminedError\n-  if (!defined_status_->ok()) {\n+  if (event_.IsError()) {\n+    return true;\n+  }\n+\n+  if (event_->definition_stream == stream) {\n     return true;\n   }\n \n@@ -128,14 +122,12 @@ bool BufferSequencingEvent::IsPredeterminedErrorOrDefinedOn(\n }\n \n bool BufferSequencingEvent::IsComplete() {\n-  absl::MutexLock lock(&mu_);\n-\n-  // We cannot wait for an event until ThenRecordEvent has been called; on\n-  // GPU newly created events are deemed to have already happened past.\n-  mu_.Await(\n-      absl::Condition(this, &BufferSequencingEvent::EventHasBeenRecorded));\n+  tsl::BlockUntilReady(event_);\n+  if (event_.IsError()) {\n+    return true;\n+  }\n \n-  return event_.event()->PollForStatus() == se::Event::Status::kComplete;\n+  return event_->event.event()->PollForStatus() == se::Event::Status::kComplete;\n }\n \n void BufferSequencingEvent::ExecuteOrAddToFutureTasks(\n@@ -154,10 +146,9 @@ void BufferSequencingEvent::ExecuteOrAddToFutureTasks(\n \n   // Execute the `task` when definition event becomes available. If it's already\n   // available, the task will be executed immediately.\n-  defined_status_.AndThen(\n-      [this, traced_task = std::move(traced_task)]() mutable {\n-        thread_pool_->Schedule(std::move(traced_task));\n-      });\n+  event_.AndThen([this, traced_task = std::move(traced_task)]() mutable {\n+    thread_pool_->Schedule(std::move(traced_task));\n+  });\n }\n \n ShapedBuffer RawSEDeviceMemory::AsShapedBuffer(\n@@ -273,15 +264,15 @@ void TrackedDeviceBuffer::AddUsageEvent(se::Stream* usage_stream,\n \n   // If the event is 0, it means that the event is not recorded yet and the task\n   // related to this event is deferred, so just add it.\n-  if (*event == 0) {\n+  if (!event->IsDefined()) {\n     usage_events_.push_back({usage_stream, event, reference_held});\n     return;\n   }\n \n   for (auto& existing : usage_events_) {\n     // If the existing event is 0, it means that the event is not recorded yet\n     // and the task related to this event is deferred, so don't replace it.\n-    if (*existing.event == 0) continue;\n+    if (!existing.event->IsDefined()) continue;\n     if (existing.stream == usage_stream) {\n       if (*existing.event < *event) {\n         existing.event = event;"
        },
        {
            "sha": "092f77c3128c281d482f8f2aea5d3d76372ecdbd",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.h",
            "status": "modified",
            "additions": 20,
            "deletions": 26,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0643762ce2b31f619240235f4c9676a3542c7574/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0643762ce2b31f619240235f4c9676a3542c7574/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h?ref=0643762ce2b31f619240235f4c9676a3542c7574",
            "patch": "@@ -78,7 +78,7 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n  public:\n   explicit BufferSequencingEvent(tsl::thread::ThreadPool* thread_pool)\n       : thread_pool_(thread_pool),\n-        defined_status_(tsl::MakeUnconstructedAsyncValueRef<absl::Status>()) {}\n+        event_(tsl::MakeUnconstructedAsyncValueRef<EventState>()) {}\n \n   static tsl::AsyncValueRef<BufferSequencingEvent> Create(\n       tsl::thread::ThreadPool* thread_pool) {\n@@ -124,29 +124,26 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n     return !(*this < rhs);\n   }\n \n-  inline bool operator==(int number) const {\n-    return sequence_number() == number;\n-  }\n-\n   // Executes the `task` if the event is ready; otherwise adds the `task`\n-  // callback to `defined_status_` async value, to be executed when it becomes\n+  // callback to `event_` async value, to be executed when it becomes\n   // available.\n   void ExecuteOrAddToFutureTasks(const std::string& task_name,\n                                  std::function<void()> task);\n \n-  bool IsDefined() { return defined_status_.IsConcrete(); }\n+  bool IsDefined() { return event_.IsAvailable(); }\n \n   // Do not call directly. Use PjRtStreamExecutorClient::SetEventAsError.\n   void SetDefinedStatus(absl::Status status);\n \n   absl::Status GetDefinedStatus() {\n-    CHECK(defined_status_.IsConcrete());\n-    return *defined_status_;\n+    CHECK(event_.IsAvailable());\n+    if (const auto* error = event_.GetErrorIfPresent()) {\n+      return *error;\n+    }\n+    return absl::OkStatus();\n   }\n \n-  bool IsPredeterminedError() {\n-    return defined_status_.IsConcrete() && !defined_status_->ok();\n-  }\n+  bool IsPredeterminedError() { return event_.IsError(); }\n \n   // Returns true if either:\n   // 1. The event IsPredeterminedError\n@@ -156,21 +153,18 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n   // blocks the calling thread until either of those 2 happens.\n   bool IsPredeterminedErrorOrDefinedOn(se::Stream* stream);\n \n- private:\n-  bool EventHasBeenRecorded() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n-  uint64_t sequence_number() const;\n+  struct EventState {\n+    // An event that is triggered when the content of one or more buffers has\n+    // been read or written. If this event is used as a definition event and is\n+    // nullptr, it is assumed that the buffer's content is always defined for\n+    // example because it uses storage borrowed from elsewhere.\n+    EventPool::Handle event;\n \n-  // An event that is triggered when the content of one or more buffers has been\n-  // read or written. If this event is used as a definition event and is\n-  // nullptr, it is assumed that the buffer's content is always defined for\n-  // example because it uses storage borrowed from elsewhere.\n-  EventPool::Handle event_;\n+    se::Stream* definition_stream;\n+  };\n \n-  // Cache of event_->sequence_number that avoids synchronization overhead.\n-  // TODO(phawkins): In fact, event_->sequence_number is unused beyond the\n-  // initial population of sequence_number_, and we could remove it if we\n-  // refactored the EventPool API.\n-  std::atomic<uint64_t> sequence_number_{0};\n+ private:\n+  uint64_t sequence_number() const;\n \n   mutable absl::Mutex mu_;\n   // A list of all streams for which the buffer's content is known to be defined\n@@ -181,7 +175,7 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n \n   // Indicates if the buffer is in an error status. And error status is used to\n   // propagate the error to the buffer consumers.\n-  tsl::AsyncValueRef<absl::Status> defined_status_;\n+  tsl::AsyncValueRef<EventState> event_;\n };\n \n using BufferSequencingEventRef = tsl::AsyncValueRef<BufferSequencingEvent>;"
        }
    ],
    "stats": {
        "total": 131,
        "additions": 58,
        "deletions": 73
    }
}