{
    "author": "ezhulenev",
    "message": "[xla:cpu] Do not register builtin runtime symbols as custom calls\n\nSimplify runtime symbols registration with XLA:CPU executables\n\nPiperOrigin-RevId: 827730741",
    "sha": "c4019fdf9d48a801df4b8218d661ea4461b52cae",
    "files": [
        {
            "sha": "f1b81f196d879da92f67b935f63529b08835a145",
            "filename": "third_party/xla/xla/service/cpu/BUILD",
            "status": "modified",
            "additions": 5,
            "deletions": 25,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c4019fdf9d48a801df4b8218d661ea4461b52cae/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c4019fdf9d48a801df4b8218d661ea4461b52cae/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD?ref=c4019fdf9d48a801df4b8218d661ea4461b52cae",
            "patch": "@@ -4,7 +4,6 @@\n load(\n     \"//third_party/compute_library:build_defs.bzl\",\n     \"acl_deps\",\n-    \"if_enable_acl\",\n )\n load(\n     \"//xla:xla.default.bzl\",\n@@ -568,41 +567,22 @@ tf_proto_library(\n \n cc_library(\n     name = \"runtime_symbol_generator\",\n-    srcs = [\n-        \"runtime_symbol_generator.cc\",\n-        \"windows_compatibility.cc\",\n-        \"windows_compatibility.h\",\n-    ],\n+    srcs = [\"runtime_symbol_generator.cc\"],\n     hdrs = [\"runtime_symbol_generator.h\"],\n-    copts = if_enable_acl([\"-DXLA_CPU_USE_ACL=1\"]) + tsl_copts(),\n+    copts = tsl_copts(),\n     deps = [\n-        \":cpu_runtime\",\n-        \":runtime_conv2d\",\n-        \":runtime_conv2d_acl\",\n-        \":runtime_conv3d\",\n-        \":runtime_custom_call_status\",\n         \":runtime_fp16\",\n-        \":runtime_key_value_sort\",\n-        \":runtime_matmul\",\n-        \":runtime_matmul_acl\",\n         \":runtime_pow\",\n-        \":runtime_single_threaded_conv2d\",\n-        \":runtime_single_threaded_conv3d\",\n-        \":runtime_single_threaded_matmul\",\n-        \":runtime_topk\",\n-        \"//xla/service:custom_call_target_registry\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/functional:any_invocable\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@llvm-project//llvm:Core\",\n         \"@llvm-project//llvm:OrcJIT\",\n         \"@llvm-project//llvm:OrcShared\",\n         \"@llvm-project//llvm:Support\",\n         \"@llvm-project//mlir:mlir_c_runner_utils\",\n-        \"@local_tsl//tsl/platform:logging\",\n-    ] + if_onednn([\n-        \":onednn_convolution\",\n-        \":onednn_matmul\",\n-    ]),\n+    ],\n )\n \n cc_library("
        },
        {
            "sha": "86fcead497707d91c84ff171a9ab5b4a2522b10b",
            "filename": "third_party/xla/xla/service/cpu/runtime_symbol_generator.cc",
            "status": "modified",
            "additions": 119,
            "deletions": 98,
            "changes": 217,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c4019fdf9d48a801df4b8218d661ea4461b52cae/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_symbol_generator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c4019fdf9d48a801df4b8218d661ea4461b52cae/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_symbol_generator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_symbol_generator.cc?ref=c4019fdf9d48a801df4b8218d661ea4461b52cae",
            "patch": "@@ -15,15 +15,19 @@ limitations under the License.\n \n #include \"xla/service/cpu/runtime_symbol_generator.h\"\n \n+#ifdef _MSC_VER\n+#include <math.h>\n+#endif  // _MSC_VER\n+\n #include <cmath>\n #include <cstdint>\n-#include <cstdio>\n-#include <cstdlib>\n #include <cstring>\n #include <optional>\n #include <string>\n #include <utility>\n \n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/container/flat_hash_map.h\"\n #include \"llvm/ADT/StringRef.h\"\n #include \"llvm/ExecutionEngine/JITSymbol.h\"\n #include \"llvm/ExecutionEngine/Orc/AbsoluteSymbols.h\"\n@@ -35,53 +39,47 @@ limitations under the License.\n #include \"llvm/Support/Error.h\"\n #include \"xla/service/cpu/runtime_fp16.h\"\n #include \"xla/service/cpu/runtime_pow.h\"\n-#include \"xla/service/cpu/windows_compatibility.h\"  // IWYU pragma: keep\n-#include \"xla/service/custom_call_target_registry.h\"\n \n namespace xla::cpu {\n \n-RuntimeSymbolGenerator::RuntimeSymbolGenerator(llvm::DataLayout data_layout)\n-    : data_layout_(std::move(data_layout)) {}\n+//===----------------------------------------------------------------------===//\n+// A global static registry of builtin symbols available to XLA:CPU executables.\n+//===----------------------------------------------------------------------===//\n \n-llvm::Error RuntimeSymbolGenerator::tryToGenerate(\n-    llvm::orc::LookupState&, llvm::orc::LookupKind kind,\n-    llvm::orc::JITDylib& jit_dylib, llvm::orc::JITDylibLookupFlags,\n-    const llvm::orc::SymbolLookupSet& names) {\n-  llvm::orc::SymbolMap symbols;\n-  symbols.reserve(names.size());\n+using Registry = absl::flat_hash_map<std::string, llvm::orc::ExecutorSymbolDef>;\n \n-  for (const auto& [name, flags] : names) {\n-    if (auto symbol = ResolveRuntimeSymbol(*name)) {\n-      symbols[name] = *symbol;\n-    }\n-  }\n+// Create a new registry of builtin runtime symbols by looking up the addresses\n+// of the symbols in the current process. Defined below.\n+static Registry CreateRegistry();\n \n-  cantFail(jit_dylib.define(llvm::orc::absoluteSymbols(std::move(symbols))));\n-  return llvm::Error::success();\n+// Returns a global static registry of builtin runtime symbols.\n+static const Registry& StaticRegistry() {\n+  static absl::NoDestructor<Registry> registry(CreateRegistry());\n+  return *registry;\n }\n \n-std::optional<llvm::orc::ExecutorSymbolDef>\n-RuntimeSymbolGenerator::ResolveRuntimeSymbol(llvm::StringRef name) {\n-  void* fn_addr = nullptr;\n-  if (name.size() > 1 && name.front() == data_layout_.getGlobalPrefix()) {\n+static std::optional<llvm::orc::ExecutorSymbolDef> ResolveBuiltinSymbol(\n+    const llvm::DataLayout& data_layout, llvm::StringRef name) {\n+  const Registry& registry = StaticRegistry();\n+\n+  if (name.size() > 1 && name.front() == data_layout.getGlobalPrefix()) {\n     // On Mac OS X, 'name' may have a leading underscore prefix, even though the\n     // registered name may not.\n     std::string stripped_name(name.begin() + 1, name.end());\n-    fn_addr = CustomCallTargetRegistry::Global()->Lookup(stripped_name, \"Host\");\n+    if (registry.contains(stripped_name)) {\n+      return registry.at(stripped_name);\n+    }\n   } else {\n-    fn_addr = CustomCallTargetRegistry::Global()->Lookup(name.str(), \"Host\");\n+    if (registry.contains(name)) {\n+      return registry.at(name.str());\n+    }\n   }\n \n-  // We register runtime symbols as weak, because during concurrent compilation\n-  // different threads may race to register their symbols in the same dylib and\n-  // we get spurious \"symbol already defined\" errors.\n-  return llvm::orc::ExecutorSymbolDef{\n-      llvm::orc::ExecutorAddr(reinterpret_cast<uint64_t>(fn_addr)),\n-      llvm::JITSymbolFlags::Weak};\n+  return std::nullopt;\n }\n \n //===----------------------------------------------------------------------===//\n-// Register XLA:CPU runtime symbols with the CustomCallTargetRegistry.\n+// Create builtin runtime symbols registry for the current process.\n //===----------------------------------------------------------------------===//\n \n #if defined(PLATFORM_WINDOWS)\n@@ -106,43 +104,55 @@ float __extendhfsf2(uint16_t a);\n \n }  // extern \"C\"\n \n+// MSVC does not have sincos[f].\n+#ifdef _MSC_VER\n+\n+static void sincos(double x, double* sinv, double* cosv) {\n+  *sinv = sin(x);\n+  *cosv = cos(x);\n+}\n+\n+static void sincosf(float x, float* sinv, float* cosv) {\n+  *sinv = sinf(x);\n+  *cosv = cosf(x);\n+}\n+\n+#endif  // _MSC_VER\n+\n+template <typename R, typename... Args>\n+static llvm::orc::ExecutorSymbolDef SymbolDef(R (*func)(Args...)) {\n+  // We register runtime symbols as weak, because during concurrent compilation\n+  // different threads may race to register their symbols in the same dylib and\n+  // we get spurious \"symbol already defined\" errors.\n+  return llvm::orc::ExecutorSymbolDef{\n+      llvm::orc::ExecutorAddr(reinterpret_cast<uint64_t>(func)),\n+      llvm::JITSymbolFlags::Weak};\n+}\n+\n // Register both the f32 (float) and f64 (double) versions of a libm symbol.\n // Unfortunately the double versions are overloaded on some systems, e.g.\n // Mac so we need an explicit cast. This requires passing the function signature\n // for that case.\n-#define REGISTER_LIBM_SYMBOL(name, double_sig)                                 \\\n-  do {                                                                         \\\n-    registry->Register(#name \"f\", reinterpret_cast<void*>(name##f), \"Host\");   \\\n-    registry->Register(#name,                                                  \\\n-                       reinterpret_cast<void*>(static_cast<double_sig>(name)), \\\n-                       \"Host\");                                                \\\n-  } while (false)\n-\n-static bool RegisterKnownJITSymbols() {\n-  xla::CustomCallTargetRegistry* registry =\n-      xla::CustomCallTargetRegistry::Global();\n-  registry->Register(\"printf\", reinterpret_cast<void*>(&printf), \"Host\");\n-  registry->Register(\"puts\", reinterpret_cast<void*>(&puts), \"Host\");\n-\n-  registry->Register(\"__gnu_f2h_ieee\", reinterpret_cast<void*>(__gnu_f2h_ieee),\n-                     \"Host\");\n-  registry->Register(\"__gnu_h2f_ieee\", reinterpret_cast<void*>(__gnu_h2f_ieee),\n-                     \"Host\");\n-  registry->Register(\"__truncdfhf2\", reinterpret_cast<void*>(__truncdfhf2),\n-                     \"Host\");\n-  registry->Register(\"__truncdfbf2\", reinterpret_cast<void*>(__truncdfbf2),\n-                     \"Host\");\n-  registry->Register(\"__truncsfbf2\", reinterpret_cast<void*>(__truncsfbf2),\n-                     \"Host\");\n+#define REGISTER_LIBM_SYMBOL(name, double_sig) \\\n+  registry[#name \"f\"] = SymbolDef(name##f);    \\\n+  registry[#name] = SymbolDef(static_cast<double_sig>(name));\n \n-#ifdef __APPLE__\n-  registry->Register(\"__truncsfhf2\", reinterpret_cast<void*>(__truncsfhf2),\n-                     \"Host\");\n-  registry->Register(\"__extendhfsf2\", reinterpret_cast<void*>(__extendhfsf2),\n-                     \"Host\");\n-#endif  // __APPLE__\n-  registry->Register(\"__powisf2\", reinterpret_cast<void*>(__powisf2), \"Host\");\n-  registry->Register(\"__powidf2\", reinterpret_cast<void*>(__powidf2), \"Host\");\n+static Registry CreateRegistry() {\n+  Registry registry;\n+\n+  registry[\"memcpy\"] = SymbolDef(memcpy);\n+  registry[\"memmove\"] = SymbolDef(memmove);\n+  registry[\"memset\"] = SymbolDef(memset);\n+\n+  registry[\"__gnu_f2h_ieee\"] = SymbolDef(__gnu_f2h_ieee);\n+  registry[\"__gnu_h2f_ieee\"] = SymbolDef(__gnu_h2f_ieee);\n+\n+  registry[\"__truncdfhf2\"] = SymbolDef(__truncdfhf2);\n+  registry[\"__truncdfbf2\"] = SymbolDef(__truncdfbf2);\n+  registry[\"__truncsfbf2\"] = SymbolDef(__truncsfbf2);\n+\n+  registry[\"__powisf2\"] = SymbolDef(__powisf2);\n+  registry[\"__powidf2\"] = SymbolDef(__powidf2);\n \n   REGISTER_LIBM_SYMBOL(acos, double (*)(double));\n   REGISTER_LIBM_SYMBOL(acosh, double (*)(double));\n@@ -173,15 +183,15 @@ static bool RegisterKnownJITSymbols() {\n   REGISTER_LIBM_SYMBOL(ilogb, int (*)(double));\n   REGISTER_LIBM_SYMBOL(ldexp, double (*)(double, int));\n   REGISTER_LIBM_SYMBOL(lgamma, double (*)(double));\n-  REGISTER_LIBM_SYMBOL(llrint, long long (*)(double));   // NOLINT(runtime/int)\n-  REGISTER_LIBM_SYMBOL(llround, long long (*)(double));  // NOLINT(runtime/int)\n+  REGISTER_LIBM_SYMBOL(llrint, long long (*)(double));   // NOLINT\n+  REGISTER_LIBM_SYMBOL(llround, long long (*)(double));  // NOLINT\n   REGISTER_LIBM_SYMBOL(log, double (*)(double));\n   REGISTER_LIBM_SYMBOL(log10, double (*)(double));\n   REGISTER_LIBM_SYMBOL(log1p, double (*)(double));\n   REGISTER_LIBM_SYMBOL(log2, double (*)(double));\n   REGISTER_LIBM_SYMBOL(logb, double (*)(double));\n-  REGISTER_LIBM_SYMBOL(lrint, long (*)(double));   // NOLINT(runtime/int)\n-  REGISTER_LIBM_SYMBOL(lround, long (*)(double));  // NOLINT(runtime/int)\n+  REGISTER_LIBM_SYMBOL(lrint, long (*)(double));   // NOLINT\n+  REGISTER_LIBM_SYMBOL(lround, long (*)(double));  // NOLINT\n   REGISTER_LIBM_SYMBOL(modf, double (*)(double, double*));\n   REGISTER_LIBM_SYMBOL(nan, double (*)(const char*));\n   REGISTER_LIBM_SYMBOL(nearbyint, double (*)(double));\n@@ -192,56 +202,67 @@ static bool RegisterKnownJITSymbols() {\n   REGISTER_LIBM_SYMBOL(remquo, double (*)(double, double, int*));\n   REGISTER_LIBM_SYMBOL(rint, double (*)(double));\n   REGISTER_LIBM_SYMBOL(round, double (*)(double));\n-  REGISTER_LIBM_SYMBOL(scalbln,\n-                       double (*)(double, long));  // NOLINT(runtime/int)\n+  REGISTER_LIBM_SYMBOL(scalbln, double (*)(double, long));  // NOLINT\n   REGISTER_LIBM_SYMBOL(scalbn, double (*)(double, int));\n   REGISTER_LIBM_SYMBOL(sin, double (*)(double));\n-#ifdef __APPLE__\n-  REGISTER_LIBM_SYMBOL(__sincos, void (*)(double, double*, double*));\n-  registry->Register(\"__sincosf_stret\",\n-                     reinterpret_cast<void*>(__sincosf_stret), \"Host\");\n-  registry->Register(\"__sincos_stret\", reinterpret_cast<void*>(__sincos_stret),\n-                     \"Host\");\n-#else\n-  REGISTER_LIBM_SYMBOL(sincos, void (*)(double, double*, double*));\n-#endif\n   REGISTER_LIBM_SYMBOL(sinh, double (*)(double));\n   REGISTER_LIBM_SYMBOL(sqrt, double (*)(double));\n   REGISTER_LIBM_SYMBOL(tan, double (*)(double));\n   REGISTER_LIBM_SYMBOL(tanh, double (*)(double));\n   REGISTER_LIBM_SYMBOL(tgamma, double (*)(double));\n   REGISTER_LIBM_SYMBOL(trunc, double (*)(double));\n \n-  registry->Register(\"memcpy\", reinterpret_cast<void*>(memcpy), \"Host\");\n-  registry->Register(\"memmove\", reinterpret_cast<void*>(memmove), \"Host\");\n-  registry->Register(\"memset\", reinterpret_cast<void*>(memset), \"Host\");\n+#ifdef __APPLE__\n+  REGISTER_LIBM_SYMBOL(__sincos, void (*)(double, double*, double*));\n+  registry[\"__sincosf_stret\"] = SymbolDef(__sincosf_stret);\n+  registry[\"__sincos_stret\"] = SymbolDef(__sincos_stret);\n+#else\n+  REGISTER_LIBM_SYMBOL(sincos, void (*)(double, double*, double*));\n+#endif\n \n-  // Used by MLIR lowering.\n-  registry->Register(\"malloc\", reinterpret_cast<void*>(malloc), \"Host\");\n-  registry->Register(\"calloc\", reinterpret_cast<void*>(calloc), \"Host\");\n-  registry->Register(\"free\", reinterpret_cast<void*>(free), \"Host\");\n+#undef REGISTER_LIBM_SYMBOL\n \n #ifdef __APPLE__\n-  registry->Register(\"__bzero\", reinterpret_cast<void*>(bzero), \"Host\");\n-  registry->Register(\"bzero\", reinterpret_cast<void*>(bzero), \"Host\");\n-  registry->Register(\"memset_pattern16\",\n-                     reinterpret_cast<void*>(memset_pattern16), \"Host\");\n+  registry[\"__truncsfhf2\"] = SymbolDef(__truncsfhf2);\n+  registry[\"__extendhfsf2\"] = SymbolDef(__extendhfsf2);\n+  registry[\"__bzero\"] = SymbolDef(bzero);\n+  registry[\"bzero\"] = SymbolDef(bzero);\n+  registry[\"memset_pattern16\"] = SymbolDef(memset_pattern16);\n #endif\n \n-#ifdef MEMORY_SANITIZER\n-  registry->Register(\"__msan_unpoison\",\n-                     reinterpret_cast<void*>(__msan_unpoison), \"Host\");\n+#if defined(PLATFORM_WINDOWS)\n+  registry[\"__chkstk\"] = SymbolDef(__chkstk);\n #endif\n \n-#if defined(PLATFORM_WINDOWS)\n-  registry->Register(\"__chkstk\", reinterpret_cast<void*>(__chkstk), \"Host\");\n+#ifdef MEMORY_SANITIZER\n+  registry[\"__msan_unpoison\"] = SymbolDef(__msan_unpoison);\n #endif\n \n-  return true;\n+  return registry;\n }\n \n-#undef REGISTER_LIBM_SYMBOL\n+//===----------------------------------------------------------------------===//\n+// RuntimeSymbolGenerator\n+//===----------------------------------------------------------------------===//\n+\n+RuntimeSymbolGenerator::RuntimeSymbolGenerator(llvm::DataLayout data_layout)\n+    : data_layout_(std::move(data_layout)) {}\n+\n+llvm::Error RuntimeSymbolGenerator::tryToGenerate(\n+    llvm::orc::LookupState&, llvm::orc::LookupKind kind,\n+    llvm::orc::JITDylib& jit_dylib, llvm::orc::JITDylibLookupFlags,\n+    const llvm::orc::SymbolLookupSet& names) {\n+  llvm::orc::SymbolMap symbols;\n+  symbols.reserve(names.size());\n+\n+  for (const auto& [name, flags] : names) {\n+    if (auto symbol = ResolveBuiltinSymbol(data_layout_, *name)) {\n+      symbols[name] = *symbol;\n+    }\n+  }\n \n-static bool unused = RegisterKnownJITSymbols();\n+  cantFail(jit_dylib.define(llvm::orc::absoluteSymbols(std::move(symbols))));\n+  return llvm::Error::success();\n+}\n \n }  // namespace xla::cpu"
        },
        {
            "sha": "5959f65d0af28ebcb6fd22d271d6163dd3f0ed75",
            "filename": "third_party/xla/xla/service/cpu/runtime_symbol_generator.h",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c4019fdf9d48a801df4b8218d661ea4461b52cae/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_symbol_generator.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c4019fdf9d48a801df4b8218d661ea4461b52cae/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_symbol_generator.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fruntime_symbol_generator.h?ref=c4019fdf9d48a801df4b8218d661ea4461b52cae",
            "patch": "@@ -16,11 +16,7 @@ limitations under the License.\n #ifndef XLA_SERVICE_CPU_RUNTIME_SYMBOL_GENERATOR_H_\n #define XLA_SERVICE_CPU_RUNTIME_SYMBOL_GENERATOR_H_\n \n-#include <optional>\n-\n-#include \"llvm/ADT/StringRef.h\"\n #include \"llvm/ExecutionEngine/Orc/Core.h\"\n-#include \"llvm/ExecutionEngine/Orc/Shared/ExecutorSymbolDef.h\"\n #include \"llvm/IR/DataLayout.h\"\n #include \"llvm/Support/Error.h\"\n \n@@ -38,9 +34,6 @@ class RuntimeSymbolGenerator : public llvm::orc::DefinitionGenerator {\n                             const llvm::orc::SymbolLookupSet& names) final;\n \n  private:\n-  std::optional<llvm::orc::ExecutorSymbolDef> ResolveRuntimeSymbol(\n-      llvm::StringRef name);\n-\n   llvm::DataLayout data_layout_;\n };\n "
        },
        {
            "sha": "f6da04d750f7e0fb51c26880d8666a4e7890cc3d",
            "filename": "third_party/xla/xla/service/cpu/windows_compatibility.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/18161a0cb25a84e08ba105797760c46eda285729/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fwindows_compatibility.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/18161a0cb25a84e08ba105797760c46eda285729/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fwindows_compatibility.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fwindows_compatibility.cc?ref=18161a0cb25a84e08ba105797760c46eda285729",
            "patch": "@@ -1,32 +0,0 @@\n-/* Copyright 2017 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/service/cpu/windows_compatibility.h\"\n-\n-#ifdef _MSC_VER\n-\n-#include <math.h>\n-\n-void sincos(double x, double *sinv, double *cosv) {\n-  *sinv = sin(x);\n-  *cosv = cos(x);\n-}\n-\n-void sincosf(float x, float *sinv, float *cosv) {\n-  *sinv = sinf(x);\n-  *cosv = cosf(x);\n-}\n-\n-#endif  // _MSC_VER"
        },
        {
            "sha": "4e10087e5fa74d944dc199ec5bfef56ac348c319",
            "filename": "third_party/xla/xla/service/cpu/windows_compatibility.h",
            "status": "removed",
            "additions": 0,
            "deletions": 31,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/18161a0cb25a84e08ba105797760c46eda285729/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fwindows_compatibility.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/18161a0cb25a84e08ba105797760c46eda285729/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fwindows_compatibility.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fwindows_compatibility.h?ref=18161a0cb25a84e08ba105797760c46eda285729",
            "patch": "@@ -1,31 +0,0 @@\n-/* Copyright 2017 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef XLA_SERVICE_CPU_WINDOWS_COMPATIBILITY_H_\n-#define XLA_SERVICE_CPU_WINDOWS_COMPATIBILITY_H_\n-\n-#ifdef _MSC_VER\n-\n-extern \"C\" {\n-\n-// MSVC does not have sincos[f].\n-void sincos(double x, double *sinv, double *cosv);\n-void sincosf(float x, float *sinv, float *cosv);\n-\n-}\n-\n-#endif  // _MSC_VER\n-\n-#endif  // XLA_SERVICE_CPU_WINDOWS_COMPATIBILITY_H_"
        }
    ],
    "stats": {
        "total": 317,
        "additions": 124,
        "deletions": 193
    }
}