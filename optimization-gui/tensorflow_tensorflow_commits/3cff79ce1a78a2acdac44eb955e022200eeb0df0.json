{
    "author": "ezhulenev",
    "message": "[xla] Add PjRtFuture<>::MakePromise() to create a pair of connected promise+future\n\nWe want to make promise move-only and guarantee that exactly one future is constructed for a given promise. This is a first step in that direction.\n\nPiperOrigin-RevId: 802805444",
    "sha": "3cff79ce1a78a2acdac44eb955e022200eeb0df0",
    "files": [
        {
            "sha": "35b061f0569d041e5fcf534719c210ceba5ddd40",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 25,
            "deletions": 16,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3cff79ce1a78a2acdac44eb955e022200eeb0df0/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3cff79ce1a78a2acdac44eb955e022200eeb0df0/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=3cff79ce1a78a2acdac44eb955e022200eeb0df0",
            "patch": "@@ -233,16 +233,16 @@ class PjRtFutureBase : public PjRtFutureMoveControl<is_move_only> {\n       promise_.template emplace<Args...>(std::forward<Args>(args)...);\n     }\n \n-    // Releases the underlying AsyncValueRef container to the caller.\n-    tsl::AsyncValueRef<T> release() { return std::move(promise_); }\n+    // Takes a reference to the underlying AsyncValueRef container.\n+    tsl::AsyncValueRef<T> ref() const { return promise_; }\n \n     // Returns a pointer to the underlying AsyncValue that can be used to\n     // track completion of a promise. It is undefined behavior to access the\n     // value stored in the AsyncValue.\n     tsl::AsyncValue* async_value() const { return promise_.GetAsyncValue(); }\n \n #ifndef NDEBUG\n-    int64_t AddFuture() { return num_futures_->fetch_add(1); }\n+    int64_t AddFuture() const { return num_futures_->fetch_add(1); }\n #endif\n \n    private:\n@@ -458,10 +458,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n   // - on_block_start is called before Await starts to block.\n   //  - on_block_end is called after Await finishes blocking.\n   explicit PjRtFuture(\n-      Promise promise,\n+      const Promise& promise,\n       PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n       PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr)\n-      : Base(promise.release(), std::move(on_block_start),\n+      : Base(promise.ref(), std::move(on_block_start),\n              std::move(on_block_end)) {\n #ifndef NDEBUG\n     if constexpr (is_move_only) {\n@@ -689,6 +689,14 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n     return Promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n   }\n \n+  // Returns a pair of connected Promise and PjRtFuture<>. Setting the returned\n+  // promise will fulfill the connected future.\n+  static std::pair<Promise, PjRtFuture<>> MakePromise() {\n+    auto promise = CreatePromise();\n+    auto future = PjRtFuture<void>(promise);\n+    return std::make_pair(std::move(promise), std::move(future));\n+  }\n+\n   // Bring PjRtFutureBase constructors in scope.\n   using Base::Base;\n \n@@ -698,10 +706,10 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   // - on_block_start is called before Await starts to block.\n   // - on_block_end is called after Await finishes blocking.\n   explicit PjRtFuture(\n-      Promise promise,\n+      const Promise& promise,\n       PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n       PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr)\n-      : Base(promise.release(), std::move(on_block_start),\n+      : Base(promise.ref(), std::move(on_block_start),\n              std::move(on_block_end)) {}\n \n   // Constructor for a future that is immediately ready with a given status.\n@@ -822,15 +830,16 @@ namespace internal {\n \n template <typename T, bool is_move_only>\n PjRtFuture<> PjRtFutureBase<T, is_move_only>::GetReadyFuture() const& {\n-  PjRtFuture<>::Promise promise = PjRtFuture<>::CreatePromise();\n-  promise_.AndThen([p = promise_.AsPtr(), promise]() mutable {\n-    if constexpr (std::is_same_v<T, absl::Status>) {\n-      promise.Set(*p);\n-    } else {\n-      promise.Set(p->status());\n-    }\n-  });\n-  return PjRtFuture<>(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n+  promise_.AndThen(\n+      [self = promise_.AsPtr(), promise = std::move(promise)]() mutable {\n+        if constexpr (std::is_same_v<T, absl::Status>) {\n+          promise.Set(*self);\n+        } else {\n+          promise.Set(self->status());\n+        }\n+      });\n+  return future;\n }\n \n template <typename T, bool is_move_only>"
        },
        {
            "sha": "c8be4c8fa347c2b725917ffc8f13b894a4c6188e",
            "filename": "third_party/xla/xla/pjrt/pjrt_future_test.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 28,
            "changes": 45,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3cff79ce1a78a2acdac44eb955e022200eeb0df0/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3cff79ce1a78a2acdac44eb955e022200eeb0df0/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc?ref=3cff79ce1a78a2acdac44eb955e022200eeb0df0",
            "patch": "@@ -40,8 +40,7 @@ TEST(PjRtFutureTest, ValueConstructedFuture) {\n }\n \n TEST(PjRtFutureTest, StatelessFuture) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set();\n@@ -352,8 +351,7 @@ TEST(PjRtFutureTest, TryMapMoveOnlyFutureCreateError) {\n }\n \n TEST(PjRtFutureTest, StatelessError) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(absl::InternalError(\"test\"));\n@@ -386,8 +384,7 @@ TEST(PjRtFutureTest, StatelessImmediate) {\n }\n \n TEST(PjRtFutureTest, MapStatelessFuture) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   PjRtFuture<float> mapped = future.Map([]() { return 42.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n@@ -402,8 +399,7 @@ TEST(PjRtFutureTest, MapStatelessFuture) {\n }\n \n TEST(PjRtFutureTest, MapStatelessFutureError) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   PjRtFuture<float> mapped = future.Map([]() { return 42.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n@@ -418,8 +414,7 @@ TEST(PjRtFutureTest, MapStatelessFutureError) {\n }\n \n TEST(PjRtFutureTest, TryMapStatelessFuture) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   PjRtFuture<float> mapped =\n       future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n \n@@ -435,8 +430,7 @@ TEST(PjRtFutureTest, TryMapStatelessFuture) {\n }\n \n TEST(PjRtFutureTest, TryMapStatelessFutureForwardError) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   PjRtFuture<float> mapped =\n       future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n \n@@ -446,8 +440,7 @@ TEST(PjRtFutureTest, TryMapStatelessFutureForwardError) {\n }\n \n TEST(PjRtFutureTest, TryMapStatelessFutureCreateError) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   PjRtFuture<float> mapped = future.TryMap(\n       []() -> absl::StatusOr<float> { return absl::InternalError(\"test\"); });\n \n@@ -457,8 +450,7 @@ TEST(PjRtFutureTest, TryMapStatelessFutureCreateError) {\n }\n \n TEST(PjRtFutureTest, MapToStatelessFuture) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   PjRtFuture<float> mapped = future.MapTo(42.0f);\n \n   EXPECT_FALSE(future.IsReady());\n@@ -484,8 +476,7 @@ TEST(PjRtFutureTest, StatefulFuture) {\n }\n \n TEST(PjRtFutureTest, StatusFuture) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n-  PjRtFuture<> future(promise);\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(absl::OkStatus());\n@@ -511,12 +502,11 @@ TEST(PjRtFutureTest, JoinFutures) {\n   EXPECT_TRUE(empty_join.IsReady());\n   EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n \n-  auto promise0 = PjRtFuture<>::CreatePromise();\n-  auto promise1 = PjRtFuture<>::CreatePromise();\n+  auto [promise0, future0] = PjRtFuture<>::MakePromise();\n+  auto [promise1, future1] = PjRtFuture<>::MakePromise();\n \n-  std::vector<PjRtFuture<>> futures0 = {PjRtFuture<>(promise0)};\n-  std::vector<PjRtFuture<>> futures1 = {PjRtFuture<>(promise0),\n-                                        PjRtFuture<>(promise1)};\n+  std::vector<PjRtFuture<>> futures0 = {future0};\n+  std::vector<PjRtFuture<>> futures1 = {future0, future1};\n \n   auto join_one = JoinFutures(futures0);\n   EXPECT_FALSE(join_one.IsReady());\n@@ -539,12 +529,11 @@ TEST(PjRtFutureTest, JoinErrors) {\n   EXPECT_TRUE(empty_join.IsReady());\n   EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n \n-  auto promise0 = PjRtFuture<>::CreatePromise();\n-  auto promise1 = PjRtFuture<>::CreatePromise();\n+  auto [promise0, future0] = PjRtFuture<>::MakePromise();\n+  auto [promise1, future1] = PjRtFuture<>::MakePromise();\n \n-  std::vector<PjRtFuture<>> futures0 = {PjRtFuture<>(promise0)};\n-  std::vector<PjRtFuture<>> futures1 = {PjRtFuture<>(promise0),\n-                                        PjRtFuture<>(promise1)};\n+  std::vector<PjRtFuture<>> futures0 = {future0};\n+  std::vector<PjRtFuture<>> futures1 = {future0, future1};\n \n   auto join_one = JoinFutures(futures0);\n   EXPECT_FALSE(join_one.IsReady());"
        }
    ],
    "stats": {
        "total": 86,
        "additions": 42,
        "deletions": 44
    }
}