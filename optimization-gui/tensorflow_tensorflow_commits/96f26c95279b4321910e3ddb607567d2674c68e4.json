{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 848170320",
    "sha": "96f26c95279b4321910e3ddb607567d2674c68e4",
    "files": [
        {
            "sha": "1d897c4b67e512126498d0d654ea96de5e22cdd7",
            "filename": "tensorflow/python/lib/core/ndarray_tensor.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fndarray_tensor.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fndarray_tensor.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Flib%2Fcore%2Fndarray_tensor.cc?ref=96f26c95279b4321910e3ddb607567d2674c68e4",
            "patch": "@@ -100,7 +100,7 @@ absl::Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n     if (!key_string) {\n       return errors::Internal(\"Corrupt numpy type descriptor\");\n     }\n-    tensorflow::string key = key_string;\n+    std::string key = key_string;\n     // The typenames here should match the field names in the custom struct\n     // types constructed in test_util.py.\n     // TODO(mrry,keveman): Investigate Numpy type registration to replace this\n@@ -320,7 +320,8 @@ absl::Status EncodePyBytesArray(PyArrayObject* array, int64_t nelems,\n   return absl::OkStatus();\n }\n \n-absl::Status CopyTF_TensorStringsToPyArray(const TF_Tensor* src, uint64 nelems,\n+absl::Status CopyTF_TensorStringsToPyArray(const TF_Tensor* src,\n+                                           uint64_t nelems,\n                                            PyArrayObject* dst) {\n   const void* tensor_data = TF_TensorData(src);\n   DCHECK(tensor_data != nullptr);"
        },
        {
            "sha": "fbb1f10c855b15701ba4e9437d08516144d9b688",
            "filename": "tensorflow/python/lib/core/ndarray_tensor_bridge.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fndarray_tensor_bridge.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fndarray_tensor_bridge.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Flib%2Fcore%2Fndarray_tensor_bridge.cc?ref=96f26c95279b4321910e3ddb607567d2674c68e4",
            "patch": "@@ -253,10 +253,10 @@ absl::Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data,\n   auto* np_array = reinterpret_cast<PyArrayObject*>(\n       PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n   if (np_array == nullptr) {\n-    string shape_str = absl::StrJoin(\n+    std::string shape_str = absl::StrJoin(\n         absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n     if (PyErr_Occurred()) {\n-      string exception_str = PyExceptionFetch();\n+      std::string exception_str = PyExceptionFetch();\n       PyErr_Clear();\n       return errors::InvalidArgument(\n           \"Failed to create numpy array from tensor of shape [\", shape_str,"
        },
        {
            "sha": "54178667bfddaaca8e9468dbf9e1ab9f9594498b",
            "filename": "tensorflow/python/lib/core/py_func.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_func.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_func.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_func.cc?ref=96f26c95279b4321910e3ddb607567d2674c68e4",
            "patch": "@@ -63,7 +63,7 @@ PyObject* GetPyTrampoline() {\n struct PyCall {\n   // Passed to python runtime to call the python function registered\n   // with this \"token\".\n-  string token;\n+  std::string token;\n \n   // The device on which Tensors are stored; only used for EagerPyFunc.\n   Device* device = nullptr;\n@@ -164,7 +164,8 @@ absl::Status ExtractTensorFromEagerTensor(const PyObject* eager_tensor,\n   TF_RETURN_IF_ERROR(handle->Tensor(output_tensor));\n   // actual_device may be nullptr, which implies local CPU.\n   if (expected_device == actual_device) return absl::OkStatus();\n-  const string& expected_device_name = expected_device->attributes().name();\n+  const std::string& expected_device_name =\n+      expected_device->attributes().name();\n   if (actual_device == nullptr) {\n     if (!IsCPUDevice(expected_device)) {\n       return errors::Internal(\n@@ -380,7 +381,8 @@ class PyFuncOp : public OpKernel {\n       return;\n     }\n \n-    OP_REQUIRES(ctx, static_cast<int32>(call.out.size()) == ctx->num_outputs(),\n+    OP_REQUIRES(ctx,\n+                static_cast<int32_t>(call.out.size()) == ctx->num_outputs(),\n                 errors::InvalidArgument(token_, \" returns \", call.out.size(),\n                                         \" values, but expects to see \",\n                                         ctx->num_outputs(), \" values.\"));\n@@ -396,7 +398,7 @@ class PyFuncOp : public OpKernel {\n   }\n \n  private:\n-  string token_;\n+  std::string token_;\n \n   // True if and only if this op should execute the python function eagerly,\n   // i.e., if and only if the eager attribute is set."
        },
        {
            "sha": "6b2b6be8cf53e7e4069e059934f936d81551053c",
            "filename": "tensorflow/python/lib/core/py_seq_tensor.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_seq_tensor.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_seq_tensor.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_seq_tensor.cc?ref=96f26c95279b4321910e3ddb607567d2674c68e4",
            "patch": "@@ -360,8 +360,9 @@ struct ConverterTraits<int64_t> {\n typedef Converter<int64_t> Int64Converter;\n \n template <>\n-struct ConverterTraits<uint64> {\n-  static AbstractTensorInterface* CreateScalar(TFE_Context* ctx, uint64 value) {\n+struct ConverterTraits<uint64_t> {\n+  static AbstractTensorInterface* CreateScalar(TFE_Context* ctx,\n+                                               uint64_t value) {\n     return tensorflow::unwrap(ctx)->CreateUint64Scalar(value);\n   }\n \n@@ -370,7 +371,7 @@ struct ConverterTraits<uint64> {\n     return tensorflow::unwrap(ctx)->CreateTensor(DT_UINT64, dim_sizes);\n   }\n \n-  static const char* ConvertScalar(PyObject* v, uint64* out) {\n+  static const char* ConvertScalar(PyObject* v, uint64_t* out) {\n #if PY_MAJOR_VERSION < 3\n     if (TF_PREDICT_TRUE(PyInt_Check(v))) {\n       *out = PyInt_AsUnsignedLongLongMask(v);\n@@ -394,10 +395,10 @@ struct ConverterTraits<uint64> {\n   }\n };\n \n-typedef Converter<uint64> UInt64Converter;\n+typedef Converter<uint64_t> UInt64Converter;\n \n template <>\n-struct ConverterTraits<int32> {\n+struct ConverterTraits<int32_t> {\n   static AbstractTensorInterface* CreateScalar(TFE_Context* ctx,\n                                                int32_t value) {\n     return tensorflow::unwrap(ctx)->CreateInt32Scalar(value);\n@@ -408,7 +409,7 @@ struct ConverterTraits<int32> {\n     return tensorflow::unwrap(ctx)->CreateTensor(DT_INT32, dim_sizes);\n   }\n \n-  static const char* ConvertScalar(PyObject* v, int32* out) {\n+  static const char* ConvertScalar(PyObject* v, int32_t* out) {\n     int64_t i;\n #if PY_MAJOR_VERSION < 3\n     if (TF_PREDICT_TRUE(PyInt_Check(v))) {\n@@ -432,14 +433,14 @@ struct ConverterTraits<int32> {\n     } else {\n       return ErrorMixedTypes;\n     }\n-    *out = static_cast<uint32>(static_cast<uint64>(i));\n+    *out = static_cast<uint32_t>(static_cast<uint64_t>(i));\n     // Check for 32-bit overflow.\n     if (TF_PREDICT_FALSE(i != *out)) return ErrorFoundInt64;\n     return nullptr;\n   }\n };\n \n-typedef Converter<int32> Int32Converter;\n+typedef Converter<int32_t> Int32Converter;\n \n // Floating-point support\n \n@@ -694,11 +695,11 @@ TFE_TensorHandle* NumpyToTFE_TensorHandle(TFE_Context* ctx, PyObject* obj) {\n   absl::Status status = tensorflow::NdarrayToTensor(ctx, obj, &tf_tensor);\n \n   if (TF_PREDICT_FALSE(!status.ok())) {\n-    PyErr_SetString(PyExc_ValueError,\n-                    tensorflow::strings::StrCat(\n-                        \"Failed to convert a NumPy array to a Tensor (\",\n-                        status.message(), \").\")\n-                        .c_str());\n+    PyErr_SetString(\n+        PyExc_ValueError,\n+        absl::StrCat(\"Failed to convert a NumPy array to a Tensor (\",\n+                     status.message(), \").\")\n+            .c_str());\n     return nullptr;\n   }\n \n@@ -758,8 +759,7 @@ TFE_TensorHandle* PySeqToTFE_TensorHandle(TFE_Context* ctx, PyObject* obj,\n                .ok()) {\n         PyErr_SetString(\n             PyExc_TypeError,\n-            tensorflow::strings::StrCat(\"Invalid dtype argument value \", dtype)\n-                .c_str());\n+            absl::StrCat(\"Invalid dtype argument value \", dtype).c_str());\n         return nullptr;\n       }\n     }"
        },
        {
            "sha": "fa1845bd7828415b25b2585f38a1c0f1d44b43b0",
            "filename": "tensorflow/python/lib/core/py_util.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_util.cc?ref=96f26c95279b4321910e3ddb607567d2674c68e4",
            "patch": "@@ -45,7 +45,7 @@ const char* ClassName(PyObject* py) {\n \n // Returns a PyObject containing a string, or null\n void TryAppendTraceback(PyObject* ptype, PyObject* pvalue, PyObject* ptraceback,\n-                        string* out) {\n+                        std::string* out) {\n   // The \"traceback\" module is assumed to be imported already by script_ops.py.\n   PyObject* tb_module = PyImport_AddModule(\"traceback\");\n \n@@ -84,35 +84,35 @@ void TryAppendTraceback(PyObject* ptype, PyObject* pvalue, PyObject* ptraceback,\n #if PY_MAJOR_VERSION < 3\n     strings::StrAppend(out, PyString_AS_STRING(v), \"\\n\");\n #else\n-    strings::StrAppend(out, PyUnicode_AsUTF8(v), \"\\n\");\n+    absl::StrAppend(out, PyUnicode_AsUTF8(v), \"\\n\");\n #endif\n   }\n \n   // Iterate through ret_val.\n   Py_DECREF(ret_val);\n }\n \n-string PyExceptionFetch() {\n+std::string PyExceptionFetch() {\n   CHECK(PyErr_Occurred())\n       << \"Must only call PyExceptionFetch after an exception.\";\n   PyObject* ptype;\n   PyObject* pvalue;\n   PyObject* ptraceback;\n   PyErr_Fetch(&ptype, &pvalue, &ptraceback);\n   PyErr_NormalizeException(&ptype, &pvalue, &ptraceback);\n-  string err = ClassName(ptype);\n+  std::string err = ClassName(ptype);\n   if (pvalue) {\n     PyObject* str = PyObject_Str(pvalue);\n \n     if (str) {\n #if PY_MAJOR_VERSION < 3\n       strings::StrAppend(&err, \": \", PyString_AS_STRING(str), \"\\n\");\n #else\n-      strings::StrAppend(&err, \": \", PyUnicode_AsUTF8(str), \"\\n\");\n+      absl::StrAppend(&err, \": \", PyUnicode_AsUTF8(str), \"\\n\");\n #endif\n       Py_DECREF(str);\n     } else {\n-      strings::StrAppend(&err, \"(unknown error message)\\n\");\n+      absl::StrAppend(&err, \"(unknown error message)\\n\");\n     }\n \n     TryAppendTraceback(ptype, pvalue, ptraceback, &err);"
        },
        {
            "sha": "d6b2b9f78ddca6ab513566bcb38e4763e61b8cad",
            "filename": "tensorflow/python/lib/core/py_util.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/96f26c95279b4321910e3ddb607567d2674c68e4/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Flib%2Fcore%2Fpy_util.h?ref=96f26c95279b4321910e3ddb607567d2674c68e4",
            "patch": "@@ -25,7 +25,7 @@ namespace tensorflow {\n \n // Fetch the exception message as a string. An exception must be set\n // (PyErr_Occurred() must be true).\n-string PyExceptionFetch();\n+std::string PyExceptionFetch();\n \n // Assert that Python GIL is held.\n inline void DCheckPyGilState() {"
        }
    ],
    "stats": {
        "total": 63,
        "additions": 33,
        "deletions": 30
    }
}