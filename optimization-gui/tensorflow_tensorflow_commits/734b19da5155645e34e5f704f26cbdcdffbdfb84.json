{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809678720",
    "sha": "734b19da5155645e34e5f704f26cbdcdffbdfb84",
    "files": [
        {
            "sha": "764573967081af13d6247b92bbb38d5020efc99e",
            "filename": "third_party/xla/xla/service/cpu/orc_jit_memory_mapper.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/734b19da5155645e34e5f704f26cbdcdffbdfb84/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Forc_jit_memory_mapper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/734b19da5155645e34e5f704f26cbdcdffbdfb84/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Forc_jit_memory_mapper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Forc_jit_memory_mapper.cc?ref=734b19da5155645e34e5f704f26cbdcdffbdfb84",
            "patch": "@@ -48,7 +48,7 @@ llvm::SectionMemoryManager::MemoryMapper* GetInstance(\n       return nullptr;\n     }\n   }\n-  absl::MutexLock lock(&mapper_instances_mutex);\n+  absl::MutexLock lock(mapper_instances_mutex);\n   auto it = mapper_instances->find(allocation_region_name);\n   if (it == mapper_instances->end()) {\n     it = mapper_instances\n@@ -68,7 +68,7 @@ Registrar::Registrar(Registrar::MemoryMapperGetter* mapper_getter) {\n       std::memory_order_acquire));\n \n   {\n-    absl::MutexLock lock(&mapper_instances_mutex);\n+    absl::MutexLock lock(mapper_instances_mutex);\n     if (mapper_instances == nullptr) {\n       mapper_instances =\n           new absl::flat_hash_map<std::string,"
        },
        {
            "sha": "53ef4af9d41f55a6a92649a0a0d5bc5203bc8869",
            "filename": "third_party/xla/xla/service/cpu/parallel_fusion_emitter.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/734b19da5155645e34e5f704f26cbdcdffbdfb84/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/734b19da5155645e34e5f704f26cbdcdffbdfb84/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter.cc?ref=734b19da5155645e34e5f704f26cbdcdffbdfb84",
            "patch": "@@ -80,7 +80,7 @@ class ParallelFusionEmitter::FusionCompilerPool {\n ParallelFusionEmitter::FusionCompilerPool::~FusionCompilerPool() {\n   // We must wait for all instances to be returned to the pool before\n   // destroying it.\n-  absl::MutexLock lock(&instances_mutex_);\n+  absl::MutexLock lock(instances_mutex_);\n   instances_mutex_.Await(absl::Condition(\n       +[](int64_t* outstanding_instances) {\n         return *outstanding_instances == 0;\n@@ -90,7 +90,7 @@ ParallelFusionEmitter::FusionCompilerPool::~FusionCompilerPool() {\n \n auto ParallelFusionEmitter::FusionCompilerPool::GetInstance()\n     -> std::shared_ptr<CompilerInstance> {\n-  absl::MutexLock lock(&instances_mutex_);\n+  absl::MutexLock lock(instances_mutex_);\n   if (!instances_.empty()) {\n     CompilerInstance instance = std::move(instances_.top());\n     instances_.pop();\n@@ -115,7 +115,7 @@ auto ParallelFusionEmitter::FusionCompilerPool::CreateSharedInstance(\n \n void ParallelFusionEmitter::FusionCompilerPool::RecycleCompilerInstance(\n     CompilerInstance* instance) {\n-  absl::MutexLock lock(&instances_mutex_);\n+  absl::MutexLock lock(instances_mutex_);\n   outstanding_instances_--;\n   instances_.push(std::move(*instance));\n   delete instance;\n@@ -163,7 +163,7 @@ absl::StatusOr<KernelSpec> ParallelFusionEmitter::AddFusion(\n                                        buffer_assignment_, use_unique_c_name_));\n \n   {\n-    absl::MutexLock lock(&kernels_mutex_);\n+    absl::MutexLock lock(kernels_mutex_);\n     outstanding_kernels_++;\n   }\n \n@@ -180,7 +180,7 @@ absl::StatusOr<KernelSpec> ParallelFusionEmitter::AddFusion(\n \n absl::StatusOr<std::vector<LlvmKernelDefinition>>\n ParallelFusionEmitter::ConsumeKernels() {\n-  absl::MutexLock lock(&kernels_mutex_);\n+  absl::MutexLock lock(kernels_mutex_);\n \n   kernels_mutex_.Await(absl::Condition(\n       +[](int64_t* outstanding_kernels) { return *outstanding_kernels == 0; },\n@@ -206,7 +206,7 @@ void ParallelFusionEmitter::CompileFusion(\n   absl::StatusOr<LlvmIrKernelSource> llvm_kernel_source =\n       compiler_instance->compiler->Compile(std::move(source));\n \n-  absl::MutexLock lock(&kernels_mutex_);\n+  absl::MutexLock lock(kernels_mutex_);\n   outstanding_kernels_--;\n \n   if (!llvm_kernel_source.ok()) {"
        }
    ],
    "stats": {
        "total": 16,
        "additions": 8,
        "deletions": 8
    }
}