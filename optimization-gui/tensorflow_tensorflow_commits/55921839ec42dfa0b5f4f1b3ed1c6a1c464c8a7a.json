{
    "author": "hyeontaek",
    "message": "[IFRT] Add primitives for `UserContext` annotation and composition\n\nThis change adds 3 primitives that express additional information to a\n`UserContext` or the relationship between `UserContext`s.\n\n* `AnnotatedUserContext` adds a simple message to a `UserContext` to convey additional information that was not known at creation time of the `UserContext`.\n\n* `ChainedUserContext` expresses the propagation path of an error that goes\nthrough multiple operations that are identified by their own user contexts.\n\n* `FusedUserContext` represents a set of `UserContext`s for the operations that\nare indistinguishable from error reporting purposes (e.g., an error status is\naggregated over a batch of operations).\n\nPiperOrigin-RevId: 807440819",
    "sha": "55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a",
    "files": [
        {
            "sha": "856aa6cb7712dc0af1f6105707fb318a6385009c",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a",
            "patch": "@@ -1110,11 +1110,17 @@ cc_library(\n     deps = [\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/lib/gtl:int_type\",\n+        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/base:no_destructor\",\n         \"@com_google_absl//absl/base:nullability\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n+        \"@local_tsl//tsl/platform:fingerprint\",\n+        \"@local_tsl//tsl/platform:random\",\n     ],\n )\n \n@@ -1125,6 +1131,7 @@ xla_cc_test(\n         \":user_context\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/platform:env\",\n+        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/time\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@llvm-project//llvm:Support\","
        },
        {
            "sha": "eb516c127d2a8c0b95b5ad261d1412b8b0d049a6",
            "filename": "third_party/xla/xla/python/ifrt/user_context.cc",
            "status": "modified",
            "additions": 119,
            "deletions": 1,
            "changes": 120,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.cc?ref=55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a",
            "patch": "@@ -15,17 +15,31 @@ limitations under the License.\n \n #include \"xla/python/ifrt/user_context.h\"\n \n+#include <cstdint>\n+#include <string>\n #include <utility>\n+#include <vector>\n \n+#include \"absl/algorithm/container.h\"\n #include \"absl/base/attributes.h\"\n #include \"absl/base/no_destructor.h\"\n #include \"absl/base/nullability.h\"\n #include \"absl/log/check.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+#include \"tsl/platform/fingerprint.h\"\n+#include \"tsl/platform/random.h\"\n \n namespace xla {\n namespace ifrt {\n \n-char UserContext::ID = 0;  // For llvm::RTTI\n+// For llvm::RTTI\n+[[maybe_unused]] char UserContext::ID = 0;\n+[[maybe_unused]] char AnnotatedUserContext::ID = 0;\n+[[maybe_unused]] char ChainedUserContext::ID = 0;\n+[[maybe_unused]] char FusedUserContext::ID = 0;\n \n namespace {\n \n@@ -36,6 +50,110 @@ ABSL_CONST_INIT thread_local\n \n }  // namespace\n \n+absl_nonnull UserContextRef\n+AnnotatedUserContext::Create(UserContextRef user_context, std::string msg) {\n+  return tsl::MakeRef<AnnotatedUserContext>(std::move(user_context),\n+                                            std::move(msg));\n+}\n+\n+AnnotatedUserContext::AnnotatedUserContext(UserContextRef user_context,\n+                                           std::string msg)\n+    : id_(tsl::random::ThreadLocalNew64()),\n+      user_context_(std::move(user_context)),\n+      msg_(std::move(msg)) {}\n+\n+uint64_t AnnotatedUserContext::Fingerprint() const {\n+  if (user_context_ != nullptr) {\n+    return tsl::FingerprintCat64(user_context_->Fingerprint(),\n+                                 tsl::Fingerprint64(msg_));\n+  }\n+  return tsl::Fingerprint64(msg_);\n+}\n+\n+UserContextId AnnotatedUserContext::Id() const { return id_; }\n+\n+std::string AnnotatedUserContext::DebugString() const {\n+  return absl::StrCat(\n+      (user_context_ ? user_context_->DebugString() : \"(nullptr user context)\"),\n+      \"; \", msg_);\n+}\n+\n+absl_nonnull UserContextRef\n+ChainedUserContext::Create(absl::Span<const UserContextRef> user_contexts) {\n+  return tsl::MakeRef<ChainedUserContext>(user_contexts);\n+}\n+\n+ChainedUserContext::ChainedUserContext(\n+    absl::Span<const UserContextRef> user_contexts)\n+    : id_(tsl::random::ThreadLocalNew64()),\n+      user_contexts_(user_contexts.begin(), user_contexts.end()) {}\n+\n+uint64_t ChainedUserContext::Fingerprint() const {\n+  static const uint64_t kFingerprintInitialValue =\n+      tsl::Fingerprint64(\"ChainedUserContext\");\n+  uint64_t fingerprint = kFingerprintInitialValue;\n+  for (int i = 0; i < user_contexts_.size(); ++i) {\n+    if (user_contexts_[i] != nullptr) {\n+      fingerprint =\n+          tsl::FingerprintCat64(fingerprint, user_contexts_[i]->Fingerprint());\n+    }\n+  }\n+  return fingerprint;\n+}\n+\n+UserContextId ChainedUserContext::Id() const { return id_; }\n+\n+std::string ChainedUserContext::DebugString() const {\n+  return absl::StrJoin(\n+      user_contexts_, \"\\n\\n ->\\n\\n\",\n+      [](std::string* out, const UserContextRef& user_context) {\n+        absl::StrAppend(out, (user_context ? user_context->DebugString()\n+                                           : \"(nullptr user context)\"));\n+      });\n+}\n+\n+absl_nonnull UserContextRef\n+FusedUserContext::Create(absl::Span<const UserContextRef> user_contexts) {\n+  return tsl::MakeRef<FusedUserContext>(user_contexts);\n+}\n+\n+FusedUserContext::FusedUserContext(\n+    absl::Span<const UserContextRef> user_contexts)\n+    : id_(tsl::random::ThreadLocalNew64()),\n+      user_contexts_(user_contexts.begin(), user_contexts.end()) {}\n+\n+uint64_t FusedUserContext::Fingerprint() const {\n+  static const uint64_t kFingerprintInitialValue =\n+      tsl::Fingerprint64(\"FusedUserContext\");\n+  std::vector<uint64_t> fingerprints;\n+  fingerprints.reserve(user_contexts_.size());\n+  for (int i = 0; i < user_contexts_.size(); ++i) {\n+    if (user_contexts_[i] != nullptr) {\n+      fingerprints.push_back(user_contexts_[i]->Fingerprint());\n+    }\n+  }\n+  absl::c_sort(fingerprints);\n+  uint64_t fingerprint = kFingerprintInitialValue;\n+  for (uint64_t user_context_fingerprint : fingerprints) {\n+    fingerprint = tsl::FingerprintCat64(fingerprint, user_context_fingerprint);\n+  }\n+  return fingerprint;\n+}\n+\n+UserContextId FusedUserContext::Id() const { return id_; }\n+\n+std::string FusedUserContext::DebugString() const {\n+  return absl::StrCat(\n+      \"Fused user context: {\\n\\n\",\n+      absl::StrJoin(user_contexts_, \"\\n\\n\",\n+                    [](std::string* out, const UserContextRef& user_context) {\n+                      absl::StrAppend(\n+                          out, (user_context ? user_context->DebugString()\n+                                             : \"(nullptr user context)\"));\n+                    }),\n+      \"\\n\\n}\");\n+}\n+\n UserContextScope::UserContextScope(absl_nullable UserContextRef context)\n     : outer_context_(current_context), context_(std::move(context)) {\n   current_context = &context_;"
        },
        {
            "sha": "413cb3510d35aa090b83cf70a127e3f2182a5a21",
            "filename": "third_party/xla/xla/python/ifrt/user_context.h",
            "status": "modified",
            "additions": 123,
            "deletions": 6,
            "changes": 129,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.h?ref=55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a",
            "patch": "@@ -18,8 +18,11 @@ limitations under the License.\n \n #include <cstdint>\n #include <string>\n+#include <vector>\n \n #include \"absl/base/nullability.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/lib/gtl/int_type.h\"\n@@ -30,19 +33,19 @@ namespace ifrt {\n // Globally unique ID for a `UserContext`.\n TSL_LIB_GTL_DEFINE_INT_TYPE(UserContextId, uint64_t);\n \n-// UserContext is an interface that must be implemented by any object that the\n+// `UserContext` is an interface that must be implemented by any object that the\n // user would like to be associated with the runtime operations triggered by an\n-// IFRT call. For example, a UserContext can be based on a stack trace for\n+// IFRT call. For example, a `UserContext` can be based on a stack trace for\n // Python frameworks (e.g.: JAX), or on a \"request_id\" in case of request\n // serving applications.\n class UserContext : public tsl::ReferenceCounted<UserContext>,\n                     public llvm::RTTIExtends<UserContext, llvm::RTTIRoot> {\n  public:\n   ~UserContext() override = default;\n \n-  // Returns a fingerprint of the UserContext. The returned fingerprint must\n+  // Returns a fingerprint of the `UserContext`. The returned fingerprint must\n   // be non-zero, as the special value of zero is reserved for the IFRT\n-  // implementations for their internal default UserContext.  IFRT\n+  // implementations for their internal default `UserContext`.  IFRT\n   // implementations may use internally. IFRT implementations\n   // may also use this as a key for holding the UserContexts in a container, and\n   // so this should be efficient enough to called multiple times.\n@@ -53,9 +56,9 @@ class UserContext : public tsl::ReferenceCounted<UserContext>,\n   // `Id()` semantics allows an indefinite set of IDs.\n   virtual uint64_t Fingerprint() const = 0;\n \n-  // Returns the unique ID of the UserContext. This ID is expected to be\n+  // Returns the unique ID of the `UserContext`. This ID is expected to be\n   // globally unique for a certain context. For instance, both a global random\n-  // ID and the fingerprint of the UserContext content may be used as the ID.\n+  // ID and the fingerprint of the `UserContext` content may be used as the ID.\n   virtual UserContextId Id() const = 0;\n \n   // Returns a human readable string. Meant for debugging, logging, and for\n@@ -75,6 +78,120 @@ class UserContext : public tsl::ReferenceCounted<UserContext>,\n \n using UserContextRef = tsl::RCReference<UserContext>;\n \n+// 'AnnotatedUserContext` represents a `UserContext` with a human-readable short\n+// message. The annotation adds extra contextual information that is known after\n+// creation time of the original `UserContext`, but before actually observing\n+// any error. For example, if the dispatch logic of a runtime takes a certain\n+// internal implementation path, the runtime can mention this choice in the\n+// annotation. If an error ends up happening later, this annotation will provide\n+// an extra context to the user.\n+class AnnotatedUserContext\n+    : public llvm::RTTIExtends<AnnotatedUserContext, UserContext> {\n+ public:\n+  static absl_nonnull UserContextRef Create(UserContextRef user_context,\n+                                            std::string msg);\n+\n+  const UserContextRef& user_context() const { return user_context_; }\n+  absl::string_view msg() const { return msg_; }\n+\n+  // `UserContext` implementation.\n+\n+  uint64_t Fingerprint() const override;\n+  UserContextId Id() const override;\n+  std::string DebugString() const override;\n+\n+  static char ID;  // NOLINT\n+\n+ private:\n+  template <typename T, typename... Args>\n+  friend tsl::RCReference<T> tsl::MakeRef(Args&&... args);\n+\n+  explicit AnnotatedUserContext(UserContextRef user_context, std::string msg);\n+\n+  UserContextId id_;\n+  UserContextRef user_context_;\n+  std::string msg_;\n+};\n+\n+// `ChainedUserContext` represents a chain of `UserContext`s of the operations,\n+// each of which is dependent on its preceding operation. This expresses how an\n+// error is propagated from one operation to another operation that uses the\n+// result of the former operation. `user_contexts` is order-dependent: for\n+// example, `user_contexts.front()` indicates the context of the earliest\n+// operation that is the original source of the error, and\n+// `user_contexts.back()` indicates the context of the latest operation that is\n+// finally surfacing the error to the user.\n+class ChainedUserContext\n+    : public llvm::RTTIExtends<ChainedUserContext, UserContext> {\n+ public:\n+  static absl_nonnull UserContextRef\n+  Create(absl::Span<const UserContextRef> user_contexts);\n+\n+  // Not copyable or movable.\n+  ChainedUserContext(const ChainedUserContext&) = delete;\n+  ChainedUserContext& operator=(const ChainedUserContext&) = delete;\n+\n+  absl::Span<const UserContextRef> user_contexts() const {\n+    return user_contexts_;\n+  }\n+\n+  // `UserContext` implementation.\n+\n+  uint64_t Fingerprint() const override;\n+  UserContextId Id() const override;\n+  std::string DebugString() const override;\n+\n+  static char ID;  // NOLINT\n+\n+ private:\n+  template <typename T, typename... Args>\n+  friend tsl::RCReference<T> tsl::MakeRef(Args&&... args);\n+\n+  explicit ChainedUserContext(absl::Span<const UserContextRef> user_contexts);\n+\n+  UserContextId id_;\n+  std::vector<UserContextRef> user_contexts_;\n+};\n+\n+// `FusedUserContext` represents a set of `UserContext`s whose operations may\n+// contribute to an error, but are indistinguishable from each other from a\n+// runtime's perspective. For instance, the runtime can batch multiple API calls\n+// together while getting a single aggregate error status for the whole batch.\n+// Then, the runtime can use this user context to indicate that the error can\n+// come from any of the batched operations. The ordering of user contexts in a\n+// fused user context is insignificant.\n+class FusedUserContext\n+    : public llvm::RTTIExtends<FusedUserContext, UserContext> {\n+ public:\n+  static absl_nonnull UserContextRef\n+  Create(absl::Span<const UserContextRef> user_contexts);\n+\n+  // Not copyable or movable.\n+  FusedUserContext(const FusedUserContext&) = delete;\n+  FusedUserContext& operator=(const FusedUserContext&) = delete;\n+\n+  absl::Span<const UserContextRef> user_contexts() const {\n+    return user_contexts_;\n+  }\n+\n+  // `UserContext` implementation.\n+\n+  uint64_t Fingerprint() const override;\n+  UserContextId Id() const override;\n+  std::string DebugString() const override;\n+\n+  static char ID;  // NOLINT\n+\n+ private:\n+  template <typename T, typename... Args>\n+  friend tsl::RCReference<T> tsl::MakeRef(Args&&... args);\n+\n+  explicit FusedUserContext(absl::Span<const UserContextRef> user_contexts);\n+\n+  UserContextId id_;\n+  std::vector<UserContextRef> user_contexts_;\n+};\n+\n // Tracks the active `UserContext` within the scope. It holds a pointer to the\n // `UserContext` instance and uses a thread-local variable to make it\n // discoverable through a static method."
        },
        {
            "sha": "5770d17d6cdaf7aeec741fe0620cbabe257ef12b",
            "filename": "third_party/xla/xla/python/ifrt/user_context_test.cc",
            "status": "modified",
            "additions": 155,
            "deletions": 13,
            "changes": 168,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_test.cc?ref=55921839ec42dfa0b5f4f1b3ed1c6a1c464c8a7a",
            "patch": "@@ -19,6 +19,7 @@ limitations under the License.\n #include <string>\n \n #include <gtest/gtest.h>\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n@@ -33,35 +34,175 @@ namespace {\n \n class TestUserContext : public llvm::RTTIExtends<TestUserContext, UserContext> {\n  public:\n-  static UserContextRef Create() { return tsl::MakeRef<TestUserContext>(); }\n+  static UserContextRef Create(UserContextId id) {\n+    return tsl::TakeRef<TestUserContext>(new TestUserContext(id));\n+  }\n \n-  uint64_t Fingerprint() const override { return 1; }\n-  UserContextId Id() const override { return UserContextId(1); }\n+  uint64_t Fingerprint() const override { return id_.value(); }\n+  UserContextId Id() const override { return id_; }\n \n-  std::string DebugString() const override { return \"\"; }\n+  std::string DebugString() const override {\n+    return absl::StrCat(\"user context \", id_.value());\n+  }\n \n   // No new `ID` is not defined because tests below do not exercise RTTI.\n+\n+ private:\n+  explicit TestUserContext(UserContextId id) : id_(id) {}\n+\n+  UserContextId id_;\n };\n \n+TEST(AnnotatedUserContextTest, Id) {\n+  const UserContextId kUserContextId(100);\n+  UserContextRef context = TestUserContext::Create(kUserContextId);\n+\n+  UserContextRef annotated_context1 =\n+      AnnotatedUserContext::Create(context, \"test annotation\");\n+  EXPECT_NE(annotated_context1->Id(), context->Id());\n+\n+  UserContextRef annotated_context2 =\n+      AnnotatedUserContext::Create(context, \"test annotation 2\");\n+  EXPECT_NE(annotated_context2->Id(), annotated_context1->Id());\n+\n+  UserContextRef annotated_context3 =\n+      AnnotatedUserContext::Create(UserContextRef(), \"test annotation\");\n+  EXPECT_NE(annotated_context3->Id(), annotated_context1->Id());\n+}\n+\n+TEST(AnnotatedUserContextTest, Fingerprint) {\n+  const UserContextId kUserContextId(100);\n+  UserContextRef context = TestUserContext::Create(kUserContextId);\n+\n+  UserContextRef annotated_context1 =\n+      AnnotatedUserContext::Create(context, \"test annotation\");\n+  EXPECT_NE(annotated_context1->Fingerprint(), context->Fingerprint());\n+\n+  UserContextRef annotated_context2 =\n+      AnnotatedUserContext::Create(context, \"test annotation 2\");\n+  EXPECT_NE(annotated_context2->Fingerprint(),\n+            annotated_context1->Fingerprint());\n+\n+  UserContextRef annotated_context3 =\n+      AnnotatedUserContext::Create(UserContextRef(), \"test annotation\");\n+  EXPECT_NE(annotated_context3->Fingerprint(),\n+            annotated_context1->Fingerprint());\n+}\n+\n+TEST(AnnotatedUserContextTest, DebugString) {\n+  {\n+    const UserContextId kUserContextId(100);\n+    UserContextRef context = TestUserContext::Create(kUserContextId);\n+    UserContextRef annotated_context =\n+        AnnotatedUserContext::Create(context, \"test annotation\");\n+    EXPECT_EQ(annotated_context->DebugString(),\n+              \"user context 100; test annotation\");\n+  }\n+  {\n+    UserContextRef annotated_context =\n+        AnnotatedUserContext::Create(UserContextRef(), \"test annotation\");\n+    EXPECT_EQ(annotated_context->DebugString(),\n+              \"(nullptr user context); test annotation\");\n+  }\n+}\n+\n+TEST(ChainedUserContextTest, Id) {\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n+  UserContextRef chained_context =\n+      ChainedUserContext::Create({context1, UserContextRef(), context2});\n+  EXPECT_NE(chained_context->Id(), context1->Id());\n+  EXPECT_NE(chained_context->Id(), context2->Id());\n+}\n+\n+TEST(ChainedUserContextTest, Fingerprint) {\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n+  UserContextRef chained_context1 =\n+      ChainedUserContext::Create({context1, UserContextRef(), context2});\n+  EXPECT_NE(chained_context1->Fingerprint(), context1->Fingerprint());\n+  EXPECT_NE(chained_context1->Fingerprint(), context2->Fingerprint());\n+  UserContextRef chained_context2 =\n+      ChainedUserContext::Create({context2, UserContextRef(), context1});\n+  EXPECT_NE(chained_context2->Fingerprint(), chained_context1->Fingerprint());\n+}\n+\n+TEST(ChainedUserContextTest, DebugString) {\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n+  UserContextRef chained_context =\n+      ChainedUserContext::Create({context1, UserContextRef(), context2});\n+  EXPECT_EQ(chained_context->DebugString(),\n+            \"user context 100\\n\\n ->\\n\\n(nullptr user context)\\n\\n ->\\n\\nuser \"\n+            \"context 200\");\n+}\n+\n+TEST(FusedUserContextTest, Id) {\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n+  UserContextRef fused_context =\n+      FusedUserContext::Create({context1, UserContextRef(), context2});\n+  EXPECT_NE(fused_context->Id(), context1->Id());\n+  EXPECT_NE(fused_context->Id(), context2->Id());\n+}\n+\n+TEST(FusedUserContextTest, Fingerprint) {\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n+  UserContextRef fused_context1 =\n+      FusedUserContext::Create({context1, UserContextRef(), context2});\n+  EXPECT_NE(fused_context1->Fingerprint(), context1->Fingerprint());\n+  EXPECT_NE(fused_context1->Fingerprint(), context2->Fingerprint());\n+  UserContextRef fused_context2 =\n+      FusedUserContext::Create({context2, UserContextRef(), context1});\n+  EXPECT_EQ(fused_context2->Fingerprint(), fused_context1->Fingerprint());\n+}\n+\n+TEST(FusedUserContextTest, DebugString) {\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n+  UserContextRef fused_context =\n+      FusedUserContext::Create({context1, UserContextRef(), context2});\n+  EXPECT_EQ(fused_context->DebugString(),\n+            \"Fused user context: {\\n\\nuser context 100\\n\\n(nullptr user \"\n+            \"context)\\n\\nuser context 200\\n\\n}\");\n+}\n+\n TEST(UserContextScopeTest, NullContext) {\n   EXPECT_EQ(UserContextScope::current(), nullptr);\n }\n \n TEST(UserContextScopeTest, SingleScope) {\n-  UserContextRef context = TestUserContext::Create();\n+  const UserContextId kUserContextId(100);\n+  UserContextRef context = TestUserContext::Create(kUserContextId);\n   UserContextScope scope(context);\n   EXPECT_EQ(UserContextScope::current(), context);\n }\n \n TEST(UserContextScopeTest, SingleScopeWithInlineContextCreation) {\n-  UserContextScope scope(TestUserContext::Create());\n-  EXPECT_EQ(UserContextScope::current()->Fingerprint(), 1);\n-  EXPECT_EQ(UserContextScope::current()->Id(), UserContextId(1));\n+  const UserContextId kUserContextId(100);\n+  UserContextScope scope(TestUserContext::Create(kUserContextId));\n+  EXPECT_EQ(UserContextScope::current()->Fingerprint(), kUserContextId.value());\n+  EXPECT_EQ(UserContextScope::current()->Id(), kUserContextId);\n }\n \n TEST(UserContextScopeTest, NestedScopes) {\n-  UserContextRef context1 = TestUserContext::Create();\n-  UserContextRef context2 = TestUserContext::Create();\n+  const UserContextId kUserContextId1(100);\n+  const UserContextId kUserContextId2(200);\n+  UserContextRef context1 = TestUserContext::Create(kUserContextId1);\n+  UserContextRef context2 = TestUserContext::Create(kUserContextId2);\n   UserContextScope scope1(context1);\n   EXPECT_EQ(UserContextScope::current(), context1);\n   {\n@@ -72,7 +213,8 @@ TEST(UserContextScopeTest, NestedScopes) {\n }\n \n TEST(UserContextScopeTest, ThreadLocalScopes) {\n-  UserContextRef context = TestUserContext::Create();\n+  const UserContextId kUserContextId(100);\n+  UserContextRef context = TestUserContext::Create(kUserContextId);\n   UserContextScope scope(context);\n   EXPECT_EQ(UserContextScope::current(), context);\n \n@@ -84,15 +226,15 @@ TEST(UserContextScopeTest, ThreadLocalScopes) {\n   // The effect of UserContextScope set is limited to the current thread.\n   for (int i = 0; i < 100; ++i) {\n     thread_pool1.Schedule([&]() {\n-      UserContextRef context1 = TestUserContext::Create();\n+      UserContextRef context1 = TestUserContext::Create(kUserContextId);\n       UserContextScope scope1(context1);\n       EXPECT_EQ(UserContextScope::current(), context1);\n       absl::SleepFor(absl::Microseconds(10));\n     });\n   }\n   for (int i = 0; i < 100; ++i) {\n     thread_pool2.Schedule([&]() {\n-      UserContextRef context2 = TestUserContext::Create();\n+      UserContextRef context2 = TestUserContext::Create(kUserContextId);\n       UserContextScope scope1(context2);\n       EXPECT_EQ(UserContextScope::current(), context2);\n       absl::SleepFor(absl::Microseconds(10));"
        }
    ],
    "stats": {
        "total": 424,
        "additions": 404,
        "deletions": 20
    }
}