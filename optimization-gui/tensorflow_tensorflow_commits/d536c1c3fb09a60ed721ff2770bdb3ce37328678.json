{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845674996",
    "sha": "d536c1c3fb09a60ed721ff2770bdb3ce37328678",
    "files": [
        {
            "sha": "549bf3f9f7c933b6c06972b827a9647a6e1b0eb9",
            "filename": "third_party/xla/xla/tsl/util/device_name_utils.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 21,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils.cc?ref=d536c1c3fb09a60ed721ff2770bdb3ce37328678",
            "patch": "@@ -43,7 +43,7 @@ static bool IsJobName(absl::string_view in) {\n          std::all_of(in.begin(), in.end(), IsAlphaNumOrUnderscore);\n }\n \n-static bool ConsumePrefix(absl::string_view* in, string* out,\n+static bool ConsumePrefix(absl::string_view* in, std::string* out,\n                           absl::string_view prefix_terminators) {\n   if (in->empty() || !absl::ascii_isalpha(in->front())) {\n     return false;\n@@ -60,13 +60,13 @@ static bool ConsumePrefix(absl::string_view* in, string* out,\n }\n \n // Returns true and fills in \"*job\" iff \"*in\" starts with a job name.\n-static bool ConsumeJobName(absl::string_view* in, string* job) {\n+static bool ConsumeJobName(absl::string_view* in, std::string* job) {\n   return ConsumePrefix(in, job, \"/\");\n }\n \n // Returns true and fills in \"*device_type\" iff \"*in\" starts with a device type\n // name.\n-static bool ConsumeDeviceType(absl::string_view* in, string* device_type) {\n+static bool ConsumeDeviceType(absl::string_view* in, std::string* device_type) {\n   return ConsumePrefix(in, device_type, \"/:\");\n }\n \n@@ -95,14 +95,15 @@ static std::string DeviceName(absl::string_view job, int replica, int task,\n }\n \n /* static */\n-string DeviceNameUtils::FullName(const string& job, int replica, int task,\n-                                 const string& type, int id) {\n+std::string DeviceNameUtils::FullName(const std::string& job, int replica,\n+                                      int task, const std::string& type,\n+                                      int id) {\n   return DeviceName(job, replica, task, \"/device:\", type, id);\n }\n \n namespace {\n-string LegacyName(const string& job, int replica, int task, const string& type,\n-                  int id) {\n+std::string LegacyName(const std::string& job, int replica, int task,\n+                       const std::string& type, int id) {\n   return DeviceName(job, replica, task, \"/\", absl::AsciiStrToLower(type), id);\n }\n }  // anonymous namespace\n@@ -214,9 +215,9 @@ void CompleteName(const DeviceNameUtils::ParsedName& parsed_basename,\n }  // namespace\n \n /* static */\n-absl::Status DeviceNameUtils::CanonicalizeDeviceName(absl::string_view fullname,\n-                                                     absl::string_view basename,\n-                                                     string* canonical_name) {\n+absl::Status DeviceNameUtils::CanonicalizeDeviceName(\n+    absl::string_view fullname, absl::string_view basename,\n+    std::string* canonical_name) {\n   *canonical_name = \"\";\n   ParsedName parsed_basename;\n   if (!ParseFullName(basename, &parsed_basename)) {\n@@ -247,8 +248,8 @@ absl::Status DeviceNameUtils::CanonicalizeDeviceName(absl::string_view fullname,\n }\n \n /* static */\n-string DeviceNameUtils::ParsedNameToString(const ParsedName& pn) {\n-  string buf;\n+std::string DeviceNameUtils::ParsedNameToString(const ParsedName& pn) {\n+  std::string buf;\n   if (pn.has_job) {\n     absl::StrAppend(&buf, \"/job:\", pn.job);\n   }\n@@ -533,20 +534,20 @@ const DeviceNameUtils::ParsedName DeviceNameUtils::AddressSpace(\n }\n \n /* static */\n-string DeviceNameUtils::LocalName(absl::string_view type, int id) {\n+std::string DeviceNameUtils::LocalName(absl::string_view type, int id) {\n   return absl::StrCat(\"/device:\", type, \":\", id);\n }\n \n namespace {\n // Returns the legacy local device name given its \"type\" and \"id\" (which is\n // '/device:type:id').\n-string LegacyLocalName(absl::string_view type, int id) {\n+std::string LegacyLocalName(absl::string_view type, int id) {\n   return absl::StrCat(type, \":\", id);\n }\n }  // anonymous namespace\n \n /* static */\n-string DeviceNameUtils::LocalName(absl::string_view fullname) {\n+std::string DeviceNameUtils::LocalName(absl::string_view fullname) {\n   ParsedName x;\n   CHECK(ParseFullName(fullname, &x)) << fullname;\n   return LocalName(x.type, x.id);\n@@ -569,8 +570,8 @@ bool DeviceNameUtils::ParseLocalName(absl::string_view name, ParsedName* p) {\n }\n \n /* static */\n-bool DeviceNameUtils::SplitDeviceName(absl::string_view name, string* task,\n-                                      string* device) {\n+bool DeviceNameUtils::SplitDeviceName(absl::string_view name, std::string* task,\n+                                      std::string* device) {\n   ParsedName pn;\n   if (ParseFullName(name, &pn) && pn.has_type && pn.has_id) {\n     task->clear();\n@@ -595,7 +596,7 @@ bool DeviceNameUtils::SplitDeviceName(absl::string_view name, string* task,\n }\n \n /* static */\n-bool DeviceNameUtils::GetTaskName(const ParsedName& pn, string* task) {\n+bool DeviceNameUtils::GetTaskName(const ParsedName& pn, std::string* task) {\n   if (pn.has_job && pn.has_replica && pn.has_task) {\n     task->clear();\n     task->reserve((5 + pn.job.size()) +\n@@ -609,7 +610,7 @@ bool DeviceNameUtils::GetTaskName(const ParsedName& pn, string* task) {\n   return false;\n }\n \n-std::vector<string> DeviceNameUtils::GetNamesForDeviceMappings(\n+std::vector<std::string> DeviceNameUtils::GetNamesForDeviceMappings(\n     const ParsedName& pn) {\n   if (pn.has_job && pn.has_replica && pn.has_task && pn.has_type && pn.has_id) {\n     return {\n@@ -619,7 +620,7 @@ std::vector<string> DeviceNameUtils::GetNamesForDeviceMappings(\n   return {};\n }\n \n-std::vector<string> DeviceNameUtils::GetLocalNamesForDeviceMappings(\n+std::vector<std::string> DeviceNameUtils::GetLocalNamesForDeviceMappings(\n     const ParsedName& pn) {\n   if (pn.has_type && pn.has_id) {\n     return {DeviceNameUtils::LocalName(pn.type, pn.id),\n@@ -629,7 +630,7 @@ std::vector<string> DeviceNameUtils::GetLocalNamesForDeviceMappings(\n }\n \n /*static*/ absl::Status DeviceNameUtils::DeviceNameToCpuDeviceName(\n-    const string& device_name, string* host_device_name) {\n+    const std::string& device_name, std::string* host_device_name) {\n   DeviceNameUtils::ParsedName device;\n   if (!DeviceNameUtils::ParseFullName(device_name, &device)) {\n     return errors::Internal(\"Could not parse device name \", device_name);"
        },
        {
            "sha": "b431037c038848511b2b5ea5b65b18c6274631d9",
            "filename": "third_party/xla/xla/tsl/util/device_name_utils.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils.h?ref=d536c1c3fb09a60ed721ff2770bdb3ce37328678",
            "patch": "@@ -273,12 +273,13 @@ class DeviceNameUtils {\n   // Returns canonical and legacy full names for the given parsed\n   // device name 'pn'. The returned string names are often useful to\n   // look up devices from a mapping.\n-  static std::vector<string> GetNamesForDeviceMappings(const ParsedName& pn);\n+  static std::vector<std::string> GetNamesForDeviceMappings(\n+      const ParsedName& pn);\n \n   // Returns canonical and legacy local names for the given parsed device name\n   // 'pn'. The returned string names are often useful to look up devices from a\n   // mapping.\n-  static std::vector<string> GetLocalNamesForDeviceMappings(\n+  static std::vector<std::string> GetLocalNamesForDeviceMappings(\n       const ParsedName& pn);\n \n   // Returns name of the CPU:0 device on the same host as the device"
        },
        {
            "sha": "3dd25347fd0342914f812897e1fd4960159b09d2",
            "filename": "third_party/xla/xla/tsl/util/device_name_utils_test.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 23,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fdevice_name_utils_test.cc?ref=d536c1c3fb09a60ed721ff2770bdb3ce37328678",
            "patch": "@@ -29,20 +29,22 @@ namespace tsl {\n \n namespace {\n \n-bool RoundTripParsedName(const string& original, const string& expected) {\n+bool RoundTripParsedName(const std::string& original,\n+                         const std::string& expected) {\n   DeviceNameUtils::ParsedName p;\n   if (!DeviceNameUtils::ParseFullName(original, &p)) {\n     return false;\n   }\n-  string round_tripped = DeviceNameUtils::ParsedNameToString(p);\n+  std::string round_tripped = DeviceNameUtils::ParsedNameToString(p);\n   return (round_tripped == expected);\n }\n \n enum NamePart { kJob = 0x01, kReplica = 0x02, kTask = 0x04, kDevice = 0x08 };\n \n-bool RoundTripPartialName(int parts_to_test, const std::vector<string>& parts,\n+bool RoundTripPartialName(int parts_to_test,\n+                          const std::vector<std::string>& parts,\n                           bool explicitDevice) {\n-  string original, expected;\n+  std::string original, expected;\n   if (parts_to_test & kJob) {\n     absl::StrAppend(&original, \"/job:\", parts[0]);\n     absl::StrAppend(&expected, \"/job:\", parts[0]);\n@@ -370,8 +372,8 @@ TEST(DeviceNameUtilsTest, IsSpecification) {\n }\n \n TEST(DeviceNameUtilsTest, SplitDeviceName) {\n-  string task;\n-  string device;\n+  std::string task;\n+  std::string device;\n   EXPECT_TRUE(DeviceNameUtils::SplitDeviceName(\n       \"/job:foo/replica:1/task:2/cpu:1\", &task, &device));\n   EXPECT_EQ(\"/job:foo/replica:1/task:2\", task);\n@@ -393,14 +395,15 @@ TEST(DeviceNameUtilsTest, SplitDeviceName) {\n   EXPECT_EQ(\"myspecialdevice:3\", device);\n }\n \n-static DeviceNameUtils::ParsedName Name(const string& str) {\n+static DeviceNameUtils::ParsedName Name(const std::string& str) {\n   DeviceNameUtils::ParsedName ret;\n   CHECK(DeviceNameUtils::ParseFullName(str, &ret)) << \"Invalid name: \" << str;\n   return ret;\n }\n \n-static void MergeDevNamesHelperImpl(const string& name_a, const string& name_b,\n-                                    const string& expected_merge_name,\n+static void MergeDevNamesHelperImpl(const std::string& name_a,\n+                                    const std::string& name_b,\n+                                    const std::string& expected_merge_name,\n                                     bool allow_soft_placement) {\n   DeviceNameUtils::ParsedName target_a = Name(name_a);\n   TF_EXPECT_OK(DeviceNameUtils::MergeDevNames(&target_a, Name(name_b),\n@@ -413,27 +416,30 @@ static void MergeDevNamesHelperImpl(const string& name_a, const string& name_b,\n   EXPECT_EQ(target_b, Name(expected_merge_name));\n }\n \n-static void MergeDevNamesHelper(const string& name_a, const string& name_b,\n-                                const string& expected_merge_name) {\n+static void MergeDevNamesHelper(const std::string& name_a,\n+                                const std::string& name_b,\n+                                const std::string& expected_merge_name) {\n   MergeDevNamesHelperImpl(name_a, name_b, expected_merge_name, false);\n }\n \n static void MergeDevNamesHelperAllowSoftPlacement(\n-    const string& name_a, const string& name_b,\n-    const string& expected_merge_name) {\n+    const std::string& name_a, const std::string& name_b,\n+    const std::string& expected_merge_name) {\n   MergeDevNamesHelperImpl(name_a, name_b, expected_merge_name, true);\n }\n \n-static void MergeDevNamesError(const string& name_a, const string& name_b,\n-                               const string& expected_error_substr) {\n+static void MergeDevNamesError(const std::string& name_a,\n+                               const std::string& name_b,\n+                               const std::string& expected_error_substr) {\n   DeviceNameUtils::ParsedName target_a = Name(name_a);\n   absl::Status s = DeviceNameUtils::MergeDevNames(&target_a, Name(name_b));\n   EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n   EXPECT_TRUE(absl::StrContains(s.message(), expected_error_substr)) << s;\n }\n \n-static void MergeOverrideHelper(const string& target, const string& name,\n-                                const string& expected_merge_name) {\n+static void MergeOverrideHelper(const std::string& target,\n+                                const std::string& name,\n+                                const std::string& expected_merge_name) {\n   DeviceNameUtils::ParsedName parsed_target = Name(target);\n   TF_EXPECT_OK(\n       DeviceNameUtils::MergeOverrideDevNames(&parsed_target, Name(name)));\n@@ -445,9 +451,10 @@ static void MergeOverrideHelper(const string& target, const string& name,\n       << DeviceNameUtils::ParsedNameToString(parsed_expected);\n }\n \n-static void MergeUnsetDevNamesHelper(const string& name_a, const string& name_b,\n-                                     const string& expected_merge_name_ab,\n-                                     const string& expected_merge_name_ba) {\n+static void MergeUnsetDevNamesHelper(\n+    const std::string& name_a, const std::string& name_b,\n+    const std::string& expected_merge_name_ab,\n+    const std::string& expected_merge_name_ba) {\n   DeviceNameUtils::ParsedName target_a = Name(name_a);\n   DeviceNameUtils::MergeUnsetDevNames(&target_a, Name(name_b));\n   EXPECT_EQ(target_a, Name(expected_merge_name_ab));\n@@ -592,10 +599,10 @@ TEST(DeviceNameUtilsTest, GetNamesForDeviceMappings) {\n }\n \n TEST(DeviceNameUtilsTest, CanonicalizeDeviceName) {\n-  string canonical_name;\n+  std::string canonical_name;\n   {\n     // Good basename.\n-    string basename = \"/job:foo/replica:10/task:0/device:CPU:0\";\n+    std::string basename = \"/job:foo/replica:10/task:0/device:CPU:0\";\n     TF_EXPECT_OK(DeviceNameUtils::CanonicalizeDeviceName(\n         \"/job:foo/replica:10/task:0/device:CPU:1\", basename, &canonical_name));\n     EXPECT_EQ(\"/job:foo/replica:10/task:0/device:CPU:1\", canonical_name);\n@@ -616,7 +623,7 @@ TEST(DeviceNameUtilsTest, CanonicalizeDeviceName) {\n \n   {\n     // Try out malformed basenames.\n-    string fullname = \"/device:CPU:0\";\n+    std::string fullname = \"/device:CPU:0\";\n \n     absl::Status s = DeviceNameUtils::CanonicalizeDeviceName(\n         fullname, \"/device:CPU:0\", &canonical_name);"
        },
        {
            "sha": "351a8e3d3c3baebc85b5430f4b0a49801eef274c",
            "filename": "third_party/xla/xla/tsl/util/env_var.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fenv_var.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fenv_var.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fenv_var.cc?ref=d536c1c3fb09a60ed721ff2770bdb3ce37328678",
            "patch": "@@ -30,11 +30,11 @@ namespace tsl {\n absl::Status ReadBoolFromEnvVar(absl::string_view env_var_name,\n                                 bool default_val, bool* value) {\n   *value = default_val;\n-  const char* tf_env_var_val = getenv(string(env_var_name).c_str());\n+  const char* tf_env_var_val = getenv(std::string(env_var_name).c_str());\n   if (tf_env_var_val == nullptr) {\n     return absl::OkStatus();\n   }\n-  string str_value = absl::AsciiStrToLower(tf_env_var_val);\n+  std::string str_value = absl::AsciiStrToLower(tf_env_var_val);\n   if (str_value == \"0\" || str_value == \"false\") {\n     *value = false;\n     return absl::OkStatus();\n@@ -51,7 +51,7 @@ absl::Status ReadBoolFromEnvVar(absl::string_view env_var_name,\n absl::Status ReadInt64FromEnvVar(absl::string_view env_var_name,\n                                  int64_t default_val, int64_t* value) {\n   *value = default_val;\n-  const char* tf_env_var_val = getenv(string(env_var_name).c_str());\n+  const char* tf_env_var_val = getenv(std::string(env_var_name).c_str());\n   if (tf_env_var_val == nullptr) {\n     return absl::OkStatus();\n   }\n@@ -66,7 +66,7 @@ absl::Status ReadInt64FromEnvVar(absl::string_view env_var_name,\n absl::Status ReadFloatFromEnvVar(absl::string_view env_var_name,\n                                  float default_val, float* value) {\n   *value = default_val;\n-  const char* tf_env_var_val = getenv(string(env_var_name).c_str());\n+  const char* tf_env_var_val = getenv(std::string(env_var_name).c_str());\n   if (tf_env_var_val == nullptr) {\n     return absl::OkStatus();\n   }\n@@ -80,20 +80,20 @@ absl::Status ReadFloatFromEnvVar(absl::string_view env_var_name,\n \n absl::Status ReadStringFromEnvVar(absl::string_view env_var_name,\n                                   absl::string_view default_val,\n-                                  string* value) {\n-  const char* tf_env_var_val = getenv(string(env_var_name).c_str());\n+                                  std::string* value) {\n+  const char* tf_env_var_val = getenv(std::string(env_var_name).c_str());\n   if (tf_env_var_val != nullptr) {\n     *value = tf_env_var_val;\n   } else {\n-    *value = string(default_val);\n+    *value = std::string(default_val);\n   }\n   return absl::OkStatus();\n }\n \n absl::Status ReadStringsFromEnvVar(absl::string_view env_var_name,\n                                    absl::string_view default_val,\n-                                   std::vector<string>* value) {\n-  string str_val;\n+                                   std::vector<std::string>* value) {\n+  std::string str_val;\n   TF_RETURN_IF_ERROR(ReadStringFromEnvVar(env_var_name, default_val, &str_val));\n   *value = str_util::Split(str_val, ',');\n   return absl::OkStatus();"
        },
        {
            "sha": "e5eae477f141f558aceecc9b1f0972790476fd9a",
            "filename": "third_party/xla/xla/tsl/util/reporter.h",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Freporter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d536c1c3fb09a60ed721ff2770bdb3ce37328678/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Freporter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Freporter.h?ref=d536c1c3fb09a60ed721ff2770bdb3ce37328678",
            "patch": "@@ -32,14 +32,14 @@ namespace tsl {\n class TestReportFile {\n  public:\n   // Create a TestReportFile with the test name 'test_name'.\n-  TestReportFile(const string& fname, const string& test_name);\n+  TestReportFile(const std::string& fname, const std::string& test_name);\n \n   // Initialize the TestReportFile.  If the reporting env flag is set,\n   // try to create the reporting file.  Fails if the file already exists.\n   absl::Status Initialize();\n \n   // Append the report file w/ 'content'.\n-  absl::Status Append(const string& content);\n+  absl::Status Append(const std::string& content);\n \n   // Close the report file.\n   absl::Status Close();\n@@ -50,8 +50,8 @@ class TestReportFile {\n \n  private:\n   bool closed_;\n-  string fname_;\n-  string test_name_;\n+  std::string fname_;\n+  std::string test_name_;\n   std::unique_ptr<WritableFile> log_file_;\n   TestReportFile(const TestReportFile&) = delete;\n   void operator=(const TestReportFile&) = delete;\n@@ -82,11 +82,11 @@ class TestReporter {\n   static constexpr const char* kTestReporterEnv = \"TEST_REPORT_FILE_PREFIX\";\n \n   // Create a TestReporter with the test name 'test_name'.\n-  explicit TestReporter(const string& test_name)\n+  explicit TestReporter(const std::string& test_name)\n       : TestReporter(GetLogEnv(), test_name) {}\n \n   // Provide a prefix filename, mostly used for testing this class.\n-  TestReporter(const string& fname, const string& test_name);\n+  TestReporter(const std::string& fname, const std::string& test_name);\n \n   // Initialize the TestReporter.  If the reporting env flag is set,\n   // try to create the reporting file.  Fails if the file already exists.\n@@ -106,19 +106,19 @@ class TestReporter {\n                          double throughput);\n \n   // Set property on Benchmark to the given value.\n-  absl::Status SetProperty(const string& name, double value);\n+  absl::Status SetProperty(const std::string& name, double value);\n \n   // Set property on Benchmark to the given value.\n-  absl::Status SetProperty(const string& name, const string& value);\n+  absl::Status SetProperty(const std::string& name, const std::string& value);\n \n   // Add the given value to the metrics on the Benchmark.\n-  absl::Status AddMetric(const string& name, double value);\n+  absl::Status AddMetric(const std::string& name, double value);\n \n   // TODO(b/32704451): Don't just ignore the ::tensorflow::Status object!\n   ~TestReporter() { Close().IgnoreError(); }  // Autoclose in destructor.\n \n  private:\n-  static string GetLogEnv() {\n+  static std::string GetLogEnv() {\n     const char* fname_ptr = getenv(kTestReporterEnv);\n     return (fname_ptr != nullptr) ? fname_ptr : \"\";\n   }"
        }
    ],
    "stats": {
        "total": 139,
        "additions": 74,
        "deletions": 65
    }
}