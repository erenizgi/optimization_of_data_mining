{
    "author": "ezhulenev",
    "message": "[xla] Make PjRtFuture<> constructor from Promise private\n\nPiperOrigin-RevId: 810705117",
    "sha": "4ef60aed5aa34ed65074656c161830ebacc24e37",
    "files": [
        {
            "sha": "28654a922bec6bdd941e7920e07417f743d17d1f",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 42,
            "deletions": 28,
            "changes": 70,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4ef60aed5aa34ed65074656c161830ebacc24e37/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4ef60aed5aa34ed65074656c161830ebacc24e37/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=4ef60aed5aa34ed65074656c161830ebacc24e37",
            "patch": "@@ -747,6 +747,19 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n       tsl::internal::is_status_or_v<U>;\n \n  public:\n+  PjRtFuture() = default;\n+\n+  // Constructor for a future that is immediately ready with a given status.\n+  // For futures that are immediately ready with OK status, we use a global non\n+  // reference-counted async value that avoids heap allocation and reference\n+  // counting operations on a hot path.\n+  explicit PjRtFuture(absl::Status status)\n+      : Base(ABSL_PREDICT_TRUE(status.ok())\n+                 ? ready_promise_->AsRef()\n+                 : tsl::MakeAvailableAsyncValueRef<absl::Status>(\n+                       std::move(status)),\n+             /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n+\n   class Promise : public Base::Promise {\n    public:\n     Promise(Promise&&) = default;\n@@ -770,44 +783,29 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n       return std::make_shared<Promise>(std::move(*this));\n     }\n \n+    // Returns a future associated with the promise.\n+    PjRtFuture<> future(\n+        PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n+        PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) const {\n+      return PjRtFuture<>(*this, std::move(on_block_start),\n+                          std::move(on_block_end));\n+    }\n+\n    private:\n     friend class PjRtFuture<void>;\n   };\n \n   // Returns a pair of connected Promise and PjRtFuture<>. Setting the returned\n   // promise will fulfill the connected future.\n-  static std::pair<Promise, PjRtFuture<>> MakePromise() {\n+  static std::pair<Promise, PjRtFuture<>> MakePromise(\n+      PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n+      PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) {\n     Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n-    PjRtFuture<> future(promise);\n+    PjRtFuture<> future(promise, std::move(on_block_start),\n+                        std::move(on_block_end));\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n-  // Bring PjRtFutureBase constructors in scope.\n-  using Base::Base;\n-\n-  // Constructor for unavailable future that will be fulfilled later via the\n-  // promise object.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n-  explicit PjRtFuture(\n-      const Promise& promise,\n-      PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-      PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr)\n-      : Base(promise.ref(), std::move(on_block_start),\n-             std::move(on_block_end)) {}\n-\n-  // Constructor for a future that is immediately ready with a given status.\n-  // For futures that are immediately ready with OK status, we use a global non\n-  // reference-counted async value that avoids heap allocation and reference\n-  // counting operations on a hot path.\n-  explicit PjRtFuture(absl::Status status)\n-      : Base(ABSL_PREDICT_TRUE(status.ok())\n-                 ? ready_promise_->AsRef()\n-                 : tsl::MakeAvailableAsyncValueRef<absl::Status>(\n-                       std::move(status)),\n-             /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n-\n   using Base::Await;\n   using Base::BlockUntilReady;\n   using Base::OnReady;\n@@ -919,10 +917,26 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   }\n \n  private:\n+  friend class PjRtFutureHelpers;\n+\n   // A promise that is immediately ready with OK status. Async value allocated\n   // in the static storage and is not reference-counted.\n   static absl::NoDestructor<tsl::AsyncValueOwningRef<absl::Status>>\n       ready_promise_;\n+\n+  // Bring PjRtFutureBase constructors in scope.\n+  using Base::Base;\n+\n+  // Constructor for unavailable future that will be fulfilled later via the\n+  // promise object.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  PjRtFuture(const Promise& promise,\n+             PjRtFutureHelpers::OnBlockStartFn on_block_start,\n+             PjRtFutureHelpers::OnBlockEndFn on_block_end)\n+      : Base(promise.ref(), std::move(on_block_start),\n+             std::move(on_block_end)) {}\n };\n \n //===----------------------------------------------------------------------===//"
        }
    ],
    "stats": {
        "total": 70,
        "additions": 42,
        "deletions": 28
    }
}