{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 847088166",
    "sha": "4c4373fe645c803b5651e7fe6ad141839acc272f",
    "files": [
        {
            "sha": "fc5ab0b624754e459138aa4a3b46ea3535e29f8d",
            "filename": "tensorflow/core/util/tensor_bundle/naming.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c4373fe645c803b5651e7fe6ad141839acc272f/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Fnaming.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c4373fe645c803b5651e7fe6ad141839acc272f/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Fnaming.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Fnaming.cc?ref=4c4373fe645c803b5651e7fe6ad141839acc272f",
            "patch": "@@ -24,16 +24,16 @@ limitations under the License.\n \n namespace tensorflow {\n \n-string MetaFilename(absl::string_view prefix) {\n-  return strings::Printf(\"%.*s.index\", static_cast<int>(prefix.size()),\n+std::string MetaFilename(absl::string_view prefix) {\n+  return absl::StrFormat(\"%.*s.index\", static_cast<int>(prefix.size()),\n                          prefix.data());\n }\n \n-string DataFilename(absl::string_view prefix, int32_t shard_id,\n-                    int32_t num_shards) {\n+std::string DataFilename(absl::string_view prefix, int32_t shard_id,\n+                         int32_t num_shards) {\n   DCHECK_GT(num_shards, 0);\n   DCHECK_LT(shard_id, num_shards);\n-  return strings::Printf(\"%.*s.data-%05d-of-%05d\",\n+  return absl::StrFormat(\"%.*s.data-%05d-of-%05d\",\n                          static_cast<int>(prefix.size()), prefix.data(),\n                          shard_id, num_shards);\n }"
        },
        {
            "sha": "3acd5dcdd9bbe8a4f5be91e471dad33e2d82f100",
            "filename": "tensorflow/core/util/tensor_bundle/naming.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c4373fe645c803b5651e7fe6ad141839acc272f/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Fnaming.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c4373fe645c803b5651e7fe6ad141839acc272f/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Fnaming.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Fnaming.h?ref=4c4373fe645c803b5651e7fe6ad141839acc272f",
            "patch": "@@ -40,9 +40,9 @@ limitations under the License.\n \n namespace tensorflow {\n \n-string MetaFilename(absl::string_view prefix);\n-string DataFilename(absl::string_view prefix, int32_t shard_id,\n-                    int32_t num_shards);\n+std::string MetaFilename(absl::string_view prefix);\n+std::string DataFilename(absl::string_view prefix, int32_t shard_id,\n+                         int32_t num_shards);\n \n }  // namespace tensorflow\n "
        },
        {
            "sha": "592583c1acb2defeac95b7f80311c2fd5aca87ca",
            "filename": "tensorflow/core/util/tensor_bundle/tensor_bundle_test.cc",
            "status": "modified",
            "additions": 75,
            "deletions": 72,
            "changes": 147,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c4373fe645c803b5651e7fe6ad141839acc272f/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Ftensor_bundle_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c4373fe645c803b5651e7fe6ad141839acc272f/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Ftensor_bundle_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Ftensor_bundle%2Ftensor_bundle_test.cc?ref=4c4373fe645c803b5651e7fe6ad141839acc272f",
            "patch": "@@ -50,13 +50,13 @@ using ::testing::ElementsAre;\n namespace {\n \n // Prepend the current test case's working temporary directory to <prefix>\n-string Prefix(const string& prefix) {\n+std::string Prefix(const std::string& prefix) {\n   return absl::StrCat(testing::TmpDir(), \"/\", prefix);\n }\n \n // Construct a data input directory by prepending the test data root\n // directory to <prefix>\n-string TestdataPrefix(const string& prefix) {\n+std::string TestdataPrefix(const std::string& prefix) {\n   return absl::StrCat(testing::TensorFlowSrcRoot(),\n                       \"/core/util/tensor_bundle/testdata/\", prefix);\n }\n@@ -87,7 +87,7 @@ Tensor ByteSwap(Tensor t) {\n // Assert that <reader> has a tensor under <key> matching <expected_val> in\n // terms of both shape, dtype, and value\n template <typename T>\n-void Expect(BundleReader* reader, const string& key,\n+void Expect(BundleReader* reader, const std::string& key,\n             const Tensor& expected_val) {\n   // Tests for Contains().\n   EXPECT_TRUE(reader->Contains(key));\n@@ -104,7 +104,7 @@ void Expect(BundleReader* reader, const string& key,\n }\n \n template <class T>\n-void ExpectVariant(BundleReader* reader, const string& key,\n+void ExpectVariant(BundleReader* reader, const std::string& key,\n                    const Tensor& expected_t) {\n   // Tests for Contains().\n   EXPECT_TRUE(reader->Contains(key));\n@@ -137,8 +137,8 @@ void ExpectNext(BundleReader* reader, const Tensor& expected_val) {\n   test::ExpectTensorEqual<T>(val, expected_val);\n }\n \n-std::vector<string> AllTensorKeys(BundleReader* reader) {\n-  std::vector<string> ret;\n+std::vector<std::string> AllTensorKeys(BundleReader* reader) {\n+  std::vector<std::string> ret;\n   reader->Seek(kHeaderEntryKey);\n   reader->Next();\n   for (; reader->Valid(); reader->Next()) {\n@@ -149,9 +149,9 @@ std::vector<string> AllTensorKeys(BundleReader* reader) {\n \n // Writes out the metadata file of a bundle again, with the endianness marker\n // bit flipped.\n-absl::Status FlipEndiannessBit(const string& prefix) {\n+absl::Status FlipEndiannessBit(const std::string& prefix) {\n   Env* env = Env::Default();\n-  const string metadata_tmp_path = Prefix(\"some_tmp_path\");\n+  const std::string metadata_tmp_path = Prefix(\"some_tmp_path\");\n   std::unique_ptr<WritableFile> metadata_file;\n   TF_RETURN_IF_ERROR(env->NewWritableFile(metadata_tmp_path, &metadata_file));\n   // We create the builder lazily in case we run into an exception earlier, in\n@@ -161,8 +161,8 @@ absl::Status FlipEndiannessBit(const string& prefix) {\n \n   // Reads the existing metadata file, and fills the builder.\n   {\n-    const string filename = MetaFilename(prefix);\n-    uint64 file_size;\n+    const std::string filename = MetaFilename(prefix);\n+    uint64_t file_size;\n     TF_RETURN_IF_ERROR(env->GetFileSize(filename, &file_size));\n     std::unique_ptr<RandomAccessFile> file;\n     TF_RETURN_IF_ERROR(env->NewRandomAccessFile(filename, &file));\n@@ -213,7 +213,7 @@ void TestBasic() {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n+        std::vector<std::string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n     Expect<T>(&reader, \"foo_000\", Constant_2x3(T(0)));\n     Expect<T>(&reader, \"foo_001\", Constant_2x3(T(1)));\n     Expect<T>(&reader, \"foo_002\", Constant_2x3(T(2)));\n@@ -243,7 +243,7 @@ void TestBasic() {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\"}));\n+        std::vector<std::string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\"}));\n     Expect<T>(&reader, \"bar_003\", Constant_2x3(T(3)));\n     Expect<T>(&reader, \"bar_002\", Constant_2x3(T(2)));\n     Expect<T>(&reader, \"bar_001\", Constant_2x3(T(1)));\n@@ -267,8 +267,8 @@ void TestBasic() {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\",\n-                             \"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n+        std::vector<std::string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\",\n+                                  \"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n     Expect<T>(&reader, \"bar_000\", Constant_2x3(T(0)));\n     Expect<T>(&reader, \"bar_001\", Constant_2x3(T(1)));\n     Expect<T>(&reader, \"bar_002\", Constant_2x3(T(2)));\n@@ -361,8 +361,8 @@ TEST(TensorBundleTest, SwapBytes) {\n \n   // 64-bit types\n   // Cast to uint64*/int64* to make DataTypeToEnum<T> happy\n-  TestByteSwap(reinterpret_cast<const uint64*>(forward_64),\n-               reinterpret_cast<const uint64*>(swapped_64), arr_len_64);\n+  TestByteSwap(reinterpret_cast<const uint64_t*>(forward_64),\n+               reinterpret_cast<const uint64_t*>(swapped_64), arr_len_64);\n   TestByteSwap(reinterpret_cast<const int64_t*>(forward_64),\n                reinterpret_cast<const int64_t*>(swapped_64), arr_len_64);\n   TestByteSwap(reinterpret_cast<const double*>(forward_64),\n@@ -413,7 +413,7 @@ void TestEndianness() {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n+        std::vector<std::string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n     Expect<T>(&reader, \"foo_000\", Constant_2x3<T>(T(0)));\n     Expect<T>(&reader, \"foo_001\", Constant_2x3<T>(T(1)));\n     Expect<T>(&reader, \"foo_002\", Constant_2x3<T>(T(2)));\n@@ -444,7 +444,7 @@ void TestEndianness() {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\"}));\n+        std::vector<std::string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\"}));\n     Expect<T>(&reader, \"bar_003\", Constant_2x3<T>(T(3)));\n     Expect<T>(&reader, \"bar_002\", Constant_2x3<T>(T(2)));\n     Expect<T>(&reader, \"bar_001\", Constant_2x3<T>(T(1)));\n@@ -468,8 +468,8 @@ void TestEndianness() {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\",\n-                             \"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n+        std::vector<std::string>({\"bar_000\", \"bar_001\", \"bar_002\", \"bar_003\",\n+                                  \"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n     Expect<T>(&reader, \"bar_000\", Constant_2x3<T>(T(0)));\n     Expect<T>(&reader, \"bar_001\", Constant_2x3<T>(T(1)));\n     Expect<T>(&reader, \"bar_002\", Constant_2x3<T>(T(2)));\n@@ -519,7 +519,7 @@ void TestNonStandardShapes() {\n \n // Writes a bundle to disk with a bad \"version\"; checks for \"expected_error\".\n void VersionTest(const VersionDef& version, absl::string_view expected_error) {\n-  const string path = Prefix(\"version_test\");\n+  const std::string path = Prefix(\"version_test\");\n   {\n     // Prepare an empty bundle with the given version information.\n     BundleHeaderProto header;\n@@ -543,10 +543,10 @@ void VersionTest(const VersionDef& version, absl::string_view expected_error) {\n TEST(TensorBundleTest, Basic) {\n   TestBasic<float>();\n   TestBasic<double>();\n-  TestBasic<int32>();\n-  TestBasic<uint8>();\n-  TestBasic<int16>();\n-  TestBasic<int8>();\n+  TestBasic<int32_t>();\n+  TestBasic<uint8_t>();\n+  TestBasic<int16_t>();\n+  TestBasic<int8_t>();\n   TestBasic<complex64>();\n   TestBasic<complex128>();\n   TestBasic<int64_t>();\n@@ -560,10 +560,10 @@ TEST(TensorBundleTest, Basic) {\n TEST(TensorBundleTest, Endianness) {\n   TestEndianness<float>();\n   TestEndianness<double>();\n-  TestEndianness<int32>();\n-  TestEndianness<uint8>();\n-  TestEndianness<int16>();\n-  TestEndianness<int8>();\n+  TestEndianness<int32_t>();\n+  TestEndianness<uint8_t>();\n+  TestEndianness<int16_t>();\n+  TestEndianness<int8_t>();\n   TestEndianness<complex64>();\n   TestEndianness<complex128>();\n   TestEndianness<int64_t>();\n@@ -704,10 +704,10 @@ TEST(TensorBundleTest, EquivalentSliceTest) {\n TEST(TensorBundleTest, NonStandardShapes) {\n   TestNonStandardShapes<float>();\n   TestNonStandardShapes<double>();\n-  TestNonStandardShapes<int32>();\n-  TestNonStandardShapes<uint8>();\n-  TestNonStandardShapes<int16>();\n-  TestNonStandardShapes<int8>();\n+  TestNonStandardShapes<int32_t>();\n+  TestNonStandardShapes<uint8_t>();\n+  TestNonStandardShapes<int16_t>();\n+  TestNonStandardShapes<int8_t>();\n   TestNonStandardShapes<complex64>();\n   TestNonStandardShapes<complex128>();\n   TestNonStandardShapes<int64_t>();\n@@ -723,15 +723,16 @@ TEST(TensorBundleTest, StringTensorsOldFormat) {\n   // varint32s to store string lengths (we now use varint64s).\n   BundleReader reader(Env::Default(), TestdataPrefix(\"old_string_tensors/foo\"));\n   TF_ASSERT_OK(reader.status());\n-  EXPECT_EQ(AllTensorKeys(&reader),\n-            std::vector<string>({\"floats\", \"scalar\", \"string_tensor\", \"strs\"}));\n+  EXPECT_EQ(\n+      AllTensorKeys(&reader),\n+      std::vector<std::string>({\"floats\", \"scalar\", \"string_tensor\", \"strs\"}));\n \n   Expect<tstring>(&reader, \"string_tensor\",\n                   Tensor(DT_STRING, TensorShape({1})));\n   Expect<tstring>(&reader, \"scalar\", test::AsTensor<tstring>({\"hello\"}));\n   Expect<tstring>(\n       &reader, \"strs\",\n-      test::AsTensor<tstring>({\"hello\", \"\", \"x01\", string(1 << 10, 'c')}));\n+      test::AsTensor<tstring>({\"hello\", \"\", \"x01\", std::string(1 << 10, 'c')}));\n   Expect<float>(&reader, \"floats\", Constant_2x3<float>(16.18));\n }\n \n@@ -758,8 +759,8 @@ TEST(TensorBundleTest, StringTensors) {\n                             Tensor(DT_STRING, TensorShape({1}))));  // Empty.\n     TF_EXPECT_OK(writer.Add(\"scalar\", test::AsTensor<tstring>({\"hello\"})));\n     TF_EXPECT_OK(writer.Add(\n-        \"strs\",\n-        test::AsTensor<tstring>({\"hello\", \"\", \"x01\", string(1 << 25, 'c')})));\n+        \"strs\", test::AsTensor<tstring>(\n+                    {\"hello\", \"\", \"x01\", std::string(1 << 25, 'c')})));\n \n     // Requires a 64-bit length.\n     tstring* backing_string = long_string_tensor.flat<tstring>().data();\n@@ -775,15 +776,15 @@ TEST(TensorBundleTest, StringTensors) {\n     BundleReader reader(Env::Default(), Prefix(\"foo\"));\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(AllTensorKeys(&reader),\n-              std::vector<string>({\"floats\", \"long_scalar\", \"scalar\",\n-                                   \"string_tensor\", \"strs\"}));\n+              std::vector<std::string>({\"floats\", \"long_scalar\", \"scalar\",\n+                                        \"string_tensor\", \"strs\"}));\n \n     Expect<tstring>(&reader, \"string_tensor\",\n                     Tensor(DT_STRING, TensorShape({1})));\n     Expect<tstring>(&reader, \"scalar\", test::AsTensor<tstring>({\"hello\"}));\n-    Expect<tstring>(\n-        &reader, \"strs\",\n-        test::AsTensor<tstring>({\"hello\", \"\", \"x01\", string(1 << 25, 'c')}));\n+    Expect<tstring>(&reader, \"strs\",\n+                    test::AsTensor<tstring>(\n+                        {\"hello\", \"\", \"x01\", std::string(1 << 25, 'c')}));\n \n     Expect<float>(&reader, \"floats\", Constant_2x3<float>(16.18));\n \n@@ -825,10 +826,10 @@ TEST(TensorBundleTest, StringTensors) {\n class VariantObject {\n  public:\n   VariantObject() {}\n-  VariantObject(const string& metadata, int64_t value)\n+  VariantObject(const std::string& metadata, int64_t value)\n       : metadata_(metadata), value_(value) {}\n \n-  string TypeName() const { return \"TEST VariantObject\"; }\n+  std::string TypeName() const { return \"TEST VariantObject\"; }\n   void Encode(VariantTensorData* data) const {\n     data->set_type_name(TypeName());\n     data->set_metadata(metadata_);\n@@ -846,7 +847,7 @@ class VariantObject {\n   bool operator==(const VariantObject other) const {\n     return metadata_ == other.metadata_ && value_ == other.value_;\n   }\n-  string metadata_;\n+  std::string metadata_;\n   int64_t value_;\n };\n \n@@ -874,8 +875,8 @@ TEST(TensorBundleTest, VariantTensors) {\n TEST(TensorBundleTest, DirectoryStructure) {\n   Env* env = Env::Default();\n   // Writes two bundles.\n-  const std::vector<string> kBundlePrefixes = {Prefix(\"worker0\"),\n-                                               Prefix(\"worker1\")};\n+  const std::vector<std::string> kBundlePrefixes = {Prefix(\"worker0\"),\n+                                                    Prefix(\"worker1\")};\n   for (int i = 0; i < 2; ++i) {\n     BundleWriter writer(env, kBundlePrefixes[i]);\n     TF_EXPECT_OK(\n@@ -884,10 +885,10 @@ TEST(TensorBundleTest, DirectoryStructure) {\n   }\n \n   // Ensures we have the expected files.\n-  auto CheckDirFiles = [env](const string& bundle_prefix,\n-                             absl::Span<const string> expected_files) {\n+  auto CheckDirFiles = [env](const std::string& bundle_prefix,\n+                             absl::Span<const std::string> expected_files) {\n     absl::string_view dir = io::Dirname(bundle_prefix);\n-    for (const string& expected_file : expected_files) {\n+    for (const std::string& expected_file : expected_files) {\n       TF_EXPECT_OK(env->FileExists(io::JoinPath(dir, expected_file)));\n     }\n   };\n@@ -901,7 +902,7 @@ TEST(TensorBundleTest, DirectoryStructure) {\n                 {\"worker1.index\", \"worker1.data-00000-of-00001\"});\n \n   // Trivially \"merge\" one bundle to some other location (i.e., a renaming).\n-  const string kAnotherPrefix = Prefix(\"another\");\n+  const std::string kAnotherPrefix = Prefix(\"another\");\n   TF_ASSERT_OK(MergeBundles(env, {kBundlePrefixes[0]}, kAnotherPrefix));\n   CheckDirFiles(kAnotherPrefix,\n                 {\"another.index\", \"another.data-00000-of-00001\"});\n@@ -910,7 +911,7 @@ TEST(TensorBundleTest, DirectoryStructure) {\n   //   merged.index\n   //   merged.data-00000-of-00002\n   //   merged.data-00001-of-00002\n-  const string kMerged = Prefix(\"merged\");\n+  const std::string kMerged = Prefix(\"merged\");\n   TF_ASSERT_OK(\n       MergeBundles(env, {kAnotherPrefix, kBundlePrefixes[1]}, kMerged));\n   CheckDirFiles(kMerged, {\"merged.index\", \"merged.data-00000-of-00002\",\n@@ -919,8 +920,8 @@ TEST(TensorBundleTest, DirectoryStructure) {\n \n TEST(TensorBundleTest, SortForSequentialAccess) {\n   Env* env = Env::Default();\n-  const std::vector<string> kBundlePrefixes = {Prefix(\"worker0\"),\n-                                               Prefix(\"worker1\")};\n+  const std::vector<std::string> kBundlePrefixes = {Prefix(\"worker0\"),\n+                                                    Prefix(\"worker1\")};\n   BundleWriter writer0(env, kBundlePrefixes[0]);\n   for (int i = 0; i < 3; ++i) {\n     TF_EXPECT_OK(\n@@ -935,7 +936,7 @@ TEST(TensorBundleTest, SortForSequentialAccess) {\n   }\n   TF_ASSERT_OK(writer1.Finish());\n \n-  const string kMerged = Prefix(\"merged\");\n+  const std::string kMerged = Prefix(\"merged\");\n   TF_ASSERT_OK(\n       MergeBundles(env, {kBundlePrefixes[0], kBundlePrefixes[1]}, kMerged));\n \n@@ -945,10 +946,11 @@ TEST(TensorBundleTest, SortForSequentialAccess) {\n \n   BundleReader reader(env, kMerged);\n   TF_ASSERT_OK(reader.status());\n-  std::vector<string> tensor_names = {\"tensor-1-0\", \"tensor-0-1\", \"tensor-1-2\",\n-                                      \"tensor-0-0\", \"tensor-1-1\", \"tensor-0-2\"};\n-  TF_ASSERT_OK(reader.SortForSequentialAccess<string>(\n-      tensor_names, [](const string& element) { return element; }));\n+  std::vector<std::string> tensor_names = {\"tensor-1-0\", \"tensor-0-1\",\n+                                           \"tensor-1-2\", \"tensor-0-0\",\n+                                           \"tensor-1-1\", \"tensor-0-2\"};\n+  TF_ASSERT_OK(reader.SortForSequentialAccess<std::string>(\n+      tensor_names, [](const std::string& element) { return element; }));\n   EXPECT_THAT(tensor_names,\n               ElementsAre(\"tensor-0-0\", \"tensor-0-1\", \"tensor-0-2\",\n                           \"tensor-1-2\", \"tensor-1-1\", \"tensor-1-0\"));\n@@ -976,11 +978,11 @@ TEST(TensorBundleTest, Error) {\n TEST(TensorBundleTest, Checksum) {\n   // Randomly flips a byte in [pos_lhs, end of data file), or exactly byte\n   // pos_lhs if exact_pos == True.\n-  auto FlipByte = [](const string& prefix, int pos_lhs,\n+  auto FlipByte = [](const std::string& prefix, int pos_lhs,\n                      bool exact_pos = false) {\n     DCHECK_GE(pos_lhs, 0);\n-    const string& datafile = DataFilename(Prefix(prefix), 0, 1);\n-    string data;\n+    const std::string& datafile = DataFilename(Prefix(prefix), 0, 1);\n+    std::string data;\n     TF_ASSERT_OK(ReadFileToString(Env::Default(), datafile, &data));\n \n     int byte_pos = 0;\n@@ -995,8 +997,8 @@ TEST(TensorBundleTest, Checksum) {\n     TF_ASSERT_OK(WriteStringToFile(Env::Default(), datafile, data));\n   };\n   // The lookup should fail with a checksum-related message.\n-  auto ExpectLookupFails = [](const string& prefix, const string& key,\n-                              const string& expected_msg, Tensor& val) {\n+  auto ExpectLookupFails = [](const std::string& prefix, const std::string& key,\n+                              const std::string& expected_msg, Tensor& val) {\n     BundleReader reader(Env::Default(), Prefix(prefix));\n     absl::Status status = reader.Lookup(key, &val);\n     EXPECT_TRUE(absl::IsDataLoss(status));\n@@ -1048,8 +1050,8 @@ TEST(TensorBundleTest, TruncatedTensorContents) {\n   TF_ASSERT_OK(writer.Finish());\n \n   // Truncates the data file by one byte, so that we hit EOF.\n-  const string datafile = DataFilename(Prefix(\"end\"), 0, 1);\n-  string data;\n+  const std::string datafile = DataFilename(Prefix(\"end\"), 0, 1);\n+  std::string data;\n   TF_ASSERT_OK(ReadFileToString(env, datafile, &data));\n   ASSERT_TRUE(!data.empty());\n   TF_ASSERT_OK(WriteStringToFile(\n@@ -1143,7 +1145,7 @@ TEST(TensorBundleTest, LargeVariableLoadingTest) {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n+        std::vector<std::string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n     Expect<float>(&reader, \"foo_000\", Constant_100x100<float>(0));\n     Expect<float>(&reader, \"foo_001\", Constant_100x100<float>(1));\n     Expect<float>(&reader, \"foo_002\", Constant_100x100<float>(2));\n@@ -1220,7 +1222,8 @@ TEST(BundleCacheTest, ConcurrentGetFile) {\n class TensorBundleAlignmentTest : public ::testing::Test {\n  protected:\n   template <typename T>\n-  void ExpectAlignment(BundleReader* reader, const string& key, int alignment) {\n+  void ExpectAlignment(BundleReader* reader, const std::string& key,\n+                       int alignment) {\n     BundleEntryProto full_tensor_entry;\n     TF_ASSERT_OK(reader->GetBundleEntryProto(key, &full_tensor_entry));\n     EXPECT_EQ(0, full_tensor_entry.offset() % alignment);\n@@ -1243,7 +1246,7 @@ TEST_F(TensorBundleAlignmentTest, AlignmentTest) {\n     TF_ASSERT_OK(reader.status());\n     EXPECT_EQ(\n         AllTensorKeys(&reader),\n-        std::vector<string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n+        std::vector<std::string>({\"foo_000\", \"foo_001\", \"foo_002\", \"foo_003\"}));\n     Expect<float>(&reader, \"foo_000\", Constant_2x3<float>(0));\n     Expect<float>(&reader, \"foo_001\", Constant_2x3<float>(1));\n     Expect<float>(&reader, \"foo_002\", Constant_2x3<float>(2));\n@@ -1298,7 +1301,7 @@ BENCHMARK(BM_BundleAlignment)->ArgPair(4096, 1048576);\n \n static void BM_BundleWriterSmallTensor(::testing::benchmark::State& state) {\n   const int64_t bytes = state.range(0);\n-  Tensor t = Constant(static_cast<int8>('a'), TensorShape{bytes});\n+  Tensor t = Constant(static_cast<int8_t>('a'), TensorShape{bytes});\n   BundleWriter writer(Env::Default(), Prefix(\"foo\"));\n   int suffix = 0;\n   for (auto s : state) {\n@@ -1311,7 +1314,7 @@ BENCHMARK(BM_BundleWriterSmallTensor)->Range(1, 1 << 20);\n static void BM_BundleWriterLargeTensor(::testing::benchmark::State& state) {\n   const int mb = state.range(0);\n   const int64_t bytes = static_cast<int64_t>(mb) * (1 << 20);\n-  Tensor t = Constant(static_cast<int8>('a'), TensorShape{bytes});\n+  Tensor t = Constant(static_cast<int8_t>('a'), TensorShape{bytes});\n   for (auto s : state) {\n     BundleWriter writer(Env::Default(), Prefix(\"foo\"));\n     TF_CHECK_OK(writer.Add(\"big\", t));"
        }
    ],
    "stats": {
        "total": 163,
        "additions": 83,
        "deletions": 80
    }
}