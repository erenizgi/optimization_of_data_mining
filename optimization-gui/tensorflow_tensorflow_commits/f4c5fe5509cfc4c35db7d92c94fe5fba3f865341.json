{
    "author": "qukhan",
    "message": "In `FileDescriptor` tests, improve temporary file path generation.\n\nDepending on the compiler, `testing::TempDir() + __FUNCTION__` may generate and\ninvalid file name.\n\nPiperOrigin-RevId: 846275995",
    "sha": "f4c5fe5509cfc4c35db7d92c94fe5fba3f865341",
    "files": [
        {
            "sha": "9a1ce5e50aa5f220710d2d2d8f3b5585da7399dc",
            "filename": "tensorflow/lite/delegates/xnnpack/file_util_test.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f4c5fe5509cfc4c35db7d92c94fe5fba3f865341/tensorflow%2Flite%2Fdelegates%2Fxnnpack%2Ffile_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f4c5fe5509cfc4c35db7d92c94fe5fba3f865341/tensorflow%2Flite%2Fdelegates%2Fxnnpack%2Ffile_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Flite%2Fdelegates%2Fxnnpack%2Ffile_util_test.cc?ref=f4c5fe5509cfc4c35db7d92c94fe5fba3f865341",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n \n #include <fcntl.h>\n \n+#include <atomic>\n #include <string>\n #include <type_traits>\n #include <utility>\n@@ -25,6 +26,14 @@ limitations under the License.\n namespace tflite::xnnpack {\n namespace {\n \n+// Returns a path for a temporary file.\n+//\n+// Each call will return a new path.\n+std::string NewTempFilePath() {\n+  static std::atomic<int> i = 0;\n+  return testing::TempDir() + \"test_file_\" + std::to_string(i++);\n+}\n+\n TEST(FileDescriptorTest, DefaultConstructedIsInvalid) {\n   FileDescriptor fd;\n   EXPECT_FALSE(fd.IsValid());\n@@ -54,7 +63,7 @@ TEST(FileDescriptorTest, OpenNullFileFails) {\n }\n \n TEST(FileDescriptorTest, OpenWriteRewindAndReadWorks) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   FileDescriptor fd =\n       FileDescriptor::Open(tmp_file.c_str(), O_CREAT | O_TRUNC | O_RDWR, 0644);\n   ASSERT_TRUE(fd.IsValid());\n@@ -67,7 +76,7 @@ TEST(FileDescriptorTest, OpenWriteRewindAndReadWorks) {\n }\n \n TEST(FileDescriptorTest, WriteFailureReturnsFalse) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   FileDescriptor fd = FileDescriptor::Open(tmp_file.c_str(),\n                                            O_CREAT | O_TRUNC | O_RDONLY, 0644);\n   ASSERT_TRUE(fd.IsValid());\n@@ -76,7 +85,7 @@ TEST(FileDescriptorTest, WriteFailureReturnsFalse) {\n }\n \n TEST(FileDescriptorTest, ReadFailureReturnsFalse) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   FileDescriptor fd = FileDescriptor::Open(tmp_file.c_str(),\n                                            O_CREAT | O_TRUNC | O_WRONLY, 0644);\n   ASSERT_TRUE(fd.IsValid());\n@@ -85,28 +94,28 @@ TEST(FileDescriptorTest, ReadFailureReturnsFalse) {\n }\n \n TEST(FileDescriptorTest, IsFileEmptyReturnTrueForAnEmptyFileThatExists) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   FileDescriptor fd = FileDescriptor::Open(tmp_file.c_str(),\n                                            O_CREAT | O_TRUNC | O_WRONLY, 0644);\n   fd.Close();\n   EXPECT_TRUE(IsFileEmpty(tmp_file.c_str(), FileDescriptor()));\n }\n \n TEST(FileDescriptorTest, IsFileEmptyReturnTrueForAnNonExistingFile) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   EXPECT_TRUE(IsFileEmpty(tmp_file.c_str(), FileDescriptor()));\n }\n \n TEST(FileDescriptorTest,\n      IsFileEmptyReturnTrueForAnNonExistingFileWithFileDescriptor) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   FileDescriptor fd = FileDescriptor::Open(tmp_file.c_str(),\n                                            O_CREAT | O_TRUNC | O_WRONLY, 0644);\n   EXPECT_TRUE(IsFileEmpty(\"asdfasdf\", FileDescriptor()));\n }\n \n TEST(FileDescriptorTest, IsFileEmptyReturnFalseForAFileThatHasContents) {\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n+  const std::string tmp_file = NewTempFilePath();\n   FileDescriptor fd = FileDescriptor::Open(tmp_file.c_str(),\n                                            O_CREAT | O_TRUNC | O_WRONLY, 0644);\n   const std::string src_data = \"The quick brown fox jumps over the lazy dog.\";\n@@ -117,8 +126,8 @@ TEST(FileDescriptorTest, IsFileEmptyReturnFalseForAFileThatHasContents) {\n TEST(FileDescriptorTest, IsFileEmptyPrioritizesTheFileDescriptor) {\n   // We open 2 files, put some data only in one and then pass the file name of\n   // the one that has data and the file descriptor of the empty one.\n-  const std::string tmp_file = testing::TempDir() + __FUNCTION__;\n-  const std::string tmp_file2 = testing::TempDir() + __FUNCTION__ + \"2\";\n+  const std::string tmp_file = NewTempFilePath();\n+  const std::string tmp_file2 = NewTempFilePath();\n   FileDescriptor fd = FileDescriptor::Open(tmp_file.c_str(),\n                                            O_CREAT | O_TRUNC | O_WRONLY, 0644);\n   FileDescriptor fd2 = FileDescriptor::Open(tmp_file2.c_str(),"
        }
    ],
    "stats": {
        "total": 27,
        "additions": 18,
        "deletions": 9
    }
}