{
    "author": "nvgrw",
    "message": "Migrate conditional_test to PjRt.\n\nPiperOrigin-RevId: 847911726",
    "sha": "dd10786acdfd2875771b3e3a37fd80f22f4a214b",
    "files": [
        {
            "sha": "a53c743d0abd52b67c9805b7b24b404b2f018ede",
            "filename": "third_party/xla/xla/tests/BUILD",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dd10786acdfd2875771b3e3a37fd80f22f4a214b/third_party%2Fxla%2Fxla%2Ftests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dd10786acdfd2875771b3e3a37fd80f22f4a214b/third_party%2Fxla%2Fxla%2Ftests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2FBUILD?ref=dd10786acdfd2875771b3e3a37fd80f22f4a214b",
            "patch": "@@ -801,9 +801,12 @@ xla_test(\n     name = \"conditional_test\",\n     srcs = [\"conditional_test.cc\"],\n     shard_count = 2,\n+    tags = [\"test_migrated_to_hlo_runner_pjrt\"],\n     deps = [\n         \":client_library_test_runner_mixin\",\n-        \":hlo_test_base\",\n+        \":hlo_pjrt_interpreter_reference_mixin\",\n+        \":hlo_pjrt_test_base\",\n+        \":literal_test_util\",\n         \":xla_internal_test_main\",  # fixdeps: keep\n         \"//xla:array2d\",\n         \"//xla:error_spec\",\n@@ -812,11 +815,14 @@ xla_test(\n         \"//xla:shape_util\",\n         \"//xla/hlo/builder:xla_builder\",\n         \"//xla/hlo/builder:xla_computation\",\n+        \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:test_helpers\",\n+        \"//xla/service:hlo_runner_interface\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings\",\n     ],\n )"
        },
        {
            "sha": "c293e12186e7d4022644b11d1be21dfa82f50405",
            "filename": "third_party/xla/xla/tests/conditional_test.cc",
            "status": "modified",
            "additions": 210,
            "deletions": 154,
            "changes": 364,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dd10786acdfd2875771b3e3a37fd80f22f4a214b/third_party%2Fxla%2Fxla%2Ftests%2Fconditional_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dd10786acdfd2875771b3e3a37fd80f22f4a214b/third_party%2Fxla%2Fxla%2Ftests%2Fconditional_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fconditional_test.cc?ref=dd10786acdfd2875771b3e3a37fd80f22f4a214b",
            "patch": "@@ -13,24 +13,31 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n+#include <array>\n #include <cstdint>\n+#include <memory>\n #include <string>\n #include <utility>\n #include <vector>\n \n #include \"absl/log/check.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"xla/array2d.h\"\n #include \"xla/error_spec.h\"\n #include \"xla/hlo/builder/xla_builder.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/testlib/test_helpers.h\"\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n+#include \"xla/service/hlo_runner_interface.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tests/client_library_test_runner_mixin.h\"\n-#include \"xla/tests/hlo_test_base.h\"\n+#include \"xla/tests/hlo_pjrt_interpreter_reference_mixin.h\"\n+#include \"xla/tests/hlo_pjrt_test_base.h\"\n+#include \"xla/tests/literal_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n@@ -39,12 +46,17 @@ limitations under the License.\n namespace xla {\n namespace {\n \n+using ::absl_testing::IsOkAndHolds;\n+\n constexpr ErrorSpec kErrorSpec{0.001};\n \n-class ConditionalOpTest : public ClientLibraryTestRunnerMixin<HloTestBase> {\n+class ConditionalOpTest\n+    : public ClientLibraryTestRunnerMixin<\n+          HloPjRtInterpreterReferenceMixin<HloPjRtTestBase>> {\n  protected:\n   void SetUp() override {\n-    ClientLibraryTestRunnerMixin<HloTestBase>::SetUp();\n+    ClientLibraryTestRunnerMixin<\n+        HloPjRtInterpreterReferenceMixin<HloPjRtTestBase>>::SetUp();\n     mutable_debug_options()->set_xla_test_add_command_buffer_mode(true);\n   }\n \n@@ -212,31 +224,37 @@ TEST_F(ConditionalOpTest, Parameters0) {\n \n // Test branch computations that do not take any parameters.\n TEST_P(CaseOpTest, Parameters0) {\n-  int num_branches = GetParam();\n+  const int num_branches = GetParam();\n+\n+  XlaBuilder builder(TestName());\n+  const XlaOp branch_index =\n+      Parameter(&builder, 0, ShapeUtil::MakeShape(S32, {}), \"branch_index_arg\");\n+  auto operand = Tuple(&builder, {});\n+  std::vector<XlaOp> operands(num_branches, operand);\n+  std::vector<XlaComputation> branches;\n+  branches.reserve(num_branches);\n+  std::vector<const XlaComputation*> branches_p(num_branches);\n+  for (int i = 0; i < num_branches; ++i) {\n+    branches.push_back(CreateR0ConstantComputation(static_cast<float>(i) * 10));\n+    branches_p[i] = &branches[i];\n+  }\n+  Conditional(branch_index, branches_p, operands);\n+\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       HloModuleFromXlaBuilder(&builder, execution_options()));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<OpaqueExecutable> executable,\n+                       test_runner().CreateExecutable(std::move(module),\n+                                                      /*run_hlo_passes=*/true));\n   for (int bi = -1; bi <= num_branches; ++bi) {\n     SCOPED_TRACE(bi);\n-    XlaBuilder builder(TestName());\n-    XlaOp branch_index;\n-    auto branch_index_arg = CreateR0Parameter<int32_t>(\n-        bi, 0, \"branch_index_arg\", &builder, &branch_index);\n-    auto operand = Tuple(&builder, {});\n-\n-    std::vector<XlaOp> operands(num_branches, operand);\n-    std::vector<XlaComputation> branches;\n-    branches.reserve(num_branches);\n-    std::vector<const XlaComputation*> branches_p(num_branches);\n-    for (int i = 0; i < num_branches; ++i) {\n-      branches.emplace_back(\n-          CreateR0ConstantComputation(static_cast<float>(i) * 10));\n-      branches_p[i] = &branches[i];\n-    }\n-    Conditional(branch_index, branches_p, operands);\n-\n-    float expected = 10 * static_cast<float>((bi < 0 || bi >= num_branches)\n-                                                 ? num_branches - 1\n-                                                 : bi);\n-    ComputeAndCompareR0<float>(&builder, expected, {&branch_index_arg},\n-                               kErrorSpec);\n+    const Literal expected = LiteralUtil::CreateR0<float>(\n+        10 * static_cast<float>(\n+                 (bi < 0 || bi >= num_branches) ? num_branches - 1 : bi));\n+    const Literal branch_index_arg = LiteralUtil::CreateR0<int32_t>(bi);\n+    ASSERT_OK_AND_ASSIGN(const Literal result,\n+                         test_runner().ExecuteWithExecutable(\n+                             executable.get(), {&branch_index_arg}));\n+    EXPECT_TRUE(LiteralTestUtil::Near(expected, result, kErrorSpec));\n   }\n }\n \n@@ -255,40 +273,45 @@ TEST_F(ConditionalOpTest, Parameters1) {\n \n // Test branch computations that take in 1 parameter.\n TEST_P(CaseOpTest, Parameters1) {\n-  int num_branches = GetParam();\n+  const int num_branches = GetParam();\n+\n+  XlaBuilder builder(TestName());\n+  const XlaOp branch_index =\n+      Parameter(&builder, 0, ShapeUtil::MakeShape(S32, {}), \"branch_index_arg\");\n+  std::vector<XlaComputation> branches;\n+  branches.reserve(num_branches);\n+  std::vector<const XlaComputation*> branches_p(num_branches);\n+  std::vector<XlaOp> operands;\n+  operands.reserve(num_branches);\n+  std::vector<Literal> expecteds(num_branches);\n+  for (int i = 0; i < num_branches; ++i) {\n+    std::unique_ptr<XlaBuilder> sb =\n+        builder.CreateSubBuilder(absl::StrCat(\"branch_\", i));\n+    Add(ConstantR0<float>(sb.get(), static_cast<float>(i)),\n+        Parameter(sb.get(), 0, r0f32_, \"p0\"));\n+    branches.push_back(sb->BuildAndNoteError());\n+    branches_p[i] = &branches[i];\n+    const float fi = static_cast<float>(i);\n+    operands.push_back(ConstantR0<float>(&builder, 10 * fi + 7));\n+    expecteds[i] = LiteralUtil::CreateR0<float>(10 * fi + 7 + fi);\n+  }\n+  Conditional(branch_index, branches_p, operands);\n+\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       HloModuleFromXlaBuilder(&builder, execution_options()));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<OpaqueExecutable> executable,\n+                       test_runner().CreateExecutable(std::move(module),\n+                                                      /*run_hlo_passes=*/true));\n   for (int bi = -1; bi <= num_branches; ++bi) {\n     SCOPED_TRACE(bi);\n-    XlaBuilder builder(TestName());\n-    XlaOp branch_index;\n-    auto branch_index_arg = CreateR0Parameter<int32_t>(\n-        bi, 0, \"branch_index_arg\", &builder, &branch_index);\n-\n-    auto make_branch = [&builder, this](int i) {\n-      auto sb = builder.CreateSubBuilder(absl::StrCat(\"branch_\", i));\n-      Add(ConstantR0<float>(sb.get(), static_cast<float>(i)),\n-          Parameter(sb.get(), 0, r0f32_, \"p0\"));\n-      return sb->BuildAndNoteError();\n-    };\n-    std::vector<XlaComputation> branches;\n-    branches.reserve(num_branches);\n-    std::vector<const XlaComputation*> branches_p(num_branches);\n-    std::vector<XlaOp> operands;\n-    operands.reserve(num_branches);\n-    std::vector<float> expecteds(num_branches);\n-    for (int i = 0; i < num_branches; ++i) {\n-      branches.emplace_back(make_branch(i));\n-      branches_p[i] = &branches[i];\n-      auto fi = static_cast<float>(i);\n-      operands.emplace_back(ConstantR0<float>(&builder, 10 * fi + 7));\n-      expecteds[i] = 10 * fi + 7 + fi;\n-    }\n-\n-    Conditional(branch_index, branches_p, operands);\n-    float expected = (bi < 0 || bi >= num_branches)\n-                         ? expecteds[num_branches - 1]\n-                         : expecteds[bi];\n-    ComputeAndCompareR0<float>(&builder, expected, {&branch_index_arg},\n-                               kErrorSpec);\n+    const Literal& expected = (bi < 0 || bi >= num_branches)\n+                                  ? expecteds[num_branches - 1]\n+                                  : expecteds[bi];\n+    const Literal branch_index_arg = LiteralUtil::CreateR0<int32_t>(bi);\n+    ASSERT_OK_AND_ASSIGN(const Literal result,\n+                         test_runner().ExecuteWithExecutable(\n+                             executable.get(), {&branch_index_arg}));\n+    EXPECT_TRUE(LiteralTestUtil::Near(expected, result, kErrorSpec));\n   }\n }\n \n@@ -428,38 +451,46 @@ TEST_F(ConditionalOpTest, Parameters2ArrayTrueBranch) {\n \n // Test branch computations that take in 2 array parameters.\n TEST_P(CaseOpTest, Parameters2Array) {\n-  int num_branches = GetParam();\n+  const int num_branches = GetParam();\n+\n+  XlaBuilder builder(TestName());\n+  const XlaOp branch_index =\n+      Parameter(&builder, 0, ShapeUtil::MakeShape(S32, {}), \"branch_index_arg\");\n+  const XlaOp operand1 = ConstantR1<float>(&builder, {24.0f, 56.0f});\n+  const XlaOp operand2 = ConstantR1<float>(&builder, {10.0f, 11.0f});\n+  const XlaOp operands = Tuple(&builder, {operand1, operand2});\n+  std::vector<XlaComputation> branches;\n+  branches.reserve(num_branches);\n+  std::vector<const XlaComputation*> branches_p(num_branches);\n+  for (int i = 0; i < num_branches; ++i) {\n+    std::unique_ptr<XlaBuilder> sb =\n+        builder.CreateSubBuilder(absl::StrCat(\"branch_\", i));\n+    const XlaOp p = Parameter(sb.get(), 0, tuple_2_r1s2f32_, \"p0\");\n+    Add(Mul(ConstantR0<float>(sb.get(), static_cast<float>(i)),\n+            GetTupleElement(p, 0)),\n+        GetTupleElement(p, 1));\n+    branches.push_back(sb->BuildAndNoteError());\n+    branches_p[i] = &branches[i];\n+  }\n+  Conditional(branch_index, branches_p,\n+              std::vector<XlaOp>(num_branches, operands));\n+\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       HloModuleFromXlaBuilder(&builder, execution_options()));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<OpaqueExecutable> executable,\n+                       test_runner().CreateExecutable(std::move(module),\n+                                                      /*run_hlo_passes=*/true));\n   for (int bi = -1; bi <= num_branches; ++bi) {\n     SCOPED_TRACE(bi);\n-    XlaBuilder builder(TestName());\n-    XlaOp branch_index;\n-    auto branch_index_arg =\n-        CreateR0Parameter<int32_t>(bi, 0, \"pred\", &builder, &branch_index);\n-    auto operand1 = ConstantR1<float>(&builder, {24.0f, 56.0f});\n-    auto operand2 = ConstantR1<float>(&builder, {10.0f, 11.0f});\n-    auto operands = Tuple(&builder, {operand1, operand2});\n-    auto make_branch = [&builder, this](int i) {\n-      auto sb = builder.CreateSubBuilder(absl::StrCat(\"branch_\", i));\n-      auto p = Parameter(sb.get(), 0, tuple_2_r1s2f32_, \"p0\");\n-      Add(Mul(ConstantR0<float>(sb.get(), static_cast<float>(i)),\n-              GetTupleElement(p, 0)),\n-          GetTupleElement(p, 1));\n-      return sb->BuildAndNoteError();\n-    };\n-    std::vector<XlaComputation> branches;\n-    branches.reserve(num_branches);\n-    std::vector<const XlaComputation*> branches_p(num_branches);\n-    for (int i = 0; i < num_branches; ++i) {\n-      branches.emplace_back(make_branch(i));\n-      branches_p[i] = &branches[i];\n-    }\n-    Conditional(branch_index, branches_p,\n-                std::vector<XlaOp>(num_branches, operands));\n-    auto modified_bi = static_cast<float>(\n+    const Literal branch_index_arg = LiteralUtil::CreateR0<int32_t>(bi);\n+    const float modified_bi = static_cast<float>(\n         (bi < 0 || bi >= num_branches) ? num_branches - 1 : bi);\n-    ComputeAndCompareR1<float>(\n-        &builder, {24.0f * modified_bi + 10, 56.0f * modified_bi + 11},\n-        {&branch_index_arg}, kErrorSpec);\n+    const Literal expected = LiteralUtil::CreateR1<float>(\n+        {24.0f * modified_bi + 10, 56.0f * modified_bi + 11});\n+    ASSERT_OK_AND_ASSIGN(const Literal result,\n+                         test_runner().ExecuteWithExecutable(\n+                             executable.get(), {&branch_index_arg}));\n+    EXPECT_TRUE(LiteralTestUtil::Near(expected, result, kErrorSpec));\n   }\n }\n \n@@ -561,48 +592,53 @@ TEST_F(ConditionalOpTest, ReturnNestedTuple) {\n   XlaBuilder true_builder(TestName() + \".true\");\n   {\n     Parameter(&true_builder, 0, empty_tuple_, \"tuple\");\n-    auto true_constant1 = ConstantR0<float>(&true_builder, 12.2f);\n-    auto true_constant2 = ConstantR1<float>(&true_builder, {12.8f, 14.6f});\n-    auto true_constant3 = ConstantR1<float>(&true_builder, {25.4f, 29.8f});\n-    auto true_constant4 = ConstantR0<float>(&true_builder, 35.6f);\n+    const XlaOp true_constant1 = ConstantR0<float>(&true_builder, 12.2f);\n+    const XlaOp true_constant2 =\n+        ConstantR1<float>(&true_builder, {12.8f, 14.6f});\n+    const XlaOp true_constant3 =\n+        ConstantR1<float>(&true_builder, {25.4f, 29.8f});\n+    const XlaOp true_constant4 = ConstantR0<float>(&true_builder, 35.6f);\n     Tuple(&true_builder,\n           {Tuple(&true_builder, {true_constant1, true_constant2}),\n            Tuple(&true_builder, {true_constant3, true_constant4})});\n   }\n-  auto true_builder_result = true_builder.Build();\n-  EXPECT_IS_OK(true_builder_result.status());\n+  ASSERT_OK_AND_ASSIGN(XlaComputation true_comp, true_builder.Build());\n \n   XlaBuilder false_builder(TestName() + \".false\");\n   {\n     Parameter(&false_builder, 0, empty_tuple_, \"tuple\");\n-    auto false_constant1 = ConstantR0<float>(&false_builder, 46.6f);\n-    auto false_constant2 = ConstantR1<float>(&false_builder, {54.4f, 58.4f});\n-    auto false_constant3 = ConstantR1<float>(&false_builder, {62.1f, 67.4f});\n-    auto false_constant4 = ConstantR0<float>(&false_builder, 9.3f);\n+    const XlaOp false_constant1 = ConstantR0<float>(&false_builder, 46.6f);\n+    const XlaOp false_constant2 =\n+        ConstantR1<float>(&false_builder, {54.4f, 58.4f});\n+    const XlaOp false_constant3 =\n+        ConstantR1<float>(&false_builder, {62.1f, 67.4f});\n+    const XlaOp false_constant4 = ConstantR0<float>(&false_builder, 9.3f);\n     Tuple(&false_builder,\n           {Tuple(&false_builder, {false_constant1, false_constant2}),\n            Tuple(&false_builder, {false_constant3, false_constant4})});\n   }\n-  auto false_builder_result = false_builder.Build();\n-  EXPECT_IS_OK(false_builder_result.status());\n+  ASSERT_OK_AND_ASSIGN(XlaComputation false_comp, false_builder.Build());\n \n   XlaBuilder builder(TestName());\n   XlaOp pred;\n-  auto pred_arg = CreateR0Parameter<bool>(false, 0, \"pred\", &builder, &pred);\n-  auto operands = Tuple(&builder, {});\n-  Conditional(pred, operands, std::move(true_builder_result).value(), operands,\n-              std::move(false_builder_result).value());\n+  const Literal pred_arg =\n+      CreateR0Parameter<bool>(false, 0, \"pred\", &builder, &pred);\n+  const XlaOp operands = Tuple(&builder, {});\n+  const XlaOp result = Conditional(pred, operands, std::move(true_comp),\n+                                   operands, std::move(false_comp));\n+  // Flatten nested tuple for PjRt.\n+  const XlaOp e0 = GetTupleElement(result, 0);\n+  const XlaOp e1 = GetTupleElement(result, 1);\n+  Tuple(&builder, {GetTupleElement(e0, 0), GetTupleElement(e0, 1),\n+                   GetTupleElement(e1, 0), GetTupleElement(e1, 1)});\n \n-  ComputeAndCompareLiteral(\n-      &builder,\n-      LiteralUtil::MakeTupleFromSlices(\n-          {LiteralUtil::MakeTupleFromSlices(\n-               {LiteralUtil::CreateR0<float>(46.6f),\n-                LiteralUtil::CreateR1<float>({54.4f, 58.4f})}),\n-           LiteralUtil::MakeTupleFromSlices(\n-               {LiteralUtil::CreateR1<float>({62.1f, 67.4f}),\n-                LiteralUtil::CreateR0<float>(9.3f)})}),\n-      {&pred_arg}, kErrorSpec);\n+  ComputeAndCompareLiteral(&builder,\n+                           LiteralUtil::MakeTupleFromSlices(\n+                               {LiteralUtil::CreateR0<float>(46.6f),\n+                                LiteralUtil::CreateR1<float>({54.4f, 58.4f}),\n+                                LiteralUtil::CreateR1<float>({62.1f, 67.4f}),\n+                                LiteralUtil::CreateR0<float>(9.3f)}),\n+                           {&pred_arg}, kErrorSpec);\n }\n \n // Test conditional that takes in scalar operands in the form of external\n@@ -751,21 +787,31 @@ TEST_F(ConditionalOpTest, SwappedInputsInSequentialConditionals) {\n     main = builder.Build().value();\n   }\n \n-  auto test_swap = [&](float a, float b) {\n-    XlaBuilder builder(TestName());\n-    XlaOp x, y;\n-    auto x_arg = CreateR0Parameter<float>(a, 0, \"x\", &builder, &x);\n-    auto y_arg = CreateR0Parameter<float>(b, 1, \"y\", &builder, &y);\n-    auto tuple_operand = Tuple(&builder, {x, y});\n-    Call(&builder, main, {tuple_operand});\n-    ComputeAndCompareLiteral(\n-        &builder,\n-        LiteralUtil::MakeTupleFromSlices(\n-            {LiteralUtil::CreateR0<float>(a), LiteralUtil::CreateR0<float>(b)}),\n-        {&x_arg, &y_arg}, kErrorSpec);\n+  XlaBuilder builder(TestName());\n+  const XlaOp x = Parameter(&builder, 0, r0f32_, \"x\");\n+  const XlaOp y = Parameter(&builder, 1, r0f32_, \"y\");\n+  const XlaOp tuple_operand = Tuple(&builder, {x, y});\n+  Call(&builder, main, {tuple_operand});\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       HloModuleFromXlaBuilder(&builder, execution_options()));\n+  ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<OpaqueExecutable> executable,\n+      CreateExecutable(std::move(module), /*run_hlo_passes=*/true));\n+\n+  const auto test_swap =\n+      [&, this](float a,\n+                float b) -> absl::StatusOr<::testing::AssertionResult> {\n+    const Literal x_arg = LiteralUtil::CreateR0<float>(a);\n+    const Literal y_arg = LiteralUtil::CreateR0<float>(b);\n+    const Literal expected = LiteralUtil::MakeTupleFromSlices(\n+        {LiteralUtil::CreateR0<float>(a), LiteralUtil::CreateR0<float>(b)});\n+    ASSIGN_OR_RETURN(const Literal result,\n+                     test_runner().ExecuteWithExecutable(executable.get(),\n+                                                         {&x_arg, &y_arg}));\n+    return LiteralTestUtil::Near(expected, result, kErrorSpec);\n   };\n-  test_swap(3.11f, 9.4f);\n-  test_swap(11.24f, 5.55f);\n+  EXPECT_THAT(test_swap(3.11f, 9.4f), IsOkAndHolds(true));\n+  EXPECT_THAT(test_swap(11.24f, 5.55f), IsOkAndHolds(true));\n }\n \n // Test conditional that duplicates tuple elements in the then and else\n@@ -792,35 +838,45 @@ TEST_F(ConditionalOpTest, DuplicateElementsConditional) {\n     else_comp = builder.Build().value();\n   }\n \n-  {\n-    // Pred is true case.\n-    std::vector<Literal> args;\n-    args.push_back(LiteralUtil::MakeTupleFromSlices(\n-        {LiteralUtil::CreateR0<int32_t>(123),\n-         LiteralUtil::CreateR0<int32_t>(-42)}));\n-    args.push_back(LiteralUtil::CreateR0<bool>(true));\n-    XlaBuilder builder(TestName() + \".main\");\n-    auto p = Parameter(&builder, 0, tuple2, \"p0\");\n-    auto p_pred = Parameter(&builder, 1, ShapeUtil::MakeShape(PRED, {}), \"p1\");\n-    Conditional(p_pred, p, then_comp, p, else_comp);\n-    ComputeAndCompare(&builder, {&args[0], &args[1]});\n-  }\n-  {\n-    // Pred is false case.\n-    std::vector<Literal> args;\n-    args.push_back(LiteralUtil::MakeTupleFromSlices(\n-        {LiteralUtil::CreateR0<int32_t>(123),\n-         LiteralUtil::CreateR0<int32_t>(-42)}));\n-    args.push_back(LiteralUtil::CreateR0<bool>(false));\n-    XlaBuilder builder(TestName() + \".main\");\n-    auto p = Parameter(&builder, 0, tuple2, \"p0\");\n-    auto p_pred = Parameter(&builder, 1, ShapeUtil::MakeShape(PRED, {}), \"p1\");\n-    Conditional(p_pred, p, then_comp, p, else_comp);\n-    ComputeAndCompare(&builder, {&args[0], &args[1]});\n-  }\n+  XlaBuilder builder(TestName() + \".main\");\n+  auto p0 = Parameter(&builder, 0, scalar, \"p0.0\");\n+  auto p1 = Parameter(&builder, 1, scalar, \"p0.1\");\n+  auto p = Tuple(&builder, {p0, p1});\n+  auto p_pred = Parameter(&builder, 2, ShapeUtil::MakeShape(PRED, {}), \"p1\");\n+  Conditional(p_pred, p, then_comp, p, else_comp);\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       HloModuleFromXlaBuilder(&builder, execution_options()));\n+\n+  const std::array<Literal, 4> args = {\n+      LiteralUtil::CreateR0<int32_t>(123), LiteralUtil::CreateR0<int32_t>(-42),\n+      LiteralUtil::CreateR0<bool>(true), LiteralUtil::CreateR0<bool>(false)};\n+  const std::array<const Literal*, 3> true_args = {&args[0], &args[1],\n+                                                   &args[2]};\n+  const std::array<const Literal*, 3> false_args = {&args[0], &args[1],\n+                                                    &args[3]};\n+\n+  // Compute reference values. Because this test is not parameterized, we need\n+  // to manually invoke the test runner and reference runner.\n+  ASSERT_OK_AND_ASSIGN(Literal true_reference,\n+                       reference_runner().Execute(module->Clone(), true_args,\n+                                                  /*run_hlo_passes=*/true));\n+  ASSERT_OK_AND_ASSIGN(Literal false_reference,\n+                       reference_runner().Execute(module->Clone(), false_args,\n+                                                  /*run_hlo_passes=*/true));\n+\n+  ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<OpaqueExecutable> executable,\n+      CreateExecutable(std::move(module), /*run_hlo_passes=*/true));\n+  ASSERT_OK_AND_ASSIGN(Literal true_result, test_runner().ExecuteWithExecutable(\n+                                                executable.get(), true_args));\n+  ASSERT_OK_AND_ASSIGN(\n+      Literal false_result,\n+      test_runner().ExecuteWithExecutable(executable.get(), false_args));\n+  EXPECT_TRUE(LiteralTestUtil::Equal(true_reference, true_result));\n+  EXPECT_TRUE(LiteralTestUtil::Equal(false_reference, false_result));\n }\n \n-using ConditionalOpHloTest = HloTestBase;\n+using ConditionalOpHloTest = HloPjRtTestBase;\n \n TEST_F(ConditionalOpHloTest, ParallelExecution) {\n   // Test conditional works when an executable is executed in parallel."
        }
    ],
    "stats": {
        "total": 372,
        "additions": 217,
        "deletions": 155
    }
}