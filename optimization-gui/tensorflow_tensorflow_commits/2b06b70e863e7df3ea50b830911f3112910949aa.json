{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809713653",
    "sha": "2b06b70e863e7df3ea50b830911f3112910949aa",
    "files": [
        {
            "sha": "98768af3c1c9672713826d5f1514bc3479bd7332",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/preemption/preemption_notifier.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b06b70e863e7df3ea50b830911f3112910949aa/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fpreemption%2Fpreemption_notifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b06b70e863e7df3ea50b830911f3112910949aa/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fpreemption%2Fpreemption_notifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fpreemption%2Fpreemption_notifier.cc?ref=2b06b70e863e7df3ea50b830911f3112910949aa",
            "patch": "@@ -107,7 +107,7 @@ absl::StatusOr<absl::Time> PreemptionNotifier::WillBePreemptedAt() {\n }\n \n void PreemptionNotifier::WillBePreemptedAtAsync(PreemptTimeCallback callback) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   if (death_time_ == kUnsetDeathTime) {\n     // Did not receive preemption notice yet.\n     callbacks_.push_back(std::move(callback));\n@@ -119,7 +119,7 @@ void PreemptionNotifier::WillBePreemptedAtAsync(PreemptTimeCallback callback) {\n \n void PreemptionNotifier::NotifyRegisteredListeners(\n     absl::StatusOr<absl::Time> death_time) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   if (death_time.ok()) {\n     death_time_ = death_time.value();\n   }"
        },
        {
            "sha": "f5a0a0a4f3313af28233afa0f730ea5c5a8f935e",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/preemption/preemption_sync_manager.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b06b70e863e7df3ea50b830911f3112910949aa/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fpreemption%2Fpreemption_sync_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b06b70e863e7df3ea50b830911f3112910949aa/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fpreemption%2Fpreemption_sync_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fpreemption%2Fpreemption_sync_manager.cc?ref=2b06b70e863e7df3ea50b830911f3112910949aa",
            "patch": "@@ -92,7 +92,7 @@ absl::Status PreemptionSyncManager::Initialize(\n     CoordinationServiceAgent* agent,\n     std::unique_ptr<PreemptionNotifier> notifier) {\n   {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     CHECK(!shut_down_);\n   }\n \n@@ -179,7 +179,7 @@ absl::Status PreemptionSyncManager::Initialize(\n \n         // Trigger protocol in a separate thread: compute max call counter.\n         {\n-          absl::MutexLock l(&mu_);\n+          absl::MutexLock l(mu_);\n           if (shut_down_) {\n             return;\n           }\n@@ -194,7 +194,7 @@ absl::Status PreemptionSyncManager::Initialize(\n }\n \n void PreemptionSyncManager::Shutdown() {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   if (shut_down_) {\n     LOG(INFO) << \"PreemptionSyncManager already shut down\";\n     return;\n@@ -234,7 +234,7 @@ void PreemptionSyncManager::ComputeSyncCallCounter(absl::Time death_time) {\n   // function exits, implying that we have decided on a new\n   // `preemption_sync_counter_` or the protocol failed. This ensures correctness\n   // of the preemption sync protocol.\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   const absl::Status notified_status = agent_->InsertKeyValue(\n       current_call_counter_key_, std::to_string(call_counter_));\n   if (!notified_status.ok()) {\n@@ -306,7 +306,7 @@ bool PreemptionSyncManager::ReachedSyncPoint(int step_counter) {\n   // is ongoing , this method will be blocked until it acquires the lock. This\n   // prevents updates to `call_counter_` while `preemption_sync_counter_` is\n   // being computed, which ensures correctness of the preemption sync protocol.\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   CHECK(!shut_down_);\n   // Track current call.\n   call_counter_ = step_counter;"
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}