{
    "author": "bhatuzdaname",
    "message": "Support for tracking GPU peak memory in presumbit/postsubmit hlo runs.\n\nPiperOrigin-RevId: 799627273",
    "sha": "5a66337d60b3f75a37cfc06fb80841ac4b2c2187",
    "files": [
        {
            "sha": "635a0bffc39ef7b0249bafd47068c48cd8f8b7aa",
            "filename": "third_party/xla/.github/workflows/benchmarks/compare_with_baseline.py",
            "status": "modified",
            "additions": 54,
            "deletions": 24,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5a66337d60b3f75a37cfc06fb80841ac4b2c2187/third_party%2Fxla%2F.github%2Fworkflows%2Fbenchmarks%2Fcompare_with_baseline.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5a66337d60b3f75a37cfc06fb80841ac4b2c2187/third_party%2Fxla%2F.github%2Fworkflows%2Fbenchmarks%2Fcompare_with_baseline.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2F.github%2Fworkflows%2Fbenchmarks%2Fcompare_with_baseline.py?ref=5a66337d60b3f75a37cfc06fb80841ac4b2c2187",
            "patch": "@@ -95,14 +95,23 @@ def compare_metrics(\n   # {\n   #   ...,\n   #   \"metrics\": {\n-  #     \"GPU_DEVICE_TIME\": { \"value_ms\": 150.0, \"unit\": \"ms\", ... },\n-  #     \"GPU_DEVICE_MEMCPY_TIME\": { \"value_ms\": 1.2, \"unit\": \"ms\", ... },\n+  #     \"GPU_DEVICE_TIME\": { \"value\": 150.0, \"unit\": \"ms\", ... },\n+  #     \"GPU_DEVICE_MEMCPY_TIME\": { \"value\": 1.2, \"unit\": \"ms\", ... },\n+  #     \"PEAK_GPU_MEMORY\": { \"value\": 12.45, \"unit\": \"GB\", ... },\n   #     ...\n   #   }\n   # }\n   # If your actual results.json structure is different, you MUST adapt this\n   # section.\n   actual_metrics_container = results_data.get(\"metrics\")\n+  metric_to_baseline_key = {\n+      \"WALL_TIME\": \"baseline_ms\",\n+      \"GPU_DEVICE_TIME\": \"baseline_ms\",\n+      \"GPU_DEVICE_MEMCPY_TIME\": \"baseline_ms\",\n+      \"CPU_TIME\": \"baseline_ms\",\n+      \"PEAK_CPU_MEMORY\": \"baseline_gb\",\n+      \"PEAK_GPU_MEMORY\": \"baseline_gb\",\n+  }\n \n   if not actual_metrics_container or not isinstance(\n       actual_metrics_container, dict\n@@ -119,33 +128,44 @@ def compare_metrics(\n     sys.exit(0)  # Exit cleanly if no metrics to compare\n \n   for metric_name, baseline_info in config_baselines.items():\n-    if not isinstance(baseline_info, dict) or not all(\n-        key in baseline_info for key in [\"baseline_ms\", \"threshold\"]\n+    if (\n+        not isinstance(baseline_info, dict)\n+        or \"threshold\" not in baseline_info\n+        or not {\"baseline_ms\", \"baseline_gb\"}.intersection(baseline_info.keys())\n     ):\n       summary_messages.append(\n           f\"::warning title=Malformed Baseline::Metric '{metric_name}' in\"\n-          f\" baseline for '{config_id}' is missing 'baseline_ms' or\"\n-          \" 'threshold', or is not structured as a dictionary. Skipping.\"\n+          f\" baseline for '{config_id}' is missing 'threshold', or is missing\"\n+          \" both 'baseline_ms' and 'baseline_gb', or is not structured as a\"\n+          \" dictionary. Skipping.\"\n+      )\n+      continue\n+\n+    baseline_key = metric_to_baseline_key.get(metric_name)\n+    if not baseline_key:\n+      summary_messages.append(\n+          f\"::warning title=Unsupported Metric::Metric '{metric_name}' is not\"\n+          \" supported by this script. Skipping.\"\n       )\n       continue\n \n     try:\n-      baseline_value_ms = float(baseline_info[\"baseline_ms\"])\n+      baseline_value = float(baseline_info[baseline_key])\n       threshold_percentage = float(baseline_info[\"threshold\"])\n     except ValueError:\n       summary_messages.append(\n           f\"::warning title=Invalid Baseline Value::Metric '{metric_name}' in\"\n-          f\" baseline for '{config_id}' has non-numeric 'baseline_ms' or\"\n+          f\" baseline for '{config_id}' has non-numeric '{baseline_key}' or\"\n           \" 'threshold'. Skipping.\"\n       )\n       continue\n \n     # Extract the actual metric value from results.json\n     actual_metric_entry = actual_metrics_container.get(metric_name)\n \n-    if not actual_metric_entry or \"value_ms\" not in actual_metric_entry:\n+    if not actual_metric_entry or \"value\" not in actual_metric_entry:\n       summary_messages.append(\n-          f\"Metric '{metric_name}': Actual value or 'value_ms' key not found in\"\n+          f\"Metric '{metric_name}': Actual value or 'value' key not found in\"\n           \" results, or not a dictionary. Skipping.\"\n       )\n       # For debugging:\n@@ -161,50 +181,60 @@ def compare_metrics(\n       continue\n \n     try:\n-      actual_value_ms = float(actual_metric_entry[\"value_ms\"])\n+      actual_value = float(actual_metric_entry[\"value\"])\n     except (ValueError, TypeError):\n       summary_messages.append(\n           f\"Metric '{metric_name}': Actual value\"\n-          f\" '{actual_metric_entry['value_ms']}' is not a valid number.\"\n+          f\" '{actual_metric_entry['value']}' is not a valid number.\"\n+          \" Skipping.\"\n+      )\n+      continue\n+\n+    actual_unit = actual_metric_entry.get(\"unit\")\n+    if not actual_unit:\n+      summary_messages.append(\n+          f\"Metric '{metric_name}': Actual value unit is not specified.\"\n           \" Skipping.\"\n       )\n       continue\n \n     summary_messages.append(f\"\\nComparing metric: {metric_name}\")\n-    summary_messages.append(f\"  Actual Value: {actual_value_ms:.3f} ms\")\n-    summary_messages.append(f\"  Baseline Value: {baseline_value_ms:.3f} ms\")\n+    summary_messages.append(f\"  Actual Value: {actual_value:.3f} {actual_unit}\")\n+    summary_messages.append(\n+        f\"  Baseline Value: {baseline_value:.3f} {actual_unit}\"\n+    )\n     summary_messages.append(\n         f\"  Allowed Threshold: {threshold_percentage*100:.1f}%\"\n     )\n \n     # Higher value is worse for time-based metrics\n-    allowed_upper_bound = baseline_value_ms * (1.0 + threshold_percentage)\n+    allowed_upper_bound = baseline_value * (1.0 + threshold_percentage)\n     summary_messages.append(\n         \"  Allowed Upper Bound (Baseline * (1 + Threshold)):\"\n-        f\" {allowed_upper_bound:.3f} ms\"\n+        f\" {allowed_upper_bound:.3f} {actual_unit}\"\n     )\n \n-    if actual_value_ms > allowed_upper_bound:\n+    if actual_value > allowed_upper_bound:\n       percentage_diff = 0.0\n       if (\n-          abs(baseline_value_ms) > 1e-9\n+          abs(baseline_value) > 1e-9\n       ):  # Avoid division by zero for very small baselines\n         percentage_diff = (\n-            (actual_value_ms - baseline_value_ms) / baseline_value_ms\n+            (actual_value - baseline_value) / baseline_value\n         ) * 100.0\n       elif (\n-          actual_value_ms > 0\n+          actual_value > 0\n       ):  # If baseline is effectively zero, any positive value is infinitely\n         # worse.\n         percentage_diff = float(\"inf\")\n \n       # Use GitHub Actions error annotation for better visibility\n       error_title = f\"REGRESSION: {metric_name}\"\n       error_details = (\n-          f\"Value {actual_value_ms:.3f} ms is {percentage_diff:.2f}% worse than\"\n-          f\" baseline {baseline_value_ms:.3f} ms. Exceeds threshold of\"\n-          f\" {threshold_percentage*100:.1f}% (max allowed:\"\n-          f\" {allowed_upper_bound:.3f} ms).\"\n+          f\"Value {actual_value:.3f} {actual_unit} is {percentage_diff:.2f}%\"\n+          f\" worse than baseline {baseline_value:.3f} {actual_unit}. Exceeds\"\n+          f\" threshold of {threshold_percentage*100:.1f}% (max allowed:\"\n+          f\" {allowed_upper_bound:.3f} {actual_unit}).\"\n       )\n       summary_messages.append(\n           \"  ::error\""
        },
        {
            "sha": "f579831c0c41b86823c5816c93a37f8676ee279e",
            "filename": "third_party/xla/.github/workflows/benchmarks/run_benchmark.sh",
            "status": "modified",
            "additions": 47,
            "deletions": 39,
            "changes": 86,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5a66337d60b3f75a37cfc06fb80841ac4b2c2187/third_party%2Fxla%2F.github%2Fworkflows%2Fbenchmarks%2Frun_benchmark.sh",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5a66337d60b3f75a37cfc06fb80841ac4b2c2187/third_party%2Fxla%2F.github%2Fworkflows%2Fbenchmarks%2Frun_benchmark.sh",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2F.github%2Fworkflows%2Fbenchmarks%2Frun_benchmark.sh?ref=5a66337d60b3f75a37cfc06fb80841ac4b2c2187",
            "patch": "@@ -128,49 +128,57 @@ if [ -f \"$XSPACE_FILE_PATH\" ] && [ $RUNNER_EXIT_CODE -eq 0 ]; then\n         key=$(echo \"$key\" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')\n         value=$(echo \"$value\" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')\n \n-        # Expecting lines like \"Metric Name: 123.45 us\"\n-        if [[ \"$value\" == *us ]]; then\n-            num_value=$(echo \"$value\" | sed 's/ us$//')\n-            # Convert microseconds to milliseconds using awk\n-            ms_value=$(LC_ALL=C awk -v num=\"$num_value\" 'BEGIN { printf \"%.3f\", num / 1000 }')\n-\n-            # Sanitize base metric key (e.g., \"Device Time\" -> \"DEVICE_TIME\")\n-            base_metric_key=$(echo \"$key\" | tr ' ' '_' | tr '[:lower:]' '[:upper:]')\n-            final_metric_key=\"\"\n-\n-            # Determine the final metric key based on HARDWARE_CATEGORY for baseline matching\n-            if [[ \"$HARDWARE_CATEGORY\" == GPU* ]]; then\n-                if [[ \"$base_metric_key\" == \"DEVICE_TIME\" ]]; then\n-                    final_metric_key=\"GPU_DEVICE_TIME\"\n-                elif [[ \"$base_metric_key\" == \"DEVICE_MEMCPY_TIME\" ]]; then\n-                    final_metric_key=\"GPU_DEVICE_MEMCPY_TIME\"\n-                # Add other specific GPU mappings here if needed\n-                # else\n-                #    final_metric_key=\"GPU_${base_metric_key}\" # Generic prefix\n-                else\n-                    final_metric_key=\"$base_metric_key\" # If no specific GPU mapping, use base\n-                fi\n-            elif [[ \"$HARDWARE_CATEGORY\" == CPU* ]]; then\n-                if [[ \"$base_metric_key\" == \"CPU_TIME\" ]] || [[ \"$base_metric_key\" == \"TIME\" ]]; then # Handle \"CPU Time\" or just \"Time\"\n-                    final_metric_key=\"CPU_TIME\"\n-                elif [[ \"$base_metric_key\" == \"WALL_TIME\" ]]; then\n-                    final_metric_key=\"WALL_TIME\" # Wall time is generic\n-                # Add other specific CPU mappings here if needed\n-                # else\n-                #    final_metric_key=\"CPU_${base_metric_key}\" # Generic prefix\n-                else\n-                    final_metric_key=\"$base_metric_key\" # If no specific CPU mapping, use base\n-                fi\n+        # Sanitize base metric key (e.g., \"Device Time\" -> \"DEVICE_TIME\")\n+        base_metric_key=$(echo \"$key\" | tr ' ' '_' | tr '[:lower:]' '[:upper:]')\n+        final_metric_key=\"\"\n+\n+        # Determine the final metric key based on HARDWARE_CATEGORY for baseline matching\n+        if [[ \"$HARDWARE_CATEGORY\" == GPU* ]]; then\n+            if [[ \"$base_metric_key\" == \"DEVICE_TIME\" ]]; then\n+                final_metric_key=\"GPU_DEVICE_TIME\"\n+            elif [[ \"$base_metric_key\" == \"DEVICE_MEMCPY_TIME\" ]]; then\n+                final_metric_key=\"GPU_DEVICE_MEMCPY_TIME\"\n+            elif  [[ \"$base_metric_key\" == \"PEAK_MEMORY\" ]]; then\n+                final_metric_key=\"PEAK_GPU_MEMORY\"\n+            # Add other specific GPU mappings here if needed\n+            # else\n+            #    final_metric_key=\"GPU_${base_metric_key}\" # Generic prefix\n             else\n-                final_metric_key=\"$base_metric_key\" # For unknown/other categories\n+                final_metric_key=\"$base_metric_key\" # If no specific GPU mapping, use base\n             fi\n+        elif [[ \"$HARDWARE_CATEGORY\" == CPU* ]]; then\n+            if [[ \"$base_metric_key\" == \"CPU_TIME\" ]] || [[ \"$base_metric_key\" == \"TIME\" ]]; then # Handle \"CPU Time\" or just \"Time\"\n+                final_metric_key=\"CPU_TIME\"\n+            elif [[ \"$base_metric_key\" == \"WALL_TIME\" ]]; then\n+                final_metric_key=\"WALL_TIME\" # Wall time is generic\n+            # Add other specific CPU mappings here if needed\n+            # else\n+            #    final_metric_key=\"CPU_${base_metric_key}\" # Generic prefix\n+            else\n+                final_metric_key=\"$base_metric_key\" # If no specific CPU mapping, use base\n+            fi\n+        else\n+            final_metric_key=\"$base_metric_key\" # For unknown/other categories\n+        fi\n \n-            echo \"INFO: Parsed metric: OriginalKey='$key', BaseKey='$base_metric_key', FinalKey='$final_metric_key', ValueMs='$ms_value'\"\n-\n-            if ! $first_metric; then metrics_obj_str+=\",\"; fi\n-            metrics_obj_str+=\"\\\"$final_metric_key\\\": {\\\"value_ms\\\": $ms_value, \\\"unit\\\": \\\"ms\\\"}\"\n-            first_metric=false\n+        # Expecting lines like \"Metric Name: 123.45 us\" or \"Metric Name: 12345 bytes\"\n+        read number unit <<< $(echo \"$value\" | sed -E 's/([0-9]+\\.?[0-9]*)\\s*([a-zA-Z]+).*/\\1 \\2/')\n+        # Convert microseconds to milliseconds\n+        if [[ \"$unit\" == \"us\" ]]; then\n+            final_metric_value=$(LC_ALL=C awk -v num=\"$number\" 'BEGIN { printf \"%.3f\", num / 1000 }')\n+            final_unit=\"ms\"\n+        elif [[ \"$unit\" == \"bytes\" ]]; then\n+            # Convert bytes to GB\n+            final_metric_value=$(echo \"$number\" | awk '{printf \"%.2f\", $1/1024^3}')\n+            final_unit=\"GB\"\n+        else\n+          echo \"::warning::Skipping unsupported unit: $unit\"\n+          continue\n         fi\n+        if ! $first_metric; then metrics_obj_str+=\",\"; fi\n+        metrics_obj_str+=\"\\\"$final_metric_key\\\": {\\\"value\\\": $final_metric_value, \\\"unit\\\": \\\"$final_unit\\\"}\"\n+        first_metric=false\n+        echo \"INFO: Parsed metric: OriginalKey='$key', BaseKey='$base_metric_key', FinalKey='$final_metric_key', Value='$final_metric_value $final_unit'\"\n     done <<< \"$STATS_OUTPUT\"\n     metrics_obj_str+=\"}\"\n "
        },
        {
            "sha": "62b7808b979c3187af760ad810646359ed314e9f",
            "filename": "third_party/xla/xla/tools/benchmarks/baseline/presubmit_baseline.yml",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5a66337d60b3f75a37cfc06fb80841ac4b2c2187/third_party%2Fxla%2Fxla%2Ftools%2Fbenchmarks%2Fbaseline%2Fpresubmit_baseline.yml",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5a66337d60b3f75a37cfc06fb80841ac4b2c2187/third_party%2Fxla%2Fxla%2Ftools%2Fbenchmarks%2Fbaseline%2Fpresubmit_baseline.yml",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fbenchmarks%2Fbaseline%2Fpresubmit_baseline.yml?ref=5a66337d60b3f75a37cfc06fb80841ac4b2c2187",
            "patch": "@@ -23,6 +23,10 @@\n     \"GPU_DEVICE_MEMCPY_TIME\": {\n       \"baseline_ms\": 0.3,\n       \"threshold\": 0.30 # Allow 30% regression max\n+    },\n+    \"PEAK_GPU_MEMORY\" : {\n+      \"baseline_gb\": 1.87,\n+      \"threshold\": 0.10 # Allow 10% regression max\n     }\n   },\n   \"gemma3_1b_flax_call_x86_1h1d_presubmit\": { # config_id\n@@ -53,6 +57,10 @@\n     \"GPU_DEVICE_MEMCPY_TIME\": {\n       \"baseline_ms\": 0.05,\n       \"threshold\": 0.30 # Allow 30% regression max\n+    },\n+    \"PEAK_GPU_MEMORY\" : {\n+      \"baseline_gb\": 10.210,\n+      \"threshold\": 0.10 # Allow 10% regression max\n     }\n   }\n }"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 109,
        "deletions": 63
    }
}