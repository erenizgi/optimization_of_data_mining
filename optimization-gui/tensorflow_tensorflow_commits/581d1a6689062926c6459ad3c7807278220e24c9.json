{
    "author": "olegshyshkov",
    "message": "[XLA:GPU] Consistently check which bitcasts we can fuse.\n\ngithub.com/openxla/xla/pull/30864 added a check that we shouldn't fuse bitcasts that change bit width, but only in one place. We need to do that consistently, because there are multiple places in PriorityFusion that have special handling for bitcasts.\n\nPiperOrigin-RevId: 833281452",
    "sha": "581d1a6689062926c6459ad3c7807278220e24c9",
    "files": [
        {
            "sha": "8a60209fda4615f93e791da3b07c26cbd6bba90b",
            "filename": "third_party/xla/xla/service/gpu/transforms/priority_fusion.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 8,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/581d1a6689062926c6459ad3c7807278220e24c9/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/581d1a6689062926c6459ad3c7807278220e24c9/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.cc?ref=581d1a6689062926c6459ad3c7807278220e24c9",
            "patch": "@@ -81,6 +81,12 @@ namespace gpu {\n \n namespace {\n \n+// Bitcasts are fusible if they don't change the bit width.\n+bool IsFusibleBitcast(const HloInstruction& instr) {\n+  return instr.opcode() == HloOpcode::kBitcast &&\n+         hlo_instruction_utils::KeepsBitwidth(instr);\n+}\n+\n bool IsFusible(const HloInstruction& instr) {\n   // Side-effecting operations are not fusible.\n   if (!instr.IsFusible()) {\n@@ -92,13 +98,16 @@ bool IsFusible(const HloInstruction& instr) {\n     return true;\n   }\n \n+  // Bitcasts are fusible if they don't change the bit width.\n+  if (IsFusibleBitcast(instr)) {\n+    return true;\n+  }\n+\n   // Other non-elementwise ops also supported by elemental fusion.\n   switch (instr.opcode()) {\n     case HloOpcode::kFusion:\n       return IsGenericTritonFusion(instr) ||\n              instr.fusion_kind() != HloInstruction::FusionKind::kCustom;\n-    case HloOpcode::kBitcast:\n-      return hlo_instruction_utils::KeepsBitwidth(instr);\n     case HloOpcode::kCopy:\n     case HloOpcode::kIota:\n     case HloOpcode::kConstant:\n@@ -265,7 +274,7 @@ class PriorityFusionQueue {\n         current_consumers_ = {*preferred_consumer};\n       }\n \n-      if (HloPredicateIsOp<HloOpcode::kBitcast>(current_producer_)) {\n+      if (IsFusibleBitcast(*current_producer_)) {\n         // We don't check if bitcasts can be fused with all consumers, so we\n         // have to do it here.\n         llvm::erase_if(current_consumers_, [&](HloInstruction* consumer) {\n@@ -547,7 +556,7 @@ class PriorityFusionQueue {\n       preferred_consumer_.erase(producer);\n     }\n     // Bitcasts should always be fused first, since they are no-ops.\n-    if (HloPredicateIsOp<HloOpcode::kBitcast>(producer)) {\n+    if (IsFusibleBitcast(*producer)) {\n       return absl::InfiniteDuration();\n     }\n     // We always fuse constants, but the cost model doesn't handle them very\n@@ -790,7 +799,7 @@ class PriorityFusionQueue {\n       return can_fuse_triton;\n     }\n \n-    if (HloPredicateIsOp<HloOpcode::kBitcast>(consumer)) {\n+    if (IsFusibleBitcast(*consumer)) {\n       return FusionDecision::Forbid(\n           \"not fusing into a single bitcast as consumer\");\n     }\n@@ -926,7 +935,7 @@ class PriorityFusionQueue {\n     }\n     std::vector<HloInstruction*> possible_consumers;\n     for (const auto& user : producer->users()) {\n-      if (HloPredicateIsOp<HloOpcode::kBitcast>(user)) {\n+      if (IsFusibleBitcast(*user)) {\n         continue;\n       }\n       if (CanFuseTriton(producer, user, /*use_multi_output_fusion=*/true) &&\n@@ -960,7 +969,7 @@ class PriorityFusionQueue {\n \n     bool has_non_bitcast_user = false;\n     for (const auto& user : producer->users()) {\n-      if (HloPredicateIsOp<HloOpcode::kBitcast>(user)) {\n+      if (IsFusibleBitcast(*user)) {\n         continue;\n       }\n       has_non_bitcast_user = true;\n@@ -1181,7 +1190,7 @@ absl::StatusOr<bool> PriorityFusion::RunImpl(\n       for (auto* consumer : consumers) {\n         // Don't fuse into single bitcasts. We ignore them in the check\n         // CanFuseWithAllNonBitcastUsers(), so we need to check it here.\n-        if (HloPredicateIsOp<HloOpcode::kBitcast>(consumer)) {\n+        if (IsFusibleBitcast(*consumer)) {\n           continue;\n         }\n         if (!ConsumeFuel(producer, consumer)) {"
        },
        {
            "sha": "74a8d5cddf8d61d7262f66ad8f783d30ebd39c07",
            "filename": "third_party/xla/xla/service/gpu/transforms/priority_fusion_test.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/581d1a6689062926c6459ad3c7807278220e24c9/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/581d1a6689062926c6459ad3c7807278220e24c9/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion_test.cc?ref=581d1a6689062926c6459ad3c7807278220e24c9",
            "patch": "@@ -218,17 +218,19 @@ CHECK-NEXT: ROOT %{{.*}} = (f32[512]{0}, s32[512]{0}) tuple(%[[FUSION_F32]], %[[\n }\n \n TEST_F(PriorityFusionTest, DoNotFuseBitWidthChangingBitcast) {\n-  EXPECT_TRUE(RunAndCheckHloRewrite(R\"(\n-e {\n-  a = s8[3,5,2]{2,1,0} parameter(0)\n-  n = s8[3,5,2]{2,1,0} negate(a)\n-  b = s16[3,5]{1,0} bitcast(n)\n-  m = s16[3,5]{1,0} multiply(b, b)\n-})\",\n-                                    std::move(priority_fusion_),\n-                                    /*expect_change=*/false)\n-                  .status()\n-                  .ok());\n+  // `neg` is the producer that could be fused with `bitcast` and `mul`, but\n+  // since `bitcast` changes the bit width, we don't fuse it.\n+  auto module = *ParseAndReturnVerifiedModule(R\"(\n+    ENTRY main {\n+      p0 = s8[3,5,2]{2,1,0} parameter(0)\n+      neg = s8[3,5,2]{2,1,0} negate(p0)\n+      bitcast = s16[3,5]{1,0} bitcast(neg)\n+      mul = s8[3,5,2]{2,1,0} add(neg, neg)\n+      ROOT result = (s16[3,5]{1,0}, s8[3,5,2]{2,1,0}) tuple(bitcast, mul)\n+    })\");\n+\n+  EXPECT_THAT(priority_fusion_.Run(module.get()),\n+              absl_testing::IsOkAndHolds(false));\n }\n \n TEST_F(PriorityFusionTest, FuseConvertIntoReduce) {"
        }
    ],
    "stats": {
        "total": 49,
        "additions": 30,
        "deletions": 19
    }
}