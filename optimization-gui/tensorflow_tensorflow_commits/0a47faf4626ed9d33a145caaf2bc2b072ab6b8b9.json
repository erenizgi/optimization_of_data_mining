{
    "author": "beckerhe",
    "message": "Support serialization of InprocessSymbolSpecs\n\n`KernelLoaderSpec::InprocessSymbol` reference CUDA or ROCm kernels through a function pointer. This function pointer is only valid in the currently running process and can't easily be serialized for usage in a different process.\n\nTherefore this change introduces the `KernelSymbolRegistry` which is a mapping from a unique name (string) to a function pointer. With the help of this registry we can use the name for serialization and recover the function pointer in a different process.\n\nPiperOrigin-RevId: 831725973",
    "sha": "0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
    "files": [
        {
            "sha": "dc3bdbd87aa66399ce3f29b617de157c95ac6eab",
            "filename": "third_party/xla/xla/stream_executor/BUILD",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -543,6 +543,41 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"kernel_symbol_registry\",\n+    srcs = [\"kernel_symbol_registry.cc\"],\n+    hdrs = [\"kernel_symbol_registry.h\"],\n+    deps = [\n+        \":platform\",\n+        \":platform_manager\",\n+        \"//xla/stream_executor/platform:initialize\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/synchronization\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"kernel_symbol_registry_test\",\n+    srcs = [\"kernel_symbol_registry_test.cc\"],\n+    deps = [\n+        \":kernel_symbol_registry\",\n+        \"//xla/stream_executor/cuda:cuda_platform_id\",\n+        \"@com_google_absl//absl/base\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:status_matchers\",\n+        \"@local_tsl//tsl/platform:test\",\n+    ],\n+)\n+\n cc_library(\n     name = \"kernel_spec\",\n     srcs = [\"kernel_spec.cc\"],\n@@ -552,7 +587,10 @@ cc_library(\n         \":kernel_args\",\n         \":kernel_argument_packing_spec\",\n         \":kernel_spec_proto_cc\",\n+        \":kernel_symbol_registry\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/base:nullability\",\n+        \"@com_google_absl//absl/functional:function_ref\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\","
        },
        {
            "sha": "3b2c74f5091e6eb0dab9fb911d5c3998fa408e59",
            "filename": "third_party/xla/xla/stream_executor/kernel_spec.cc",
            "status": "modified",
            "additions": 62,
            "deletions": 23,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.cc?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n \n #include <cstddef>\n #include <cstdint>\n+#include <optional>\n #include <string>\n #include <utility>\n #include <variant>\n@@ -40,6 +41,14 @@ KernelLoaderSpec KernelLoaderSpec::CreateInProcessSymbolSpec(\n                           arity, kernel_args_packing};\n }\n \n+KernelLoaderSpec KernelLoaderSpec::CreateSerializableInProcessSymbolSpec(\n+    std::string persistent_kernel_name, void* symbol, std::string kernel_name,\n+    size_t arity, KernelArgsPacking kernel_args_packing) {\n+  return KernelLoaderSpec{\n+      InProcessSymbol{symbol, std::move(persistent_kernel_name)},\n+      std::move(kernel_name), arity, kernel_args_packing};\n+}\n+\n KernelLoaderSpec KernelLoaderSpec::CreateCudaCubinInMemorySpec(\n     absl::Span<const uint8_t> cubin_bytes, std::string kernel_name,\n     size_t arity, KernelArgsPacking kernel_args_packing) {\n@@ -76,12 +85,6 @@ absl::StatusOr<KernelLoaderSpecProto> KernelLoaderSpec::ToProto() const {\n         \"serializable.\");\n   }\n \n-  if (has_in_process_symbol()) {\n-    return absl::InvalidArgumentError(\n-        \"KernelLoaderSpec referencing in process device functions can't \"\n-        \"be serialized.\");\n-  }\n-\n   KernelLoaderSpecProto proto{};\n   proto.set_arity(arity_);\n   proto.set_kernel_name(kernel_name_);\n@@ -95,7 +98,18 @@ absl::StatusOr<KernelLoaderSpecProto> KernelLoaderSpec::ToProto() const {\n     proto.mutable_ptx()->set_data(cuda_ptx_in_memory()->ptx);\n   }\n \n-  CHECK(proto.has_cubin() || proto.has_ptx());\n+  if (has_in_process_symbol()) {\n+    if (in_process_symbol()->persistent_name.empty()) {\n+      return absl::InvalidArgumentError(\n+          \"KernelLoaderSpec referencing in process device functions can't \"\n+          \"be serialized without a persistent kernel name.\");\n+    }\n+    proto.mutable_in_process_symbol()->set_persistent_name(\n+        in_process_symbol()->persistent_name);\n+  }\n+\n+  CHECK(has_cuda_cubin_in_memory() || has_cuda_ptx_in_memory() ||\n+        has_in_process_symbol());\n \n   if (std::holds_alternative<KernelArgumentsPackingSpec>(\n           kernel_args_packing_)) {\n@@ -108,30 +122,55 @@ absl::StatusOr<KernelLoaderSpecProto> KernelLoaderSpec::ToProto() const {\n }\n \n absl::StatusOr<KernelLoaderSpec> KernelLoaderSpec::FromProto(\n-    const KernelLoaderSpecProto& proto) {\n+    const KernelLoaderSpecProto& proto,\n+    std::optional<SymbolResolver> symbol_resolver) {\n   KernelArgsPacking kernel_args_packing;\n   if (proto.has_kernel_args_packing_spec()) {\n     TF_ASSIGN_OR_RETURN(kernel_args_packing,\n                         KernelArgumentsPackingSpec::FromProto(\n                             proto.kernel_args_packing_spec()));\n   }\n \n-  if (proto.has_cubin()) {\n-    const std::string& data = proto.cubin().data();\n-    return KernelLoaderSpec::CreateOwningCudaCubinInMemorySpec(\n-        std::vector<uint8_t>{data.begin(), data.end()}, proto.kernel_name(),\n-        proto.arity(), std::move(kernel_args_packing));\n+  switch (proto.payload_case()) {\n+    case KernelLoaderSpecProto::kCubin: {\n+      const std::string& data = proto.cubin().data();\n+      return KernelLoaderSpec::CreateOwningCudaCubinInMemorySpec(\n+          std::vector<uint8_t>{data.begin(), data.end()}, proto.kernel_name(),\n+          proto.arity(), std::move(kernel_args_packing));\n+    }\n+\n+    case KernelLoaderSpecProto::kPtx: {\n+      return KernelLoaderSpec::CreateOwningCudaPtxInMemorySpec(\n+          proto.ptx().data(), proto.kernel_name(), proto.arity(),\n+          std::move(kernel_args_packing));\n+    }\n+\n+    case KernelLoaderSpecProto::kInProcessSymbol: {\n+      if (!symbol_resolver.has_value()) {\n+        return absl::InvalidArgumentError(\n+            \"KernelLoaderSpecProto references in process symbol, but no symbol \"\n+            \"registry has been provided.\");\n+      }\n+      if (proto.in_process_symbol().persistent_name().empty()) {\n+        return absl::InvalidArgumentError(\n+            \"KernelLoaderSpecProto references in process symbol, but no \"\n+            \"persistent name has been provided.\");\n+      }\n+\n+      TF_ASSIGN_OR_RETURN(\n+          void* symbol,\n+          (*symbol_resolver)(proto.in_process_symbol().persistent_name()));\n+      return KernelLoaderSpec::CreateSerializableInProcessSymbolSpec(\n+          proto.in_process_symbol().persistent_name(), symbol,\n+          proto.kernel_name(), proto.arity());\n+    }\n+\n+    default:\n+      return absl::InvalidArgumentError(\n+          \"Invalid KernelLoaderSpecProto. Neither PTX nor CUBIN payload has \"\n+          \"been \"\n+          \"found.\");\n   }\n-\n-  if (proto.has_ptx()) {\n-    return KernelLoaderSpec::CreateOwningCudaPtxInMemorySpec(\n-        proto.ptx().data(), proto.kernel_name(), proto.arity(),\n-        std::move(kernel_args_packing));\n-  }\n-\n-  return absl::InvalidArgumentError(\n-      \"Invalid KernelLoaderSpecProto. Neither PTX nor CUBIN payload has been \"\n-      \"found.\");\n }\n \n }  // namespace stream_executor"
        },
        {
            "sha": "450bccfda1a62a38a743d5363a0d82665d9d4e30",
            "filename": "third_party/xla/xla/stream_executor/kernel_spec.h",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.h?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -48,6 +48,7 @@ limitations under the License.\n #include <variant>\n #include <vector>\n \n+#include \"absl/functional/function_ref.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -62,6 +63,9 @@ namespace stream_executor {\n // function).\n struct InProcessSymbol {\n   void* symbol;\n+  // If not empty, this symbol can be looked up by this name in the kernel\n+  // symbol registry.\n+  std::string persistent_name;\n };\n \n // Kernel loader specification for PTX text that resides in memory.\n@@ -155,6 +159,9 @@ class KernelLoaderSpec {\n   static KernelLoaderSpec CreateInProcessSymbolSpec(\n       void* symbol, std::string kernel_name, size_t arity,\n       KernelArgsPacking kernel_args_packing = nullptr);\n+  static KernelLoaderSpec CreateSerializableInProcessSymbolSpec(\n+      std::string persistent_kernel_name, void* symbol, std::string kernel_name,\n+      size_t arity, KernelArgsPacking kernel_args_packing = nullptr);\n   static KernelLoaderSpec CreateCudaCubinInMemorySpec(\n       absl::Span<const uint8_t> cubin_bytes, std::string kernel_name,\n       size_t arity,\n@@ -181,8 +188,12 @@ class KernelLoaderSpec {\n \n   absl::StatusOr<KernelLoaderSpecProto> ToProto() const;\n \n+  using SymbolResolver =\n+      absl::FunctionRef<absl::StatusOr<void*>(absl::string_view)>;\n+\n   static absl::StatusOr<KernelLoaderSpec> FromProto(\n-      const KernelLoaderSpecProto& proto);\n+      const KernelLoaderSpecProto& proto,\n+      std::optional<SymbolResolver> symbol_resolver = std::nullopt);\n \n  private:\n   using Payload ="
        },
        {
            "sha": "939b06cba35ebdbc7f92021ca3c87c884e6cba54",
            "filename": "third_party/xla/xla/stream_executor/kernel_spec.proto",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec.proto?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -12,10 +12,15 @@ message CudaCubinProto {\n   bytes data = 1;\n }\n \n+message InProcessSymbolProto {\n+  string persistent_name = 1;\n+}\n+\n message KernelLoaderSpecProto {\n   oneof payload {\n     CudaPtxProto ptx = 1;\n     CudaCubinProto cubin = 2;\n+    InProcessSymbolProto in_process_symbol = 6;\n   }\n \n   int32 arity = 3;"
        },
        {
            "sha": "0211fdf8ef7687111c0e2a35d3aa05c1d0697647",
            "filename": "third_party/xla/xla/stream_executor/kernel_spec_test.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 5,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec_test.cc?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -38,6 +38,7 @@ namespace stream_executor {\n namespace {\n \n using ::absl_testing::IsOkAndHolds;\n+using ::absl_testing::StatusIs;\n using ::testing::Field;\n using ::testing::Optional;\n using ::tsl::proto_testing::EqualsProto;\n@@ -171,12 +172,51 @@ TEST(KernelLoaderSpec, CubinKernelToProto) {\n               )pb\")));\n }\n \n-TEST(KernelLoaderSpec, InProcessSymbolToProto) {\n-  auto spec = stream_executor::KernelLoaderSpec::CreateInProcessSymbolSpec(\n-      nullptr, \"kernel_name\", 42);\n+TEST(KernelLoaderSpec, InProcessSymbolFromProto) {\n+  auto proto = ParseTextProtoOrDie<KernelLoaderSpecProto>(R\"pb(\n+    in_process_symbol { persistent_name: \"persistent_kernel_name\" }\n+    kernel_name: \"kernel_name\"\n+    arity: 42\n+  )pb\");\n+\n+  const auto symbol_resolver = [](absl::string_view name) {\n+    return absl::bit_cast<void*>(static_cast<uintptr_t>(0x1234567890));\n+  };\n+\n+  TF_ASSERT_OK_AND_ASSIGN(KernelLoaderSpec spec,\n+                          KernelLoaderSpec::FromProto(proto, symbol_resolver));\n+  EXPECT_EQ(spec.kernel_name(), \"kernel_name\");\n+  EXPECT_EQ(spec.arity(), 42);\n+  EXPECT_THAT(spec.in_process_symbol(),\n+              Optional(Field(&InProcessSymbol::symbol,\n+                             absl::bit_cast<void*>(\n+                                 static_cast<uintptr_t>(0x1234567890)))));\n+  EXPECT_THAT(spec.in_process_symbol(),\n+              Optional(Field(&InProcessSymbol::persistent_name,\n+                             \"persistent_kernel_name\")));\n \n-  EXPECT_THAT(spec.ToProto(),\n-              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+  // If the symbol resolver is not provided, the spec cannot be deserialized.\n+  EXPECT_THAT(KernelLoaderSpec::FromProto(proto),\n+              StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n+TEST(KernelLoaderSpec, InProcessSymbolToProto) {\n+  auto non_serializable_spec =\n+      stream_executor::KernelLoaderSpec::CreateInProcessSymbolSpec(\n+          nullptr, \"kernel_name\", 42);\n+\n+  // InProcessSymbol specs without a persistent name cannot be serialized.\n+  EXPECT_THAT(non_serializable_spec.ToProto(),\n+              StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  auto serializable_spec =\n+      stream_executor::KernelLoaderSpec::CreateSerializableInProcessSymbolSpec(\n+          \"persistent_kernel_name\", nullptr, \"kernel_name\", 42);\n+  EXPECT_THAT(serializable_spec.ToProto(), IsOkAndHolds(EqualsProto(R\"pb(\n+                in_process_symbol { persistent_name: \"persistent_kernel_name\" }\n+                kernel_name: \"kernel_name\"\n+                arity: 42\n+              )pb\")));\n }\n \n TEST(kernelLoaderSpec, StoresKernelArgsPackingSpec) {"
        },
        {
            "sha": "c6375e0cfef37ede8a2113e14ddd97d060259a7f",
            "filename": "third_party/xla/xla/stream_executor/kernel_symbol_registry.cc",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry.cc?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -0,0 +1,70 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/kernel_symbol_registry.h\"\n+\n+#include <string>\n+#include <tuple>\n+\n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/stream_executor/platform.h\"\n+#include \"xla/stream_executor/platform_manager.h\"\n+\n+namespace stream_executor {\n+namespace {\n+std::string GetPlatformName(Platform::Id platform_id) {\n+  absl::StatusOr<Platform*> platform =\n+      PlatformManager::PlatformWithId(platform_id);\n+  return platform.ok() ? platform.value()->Name() : \"<unknown>\";\n+}\n+}  // namespace\n+\n+KernelSymbolRegistry& KernelSymbolRegistry::GetGlobalInstance() {\n+  static absl::NoDestructor<KernelSymbolRegistry> registry;\n+  return *registry;\n+}\n+\n+absl::Status KernelSymbolRegistry::RegisterSymbol(absl::string_view name,\n+                                                  Platform::Id platform_id,\n+                                                  void* symbol) {\n+  absl::MutexLock lock(mutex_);\n+  bool inserted;\n+  std::tie(std::ignore, inserted) =\n+      symbols_.insert({{std::string(name), platform_id}, symbol});\n+  if (!inserted) {\n+    return absl::AlreadyExistsError(\n+        absl::StrCat(\"Symbol \", name, \" is already registered.\"));\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::StatusOr<void*> KernelSymbolRegistry::FindSymbol(\n+    absl::string_view name, Platform::Id platform_id) const {\n+  absl::MutexLock lock(mutex_);\n+  auto it = symbols_.find({std::string(name), platform_id});\n+  if (it == symbols_.end()) {\n+    return absl::NotFoundError(absl::StrCat(\"Symbol \", name,\n+                                            \" not found for platform \",\n+                                            GetPlatformName(platform_id)));\n+  }\n+  return it->second;\n+}\n+\n+}  // namespace stream_executor"
        },
        {
            "sha": "ac388a5e17dabad9f12bff77ab26b2ba69b3c898",
            "filename": "third_party/xla/xla/stream_executor/kernel_symbol_registry.h",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry.h?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -0,0 +1,114 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_STREAM_EXECUTOR_KERNEL_SYMBOL_REGISTRY_H_\n+#define XLA_STREAM_EXECUTOR_KERNEL_SYMBOL_REGISTRY_H_\n+\n+#include <string>\n+#include <tuple>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/stream_executor/platform.h\"\n+#include \"xla/stream_executor/platform/initialize.h\"\n+\n+namespace stream_executor {\n+\n+/**\n+ * A registry for GPU kernel symbols.\n+ *\n+ * We use void* pointers to the host entry functions of CUDA C++ kernels to\n+ * identify them and load their GPU implementation into the GPU.\n+ *\n+ * This registry allows us to do this consistently and reliably across different\n+ * processes by mapping the host entry function to a persistent name and using\n+ * that name to look up the host entry function pointer in the registry.\n+ *\n+ * Maps a (name, platform_id) tuple to a void* pointer.\n+ *\n+ * You can use the KERNEL_SYMBOL_REGISTRY_REGISTER_SYMBOL_STATICALLY macro to\n+ * register symbols during initialization. Make sure to mark the target as\n+ * `alwayslink = True` so that it won't be stripped by the linker.\n+ *\n+ * The class is thread-safe.\n+ */\n+class KernelSymbolRegistry {\n+ public:\n+  static KernelSymbolRegistry& GetGlobalInstance();\n+\n+  // Registers a symbol in the registry. The symbol is identified by a name and\n+  // a platform ID.\n+  //\n+  // Returns an error if the symbol is already registered.\n+  absl::Status RegisterSymbol(absl::string_view name, Platform::Id platform_id,\n+                              void* symbol);\n+\n+  // Convenience overload for registering any raw function pointer as a symbol.\n+  template <typename... Args>\n+  absl::Status RegisterSymbol(absl::string_view name, Platform::Id platform_id,\n+                              void (*symbol)(Args...)) {\n+    return RegisterSymbol(name, platform_id, absl::bit_cast<void*>(symbol));\n+  }\n+\n+  absl::StatusOr<void*> FindSymbol(absl::string_view name,\n+                                   Platform::Id platform_id) const;\n+\n+ private:\n+  mutable absl::Mutex mutex_;\n+  using RegistryKey = std::tuple<std::string, Platform::Id>;\n+  absl::flat_hash_map<RegistryKey, void*> symbols_ ABSL_GUARDED_BY(mutex_);\n+};\n+\n+// Registers a symbol in the kernel symbol registry.\n+//\n+// This macro registers a symbol in the kernel symbol registry during static\n+// initialization. It uses the identifier to generate a unique name for the\n+// symbol and logs a fatal error if the symbol is already registered.\n+//\n+// Example usage:\n+//\n+//   __global__ void my_cuda_kernel(int* x);\n+//   KERNEL_SYMBOL_REGISTRY_REGISTER_SYMBOL_STATICALLY(my_unique_persistent_name,\n+//                                                     cuda::kCudaPlatformId,\n+//                                                     &my_cuda_kernel);\n+//\n+// The symbol will be registered with the name \"my_unique_persistent_name\" and\n+// the platform ID cuda::kCudaPlatformId. The name will also be used to generate\n+// a C++ identifier for the static initializer. therefore it needs to be a valid\n+// C++ variable name.\n+//\n+// Make sure to mark the target as `alwayslink = True` so that it won't be\n+// stripped by the linker.\n+#define KERNEL_SYMBOL_REGISTRY_REGISTER_SYMBOL_STATICALLY(identifier,          \\\n+                                                          platform_id, symbol) \\\n+  static void RegisterSymbol##identifier##Impl() {                             \\\n+    absl::Status result =                                                      \\\n+        stream_executor::KernelSymbolRegistry::GetGlobalInstance()             \\\n+            .RegisterSymbol(#identifier, platform_id, symbol);                 \\\n+    if (!result.ok()) {                                                        \\\n+      LOG(FATAL) << \"Failed to register symbol: \" << result;                   \\\n+    }                                                                          \\\n+  }                                                                            \\\n+  STREAM_EXECUTOR_REGISTER_MODULE_INITIALIZER(                                 \\\n+      RegisterSymbol##identifier, RegisterSymbol##identifier##Impl());\n+\n+}  // namespace stream_executor\n+\n+#endif  // XLA_STREAM_EXECUTOR_KERNEL_SYMBOL_REGISTRY_H_"
        },
        {
            "sha": "afcf7bc880178854349197c5793d42b0aaf537b4",
            "filename": "third_party/xla/xla/stream_executor/kernel_symbol_registry_test.cc",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_symbol_registry_test.cc?ref=0a47faf4626ed9d33a145caaf2bc2b072ab6b8b9",
            "patch": "@@ -0,0 +1,66 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/kernel_symbol_registry.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/base/casts.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"xla/stream_executor/cuda/cuda_platform_id.h\"\n+\n+namespace stream_executor {\n+namespace {\n+\n+using absl_testing::IsOk;\n+using absl_testing::IsOkAndHolds;\n+using absl_testing::StatusIs;\n+\n+TEST(KernelSymbolRegistryTest, RegisterSymbol) {\n+  KernelSymbolRegistry registry;\n+  EXPECT_THAT(registry.RegisterSymbol(\"symbol_name\", cuda::kCudaPlatformId,\n+                                      /*symbol=*/nullptr),\n+              IsOk());\n+  EXPECT_THAT(registry.RegisterSymbol(\"symbol_name\", cuda::kCudaPlatformId,\n+                                      /*symbol=*/nullptr),\n+              StatusIs(absl::StatusCode::kAlreadyExists));\n+}\n+\n+void PretendsToBeAKernel(int* x) { *x = 42; }\n+\n+TEST(KernelSymbolRegistryTest, FindSymbol) {\n+  KernelSymbolRegistry registry;\n+  EXPECT_THAT(registry.FindSymbol(\"symbol_name\", cuda::kCudaPlatformId),\n+              StatusIs(absl::StatusCode::kNotFound));\n+  EXPECT_THAT(registry.RegisterSymbol(\"symbol_name\", cuda::kCudaPlatformId,\n+                                      &PretendsToBeAKernel),\n+              IsOk());\n+  EXPECT_THAT(registry.FindSymbol(\"symbol_name\", cuda::kCudaPlatformId),\n+              IsOkAndHolds(absl::bit_cast<void*>(&PretendsToBeAKernel)));\n+}\n+\n+KERNEL_SYMBOL_REGISTRY_REGISTER_SYMBOL_STATICALLY(static_test_symbol,\n+                                                  cuda::kCudaPlatformId,\n+                                                  &PretendsToBeAKernel);\n+\n+TEST(KernelSymbolRegistryTest, StaticRegistration) {\n+  EXPECT_THAT(KernelSymbolRegistry::GetGlobalInstance().FindSymbol(\n+                  \"static_test_symbol\", cuda::kCudaPlatformId),\n+              IsOkAndHolds(absl::bit_cast<void*>(&PretendsToBeAKernel)));\n+}\n+\n+}  // namespace\n+}  // namespace stream_executor"
        }
    ],
    "stats": {
        "total": 441,
        "additions": 412,
        "deletions": 29
    }
}