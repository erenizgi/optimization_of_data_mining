{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832655404",
    "sha": "257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47",
    "files": [
        {
            "sha": "e62a49d223b7a11ae9d5a713e3bda0718bb95e85",
            "filename": "third_party/xla/xla/tsl/platform/env.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 48,
            "changes": 101,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv.cc?ref=257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47",
            "patch": "@@ -156,7 +156,7 @@ absl::Status Env::SetOption(const std::string& scheme, const std::string& key,\n }\n \n absl::Status Env::SetOption(const std::string& scheme, const std::string& key,\n-                            const std::vector<string>& values) {\n+                            const std::vector<std::string>& values) {\n   FileSystem* file_system = file_system_registry_->Lookup(scheme);\n   if (!file_system) {\n     return errors::Unimplemented(\"File system scheme '\", scheme,\n@@ -186,9 +186,9 @@ absl::Status Env::SetOption(const std::string& scheme, const std::string& key,\n }\n \n absl::Status Env::FlushFileSystemCaches() {\n-  std::vector<string> schemes;\n+  std::vector<std::string> schemes;\n   TF_RETURN_IF_ERROR(GetRegisteredFileSystemSchemes(&schemes));\n-  for (const string& scheme : schemes) {\n+  for (const std::string& scheme : schemes) {\n     FileSystem* fs = nullptr;\n     TF_RETURN_IF_ERROR(\n         GetFileSystemForFile(io::CreateURI(scheme, \"\", \"\"), &fs));\n@@ -198,49 +198,49 @@ absl::Status Env::FlushFileSystemCaches() {\n }\n \n absl::Status Env::NewRandomAccessFile(\n-    const string& fname, std::unique_ptr<RandomAccessFile>* result) {\n+    const std::string& fname, std::unique_ptr<RandomAccessFile>* result) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->NewRandomAccessFile(fname, result);\n }\n \n absl::Status Env::NewReadOnlyMemoryRegionFromFile(\n-    const string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) {\n+    const std::string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->NewReadOnlyMemoryRegionFromFile(fname, result);\n }\n \n-absl::Status Env::NewWritableFile(const string& fname,\n+absl::Status Env::NewWritableFile(const std::string& fname,\n                                   std::unique_ptr<WritableFile>* result) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->NewWritableFile(fname, result);\n }\n \n-absl::Status Env::NewAppendableFile(const string& fname,\n+absl::Status Env::NewAppendableFile(const std::string& fname,\n                                     std::unique_ptr<WritableFile>* result) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->NewAppendableFile(fname, result);\n }\n \n-absl::Status Env::FileExists(const string& fname) {\n+absl::Status Env::FileExists(const std::string& fname) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->FileExists(fname);\n }\n \n-bool Env::FilesExist(const std::vector<string>& files,\n+bool Env::FilesExist(const std::vector<std::string>& files,\n                      std::vector<absl::Status>* status) {\n-  std::unordered_map<string, std::vector<string>> files_per_fs;\n+  std::unordered_map<std::string, std::vector<std::string>> files_per_fs;\n   for (const auto& file : files) {\n     absl::string_view scheme, host, path;\n     io::ParseURI(file, &scheme, &host, &path);\n-    files_per_fs[string(scheme)].push_back(file);\n+    files_per_fs[std::string(scheme)].push_back(file);\n   }\n \n-  std::unordered_map<string, absl::Status> per_file_status;\n+  std::unordered_map<std::string, absl::Status> per_file_status;\n   bool result = true;\n   for (auto itr : files_per_fs) {\n     FileSystem* file_system = file_system_registry_->Lookup(itr.first);\n@@ -277,76 +277,79 @@ bool Env::FilesExist(const std::vector<string>& files,\n   return result;\n }\n \n-absl::Status Env::GetChildren(const string& dir, std::vector<string>* result) {\n+absl::Status Env::GetChildren(const std::string& dir,\n+                              std::vector<std::string>* result) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(dir, &fs));\n   return fs->GetChildren(dir, result);\n }\n \n-absl::Status Env::GetMatchingPaths(const string& pattern,\n-                                   std::vector<string>* results) {\n+absl::Status Env::GetMatchingPaths(const std::string& pattern,\n+                                   std::vector<std::string>* results) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(pattern, &fs));\n   return fs->GetMatchingPaths(pattern, results);\n }\n \n-absl::Status Env::DeleteFile(const string& fname) {\n+absl::Status Env::DeleteFile(const std::string& fname) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->DeleteFile(fname);\n }\n \n-absl::Status Env::RecursivelyCreateDir(const string& dirname) {\n+absl::Status Env::RecursivelyCreateDir(const std::string& dirname) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(dirname, &fs));\n   return fs->RecursivelyCreateDir(dirname);\n }\n \n-absl::Status Env::CreateDir(const string& dirname) {\n+absl::Status Env::CreateDir(const std::string& dirname) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(dirname, &fs));\n   return fs->CreateDir(dirname);\n }\n \n-absl::Status Env::DeleteDir(const string& dirname) {\n+absl::Status Env::DeleteDir(const std::string& dirname) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(dirname, &fs));\n   return fs->DeleteDir(dirname);\n }\n \n-absl::Status Env::Stat(const string& fname, FileStatistics* stat) {\n+absl::Status Env::Stat(const std::string& fname, FileStatistics* stat) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->Stat(fname, stat);\n }\n \n-absl::Status Env::IsDirectory(const string& fname) {\n+absl::Status Env::IsDirectory(const std::string& fname) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->IsDirectory(fname);\n }\n \n-absl::Status Env::HasAtomicMove(const string& path, bool* has_atomic_move) {\n+absl::Status Env::HasAtomicMove(const std::string& path,\n+                                bool* has_atomic_move) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(path, &fs));\n   return fs->HasAtomicMove(path, has_atomic_move);\n }\n \n-absl::Status Env::DeleteRecursively(const string& dirname,\n+absl::Status Env::DeleteRecursively(const std::string& dirname,\n                                     int64_t* undeleted_files,\n                                     int64_t* undeleted_dirs) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(dirname, &fs));\n   return fs->DeleteRecursively(dirname, undeleted_files, undeleted_dirs);\n }\n \n-absl::Status Env::GetFileSize(const string& fname, uint64* file_size) {\n+absl::Status Env::GetFileSize(const std::string& fname, uint64_t* file_size) {\n   FileSystem* fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(fname, &fs));\n   return fs->GetFileSize(fname, file_size);\n }\n \n-absl::Status Env::RenameFile(const string& src, const string& target) {\n+absl::Status Env::RenameFile(const std::string& src,\n+                             const std::string& target) {\n   FileSystem* src_fs;\n   FileSystem* target_fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(src, &src_fs));\n@@ -358,7 +361,7 @@ absl::Status Env::RenameFile(const string& src, const string& target) {\n   return src_fs->RenameFile(src, target);\n }\n \n-absl::Status Env::CopyFile(const string& src, const string& target) {\n+absl::Status Env::CopyFile(const std::string& src, const std::string& target) {\n   FileSystem* src_fs;\n   FileSystem* target_fs;\n   TF_RETURN_IF_ERROR(GetFileSystemForFile(src, &src_fs));\n@@ -369,7 +372,7 @@ absl::Status Env::CopyFile(const string& src, const string& target) {\n   return FileSystemCopyFile(src_fs, src, target_fs, target);\n }\n \n-string Env::GetExecutablePath() {\n+std::string Env::GetExecutablePath() {\n   char exe_path[PATH_MAX] = {0};\n #ifdef __APPLE__\n   uint32_t buffer_size(0U);\n@@ -426,13 +429,13 @@ string Env::GetExecutablePath() {\n   return exe_path;\n }\n \n-bool Env::LocalTempFilename(string* filename) {\n-  std::vector<string> dirs;\n+bool Env::LocalTempFilename(std::string* filename) {\n+  std::vector<std::string> dirs;\n   GetLocalTempDirectories(&dirs);\n \n   // Try each directory, as they might be full, have inappropriate\n   // permissions or have different problems at times.\n-  for (const string& dir : dirs) {\n+  for (const std::string& dir : dirs) {\n     *filename = io::JoinPath(dir, \"tempfile-\");\n     if (CreateUniqueFileName(filename, \"\")) {\n       return true;\n@@ -441,7 +444,7 @@ bool Env::LocalTempFilename(string* filename) {\n   return false;\n }\n \n-bool Env::CreateUniqueFileName(string* prefix, const string& suffix) {\n+bool Env::CreateUniqueFileName(std::string* prefix, const std::string& suffix) {\n   int64_t tid = GetCurrentThreadId();\n   int32_t pid = GetProcessId();\n   long long now_microsec = NowMicros();  // NOLINT\n@@ -460,20 +463,21 @@ bool Env::CreateUniqueFileName(string* prefix, const string& suffix) {\n   }\n }\n \n-int32 Env::GetProcessId() {\n+int32_t Env::GetProcessId() {\n #ifdef PLATFORM_WINDOWS\n   return static_cast<int32>(GetCurrentProcessId());\n #else\n-  return static_cast<int32>(getpid());\n+  return static_cast<int32_t>(getpid());\n #endif\n }\n \n Thread::~Thread() {}\n \n EnvWrapper::~EnvWrapper() {}\n \n-absl::Status ReadFileToString(Env* env, const string& fname, string* data) {\n-  uint64 file_size;\n+absl::Status ReadFileToString(Env* env, const std::string& fname,\n+                              std::string* data) {\n+  uint64_t file_size;\n   absl::Status s = env->GetFileSize(fname, &file_size);\n   if (!s.ok()) {\n     return s;\n@@ -501,7 +505,7 @@ absl::Status ReadFileToString(Env* env, const string& fname, string* data) {\n   return s;\n }\n \n-absl::Status WriteStringToFile(Env* env, const string& fname,\n+absl::Status WriteStringToFile(Env* env, const std::string& fname,\n                                absl::string_view data) {\n   std::unique_ptr<WritableFile> file;\n   absl::Status s = env->NewWritableFile(fname, &file);\n@@ -515,13 +519,14 @@ absl::Status WriteStringToFile(Env* env, const string& fname,\n   return s;\n }\n \n-absl::Status FileSystemCopyFile(FileSystem* src_fs, const string& src,\n-                                FileSystem* target_fs, const string& target) {\n+absl::Status FileSystemCopyFile(FileSystem* src_fs, const std::string& src,\n+                                FileSystem* target_fs,\n+                                const std::string& target) {\n   std::unique_ptr<RandomAccessFile> src_file;\n   TF_RETURN_IF_ERROR(src_fs->NewRandomAccessFile(src, &src_file));\n \n   // When `target` points to a directory, we need to create a file within.\n-  string target_name;\n+  std::string target_name;\n   if (target_fs->IsDirectory(target).ok()) {\n     target_name = io::JoinPath(target, io::Basename(src));\n   } else {\n@@ -531,7 +536,7 @@ absl::Status FileSystemCopyFile(FileSystem* src_fs, const string& src,\n   std::unique_ptr<WritableFile> target_file;\n   TF_RETURN_IF_ERROR(target_fs->NewWritableFile(target_name, &target_file));\n \n-  uint64 offset = 0;\n+  uint64_t offset = 0;\n   std::unique_ptr<char[]> scratch(new char[kCopyFileBufferSize]);\n   absl::Status s = absl::OkStatus();\n   while (s.ok()) {\n@@ -586,14 +591,14 @@ class FileStream : public protobuf::io::ZeroCopyInputStream {\n \n }  // namespace\n \n-absl::Status WriteBinaryProto(Env* env, const string& fname,\n+absl::Status WriteBinaryProto(Env* env, const std::string& fname,\n                               const protobuf::MessageLite& proto) {\n-  string serialized;\n+  std::string serialized;\n   proto.AppendToString(&serialized);\n   return WriteStringToFile(env, fname, serialized);\n }\n \n-absl::Status ReadBinaryProto(Env* env, const string& fname,\n+absl::Status ReadBinaryProto(Env* env, const std::string& fname,\n                              protobuf::MessageLite* proto) {\n   std::unique_ptr<RandomAccessFile> file;\n   TF_RETURN_IF_ERROR(env->NewRandomAccessFile(fname, &file));\n@@ -608,16 +613,16 @@ absl::Status ReadBinaryProto(Env* env, const string& fname,\n   return absl::OkStatus();\n }\n \n-absl::Status WriteTextProto(Env* env, const string& fname,\n+absl::Status WriteTextProto(Env* env, const std::string& fname,\n                             const protobuf::Message& proto) {\n-  string serialized;\n+  std::string serialized;\n   if (!protobuf::TextFormat::PrintToString(proto, &serialized)) {\n     return errors::FailedPrecondition(\"Unable to convert proto to text.\");\n   }\n   return WriteStringToFile(env, fname, serialized);\n }\n \n-absl::Status ReadTextProto(Env* env, const string& fname,\n+absl::Status ReadTextProto(Env* env, const std::string& fname,\n                            protobuf::Message* proto) {\n   std::unique_ptr<RandomAccessFile> file;\n   TF_RETURN_IF_ERROR(env->NewRandomAccessFile(fname, &file));\n@@ -630,15 +635,15 @@ absl::Status ReadTextProto(Env* env, const string& fname,\n   return absl::OkStatus();\n }\n \n-absl::Status ReadTextOrBinaryProto(Env* env, const string& fname,\n+absl::Status ReadTextOrBinaryProto(Env* env, const std::string& fname,\n                                    protobuf::Message* proto) {\n   if (ReadTextProto(env, fname, proto).ok()) {\n     return absl::OkStatus();\n   }\n   return ReadBinaryProto(env, fname, proto);\n }\n \n-absl::Status ReadTextOrBinaryProto(Env* env, const string& fname,\n+absl::Status ReadTextOrBinaryProto(Env* env, const std::string& fname,\n                                    protobuf::MessageLite* proto) {\n   return ReadBinaryProto(env, fname, proto);\n }"
        },
        {
            "sha": "30bd4e34b618db551ca6b2eb03ff101f8eb0d4fe",
            "filename": "third_party/xla/xla/tsl/platform/env.h",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv.h?ref=257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47",
            "patch": "@@ -104,7 +104,7 @@ class Env {\n                          const std::string& value);\n \n   absl::Status SetOption(const std::string& scheme, const std::string& key,\n-                         const std::vector<string>& values);\n+                         const std::vector<std::string>& values);\n \n   absl::Status SetOption(const std::string& scheme, const std::string& key,\n                          const std::vector<int64_t>& values);\n@@ -211,22 +211,23 @@ class Env {\n   /// Returns true if all the listed files exist, false otherwise.\n   /// if status is not null, populate the vector with a detailed status\n   /// for each file.\n-  bool FilesExist(const std::vector<string>& files,\n+  bool FilesExist(const std::vector<std::string>& files,\n                   std::vector<absl::Status>* status);\n \n-  bool FilesExist(const std::vector<string>& files, TransactionToken* token,\n-                  std::vector<absl::Status>* status) {\n+  bool FilesExist(const std::vector<std::string>& files,\n+                  TransactionToken* token, std::vector<absl::Status>* status) {\n     return true;\n   }\n \n   /// \\brief Stores in *result the names of the children of the specified\n   /// directory. The names are relative to \"dir\".\n   ///\n   /// Original contents of *results are dropped.\n-  absl::Status GetChildren(const std::string& dir, std::vector<string>* result);\n+  absl::Status GetChildren(const std::string& dir,\n+                           std::vector<std::string>* result);\n \n   absl::Status GetChildren(const std::string& dir, TransactionToken* token,\n-                           std::vector<string>* result) {\n+                           std::vector<std::string>* result) {\n     return absl::OkStatus();\n   }\n \n@@ -240,11 +241,11 @@ class Env {\n   ///\n   /// More details about `pattern` in FileSystem::GetMatchingPaths.\n   virtual absl::Status GetMatchingPaths(const std::string& pattern,\n-                                        std::vector<string>* results);\n+                                        std::vector<std::string>* results);\n \n   absl::Status GetMatchingPaths(const std::string& pattern,\n                                 TransactionToken* token,\n-                                std::vector<string>* results) {\n+                                std::vector<std::string>* results) {\n     return absl::OkStatus();\n   }\n \n@@ -348,10 +349,10 @@ class Env {\n   absl::Status HasAtomicMove(const std::string& path, bool* has_atomic_move);\n \n   /// Stores the size of `fname` in `*file_size`.\n-  absl::Status GetFileSize(const std::string& fname, uint64* file_size);\n+  absl::Status GetFileSize(const std::string& fname, uint64_t* file_size);\n \n   absl::Status GetFileSize(const std::string& fname, TransactionToken* token,\n-                           uint64* file_size) {\n+                           uint64_t* file_size) {\n     return absl::OkStatus();\n   }\n \n@@ -426,19 +427,19 @@ class Env {\n   // provide a routine to get the absolute time.\n \n   /// \\brief Returns the number of nano-seconds since the Unix epoch.\n-  virtual uint64 NowNanos() const { return EnvTime::NowNanos(); }\n+  virtual uint64_t NowNanos() const { return EnvTime::NowNanos(); }\n \n   /// \\brief Returns the number of micro-seconds since the Unix epoch.\n-  virtual uint64 NowMicros() const { return EnvTime::NowMicros(); }\n+  virtual uint64_t NowMicros() const { return EnvTime::NowMicros(); }\n \n   /// \\brief Returns the number of seconds since the Unix epoch.\n-  virtual uint64 NowSeconds() const { return EnvTime::NowSeconds(); }\n+  virtual uint64_t NowSeconds() const { return EnvTime::NowSeconds(); }\n \n   /// Sleeps/delays the thread for the prescribed number of micro-seconds.\n   virtual void SleepForMicroseconds(int64_t micros) = 0;\n \n   /// Returns the process ID of the calling process.\n-  int32 GetProcessId();\n+  int32_t GetProcessId();\n \n   /// \\brief Returns a new thread that is running fn() and is identified\n   /// (for debugging/performance-analysis) by \"name\".\n@@ -511,7 +512,7 @@ class Env {\n                                             const std::string& version) = 0;\n \n   // Returns a possible list of local temporary directories.\n-  virtual void GetLocalTempDirectories(std::vector<string>* list) = 0;\n+  virtual void GetLocalTempDirectories(std::vector<std::string>* list) = 0;\n \n  private:\n   std::unique_ptr<FileSystemRegistry> file_system_registry_;\n@@ -538,7 +539,7 @@ class EnvWrapper : public Env {\n   }\n \n   absl::Status GetRegisteredFileSystemSchemes(\n-      std::vector<string>* schemes) override {\n+      std::vector<std::string>* schemes) override {\n     return target_->GetRegisteredFileSystemSchemes(schemes);\n   }\n \n@@ -551,7 +552,7 @@ class EnvWrapper : public Env {\n     return target_->MatchPath(path, pattern);\n   }\n \n-  uint64 NowMicros() const override { return target_->NowMicros(); }\n+  uint64_t NowMicros() const override { return target_->NowMicros(); }\n   void SleepForMicroseconds(int64_t micros) override {\n     target_->SleepForMicroseconds(micros);\n   }\n@@ -595,7 +596,7 @@ class EnvWrapper : public Env {\n   std::string GetRunfilesDir() override { return target_->GetRunfilesDir(); }\n \n  private:\n-  void GetLocalTempDirectories(std::vector<string>* list) override {\n+  void GetLocalTempDirectories(std::vector<std::string>* list) override {\n     target_->GetLocalTempDirectories(list);\n   }\n \n@@ -700,7 +701,8 @@ struct Register {\n     // after TF 2.6+.\n     if (try_modular_filesystems) {\n       const char* env_value = getenv(\"TF_USE_MODULAR_FILESYSTEM\");\n-      string load_plugin = env_value ? absl::AsciiStrToLower(env_value) : \"\";\n+      std::string load_plugin =\n+          env_value ? absl::AsciiStrToLower(env_value) : \"\";\n       if (load_plugin == \"true\" || load_plugin == \"1\") {\n         // We don't register the static filesystem and wait for SIG IO one\n         LOG(WARNING) << \"Using modular file system for '\" << scheme << \"'.\""
        },
        {
            "sha": "f66f2362f40dc47245e4c5fb31ead52ed5b7a320",
            "filename": "third_party/xla/xla/tsl/platform/env_time.h",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv_time.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv_time.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fenv_time.h?ref=257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47",
            "patch": "@@ -25,37 +25,37 @@ namespace tsl {\n /// access timer related operations.\n class EnvTime {\n  public:\n-  static constexpr uint64 kMicrosToPicos = 1000ULL * 1000ULL;\n-  static constexpr uint64 kMicrosToNanos = 1000ULL;\n-  static constexpr uint64 kMillisToMicros = 1000ULL;\n-  static constexpr uint64 kMillisToNanos = 1000ULL * 1000ULL;\n-  static constexpr uint64 kNanosToPicos = 1000ULL;\n-  static constexpr uint64 kSecondsToMillis = 1000ULL;\n-  static constexpr uint64 kSecondsToMicros = 1000ULL * 1000ULL;\n-  static constexpr uint64 kSecondsToNanos = 1000ULL * 1000ULL * 1000ULL;\n+  static constexpr uint64_t kMicrosToPicos = 1000ULL * 1000ULL;\n+  static constexpr uint64_t kMicrosToNanos = 1000ULL;\n+  static constexpr uint64_t kMillisToMicros = 1000ULL;\n+  static constexpr uint64_t kMillisToNanos = 1000ULL * 1000ULL;\n+  static constexpr uint64_t kNanosToPicos = 1000ULL;\n+  static constexpr uint64_t kSecondsToMillis = 1000ULL;\n+  static constexpr uint64_t kSecondsToMicros = 1000ULL * 1000ULL;\n+  static constexpr uint64_t kSecondsToNanos = 1000ULL * 1000ULL * 1000ULL;\n \n   EnvTime() = default;\n   virtual ~EnvTime() = default;\n \n   /// \\brief Returns the number of nano-seconds since the Unix epoch.\n-  static uint64 NowNanos();\n+  static uint64_t NowNanos();\n \n   /// \\brief Returns the number of micro-seconds since the Unix epoch.\n-  static uint64 NowMicros() { return NowNanos() / kMicrosToNanos; }\n+  static uint64_t NowMicros() { return NowNanos() / kMicrosToNanos; }\n \n   /// \\brief Returns the number of seconds since the Unix epoch.\n-  static uint64 NowSeconds() { return NowNanos() / kSecondsToNanos; }\n+  static uint64_t NowSeconds() { return NowNanos() / kSecondsToNanos; }\n \n   /// \\brief A version of NowNanos() that may be overridden by a subclass.\n-  virtual uint64 GetOverridableNowNanos() const { return NowNanos(); }\n+  virtual uint64_t GetOverridableNowNanos() const { return NowNanos(); }\n \n   /// \\brief A version of NowMicros() that may be overridden by a subclass.\n-  virtual uint64 GetOverridableNowMicros() const {\n+  virtual uint64_t GetOverridableNowMicros() const {\n     return GetOverridableNowNanos() / kMicrosToNanos;\n   }\n \n   /// \\brief A version of NowSeconds() that may be overridden by a subclass.\n-  virtual uint64 GetOverridableNowSeconds() const {\n+  virtual uint64_t GetOverridableNowSeconds() const {\n     return GetOverridableNowNanos() / kSecondsToNanos;\n   }\n };"
        },
        {
            "sha": "ff3f44fe4d2ed23717d1df09a215e763c94fded5",
            "filename": "third_party/xla/xla/tsl/platform/file_system.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 27,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Ffile_system.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Ffile_system.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Ffile_system.cc?ref=257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47",
            "patch": "@@ -42,7 +42,8 @@ limitations under the License.\n \n namespace tsl {\n \n-bool FileSystem::Match(const string& filename, const string& pattern) {\n+bool FileSystem::Match(const std::string& filename,\n+                       const std::string& pattern) {\n #if defined(PLATFORM_POSIX) || defined(IS_MOBILE_PLATFORM) || \\\n     defined(PLATFORM_GOOGLE)\n   // We avoid relying on RE2 on mobile platforms, because it incurs a\n@@ -61,7 +62,7 @@ bool FileSystem::Match(const string& filename, const string& pattern) {\n         // defined(PLATFORM_GOOGLE)\n }\n \n-string FileSystem::TranslateName(const string& name) const {\n+std::string FileSystem::TranslateName(const std::string& name) const {\n   // If the name is empty, CleanPath returns \".\" which is incorrect and\n   // we should return the empty path instead.\n   if (name.empty()) return name;\n@@ -76,7 +77,7 @@ string FileSystem::TranslateName(const string& name) const {\n   return this->CleanPath(path);\n }\n \n-absl::Status FileSystem::IsDirectory(const string& name,\n+absl::Status FileSystem::IsDirectory(const std::string& name,\n                                      TransactionToken* token) {\n   // Check if path exists.\n   // TODO(sami):Forward token to other methods once migration is complete.\n@@ -89,15 +90,15 @@ absl::Status FileSystem::IsDirectory(const string& name,\n   return absl::Status(absl::StatusCode::kFailedPrecondition, \"Not a directory\");\n }\n \n-absl::Status FileSystem::HasAtomicMove(const string& path,\n+absl::Status FileSystem::HasAtomicMove(const std::string& path,\n                                        bool* has_atomic_move) {\n   *has_atomic_move = true;\n   return absl::OkStatus();\n }\n \n void FileSystem::FlushCaches(TransactionToken* token) {}\n \n-bool FileSystem::FilesExist(const std::vector<string>& files,\n+bool FileSystem::FilesExist(const std::vector<std::string>& files,\n                             TransactionToken* token,\n                             std::vector<absl::Status>* status) {\n   bool result = true;\n@@ -114,7 +115,7 @@ bool FileSystem::FilesExist(const std::vector<string>& files,\n   return result;\n }\n \n-absl::Status FileSystem::DeleteRecursively(const string& dirname,\n+absl::Status FileSystem::DeleteRecursively(const std::string& dirname,\n                                            TransactionToken* token,\n                                            int64_t* undeleted_files,\n                                            int64_t* undeleted_dirs) {\n@@ -137,27 +138,27 @@ absl::Status FileSystem::DeleteRecursively(const string& dirname,\n     return delete_root_status;\n   }\n \n-  std::deque<string> dir_q;      // Queue for the BFS\n-  std::vector<string> dir_list;  // List of all dirs discovered\n+  std::deque<std::string> dir_q;      // Queue for the BFS\n+  std::vector<std::string> dir_list;  // List of all dirs discovered\n   dir_q.push_back(dirname);\n   absl::Status ret;  // Status to be returned.\n   // Do a BFS on the directory to discover all the sub-directories. Remove all\n   // children that are files along the way. Then cleanup and remove the\n   // directories in reverse order.;\n   while (!dir_q.empty()) {\n-    string dir = dir_q.front();\n+    std::string dir = dir_q.front();\n     dir_q.pop_front();\n     dir_list.push_back(dir);\n-    std::vector<string> children;\n+    std::vector<std::string> children;\n     // GetChildren might fail if we don't have appropriate permissions.\n     absl::Status s = GetChildren(dir, &children);\n     ret.Update(s);\n     if (!s.ok()) {\n       (*undeleted_dirs)++;\n       continue;\n     }\n-    for (const string& child : children) {\n-      const string child_path = this->JoinPath(dir, child);\n+    for (const std::string& child : children) {\n+      const std::string child_path = this->JoinPath(dir, child);\n       // If the child is a directory add it to the queue, otherwise delete it.\n       if (IsDirectory(child_path).ok()) {\n         dir_q.push_back(child_path);\n@@ -175,7 +176,7 @@ absl::Status FileSystem::DeleteRecursively(const string& dirname,\n   // Now reverse the list of directories and delete them. The BFS ensures that\n   // we can delete the directories in this order.\n   std::reverse(dir_list.begin(), dir_list.end());\n-  for (const string& dir : dir_list) {\n+  for (const std::string& dir : dir_list) {\n     // Delete dir might fail because of permissions issues or might be\n     // unimplemented.\n     absl::Status s = DeleteDir(dir);\n@@ -187,7 +188,7 @@ absl::Status FileSystem::DeleteRecursively(const string& dirname,\n   return ret;\n }\n \n-absl::Status FileSystem::RecursivelyCreateDir(const string& dirname,\n+absl::Status FileSystem::RecursivelyCreateDir(const std::string& dirname,\n                                               TransactionToken* token) {\n   absl::string_view scheme, host, remaining_dir;\n   this->ParseURI(dirname, &scheme, &host, &remaining_dir);\n@@ -222,7 +223,7 @@ absl::Status FileSystem::RecursivelyCreateDir(const string& dirname,\n   std::reverse(sub_dirs.begin(), sub_dirs.end());\n \n   // Now create the directories.\n-  string built_path(remaining_dir);\n+  std::string built_path(remaining_dir);\n   for (const absl::string_view sub_dir : sub_dirs) {\n     built_path = this->JoinPath(built_path, sub_dir);\n     absl::Status status = CreateDir(this->CreateURI(scheme, host, built_path));\n@@ -233,22 +234,23 @@ absl::Status FileSystem::RecursivelyCreateDir(const string& dirname,\n   return absl::OkStatus();\n }\n \n-absl::Status FileSystem::CopyFile(const string& src, const string& target,\n+absl::Status FileSystem::CopyFile(const std::string& src,\n+                                  const std::string& target,\n                                   TransactionToken* token) {\n   return FileSystemCopyFile(this, src, this, target);\n }\n \n char FileSystem::Separator() const { return '/'; }\n \n-string FileSystem::JoinPathImpl(\n+std::string FileSystem::JoinPathImpl(\n     std::initializer_list<absl::string_view> paths) {\n-  string result;\n+  std::string result;\n \n   for (absl::string_view path : paths) {\n     if (path.empty()) continue;\n \n     if (result.empty()) {\n-      result = string(path);\n+      result = std::string(path);\n       continue;\n     }\n \n@@ -367,18 +369,18 @@ absl::string_view FileSystem::Extension(absl::string_view path) const {\n   }\n }\n \n-string FileSystem::CleanPath(absl::string_view unclean_path) const {\n-  string path(unclean_path);\n+std::string FileSystem::CleanPath(absl::string_view unclean_path) const {\n+  std::string path(unclean_path);\n   const char* src = path.c_str();\n-  string::iterator dst = path.begin();\n+  std::string::iterator dst = path.begin();\n \n   // Check for absolute path and determine initial backtrack limit.\n   const bool is_absolute_path = *src == '/';\n   if (is_absolute_path) {\n     *dst++ = *src++;\n     while (*src == '/') ++src;\n   }\n-  string::const_iterator backtrack_limit = dst;\n+  std::string::const_iterator backtrack_limit = dst;\n \n   // Process all parts\n   while (*src) {\n@@ -434,7 +436,7 @@ string FileSystem::CleanPath(absl::string_view unclean_path) const {\n   }\n \n   // Calculate and check the length of the cleaned path.\n-  string::difference_type path_length = dst - path.begin();\n+  std::string::difference_type path_length = dst - path.begin();\n   if (path_length != 0) {\n     // Remove trailing '/' except if it is root path (\"/\" ==> path_length := 1)\n     if (path_length > 1 && path[path_length - 1] == '/') {\n@@ -480,10 +482,11 @@ void FileSystem::ParseURI(absl::string_view remaining,\n   *path = remaining;\n }\n \n-string FileSystem::CreateURI(absl::string_view scheme, absl::string_view host,\n-                             absl::string_view path) const {\n+std::string FileSystem::CreateURI(absl::string_view scheme,\n+                                  absl::string_view host,\n+                                  absl::string_view path) const {\n   if (scheme.empty()) {\n-    return string(path);\n+    return std::string(path);\n   }\n   return absl::StrCat(scheme, \"://\", host, path);\n }"
        },
        {
            "sha": "f8c590704a6603eef45e49033b4477e116df4e45",
            "filename": "third_party/xla/xla/tsl/platform/file_system_helper.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Ffile_system_helper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Ffile_system_helper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Ffile_system_helper.cc?ref=257f386a47ab79d87fbbb7e2a87c60d0d2ee7b47",
            "patch": "@@ -121,8 +121,9 @@ static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {\n \n }  // namespace\n \n-absl::Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n-                              std::vector<string>* results) {\n+absl::Status GetMatchingPaths(FileSystem* fs, Env* env,\n+                              const std::string& pattern,\n+                              std::vector<std::string>* results) {\n   // Check that `fs`, `env` and `results` are non-null.\n   if (fs == nullptr || env == nullptr || results == nullptr) {\n     return absl::Status(\n@@ -181,8 +182,8 @@ absl::Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n   // INVARIANT: If `{d, _}` is in queue, then `d` is a real directory.\n   // INVARIANT: If `{_, ix}` is in queue, then `ix < dirs.size() - 1`.\n   // INVARIANT: If `{_, ix}` is in queue, `IsGlobbingPattern(dirs[ix + 1])`.\n-  std::deque<std::pair<string, int>> expand_queue;\n-  std::deque<std::pair<string, int>> next_expand_queue;\n+  std::deque<std::pair<std::string, int>> expand_queue;\n+  std::deque<std::pair<std::string, int>> next_expand_queue;\n   expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);\n \n   // Adding to `result` or `new_expand_queue` need to be protected by mutexes\n@@ -267,7 +268,7 @@ absl::Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n   return absl::OkStatus();\n }\n \n-absl::StatusOr<bool> FileExists(Env* env, const string& fname) {\n+absl::StatusOr<bool> FileExists(Env* env, const std::string& fname) {\n   absl::Status status = env->FileExists(fname);\n   if (absl::IsNotFound(status)) {\n     return false;"
        }
    ],
    "stats": {
        "total": 237,
        "additions": 124,
        "deletions": 113
    }
}