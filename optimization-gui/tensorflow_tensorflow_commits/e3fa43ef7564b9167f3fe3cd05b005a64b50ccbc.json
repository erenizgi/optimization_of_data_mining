{
    "author": "mkuperst",
    "message": "[XLA] Excise module groups from the CompileOnlyClient/CompileOnlyService interface.\n\nLiterally nothing ever calls this interface with more than one module.\n\nPiperOrigin-RevId: 814703152",
    "sha": "e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc",
    "files": [
        {
            "sha": "7d0897829b98cad22ecaa9e85826670fd3be177e",
            "filename": "tensorflow/compiler/aot/compile.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/tensorflow%2Fcompiler%2Faot%2Fcompile.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/tensorflow%2Fcompiler%2Faot%2Fcompile.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcompile.cc?ref=e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc",
            "patch": "@@ -107,7 +107,7 @@ absl::Status CompileXla(xla::CompileOnlyClient* client,\n                       xla::Shape::FromProto(pshape->result()));\n   instance.result_layout = &result_shape;\n   absl::StatusOr<std::vector<std::unique_ptr<xla::AotCompilationResult>>>\n-      aot_or = client->CompileAheadOfTime({instance}, aot_opts);\n+      aot_or = client->CompileAheadOfTime(instance, aot_opts);\n   if (!aot_or.ok()) {\n     return errors::Unknown(\"XLA compilation failed: \",\n                            aot_or.status().message());"
        },
        {
            "sha": "3a9fe305a049481ea783f4be71bf42123ad698bc",
            "filename": "third_party/xla/xla/client/compile_only_client.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 13,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fclient%2Fcompile_only_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fclient%2Fcompile_only_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fclient%2Fcompile_only_client.cc?ref=e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc",
            "patch": "@@ -46,21 +46,15 @@ CompileOnlyClient::CreateModuleConfig(\n \n absl::StatusOr<std::vector<std::unique_ptr<AotCompilationResult>>>\n CompileOnlyClient::CompileAheadOfTime(\n-    const absl::Span<const AotXlaComputationInstance> computations,\n+    const AotXlaComputationInstance& computation,\n     const AotCompilationOptions& options,\n     std::unique_ptr<AotCompilationMetadata>* metadata) {\n-  std::vector<CompileOnlyService::AotXlaComputationInstance> service_instances;\n-  service_instances.reserve(computations.size());\n-  for (const AotXlaComputationInstance& instance : computations) {\n-    service_instances.emplace_back();\n-    CompileOnlyService::AotXlaComputationInstance& service_instance =\n-        service_instances.back();\n-    TF_RET_CHECK(instance.computation != nullptr);\n-    service_instance.computation = instance.computation->proto();\n-    service_instance.argument_layouts = instance.argument_layouts;\n-    service_instance.result_layout = *instance.result_layout;\n-  }\n-  return compiler_service_->CompileAheadOfTime(service_instances, options,\n+  CompileOnlyService::AotXlaComputationInstance service_instance;\n+  TF_RET_CHECK(computation.computation != nullptr);\n+  service_instance.computation = computation.computation->proto();\n+  service_instance.argument_layouts = computation.argument_layouts;\n+  service_instance.result_layout = *computation.result_layout;\n+  return compiler_service_->CompileAheadOfTime(service_instance, options,\n                                                metadata);\n }\n "
        },
        {
            "sha": "53d17b87795a4fbedcf1a733bd9c9338e9cbbe7d",
            "filename": "third_party/xla/xla/client/compile_only_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fclient%2Fcompile_only_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fclient%2Fcompile_only_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fclient%2Fcompile_only_client.h?ref=e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc",
            "patch": "@@ -61,7 +61,7 @@ class CompileOnlyClient : public Client {\n   // code. |metadata|, if provided, is populated during compilation.\n   absl::StatusOr<std::vector<std::unique_ptr<AotCompilationResult>>>\n   CompileAheadOfTime(\n-      absl::Span<const AotXlaComputationInstance> computations,\n+      const AotXlaComputationInstance& computation,\n       const AotCompilationOptions& options,\n       std::unique_ptr<AotCompilationMetadata>* metadata = nullptr);\n "
        },
        {
            "sha": "906577fef41eb8a849cb3f1427a6cca06ba2dbd9",
            "filename": "third_party/xla/xla/service/compile_only_service.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 37,
            "changes": 68,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fservice%2Fcompile_only_service.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fservice%2Fcompile_only_service.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcompile_only_service.cc?ref=e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc",
            "patch": "@@ -63,11 +63,9 @@ CompileOnlyService::CompileOnlyService(const ServiceOptions& options,\n \n absl::StatusOr<std::vector<std::unique_ptr<AotCompilationResult>>>\n CompileOnlyService::CompileAheadOfTime(\n-    absl::Span<const AotXlaComputationInstance> computations,\n+    const AotXlaComputationInstance& computation,\n     const AotCompilationOptions& options,\n     std::unique_ptr<AotCompilationMetadata>* metadata) {\n-  std::vector<std::unique_ptr<HloModule>> hlo_modules;\n-\n   const DebugOptions& debug_options = options.debug_options();\n   ExecutionOptions execution_options;\n   *execution_options.mutable_debug_options() = debug_options;\n@@ -103,44 +101,40 @@ CompileOnlyService::CompileAheadOfTime(\n     execution_options.mutable_auto_spmd_partitioning_mesh_ids()->Add(t);\n   }\n   execution_options.set_deduplicate_hlo(options.deduplicate_hlo());\n-  for (const AotXlaComputationInstance& instance : computations) {\n-    TF_RET_CHECK(instance.computation.has_host_program_shape());\n-    auto update_shape_with_empty_tiles = [this](Shape* subshape,\n-                                                const xla::ShapeIndex& index) {\n-      if (subshape->IsArray() &&\n-          (!subshape->has_layout() || subshape->layout().tiles().empty())) {\n-        *subshape = compiler_->DefaultDeviceShapeRepresentation(*subshape);\n-      }\n-    };\n-    Shape result_layout(instance.result_layout);\n-    ShapeUtil::ForEachMutableSubshape(&result_layout,\n-                                      update_shape_with_empty_tiles);\n-    *execution_options.mutable_shape_with_output_layout() =\n-        result_layout.ToProto();\n-    for (auto shape : instance.argument_layouts) {\n-      ShapeUtil::ForEachMutableSubshape(const_cast<Shape*>(shape),\n-                                        update_shape_with_empty_tiles);\n+  TF_RET_CHECK(computation.computation.has_host_program_shape());\n+  auto update_shape_with_empty_tiles = [this](Shape* subshape,\n+                                              const xla::ShapeIndex& index) {\n+    if (subshape->IsArray() &&\n+        (!subshape->has_layout() || subshape->layout().tiles().empty())) {\n+      *subshape = compiler_->DefaultDeviceShapeRepresentation(*subshape);\n     }\n-\n-    TF_ASSIGN_OR_RETURN(\n-        ProgramShape program_shape,\n-        ProgramShape::FromProto(instance.computation.host_program_shape()));\n-    TF_ASSIGN_OR_RETURN(\n-        std::unique_ptr<HloModuleConfig> module_config,\n-        CreateModuleConfig(program_shape, instance.argument_layouts,\n-                           &execution_options, &options));\n-\n-    TF_ASSIGN_OR_RETURN(\n-        std::unique_ptr<HloModule> hlo_module,\n-        HloModule::CreateFromProto(instance.computation, *module_config));\n-    DumpHloModuleIfEnabled(*hlo_module, \"before_optimizations\");\n-    hlo_modules.push_back(std::move(hlo_module));\n+  };\n+  Shape result_layout(computation.result_layout);\n+  ShapeUtil::ForEachMutableSubshape(&result_layout,\n+                                    update_shape_with_empty_tiles);\n+  *execution_options.mutable_shape_with_output_layout() =\n+      result_layout.ToProto();\n+  for (auto shape : computation.argument_layouts) {\n+    ShapeUtil::ForEachMutableSubshape(const_cast<Shape*>(shape),\n+                                      update_shape_with_empty_tiles);\n   }\n \n+  TF_ASSIGN_OR_RETURN(\n+      ProgramShape program_shape,\n+      ProgramShape::FromProto(computation.computation.host_program_shape()));\n+  TF_ASSIGN_OR_RETURN(\n+      std::unique_ptr<HloModuleConfig> module_config,\n+      CreateModuleConfig(program_shape, computation.argument_layouts,\n+                         &execution_options, &options));\n+\n+  TF_ASSIGN_OR_RETURN(\n+      std::unique_ptr<HloModule> hlo_module,\n+      HloModule::CreateFromProto(computation.computation, *module_config));\n+  DumpHloModuleIfEnabled(*hlo_module, \"before_optimizations\");\n+\n   return compiler_->CompileAheadOfTime(\n-      std::make_unique<HloModuleGroup>(hlo_modules[0]->name(),\n-                                       absl::MakeSpan(hlo_modules)),\n-      options, metadata);\n+      std::make_unique<HloModuleGroup>(std::move(hlo_module)), options,\n+      metadata);\n }\n \n }  // namespace xla"
        },
        {
            "sha": "72abeef25d32b3c3fb27fa996f7005189e356a5d",
            "filename": "third_party/xla/xla/service/compile_only_service.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fservice%2Fcompile_only_service.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc/third_party%2Fxla%2Fxla%2Fservice%2Fcompile_only_service.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcompile_only_service.h?ref=e3fa43ef7564b9167f3fe3cd05b005a64b50ccbc",
            "patch": "@@ -49,7 +49,7 @@ class CompileOnlyService : public Service {\n   // intended for use in static compilation.  See\n   // |CompileOnlyClient::CompileAheadOfTime| for additional details.\n   absl::StatusOr<std::vector<std::unique_ptr<AotCompilationResult>>>\n-  CompileAheadOfTime(absl::Span<const AotXlaComputationInstance> computations,\n+  CompileAheadOfTime(const AotXlaComputationInstance& computation,\n                      const AotCompilationOptions& options,\n                      std::unique_ptr<AotCompilationMetadata>* metadata);\n "
        }
    ],
    "stats": {
        "total": 94,
        "additions": 41,
        "deletions": 53
    }
}