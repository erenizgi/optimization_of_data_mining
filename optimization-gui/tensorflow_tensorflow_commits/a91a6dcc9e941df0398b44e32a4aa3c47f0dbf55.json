{
    "author": "WillFroom",
    "message": "[XTile] Introduce to/from tensor ops.\n\nPiperOrigin-RevId: 827514977",
    "sha": "a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55",
    "files": [
        {
            "sha": "714bdbf033fc51d6d4c3b43447b44d0287621faa",
            "filename": "third_party/xla/xla/codegen/xtile/ir/tests/to_from_tensor.mlir",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Ftests%2Fto_from_tensor.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Ftests%2Fto_from_tensor.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Ftests%2Fto_from_tensor.mlir?ref=a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55",
            "patch": "@@ -0,0 +1,17 @@\n+// RUN: emitters_opt %s  -canonicalize | FileCheck %s\n+\n+// CHECK-LABEL: @to_scalar_roundtrip\n+func.func @to_scalar_roundtrip(%arg0: tensor<i32>) -> tensor<i32> {\n+  %0 = xtile.to_scalar %arg0 : tensor<i32>\n+  %1 = xtile.to_tensor %0 : i32\n+  // CHECK: return %arg0 : tensor<i32>\n+  return %1 : tensor<i32>\n+}\n+\n+// CHECK-LABEL: @to_tensor_roundtrip\n+func.func @to_tensor_roundtrip(%arg0: i32) -> i32 {\n+  %0 = xtile.to_tensor %arg0 : i32\n+  %1 = xtile.to_scalar %0 : tensor<i32>\n+  // CHECK: return %arg0 : i32\n+  return %1 : i32\n+}"
        },
        {
            "sha": "feffd37ec877ace9a870a808a93419b7244c4868",
            "filename": "third_party/xla/xla/codegen/xtile/ir/xtile_ops.cc",
            "status": "modified",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Fxtile_ops.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Fxtile_ops.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Fxtile_ops.cc?ref=a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55",
            "patch": "@@ -196,4 +196,58 @@ mlir::TypedValue<mlir::RankedTensorType> InsertTileOp::getTile() {\n \n mlir::LogicalResult InsertTileOp::verify() { return VerifyBufferOp(*this); }\n \n+mlir::LogicalResult ToScalarOp::inferReturnTypes(\n+    mlir::MLIRContext* context, ::std::optional<mlir::Location> location,\n+    mlir::ValueRange operands, mlir::DictionaryAttr attributes,\n+    mlir::OpaqueProperties properties, mlir::RegionRange regions,\n+    ::llvm::SmallVectorImpl<mlir::Type>& inferredReturnTypes) {\n+  if (operands.size() != 1) {\n+    return mlir::failure();\n+  }\n+\n+  auto tensor_type =\n+      mlir::dyn_cast<mlir::RankedTensorType>(operands[0].getType());\n+  if (!tensor_type) {\n+    return mlir::failure();\n+  }\n+\n+  if (tensor_type.getRank() != 0) {\n+    return mlir::failure();\n+  }\n+\n+  inferredReturnTypes.push_back(tensor_type.getElementType());\n+  return mlir::success();\n+}\n+\n+mlir::OpFoldResult ToScalarOp::fold(FoldAdaptor adaptor) {\n+  if (auto to_tensor = getOperand().getDefiningOp<ToTensorOp>()) {\n+    // to_scalar(to_tensor(x)) -> x\n+    return to_tensor.getOperand();\n+  }\n+\n+  return {};\n+}\n+\n+mlir::LogicalResult ToTensorOp::inferReturnTypes(\n+    mlir::MLIRContext* context, ::std::optional<mlir::Location> location,\n+    mlir::ValueRange operands, mlir::DictionaryAttr attributes,\n+    mlir::OpaqueProperties properties, mlir::RegionRange regions,\n+    ::llvm::SmallVectorImpl<mlir::Type>& inferredReturnTypes) {\n+  if (operands.size() != 1) {\n+    return mlir::failure();\n+  }\n+  inferredReturnTypes.push_back(\n+      mlir::RankedTensorType::get({}, operands[0].getType()));\n+  return mlir::success();\n+}\n+\n+mlir::OpFoldResult ToTensorOp::fold(FoldAdaptor adaptor) {\n+  if (auto to_scalar = getOperand().getDefiningOp<ToScalarOp>()) {\n+    // to_tensor(to_scalar(x)) -> x\n+    return to_scalar.getOperand();\n+  }\n+\n+  return {};\n+}\n+\n }  // namespace xla::xtile"
        },
        {
            "sha": "3a76c41340ea902c053231962f340b0cebd6321c",
            "filename": "third_party/xla/xla/codegen/xtile/ir/xtile_ops.td",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Fxtile_ops.td",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Fxtile_ops.td",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fxtile%2Fir%2Fxtile_ops.td?ref=a91a6dcc9e941df0398b44e32a4aa3c47f0dbf55",
            "patch": "@@ -202,5 +202,27 @@ def InsertTileOp : XTile_Op<\"insert\", [TiledBufferInterface]> {\n   let hasVerifier = 1;\n }\n \n+// TODO(willfroom): Revisit if/where these are needed after the migration of the\n+// triton emitter to support 0D tensors is complete.\n+def ToScalarOp : XTile_Op<\"to_scalar\", [Pure, DeclareOpInterfaceMethods<InferTypeOpInterface>]> {\n+  let summary = \"Converts a 0D tensor to a scalar\";\n+  let arguments = (ins 0DTensorOf<[AnyType]>:$input);\n+  let results = (outs AnyType:$output);\n+\n+  let assemblyFormat = \"$input `:` type($input) attr-dict\";\n+\n+  let hasFolder = 1;\n+}\n+\n+def ToTensorOp : XTile_Op<\"to_tensor\", [Pure, DeclareOpInterfaceMethods<InferTypeOpInterface>]> {\n+  let summary = \"Converts a scalar to a 0D tensor\";\n+  let arguments = (ins AnyType:$input);\n+  let results = (outs 0DTensorOf<[AnyType]>:$output);\n+\n+  let assemblyFormat = \"$input `:` type($input) attr-dict\";\n+\n+  let hasFolder = 1;\n+}\n+\n #endif // XLA_CODEGEN_XTILE_IR_XTILE_OPS\n "
        }
    ],
    "stats": {
        "total": 93,
        "additions": 93,
        "deletions": 0
    }
}