{
    "author": "tensorflower-gardener",
    "message": "[XLA:MSA] Speed up Evict() by combining computations across retries.\n\nIn `Evict()`, for each buffer with live range [b.start, b.end), we are trying to find the smallest x, such that restricting its live range to [b.start, x), there is  a free chunk at the preferred_offset.\n\nCurrently, we begin with x = b.end, compute the free chunks, check if there is an appropriate free chunk. If not, then decrease x and retry. The retry essentially processes a subset of the intervals from the previous iteration.\n\nThis CL tries to find x directly. It processes the buffers in order of increasing live range starting point (by doing an inorder traversal of the interval_tree and then subtracts the chunks one by one, until there is no free chunk at the preferred offset. This avoids the need for retries.\n\nPiperOrigin-RevId: 800017255",
    "sha": "a25e0396fe04288c9cd584f34b49ad05ba583d5c",
    "files": [
        {
            "sha": "0fbf1d46f6140ac8c643ca61d2094156fe0a5cfb",
            "filename": "third_party/xla/xla/service/heap_simulator/heap_simulator.cc",
            "status": "modified",
            "additions": 100,
            "deletions": 10,
            "changes": 110,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a25e0396fe04288c9cd584f34b49ad05ba583d5c/third_party%2Fxla%2Fxla%2Fservice%2Fheap_simulator%2Fheap_simulator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a25e0396fe04288c9cd584f34b49ad05ba583d5c/third_party%2Fxla%2Fxla%2Fservice%2Fheap_simulator%2Fheap_simulator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fheap_simulator%2Fheap_simulator.cc?ref=a25e0396fe04288c9cd584f34b49ad05ba583d5c",
            "patch": "@@ -759,6 +759,22 @@ GlobalDecreasingSizeBestFitHeap<BufferType>::GetTransitiveColocations(\n   return result;\n }\n \n+template <typename BufferType>\n+int64_t GlobalDecreasingSizeBestFitHeap<BufferType>::ComputeAlignedChunkEnd(\n+    int64_t chunk_end) const {\n+  int64_t chunk_end_aligned = chunk_end;\n+  if (alignment_ != 1) {\n+    if (absl::has_single_bit(static_cast<uint64_t>(alignment_))) {\n+      // Alignment is 2^n, add 2^n-1 and then zero the last n bits.\n+      chunk_end_aligned =\n+          (chunk_end_aligned + alignment_ - 1) & ~(alignment_ - 1);\n+    } else {\n+      chunk_end_aligned = RoundUpTo(chunk_end, alignment_);\n+    }\n+  }\n+  return chunk_end_aligned;\n+}\n+\n template <typename BufferType>\n void GlobalDecreasingSizeBestFitHeap<BufferType>::Free(const BufferType* buffer,\n                                                        int64_t size) {\n@@ -968,6 +984,62 @@ void BufferIntervalTree::ApplyToNodesOverlappingInTime(\n   }\n }\n \n+void BufferIntervalTree::ApplyToSortedNodesOverlapping(\n+    int64_t start, int64_t end,\n+    absl::FunctionRef<bool(const BufferIntervalTreeNode*)> fn) const {\n+  if (root_ == nullptr) {\n+    return;\n+  }\n+  // We do an inorder traversal of the binary tree, keeping in the visiting\n+  // stack whether we have visited the left subtree of the current node.\n+  struct NodeInfo {\n+    const BufferIntervalTreeNode* node;\n+    bool have_visited_left_subtree;\n+\n+    NodeInfo(const BufferIntervalTreeNode* node, bool have_visited_left_subtree)\n+        : node(node), have_visited_left_subtree(have_visited_left_subtree) {}\n+  };\n+  std::vector<NodeInfo> visiting_stack;\n+  visiting_stack.emplace_back(root_, false);\n+  int64_t prev_start = -1;\n+  while (!visiting_stack.empty()) {\n+    auto top = visiting_stack.back();\n+    // Skip the subtree if there is no overlap with the given interval.\n+    if (start > top.node->subtree_end) {\n+      visiting_stack.pop_back();\n+      continue;\n+    }\n+    // Ensure that we have first visited the left child.\n+    const BufferIntervalTreeNode* left = top.node->left;\n+    if (!top.have_visited_left_subtree && left != nullptr) {\n+      visiting_stack.back().have_visited_left_subtree = true;\n+      visiting_stack.emplace_back(left, false);\n+      continue;\n+    }\n+    // Visit current node.\n+    const int64_t top_start = top.node->start;\n+    if (top_start <= end && top.node->end >= start) {\n+      // Ensure that this is indeed an inorder traversal.\n+      CHECK_LE(prev_start, top_start);\n+      prev_start = top_start;\n+      // If the callback signals, then we terminate the traversal early.\n+      if (fn(top.node)) {\n+        break;\n+      }\n+    }\n+    visiting_stack.pop_back();\n+    // Skip the right subtree if there is no overlap.\n+    if (end < top_start) {\n+      continue;\n+    }\n+    // Finally, visit the right child.\n+    if (const BufferIntervalTreeNode* right = top.node->right;\n+        right != nullptr) {\n+      visiting_stack.emplace_back(right, false);\n+    }\n+  }\n+}\n+\n int BufferIntervalTree::NumChunksOverlappingInTime(int64_t start,\n                                                    int64_t end) const {\n   int result = 0;\n@@ -2395,16 +2467,7 @@ GlobalDecreasingSizeBestFitHeap<BufferType>::MakeFreeChunks(\n     free_chunks.erase(it_end, it_start);\n \n     // Create a new free chunk after the used chunk, if it is large enough.\n-    int64_t chunk_end_aligned = used_chunk.chunk_end();\n-    if (alignment_ != 1) {\n-      if (absl::has_single_bit(static_cast<uint64_t>(alignment_))) {\n-        // Alignment is 2^n, add 2^n-1 and then zero the last n bits.\n-        chunk_end_aligned =\n-            (chunk_end_aligned + alignment_ - 1) & ~(alignment_ - 1);\n-      } else {\n-        chunk_end_aligned = RoundUpTo(used_chunk.chunk_end(), alignment_);\n-      }\n-    }\n+    int64_t chunk_end_aligned = ComputeAlignedChunkEnd(used_chunk.chunk_end());\n     if (free_chunk_end - chunk_end_aligned >= max_colocation_size) {\n       CHECK(free_chunks.insert({chunk_end_aligned, free_chunk_end}).second);\n     }\n@@ -2426,6 +2489,33 @@ GlobalDecreasingSizeBestFitHeap<BufferType>::MakeFreeChunks(\n   return free_chunks;\n }\n \n+template <typename BufferType>\n+int64_t GlobalDecreasingSizeBestFitHeap<BufferType>::\n+    FindLatestEndWithFreeChunkAtPreferredOffset(\n+        const BufferInterval& buffer_interval, int64_t preferred_offset) const {\n+  CHECK_GE(preferred_offset, 0);\n+  int64_t latest_end_with_free_chunk_at_preferred_offset = buffer_interval.end;\n+\n+  interval_tree_.ApplyToSortedNodesOverlapping(\n+      buffer_interval.start, buffer_interval.end,\n+      [&](const BufferIntervalTreeNode* node) {\n+        const Chunk& used_chunk = node->chunk;\n+        if ((used_chunk.offset < preferred_offset &&\n+             preferred_offset <\n+                 ComputeAlignedChunkEnd(used_chunk.chunk_end())) ||\n+            (preferred_offset <= used_chunk.offset &&\n+             used_chunk.offset < preferred_offset + buffer_interval.size)) {\n+          // There is a chunk that intersects with the preferred location, then\n+          // stop the search.\n+          latest_end_with_free_chunk_at_preferred_offset = node->start - 1;\n+          return true;\n+        }\n+        return false;\n+      });\n+\n+  return latest_end_with_free_chunk_at_preferred_offset;\n+}\n+\n template <typename BufferType>\n std::vector<typename GlobalDecreasingSizeBestFitHeap<BufferType>::Chunk>\n GlobalDecreasingSizeBestFitHeap<BufferType>::FindChunkCandidates("
        },
        {
            "sha": "498eb5a1bad406f4314f43b47e54f7c119d51be7",
            "filename": "third_party/xla/xla/service/heap_simulator/heap_simulator.h",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a25e0396fe04288c9cd584f34b49ad05ba583d5c/third_party%2Fxla%2Fxla%2Fservice%2Fheap_simulator%2Fheap_simulator.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a25e0396fe04288c9cd584f34b49ad05ba583d5c/third_party%2Fxla%2Fxla%2Fservice%2Fheap_simulator%2Fheap_simulator.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fheap_simulator%2Fheap_simulator.h?ref=a25e0396fe04288c9cd584f34b49ad05ba583d5c",
            "patch": "@@ -367,6 +367,13 @@ class BufferIntervalTree {\n       int64_t start, int64_t end,\n       absl::FunctionRef<void(const BufferIntervalTreeNode*)> fn) const;\n \n+  // Apply fn to the nodes that overlap with the given time interval. It is\n+  // guaranteed that fn is called for non-null nodes in order of non-decreasing\n+  // start time. If fn returns true, then no more nodes are visited.\n+  void ApplyToSortedNodesOverlapping(\n+      int64_t start, int64_t end,\n+      absl::FunctionRef<bool(const BufferIntervalTreeNode*)> fn) const;\n+\n   // Returns the number of allocated chunks that overlap with the given time\n   // interval.\n   int NumChunksOverlappingInTime(int64_t start, int64_t end) const;\n@@ -898,6 +905,11 @@ class GlobalDecreasingSizeBestFitHeap : public HeapAlgorithm<BufferType> {\n   FreeChunks MakeFreeChunks(const BufferInterval& buffer_interval,\n                             int64_t max_colocation_size) const;\n \n+  // Finds the latest value <= buffer_interval.end such that that no chunk\n+  // intersects [preferred_offset, preferred_offset + buffer_interval.size).\n+  int64_t FindLatestEndWithFreeChunkAtPreferredOffset(\n+      const BufferInterval& buffer_interval, int64_t preferred_offset) const;\n+\n   // These two methods below are exposed to other heap algorithms that inherit\n   // from this class. The Finish() method tries to find a candidate chunk for\n   // each BufferInterval, after calling GetSortedBufferIntervals. If a\n@@ -969,6 +981,9 @@ class GlobalDecreasingSizeBestFitHeap : public HeapAlgorithm<BufferType> {\n   // returns all three of them.\n   absl::flat_hash_set<const BufferType*> GetTransitiveColocations(\n       const BufferInterval& interval) const;\n+\n+  // Returns the aligned chunk end.\n+  int64_t ComputeAlignedChunkEnd(int64_t chunk_end) const;\n };\n \n // This class implements an algorithm that will produce multiple heaps, where"
        },
        {
            "sha": "78fdf4e76c1804500f1745d4fdcf2f4ed881f863",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 3,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a25e0396fe04288c9cd584f34b49ad05ba583d5c/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a25e0396fe04288c9cd584f34b49ad05ba583d5c/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc?ref=a25e0396fe04288c9cd584f34b49ad05ba583d5c",
            "patch": "@@ -6175,11 +6175,31 @@ AllocationResult MsaAlgorithm::Evict(const AllocationRequest& request,\n              !edge_time_indices_.contains(next_eviction_end_time));\n     return next_eviction_end_time;\n   };\n+  int64_t original_end_time = eviction_mem_interval.end;\n   for (; eviction_mem_interval.end > eviction_end_time;\n        eviction_mem_interval.end = next_eviction_end_time_candidate()) {\n-    Chunk chunk_candidate =\n-        FindChunkCandidate(eviction_mem_interval, preferred_offset);\n-    if (chunk_candidate.offset == preferred_offset) {\n+    Chunk chunk_candidate;\n+    // If the buffer has no colocations, then use the fast algorithm to find\n+    // the earliest end time with a free chunk at the preferred offset.\n+    if (GetTransitiveColocations(eviction_mem_interval).empty()) {\n+      int64_t earliest_end_with_free_chunk =\n+          FindLatestEndWithFreeChunkAtPreferredOffset(eviction_mem_interval,\n+                                                      preferred_offset);\n+      if (earliest_end_with_free_chunk <= eviction_end_time) {\n+        eviction_mem_interval.end = eviction_end_time;\n+        break;\n+      }\n+      eviction_mem_interval.end = earliest_end_with_free_chunk;\n+      chunk_candidate =\n+          Chunk::FromOffsetSize(preferred_offset, eviction_mem_interval.size);\n+    } else {\n+      chunk_candidate =\n+          FindChunkCandidate(eviction_mem_interval, preferred_offset);\n+    }\n+\n+    if (chunk_candidate.offset == preferred_offset &&\n+        (eviction_mem_interval.end == original_end_time ||\n+         edge_time_indices_.contains(eviction_mem_interval.end))) {\n       AddToPendingChunks(eviction_mem_interval, chunk_candidate);\n       break;\n     }"
        }
    ],
    "stats": {
        "total": 151,
        "additions": 138,
        "deletions": 13
    }
}