{
    "author": "tensorflower-gardener",
    "message": "Ignore copy fusions that change tiling in HLO dataflow analysis, as they will be handled by the emitters.\n\nPiperOrigin-RevId: 840739467",
    "sha": "c8232df86a463a25f98bf71cd2fb01e31407f6fa",
    "files": [
        {
            "sha": "893c233f9bd1c2aa7d05eb377918e4680272bb45",
            "filename": "third_party/xla/xla/hlo/analysis/hlo_dataflow_analysis.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 1,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8232df86a463a25f98bf71cd2fb01e31407f6fa/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_dataflow_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8232df86a463a25f98bf71cd2fb01e31407f6fa/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_dataflow_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_dataflow_analysis.cc?ref=c8232df86a463a25f98bf71cd2fb01e31407f6fa",
            "patch": "@@ -44,6 +44,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/layout.h\"\n #include \"xla/map_util.h\"\n #include \"xla/service/call_graph.h\"\n #include \"xla/service/hlo_value.h\"\n@@ -1616,6 +1617,26 @@ HloDataflowAnalysis::GetInPlaceInputOutputPairs(\n   return alias_info->GetInPlaceInputOutputPairs(instruction);\n }\n \n+// Returns true if the instruction is a fusion consisting of a single copy which\n+// changes tiling. This is handled by the emitters and effectively are no-ops.\n+static bool IsChangeTilingCopyFusion(HloInstruction* instr) {\n+  if (!instr->parent()->IsFusionComputation() ||\n+      instr->opcode() != HloOpcode::kFusion ||\n+      instr->called_computations().size() != 1 || instr->operand_count() != 1) {\n+    return false;\n+  }\n+  // These copy fusions should only change tiling (and sometimes memory space).\n+  HloInstruction* fusion_root = instr->fused_expression_root();\n+  const Layout& operand_layout = fusion_root->operand(0)->shape().layout();\n+  const Layout& output_layout = fusion_root->shape().layout();\n+  absl::Span<const Tile> operand_tiles = operand_layout.tiles();\n+  absl::Span<const Tile> output_tiles = output_layout.tiles();\n+  return fusion_root->opcode() == HloOpcode::kCopy &&\n+         Layout::Equal().IgnoreTiles().IgnoreMemorySpace()(operand_layout,\n+                                                           output_layout) &&\n+         operand_tiles != output_tiles;\n+}\n+\n bool HloDataflowAnalysis::CanShareOperandBufferWithUser(\n     HloInstruction* operand, const ShapeIndex& operand_index,\n     HloInstruction* user, const ShapeIndex& user_index,\n@@ -1631,7 +1652,12 @@ bool HloDataflowAnalysis::CanShareOperandBufferWithUser(\n   const Shape& user_subshape =\n       ShapeUtil::GetSubshape(user->shape(), user_index);\n \n-  auto shapes_equal = ShapeUtil::Equal(operand_subshape, user_subshape);\n+  // During tiling assignment, we can add no-op instructions which appear to\n+  // change tiling (and memory space) of the operand, but don't.\n+  if (IsChangeTilingCopyFusion(user) || IsChangeTilingCopyFusion(operand)) {\n+    return true;\n+  }\n+  const bool shapes_equal = ShapeUtil::Equal(operand_subshape, user_subshape);\n   // Check that operand and user emit the same shape and layout.\n   if (shapes_equal) {\n     // Must-alias relationship returns true for in-place operations (DUS and DUS"
        }
    ],
    "stats": {
        "total": 28,
        "additions": 27,
        "deletions": 1
    }
}