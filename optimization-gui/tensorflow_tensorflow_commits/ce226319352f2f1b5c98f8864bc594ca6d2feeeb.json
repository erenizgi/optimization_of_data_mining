{
    "author": "tensorflower-gardener",
    "message": "Return an error if a tracked buffer cannot be retrieved.\n\nPiperOrigin-RevId: 834100455",
    "sha": "ce226319352f2f1b5c98f8864bc594ca6d2feeeb",
    "files": [
        {
            "sha": "6784a0b06bc770144c415a45a250b1ab9ef9a5f4",
            "filename": "third_party/xla/xla/pjrt/gpu/tfrt/tfrt_gpu_executable.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 61,
            "changes": 109,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ce226319352f2f1b5c98f8864bc594ca6d2feeeb/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_executable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ce226319352f2f1b5c98f8864bc594ca6d2feeeb/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_executable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_executable.cc?ref=ce226319352f2f1b5c98f8864bc594ca6d2feeeb",
            "patch": "@@ -436,70 +436,57 @@ absl::StatusOr<PjRtLoadedExecutable::Result> TfrtGpuExecutable::ExecuteHelper(\n         options.non_donatable_input_indices.contains(i);\n     bool must_donate = donate_it != donated_params.end() && *donate_it == i &&\n                        !donation_denied_at_runtime;\n-    auto tracked_buffer_or = [&]() -> absl::StatusOr<TrackedGpuDeviceBuffer*> {\n-      TrackedGpuDeviceBuffer* tracked_buffer = nullptr;\n-      if (must_donate) {\n-        VLOG(3) << \"Buffer for argument_handles[\" << i << \"] is donated\";\n-\n-        ++donate_it;\n-        TF_RETURN_IF_ERROR(TestBufferDonationClashes(\n-            handle, donation_clashes, must_donate, i, replica, partition));\n-        TF_ASSIGN_OR_RETURN(auto donation_transaction,\n-                            tfrt_buffer->AcquireDonation());\n-\n-        // After acquiring the buffer for donation, we retrieve the dependent\n-        // usage events. Note that we don't need any locking here as\n-        // AcquireDonation() is supposed to synchronize with other usages.\n-        input_deps.push_back(\n-            donation_transaction.device_buffer()->AfterAllUsageEvents());\n-        tracked_buffer = donation_transaction.device_buffer();\n-        donation_transactions.push_back(std::move(donation_transaction));\n-        buffer_is_donated.push_back(true);\n-      } else {\n-        tracked_buffer = tfrt_buffer->AcquireUsage(complete_event);\n-        if (!tracked_buffer) {\n-          return InvalidArgument(\n-              \"Invalid buffer passed: buffer has been deleted or donated.\");\n-        }\n-        buffer_is_donated.push_back(false);\n-      }\n-      return tracked_buffer;\n-    }();\n-\n-    if (!tracked_buffer_or.ok()) {\n-      // If something failed when preparing the input, we still need to add it\n-      // to the input deps so that it can poison the output buffers.\n-      auto error_av = tsl::MakeErrorAsyncValueRef(tracked_buffer_or.status());\n-      prepare_input_deps.push_back(error_av);\n-      input_deps.push_back(error_av);\n-\n-      LOG(ERROR) << \"argument_handles[\" << i\n-                 << \"]: failed to get tracked buffer with status \"\n-                 << tracked_buffer_or.status();\n+\n+    // Prepare the tracked buffer for the input.\n+    TrackedGpuDeviceBuffer* tracked_buffer = nullptr;\n+    if (must_donate) {\n+      VLOG(3) << \"Buffer for argument_handles[\" << i << \"] is donated\";\n+\n+      ++donate_it;\n+      TF_RETURN_IF_ERROR(TestBufferDonationClashes(\n+          handle, donation_clashes, must_donate, i, replica, partition));\n+      TF_ASSIGN_OR_RETURN(auto donation_transaction,\n+                          tfrt_buffer->AcquireDonation());\n+\n+      // After acquiring the buffer for donation, we retrieve the dependent\n+      // usage events. Note that we don't need any locking here as\n+      // AcquireDonation() is supposed to synchronize with other usages.\n+      input_deps.push_back(\n+          donation_transaction.device_buffer()->AfterAllUsageEvents());\n+      tracked_buffer = donation_transaction.device_buffer();\n+      donation_transactions.push_back(std::move(donation_transaction));\n+      buffer_is_donated.push_back(true);\n     } else {\n-      TrackedGpuDeviceBuffer* tracked_buffer = tracked_buffer_or.value();\n-      tracked_buffers.push_back(tracked_buffer);\n-      prepare_input_deps.push_back(tracked_buffer->buffer().CopyRCRef());\n-\n-      VLOG(3) << \"argument_handles[\" << i << \"]: addr = \"\n-              << (tracked_buffer->buffer().IsAvailable()\n-                      ? tracked_buffer->buffer()->buffer().opaque()\n-                      : \"NotReady\")\n-              << \", logical shape = \"\n-              << tfrt_buffer->logical_on_device_shape()->ToString();\n-\n-      // Definition events are never modified after buffer construction. If they\n-      // are available and have no error, they can be skipped in input deps.\n-      // In contrast, already known errors in the input are taken as deps so\n-      // that they can poison output buffers.\n-      const auto& definition_event = tracked_buffer->definition_event();\n-      if (!definition_event.IsAvailable() || definition_event.IsError()) {\n-        VLOG(3) << \"definition_event is not available: AsyncValue pointer: \"\n-                << definition_event.GetAsyncValue();\n-        input_deps.push_back(definition_event.CopyRCRef());\n+      tracked_buffer = tfrt_buffer->AcquireUsage(complete_event);\n+      if (!tracked_buffer) {\n+        return InvalidArgument(\n+            \"Invalid buffer passed: buffer has been deleted or donated.\");\n       }\n-      ready_deps.push_back(tracked_buffer->ready_event().CopyRCRef());\n+      buffer_is_donated.push_back(false);\n+    }\n+\n+    // By now, the tracked buffer is guaranteed to be valid.\n+    tracked_buffers.push_back(tracked_buffer);\n+    prepare_input_deps.push_back(tracked_buffer->buffer().CopyRCRef());\n+\n+    VLOG(3) << \"argument_handles[\" << i << \"]: addr = \"\n+            << (tracked_buffer->buffer().IsAvailable()\n+                    ? tracked_buffer->buffer()->buffer().opaque()\n+                    : \"NotReady\")\n+            << \", logical shape = \"\n+            << tfrt_buffer->logical_on_device_shape()->ToString();\n+\n+    // Definition events are never modified after buffer construction. If they\n+    // are available and have no error, they can be skipped in input deps.\n+    // In contrast, already known errors in the input are taken as deps so\n+    // that they can poison output buffers.\n+    const auto& definition_event = tracked_buffer->definition_event();\n+    if (!definition_event.IsAvailable() || definition_event.IsError()) {\n+      VLOG(3) << \"definition_event is not available: AsyncValue pointer: \"\n+              << definition_event.GetAsyncValue();\n+      input_deps.push_back(definition_event.CopyRCRef());\n     }\n+    ready_deps.push_back(tracked_buffer->ready_event().CopyRCRef());\n   }\n \n   {"
        }
    ],
    "stats": {
        "total": 109,
        "additions": 48,
        "deletions": 61
    }
}