{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Merge Future<T>::TryMap into Future<T>::Map\n\nFuture<T>::Map(f) now supports three types of `f` functors:\n1. (...) -> absl::Status      to Future<>\n2. (...) -> absl::StatusOr<R> to Future<R>\n3. (...) -> R                 to Future<R>\n\nReverts 93bcfe510df0894dce0ae332bb086331643a01de\n\nPiperOrigin-RevId: 814387992",
    "sha": "cafc68871e93587135664c984447f02e8a9f6963",
    "files": [
        {
            "sha": "380891fb2e48ba1e8d9012de39d2d04ecd2797a5",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 130,
            "deletions": 181,
            "changes": 311,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cafc68871e93587135664c984447f02e8a9f6963/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cafc68871e93587135664c984447f02e8a9f6963/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=cafc68871e93587135664c984447f02e8a9f6963",
            "patch": "@@ -345,9 +345,8 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   // callback, for example by using the callback to enqueue work on a\n   // client-owned threadpool.\n   template <typename F,\n-            std::enable_if_t<is_move_only ? std::is_invocable_v<F, T>\n-                                          : std::is_invocable_v<F, const T&>>* =\n-                nullptr>\n+            std::enable_if_t<std::is_invocable_v<\n+                F, std::conditional_t<is_move_only, T, const T&>>>* = nullptr>\n   void OnReady(F&& f) && {\n     CHECK(IsValid());\n     promise_.AndThen(\n@@ -387,6 +386,19 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   FutureHelpers::OnBlockEnd on_block_end_;\n };\n \n+// A type predicate to check if a type combination of `R` and `U` is\n+// valid for `Future<T>::Map(...)` methods defined below.\n+template <typename R, typename U>\n+struct IsMappable : public std::is_constructible<R, U> {};\n+template <>\n+struct IsMappable<void, absl::Status> : public std::true_type {};\n+template <typename R, typename U>\n+struct IsMappable<R, absl::StatusOr<U>> : public std::is_constructible<R, U> {};\n+\n+// A pre C++20 \"concept\" that checks if `R` and `U` are mappable types.\n+template <typename R, typename U>\n+using Mappable = std::enable_if_t<IsMappable<R, U>::value>;\n+\n }  // namespace internal\n \n // Future<T> is a simple future that is returned by  APIs that enqueue\n@@ -409,10 +421,6 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n \n   static constexpr bool is_move_only = Base::IsMoveOnly();  // NOLINT\n \n-  template <typename U>\n-  static constexpr bool is_status_or =  // NOLINT\n-      tsl::internal::is_status_or_v<U>;\n-\n   static_assert(!std::is_same_v<T, absl::Status>,\n                 \"Use Future<> specialization for stateless futures\");\n \n@@ -511,107 +519,46 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //   return U(value); // R must be constructible from U\n   // })\n   //\n+  // Supported `R` and `U` type combinations:\n+  //\n+  // - `Future<>`  from `(const T&) -> absl::Status`\n+  // - `Future<R>` from `(const T&) -> absl::StatusOr<U>`\n+  // - `Future<R>` from `(const T&) -> U`\n+  //\n+  // See `Map` functor type inference defined below for more details.\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<F, const T&>,\n-            std::enable_if_t<!is_move_only && std::is_constructible_v<R, U>>* =\n-                nullptr>\n+            internal::Mappable<R, U>* = nullptr>\n   Future<R> Map(F&& f) const& {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     using Value = const absl::StatusOr<T>&;\n     OnReady([promise = std::move(promise),\n              f = std::forward<F>(f)](Value value) mutable {\n+      // Do not compute `f` if the result is unused.\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        promise.emplace(absl::in_place_t{}, f(*value));\n-      } else {\n-        promise.Set(value.status());\n+        return;\n       }\n-    });\n-\n-    return std::move(future);\n-  }\n \n-  // Returns an Future<R> that is constructed from the result of invoking\n-  // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage: move-only type T passed by value\n-  //\n-  // std::move(future).Map<R>([](T value) -> U {\n-  //   return U(std::move(value)); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F,\n-            typename U = std::invoke_result_t<\n-                F, std::conditional_t<is_move_only, T, const T&>>,\n-            std::enable_if_t<std::is_constructible_v<R, U>>* = nullptr>\n-  Future<R> Map(F&& f) && {\n-    auto [promise, future] = Future<R>::MakePromise();\n-\n-    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n-                                     const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady([promise = std::move(promise),\n-                              f = std::forward<F>(f)](Value value) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        if constexpr (is_move_only) {\n-          promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n-        } else {\n-          promise.emplace(absl::in_place_t{}, f(*value));\n-        }\n-      } else {\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!value.ok())) {\n         promise.Set(value.status());\n+        return;\n       }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // Returns an Future<R> that is constructed from the result of invoking\n-  // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error. Functor `f` must return a value of type\n-  // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n-  // is automatically unwrapped and returned as a future payload.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage:\n-  //\n-  // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <\n-      typename R, typename F, typename U = std::invoke_result_t<F, const T&>,\n-      std::enable_if_t<!is_move_only && is_status_or<U> &&\n-                       std::is_constructible_v<R, typename U::value_type>>* =\n-          nullptr>\n-  Future<R> TryMap(F&& f) const& {\n-    auto [promise, future] = Future<R>::MakePromise();\n \n-    using Value = const absl::StatusOr<T>&;\n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](Value value) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        auto result = f(*value);\n+      // Set the result future available with a result of invoking `f`.\n+      if constexpr (internal::is_status_v<U>) {\n+        promise.Set(f(*value));\n+      } else if constexpr (internal::is_status_or_v<U>) {\n+        absl::StatusOr<typename U::value_type> result = f(*value);\n         if (ABSL_PREDICT_TRUE(result.ok())) {\n           promise.emplace(absl::in_place_t{}, *std::move(result));\n         } else {\n           promise.Set(std::move(result).status());\n         }\n       } else {\n-        promise.Set(value.status());\n+        promise.emplace(absl::in_place_t{}, f(*value));\n       }\n     });\n \n@@ -620,84 +567,102 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n \n   // Returns an Future<R> that is constructed from the result of invoking\n   // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error. Functor `f` must return a value of type\n-  // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n-  // is automatically unwrapped and returned as a future payload.\n+  // future will also be an error.\n   //\n   // Note: The implementation may choose to not run `f` if it can infer that the\n   // returned future will never be used. Do not use this method if `f` has a\n   // side effect that must always be executed when the future becomes ready.\n   //\n-  // Sample usage: move-only type T passed by rvalue\n+  // Sample usage: move-only type T passed by value\n   //\n-  // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n-  //   return U(value); // R must be constructible from U\n+  // std::move(future).Map<R>([](T value) -> U {\n+  //   return U(std::move(value)); // R must be constructible from U\n   // })\n   //\n+  // Supported `R` and `U` type combinations: (*)\n+  //\n+  // - `Future<>`  from `(T) -> absl::Status`\n+  // - `Future<R>` from `(T) -> absl::StatusOr<U>`\n+  // - `Future<R>` from `(T) -> U`\n+  //\n+  // See `Map` functor type inference defined below for more details.\n+  //\n+  // (*) For copyable type `T` functor `f` is called with `const T&` reference.\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n-            std::enable_if_t<\n-                is_status_or<U> &&\n-                std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n-  Future<R> TryMap(F&& f) && {\n+            internal::Mappable<R, U>* = nullptr>\n+  Future<R> Map(F&& f) && {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n                                      const absl::StatusOr<T>&>;\n     std::move(*this).OnReady([promise = std::move(promise),\n                               f = std::forward<F>(f)](Value value) mutable {\n+      // Do not compute `f` if the result is unused.\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        auto result = [&] {\n-          if constexpr (is_move_only) {\n-            return f(std::move(*value));\n-          } else {\n-            return f(*value);\n-          }\n-        }();\n+        return;\n+      }\n+\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!value.ok())) {\n+        promise.Set(value.status());\n+        return;\n+      }\n+\n+      // Set the result future available with a result of invoking `f`.\n+      if constexpr (internal::is_status_v<U>) {\n+        promise.Set(f(std::move(*value)));\n+      } else if constexpr (internal::is_status_or_v<U>) {\n+        absl::StatusOr<typename U::value_type> result = f(std::move(*value));\n         if (ABSL_PREDICT_TRUE(result.ok())) {\n           promise.emplace(absl::in_place_t{}, *std::move(result));\n         } else {\n           promise.Set(std::move(result).status());\n         }\n       } else {\n-        promise.Set(value.status());\n+        promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n       }\n     });\n \n     return std::move(future);\n   }\n \n-  // A `Map` overload that automatically infers the type of result from `f`.\n+  // A `Map` overload that automatically infers the type of result from `f`:\n+  //\n+  // - `R` is `absl::Status`      -> Future<>\n+  // - `R` is `absl::StatusOr<T>` -> Future<T>\n+  // - `R` is any other type      -> Future<R>\n+  //\n   template <typename F, typename R = std::invoke_result_t<F, const T&>>\n-  Future<R> Map(F&& f) const& {\n-    return Map<R>(std::forward<F>(f));\n+  auto Map(F&& f) const& {\n+    if constexpr (internal::is_status_v<R>) {\n+      return Map<void>(std::forward<F>(f));\n+    } else if constexpr (internal::is_status_or_v<R>) {\n+      return Map<typename R::value_type>(std::forward<F>(f));\n+    } else {\n+      return Map<R>(std::forward<F>(f));\n+    }\n   }\n \n   // A `Map` overload that automatically infers the type of result from `f`.\n+  //\n+  // - `R` is `absl::Status`      -> Future<>\n+  // - `R` is `absl::StatusOr<T>` -> Future<T>\n+  // - `R` is any other type      -> Future<R>\n+  //\n   template <typename F, typename R = std::invoke_result_t<\n                             F, std::conditional_t<is_move_only, T, const T&>>>\n-  Future<R> Map(F&& f) && {\n-    return std::move(*this).template Map<R>(std::forward<F>(f));\n-  }\n-\n-  // A `TryMap` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<F, const T&>,\n-            std::enable_if_t<is_status_or<R>>* = nullptr>\n-  Future<typename R::value_type> TryMap(F&& f) const& {\n-    return TryMap<typename R::value_type>(std::forward<F>(f));\n-  }\n-\n-  // A `TryMap` overload that automatically infers the type of result from `f`.\n-  template <typename F,\n-            typename R = std::invoke_result_t<\n-                F, std::conditional_t<is_move_only, T, const T&>>,\n-            std::enable_if_t<is_status_or<R>>* = nullptr>\n-  Future<typename R::value_type> TryMap(F&& f) && {\n-    return std::move(*this).template TryMap<typename R::value_type>(\n-        std::forward<F>(f));\n+  auto Map(F&& f) && {\n+    if constexpr (internal::is_status_v<R>) {\n+      return std::move(*this).template Map<void>(std::forward<F>(f));\n+    } else if constexpr (internal::is_status_or_v<R>) {\n+      return std::move(*this).template Map<typename R::value_type>(\n+          std::forward<F>(f));\n+    } else {\n+      return std::move(*this).template Map<R>(std::forward<F>(f));\n+    }\n   }\n \n  private:\n@@ -724,10 +689,6 @@ template <>\n class Future<void> : public internal::FutureBase<absl::Status> {\n   using Base = internal::FutureBase<absl::Status>;\n \n-  template <typename U>\n-  static constexpr bool is_status_or =  // NOLINT\n-      tsl::internal::is_status_or_v<U>;\n-\n  public:\n   Future() = default;\n \n@@ -786,7 +747,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // Returns a future that is constructed from the result of invoking functor\n   // `f` on the given `executor`.\n   template <typename F, typename R = std::invoke_result_t<F>,\n-            std::enable_if_t<std::is_same_v<R, absl::Status>>* = nullptr>\n+            std::enable_if_t<internal::is_status_v<R>>* = nullptr>\n   static Future<> MakeOn(Executor& executor, F&& f) {\n     auto [promise, future] = MakePromise();\n     executor.Execute([promise = std::move(promise),\n@@ -812,77 +773,65 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   //   return U(value); // R must be constructible from U\n   // })\n   //\n-  template <typename R, typename F, typename U = std::invoke_result_t<F>>\n+  // Supported `R` and `U` type combinations:\n+  //\n+  // - `Future<>`  from `() -> absl::Status`\n+  // - `Future<R>` from `() -> absl::StatusOr<U>`\n+  // - `Future<R>` from `() -> U`\n+  //\n+  // See `Map` functor type inference defined below for more details.\n+  template <typename R, typename F, typename U = std::invoke_result_t<F>,\n+            internal::Mappable<R, U>* = nullptr>\n   Future<R> Map(F&& f) {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     OnReady([promise = std::move(promise),\n              f = std::forward<F>(f)](absl::Status status) mutable {\n+      // Do not compute `f` if the result is unused.\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n-        promise.emplace(absl::in_place_t{}, f());\n-      } else {\n-        promise.Set(std::move(status));\n+        return;\n       }\n-    });\n-\n-    return std::move(future);\n-  }\n \n-  // Returns an Future<R> that is constructed from the result of invoking\n-  // functor `f`. If *this completes with an error, returned future will also be\n-  // an error. Functor `f` must return a value of type absl::StatusOr<U> where R\n-  // is constructible from U. Returned absl::StatusOr is automatically unwrapped\n-  // and returned as a future payload.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage:\n-  //\n-  // future.TryMap<R>([]() -> absl::StatusOr<U> {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F, typename U = std::invoke_result_t<F>,\n-            std::enable_if_t<\n-                is_status_or<U> &&\n-                std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n-  Future<R> TryMap(F&& f) {\n-    auto [promise, future] = Future<R>::MakePromise();\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!status.ok())) {\n+        promise.Set(std::move(status));\n+        return;\n+      }\n \n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](absl::Status status) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n-        auto result = f();\n+      // Set the result future available with a result of invoking `f`.\n+      if constexpr (internal::is_status_v<U>) {\n+        promise.Set(f());\n+      } else if constexpr (internal::is_status_or_v<U>) {\n+        absl::StatusOr<typename U::value_type> result = f();\n         if (ABSL_PREDICT_TRUE(result.ok())) {\n           promise.emplace(absl::in_place_t{}, *std::move(result));\n         } else {\n           promise.Set(std::move(result).status());\n         }\n       } else {\n-        promise.Set(std::move(status));\n+        promise.emplace(absl::in_place_t{}, f());\n       }\n     });\n \n     return std::move(future);\n   }\n \n-  // A `Map` overload that automatically infers the type of result from `f`.\n+  // A `Map` overload that automatically infers the type of result from `f`:\n+  //\n+  // - `R` is `absl::Status`      -> Future<>\n+  // - `R` is `absl::StatusOr<T>` -> Future<T>\n+  // - `R` is any other type      -> Future<R>\n+  //\n   template <typename F, typename R = std::invoke_result_t<F>>\n-  Future<R> Map(F&& f) {\n-    return Map<R>(std::forward<F>(f));\n-  }\n-\n-  // A `TryMap` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<F>,\n-            std::enable_if_t<is_status_or<R>>* = nullptr>\n-  Future<typename R::value_type> TryMap(F&& f) {\n-    return TryMap<typename R::value_type>(std::forward<F>(f));\n+  auto Map(F&& f) {\n+    if constexpr (internal::is_status_v<R>) {\n+      return Map<void>(std::forward<F>(f));\n+    } else if constexpr (internal::is_status_or_v<R>) {\n+      return Map<typename R::value_type>(std::forward<F>(f));\n+    } else {\n+      return Map<R>(std::forward<F>(f));\n+    }\n   }\n \n   // Returns an Future<R> that is constructed from the given value. If *this"
        },
        {
            "sha": "cfa406e08476bb86a4a02a95e4e954867ca5b1c2",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 87,
            "deletions": 28,
            "changes": 115,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cafc68871e93587135664c984447f02e8a9f6963/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cafc68871e93587135664c984447f02e8a9f6963/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=cafc68871e93587135664c984447f02e8a9f6963",
            "patch": "@@ -318,10 +318,26 @@ TEST(FutureTest, MapStatusUnusedResult) {\n   EXPECT_FALSE(called);\n }\n \n+TEST(FutureTest, TryMapCopyableFutureToStateless) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  promise.Set(42);\n+\n+  {\n+    Future<> mapped = future.Map([](int32_t) { return absl::OkStatus(); });\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+  }\n+\n+  {\n+    Future<> mapped =\n+        future.Map([](int32_t) { return absl::InternalError(\"test\"); });\n+    EXPECT_EQ(mapped.Await(), absl::InternalError(\"test\"));\n+  }\n+}\n+\n TEST(FutureTest, TryMapCopyableFuture) {\n   auto [promise, future] = Future<int32_t>::MakePromise();\n-  Future<float> mapped = future.TryMap(\n-      [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n+  Future<float> mapped =\n+      future.Map([](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n   EXPECT_FALSE(mapped.IsReady());\n@@ -333,15 +349,15 @@ TEST(FutureTest, TryMapCopyableFuture) {\n   EXPECT_EQ(*future.Await(), 42);\n   EXPECT_EQ(*mapped.Await(), 84.0f);\n \n-  Future<int32_t> mapped_again = std::move(mapped).TryMap(\n+  Future<int32_t> mapped_again = std::move(mapped).Map(\n       [](float v) -> absl::StatusOr<int32_t> { return v; });\n   EXPECT_EQ(*mapped_again.Await(), 84);\n }\n \n TEST(FutureTest, TryMapCopyableFutureForwardError) {\n   auto [promise, future] = Future<int32_t>::MakePromise();\n-  Future<float> mapped = future.TryMap(\n-      [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n+  Future<float> mapped =\n+      future.Map([](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n \n   promise.Set(absl::InternalError(\"test\"));\n   EXPECT_TRUE(mapped.IsReady());\n@@ -350,7 +366,7 @@ TEST(FutureTest, TryMapCopyableFutureForwardError) {\n \n TEST(FutureTest, TryMapCopyableFutureCreateError) {\n   auto [promise, future] = Future<int32_t>::MakePromise();\n-  Future<float> mapped = future.TryMap([](int32_t v) -> absl::StatusOr<float> {\n+  Future<float> mapped = future.Map([](int32_t v) -> absl::StatusOr<float> {\n     return absl::InternalError(\"test\");\n   });\n \n@@ -359,10 +375,19 @@ TEST(FutureTest, TryMapCopyableFutureCreateError) {\n   EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n }\n \n+TEST(FutureTest, TryMapMoveOnlyFutureToStateless) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  promise.Set(std::make_unique<int32_t>(42));\n+\n+  Future<> mapped = std::move(future).Map(\n+      [](std::unique_ptr<int32_t>) { return absl::OkStatus(); });\n+  EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+}\n+\n TEST(FutureTest, TryMapMoveOnlyFuture) {\n   auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n \n-  Future<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n+  Future<std::unique_ptr<float>> mapped = std::move(future).Map(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n         return std::make_unique<float>(*v * 2.0f);\n       });\n@@ -378,7 +403,7 @@ TEST(FutureTest, TryMapMoveOnlyFuture) {\n TEST(FutureTest, TryMapMoveOnlyFutureForwardError) {\n   auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n \n-  Future<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n+  Future<std::unique_ptr<float>> mapped = std::move(future).Map(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n         return std::make_unique<float>(*v * 2.0f);\n       });\n@@ -391,10 +416,30 @@ TEST(FutureTest, TryMapMoveOnlyFutureForwardError) {\n   EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n }\n \n+TEST(FutureTest, MapFutureCopies) {\n+  auto [promise, future] = Future<std::shared_ptr<int32_t>>::MakePromise();\n+  promise.Set(std::make_shared<int32_t>(42));\n+\n+  Future<std::shared_ptr<int32_t>> future0 = future;\n+  Future<std::shared_ptr<int32_t>> future1 = future;\n+\n+  Future<> future2 = std::move(future0).Map(\n+      [](std::shared_ptr<int32_t>) { return absl::OkStatus(); });\n+  Future<> future3 = std::move(future1).Map(\n+      [](std::shared_ptr<int32_t>) { return absl::OkStatus(); });\n+\n+  EXPECT_EQ(future2.Await(), absl::OkStatus());\n+  EXPECT_EQ(future3.Await(), absl::OkStatus());\n+\n+  // Check that future holds a valid shared pointer, and it was not actually\n+  // moved to any of the functors.\n+  EXPECT_EQ(**future.Await(), 42);\n+}\n+\n TEST(FutureTest, TryMapMoveOnlyFutureCreateError) {\n   auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n \n-  Future<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n+  Future<std::unique_ptr<float>> mapped = std::move(future).Map(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n         return absl::InternalError(\"test\");\n       });\n@@ -411,26 +456,14 @@ TEST(FutureTest, TryMapUnusedResult) {\n   auto [promise, future] = Future<int>::MakePromise();\n \n   bool called = false;\n-  future.TryMap([&](int) -> absl::StatusOr<int> {\n+  future.Map([&](int) -> absl::StatusOr<int> {\n     called = true;\n     return 2;\n   });\n   promise.Set(1);\n   EXPECT_FALSE(called);\n }\n \n-TEST(FutureTest, TryMapStatusUnusedResult) {\n-  auto [promise, future] = Future<>::MakePromise();\n-\n-  bool called = false;\n-  future.TryMap([&]() -> absl::StatusOr<int> {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set();\n-  EXPECT_FALSE(called);\n-}\n-\n TEST(FutureTest, StatelessError) {\n   auto [promise, future] = Future<>::MakePromise();\n \n@@ -479,6 +512,32 @@ TEST(FutureTest, MapStatelessFuture) {\n   EXPECT_EQ(*mapped.Await(), 42.0f);\n }\n \n+TEST(FutureTest, MapStatelessToStatus) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  promise.Set(absl::OkStatus());\n+\n+  {\n+    Future<> mapped = future.Map([] { return absl::OkStatus(); });\n+    EXPECT_TRUE(mapped.IsReady());\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+  }\n+\n+  {\n+    Future<> mapped = future.Map([] { return absl::InternalError(\"test\"); });\n+    EXPECT_TRUE(mapped.IsReady());\n+    EXPECT_EQ(mapped.Await(), absl::InternalError(\"test\"));\n+  }\n+}\n+\n+TEST(FutureTest, MapStatelessErrorToStatus) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  promise.Set(absl::InternalError(\"test\"));\n+\n+  Future<> mapped = future.Map([] { return absl::OkStatus(); });\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await(), absl::InternalError(\"test\"));\n+}\n+\n TEST(FutureTest, MapStatelessFutureError) {\n   auto [promise, future] = Future<>::MakePromise();\n   Future<float> mapped = future.Map([]() { return 42.0f; });\n@@ -494,10 +553,10 @@ TEST(FutureTest, MapStatelessFutureError) {\n   EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n }\n \n-TEST(FutureTest, TryMapStatelessFuture) {\n+TEST(FutureTest, MapStatelessFutureToStatusOr) {\n   auto [promise, future] = Future<>::MakePromise();\n   Future<float> mapped =\n-      future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n+      future.Map([]() -> absl::StatusOr<float> { return 42.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n   EXPECT_FALSE(mapped.IsReady());\n@@ -510,19 +569,19 @@ TEST(FutureTest, TryMapStatelessFuture) {\n   EXPECT_EQ(*mapped.Await(), 42.0f);\n }\n \n-TEST(FutureTest, TryMapStatelessFutureForwardError) {\n+TEST(FutureTest, MapStatelessFutureForwardError) {\n   auto [promise, future] = Future<>::MakePromise();\n   Future<float> mapped =\n-      future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n+      future.Map([]() -> absl::StatusOr<float> { return 42.0f; });\n \n   promise.Set(absl::InternalError(\"test\"));\n   EXPECT_TRUE(mapped.IsReady());\n   EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n }\n \n-TEST(FutureTest, TryMapStatelessFutureCreateError) {\n+TEST(FutureTest, MapStatelessFutureCreateError) {\n   auto [promise, future] = Future<>::MakePromise();\n-  Future<float> mapped = future.TryMap(\n+  Future<float> mapped = future.Map(\n       []() -> absl::StatusOr<float> { return absl::InternalError(\"test\"); });\n \n   promise.Set(absl::OkStatus());"
        }
    ],
    "stats": {
        "total": 426,
        "additions": 217,
        "deletions": 209
    }
}