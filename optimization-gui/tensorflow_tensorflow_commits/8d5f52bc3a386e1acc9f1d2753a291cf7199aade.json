{
    "author": "metaflow",
    "message": "[XLA:GPU] split dimensions greedly including ones in\nCalculateBitcastOfTransposeImpl\n\nWe have not hanlded the case when bitcast introcduces a new 1-size dimension in\ncase like\n\na = f32[6,7] transpose(f32[7,6]), dims={1,0}\nb = f32[6,1,7] bitcast(a)\n\nas this 1-size dimension could teoretically be moved anywhere in the\nhosted expression\n\nc = f32[1,7,6] bitcase(f32[7,6])\n# or c = f32[7,1,6] bitcase(f32[7,6])\n# or c = f32[7,6,1] bitcase(f32[7,6])\nb = f32[6,1,7] transpose(c), dims=...\n\nby using a \"greedy\" version of CommonFactors that does not produce\ngrouping like [] -> [1] or [1] -> [] we now handle this case (picking\ngroup [6,1] -> [6] mapping).\n\nPiperOrigin-RevId: 842282725",
    "sha": "8d5f52bc3a386e1acc9f1d2753a291cf7199aade",
    "files": [
        {
            "sha": "1acb680d9e73d7e4de4203d01ced66a589bf7819",
            "filename": "third_party/xla/xla/service/gpu/transforms/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2FBUILD?ref=8d5f52bc3a386e1acc9f1d2753a291cf7199aade",
            "patch": "@@ -1857,7 +1857,6 @@ cc_library(\n         \"//xla/codegen/tiling:symbolic_tile_analysis\",\n         \"//xla/codegen/tiling:symbolic_tiled_hlo_instruction\",\n         \"//xla/codegen/tiling:tiling_specification\",\n-        \"//xla/hlo/analysis:symbolic_expr\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/hlo/transforms/simplifiers:hlo_dce\",\n@@ -1898,18 +1897,18 @@ xla_cc_test(\n     deps = [\n         \":nest_gemm_fusion\",\n         \"//xla:xla_proto_cc\",\n-        \"//xla/hlo/analysis:symbolic_expr\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:filecheck\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:pattern_matcher_gmock\",\n+        \"//xla/hlo/testlib:verified_hlo_module\",\n         \"//xla/service:pattern_matcher\",\n         \"//xla/service/gpu:backend_configs_cc\",\n         \"//xla/service/gpu:gpu_device_info_for_tests\",\n         \"//xla/stream_executor:device_description\",\n         \"//xla/stream_executor/cuda:cuda_compute_capability\",\n-        \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:inlined_vector\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings\","
        },
        {
            "sha": "f9812d96ca0747c61d09fb5d30f7c0d36ae59751",
            "filename": "third_party/xla/xla/service/gpu/transforms/nest_gemm_fusion.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 2,
            "changes": 35,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion.cc?ref=8d5f52bc3a386e1acc9f1d2753a291cf7199aade",
            "patch": "@@ -15,6 +15,7 @@ limitations under the License.\n \n #include \"xla/service/gpu/transforms/nest_gemm_fusion.h\"\n \n+#include <cstddef>\n #include <cstdint>\n #include <deque>\n #include <memory>\n@@ -658,8 +659,11 @@ absl::StatusOr<BitcastParams> CalculateBitcastOfTransposeImpl(\n   // Maps logical operand dimension index to the physical dimension index.\n   llvm::SmallVector<int64_t> operand_inv_layout =\n       GetInversePermutation(operand_shape.layout().minor_to_major());\n-  auto factors = CommonFactors(GetPhysicalDimensions(result_shape),\n-                               GetPhysicalDimensions(transpose_shape));\n+\n+  const absl::InlinedVector<std::pair<int64_t, int64_t>, 8> factors =\n+      ::xla::gpu::detail::CommonFactorsMergingTrivialRanges(\n+          GetPhysicalDimensions(result_shape),\n+          GetPhysicalDimensions(transpose_shape));\n   for (int64_t i = 1; i < factors.size(); ++i) {\n     auto [result_from, transpose_from] = factors[i - 1];\n     auto [result_to, transpose_to] = factors[i];\n@@ -1348,5 +1352,32 @@ absl::StatusOr<BlockLevelParameters> FindBlockLevelParameters(\n       \"Couldn't find output tile sizes that satisfy \", tiled_dot.ToString()));\n }\n \n+absl::InlinedVector<std::pair<int64_t, int64_t>, 8>\n+CommonFactorsMergingTrivialRanges(absl::Span<const int64_t> a,\n+                                  absl::Span<const int64_t> b) {\n+  // CommonFactors does what we need but it also creates empty groups with\n+  // product of 1, e.g. `[1] -> []` or `[] -> [1]`. We remove the bounds of\n+  // such ranges to merge them with neighbors. There are many different ways\n+  // to do this, here we continously append ranges to the start of the next\n+  // group unless it is the very last range.\n+  absl::InlinedVector<std::pair<int64_t, int64_t>, 8> bounds =\n+      CommonFactors(a, b);\n+  for (size_t i = 0; i + 1 < bounds.size() && bounds.size() > 2;) {\n+    auto [a_start, b_start] = bounds[i];\n+    auto [a_end, b_end] = bounds[i + 1];\n+    if (a_start != a_end && b_start != b_end) {\n+      i++;\n+      continue;\n+    }\n+    if (i + 2 == bounds.size()) {\n+      // Very last range - append it to the previous one.\n+      bounds.erase(bounds.begin() + i);\n+    } else {\n+      bounds.erase(bounds.begin() + i + 1);\n+    }\n+  }\n+  return bounds;\n+}\n+\n }  // namespace detail\n }  // namespace xla::gpu"
        },
        {
            "sha": "bc1a54cfadd09a92f4ef96a6fd1cce501390ea7e",
            "filename": "third_party/xla/xla/service/gpu/transforms/nest_gemm_fusion.h",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion.h?ref=8d5f52bc3a386e1acc9f1d2753a291cf7199aade",
            "patch": "@@ -16,11 +16,16 @@ limitations under the License.\n #ifndef XLA_SERVICE_GPU_TRANSFORMS_NEST_GEMM_FUSION_H_\n #define XLA_SERVICE_GPU_TRANSFORMS_NEST_GEMM_FUSION_H_\n \n+#include <cstdint>\n+#include <utility>\n+\n #include \"absl/container/flat_hash_set.h\"\n+#include \"absl/container/inlined_vector.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n-#include \"xla/hlo/analysis/symbolic_expr.h\"\n-#include \"xla/hlo/ir/hlo_instructions.h\"\n+#include \"absl/types/span.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/pass/hlo_pass_interface.h\"\n #include \"xla/service/gpu/matmul_utils.h\"\n@@ -81,6 +86,16 @@ absl::StatusOr<BlockLevelParameters> FindBlockLevelParameters(\n     mlir::MLIRContext* mlir_context,\n     const se::DeviceDescription& device_description);\n \n+// Returns the start indices of consecutive non-overlapping subsequences of `a`\n+// and `b` with the same product (see `CommonFactors` from `util.h`) grouping\n+// ranges having product of 1 with neighbors.\n+//\n+// For example, if a=[2, 5, 1, 3] and b=[1, 10, 3, 1], the result will be\n+// {{0, 0}, {2, 2}, {4, 4}}, grouping [2,5] with [1,10] and [1,3] with [3,1].\n+absl::InlinedVector<std::pair<int64_t, int64_t>, 8>\n+CommonFactorsMergingTrivialRanges(absl::Span<const int64_t> a,\n+                                  absl::Span<const int64_t> b);\n+\n }  // namespace detail\n \n }  // namespace xla::gpu"
        },
        {
            "sha": "fd81e8ef39895bf0675074428fe30511f3767be7",
            "filename": "third_party/xla/xla/service/gpu/transforms/nest_gemm_fusion_test.cc",
            "status": "modified",
            "additions": 166,
            "deletions": 83,
            "changes": 249,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d5f52bc3a386e1acc9f1d2753a291cf7199aade/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fnest_gemm_fusion_test.cc?ref=8d5f52bc3a386e1acc9f1d2753a291cf7199aade",
            "patch": "@@ -15,31 +15,38 @@ limitations under the License.\n \n #include \"xla/service/gpu/transforms/nest_gemm_fusion.h\"\n \n+#include <cstdint>\n+#include <memory>\n #include <string>\n+#include <utility>\n+#include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/container/inlined_vector.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status_matchers.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/strings/substitute.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/hlo/analysis/symbolic_expr.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/testlib/filecheck.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/pattern_matcher_gmock.h\"\n+#include \"xla/hlo/testlib/verified_hlo_module.h\"\n #include \"xla/service/gpu/backend_configs.pb.h\"\n #include \"xla/service/gpu/gpu_device_info_for_tests.h\"\n #include \"xla/service/pattern_matcher.h\"\n #include \"xla/stream_executor/cuda/cuda_compute_capability.h\"\n #include \"xla/stream_executor/device_description.h\"\n-#include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla.pb.h\"\n \n+using ::absl_testing::IsOkAndHolds;\n using ::testing::ElementsAre;\n \n namespace xla {\n@@ -105,7 +112,7 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n   ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n \n   const HloInstruction* fusion = nullptr;\n@@ -162,9 +169,9 @@ ENTRY e {\n                          \"num_ctas\":1}}}\n })\";\n   TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   HloComputation* fusion_computation = module->entry_computation()\n                                            ->root_instruction()\n@@ -283,7 +290,7 @@ ENTRY entry {\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n   ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n \n   const HloInstruction* fusion = nullptr;\n@@ -330,7 +337,7 @@ ENTRY entry {\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n   ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n \n   const HloInstruction* fusion = nullptr;\n@@ -375,9 +382,9 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -410,9 +417,9 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -444,15 +451,15 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK: f16[3,11]{1,0} convert(\n CHECK: f16[3,11]{1,0} fusion(\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n \n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n@@ -490,9 +497,9 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -526,17 +533,17 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n   CHECK: ENTRY\n   CHECK: {{.*}} = s8[3,7]{1,0:E(4)} bitcast({{.*}})\n   CHECK: [[fusion:[^ ]+]] = s8[3,11]{1,0:E(4)} fusion({{.*}})\n   CHECK: ROOT {{.*}} = s8[33]{0:E(4)} bitcast([[fusion]])\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -570,9 +577,9 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -609,9 +616,9 @@ ENTRY entry_computation {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -645,9 +652,9 @@ ENTRY entry_computation {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -680,9 +687,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -712,9 +719,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n@@ -727,7 +734,7 @@ CHECK: ENTRY {{.*}} {\n CHECK: [[entry_p0:[^ ]+]] = f32[11,1,24,1]{3,2,1,0} parameter(0)\n CHECK: {{.*}} = f32[264]{0} bitcast([[entry_p0]])\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -758,7 +765,7 @@ ENTRY e {\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n   // We can nest the fusion including the broadcast.\n-  EXPECT_TRUE(NestGemmFusion(device_description_, &mlir_context_)\n+  ASSERT_TRUE(NestGemmFusion(device_description_, &mlir_context_)\n                   .Run(module.get())\n                   .ok());\n   ASSERT_OK(verifier().Run(module.get()).status());\n@@ -769,7 +776,7 @@ CHECK:      f32[3,4,16]{2,1,0} broadcast\n CHECK-NEXT: f32[3,64]{1,0} $0\n )\",\n                                             HloOpcodeString(opcode))),\n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -800,7 +807,7 @@ ENTRY e {\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n   // We can nest the fusion including the broadcast.\n-  EXPECT_TRUE(NestGemmFusion(device_description_, &mlir_context_)\n+  ASSERT_TRUE(NestGemmFusion(device_description_, &mlir_context_)\n                   .Run(module.get())\n                   .ok());\n   ASSERT_OK(verifier().Run(module.get()).status());\n@@ -811,7 +818,7 @@ CHECK:      f32[2,3,5]{2,1,0} $0\n CHECK-NEXT: f32[2,4,3,5]{3,2,1,0} broadcast\n )\",\n                                             HloOpcodeString(opcode))),\n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -843,9 +850,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n@@ -854,7 +861,7 @@ CHECK-DAG: {{.*}} = f32[15,77]{1,0} broadcast([[p0]]), dimensions={0}\n CHECK-DAG: [[br:[^ ]+]] = f32[15]{0} broadcast([[p0]]), dimensions={0}\n CHECK-DAG: {{.*}} = f32[15,77]{1,0} broadcast([[br]]), dimensions={0}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest, BitcastsAreHoistedOverBroadcasts) {\n@@ -883,9 +890,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()),\n                            R\"(\n@@ -899,7 +906,7 @@ CHECK: [[entry_p0:[^ ]+]] = f32[11,1,24,1]{3,2,1,0} parameter(0)\n CHECK: {{.*}} = f32[264]{0} bitcast([[entry_p0]])\n )\"),\n \n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest, BitcastsLayoutIsPreserved) {\n@@ -934,9 +941,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()),\n                            absl::Substitute(R\"(\n@@ -953,7 +960,7 @@ CHECK: ENTRY {{.*}} {\n CHECK: {{.*}} = pred[122,5]{0,1} bitcast({{.*}})\n )\",\n                                             HloOpcodeString(opcode))),\n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -985,16 +992,16 @@ ENTRY entry {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK: bf16[1,2,4,8]{{.*}} broadcast({{.*}}), dimensions={0,3}\n CHECK: bf16[1,2,4,8]{{.*}} broadcast({{.*}}), dimensions={0,3}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest, BitcastsAreHoistedUpThroughTransposes) {\n@@ -1021,17 +1028,55 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK:      ROOT transpose\n CHECK-SAME: f32[2,3,7]{2,1,0} transpose\n CHECK-SAME: dimensions={1,2,0}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n+}\n+\n+TEST_P(NestGemmFusionReshapeTest,\n+       BitcastsWithSize1DimensionsAreHoistedUpThroughTransposes) {\n+  const HloOpcode opcode = GetParam();\n+  absl::string_view hlo = R\"(\n+triton_dot {\n+  p0 = f32[7,6] parameter(0)\n+  transpose = f32[6,7] transpose(p0), dimensions={1,0}\n+  bitcast = f32[1,6,7] $0(transpose)\n+  p1 = f32[1,5,7] parameter(1)\n+  ROOT result = f32[1,6,5] dot(bitcast, p1),\n+    lhs_contracting_dims={2}, lhs_batch_dims={0},\n+    rhs_contracting_dims={2}, rhs_batch_dims={0}\n+}\n+\n+ENTRY e {\n+  p0 = f32[7,6] parameter(0)\n+  p1 = f32[1,5,7] parameter(1)\n+  ROOT result = f32[1,6,5] fusion(p0, p1), kind=kCustom, calls=triton_dot,\n+    backend_config={\"fusion_backend_config\": {kind: \"__triton_gemm\",\n+    triton_gemm_config: {\"block_m\":16,\"block_n\":16,\"block_k\":8,\n+    \"split_k\":1,\"num_stages\":1,\"num_warps\":1,\"num_ctas\":1}}}}\n+)\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(\n+                              absl::Substitute(hlo, HloOpcodeString(opcode))));\n+  ASSERT_THAT(\n+      NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n+      IsOkAndHolds(true));\n+  ASSERT_OK(verifier().Run(module.get()).status());\n+  EXPECT_THAT(\n+      RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n+CHECK:      ROOT transpose\n+CHECK-SAME: f32[1,6,7]{2,1,0} transpose\n+CHECK-SAME: dimensions={1,2,0}\n+)\"),\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -1058,17 +1103,17 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK:      transpose\n CHECK-SAME: f32[3,2,7]{2,1,0} transpose\n CHECK-SAME: dimensions={2,0,1}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -1095,17 +1140,17 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()),\n                            absl::Substitute(R\"(\n CHECK:      f32[2,3,5]{2,1,0} $0\n CHECK-NEXT: f32[2,5,3]{2,1,0} transpose\n )\",\n                                             HloOpcodeString(opcode))),\n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -1134,9 +1179,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   // Checks that transpose is on rank 3 tensor from hoisting bitcast1, not rank\n   // 4 tensor from hoisting bitcast0 first and then failing to hoist bitcast1.\n@@ -1146,7 +1191,7 @@ CHECK:      transpose\n CHECK-SAME: f16[3,1152,122]{2,1,0} transpose\n CHECK-SAME: dimensions={0,2,1}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest, BitcastsAreHoistedDownThroughTransposes) {\n@@ -1173,17 +1218,17 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK:      ROOT transpose\n CHECK-SAME: f32[5,2,3]{2,1,0} transpose\n CHECK-SAME: dimensions={2,0,1}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest, BitcastsAreHoistedDownThroughBroadcasts) {\n@@ -1209,17 +1254,17 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK:      ROOT broadcast\n CHECK-SAME: f32[3,5,6,2]{2,1,0,3} broadcast\n CHECK-SAME: dimensions={0,1}\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -1246,17 +1291,17 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()),\n                            absl::Substitute(R\"(\n CHECK:      f32[2,3,5]{2,1,0} $0(dot)\n CHECK-NEXT: f32[2,3,5]{2,0,1} broadcast\n )\",\n                                             HloOpcodeString(opcode))),\n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest, BitcastRootsAreHoistedDown) {\n@@ -1281,15 +1326,15 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK: ROOT dot\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -1318,15 +1363,15 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK: ROOT add = f32[3,5]{1,0} add\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n }\n \n TEST_P(NestGemmFusionReshapeTest,\n@@ -1359,9 +1404,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK-NOT: bitcast\n@@ -1376,7 +1421,7 @@ CHECK: f32[2,7]{1,0} bitcast(p0\n CHECK: result = f32[2,7,15,11]{2,1,0,3} fusion\n CHECK: ROOT {{.*}} = f32[15,11,14]{0,2,1} bitcast(result)\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -1410,9 +1455,9 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK-NOT: bitcast\n@@ -1427,7 +1472,7 @@ CHECK: f32[7,3,2]{2,0,1} bitcast(p0\n CHECK: result = f32[3,5,2]{2,1,0} fusion\n CHECK: ROOT {{.*}} = f32[2,3,5]{0,2,1} bitcast(result)\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -1458,16 +1503,16 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(\n                               absl::Substitute(hlo, HloOpcodeString(opcode))));\n-  EXPECT_THAT(\n+  ASSERT_THAT(\n       NestGemmFusion(device_description_, &mlir_context_).Run(module.get()),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   EXPECT_THAT(\n       RunFileCheck(module->ToString(HloPrintOptions::ShortParsable()), R\"(\n CHECK-NOT: bitcast\n CHECK-NOT: reshape\n CHECK: ENTRY\n )\"),\n-      absl_testing::IsOkAndHolds(true));\n+      IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -1509,7 +1554,7 @@ CHECK-NOT: bitcast\n CHECK-NOT: reshape\n         )\",\n                                             HloOpcodeString(opcode))),\n-              absl_testing::IsOkAndHolds(true));\n+              IsOkAndHolds(true));\n   ASSERT_OK(verifier().Run(module.get()).status());\n }\n \n@@ -1521,6 +1566,44 @@ INSTANTIATE_TEST_SUITE_P(NestGemmFusionReshapeTestSuite,\n                            return std::string(HloOpcodeString(info.param));\n                          });\n \n+struct CommonFactorsTestCase {\n+  std::vector<int64_t> from, to;\n+  absl::InlinedVector<std::pair<int64_t, int64_t>, 8> expected;\n+};\n+\n+class CommonFactorsMergingTrivialRangesTest\n+    : public ::testing::TestWithParam<CommonFactorsTestCase> {};\n+\n+TEST_P(CommonFactorsMergingTrivialRangesTest, Example) {\n+  const CommonFactorsTestCase& test_case = GetParam();\n+  EXPECT_EQ(test_case.expected, detail::CommonFactorsMergingTrivialRanges(\n+                                    test_case.from, test_case.to));\n+}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+    CommonFactorsMergingTrivialRangesTestSuite,\n+    CommonFactorsMergingTrivialRangesTest,\n+    ::testing::Values(\n+        CommonFactorsTestCase{{1}, {}, {{0, 0}, {1, 0}}},\n+        CommonFactorsTestCase{{}, {1}, {{0, 0}, {0, 1}}},\n+        CommonFactorsTestCase{{}, {}, {{0, 0}}},\n+        CommonFactorsTestCase{{1, 2, 0}, {2, 0, 3}, {{0, 0}, {3, 3}}},\n+        CommonFactorsTestCase{{2, 3, 0}, {1, 0, 1000}, {{0, 0}, {3, 3}}},\n+        CommonFactorsTestCase{{1, 1, 1}, {1, 1}, {{0, 0}, {1, 1}, {3, 2}}},\n+        CommonFactorsTestCase{{1, 1, 3}, {3, 1, 1}, {{0, 0}, {3, 3}}},\n+        CommonFactorsTestCase{{2, 6}, {4, 3}, {{0, 0}, {2, 2}}},\n+        CommonFactorsTestCase{{1, 2, 6}, {4, 1, 3, 1}, {{0, 0}, {3, 4}}},\n+        CommonFactorsTestCase{{2, 3, 4, 5}, {6, 20}, {{0, 0}, {2, 1}, {4, 2}}},\n+        CommonFactorsTestCase{\n+            {2, 3, 4, 5, 6}, {6, 20, 6}, {{0, 0}, {2, 1}, {4, 2}, {5, 3}}},\n+        CommonFactorsTestCase{{2, 2, 2, 2}, {4, 4}, {{0, 0}, {2, 1}, {4, 2}}},\n+        CommonFactorsTestCase{\n+            {2, 5, 1, 3}, {1, 10, 3, 1}, {{0, 0}, {2, 2}, {4, 4}}}),\n+    [](const ::testing::TestParamInfo<CommonFactorsTestCase>& info) {\n+      return absl::StrCat(absl::StrJoin(info.param.from, \"_\"), \"_to_\",\n+                          absl::StrJoin(info.param.to, \"_\"));\n+    });\n+\n }  // namespace\n }  // namespace gpu\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 308,
        "additions": 218,
        "deletions": 90
    }
}