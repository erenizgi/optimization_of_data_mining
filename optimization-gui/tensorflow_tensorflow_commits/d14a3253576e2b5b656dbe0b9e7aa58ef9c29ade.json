{
    "author": "GleasonK",
    "message": "Delete MHLO convert to signless pass, use StableHLO's\n\nPiperOrigin-RevId: 810522807",
    "sha": "d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
    "files": [
        {
            "sha": "67b836f125b472b85c74b6e1cfb2740f3a60b384",
            "filename": "tensorflow/compiler/mlir/tools/kernel_gen/kernel_creator.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/tensorflow%2Fcompiler%2Fmlir%2Ftools%2Fkernel_gen%2Fkernel_creator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/tensorflow%2Fcompiler%2Fmlir%2Ftools%2Fkernel_gen%2Fkernel_creator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftools%2Fkernel_gen%2Fkernel_creator.cc?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -185,7 +185,7 @@ absl::Status LowerHlotoLoops(mlir::ModuleOp module,\n \n   // Remove the remaining references to unsigned types after all HLO compute\n   // operations were converted.\n-  pm.addPass(mlir::mhlo::createConvertToSignlessPass());\n+  pm.addPass(mlir::stablehlo::createStablehloConvertToSignlessPass());\n \n   pm.addPass(mlir::createCanonicalizerPass());\n   pm.addNestedPass<FuncOp>(mlir::createCSEPass());"
        },
        {
            "sha": "29839c72fbd0bf36f99e52689bdd8e0fa8ea5fc8",
            "filename": "third_party/xla/xla/backends/cpu/codegen/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2FBUILD?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -155,7 +155,6 @@ cc_library(\n         \"//xla/codegen/emitters/transforms:passes\",\n         \"//xla/mlir/tools/mlir_replay/public:compiler_trace_proto_cc\",\n         \"//xla/mlir_hlo\",\n-        \"//xla/mlir_hlo:mhlo_passes\",\n         \"//xla/tsl/framework/mlir:status_scoped_diagnostic_handler\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n@@ -194,6 +193,7 @@ cc_library(\n         \"@llvm-project//mlir:VectorDialect\",\n         \"@local_tsl//tsl/profiler/lib:traceme\",\n         \"@local_tsl//tsl/profiler/lib:traceme_encode\",\n+        \"@stablehlo//:stablehlo_passes\",\n     ],\n )\n "
        },
        {
            "sha": "693090d72e75be4e790028d736693e585060426d",
            "filename": "third_party/xla/xla/backends/cpu/codegen/fusion_compiler.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ffusion_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ffusion_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ffusion_compiler.cc?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -66,6 +66,7 @@ limitations under the License.\n #include \"mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h\"\n #include \"mlir/Target/LLVMIR/Export.h\"\n #include \"mlir/Transforms/Passes.h\"\n+#include \"stablehlo/transforms/Passes.h\"\n #include \"xla/backends/cpu/codegen/emitters/ir/xla_cpu_dialect.h\"\n #include \"xla/backends/cpu/codegen/emitters/transforms/passes.h\"\n #include \"xla/backends/cpu/codegen/kernel_api_ir_builder.h\"\n@@ -79,7 +80,6 @@ limitations under the License.\n #include \"xla/codegen/trace_pass_instrumentation.h\"\n #include \"xla/mlir/tools/mlir_replay/public/compiler_trace.pb.h\"\n #include \"xla/mlir_hlo/mhlo/IR/hlo_ops.h\"\n-#include \"xla/mlir_hlo/mhlo/transforms/passes.h\"\n #include \"xla/status_macros.h\"\n #include \"xla/tsl/framework/mlir/status_scoped_diagnostic_handler.h\"\n #include \"xla/tsl/platform/errors.h\"\n@@ -135,7 +135,7 @@ static void AddLoopTransformationPasses(mlir::OpPassManager& pm,\n   pm.addPass(mlir::createCSEPass());\n   pm.addNestedPass<mlir::func::FuncOp>(\n       emitters::CreateLowerXlaLoopsToScfPass());\n-  pm.addPass(mlir::mhlo::createConvertToSignlessPass());\n+  pm.addPass(mlir::stablehlo::createStablehloConvertToSignlessPass());\n   pm.addPass(emitters::CreatePropagateSliceIndicesPass());\n   pm.addPass(emitters::CreateFlattenTensorsPass());\n   // We need LICM before unswitching loops, because our loop unswitcher only"
        },
        {
            "sha": "e22eb5bddc273420035e186dd752ddf8bc5d68be",
            "filename": "third_party/xla/xla/backends/gpu/codegen/emitters/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2FBUILD?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -66,7 +66,6 @@ cc_library(\n         \"//xla/mlir/tools/mlir_replay/public:compiler_trace_instrumentation\",\n         \"//xla/mlir/tools/mlir_replay/public:compiler_trace_proto_cc\",\n         \"//xla/mlir_hlo\",\n-        \"//xla/mlir_hlo:mhlo_passes\",\n         \"//xla/service:buffer_assignment\",\n         \"//xla/service:dump\",\n         \"//xla/service/gpu:gpu_constants\",\n@@ -125,6 +124,7 @@ cc_library(\n         \"@llvm-project//mlir:ToLLVMIRTranslation\",\n         \"@llvm-project//mlir:Transforms\",\n         \"@llvm-project//mlir:VectorDialect\",\n+        \"@stablehlo//:stablehlo_passes\",\n     ],\n )\n "
        },
        {
            "sha": "9d7769c8e899977ced54c8bc3cea978fdf3d85c9",
            "filename": "third_party/xla/xla/backends/gpu/codegen/emitters/emitter_base.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Femitter_base.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Femitter_base.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Femitter_base.cc?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -80,6 +80,7 @@ limitations under the License.\n #include \"mlir/Target/LLVMIR/Dialect/ROCDL/ROCDLToLLVMIRTranslation.h\"\n #include \"mlir/Target/LLVMIR/Export.h\"\n #include \"mlir/Transforms/Passes.h\"\n+#include \"stablehlo/transforms/Passes.h\"\n #include \"xla/backends/gpu/codegen/emitters/ir/xla_gpu_ops.h\"\n #include \"xla/backends/gpu/codegen/emitters/transforms/passes.h\"\n #include \"xla/backends/gpu/codegen/fusion_emitter.h\"\n@@ -100,7 +101,6 @@ limitations under the License.\n #include \"xla/mlir/tools/mlir_replay/public/compiler_trace.pb.h\"\n #include \"xla/mlir/tools/mlir_replay/public/compiler_trace_instrumentation.h\"\n #include \"xla/mlir_hlo/mhlo/IR/hlo_ops.h\"\n-#include \"xla/mlir_hlo/mhlo/transforms/passes.h\"\n #include \"xla/service/buffer_assignment.h\"\n #include \"xla/service/dump.h\"\n #include \"xla/service/gpu/gpu_constants.h\"\n@@ -458,7 +458,7 @@ void AddLoopTransformationPasses(mlir::OpPassManager& pm,\n   pm.addPass(mlir::createCSEPass());\n   pm.addNestedPass<FuncOp>(CreatePeelLoopsPass());\n   pm.addNestedPass<FuncOp>(emitters::CreateLowerXlaLoopsToScfPass());\n-  pm.addPass(mlir::mhlo::createConvertToSignlessPass());\n+  pm.addPass(mlir::stablehlo::createStablehloConvertToSignlessPass());\n   pm.addPass(emitters::CreatePropagateSliceIndicesPass());\n   pm.addPass(emitters::CreateFlattenTensorsPass());\n   // We need LICM before unswitching loops, because our loop unswitcher only"
        },
        {
            "sha": "bb057c1862ae05c05eb042d8ac3d650d6e60ede4",
            "filename": "third_party/xla/xla/mlir_hlo/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2FBUILD?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -330,7 +330,6 @@ cc_library(\n     srcs = [\n         \"mhlo/transforms/chlo_legalize_to_hlo/chlo_legalize_to_hlo_pass.cc\",\n         \"mhlo/transforms/collapse_elementwise_map/collapse_elementwise_map.cc\",\n-        \"mhlo/transforms/convert_to_signless/convert_to_signless_pass.cc\",\n         \"mhlo/transforms/expand_hlo_tuples/expand_hlo_tuples.cc\",\n         \"mhlo/transforms/hlo_legalize_to_arithmetic/hlo_legalize_to_arithmetic.cc\",\n         \"mhlo/transforms/hlo_legalize_to_memref/hlo_legalize_to_memref.cc\","
        },
        {
            "sha": "6910853889aeff1561e5e0b5db36240b19038313",
            "filename": "third_party/xla/xla/mlir_hlo/mhlo/transforms/CMakeLists.txt",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2FCMakeLists.txt",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2FCMakeLists.txt",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2FCMakeLists.txt?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -30,7 +30,6 @@ add_public_tablegen_target(MLIRChloLegalizeToHloIncGen)\n \n add_mlir_library(MhloPasses\n   collapse_elementwise_map/collapse_elementwise_map.cc\n-  convert_to_signless/convert_to_signless_pass.cc\n   expand_hlo_tuples/expand_hlo_tuples.cc\n   legalize_dot_to_dot_general/legalize_dot_to_dot_general.cc\n   legalize_einsum_to_dot_general/legalize_einsum_to_dot_general.cc"
        },
        {
            "sha": "dffab945389ee1f16c0b36fb6bcf937c52e56334",
            "filename": "third_party/xla/xla/mlir_hlo/mhlo/transforms/convert_to_signless/convert_to_signless_pass.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 146,
            "changes": 146,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4c4b850ca19d7e786f20f2aa26a3eed9b7964c4/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fconvert_to_signless%2Fconvert_to_signless_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4c4b850ca19d7e786f20f2aa26a3eed9b7964c4/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fconvert_to_signless%2Fconvert_to_signless_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fconvert_to_signless%2Fconvert_to_signless_pass.cc?ref=e4c4b850ca19d7e786f20f2aa26a3eed9b7964c4",
            "patch": "@@ -1,146 +0,0 @@\n-/* Copyright 2020 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-// This file implements logic for translating mixed IR to buffer form.\n-// Currently it supports MHLO and some operations from the Standard dialect.\n-\n-#include <memory>\n-#include <utility>\n-\n-#include \"llvm/ADT/STLExtras.h\"\n-#include \"llvm/ADT/SmallVector.h\"\n-#include \"mhlo/transforms/passes.h\"\n-#include \"mhlo/utils/type_conversion.h\"\n-#include \"mlir/Dialect/Arith/IR/Arith.h\"\n-#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n-#include \"mlir/IR/Attributes.h\"\n-#include \"mlir/IR/BuiltinAttributes.h\"\n-#include \"mlir/IR/BuiltinOps.h\"\n-#include \"mlir/IR/BuiltinTypes.h\"\n-#include \"mlir/IR/MLIRContext.h\"\n-#include \"mlir/IR/Operation.h\"\n-#include \"mlir/IR/PatternMatch.h\"\n-#include \"mlir/Pass/Pass.h\"\n-#include \"mlir/Support/LLVM.h\"\n-#include \"mlir/Support/LogicalResult.h\"\n-#include \"mlir/Transforms/DialectConversion.h\"\n-\n-namespace mlir {\n-namespace mhlo {\n-\n-#define GEN_PASS_DEF_CONVERTTOSIGNLESSPASS\n-#include \"mhlo/transforms/mhlo_passes.h.inc\"\n-\n-namespace {\n-\n-// Generic pattern that rewrites any op by rewriting its operands and result\n-// types. Regions are also rewritten.\n-class ConvertToSignless : public ConversionPattern {\n- public:\n-  ConvertToSignless(TypeConverter& typeConverter, MLIRContext* context)\n-      : ConversionPattern(typeConverter, MatchAnyOpTypeTag{}, 0, context) {}\n-\n-  LogicalResult matchAndRewrite(\n-      Operation* op, ArrayRef<Value> operands,\n-      ConversionPatternRewriter& rewriter) const final {\n-    SmallVector<Type> resultTypes;\n-    if (failed(typeConverter->convertTypes(op->getResultTypes(), resultTypes)))\n-      return failure();\n-\n-    auto* newOp = Operation::create(\n-        op->getLoc(), op->getName(), resultTypes, operands, op->getAttrs(),\n-        op->getPropertiesStorage(), op->getSuccessors(), op->getNumRegions());\n-    for (auto regions : llvm::zip(op->getRegions(), newOp->getRegions())) {\n-      Region& before = std::get<0>(regions);\n-      Region& parent = std::get<1>(regions);\n-      rewriter.inlineRegionBefore(before, parent, parent.end());\n-      if (failed(rewriter.convertRegionTypes(&parent, *typeConverter)))\n-        return failure();\n-    }\n-    rewriter.insert(newOp);\n-    rewriter.replaceOp(op, newOp->getResults());\n-    return success();\n-  }\n-};\n-\n-// A pattern that converts the type of the attribute used as an operand for\n-// arith.constant\n-class ConvertConstantToSignless\n-    : public OpConversionPattern<arith::ConstantOp> {\n- public:\n-  ConvertConstantToSignless(TypeConverter& typeConverter, MLIRContext* context)\n-      : OpConversionPattern<arith::ConstantOp>(typeConverter, context) {}\n-\n-  LogicalResult matchAndRewrite(\n-      arith::ConstantOp constantOp, arith::ConstantOpAdaptor adaptor,\n-      ConversionPatternRewriter& rewriter) const override {\n-    // We only care about unsigned integers\n-    if (!mlir::isa<DenseIntElementsAttr>(adaptor.getValue())) return failure();\n-\n-    auto values =\n-        llvm::to_vector(mlir::cast<DenseIntElementsAttr>(adaptor.getValue())\n-                            .getValues<APInt>());\n-    Type type = typeConverter->convertType(constantOp.getType());\n-    auto shapedType = mlir::dyn_cast<ShapedType>(type);\n-    auto newValues = DenseIntElementsAttr::get(\n-        shapedType, values);\n-\n-    rewriter.replaceOpWithNewOp<arith::ConstantOp>(constantOp, newValues);\n-    return success();\n-  }\n-};\n-\n-struct ConvertToSignlessPass\n-    : public impl::ConvertToSignlessPassBase<ConvertToSignlessPass> {\n- public:\n-  void runOnOperation() override {\n-    auto& context = getContext();\n-    ConversionTarget target(context);\n-\n-    mhlo::RemoveSignTypeConverter converter;\n-    target.markUnknownOpDynamicallyLegal([&](auto op) {\n-      return converter.isLegal(op->getOperandTypes()) &&\n-             converter.isLegal(op->getResultTypes());\n-    });\n-    target.addDynamicallyLegalOp<func::FuncOp>([&](func::FuncOp op) {\n-      return converter.isSignatureLegal(op.getFunctionType());\n-    });\n-    target.addDynamicallyLegalOp<arith::ConstantOp>([&](arith::ConstantOp op) {\n-      return converter.isLegal(op.getType()) &&\n-             converter.isLegal(op.getValue().getType());\n-    });\n-\n-    RewritePatternSet patterns(&getContext());\n-    patterns.add<ConvertToSignless, ConvertConstantToSignless>(converter,\n-                                                               &context);\n-    // FuncOp is special as it has type encoding via attributes.\n-    populateFunctionOpInterfaceTypeConversionPattern<func::FuncOp>(patterns,\n-                                                                   converter);\n-\n-    auto module = getOperation();\n-    if (failed(applyFullConversion(module, target, std::move(patterns)))) {\n-      signalPassFailure();\n-    }\n-  }\n-};\n-\n-}  // namespace\n-\n-std::unique_ptr<OperationPass<ModuleOp>> createConvertToSignlessPass() {\n-  return std::make_unique<ConvertToSignlessPass>();\n-}\n-\n-}  // namespace mhlo\n-}  // namespace mlir"
        },
        {
            "sha": "4f11bd29b27dd74fdc67158a227f0d0789f0ae4c",
            "filename": "third_party/xla/xla/mlir_hlo/mhlo/transforms/mhlo_passes.td",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmhlo_passes.td",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmhlo_passes.td",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmhlo_passes.td?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -159,11 +159,6 @@ def FlattenTuplePass : Pass<\"mhlo-flatten-tuple\", \"func::FuncOp\"> {\n   let constructor = \"createFlattenTuplePass()\";\n }\n \n-def ConvertToSignlessPass : Pass<\"convert-to-signless\", \"ModuleOp\"> {\n-  let summary = \"Pass to transform the IR to be on signless integers.\";\n-  let constructor = \"createConvertToSignlessPass()\";\n-}\n-\n def CollapseElementwiseMapPass\n     : Pass<\"mhlo-collapse-elementwise-map\", \"func::FuncOp\"> {\n   let summary = \"Collapse the mhlo.map if the map only has elementwise ops.\";"
        },
        {
            "sha": "b7620882c3c430268b1830e14e9a27197b08238e",
            "filename": "third_party/xla/xla/mlir_hlo/mhlo/transforms/passes.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fpasses.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fpasses.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fpasses.h?ref=d14a3253576e2b5b656dbe0b9e7aa58ef9c29ade",
            "patch": "@@ -76,9 +76,6 @@ std::unique_ptr<OperationPass<ModuleOp>> createExpandHloTuplesPass(\n // op.\n std::unique_ptr<OperationPass<func::FuncOp>> createCollapseElementwiseMapPass();\n \n-// Pass to replace unsigned types with signless integers.\n-std::unique_ptr<OperationPass<ModuleOp>> createConvertToSignlessPass();\n-\n // Test passes.\n std::unique_ptr<Pass> createTestInferShapedTypeMethodsPass();\n std::unique_ptr<Pass> createTestMaterializeBroadcastsPass();"
        },
        {
            "sha": "55c5db1b869d58599618663747a48edf0d70f2a1",
            "filename": "third_party/xla/xla/mlir_hlo/tests/Dialect/mhlo/convert_to_signless.mlir",
            "status": "removed",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4c4b850ca19d7e786f20f2aa26a3eed9b7964c4/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Ftests%2FDialect%2Fmhlo%2Fconvert_to_signless.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4c4b850ca19d7e786f20f2aa26a3eed9b7964c4/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Ftests%2FDialect%2Fmhlo%2Fconvert_to_signless.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Ftests%2FDialect%2Fmhlo%2Fconvert_to_signless.mlir?ref=e4c4b850ca19d7e786f20f2aa26a3eed9b7964c4",
            "patch": "@@ -1,15 +0,0 @@\n-// RUN: mlir-hlo-opt %s --convert-to-signless --canonicalize | FileCheck %s\n-\n-func.func @Uint16ToInt16(%arg0: memref<*xui16>) -> memref<ui16> {\n-  // CHECK-NOT: unrealized_conversion_cast\n-  // CHECK: %[[CAST:.*]] = memref.cast %arg0 : memref<*xi16> to memref<i16>\n-  // CHECK: return %[[CAST]] : memref<i16>\n-  %1 = builtin.unrealized_conversion_cast %arg0 : memref<*xui16> to memref<*xi16>\n-  %2 = memref.cast %1 : memref<*xi16> to memref<i16>\n-  %3 = builtin.unrealized_conversion_cast %2 : memref<i16> to memref<ui16>\n-  %4 = bufferization.to_tensor %3 : memref<ui16> to tensor<ui16>\n-  %5 = builtin.unrealized_conversion_cast %4 : tensor<ui16> to tensor<i16>\n-  %6 = bufferization.to_buffer %5 : tensor<i16> to memref<i16>\n-  %7 = builtin.unrealized_conversion_cast %6 : memref<i16> to memref<ui16>\n-  func.return %7 : memref<ui16>\n-}"
        }
    ],
    "stats": {
        "total": 185,
        "additions": 7,
        "deletions": 178
    }
}