{
    "author": "shawnwang18",
    "message": "PR #30397: [XLA:GPU] Refactor dynamic slice fusion lowering code to reduce the API calls\n\nImported from GitHub PR https://github.com/openxla/xla/pull/30397\n\nThis PR should be able to remove many redundant calls to `GetLoopInductionVarTupleIdx`\nCopybara import of the project:\n\n--\n6a47f5265d6b7f84947a0fe477665a1bd89619fa by Shawn Wang <shawnw@nvidia.com>:\n\nRefactor dynamic slice fusion code to reduce the API calls\n\n--\n879089a5b5821bdc49407aebfb8142183422986b by Shawn Wang <shawnw@nvidia.com>:\n\nfix\n\n--\n6404d1f495f40b4a915bffe02c920633e4e413e9 by Shawn Wang <shawnw@nvidia.com>:\n\nfix\n\n--\n7360b5ad66e64d17f893a2b61310d72daed2fca9 by Shawn Wang <shawnw@nvidia.com>:\n\nfix\n\n--\nbce585c086e5be6dbc3d24bdf20aa765f52edb94 by Shawn Wang <shawnw@nvidia.com>:\n\nfix some comments\n\nMerging this change closes #30397\n\nPiperOrigin-RevId: 799557752",
    "sha": "429aad7c0f4567b298adcc28f05b105e2bc79767",
    "files": [
        {
            "sha": "a1b83f18289d4b6ba62082d9474778686dea99c9",
            "filename": "third_party/xla/xla/backends/gpu/codegen/custom.cc",
            "status": "modified",
            "additions": 93,
            "deletions": 76,
            "changes": 169,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/429aad7c0f4567b298adcc28f05b105e2bc79767/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/429aad7c0f4567b298adcc28f05b105e2bc79767/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc?ref=429aad7c0f4567b298adcc28f05b105e2bc79767",
            "patch": "@@ -209,17 +209,9 @@ std::optional<HloInstruction*> GetParentWhileOp(const HloInstruction& op,\n // hard checks for the conditions on this here, because these conditions are\n // ensured before fusing in\n // `dynamic_slice_fusion_rewriter.cc:IsValueFunctionOfLoopInductionVariable`.\n+// indvar_idx is the tuple index of the induction variable in the while body.\n std::unique_ptr<HloModule> ExtractOffsetModule(\n-    const HloInstruction* offset_value,\n-    std::optional<const HloInstruction*> while_op) {\n-  if (while_op == std::nullopt) return nullptr;\n-\n-  // First we check that we can get the indvar index.\n-  std::optional<int64_t> indvar_idx = GetLoopInductionVarTupleIdx(*while_op);\n-  CHECK(indvar_idx != std::nullopt)\n-      << \"Unable to get tuple idx for offset value: \"\n-      << (*while_op)->ToString();\n-\n+    const HloInstruction* offset_value, int64_t indvar_idx) {\n   // Extract offset as a function of parameter to while body.\n   std::unique_ptr<HloModule> extracted_offset = ExtractModule(\n       /*instruction=*/offset_value, /*height=*/-1,\n@@ -245,11 +237,11 @@ std::unique_ptr<HloModule> ExtractOffsetModule(\n       extracted_offset->entry_computation()->parameter_instruction(0)->users(),\n       [indvar_idx](const HloInstruction* instr) {\n         return instr->opcode() == HloOpcode::kGetTupleElement &&\n-               instr->tuple_index() == *indvar_idx;\n+               instr->tuple_index() == indvar_idx;\n       }))\n       << \"Extracted offset module does not have all operations on the \"\n          \"parameter as get-tuple-element for index \"\n-      << *indvar_idx << \": \" << extracted_offset->ToString();\n+      << indvar_idx << \": \" << extracted_offset->ToString();\n \n   // We simply replace the parameter with the get-tuple-element instruction as\n   // the parameter.\n@@ -265,27 +257,21 @@ std::unique_ptr<HloModule> ExtractOffsetModule(\n // variable. There are hard checks for the conditions on this here, because\n // these conditions are ensured before fusing in\n // `dynamic_slice_fusion_rewriter.cc:IsValueFunctionOfLoopInductionVariable`.\n+// indvar_idx is the tuple index of the induction variable in the while body.\n std::unique_ptr<HloModule> ExtractWhileUpdateModule(\n-    const HloInstruction* while_op) {\n-  std::optional<int64_t> tuple_idx = GetLoopInductionVarTupleIdx(while_op);\n-  if (tuple_idx == std::nullopt) {\n-    return nullptr;\n-  }\n+    const HloInstruction* while_op, int64_t indvar_idx) {\n   const HloInstruction* update =\n-      while_op->while_body()->root_instruction()->operand(*tuple_idx);\n-  return ExtractOffsetModule(update, while_op);\n+      while_op->while_body()->root_instruction()->operand(indvar_idx);\n+  return ExtractOffsetModule(update, indvar_idx);\n }\n \n // Extracts the while induction variable initialization module. This must have\n // no parameters and this condition was ensured before fusing in\n // `dynamic_slice_fusion_rewriter.cc:IsValueFunctionOfLoopInductionVariable`.\n+// indvar_idx is the tuple index of the induction variable in the while body.\n std::unique_ptr<HloModule> ExtractWhileInitModule(\n-    const HloInstruction* while_op) {\n-  std::optional<int64_t> tuple_idx = GetLoopInductionVarTupleIdx(while_op);\n-  if (tuple_idx == std::nullopt) {\n-    return nullptr;\n-  }\n-  const HloInstruction* init = while_op->operand(0)->operand(*tuple_idx);\n+    const HloInstruction* while_op, int64_t indvar_idx) {\n+  const HloInstruction* init = while_op->operand(0)->operand(indvar_idx);\n   std::unique_ptr<HloModule> init_module = ExtractModule(\n       /*instruction=*/init, /*height=*/-1, /*extract_selector=*/nullptr,\n       /*replace_type_selector=*/nullptr, /*cross_computation=*/false,\n@@ -301,6 +287,14 @@ bool IsDynamicSliceOrDynamicUpdateSlice(const HloInstruction* instr) {\n           instr->opcode() == HloOpcode::kDynamicUpdateSlice);\n }\n \n+// Collects the slice info for the argument `arg_idx` of the fusion\n+// `fusion_instr`. can_compute_indvar_on_host is true if the induction variable\n+// can be computed on host. while_op is the possible while op surrounding the\n+// fusion. indvar_idx is the possible tuple index of the induction variable in\n+// the while body.\n+// Note that when there is a wrapping while loop, we may not have an index\n+// variable for the loop, in case when the loop count is not naively controlled\n+// by a single loop index, so we will have the while op but no indvar_idx.\n absl::Status CollectSliceInfo(\n     const BufferAssignment& buffer_assignment,\n     const HloInstruction& fusion_instr,\n@@ -311,7 +305,8 @@ absl::Status CollectSliceInfo(\n     std::vector<std::optional<uint64_t>>& offset_byte_sizes,\n     std::vector<std::unique_ptr<HloModule>>& extracted_offset_modules,\n     unsigned arg_idx, bool can_compute_indvar_on_host,\n-    std::optional<const HloInstruction*> while_op) {\n+    std::optional<const HloInstruction*> while_op,\n+    std::optional<int64_t> indvar_idx) {\n   if (!IsDynamicSliceOrDynamicUpdateSlice(slice_instrs[arg_idx])) {\n     return absl::OkStatus();\n   }\n@@ -347,10 +342,10 @@ absl::Status CollectSliceInfo(\n             absl::StrCat(\"Unsupported constant offset shape: \",\n                          offset_literal->shape().ToString()));\n       }\n-\n-    } else if (std::unique_ptr<HloModule> offset_module =\n-                   ExtractOffsetModule(offset_value, while_op);\n-               (can_compute_indvar_on_host && offset_module != nullptr)) {\n+    } else if (indvar_idx != std::nullopt && can_compute_indvar_on_host) {\n+      std::unique_ptr<HloModule> offset_module =\n+          ExtractOffsetModule(offset_value, indvar_idx.value());\n+      CHECK(offset_module != nullptr) << \"Failed to extract slice module\";\n       extracted_offset_modules.push_back(std::move(offset_module));\n       arg_offsets.emplace_back() = extracted_offset_modules.back().get();\n     } else {\n@@ -406,9 +401,9 @@ absl::StatusOr<BufferAllocation::Slice> GetResultSlice(\n     return GetAllocationSlice(buffer_assignment, &fusion_instr, shape_idx);\n   }\n \n-  // Walk through ShapeIndex to find the real \"user\" (i.e. not get-tuple-element\n-  // user). Otherwise one sliced element will mark all buffers of all other\n-  // elements \"sliced\" too.\n+  // Walk through ShapeIndex to find the real \"user\" (i.e. not\n+  // get-tuple-element user). Otherwise one sliced element will mark all\n+  // buffers of all other elements \"sliced\" too.\n   if (start->shape().IsTuple()) {\n     for (auto [index_nesting_level, index_in_shape] :\n          llvm::enumerate(shape_idx)) {\n@@ -483,8 +478,8 @@ absl::StatusOr<BufferAllocation::Slice> GetResultSlice(\n   // computation. There are two options; either, the root is a tuple, or it is\n   // not.\n   //\n-  // If the root is not a tuple, we can simply get the buffer slice assigned to\n-  // the fusion itself---there is nothing else to choose from.\n+  // If the root is not a tuple, we can simply get the buffer slice assigned\n+  // to the fusion itself---there is nothing else to choose from.\n   if (fusion_instr.shape().IsArray()) {\n     HloInstruction* root = fusion_instr.fused_expression_root();\n     if (root->opcode() == HloOpcode::kDynamicUpdateSlice &&\n@@ -502,7 +497,8 @@ absl::StatusOr<BufferAllocation::Slice> GetResultSlice(\n   do {\n     TF_RET_CHECK(current_hlo->user_count() == 1);\n     HloInstruction* user = current_hlo->users().front();\n-    // We may encounter three ops here: dynamic-update-slice, tuple, or bitcast.\n+    // We may encounter three ops here: dynamic-update-slice, tuple, or\n+    // bitcast.\n     switch (user->opcode()) {\n       case HloOpcode::kBitcast:\n         break;\n@@ -547,44 +543,50 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n   std::optional<HloInstruction*> while_op =\n       GetParentWhileOp(fusion, call_graph);\n   std::unique_ptr<HloModule> init_module, update_module;\n+  std::optional<int64_t> indvar_idx;\n   if (while_op != std::nullopt) {\n     CHECK(while_op.value() != nullptr)\n         << \"GetWhileOp is not expected to return nullptr.\";\n-    init_module = ExtractWhileInitModule(*while_op);\n-    update_module = ExtractWhileUpdateModule(*while_op);\n+    indvar_idx = GetLoopInductionVarTupleIdx(*while_op);\n+    if (indvar_idx != std::nullopt) {\n+      init_module = ExtractWhileInitModule(*while_op, indvar_idx.value());\n+      update_module = ExtractWhileUpdateModule(*while_op, indvar_idx.value());\n+    }\n   }\n   bool can_compute_indvar_on_host =\n       (init_module != nullptr && update_module != nullptr);\n \n   unsigned arg_idx = 0;\n-  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice lhs_slice,\n-                      GetOperandSlice(buffer_assignment, adaptor, fusion,\n-                                      *custom_call.operand(arg_idx),\n-                                      slice_instrs, /*shape_idx=*/{}, arg_idx));\n+  TF_ASSIGN_OR_RETURN(\n+      BufferAllocation::Slice lhs_slice,\n+      GetOperandSlice(buffer_assignment, adaptor, fusion,\n+                      *custom_call.operand(arg_idx), slice_instrs,\n+                      /*shape_idx=*/{}, arg_idx));\n   TF_RETURN_IF_ERROR(CollectSliceInfo(\n       buffer_assignment, fusion, absl::Span<HloInstruction*>(slice_instrs),\n       offset_buffer_indices, orig_shapes, sliced_shapes, offset_byte_sizes,\n-      extracted_offset_modules, arg_idx++, can_compute_indvar_on_host,\n-      while_op));\n+      extracted_offset_modules, arg_idx++, can_compute_indvar_on_host, while_op,\n+      indvar_idx));\n \n-  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice rhs_slice,\n-                      GetOperandSlice(buffer_assignment, adaptor, fusion,\n-                                      *custom_call.operand(arg_idx),\n-                                      slice_instrs, /*shape_idx=*/{}, arg_idx));\n+  TF_ASSIGN_OR_RETURN(\n+      BufferAllocation::Slice rhs_slice,\n+      GetOperandSlice(buffer_assignment, adaptor, fusion,\n+                      *custom_call.operand(arg_idx), slice_instrs,\n+                      /*shape_idx=*/{}, arg_idx));\n   TF_RETURN_IF_ERROR(CollectSliceInfo(\n       buffer_assignment, fusion, absl::Span<HloInstruction*>(slice_instrs),\n       offset_buffer_indices, orig_shapes, sliced_shapes, offset_byte_sizes,\n-      extracted_offset_modules, arg_idx++, can_compute_indvar_on_host,\n-      while_op));\n+      extracted_offset_modules, arg_idx++, can_compute_indvar_on_host, while_op,\n+      indvar_idx));\n \n   BufferAllocation::Slice output;\n   std::optional<BufferAllocation::Slice> workspace = std::nullopt;\n   std::optional<BufferAllocation::Slice> slice_workspace_fake = std::nullopt;\n \n   // Handling cases where multiple operands share the same buffer, with\n-  // different offset by creating new fake allocations so each operand will have\n-  // a different buffer index. The slices can thus always start at offset 0.\n-  // DynamicSliceThunk will take care of the offset adjustment.\n+  // different offset by creating new fake allocations so each operand will\n+  // have a different buffer index. The slices can thus always start at offset\n+  // 0. DynamicSliceThunk will take care of the offset adjustment.\n   std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(4);\n   if (fusion.shape().IsArray()) {\n     TF_ASSIGN_OR_RETURN(\n@@ -593,8 +595,8 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n     TF_RETURN_IF_ERROR(CollectSliceInfo(\n         buffer_assignment, fusion, absl::Span<HloInstruction*>(slice_instrs),\n         offset_buffer_indices, orig_shapes, sliced_shapes, offset_byte_sizes,\n-        extracted_offset_modules, arg_idx, can_compute_indvar_on_host,\n-        while_op));\n+        extracted_offset_modules, arg_idx, can_compute_indvar_on_host, while_op,\n+        indvar_idx));\n   } else {\n     TF_ASSIGN_OR_RETURN(\n         output,\n@@ -605,7 +607,7 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n         buffer_assignment, fusion, absl::Span<HloInstruction*>(slice_instrs),\n         offset_buffer_indices, orig_shapes, sliced_shapes, offset_byte_sizes,\n         extracted_offset_modules, arg_idx++, can_compute_indvar_on_host,\n-        while_op));\n+        while_op, indvar_idx));\n \n     // TODO(vuson): If we want to support slices of workspace, we'd need to\n     // start `HloFindIf` with `get-tuple-element` with the right index.\n@@ -615,8 +617,8 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n     TF_RETURN_IF_ERROR(CollectSliceInfo(\n         buffer_assignment, fusion, absl::Span<HloInstruction*>(slice_instrs),\n         offset_buffer_indices, orig_shapes, sliced_shapes, offset_byte_sizes,\n-        extracted_offset_modules, arg_idx, can_compute_indvar_on_host,\n-        while_op));\n+        extracted_offset_modules, arg_idx, can_compute_indvar_on_host, while_op,\n+        indvar_idx));\n     fake_allocations[arg_idx] = std::make_unique<BufferAllocation>(\n         /*index=*/arg_idx, workspace->size(), /*color=*/0);\n     slice_workspace_fake = BufferAllocation::Slice(\n@@ -683,7 +685,8 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n           DynamicSliceThunk::OffsetAsFunctionOfIndvarModulesMetadata{\n               /*indvar_init=*/std::move(init_module),\n               /*indvar_update=*/std::move(update_module),\n-              /*extracted_offset_modules=*/std::move(extracted_offset_modules)};\n+              /*extracted_offset_modules=*/\n+              std::move(extracted_offset_modules)};\n     }\n     thunk = std::make_unique<DynamicSliceThunk>(\n         thunk_info, std::make_unique<ThunkSequence>(std::move(seq)),\n@@ -753,11 +756,15 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n   std::optional<HloInstruction*> while_op =\n       GetParentWhileOp(fusion, call_graph);\n   std::unique_ptr<HloModule> init_module, update_module;\n+  std::optional<int64_t> indvar_idx = std::nullopt;\n   if (while_op != std::nullopt) {\n     CHECK(while_op.value() != nullptr)\n         << \"GetWhileOp is not expected to return nullptr.\";\n-    init_module = ExtractWhileInitModule(*while_op);\n-    update_module = ExtractWhileUpdateModule(*while_op);\n+    indvar_idx = GetLoopInductionVarTupleIdx(*while_op);\n+    if (indvar_idx != std::nullopt) {\n+      init_module = ExtractWhileInitModule(*while_op, indvar_idx.value());\n+      update_module = ExtractWhileUpdateModule(*while_op, indvar_idx.value());\n+    }\n   }\n   bool can_compute_indvar_on_host =\n       (init_module != nullptr && update_module != nullptr);\n@@ -784,7 +791,7 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n               buffer_assignment, fusion,\n               absl::Span<HloInstruction*>(slice_instrs), offsets, orig_shapes,\n               sliced_shapes, offset_byte_sizes, extracted_offset_modules,\n-              arg_idx++, can_compute_indvar_on_host, while_op));\n+              arg_idx++, can_compute_indvar_on_host, while_op, indvar_idx));\n \n           operands.push_back(CustomCallThunk::Slice{slice, subshape});\n           arguments.push_back(slice);\n@@ -811,7 +818,7 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n             buffer_assignment, fusion,\n             absl::Span<HloInstruction*>(slice_instrs), offsets, orig_shapes,\n             sliced_shapes, offset_byte_sizes, extracted_offset_modules,\n-            arg_idx++, can_compute_indvar_on_host, while_op));\n+            arg_idx++, can_compute_indvar_on_host, while_op, indvar_idx));\n \n         results.push_back(CustomCallThunk::Slice{slice, subshape});\n         arguments.push_back(slice);\n@@ -831,8 +838,8 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n   CustomCallThunk::CustomCallTarget custom_call_target;\n \n   // For XLA FFI handlers we decode opaque backend config into attributes map\n-  // at IR emission time, so that we do not need to parse MLIR at run time. For\n-  // FFI handlers backend config must be a compatible MLIR dictionary.\n+  // at IR emission time, so that we do not need to parse MLIR at run time.\n+  // For FFI handlers backend config must be a compatible MLIR dictionary.\n   CustomCallThunk::AttributesMap attributes;\n \n   // For information about this calling convention, see\n@@ -982,7 +989,8 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n           DynamicSliceThunk::OffsetAsFunctionOfIndvarModulesMetadata{\n               /*indvar_init=*/std::move(init_module),\n               /*indvar_update=*/std::move(update_module),\n-              /*extracted_offset_modules=*/std::move(extracted_offset_modules)};\n+              /*extracted_offset_modules=*/\n+              std::move(extracted_offset_modules)};\n     }\n     thunk = std::make_unique<DynamicSliceThunk>(\n         thunk_info, std::make_unique<ThunkSequence>(std::move(seq)),\n@@ -1055,11 +1063,18 @@ CollectSliceArgumentMetadataForCollectives(\n   SliceDataForCollectives slice_data(num_args);\n   std::optional<HloInstruction*> while_op =\n       GetParentWhileOp(fusion_instr, call_graph);\n+\n+  std::optional<int64_t> indvar_idx = std::nullopt;\n   if (while_op != std::nullopt) {\n     CHECK(while_op.value() != nullptr)\n         << \"GetParentWhileOp is not expected to return nullptr.\";\n-    slice_data.init_module = ExtractWhileInitModule(*while_op);\n-    slice_data.update_module = ExtractWhileUpdateModule(*while_op);\n+    indvar_idx = GetLoopInductionVarTupleIdx(*while_op);\n+    if (indvar_idx != std::nullopt) {\n+      slice_data.init_module =\n+          ExtractWhileInitModule(*while_op, indvar_idx.value());\n+      slice_data.update_module =\n+          ExtractWhileUpdateModule(*while_op, indvar_idx.value());\n+    }\n   }\n   slice_data.can_compute_indvar_on_host = (slice_data.init_module != nullptr &&\n                                            slice_data.update_module != nullptr);\n@@ -1078,7 +1093,7 @@ CollectSliceArgumentMetadataForCollectives(\n         /*offsets=*/slice_data.offset_buffer_indices, slice_data.orig_shapes,\n         slice_data.sliced_shapes, slice_data.offset_byte_sizes,\n         slice_data.extracted_offset_modules, arg_idx,\n-        slice_data.can_compute_indvar_on_host, while_op));\n+        slice_data.can_compute_indvar_on_host, while_op, indvar_idx));\n     arg_idx++;\n   }\n \n@@ -1104,7 +1119,7 @@ CollectSliceArgumentMetadataForCollectives(\n         /*offsets=*/slice_data.offset_buffer_indices, slice_data.orig_shapes,\n         slice_data.sliced_shapes, slice_data.offset_byte_sizes,\n         slice_data.extracted_offset_modules, arg_idx,\n-        slice_data.can_compute_indvar_on_host, while_op));\n+        slice_data.can_compute_indvar_on_host, while_op, indvar_idx));\n     arg_idx++;\n   }\n \n@@ -1130,8 +1145,8 @@ CollectSliceArgumentMetadataForCollectives(\n       << \"Dynamic index operation found in a fusion instruction that is not \"\n          \"labelled dynamic_address_computation\";\n   if (slice_data.isDynamic) {\n-    // Provide fake allocations for inputs and outputs. The dynamic-slice thunk\n-    // will own these allocations.\n+    // Provide fake allocations for inputs and outputs. The dynamic-slice\n+    // thunk will own these allocations.\n     unsigned fake_arg_idx = 0;\n     for (HloInstruction* operand : instr->operands()) {\n       int64_t operand_byte_size = ShapeUtil::ByteSizeOf(operand->shape());\n@@ -1157,7 +1172,8 @@ CollectSliceArgumentMetadataForCollectives(\n       int64_t out_fake_byte_size = ShapeUtil::ByteSizeOf(user->shape());\n       slice_data.fake_allocations[fake_arg_idx] =\n           std::make_unique<BufferAllocation>(\n-              /*index=*/fake_arg_idx, /*size=*/out_fake_byte_size, /*color=*/0);\n+              /*index=*/fake_arg_idx, /*size=*/out_fake_byte_size,\n+              /*color=*/0);\n       BufferAllocation::Slice fake_slice(\n           /*allocation=*/slice_data.fake_allocations[fake_arg_idx].get(),\n           /*offset=*/0, /*size=*/out_fake_byte_size);\n@@ -1237,7 +1253,8 @@ absl::StatusOr<FusionEmissionResult> EmitCollective(\n       std::optional<BufferAllocation::Slice> dst =\n           slice_data.args()[idx + instr->operand_count()];\n       TF_RET_CHECK(src.has_value() && dst.has_value())\n-          << \"Expected source and destination to be present for non-degenerate \"\n+          << \"Expected source and destination to be present for \"\n+             \"non-degenerate \"\n              \"collective\";\n       buffers.push_back(CollectiveThunk::Buffer{\n           /*element_count=*/ShapeUtil::ElementsIn(src_shape),\n@@ -1272,8 +1289,8 @@ absl::StatusOr<FusionEmissionResult> EmitCollective(\n     return implementable_status;\n   }\n \n-  // Depending on whether this is a dynamic fusion or not, we wrap the thunk(s)\n-  // within a dynamic-slice thunk.\n+  // Depending on whether this is a dynamic fusion or not, we wrap the\n+  // thunk(s) within a dynamic-slice thunk.\n   if (slice_data.isDynamic) {\n     std::optional<DynamicSliceThunk::OffsetAsFunctionOfIndvarModulesMetadata>\n         offset_modules_metadata = std::nullopt;"
        }
    ],
    "stats": {
        "total": 169,
        "additions": 93,
        "deletions": 76
    }
}