{
    "author": "junwhanahn",
    "message": "Implement a new two-stage `ProgramInterpreter` design for better efficiency and safety\n\nThis CL implements a new design for `ProgramInterpreter` with a goal of separating work that can be done once per program vs. work that needs to be done per program invocation.\n\nThe current `ProgramInterpreter` design iterates over the compiled IFRT IR program and invokes IFRT APIs on demand. In this design, the interpreter needs to convert MLIR types into IFRT types, perform validation, etc. during every execution, which is wasteful since such information does not change.\n\nThe new design avoids the aforementioned problem by splitting the program interpreter into two stages. First, `ProgramInterpreter::BuildExecuteFn()` now traverses the program and *returns a function that can be invoked to run the program*. The execute function is built only once during compilation and can perform any work that only needs static information, e.g., building `xla::ifrt::RemapPlan` from a `RemapArraysOp` MLIR op. Once that is complete, each program invocation just needs to call the execute function produced by the program interpreter.\n\n`CompiledIfrtIRProgram` now carries this \"compiled\" execute functions so that this can be invoked by executables. This makes `CompiledIfrtIRProgram::program` optional since we no longer need to carry the MLIR module to execute an IFRT IR program. This can save host memory if there are a large number of IFRT IR programs.\n\nPiperOrigin-RevId: 841834380",
    "sha": "bf24158520d842ad494969edf868a3671f7f6257",
    "files": [
        {
            "sha": "8f35b34468e5b815e04ed91f4e2e43adf5ce74bf",
            "filename": "third_party/xla/xla/python/ifrt/ir/BUILD",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD?ref=bf24158520d842ad494969edf868a3671f7f6257",
            "patch": "@@ -507,6 +507,7 @@ cc_library(\n         \":atom_program_compiler\",\n         \":ifrt_ir_program\",\n         \":ir\",\n+        \":program_interpreter\",\n         \"//xla:status_macros\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/pjrt:pjrt_layout\",\n@@ -520,6 +521,7 @@ cc_library(\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/cleanup\",\n         \"@com_google_absl//absl/container:inlined_vector\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n@@ -542,7 +544,7 @@ cc_library(\n     compatible_with = get_compatible_with_portable(),\n     visibility = [\"//xla/python/ifrt:users\"],\n     deps = [\n-        \":compiled_ifrt_ir_program\",\n+        \":atom_program_compiler\",\n         \":ir\",\n         \"//xla:status_macros\",\n         \"//xla/python/ifrt\",\n@@ -555,6 +557,8 @@ cc_library(\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/container:inlined_vector\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n+        \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\","
        },
        {
            "sha": "67c912b86cafc2ae97fd3af16f114fd8c20a4549",
            "filename": "third_party/xla/xla/python/ifrt/ir/compiled_ifrt_ir_program.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.cc?ref=bf24158520d842ad494969edf868a3671f7f6257",
            "patch": "@@ -55,6 +55,7 @@ limitations under the License.\n #include \"xla/python/ifrt/ir/ifrt_dialect.h\"\n #include \"xla/python/ifrt/ir/ifrt_ir_program.h\"\n #include \"xla/python/ifrt/ir/ifrt_ops.h\"\n+#include \"xla/python/ifrt/ir/program_interpreter.h\"\n #include \"xla/python/ifrt/ir/transforms/debug.h\"\n #include \"xla/python/ifrt/ir/transforms/passes.h\"\n #include \"xla/python/ifrt/ir/transforms/utils.h\"\n@@ -327,6 +328,8 @@ absl::StatusOr<CompiledIfrtIrProgram> CompiledIfrtIrProgram::Create(\n   mlir::MLIRContext* context = mlir_module.getContext();\n   xla::ifrt::support::RegisterMlirDialects(*context);\n \n+  std::string program_name = mlir_module.getName().value_or(\"unknown\").str();\n+\n   // Add the bounded executables to the atom program executable map so that\n   // they can be used by the interpreter\n   std::shared_ptr<xla::ifrt::AtomExecutableMap> atom_executable_map =\n@@ -434,8 +437,16 @@ absl::StatusOr<CompiledIfrtIrProgram> CompiledIfrtIrProgram::Create(\n     }\n   }\n \n+  TF_ASSIGN_OR_RETURN(DeviceListRef device_list,\n+                      client->MakeDeviceList(devices));\n+  TF_ASSIGN_OR_RETURN(\n+      auto interpreter,\n+      ProgramInterpreter::Create(client, program_name, mlir_module,\n+                                 atom_executable_map, std::move(device_list)));\n+  TF_ASSIGN_OR_RETURN(auto execute_fn, interpreter->BuildExecuteFn());\n+\n   return CompiledIfrtIrProgram{\n-      /*program_name=*/mlir_module.getName().value_or(\"unknown\").str(),\n+      /*program_name=*/std::move(program_name),\n       /*atom_program_executables=*/std::move(atom_executable_map),\n       /*in_specs=*/std::move(in_specs),\n       /*out_specs=*/std::move(out_specs),\n@@ -444,6 +455,7 @@ absl::StatusOr<CompiledIfrtIrProgram> CompiledIfrtIrProgram::Create(\n       /*program=*/std::move(ifrt_ir_program),\n       /*device_assignments=*/std::move(device_assignments),\n       /*compile_options=*/compile_options,\n+      /*execute_fn=*/std::move(execute_fn),\n   };\n }\n "
        },
        {
            "sha": "c9baf2b35b5b8c336703f61f2da7d5d19cd4ba6b",
            "filename": "third_party/xla/xla/python/ifrt/ir/compiled_ifrt_ir_program.h",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.h?ref=bf24158520d842ad494969edf868a3671f7f6257",
            "patch": "@@ -16,14 +16,20 @@ limitations under the License.\n #ifndef XLA_PYTHON_IFRT_IR_COMPILED_IFRT_IR_PROGRAM_H_\n #define XLA_PYTHON_IFRT_IR_COMPILED_IFRT_IR_PROGRAM_H_\n #include <memory>\n+#include <optional>\n #include <string>\n #include <vector>\n \n+#include \"absl/functional/any_invocable.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/array_spec.h\"\n #include \"xla/python/ifrt/client.h\"\n #include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n+#include \"xla/python/ifrt/executable.h\"\n #include \"xla/python/ifrt/ir/atom_program_compiler.h\"\n #include \"xla/python/ifrt/ir/ifrt_ir_program.h\"\n \n@@ -63,6 +69,14 @@ struct CompiledIfrtIrProgram {\n   // The compile options used to compile the program.\n   std::shared_ptr<xla::ifrt::IfrtIRCompileOptions> compile_options;\n \n+  // Precompiled execute function that interprets the IFRT IR program. The\n+  // signature matches that of `xla::ifrt::LoadedExecutable::Execute()`.\n+  absl::AnyInvocable<absl::StatusOr<xla::ifrt::LoadedExecutable::ExecuteResult>(\n+      absl::Span<xla::ifrt::ArrayRef> arrays,\n+      const xla::ifrt::LoadedExecutable::ExecuteOptions& options,\n+      std::optional<xla::ifrt::DeviceListRef> devices)>\n+      execute_fn;\n+\n   // Compiles an IFRT IR program.\n   static absl::StatusOr<CompiledIfrtIrProgram> Create(\n       std::unique_ptr<xla::ifrt::IfrtIRProgram> ifrt_ir_program,"
        },
        {
            "sha": "deddd328048a7d7446efb6df5331ae553ec1bf47",
            "filename": "third_party/xla/xla/python/ifrt/ir/program_interpreter.cc",
            "status": "modified",
            "additions": 551,
            "deletions": 376,
            "changes": 927,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.cc?ref=bf24158520d842ad494969edf868a3671f7f6257",
            "patch": "@@ -15,6 +15,7 @@ limitations under the License.\n \n #include \"xla/python/ifrt/ir/program_interpreter.h\"\n \n+#include <cstdint>\n #include <memory>\n #include <optional>\n #include <string>\n@@ -24,18 +25,21 @@ limitations under the License.\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/container/inlined_vector.h\"\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/functional/bind_front.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n-#include \"llvm/ADT/DenseMap.h\"\n #include \"llvm/ADT/STLExtras.h\"\n #include \"llvm/ADT/TypeSwitch.h\"\n #include \"llvm/Support/Casting.h\"\n #include \"mlir/Analysis/Liveness.h\"\n #include \"mlir/Dialect/Func/IR/FuncOps.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n+#include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/Operation.h\"\n #include \"mlir/IR/Value.h\"\n #include \"mlir/Support/DebugStringHelper.h\"\n@@ -46,7 +50,7 @@ limitations under the License.\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n #include \"xla/python/ifrt/executable.h\"\n-#include \"xla/python/ifrt/ir/compiled_ifrt_ir_program.h\"\n+#include \"xla/python/ifrt/ir/atom_program_compiler.h\"\n #include \"xla/python/ifrt/ir/constants.h\"\n #include \"xla/python/ifrt/ir/ifrt_dialect.h\"\n #include \"xla/python/ifrt/ir/ifrt_ops.h\"\n@@ -74,12 +78,20 @@ using ExecuteResult = ::xla::ifrt::LoadedExecutable::ExecuteResult;\n \n namespace {\n \n+// Opaque handle that represents an array. Zero is reserved for null.\n+using ArrayHandle = uintptr_t;\n+\n // Array with additional metadata (e.g., if it can be donated).\n struct ArrayState {\n   ArrayRef array;\n   bool can_be_donated;\n };\n \n+// Assigns a unique handle to the given MLIR value.\n+ArrayHandle ToArrayHandle(mlir::Value value) {\n+  return reinterpret_cast<ArrayHandle>(value.getAsOpaquePointer());\n+}\n+\n // Returns an xla::ifrt::Sharding for the given IFRT array type.\n absl::StatusOr<xla::ifrt::ShardingRef> GetSharding(\n     xla::ifrt::IfrtArrayType array_type, xla::ifrt::Client* client,\n@@ -110,65 +122,23 @@ std::string PrettyPrintGeneric(mlir::Operation* op) {\n                       GetPrettyLocation(op->getLoc()));\n }\n \n-// Populates the cache storing a Sharding for each IfrtArrayType.\n-//\n-// This cache exists to avoid traversing and creating large device lists at\n-// execution time.\n-//\n-// Note that the cache is only populated for array types returned by CopyArrays\n-// and RemapArrays ops because they are the only ops that need shardings.\n-absl::StatusOr<llvm::DenseMap<xla::ifrt::IfrtArrayType, xla::ifrt::ShardingRef>>\n-PopulateShardingCache(mlir::func::FuncOp main_func, xla::ifrt::Client* client,\n-                      const xla::ifrt::DeviceListRef& devices) {\n-  llvm::DenseMap<xla::ifrt::IfrtArrayType, xla::ifrt::ShardingRef>\n-      array_type_to_sharding;\n-  for (const mlir::Operation& op : main_func.getOps()) {\n-    if (auto copy_arrays_op = llvm::dyn_cast<xla::ifrt::CopyArraysOp>(&op);\n-        copy_arrays_op != nullptr) {\n-      for (const auto [idx, output] :\n-           llvm::enumerate(copy_arrays_op.getOutputs())) {\n-        const auto array_type =\n-            llvm::cast<xla::ifrt::IfrtArrayType>(output.getType());\n-        TF_RET_CHECK(array_type != nullptr)\n-            << \"Output array #\" << idx << \" is not of type `IfrtArrayType`. \"\n-            << PrettyPrintGeneric(copy_arrays_op);\n-        if (array_type_to_sharding.find(array_type) ==\n-            array_type_to_sharding.end()) {\n-          TF_ASSIGN_OR_RETURN(auto sharding,\n-                              GetSharding(array_type, client, devices));\n-          array_type_to_sharding[array_type] = std::move(sharding);\n-        }\n-      }\n-    } else if (auto remap_op = llvm::dyn_cast<xla::ifrt::RemapArraysOp>(&op);\n-               remap_op != nullptr) {\n-      for (const auto [idx, output] : llvm::enumerate(remap_op.getOutputs())) {\n-        const auto array_type =\n-            llvm::cast<xla::ifrt::IfrtArrayType>(output.getType());\n-        TF_RET_CHECK(array_type != nullptr)\n-            << \"Output array #\" << idx << \" is not of type `IfrtArrayType`. \"\n-            << PrettyPrintGeneric(remap_op);\n-        if (array_type_to_sharding.find(array_type) ==\n-            array_type_to_sharding.end()) {\n-          TF_ASSIGN_OR_RETURN(auto sharding,\n-                              GetSharding(array_type, client, devices));\n-          array_type_to_sharding[array_type] = std::move(sharding);\n-        }\n-      }\n-    }\n-  }\n-  return array_type_to_sharding;\n-}\n-\n }  // namespace\n \n struct Environment {\n-  // Associates array with an MLIR value.\n-  void AssociateArray(mlir::Value value, ArrayState array) {\n-    CHECK(value_to_array.try_emplace(value, array).second);\n+  // Associates array with an opaque handle.\n+  void AssociateArray(ArrayHandle handle, ArrayState array) {\n+    CHECK(handle_to_array.try_emplace(handle, array).second);\n   }\n \n-  // Map from MLIR value to IFRT array corresponding to the value.\n-  llvm::DenseMap<mlir::Value, ArrayState> value_to_array;\n+  // IFRT client for execution.\n+  xla::ifrt::Client* client;\n+  // Name of the program.\n+  std::string program_name;\n+  // Set of donated program arguments, which can be deleted after their last\n+  // use. Entries are removed upon deletion or if they are aliased.\n+  absl::flat_hash_set<ArrayHandle> deletable_program_arguments;\n+  // Map from an opaque handle to IFRT array corresponding to the value.\n+  absl::flat_hash_map<ArrayHandle, ArrayState> handle_to_array;\n   // Outputs of the program.\n   std::vector<ArrayRef> outputs;\n   // `ExecuteOptions.fill_status` passed to Execute().\n@@ -179,213 +149,401 @@ struct Environment {\n };\n \n absl::StatusOr<std::unique_ptr<ProgramInterpreter>> ProgramInterpreter::Create(\n-    xla::ifrt::Client* client, std::shared_ptr<CompiledIfrtIrProgram> program,\n+    xla::ifrt::Client* client, absl::string_view program_name,\n+    mlir::ModuleOp mlir_module,\n+    std::shared_ptr<xla::ifrt::AtomExecutableMap> atom_program_executables,\n     xla::ifrt::DeviceListRef devices) {\n-  mlir::func::FuncOp main_func =\n-      xla::ifrt::GetMainFunction(program->program->mlir_module);\n+  mlir::func::FuncOp main_func = xla::ifrt::GetMainFunction(mlir_module);\n   if (!main_func->hasAttr(xla::ifrt::kIfrtFunctionAttrName)) {\n-    return absl::InvalidArgumentError(absl::StrCat(\n-        \"`main` function of IFRT IR program: \", program->program_name,\n-        \" is not an IFRT function.\"));\n+    return absl::InvalidArgumentError(\n+        absl::StrCat(\"`main` function of IFRT IR program: \", program_name,\n+                     \" is not an IFRT function.\"));\n   }\n-  TF_ASSIGN_OR_RETURN(auto array_type_to_sharding,\n-                      PopulateShardingCache(main_func, client, devices));\n   return std::unique_ptr<ProgramInterpreter>(new ProgramInterpreter(\n-      client, std::move(program), std::move(devices), mlir::Liveness(main_func),\n-      std::move(array_type_to_sharding)));\n+      client, program_name, mlir_module, std::move(atom_program_executables),\n+      std::move(devices), mlir::Liveness(main_func)));\n }\n \n-absl::StatusOr<ExecuteResult> ProgramInterpreter::Execute(\n-    absl::Span<ArrayRef> arrays, const ExecuteOptions& options,\n-    std::optional<xla::ifrt::DeviceListRef> devices) {\n-  TraceMe traceme([&]() {\n-    return TraceMeEncode(\"DispatchProgram\",\n-                         {\n-                             {\"ifrt_ir_program\", program_->program_name},\n-                         });\n-  });\n-  VLOG(2) << \"Started interpreting program: \" << program_->program_name;\n-  mlir::func::FuncOp main_func =\n-      xla::ifrt::GetMainFunction(program_->program->mlir_module);\n-  if (arrays.size() != main_func.getNumArguments()) {\n-    return absl::InvalidArgumentError(absl::StrCat(\n-        \"`main` function of IFRT IR program: \", program_->program_name,\n-        \" invoked with \", arrays.size(), \" arguments, but it expects \",\n-        main_func.getNumArguments(), \" arguments.\"));\n-  }\n+namespace {\n+\n+struct ProgramInterpreterState {\n+  xla::ifrt::Client* client;\n+  std::string program_name;\n \n-  for (const auto& [idx, array] : llvm::enumerate(arrays)) {\n-    if (array->IsDeleted()) {\n+  std::vector<ArrayHandle> input_handles;\n+  absl::flat_hash_set<int> donated_input_indices;\n+\n+  std::vector<absl::AnyInvocable<absl::Status(Environment& env) const>> op_fns;\n+\n+  absl::StatusOr<xla::ifrt::LoadedExecutable::ExecuteResult> Run(\n+      absl::Span<xla::ifrt::ArrayRef> arrays,\n+      const xla::ifrt::LoadedExecutable::ExecuteOptions& options,\n+      std::optional<xla::ifrt::DeviceListRef> devices) const {\n+    TraceMe traceme([&]() {\n+      return TraceMeEncode(\"DispatchProgram\",\n+                           {{\"ifrt_ir_program\", program_name}});\n+    });\n+    VLOG(2) << \"Started interpreting program: \" << program_name;\n+\n+    if (arrays.size() != input_handles.size()) {\n       return absl::InvalidArgumentError(absl::StrCat(\n-          \"Input array #\", idx, \" of program \", program_->program_name,\n-          \" has already been deleted or donated.\"));\n+          \"`main` function of IFRT IR program: \", program_name,\n+          \" invoked with \", arrays.size(), \" arguments, but it expects \",\n+          input_handles.size(), \" arguments.\"));\n     }\n-  }\n \n-  Environment env;\n-  env.fill_status = options.fill_status;\n+    for (int idx = 0; idx < arrays.size(); ++idx) {\n+      const xla::ifrt::ArrayRef& array = arrays[idx];\n+      if (array->IsDeleted()) {\n+        return absl::InvalidArgumentError(\n+            absl::StrCat(\"Input array #\", idx, \" of program \", program_name,\n+                         \" has already been deleted or donated.\"));\n+      }\n+    }\n+\n+    Environment env;\n+    env.client = client;\n+    env.fill_status = options.fill_status;\n+    for (int idx = 0; idx < input_handles.size(); ++idx) {\n+      // Add to the environment the arrays that are used.\n+      bool is_donated = donated_input_indices.contains(idx) &&\n+                        !options.non_donatable_input_indices.contains(idx);\n+      const ArrayHandle handle = input_handles[idx];\n+      if (handle != 0) {\n+        env.AssociateArray(handle, ArrayState{\n+                                       /*array=*/arrays[idx],\n+                                       /*can_be_donated=*/is_donated,\n+                                   });\n+        if (is_donated) {\n+          env.deletable_program_arguments.insert(handle);\n+        }\n+      } else if (is_donated) {\n+        // If the argument is donated but not used, it can be deleted.\n+        arrays[idx]->Delete();\n+      }\n+    }\n+\n+    for (const auto& op_fn : op_fns) {\n+      TF_RETURN_IF_ERROR(op_fn(env));\n+    }\n+\n+    VLOG(2) << \"Finished interpreting program: \" << program_name;\n+    ExecuteResult result;\n+    if (env.fill_status) {\n+      result.status =\n+          tsl::JoinFutures(absl::MakeSpan(env.leaf_call_op_futures));\n+    }\n+    result.outputs = std::move(env.outputs);\n+    return result;\n+  };\n+};\n+\n+}  // namespace\n+\n+absl::StatusOr<ProgramInterpreter::ExecuteFn>\n+ProgramInterpreter::BuildExecuteFn() {\n+  ProgramInterpreterState state;\n+  state.client = client_;\n+  state.program_name = program_name_;\n+\n+  mlir::func::FuncOp main_func = xla::ifrt::GetMainFunction(mlir_module_);\n+\n   for (const auto [idx, arg] : llvm::enumerate(main_func.getArguments())) {\n     // Add to the environment the arrays that are used.\n-    bool is_donated = main_func.getArgAttr(\n-                          idx, xla::ifrt::kIfrtDonatedArgAttrName) != nullptr &&\n-                      !options.non_donatable_input_indices.contains(idx);\n-    if (!arg.use_empty()) {\n-      env.AssociateArray(arg, ArrayState{/*array=*/arrays[idx],\n-                                         /*can_be_donated=*/is_donated});\n-      if (is_donated) {\n-        deletable_program_arguments_.insert(arg);\n-      }\n-    } else if (is_donated) {\n-      // If the argument is donated but not used, it can be deleted.\n-      arrays[idx]->Delete();\n+    const ArrayHandle handle = arg.use_empty() ? 0 : ToArrayHandle(arg);\n+    state.input_handles.push_back(handle);\n+    if (main_func.getArgAttr(idx, xla::ifrt::kIfrtDonatedArgAttrName) !=\n+        nullptr) {\n+      state.donated_input_indices.insert(idx);\n     }\n   }\n \n-  // Walk ops one-by-one in program order, and dispatch atom program and\n-  // copy arrays.\n+  // Walk ops one-by-one in program order and create functions that execute each\n+  // op on a given environment.\n   for (mlir::Operation& op : main_func.getOps()) {\n-    auto exec_op_status =\n-        llvm::TypeSwitch<const mlir::Operation&, absl::Status>(op)\n+    auto op_fn =\n+        llvm::TypeSwitch<const mlir::Operation&, absl::StatusOr<OpFn>>(op)\n             .Case<xla::ifrt::CallLoadedExecutableOp, xla::ifrt::RemapArraysOp,\n                   xla::ifrt::CopyArraysOp, mlir::func::ReturnOp>(\n-                [&](const auto& op) { return ExecuteOp(op, env); })\n-            .Default([&](const auto& op) {\n+                [this](const auto& op) { return HandleOp(op); })\n+            .Default([](const mlir::Operation& op) {\n               return absl::InvalidArgumentError(absl::StrCat(\n                   \"Interpreter found unexpected op: \", mlir::debugString(op)));\n             });\n-    if (!exec_op_status.ok()) {\n-      tsl::errors::AppendToMessage(&exec_op_status, PrettyPrint(&op));\n-      return exec_op_status;\n+    if (!op_fn.ok()) {\n+      absl::Status status = op_fn.status();\n+      tsl::errors::AppendToMessage(&status, PrettyPrint(&op));\n+      return status;\n     }\n+    state.op_fns.push_back(\n+        [op_fn = *std::move(op_fn),\n+         pretty_print = PrettyPrint(&op)](Environment& env) -> absl::Status {\n+          absl::Status status = op_fn(env);\n+          tsl::errors::AppendToMessage(&status, pretty_print);\n+          return status;\n+        });\n   }\n \n-  VLOG(2) << \"Finished interpreting program: \" << program_->program_name;\n-  ExecuteResult result;\n-  if (env.fill_status) {\n-    result.status = tsl::JoinFutures(absl::MakeSpan(env.leaf_call_op_futures));\n-  }\n-  result.outputs = std::move(env.outputs);\n-  return result;\n+  return absl::bind_front(&ProgramInterpreterState::Run, std::move(state));\n }\n \n-absl::Status ProgramInterpreter::ExecuteOp(\n-    xla::ifrt::CallLoadedExecutableOp call_loaded_op, Environment& env) {\n+namespace {\n+\n+struct CallLoadedExecutableOpState {\n+  std::string pretty_print;\n+  std::string atom_program_name;\n+\n+  std::vector<ArrayHandle> input_handles;\n+  absl::flat_hash_set<int> donated_arg_idxs;\n+  absl::flat_hash_set<ArrayHandle> dead_inputs;\n+\n+  xla::ifrt::LoadedExecutable::ExecuteOptions execute_options;\n+  std::shared_ptr<xla::ifrt::LoadedExecutable> executable;\n+\n+  std::vector<ArrayHandle> output_handles;\n+  bool is_leaf_op;\n+\n+  absl::Status Run(Environment& env) const {\n+    TraceMe traceme([&]() {\n+      return TraceMeEncode(\"DispatchLoadedExecutableOp\",\n+                           {\n+                               {\"ifrt_ir_program\", env.program_name},\n+                               {\"atom_program\", atom_program_name},\n+                           });\n+    });\n+    VLOG(3) << pretty_print;\n+\n+    xla::ifrt::LoadedExecutable::ExecuteOptions options = execute_options;\n+    options.fill_status = env.fill_status;\n+\n+    // Get the inputs of the loaded executable.\n+    std::vector<ArrayRef> inputs;\n+    std::vector<ArrayHandle> arrays_to_remove;\n+    for (int idx = 0; idx < input_handles.size(); ++idx) {\n+      const ArrayHandle handle = input_handles[idx];\n+\n+      auto array_it = env.handle_to_array.find(handle);\n+      TF_RET_CHECK(array_it != env.handle_to_array.end())\n+          << \"Input array #\" << idx << \" not found. \" << pretty_print;\n+      if (array_it->second.array->IsDeleted()) {\n+        // We explicitly check here for deletion in order to provide a more\n+        // informative error message.\n+        return absl::InvalidArgumentError(absl::StrCat(\n+            \"Input array #\", idx, \"` has already been deleted or donated. \",\n+            pretty_print));\n+      }\n+      inputs.push_back(array_it->second.array);\n+\n+      bool is_donated = donated_arg_idxs.contains(idx);\n+      if (is_donated && !array_it->second.can_be_donated) {\n+        VLOG(2) << \"Atom program donates input #\" << idx\n+                << \", but it has not been donated to the IFRT IR program. \"\n+                   \"Input will not be donated. \\n\"\n+                << pretty_print;\n+        is_donated = false;\n+      }\n+      if (is_donated || dead_inputs.contains(handle)) {\n+        arrays_to_remove.push_back(handle);\n+      }\n+      if (!is_donated) {\n+        options.non_donatable_input_indices.insert(idx);\n+      }\n+    }\n+\n+    TF_ASSIGN_OR_RETURN(xla::ifrt::LoadedExecutable::ExecuteResult result,\n+                        executable->Execute(absl::MakeSpan(inputs), options,\n+                                            /*devices=*/std::nullopt));\n+    TF_RET_CHECK(result.outputs.size() == output_handles.size())\n+        << \"Got \" << result.outputs.size() << \" results, but atom program has \"\n+        << output_handles.size() << \". \" << pretty_print;\n+\n+    // Remove the arrays from the environment after the inputs vector is\n+    // created. This is because in situations such as `ifrt.Call(%0, %0)` the\n+    // liveness analysis will return that %0 is dead, but it's used for the\n+    // second argument.\n+    for (const auto handle : arrays_to_remove) {\n+      if (env.deletable_program_arguments.erase(handle)) {\n+        // Explicitly delete donated program arguments that are not used later.\n+        env.handle_to_array[handle].array->Delete();\n+      }\n+      env.handle_to_array.erase(handle);\n+    }\n+\n+    for (int i = 0; i < output_handles.size(); ++i) {\n+      const ArrayHandle handle = output_handles[i];\n+      if (handle != 0) {\n+        // The output array is kept only if it used later. This can happen if an\n+        // executable has multiple output arrays, but only some of them are\n+        // used.\n+        env.AssociateArray(handle, ArrayState{\n+                                       /*array=*/std::move(result.outputs[i]),\n+                                       /*can_be_donated=*/true,\n+                                   });\n+      }\n+    }\n+    if (is_leaf_op && env.fill_status) {\n+      env.leaf_call_op_futures.push_back(std::move(result.status));\n+    }\n+    return absl::OkStatus();\n+  }\n+};\n+\n+}  // namespace\n+\n+absl::StatusOr<ProgramInterpreter::OpFn> ProgramInterpreter::HandleOp(\n+    xla::ifrt::CallLoadedExecutableOp call_loaded_op) {\n+  CallLoadedExecutableOpState state;\n+  state.pretty_print = PrettyPrint(call_loaded_op);\n+\n   xla::ifrt::LoadedExecutableOp loaded_exec_op =\n       call_loaded_op.getCalleeOp(symbol_table_);\n-  std::string atom_program_name = loaded_exec_op.getSymName().str();\n-  TraceMe traceme([&]() {\n-    return TraceMeEncode(\"DispatchLoadedExecutableOp\",\n-                         {\n-                             {\"ifrt_ir_program\", program_->program_name},\n-                             {\"atom_program\", atom_program_name},\n-                         });\n-  });\n-  std::string op_name = call_loaded_op->getName().getStringRef().str();\n-  VLOG(3) << PrettyPrint(call_loaded_op);\n+  state.atom_program_name = loaded_exec_op.getSymName().str();\n+\n   // Get the loaded executable for the atom program.\n-  auto exec_it = program_->atom_program_executables->find(atom_program_name);\n-  TF_RET_CHECK(exec_it != program_->atom_program_executables->end())\n-      << \"Could not find executable. \" << PrettyPrint(call_loaded_op);\n+  auto exec_it = atom_program_executables_->find(state.atom_program_name);\n+  TF_RET_CHECK(exec_it != atom_program_executables_->end())\n+      << \"Could not find executable. \" << state.pretty_print;\n+  state.executable = exec_it->second;\n \n-  absl::flat_hash_set<int> donated_arg_idxs(\n-      call_loaded_op.getDonatedInputIndices().begin(),\n-      call_loaded_op.getDonatedInputIndices().end());\n+  state.donated_arg_idxs.insert(call_loaded_op.getDonatedInputIndices().begin(),\n+                                call_loaded_op.getDonatedInputIndices().end());\n   for (const auto& io_alias :\n        call_loaded_op.getIoAliases().getAsRange<mlir::DenseI32ArrayAttr>()) {\n     // Insert the aliased input to the set.\n-    donated_arg_idxs.insert(io_alias.asArrayRef()[0]);\n+    state.donated_arg_idxs.insert(io_alias.asArrayRef()[0]);\n   }\n-  // Get the inputs of the loaded executable.\n-  std::vector<ArrayRef> inputs;\n-  xla::ifrt::LoadedExecutable::ExecuteOptions execute_options;\n-  execute_options.fill_status = env.fill_status;\n-  llvm::DenseSet<mlir::Value> array_values_to_gc_from_env;\n-  for (const auto [idx, input] : llvm::enumerate(call_loaded_op.getInputs())) {\n-    auto array_it = env.value_to_array.find(input);\n-    TF_RET_CHECK(array_it != env.value_to_array.end())\n-        << \"Input array #\" << idx << \" not found. \"\n-        << PrettyPrint(call_loaded_op);\n-    if (array_it->second.array->IsDeleted()) {\n-      // We explicitly check here for deletion in order to provide a more\n-      // informative error message.\n-      return absl::InvalidArgumentError(absl::StrCat(\n-          \"Input array #\", idx, \"` has already been deleted or donated. \",\n-          PrettyPrint(call_loaded_op)));\n-    }\n-    inputs.push_back(array_it->second.array);\n-\n-    bool is_donated = donated_arg_idxs.contains(idx);\n-    if (is_donated && !array_it->second.can_be_donated) {\n-      VLOG(2) << \"Atom program donates input #\" << idx\n-              << \", but it has not been donated to the IFRT IR program. \"\n-                 \"Input will not be donated. \\n\"\n-              << PrettyPrint(call_loaded_op);\n-      is_donated = false;\n-    }\n-    if (is_donated || liveness_.isDeadAfter(input, call_loaded_op)) {\n-      array_values_to_gc_from_env.insert(input);\n-    }\n-    if (!is_donated) {\n-      execute_options.non_donatable_input_indices.insert(idx);\n+  for (const auto input : call_loaded_op.getInputs()) {\n+    state.input_handles.push_back(ToArrayHandle(input));\n+    if (liveness_.isDeadAfter(input, call_loaded_op)) {\n+      state.dead_inputs.insert(ToArrayHandle(input));\n     }\n   }\n \n-  TF_ASSIGN_OR_RETURN(\n-      xla::ifrt::LoadedExecutable::ExecuteResult result,\n-      exec_it->second->Execute(absl::MakeSpan(inputs), execute_options,\n-                               /*devices=*/std::nullopt));\n-  TF_RET_CHECK(result.outputs.size() == call_loaded_op.getOutputs().size())\n-      << \"Got \" << result.outputs.size() << \" results, but atom program has \"\n-      << call_loaded_op.getOutputs().size() << \". \"\n-      << PrettyPrint(call_loaded_op);\n-\n-  // Remove the arrays from the environment after the inputs vector is created.\n-  // This is because in situations such as `ifrt.Call(%0, %0)` the liveness\n-  // analysis will return that %0 is dead, but it's used for the second\n-  // argument.\n-  for (const auto& array_value : array_values_to_gc_from_env) {\n-    if (deletable_program_arguments_.erase(array_value)) {\n-      // Explicitly delete donated program arguments that are not used later.\n-      env.value_to_array[array_value].array->Delete();\n-    }\n-    env.value_to_array.erase(array_value);\n-  }\n+  state.is_leaf_op = true;\n+  for (const auto output : call_loaded_op.getOutputs()) {\n+    const ArrayHandle handle = output.use_empty() ? 0 : ToArrayHandle(output);\n+    state.output_handles.push_back(handle);\n \n-  bool is_leaf_op = true;\n-  for (const auto [output_array, output] :\n-       llvm::zip(result.outputs, call_loaded_op.getOutputs())) {\n-    if (!output.use_empty()) {\n-      // The output array is kept only if it used later. This can happen if\n-      // an executable has multiple output arrays, but only some of them are\n-      // used.\n-      env.AssociateArray(output, ArrayState{/*array=*/std::move(output_array),\n-                                            /*can_be_donated=*/true});\n-    }\n-    if (is_leaf_op) {\n+    if (state.is_leaf_op) {\n       for (mlir::OpOperand& use : output.getUses()) {\n         // An ifrt.CallOp is not a leaf if any of its outputs are not returned.\n         if (llvm::dyn_cast<mlir::func::ReturnOp>(use.getOwner()) == nullptr) {\n-          is_leaf_op = false;\n+          state.is_leaf_op = false;\n           break;\n         }\n       }\n     }\n   }\n-  if (is_leaf_op && env.fill_status) {\n-    env.leaf_call_op_futures.push_back(std::move(result.status));\n-  }\n \n-  return absl::OkStatus();\n+  return absl::bind_front(&CallLoadedExecutableOpState::Run, std::move(state));\n }\n \n-absl::Status ProgramInterpreter::ExecuteOp(xla::ifrt::RemapArraysOp remap_op,\n-                                           Environment& env) {\n-  TraceMe traceme([&]() {\n-    return TraceMeEncode(\"DispatchRemapArraysOp\",\n-                         {{\"ifrt_ir_program\", program_->program_name}});\n-  });\n-  std::string op_name = remap_op->getName().getStringRef().str();\n-  VLOG(3) << PrettyPrint(remap_op);\n+namespace {\n+\n+struct RemapArraysOpState {\n+  std::string pretty_print;\n+\n+  xla::ifrt::RemapPlan remap_plan;\n+  std::vector<ArrayHandle> input_handles;\n+  absl::flat_hash_set<ArrayHandle> dead_inputs;\n+  bool remap_is_donated;\n+\n+  std::vector<ArrayHandle> output_handles;\n+\n+  absl::Status Run(Environment& env) const {\n+    TraceMe traceme([&]() {\n+      return TraceMeEncode(\"DispatchRemapArraysOp\",\n+                           {{\"ifrt_ir_program\", env.program_name}});\n+    });\n+    VLOG(3) << pretty_print;\n+\n+    std::vector<ArrayRef> inputs;\n+    inputs.reserve(remap_plan.input_specs.size());\n+\n+    std::optional<bool> is_donated;\n+    std::vector<ArrayHandle> arrays_to_remove;\n+\n+    for (int idx = 0; idx < input_handles.size(); ++idx) {\n+      const ArrayHandle handle = input_handles[idx];\n+\n+      auto array_it = env.handle_to_array.find(handle);\n+      TF_RET_CHECK(array_it != env.handle_to_array.end())\n+          << \"Input array #\" << idx << \" not found. \" << pretty_print;\n+      if (array_it->second.array->IsDeleted()) {\n+        // We explicitly check here for deletion in order to provide a more\n+        // informative error message.\n+        return absl::InvalidArgumentError(absl::StrCat(\n+            \"Input array #\", idx, \"` has already been deleted or donated. \",\n+            pretty_print));\n+      }\n+      inputs.push_back(array_it->second.array);\n+\n+      // The default buffer donation semantic is finalized at compilation time.\n+      // Users can override the donation semantic at runtime. In the meantime,\n+      // the IFRT client RemapArrays API requires all input arrays have the same\n+      // donation semantic.\n+      if (!is_donated.has_value()) {\n+        is_donated = remap_is_donated && array_it->second.can_be_donated;\n+      }\n+      if (*is_donated && !array_it->second.can_be_donated) {\n+        return absl::InvalidArgumentError(absl::StrCat(\n+            \"Donation semantic must be consistent across all input arrays of \"\n+            \"RemapArraysOp. Input array #\",\n+            idx,\n+            \" cannot be donated, but previous input arrays can be donated. \"\n+            \"It's likely due to a MPMD program argument is marked as \"\n+            \"non-donatable. \",\n+            pretty_print));\n+      }\n+      if (*is_donated || dead_inputs.contains(handle)) {\n+        arrays_to_remove.push_back(handle);\n+      }\n+    }\n+    TF_RET_CHECK(is_donated.has_value())\n+        << \"Unable to determine the donation semantic of the remap op. The \"\n+           \"remap op has no inputs. \"\n+        << pretty_print;\n+\n+    // Apply the remap arrays operation.\n+    xla::ifrt::ArrayCopySemantics copy_semantics =\n+        *is_donated ? xla::ifrt::ArrayCopySemantics::kDonateInput\n+                    : xla::ifrt::ArrayCopySemantics::kReuseInput;\n+    TF_ASSIGN_OR_RETURN(auto out_arrays, env.client->RemapArrays(\n+                                             remap_plan, absl::MakeSpan(inputs),\n+                                             copy_semantics));\n+\n+    for (const auto handle : arrays_to_remove) {\n+      // Donated remapped arrays are pro-actively deleted, and aliased arrays\n+      // cannot be deleted later. Thus, remove the arrays from the deletable\n+      // program arguments set.\n+      env.deletable_program_arguments.erase(handle);\n+      env.handle_to_array.erase(handle);\n+    }\n+\n+    // Store the result arrays in the environment.\n+    TF_RET_CHECK(out_arrays.size() == remap_plan.output_specs.size())\n+        << \"Got \" << out_arrays.size() << \" results, but op has \"\n+        << remap_plan.output_specs.size() << \". \" << pretty_print;\n+    for (int i = 0; i < output_handles.size(); ++i) {\n+      const ArrayHandle handle = output_handles[i];\n+      if (handle != 0) {\n+        env.AssociateArray(handle, ArrayState{\n+                                       /*array=*/std::move(out_arrays[i]),\n+                                       /*can_be_donated=*/true,\n+                                   });\n+      }\n+    }\n+\n+    return absl::OkStatus();\n+  }\n+};\n+\n+}  // namespace\n+\n+absl::StatusOr<ProgramInterpreter::OpFn> ProgramInterpreter::HandleOp(\n+    xla::ifrt::RemapArraysOp remap_op) {\n+  RemapArraysOpState state;\n+  state.pretty_print = PrettyPrint(remap_op);\n \n   // Construct the mappings of the remap plan.\n   auto mappings =\n@@ -410,54 +568,28 @@ absl::Status ProgramInterpreter::ExecuteOp(xla::ifrt::RemapArraysOp remap_op,\n     }\n   };\n \n-  std::vector<ArrayRef> inputs;\n-  std::vector<xla::ifrt::ArraySpec> input_specs;\n-  inputs.reserve(remap_op.getInputs().size());\n-  input_specs.reserve(remap_op.getInputs().size());\n   // Get the input specs of the remap plan and the input arrays.\n-  llvm::DenseSet<mlir::Value> array_values_to_gc_from_env;\n-  std::optional<bool> is_donated;\n+  std::vector<xla::ifrt::ArraySpec> input_specs;\n+  input_specs.reserve(remap_op.getOutputs().size());\n   for (const auto [idx, input] : llvm::enumerate(remap_op.getInputs())) {\n-    auto array_it = env.value_to_array.find(input);\n-    TF_RET_CHECK(array_it != env.value_to_array.end())\n-        << \"Input array #\" << idx << \" not found. \" << PrettyPrint(remap_op);\n-    if (array_it->second.array->IsDeleted()) {\n-      // We explicitly check here for deletion in order to provide a more\n-      // informative error message.\n-      return absl::InvalidArgumentError(absl::StrCat(\n-          \"Input array #\", idx, \" has already been deleted or donated. \",\n-          PrettyPrint(remap_op)));\n-    }\n-    inputs.push_back(array_it->second.array);\n+    state.input_handles.push_back(ToArrayHandle(input));\n+\n+    const auto array_type =\n+        llvm::cast<xla::ifrt::IfrtArrayType>(input.getType());\n+    TF_ASSIGN_OR_RETURN(\n+        xla::ifrt::DType dtype,\n+        xla::ifrt::ToIfrtDType(array_type.getShape().getElementType()));\n+    TF_ASSIGN_OR_RETURN(xla::ifrt::ShardingRef sharding,\n+                        GetSharding(array_type, client_, devices_));\n     input_specs.push_back(xla::ifrt::ArraySpec{\n-        /*dtype=*/array_it->second.array->dtype(),\n-        /*shape=*/array_it->second.array->shape(),\n-        /*sharding=*/array_it->second.array->shared_ptr_sharding()});\n-\n-    // The default buffer donation semantic is finalized at compilation time.\n-    // Users can override the donation semantic at runtime. In the meantime, the\n-    // IFRT client RemapArrays API requires all input arrays have the same\n-    // donation semantic.\n-    if (!is_donated.has_value()) {\n-      is_donated = remap_op.getDonated() && array_it->second.can_be_donated;\n-    }\n-    if (*is_donated && !array_it->second.can_be_donated) {\n-      return absl::InvalidArgumentError(absl::StrCat(\n-          \"Donation semantic must be consistent across all input arrays of \"\n-          \"RemapArraysOp. Input array #\",\n-          idx,\n-          \" cannot be donated, but previous input arrays can be donated. It's \"\n-          \"likely due to a MPMD program argument is marked as non-donatable. \",\n-          PrettyPrint(remap_op)));\n-    }\n-    if (*is_donated || liveness_.isDeadAfter(input, remap_op)) {\n-      array_values_to_gc_from_env.insert(input);\n+        /*dtype=*/dtype,\n+        /*shape=*/xla::ifrt::Shape(array_type.getShape().getShape()),\n+        /*sharding=*/std::move(sharding)});\n+\n+    if (liveness_.isDeadAfter(input, remap_op)) {\n+      state.dead_inputs.insert(ToArrayHandle(input));\n     }\n   }\n-  TF_RET_CHECK(is_donated.has_value())\n-      << \"Unable to determine the donation semantic of the remap op. The remap \"\n-         \"op has no inputs. \"\n-      << PrettyPrint(remap_op);\n \n   // Get the output specs of the remap plan.\n   std::vector<xla::ifrt::ArraySpec> output_specs;\n@@ -468,153 +600,196 @@ absl::Status ProgramInterpreter::ExecuteOp(xla::ifrt::RemapArraysOp remap_op,\n     TF_ASSIGN_OR_RETURN(\n         xla::ifrt::DType dtype,\n         xla::ifrt::ToIfrtDType(array_type.getShape().getElementType()));\n+    TF_ASSIGN_OR_RETURN(xla::ifrt::ShardingRef sharding,\n+                        GetSharding(array_type, client_, devices_));\n     output_specs.push_back(xla::ifrt::ArraySpec{\n         /*dtype=*/dtype,\n         /*shape=*/xla::ifrt::Shape(array_type.getShape().getShape()),\n-        /*sharding=*/array_type_to_sharding_.at(array_type)});\n+        /*sharding=*/std::move(sharding)});\n   }\n \n-  // Apply the remap arrays operation.\n-  xla::ifrt::ArrayCopySemantics copy_semantics =\n-      *is_donated ? xla::ifrt::ArrayCopySemantics::kDonateInput\n-                  : xla::ifrt::ArrayCopySemantics::kReuseInput;\n-  TF_ASSIGN_OR_RETURN(\n-      auto out_arrays,\n-      client_->RemapArrays({\n-                               /*input_specs=*/std::move(input_specs),\n-                               /*output_specs=*/std::move(output_specs),\n-                               /*mappings=*/std::move(mappings),\n-                           },\n-                           absl::MakeSpan(inputs), copy_semantics));\n-\n-  for (const auto& array_value : array_values_to_gc_from_env) {\n-    // Donated remapped arrays are pro-actively deleted, and aliased arrays\n-    // cannot be deleted later. Thus, remove the arrays from the deletable\n-    // program arguments set.\n-    deletable_program_arguments_.erase(array_value);\n-    env.value_to_array.erase(array_value);\n-  }\n+  state.remap_plan = xla::ifrt::RemapPlan{\n+      /*input_specs=*/std::move(input_specs),\n+      /*output_specs=*/std::move(output_specs),\n+      /*mappings=*/std::move(mappings),\n+  };\n+  state.remap_is_donated = remap_op.getDonated();\n \n-  // Store the result arrays in the environment.\n-  TF_RET_CHECK(out_arrays.size() == remap_op.getOutputs().size())\n-      << \"Got \" << out_arrays.size() << \" results, but op has \"\n-      << remap_op.getOutputs().size() << \". \" << PrettyPrint(remap_op);\n-  for (const auto [output_array, output] :\n-       llvm::zip(out_arrays, remap_op.getOutputs())) {\n-    if (!output.use_empty()) {\n-      env.AssociateArray(output, ArrayState{/*array=*/std::move(output_array),\n-                                            /*can_be_donated=*/true});\n-    }\n+  for (const auto output : remap_op.getOutputs()) {\n+    const ArrayHandle handle = output.use_empty() ? 0 : ToArrayHandle(output);\n+    state.output_handles.push_back(handle);\n   }\n-  return absl::OkStatus();\n+\n+  return absl::bind_front(&RemapArraysOpState::Run, std::move(state));\n }\n \n-absl::Status ProgramInterpreter::ExecuteOp(\n-    xla::ifrt::CopyArraysOp copy_arrays_op, Environment& env) {\n-  TraceMe traceme([&]() {\n-    return TraceMeEncode(\"DispatchCopyArraysOp\",\n-                         {{\"ifrt_ir_program\", program_->program_name}});\n-  });\n-  std::string op_name = copy_arrays_op->getName().getStringRef().str();\n-  VLOG(3) << PrettyPrint(copy_arrays_op);\n-\n-  std::vector<ArrayRef> inputs;\n-  inputs.reserve(copy_arrays_op.getInputs().size());\n-  llvm::DenseSet<mlir::Value> array_values_to_gc_from_env;\n-  std::optional<bool> is_donated;\n-  for (const auto [idx, input] : llvm::enumerate(copy_arrays_op.getInputs())) {\n-    auto array_it = env.value_to_array.find(input);\n-    TF_RET_CHECK(array_it != env.value_to_array.end())\n-        << \"Input array #\" << idx << \" not found. \"\n-        << PrettyPrint(copy_arrays_op);\n-    if (array_it->second.array->IsDeleted()) {\n-      // We explicitly check here for deletion in order to provide a more\n-      // informative error message.\n-      return absl::InvalidArgumentError(absl::StrCat(\n-          \"Input array #\", idx, \" has already been deleted or donated. \",\n-          PrettyPrint(copy_arrays_op)));\n+namespace {\n+\n+struct CopyArraysOpState {\n+  std::string pretty_print;\n+\n+  std::vector<ArrayHandle> input_handles;\n+  absl::flat_hash_set<ArrayHandle> dead_inputs;\n+  bool copy_is_donated;\n+\n+  std::vector<ArrayHandle> output_handles;\n+  xla::ifrt::ShardingRef new_sharding;\n+\n+  absl::Status Run(Environment& env) const {\n+    TraceMe traceme([&]() {\n+      return TraceMeEncode(\"DispatchCopyArraysOp\",\n+                           {{\"ifrt_ir_program\", env.program_name}});\n+    });\n+    VLOG(3) << pretty_print;\n+\n+    std::vector<ArrayRef> inputs;\n+    inputs.reserve(input_handles.size());\n+\n+    std::optional<bool> is_donated;\n+    std::vector<ArrayHandle> arrays_to_remove;\n+\n+    for (int idx = 0; idx < input_handles.size(); ++idx) {\n+      const ArrayHandle handle = input_handles[idx];\n+\n+      auto array_it = env.handle_to_array.find(handle);\n+      TF_RET_CHECK(array_it != env.handle_to_array.end())\n+          << \"Input array #\" << idx << \" not found. \" << pretty_print;\n+      if (array_it->second.array->IsDeleted()) {\n+        // We explicitly check here for deletion in order to provide a more\n+        // informative error message.\n+        return absl::InvalidArgumentError(absl::StrCat(\n+            \"Input array #\", idx, \" has already been deleted or donated. \",\n+            pretty_print));\n+      }\n+      inputs.push_back(array_it->second.array);\n+\n+      // The default buffer donation semantic is finalized at compilation time.\n+      // Users can override the donation semantic at runtime. In the meantime,\n+      // the IFRT client CopyArrays API requires all input arrays have the same\n+      // donation semantic.\n+      if (!is_donated.has_value()) {\n+        is_donated = copy_is_donated && array_it->second.can_be_donated;\n+      }\n+      if (*is_donated && !array_it->second.can_be_donated) {\n+        return absl::InvalidArgumentError(absl::StrCat(\n+            \"Donation semantic must be consistent across all input arrays of \"\n+            \"CopyArraysOp. Input array #\",\n+            idx,\n+            \" cannot be donated, but previous input arrays can be donated. \"\n+            \"It's likely due to a MPMD program argument is marked as \"\n+            \"non-donatable. \",\n+            pretty_print));\n+      }\n+      if (*is_donated || dead_inputs.contains(handle)) {\n+        arrays_to_remove.push_back(handle);\n+      }\n     }\n-    inputs.push_back(array_it->second.array);\n-\n-    // The default buffer donation semantic is finalized at compilation time.\n-    // Users can override the donation semantic at runtime. In the meantime, the\n-    // IFRT client CopyArrays API requires all input arrays have the same\n-    // donation semantic.\n-    if (!is_donated.has_value()) {\n-      is_donated =\n-          copy_arrays_op.getDonated() && array_it->second.can_be_donated;\n+    TF_RET_CHECK(is_donated.has_value())\n+        << \"Unable to determine the donation semantic of the copy arrays op. \"\n+           \"The copy arrays op has no inputs. \"\n+        << pretty_print;\n+\n+    auto array_copy_semantics =\n+        *is_donated ? xla::ifrt::ArrayCopySemantics::kDonateInput\n+                    : xla::ifrt::ArrayCopySemantics::kAlwaysCopy;\n+    // It is safe to get the devices and memory kind from the first output\n+    // because all outputs use the same devices and have the same memory kind.\n+    TF_ASSIGN_OR_RETURN(auto copied_arrays,\n+                        env.client->CopyArrays(\n+                            absl::MakeSpan(inputs), new_sharding->devices(),\n+                            new_sharding->memory_kind(), array_copy_semantics));\n+\n+    for (const auto handle : arrays_to_remove) {\n+      if (env.deletable_program_arguments.erase(handle)) {\n+        // Explicitly delete donated program arguments that are not used later.\n+        env.handle_to_array[handle].array->Delete();\n+      }\n+      env.handle_to_array.erase(handle);\n     }\n-    if (*is_donated && !array_it->second.can_be_donated) {\n-      return absl::InvalidArgumentError(absl::StrCat(\n-          \"Donation semantic must be consistent across all input arrays of \"\n-          \"CopyArraysOp. Input array #\",\n-          idx,\n-          \" cannot be donated, but previous input arrays can be donated. It's \"\n-          \"likely due to a MPMD program argument is marked as non-donatable. \",\n-          PrettyPrint(copy_arrays_op)));\n+\n+    TF_RET_CHECK(copied_arrays.size() == inputs.size())\n+        << \"Got \" << copied_arrays.size() << \" results, but op has \"\n+        << inputs.size() << \". \" << pretty_print;\n+    for (int i = 0; i < output_handles.size(); ++i) {\n+      const ArrayHandle handle = output_handles[i];\n+      if (handle != 0) {\n+        env.AssociateArray(handle, ArrayState{\n+                                       /*array=*/std::move(copied_arrays[i]),\n+                                       /*can_be_donated=*/true,\n+                                   });\n+      }\n     }\n-    if (*is_donated || liveness_.isDeadAfter(input, copy_arrays_op)) {\n-      array_values_to_gc_from_env.insert(input);\n+\n+    return absl::OkStatus();\n+  }\n+};\n+\n+}  // namespace\n+\n+absl::StatusOr<ProgramInterpreter::OpFn> ProgramInterpreter::HandleOp(\n+    xla::ifrt::CopyArraysOp copy_arrays_op) {\n+  CopyArraysOpState state;\n+  state.pretty_print = PrettyPrint(copy_arrays_op);\n+\n+  for (const auto [idx, input] : llvm::enumerate(copy_arrays_op.getInputs())) {\n+    state.input_handles.push_back(ToArrayHandle(input));\n+    if (liveness_.isDeadAfter(input, copy_arrays_op)) {\n+      state.dead_inputs.insert(ToArrayHandle(input));\n     }\n   }\n-  TF_RET_CHECK(is_donated.has_value())\n-      << \"Unable to determine the donation semantic of the copy arrays op. The \"\n-         \"copy arrays op has no inputs. \"\n-      << PrettyPrint(copy_arrays_op);\n+  state.copy_is_donated = copy_arrays_op.getDonated();\n \n   const auto out_array_type = llvm::cast<xla::ifrt::IfrtArrayType>(\n       copy_arrays_op.getOutputs().front().getType());\n   TF_RET_CHECK(out_array_type != nullptr)\n       << \"Output array #0 is not of type `IfrtArrayType`. \"\n-      << PrettyPrint(copy_arrays_op);\n-  auto new_sharding = array_type_to_sharding_.at(out_array_type);\n-  auto array_copy_semantics = *is_donated\n-                                  ? xla::ifrt::ArrayCopySemantics::kDonateInput\n-                                  : xla::ifrt::ArrayCopySemantics::kAlwaysCopy;\n-  // It is safe to get the devices and memory kind from the first output\n-  // because all outputs use the same devices and have the same memory kind.\n-  TF_ASSIGN_OR_RETURN(\n-      auto copied_arrays,\n-      client_->CopyArrays(absl::MakeSpan(inputs), new_sharding->devices(),\n-                          new_sharding->memory_kind(), array_copy_semantics));\n-\n-  for (const auto& array_value : array_values_to_gc_from_env) {\n-    if (deletable_program_arguments_.erase(array_value)) {\n-      // Explicitly delete donated program arguments that are not used later.\n-      env.value_to_array[array_value].array->Delete();\n-    }\n-    env.value_to_array.erase(array_value);\n+      << state.pretty_print;\n+  TF_ASSIGN_OR_RETURN(state.new_sharding,\n+                      GetSharding(out_array_type, client_, devices_));\n+\n+  for (const auto output : copy_arrays_op.getOutputs()) {\n+    const ArrayHandle handle = output.use_empty() ? 0 : ToArrayHandle(output);\n+    state.output_handles.push_back(handle);\n   }\n \n-  // Store the result arrays in the environment.\n-  TF_RET_CHECK(copied_arrays.size() == copy_arrays_op.getOutputs().size())\n-      << \"Got \" << copied_arrays.size() << \" results, but op has \"\n-      << copy_arrays_op.getOutputs().size() << \". \"\n-      << PrettyPrint(copy_arrays_op);\n-  for (const auto [output_array, output] :\n-       llvm::zip(copied_arrays, copy_arrays_op.getOutputs())) {\n-    if (!output.use_empty()) {\n-      env.AssociateArray(output, ArrayState{/*array=*/std::move(output_array),\n-                                            /*can_be_donated=*/true});\n+  return absl::bind_front(&CopyArraysOpState::Run, std::move(state));\n+}\n+\n+namespace {\n+\n+struct ReturnOpState {\n+  std::string pretty_print;\n+  std::vector<ArrayHandle> output_handles;\n+\n+  absl::Status Run(Environment& env) const {\n+    VLOG(3) << \"func.return of `main` function\";\n+    env.outputs.reserve(output_handles.size());\n+    for (int idx = 0; idx < output_handles.size(); ++idx) {\n+      auto array_it = env.handle_to_array.find(output_handles[idx]);\n+      TF_RET_CHECK(array_it != env.handle_to_array.end())\n+          << \"Input array #\" << idx << \" not found. \" << pretty_print;\n+      env.outputs.push_back(std::move(array_it->second.array));\n     }\n+    env.handle_to_array.clear();\n+    return absl::OkStatus();\n   }\n-  return absl::OkStatus();\n-}\n+};\n+\n+}  // namespace\n+\n+absl::StatusOr<ProgramInterpreter::OpFn> ProgramInterpreter::HandleOp(\n+    mlir::func::ReturnOp return_op) {\n+  ReturnOpState state;\n+  state.pretty_print = PrettyPrint(return_op);\n \n-absl::Status ProgramInterpreter::ExecuteOp(mlir::func::ReturnOp return_op,\n-                                           Environment& env) {\n   auto func_op = return_op->getParentOfType<mlir::func::FuncOp>();\n   CHECK_EQ(func_op.getSymName().str(), \"main\");\n-  VLOG(3) << return_op->getName().getStringRef().str() << \" of `main` function\";\n-  env.outputs.reserve(return_op->getNumOperands());\n+  state.output_handles.reserve(return_op->getNumOperands());\n   for (const auto& [idx, result] : llvm::enumerate(return_op.getOperands())) {\n-    auto array_it = env.value_to_array.find(result);\n-    TF_RET_CHECK(array_it != env.value_to_array.end())\n-        << \"Input array #\" << idx << \" not found. \" << PrettyPrint(return_op);\n-    env.outputs.push_back(std::move(array_it->second.array));\n+    state.output_handles.push_back(ToArrayHandle(result));\n   }\n-  env.value_to_array.clear();\n-  return absl::OkStatus();\n+\n+  return absl::bind_front(&ReturnOpState::Run, std::move(state));\n }\n \n std::string ProgramInterpreter::PrettyPrint(mlir::Operation* op) {"
        },
        {
            "sha": "35158ac1305124f349a12557f596ed63d2a27fdc",
            "filename": "third_party/xla/xla/python/ifrt/ir/program_interpreter.h",
            "status": "modified",
            "additions": 50,
            "deletions": 35,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf24158520d842ad494969edf868a3671f7f6257/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.h?ref=bf24158520d842ad494969edf868a3671f7f6257",
            "patch": "@@ -21,23 +21,22 @@ limitations under the License.\n #include <string>\n #include <utility>\n \n+#include \"absl/functional/any_invocable.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n-#include \"llvm/ADT/DenseMap.h\"\n-#include \"llvm/ADT/DenseSet.h\"\n #include \"mlir/Analysis/Liveness.h\"\n #include \"mlir/Dialect/Func/IR/FuncOps.h\"\n+#include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/SymbolTable.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/client.h\"\n #include \"xla/python/ifrt/device.h\"\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/executable.h\"\n-#include \"xla/python/ifrt/ir/compiled_ifrt_ir_program.h\"\n-#include \"xla/python/ifrt/ir/ifrt_dialect.h\"\n+#include \"xla/python/ifrt/ir/atom_program_compiler.h\"\n #include \"xla/python/ifrt/ir/ifrt_ops.h\"\n-#include \"xla/python/ifrt/sharding.h\"\n \n namespace xla {\n namespace ifrt {\n@@ -46,59 +45,75 @@ namespace ifrt {\n struct Environment;\n \n // Interpreter for an IFRT IR program.\n+//\n+// The program interpreter is responsible for executing an IFRT IR program. The\n+// interpreter works in two stages. First, when `BuildExecuteFn` is called, it\n+// traverses the program and builds a function that can be invoked to execute\n+// the program, which happens only once during compilation. Second, the returned\n+// execute function can be called multiple times to interpret the IFRT IR\n+// program.\n+//\n+// This two-stage design has two primary purposes:\n+//\n+// 1. It allows us to leverage the static information available in the program\n+//    as much as possible. For example, `RemapArraysOp` builds its remap plan\n+//    during the first stage and the plan is reused for all executions.\n+//\n+// 2. It avoids running any LLVM/MLIR code during execution. This is\n+//    particularly useful in environments where the use of LLVM/MLIR\n+//    synchronization primitives may cause deadlocks, e.g., cooperatively\n+//    scheduled fibers.\n class ProgramInterpreter {\n  public:\n+  using ExecuteFn = absl::AnyInvocable<\n+      absl::StatusOr<xla::ifrt::LoadedExecutable::ExecuteResult>(\n+          absl::Span<xla::ifrt::ArrayRef> arrays,\n+          const xla::ifrt::LoadedExecutable::ExecuteOptions& options,\n+          std::optional<xla::ifrt::DeviceListRef> devices)>;\n+\n   static absl::StatusOr<std::unique_ptr<ProgramInterpreter>> Create(\n-      xla::ifrt::Client* client, std::shared_ptr<CompiledIfrtIrProgram> program,\n+      xla::ifrt::Client* client, absl::string_view program_name,\n+      mlir::ModuleOp mlir_module,\n+      std::shared_ptr<xla::ifrt::AtomExecutableMap> atom_program_executables,\n       xla::ifrt::DeviceListRef devices);\n \n-  // Executes the IFRT IR program.\n-  absl::StatusOr<xla::ifrt::LoadedExecutable::ExecuteResult> Execute(\n-      absl::Span<xla::ifrt::ArrayRef> arrays,\n-      const xla::ifrt::LoadedExecutable::ExecuteOptions& options,\n-      std::optional<xla::ifrt::DeviceListRef> devices);\n+  absl::StatusOr<ExecuteFn> BuildExecuteFn();\n \n  private:\n+  using OpFn = absl::AnyInvocable<absl::Status(Environment& env) const>;\n+\n   ProgramInterpreter(\n-      xla::ifrt::Client* client, std::shared_ptr<CompiledIfrtIrProgram> program,\n-      xla::ifrt::DeviceListRef devices, mlir::Liveness liveness,\n-      llvm::DenseMap<xla::ifrt::IfrtArrayType, xla::ifrt::ShardingRef>\n-          array_type_to_sharding)\n+      xla::ifrt::Client* client, absl::string_view program_name,\n+      mlir::ModuleOp mlir_module,\n+      std::shared_ptr<xla::ifrt::AtomExecutableMap> atom_program_executables,\n+      xla::ifrt::DeviceListRef devices, mlir::Liveness liveness)\n       : client_(client),\n-        program_(std::move(program)),\n+        program_name_(program_name),\n+        mlir_module_(mlir_module),\n+        atom_program_executables_(std::move(atom_program_executables)),\n         devices_(std::move(devices)),\n-        liveness_(std::move(liveness)),\n-        array_type_to_sharding_(std::move(array_type_to_sharding)) {}\n+        liveness_(std::move(liveness)) {}\n \n-  absl::Status ExecuteOp(xla::ifrt::CallLoadedExecutableOp call_loaded_op,\n-                         Environment& env);\n-  absl::Status ExecuteOp(xla::ifrt::RemapArraysOp remap_op, Environment& env);\n-  absl::Status ExecuteOp(xla::ifrt::CopyArraysOp copy_arrays_op,\n-                         Environment& env);\n-  absl::Status ExecuteOp(mlir::func::ReturnOp return_op, Environment& env);\n+  absl::StatusOr<OpFn> HandleOp(\n+      xla::ifrt::CallLoadedExecutableOp call_loaded_op);\n+  absl::StatusOr<OpFn> HandleOp(xla::ifrt::RemapArraysOp remap_op);\n+  absl::StatusOr<OpFn> HandleOp(xla::ifrt::CopyArraysOp copy_arrays_op);\n+  absl::StatusOr<OpFn> HandleOp(mlir::func::ReturnOp return_op);\n \n   // Returns a pretty string representation of the op.\n   std::string PrettyPrint(mlir::Operation* op);\n \n   xla::ifrt::Client* client_;\n   mlir::SymbolTableCollection symbol_table_;\n-  std::shared_ptr<CompiledIfrtIrProgram> program_;\n+  std::string program_name_;\n+  mlir::ModuleOp mlir_module_;\n+  std::shared_ptr<xla::ifrt::AtomExecutableMap> atom_program_executables_;\n \n   // All the devices the program uses.\n   xla::ifrt::DeviceListRef devices_;\n \n   // Cached liveness analysis of the IFRT IR program.\n   mlir::Liveness liveness_;\n-\n-  // Mapping between IfrtArrayType and Sharding. This map is used to cache\n-  // the Shardings at IFRT IR program compilation time in order to avoid\n-  // overheads at execution time.\n-  llvm::DenseMap<xla::ifrt::IfrtArrayType, xla::ifrt::ShardingRef>\n-      array_type_to_sharding_;\n-\n-  // Set of donated program arguments, which can be deleted after their last\n-  // use. Entries are removed upon deletion or if they are aliased.\n-  llvm::DenseSet<mlir::Value> deletable_program_arguments_;\n };\n \n }  // namespace ifrt"
        }
    ],
    "stats": {
        "total": 1046,
        "additions": 633,
        "deletions": 413
    }
}