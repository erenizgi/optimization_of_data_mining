{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845699350",
    "sha": "0301475b0e056024d7b32533b18aeb6fdb2c609b",
    "files": [
        {
            "sha": "1e56ee3735163cd5f2e95416053fb6a2d6e63411",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0301475b0e056024d7b32533b18aeb6fdb2c609b/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0301475b0e056024d7b32533b18aeb6fdb2c609b/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=0301475b0e056024d7b32533b18aeb6fdb2c609b",
            "patch": "@@ -1920,17 +1920,18 @@ static void MaybeDumpHloSnapshot(\n   *hlo_snapshot.mutable_hlo()->mutable_hlo_module() = module.ToProto();\n \n   for (auto* argument : arguments) {\n-    *hlo_snapshot.add_arguments() = (*argument->ToLiteralSync())->ToProto();\n+    *hlo_snapshot.add_arguments() = (*argument->ToLiteral().Await())->ToProto();\n   }\n \n   // If there are multiple results, wrap them in a tuple.\n   if (results.size() == 1) {\n-    *hlo_snapshot.mutable_result() = (*results[0]->ToLiteralSync())->ToProto();\n+    *hlo_snapshot.mutable_result() =\n+        (*results[0]->ToLiteral().Await())->ToProto();\n   } else {\n     std::vector<Literal> result_literals;\n     result_literals.reserve(results.size());\n     for (auto& result : results) {\n-      result_literals.push_back(std::move(**result->ToLiteralSync()));\n+      result_literals.push_back(std::move(**result->ToLiteral().Await()));\n     }\n     *hlo_snapshot.mutable_result() =\n         LiteralUtil::MakeTupleOwned(std::move(result_literals)).ToProto();\n@@ -1987,7 +1988,7 @@ PjRtCpuExecutable::Execute(\n       for (const auto& argument_handle : argument_handles) {\n         HloInputs hlo_inputs;\n         for (const auto& buffer : argument_handle) {\n-          TF_ASSIGN_OR_RETURN(auto literal, buffer->ToLiteralSync());\n+          TF_ASSIGN_OR_RETURN(auto literal, buffer->ToLiteral().Await());\n           *hlo_inputs.add_arguments() = literal->ToProto();\n         }\n         *hlo_snapshot.add_partitions() = std::move(hlo_inputs);"
        },
        {
            "sha": "b1d1bd1ce8e27ff6193d709b45c6c2156c755ab9",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client_test.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 21,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0301475b0e056024d7b32533b18aeb6fdb2c609b/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0301475b0e056024d7b32533b18aeb6fdb2c609b/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client_test.cc?ref=0301475b0e056024d7b32533b18aeb6fdb2c609b",
            "patch": "@@ -445,7 +445,7 @@ TEST(PjRtCpuClientTest, AsyncTransferRawData) {\n   absl::string_view raw_data_view(raw_data, raw_data_size);\n   TF_ASSERT_OK(transfer_manager->TransferRawDataToBuffer(\n       0, absl::string_view(raw_data, raw_data_size), []() {}));\n-  TF_ASSERT_OK_AND_ASSIGN(auto literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto literal, buffer->ToLiteral().Await());\n   ASSERT_EQ(literal->element_count(), 3 * 2);\n   EXPECT_THAT(literal->data<uint32_t>(), Each(0x42424242));\n }\n@@ -466,7 +466,7 @@ TEST(PjRtCpuClientTest, AsyncTransferWithSpecs) {\n   absl::string_view raw_data_view(raw_data, raw_data_size);\n   TF_ASSERT_OK(transfer_manager->TransferRawDataToBuffer(\n       0, absl::string_view(raw_data, raw_data_size), []() {}));\n-  TF_ASSERT_OK_AND_ASSIGN(auto literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto literal, buffer->ToLiteral().Await());\n   ASSERT_EQ(literal->element_count(), 3 * 2);\n   EXPECT_THAT(literal->data<uint32_t>(), Each(0x42424242));\n }\n@@ -482,7 +482,7 @@ TEST(PjRtCpuClientTest, AsyncTransferLiteral) {\n   EXPECT_THAT(ready_future.IsReady(), IsFalse());\n   TF_ASSERT_OK_AND_ASSIGN(auto literal, xla::MakeFakeLiteral(shape));\n   TF_ASSERT_OK(transfer_manager->TransferLiteralToBuffer(0, literal, []() {}));\n-  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteral().Await());\n   EXPECT_THAT(received_literal->data<float>(),\n               ElementsAreArray(literal.data<float>()));\n }\n@@ -498,7 +498,7 @@ TEST(PjRtCpuClientTest, AsyncTransferLiteralInt4) {\n   EXPECT_THAT(ready_future.IsReady(), IsFalse());\n   TF_ASSERT_OK_AND_ASSIGN(auto literal, xla::MakeFakeLiteral(shape));\n   TF_ASSERT_OK(transfer_manager->TransferLiteralToBuffer(0, literal, []() {}));\n-  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteral().Await());\n   EXPECT_THAT(received_literal->data<s4>(),\n               ElementsAreArray(literal.data<s4>()));\n }\n@@ -510,7 +510,7 @@ TEST(PjRtCpuClientTest, BufferFromLiteralInt4) {\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto buffer,\n       client->BufferFromHostLiteral(literal, client->memory_spaces()[0]));\n-  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteral().Await());\n   EXPECT_THAT(received_literal->data<s4>(),\n               ElementsAreArray(literal.data<s4>()));\n }\n@@ -524,7 +524,7 @@ TEST(PjRtCpuClientTest, CopyToMemorySpace) {\n       client->BufferFromHostLiteral(literal, client->memory_spaces()[0]));\n   TF_ASSERT_OK_AND_ASSIGN(buffer,\n                           buffer->CopyToMemorySpace(buffer->memory_space()));\n-  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteral().Await());\n   EXPECT_THAT(received_literal->data<int32_t>(),\n               ElementsAreArray(literal.data<int32_t>()));\n }\n@@ -556,7 +556,7 @@ TEST(PjRtCpuClientTest, AsyncTransferNeverTransferred) {\n   auto buffer = transfer_manager->RetrieveBuffer(0);\n   transfer_manager.reset();\n   EXPECT_THAT(\n-      buffer->ToLiteralSync(),\n+      buffer->ToLiteral().Await(),\n       absl_testing::StatusIs(tsl::error::INTERNAL,\n                              HasSubstr(\"Async transfer object was deleted \"\n                                        \"before transfers completed.\")));\n@@ -603,7 +603,7 @@ TEST(PjRtCpuClientTest, AsyncTransferSetBufferError) {\n   auto buffer = transfer_manager->RetrieveBuffer(0);\n   transfer_manager->SetBufferError(0, Internal(\"foobar\"));\n   EXPECT_THAT(\n-      buffer->ToLiteralSync(),\n+      buffer->ToLiteral().Await(),\n       absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar\")));\n }\n \n@@ -615,7 +615,7 @@ TEST(PjRtCpuClientTest, CreateErrorBuffer) {\n         auto buffer,\n         client->CreateErrorBuffer(Internal(\"foobar\"), shape, memory_space));\n     EXPECT_THAT(\n-        buffer->ToLiteralSync(),\n+        buffer->ToLiteral().Await(),\n         absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar\")));\n     EXPECT_EQ(buffer->memory_space(), memory_space);\n   }\n@@ -640,7 +640,7 @@ TEST(PjRtCpuClientTest, AsyncTransferRawDataToSubBuffer) {\n   TF_ASSERT_OK(transfer_manager->TransferRawDataToSubBuffer(\n       0, raw_data_view.data(), raw_data_size - 1, 1, /*is_last_transfer=*/true,\n       []() {}));\n-  TF_ASSERT_OK_AND_ASSIGN(auto literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto literal, buffer->ToLiteral().Await());\n   ASSERT_EQ(literal->element_count(), 3 * 2);\n   EXPECT_THAT(literal->data<uint32_t>(), Each(0x42424242));\n }\n@@ -679,7 +679,7 @@ ENTRY Identity() -> f32[2, 2] {\n   ASSERT_THAT(result, absl_testing::StatusIs(tsl::error::OK));\n   // However, the buffer is expected to be poisoned.\n   EXPECT_THAT(\n-      result->at(0).at(0)->ToLiteralSync(),\n+      result->at(0).at(0)->ToLiteral().Await(),\n       absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar\")));\n }\n \n@@ -718,7 +718,7 @@ ENTRY Identity() -> f32[2, 2] {\n   ASSERT_EQ(result->size(), 1);\n   ASSERT_EQ(result->at(0).size(), 1);\n   EXPECT_THAT(\n-      result->at(0).at(0)->ToLiteralSync(),\n+      result->at(0).at(0)->ToLiteral().Await(),\n       absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar\")));\n }\n \n@@ -776,11 +776,11 @@ ENTRY Identity() -> f32[2, 2] {\n   }\n   for (int i = 0; i < output_buffers.size(); ++i) {\n     if (i % 2 == 0) {\n-      EXPECT_THAT(output_buffers[i]->ToLiteralSync(),\n+      EXPECT_THAT(output_buffers[i]->ToLiteral().Await(),\n                   absl_testing::StatusIs(tsl::error::OK));\n     } else {\n       EXPECT_THAT(\n-          output_buffers[i]->ToLiteralSync(),\n+          output_buffers[i]->ToLiteral().Await(),\n           absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar\")));\n     }\n   }\n@@ -833,15 +833,15 @@ ENTRY Identity() -> f32[2, 2] {\n   ASSERT_EQ(result->size(), 1);\n   ASSERT_EQ(result->at(0).size(), 1);\n   EXPECT_THAT(\n-      result->at(0).at(0)->ToLiteralSync(),\n+      result->at(0).at(0)->ToLiteral().Await(),\n       absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar1\")));\n \n   // A later error (propagated from the input buffer) would not affect the\n   // already poisoned output buffer.\n   transfer_manager->SetBufferError(0, Internal(\"foobar2\"));\n \n   EXPECT_THAT(\n-      result->at(0).at(0)->ToLiteralSync(),\n+      result->at(0).at(0)->ToLiteral().Await(),\n       absl_testing::StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar1\")));\n \n   // Attempting to poison a non-existent execution should fail.\n@@ -900,7 +900,7 @@ TEST(PjRtCpuClientTest, ForwardUserDataToFfiHandler) {\n   auto result = executable->Execute(/*argument_handles=*/{{}}, opts);\n \n   TF_ASSERT_OK_AND_ASSIGN(std::shared_ptr<xla::Literal> result_literal,\n-                          result->at(0).at(0)->ToLiteralSync());\n+                          result->at(0).at(0)->ToLiteral().Await());\n   EXPECT_TRUE(LiteralTestUtil::Equal(\n       LiteralUtil::CreateR1<float>({42.0f, 42.0f, 42.0f, 42.0f}),\n       *result_literal));\n@@ -944,7 +944,7 @@ TEST(PjRtCpuClientTest, PassAttrToFfiHandler) {\n   auto result = executable->Execute(/*argument_handles=*/{{}}, opts);\n \n   TF_ASSERT_OK_AND_ASSIGN(std::shared_ptr<xla::Literal> result_literal,\n-                          result->at(0).at(0)->ToLiteralSync());\n+                          result->at(0).at(0)->ToLiteral().Await());\n   EXPECT_TRUE(LiteralTestUtil::Equal(\n       LiteralUtil::CreateR1<float>({3.0f, 3.0f, 3.0f, 3.0f}), *result_literal));\n }\n@@ -1026,7 +1026,7 @@ TEST(PjRtCpuClientTest, CustomAllocator) {\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto buffer,\n       client->BufferFromHostLiteral(literal, client->memory_spaces()[0]));\n-  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(auto received_literal, buffer->ToLiteral().Await());\n \n   // Check that buffer was constructed in the data array provided by the custom\n   // allocator.\n@@ -1074,7 +1074,7 @@ TEST(PjRtCpuClientTest, SerializeYnnFusions) {\n   auto result = executable->Execute({{buf.get(), buf.get()}}, opts);\n \n   TF_ASSERT_OK_AND_ASSIGN(std::shared_ptr<xla::Literal> result_literal,\n-                          result->at(0).at(0)->ToLiteralSync());\n+                          result->at(0).at(0)->ToLiteral().Await());\n   EXPECT_TRUE(LiteralTestUtil::Equal(\n       LiteralUtil::CreateR1<float>(literal_data_x2_squared), *result_literal));\n \n@@ -1087,7 +1087,8 @@ TEST(PjRtCpuClientTest, SerializeYnnFusions) {\n       client->LoadSerializedExecutable(serialized, std::nullopt, {}));\n \n   result = executable->Execute({{buf.get(), buf.get()}}, opts);\n-  TF_ASSERT_OK_AND_ASSIGN(result_literal, result->at(0).at(0)->ToLiteralSync());\n+  TF_ASSERT_OK_AND_ASSIGN(result_literal,\n+                          result->at(0).at(0)->ToLiteral().Await());\n   EXPECT_TRUE(LiteralTestUtil::Equal(\n       LiteralUtil::CreateR1<float>(literal_data_x2_squared), *result_literal));\n }"
        },
        {
            "sha": "3e2f8aafc0000be70c8158df4d8d3767fae3e12f",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0301475b0e056024d7b32533b18aeb6fdb2c609b/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0301475b0e056024d7b32533b18aeb6fdb2c609b/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc?ref=0301475b0e056024d7b32533b18aeb6fdb2c609b",
            "patch": "@@ -81,7 +81,8 @@ class AlignedMemory final : public CpuDeviceMemory::RawMemory {\n       : base_(base), size_bytes_(size_bytes) {}\n \n   ~AlignedMemory() final {\n-    tsl::port::AlignedSizedFree(base_, cpu::MinAlign(), size_bytes_);\n+    tsl::port::AlignedSizedFree(base_, size_bytes_,\n+                                static_cast<std::align_val_t>(cpu::MinAlign()));\n   }\n \n   void* base() const final { return base_; }\n@@ -96,7 +97,8 @@ class AlignedAllocator final : public CpuDeviceMemory::Allocator {\n  public:\n   absl::StatusOr<std::unique_ptr<CpuDeviceMemory::RawMemory>> Allocate(\n       size_t size_bytes, size_t alignment) const final {\n-    if (void* base = tsl::port::AlignedMalloc(size_bytes, alignment)) {\n+    if (void* base = tsl::port::AlignedMalloc(\n+            size_bytes, static_cast<std::align_val_t>(alignment))) {\n       return std::make_unique<AlignedMemory>(base, size_bytes);\n     }\n     return ResourceExhausted(\"Out of memory allocating %d bytes.\", size_bytes);"
        }
    ],
    "stats": {
        "total": 58,
        "additions": 31,
        "deletions": 27
    }
}