{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 812376218",
    "sha": "d43197f4a10acecf3d88044556db4557156634e2",
    "files": [
        {
            "sha": "5f5ba1c930bfb45a87f3af1c29bbf842000e6c74",
            "filename": "third_party/xla/xla/stream_executor/executor_cache.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fexecutor_cache.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fexecutor_cache.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fexecutor_cache.cc?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -44,13 +44,13 @@ absl::StatusOr<StreamExecutor*> ExecutorCache::GetOrCreate(\n   VLOG(2) << \"building executor\";\n   TF_ASSIGN_OR_RETURN(std::unique_ptr<StreamExecutor> result, factory());\n   auto returned_executor = result.get();\n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   cache_.emplace(ordinal, std::move(result));\n   return returned_executor;\n }\n \n absl::StatusOr<StreamExecutor*> ExecutorCache::Get(int ordinal) {\n-  absl::ReaderMutexLock lock{&mutex_};\n+  absl::ReaderMutexLock lock{mutex_};\n \n   if (auto it = cache_.find(ordinal); it != cache_.end()) {\n     return it->second.get();"
        },
        {
            "sha": "43d476bcb832c5cee39fee6faf9c432432e4b104",
            "filename": "third_party/xla/xla/stream_executor/stream.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream.cc?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -34,7 +34,7 @@ Stream::ResourceTypeId Stream::GetNextResourceTypeId() {\n }\n \n Stream::Resource* Stream::GetOrNullResource(ResourceTypeId type_id) {\n-  absl::MutexLock lock(&resource_mutex_);\n+  absl::MutexLock lock(resource_mutex_);\n   auto it = resources_.find(type_id);\n   return (it != resources_.end()) ? it->second.get() : nullptr;\n }\n@@ -44,7 +44,7 @@ Stream::Resource* Stream::GetOrCreateResource(\n     absl::FunctionRef<std::unique_ptr<Resource>()> create) {\n   // First, try to find the resource under lock\n   {\n-    absl::MutexLock lock(&resource_mutex_);\n+    absl::MutexLock lock(resource_mutex_);\n     auto it = resources_.find(type_id);\n     if (ABSL_PREDICT_TRUE(it != resources_.end())) {\n       return it->second.get();\n@@ -57,7 +57,7 @@ Stream::Resource* Stream::GetOrCreateResource(\n \n   // Acquire lock again to insert the new resource\n   {\n-    absl::MutexLock lock(&resource_mutex_);\n+    absl::MutexLock lock(resource_mutex_);\n     auto it = resources_.find(type_id);\n     if (ABSL_PREDICT_TRUE(it == resources_.end())) {\n       // We won the race — insert our resource"
        },
        {
            "sha": "7a76379750f18c71878c3bc70a69caaa535824c8",
            "filename": "third_party/xla/xla/stream_executor/stream_common.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_common.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_common.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_common.cc?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -65,7 +65,7 @@ absl::StatusOr<Stream *> StreamCommon::GetOrCreateSubStream() {\n   // BlockHostUntilDone and it's host callbacks might attempt to acquire mu_.\n   std::vector<std::unique_ptr<Stream>> bad_streams;\n \n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n \n   // Look for the first reusable sub_stream that is ok, dropping !ok sub_streams\n   // we encounter along the way.\n@@ -111,7 +111,7 @@ void StreamCommon::ReturnSubStream(Stream *sub_stream) {\n   // BlockHostUntilDone and it's host callbacks might attempt to acquire mu_.\n   std::unique_ptr<Stream> bad_stream;\n \n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n \n   // Look for the sub-stream.\n   for (int64_t index = 0, end = sub_streams_.size(); index < end; ++index) {\n@@ -147,7 +147,7 @@ void StreamCommon::CheckError(bool operation_retcode) {\n   if (operation_retcode) {\n     return;\n   }\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   status_ = absl::InternalError(\"Unknown error\");\n }\n \n@@ -156,7 +156,7 @@ void StreamCommon::CheckStatus(absl::Status status) {\n     return;\n   }\n   LOG(ERROR) << status;\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   status_ = status;\n }\n "
        },
        {
            "sha": "48abdde421a1fa72f3b977dfffd876f19d96be4d",
            "filename": "third_party/xla/xla/stream_executor/stream_common.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_common.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_common.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_common.h?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -90,7 +90,7 @@ class StreamCommon : public Stream {\n \n  protected:\n   bool InErrorState() const TF_LOCKS_EXCLUDED(mu_) {\n-    absl::ReaderMutexLock lock(&mu_);\n+    absl::ReaderMutexLock lock(mu_);\n     return !status_.ok();\n   }\n "
        },
        {
            "sha": "5ac2900b6737358d2162dcc38d9b71d6d670493a",
            "filename": "third_party/xla/xla/stream_executor/stream_executor.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor.cc?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -34,7 +34,7 @@ StreamExecutor::ResourceTypeId StreamExecutor::GetNextResourceTypeId() {\n \n StreamExecutor::Resource* StreamExecutor::GetOrNullResource(\n     ResourceTypeId type_id) {\n-  absl::MutexLock lock(&resource_mutex_);\n+  absl::MutexLock lock(resource_mutex_);\n   auto it = resources_.find(type_id);\n   return (it != resources_.end()) ? it->second.get() : nullptr;\n }\n@@ -44,7 +44,7 @@ StreamExecutor::Resource* StreamExecutor::GetOrCreateResource(\n     absl::FunctionRef<std::unique_ptr<Resource>()> create) {\n   // First, try to find the resource under lock\n   {\n-    absl::MutexLock lock(&resource_mutex_);\n+    absl::MutexLock lock(resource_mutex_);\n     auto it = resources_.find(type_id);\n     if (ABSL_PREDICT_TRUE(it != resources_.end())) {\n       return it->second.get();\n@@ -57,7 +57,7 @@ StreamExecutor::Resource* StreamExecutor::GetOrCreateResource(\n \n   // Acquire lock again to insert the new resource\n   {\n-    absl::MutexLock lock(&resource_mutex_);\n+    absl::MutexLock lock(resource_mutex_);\n     auto it = resources_.find(type_id);\n     if (ABSL_PREDICT_TRUE(it == resources_.end())) {\n       // We won the race — insert our resource"
        },
        {
            "sha": "eed2c0338b3e4977102c23608333c68cc693acb2",
            "filename": "third_party/xla/xla/stream_executor/stream_executor_common.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor_common.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor_common.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor_common.cc?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -43,7 +43,7 @@ StreamExecutorCommon::StreamExecutorCommon(const Platform* platform)\n       memory_limit_bytes_(GetMemoryLimitBytesFromEnvironmentVariable()) {}\n \n const DeviceDescription& StreamExecutorCommon::GetDeviceDescription() const {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (device_description_ != nullptr) {\n     return *device_description_;\n   }"
        },
        {
            "sha": "dd70ddbb2b660407835370eaa21d48ba53217992",
            "filename": "third_party/xla/xla/stream_executor/stream_executor_memory_allocator.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor_memory_allocator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d43197f4a10acecf3d88044556db4557156634e2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor_memory_allocator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fstream_executor_memory_allocator.cc?ref=d43197f4a10acecf3d88044556db4557156634e2",
            "patch": "@@ -104,7 +104,7 @@ absl::StatusOr<Stream*> StreamExecutorMemoryAllocator::GetStream(\n       << \"The logic below only works for synchronous allocators\";\n   TF_ASSIGN_OR_RETURN(StreamExecutor * executor,\n                       GetStreamExecutor(device_ordinal));\n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   if (!streams_.count(device_ordinal)) {\n     TF_ASSIGN_OR_RETURN(auto stream, executor->CreateStream());\n     auto stream_ptr = stream.get();"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 15,
        "deletions": 15
    }
}