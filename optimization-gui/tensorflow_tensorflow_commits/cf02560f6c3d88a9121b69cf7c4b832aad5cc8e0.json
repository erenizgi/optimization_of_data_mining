{
    "author": "tensorflower-gardener",
    "message": "Add GpuOnDeviceEventReceiver and GpuOnDeviceEventCollector.\nGpuOnDeviceEventReceiver is a singleton that receives GpuOnDeviceEvent(s). It is public through c++ APIs or Python bindings, so that client can inject events.\nGpuOnDeviceEventCollector takes GpuOnDeviceTraceEvents from GpuOnDeviceEventReceiver, store and export them.\n\nPiperOrigin-RevId: 800599016",
    "sha": "cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
    "files": [
        {
            "sha": "46f449d62a93d3a3d70e899aad85b7e48a9adae7",
            "filename": "third_party/xla/xla/backends/profiler/gpu/BUILD",
            "status": "modified",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2FBUILD?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -546,6 +546,56 @@ cc_library(\n     alwayslink = 1,\n )\n \n+cc_library(\n+    name = \"ondevice_event_exporter\",\n+    srcs = [\"ondevice_event_exporter.cc\"],\n+    hdrs = [\"ondevice_event_exporter.h\"],\n+    # copybara:uncomment compatible_with = [\"//buildenv/target:non_prod\"],\n+    tags = [\n+        \"cuda-only\",\n+        \"gpu\",\n+    ],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \":cupti_buffer_events\",\n+        \"//xla/tsl/profiler/backends/gpu:ondevice_event_collector\",\n+        \"//xla/tsl/profiler/backends/gpu:ondevice_trace_event\",\n+        \"//xla/tsl/profiler/utils:lock_free_queue\",\n+        \"//xla/tsl/profiler/utils:trace_utils\",\n+        \"//xla/tsl/profiler/utils:xplane_builder\",\n+        \"//xla/tsl/profiler/utils:xplane_schema\",\n+        \"//xla/tsl/profiler/utils:xplane_utils\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"ondevice_event_exporter_test\",\n+    srcs = [\"ondevice_event_exporter_test.cc\"],\n+    tags = [\n+        \"cuda-only\",\n+        \"gpu\",\n+        \"no_mac\",\n+        \"requires-gpu-nvidia\",\n+    ],\n+    deps = [\n+        \":ondevice_event_exporter\",\n+        \"//xla/tsl/profiler/backends/gpu:ondevice_event_receiver\",\n+        \"//xla/tsl/profiler/backends/gpu:ondevice_trace_event\",\n+        \"//xla/tsl/profiler/utils:xplane_builder\",\n+        \"//xla/tsl/profiler/utils:xplane_schema\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:test\",\n+        \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n+    ],\n+)\n+\n cc_library(\n     name = \"cupti_status\",\n     srcs = [\"cupti_status.cc\"],"
        },
        {
            "sha": "711cb2c01df92158d5deff454a5b428f5aafa210",
            "filename": "third_party/xla/xla/backends/profiler/gpu/ondevice_event_exporter.cc",
            "status": "added",
            "additions": 242,
            "deletions": 0,
            "changes": 242,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter.cc?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,242 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/gpu/ondevice_event_exporter.h\"\n+\n+#include <algorithm>\n+#include <cstddef>\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <utility>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/backends/profiler/gpu/cupti_buffer_events.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_trace_event.h\"\n+#include \"xla/tsl/profiler/utils/lock_free_queue.h\"\n+#include \"xla/tsl/profiler/utils/trace_utils.h\"\n+#include \"xla/tsl/profiler/utils/xplane_builder.h\"\n+#include \"xla/tsl/profiler/utils/xplane_schema.h\"\n+#include \"xla/tsl/profiler/utils/xplane_utils.h\"\n+\n+using ::tensorflow::profiler::XPlane;\n+using ::tensorflow::profiler::XSpace;\n+using ::tsl::profiler::GpuOnDeviceTraceEvent;\n+using ::tsl::profiler::XEventBuilder;\n+using ::tsl::profiler::XEventMetadata;\n+using ::tsl::profiler::XLineBuilder;\n+using ::tsl::profiler::XPlaneBuilder;\n+\n+namespace xla {\n+namespace profiler {\n+namespace {\n+\n+class EventQueueWithStringSilo {\n+ public:\n+  using EventQueue = ::tsl::profiler::BlockedQueue<GpuOnDeviceTraceEvent>;\n+\n+  void Clear() {\n+    absl::MutexLock lock(&m_);\n+    string_silo_.Clear();\n+    events_.Clear();\n+  }\n+\n+  void AddEvent(GpuOnDeviceTraceEvent&& event);\n+\n+  absl::flat_hash_map<int64_t, EventQueue> GroupPerInstanceEvents();\n+\n+ private:\n+  absl::Mutex m_;\n+  StringDeduper string_silo_ ABSL_GUARDED_BY(m_);\n+  EventQueue events_ ABSL_GUARDED_BY(m_);\n+};\n+\n+using EventQueue = EventQueueWithStringSilo::EventQueue;\n+\n+void EventQueueWithStringSilo::AddEvent(GpuOnDeviceTraceEvent&& event) {\n+  absl::MutexLock lock(&m_);\n+  event.tag_name = string_silo_.Dedup(event.tag_name);\n+  events_.Push(std::move(event));\n+}\n+\n+absl::flat_hash_map<int64_t, EventQueue>\n+EventQueueWithStringSilo::GroupPerInstanceEvents() {\n+  absl::flat_hash_map<int64_t, EventQueue> grouped;\n+  // Note: after GroupPerInstanceEvents, the events_ is empty.\n+  absl::MutexLock lock(&m_);\n+  for (std::optional<GpuOnDeviceTraceEvent> event = events_.Pop();\n+       event.has_value(); event = events_.Pop()) {\n+    grouped[event->injection_instance_id].Push(std::move(event.value()));\n+  }\n+  return grouped;\n+}\n+\n+class OndeviceLineIdAllocator {\n+ public:\n+  int64_t operator()(uint32_t pid, uint32_t tid) {\n+    uint64_t key = Key(pid, tid);\n+    auto it = pid_tid_to_line_id_.find(key);\n+    if (it != pid_tid_to_line_id_.end()) {\n+      return it->second;\n+    }\n+    int64_t line_id = pid_tid_to_line_id_.size();\n+    pid_tid_to_line_id_[key] = line_id;\n+    return line_id;\n+  }\n+\n+ private:\n+  static inline uint64_t Key(uint32_t pid, uint32_t tid) {\n+    return static_cast<uint64_t>(pid) << 32 | tid;\n+  }\n+\n+  absl::flat_hash_map<uint64_t, int64_t> pid_tid_to_line_id_;\n+};\n+\n+class GpuOnDeviceTraceEventCollectorImpl final\n+    : public GpuOnDeviceTraceEventExporter {\n+ public:\n+  GpuOnDeviceTraceEventCollectorImpl(\n+      const GpuOnDeviceTraceEventCollectorOptions& options,\n+      uint64_t start_walltime_ns, uint64_t start_gputime_ns)\n+      : options_(options), start_gputime_ns_(start_gputime_ns) {}\n+\n+  ~GpuOnDeviceTraceEventCollectorImpl() override = default;\n+\n+  absl::Status AddEvent(GpuOnDeviceTraceEvent&& event) override;\n+\n+  absl::Status Export(XSpace* space, uint64_t end_gpu_ns) override;\n+\n+ private:\n+  const GpuOnDeviceTraceEventCollectorOptions& options() const {\n+    return options_;\n+  };\n+\n+  void CreateXEvent(GpuOnDeviceTraceEvent& event, XPlaneBuilder* plane,\n+                    XLineBuilder* line, int64_t adjust_time_ns);\n+\n+  size_t FlushPerInstanceEvents(uint32_t instance_id, uint64_t end_gpu_ns,\n+                                XSpace* space);\n+\n+  const GpuOnDeviceTraceEventCollectorOptions options_;\n+  uint64_t start_gputime_ns_;\n+  EventQueueWithStringSilo all_events_ = {};\n+  absl::flat_hash_map<int64_t, EventQueue> instance_events_ = {};\n+};\n+\n+void GpuOnDeviceTraceEventCollectorImpl::CreateXEvent(\n+    GpuOnDeviceTraceEvent& event, XPlaneBuilder* plane, XLineBuilder* line,\n+    int64_t adjust_time_ns) {\n+  XEventMetadata* event_metadata =\n+      plane->GetOrCreateEventMetadata(event.tag_name);\n+  XEventBuilder xevent = line->AddEvent(*event_metadata);\n+  xevent.SetTimestampNs(event.start_time_ns + adjust_time_ns);\n+  xevent.SetDurationPs(static_cast<int64_t>(event.duration_ps));\n+}\n+\n+size_t GpuOnDeviceTraceEventCollectorImpl::FlushPerInstanceEvents(\n+    uint32_t instance_id, uint64_t end_gpu_ns, XSpace* space) {\n+  // Create a plane for each instance.\n+  if (instance_id >= ::tsl::profiler::kNumGpuOnDeviceCustomPlanesPerHost) {\n+    LOG(WARNING) << \"Instance id \" << instance_id\n+                 << \" is larger than kNumGpuOnDeviceCustomPlanesPerHost(\"\n+                 << ::tsl::profiler::kNumGpuOnDeviceCustomPlanesPerHost << \")\";\n+    return 0;\n+  }\n+\n+  auto& events = instance_events_[instance_id];\n+  // As uint32 is used for the mosaic event time, no absolute time could be\n+  // calculated. So we use the earliest time stamp for this instance to align\n+  // with the collector start time. Note such alignment only happens when the\n+  // earliest time less than the collector start time.\n+  int64_t earliest_time_ns = std::numeric_limits<int64_t>::max();\n+  for (auto it = events.begin(), ite = events.end(); it != ite; ++it) {\n+    earliest_time_ns = std::min(earliest_time_ns, it->start_time_ns);\n+  }\n+  int64_t adjust_time_ns =\n+      static_cast<int64_t>(start_gputime_ns_) <= earliest_time_ns\n+          ? 0\n+          : static_cast<int64_t>(start_gputime_ns_) - earliest_time_ns;\n+\n+  std::string plane_name =\n+      ::tsl::profiler::GpuOnDeviceTracePlaneName(instance_id);\n+  XPlane* plane =\n+      ::tsl::profiler::FindOrAddMutablePlaneWithName(space, plane_name);\n+  plane->set_id(::tsl::profiler::kFirstGpuOnDeviceCustomPlaneId + instance_id);\n+  XPlaneBuilder plane_builder(plane);\n+\n+  size_t num_events = 0;\n+  OndeviceLineIdAllocator line_id_allocator;\n+  for (auto it = events.begin(), ite = events.end(); it != ite; ++it) {\n+    auto& event = *it;\n+    int64_t line_id = line_id_allocator(event.pid, event.tid);\n+    XLineBuilder line = plane_builder.GetOrCreateLine(line_id);\n+    if (line.Name().empty()) {\n+      line.SetName(absl::StrFormat(\"PID#%9u, TID#%9u\", it->pid, it->tid));\n+      line.SetTimestampNs(start_gputime_ns_);\n+    }\n+    CreateXEvent(event, &plane_builder, &line, adjust_time_ns);\n+    num_events++;\n+  }\n+  events.Clear();\n+  return num_events;\n+}\n+\n+absl::Status GpuOnDeviceTraceEventCollectorImpl::Export(XSpace* space,\n+                                                        uint64_t end_gpu_ns) {\n+  instance_events_ = all_events_.GroupPerInstanceEvents();\n+  for (auto& [instance_id, events] : instance_events_) {\n+    FlushPerInstanceEvents(instance_id, end_gpu_ns, space);\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status GpuOnDeviceTraceEventCollectorImpl::AddEvent(\n+    GpuOnDeviceTraceEvent&& event) {\n+  if (event.injection_instance_id > options_.max_injection_instance) {\n+    LOG_FIRST_N(WARNING, 32) << \"Injection instance id \"\n+                             << event.injection_instance_id << \" is too large.\";\n+    return absl::InvalidArgumentError(\"Injection instance id is too large.\");\n+  }\n+  if (event.pid >= options_.max_pid && options_.max_pid > 0) {\n+    LOG_FIRST_N(WARNING, 32) << \"Pid \" << event.pid << \" is too large.\";\n+    return absl::InvalidArgumentError(\"Pid is too large.\");\n+  }\n+  if (event.tid >= options_.max_tid && options_.max_tid > 0) {\n+    LOG_FIRST_N(WARNING, 32) << \"Tid \" << event.tid << \" is too large.\";\n+    return absl::InvalidArgumentError(\"Tid is too large.\");\n+  }\n+  all_events_.AddEvent(std::move(event));\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace\n+\n+std::unique_ptr<GpuOnDeviceTraceEventExporter>\n+CreateGpuOnDeviceTraceEventExporter(\n+    const GpuOnDeviceTraceEventCollectorOptions& options,\n+    uint64_t start_walltime_ns, uint64_t start_gputime_ns) {\n+  return std::make_unique<GpuOnDeviceTraceEventCollectorImpl>(\n+      options, start_walltime_ns, start_gputime_ns);\n+}\n+\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "2bf5090a10ef603a39d64d4805138362fd464320",
            "filename": "third_party/xla/xla/backends/profiler/gpu/ondevice_event_exporter.h",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter.h?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,57 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_PROFILER_GPU_ONDEVICE_EVENT_EXPORTER_H_\n+#define XLA_BACKENDS_PROFILER_GPU_ONDEVICE_EVENT_EXPORTER_H_\n+\n+#include <cstdint>\n+#include <memory>\n+\n+#include \"absl/status/status.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_event_collector.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_trace_event.h\"\n+#include \"tsl/profiler/protobuf/xplane.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+\n+struct GpuOnDeviceTraceEventCollectorOptions {\n+  int32_t max_injection_instance = 0;\n+  int32_t max_pid = 0;\n+  int32_t max_tid = 0;\n+};\n+\n+// Add export() to GpuOnDeviceTraceEventCollector.\n+class GpuOnDeviceTraceEventExporter\n+    : public ::tsl::profiler::GpuOnDeviceTraceEventCollector {\n+ public:\n+  ~GpuOnDeviceTraceEventExporter() override = default;\n+\n+  absl::Status AddEvent(\n+      ::tsl::profiler::GpuOnDeviceTraceEvent&& event) override = 0;\n+\n+  virtual absl::Status Export(tensorflow::profiler::XSpace* space,\n+                              uint64_t end_gpu_ns) = 0;\n+};\n+\n+std::unique_ptr<GpuOnDeviceTraceEventExporter>\n+CreateGpuOnDeviceTraceEventExporter(\n+    const GpuOnDeviceTraceEventCollectorOptions& options,\n+    uint64_t start_walltime_ns, uint64_t start_gputime_ns);\n+\n+}  // namespace profiler\n+}  // namespace xla\n+\n+#endif  // XLA_BACKENDS_PROFILER_GPU_ONDEVICE_EVENT_EXPORTER_H_"
        },
        {
            "sha": "61bef5b7e91763e42b6eac157075b8054ebe74f5",
            "filename": "third_party/xla/xla/backends/profiler/gpu/ondevice_event_exporter_test.cc",
            "status": "added",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fondevice_event_exporter_test.cc?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,90 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/gpu/ondevice_event_exporter.h\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_event_receiver.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_trace_event.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace test {\n+\n+namespace {\n+\n+using ::tsl::profiler::GpuOnDeviceTraceEvent;\n+using ::tsl::profiler::GpuOnDeviceTraceEventReceiver;\n+\n+TEST(GpuOnDeviceTraceEventExporterTest, SimpleInjection) {\n+  static constexpr int kMaxInjectionInstance = 1;\n+  std::unique_ptr<GpuOnDeviceTraceEventExporter> collector =\n+      CreateGpuOnDeviceTraceEventExporter(\n+          {.max_injection_instance = kMaxInjectionInstance,\n+           .max_pid = 10,\n+           .max_tid = 10},\n+          0, 0);\n+  auto* receiver = GpuOnDeviceTraceEventReceiver::GetSingleton();\n+  ASSERT_EQ(receiver->ActiveVersion(), 0);\n+\n+  auto status_or_version =\n+      receiver->StartWith(collector.get(), kMaxInjectionInstance);\n+  ASSERT_TRUE(status_or_version.ok());\n+  size_t version = status_or_version.value();\n+  ASSERT_NE(version, 0);\n+\n+  int32_t wrong_version_injection =\n+      receiver->StartInjectionInstance(version + 100);\n+  ASSERT_EQ(wrong_version_injection, 0);\n+\n+  int32_t instance_id = receiver->StartInjectionInstance(version);\n+  ASSERT_NE(instance_id, 0);\n+\n+  GpuOnDeviceTraceEvent event{\n+      .injection_instance_id = instance_id,\n+      .tag_name = \"test_tag\",\n+      .pid = 1,\n+      .tid = 1,\n+      .start_time_ns = 10,\n+      .duration_ps = 10000,\n+  };\n+  ASSERT_TRUE(receiver->Inject(version, std::move(event)).ok());\n+\n+  GpuOnDeviceTraceEvent event_wrong_instance_id{\n+      .injection_instance_id = instance_id + 10,\n+      .tag_name = \"wrong_instance_id\",\n+      .pid = 1,\n+      .tid = 1,\n+      .start_time_ns = 20,\n+      .duration_ps = 10000,\n+  };\n+  auto status = receiver->Inject(version, std::move(event_wrong_instance_id));\n+  ASSERT_FALSE(status.ok());\n+  ASSERT_EQ(status.message(), \"Injection instance id is out of range.\");\n+\n+  ASSERT_TRUE(receiver->Stop().ok());\n+}\n+\n+}  // namespace\n+\n+}  // namespace test\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "6ec798711156849253d8a06fa9658dd1534d7012",
            "filename": "third_party/xla/xla/tsl/profiler/backends/gpu/BUILD",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2FBUILD?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,54 @@\n+load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\")\n+load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_library\")\n+load(\"//xla/tsl/profiler/builds:build_config.bzl\", \"tf_profiler_copts\")\n+\n+# copybara:uncomment package(default_applicable_licenses = [\"//tensorflow:license\"])\n+\n+cc_library(\n+    name = \"ondevice_trace_event\",\n+    hdrs = [\"ondevice_trace_event.h\"],\n+    copts = tf_profiler_copts(),\n+    visibility = internal_visibility([\n+        \"//xla/tsl/profiler:internal\",\n+        \"//xla/tsl/profiler:xla_profiler_backends\",\n+        \"//tensorflow/lite:__pkg__\",\n+    ]),\n+    deps = [\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"ondevice_event_collector\",\n+    hdrs = [\"ondevice_event_collector.h\"],\n+    copts = tf_profiler_copts(),\n+    visibility = internal_visibility([\n+        \"//xla/tsl/profiler:internal\",\n+        \"//xla/tsl/profiler:xla_profiler_backends\",\n+        \"//tensorflow/lite:__pkg__\",\n+    ]),\n+    deps = [\n+        \":ondevice_trace_event\",\n+        \"@com_google_absl//absl/status\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"ondevice_event_receiver\",\n+    srcs = [\"ondevice_event_receiver.cc\"],\n+    hdrs = [\"ondevice_event_receiver.h\"],\n+    copts = tf_profiler_copts(),\n+    visibility = internal_visibility([\n+        \"//xla/tsl/profiler:internal\",\n+        \"//xla/tsl/profiler:xla_profiler_backends\",\n+        \"//tensorflow/lite:__pkg__\",\n+    ]),\n+    deps = [\n+        \":ondevice_event_collector\",\n+        \":ondevice_trace_event\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/synchronization\",\n+    ],\n+)"
        },
        {
            "sha": "39972fdade5e604619650d4ab8ecb8c141658094",
            "filename": "third_party/xla/xla/tsl/profiler/backends/gpu/ondevice_event_collector.h",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_collector.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_collector.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_collector.h?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,36 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_EVENT_COLLECTOR_H_\n+#define XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_EVENT_COLLECTOR_H_\n+\n+#include \"absl/status/status.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_trace_event.h\"\n+\n+namespace tsl {\n+namespace profiler {\n+\n+// This is the interface for the the on-device event receiver to inject event.\n+class GpuOnDeviceTraceEventCollector {\n+ public:\n+  virtual ~GpuOnDeviceTraceEventCollector() = default;\n+\n+  virtual absl::Status AddEvent(GpuOnDeviceTraceEvent&& event) = 0;\n+};\n+\n+}  // namespace profiler\n+}  // namespace tsl\n+\n+#endif  // XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_EVENT_COLLECTOR_H_"
        },
        {
            "sha": "7236c25e2a313675e6171399c630d11941a51707",
            "filename": "third_party/xla/xla/tsl/profiler/backends/gpu/ondevice_event_receiver.cc",
            "status": "added",
            "additions": 100,
            "deletions": 0,
            "changes": 100,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_receiver.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_receiver.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_receiver.cc?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,100 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_event_receiver.h\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_event_collector.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_trace_event.h\"\n+\n+namespace tsl {\n+namespace profiler {\n+\n+GpuOnDeviceTraceEventReceiver* GpuOnDeviceTraceEventReceiver::GetSingleton() {\n+  static GpuOnDeviceTraceEventReceiver* receiver =\n+      new GpuOnDeviceTraceEventReceiver();\n+  return receiver;\n+}\n+\n+size_t GpuOnDeviceTraceEventReceiver::ActiveVersion() {\n+  absl::MutexLock lock(&mutex_);\n+  return (collector_ != nullptr) ? version_ : 0;\n+}\n+\n+absl::Status GpuOnDeviceTraceEventReceiver::Inject(\n+    size_t version, GpuOnDeviceTraceEvent&& event) {\n+  absl::MutexLock lock(&mutex_);\n+  if (collector_ != nullptr && version == version_) {\n+    if (event.injection_instance_id > current_injection_id_ ||\n+        event.injection_instance_id <= 0) {\n+      return absl::InternalError(\"Injection instance id is out of range.\");\n+    }\n+    return collector_->AddEvent(std::move(event));\n+  }\n+  return collector_ == nullptr\n+             ? absl::InternalError(\"Can not inject to nullptr collector.\")\n+             : absl::InternalError(\"Inject with mismatched version!\");\n+}\n+\n+absl::StatusOr<size_t> GpuOnDeviceTraceEventReceiver::StartWith(\n+    GpuOnDeviceTraceEventCollector* collector, int32_t max_injection_instance) {\n+  if (collector == nullptr) {\n+    return absl::InternalError(\"Can not bind nullptr collector.\");\n+  }\n+  if (max_injection_instance <= 0) {\n+    return absl::InternalError(\"Max injection instance must be positive.\");\n+  }\n+  absl::MutexLock lock(&mutex_);\n+  if (collector_ != nullptr && collector_ != collector) {\n+    return absl::InternalError(\n+        \"GpuOnDeviceTraceEventReceiver already bind with another collector.\");\n+  }\n+  if (collector_ == nullptr) {\n+    version_++;\n+    current_injection_id_ = 0;\n+    collector_ = collector;\n+    max_injection_instance_ = max_injection_instance;\n+  }\n+  return version_;\n+}\n+\n+// Return and increment the injection instance id if successful.\n+int32_t GpuOnDeviceTraceEventReceiver::StartInjectionInstance(size_t version) {\n+  absl::MutexLock lock(&mutex_);\n+  if (collector_ == nullptr || version != version_ ||\n+      current_injection_id_ >= max_injection_instance_) {\n+    return 0;\n+  }\n+  return ++current_injection_id_;\n+}\n+\n+absl::Status GpuOnDeviceTraceEventReceiver::Stop() {\n+  absl::MutexLock lock(&mutex_);\n+  if (collector_ != nullptr) {\n+    collector_ = nullptr;\n+    version_++;\n+  }\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace profiler\n+}  // namespace tsl"
        },
        {
            "sha": "3f3440d9e1c5cd2c464cda777fd4ab62c9a7b49d",
            "filename": "third_party/xla/xla/tsl/profiler/backends/gpu/ondevice_event_receiver.h",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_receiver.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_receiver.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_event_receiver.h?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,84 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_EVENT_RECEIVER_H_\n+#define XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_EVENT_RECEIVER_H_\n+\n+#include <cstddef>\n+#include <cstdint>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_event_collector.h\"\n+#include \"xla/tsl/profiler/backends/gpu/ondevice_trace_event.h\"\n+\n+namespace tsl {\n+namespace profiler {\n+\n+//     GpuOnDeviceTraceEventReceiver is a singleton class that receives\n+// GpuOnDeviceTraceEvent(s). Parallel threads may postprocess hardware event\n+// buffer (may be dumped into host memory) and inject those software generated\n+// event(s) to this Receiver. It will be global available to users by its APIs,\n+// or Python bindings, to a) check if it is active (in some profiling session);\n+// b) inject events that user software generated.\n+//     Upon receiving the event(s), the receiver will forward the event(s) to\n+// the collector (if not nullptr) of type GpuOnDeviceTraceEventCollector.\n+// The Collector registers itself to this receiver by calling StartWith(), so\n+// that it could receive the event(s) from the receiver upon user injection.\n+//     Note that the collector could be wrapped by a profiler which follows\n+// profiler api, so that it will be created together with other profilers\n+// at the beginning of a session, and be destroyed at the end of the session.\n+class GpuOnDeviceTraceEventReceiver final {\n+ public:\n+  static GpuOnDeviceTraceEventReceiver* GetSingleton();\n+\n+  // Returns non-zero version number if the there has a collector bound\n+  // to this receiver. Otherwise, returns zero. A version number is uniquely\n+  // assigned to each collector when it is bound to this receiver in the\n+  // StartWith() call.\n+  size_t ActiveVersion();\n+\n+  // Return and increment the injection instance id if the version matches.\n+  int32_t StartInjectionInstance(size_t version);\n+\n+  absl::Status Inject(size_t version, GpuOnDeviceTraceEvent&& event);\n+\n+  // Return active version number if collector is successfully bound to this\n+  // receiver. Otherwise, error status. The max_injection_instance is the\n+  // maximum number of injection instances that the collector can handle.\n+  absl::StatusOr<size_t> StartWith(GpuOnDeviceTraceEventCollector* collector,\n+                                   int32_t max_injection_instance);\n+\n+  absl::Status Stop();\n+\n+ private:\n+  GpuOnDeviceTraceEventReceiver() = default;\n+  GpuOnDeviceTraceEventReceiver(const GpuOnDeviceTraceEventReceiver&) = delete;\n+  GpuOnDeviceTraceEventReceiver& operator=(\n+      const GpuOnDeviceTraceEventReceiver&) = delete;\n+\n+  absl::Mutex mutex_;\n+  int32_t max_injection_instance_ ABSL_GUARDED_BY(mutex_) = 0;\n+  uint32_t current_injection_id_ ABSL_GUARDED_BY(mutex_) = 0;\n+  size_t version_ ABSL_GUARDED_BY(mutex_) = 0;\n+  GpuOnDeviceTraceEventCollector* collector_ ABSL_GUARDED_BY(mutex_) = nullptr;\n+};\n+\n+}  // namespace profiler\n+}  // namespace tsl\n+\n+#endif  // XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_EVENT_RECEIVER_H_"
        },
        {
            "sha": "274a6fc5a57eee32b174ae8351df17cfcd0eb57b",
            "filename": "third_party/xla/xla/tsl/profiler/backends/gpu/ondevice_trace_event.h",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_trace_event.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_trace_event.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Fbackends%2Fgpu%2Fondevice_trace_event.h?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -0,0 +1,40 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_TRACE_EVENT_H_\n+#define XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_TRACE_EVENT_H_\n+\n+#include <cstdint>\n+\n+#include \"absl/strings/string_view.h\"\n+\n+namespace tsl {\n+namespace profiler {\n+\n+struct GpuOnDeviceTraceEvent {\n+  // One injection instance mapping to a single kernel execution.\n+  int32_t injection_instance_id = 0;\n+  absl::string_view tag_name = \"\";\n+  uint32_t tag_id = 0;\n+  uint32_t pid = 0;\n+  uint32_t tid = 0;\n+  int64_t start_time_ns = 0;\n+  int64_t duration_ps = 0;\n+};\n+\n+}  // namespace profiler\n+}  // namespace tsl\n+\n+#endif  // XLA_TSL_PROFILER_BACKENDS_GPU_ONDEVICE_TRACE_EVENT_H_"
        },
        {
            "sha": "3dec1f5d3750fd97bfa8f668736251f20fddac4e",
            "filename": "third_party/xla/xla/tsl/profiler/utils/trace_utils.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Ftrace_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Ftrace_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Ftrace_utils.h?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -47,6 +47,12 @@ constexpr uint32 kFirstNcclPlaneId =\n     tsl::profiler::kMaxCustomPlaneDevicesPerHost - kMaxNcclPlanes;\n constexpr uint32 kLastNcclPlaneId = kFirstNcclPlaneId + kMaxNcclPlanes - 1;\n \n+constexpr int kNumGpuOnDeviceCustomPlanesPerHost = 50;\n+constexpr int kFirstGpuOnDeviceCustomPlaneId =\n+    kFirstNcclPlaneId - kNumGpuOnDeviceCustomPlanesPerHost;\n+constexpr int kLastGpuOnDeviceCustomPlaneId =\n+    kFirstGpuOnDeviceCustomPlaneId + kNumGpuOnDeviceCustomPlanesPerHost - 1;\n+\n // Constants used as trace_viewer TID (resource_id in trace_events.proto).\n constexpr int kThreadIdDerivedMin = 0xdeadbeef;\n constexpr int kThreadIdStepInfo = kThreadIdDerivedMin;"
        },
        {
            "sha": "e5a67e33471efa8798838e8c6f6fbdd66fb0c87a",
            "filename": "third_party/xla/xla/tsl/profiler/utils/xplane_schema.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.cc?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -37,6 +37,8 @@ const char kSparseCorePlaneRegex[] = {\n // TODO(b/195582092): change it to /device:custom once all literals are\n // migrated.\n const absl::string_view kCustomPlanePrefix = \"/device:CUSTOM:\";\n+const absl::string_view kCustomGpuOnDeviceTracePlanePrefix =\n+    \"/device:CUSTOM:MOSAIC:\";  // /device:CUSTOM:MOSAIC:INSTANCE_ID\n \n const absl::string_view kScopeRangeIdTreePlaneName =\n     \"/host:__ScopeRangeCallStack__\";"
        },
        {
            "sha": "ee59bf16b1413cee165b046fb41ba5dd28522d98",
            "filename": "third_party/xla/xla/tsl/profiler/utils/xplane_schema.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.h?ref=cf02560f6c3d88a9121b69cf7c4b832aad5cc8e0",
            "patch": "@@ -66,6 +66,8 @@ TF_CONST_INIT extern const absl::string_view kHostCpusPlaneName;\n TF_CONST_INIT extern const absl::string_view kSyscallsPlaneName;\n // Name of XPlane that contains namescope stack tree.\n TF_CONST_INIT extern const absl::string_view kScopeRangeIdTreePlaneName;\n+// Name prefix of XPlane that contains GPU on-device events.\n+TF_CONST_INIT extern const absl::string_view kCustomGpuOnDeviceTracePlanePrefix;\n \n // Names of XLines that contain ML-level events.\n TF_CONST_INIT extern const absl::string_view kStepLineName;\n@@ -429,6 +431,10 @@ inline std::string GpuPlaneName(int32_t device_ordinal) {\n   return absl::StrCat(kGpuPlanePrefix, device_ordinal);\n }\n \n+inline std::string GpuOnDeviceTracePlaneName(int32_t instance_id) {\n+  return absl::StrCat(kCustomGpuOnDeviceTracePlanePrefix, instance_id);\n+}\n+\n absl::string_view GetHostEventTypeStr(HostEventType event_type);\n \n bool IsHostEventType(HostEventType event_type, absl::string_view event_name);"
        }
    ],
    "stats": {
        "total": 767,
        "additions": 767,
        "deletions": 0
    }
}