{
    "author": "tensorflower-gardener",
    "message": "Refactor SymbolicExpr creation to use free functions with MLIRContext\n\nThis change introduces free functions like `CreateSymbolicConstant`, `CreateSymbolicVariable`, and `CreateSymbolicBinaryOp` that directly accept an `mlir::MLIRContext*`. The `SymbolicExprContext` class is now deprecated, and its methods are refactored to call these new free functions. The internal `SymbolicExprStorage` now holds a pointer to `mlir::MLIRContext`. I left the SymbolicExprContext for now until all the refactor is done.\n\nPiperOrigin-RevId: 833305709",
    "sha": "7a2bbf276349f880f5cb750ca2b5378ba294020a",
    "files": [
        {
            "sha": "f9d92cffa731724d003dd56f06c8059987e82888",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr.cc",
            "status": "modified",
            "additions": 142,
            "deletions": 84,
            "changes": 226,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7a2bbf276349f880f5cb750ca2b5378ba294020a/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7a2bbf276349f880f5cb750ca2b5378ba294020a/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc?ref=7a2bbf276349f880f5cb750ca2b5378ba294020a",
            "patch": "@@ -73,7 +73,7 @@ std::string GetBinaryOpString(SymbolicExprType type) {\n // Helper class to manage the state of the parser.\n class Parser {\n  public:\n-  Parser(absl::string_view str, SymbolicExprContext* context)\n+  Parser(absl::string_view str, mlir::MLIRContext* context)\n       : remaining_str_(str), context_(context) {}\n \n   SymbolicExpr Parse() {\n@@ -107,8 +107,8 @@ class Parser {\n     while (true) {\n       SkipWhitespace();\n       if (absl::ConsumePrefix(&remaining_str_, \"+\")) {\n-        lhs =\n-            context_->CreateBinaryOp(SymbolicExprType::kAdd, lhs, ParseTerm());\n+        lhs = CreateSymbolicBinaryOp(SymbolicExprType::kAdd, lhs, ParseTerm(),\n+                                     context_);\n       } else {\n         break;\n       }\n@@ -122,14 +122,14 @@ class Parser {\n     while (true) {\n       SkipWhitespace();\n       if (absl::ConsumePrefix(&remaining_str_, \"*\")) {\n-        lhs = context_->CreateBinaryOp(SymbolicExprType::kMul, lhs,\n-                                       ParseFactor());\n+        lhs = CreateSymbolicBinaryOp(SymbolicExprType::kMul, lhs, ParseFactor(),\n+                                     context_);\n       } else if (absl::ConsumePrefix(&remaining_str_, \"floordiv\")) {\n-        lhs = context_->CreateBinaryOp(SymbolicExprType::kFloorDiv, lhs,\n-                                       ParseFactor());\n+        lhs = CreateSymbolicBinaryOp(SymbolicExprType::kFloorDiv, lhs,\n+                                     ParseFactor(), context_);\n       } else if (absl::ConsumePrefix(&remaining_str_, \"ceildiv\")) {\n-        lhs = context_->CreateBinaryOp(SymbolicExprType::kCeilDiv, lhs,\n-                                       ParseFactor());\n+        lhs = CreateSymbolicBinaryOp(SymbolicExprType::kCeilDiv, lhs,\n+                                     ParseFactor(), context_);\n       } else {\n         break;\n       }\n@@ -152,7 +152,7 @@ class Parser {\n     SkipWhitespace();\n     CHECK(absl::ConsumePrefix(&remaining_str_, \")\"))\n         << \"Missing ')' in \" << func_name << \"()\";\n-    return context_->CreateBinaryOp(type, lhs, rhs);\n+    return CreateSymbolicBinaryOp(type, lhs, rhs, context_);\n   }\n \n   // Handles highest precedence items: numbers, variables, and functions.\n@@ -178,21 +178,21 @@ class Parser {\n     if (absl::ConsumePrefix(&remaining_str_, \"v\")) {\n       std::string error_msg = \"Invalid variable format\";\n       int64_t var_id = ParseNumber(error_msg);\n-      return context_->CreateVariable(var_id);\n+      return CreateSymbolicVariable(var_id, context_);\n     }\n     // Case 4: Number\n     std::string error_msg =\n         absl::StrCat(\"Failed to parse expression: \\\"\", remaining_str_, \"\\\"\");\n     int64_t val = ParseNumber(error_msg);\n-    return context_->CreateConstant(val);\n+    return CreateSymbolicConstant(val, context_);\n   }\n \n   void SkipWhitespace() {\n     remaining_str_ = absl::StripLeadingAsciiWhitespace(remaining_str_);\n   }\n \n   absl::string_view remaining_str_;\n-  SymbolicExprContext* context_;\n+  mlir::MLIRContext* context_;\n };\n \n // Returns {BASE, COEFF}, where expr is equivalent to BASE * COEFF.\n@@ -231,13 +231,15 @@ SymbolicExpr BasicAddSimplify(SymbolicExpr lhs, SymbolicExpr rhs) {\n   }\n   if (lhs.GetType() == SymbolicExprType::kConstant &&\n       rhs.GetType() == SymbolicExprType::kConstant) {\n-    return lhs.GetContext()->CreateConstant(lhs.GetValue() + rhs.GetValue());\n+    return CreateSymbolicConstant(lhs.GetValue() + rhs.GetValue(),\n+                                  lhs.GetContext());\n   }\n-  return lhs.GetContext()->CreateBinaryOp(SymbolicExprType::kAdd, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kAdd, lhs, rhs,\n+                                lhs.GetContext());\n }\n \n SymbolicExpr CanonicalizeAdd(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   // Flattening and term collection\n   llvm::SmallVector<std::pair<SymbolicExpr, int64_t>> terms;\n@@ -272,17 +274,18 @@ SymbolicExpr CanonicalizeAdd(SymbolicExpr lhs, SymbolicExpr rhs) {\n \n   // Add the combined constant term as an expression\n   if (const_val != 0) {\n-    exprs.push_back(ctx->CreateConstant(const_val));\n+    exprs.push_back(CreateSymbolicConstant(const_val, ctx));\n   }\n   if (exprs.empty()) {\n-    return ctx->CreateConstant(0);\n+    return CreateSymbolicConstant(0, ctx);\n   }\n   // Sort all terms, including the constant\n   absl::c_sort(exprs);\n \n   SymbolicExpr result = exprs[0];\n   for (size_t i = 1; i < exprs.size(); ++i) {\n-    result = ctx->CreateBinaryOp(SymbolicExprType::kAdd, result, exprs[i]);\n+    result =\n+        CreateSymbolicBinaryOp(SymbolicExprType::kAdd, result, exprs[i], ctx);\n   }\n   return result;\n }\n@@ -293,7 +296,7 @@ SymbolicExpr SimplifyMulByConstantRHS(SymbolicExpr lhs, SymbolicExpr rhs) {\n     return SymbolicExpr();\n   }\n   int64_t rhs_val = rhs.GetValue();\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   if (rhs_val == 0) {\n     return rhs;  // x * 0 = 0\n@@ -302,21 +305,21 @@ SymbolicExpr SimplifyMulByConstantRHS(SymbolicExpr lhs, SymbolicExpr rhs) {\n     return lhs;  // x * 1 = x\n   }\n   if (lhs.GetType() == SymbolicExprType::kConstant) {\n-    return ctx->CreateConstant(lhs.GetValue() * rhs_val);\n+    return CreateSymbolicConstant(lhs.GetValue() * rhs_val, ctx);\n   }\n \n   // Associativity: (X * C1) * C2 => X * (C1 * C2)\n   if (lhs.GetType() == SymbolicExprType::kMul &&\n       lhs.GetRHS().GetType() == SymbolicExprType::kConstant) {\n-    return ctx->CreateBinaryOp(\n+    return CreateSymbolicBinaryOp(\n         SymbolicExprType::kMul, lhs.GetLHS(),\n-        ctx->CreateConstant(lhs.GetRHS().GetValue() * rhs_val));\n+        CreateSymbolicConstant(lhs.GetRHS().GetValue() * rhs_val, ctx), ctx);\n   }\n   return SymbolicExpr();\n }\n \n SymbolicExpr BasicMulSimplify(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   // Try constant folding, neutral element simplification, and associativity.\n   if (rhs.GetType() == SymbolicExprType::kConstant) {\n@@ -331,11 +334,11 @@ SymbolicExpr BasicMulSimplify(SymbolicExpr lhs, SymbolicExpr rhs) {\n     }\n   }\n \n-  return ctx->CreateBinaryOp(SymbolicExprType::kMul, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMul, lhs, rhs, ctx);\n }\n \n SymbolicExpr CanonicalizeMul(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   if (rhs.GetType() == SymbolicExprType::kConstant) {\n     // Try constant folding, neutral element simplification, and associativity.\n@@ -357,7 +360,7 @@ SymbolicExpr CanonicalizeMul(SymbolicExpr lhs, SymbolicExpr rhs) {\n     return ((lhs * rhs.GetLHS()) + (lhs * rhs.GetRHS())).Canonicalize();\n   }\n \n-  return ctx->CreateBinaryOp(SymbolicExprType::kMul, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMul, lhs, rhs, ctx);\n }\n \n std::optional<int64_t> SubtractAndGetConstDiff(SymbolicExpr lhs,\n@@ -370,21 +373,21 @@ std::optional<int64_t> SubtractAndGetConstDiff(SymbolicExpr lhs,\n }\n \n SymbolicExpr CanonicalizeMin(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n   if (auto diff = SubtractAndGetConstDiff(lhs, rhs)) {  // min(X, X + k) = X\n     return (diff.value() <= 0) ? lhs : rhs;\n   }\n \n-  return ctx->CreateBinaryOp(SymbolicExprType::kMin, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMin, lhs, rhs, ctx);\n }\n \n SymbolicExpr CanonicalizeMax(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n   if (auto diff = SubtractAndGetConstDiff(lhs, rhs)) {  // max(X, X + k) = X + k\n     return (diff.value() >= 0) ? lhs : rhs;\n   }\n \n-  return ctx->CreateBinaryOp(SymbolicExprType::kMax, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMax, lhs, rhs, ctx);\n }\n \n // Helper function to simplify (A * C1) op C2 using GCD.\n@@ -443,7 +446,7 @@ SymbolicExpr SimplifyFloorDivAddOperand(SymbolicExpr a, SymbolicExpr b,\n     remaining_expr = a.GetLHS();\n   } else if (a.GetType() == SymbolicExprType::kConstant) {\n     a_coeff = a.GetValue();\n-    remaining_expr = a.GetContext()->CreateConstant(1);\n+    remaining_expr = CreateSymbolicConstant(1, a.GetContext());\n   } else {\n     return SymbolicExpr();  // Cannot simplify\n   }\n@@ -455,7 +458,7 @@ SymbolicExpr SimplifyFloorDivAddOperand(SymbolicExpr a, SymbolicExpr b,\n }\n \n SymbolicExpr CanonicalizeFloorDiv(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n     return lhs;  // 0 floordiv X => 0\n@@ -493,11 +496,11 @@ SymbolicExpr CanonicalizeFloorDiv(SymbolicExpr lhs, SymbolicExpr rhs) {\n     }\n   }\n \n-  return ctx->CreateBinaryOp(SymbolicExprType::kFloorDiv, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kFloorDiv, lhs, rhs, ctx);\n }\n \n SymbolicExpr CanonicalizeCeilDiv(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n     return lhs;  // 0 ceildiv X => 0\n@@ -525,18 +528,18 @@ SymbolicExpr CanonicalizeCeilDiv(SymbolicExpr lhs, SymbolicExpr rhs) {\n     return (-(lhs.floorDiv(-divisor))).Canonicalize();\n   }\n \n-  return ctx->CreateBinaryOp(SymbolicExprType::kCeilDiv, lhs, rhs);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kCeilDiv, lhs, rhs, ctx);\n }\n \n SymbolicExpr CanonicalizeMod(SymbolicExpr lhs, SymbolicExpr rhs) {\n-  SymbolicExprContext* ctx = lhs.GetContext();\n+  mlir::MLIRContext* ctx = lhs.GetContext();\n \n   if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n     return lhs;  // 0 mod X => 0\n   }\n \n   if (lhs == rhs) {\n-    return ctx->CreateConstant(0);  // X mod X => 0\n+    return CreateSymbolicConstant(0, ctx);  // X mod X => 0\n   }\n \n   if (rhs.GetType() == SymbolicExprType::kConstant) {\n@@ -594,12 +597,16 @@ class SymbolicExprStorage : public mlir::StorageUniquer::BaseStorage {\n \n  protected:\n   friend class SymbolicExpr;\n-  friend class SymbolicExprContext;\n+  friend SymbolicExpr GetOrCreateSymbolicExpr(SymbolicExprType type,\n+                                              int64_t value, SymbolicExpr lhs,\n+                                              SymbolicExpr rhs,\n+                                              mlir::MLIRContext* mlir_context);\n+\n   SymbolicExprType type_;\n   int64_t value_ = 0;\n   SymbolicExpr lhs_;\n   SymbolicExpr rhs_;\n-  SymbolicExprContext* ctx_ = nullptr;\n+  mlir::MLIRContext* mlir_context_ = nullptr;\n \n  private:\n   SymbolicExprStorage(SymbolicExprType type, int64_t value)\n@@ -608,7 +615,9 @@ class SymbolicExprStorage : public mlir::StorageUniquer::BaseStorage {\n       : type_(type), lhs_(lhs), rhs_(rhs) {}\n };\n \n-SymbolicExprContext* SymbolicExpr::GetContext() const { return impl_->ctx_; }\n+mlir::MLIRContext* SymbolicExpr::GetContext() const {\n+  return impl_->mlir_context_;\n+}\n \n SymbolicExprType SymbolicExpr::GetType() const { return impl_->type_; }\n \n@@ -730,7 +739,7 @@ int64_t SymbolicExpr::Evaluate(\n \n SymbolicExpr SymbolicExpr::ReplaceVariables(\n     absl::Span<const SymbolicExpr> substitutions) const {\n-  SymbolicExprContext* ctx = GetContext();\n+  mlir::MLIRContext* ctx = GetContext();\n   switch (GetType()) {\n     case SymbolicExprType::kConstant:\n       return *this;\n@@ -754,7 +763,7 @@ SymbolicExpr SymbolicExpr::ReplaceVariables(\n       if (new_lhs == GetLHS() && new_rhs == GetRHS()) {\n         return *this;\n       }\n-      return ctx->CreateBinaryOp(GetType(), new_lhs, new_rhs);\n+      return CreateSymbolicBinaryOp(GetType(), new_lhs, new_rhs, ctx);\n     }\n     default:\n       LOG(FATAL) << \"Substitute not implemented for this type.\";\n@@ -772,8 +781,9 @@ SymbolicExpr SymbolicExpr::ReplaceDimsAndSymbols(\n     int64_t num_dims) const {\n   llvm::SmallVector<SymbolicExpr> replacements;\n   replacements.append(dim_replacements.begin(), dim_replacements.end());\n+  mlir::MLIRContext* ctx = GetContext();\n   for (int64_t i = dim_replacements.size(); i < num_dims; ++i) {\n-    replacements.push_back(GetContext()->CreateVariable(i));\n+    replacements.push_back(CreateSymbolicVariable(i, ctx));\n   }\n   replacements.append(symbol_replacements.begin(), symbol_replacements.end());\n   return ReplaceVariables(replacements);\n@@ -806,7 +816,7 @@ SymbolicExpr SymbolicExpr::Replace(\n   if (new_lhs == lhs && new_rhs == rhs) {\n     return *this;\n   }\n-  return GetContext()->CreateBinaryOp(type, new_lhs, new_rhs);\n+  return CreateSymbolicBinaryOp(type, new_lhs, new_rhs, GetContext());\n }\n \n void SymbolicExpr::GetUsedVariables(\n@@ -850,9 +860,10 @@ SymbolicExpr SymbolicExpr::Canonicalize() const {\n   // If both sides are constants, we can evaluate the expression.\n   if (lhs.GetType() == SymbolicExprType::kConstant &&\n       rhs.GetType() == SymbolicExprType::kConstant) {\n-    return GetContext()->CreateConstant(\n-        SymbolicExpr(GetContext()->CreateBinaryOp(type, lhs, rhs))\n-            .Evaluate({}));\n+    return CreateSymbolicConstant(\n+        SymbolicExpr(CreateSymbolicBinaryOp(type, lhs, rhs, GetContext()))\n+            .Evaluate({}),\n+        GetContext());\n   }\n \n   // Assure constants are on the RHS for commutative operations.\n@@ -890,7 +901,7 @@ SymbolicExpr SymbolicExpr::Canonicalize() const {\n }\n \n SymbolicExpr SymbolicExpr::operator+(int64_t v) const {\n-  return *this + GetContext()->CreateConstant(v);\n+  return *this + CreateSymbolicConstant(v, GetContext());\n }\n SymbolicExpr SymbolicExpr::operator+(SymbolicExpr other) const {\n   // TODO(b/433693782): We should use our own canonicalization here instead of\n@@ -899,15 +910,15 @@ SymbolicExpr SymbolicExpr::operator+(SymbolicExpr other) const {\n }\n \n SymbolicExpr SymbolicExpr::operator-() const {\n-  return (*this * GetContext()->CreateConstant(-1)).Canonicalize();\n+  return (*this * CreateSymbolicConstant(-1, GetContext())).Canonicalize();\n }\n SymbolicExpr SymbolicExpr::operator-(int64_t v) const { return *this + (-v); }\n SymbolicExpr SymbolicExpr::operator-(SymbolicExpr other) const {\n   return *this + (-other);\n }\n \n SymbolicExpr SymbolicExpr::operator*(int64_t v) const {\n-  return *this * GetContext()->CreateConstant(v);\n+  return *this * CreateSymbolicConstant(v, GetContext());\n }\n SymbolicExpr SymbolicExpr::operator*(SymbolicExpr other) const {\n   // TODO(b/433693782): We should use our own canonicalization here instead of\n@@ -916,89 +927,136 @@ SymbolicExpr SymbolicExpr::operator*(SymbolicExpr other) const {\n }\n \n SymbolicExpr SymbolicExpr::operator%(int64_t v) const {\n-  return this->operator%(GetContext()->CreateConstant(v));\n+  return this->operator%(CreateSymbolicConstant(v, GetContext()));\n }\n SymbolicExpr SymbolicExpr::operator%(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kMod, *this, other);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMod, *this, other,\n+                                GetContext());\n }\n \n SymbolicExpr SymbolicExpr::floorDiv(int64_t v) const {\n-  return this->floorDiv(GetContext()->CreateConstant(v));\n+  return this->floorDiv(CreateSymbolicConstant(v, GetContext()));\n }\n SymbolicExpr SymbolicExpr::floorDiv(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kFloorDiv, *this,\n-                                      other);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kFloorDiv, *this, other,\n+                                GetContext());\n }\n \n SymbolicExpr SymbolicExpr::ceilDiv(int64_t v) const {\n-  return this->ceilDiv(GetContext()->CreateConstant(v));\n+  return this->ceilDiv(CreateSymbolicConstant(v, GetContext()));\n }\n SymbolicExpr SymbolicExpr::ceilDiv(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kCeilDiv, *this, other);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kCeilDiv, *this, other,\n+                                GetContext());\n }\n \n SymbolicExpr SymbolicExpr::min(int64_t v) const {\n-  return this->min(GetContext()->CreateConstant(v));\n+  return this->min(CreateSymbolicConstant(v, GetContext()));\n }\n SymbolicExpr SymbolicExpr::min(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kMin, *this, other);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMin, *this, other,\n+                                GetContext());\n }\n \n SymbolicExpr SymbolicExpr::max(int64_t v) const {\n-  return this->max(GetContext()->CreateConstant(v));\n+  return this->max(CreateSymbolicConstant(v, GetContext()));\n }\n SymbolicExpr SymbolicExpr::max(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kMax, *this, other);\n+  return CreateSymbolicBinaryOp(SymbolicExprType::kMax, *this, other,\n+                                GetContext());\n }\n \n static absl::Mutex& getSymbolicExprStorageMutex() {\n   static absl::Mutex m(absl::kConstInit);\n   return m;\n }\n \n-SymbolicExprContext::SymbolicExprContext(mlir::MLIRContext* mlir_context)\n-    : mlir_context_(mlir_context) {\n+void RegisterSymbolicExprStorage(mlir::MLIRContext* mlir_context) {\n   CHECK(mlir_context != nullptr);\n-  absl::MutexLock lock(getSymbolicExprStorageMutex());\n-  auto* uniquer = &mlir_context_->getAffineUniquer();\n-  if (!uniquer->isParametricStorageInitialized(\n-          mlir::TypeID::get<SymbolicExprStorage>())) {\n-    uniquer->registerParametricStorageType<SymbolicExprStorage>();\n+  auto* uniquer = &mlir_context->getAffineUniquer();\n+  {\n+    absl::MutexLock lock(getSymbolicExprStorageMutex());\n+    if (!uniquer->isParametricStorageInitialized(\n+            mlir::TypeID::get<SymbolicExprStorage>())) {\n+      uniquer->registerParametricStorageType<SymbolicExprStorage>();\n+    }\n+  }\n+}\n+\n+SymbolicExpr GetOrCreateSymbolicExpr(SymbolicExprType type, int64_t value,\n+                                     SymbolicExpr lhs, SymbolicExpr rhs,\n+                                     mlir::MLIRContext* mlir_context) {\n+  // TODO(b/433696544): This might be too expensive to call per expression.\n+  // We should consider calling this once per MLIRContext creation.\n+  RegisterSymbolicExprStorage(mlir_context);\n+  auto* uniquer = &mlir_context->getAffineUniquer();\n+  auto initContext = [&](SymbolicExprStorage* storage) {\n+    storage->mlir_context_ = mlir_context;\n+  };\n+  return uniquer->get<SymbolicExprStorage>(initContext, type, value, lhs, rhs);\n+}\n+\n+SymbolicExpr CreateSymbolicConstant(int64_t value,\n+                                    mlir::MLIRContext* mlir_context) {\n+  return GetOrCreateSymbolicExpr(SymbolicExprType::kConstant, value,\n+                                 SymbolicExpr(), SymbolicExpr(), mlir_context);\n+}\n+\n+SymbolicExpr CreateSymbolicVariable(int64_t var_id,\n+                                    mlir::MLIRContext* mlir_context) {\n+  return GetOrCreateSymbolicExpr(SymbolicExprType::kVariable, var_id,\n+                                 SymbolicExpr(), SymbolicExpr(), mlir_context);\n+}\n+\n+SymbolicExpr CreateSymbolicBinaryOp(SymbolicExprType type, SymbolicExpr lhs,\n+                                    SymbolicExpr rhs,\n+                                    mlir::MLIRContext* mlir_context) {\n+  CHECK(type != SymbolicExprType::kConstant &&\n+        type != SymbolicExprType::kVariable && lhs && rhs)\n+      << \"We expect a binary operation and two symbolic expressions as \"\n+         \"children.\";\n+  return GetOrCreateSymbolicExpr(type, 0, lhs, rhs, mlir_context);\n+}\n+\n+llvm::SmallVector<SymbolicExpr> CreateSymbolicConstantExprs(\n+    llvm::ArrayRef<int64_t> constants, mlir::MLIRContext* context) {\n+  llvm::SmallVector<SymbolicExpr> exprs;\n+  exprs.reserve(constants.size());\n+  for (int64_t constant : constants) {\n+    exprs.push_back(CreateSymbolicConstant(constant, context));\n   }\n+  return exprs;\n+}\n+SymbolicExpr ParseSymbolicExpr(absl::string_view expr_str,\n+                               mlir::MLIRContext* mlir_context) {\n+  return Parser(expr_str, mlir_context).Parse();\n }\n \n+SymbolicExprContext::SymbolicExprContext(mlir::MLIRContext* mlir_context)\n+    : mlir_context_(mlir_context) {}\n+\n SymbolicExpr SymbolicExprContext::GetOrCreate(SymbolicExprType type,\n                                               int64_t value, SymbolicExpr lhs,\n                                               SymbolicExpr rhs) {\n-  auto initContext = [&](SymbolicExprStorage* storage) {\n-    storage->ctx_ = this;\n-  };\n-  return mlir_context_->getAffineUniquer().get<SymbolicExprStorage>(\n-      initContext, type, value, lhs, rhs);\n+  return GetOrCreateSymbolicExpr(type, value, lhs, rhs, mlir_context_);\n }\n \n SymbolicExpr SymbolicExprContext::CreateConstant(int64_t value) {\n-  return GetOrCreate(SymbolicExprType::kConstant, value, SymbolicExpr(),\n-                     SymbolicExpr());\n+  return CreateSymbolicConstant(value, mlir_context_);\n }\n \n SymbolicExpr SymbolicExprContext::CreateVariable(int64_t var_id) {\n-  return GetOrCreate(SymbolicExprType::kVariable, var_id, SymbolicExpr(),\n-                     SymbolicExpr());\n+  return CreateSymbolicVariable(var_id, mlir_context_);\n }\n \n SymbolicExpr SymbolicExprContext::CreateBinaryOp(SymbolicExprType type,\n                                                  SymbolicExpr lhs,\n                                                  SymbolicExpr rhs) {\n-  CHECK(type != SymbolicExprType::kConstant &&\n-        type != SymbolicExprType::kVariable && lhs && rhs)\n-      << \"We expect a binary operation and two symbolic expressions as \"\n-         \"children.\";\n-  return GetOrCreate(type, 0, lhs, rhs);\n+  return CreateSymbolicBinaryOp(type, lhs, rhs, mlir_context_);\n }\n \n SymbolicExpr SymbolicExprContext::Parse(absl::string_view expr_str) {\n-  return Parser(expr_str, this).Parse();\n+  return ParseSymbolicExpr(expr_str, mlir_context_);\n }\n \n bool SymbolicExprContext::operator==(const SymbolicExprContext& other) const {"
        },
        {
            "sha": "8aeb3d1b2d37f209403eee4f12ffce1b860525a9",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr.h",
            "status": "modified",
            "additions": 20,
            "deletions": 18,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7a2bbf276349f880f5cb750ca2b5378ba294020a/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7a2bbf276349f880f5cb750ca2b5378ba294020a/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.h?ref=7a2bbf276349f880f5cb750ca2b5378ba294020a",
            "patch": "@@ -63,7 +63,7 @@ class SymbolicExpr {\n   bool operator!=(SymbolicExpr other) const { return !(*this == other); }\n   bool operator<(const SymbolicExpr& other) const;\n \n-  SymbolicExprContext* GetContext() const;\n+  mlir::MLIRContext* GetContext() const;\n   SymbolicExprType GetType() const;\n   bool IsBinaryOp() const;\n   SymbolicExpr GetLHS() const;\n@@ -153,6 +153,25 @@ H AbslHashValue(H h, const SymbolicExpr& expr) {\n   return H::combine(std::move(h), hash_value(expr));\n }\n \n+// This method should be called once per MLIRContext to register the\n+// SymbolicExprStorage type with the MLIRContext's uniquifier. It should be\n+// called before any SymbolicExprs are created.\n+void RegisterSymbolicExprStorage(mlir::MLIRContext* mlir_context);\n+\n+// Free functions to create SymbolicExpr.\n+SymbolicExpr ParseSymbolicExpr(absl::string_view expr_str,\n+                               mlir::MLIRContext* mlir_context);\n+SymbolicExpr CreateSymbolicConstant(int64_t value,\n+                                    mlir::MLIRContext* mlir_context);\n+SymbolicExpr CreateSymbolicVariable(int64_t var_id,\n+                                    mlir::MLIRContext* mlir_context);\n+SymbolicExpr CreateSymbolicBinaryOp(SymbolicExprType type, SymbolicExpr lhs,\n+                                    SymbolicExpr rhs,\n+                                    mlir::MLIRContext* mlir_context);\n+llvm::SmallVector<SymbolicExpr> CreateSymbolicConstantExprs(\n+    llvm::ArrayRef<int64_t> constants, mlir::MLIRContext* mlir_context);\n+\n+// Deprecated. Use free functions taking mlir::MLIRContext* instead.\n class SymbolicExprContext {\n  public:\n   explicit SymbolicExprContext(mlir::MLIRContext* mlir_context);\n@@ -178,23 +197,6 @@ class SymbolicExprContext {\n   mlir::MLIRContext* mlir_context_;\n };\n \n-// Free function to create a constant SymbolicExpr.\n-inline SymbolicExpr GetSymbolicConstantExpr(int64_t constant,\n-                                            SymbolicExprContext* context) {\n-  return context->CreateConstant(constant);\n-}\n-\n-// Free function to create a vector of constant SymbolicExprs.\n-inline llvm::SmallVector<SymbolicExpr> GetSymbolicConstantExprs(\n-    llvm::ArrayRef<int64_t> constants, SymbolicExprContext* context) {\n-  llvm::SmallVector<SymbolicExpr> exprs;\n-  exprs.reserve(constants.size());\n-  for (int64_t constant : constants) {\n-    exprs.push_back(GetSymbolicConstantExpr(constant, context));\n-  }\n-  return exprs;\n-}\n-\n }  // namespace xla\n \n namespace llvm {"
        },
        {
            "sha": "4e8f01e94f9213a3a27907b62fd504258d341438",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 52,
            "deletions": 69,
            "changes": 121,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7a2bbf276349f880f5cb750ca2b5378ba294020a/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7a2bbf276349f880f5cb750ca2b5378ba294020a/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc?ref=7a2bbf276349f880f5cb750ca2b5378ba294020a",
            "patch": "@@ -36,11 +36,10 @@ using ::testing::Values;\n // Test fixture to hold the context for all tests.\n struct SymbolicExprTest : public ::testing::Test {\n  protected:\n-  mlir::MLIRContext mlir_context;\n-  SymbolicExprContext ctx{&mlir_context};\n-  SymbolicExpr v0 = ctx.CreateVariable(0);\n-  SymbolicExpr v1 = ctx.CreateVariable(1);\n-  SymbolicExpr c2 = ctx.CreateConstant(2);\n+  mlir::MLIRContext ctx;\n+  SymbolicExpr v0 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr v1 = CreateSymbolicVariable(1, &ctx);\n+  SymbolicExpr c2 = CreateSymbolicConstant(2, &ctx);\n };\n \n TEST_F(SymbolicExprTest, CreateAndPrint) {\n@@ -67,17 +66,20 @@ TEST_F(SymbolicExprTest, PrintWithDifferentNumDimensions) {\n TEST_F(SymbolicExprTest, ParseAndPrint) {\n   const std::string kStringContainingAllOperators =\n       \"((((v0 + 42) * max(min(v1, 2), 0)) floordiv 2) ceildiv 2)\";\n-  SymbolicExpr parsed_expr = ctx.Parse(kStringContainingAllOperators);\n+  SymbolicExpr parsed_expr =\n+      ParseSymbolicExpr(kStringContainingAllOperators, &ctx);\n   ASSERT_NE(parsed_expr, nullptr);\n   EXPECT_THAT(parsed_expr.ToString(),\n               MatchIndexingString(kStringContainingAllOperators));\n }\n \n TEST_F(SymbolicExprTest, ParseAndPrint_Invalid) {\n-  EXPECT_DEATH(ctx.Parse(\"1 + \"), \"Unexpected end of expression\");\n-  EXPECT_DEATH(ctx.Parse(\"max(1, )\"), \"Failed to parse expression\");\n-  EXPECT_DEATH(ctx.Parse(\"(1 + 2\"), \"Missing parenthesis\");\n-  EXPECT_DEATH(ctx.Parse(\"foo(3, 4)\"), \"Failed to parse expression\");\n+  EXPECT_DEATH(ParseSymbolicExpr(\"1 + \", &ctx), \"Unexpected end of expression\");\n+  EXPECT_DEATH(ParseSymbolicExpr(\"max(1, )\", &ctx),\n+               \"Failed to parse expression\");\n+  EXPECT_DEATH(ParseSymbolicExpr(\"(1 + 2\", &ctx), \"Missing parenthesis\");\n+  EXPECT_DEATH(ParseSymbolicExpr(\"foo(3, 4)\", &ctx),\n+               \"Failed to parse expression\");\n }\n \n TEST_F(SymbolicExprTest, Evaluate) {\n@@ -102,8 +104,8 @@ TEST_P(SymbolicExprEvaluateDivModTest, EvaluateDivMod) {\n   const auto& params = GetParam();\n   const int64_t numerator_val = std::get<0>(params);\n   const int64_t denominator_val = std::get<1>(params);\n-  SymbolicExpr numerator = ctx.CreateConstant(numerator_val);\n-  SymbolicExpr denominator = ctx.CreateConstant(denominator_val);\n+  SymbolicExpr numerator = CreateSymbolicConstant(numerator_val, &ctx);\n+  SymbolicExpr denominator = CreateSymbolicConstant(denominator_val, &ctx);\n \n   if (numerator_val % denominator_val == 0) {\n     EXPECT_EQ((numerator % denominator).Evaluate({}), 0);\n@@ -120,27 +122,28 @@ INSTANTIATE_TEST_SUITE_P(PositiveAndNegative, SymbolicExprEvaluateDivModTest,\n                          Combine(Values(5, -5, 4, -4), Values(2, -2)));\n \n TEST_F(SymbolicExprTest, ReplaceVariables) {\n-  SymbolicExpr expr_to_sub = ctx.Parse(\"(v0 + v1)\");\n-  std::vector<SymbolicExpr> substitutions{{}, ctx.Parse(\"(v2 * 10)\")};\n+  SymbolicExpr expr_to_sub = ParseSymbolicExpr(\"(v0 + v1)\", &ctx);\n+  std::vector<SymbolicExpr> substitutions{{},\n+                                          ParseSymbolicExpr(\"(v2 * 10)\", &ctx)};\n   SymbolicExpr result = expr_to_sub.ReplaceVariables(substitutions);\n   EXPECT_EQ(result.ToString(), \"(v0 + (v2 * 10))\");\n }\n \n TEST_F(SymbolicExprTest, ReplaceSymbols) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr s0 = ctx.CreateVariable(1);\n-  SymbolicExpr s1 = ctx.CreateVariable(2);\n-  SymbolicExpr c7 = ctx.CreateConstant(7);\n+  SymbolicExpr d0 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr s0 = CreateSymbolicVariable(1, &ctx);\n+  SymbolicExpr s1 = CreateSymbolicVariable(2, &ctx);\n+  SymbolicExpr c7 = CreateSymbolicConstant(7, &ctx);\n   SymbolicExpr expr_to_sub = (d0 + s0 * 2) * s1;\n   SymbolicExpr result = expr_to_sub.ReplaceSymbols({d0, c7}, /*num_dims=*/1);\n   EXPECT_EQ(result, ((d0 + (d0 * 2)) * c7));\n }\n \n TEST_F(SymbolicExprTest, ReplaceDimsAndSymbols) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr s0 = ctx.CreateVariable(1);\n-  SymbolicExpr s1 = ctx.CreateVariable(2);\n-  SymbolicExpr c7 = ctx.CreateConstant(7);\n+  SymbolicExpr d0 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr s0 = CreateSymbolicVariable(1, &ctx);\n+  SymbolicExpr s1 = CreateSymbolicVariable(2, &ctx);\n+  SymbolicExpr c7 = CreateSymbolicConstant(7, &ctx);\n   SymbolicExpr expr_to_sub = (d0 + s0 * 2) * s1;\n   SymbolicExpr result =\n       expr_to_sub.ReplaceDimsAndSymbols({s0}, {d0, c7}, /*num_dims=*/1);\n@@ -156,10 +159,10 @@ TEST_F(SymbolicExprTest, ReplaceDimsAndSymbols) {\n }\n \n TEST_F(SymbolicExprTest, UniquingWorks) {\n-  SymbolicExpr c1 = ctx.CreateConstant(42);\n-  SymbolicExpr c2 = ctx.CreateConstant(42);\n+  SymbolicExpr c1 = CreateSymbolicConstant(42, &ctx);\n+  SymbolicExpr c2 = CreateSymbolicConstant(42, &ctx);\n   EXPECT_EQ(c1, c2);\n-  SymbolicExpr c3 = ctx.CreateConstant(99);\n+  SymbolicExpr c3 = CreateSymbolicConstant(99, &ctx);\n   EXPECT_NE(c1, c3);\n \n   SymbolicExpr add1 = v0 + 42;\n@@ -170,39 +173,32 @@ TEST_F(SymbolicExprTest, UniquingWorks) {\n }\n \n TEST_F(SymbolicExprTest, UniquingDoesNotCrashWithCombinedAffineExpr) {\n-  mlir::AffineExpr affine_expr = mlir::getAffineDimExpr(0, &mlir_context);\n-  SymbolicExpr c1 = ctx.CreateConstant(42);\n-  EXPECT_EQ(affine_expr, mlir::getAffineDimExpr(0, &mlir_context));\n-  EXPECT_EQ(c1, ctx.CreateConstant(42));\n-}\n-\n-TEST_F(SymbolicExprTest, UniquingWorksAcrossDifferentContexts) {\n-  SymbolicExprContext ctx2(&mlir_context);\n-\n-  EXPECT_EQ(ctx.CreateConstant(42), ctx2.CreateConstant(42));\n-  EXPECT_EQ(ctx.CreateVariable(0), ctx2.CreateVariable(0));\n+  mlir::AffineExpr affine_expr = mlir::getAffineDimExpr(0, &ctx);\n+  SymbolicExpr c1 = CreateSymbolicConstant(42, &ctx);\n+  EXPECT_EQ(affine_expr, mlir::getAffineDimExpr(0, &ctx));\n+  EXPECT_EQ(c1, CreateSymbolicConstant(42, &ctx));\n }\n \n TEST_F(SymbolicExprTest, Replace) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n-  SymbolicExpr c2 = ctx.CreateConstant(2);\n-  SymbolicExpr c5 = ctx.CreateConstant(5);\n+  SymbolicExpr d0 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr d1 = CreateSymbolicVariable(1, &ctx);\n+  SymbolicExpr c2 = CreateSymbolicConstant(2, &ctx);\n+  SymbolicExpr c5 = CreateSymbolicConstant(5, &ctx);\n \n   SymbolicExpr expr = (d0 + c2) * (d1 + c2);\n   EXPECT_EQ(expr.Replace(d0 + c2, c5), (c5 * (d1 + c2)));\n   EXPECT_EQ(expr.Replace(d1, d0), (d0 + c2) * (d0 + c2));\n   EXPECT_EQ(expr.Replace(c2, c5), (d0 + c5) * (d1 + c5));\n   EXPECT_EQ(expr.Replace(expr, c2), c2);\n   EXPECT_EQ(expr.Replace(d1, d1), expr);\n-  EXPECT_EQ(expr.Replace(ctx.CreateConstant(42), d1), expr);\n+  EXPECT_EQ(expr.Replace(CreateSymbolicConstant(42, &ctx), d1), expr);\n }\n \n TEST_F(SymbolicExprTest, ReplaceWithMap) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n-  SymbolicExpr c2 = ctx.CreateConstant(2);\n-  SymbolicExpr c5 = ctx.CreateConstant(5);\n+  SymbolicExpr d0 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr d1 = CreateSymbolicVariable(1, &ctx);\n+  SymbolicExpr c2 = CreateSymbolicConstant(2, &ctx);\n+  SymbolicExpr c5 = CreateSymbolicConstant(5, &ctx);\n \n   SymbolicExpr expr = (d0 + c2) * (d1 + c2);\n \n@@ -221,14 +217,14 @@ TEST_F(SymbolicExprTest, ReplaceWithMap) {\n   EXPECT_EQ(expr.Replace(swap_variables), (d1 + c2) * (d0 + c2));\n \n   llvm::DenseMap<SymbolicExpr, SymbolicExpr> no_change;\n-  no_change[ctx.CreateVariable(99)] = c5;\n+  no_change[CreateSymbolicVariable(99, &ctx)] = c5;\n   EXPECT_EQ(expr.Replace(no_change), expr);\n }\n \n TEST_F(SymbolicExprTest, BasicSimplificationsAtCreationTime) {\n-  auto c0 = ctx.CreateConstant(0);\n-  auto c1 = ctx.CreateConstant(1);\n-  auto c3 = ctx.CreateConstant(3);\n+  auto c0 = CreateSymbolicConstant(0, &ctx);\n+  auto c1 = CreateSymbolicConstant(1, &ctx);\n+  auto c3 = CreateSymbolicConstant(3, &ctx);\n \n   // x + 0 = x\n   EXPECT_EQ(v0 + c0, v0);\n@@ -253,7 +249,7 @@ TEST_F(SymbolicExprTest, BasicSimplificationsAtCreationTime) {\n \n   // No associativity if constant is on LHS of outer mul.\n   // TODO(b/459357586): This will be canonicalized to (v0 * 6) in the future.\n-  SymbolicExpr mul_2_v0 = ctx.CreateConstant(2) * v0;\n+  SymbolicExpr mul_2_v0 = CreateSymbolicConstant(2, &ctx) * v0;\n   SymbolicExpr mul_2_v0_3 = mul_2_v0 * 3;\n   EXPECT_EQ(mul_2_v0_3.ToString(), \"((2 * v0) * 3)\");\n }\n@@ -356,18 +352,18 @@ TEST_F(SymbolicExprTest, Walk) {\n TEST_F(SymbolicExprTest, Hashing) {\n   absl::flat_hash_set<SymbolicExpr> set;\n \n-  SymbolicExpr c42_1 = ctx.CreateConstant(42);\n-  SymbolicExpr c42_2 = ctx.CreateConstant(42);\n-  SymbolicExpr c3 = ctx.CreateConstant(3);\n+  SymbolicExpr c42_1 = CreateSymbolicConstant(42, &ctx);\n+  SymbolicExpr c42_2 = CreateSymbolicConstant(42, &ctx);\n+  SymbolicExpr c3 = CreateSymbolicConstant(3, &ctx);\n \n   set.insert(c42_1);\n   set.insert(c42_2);\n   set.insert(c3);\n   EXPECT_EQ(set.size(), 2);\n \n-  SymbolicExpr v0_1 = ctx.CreateVariable(0);\n-  SymbolicExpr v0_2 = ctx.CreateVariable(0);\n-  SymbolicExpr v1 = ctx.CreateVariable(1);\n+  SymbolicExpr v0_1 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr v0_2 = CreateSymbolicVariable(0, &ctx);\n+  SymbolicExpr v1 = CreateSymbolicVariable(1, &ctx);\n \n   set.insert(v0_1);\n   set.insert(v0_2);\n@@ -384,18 +380,5 @@ TEST_F(SymbolicExprTest, Hashing) {\n   EXPECT_EQ(set.size(), 6);\n }\n \n-TEST_F(SymbolicExprTest, SymbolicExprContextEq) {\n-  mlir::MLIRContext mlir_context2;\n-  SymbolicExprContext ctx2(&mlir_context2);\n-\n-  // Different MLIRContexts should result in different SymbolicExprContexts.\n-  EXPECT_NE(ctx, ctx2);\n-\n-  // Same MLIRContext should result in same StorageUniquer and thus equal\n-  // SymbolicExprContexts.\n-  SymbolicExprContext ctx3(&mlir_context);\n-  EXPECT_EQ(ctx, ctx3);\n-}\n-\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 385,
        "additions": 214,
        "deletions": 171
    }
}