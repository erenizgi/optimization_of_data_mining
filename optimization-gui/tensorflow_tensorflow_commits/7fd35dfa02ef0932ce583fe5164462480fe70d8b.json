{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add ABSL_ATTRIBUTE_ALWAYS_INLINE to Future::{Map,OnReady}\n\n```\nname                        cpu/op        cpu/op      vs base\nBM_MapStatelessFuture       46.03n ± 1%   36.93n ± 0%  -19.76% (p=0.000 n=40)\nBM_TryMapStatelessFuture    46.15n ± 1%   36.00n ± 1%  -22.01% (p=0.000 n=40)\nBM_MapToFromStatelessFuture 49.54n ± 0%   39.19n ± 0%  -20.90% (p=0.000 n=40)\nBM_MapStatefulFuture        45.88n ± 0%   39.97n ± 3%  -12.87% (p=0.000 n=40)\nBM_TryMapStatefulFuture     52.14n ± 0%   36.90n ± 0%  -29.24% (p=0.000 n=40)\n```\n\nPiperOrigin-RevId: 817699788",
    "sha": "7fd35dfa02ef0932ce583fe5164462480fe70d8b",
    "files": [
        {
            "sha": "6d11c9622ddb3074081c924168409519f9799f26",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 16,
            "deletions": 17,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7fd35dfa02ef0932ce583fe5164462480fe70d8b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7fd35dfa02ef0932ce583fe5164462480fe70d8b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=7fd35dfa02ef0932ce583fe5164462480fe70d8b",
            "patch": "@@ -23,6 +23,7 @@ limitations under the License.\n #include <type_traits>\n #include <utility>\n \n+#include \"absl/base/attributes.h\"\n #include \"absl/base/no_destructor.h\"\n #include \"absl/base/optimization.h\"\n #include \"absl/meta/type_traits.h\"\n@@ -328,7 +329,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   template <typename F,\n             std::enable_if_t<!is_move_only &&\n                              std::is_invocable_v<F, const T&>>* = nullptr>\n-  void OnReady(F&& f) const& {\n+  ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(F&& f) const& {\n     CHECK(IsValid());\n     promise_.AndThen(\n         [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n@@ -347,7 +348,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   template <typename F,\n             std::enable_if_t<std::is_invocable_v<\n                 F, std::conditional_t<is_move_only, T, const T&>>>* = nullptr>\n-  void OnReady(F&& f) && {\n+  ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(F&& f) && {\n     CHECK(IsValid());\n     promise_.AndThen(\n         [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n@@ -483,7 +484,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   // - on_block_start is called before Await starts to block.\n   // - on_block_end is called after Await finishes blocking.\n-  static std::pair<Promise, Future<T>> MakePromise(\n+  static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<T>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n       FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n     Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n@@ -535,7 +536,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<F, const T&>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] Future<R> Map(F&& f) const& {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const& {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     using Value = const absl::StatusOr<T>&;\n@@ -601,7 +602,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n             typename U = std::invoke_result_t<\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] Future<R> Map(F&& f) && {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) && {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n@@ -647,7 +648,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   // - `R` is any other type      -> Future<R>\n   //\n   template <typename F, typename R = std::invoke_result_t<F, const T&>>\n-  [[nodiscard]] auto Map(F&& f) const& {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) const& {\n     if constexpr (std::is_void_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {\n@@ -667,7 +668,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   template <typename F, typename R = std::invoke_result_t<\n                             F, std::conditional_t<is_move_only, T, const T&>>>\n-  [[nodiscard]] auto Map(F&& f) && {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) && {\n     if constexpr (std::is_void_v<R>) {\n       return std::move(*this).template Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {\n@@ -759,7 +760,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n \n   // Returns a pair of connected Promise and Future<>. Setting the returned\n   // promise will fulfill the connected future.\n-  static std::pair<Promise, Future<>> MakePromise(\n+  static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n       FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n     Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n@@ -809,7 +810,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // See `Map` functor type inference defined below for more details.\n   template <typename R, typename F, typename U = std::invoke_result_t<F>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] Future<R> Map(F&& f) {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     OnReady([promise = std::move(promise),\n@@ -853,7 +854,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // - `R` is any other type      -> Future<R>\n   //\n   template <typename F, typename R = std::invoke_result_t<F>>\n-  [[nodiscard]] auto Map(F&& f) {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) {\n     if constexpr (std::is_void_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {\n@@ -868,16 +869,14 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // Returns an Future<R> that is constructed from the given value. If *this\n   // completes with an error, returned future will also be an error.\n   //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n+  // Sample usage: make buffer available when copy is complete\n   //\n-  // Sample usage: make buffer available when future is ready\n+  //   std::unique_ptr<Buffer> buffer = AllocateDestinationBuffer();\n+  //   Future<> future = CopyToBuffer(buffer, ...);\n+  //   future.MapTo(std::move(buffer));\n   //\n-  // std::unique_ptr<Buffer> buffer = ...;\n-  // future.MapTo<R>(std::move(buffer));\n   template <typename R>\n-  Future<absl::remove_cvref_t<R>> MapTo(R&& value) {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto MapTo(R&& value) {\n     return Map<absl::remove_cvref_t<R>>(\n         [value = std::forward<R>(value)]() mutable {\n           return std::move(value);"
        }
    ],
    "stats": {
        "total": 33,
        "additions": 16,
        "deletions": 17
    }
}