{
    "author": "jeffreyadean",
    "message": "Improve data structures and cache behavior in HloReachabilityMap.\n\nMain class now holds a single block of memory for all the bitvectors,\nand the internal BitSet class now represents a view over one of these\nbitvectors in the overall bit matrix we allocated.\n\nThis means:\n\n(a) We get rid of the cache footprint of the vector<BitSet> separate\nbitvector objects (each of which had a size_t and a vector<Word>\ninside) throughout the reachability computation, and instead just\ndynamically create the right view for the \"i\"th instruction's BitSet\nas needed from just the base pointer + i * num_words_per_bitset\n\n(b) We avoid O(# instructions) separate memory allocations for each\nindividual BitSet's vector<Word> backing store.\n\nand\n\n(c) We avoid an extra level of indirection for every access to every\nbit vector, since we don't have to indirect through the vector<Word>\nin each BitSet.\n\nBenchmark results:\n\n```\nRun on (72 X 3568.55 MHz CPU s)\nBenchmark                                      Base (ns)    New (ns) Improvement\n----------------------------------------------------------------------------\nBM_HloReachabilityBitSetUnion/1_mean                1.63        2.17    -33.1%\nBM_HloReachabilityBitSetUnion/64_mean               1.63        2.17    -33.1%\nBM_HloReachabilityBitSetUnion/128_mean              1.90        2.72    -43.2%\nBM_HloReachabilityBitSetUnion/256_mean              3.00        3.81    -27.0%\nBM_HloReachabilityBitSetUnion/512_mean              4.60        3.82    +17.0%\nBM_HloReachabilityBitSetUnion/4096_mean            28.10       14.40    +48.8%\nBM_HloReachabilityBitSetUnion/32768_mean            215         106     +50.7%\nBM_HloReachabilityBitSetUnion/262144_mean          1907        1334     +30.0%\nBM_HloReachabilityBuild/1_mean                    767.00       86.50    +88.7%\nBM_HloReachabilityBuild/64_mean                   21196        4100     +80.7%\nBM_HloReachabilityBuild/128_mean                  41435        8138     +80.4%\nBM_HloReachabilityBuild/256_mean                  82157       16537     +79.9%\nBM_HloReachabilityBuild/512_mean                 170361       33346     +80.4%\nBM_HloReachabilityBuild/4096_mean               2518996      534016     +78.8%\nBM_HloReachabilityBuild/32768_mean             77882703    30536467     +60.8%\nBM_HloReachabilityBuild/262144_mean          4268340351  2458854859     +42.4%\n```\n\nPiperOrigin-RevId: 806439980",
    "sha": "ad30c7204fb802b0255f8846d378e41f7135a987",
    "files": [
        {
            "sha": "2cbf312f7f5a3b4483460021a48798b457ed5a9d",
            "filename": "third_party/xla/xla/hlo/analysis/hlo_reachability.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 9,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ad30c7204fb802b0255f8846d378e41f7135a987/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ad30c7204fb802b0255f8846d378e41f7135a987/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability.cc?ref=ad30c7204fb802b0255f8846d378e41f7135a987",
            "patch": "@@ -15,7 +15,9 @@ limitations under the License.\n \n #include \"xla/hlo/analysis/hlo_reachability.h\"\n \n+#include <algorithm>\n #include <cstddef>\n+#include <cstring>\n #include <memory>\n #include <queue>\n #include <vector>\n@@ -30,10 +32,26 @@ namespace xla {\n \n HloReachabilityMap::HloReachabilityMap(\n     absl::Span<const HloInstruction* const> instructions)\n-    : bit_sets_(instructions.size(), BitSet(instructions.size())) {\n+    : bits_per_bitset_(instructions.size()),\n+      words_per_bitset_((bits_per_bitset_ + BitSet::kBits - 1) / BitSet::kBits),\n+      total_words_((instructions.size() + 1 /*for tmp_bit_set_*/) *\n+                   words_per_bitset_) {\n+  int row = 0;\n+  int total_rows = instructions.size() + 1;  // for tmp_bit_set_\n+  while (row < total_rows) {\n+    const int rows_to_allocate = std::min(kRowsPerAllocation, total_rows - row);\n+    size_t words_to_allocate = rows_to_allocate * words_per_bitset_;\n+    bit_storage_.push_back(std::make_unique<BitSet::Word[]>(words_to_allocate));\n+    // Initialize all the bitsets to 0\n+    memset(bit_storage_.back().get(), 0,\n+           words_to_allocate * sizeof(BitSet::Word));\n+    row += rows_to_allocate;\n+  }\n+\n+  tmp_bit_set_ = BitSetFromIndex(instructions.size());\n   indices_.reserve(instructions.size());\n   for (size_t i = 0; i < instructions.size(); ++i) {\n-    bit_sets_[i].Set(i);  // Instructions are reachable from themselves.\n+    BitSetFromIndex(i).Set(i);  // Instructions are reachable from themselves.\n     indices_[GetKey(instructions[i])] = i;\n   }\n }\n@@ -42,8 +60,8 @@ bool HloReachabilityMap::SetReachabilityToUnion(\n     absl::Span<const HloInstruction* const> inputs,\n     const HloInstruction* instruction) {\n   Index index = GetIndex(instruction);\n-  BitSet& bit_set = bit_sets_[index];\n-  tmp_bit_set_ = bit_set;\n+  BitSet bit_set = BitSetFromIndex(index);\n+  tmp_bit_set_.CopyBitSet(bit_set);\n   SetReachabilityToUnionHelper(inputs, index);\n   return bit_set != tmp_bit_set_;\n }\n@@ -71,15 +89,15 @@ void HloReachabilityMap::SetReachabilityToUnionHelper(\n \n void HloReachabilityMap::SetReachabilityToUnionHelper(\n     absl::Span<const Index> input_indices, Index index) {\n-  BitSet& bit_set = bit_sets_[index];\n+  BitSet bit_set = BitSetFromIndex(index);\n   // If instruction is part of inputs, don't reset the bit-set.\n   if (!absl::c_linear_search(input_indices, index)) {\n     bit_set.SetToZero();\n   }\n   bit_set.Set(index);\n   for (Index input_index : input_indices) {\n     if (input_index != index) {\n-      bit_set |= bit_sets_[input_index];\n+      bit_set |= BitSetFromIndex(input_index);\n     }\n   }\n }\n@@ -117,12 +135,12 @@ std::unique_ptr<HloReachabilityMap> HloReachabilityMap::Build(\n       computation->MakeInstructionPostOrder(channel_dependencies);\n   auto result = std::make_unique<HloReachabilityMap>(instructions);\n \n-  auto get_bit_set = [&](const HloInstruction* instruction) -> BitSet& {\n-    return result->bit_sets_[result->GetIndex(instruction)];\n+  auto get_bit_set = [&](const HloInstruction* instruction) -> BitSet {\n+    return result->BitSetFromIndex(result->GetIndex(instruction));\n   };\n \n   for (const HloInstruction* instruction : instructions) {\n-    BitSet& bit_set = get_bit_set(instruction);\n+    BitSet bit_set = get_bit_set(instruction);\n \n     auto add_dependencies = [&](const HloInstruction* instruction) {\n       for (const HloInstruction* operand : instruction->operands()) {"
        },
        {
            "sha": "1096434e1ce242f56950f82184a55246985cf88f",
            "filename": "third_party/xla/xla/hlo/analysis/hlo_reachability.h",
            "status": "modified",
            "additions": 83,
            "deletions": 27,
            "changes": 110,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ad30c7204fb802b0255f8846d378e41f7135a987/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ad30c7204fb802b0255f8846d378e41f7135a987/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability.h?ref=ad30c7204fb802b0255f8846d378e41f7135a987",
            "patch": "@@ -49,6 +49,9 @@ class HloReachabilityMap {\n   explicit HloReachabilityMap(\n       absl::Span<const HloInstruction* const> instructions);\n \n+  HloReachabilityMap(const HloReachabilityMap& b) noexcept = delete;\n+  HloReachabilityMap& operator=(HloReachabilityMap& b) noexcept = delete;\n+\n   // Computes and returns the reachability between HLO instructions in the\n   // computation. The returned HloReachabilityMap is constructed such that\n   // HloReachabilityMap::IsReachable(a, b) returns true iff there exists a\n@@ -105,7 +108,7 @@ class HloReachabilityMap {\n   void SetReachable(const HloInstruction* a, const HloInstruction* b) {\n     SetReachable(GetIndex(a), GetIndex(b));\n   }\n-  void SetReachable(Index a, Index b) { bit_sets_[b].Set(a); }\n+  void SetReachable(Index a, Index b) { BitSetFromIndex(b).Set(a); }\n \n   // Updates the given reachability map after the immediate predecessor set\n   // (operands and control predecessors) of 'instruction' has changed.\n@@ -118,7 +121,7 @@ class HloReachabilityMap {\n   bool IsReachable(const HloInstruction* a, const HloInstruction* b) const {\n     return IsReachable(GetIndex(a), GetIndex(b));\n   }\n-  bool IsReachable(Index a, Index b) const { return bit_sets_[b].Get(a); }\n+  bool IsReachable(Index a, Index b) const { return BitSetFromIndex(b).Get(a); }\n \n   // Returns true if \"b\" is reachable from \"a\" or \"a\" is reachable from \"b\"\n   //\n@@ -148,57 +151,95 @@ class HloReachabilityMap {\n                const HloInstruction* replacement);\n \n  private:\n-  // A dynamically sized bit-set implementation specialized for this use case\n-  // providing fast bitwise OR (not available in tsl::gtl::BitMap).\n+  // A BitSet is a view over a contiguous region of member that holds a bitset\n+  // as an array of words.\n   class BitSet {\n    public:\n-    BitSet() = default;\n-    explicit BitSet(size_t size)\n-        : size_(size), vector_((size + kBits - 1) / kBits, 0) {}\n+    using Word = uint64_t;\n+    static constexpr size_t kBits = 64;\n+\n+    BitSet() : ptr_(nullptr), bits_(0) {}\n+    // Create a BitSet view of \"num_bits\" starting at \"ptr\".  The memory backing\n+    // the bit set must be rounded up to the nearest word boundary (for\n+    // efficiency, we sometimes write full words at the ragged edges of bitsets\n+    // that are not exactly multiples of kBits in size).\n+    explicit BitSet(Word* ptr, size_t num_bits) : ptr_(ptr), bits_(num_bits) {}\n \n     // Returns the bit at the given index.\n     bool Get(Index index) const {\n-      DCHECK(index >= 0 && index < size_);\n-      return vector_[index / kBits] & (1ull << (index % kBits));\n+      DCHECK(index >= 0 && index < bits_);\n+      return ptr_[index / kBits] & (1ull << (index % kBits));\n     }\n \n     // Sets the bit at the given index.\n     void Set(Index index) {\n-      DCHECK(index >= 0 && index < size_);\n-      vector_[index / kBits] |= 1ull << (index % kBits);\n+      DCHECK(index >= 0 && index < bits_);\n+      ptr_[index / kBits] |= 1ull << (index % kBits);\n     }\n \n     // Sets this bit-set to union of this bit-set and `other`.\n     void operator|=(const BitSet& other) {\n-      if (this == &other) return;\n-      DCHECK(size_ == other.size_);\n+      DCHECK(bits_ == other.bits_);\n+      if (ptr_ == other.ptr_) {\n+        return;\n+      }\n \n       // Ease the work of the auto-vectorizer.\n-      const Word* a = vector_.data();\n-      const Word* b = other.vector_.data();\n-      Word* __restrict out = vector_.data();\n-      size_t num_words = vector_.size();\n+      const Word* a = ptr_;\n+      const Word* b = other.ptr_;\n+      Word* __restrict out = ptr_;\n+      size_t num_words = NumWords();\n       for (size_t i = 0; i < num_words; ++i) {\n         out[i] = a[i] | b[i];\n       }\n     }\n+    // Copy the bitset contents of \"other\" into \"this\".\n+    void CopyBitSet(const BitSet& other) {\n+      DCHECK(bits_ == other.bits_);\n+      if (ptr_ == other.ptr_) {\n+        return;\n+      }\n+\n+      // Ease the work of the auto-vectorizer.\n+      const Word* b = other.ptr_;\n+      Word* __restrict out = ptr_;\n+      size_t num_words = NumWords();\n+      for (size_t i = 0; i < num_words; ++i) {\n+        out[i] = b[i];\n+      }\n+    }\n+\n+    size_t NumWords() const { return (bits_ + kBits - 1) / kBits; }\n+    size_t NumBytes() const {\n+      return NumWords() * sizeof(Word) / sizeof(uint8_t);\n+    }\n \n     // Sets the bitvector to all zeros.\n-    void SetToZero() { absl::c_fill(vector_, 0); }\n+    void SetToZero() { memset(ptr_, 0, NumBytes()); }\n \n     bool operator==(const BitSet& other) const {\n-      return vector_ == other.vector_;\n+      if (bits_ != other.bits_) {\n+        return false;\n+      }\n+      absl::Span<Word> aspan(ptr_, NumWords());\n+      absl::Span<Word> bspan(other.ptr_, other.NumWords());\n+      return aspan == bspan;\n     }\n     bool operator!=(const BitSet& other) const { return !(*this == other); }\n \n    private:\n-    using Word = uint64_t;\n-    static constexpr size_t kBits = 64;\n-\n-    size_t size_;  // Number of bits in the set.\n-    std::vector<Word> vector_;\n+    Word* ptr_;\n+    size_t bits_;  // Number of bits in the set.\n   };\n \n+  BitSet BitSetFromIndex(Index i) const {\n+    const int block = i / kRowsPerAllocation;\n+    const int row_within_block = i % kRowsPerAllocation;\n+    return BitSet(\n+        bit_storage_[block].get() + row_within_block * words_per_bitset_,\n+        bits_per_bitset_);\n+  }\n+\n   friend class HloReachabilityMapBitSetBenchmark;\n \n   using Key = std::pair<int64_t, int64_t>;  // module ID, instruction ID.\n@@ -216,9 +257,24 @@ class HloReachabilityMap {\n   // within a BitSet.\n   absl::flat_hash_map<Key, Index> indices_;\n \n-  // Bit-sets holding the reachability to each instruction. The bit-set for\n-  // instruction X includes ones for each instruction which X is reachable from.\n-  std::vector<BitSet> bit_sets_;\n+  // We allocate an (instructions.size() + 1) * (roundup(instructions.size(),\n+  // 64) bit matrix to hold the adjacency information.  We round up one\n+  // dimension so that each bit matrix starts on its own word boundary.  We\n+  // allocate one extra so that we have one bit vector worth of temporary\n+  // storage for use during the reachability computation.\n+\n+  // To avoid allocating a single giant block of memory in one allocation, we\n+  // allocate groups of up to kRowsPerAllocation bitsets at a time.  These\n+  // groups of rows are stored in the elements of \"bit_storage_\".\n+  //\n+  // BitSetFromIndex(i) abstracts away this representation to give the proper\n+  // pointer to the \"i\"th row.\n+  static constexpr int kRowsPerAllocation = 1024;\n+\n+  size_t bits_per_bitset_;\n+  size_t words_per_bitset_;\n+  size_t total_words_;  // Total allocated words in bit_storage_\n+  std::vector<std::unique_ptr<BitSet::Word[]>> bit_storage_;\n \n   // A temporary used by SetReachabilityToUnion to avoid an allocation with each\n   // call to the method."
        },
        {
            "sha": "478c13a3edfcb6602d468d32811a5b01040a036a",
            "filename": "third_party/xla/xla/hlo/analysis/hlo_reachability_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ad30c7204fb802b0255f8846d378e41f7135a987/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ad30c7204fb802b0255f8846d378e41f7135a987/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_reachability_test.cc?ref=ad30c7204fb802b0255f8846d378e41f7135a987",
            "patch": "@@ -15,8 +15,11 @@ limitations under the License.\n \n #include \"xla/hlo/analysis/hlo_reachability.h\"\n \n+#include <cstddef>\n+#include <cstdint>\n #include <memory>\n #include <string>\n+#include <vector>\n \n #include \"absl/random/random.h\"\n #include \"absl/strings/string_view.h\"\n@@ -257,7 +260,11 @@ TEST_F(HloReachabilityTest, ReplaceInstructions) {\n \n class HloReachabilityMapBitSetBenchmark {\n  public:\n-  explicit HloReachabilityMapBitSetBenchmark(int size) : a_(size), b_(size) {\n+  explicit HloReachabilityMapBitSetBenchmark(int size) {\n+    size_t nwords = (size + 63) / 64;\n+    std::vector<uint64_t> space(2 * nwords);\n+    a_ = HloReachabilityMap::BitSet(&space[0], size);\n+    b_ = HloReachabilityMap::BitSet(&space[nwords], size);\n     // Initialize the bit sets to random inputs. Done out of caution -- note\n     // that a sufficiently smart optimizer might realize that the bit sets\n     // are otherwise initialized to 0."
        }
    ],
    "stats": {
        "total": 155,
        "additions": 118,
        "deletions": 37
    }
}