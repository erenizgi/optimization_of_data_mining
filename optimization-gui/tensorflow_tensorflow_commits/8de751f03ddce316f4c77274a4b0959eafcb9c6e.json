{
    "author": "tensorflower-gardener",
    "message": "Drop uncalled inlineable manual computation functions.\n\nShardMapExport pass runs before ExportNamedComputation pass on StableHLO export pipeline. ShardMapExport creates a new function for each manual computation, even they are within the named computations originated from the same function. ExportNamedComputation deduplicates named computations only based on input/output shardings, and as a result it ends up uncalled manual computations.\n\nFor example:\n\n%0 = sdy.named_computation<\"foo\"> {\n  %2 = sdy.manual_computation {} ...\n}\n%1 = sdy.named_computation<\"foo\"> {\n  %2 = sdy.manual_computation {} ...\n}\n\n----> (ShardMapExport) ---->\n\n%0 = sdy.named_computation<\"foo\"> {\n  %2 = call @xla.sdy.inlinable_manual_computation_body\n  ...\n}\n%1 = sdy.named_computation<\"foo\"> {\n  %2 = call @xla.sdy.inlinable_manual_computation_body_0\n  ...\n}\n...\nfunc.func @xla.sdy.inlinable_manual_computation_body {...}\nfunc.func @xla.sdy.inlinable_manual_computation_body_0 {...}\n\n----> (ExportNamedComputations) ---->\n\n%0 = call @foo\n%1 = call @foo\n...\nfunc.func @xla.sdy.inlinable_manual_computation_body {...}\nfunc.func @xla.sdy.inlinable_manual_computation_body_0 {...}\nfunc.func @foo {\n  %0 = call @xla.sdy.inlinable_manual_computation_body\n  ...\n}\n\nPiperOrigin-RevId: 830835786",
    "sha": "8de751f03ddce316f4c77274a4b0959eafcb9c6e",
    "files": [
        {
            "sha": "fdafc3438c8ee37d35cbb8f1920061db013289a5",
            "filename": "third_party/xla/xla/service/spmd/shardy/round_trip_common/export_named_computations.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8de751f03ddce316f4c77274a4b0959eafcb9c6e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fround_trip_common%2Fexport_named_computations.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8de751f03ddce316f4c77274a4b0959eafcb9c6e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fround_trip_common%2Fexport_named_computations.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fround_trip_common%2Fexport_named_computations.cc?ref=8de751f03ddce316f4c77274a4b0959eafcb9c6e",
            "patch": "@@ -57,6 +57,8 @@ using ::mlir::NamedAttribute;\n using ::mlir::StringAttr;\n using ::mlir::StringRef;\n using ::mlir::SymbolTable;\n+using ::mlir::SymbolTableCollection;\n+using ::mlir::SymbolUserMap;\n using ::mlir::func::CallOp;\n using ::mlir::func::FuncOp;\n \n@@ -151,7 +153,8 @@ class ExportNamedComputationsPass\n \n   void runOnOperation() final {\n     ModuleOp moduleOp = getOperation();\n-    SymbolTable symbolTable(moduleOp);\n+    SymbolTableCollection symbolTableCollection;\n+    SymbolTable& symbolTable = symbolTableCollection.getSymbolTable(moduleOp);\n     mlir::Block& moduleBlock = moduleOp.getRegion().front();\n     llvm::SmallDenseMap<ComputationKey, StringAttr> funcCache;\n \n@@ -264,6 +267,22 @@ class ExportNamedComputationsPass\n         }\n       }\n     });\n+\n+    // Drop uncalled inlineable manual computation funcs.\n+    // TODO(enver): Drop generically, not just inlined manual computation funcs.\n+    llvm::SmallVector<FuncOp> uncalledInlineableManualComputationFuncs;\n+    SymbolUserMap symbolUserMap(symbolTableCollection, moduleOp);\n+    for (FuncOp funcOp : moduleOp.getOps<FuncOp>()) {\n+      if (StringRef funcSymName = funcOp.getName();\n+          funcSymName.contains(kInlineableManualComputationFuncName) &&\n+          symbolUserMap.useEmpty(funcOp)) {\n+        uncalledInlineableManualComputationFuncs.push_back(funcOp);\n+      }\n+    }\n+    // TODO(enver): Erase directly without collecting on a vector.\n+    for (FuncOp funcOp : uncalledInlineableManualComputationFuncs) {\n+      symbolTable.erase(funcOp);\n+    }\n   }\n \n   StringRef getArgument() const override {"
        },
        {
            "sha": "a389c3f6fbbf9b05796f19f6d26e27d0a7108023",
            "filename": "third_party/xla/xla/service/spmd/shardy/test/export_named_computations.mlir",
            "status": "modified",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8de751f03ddce316f4c77274a4b0959eafcb9c6e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fexport_named_computations.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8de751f03ddce316f4c77274a4b0959eafcb9c6e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fexport_named_computations.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fexport_named_computations.mlir?ref=8de751f03ddce316f4c77274a4b0959eafcb9c6e",
            "patch": "@@ -101,6 +101,56 @@ func.func @multiple_same_named_computations_different_shardings(%arg0: tensor<8x\n \n sdy.mesh @mesh = <[\"x\"=2, \"y\"=2]>\n \n+// CHECK-LABEL: func @multiple_same_named_computations_same_shardings_named_computations_have_different_manual_computation_calls(\n+func.func @multiple_same_named_computations_same_shardings_named_computations_have_different_manual_computation_calls(%arg0: tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{\"y\"}, {\"x\"}]>}) -> (tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{\"x\"}, {\"y\"}]>}) {\n+  // CHECK-NEXT: %0 = call @baz(%arg0) {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {}]>]>} : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+  // CHECK-NEXT: %1 = call @baz(%arg0) {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {}]>]>} : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+  // CHECK-NEXT: %2 = call @baz(%arg0) {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {}]>]>} : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+  // CHECK-NEXT: return %2 : tensor<8x2xi32>\n+  %0 = sdy.named_computation<\"baz\">(%arg0) in_shardings=[<@mesh, [{}, {}]>] out_shardings=[<@mesh, [{}, {}]>] (%arg1: tensor<8x2xi32>) {\n+    %3 = func.call @local_xla.sdy.inlinable_manual_computation_body(%arg1) {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {}]>]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>} : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+    sdy.return %3 : tensor<8x2xi32>\n+  } : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+  %1 = sdy.named_computation<\"baz\">(%arg0) in_shardings=[<@mesh, [{}, {}]>] out_shardings=[<@mesh, [{}, {}]>] (%arg1: tensor<8x2xi32>) {\n+    %3 = func.call @local_xla.sdy.inlinable_manual_computation_body_0(%arg1) {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {}]>]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>} : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+    sdy.return %3 : tensor<8x2xi32>\n+  } : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+  %2 = sdy.named_computation<\"baz\">(%arg0) in_shardings=[<@mesh, [{}, {}]>] out_shardings=[<@mesh, [{}, {}]>] (%arg1: tensor<8x2xi32>) {\n+    %3 = func.call @local_xla.sdy.inlinable_manual_computation_body_1(%arg1) {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {}]>]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>} : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+    sdy.return %3 : tensor<8x2xi32>\n+  } : (tensor<8x2xi32>) -> tensor<8x2xi32>\n+  return %2 : tensor<8x2xi32>\n+}\n+\n+// CHECK-LABEL: func @local_xla.sdy.inlinable_manual_computation_body(\n+func.func @local_xla.sdy.inlinable_manual_computation_body(\n+  %arg0: tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>})\n+ -> (tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>}) {\n+  return %arg0 : tensor<8x2xi32>\n+}\n+\n+// CHECK-NOT:   func @local_xla.sdy.inlinable_manual_computation_body_0(\n+func.func @local_xla.sdy.inlinable_manual_computation_body_0(\n+  %arg0: tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>})\n+ -> (tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>}) {\n+  return %arg0 : tensor<8x2xi32>\n+}\n+\n+// CHECK-NOT:   func @local_xla.sdy.inlinable_manual_computation_body_1(\n+func.func @local_xla.sdy.inlinable_manual_computation_body_1(\n+  %arg0: tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>})\n+ -> (tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>, xla.sdy.manual_axes = #sdy<manual_axes{\"x\"}>}) {\n+  return %arg0 : tensor<8x2xi32>\n+}\n+\n+// CHECK-LABEL: func private @baz(\n+// CHECK-SAME:    %arg0: tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>})\n+// CHECK-SAME:    -> (tensor<8x2xi32> {sdy.sharding = #sdy.sharding<@mesh, [{}, {}]>})\n+\n+// -----\n+\n+sdy.mesh @mesh = <[\"x\"=2, \"y\"=2]>\n+\n // CHECK-LABEL: func @non_flat_nested_named_computations_same_shardings(\n // CHECK-SAME:      %arg0: tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{\"x\"}]>}\n // CHECK-SAME:      -> (tensor<8xf32> {sdy.sharding = #sdy.sharding<@mesh, [{\"x\"}]>}) {"
        }
    ],
    "stats": {
        "total": 71,
        "additions": 70,
        "deletions": 1
    }
}