{
    "author": "emilyfertig",
    "message": "Make `MakeCrossHostReceiveBuffers` non-blocking by fixing memory bugs that required awaiting the buffers' ready futures.\n\nPiperOrigin-RevId: 800226668",
    "sha": "691a5f43be7be701fb460fb3e98e463512d605b8",
    "files": [
        {
            "sha": "0b359ad7cae05e9c699e0461c8688e3e89cf3be0",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 34,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/691a5f43be7be701fb460fb3e98e463512d605b8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/691a5f43be7be701fb460fb3e98e463512d605b8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=691a5f43be7be701fb460fb3e98e463512d605b8",
            "patch": "@@ -806,34 +806,34 @@ absl::Status PjRtCApiClient::DmaUnmap(void* data) {\n }\n \n PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n-    const PJRT_Api* c_api, const xla::PjRtCrossHostRecvNotifier& cpp_notifier,\n-    PjRtCApiClient::CrossHostRecvNotifierFunction* notifier_function) {\n-  *notifier_function = [&cpp_notifier, c_api](\n-                           PJRT_Error* error,\n-                           const char** serialized_descriptors,\n-                           size_t* descriptors_sizes, size_t num_descriptors) {\n-    if (error != nullptr) {\n-      absl::Status state = ::pjrt::PjrtErrorToStatus(error, c_api);\n-      return cpp_notifier(std::move(state));\n-    }\n-    xla::PjRtCrossHostRecvState state;\n-    state.descriptors.reserve(num_descriptors);\n-    for (int i = 0; i < num_descriptors; ++i) {\n-      xla::PjRtCrossHostRecvDescriptors descriptors;\n-      descriptors.serialized_descriptors.push_back(\n-          std::string(serialized_descriptors[i], descriptors_sizes[i]));\n-      state.descriptors.push_back(std::move(descriptors));\n-    }\n-\n-    // TODO(emilyaf): Support cancellation.\n-    xla::PjRtCrossHostSendCancelNotifier cancel_notifier =\n-        [](absl::string_view, absl::Status, std::function<void(absl::Status)>) {\n-          LOG(FATAL) << \"MakeCrossHostReceiveBuffers: Cancellation is not \"\n-                        \"supported in PJRT C API.\";\n-        };\n-    state.cancel_notifier = cancel_notifier;\n-    return cpp_notifier(std::move(state));\n-  };\n+    const PJRT_Api* c_api, xla::PjRtCrossHostRecvNotifier cpp_notifier) {\n+  auto notifier_function = new PjRtCApiClient::CrossHostRecvNotifierFunction(\n+      [cpp_notifier = std::move(cpp_notifier), c_api](\n+          PJRT_Error* error, const char** serialized_descriptors,\n+          size_t* descriptors_sizes, size_t num_descriptors) {\n+        if (error != nullptr) {\n+          absl::Status state = ::pjrt::PjrtErrorToStatus(error, c_api);\n+          return cpp_notifier(std::move(state));\n+        }\n+        xla::PjRtCrossHostRecvState state;\n+        state.descriptors.reserve(num_descriptors);\n+        for (int i = 0; i < num_descriptors; ++i) {\n+          xla::PjRtCrossHostRecvDescriptors descriptors;\n+          descriptors.serialized_descriptors.push_back(\n+              std::string(serialized_descriptors[i], descriptors_sizes[i]));\n+          state.descriptors.push_back(std::move(descriptors));\n+        }\n+\n+        // TODO(emilyaf): Support cancellation.\n+        xla::PjRtCrossHostSendCancelNotifier cancel_notifier =\n+            [](absl::string_view, absl::Status,\n+               std::function<void(absl::Status)>) {\n+              LOG(FATAL) << \"MakeCrossHostReceiveBuffers: Cancellation is not \"\n+                            \"supported in PJRT C API.\";\n+            };\n+        state.cancel_notifier = cancel_notifier;\n+        return cpp_notifier(std::move(state));\n+      });\n   return PJRT_Transfers_CrossHostRecvNotifierInfo{\n       /*user_arg=*/notifier_function,\n       /*notifier=*/\n@@ -842,8 +842,9 @@ PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n         PjRtCApiClient::CrossHostRecvNotifierFunction* notifier_fn =\n             reinterpret_cast<PjRtCApiClient::CrossHostRecvNotifierFunction*>(\n                 user_arg);\n-        return (*notifier_fn)(error, serialized_descriptors, descriptors_sizes,\n-                              num_descriptors);\n+        (*notifier_fn)(error, serialized_descriptors, descriptors_sizes,\n+                       num_descriptors);\n+        delete notifier_fn;\n       }};\n }\n \n@@ -894,9 +895,7 @@ PjRtCApiClient::MakeCrossHostReceiveBuffers(\n   args.element_types = element_type_list.data();\n   args.layouts = layout_list.data();\n \n-  CrossHostRecvNotifierFunction notifier_function;\n-  args.notifier =\n-      CppCrossHostRecvNotifierToC(c_api, notifier, &notifier_function);\n+  args.notifier = CppCrossHostRecvNotifierToC(c_api, std::move(notifier));\n   args.device = tensorflow::down_cast<PjRtCApiDevice*>(device)->c_device();\n \n   std::vector<PJRT_Buffer*> temp_buffers(shapes.size());\n@@ -909,7 +908,6 @@ PjRtCApiClient::MakeCrossHostReceiveBuffers(\n   for (int i = 0; i < args.num_buffers; ++i) {\n     buffers.emplace_back(std::unique_ptr<PjRtBuffer>(\n         std::make_unique<PjRtCApiBuffer>(this, args.buffers[i])));\n-    buffers.back()->GetReadyFuture().Await();\n   }\n   return buffers;\n }"
        }
    ],
    "stats": {
        "total": 66,
        "additions": 32,
        "deletions": 34
    }
}