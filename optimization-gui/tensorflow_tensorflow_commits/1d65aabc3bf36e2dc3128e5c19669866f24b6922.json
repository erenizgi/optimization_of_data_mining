{
    "author": "ezhulenev",
    "message": "[xla] Make PjRtFuture<T> constructor from Promise private\n\nPiperOrigin-RevId: 810481233",
    "sha": "1d65aabc3bf36e2dc3128e5c19669866f24b6922",
    "files": [
        {
            "sha": "edda292b8e10fb0b57632970fd3a6aafcd486d8c",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 30,
            "deletions": 37,
            "changes": 67,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1d65aabc3bf36e2dc3128e5c19669866f24b6922/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1d65aabc3bf36e2dc3128e5c19669866f24b6922/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=1d65aabc3bf36e2dc3128e5c19669866f24b6922",
            "patch": "@@ -17,7 +17,6 @@ limitations under the License.\n #define XLA_PJRT_PJRT_FUTURE_H_\n \n #include <algorithm>\n-#include <atomic>\n #include <cstdint>\n #include <functional>\n #include <memory>\n@@ -279,22 +278,8 @@ class PjRtFutureBase : public PjRtFutureMoveControl<is_move_only> {\n     // value stored in the AsyncValue.\n     tsl::AsyncValue* async_value() const { return promise_.GetAsyncValue(); }\n \n-#ifndef NDEBUG\n-    int64_t AddFuture() const { return num_futures_->fetch_add(1); }\n-#endif\n-\n    private:\n     tsl::AsyncValueRef<T> promise_;\n-\n-#ifndef NDEBUG\n-    // In debug builds we track the number of futures created from a promise to\n-    // detect when a promise for a move-only type can be accidentally shared by\n-    // multiple futures. We wrap the counter into shared pointer because promise\n-    // for a move-only future is still copyable, but only one future can be\n-    // created from all the copies.\n-    std::shared_ptr<std::atomic<int64_t>> num_futures_ =\n-        std::make_shared<std::atomic<int64_t>>(0);\n-#endif\n   };\n \n   class ProfilingCleanup {\n@@ -475,6 +460,16 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n       \"PjRtFuture<T> already has an implicit absl::StatusOr<T> semantics\");\n \n  public:\n+  PjRtFuture() = default;\n+\n+  // Constructs an immediately available future with the given value.\n+  explicit PjRtFuture(absl::StatusOr<T> value) : Base(std::move(value)) {}\n+\n+  // Constructs and immediately available future from the given value.\n+  template <typename U,\n+            std::enable_if_t<std::is_constructible_v<T, U>>* = nullptr>\n+  explicit PjRtFuture(U value) : Base(std::forward<U>(value)) {}\n+\n   class Promise : public Base::Promise {\n    public:\n     Promise(Promise&&) = default;\n@@ -503,6 +498,9 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n \n   // Returns a pair of connected Promise and PjRtFuture<T>. Setting the returned\n   // promise will fulfill the connected future.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n   static std::pair<Promise, PjRtFuture<T>> MakePromise(\n       PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n       PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) {\n@@ -512,28 +510,6 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n-  // Bring PjRtFutureBase constructors in scope.\n-  using Base::Base;\n-\n-  // Constructor for unavailable future that will be fulfilled later via the\n-  // promise object.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  //  - on_block_end is called after Await finishes blocking.\n-  explicit PjRtFuture(\n-      const Promise& promise,\n-      PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-      PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr)\n-      : Base(promise.ref(), std::move(on_block_start),\n-             std::move(on_block_end)) {\n-#ifndef NDEBUG\n-    if constexpr (is_move_only) {\n-      DCHECK_EQ(promise.AddFuture(), 0)\n-          << \"Move-only PjRtFuture cannot share a promise object\";\n-    }\n-#endif\n-  }\n-\n   using Base::Await;\n   using Base::GetReadyFuture;\n   using Base::OnReady;\n@@ -740,6 +716,23 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n     return std::move(*this).template TryMap<typename R::value_type>(\n         std::forward<F>(f));\n   }\n+\n+ private:\n+  friend class PjRtFutureHelpers;\n+\n+  // Bring PjRtFutureBase constructors in scope.\n+  using Base::Base;\n+\n+  // Constructor for unavailable future that will be fulfilled later via the\n+  // promise object.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  PjRtFuture(const Promise& promise,\n+             PjRtFutureHelpers::OnBlockStartFn on_block_start,\n+             PjRtFutureHelpers::OnBlockEndFn on_block_end)\n+      : Base(promise.ref(), std::move(on_block_start),\n+             std::move(on_block_end)) {}\n };\n \n // PjRtFuture<void> specialization for communicating stateless events."
        }
    ],
    "stats": {
        "total": 67,
        "additions": 30,
        "deletions": 37
    }
}