{
    "author": "ezhulenev",
    "message": "[xla:ffi] Check that Type used as a state is registered before the handler\n\nPiperOrigin-RevId: 824258481",
    "sha": "e65144c31fba7e30ceb5bd100b0e922661bc8eb6",
    "files": [
        {
            "sha": "24675ed27b87436f26d2b62ba044418c2fb326e7",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e65144c31fba7e30ceb5bd100b0e922661bc8eb6/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e65144c31fba7e30ceb5bd100b0e922661bc8eb6/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=e65144c31fba7e30ceb5bd100b0e922661bc8eb6",
            "patch": "@@ -192,6 +192,49 @@ inline std::ostream& operator<<(std::ostream& os,\n   }\n }\n \n+//===----------------------------------------------------------------------===//\n+// Builtin structs equality\n+//===----------------------------------------------------------------------===//\n+\n+inline bool operator==(const XLA_FFI_TypeId& a, const XLA_FFI_TypeId& b) {\n+  return a.type_id == b.type_id;\n+}\n+\n+inline bool operator!=(const XLA_FFI_TypeId& a, const XLA_FFI_TypeId& b) {\n+  return !(a == b);\n+}\n+\n+inline bool operator==(const XLA_FFI_Api_Version& a,\n+                       const XLA_FFI_Api_Version& b) {\n+  return a.major_version == b.major_version &&\n+         a.minor_version == b.minor_version;\n+}\n+\n+inline bool operator!=(const XLA_FFI_Api_Version& a,\n+                       const XLA_FFI_Api_Version& b) {\n+  return !(a == b);\n+}\n+\n+inline bool operator==(const XLA_FFI_Metadata& a, const XLA_FFI_Metadata& b) {\n+  return a.api_version == b.api_version && a.traits == b.traits &&\n+         a.state_type_id == b.state_type_id;\n+}\n+\n+inline bool operator!=(const XLA_FFI_Metadata& a, const XLA_FFI_Metadata& b) {\n+  return !(a == b);\n+}\n+\n+inline bool operator==(const XLA_FFI_Handler_Bundle& a,\n+                       const XLA_FFI_Handler_Bundle& b) {\n+  return a.instantiate == b.instantiate && a.prepare == b.prepare &&\n+         a.initialize == b.initialize && a.execute == b.execute;\n+}\n+\n+inline bool operator!=(const XLA_FFI_Handler_Bundle& a,\n+                       const XLA_FFI_Handler_Bundle& b) {\n+  return !(a == b);\n+}\n+\n namespace xla::ffi {\n \n enum class ExecutionStage : uint8_t {\n@@ -321,6 +364,9 @@ class Ffi {\n   static XLA_FFI_Error* InvalidArgument(const XLA_FFI_Api* api,\n                                         std::string message);\n \n+  static XLA_FFI_Error* FailedPrecondition(const XLA_FFI_Api* api,\n+                                           std::string message);\n+\n   static XLA_FFI_Error* CheckStructSize(const XLA_FFI_Api* api,\n                                         std::string_view struct_name,\n                                         size_t expected, size_t actual);\n@@ -384,6 +430,12 @@ inline XLA_FFI_Error* Ffi::InvalidArgument(const XLA_FFI_Api* api,\n                    std::move(message));\n }\n \n+inline XLA_FFI_Error* Ffi::FailedPrecondition(const XLA_FFI_Api* api,\n+                                              std::string message) {\n+  return MakeError(api, XLA_FFI_Error_Code_FAILED_PRECONDITION,\n+                   std::move(message));\n+}\n+\n inline XLA_FFI_Error* Ffi::CheckStructSize(const XLA_FFI_Api* api,\n                                            std::string_view struct_name,\n                                            size_t expected, size_t actual) {\n@@ -1211,6 +1263,7 @@ class RemainingArgsBase {\n   template <typename T>\n   bool isa(size_t index) const {\n     size_t idx = offset() + index;\n+    assert(idx < args_->size && \"illegal remaining args index\");\n     return ArgDecoding<T>::Isa(args_->types[idx], args_->args[idx]);\n   }\n \n@@ -1244,6 +1297,7 @@ class RemainingRetsBase {\n   template <typename T>\n   bool isa(size_t index) const {\n     size_t idx = offset_ + index;\n+    assert(idx < rets_->size && \"illegal remaining rets index\");\n     return RetDecoding<T>::Isa(rets_->types[idx], rets_->rets[idx]);\n   }\n \n@@ -1655,6 +1709,11 @@ class Handler : public Ffi {\n     // type id in the metadata.\n     using ResultEncoding = ResultEncoding<stage, ResultType>;\n     if constexpr (internal::is_state_constructor_v<ResultEncoding>) {\n+      if (ResultEncoding::state_type_id() == XLA_FFI_UNKNOWN_TYPE_ID) {\n+        return FailedPrecondition(api,\n+                                  \"Types used by FFI handlers must be \"\n+                                  \"registered before the handler registration\");\n+      }\n       extension->metadata->state_type_id = ResultEncoding::state_type_id();\n     } else {\n       extension->metadata->state_type_id = XLA_FFI_UNKNOWN_TYPE_ID;"
        },
        {
            "sha": "4d75e64a43fa3e0cdcbb72339647d6568b2217bf",
            "filename": "third_party/xla/xla/ffi/ffi_api.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 17,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e65144c31fba7e30ceb5bd100b0e922661bc8eb6/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e65144c31fba7e30ceb5bd100b0e922661bc8eb6/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc?ref=e65144c31fba7e30ceb5bd100b0e922661bc8eb6",
            "patch": "@@ -289,7 +289,7 @@ static XLA_FFI_CallFrame PrepareMetadataCallFrame(\n   return XLA_FFI_CallFrame{\n       XLA_FFI_CallFrame_STRUCT_SIZE,\n       &extension->extension_base,\n-      /*api=*/nullptr,\n+      /*api=*/GetXlaFfiApi(),\n       /*context=*/nullptr,\n       /*stage=*/XLA_FFI_ExecutionStage_EXECUTE,\n       /*args=*/XLA_FFI_Args{XLA_FFI_Args_STRUCT_SIZE},\n@@ -386,20 +386,6 @@ static std::vector<std::string> GetHandlerStages(\n   return stages;\n }\n \n-static bool CheckMetadata(const XLA_FFI_Metadata& a,\n-                          const XLA_FFI_Metadata& b) {\n-  return a.api_version.major_version == b.api_version.major_version &&\n-         a.api_version.minor_version == b.api_version.minor_version &&\n-         a.traits == b.traits &&\n-         a.state_type_id.type_id == b.state_type_id.type_id;\n-}\n-\n-static bool CheckHandlerBundle(const XLA_FFI_Handler_Bundle& a,\n-                               const XLA_FFI_Handler_Bundle& b) {\n-  return a.instantiate == b.instantiate && a.prepare == b.prepare &&\n-         a.initialize == b.initialize && a.execute == b.execute;\n-}\n-\n static absl::Status RegisterHandler(absl::string_view name,\n                                     absl::string_view platform,\n                                     XLA_FFI_Handler_Bundle bundle,\n@@ -455,13 +441,13 @@ static absl::Status RegisterHandler(absl::string_view name,\n   // long as we register exactly the same handler.\n   if (!emplaced) {\n     const HandlerRegistration& existing = it->second;\n-    if (!CheckMetadata(existing.metadata, metadata)) {\n+    if (existing.metadata != metadata) {\n       return InvalidArgument(\n           \"Duplicate FFI handler registration for %s on platform %s \"\n           \"(canonical %s) with different metadata: %v vs %v\",\n           name, platform, canonical_platform, existing.metadata, metadata);\n     }\n-    if (!CheckHandlerBundle(existing.bundle, bundle)) {\n+    if (existing.bundle != bundle) {\n       return InvalidArgument(\n           \"Duplicate FFI handler registration for %s on platform %s \"\n           \"(canonical %s) with different bundle addresses\","
        }
    ],
    "stats": {
        "total": 79,
        "additions": 62,
        "deletions": 17
    }
}