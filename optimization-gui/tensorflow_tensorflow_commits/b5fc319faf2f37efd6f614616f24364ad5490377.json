{
    "author": "ezhulenev",
    "message": "[xla:cpu] Add CpuDeviceMemory::Allocator to be able to customize memory allocation for CPU device buffers\n\nPiperOrigin-RevId: 802668212",
    "sha": "b5fc319faf2f37efd6f614616f24364ad5490377",
    "files": [
        {
            "sha": "77dce8d759d7e000e39820f3a3ce22d61d52888f",
            "filename": "third_party/xla/xla/pjrt/cpu/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b5fc319faf2f37efd6f614616f24364ad5490377/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b5fc319faf2f37efd6f614616f24364ad5490377/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD?ref=b5fc319faf2f37efd6f614616f24364ad5490377",
            "patch": "@@ -79,6 +79,7 @@ cc_library(\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n         \"@com_google_absl//absl/container:inlined_vector\",\n         \"@com_google_absl//absl/functional:any_invocable\",\n         \"@com_google_absl//absl/log\","
        },
        {
            "sha": "1310a6b1445702f72f3b33a48554ae980e2ce55a",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.cc",
            "status": "modified",
            "additions": 81,
            "deletions": 19,
            "changes": 100,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b5fc319faf2f37efd6f614616f24364ad5490377/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b5fc319faf2f37efd6f614616f24364ad5490377/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc?ref=b5fc319faf2f37efd6f614616f24364ad5490377",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include <utility>\n #include <vector>\n \n+#include \"absl/base/no_destructor.h\"\n #include \"absl/container/inlined_vector.h\"\n #include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n@@ -39,6 +40,7 @@ limitations under the License.\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n #include \"tsl/platform/casts.h\"\n #include \"tsl/platform/mem.h\"\n@@ -67,23 +69,68 @@ tsl::AsyncValueRef<CpuEvent> AfterAll(\n \n   return std::move(after_all).AsRef();\n }\n+\n+//===----------------------------------------------------------------------===//\n+// Default CpuDeviceMemory::RawMemory allocator.\n+//===----------------------------------------------------------------------===//\n+\n+class AlignedMemory final : public CpuDeviceMemory::RawMemory {\n+ public:\n+  AlignedMemory(void* base, size_t size_bytes)\n+      : base_(base), size_bytes_(size_bytes) {}\n+\n+  ~AlignedMemory() final {\n+    tsl::port::AlignedSizedFree(base_, cpu::MinAlign(), size_bytes_);\n+  }\n+\n+  void* base() const final { return base_; }\n+  size_t size_bytes() const final { return size_bytes_; }\n+\n+ private:\n+  void* base_;\n+  size_t size_bytes_;\n+};\n+\n+class AlignedAllocator final : public CpuDeviceMemory::Allocator {\n+ public:\n+  absl::StatusOr<std::unique_ptr<CpuDeviceMemory::RawMemory>> Allocate(\n+      size_t size_bytes, size_t alignment) const final {\n+    if (void* base = tsl::port::AlignedMalloc(size_bytes, alignment)) {\n+      return std::make_unique<AlignedMemory>(base, size_bytes);\n+    }\n+    return ResourceExhausted(\"Out of memory allocating %d bytes.\", size_bytes);\n+  }\n+};\n+\n }  // namespace\n \n+CpuDeviceMemory::Allocator& CpuDeviceMemory::DefaultAllocator() {\n+  static absl::NoDestructor<AlignedAllocator> allocator;\n+  return *allocator;\n+}\n+\n+//===----------------------------------------------------------------------===//\n+// CpuDeviceMemory implementations.\n+//===----------------------------------------------------------------------===//\n+\n class CpuDeviceMemoryOwned final : public CpuDeviceMemory {\n  public:\n-  CpuDeviceMemoryOwned(void* base, size_t size) : CpuDeviceMemory(base, size) {}\n+  explicit CpuDeviceMemoryOwned(std::unique_ptr<RawMemory> mem)\n+      : mem_(std::move(mem)) {}\n \n-  ~CpuDeviceMemoryOwned() final {\n-    CHECK_NE(untyped_data(), nullptr);\n-    tsl::port::AlignedSizedFree(untyped_data(), cpu::MinAlign(), size_bytes());\n-  }\n+  void* untyped_data() const final { return mem_->base(); }\n+  size_t size_bytes() const final { return mem_->size_bytes(); }\n+\n+ private:\n+  std::unique_ptr<RawMemory> mem_;\n };\n \n class CpuDeviceMemoryForeign final : public CpuDeviceMemory {\n  public:\n   CpuDeviceMemoryForeign(void* base, size_t size,\n                          absl::AnyInvocable<void() &&> on_delete_callback)\n-      : CpuDeviceMemory(base, size),\n+      : base_(base),\n+        size_bytes_(size),\n         on_delete_callback_(std::move(on_delete_callback)) {}\n \n   ~CpuDeviceMemoryForeign() final {\n@@ -92,14 +139,26 @@ class CpuDeviceMemoryForeign final : public CpuDeviceMemory {\n     }\n   }\n \n+  void* untyped_data() const final { return base_; }\n+  size_t size_bytes() const final { return size_bytes_; }\n+\n  private:\n+  void* base_;\n+  size_t size_bytes_;\n   absl::AnyInvocable<void() &&> on_delete_callback_;\n };\n \n class CpuDeviceMemoryConstant final : public CpuDeviceMemory {\n  public:\n   CpuDeviceMemoryConstant(void* base, size_t size)\n-      : CpuDeviceMemory(base, size) {}\n+      : base_(base), size_bytes_(size) {}\n+\n+  void* untyped_data() const final { return base_; }\n+  size_t size_bytes() const final { return size_bytes_; }\n+\n+ private:\n+  void* base_;\n+  size_t size_bytes_;\n };\n \n tsl::AsyncValueRef<CpuDeviceMemory> CpuDeviceMemory::CreateDelayedMemory() {\n@@ -119,27 +178,30 @@ tsl::AsyncValueRef<CpuDeviceMemory> CpuDeviceMemory::CreateConstantMemory(\n \n // Allocates owning memory wrapped in an available `AsyncValueRef`.\n absl::StatusOr<tsl::AsyncValueRef<CpuDeviceMemory>> CpuDeviceMemory::Allocate(\n-    size_t size_bytes) {\n-  if (void* data = tsl::port::AlignedMalloc(size_bytes, cpu::MinAlign())) {\n-    return tsl::MakeAvailableAsyncValueRef<CpuDeviceMemoryOwned>(data,\n-                                                                 size_bytes);\n-  }\n-  return ResourceExhausted(\"Out of memory allocating %d bytes.\", size_bytes);\n+    size_t size_bytes, const Allocator& allocator) {\n+  TF_ASSIGN_OR_RETURN(std::unique_ptr<RawMemory> mem,\n+                      allocator.Allocate(size_bytes, cpu::MinAlign()));\n+  return tsl::MakeAvailableAsyncValueRef<CpuDeviceMemoryOwned>(std::move(mem));\n }\n \n absl::Status CpuDeviceMemory::AllocateInto(\n-    size_t size_bytes, tsl::AsyncValuePtr<CpuDeviceMemory> delayed_memory) {\n+    size_t size_bytes, tsl::AsyncValuePtr<CpuDeviceMemory> delayed_memory,\n+    const Allocator& allocator) {\n   auto owned_memory = delayed_memory.DynCast<CpuDeviceMemoryOwned>();\n   if (!owned_memory) {\n     return Internal(\"Delayed memory is not a CpuDeviceMemoryOwned\");\n   }\n-  if (void* data = tsl::port::AlignedMalloc(size_bytes, cpu::MinAlign())) {\n-    owned_memory.emplace(data, size_bytes);\n-    return absl::OkStatus();\n-  }\n-  return ResourceExhausted(\"Out of memory allocating %d bytes.\", size_bytes);\n+\n+  TF_ASSIGN_OR_RETURN(std::unique_ptr<RawMemory> mem,\n+                      allocator.Allocate(size_bytes, cpu::MinAlign()));\n+  owned_memory.emplace(std::move(mem));\n+  return absl::OkStatus();\n }\n \n+//===----------------------------------------------------------------------===//\n+// TrackedCpuDeviceBuffer.\n+//===----------------------------------------------------------------------===//\n+\n TrackedCpuDeviceBuffer::TrackedCpuDeviceBuffer(\n     bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n     absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events)"
        },
        {
            "sha": "99582c77b49776f0cd603d2e17a391de120d3849",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.h",
            "status": "modified",
            "additions": 66,
            "deletions": 8,
            "changes": 74,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b5fc319faf2f37efd6f614616f24364ad5490377/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b5fc319faf2f37efd6f614616f24364ad5490377/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h?ref=b5fc319faf2f37efd6f614616f24364ad5490377",
            "patch": "@@ -18,6 +18,8 @@ limitations under the License.\n \n #include <cstddef>\n #include <cstdlib>\n+#include <memory>\n+#include <vector>\n \n #include \"absl/container/inlined_vector.h\"\n #include \"absl/functional/any_invocable.h\"\n@@ -26,21 +28,49 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"xla/pjrt/abstract_tracked_device_buffer.h\"\n #include \"xla/pjrt/cpu/cpu_event.h\"\n+#include \"xla/pjrt/device_event.h\"\n+#include \"xla/pjrt/pjrt_future.h\"\n+#include \"xla/pjrt/raw_buffer.h\"\n+#include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n \n // A region of device memory that can be used to construct PjRt buffers. Device\n // memory can be either owned or non-owned.\n+//\n+// CpuDeviceMemory has an asynchronous memory allocation semantics, as the size\n+// of the allocation might depend on a result of another computation (pending\n+// async value), and must be delayed until the async value becomes available.\n+//\n+// Synchronous allocations of the raw memory (same semantics as `aligned_malloc`\n+// and `free`) is handled via the `CpuDeviceMemory::Allocator` interface.\n+//\n+// Types of CpuDeviceMemory:\n+//\n+//   OWNED:    raw memory was allocated for the CpuDeviceMemory and will be\n+//             freed when when CpuDeviceMemory is destroyed.\n+//\n+//   FOREIGN:  raw memory was allocated by another entity (i.e. it can be a view\n+//             into a buffer owned by a different runtime) and the owner will be\n+//             notified via the on_delete_callback when CpuDeviceMemory is\n+//             destroyed.\n+//\n+//   CONSTANT: raw memory has a lifetime that is not bound to the\n+//             CpuDeviceMemory (i.e. a global static).\n+//\n class CpuDeviceMemory {\n  public:\n+  class Allocator;\n+\n   virtual ~CpuDeviceMemory() = default;\n \n   CpuDeviceMemory(const CpuDeviceMemory&) = delete;\n   CpuDeviceMemory& operator=(const CpuDeviceMemory&) = delete;\n \n-  void* untyped_data() const { return base_; }\n-  size_t size_bytes() const { return size_bytes_; }\n+  virtual void* untyped_data() const = 0;\n+  virtual size_t size_bytes() const = 0;\n \n   // Creates an unavailable AsyncValueRef placeholder for a delayed\n   // memory allocation (see `AllocateInto` below).\n@@ -59,18 +89,46 @@ class CpuDeviceMemory {\n \n   // Allocates owning memory wrapped in an available `AsyncValueRef`.\n   static absl::StatusOr<tsl::AsyncValueRef<CpuDeviceMemory>> Allocate(\n-      size_t size_bytes);\n+      size_t size_bytes, const Allocator& allocator = DefaultAllocator());\n \n   // Allocates owning memory into the previously created delayed memory\n   // placeholder (see `CreateDelayedMemory` above).\n   static absl::Status AllocateInto(\n-      size_t size_bytes, tsl::AsyncValuePtr<CpuDeviceMemory> delayed_memory);\n+      size_t size_bytes, tsl::AsyncValuePtr<CpuDeviceMemory> delayed_memory,\n+      const Allocator& allocator = DefaultAllocator());\n+\n+  //===--------------------------------------------------------------------===//\n+  // Custom raw memory allocation APIs.\n+  //===--------------------------------------------------------------------===//\n+\n+  // Default allocator uses aligned allocation and free APIs from tsl.\n+  static Allocator& DefaultAllocator();\n+\n+  // A raw memory allocation that can be used to construct a CpuDeviceMemory.\n+  class RawMemory {\n+   public:\n+    virtual ~RawMemory() = default;\n+    virtual void* base() const = 0;\n+    virtual size_t size_bytes() const = 0;\n+  };\n+\n+  // A raw memory allocator that allocates memory buffers for constructing\n+  // CpuDeviceMemory.\n+  //\n+  // This is a virtual interface to allow for different memory allocation\n+  // strategies, e.g. aligned_alloc, pre-mapped DMA buffers, etc. For example,\n+  // when XLA:CPU is running as a part of host-offloading computation, we want\n+  // all buffers used by XLA:CPU to be pre-mapped with the accelerator device,\n+  // so that we can issue zero-copy DMA transfers operations if needed.\n+  class Allocator {\n+   public:\n+    virtual ~Allocator() = default;\n+    virtual absl::StatusOr<std::unique_ptr<RawMemory>> Allocate(\n+        size_t size_bytes, size_t alignment) const = 0;\n+  };\n \n  protected:\n-  CpuDeviceMemory(void* base, size_t size) : base_(base), size_bytes_(size) {}\n-\n-  void* base_;\n-  size_t size_bytes_;\n+  CpuDeviceMemory() = default;\n };\n \n // A class that represents a CPU device buffer: it can be a single memory region"
        }
    ],
    "stats": {
        "total": 175,
        "additions": 148,
        "deletions": 27
    }
}