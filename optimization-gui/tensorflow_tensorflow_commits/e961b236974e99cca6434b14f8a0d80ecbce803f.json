{
    "author": "vsytch",
    "message": "[XLA] Continue trying to unroll pipelined loops after failure\n\nPiperOrigin-RevId: 846839467",
    "sha": "e961b236974e99cca6434b14f8a0d80ecbce803f",
    "files": [
        {
            "sha": "d42050eb0f5a2af0a583bc34ad28856e94dc3465",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e961b236974e99cca6434b14f8a0d80ecbce803f/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e961b236974e99cca6434b14f8a0d80ecbce803f/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=e961b236974e99cca6434b14f8a0d80ecbce803f",
            "patch": "@@ -6100,14 +6100,14 @@ cc_library(\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/hlo/transforms/simplifiers:flatten_call_graph\",\n         \"//xla/hlo/transforms/simplifiers:hlo_dce\",\n+        \"//xla/tsl/platform:status_macros\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/strings:string_view\",\n-        \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n \n@@ -6122,7 +6122,6 @@ xla_cc_test(\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:test_helpers\",\n-        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/container:inlined_vector\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\","
        },
        {
            "sha": "537220e28e543ed76f3c0e3beacbd92e619c6675",
            "filename": "third_party/xla/xla/service/while_loop_pipeline_unroller.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e961b236974e99cca6434b14f8a0d80ecbce803f/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_pipeline_unroller.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e961b236974e99cca6434b14f8a0d80ecbce803f/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_pipeline_unroller.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_pipeline_unroller.cc?ref=e961b236974e99cca6434b14f8a0d80ecbce803f",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n@@ -34,8 +35,7 @@ limitations under the License.\n #include \"xla/hlo/transforms/simplifiers/flatten_call_graph.h\"\n #include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n #include \"xla/service/while_util.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/status_macros.h\"\n \n namespace xla {\n /*static*/\n@@ -125,8 +125,9 @@ absl::StatusOr<bool> WhileLoopPipelineUnroller::RunImpl(\n     }\n   }\n \n-  std::vector<HloInstruction*> original_roots;\n   for (auto&& [while_instruction, unroll_factor] : while_instructions) {\n+    VLOG(1) << \"Unrolling: \" << while_instruction->name()\n+            << \" unroll_factor: \" << unroll_factor;\n     HloComputation* body = while_instruction->while_body();\n     HloComputation* condition = while_instruction->while_condition();\n \n@@ -138,16 +139,15 @@ absl::StatusOr<bool> WhileLoopPipelineUnroller::RunImpl(\n         b.AddInstruction(HloInstruction::CreateParameter(\n             0, while_instruction->shape(), \"input_tuple\"));\n     HloComputation* unrolled_body = module->AddEmbeddedComputation(b.Build());\n+    HloInstruction* unrolled_root = input_tuple;\n     for (int64_t step = 0; step < unroll_factor; ++step) {\n       HloComputation* loop_step = module->AddEmbeddedComputation(body->Clone(\n           absl::StrFormat(\"unrolled_%dx_step_%d\", unroll_factor, step)));\n       input_tuple = unrolled_body->AddInstruction(HloInstruction::CreateCall(\n           while_instruction->shape(), {input_tuple}, loop_step));\n-      original_roots.push_back(input_tuple);\n+      unrolled_root = input_tuple;\n     }\n     // The final original root is now the root of the unrolled loop.\n-    HloInstruction* unrolled_root = original_roots.back();\n-    original_roots.pop_back();\n     unrolled_body->set_root_instruction(unrolled_root);\n \n     // We need the unrolled loop and the remainder (original) loop to execute\n@@ -167,12 +167,16 @@ absl::StatusOr<bool> WhileLoopPipelineUnroller::RunImpl(\n         while_instruction->parent()->AddInstruction(HloInstruction::CreateWhile(\n             while_instruction->shape(), unrolled_condition, body,\n             while_instruction->mutable_operand(0)));\n-    TF_RETURN_IF_ERROR(WhileUtil::IncrementWhileLoopTripCount(\n-        *unrolled_while_instruction, -(unroll_factor - 1)));\n+    absl::Status status = WhileUtil::IncrementWhileLoopTripCount(\n+        *unrolled_while_instruction, -(unroll_factor - 1));\n     unrolled_while_instruction->set_while_body(unrolled_body);\n \n-    TF_RETURN_IF_ERROR(\n-        while_instruction->ReplaceOperandWith(0, unrolled_while_instruction));\n+    if (status.ok()) {\n+      RETURN_IF_ERROR(\n+          while_instruction->ReplaceOperandWith(0, unrolled_while_instruction));\n+    } else {\n+      VLOG(1) << \"Failed to unroll: \" << while_instruction->name();\n+    }\n   }\n \n   const bool changed = !while_instructions.empty();\n@@ -181,9 +185,9 @@ absl::StatusOr<bool> WhileLoopPipelineUnroller::RunImpl(\n     // recursively clone all the nested computations. FCG will take care of this\n     // for us.\n     FlattenCallGraph fcg;\n-    TF_RETURN_IF_ERROR(fcg.Run(module).status());\n+    RETURN_IF_ERROR(fcg.Run(module).status());\n     HloDCE dce;\n-    TF_RETURN_IF_ERROR(dce.Run(module).status());\n+    RETURN_IF_ERROR(dce.Run(module).status());\n   }\n \n   return changed;"
        },
        {
            "sha": "b1ce4e66e25fe99b7d700aafaa902260ed1e9069",
            "filename": "third_party/xla/xla/service/while_loop_pipeline_unroller_test.cc",
            "status": "modified",
            "additions": 102,
            "deletions": 3,
            "changes": 105,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e961b236974e99cca6434b14f8a0d80ecbce803f/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_pipeline_unroller_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e961b236974e99cca6434b14f8a0d80ecbce803f/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_pipeline_unroller_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_pipeline_unroller_test.cc?ref=e961b236974e99cca6434b14f8a0d80ecbce803f",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n \n #include <cstdint>\n \n+#include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/container/inlined_vector.h\"\n #include \"absl/strings/string_view.h\"\n@@ -27,7 +28,6 @@ limitations under the License.\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/test_helpers.h\"\n #include \"xla/service/copy_insertion.h\"\n-#include \"xla/tsl/platform/statusor.h\"\n \n namespace xla {\n namespace {\n@@ -78,7 +78,7 @@ ENTRY main {\n   ROOT while.0 = (s32[], s32[], s32[], s32[]) while(while_tuple.0), body=body, condition=condition\n }\n   )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n   WhileLoopPipelineUnroller wlpu;\n   ASSERT_IS_OK(wlpu.Run(module.get()).status());\n   AliasInfo alias_info;\n@@ -147,7 +147,7 @@ ENTRY main {\n   ROOT root.0 = get-tuple-element(while.0), index=0\n }\n   )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n   WhileLoopPipelineUnroller wlpu;\n   ASSERT_IS_OK(wlpu.Run(module.get()).status());\n   AliasInfo alias_info;\n@@ -186,5 +186,104 @@ ENTRY main {\n   }\n }\n \n+TEST_F(WhileLoopPipelineUnrollerTest, FailureRecovery) {\n+  constexpr absl::string_view hlo = R\"hlo(\n+HloModule main\n+\n+body {\n+  input_tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+  arg.0 = get-tuple-element(input_tuple.0), index=0\n+  arg.1 = get-tuple-element(input_tuple.0), index=1\n+  arg.2 = get-tuple-element(input_tuple.0), index=2\n+  arg.3 = get-tuple-element(input_tuple.0), index=3\n+\n+  one.0 = s32[] constant(1)\n+  out.0 = add(arg.0, one.0)\n+\n+  add.0 = add(arg.3, one.0)\n+  ROOT output_tuple.0 = tuple(arg.1, arg.2, out.0, add.0)\n+}\n+\n+condition {\n+  input_tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+  arg.3 = get-tuple-element(input_tuple.0), index=3\n+  three.0 = s32[] constant(3)\n+  ROOT pred.0 = compare(arg.3, three.0), direction=LT\n+}\n+\n+ENTRY main {\n+  tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+  while-pass.0 = (s32[], s32[], s32[], s32[]) while(tuple.0), body={\n+    tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+    arg.0 = get-tuple-element(tuple.0), index=0\n+    arg.1 = get-tuple-element(tuple.0), index=1\n+    arg.2 = get-tuple-element(tuple.0), index=2\n+    arg.3 = get-tuple-element(tuple.0), index=3\n+\n+    one.0 = s32[] constant(1)\n+    add.0 = add(arg.0, one.0)\n+\n+    add.1 = add(arg.3, one.0)\n+    ROOT output_tuple.0 = tuple(arg.1, arg.2, add.0, add.1)\n+  }, condition={\n+    tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+    arg.3 = get-tuple-element(tuple.0), index=3\n+    three.0 = s32[] constant(3)\n+    ROOT pred.0 = compare(arg.3, three.0), direction=LT\n+  }\n+  ROOT while-fail.0 = (s32[], s32[], s32[], s32[]) while(while-pass.0), body={\n+    tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+    arg.0 = get-tuple-element(tuple.0), index=0\n+    arg.1 = get-tuple-element(tuple.0), index=1\n+    arg.2 = get-tuple-element(tuple.0), index=2\n+    arg.3 = get-tuple-element(tuple.0), index=3\n+\n+    one.0 = s32[] constant(1)\n+    add.0 = add(arg.0, one.0)\n+\n+    add.1 = add(arg.3, one.0)\n+    ROOT output_tuple.0 = tuple(arg.1, arg.2, add.0, add.1)\n+  }, condition={\n+    tuple.0 = (s32[], s32[], s32[], s32[]) parameter(0)\n+    arg.3 = get-tuple-element(tuple.0), index=3\n+    three.0 = s32[] constant(3)\n+    pred.0 = compare(arg.3, three.0), direction=LT\n+    true.0 = pred[] constant(true)\n+    ROOT and.0 = and(pred.0, true.0)\n+  }\n+}\n+  )hlo\";\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hlo));\n+  WhileLoopPipelineUnroller wlpu;\n+  ASSERT_IS_OK(wlpu.Run(module.get()).status());\n+  AliasInfo alias_info;\n+  CopyInsertion copy_insertion(&alias_info,\n+                               /*use_region_based_live_range_analysis=*/-1);\n+  ASSERT_IS_OK(copy_insertion.Run(module.get()).status());\n+\n+  const HloInstruction* pass_original_loop =\n+      FindInstruction(module.get(), \"while-pass.0\");\n+  // The rolled passing loop should have 3 copies.\n+  // arg.1 moves to index 0.\n+  // arg.2 moves to index 1.\n+  // out.0 moves to index 2.\n+  EXPECT_EQ(Count(HloOpcode::kCopy, *pass_original_loop->while_body()), 3);\n+\n+  const HloInstruction* unrolled_loop = pass_original_loop->operand(0);\n+  ASSERT_EQ(unrolled_loop->opcode(), HloOpcode::kWhile);\n+  // There should be no copies inserted into the unrolled loop.\n+  EXPECT_EQ(Count(HloOpcode::kCopy, *unrolled_loop->while_body()), 0);\n+\n+  const HloInstruction* fail_loop =\n+      FindInstruction(module.get(), \"while-fail.0\");\n+  // The rolled failing loop should have 3 copies.\n+  // arg.1 moves to index 0.\n+  // arg.2 moves to index 1.\n+  // out.0 moves to index 2.\n+  EXPECT_EQ(Count(HloOpcode::kCopy, *fail_loop->while_body()), 3);\n+  // The failing loop should not have been unrolled.\n+  EXPECT_EQ(fail_loop->users().size(), 0);\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 138,
        "additions": 120,
        "deletions": 18
    }
}