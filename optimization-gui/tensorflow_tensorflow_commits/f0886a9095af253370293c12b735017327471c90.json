{
    "author": "hyeontaek",
    "message": "[IFRT Proxy] Support `UserContext` propagation\n\nThis change adds support for IFRT `UserContext` to the IFRT Proxy. It\nconsists of a few parts:\n\n* IFRT Proxy client captures the current `UserContext` ID and sends it\n  in every request.\n* IFRT Proxy client keeps the current `UserContext` in a form of\n  `TrackedUserContext` until a response arrive. If the response is OK,\n  it persists `TrackedUserContext`, until a matching user context is\n  destroyed in the backend side. If the response contains an error, any\n  user context mentioned in the status payload will be re-attached using\n  the local `TrackedUserContext`s. Any new `TrackedUserContext` used for\n  the request will not be persisted.\n\n* IFRT Proxy server creates a local `IfrtBackendUserContext` whose ID\n  matches that put into the reuqest.\n* When `IfrtBackendUserContext` is destroyed by a local IFRT client, its\n  ID is recorded in the IFRT Proxy server. The recorded IDs are sent back to\n  the IFRT Proxy client as a batch in the next response (opportunistic\n  batching with no timeout).\n* Some part of the in-flight response messages from the IFRT Proxy server may be processed out of order within the IFRT Proxy client because the client uses OnReady callbacks to handle responses and these callbacks may run in a different order from the response order. To avoid prematurely dropping references to the IFRT Proxy client-side `UserContext`, each response is numbered with a strictly monotonely (dense) increasing sequence number, and this sequence number is used to delay the dereference until all earlier responses have been processed.\n\nPiperOrigin-RevId: 835297930",
    "sha": "f0886a9095af253370293c12b735017327471c90",
    "files": [
        {
            "sha": "4e78fc0dd14ae2dffcad976ce8034234afde7314",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -103,15 +103,21 @@ cc_library(\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:serdes_any_version_accessor\",\n         \"//xla/python/ifrt:serdes_version\",\n+        \"//xla/python/ifrt:user_context\",\n+        \"//xla/python/ifrt:user_context_registry\",\n+        \"//xla/python/ifrt:user_context_status_util\",\n         \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n         \"//xla/python/ifrt_proxy/common:prof_util\",\n+        \"//xla/python/ifrt_proxy/common:proto_util\",\n         \"//xla/python/ifrt_proxy/common:test_utils\",\n         \"//xla/python/ifrt_proxy/common:types\",\n         \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:status_to_from_proto\",\n         \"//xla/tsl/profiler/utils:xplane_schema\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:btree\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/functional:any_invocable\",\n         \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/functional:function_ref\",\n@@ -122,6 +128,7 @@ cc_library(\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/time\",\n+        \"@com_google_absl//absl/types:span\",\n         \"@local_tsl//tsl/platform:env\",\n         \"@local_tsl//tsl/platform:random\",\n         \"@local_tsl//tsl/platform:status_to_from_proto\",\n@@ -364,6 +371,7 @@ cc_library(\n         \"//xla/pjrt:host_callback\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:serdes\",\n+        \"//xla/python/ifrt:user_context_status_util\",\n         \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n         \"//xla/python/ifrt_proxy/common:versions\",\n         \"//xla/python/ifrt_proxy/server:host_callback\",\n@@ -440,6 +448,7 @@ cc_library(\n         \"//xla/python/ifrt:attribute_map\",\n         \"//xla/python/ifrt:sharding_serdes\",\n         \"//xla/python/ifrt:user_context\",\n+        \"//xla/python/ifrt:user_context_status_util\",\n         \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n         \"//xla/python/ifrt_proxy/common:types\",\n         \"//xla/python/ifrt_proxy/common:versions\","
        },
        {
            "sha": "cdfa23f0f6d5fd56c0a74b237f8bb379b90e5a93",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/compiler.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.cc?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -36,6 +36,7 @@\n #include \"xla/python/ifrt/program.h\"\n #include \"xla/python/ifrt/serdes.h\"\n #include \"xla/python/ifrt/topology.h\"\n+#include \"xla/python/ifrt/user_context_status_util.h\"\n #include \"xla/python/ifrt_proxy/client/executable.h\"\n #include \"xla/python/ifrt_proxy/client/rpc_helper.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n@@ -145,7 +146,8 @@ absl::StatusOr<xla::ifrt::LoadedExecutableRef> Compiler::CompileAndLoad(\n       fingerprint = response->fingerprint_value();\n       break;\n     case CompileResponse::kFingerprintError:\n-      fingerprint = tsl::StatusFromProto(response->fingerprint_error());\n+      fingerprint = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto(response->fingerprint_error()));\n       break;\n     default:\n       fingerprint = std::nullopt;"
        },
        {
            "sha": "54d0e508c76fee431e28209957fa5e821447adb2",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/executable.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -54,6 +54,7 @@\n #include \"xla/python/ifrt/shape.h\"\n #include \"xla/python/ifrt/sharding.h\"\n #include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt/user_context_status_util.h\"\n #include \"xla/python/ifrt_proxy/client/array.h\"\n #include \"xla/python/ifrt_proxy/client/host_buffer.h\"\n #include \"xla/python/ifrt_proxy/client/rpc_helper.h\"\n@@ -420,8 +421,8 @@ LoadedExecutable::LoadedExecutable(\n       info->parameter_layouts =\n           parse_layouts(response.value()->parameter_layouts_list());\n     } else if (response.value()->has_parameter_layouts_error()) {\n-      info->parameter_layouts =\n-          tsl::StatusFromProto(response.value()->parameter_layouts_error());\n+      info->parameter_layouts = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto(response.value()->parameter_layouts_error()));\n     } else {\n       info->parameter_layouts = absl::UnimplementedError(\n           \"IFRT Proxy server did not return parameter layouts\");\n@@ -430,8 +431,8 @@ LoadedExecutable::LoadedExecutable(\n       info->output_layouts =\n           parse_layouts(response.value()->output_layouts_list());\n     } else if (response.value()->has_output_layouts_error()) {\n-      info->output_layouts =\n-          tsl::StatusFromProto(response.value()->output_layouts_error());\n+      info->output_layouts = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto(response.value()->output_layouts_error()));\n     } else {\n       info->output_layouts = absl::UnimplementedError(\n           \"IFRT Proxy server did not return output layouts\");\n@@ -442,7 +443,8 @@ LoadedExecutable::LoadedExecutable(\n           response.value()->compiled_memory_stats());\n     } else if (response.value()->has_compiled_memory_stats_error()) {\n       info->compiled_memory_stats =\n-          tsl::StatusFromProto(response.value()->compiled_memory_stats_error());\n+          xla::ifrt::ReattachUserContextRefs(tsl::StatusFromProto(\n+              response.value()->compiled_memory_stats_error()));\n     } else {\n       info->compiled_memory_stats = absl::UnimplementedError(\n           \"IFRT Proxy server did not return compiled memory stats\");\n@@ -451,8 +453,9 @@ LoadedExecutable::LoadedExecutable(\n     info->size_of_generated_code_in_bytes =\n         response.value()->size_of_generated_code_in_bytes();\n \n-    if (const absl::Status s = tsl::StatusFromProto(\n-            response.value()->output_memory_kinds().status());\n+    if (const absl::Status s =\n+            xla::ifrt::ReattachUserContextRefs(tsl::StatusFromProto(\n+                response.value()->output_memory_kinds().status()));\n         !s.ok()) {\n       info->output_memory_kinds = s;\n     } else {\n@@ -485,7 +488,8 @@ LoadedExecutable::LoadedExecutable(\n                                    info->donatable_input_indices->end());\n     } else if (response.value()->has_donated_input_indices_error()) {\n       info->donatable_input_indices =\n-          tsl::StatusFromProto(response.value()->donated_input_indices_error());\n+          xla::ifrt::ReattachUserContextRefs(tsl::StatusFromProto(\n+              response.value()->donated_input_indices_error()));\n     } else {\n       info->donatable_input_indices = absl::UnimplementedError(\n           \"IFRT Proxy server did not return donated input indices\");\n@@ -643,8 +647,8 @@ absl::StatusOr<xla::ifrt::AttributeMap> LoadedExecutable::GetCostAnalysis()\n       cost_analysis_response_ =\n           AttributeMap::FromProto(response.value()->attributes());\n     } else {\n-      cost_analysis_response_ =\n-          tsl::StatusFromProto(response.value()->status());\n+      cost_analysis_response_ = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto(response.value()->status()));\n     }\n   }\n   return *cost_analysis_response_;\n@@ -680,8 +684,8 @@ absl::StatusOr<std::string> LoadedExecutable::GetHumanReadableProgramText()\n     } else if ((*response)->has_human_readable_program_text()) {\n       human_readable_program_text_ = (*response)->human_readable_program_text();\n     } else {\n-      human_readable_program_text_ =\n-          tsl::StatusFromProto((*response)->status());\n+      human_readable_program_text_ = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto((*response)->status()));\n     }\n   }\n   return *human_readable_program_text_;"
        },
        {
            "sha": "3cf34a97508166344ea6a84f1ba5d7c80c556381",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper.cc",
            "status": "modified",
            "additions": 137,
            "deletions": 7,
            "changes": 144,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -23,6 +23,9 @@\n #include <vector>\n \n #include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/btree_map.h\"\n+#include \"absl/container/btree_set.h\"\n+#include \"absl/container/flat_hash_map.h\"\n #include \"absl/functional/bind_front.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n@@ -33,6 +36,9 @@\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt/user_context_registry.h\"\n+#include \"xla/python/ifrt/user_context_status_util.h\"\n #include \"xla/python/ifrt_proxy/client/client_session.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n #include \"xla/python/ifrt_proxy/common/prof_util.h\"\n@@ -95,6 +101,80 @@ class BatchedOps {\n       batched_ ABSL_GUARDED_BY(mu_);\n };\n \n+// Tracks user contexts referenced by the proxy server.\n+class UserContextsReferencedByProxyServer {\n+ public:\n+  // Registers a user context referenced by the proxy server. If a user context\n+  // with the same ID is already registered, increments its ref count.\n+  void RegisterUserContext(TrackedUserContextRef tracked_user_context) {\n+    if (tracked_user_context == nullptr) {\n+      return;\n+    }\n+    absl::MutexLock l(mu_);\n+    UserContextId user_context_id = tracked_user_context->user_context()->Id();\n+    auto [it, inserted] = user_contexts_.insert(\n+        {user_context_id,\n+         TrackedUserContextRefWithRefCount{std::move(tracked_user_context)}});\n+    ++it->second.ref_count;\n+  }\n+\n+  // Schedules to decrement the ref count of user contexts referenced by the\n+  // proxy server once all responses before/on `seq_num` have been processed.\n+  // Once the ref count reaches 0, the user context is unregistered.\n+  void ScheduleToUnregisterUserContexts(\n+      int64_t seq_num, std::vector<UserContextId> user_context_ids) {\n+    absl::MutexLock l(mu_);\n+    pending_unregistration_.insert({seq_num, std::move(user_context_ids)});\n+  }\n+\n+  // Informs that a response with the given `seq_num` has been processed. User\n+  // context unregistration will happen for all responses with a range\n+  // [`seq_num`, ...,  N] that is contiguous and stop at any gap indicating a\n+  // response that has not been processed yet.\n+  void DoneProcessingResponse(int64_t seq_num) {\n+    // Collect user contexts to erase outside of the lock when we return from\n+    // this method.\n+    std::vector<xla::ifrt::TrackedUserContextRef> user_contexts_to_erase;\n+\n+    absl::MutexLock l(mu_);\n+    pending_seq_nums_.insert(seq_num);\n+    while (!pending_seq_nums_.empty() &&\n+           *pending_seq_nums_.begin() == next_seq_num_to_process_) {\n+      auto node = pending_unregistration_.extract(next_seq_num_to_process_);\n+      for (UserContextId user_context_id : node.mapped()) {\n+        auto it = user_contexts_.find(UserContextId(user_context_id));\n+        CHECK(it != user_contexts_.end());\n+        if (--it->second.ref_count == 0) {\n+          user_contexts_to_erase.push_back(\n+              std::move(it->second.tracked_user_context));\n+          user_contexts_.erase(it);\n+        }\n+      }\n+      pending_seq_nums_.erase(pending_seq_nums_.begin());\n+      ++next_seq_num_to_process_;\n+    }\n+  }\n+\n+ private:\n+  struct TrackedUserContextRefWithRefCount {\n+    TrackedUserContextRef tracked_user_context;\n+    // Multiple instances of UserContext may be created on the proxy server\n+    // for the same `UserContextId`. To ensure that we keep the user context\n+    // alive as long as any of its instances are alive on the proxy server,\n+    // we keep track of the number of references to each `UserContextId` on\n+    // the proxy server.\n+    int ref_count = 0;\n+  };\n+\n+  absl::Mutex mu_;\n+  absl::flat_hash_map<UserContextId, TrackedUserContextRefWithRefCount>\n+      user_contexts_ ABSL_GUARDED_BY(mu_);\n+  int64_t next_seq_num_to_process_ ABSL_GUARDED_BY(mu_) = 0;\n+  absl::btree_set<int64_t> pending_seq_nums_ ABSL_GUARDED_BY(mu_);\n+  absl::flat_hash_map<int64_t, std::vector<UserContextId>>\n+      pending_unregistration_ ABSL_GUARDED_BY(mu_);\n+};\n+\n }  // namespace\n \n // Batches any requested operations and flushes them periodically in the\n@@ -104,7 +184,9 @@ class BatchedOps {\n class RpcHelper::Batcher {\n  public:\n   explicit Batcher(std::shared_ptr<ClientSession> session)\n-      : session_(std::move(session)) {\n+      : session_(std::move(session)),\n+        user_contexts_referenced_by_proxy_server_(\n+            std::make_shared<UserContextsReferencedByProxyServer>()) {\n     thread_pool_.emplace(tsl::Env::Default(), \"IfrtProxyRpcHelperBatcher\",\n                          /*num_threads=*/1);\n     thread_pool_->Schedule(absl::bind_front(&Batcher::PeriodicFlusher, this));\n@@ -153,6 +235,11 @@ class RpcHelper::Batcher {\n     LOG(INFO) << \"RpcHelper::Batcher::Finish(): done.\";\n   }\n \n+  std::shared_ptr<UserContextsReferencedByProxyServer>\n+  user_contexts_referenced_by_proxy_server() {\n+    return user_contexts_referenced_by_proxy_server_;\n+  }\n+\n  private:\n   void PeriodicFlusher() {\n     while (true) {\n@@ -226,6 +313,12 @@ class RpcHelper::Batcher {\n   }\n \n   const std::shared_ptr<ClientSession> session_;\n+  // Tracks user contexts referenced by the proxy server. Uses a shared pointer\n+  // because the reference to `UserContextsReferencedByProxyServer` is captured\n+  // in OnReady callbacks and may outlive the `RpcHelper::Batcher` in a certain\n+  // situation (e.g., when the proxy client is destroyed).\n+  const std::shared_ptr<UserContextsReferencedByProxyServer>\n+      user_contexts_referenced_by_proxy_server_;\n \n   BatchedOps batched_;\n \n@@ -251,9 +344,25 @@ tsl::Future<std::shared_ptr<Resp>> DoRpc(RpcHelper::Batcher* batcher,\n   XFlowHelper x_flow_helper(profiling_name);\n   auto traceme = x_flow_helper.Span<XFlowHelper::kSend>();\n \n+  std::shared_ptr<UserContextsReferencedByProxyServer>\n+      user_contexts_referenced_by_proxy_server =\n+          batcher->user_contexts_referenced_by_proxy_server();\n+\n+  const UserContextRef& user_context = UserContextScope::current();\n+  if (user_context != nullptr && user_context->Id() != UserContextId(0)) {\n+    ifrt_req->mutable_request_metadata()->set_user_context_id(\n+        user_context->Id().value());\n+    TrackedUserContextRef tracked_user_context =\n+        UserContextRegistry::Get().Register(user_context);\n+    user_contexts_referenced_by_proxy_server->RegisterUserContext(\n+        std::move(tracked_user_context));\n+  }\n+\n   auto [promise, future] = tsl::Future<std::shared_ptr<Resp>>::MakePromise();\n-  auto on_ready = [promise = std::move(promise), has_resp, get_resp,\n-                   profiling_name, x_flow_helper](\n+  auto on_ready = [promise = std::move(promise),\n+                   user_contexts_referenced_by_proxy_server =\n+                       std::move(user_contexts_referenced_by_proxy_server),\n+                   has_resp, get_resp, profiling_name, x_flow_helper](\n                       absl::StatusOr<std::shared_ptr<IfrtResponse>> r) mutable {\n     if (!r.ok()) {\n       VLOG(3) << profiling_name << \" response: \" << r.status();\n@@ -274,8 +383,8 @@ tsl::Future<std::shared_ptr<Resp>> DoRpc(RpcHelper::Batcher* batcher,\n             \"IFRT server sent a message without metadata: \", r->DebugString()));\n       }\n \n-      const absl::Status metadata_status =\n-          tsl::StatusFromProto(r->response_metadata().status());\n+      const absl::Status metadata_status = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto(r->response_metadata().status()));\n       const bool has_expected_response = (r.get()->*has_resp)();\n       const auto has_some_response =\n           r->response_case() != IfrtResponse::RESPONSE_NOT_SET;\n@@ -295,11 +404,32 @@ tsl::Future<std::shared_ptr<Resp>> DoRpc(RpcHelper::Batcher* batcher,\n       // there may be an error _instead_ of an actual response value. So, check\n       // if an actual response value exists, and if so return it irrespective of\n       // what the metadata_status says.\n+      absl::StatusOr<std::shared_ptr<Resp>> result;\n       if (!has_some_response) {\n-        return metadata_status;\n+        result = std::move(metadata_status);\n       } else {\n-        return std::make_shared<Resp>(*std::move((r.get()->*get_resp)()));\n+        const int64_t seq_num = r->response_metadata().seq_num();\n+\n+        std::vector<UserContextId> user_context_ids;\n+        user_context_ids.reserve(\n+            r->response_metadata().destroyed_user_context_ids_size());\n+        for (uint64_t user_context_id :\n+             r->response_metadata().destroyed_user_context_ids()) {\n+          user_context_ids.push_back(UserContextId(user_context_id));\n+        }\n+        user_contexts_referenced_by_proxy_server\n+            ->ScheduleToUnregisterUserContexts(seq_num,\n+                                               std::move(user_context_ids));\n+\n+        result = std::shared_ptr<Resp>(\n+            new Resp(*std::move((r.get()->*get_resp)())),\n+            [user_contexts_referenced_by_proxy_server, seq_num](Resp* resp) {\n+              delete resp;\n+              user_contexts_referenced_by_proxy_server->DoneProcessingResponse(\n+                  seq_num);\n+            });\n       }\n+      return result;\n     }(*std::move(r));\n \n     if (!result.ok()) {"
        },
        {
            "sha": "bb6e7532f1ab98ebbf8ff8e3e32d7ea677ee5fb5",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FBUILD?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -85,6 +85,7 @@ tf_proto_library(\n         \":types_proto\",\n         # copybara:uncomment \"@com_google_protobuf//:any_proto\",\n         \"//xla:xla_data_proto\",\n+        \"//xla/pjrt/proto:executable_metadata_proto\",\n         \"//xla/pjrt/proto:execute_options_proto\",\n         \"//xla/python/ifrt:array_spec_proto\",\n         \"//xla/python/ifrt:attribute_map_proto\",\n@@ -96,7 +97,6 @@ tf_proto_library(\n         \"//xla/python/ifrt:sharding_proto\",\n         \"//xla/tsl/protobuf:status_proto\",\n     ],\n-    deps = [\"//xla/pjrt/proto:executable_metadata_proto\"],\n )\n \n tf_proto_library(\n@@ -209,6 +209,7 @@ cc_library(\n     hdrs = [\"proto_util.h\"],\n     deps = [\n         \":ifrt_service_proto_cc\",\n+        \"//xla/python/ifrt:user_context_status_util\",\n         \"//xla/tsl/platform:status_to_from_proto\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\","
        },
        {
            "sha": "041f6f425e766b68d53284c81554e14a0cc88526",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/ifrt_service.proto",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -166,6 +166,9 @@ message RequestMetadata {\n   // resync after transient connectivity failures.\n   fixed64 op_id = 1;\n \n+  // User context ID of the operation.\n+  fixed64 user_context_id = 5;\n+\n   // Implementation-specific payloads.\n   repeated google.protobuf.Any payloads = 4;\n \n@@ -194,6 +197,13 @@ message ResponseMetadata {\n   //    specific error type or string when this is not OK, they should check the\n   //    response message for individual absl::Statuses.\n   tensorflow.StatusProto status = 2;\n+\n+  // The sequence number of the response.\n+  int64 seq_num = 3;\n+\n+  // IDs of the destroyed user contexts since the last response identified by\n+  // `seq_num` - 1.\n+  repeated fixed64 destroyed_user_context_ids = 4;\n }\n \n // InitRequest allows the client to specify the optional startup configuration"
        },
        {
            "sha": "35599df7cc206c694452466bd3188f1326c44c83",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/BUILD",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -129,7 +129,9 @@ cc_library(\n     deps = [\n         \":host_buffer\",\n         \":host_callback\",\n+        \":ifrt_backend_user_context\",\n         \":version\",\n+        \"//xla:future\",\n         \"//xla:shape_util\",\n         \"//xla:status_macros\",\n         \"//xla:xla_data_proto_cc\",\n@@ -142,6 +144,7 @@ cc_library(\n         \"//xla/python/ifrt:serdes_version\",\n         \"//xla/python/ifrt:sharding_serdes\",\n         \"//xla/python/ifrt:user_context\",\n+        \"//xla/python/ifrt:with_user_context\",\n         \"//xla/python/ifrt_proxy/common:array_util\",\n         \"//xla/python/ifrt_proxy/common:common_serdes\",\n         \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n@@ -249,6 +252,31 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"ifrt_backend_user_context\",\n+    srcs = [\"ifrt_backend_user_context.cc\"],\n+    hdrs = [\"ifrt_backend_user_context.h\"],\n+    deps = [\n+        \"//xla/python/ifrt:user_context\",\n+        \"//xla/tsl/concurrency:ref_count\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@llvm-project//llvm:Support\",\n+    ],\n+)\n+\n+ifrt_proxy_cc_test(\n+    name = \"ifrt_backend_user_context_test\",\n+    srcs = [\"ifrt_backend_user_context_test.cc\"],\n+    deps = [\n+        \":ifrt_backend_user_context\",\n+        \"//xla/python/ifrt:user_context\",\n+        \"//xla/tsl/concurrency:future\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"host_buffer\",\n     srcs = [\"host_buffer.cc\"],"
        },
        {
            "sha": "d17546d605435a0b98cc572fa65d220ff5a3305c",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 15,
            "changes": 74,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -44,6 +44,7 @@\n #include \"absl/time/time.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/Support/Casting.h\"\n+#include \"xla/future.h\"\n #include \"xla/layout.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/python/ifrt/array.h\"\n@@ -66,6 +67,7 @@\n #include \"xla/python/ifrt/sharding.h\"\n #include \"xla/python/ifrt/user_context.h\"\n #include \"xla/python/ifrt/value.h\"\n+#include \"xla/python/ifrt/with_user_context.h\"\n #include \"xla/python/ifrt_proxy/common/array_util.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n #include \"xla/python/ifrt_proxy/common/prof_util.h\"\n@@ -75,6 +77,7 @@\n #include \"xla/python/ifrt_proxy/common/versions.h\"\n #include \"xla/python/ifrt_proxy/server/host_buffer.h\"\n #include \"xla/python/ifrt_proxy/server/host_callback.h\"\n+#include \"xla/python/ifrt_proxy/server/ifrt_backend_user_context.h\"\n #include \"xla/python/ifrt_proxy/server/version.h\"\n #include \"xla/python/pjrt_ifrt/xla_compiler.h\"\n #include \"xla/status_macros.h\"\n@@ -177,11 +180,17 @@ ParseMakeArraysFromHostBufferShardsSpecHostBufferProto(\n // Returns a string_view that is guaranteed to be valid and constant until this\n // process dies.\n absl::string_view GetRequestName(const IfrtRequest* req) {\n-  if (IfrtRequest::descriptor() == nullptr) return \"unknown\";\n-  if (req == nullptr) return \"unknown\";\n+  if (IfrtRequest::descriptor() == nullptr) {\n+    return \"unknown\";\n+  }\n+  if (req == nullptr) {\n+    return \"unknown\";\n+  }\n   auto* field =\n       IfrtRequest::descriptor()->FindFieldByNumber(req->request_case());\n-  if (field == nullptr) return \"unknown\";\n+  if (field == nullptr) {\n+    return \"unknown\";\n+  }\n   return field->name();\n }\n \n@@ -385,7 +394,9 @@ class IfrtBackend::InOrderRequestsProcessor {\n       return shutdown_msg_.has_value() || !entries_.empty();\n     };\n     mu_.Await(absl::Condition(&cond));\n-    if (shutdown_msg_.has_value()) return std::nullopt;\n+    if (shutdown_msg_.has_value()) {\n+      return std::nullopt;\n+    }\n     auto result = std::move(entries_.front());\n     entries_.pop_front();\n     return result;\n@@ -398,7 +409,7 @@ class IfrtBackend::InOrderRequestsProcessor {\n       int request_case = entry->req->request_case();\n       auto span = entry->xflow.Span<XFlowHelper::kRecvSend>();\n       parent_->ProcessInternal(std::move(entry->req))\n-          .OnReady([p = std::move(entry->promise),\n+          .OnReady([parent = parent_, p = std::move(entry->promise),\n                     xflow = std::move(entry->xflow), request_case,\n                     op_id](absl::StatusOr<Response> r) mutable {\n             auto span = xflow.Span<XFlowHelper::kRecv>();\n@@ -412,6 +423,7 @@ class IfrtBackend::InOrderRequestsProcessor {\n               LOG(WARNING) << \"Responding \" << request_type << \"(\" << op_id\n                            << \"): \" << r.status();\n             } else {\n+              parent->UpdateResponseWithDestroyedUserContextIds(*r);\n               VLOG(3) << \"Responding \" << op_id << \": \"\n                       << (*r)->ShortDebugString();\n             }\n@@ -449,7 +461,9 @@ IfrtBackend::IfrtBackend(IfrtProxyVersion version, uint64_t session_id,\n           // TODO(b/282757875): Consider making this configurable.\n           /*num_threads=*/32),\n       in_order_requests_processor_(\n-          std::make_unique<InOrderRequestsProcessor>(this)) {}\n+          std::make_unique<InOrderRequestsProcessor>(this)),\n+      destroyed_user_context_ids_(std::make_shared<DestroyedUserContextIds>()) {\n+}\n \n absl::StatusOr<std::unique_ptr<IfrtBackend>> IfrtBackend::Create(\n     IfrtProxyVersion version, uint64_t session_id,\n@@ -524,6 +538,13 @@ tsl::Future<BackendInterface::Response> IfrtBackend::Process(\n \n tsl::Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n     std::unique_ptr<IfrtRequest> request) {\n+  UserContextScope user_context_scope(IfrtBackendUserContext::Create(\n+      UserContextId(request->request_metadata().user_context_id()),\n+      [destroyed_user_context_ids =\n+           destroyed_user_context_ids_](UserContextId id) {\n+        absl::MutexLock l(destroyed_user_context_ids->mutex);\n+        destroyed_user_context_ids->ids.push_back(id);\n+      }));\n   std::optional<ArrayStore::Reservation> asr;\n   switch (request->request_case()) {\n     case IfrtRequest::RequestCase::kInitRequest:\n@@ -677,14 +698,15 @@ tsl::Future<BackendInterface::Response> IfrtBackend::AsyncExecute(\n     ++in_flight_count_;\n   }\n   auto [promise, future] = tsl::Future<Response>::MakePromise();\n-  auto f = [this, promise = std::move(promise).ToShared(),\n-            handle_fn = std::move(handle_fn)]() mutable {\n-    promise->Set(handle_fn());\n-    {\n-      absl::MutexLock lock(in_flight_count_mutex_);\n-      --in_flight_count_;\n-    }\n-  };\n+  auto f =\n+      WithCurrentUserContext([this, promise = std::move(promise).ToShared(),\n+                              handle_fn = std::move(handle_fn)]() mutable {\n+        promise->Set(handle_fn());\n+        {\n+          absl::MutexLock lock(in_flight_count_mutex_);\n+          --in_flight_count_;\n+        }\n+      });\n   if (thread_pool != nullptr) {\n     thread_pool->Schedule(std::move(f));\n   } else {\n@@ -838,7 +860,9 @@ IfrtBackend::HandleMakeArrayFromHostBufferRequest(\n       Sharding::FromProto(client_.get(), make_array_request->sharding()));\n \n   const auto byte_strides = [&]() -> std::optional<std::vector<int64_t>> {\n-    if (!make_array_request->has_byte_strides()) return std::nullopt;\n+    if (!make_array_request->has_byte_strides()) {\n+      return std::nullopt;\n+    }\n     return FromByteStridesProto(make_array_request->byte_strides());\n   }();\n   TF_ASSIGN_OR_RETURN(const auto shape,\n@@ -2050,6 +2074,26 @@ IfrtBackend::GetLoadedExecutable(uint64_t handle) {\n   return it->second;\n }\n \n+void IfrtBackend::UpdateResponseWithDestroyedUserContextIds(\n+    IfrtBackend::Response& response) {\n+  absl::MutexLock l(destroyed_user_context_ids_->mutex);\n+\n+  response->mutable_response_metadata()->set_seq_num(\n+      destroyed_user_context_ids_->next_seq_num);\n+  ++destroyed_user_context_ids_->next_seq_num;\n+\n+  std::vector<UserContextId>& ids = destroyed_user_context_ids_->ids;\n+  if (!ids.empty()) {\n+    auto* ids_proto = response->mutable_response_metadata()\n+                          ->mutable_destroyed_user_context_ids();\n+    ids_proto->Reserve(ids.size());\n+    for (UserContextId id : ids) {\n+      ids_proto->AddAlreadyReserved(id.value());\n+    }\n+    ids.clear();\n+  }\n+}\n+\n absl::StatusOr<IfrtArrayRef> IfrtBackend::ArrayStore::Find(uint64_t handle) {\n   absl::MutexLock l(mu_);\n   auto it = arrays_.find(handle);"
        },
        {
            "sha": "dd64ce305e1f6296ff08a5a3a105f40b80f1bc35",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.h",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -35,6 +35,7 @@\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt/serdes_any_version_accessor.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n #include \"xla/python/ifrt_proxy/server/host_buffer.h\"\n #include \"xla/python/ifrt_proxy/server/host_callback.h\"\n@@ -250,6 +251,25 @@ class IfrtBackend final : public BackendInterface {\n   absl::StatusOr<std::shared_ptr<LoadedExecutableWithInfo>> GetLoadedExecutable(\n       uint64_t handle);\n \n+  //////////////////////////////////////////////////////////////////////////\n+  // Methods for tracking destroyed user context IDs.\n+  //\n+\n+  // Updates `response` with a sequence number and the destroyed user context\n+  // IDs in `destroyed_user_context_ids_->ids`.\n+  //\n+  // The sequence number is strictly increasing and indicates the order of\n+  // responses. It is sent as part of every valid response so that the client\n+  // can determine when it has received all in-flight responses that potentially\n+  // reference a deleted user context ID and it can apply the received\n+  // `destroyed_user_context_ids_` to drop its own references to those user\n+  // contexts.\n+  //\n+  // `destroyed_user_context_ids_->ids` will be cleared to avoid sending the\n+  // same IDs again in the next response.\n+  void UpdateResponseWithDestroyedUserContextIds(\n+      IfrtBackend::Response& response);\n+\n   HandleGenerator handle_generator_;\n \n   // Must not change during the life of this object.\n@@ -286,6 +306,18 @@ class IfrtBackend final : public BackendInterface {\n \n   class InOrderRequestsProcessor;\n   std::unique_ptr<InOrderRequestsProcessor> in_order_requests_processor_;\n+\n+  // Tracks destroyed user context IDs. `ids` contains the ID of `UserContext`s\n+  // destroyed since the last response identified by `next_seq_num` - 1.\n+  //\n+  // Uses a shared pointer because `IfrtBackendUserContext` may outlive the\n+  // `IfrtBackend`.\n+  struct DestroyedUserContextIds {\n+    absl::Mutex mutex;\n+    int64_t next_seq_num ABSL_GUARDED_BY(mutex) = 0;\n+    std::vector<UserContextId> ids ABSL_GUARDED_BY(mutex);\n+  };\n+  std::shared_ptr<DestroyedUserContextIds> destroyed_user_context_ids_;\n };\n \n }  // namespace proxy"
        },
        {
            "sha": "93a1e12cc2970b45898ffee6540f6381a77f6f7e",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend_user_context.cc",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context.cc?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -0,0 +1,57 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt_proxy/server/ifrt_backend_user_context.h\"\n+\n+#include <string>\n+#include <utility>\n+\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace proxy {\n+\n+[[maybe_unused]] char IfrtBackendUserContext::ID = 0;\n+\n+UserContextRef IfrtBackendUserContext::Create(\n+    UserContextId original_id,\n+    absl::AnyInvocable<void(UserContextId) &&> on_destroyed) {\n+  if (original_id.value() == 0) {\n+    return UserContextRef();\n+  }\n+  return UserContextRef(tsl::MakeRef<IfrtBackendUserContext>(\n+      original_id, std::move(on_destroyed)));\n+}\n+\n+IfrtBackendUserContext::IfrtBackendUserContext(\n+    UserContextId original_id,\n+    absl::AnyInvocable<void(UserContextId) &&> on_destroyed)\n+    : original_id_(original_id), on_destroyed_(std::move(on_destroyed)) {}\n+\n+IfrtBackendUserContext::~IfrtBackendUserContext() {\n+  std::move(on_destroyed_)(original_id_);\n+}\n+\n+std::string IfrtBackendUserContext::DebugString() const {\n+  return absl::StrCat(\"IfrtProxyServerUserContext(\", original_id_.value(), \")\");\n+}\n+\n+}  // namespace proxy\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "6d3433567e78b7fa0c183d83af57e74327dcb73b",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend_user_context.h",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context.h?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -0,0 +1,66 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PYTHON_IFRT_PROXY_SERVER_IFRT_BACKEND_USER_CONTEXT_H_\n+#define XLA_PYTHON_IFRT_PROXY_SERVER_IFRT_BACKEND_USER_CONTEXT_H_\n+\n+#include <string>\n+\n+#include \"absl/functional/any_invocable.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace proxy {\n+\n+class IfrtBackendUserContext\n+    : public llvm::RTTIExtends<IfrtBackendUserContext, UserContext> {\n+ public:\n+  // Creates a UserContextRef with the given `original_id` and `on_destroyed`\n+  // callback called at its destruction. If `original_id` is 0, returns a\n+  // nullptr; `on_destroyed` will not be called this case.\n+  static UserContextRef Create(\n+      UserContextId original_id,\n+      absl::AnyInvocable<void(UserContextId) &&> on_destroyed);\n+\n+  // UserContext implementation.\n+\n+  ~IfrtBackendUserContext() override;\n+\n+  UserContextId Id() const override { return original_id_; }\n+\n+  std::string DebugString() const override;\n+\n+  static char ID;  // NOLINT\n+\n+ private:\n+  template <typename T, typename... Args>\n+  friend tsl::RCReference<T> tsl::MakeRef(Args&&... args);\n+\n+  IfrtBackendUserContext(\n+      UserContextId original_id,\n+      absl::AnyInvocable<void(UserContextId) &&> on_destroyed);\n+\n+  UserContextId original_id_;\n+  absl::AnyInvocable<void(UserContextId) &&> on_destroyed_;\n+};\n+\n+}  // namespace proxy\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_IFRT_PROXY_SERVER_IFRT_BACKEND_USER_CONTEXT_H_"
        },
        {
            "sha": "55a6a3c8a503a1a2060d7f26634dbd43c29e5c01",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend_user_context_test.cc",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f0886a9095af253370293c12b735017327471c90/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_user_context_test.cc?ref=f0886a9095af253370293c12b735017327471c90",
            "patch": "@@ -0,0 +1,57 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt_proxy/server/ifrt_backend_user_context.h\"\n+\n+#include <utility>\n+\n+#include <gtest/gtest.h>\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace proxy {\n+namespace {\n+\n+TEST(IfrtBackendUserContextTest, CreateWithZeroId) {\n+  UserContextRef user_context =\n+      IfrtBackendUserContext::Create(UserContextId(0), [](UserContextId) {});\n+  EXPECT_EQ(user_context, UserContextRef());\n+}\n+\n+TEST(IfrtBackendUserContextTest, CreateWithNonZeroId) {\n+  UserContextRef user_context =\n+      IfrtBackendUserContext::Create(UserContextId(100), [](UserContextId) {});\n+  EXPECT_EQ(user_context->Id(), UserContextId(100));\n+  EXPECT_EQ(user_context->DebugString(), \"IfrtProxyServerUserContext(100)\");\n+}\n+\n+TEST(IfrtBackendUserContextTest, DestroyUserContext) {\n+  auto [promise, future] = tsl::Future<UserContextId>::MakePromise();\n+  {\n+    UserContextRef user_context = IfrtBackendUserContext::Create(\n+        UserContextId(100), [promise = std::move(promise)](\n+                                UserContextId id) mutable { promise.Set(id); });\n+  }\n+  TF_ASSERT_OK_AND_ASSIGN(UserContextId id, future.Await());\n+  EXPECT_EQ(id, UserContextId(100));\n+}\n+\n+}  // namespace\n+}  // namespace proxy\n+}  // namespace ifrt\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 512,
        "additions": 476,
        "deletions": 36
    }
}