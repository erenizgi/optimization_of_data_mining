{
    "author": "KanishAnand",
    "message": "Moving definitions to cpp file, match function definition declaration order\n\nPiperOrigin-RevId: 847385799",
    "sha": "5042531aa849393d2a0c9af04f56a4462081d53a",
    "files": [
        {
            "sha": "d0cb57442ec492762bdc4484e44796c3716d2413",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.cc",
            "status": "modified",
            "additions": 54,
            "deletions": 19,
            "changes": 73,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5042531aa849393d2a0c9af04f56a4462081d53a/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5042531aa849393d2a0c9af04f56a4462081d53a/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc?ref=5042531aa849393d2a0c9af04f56a4462081d53a",
            "patch": "@@ -28,6 +28,8 @@ limitations under the License.\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/ADT/STLExtras.h\"\n@@ -94,6 +96,28 @@ Mesh::Mesh(TileAssignment device_assignment,\n   CHECK_OK(ValidateMesh());\n }\n \n+std::string Mesh::ToString() const {\n+  std::string mesh_str = \"@mesh\";\n+  // Add the mesh axes names and sizes.\n+  std::vector<std::string> formatted_axes_names;\n+  formatted_axes_names.reserve(axes_names_.size());\n+  for (int64_t i = 0; i < axes_names_.size(); ++i) {\n+    formatted_axes_names.push_back(\n+        absl::StrCat(axes_names_[i], \"=\", device_assignment_.dim(i)));\n+  }\n+\n+  // Add the device assignment if it is not an iota case.\n+  std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n+  std::string device_assignment_str = \"\";\n+  if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n+    device_assignment_str =\n+        absl::StrCat(\"(\", device_assignment_.ArrayToString(), \")\");\n+  }\n+  absl::StrAppend(&mesh_str, \"<\", absl::StrJoin(formatted_axes_names, \",\"), \">\",\n+                  device_assignment_str);\n+  return mesh_str;\n+}\n+\n MeshProto Mesh::ToProto() const {\n   MeshProto proto;\n   int64_t num_axes = axes_names_.size();\n@@ -168,26 +192,15 @@ Mesh Mesh::FromProto(const MeshProto& proto) {\n   return Mesh(tile_assignment, mesh_axis_names_span);\n }\n \n-absl::Status AxisRef::Validate(const Mesh& mesh) const {\n-  if (mesh_axis_index_ >= mesh.axis_names().size()) {\n-    return absl::InvalidArgumentError(\n-        \"Axis index must be less than number of axes.\");\n-  }\n-  if (!sub_axis_info_.has_value()) {\n-    return absl::OkStatus();\n-  }\n-\n-  int64_t axis_size = mesh.axis_size(mesh_axis_index_);\n-  if (axis_size % sub_axis_info_->pre_size != 0 ||\n-      axis_size % sub_axis_info_->size != 0) {\n-    return absl::InvalidArgumentError(\n-        \"Pre-size and size must divide the full axis size.\");\n-  }\n-  if (sub_axis_info_->size >= axis_size) {\n-    return absl::InvalidArgumentError(\n-        \"Sub-axis size must be strictly less than the full axis size.\");\n+std::string AxisRef::ToString(const Mesh& mesh) const {\n+  CHECK_GE(mesh_axis_index_, 0);\n+  CHECK_LT(mesh_axis_index_, mesh.axis_names().size());\n+  std::string axis_str = mesh.axis_names()[mesh_axis_index_];\n+  if (sub_axis_info_.has_value()) {\n+    absl::StrAppend(&axis_str, \":(\", sub_axis_info_->pre_size, \")\",\n+                    sub_axis_info_->size);\n   }\n-  return absl::OkStatus();\n+  return axis_str;\n }\n \n AxisRefProto AxisRef::ToProto() const {\n@@ -309,6 +322,28 @@ bool AxisRef::CanCoexistWithoutOverlap(const AxisRef& other) const {\n   return max_pre_size % min_next_pre_size == 0;\n }\n \n+absl::Status AxisRef::Validate(const Mesh& mesh) const {\n+  if (mesh_axis_index_ >= mesh.axis_names().size()) {\n+    return absl::InvalidArgumentError(\n+        \"Axis index must be less than number of axes.\");\n+  }\n+  if (!sub_axis_info_.has_value()) {\n+    return absl::OkStatus();\n+  }\n+\n+  int64_t axis_size = mesh.axis_size(mesh_axis_index_);\n+  if (axis_size % sub_axis_info_->pre_size != 0 ||\n+      axis_size % sub_axis_info_->size != 0) {\n+    return absl::InvalidArgumentError(\n+        \"Pre-size and size must divide the full axis size.\");\n+  }\n+  if (sub_axis_info_->size >= axis_size) {\n+    return absl::InvalidArgumentError(\n+        \"Sub-axis size must be strictly less than the full axis size.\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n int64_t AxisRef::size(const Mesh& mesh) const {\n   if (sub_axis_info_.has_value()) {\n     return sub_axis_info_->size;"
        },
        {
            "sha": "e83f58b7c0cb4375926cc36bb19f2ac8b7a3172a",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 3,
            "deletions": 34,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5042531aa849393d2a0c9af04f56a4462081d53a/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5042531aa849393d2a0c9af04f56a4462081d53a/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=5042531aa849393d2a0c9af04f56a4462081d53a",
            "patch": "@@ -24,8 +24,6 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/log/check.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n@@ -92,32 +90,12 @@ class Mesh {\n \n   bool operator!=(const Mesh& other) const { return !(*this == other); }\n \n-  std::string ToString() const {\n-    std::string mesh_str = \"@mesh\";\n-    // Add the mesh axes names and sizes.\n-    std::vector<std::string> formatted_axes_names;\n-    formatted_axes_names.reserve(axes_names_.size());\n-    for (int64_t i = 0; i < axes_names_.size(); ++i) {\n-      formatted_axes_names.push_back(\n-          absl::StrCat(axes_names_[i], \"=\", device_assignment_.dim(i)));\n-    }\n-\n-    // Add the device assignment if it is not an iota case.\n-    std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n-    std::string device_assignment_str = \"\";\n-    if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n-      device_assignment_str =\n-          absl::StrCat(\"(\", device_assignment_.ArrayToString(), \")\");\n-    }\n-    absl::StrAppend(&mesh_str, \"<\", absl::StrJoin(formatted_axes_names, \",\"),\n-                    \">\", device_assignment_str);\n-    return mesh_str;\n-  }\n-\n   bool DeviceAssignmentEquals(const Mesh& other) const {\n     return device_assignment_ == other.device_assignment_;\n   }\n \n+  std::string ToString() const;\n+\n   MeshProto ToProto() const;\n \n   static Mesh FromProto(const MeshProto& proto);\n@@ -178,16 +156,7 @@ class AxisRef {\n \n   bool operator!=(const xla::AxisRef& other) const { return !(*this == other); }\n \n-  std::string ToString(const Mesh& mesh) const {\n-    CHECK_GE(mesh_axis_index_, 0);\n-    CHECK_LT(mesh_axis_index_, mesh.axis_names().size());\n-    std::string axis_str = mesh.axis_names()[mesh_axis_index()];\n-    if (sub_axis_info_.has_value()) {\n-      absl::StrAppend(&axis_str, \":(\", sub_axis_info_->pre_size, \")\",\n-                      sub_axis_info_->size);\n-    }\n-    return axis_str;\n-  }\n+  std::string ToString(const Mesh& mesh) const;\n \n   AxisRefProto ToProto() const;\n "
        }
    ],
    "stats": {
        "total": 110,
        "additions": 57,
        "deletions": 53
    }
}