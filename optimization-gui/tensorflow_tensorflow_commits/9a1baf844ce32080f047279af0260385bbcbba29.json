{
    "author": "loislo",
    "message": "[XLA:GPU] #debuggability Refactor `DumpToString` to use templates.\n\nThis simplifies the code and makes `DumpToString` more generic.\n\nNow it could be used with any mlir type that has operator<< or print methods.\n\nPiperOrigin-RevId: 801443403",
    "sha": "9a1baf844ce32080f047279af0260385bbcbba29",
    "files": [
        {
            "sha": "082411950497a4c598861d8d762e0e3c70a98dbf",
            "filename": "third_party/xla/xla/service/llvm_ir/llvm_util.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9a1baf844ce32080f047279af0260385bbcbba29/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fllvm_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9a1baf844ce32080f047279af0260385bbcbba29/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fllvm_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fllvm_util.cc?ref=9a1baf844ce32080f047279af0260385bbcbba29",
            "patch": "@@ -86,18 +86,6 @@ namespace llvm_ir {\n \n namespace {\n \n-// This works for most llvm / mlir types. This also accepts a const pointer to\n-// objects which have a const print() method.\n-template <typename T>\n-std::string DumpToStringTempl(T* entity) {\n-  CHECK_NE(entity, nullptr);\n-\n-  std::string s;\n-  llvm::raw_string_ostream ostream(s);\n-  ostream << *entity;\n-  return s;\n-}\n-\n // Note, this function is only useful in an insertion context; in a global\n // (e.g. constants) context it will CHECK fail.\n llvm::Module* ModuleFromIRBuilder(llvm::IRBuilderBase* b) {\n@@ -151,27 +139,6 @@ std::optional<PrimitiveType> PrimitiveComplexTypeFromIrStructType(\n \n }  // namespace\n \n-std::string DumpToString(const llvm::Module* module) {\n-  return DumpToStringTempl(module);\n-}\n-\n-std::string DumpToString(const llvm::Type* type) {\n-  return DumpToStringTempl(type);\n-}\n-\n-std::string DumpToString(const llvm::Value* value) {\n-  return DumpToStringTempl(value);\n-}\n-\n-std::string DumpToString(mlir::Operation* operation) {\n-  return DumpToStringTempl(operation);\n-}\n-\n-std::string DumpToString(mlir::Type type) { return DumpToStringTempl(&type); }\n-\n-std::string DumpToString(mlir::Value value) {\n-  return DumpToStringTempl(&value);\n-}\n \n llvm::CallInst* EmitCallToIntrinsic(\n     llvm::Intrinsic::ID intrinsic_id, absl::Span<llvm::Value* const> operands,"
        },
        {
            "sha": "7cba1edda3d1ee5529929e3e8dd270e5f7799113",
            "filename": "third_party/xla/xla/service/llvm_ir/llvm_util.h",
            "status": "modified",
            "additions": 36,
            "deletions": 16,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9a1baf844ce32080f047279af0260385bbcbba29/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fllvm_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9a1baf844ce32080f047279af0260385bbcbba29/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fllvm_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fllvm_util.h?ref=9a1baf844ce32080f047279af0260385bbcbba29",
            "patch": "@@ -23,6 +23,7 @@ limitations under the License.\n #include <string>\n #include <utility>\n \n+#include \"absl/log/check.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n@@ -39,6 +40,7 @@ limitations under the License.\n #include \"llvm/IR/Module.h\"\n #include \"llvm/IR/Value.h\"\n #include \"llvm/Support/TypeSize.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/Location.h\"\n #include \"mlir/IR/Operation.h\"\n@@ -59,24 +61,42 @@ class TargetOptions;\n namespace xla {\n namespace llvm_ir {\n \n-// We have different DumpToString functions for each type for findability. We\n-// use pointers / values based on the usual semantics of the parameter type.\n+// Overload for pointer types that allows to pass additional arguments to the\n+// print method.\n+template <typename T, typename... ARGS>\n+inline std::string DumpToString(T* entity, ARGS... args) {\n+  std::string s;\n+  llvm::raw_string_ostream ostream(s);\n+  entity->print(ostream, args...);\n+  return s;\n+}\n \n-std::string DumpToString(const llvm::Module* module);\n-std::string DumpToString(const llvm::Type* type);\n-std::string DumpToString(const llvm::Value* value);\n+// Overload for pointer types.\n+template <typename T>\n+inline std::string DumpToString(T* entity) {\n+  std::string s;\n+  llvm::raw_string_ostream ostream(s);\n+  ostream << *entity;\n+  return s;\n+}\n \n-// This also works for mlir::Op<...> descendants, such as mlir::ModuleOp.\n-//\n-// For findability:\n-//   std::string DumpToString(mlir::Op<...>& op);\n-//   std::string DumpToString(mlir::ModuleOp& module_op);\n-//\n-// The `operation` parameter is not const, because the used print() method is\n-// not const.\n-std::string DumpToString(mlir::Operation* operation);\n-std::string DumpToString(mlir::Type type);\n-std::string DumpToString(mlir::Value value);\n+// Overload for non-pointer types. Allows to pass additional arguments to the\n+// print method.\n+template <typename T, typename... ARGS>\n+inline std::string DumpToString(const T& entity, ARGS... args) {\n+  std::string s;\n+  llvm::raw_string_ostream ostream(s);\n+  entity.print(ostream, args...);\n+  return s;\n+}\n+\n+template <typename T>\n+inline std::string DumpToString(const T& entity) {\n+  std::string s;\n+  llvm::raw_string_ostream ostream(s);\n+  ostream << entity;\n+  return s;\n+}\n \n // Constructs a human-friendly name from the given inputs.  The result is\n // suitable for use as an llvm::Value's name."
        }
    ],
    "stats": {
        "total": 85,
        "additions": 36,
        "deletions": 49
    }
}