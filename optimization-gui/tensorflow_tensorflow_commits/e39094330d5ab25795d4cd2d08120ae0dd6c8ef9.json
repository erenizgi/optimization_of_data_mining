{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 821946240",
    "sha": "e39094330d5ab25795d4cd2d08120ae0dd6c8ef9",
    "files": [
        {
            "sha": "e0d3c88bbe90be273e356fb5e164dc5fb7aca25d",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_file_system.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 21,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e39094330d5ab25795d4cd2d08120ae0dd6c8ef9/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e39094330d5ab25795d4cd2d08120ae0dd6c8ef9/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.cc?ref=e39094330d5ab25795d4cd2d08120ae0dd6c8ef9",
            "patch": "@@ -184,7 +184,7 @@ string MaybeAppendSlash(const string& name) {\n     return \"/\";\n   }\n   if (name.back() != '/') {\n-    return strings::StrCat(name, \"/\");\n+    return absl::StrCat(name, \"/\");\n   }\n   return name;\n }\n@@ -193,7 +193,7 @@ string MaybeAppendSlash(const string& name) {\n // to result in an appended slash in order for directory markers\n // to be processed correctly: \"gs://a/b\" + \"\" should give \"gs://a/b/\".\n string JoinGcsPath(const string& path, const string& subpath) {\n-  return strings::StrCat(MaybeAppendSlash(path), subpath);\n+  return absl::StrCat(MaybeAppendSlash(path), subpath);\n }\n \n /// \\brief Returns the given paths appending all their subfolders.\n@@ -773,7 +773,7 @@ class GcsWritableFile : public WritableFile {\n   }\n \n   string GetGcsPathWithObject(string object) const {\n-    return strings::StrCat(\"gs://\", bucket_, \"/\", object);\n+    return absl::StrCat(\"gs://\", bucket_, \"/\", object);\n   }\n   string GetGcsPath() const { return GetGcsPathWithObject(object_); }\n \n@@ -1234,7 +1234,7 @@ absl::Status GcsFileSystem::RequestUploadSessionStatus(\n   TF_RETURN_IF_ERROR(CreateHttpRequest(&request));\n   request->SetUri(session_uri);\n   request->SetTimeouts(timeouts_.connect, timeouts_.idle, timeouts_.metadata);\n-  request->AddHeader(\"Content-Range\", strings::StrCat(\"bytes */\", file_size));\n+  request->AddHeader(\"Content-Range\", absl::StrCat(\"bytes */\", file_size));\n   request->SetPutEmptyBody();\n   absl::Status status = request->Send();\n   if (status.ok()) {\n@@ -1655,7 +1655,7 @@ absl::Status GcsFileSystem::GetBucketMetadata(\n     const string& bucket, std::vector<char>* result_buffer) {\n   std::unique_ptr<HttpRequest> request;\n   TF_RETURN_IF_ERROR(CreateHttpRequest(&request));\n-  request->SetUri(strings::StrCat(kGcsUriBase, \"b/\", bucket));\n+  request->SetUri(absl::StrCat(kGcsUriBase, \"b/\", bucket));\n \n   if (result_buffer != nullptr) {\n     request->SetResultBuffer(result_buffer);\n@@ -1786,7 +1786,7 @@ absl::Status GcsFileSystem::GetMatchingPaths(const string& pattern,\n           // removing duplicate slashes. We know that `dir_no_slash` does not\n           // end in `/`, so we are safe inserting the new `/` here as the path\n           // separator.\n-          const string full_path = strings::StrCat(dir_no_slash, \"/\", path);\n+          const string full_path = absl::StrCat(dir_no_slash, \"/\", path);\n           if (this->Match(full_path, pattern)) {\n             results->push_back(full_path);\n           }\n@@ -1814,27 +1814,25 @@ absl::Status GcsFileSystem::GetChildrenBounded(\n     std::vector<char> output_buffer;\n     std::unique_ptr<HttpRequest> request;\n     TF_RETURN_IF_ERROR(CreateHttpRequest(&request));\n-    auto uri = strings::StrCat(kGcsUriBase, \"b/\", bucket, \"/o\");\n+    auto uri = absl::StrCat(kGcsUriBase, \"b/\", bucket, \"/o\");\n     if (recursive) {\n-      uri = strings::StrCat(uri, \"?fields=items%2Fname%2CnextPageToken\");\n+      uri = absl::StrCat(uri, \"?fields=items%2Fname%2CnextPageToken\");\n     } else {\n       // Set \"/\" as a delimiter to ask GCS to treat subfolders as children\n       // and return them in \"prefixes\".\n-      uri = strings::StrCat(uri,\n-                            \"?fields=items%2Fname%2Cprefixes%2CnextPageToken\");\n-      uri = strings::StrCat(uri, \"&delimiter=%2F\");\n+      uri =\n+          absl::StrCat(uri, \"?fields=items%2Fname%2Cprefixes%2CnextPageToken\");\n+      uri = absl::StrCat(uri, \"&delimiter=%2F\");\n     }\n     if (!object_prefix.empty()) {\n-      uri = strings::StrCat(uri,\n-                            \"&prefix=\", request->EscapeString(object_prefix));\n+      uri = absl::StrCat(uri, \"&prefix=\", request->EscapeString(object_prefix));\n     }\n     if (!nextPageToken.empty()) {\n-      uri = strings::StrCat(\n-          uri, \"&pageToken=\", request->EscapeString(nextPageToken));\n+      uri = absl::StrCat(uri,\n+                         \"&pageToken=\", request->EscapeString(nextPageToken));\n     }\n     if (max_results - retrieved_results < kGetChildrenDefaultPageSize) {\n-      uri =\n-          strings::StrCat(uri, \"&maxResults=\", max_results - retrieved_results);\n+      uri = absl::StrCat(uri, \"&maxResults=\", max_results - retrieved_results);\n     }\n     request->SetUri(uri);\n     request->SetResultBuffer(&output_buffer);\n@@ -1862,9 +1860,9 @@ absl::Status GcsFileSystem::GetChildrenBounded(\n         // the beginning of 'name'.\n         absl::string_view relative_path(name);\n         if (!absl::ConsumePrefix(&relative_path, object_prefix)) {\n-          return errors::Internal(strings::StrCat(\n-              \"Unexpected response: the returned file name \", name,\n-              \" doesn't match the prefix \", object_prefix));\n+          return errors::Internal(\n+              absl::StrCat(\"Unexpected response: the returned file name \", name,\n+                           \" doesn't match the prefix \", object_prefix));\n         }\n         if (!relative_path.empty() || include_self_directory_marker) {\n           result->emplace_back(relative_path);\n@@ -2180,7 +2178,7 @@ absl::Status GcsFileSystem::DeleteRecursively(const string& dirname,\n     *undeleted_dirs = 1;\n     return absl::Status(\n         absl::StatusCode::kNotFound,\n-        strings::StrCat(dirname, \" doesn't exist or not a directory.\"));\n+        absl::StrCat(dirname, \" doesn't exist or not a directory.\"));\n   }\n   std::vector<string> all_objects;\n   // Get all children in the directory recursively."
        }
    ],
    "stats": {
        "total": 40,
        "additions": 19,
        "deletions": 21
    }
}