{
    "author": "bchetioui",
    "message": "[XLA:GPU] Add a new runtime intrinsic custom call that allows logging the content\nof any number of arrays.\n\nIt allows specifying a format for logging, following the convention of\n`absl::Substitute` (i.e. argument 0 corresponds to string `$0`, argument 1 to\nstring `$1`, and so on).\n\nPiperOrigin-RevId: 809971519",
    "sha": "2499c21893683fde9d60f3f3f7d9f51a97548296",
    "files": [
        {
            "sha": "bd828625f914ecbbefcb663e595bef3797dc470b",
            "filename": "third_party/xla/xla/service/gpu/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD?ref=2499c21893683fde9d60f3f3f7d9f51a97548296",
            "patch": "@@ -2779,6 +2779,7 @@ tsl_gpu_library(\n     srcs = [\"runtime_intrinsics.cc\"],\n     hdrs = [\"runtime_intrinsics.h\"],\n     deps = [\n+        \"//xla:literal\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n         \"//xla:xla_data_proto_cc\",\n@@ -2788,8 +2789,10 @@ tsl_gpu_library(\n         \"//xla/service:custom_call_status\",\n         \"//xla/service:custom_call_target_registry\",\n         \"//xla/service:platform_util\",\n+        \"//xla/stream_executor:memory_allocation\",\n         \"//xla/stream_executor:stream\",\n         \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n@@ -2807,9 +2810,14 @@ xla_test(\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/tests:hlo_test_base\",\n         \"//xla/tests:xla_internal_test_main\",\n+        \"//xla/tsl/platform:status_matchers\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"@com_google_absl//absl/base:log_severity\",\n+        \"@com_google_absl//absl/log:scoped_mock_log\",\n+        \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_googletest//:gtest\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n "
        },
        {
            "sha": "d919e88d93ec10a9888607355e9af93d390e80e4",
            "filename": "third_party/xla/xla/service/gpu/runtime_intrinsics.cc",
            "status": "modified",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics.cc?ref=2499c21893683fde9d60f3f3f7d9f51a97548296",
            "patch": "@@ -16,22 +16,33 @@ limitations under the License.\n #include \"xla/service/gpu/runtime_intrinsics.h\"\n \n #include <cstdint>\n+#include <memory>\n #include <string>\n+#include <vector>\n \n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/ascii.h\"\n+#include \"absl/strings/match.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_replace.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/strings/substitute.h\"\n #include \"xla/ffi/ffi.h\"\n #include \"xla/ffi/ffi_api.h\"\n+#include \"xla/layout_util.h\"\n+#include \"xla/literal.h\"\n #include \"xla/service/collective_ops_utils.h\"\n #include \"xla/service/custom_call_status.h\"\n #include \"xla/service/custom_call_target_registry.h\"\n #include \"xla/service/platform_util.h\"\n+#include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n+#include \"xla/stream_executor/memory_allocation.h\"\n #include \"xla/stream_executor/stream.h\"\n #include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -70,8 +81,69 @@ void NopReturnTokenCustomCall(void* stream_handle, void** buffers,\n   VLOG(1) << \"NopReturnTokenCustomCall called.\";\n }\n \n+absl::Status DebugPrintCustomCall(se::Stream* stream, ffi::RemainingArgs args,\n+                                  absl::string_view format,\n+                                  ffi::Result<ffi::Buffer<xla::TOKEN>> res) {\n+  if (!stream) {\n+    return Internal(\"Stream is nullptr.\");\n+  }\n+\n+  std::vector<ffi::AnyBuffer> args_buffers;\n+  args_buffers.reserve(args.size());\n+  for (int i = 0; i < args.size(); ++i) {\n+    absl::StatusOr<ffi::AnyBuffer> arg = args.get<ffi::AnyBuffer>(i);\n+    if (!arg.ok()) {\n+      return arg.status();\n+    }\n+    args_buffers.push_back(*arg);\n+  }\n+\n+  std::string formatted(format);\n+\n+  // Iterate in reverse order to match the longest string to substitute first.\n+  for (int i = args_buffers.size() - 1; i >= 0; --i) {\n+    std::string to_substitute = absl::StrCat(\"$\", i);\n+    if (!absl::StrContains(formatted, to_substitute)) {\n+      return absl::FailedPreconditionError(absl::Substitute(\n+          \"Missing formatter for argument $0 in debug print custom call\", i));\n+    }\n+    const ffi::AnyBuffer& arg = args_buffers[i];\n+    int64_t size_bytes = arg.size_bytes();\n+    TF_ASSIGN_OR_RETURN(std::unique_ptr<se::MemoryAllocation> host_buffer,\n+                        stream->parent()->HostMemoryAllocate(size_bytes));\n+    TF_RETURN_IF_ERROR(\n+        stream->Memcpy(host_buffer->opaque(), arg.device_memory(), size_bytes));\n+    TF_RETURN_IF_ERROR(stream->BlockHostUntilDone());\n+\n+    Shape shape = ShapeUtil::MakeShape(arg.element_type(), arg.dimensions());\n+    LayoutUtil::SetToDefaultLayout(&shape);\n+    MutableBorrowingLiteral literal(static_cast<char*>(host_buffer->opaque()),\n+                                    shape);\n+    formatted =\n+        absl::StrReplaceAll(formatted, {{to_substitute, literal.ToString()}});\n+  }\n+\n+  LOG(INFO) << formatted;\n+\n+  return absl::OkStatus();\n+}\n+\n }  // namespace\n \n+// This custom call copies its arguments to the host and pretty-prints them as\n+// an info log. It takes in a \"format\" attribute to help identify the arguments\n+// in the log. \"Format\" follows the convention of `absl::Substitute`, i.e.,\n+// positional arguments are specified by `$0`, `$1`, etc.\n+XLA_FFI_DEFINE_HANDLER(kXlaGpuDebugPrintCustomCall, DebugPrintCustomCall,\n+                       ffi::Ffi::Bind()\n+                           .Ctx<ffi::Stream>()\n+                           .RemainingArgs()\n+                           .Attr<absl::string_view>(\"format\")\n+                           .Ret<xla::ffi::Buffer<xla::TOKEN>>());\n+\n+XLA_FFI_REGISTER_HANDLER(ffi::GetXlaFfiApi(), kXlaGpuDebugPrintCustomCallTag,\n+                         GetGpuPlatformName(), kXlaGpuDebugPrintCustomCall);\n+\n XLA_FFI_DEFINE_HANDLER(kXlaGpuAssertCustomCall, AssertionCustomCall,\n                        ffi::Ffi::Bind()\n                            .Ctx<ffi::Stream>()"
        },
        {
            "sha": "2b522a899f86dc708ed882d5dc17d5871f82d880",
            "filename": "third_party/xla/xla/service/gpu/runtime_intrinsics.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics.h?ref=2499c21893683fde9d60f3f3f7d9f51a97548296",
            "patch": "@@ -23,6 +23,9 @@ namespace xla {\n inline constexpr absl::string_view kXlaGpuAssertCustomCallTag =\n     \"__xla_gpu_assert\";\n \n+inline constexpr absl::string_view kXlaGpuDebugPrintCustomCallTag =\n+    \"__xla_gpu_debug_print\";\n+\n }  // namespace xla\n \n #endif  // XLA_SERVICE_GPU_RUNTIME_INTRINSICS_H_"
        },
        {
            "sha": "6644623f000281ab42c69c2dacf452c46d26043d",
            "filename": "third_party/xla/xla/service/gpu/runtime_intrinsics_test.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 1,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2499c21893683fde9d60f3f3f7d9f51a97548296/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fruntime_intrinsics_test.cc?ref=2499c21893683fde9d60f3f3f7d9f51a97548296",
            "patch": "@@ -16,18 +16,25 @@ limitations under the License.\n #include <memory>\n #include <utility>\n \n+#include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/base/log_severity.h\"\n+#include \"absl/log/scoped_mock_log.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/tests/hlo_test_base.h\"\n-#include \"tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n \n namespace xla {\n namespace gpu {\n namespace {\n \n using RuntimeIntrinsicsTest = HloTestBase;\n \n+using ::testing::EndsWith;\n+using ::testing::HasSubstr;\n+\n TEST_F(RuntimeIntrinsicsTest, NopReturnTokenWorks) {\n   constexpr absl::string_view kHloText = R\"(\n HloModule m\n@@ -82,6 +89,57 @@ ENTRY e {\n   EXPECT_FALSE(Run(std::move(module), /*run_hlo_passes=*/false));\n }\n \n+TEST_F(RuntimeIntrinsicsTest, DebugPrintCustomCallFailsWhenFormatIsMissing) {\n+  constexpr absl::string_view kHloText = R\"(\n+HloModule m\n+\n+ENTRY e {\n+  constant = f32[2]{0} constant({1, 2})\n+  ROOT print_token = token[] custom-call(constant),\n+    backend_config=\"{format = \\\"test format\\\"}\",\n+    custom_call_target=\"__xla_gpu_debug_print\",\n+    custom_call_has_side_effect=true,\n+    api_version=API_VERSION_TYPED_FFI\n+})\";\n+\n+  ::testing::AssertionResult result = Run(kHloText, /*run_hlo_passes=*/false);\n+  EXPECT_FALSE(result);\n+  EXPECT_THAT(result.message(), HasSubstr(\"Missing formatter for argument 0\"));\n+}\n+\n+TEST_F(RuntimeIntrinsicsTest, DebugPrintCustomCallWithCorrectLogsAsInfo) {\n+  constexpr absl::string_view kHloText = R\"(\n+HloModule m\n+\n+ENTRY e {\n+  constant = f32[2]{0} constant({1, 2})\n+  constant2 = f16[3]{0} constant({3, 4, 5})\n+  ROOT print_token = token[] custom-call(constant, constant2),\n+    backend_config=\"{format = \\\"test format $0 $1\\\"}\",\n+    custom_call_target=\"__xla_gpu_debug_print\",\n+    custom_call_has_side_effect=true,\n+    api_version=API_VERSION_TYPED_FFI\n+})\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          GetOptimizedModule(kHloText));\n+\n+  // The parameters of the custom call are not removed.\n+  EXPECT_EQ(module->entry_computation()->instruction_count(), 3);\n+  absl::ScopedMockLog mock_log(absl::MockLogDefault::kIgnoreUnexpected);\n+  EXPECT_CALL(mock_log,\n+              Log(absl::LogSeverity::kInfo, EndsWith(\"runtime_intrinsics.cc\"),\n+                  HasSubstr(\"test format f32[2] {1, 2} f16[3] {3, 4, 5}\")));\n+  // Run the program once before starting capturing the locks. This works around\n+  // a deadlock caused by ScopedMockLog.\n+  std::unique_ptr<HloModule> module2 = module->Clone();\n+  EXPECT_TRUE(Run(std::move(module2), /*run_hlo_passes=*/false));\n+  mock_log.StartCapturingLogs();\n+  // Runs successfully and logs the expected info.\n+  EXPECT_TRUE(Run(std::move(module), /*run_hlo_passes=*/false));\n+  mock_log.StopCapturingLogs();\n+}\n+\n }  // namespace\n }  // namespace gpu\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 145,
        "additions": 143,
        "deletions": 2
    }
}