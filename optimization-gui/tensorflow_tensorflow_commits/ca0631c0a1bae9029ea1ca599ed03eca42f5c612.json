{
    "author": "tensorflower-gardener",
    "message": "[SymbolicMap] Add basic simplifications for Add and Mul when we create them\n\nAdded basic simplifications to + and * operators to mimetize what we currently have in AffineMap. Sadly IndexingMapTests are a bit contradictory and rely too much in that simplifications. We will use our own canonicalization after fully merging.\n\nTo be clean, I introduced SimplifyMulByConstantRHS: A new helper function to encapsulate the simplification rules for multiplications where the right-hand side is a constant. This includes constant folding, handling neutral elements (0 and 1) and associativity.\n\nAdapted some tests for SymbolicExpr and SymbolicMap so these simplifications are not triggered.\n\nPiperOrigin-RevId: 831291456",
    "sha": "ca0631c0a1bae9029ea1ca599ed03eca42f5c612",
    "files": [
        {
            "sha": "9e5c36ac15c01af0011db20331f86bdb864515c9",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr.cc",
            "status": "modified",
            "additions": 74,
            "deletions": 14,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ca0631c0a1bae9029ea1ca599ed03eca42f5c612/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ca0631c0a1bae9029ea1ca599ed03eca42f5c612/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc?ref=ca0631c0a1bae9029ea1ca599ed03eca42f5c612",
            "patch": "@@ -221,6 +221,21 @@ void ExtractTerms(SymbolicExpr expr,\n   }\n }\n \n+// TODO(b/459357586): Remove this function and use CanonicalizeAdd instead.\n+SymbolicExpr BasicAddSimplify(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  if (rhs.GetType() == SymbolicExprType::kConstant && rhs.GetValue() == 0) {\n+    return lhs;\n+  }\n+  if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n+    return rhs;\n+  }\n+  if (lhs.GetType() == SymbolicExprType::kConstant &&\n+      rhs.GetType() == SymbolicExprType::kConstant) {\n+    return lhs.GetContext()->CreateConstant(lhs.GetValue() + rhs.GetValue());\n+  }\n+  return lhs.GetContext()->CreateBinaryOp(SymbolicExprType::kAdd, lhs, rhs);\n+}\n+\n SymbolicExpr CanonicalizeAdd(SymbolicExpr lhs, SymbolicExpr rhs) {\n   SymbolicExprContext* ctx = lhs.GetContext();\n \n@@ -272,25 +287,66 @@ SymbolicExpr CanonicalizeAdd(SymbolicExpr lhs, SymbolicExpr rhs) {\n   return result;\n }\n \n-SymbolicExpr CanonicalizeMul(SymbolicExpr lhs, SymbolicExpr rhs) {\n+// Helper to simplify multiplication when the RHS is a constant.\n+SymbolicExpr SimplifyMulByConstantRHS(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  if (rhs.GetType() != SymbolicExprType::kConstant) {\n+    return SymbolicExpr();\n+  }\n+  int64_t rhs_val = rhs.GetValue();\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  if (rhs_val == 0) {\n+    return rhs;  // x * 0 = 0\n+  }\n+  if (rhs_val == 1) {\n+    return lhs;  // x * 1 = x\n+  }\n+  if (lhs.GetType() == SymbolicExprType::kConstant) {\n+    return ctx->CreateConstant(lhs.GetValue() * rhs_val);\n+  }\n+\n+  // Associativity: (X * C1) * C2 => X * (C1 * C2)\n+  if (lhs.GetType() == SymbolicExprType::kMul &&\n+      lhs.GetRHS().GetType() == SymbolicExprType::kConstant) {\n+    return ctx->CreateBinaryOp(\n+        SymbolicExprType::kMul, lhs.GetLHS(),\n+        ctx->CreateConstant(lhs.GetRHS().GetValue() * rhs_val));\n+  }\n+  return SymbolicExpr();\n+}\n+\n+SymbolicExpr BasicMulSimplify(SymbolicExpr lhs, SymbolicExpr rhs) {\n   SymbolicExprContext* ctx = lhs.GetContext();\n \n-  // Neutral Elements\n+  // Try constant folding, neutral element simplification, and associativity.\n   if (rhs.GetType() == SymbolicExprType::kConstant) {\n-    if (rhs.GetValue() == 0) {\n-      return rhs;  // x * 0 = 0\n+    SymbolicExpr simplified = SimplifyMulByConstantRHS(lhs, rhs);\n+    if (simplified) {\n+      return simplified;\n     }\n-    if (rhs.GetValue() == 1) {\n-      return lhs;  // x * 1 = x\n+  } else if (lhs.GetType() == SymbolicExprType::kConstant) {\n+    SymbolicExpr simplified = SimplifyMulByConstantRHS(rhs, lhs);\n+    if (simplified) {\n+      return simplified;\n     }\n   }\n \n-  // Associativity: (X * C1) * C2 => X * (C1 * C2)\n-  if (lhs.GetType() == SymbolicExprType::kMul &&\n-      lhs.GetRHS().GetType() == SymbolicExprType::kConstant &&\n-      rhs.GetType() == SymbolicExprType::kConstant) {\n-    return (lhs.GetLHS() * (lhs.GetRHS().GetValue() * rhs.GetValue()))\n-        .Canonicalize();\n+  return ctx->CreateBinaryOp(SymbolicExprType::kMul, lhs, rhs);\n+}\n+\n+SymbolicExpr CanonicalizeMul(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  if (rhs.GetType() == SymbolicExprType::kConstant) {\n+    // Try constant folding, neutral element simplification, and associativity.\n+    SymbolicExpr simplified = SimplifyMulByConstantRHS(lhs, rhs);\n+    if (simplified) {\n+      if (simplified.GetType() == SymbolicExprType::kConstant ||\n+          simplified == lhs) {\n+        return simplified;\n+      }\n+      return simplified.Canonicalize();\n+    }\n   }\n \n   // Distribute Mul over Add: (A + B) * C => (A * C) + (B * C)\n@@ -837,7 +893,9 @@ SymbolicExpr SymbolicExpr::operator+(int64_t v) const {\n   return *this + GetContext()->CreateConstant(v);\n }\n SymbolicExpr SymbolicExpr::operator+(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kAdd, *this, other);\n+  // TODO(b/433693782): We should use our own canonicalization here instead of\n+  // relying on a similar one to AffineMap so tests do not fail.\n+  return BasicAddSimplify(*this, other);\n }\n \n SymbolicExpr SymbolicExpr::operator-() const {\n@@ -852,7 +910,9 @@ SymbolicExpr SymbolicExpr::operator*(int64_t v) const {\n   return *this * GetContext()->CreateConstant(v);\n }\n SymbolicExpr SymbolicExpr::operator*(SymbolicExpr other) const {\n-  return GetContext()->CreateBinaryOp(SymbolicExprType::kMul, *this, other);\n+  // TODO(b/433693782): We should use our own canonicalization here instead of\n+  // relying on a similar one to AffineMap so tests do not fail.\n+  return BasicMulSimplify(*this, other);\n }\n \n SymbolicExpr SymbolicExpr::operator%(int64_t v) const {"
        },
        {
            "sha": "ff1ad4cd8cc01a3b73cf1be38744a71e2a7fbf2f",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 3,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ca0631c0a1bae9029ea1ca599ed03eca42f5c612/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ca0631c0a1bae9029ea1ca599ed03eca42f5c612/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc?ref=ca0631c0a1bae9029ea1ca599ed03eca42f5c612",
            "patch": "@@ -203,14 +203,13 @@ TEST_F(SymbolicExprTest, ReplaceWithMap) {\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n   SymbolicExpr c2 = ctx.CreateConstant(2);\n   SymbolicExpr c5 = ctx.CreateConstant(5);\n-  SymbolicExpr c10 = ctx.CreateConstant(10);\n \n   SymbolicExpr expr = (d0 + c2) * (d1 + c2);\n \n   llvm::DenseMap<SymbolicExpr, SymbolicExpr> replace_expression;\n   replace_expression[d0 + c2] = c5;\n-  replace_expression[d1] = c10;\n-  EXPECT_EQ(expr.Replace(replace_expression), c5 * (c10 + c2));\n+  replace_expression[d1] = d0;\n+  EXPECT_EQ(expr.Replace(replace_expression), c5 * (d0 + c2));\n \n   llvm::DenseMap<SymbolicExpr, SymbolicExpr> replace_constant;\n   replace_constant[c2] = d0;\n@@ -226,6 +225,39 @@ TEST_F(SymbolicExprTest, ReplaceWithMap) {\n   EXPECT_EQ(expr.Replace(no_change), expr);\n }\n \n+TEST_F(SymbolicExprTest, BasicSimplificationsAtCreationTime) {\n+  auto c0 = ctx.CreateConstant(0);\n+  auto c1 = ctx.CreateConstant(1);\n+  auto c3 = ctx.CreateConstant(3);\n+\n+  // x + 0 = x\n+  EXPECT_EQ(v0 + c0, v0);\n+  EXPECT_EQ(c0 + v0, v0);\n+  EXPECT_EQ(c2 + c1, c3);\n+\n+  // TODO(b/459357586): This will be canonicalized to (v0 + 2) in the future.\n+  EXPECT_NE(v0 + c2, c2 + v0);\n+\n+  // x * 0 = 0\n+  EXPECT_EQ(v0 * c0, c0);\n+  EXPECT_EQ(c0 * v0, c0);\n+  EXPECT_EQ(c2 * c0, c0);\n+\n+  // x * 1 = x\n+  EXPECT_EQ(v0 * c1, v0);\n+  EXPECT_EQ(c1 * v0, v0);\n+  EXPECT_EQ(c2 * c1, c2);\n+\n+  // Associativity: (X * C1) * C2 = X * (C1 * C2)\n+  EXPECT_EQ(((v0 * 2) * 3), v0 * 6);\n+\n+  // No associativity if constant is on LHS of outer mul.\n+  // TODO(b/459357586): This will be canonicalized to (v0 * 6) in the future.\n+  SymbolicExpr mul_2_v0 = ctx.CreateConstant(2) * v0;\n+  SymbolicExpr mul_2_v0_3 = mul_2_v0 * 3;\n+  EXPECT_EQ(mul_2_v0_3.ToString(), \"((2 * v0) * 3)\");\n+}\n+\n TEST_F(SymbolicExprTest, Canonicalization_Basic) {\n   SymbolicExpr constants = (c2 * 3) + 5;\n   EXPECT_EQ(constants.Canonicalize().ToString(), \"11\");"
        },
        {
            "sha": "7b40b604115ea6485f17d5d60fad25de8e8f97a3",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ca0631c0a1bae9029ea1ca599ed03eca42f5c612/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ca0631c0a1bae9029ea1ca599ed03eca42f5c612/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc?ref=ca0631c0a1bae9029ea1ca599ed03eca42f5c612",
            "patch": "@@ -133,8 +133,8 @@ TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n   SymbolicExpr c3 = ctx.CreateConstant(30);\n \n   SymbolicMap replaced_basic = sample_map.ReplaceDimsAndSymbols(\n-      {c10, c2}, {c3, d0}, sample_map.GetNumDims(), sample_map.GetNumSymbols());\n-  EXPECT_THAT(replaced_basic.GetResults(), ElementsAre(c10 + c3, c2 * d0));\n+      {d1, c2}, {c3, d0}, sample_map.GetNumDims(), sample_map.GetNumSymbols());\n+  EXPECT_THAT(replaced_basic.GetResults(), ElementsAre(d1 + c3, c2 * d0));\n \n   SymbolicMap map_empty = SymbolicMap::Get(&ctx, 0, 0, {});\n   SymbolicMap replaced_empty = map_empty.ReplaceDimsAndSymbols({}, {}, 0, 0);"
        }
    ],
    "stats": {
        "total": 130,
        "additions": 111,
        "deletions": 19
    }
}