{
    "author": "zvikinoza",
    "message": "UnflattenCallGraph as candidates of duplication only considers HloComputations for which there exists other computations with matching number of instructions.\n\nPiperOrigin-RevId: 834222000",
    "sha": "d4707c5355e9c2b2f19ae1f93526493ff2dc824f",
    "files": [
        {
            "sha": "32040bec0327eb12c18ebed6f5f1a4181ca01b04",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/unflatten_call_graph.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 4,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d4707c5355e9c2b2f19ae1f93526493ff2dc824f/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Funflatten_call_graph.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d4707c5355e9c2b2f19ae1f93526493ff2dc824f/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Funflatten_call_graph.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Funflatten_call_graph.cc?ref=d4707c5355e9c2b2f19ae1f93526493ff2dc824f",
            "patch": "@@ -45,30 +45,44 @@ limitations under the License.\n namespace xla {\n \n namespace {\n-\n // Struct to hold all call instructions and called computations in a module.\n struct HloCalls {\n   // All callsites are guaranteed to be `kCall` instructions.\n-  std::vector<HloInstruction*> call_sites;\n+  absl::flat_hash_set<HloInstruction*> call_sites;\n   absl::flat_hash_set<HloComputation*> targets;\n };\n \n // Iterates through all instructions in the module's computations\n-// and collects all `HloInstruction`s with opcode `kCall` into 'calls_sites'\n+// and collects all `HloInstruction`s with opcode `kCall` into 'call_sites'\n // and all unique computations targeted by these calls into 'targets'.\n HloCalls CollectHloCalls(\n     HloModule* module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n   std::unique_ptr<CallGraph> call_graph = CallGraph::Build(module);\n   HloCalls calls;\n+  absl::flat_hash_map<uint64_t, uint64_t> count_num_instructions;\n   for (const CallGraphNode& node : call_graph->nodes()) {\n     for (const CallSite& callsite : node.callsites()) {\n       if (callsite.instruction()->opcode() == HloOpcode::kCall) {\n-        calls.call_sites.push_back(callsite.instruction());\n+        calls.call_sites.insert(callsite.instruction());\n         calls.targets.insert(callsite.instruction()->to_apply());\n+        ++count_num_instructions\n+            [callsite.instruction()->to_apply()->instruction_count()];\n       }\n     }\n   }\n+  // Remove computations for which there is no other computation with matching\n+  // number of instructions (i.e. it cannot have duplicate)\n+  for (auto it = calls.call_sites.begin(), end = calls.call_sites.end();\n+       it != end;) {\n+    // `erase()` will invalidate `it`, so advance `it` first.\n+    auto copy_it = it++;\n+    HloComputation* computation = (*copy_it)->to_apply();\n+    if (count_num_instructions[computation->instruction_count()] == 1) {\n+      calls.targets.erase(computation);\n+      calls.call_sites.erase(copy_it);\n+    }\n+  }\n   return calls;\n }\n }  // namespace"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 18,
        "deletions": 4
    }
}