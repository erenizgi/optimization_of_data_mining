{
    "author": "hhb",
    "message": "Add a PJRT C API extension for TPU topology.\n\nPiperOrigin-RevId: 835420298",
    "sha": "7ebeb5ae70991cad990e84378c7ad4f08d176265",
    "files": [
        {
            "sha": "ef965627ad4b40752170bb97b7ba2fee8332d1ac",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -63,6 +63,12 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"pjrt_c_api_tpu_topology_extension_hdrs\",\n+    hdrs = [\"pjrt_c_api_tpu_topology_extension.h\"],\n+    deps = [\":pjrt_c_api_hdrs\"],\n+)\n+\n cc_library(\n     name = \"pjrt_c_api_ffi_extension_hdrs\",\n     hdrs = [\"pjrt_c_api_ffi_extension.h\"],"
        },
        {
            "sha": "9b1167da9e3c0907fbac7d2fbd8982694461a7eb",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -69,6 +69,7 @@ typedef enum {\n   PJRT_Extension_Type_ExecutableMetadata,\n   PJRT_Extension_Type_Callback,\n   PJRT_Extension_Type_HostAllocator,  // Experimental.\n+  PJRT_Extension_Type_TpuTopology,\n } PJRT_Extension_Type;\n \n // PJRT_Extension_Base contains a type and a pointer to next"
        },
        {
            "sha": "c6a9c1b89778a74e3ac5a246abea77e432283977",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_tpu_topology_extension.h",
            "status": "added",
            "additions": 501,
            "deletions": 0,
            "changes": 501,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_tpu_topology_extension.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_tpu_topology_extension.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_tpu_topology_extension.h?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -0,0 +1,501 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PJRT_C_PJRT_C_API_TPU_TOPOLOGY_EXTENSION_H_\n+#define XLA_PJRT_C_PJRT_C_API_TPU_TOPOLOGY_EXTENSION_H_\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#include \"xla/pjrt/c/pjrt_c_api.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+// This extension provides functionality related to TPU topology.\n+\n+#define PJRT_API_TPU_TOPOLOGY_EXTENSION_VERSION 1\n+\n+struct PJRT_TpuTopology_Subslice_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  const int32_t* chips_per_host_bounds;\n+  size_t chips_per_host_bounds_num_dims;\n+  const int32_t* host_bounds;\n+  size_t host_bounds_num_dims;\n+\n+  // Owned by the caller. Should be destroyed by calling\n+  // PJRT_TpuTopology_Destroy.\n+  PJRT_TopologyDescription* subslice_topology;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_Subslice_Args, subslice_topology);\n+\n+// Returns a subslice topology of the given topology.\n+typedef PJRT_Error* PJRT_TpuTopology_Subslice(\n+    PJRT_TpuTopology_Subslice_Args* args);\n+\n+struct PJRT_TpuTopology_IsSubsliceTopology_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  bool is_subslice_topology;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_IsSubsliceTopology_Args,\n+                          is_subslice_topology);\n+\n+// Returns true if the topology is a subslice topology.\n+typedef PJRT_Error* PJRT_TpuTopology_IsSubsliceTopology(\n+    PJRT_TpuTopology_IsSubsliceTopology_Args* args);\n+\n+typedef struct PJRT_TpuTopology_SubsliceDeviceIdFromFullDeviceId_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* client_topology;\n+  const PJRT_TopologyDescription* subslice_topology;\n+  const int32_t* subslice_origin;\n+  size_t subslice_origin_dim_num;\n+  int32_t full_device_id;\n+\n+  int32_t subslice_device_id;  // out\n+} PJRT_TpuTopology_SubsliceDeviceIdFromFullDeviceId_Args;\n+PJRT_DEFINE_STRUCT_TRAITS(\n+    PJRT_TpuTopology_SubsliceDeviceIdFromFullDeviceId_Args, subslice_device_id);\n+\n+// Returns the subslice device id for the given full device id.\n+typedef PJRT_Error* PJRT_TpuTopology_SubsliceDeviceIdFromFullDeviceId(\n+    PJRT_TpuTopology_SubsliceDeviceIdFromFullDeviceId_Args* args);\n+\n+typedef struct PJRT_TpuTopology_ReplaceHostBounds_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  const int32_t* host_bounds;\n+  size_t host_bounds_dim_num;\n+\n+  // Owned by the caller. Should be destroyed by calling\n+  // PJRT_TpuTopology_Destroy.\n+  PJRT_TopologyDescription* new_topology;  // out\n+} PJRT_TpuTopology_ReplaceHostBounds_Args;\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ReplaceHostBounds_Args,\n+                          new_topology);\n+\n+// Returns a new PjRtTopologyDescription by replacing the host bounds of the\n+// input `topology` with the provided `host_bounds`.\n+typedef PJRT_Error* PJRT_TpuTopology_ReplaceHostBounds(\n+    PJRT_TpuTopology_ReplaceHostBounds_Args* args);\n+\n+typedef struct PJRT_TpuTopology_IsEnhancedBarrierEnabled_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  bool is_enhanced_barrier_enabled;  // out\n+} PJRT_TpuTopology_IsEnhancedBarrierEnabled_Args;\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_IsEnhancedBarrierEnabled_Args,\n+                          is_enhanced_barrier_enabled);\n+\n+// Returns true if the enhanced barrier is enabled in the given TPU topology.\n+typedef PJRT_Error* PJRT_TpuTopology_IsEnhancedBarrierEnabled(\n+    PJRT_TpuTopology_IsEnhancedBarrierEnabled_Args* args);\n+\n+typedef struct PJRT_TpuTopology_HasLimitedIciConnectivity_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  bool has_limited_ici_connectivity;  // out\n+} PJRT_TpuTopology_HasLimitedIciConnectivity_Args;\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_HasLimitedIciConnectivity_Args,\n+                          has_limited_ici_connectivity);\n+\n+// Returns true if the given TPU topology has limited ICI connectivity.\n+typedef PJRT_Error* PJRT_TpuTopology_HasLimitedIciConnectivity(\n+    PJRT_TpuTopology_HasLimitedIciConnectivity_Args* args);\n+\n+typedef struct PJRT_TpuTopology_IsReachableOverLimitedIci_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t source_chip_id;\n+  int32_t dest_chip_id;\n+  bool is_reachable_over_limited_ici;  // out\n+} PJRT_TpuTopology_IsReachableOverLimitedIci_Args;\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_IsReachableOverLimitedIci_Args,\n+                          is_reachable_over_limited_ici);\n+\n+// Returns true if `source_chip_id` can directly reach `dest_chip_id` on a TPU\n+// topology with limited ICI routing.\n+typedef PJRT_Error* PJRT_TpuTopology_IsReachableOverLimitedIci(\n+    PJRT_TpuTopology_IsReachableOverLimitedIci_Args* args);\n+\n+struct PJRT_TpuTopology_ProcessCount_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t process_count;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ProcessCount_Args, process_count);\n+\n+// Returns the number of processes in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ProcessCount(\n+    PJRT_TpuTopology_ProcessCount_Args* args);\n+\n+struct PJRT_TpuTopology_ChipsPerProcess_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t chips_per_process;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ChipsPerProcess_Args,\n+                          chips_per_process);\n+\n+// Returns the number of chips per process in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ChipsPerProcess(\n+    PJRT_TpuTopology_ChipsPerProcess_Args* args);\n+\n+struct PJRT_TpuTopology_CoreCountPerChip_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t core_count_of_default_type_per_chip;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_CoreCountPerChip_Args,\n+                          core_count_of_default_type_per_chip);\n+\n+// Returns the number of cores of default type per chip in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_CoreCountPerChip(\n+    PJRT_TpuTopology_CoreCountPerChip_Args* args);\n+\n+struct PJRT_TpuTopology_ChipCount_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t chip_count;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ChipCount_Args, chip_count);\n+\n+// Returns the number of total chips in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ChipCount(\n+    PJRT_TpuTopology_ChipCount_Args* args);\n+\n+struct PJRT_TpuTopology_CoreCount_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t core_count_of_default_type;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_CoreCount_Args,\n+                          core_count_of_default_type);\n+\n+// Returns the number of total cores of default type in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_CoreCount(\n+    PJRT_TpuTopology_CoreCount_Args* args);\n+\n+struct PJRT_TpuTopology_LogiDeviceCount_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t logical_device_count_of_default_type;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_LogiDeviceCount_Args,\n+                          logical_device_count_of_default_type);\n+\n+// Returns the number of total logical devices of default type in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_LogiDeviceCount(\n+    PJRT_TpuTopology_LogiDeviceCount_Args* args);\n+\n+struct PJRT_TpuTopology_LogiDeviceCountPerProcess_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t logical_device_count_of_default_type_per_process;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_LogiDeviceCountPerProcess_Args,\n+                          logical_device_count_of_default_type_per_process);\n+\n+// Returns the number of logical devices of default type per process in this\n+// topology.\n+typedef PJRT_Error* PJRT_TpuTopology_LogiDeviceCountPerProcess(\n+    PJRT_TpuTopology_LogiDeviceCountPerProcess_Args* args);\n+\n+struct PJRT_TpuTopology_LogiDeviceCountPerChip_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t logical_device_count_of_default_type_per_chip;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_LogiDeviceCountPerChip_Args,\n+                          logical_device_count_of_default_type_per_chip);\n+\n+// Returns the number of logical devices of default type per chip in this\n+// topology.\n+typedef PJRT_Error* PJRT_TpuTopology_LogiDeviceCountPerChip(\n+    PJRT_TpuTopology_LogiDeviceCountPerChip_Args* args);\n+\n+struct PJRT_TpuTopology_CoreCountPerProcess_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t core_count_of_default_type_per_process;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_CoreCountPerProcess_Args,\n+                          core_count_of_default_type_per_process);\n+\n+// Returns the number of cores per process in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_CoreCountPerProcess(\n+    PJRT_TpuTopology_CoreCountPerProcess_Args* args);\n+\n+struct PJRT_TpuTopology_ProcessIds_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  // The maximum number of process IDs that can be returned. If the topology has\n+  // more than max_process_ids processes, an error is returned.\n+  int32_t max_process_ids;\n+  // Points to an array of size max_process_ids. The process IDs will be\n+  // filled in this array.\n+  int32_t* process_ids;\n+  size_t num_process_ids;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ProcessIds_Args, num_process_ids);\n+\n+// Returns the process IDs in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ProcessIds(\n+    PJRT_TpuTopology_ProcessIds_Args* args);\n+\n+struct PJRT_TpuTopology_LogiDeviceIdsOnProcess_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t process_id;\n+  // The maximum number of device IDs that can be returned. If the topology has\n+  // more than max_logical_device_ids devices on the process, an error is\n+  // returned.\n+  int32_t max_logical_device_ids;\n+  // Points to an array of size max_logical_device_ids. The device IDs will be\n+  // filled in this array.\n+  int32_t* logical_device_of_default_type_ids;\n+  size_t num_logical_device_ids;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_LogiDeviceIdsOnProcess_Args,\n+                          num_logical_device_ids);\n+\n+// Returns the logical device of default type IDs on the given process.\n+typedef PJRT_Error* PJRT_TpuTopology_LogiDeviceIdsOnProcess(\n+    PJRT_TpuTopology_LogiDeviceIdsOnProcess_Args* args);\n+\n+struct PJRT_TpuTopology_ProcIdAndIdxOnProcForChip_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t chip_id;\n+  int32_t process_id;        // out\n+  int32_t index_on_process;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ProcIdAndIdxOnProcForChip_Args,\n+                          index_on_process);\n+\n+// Returns the process ID and index on process for the given chip.\n+typedef PJRT_Error* PJRT_TpuTopology_ProcIdAndIdxOnProcForChip(\n+    PJRT_TpuTopology_ProcIdAndIdxOnProcForChip_Args* args);\n+\n+struct PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t device_id;\n+  int32_t process_id;        // out\n+  int32_t index_on_process;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice_Args,\n+                          index_on_process);\n+\n+// Returns the process ID and index on process for the given logical device of\n+// default type.\n+typedef PJRT_Error* PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice(\n+    PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice_Args* args);\n+\n+struct PJRT_TpuTopology_ProcessCoordFromId_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t process_id;\n+  // The maximum dimension of coordinates that can be returned.\n+  // If the process has more than max_coords dimensions, an error is returned.\n+  size_t coords_max_dims;\n+  // Points to an array of size max_dims. The coordinates of the process will\n+  // be stored in this array.\n+  int32_t* coords;\n+  size_t coords_num_dims;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ProcessCoordFromId_Args,\n+                          coords_num_dims);\n+\n+// Returns the coordinates of the process with the given process ID.\n+typedef PJRT_Error* PJRT_TpuTopology_ProcessCoordFromId(\n+    PJRT_TpuTopology_ProcessCoordFromId_Args* args);\n+\n+struct PJRT_TpuTopology_ChipIdFromCoord_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  const int32_t* coords;\n+  size_t coords_num_dims;\n+  int32_t chip_id;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ChipIdFromCoord_Args, chip_id);\n+\n+// Returns the chip ID for the given coordinates.\n+typedef PJRT_Error* PJRT_TpuTopology_ChipIdFromCoord(\n+    PJRT_TpuTopology_ChipIdFromCoord_Args* args);\n+\n+struct PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  const int32_t* chip_coords;\n+  size_t chip_coords_num_dims;\n+  int32_t logical_device_index_on_chip;\n+  int32_t logical_device_of_default_type_id;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx_Args,\n+                          logical_device_of_default_type_id);\n+\n+// Returns the logical device of default type ID for the chip with the given\n+// coordinates and logical device index on chip.\n+typedef PJRT_Error* PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx(\n+    PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx_Args* args);\n+\n+struct PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  int32_t device_id;\n+  // The maximum dimension of coordinates that can be returned.\n+  // If the device has more than max_coords dimensions, an error is returned.\n+  size_t chip_coords_max_dims;\n+  // Points to an array of size max_dims. The coordinates of the device will\n+  // be stored in this array.\n+  int32_t* chip_coords;\n+  size_t chip_coords_num_dims;   // out\n+  int32_t device_index_on_chip;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice_Args,\n+                          device_index_on_chip);\n+\n+// Returns the coordinates of the chip containing the given logical device of\n+// default type, and the index of the logical device on the chip.\n+typedef PJRT_Error* PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice(\n+    PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice_Args* args);\n+\n+struct PJRT_TpuTopology_ChipsPerProcessBounds_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  // The maximum dimension of coordinates that can be returned.\n+  // If the process has more than max_coords dimensions, an error is returned.\n+  size_t chip_per_process_bounds_max_dims;\n+  // Points to an array of size max_dims. The bounds of the chips per process\n+  // will be stored in this array.\n+  int32_t* chip_per_process_bounds;\n+  size_t chip_per_process_bounds_num_dims;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ChipsPerProcessBounds_Args,\n+                          chip_per_process_bounds_num_dims);\n+\n+// Returns the bounds of the chips per process in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ChipsPerProcessBounds(\n+    PJRT_TpuTopology_ChipsPerProcessBounds_Args* args);\n+\n+struct PJRT_TpuTopology_ChipBounds_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  // The maximum dimension of coordinates that can be returned.\n+  // If the chip has more than max_coords dimensions, an error is returned.\n+  size_t chip_bounds_max_dims;\n+  // Points to an array of size max_dims. The bounds of the chip will be stored\n+  // in this array.\n+  int32_t* chip_bounds;\n+  size_t chip_bounds_num_dims;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ChipBounds_Args,\n+                          chip_bounds_num_dims);\n+\n+// Returns the bounds of the chip in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ChipBounds(\n+    PJRT_TpuTopology_ChipBounds_Args* args);\n+\n+struct PJRT_TpuTopology_ProcessBounds_Args {\n+  size_t struct_size;\n+\n+  const PJRT_TopologyDescription* topology;\n+  // The maximum dimension of coordinates that can be returned.\n+  // If the process has more than max_coords dimensions, an error is returned.\n+  size_t process_bounds_max_dims;\n+  // Points to an array of size max_dims. The bounds of the process will be\n+  // stored in this array.\n+  int32_t* process_bounds;\n+  size_t process_bounds_num_dims;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_ProcessBounds_Args,\n+                          process_bounds_num_dims);\n+\n+// Returns the bounds of the process in this topology.\n+typedef PJRT_Error* PJRT_TpuTopology_ProcessBounds(\n+    PJRT_TpuTopology_ProcessBounds_Args* args);\n+\n+typedef struct PJRT_TpuTopology_Extension {\n+  PJRT_Extension_Base base;\n+  PJRT_TpuTopology_Subslice* subslice;\n+  PJRT_TpuTopology_IsSubsliceTopology* is_subslice_topology;\n+  PJRT_TpuTopology_SubsliceDeviceIdFromFullDeviceId*\n+      subslice_device_id_from_full_device_id;\n+  PJRT_TpuTopology_ReplaceHostBounds* replace_host_bounds;\n+  PJRT_TpuTopology_IsEnhancedBarrierEnabled* is_enhanced_barrier_enabled;\n+  PJRT_TpuTopology_HasLimitedIciConnectivity* has_limited_ici_connectivity;\n+  PJRT_TpuTopology_IsReachableOverLimitedIci* is_reachable_over_limited_ici;\n+\n+  PJRT_TpuTopology_ProcessCount* process_count;\n+  PJRT_TpuTopology_ChipsPerProcess* chips_per_process;\n+  PJRT_TpuTopology_CoreCountPerChip* core_count_per_chip;\n+  PJRT_TpuTopology_ChipCount* chip_count;\n+  PJRT_TpuTopology_CoreCount* core_count;\n+  PJRT_TpuTopology_LogiDeviceCountPerProcess* logical_device_count_per_process;\n+  PJRT_TpuTopology_LogiDeviceCount* logical_device_count;\n+  PJRT_TpuTopology_LogiDeviceCountPerChip* logical_device_count_per_chip;\n+  PJRT_TpuTopology_CoreCountPerProcess* core_count_per_process;\n+  PJRT_TpuTopology_ProcessIds* process_ids;\n+  PJRT_TpuTopology_LogiDeviceIdsOnProcess* logical_device_ids_on_process;\n+  PJRT_TpuTopology_ProcIdAndIdxOnProcForChip* proc_id_and_idx_on_proc_for_chip;\n+  PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice*\n+      proc_id_and_idx_on_proc_for_logi_device;\n+  PJRT_TpuTopology_ProcessCoordFromId* process_coord_from_id;\n+  PJRT_TpuTopology_ChipIdFromCoord* chip_id_from_coord;\n+  PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx*\n+      logical_device_id_from_chip_coord_and_idx;\n+  PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice*\n+      chip_coord_and_idx_for_logi_device;\n+  PJRT_TpuTopology_ChipsPerProcessBounds* chips_per_process_bounds;\n+  PJRT_TpuTopology_ChipBounds* chip_bounds;\n+  PJRT_TpuTopology_ProcessBounds* process_bounds;\n+} PJRT_TpuTopology_Extension;\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_TpuTopology_Extension, process_bounds);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif  // XLA_PJRT_C_PJRT_C_API_TPU_TOPOLOGY_EXTENSION_H_"
        },
        {
            "sha": "01c4eb7776e13ca790edc11eb666d6fcec64287c",
            "filename": "third_party/xla/xla/pjrt/c_api_client/BUILD",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -54,6 +54,7 @@ cc_library(\n         \"//xla/pjrt:pjrt_common\",\n         \"//xla/pjrt:pjrt_compiler\",\n         \"//xla/pjrt:pjrt_device_description\",\n+        \"//xla/pjrt:pjrt_device_dimensions\",\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_layout\",\n         \"//xla/pjrt:string_utils\",\n@@ -65,6 +66,7 @@ cc_library(\n         \"//xla/pjrt/c:pjrt_c_api_phase_compile_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_profiler_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_stream_extension_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_tpu_topology_extension_hdrs\",\n         \"//xla/pjrt/distributed:key_value_store_interface\",\n         \"//xla/pjrt/extensions/cross_host_transfers:pjrt_c_api_cross_host_transfer_extension\",\n         \"//xla/pjrt/extensions/executable_metadata:executable_metadata_extension\",\n@@ -143,3 +145,21 @@ xla_cc_test(\n         \"@stablehlo//:version\",\n     ],\n )\n+\n+xla_cc_test(\n+    name = \"pjrt_c_api_client_tpu_test\",\n+    srcs = [\"pjrt_c_api_client_tpu_test.cc\"],\n+    tags = [\"no_oss\"],\n+    deps = [\n+        \":pjrt_c_api_client\",\n+        \"//xla/pjrt:pjrt_common\",\n+        \"//xla/pjrt:pjrt_compiler\",\n+        \"//xla/pjrt:pjrt_device_dimensions\",\n+        \"//xla/pjrt/plugin/xla_tpu:xla_tpu_pjrt_client\",  # buildcleaner: keep\n+        \"//xla/tsl/platform:status_matchers\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)"
        },
        {
            "sha": "979c5370113b2c012a1f81921203a57291ba8bfd",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 396,
            "deletions": 0,
            "changes": 396,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -61,6 +61,7 @@ limitations under the License.\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_profiler_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_stream_extension.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_tpu_topology_extension.h\"\n #include \"xla/pjrt/c_api_client/pjrt_c_api_phase_compiler.h\"\n #include \"xla/pjrt/distributed/key_value_store_interface.h\"\n #include \"xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.h\"\n@@ -73,6 +74,7 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_device_description.h\"\n+#include \"xla/pjrt/pjrt_device_dimensions.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/pjrt/proto/compile_options.pb.h\"\n@@ -93,6 +95,8 @@ limitations under the License.\n \n namespace xla {\n \n+constexpr int kMaxDims = 4;\n+\n // Helper macros\n \n // Return error future if not success and frees the PJRT_Error returned by\n@@ -3169,6 +3173,8 @@ PjRtCApiTopologyDescription::PjRtCApiTopologyDescription(\n     const PJRT_Api* c_api, PJRT_TopologyDescription* c_topology, bool owned)\n     : compiler_(std::make_unique<PjRtCApiCompiler>(c_api)),\n       c_api_(c_api),\n+      tpu_topology_extension_(pjrt::FindExtension<PJRT_TpuTopology_Extension>(\n+          c_api, PJRT_Extension_Type::PJRT_Extension_Type_TpuTopology)),\n       c_topology_(c_topology),\n       platform_name_(::pjrt::PlatformName(c_api, c_topology)),\n       platform_id_(tsl::Fingerprint64(platform_name_)) {\n@@ -3291,6 +3297,396 @@ void PjRtCApiTopologyDescription::InitAttributes() {\n       pjrt::ConvertFromPjRtNamedValueList(args.attributes, args.num_attributes);\n }\n \n+absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>>\n+PjRtCApiTopologyDescription::Subslice(\n+    const PjRtDeviceDimensions& chips_per_host_bounds,\n+    const PjRtDeviceDimensions& host_bounds) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"Subslice is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_Subslice_Args args;\n+  args.struct_size = PJRT_TpuTopology_Subslice_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.chips_per_host_bounds = chips_per_host_bounds.data();\n+  args.chips_per_host_bounds_num_dims = chips_per_host_bounds.size();\n+  args.host_bounds = host_bounds.data();\n+  args.host_bounds_num_dims = host_bounds.size();\n+  args.subslice_topology = nullptr;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->subslice(&args), c_api_);\n+  return std::make_unique<PjRtCApiTopologyDescription>(c_api_,\n+                                                       args.subslice_topology,\n+                                                       /*owned=*/true);\n+}\n+\n+bool PjRtCApiTopologyDescription::is_subslice_topology() const {\n+  CHECK(tpu_topology_extension_ != nullptr)\n+      << \"Subslice is not supported by the PJRT C API.\";\n+  PJRT_TpuTopology_IsSubsliceTopology_Args args;\n+  args.struct_size = PJRT_TpuTopology_IsSubsliceTopology_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  pjrt::LogFatalIfPjrtError(\n+      tpu_topology_extension_->is_subslice_topology(&args), c_api_);\n+  return args.is_subslice_topology;\n+}\n+\n+absl::StatusOr<PjRtTopologyDescriptionProto>\n+PjRtCApiTopologyDescription::ToProto() const {\n+  TF_ASSIGN_OR_RETURN(std::string serialized, Serialize());\n+  PjRtTopologyDescriptionProto proto;\n+  if (!proto.ParseFromString(serialized)) {\n+    return Internal(\"Failed to parse serialized PjRtTopologyDescriptionProto.\");\n+  }\n+  return proto;\n+}\n+\n+absl::StatusOr<int> PjRtCApiTopologyDescription::ProcessCount() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ProcessCount is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ProcessCount_Args args;\n+  args.struct_size = PJRT_TpuTopology_ProcessCount_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->process_count(&args),\n+                              c_api_);\n+  return args.process_count;\n+}\n+\n+absl::StatusOr<int> PjRtCApiTopologyDescription::ChipsPerProcess() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ChipsPerProcess is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ChipsPerProcess_Args args;\n+  args.struct_size = PJRT_TpuTopology_ChipsPerProcess_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->chips_per_process(&args),\n+                              c_api_);\n+  return args.chips_per_process;\n+}\n+\n+absl::StatusOr<int> PjRtCApiTopologyDescription::CoreCountOfDefaultTypePerChip()\n+    const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"CoreCountOfDefaultTypePerChip is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_CoreCountPerChip_Args args;\n+  args.struct_size = PJRT_TpuTopology_CoreCountPerChip_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->core_count_per_chip(&args), c_api_);\n+  return args.core_count_of_default_type_per_chip;\n+}\n+\n+absl::StatusOr<int> PjRtCApiTopologyDescription::ChipCount() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ChipCount is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ChipCount_Args args;\n+  args.struct_size = PJRT_TpuTopology_ChipCount_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->chip_count(&args),\n+                              c_api_);\n+  return args.chip_count;\n+}\n+\n+absl::StatusOr<int> PjRtCApiTopologyDescription::CoreCountOfDefaultType()\n+    const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"CoreCountOfDefaultType is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_CoreCount_Args args;\n+  args.struct_size = PJRT_TpuTopology_CoreCount_Args_STRUCT_SIZE;\n+\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->core_count(&args),\n+                              c_api_);\n+  return args.core_count_of_default_type;\n+}\n+\n+absl::StatusOr<int>\n+PjRtCApiTopologyDescription::LogicalDeviceCountOfDefaultTypePerProcess() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"LogicalDeviceCountOfDefaultTypePerProcess is not supported by the \"\n+        \"PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_LogiDeviceCountPerProcess_Args args;\n+  args.struct_size =\n+      PJRT_TpuTopology_LogiDeviceCountPerProcess_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->logical_device_count_per_process(&args), c_api_);\n+  return args.logical_device_count_of_default_type_per_process;\n+}\n+\n+absl::StatusOr<int>\n+PjRtCApiTopologyDescription::LogicalDeviceCountOfDefaultType() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"LogicalDeviceCountOfDefaultType is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_LogiDeviceCount_Args args;\n+  args.struct_size = PJRT_TpuTopology_LogiDeviceCount_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->logical_device_count(&args), c_api_);\n+  return args.logical_device_count_of_default_type;\n+}\n+\n+absl::StatusOr<int>\n+PjRtCApiTopologyDescription::LogicalDeviceCountOfDefaultTypePerChip() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"LogicalDeviceCountOfDefaultTypePerChip is not supported by the PJRT C \"\n+        \"API.\");\n+  }\n+  PJRT_TpuTopology_LogiDeviceCountPerChip_Args args;\n+  args.struct_size = PJRT_TpuTopology_LogiDeviceCountPerChip_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->logical_device_count_per_chip(&args), c_api_);\n+  return args.logical_device_count_of_default_type_per_chip;\n+}\n+\n+absl::StatusOr<int>\n+PjRtCApiTopologyDescription::CoreCountOfDefaultTypePerProcess() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"CoreCountOfDefaultTypePerProcess is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_CoreCountPerProcess_Args args;\n+  args.struct_size = PJRT_TpuTopology_CoreCountPerProcess_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->core_count_per_process(&args), c_api_);\n+  return args.core_count_of_default_type_per_process;\n+}\n+\n+absl::StatusOr<PjRtIdContainer<PjRtProcessId>>\n+PjRtCApiTopologyDescription::ProcessIds() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ProcessIds is not supported by the PJRT C API.\");\n+  }\n+  TF_ASSIGN_OR_RETURN(int process_count, ProcessCount());\n+  std::vector<int> process_ids_storage(process_count);\n+  PJRT_TpuTopology_ProcessIds_Args args;\n+  args.struct_size = PJRT_TpuTopology_ProcessIds_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.max_process_ids = process_count;\n+  args.process_ids = process_ids_storage.data();\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->process_ids(&args),\n+                              c_api_);\n+  PjRtIdContainer<PjRtProcessId> ids;\n+  ids.reserve(args.num_process_ids);\n+  for (size_t i = 0; i < args.num_process_ids; ++i) {\n+    ids.push_back(PjRtProcessId(args.process_ids[i]));\n+  }\n+  return ids;\n+}\n+\n+absl::StatusOr<PjRtIdContainer<PjRtGlobalDeviceId>>\n+PjRtCApiTopologyDescription::LogicalDeviceOfDefaultTypeIdsOnProcess(\n+    PjRtProcessId process_id) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"LogicalDeviceOfDefaultTypeIdsOnProcess is not supported by the PJRT \"\n+        \"C API.\");\n+  }\n+  TF_ASSIGN_OR_RETURN(int logical_device_count,\n+                      LogicalDeviceCountOfDefaultTypePerProcess());\n+  std::vector<int> logical_device_ids_storage(logical_device_count);\n+  PJRT_TpuTopology_LogiDeviceIdsOnProcess_Args args;\n+  args.struct_size = PJRT_TpuTopology_LogiDeviceIdsOnProcess_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.process_id = process_id.value();\n+  args.max_logical_device_ids = logical_device_count;\n+  args.logical_device_of_default_type_ids = logical_device_ids_storage.data();\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->logical_device_ids_on_process(&args), c_api_);\n+  PjRtIdContainer<PjRtGlobalDeviceId> ids;\n+  ids.reserve(args.num_logical_device_ids);\n+  for (size_t i = 0; i < args.num_logical_device_ids; ++i) {\n+    ids.push_back(\n+        PjRtGlobalDeviceId(args.logical_device_of_default_type_ids[i]));\n+  }\n+  return ids;\n+}\n+\n+absl::StatusOr<std::pair<PjRtProcessId, int>>\n+PjRtCApiTopologyDescription::ProcessIdAndIndexOnProcessForChip(\n+    PjRtGlobalChipId chip_id) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"ProcessIdAndIndexOnProcessForChip is not supported by the PJRT C \"\n+        \"API.\");\n+  }\n+  PJRT_TpuTopology_ProcIdAndIdxOnProcForChip_Args args;\n+  args.struct_size =\n+      PJRT_TpuTopology_ProcIdAndIdxOnProcForChip_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.chip_id = chip_id.value();\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->proc_id_and_idx_on_proc_for_chip(&args), c_api_);\n+  return std::make_pair(PjRtProcessId(args.process_id), args.index_on_process);\n+}\n+\n+absl::StatusOr<std::pair<PjRtProcessId, int>> PjRtCApiTopologyDescription::\n+    ProcessIdAndIndexOnProcessForLogicalDeviceOfDefaultType(\n+        xla::PjRtGlobalDeviceId device_id) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"ProcessIdAndIndexOnProcessForLogicalDeviceOfDefaultType is not \"\n+        \"supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice_Args args;\n+  args.struct_size =\n+      PJRT_TpuTopology_ProcIdAndIdxOnProcForLogiDevice_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.device_id = device_id.value();\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->proc_id_and_idx_on_proc_for_logi_device(&args),\n+      c_api_);\n+  return std::make_pair(PjRtProcessId(args.process_id), args.index_on_process);\n+}\n+\n+absl::StatusOr<PjRtDeviceDimensions>\n+PjRtCApiTopologyDescription::ProcessCoordFromId(\n+    PjRtProcessId process_id) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"ProcessCoordFromId is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ProcessCoordFromId_Args args;\n+  args.struct_size = PJRT_TpuTopology_ProcessCoordFromId_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.process_id = process_id.value();\n+  std::vector<int32_t> coords(kMaxDims);\n+  args.coords = coords.data();\n+  args.coords_max_dims = kMaxDims;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->process_coord_from_id(&args), c_api_);\n+  return PjRtDeviceDimensions(\n+      absl::MakeSpan(coords.data(), args.coords_num_dims));\n+}\n+\n+absl::StatusOr<PjRtGlobalChipId> PjRtCApiTopologyDescription::ChipIdFromCoord(\n+    const PjRtDeviceDimensions& chip) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ChipIdFromCoord is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ChipIdFromCoord_Args args;\n+  args.struct_size = PJRT_TpuTopology_ChipIdFromCoord_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.coords = chip.data();\n+  args.coords_num_dims = chip.size();\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->chip_id_from_coord(&args), c_api_);\n+  return PjRtGlobalChipId(args.chip_id);\n+}\n+\n+absl::StatusOr<xla::PjRtGlobalDeviceId> PjRtCApiTopologyDescription::\n+    LogicalDeviceOfDefaultTypeIdFromChipCoordAndCoreIndex(\n+        const PjRtDeviceDimensions& chip, int core_index) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"LogicalDeviceOfDefaultTypeIdFromChipCoordAndCoreIndex is not \"\n+        \"supported by the PJRT C API.\");\n+  }\n+  std::vector<int32_t> chip_coords_storage(chip.size());\n+  for (size_t i = 0; i < chip.size(); ++i) {\n+    chip_coords_storage[i] = chip.data()[i];\n+  }\n+  PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx_Args args;\n+  args.struct_size =\n+      PJRT_TpuTopology_LogiDeviceIdFromChipCoordAndIdx_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.chip_coords = chip_coords_storage.data();\n+  args.chip_coords_num_dims = chip.size();\n+  args.logical_device_index_on_chip = core_index;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->logical_device_id_from_chip_coord_and_idx(&args),\n+      c_api_);\n+  return PjRtGlobalDeviceId(args.logical_device_of_default_type_id);\n+}\n+\n+absl::StatusOr<std::pair<PjRtDeviceDimensions, int32_t>>\n+PjRtCApiTopologyDescription::ChipCoordAndCoreIndexForLogicalDeviceOfDefaultType(\n+    xla::PjRtGlobalDeviceId device_id) const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"ChipCoordAndCoreIndexForLogicalDeviceOfDefaultType is not supported \"\n+        \"by the PJRT C API.\");\n+  }\n+  std::vector<int32_t> chip_coords_storage(kMaxDims);\n+  PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice_Args args;\n+  args.struct_size =\n+      PJRT_TpuTopology_ChipCoordAndIdxForLogiDevice_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  args.device_id = device_id.value();\n+  args.chip_coords_max_dims = kMaxDims;\n+  args.chip_coords = chip_coords_storage.data();\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->chip_coord_and_idx_for_logi_device(&args),\n+      c_api_);\n+  return std::make_pair(\n+      PjRtDeviceDimensions(absl::MakeSpan(chip_coords_storage.data(),\n+                                          args.chip_coords_num_dims)),\n+      args.device_index_on_chip);\n+}\n+\n+absl::StatusOr<PjRtDeviceDimensions>\n+PjRtCApiTopologyDescription::ChipsPerProcessBounds() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\n+        \"ChipsPerProcessBounds is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ChipsPerProcessBounds_Args args;\n+  args.struct_size = PJRT_TpuTopology_ChipsPerProcessBounds_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  std::vector<int32_t> bounds(kMaxDims);\n+  args.chip_per_process_bounds = bounds.data();\n+  args.chip_per_process_bounds_max_dims = kMaxDims;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      tpu_topology_extension_->chips_per_process_bounds(&args), c_api_);\n+  return PjRtDeviceDimensions(\n+      absl::MakeSpan(bounds.data(), args.chip_per_process_bounds_num_dims));\n+}\n+\n+absl::StatusOr<PjRtDeviceDimensions> PjRtCApiTopologyDescription::ChipBounds()\n+    const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ChipBounds is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ChipBounds_Args args;\n+  args.struct_size = PJRT_TpuTopology_ChipBounds_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  std::vector<int32_t> bounds(kMaxDims);\n+  args.chip_bounds = bounds.data();\n+  args.chip_bounds_max_dims = kMaxDims;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->chip_bounds(&args),\n+                              c_api_);\n+  return PjRtDeviceDimensions(\n+      absl::MakeSpan(bounds.data(), args.chip_bounds_num_dims));\n+}\n+\n+absl::StatusOr<PjRtDeviceDimensions>\n+PjRtCApiTopologyDescription::ProcessBounds() const {\n+  if (tpu_topology_extension_ == nullptr) {\n+    return Unimplemented(\"ProcessBounds is not supported by the PJRT C API.\");\n+  }\n+  PJRT_TpuTopology_ProcessBounds_Args args;\n+  args.struct_size = PJRT_TpuTopology_ProcessBounds_Args_STRUCT_SIZE;\n+  args.topology = c_topology_;\n+  std::vector<int32_t> bounds(kMaxDims);\n+  args.process_bounds = bounds.data();\n+  args.process_bounds_max_dims = kMaxDims;\n+  RETURN_STATUS_IF_PJRT_ERROR(tpu_topology_extension_->process_bounds(&args),\n+                              c_api_);\n+  return PjRtDeviceDimensions(\n+      absl::MakeSpan(bounds.data(), args.process_bounds_num_dims));\n+}\n+\n // Initializes `PJRT_Compile_Args`, which will be used to call\n // API PJRT_Compile().\n static absl::StatusOr<std::unique_ptr<PjRtExecutable>>"
        },
        {
            "sha": "2b546f89ecf01f3a904d8448fe1115ff29663007",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -44,11 +44,13 @@ limitations under the License.\n #include \"xla/literal.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_tpu_topology_extension.h\"\n #include \"xla/pjrt/distributed/key_value_store_interface.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_device_description.h\"\n+#include \"xla/pjrt/pjrt_device_dimensions.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/pjrt/proto/topology_description.pb.h\"\n@@ -254,9 +256,54 @@ class PjRtCApiTopologyDescription : public PjRtTopologyDescription {\n       PrimitiveType element_type,\n       absl::Span<const int64_t> dims) const override;\n \n+  absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>> Subslice(\n+      const PjRtDeviceDimensions& chips_per_host_bounds,\n+      const PjRtDeviceDimensions& host_bounds) const override;\n+\n+  bool is_subslice_topology() const override;\n+\n+  absl::StatusOr<PjRtTopologyDescriptionProto> ToProto() const override;\n+\n+  absl::StatusOr<int> ProcessCount() const override;\n+\n+  absl::StatusOr<int> ChipsPerProcess() const override;\n+\n+  absl::StatusOr<int> CoreCountOfDefaultTypePerChip() const override;\n+\n+  absl::StatusOr<int> ChipCount() const override;\n+  absl::StatusOr<int> CoreCountOfDefaultType() const override;\n+  absl::StatusOr<int> LogicalDeviceCountOfDefaultType() const override;\n+  absl::StatusOr<int> LogicalDeviceCountOfDefaultTypePerProcess()\n+      const override;\n+  absl::StatusOr<int> LogicalDeviceCountOfDefaultTypePerChip() const override;\n+  absl::StatusOr<int> CoreCountOfDefaultTypePerProcess() const override;\n+  absl::StatusOr<PjRtIdContainer<PjRtProcessId>> ProcessIds() const override;\n+  absl::StatusOr<PjRtIdContainer<PjRtGlobalDeviceId>>\n+  LogicalDeviceOfDefaultTypeIdsOnProcess(\n+      PjRtProcessId process_id) const override;\n+  absl::StatusOr<std::pair<PjRtProcessId, int>>\n+  ProcessIdAndIndexOnProcessForChip(PjRtGlobalChipId chip_id) const override;\n+  absl::StatusOr<std::pair<PjRtProcessId, int>>\n+  ProcessIdAndIndexOnProcessForLogicalDeviceOfDefaultType(\n+      xla::PjRtGlobalDeviceId device_id) const override;\n+  absl::StatusOr<PjRtDeviceDimensions> ProcessCoordFromId(\n+      PjRtProcessId process_id) const override;\n+  absl::StatusOr<PjRtGlobalChipId> ChipIdFromCoord(\n+      const PjRtDeviceDimensions& chip) const override;\n+  absl::StatusOr<xla::PjRtGlobalDeviceId>\n+  LogicalDeviceOfDefaultTypeIdFromChipCoordAndCoreIndex(\n+      const PjRtDeviceDimensions& chip, int core_index) const override;\n+  absl::StatusOr<std::pair<PjRtDeviceDimensions, int32_t>>\n+  ChipCoordAndCoreIndexForLogicalDeviceOfDefaultType(\n+      xla::PjRtGlobalDeviceId device_id) const override;\n+  absl::StatusOr<PjRtDeviceDimensions> ChipsPerProcessBounds() const override;\n+  absl::StatusOr<PjRtDeviceDimensions> ChipBounds() const override;\n+  absl::StatusOr<PjRtDeviceDimensions> ProcessBounds() const override;\n+\n  private:\n   std::unique_ptr<PjRtCApiCompiler> compiler_;\n   const PJRT_Api* c_api_;\n+  const PJRT_TpuTopology_Extension* tpu_topology_extension_;\n   // nullptr iff the PJRT_TopologyDescription isn't owned by this wrapper\n   // (i.e. by the caller).\n   std::unique_ptr<PJRT_TopologyDescription,"
        },
        {
            "sha": "d9918b167ca3ff8099e0cdc9ee2e4ba1857f8f84",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client_tpu_test.cc",
            "status": "added",
            "additions": 232,
            "deletions": 0,
            "changes": 232,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_tpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_tpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_tpu_test.cc?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -0,0 +1,232 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_client.h\"\n+#include \"xla/pjrt/pjrt_common.h\"\n+#include \"xla/pjrt/pjrt_compiler.h\"\n+#include \"xla/pjrt/pjrt_device_dimensions.h\"\n+#include \"xla/tsl/platform/status_matchers.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+using ::testing::ElementsAre;\n+using ::testing::Pair;\n+using ::tsl::testing::IsOkAndHolds;\n+\n+using PjRtDeviceDimensionsAndInt = std::pair<PjRtDeviceDimensions, int32_t>;\n+\n+// Helper to get a TPU topology description.\n+absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>> GetTpuTopology() {\n+  return GetCApiTopology(\"tpu\", \"TPU v2:4x4\");\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, IsSubsliceTopology) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  // The default TPU topology is not a subslice.\n+  EXPECT_THAT(topology->is_subslice_topology(), false);\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, SubsliceTopology) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  PjRtDeviceDimensions chips_per_host_bounds = {2, 2, 1};\n+  PjRtDeviceDimensions host_bounds = {1, 1, 1};\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<PjRtTopologyDescription> subslice_topology,\n+      topology->Subslice(chips_per_host_bounds, host_bounds));\n+  EXPECT_THAT(subslice_topology->is_subslice_topology(), true);\n+  EXPECT_THAT(subslice_topology->DeviceDescriptions().size(), 8);\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ProcessCount) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  // Assuming a single process for a default test setup.\n+  EXPECT_THAT(topology->ProcessCount(), IsOkAndHolds(4));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ChipsPerProcess) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->ChipsPerProcess(), IsOkAndHolds(4));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, CoreCountOfDefaultTypePerChip) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  // TPU chips typically have 2 cores of the default type (TensorCores).\n+  EXPECT_THAT(topology->CoreCountOfDefaultTypePerChip(), IsOkAndHolds(2));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ToProto) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(PjRtTopologyDescriptionProto proto,\n+                          topology->ToProto());\n+  EXPECT_EQ(proto.platform_name(), \"tpu\");\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ChipCount) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->ChipCount(), IsOkAndHolds(16));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, CoreCountOfDefaultType) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->CoreCountOfDefaultType(), IsOkAndHolds(32));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest,\n+     LogicalDeviceCountOfDefaultTypePerProcess) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->LogicalDeviceCountOfDefaultTypePerProcess(),\n+              IsOkAndHolds(8));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, LogicalDeviceCountOfDefaultType) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->LogicalDeviceCountOfDefaultType(), IsOkAndHolds(32));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest,\n+     LogicalDeviceCountOfDefaultTypePerChip) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->LogicalDeviceCountOfDefaultTypePerChip(),\n+              IsOkAndHolds(2));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, CoreCountOfDefaultTypePerProcess) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->CoreCountOfDefaultTypePerProcess(), IsOkAndHolds(8));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ProcessIds) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(PjRtIdContainer<PjRtProcessId> process_ids,\n+                          topology->ProcessIds());\n+  EXPECT_THAT(process_ids, ElementsAre(PjRtProcessId(0), PjRtProcessId(1),\n+                                       PjRtProcessId(2), PjRtProcessId(3)));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest,\n+     LogicalDeviceOfDefaultTypeIdsOnProcess) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      PjRtIdContainer<PjRtGlobalDeviceId> device_ids,\n+      topology->LogicalDeviceOfDefaultTypeIdsOnProcess(PjRtProcessId(0)));\n+  EXPECT_THAT(device_ids,\n+              ElementsAre(PjRtGlobalDeviceId(0), PjRtGlobalDeviceId(1),\n+                          PjRtGlobalDeviceId(2), PjRtGlobalDeviceId(3),\n+                          PjRtGlobalDeviceId(8), PjRtGlobalDeviceId(9),\n+                          PjRtGlobalDeviceId(10), PjRtGlobalDeviceId(11)));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ProcessIdAndIndexOnProcessForChip) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->ProcessIdAndIndexOnProcessForChip(PjRtGlobalChipId(2)),\n+              IsOkAndHolds(Pair(PjRtProcessId(1), 0)));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest,\n+     ProcessIdAndIndexOnProcessForLogicalDeviceOfDefaultType) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->ProcessIdAndIndexOnProcessForLogicalDeviceOfDefaultType(\n+                  PjRtGlobalDeviceId(3)),\n+              IsOkAndHolds(Pair(PjRtProcessId(0), 3)));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ProcessCoordFromId) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(PjRtDeviceDimensions coords,\n+                          topology->ProcessCoordFromId(PjRtProcessId(2)));\n+  EXPECT_THAT(coords, (PjRtDeviceDimensions{0, 1, 0}));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ChipIdFromCoord) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->ChipIdFromCoord({1, 0, 0}),\n+              IsOkAndHolds(PjRtGlobalChipId(1)));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest,\n+     LogicalDeviceOfDefaultTypeIdFromChipCoordAndCoreIndex) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  EXPECT_THAT(topology->LogicalDeviceOfDefaultTypeIdFromChipCoordAndCoreIndex(\n+                  {1, 1, 0}, 0),\n+              IsOkAndHolds(PjRtGlobalDeviceId(10)));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest,\n+     ChipCoordAndCoreIndexForLogicalDeviceOfDefaultType) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      const PjRtDeviceDimensionsAndInt& result,\n+      topology->ChipCoordAndCoreIndexForLogicalDeviceOfDefaultType(\n+          PjRtGlobalDeviceId(10)));\n+  EXPECT_THAT(absl::MakeConstSpan(result.first.data(), result.first.size()),\n+              ElementsAre(1, 1, 0));\n+  EXPECT_EQ(result.second, 0);\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ChipsPerProcessBounds) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(PjRtDeviceDimensions bounds,\n+                          topology->ChipsPerProcessBounds());\n+  EXPECT_THAT(bounds, (PjRtDeviceDimensions{2, 2, 1}));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ChipBounds) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(PjRtDeviceDimensions bounds, topology->ChipBounds());\n+  EXPECT_THAT(bounds, (PjRtDeviceDimensions{4, 4, 1}));\n+}\n+\n+TEST(PjRtCApiTopologyDescriptionTpuTest, ProcessBounds) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtTopologyDescription> topology,\n+                          GetTpuTopology());\n+  TF_ASSERT_OK_AND_ASSIGN(PjRtDeviceDimensions bounds,\n+                          topology->ProcessBounds());\n+  EXPECT_THAT(bounds, (PjRtDeviceDimensions{2, 2, 1}));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        },
        {
            "sha": "324fbeb5a369623b4aea945875152adc8fda6de8",
            "filename": "third_party/xla/xla/pjrt/pjrt_device_dimensions.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_device_dimensions.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ebeb5ae70991cad990e84378c7ad4f08d176265/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_device_dimensions.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_device_dimensions.h?ref=7ebeb5ae70991cad990e84378c7ad4f08d176265",
            "patch": "@@ -54,6 +54,7 @@ class PjRtDeviceDimensions {\n \n   const int32_t& operator[](size_t i) const { return dimensions_[i]; }\n \n+  const int32_t* data() const { return dimensions_.data(); }\n   size_t size() const { return dimensions_.size(); }\n \n   friend bool operator==(const PjRtDeviceDimensions& a,"
        }
    ],
    "stats": {
        "total": 1204,
        "additions": 1204,
        "deletions": 0
    }
}