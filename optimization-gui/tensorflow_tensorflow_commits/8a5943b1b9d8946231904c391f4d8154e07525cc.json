{
    "author": "sfvaroglu",
    "message": "PR #34118: Add helper functions to host_offload_utils\n\nImported from GitHub PR https://github.com/openxla/xla/pull/34118\n\nüìù Summary of Changes\nThis PR adds two new utility functions to `host_offload_utils` for detecting dynamic slice operations in host offload patterns. New Functions:\n- IsMoveToHostWithDynamicUpdateSlice - Detects if a MoveToHost operation feeds into a DynamicUpdateSlice\n- IsMoveToDeviceWithDynamicSlice - Detects if a MoveToDevice operation consumes from a DynamicSlice\n\nüéØ Justification\nThese helper functions are necessary for identifying host offloading patterns that involve dynamic slicing operations (child-PR of https://github.com/openxla/xla/pull/32297/)\n\nüöÄ Kind of Contribution\nPlease remove what does not apply: ‚ú® New Feature, üß™ Tests\n\nüìä Benchmark (for Performance Improvements)\nN/A\n\nüß™ Unit Tests:\nAdded.\n\nüß™ Execution Tests:\nN/A\n\nCopybara import of the project:\n\n--\n9819a23dcfff1245e19650ed9ae191e60d07cf12 by Sevin Varoglu <svaroglu@nvidia.com>:\n\nAdd helper functions to host_offload_utils\n\n--\n35cc3e88b395146c1193d4e0859d721bed69f2e1 by Sevin Varoglu <svaroglu@nvidia.com>:\n\nAdd missing absl/strings/string_view.h\n\n--\na5b1c77e14ffc2f22c606ded4ed6f30bd1271e40 by Sevin Varoglu <svaroglu@nvidia.com>:\n\nFix include\n\nMerging this change closes #34118\n\nPiperOrigin-RevId: 839186962",
    "sha": "8a5943b1b9d8946231904c391f4d8154e07525cc",
    "files": [
        {
            "sha": "c622e54874390833cf0071f90fc7a3c02b40d84b",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=8a5943b1b9d8946231904c391f4d8154e07525cc",
            "patch": "@@ -4643,8 +4643,9 @@ xla_cc_test(\n         \"//xla:util\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/tests:xla_internal_test_main\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n "
        },
        {
            "sha": "13eef41d1453d214c28438cf40ab76ffb875cb97",
            "filename": "third_party/xla/xla/service/host_offload_utils.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils.cc?ref=8a5943b1b9d8946231904c391f4d8154e07525cc",
            "patch": "@@ -23,6 +23,7 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n+#include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n@@ -294,5 +295,63 @@ void SetHostComputeFrontendAttribute(HloInstruction& host_instruction) {\n   host_instruction.set_frontend_attributes(frontend_attributes);\n }\n \n+bool IsMoveToHostWithDynamicUpdateSlice(const HloInstruction* instr) {\n+  if (!instr->IsCustomCall(kMoveToHostCustomCallTarget)) {\n+    return false;\n+  }\n+\n+  std::vector<const HloInstruction*> to_check = {instr};\n+  absl::flat_hash_set<const HloInstruction*> visited;\n+\n+  while (!to_check.empty()) {\n+    const HloInstruction* current = to_check.back();\n+    to_check.pop_back();\n+\n+    auto [_, inserted] = visited.insert(current);\n+    if (!inserted) {\n+      continue;\n+    }\n+    for (const HloInstruction* user : current->users()) {\n+      if (user->opcode() == HloOpcode::kDynamicUpdateSlice) {\n+        return true;\n+      }\n+      if (HloPredicateIsOp<HloOpcode::kReshape, HloOpcode::kBroadcast,\n+                           HloOpcode::kTranspose>(user)) {\n+        to_check.push_back(user);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool IsMoveToDeviceWithDynamicSlice(const HloInstruction* instr) {\n+  if (!instr->IsCustomCall(kMoveToDeviceCustomCallTarget)) {\n+    return false;\n+  }\n+\n+  std::vector<const HloInstruction*> to_check = {instr};\n+  absl::flat_hash_set<const HloInstruction*> visited;\n+\n+  while (!to_check.empty()) {\n+    const HloInstruction* current = to_check.back();\n+    to_check.pop_back();\n+\n+    auto [_, inserted] = visited.insert(current);\n+    if (!inserted) {\n+      continue;\n+    }\n+    for (const HloInstruction* operand : current->operands()) {\n+      if (operand->opcode() == HloOpcode::kDynamicSlice) {\n+        return true;\n+      }\n+      if (HloPredicateIsOp<HloOpcode::kReshape, HloOpcode::kBroadcast,\n+                           HloOpcode::kTranspose>(operand)) {\n+        to_check.push_back(operand);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n }  // namespace host_offload_utils\n }  // namespace xla"
        },
        {
            "sha": "1edac1898c7b4b394ddd252aee4fcfc37bedf3c0",
            "filename": "third_party/xla/xla/service/host_offload_utils.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils.h?ref=8a5943b1b9d8946231904c391f4d8154e07525cc",
            "patch": "@@ -107,6 +107,10 @@ bool ComputeTypeIsHost(const HloInstruction* hlo_instruction);\n // instruction should be lowered as host compute.\n void SetHostComputeFrontendAttribute(HloInstruction& host_instruction);\n \n+bool IsMoveToHostWithDynamicUpdateSlice(const HloInstruction* instr);\n+\n+bool IsMoveToDeviceWithDynamicSlice(const HloInstruction* instr);\n+\n }  // namespace host_offload_utils\n }  // namespace xla\n "
        },
        {
            "sha": "b7b641ba9482d0710434f9d7423b7f94ea1809b9",
            "filename": "third_party/xla/xla/service/host_offload_utils_test.cc",
            "status": "modified",
            "additions": 146,
            "deletions": 34,
            "changes": 180,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8a5943b1b9d8946231904c391f4d8154e07525cc/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhost_offload_utils_test.cc?ref=8a5943b1b9d8946231904c391f4d8154e07525cc",
            "patch": "@@ -15,36 +15,36 @@ limitations under the License.\n \n #include \"xla/service/host_offload_utils.h\"\n \n-#include <string>\n #include <vector>\n \n #include <gtest/gtest.h>\n+#include \"absl/strings/string_view.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/shape_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla {\n namespace host_offload_utils {\n namespace {\n \n-class HostOffloadUtilsTest : public HloHardwareIndependentTestBase {};\n+using HostOffloadUtilsTest = HloHardwareIndependentTestBase;\n \n TEST_F(HostOffloadUtilsTest, SimpleGetSuccessorsGetPredecessorsTest) {\n-  const std::string& hlo_string = R\"(\n-HloModule my_module\n-ENTRY main {\n-  data_param = f32[1,2048,2048] parameter(0)\n-  index_param = s32[] parameter(1)\n-  constant_f32_0 = f32[] constant(0)\n-  constant_s32_0 = s32[] constant(0)\n-  broadcast = f32[2,2048,2048] broadcast(constant_f32_0), dimensions={}\n-  offload_custom_call = f32[1,2048,2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n-  dynamic_update_slice = f32[2,2048,2048] dynamic-update-slice(broadcast, offload_custom_call, index_param, constant_s32_0, constant_s32_0)\n-  dynamic_slice = f32[1,2048,2048] dynamic-slice(dynamic_update_slice, index_param, constant_s32_0, constant_s32_0), dynamic_slice_sizes={1,2048,2048}\n-  ROOT load_custom_call = f32[1,2048,2048] custom-call(dynamic_slice), custom_call_target=\"MoveToDevice\"\n-}\n-)\";\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[1,2048,2048] parameter(0)\n+      index_param = s32[] parameter(1)\n+      constant_f32_0 = f32[] constant(0)\n+      constant_s32_0 = s32[] constant(0)\n+      broadcast = f32[2,2048,2048] broadcast(constant_f32_0), dimensions={}\n+      offload_custom_call = f32[1,2048,2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n+      dynamic_update_slice = f32[2,2048,2048] dynamic-update-slice(broadcast, offload_custom_call, index_param, constant_s32_0, constant_s32_0)\n+      dynamic_slice = f32[1,2048,2048] dynamic-slice(dynamic_update_slice, index_param, constant_s32_0, constant_s32_0), dynamic_slice_sizes={1,2048,2048}\n+      ROOT load_custom_call = f32[1,2048,2048] custom-call(dynamic_slice), custom_call_target=\"MoveToDevice\"\n+    }\n+  )hlo\";\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(hlo_string));\n@@ -69,23 +69,23 @@ ENTRY main {\n }\n \n TEST_F(HostOffloadUtilsTest, ComputationGetSuccessorsGetPredecessorsTest) {\n-  const std::string& hlo_string = R\"(\n-HloModule my_module\n-other_computation {\n-  param_0 = f32[2048] parameter(0)\n-  param_1 = f32[2048] parameter(1)\n-  ROOT tuple = (f32[2048], f32[2048]) tuple(param_0, param_1)\n-}\n-ENTRY main {\n-  data_param = f32[2048] parameter(0)\n-  other_param = f32[2048] parameter(1)\n-  offload_custom_call = f32[2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n-  call = (f32[2048], f32[2048]) call(offload_custom_call, other_param), to_apply=other_computation\n-  gte_0 = f32[2048] get-tuple-element(call), index=0\n-  gte_1 = f32[2048] get-tuple-element(call), index=1\n-  ROOT load_custom_call = f32[2048] custom-call(gte_0), custom_call_target=\"MoveToDevice\"\n-}\n-)\";\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    other_computation {\n+      param_0 = f32[2048] parameter(0)\n+      param_1 = f32[2048] parameter(1)\n+      ROOT tuple = (f32[2048], f32[2048]) tuple(param_0, param_1)\n+    }\n+    ENTRY main {\n+      data_param = f32[2048] parameter(0)\n+      other_param = f32[2048] parameter(1)\n+      offload_custom_call = f32[2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n+      call = (f32[2048], f32[2048]) call(offload_custom_call, other_param), to_apply=other_computation\n+      gte_0 = f32[2048] get-tuple-element(call), index=0\n+      gte_1 = f32[2048] get-tuple-element(call), index=1\n+      ROOT load_custom_call = f32[2048] custom-call(gte_0), custom_call_target=\"MoveToDevice\"\n+    }\n+  )hlo\";\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           ParseAndReturnVerifiedModule(hlo_string));\n@@ -109,6 +109,118 @@ ENTRY main {\n   EXPECT_EQ(pred, expected_pred);\n }\n \n+TEST_F(HostOffloadUtilsTest, IsMoveToHostWithDynamicUpdateSliceTest) {\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[1,2048,2048] parameter(0)\n+      index_param = s32[] parameter(1)\n+      constant_f32_0 = f32[] constant(0)\n+      constant_s32_0 = s32[] constant(0)\n+      broadcast = f32[2,2048,2048] broadcast(constant_f32_0), dimensions={}\n+      custom_call = f32[1,2048,2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n+      dynamic_update_slice = f32[2,2048,2048] dynamic-update-slice(broadcast, custom_call, index_param, constant_s32_0, constant_s32_0)\n+      ROOT result = f32[2,2048,2048] copy(dynamic_update_slice)\n+    }\n+  )hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloInstruction* instr = FindInstruction(module.get(), \"custom_call\");\n+  ASSERT_NE(instr, nullptr);\n+  EXPECT_TRUE(IsMoveToHostWithDynamicUpdateSlice(instr));\n+}\n+\n+TEST_F(HostOffloadUtilsTest, IsMoveToHostNotWithDynamicUpdateSliceTest) {\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[1,2048,2048] parameter(0)\n+      custom_call = f32[1,2048,2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n+      ROOT result = f32[1,2048,2048] copy(custom_call)\n+    }\n+  )hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloInstruction* instr = FindInstruction(module.get(), \"custom_call\");\n+  ASSERT_NE(instr, nullptr);\n+  EXPECT_FALSE(IsMoveToHostWithDynamicUpdateSlice(instr));\n+}\n+\n+TEST_F(HostOffloadUtilsTest, IsMoveToDeviceWithDynamicSliceTest) {\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[2,2048,2048] parameter(0)\n+      index_param = s32[] parameter(1)\n+      constant_s32_0 = s32[] constant(0)\n+      dynamic_slice = f32[1,2048,2048] dynamic-slice(data_param, index_param, constant_s32_0, constant_s32_0), dynamic_slice_sizes={1,2048,2048}\n+      ROOT custom_call = f32[1,2048,2048] custom-call(dynamic_slice), custom_call_target=\"MoveToDevice\"\n+    }\n+  )hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloInstruction* instr = FindInstruction(module.get(), \"custom_call\");\n+  ASSERT_NE(instr, nullptr);\n+  EXPECT_TRUE(IsMoveToDeviceWithDynamicSlice(instr));\n+}\n+\n+TEST_F(HostOffloadUtilsTest, IsMoveToDeviceNotWithDynamicSliceTest) {\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[1,2048,2048] parameter(0)\n+      ROOT custom_call = f32[1,2048,2048] custom-call(data_param), custom_call_target=\"MoveToDevice\"\n+    }\n+  )hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloInstruction* instr = FindInstruction(module.get(), \"custom_call\");\n+  ASSERT_NE(instr, nullptr);\n+  EXPECT_FALSE(IsMoveToDeviceWithDynamicSlice(instr));\n+}\n+\n+TEST_F(HostOffloadUtilsTest,\n+       IsMoveToHostWithDynamicUpdateSliceThroughReshapeTest) {\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[2048,2048] parameter(0)\n+      index_param = s32[] parameter(1)\n+      constant_f32_0 = f32[] constant(0)\n+      constant_s32_0 = s32[] constant(0)\n+      broadcast = f32[2,2048,2048] broadcast(constant_f32_0), dimensions={}\n+      custom_call = f32[2048,2048] custom-call(data_param), custom_call_target=\"MoveToHost\"\n+      reshape = f32[1,2048,2048] reshape(custom_call)\n+      dynamic_update_slice = f32[2,2048,2048] dynamic-update-slice(broadcast, reshape, index_param, constant_s32_0, constant_s32_0)\n+      ROOT result = f32[2,2048,2048] copy(dynamic_update_slice)\n+    }\n+  )hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloInstruction* instr = FindInstruction(module.get(), \"custom_call\");\n+  ASSERT_NE(instr, nullptr);\n+  EXPECT_TRUE(IsMoveToHostWithDynamicUpdateSlice(instr));\n+}\n+\n+TEST_F(HostOffloadUtilsTest, IsMoveToDeviceWithDynamicSliceThroughReshapeTest) {\n+  absl::string_view hlo_string = R\"hlo(\n+    HloModule my_module\n+    ENTRY main {\n+      data_param = f32[2,2048,2048] parameter(0)\n+      index_param = s32[] parameter(1)\n+      constant_s32_0 = s32[] constant(0)\n+      dynamic_slice = f32[1,2048,2048] dynamic-slice(data_param, index_param, constant_s32_0, constant_s32_0), dynamic_slice_sizes={1,2048,2048}\n+      reshape = f32[2048,2048] reshape(dynamic_slice)\n+      ROOT custom_call = f32[2048,2048] custom-call(reshape), custom_call_target=\"MoveToDevice\"\n+    }\n+  )hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloInstruction* instr = FindInstruction(module.get(), \"custom_call\");\n+  ASSERT_NE(instr, nullptr);\n+  EXPECT_TRUE(IsMoveToDeviceWithDynamicSlice(instr));\n+}\n+\n }  // namespace\n }  // namespace host_offload_utils\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 246,
        "additions": 211,
        "deletions": 35
    }
}