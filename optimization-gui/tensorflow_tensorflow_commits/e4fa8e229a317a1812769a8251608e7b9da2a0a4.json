{
    "author": "junwhanahn",
    "message": "Add a comment about `Map`/`TryMap`'s short circuiting behavior and its implications on functors with side effects\n\nThis seems okay since `Map` is typically used for pure future->future transformations, but making that part of the API contract by explicitly stating it.\n\nPiperOrigin-RevId: 807400794",
    "sha": "e4fa8e229a317a1812769a8251608e7b9da2a0a4",
    "files": [
        {
            "sha": "1416e5287237f5b55282922938b05283ee61c070",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4fa8e229a317a1812769a8251608e7b9da2a0a4/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4fa8e229a317a1812769a8251608e7b9da2a0a4/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=e4fa8e229a317a1812769a8251608e7b9da2a0a4",
            "patch": "@@ -552,6 +552,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n   // functor `f` with *this value. If *this completes with an error, returned\n   // future will also be an error.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage:\n   //\n   // future.Map<R>([](const T& value) -> U {\n@@ -584,6 +588,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n   // functor `f` with *this value. If *this completes with an error, returned\n   // future will also be an error.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage: move-only type T passed by value\n   //\n   // std::move(future).Map<R>([](T value) -> U {\n@@ -623,6 +631,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n   // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n   // is automatically unwrapped and returned as a future payload.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage:\n   //\n   // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n@@ -663,6 +675,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n   // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n   // is automatically unwrapped and returned as a future payload.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage: move-only type T passed by rvalue\n   //\n   // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n@@ -832,6 +848,10 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   // functor `f`. If *this completes with an error, returned future will also be\n   // an error.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage:\n   //\n   // future.Map<R>([]() -> U {\n@@ -862,6 +882,10 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   // is constructible from U. Returned absl::StatusOr is automatically unwrapped\n   // and returned as a future payload.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage:\n   //\n   // future.TryMap<R>([]() -> absl::StatusOr<U> {\n@@ -910,6 +934,10 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   // Returns an PjRtFuture<R> that is constructed from the given value. If *this\n   // completes with an error, returned future will also be an error.\n   //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n   // Sample usage: make buffer available when future is ready\n   //\n   // std::unique_ptr<Buffer> buffer = ...;"
        }
    ],
    "stats": {
        "total": 28,
        "additions": 28,
        "deletions": 0
    }
}