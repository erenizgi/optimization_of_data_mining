{
    "author": "pschuh",
    "message": "Implement CreateLinkedEventPromise() for PjRtStreamExecutorClient.\n\nPiperOrigin-RevId: 817869433",
    "sha": "0573fab4a4dbbb723597f44afc069af34bc5169f",
    "files": [
        {
            "sha": "cb7c7ed20456895837cb604fa9bbd334799c20dd",
            "filename": "third_party/xla/xla/pjrt/buffer_sequencing_event.h",
            "status": "modified",
            "additions": 16,
            "deletions": 10,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fbuffer_sequencing_event.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fbuffer_sequencing_event.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fbuffer_sequencing_event.h?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -61,10 +61,24 @@ namespace xla {\n // same stream causes no additional waiting.\n class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n  public:\n+  struct EventState {\n+    // An event that is triggered when the content of one or more buffers has\n+    // been read or written. If this event is used as a definition event and is\n+    // nullptr, it is assumed that the buffer's content is always defined for\n+    // example because it uses storage borrowed from elsewhere.\n+    EventPool::Handle event;\n+\n+    se::Stream* definition_stream;\n+  };\n+\n   explicit BufferSequencingEvent(tsl::thread::ThreadPool* thread_pool)\n       : thread_pool_(thread_pool),\n         event_(tsl::MakeUnconstructedAsyncValueRef<EventState>()) {}\n \n+  explicit BufferSequencingEvent(tsl::thread::ThreadPool* thread_pool,\n+                                 tsl::AsyncValueRef<EventState> event)\n+      : thread_pool_(thread_pool), event_(event) {}\n+\n   static tsl::AsyncValueRef<BufferSequencingEvent> Create(\n       tsl::thread::ThreadPool* thread_pool) {\n     return tsl::MakeConstructedAsyncValueRef<BufferSequencingEvent>(\n@@ -138,18 +152,10 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n   // blocks the calling thread until either of those 2 happens.\n   bool IsPredeterminedErrorOrDefinedOn(se::Stream* stream);\n \n-  struct EventState {\n-    // An event that is triggered when the content of one or more buffers has\n-    // been read or written. If this event is used as a definition event and is\n-    // nullptr, it is assumed that the buffer's content is always defined for\n-    // example because it uses storage borrowed from elsewhere.\n-    EventPool::Handle event;\n-\n-    se::Stream* definition_stream;\n-  };\n-\n   se::Stream* definition_stream() const { return event_->definition_stream; }\n \n+  const tsl::AsyncValueRef<EventState>& event() { return event_; }\n+\n  private:\n   uint64_t sequence_number() const;\n "
        },
        {
            "sha": "a39417a5689199bf3b01a1307b45283ded105af3",
            "filename": "third_party/xla/xla/pjrt/gpu/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2FBUILD?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -212,6 +212,7 @@ xla_test(\n         \"//xla/hlo/builder:xla_computation\",\n         \"//xla/hlo/parser:hlo_parser\",\n         \"//xla/hlo/testlib:test\",\n+        \"//xla/pjrt:device_event\",\n         \"//xla/pjrt:host_memory_spaces\",\n         \"//xla/pjrt:local_device_state\",\n         \"//xla/pjrt:mlir_to_hlo\",\n@@ -236,6 +237,7 @@ xla_test(\n         \"//xla/stream_executor/cuda:cuda_compute_capability\",\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/concurrency:async_value\",\n+        \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\","
        },
        {
            "sha": "0281b6b4a135cca21ab6ae93e1e609c3db4a887a",
            "filename": "third_party/xla/xla/pjrt/gpu/se_gpu_pjrt_client_test.cc",
            "status": "modified",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client_test.cc?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include <optional>\n #include <set>\n #include <string>\n+#include <tuple>\n #include <utility>\n #include <variant>\n #include <vector>\n@@ -60,6 +61,7 @@ limitations under the License.\n #include \"xla/layout.h\"\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n+#include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/distributed/client.h\"\n #include \"xla/pjrt/distributed/distributed.h\"\n #include \"xla/pjrt/distributed/in_memory_key_value_store.h\"\n@@ -90,6 +92,7 @@ limitations under the License.\n #include \"xla/stream_executor/stream.h\"\n #include \"xla/tests/literal_test_util.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n@@ -2644,6 +2647,46 @@ TEST(StreamExecutorGpuClientTest, EventCaching) {\n   EXPECT_EQ(&*event3, &*event2);\n }\n \n+TEST(StreamExecutorGpuClientTest, LinkedEventPromise) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto pjrt_client,\n+                          GetStreamExecutorGpuClient(DefaultOptions()));\n+  auto* client =\n+      tensorflow::down_cast<PjRtStreamExecutorClient*>(pjrt_client.get());\n+  auto* memory_space = client->memory_spaces()[0];\n+  auto literal = LiteralUtil::CreateR1<float>({41.0f, 42.0f, 43.0f, 44.0f});\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      Shape device_shape,\n+      client->MakeDefaultShapeForMemorySpace(memory_space, literal.shape(),\n+                                             /*layout=*/nullptr));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      int64_t on_device_bytes_count,\n+      client->GetOnDeviceBytesCount(memory_space, device_shape));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto raw_buffer,\n+      client->AllocateRawBuffer(memory_space, on_device_bytes_count,\n+                                /*retry_on_oom=*/true,\n+                                /*allocate_after=*/{}));\n+  tsl::RCReference<PjRtDeviceEventPromise> promise;\n+  tsl::RCReference<PjRtDeviceEvent> event;\n+  TF_ASSERT_OK_AND_ASSIGN(std::tie(promise, event),\n+                          client->CreateLinkedEventPromise(memory_space, \"\"));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto buffer,\n+      client->DefineBuffer(device_shape, raw_buffer, {std::move(event)},\n+                           /*raw_buffer_is_mutable=*/true));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto definition_event,\n+      client->LinearizeInto(\n+          literal, device_shape,\n+          PjRtClient::HostBufferSemantics::kImmutableUntilTransferCompletes,\n+          raw_buffer));\n+  promise->Set(std::move(definition_event));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto new_literal, buffer->ToLiteralSync());\n+  ASSERT_EQ(literal, *new_literal);\n+}\n+\n struct ShardedAutotuningTestInfo {\n   bool use_xla_computation;\n   int num_active_nodes;"
        },
        {
            "sha": "df32d31e342757098cc96db9ab96bbbcdf927548",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -981,6 +981,22 @@ PjRtStreamExecutorClient::LinearizeHostBufferInto(\n   return definition_event;\n }\n \n+absl::StatusOr<std::pair<tsl::RCReference<PjRtDeviceEventPromise>,\n+                         tsl::RCReference<PjRtDeviceEvent>>>\n+PjRtStreamExecutorClient::CreateLinkedEventPromise(\n+    PjRtMemorySpace* memory_space, absl::string_view debug_info) {\n+  auto* device = tensorflow::down_cast<PjRtStreamExecutorDevice*>(\n+      memory_space->devices()[0]);\n+  TF_ASSIGN_OR_RETURN(LocalDeviceState * local_device,\n+                      device->GetLocalDeviceState());\n+  auto result = tsl::MakeRef<PjRtStreamExecutorDeviceEventPromise>(\n+      memory_space, local_device, thread_pool());\n+  const auto& event = result->event();\n+  return std::pair<tsl::RCReference<PjRtDeviceEventPromise>,\n+                   tsl::RCReference<PjRtDeviceEvent>>(\n+      std::move(result), tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(event));\n+}\n+\n tsl::RCReference<PjRtDeviceEvent>\n PjRtStreamExecutorClient::CreateErrorDeviceEvent(absl::Status error) {\n   auto definition_event = BufferSequencingEvent::Create(this->thread_pool());"
        },
        {
            "sha": "899a3853efd16b4f18bc1b0226b46fd532a1f7c7",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -412,6 +412,11 @@ class PjRtStreamExecutorClient : public CommonPjRtClient {\n       const xla::Shape& device_shape,\n       tsl::RCReference<CommonPjRtRawBuffer> raw_buffer) override;\n \n+  absl::StatusOr<std::pair<tsl::RCReference<PjRtDeviceEventPromise>,\n+                           tsl::RCReference<PjRtDeviceEvent>>>\n+  CreateLinkedEventPromise(PjRtMemorySpace* memory_space,\n+                           absl::string_view debug_info) override;\n+\n   void WaitForAllocation(se::Stream* stream,\n                          const CommonPjRtRawBuffer& raw_buffer);\n "
        },
        {
            "sha": "80dc97fd1a0320d5d9521a5f2b136a2e753a966e",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -23,15 +23,20 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"xla/future.h\"\n+#include \"xla/pjrt/buffer_sequencing_event.h\"\n+#include \"xla/pjrt/device_event.h\"\n+#include \"xla/pjrt/local_device_state.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/pjrt/pjrt_stream_executor_client.h\"\n #include \"xla/pjrt/raw_buffer.h\"\n #include \"xla/pjrt/tracked_device_buffer.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/stream.h\"\n+#include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/threadpool.h\"\n #include \"tsl/platform/casts.h\"\n #include \"tsl/profiler/lib/connected_traceme.h\"\n \n@@ -64,6 +69,49 @@ Future<> PjRtStreamExecutorDeviceEvent::GetReadyFuture() {\n       });\n }\n \n+PjRtStreamExecutorDeviceEventPromise::PjRtStreamExecutorDeviceEventPromise(\n+    PjRtMemorySpace* memory_space, LocalDeviceState* local_device,\n+    tsl::thread::ThreadPool* thread_pool)\n+    : memory_space_(memory_space),\n+      local_device_(local_device),\n+      av_(tsl::MakeIndirectAsyncValue()),\n+      event_(tsl::MakeConstructedAsyncValueRef<BufferSequencingEvent>(\n+          thread_pool,\n+          tsl::AsyncValueRef<BufferSequencingEvent::EventState>(av_))) {}\n+\n+void PjRtStreamExecutorDeviceEventPromise::Set(\n+    tsl::RCReference<PjRtDeviceEvent> event) {\n+  SetFromSEEvent(\n+      tensorflow::down_cast<PjRtStreamExecutorDeviceEvent*>(event.get())\n+          ->event());\n+}\n+\n+void PjRtStreamExecutorDeviceEventPromise::SetFromSEEvent(\n+    BufferSequencingEventRef event) {\n+  av_->ForwardTo(event->event().CopyRCRef());\n+  event.AndThen([event = event_, original_event = event]() {\n+    if (auto* error = original_event.GetErrorIfPresent()) {\n+      event.SetError(*error);\n+    }\n+    event.SetStateConcrete();\n+  });\n+}\n+\n+void PjRtStreamExecutorDeviceEventPromise::SetReady() {\n+  auto* client =\n+      tensorflow::down_cast<PjRtStreamExecutorClient*>(memory_space_->client());\n+  auto result = BufferSequencingEvent::Create(client->thread_pool());\n+  auto stream = local_device_->BorrowStreamFromPool();\n+  auto status =\n+      client->AllocateAndRecordEvent(result, local_device_, stream.get());\n+  local_device_->ReturnStreamToPool(std::move(stream));\n+  if (!status.ok()) {\n+    SetError(status);\n+  } else {\n+    SetFromSEEvent(result);\n+  }\n+}\n+\n absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>\n PjRtStreamExecutorRawBuffer::CopyRawHostToDeviceAndReturnEvent(\n     const void* src, int64_t offset, int64_t transfer_size) {"
        },
        {
            "sha": "c99413f8b362e6371a7f8917fedc3f94b071a631",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.h",
            "status": "modified",
            "additions": 35,
            "deletions": 1,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0573fab4a4dbbb723597f44afc069af34bc5169f/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h?ref=0573fab4a4dbbb723597f44afc069af34bc5169f",
            "patch": "@@ -34,7 +34,7 @@ class PjRtStreamExecutorDeviceEvent : public PjRtDeviceEvent {\n  public:\n   explicit PjRtStreamExecutorDeviceEvent(\n       tsl::AsyncValueRef<BufferSequencingEvent> event,\n-      const char* callee_type = \"CpuTrackedDeviceEvent\",\n+      const char* callee_type = \"PjRtStreamExecutorDeviceEvent\",\n       const char* callee_method = \"Unknown\")\n       : event_(std::move(event)),\n         callee_type_(callee_type),\n@@ -56,6 +56,40 @@ class PjRtStreamExecutorDeviceEvent : public PjRtDeviceEvent {\n   const char* callee_method_;\n };\n \n+class PjRtStreamExecutorDeviceEventPromise : public PjRtDeviceEventPromise {\n+ public:\n+  PjRtStreamExecutorDeviceEventPromise(PjRtMemorySpace* memory_space,\n+                                       LocalDeviceState* local_device,\n+                                       tsl::thread::ThreadPool* thread_pool);\n+\n+  tsl::AsyncValue* async_value() const override {\n+    return event_.GetAsyncValue();\n+  }\n+\n+  void Set(tsl::RCReference<PjRtDeviceEvent> event) override;\n+\n+  void SetError(absl::Status s) override {\n+    av_->SetError(s);\n+    event_.SetError(std::move(s));\n+  }\n+\n+  void SetFromSEEvent(BufferSequencingEventRef event);\n+\n+  void SetReady() override;\n+\n+  const tsl::AsyncValueRef<BufferSequencingEvent>& event() const {\n+    return event_;\n+  }\n+\n+  tsl::RCReference<tsl::IndirectAsyncValue>& av() { return av_; }\n+\n+ private:\n+  PjRtMemorySpace* memory_space_;\n+  LocalDeviceState* local_device_;\n+  tsl::RCReference<tsl::IndirectAsyncValue> av_;\n+  tsl::AsyncValueRef<BufferSequencingEvent> event_;\n+};\n+\n class PjRtStreamExecutorRawBuffer : public CommonPjRtRawBuffer {\n  public:\n   PjRtStreamExecutorRawBuffer(PjRtStreamExecutorClient* client,"
        }
    ],
    "stats": {
        "total": 176,
        "additions": 165,
        "deletions": 11
    }
}