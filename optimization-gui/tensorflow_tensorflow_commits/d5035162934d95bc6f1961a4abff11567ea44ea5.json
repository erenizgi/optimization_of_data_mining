{
    "author": "Varcho",
    "message": "[Utilities][ReplicaGroupV3] Refactor GetPerGroupCollectiveOpsCreator to reduce cognitive complexity, and make it easier to refactor for V3 support.\n\nPiperOrigin-RevId: 843032534",
    "sha": "d5035162934d95bc6f1961a4abff11567ea44ea5",
    "files": [
        {
            "sha": "cac9a5766d88acebf17195c679a2899fe1404f35",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.cc",
            "status": "modified",
            "additions": 173,
            "deletions": 126,
            "changes": 299,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d5035162934d95bc6f1961a4abff11567ea44ea5/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d5035162934d95bc6f1961a4abff11567ea44ea5/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc?ref=d5035162934d95bc6f1961a4abff11567ea44ea5",
            "patch": "@@ -545,6 +545,153 @@ std::optional<IotaReplicaGroupList> ExpandDeviceGroupsWithMeshAxes(\n       device_groups, partition_group_list->ToIotaReplicaGroupList());\n }\n \n+// Lambdas for creating SPMDCollectiveOps functions.\n+decltype(SPMDCollectiveOpsCreator::create_cross_partition_all_reduce)\n+CreateCrossPartitionAllReduce(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, HloInstruction* operand, HloComputation* reduction,\n+             const std::vector<std::vector<int64_t>>& partition_subgroups,\n+             int64_t channel_id) {\n+    return creator.create_cross_partition_all_reduce(\n+        b, operand, reduction,\n+        ExpandDeviceGroups(*device_groups_ptr, partition_subgroups),\n+        channel_id);\n+  };\n+}\n+\n+decltype(SPMDCollectiveOpsCreator::\n+             create_cross_partition_all_reduce_with_iota_device_list)\n+CreateCrossPartitionAllReduceWithIotaDeviceList(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, HloInstruction* operand, HloComputation* reduction,\n+             const IotaReplicaGroupList& partition_group_list,\n+             int64_t channel_id) {\n+    // Try to expand the device group list, but if this fails fallback\n+    // to creating collective with list of list of integers representation.\n+    std::optional<IotaReplicaGroupList> expanded_iota_partition_group_list =\n+        ExpandDeviceGroupsWithIota(*device_groups_ptr, partition_group_list);\n+    if (!expanded_iota_partition_group_list.has_value()) {\n+      return creator.create_cross_partition_all_reduce(\n+          b, operand, reduction,\n+          ExpandDeviceGroups(*device_groups_ptr,\n+                             partition_group_list.flattened_replica_groups()),\n+          channel_id);\n+    }\n+    return creator.create_cross_partition_all_reduce_with_iota_device_list(\n+        b, operand, reduction, *expanded_iota_partition_group_list, channel_id);\n+  };\n+}\n+\n+decltype(SPMDCollectiveOpsCreator::create_cross_partition_collective_permute)\n+CreateCrossPartitionCollectivePermute(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, HloInstruction* operand,\n+             std::vector<std::pair<int64_t, int64_t>>& src_dst_pairs,\n+             int64_t next_channel_id) {\n+    std::vector<std::pair<int64_t, int64_t>> expanded_pairs(\n+        src_dst_pairs.size() * device_groups_ptr->num_groups());\n+    for (int64_t g = 0; g < device_groups_ptr->num_groups(); ++g) {\n+      for (int64_t i = 0; i < src_dst_pairs.size(); ++i) {\n+        expanded_pairs[g * src_dst_pairs.size() + i] =\n+            std::pair<int64_t, int64_t>{\n+                device_groups_ptr->array()(g, src_dst_pairs[i].first),\n+                device_groups_ptr->array()(g, src_dst_pairs[i].second)};\n+      }\n+    }\n+    return creator.create_cross_partition_collective_permute(\n+        b, operand, expanded_pairs, next_channel_id);\n+  };\n+}\n+\n+decltype(SPMDCollectiveOpsCreator::create_cross_partition_all_to_all)\n+CreateCrossPartitionAllToAll(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n+             const std::vector<std::vector<int64_t>>& partition_subgroups,\n+             int64_t channel_id, std::optional<int64_t> split_dimension) {\n+    return creator.create_cross_partition_all_to_all(\n+        b, operands,\n+        ExpandDeviceGroups(*device_groups_ptr, partition_subgroups), channel_id,\n+        split_dimension);\n+  };\n+}\n+\n+decltype(SPMDCollectiveOpsCreator::\n+             create_cross_partition_all_to_all_with_iota_device_list)\n+CreateCrossPartitionAllToAllWithIotaDeviceList(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n+             const IotaReplicaGroupList& partition_group_list,\n+             int64_t channel_id, std::optional<int64_t> split_dimension) {\n+    // Try to expand the partition group list, but if this fails fallback\n+    // to creating collective with list of list of integers representation.\n+    std::optional<IotaReplicaGroupList> expanded_iota_partition_group_list =\n+        ExpandDeviceGroupsWithIota(*device_groups_ptr, partition_group_list);\n+    if (!expanded_iota_partition_group_list.has_value()) {\n+      return creator.create_cross_partition_all_to_all(\n+          b, operands,\n+          ExpandDeviceGroups(*device_groups_ptr,\n+                             partition_group_list.flattened_replica_groups()),\n+          channel_id, split_dimension);\n+    }\n+    return creator.create_cross_partition_all_to_all_with_iota_device_list(\n+        b, operands, *expanded_iota_partition_group_list, channel_id,\n+        split_dimension);\n+  };\n+}\n+\n+decltype(SPMDCollectiveOpsCreator::create_cross_partition_all_gather)\n+CreateCrossPartitionAllGather(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n+             const std::vector<std::vector<int64_t>>& partition_subgroups,\n+             int64_t channel_id, int64_t all_gather_dimension) {\n+    return creator.create_cross_partition_all_gather(\n+        b, operand, ag_shape,\n+        ExpandDeviceGroups(*device_groups_ptr, partition_subgroups), channel_id,\n+        all_gather_dimension);\n+  };\n+}\n+\n+decltype(SPMDCollectiveOpsCreator::\n+             create_cross_partition_all_gather_with_iota_device_list)\n+CreateCrossPartitionAllGatherWithIotaDeviceList(\n+    const SPMDCollectiveOpsCreator& creator,\n+    std::shared_ptr<const DeviceGroupTileAssignment> device_groups_ptr) {\n+  return [creator, device_groups_ptr](\n+             SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n+             const IotaReplicaGroupList& partition_group_list,\n+             int64_t channel_id, int64_t all_gather_dimension) {\n+    // Try to expand the device group list, but if this fails fallback\n+    // to creating collective with list of list of integers\n+    // representation.\n+    std::optional<IotaReplicaGroupList> expanded_iota_partition_group_list =\n+        ExpandDeviceGroupsWithIota(*device_groups_ptr, partition_group_list);\n+    if (!expanded_iota_partition_group_list.has_value()) {\n+      return creator.create_cross_partition_all_gather(\n+          b, operand, ag_shape,\n+          ExpandDeviceGroups(*device_groups_ptr,\n+                             partition_group_list.flattened_replica_groups()),\n+          channel_id, all_gather_dimension);\n+    }\n+    return creator.create_cross_partition_all_gather_with_iota_device_list(\n+        b, operand, ag_shape, *expanded_iota_partition_group_list, channel_id,\n+        all_gather_dimension);\n+  };\n+}\n+\n SPMDCollectiveOpsCreator GetPerGroupCollectiveOpsCreator(\n     const SPMDCollectiveOpsCreator& creator,\n     const DeviceGroupTileAssignment& device_groups) {\n@@ -568,124 +715,25 @@ SPMDCollectiveOpsCreator GetPerGroupCollectiveOpsCreator(\n                                  *device_groups_ptr, b);\n   };\n   result.create_cross_partition_all_reduce =\n-      [creator, device_groups_ptr](\n-          SpmdBuilder* b, HloInstruction* operand, HloComputation* reduction,\n-          const std::vector<std::vector<int64_t>>& partition_subgroups,\n-          int64_t channel_id) {\n-        return creator.create_cross_partition_all_reduce(\n-            b, operand, reduction,\n-            ExpandDeviceGroups(*device_groups_ptr, partition_subgroups),\n-            channel_id);\n-      };\n+      CreateCrossPartitionAllReduce(creator, device_groups_ptr);\n   result.create_cross_partition_all_reduce_with_iota_device_list =\n-      [creator, device_groups_ptr](\n-          SpmdBuilder* b, HloInstruction* operand, HloComputation* reduction,\n-          const IotaReplicaGroupList& partition_group_list,\n-          int64_t channel_id) {\n-        // Try to expand the device group list, but if this fails fallback\n-        // to creating collective with list of list of integers representation.\n-        std::optional<IotaReplicaGroupList> expanded_iota_partition_group_list =\n-            ExpandDeviceGroupsWithIota(*device_groups_ptr,\n-                                       partition_group_list);\n-        if (!expanded_iota_partition_group_list.has_value()) {\n-          return creator.create_cross_partition_all_reduce(\n-              b, operand, reduction,\n-              ExpandDeviceGroups(\n-                  *device_groups_ptr,\n-                  partition_group_list.flattened_replica_groups()),\n-              channel_id);\n-        }\n-        return creator.create_cross_partition_all_reduce_with_iota_device_list(\n-            b, operand, reduction, *expanded_iota_partition_group_list,\n-            channel_id);\n-      };\n+      CreateCrossPartitionAllReduceWithIotaDeviceList(creator,\n+                                                      device_groups_ptr);\n   result.create_cross_partition_collective_permute =\n-      [creator, device_groups_ptr](\n-          SpmdBuilder* b, HloInstruction* operand,\n-          std::vector<std::pair<int64_t, int64_t>>& src_dst_pairs,\n-          int64_t next_channel_id) {\n-        std::vector<std::pair<int64_t, int64_t>> expanded_pairs(\n-            src_dst_pairs.size() * device_groups_ptr->num_groups());\n-        for (int64_t g = 0; g < device_groups_ptr->num_groups(); ++g) {\n-          for (int64_t i = 0; i < src_dst_pairs.size(); ++i) {\n-            expanded_pairs[g * src_dst_pairs.size() + i] =\n-                std::pair<int64_t, int64_t>{\n-                    device_groups_ptr->array()(g, src_dst_pairs[i].first),\n-                    device_groups_ptr->array()(g, src_dst_pairs[i].second)};\n-          }\n-        }\n-        return creator.create_cross_partition_collective_permute(\n-            b, operand, expanded_pairs, next_channel_id);\n-      };\n+      CreateCrossPartitionCollectivePermute(creator, device_groups_ptr);\n   result.create_cross_partition_all_to_all =\n-      [creator, device_groups_ptr](\n-          SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n-          const std::vector<std::vector<int64_t>>& partition_subgroups,\n-          int64_t channel_id, std::optional<int64_t> split_dimension) {\n-        return creator.create_cross_partition_all_to_all(\n-            b, operands,\n-            ExpandDeviceGroups(*device_groups_ptr, partition_subgroups),\n-            channel_id, split_dimension);\n-      };\n+      CreateCrossPartitionAllToAll(creator, device_groups_ptr);\n   result.create_cross_partition_all_to_all_with_iota_device_list =\n-      [creator, device_groups_ptr](\n-          SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n-          const IotaReplicaGroupList& partition_group_list, int64_t channel_id,\n-          std::optional<int64_t> split_dimension) {\n-        // Try to expand the partition group list, but if this fails fallback\n-        // to creating collective with list of list of integers representation.\n-        std::optional<IotaReplicaGroupList> expanded_iota_partition_group_list =\n-            ExpandDeviceGroupsWithIota(*device_groups_ptr,\n-                                       partition_group_list);\n-        if (!expanded_iota_partition_group_list.has_value()) {\n-          return creator.create_cross_partition_all_to_all(\n-              b, operands,\n-              ExpandDeviceGroups(\n-                  *device_groups_ptr,\n-                  partition_group_list.flattened_replica_groups()),\n-              channel_id, split_dimension);\n-        }\n-        return creator.create_cross_partition_all_to_all_with_iota_device_list(\n-            b, operands, *expanded_iota_partition_group_list, channel_id,\n-            split_dimension);\n-      };\n+      CreateCrossPartitionAllToAllWithIotaDeviceList(creator,\n+                                                     device_groups_ptr);\n   if (creator.create_cross_partition_all_gather) {\n     result.create_cross_partition_all_gather =\n-        [creator, device_groups_ptr](\n-            SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n-            const std::vector<std::vector<int64_t>>& partition_subgroups,\n-            int64_t channel_id, int64_t all_gather_dimension) {\n-          return creator.create_cross_partition_all_gather(\n-              b, operand, ag_shape,\n-              ExpandDeviceGroups(*device_groups_ptr, partition_subgroups),\n-              channel_id, all_gather_dimension);\n-        };\n+        CreateCrossPartitionAllGather(creator, device_groups_ptr);\n   }\n   if (creator.create_cross_partition_all_gather_with_iota_device_list) {\n     result.create_cross_partition_all_gather_with_iota_device_list =\n-        [creator, device_groups_ptr](\n-            SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n-            const IotaReplicaGroupList& partition_group_list,\n-            int64_t channel_id, int64_t all_gather_dimension) {\n-          // Try to expand the device group list, but if this fails fallback\n-          // to creating collective with list of list of integers\n-          // representation.\n-          std::optional<IotaReplicaGroupList>\n-              expanded_iota_partition_group_list = ExpandDeviceGroupsWithIota(\n-                  *device_groups_ptr, partition_group_list);\n-          if (!expanded_iota_partition_group_list.has_value()) {\n-            return creator.create_cross_partition_all_gather(\n-                b, operand, ag_shape,\n-                ExpandDeviceGroups(\n-                    *device_groups_ptr,\n-                    partition_group_list.flattened_replica_groups()),\n-                channel_id, all_gather_dimension);\n-          }\n-          return creator\n-              .create_cross_partition_all_gather_with_iota_device_list(\n-                  b, operand, ag_shape, *expanded_iota_partition_group_list,\n-                  channel_id, all_gather_dimension);\n-        };\n+        CreateCrossPartitionAllGatherWithIotaDeviceList(creator,\n+                                                        device_groups_ptr);\n   }\n   return result;\n }\n@@ -2902,23 +2950,22 @@ std::vector<std::vector<int64_t>> GetPartitionGroupsAcrossTargetDims(\n       group_sizes.begin(), group_sizes.end(), 1, std::multiplies<int64_t>());\n   std::vector<std::vector<int64_t>> groups(sharding.num_devices() /\n                                            total_group_size);\n-  sharding.tile_assignment().Each(\n-      [&](absl::Span<const int64_t> indices, int64_t device) {\n-        int64_t group_id = 0;\n-        for (int64_t dim = 0; dim < indices.size(); ++dim) {\n-          if (auto it = absl::c_find(target_dims, dim);\n-              it != target_dims.end()) {\n-            int64_t group_size =\n-                group_sizes[std::distance(target_dims.begin(), it)];\n-            group_id *= sharding.dimension(dim) / group_size;\n-            group_id += indices[dim] / group_size;\n-          } else {\n-            group_id *= sharding.dimension(dim);\n-            group_id += indices[dim];\n-          }\n-        }\n-        groups[group_id].push_back(device);\n-      });\n+  sharding.tile_assignment().Each([&](absl::Span<const int64_t> indices,\n+                                      int64_t device) {\n+    int64_t group_id = 0;\n+    for (int64_t dim = 0; dim < indices.size(); ++dim) {\n+      if (auto it = absl::c_find(target_dims, dim); it != target_dims.end()) {\n+        int64_t group_size =\n+            group_sizes[std::distance(target_dims.begin(), it)];\n+        group_id *= sharding.dimension(dim) / group_size;\n+        group_id += indices[dim] / group_size;\n+      } else {\n+        group_id *= sharding.dimension(dim);\n+        group_id += indices[dim];\n+      }\n+    }\n+    groups[group_id].push_back(device);\n+  });\n   return groups;\n }\n "
        }
    ],
    "stats": {
        "total": 299,
        "additions": 173,
        "deletions": 126
    }
}