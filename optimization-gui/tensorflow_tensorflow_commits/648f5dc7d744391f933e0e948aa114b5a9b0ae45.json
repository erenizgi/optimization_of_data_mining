{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809669866",
    "sha": "648f5dc7d744391f933e0e948aa114b5a9b0ae45",
    "files": [
        {
            "sha": "c7e6605ce3a0218f0a4aaff6aea1cd76410bd3a9",
            "filename": "third_party/xla/xla/python/ifrt/memory.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmemory.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmemory.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmemory.cc?ref=648f5dc7d744391f933e0e948aa114b5a9b0ae45",
            "patch": "@@ -44,7 +44,7 @@ MemoryKind::MemoryKind(std::optional<absl::string_view> memory_kind) {\n   if (!memory_kind.has_value()) {\n     return;\n   }\n-  absl::MutexLock lock(&global_set->mu);\n+  absl::MutexLock lock(global_set->mu);\n   auto it = global_set->memory_kinds_set.find(*memory_kind);\n   if (it == global_set->memory_kinds_set.end()) {\n     memory_kind_ ="
        },
        {
            "sha": "7f081083f46b1dbd08ba806a0535caf371a87c9a",
            "filename": "third_party/xla/xla/python/ifrt/serdes.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fserdes.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fserdes.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fserdes.cc?ref=648f5dc7d744391f933e0e948aa114b5a9b0ae45",
            "patch": "@@ -72,7 +72,7 @@ SerDesVersion GetRequestedSerDesVersion(const SerializeOptions* options) {\n \n void RegisterSerDes(const void* type_id, std::unique_ptr<SerDes> serdes) {\n   Registry* const r = registry();\n-  absl::MutexLock l(&r->mu);\n+  absl::MutexLock l(r->mu);\n \n   CHECK(r->type_id_to_serdes.insert({type_id, serdes.get()}).second)\n       << \"xla::ifrt::SerDes cannot be registered more than once for the same \"\n@@ -96,7 +96,7 @@ absl::StatusOr<Serialized> Serialize(\n   SerDes* serdes;\n   {\n     Registry* const r = registry();\n-    absl::MutexLock l(&r->mu);\n+    absl::MutexLock l(r->mu);\n     auto it = r->type_id_to_serdes.find(serializable.dynamicClassID());\n     if (it == r->type_id_to_serdes.end()) {\n       return absl::UnimplementedError(\n@@ -121,7 +121,7 @@ absl::StatusOr<std::unique_ptr<Serializable>> DeserializeUnchecked(\n   SerDes* serdes;\n   {\n     Registry* const r = registry();\n-    absl::MutexLock l(&r->mu);\n+    absl::MutexLock l(r->mu);\n     auto it = r->name_to_serdes.find(serialized.type_name());\n     if (it == r->name_to_serdes.end()) {\n       return absl::UnimplementedError(absl::StrCat("
        },
        {
            "sha": "a7493a64c7ccb5733b33131f01ed50ffdc9f8819",
            "filename": "third_party/xla/xla/python/ifrt/test_util.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ftest_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ftest_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ftest_util.cc?ref=648f5dc7d744391f933e0e948aa114b5a9b0ae45",
            "patch": "@@ -47,13 +47,13 @@ class ClientFactory {\n  public:\n   void Register(\n       std::function<absl::StatusOr<std::shared_ptr<Client>>()> factory) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     CHECK(!factory_) << \"Client factory has been already registered.\";\n     factory_ = std::move(factory);\n   }\n \n   std::function<absl::StatusOr<std::shared_ptr<Client>>()> Get() const {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return factory_;\n   }\n "
        },
        {
            "sha": "0b30c04d53bc4004296ed03a484d0b55f787a61e",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/648f5dc7d744391f933e0e948aa114b5a9b0ae45/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc?ref=648f5dc7d744391f933e0e948aa114b5a9b0ae45",
            "patch": "@@ -38,7 +38,7 @@ UserContextRegistry::Register(absl_nullable UserContextRef user_context) {\n     return nullptr;\n   }\n   const UserContextId id = user_context->Id();\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto it = registry_.find(id);\n   if (it != registry_.end()) {\n     // If the user context is already registered, return the existing\n@@ -63,7 +63,7 @@ UserContextRegistry::Register(absl_nullable UserContextRef user_context) {\n \n absl_nullable TrackedUserContextRef\n UserContextRegistry::Lookup(UserContextId id) const {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto it = registry_.find(id);\n   if (it != registry_.end()) {\n     // This may return `nullptr` if the `TrackedUserContext` has been destroyed\n@@ -76,7 +76,7 @@ UserContextRegistry::Lookup(UserContextId id) const {\n \n std::vector<absl_nonnull TrackedUserContextRef> UserContextRegistry::LookupAll()\n     const {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   std::vector<absl_nonnull TrackedUserContextRef> tracked_user_contexts;\n   tracked_user_contexts.reserve(registry_.size());\n   for (auto it = registry_.begin(); it != registry_.end(); ++it) {\n@@ -90,7 +90,7 @@ std::vector<absl_nonnull TrackedUserContextRef> UserContextRegistry::LookupAll()\n \n void UserContextRegistry::Unregister(\n     UserContextId id, const TrackedUserContext* tracked_user_context) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto it = registry_.find(id);\n   if (it != registry_.end() && it->second.second == tracked_user_context) {\n     registry_.erase(it);"
        }
    ],
    "stats": {
        "total": 20,
        "additions": 10,
        "deletions": 10
    }
}