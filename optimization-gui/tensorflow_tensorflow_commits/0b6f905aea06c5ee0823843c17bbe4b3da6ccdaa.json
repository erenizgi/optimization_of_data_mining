{
    "author": "mkuperst",
    "message": "[XLA] Small refactor in call splitter.\n\nSplit (ha ha) the logic that actually replaces calls out of the code that splits the callee function. NFC.\n\nPiperOrigin-RevId: 834415846",
    "sha": "0b6f905aea06c5ee0823843c17bbe4b3da6ccdaa",
    "files": [
        {
            "sha": "777ba2fae821ece1d13a35f4aa5f1a9390edd1f5",
            "filename": "third_party/xla/xla/hlo/transforms/call_splitter.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 23,
            "changes": 55,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0b6f905aea06c5ee0823843c17bbe4b3da6ccdaa/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0b6f905aea06c5ee0823843c17bbe4b3da6ccdaa/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc?ref=0b6f905aea06c5ee0823843c17bbe4b3da6ccdaa",
            "patch": "@@ -80,6 +80,33 @@ absl::flat_hash_set<HloInstruction*> GetSecondCallInstructions(\n   return second_call_instructions;\n }\n \n+// Create new call ops, connect them together, and splice them\n+// where the original call was.\n+absl::Status SplitCallSite(HloInstruction* call,\n+                           HloComputation* first_call_computation,\n+                           HloComputation* second_call_computation) {\n+  HloComputation* enclosing_computation = call->parent();\n+  HloInstruction* first_call =\n+      enclosing_computation->AddInstruction(call->CloneWithNewOperands(\n+          first_call_computation->root_instruction()->shape(),\n+          call->operands()));\n+  first_call->set_to_apply(first_call_computation);\n+  std::vector<HloInstruction*> first_call_output_gtes;\n+  int num_outputs =\n+      first_call_computation->root_instruction()->shape().tuple_shapes().size();\n+  first_call_output_gtes.reserve(num_outputs);\n+  for (int i = 0; i < num_outputs; ++i) {\n+    first_call_output_gtes.push_back(enclosing_computation->AddInstruction(\n+        HloInstruction::CreateGetTupleElement(first_call, i)));\n+  }\n+  HloInstruction* second_call =\n+      enclosing_computation->AddInstruction(call->CloneWithNewOperands(\n+          second_call_computation->root_instruction()->shape(),\n+          first_call_output_gtes));\n+  second_call->set_to_apply(second_call_computation);\n+  return call->ReplaceAllUsesWith(second_call);\n+}\n+\n absl::StatusOr<bool> SplitCall(HloInstruction* call,\n                                HloPredicate boundary_predicate) {\n   // We need to do several things here:\n@@ -101,7 +128,6 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n   // instructions end up in the second one.\n \n   HloComputation* body = call->to_apply();\n-  HloComputation* enclosing_computation = call->parent();\n   HloModule* module = body->parent();\n \n   std::vector<HloInstruction*> boundary_instructions =\n@@ -181,9 +207,9 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n           &first_call_replacements, /*extra_parameters=*/{},\n           /*context=*/nullptr, /*suffix=*/\"first\", first_call_outputs_vec));\n \n-  // Now construct the second call body. In the call body, the first call\n-  // instruction that are directly used are replaced by parameters, and the rest\n-  // are deleted.\n+  // Now construct the second call body. In the call body, the instructions\n+  // that were assigned to the first call that are directly used are replaced by\n+  // parameters, and the rest are deleted.\n   absl::flat_hash_map<const HloInstruction*, std::unique_ptr<HloInstruction>>\n       second_call_replacements;\n   for (int i = 0; i < first_call_outputs_vec.size(); ++i) {\n@@ -203,25 +229,8 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n           &second_call_replacements, /*extra_parameters=*/{},\n           /*context=*/nullptr, /*suffix=*/\"second\", /*new_root=*/nullptr));\n \n-  // Now actually create the call ops, connect them together, and splice them\n-  // where the original call was.\n-  HloInstruction* first_call =\n-      enclosing_computation->AddInstruction(call->CloneWithNewOperands(\n-          first_call_computation->root_instruction()->shape(),\n-          call->operands()));\n-  first_call->set_to_apply(first_call_computation);\n-  std::vector<HloInstruction*> first_call_output_gtes;\n-  first_call_output_gtes.reserve(first_call_outputs_vec.size());\n-  for (int i = 0; i < first_call_outputs_vec.size(); ++i) {\n-    first_call_output_gtes.push_back(enclosing_computation->AddInstruction(\n-        HloInstruction::CreateGetTupleElement(first_call, i)));\n-  }\n-  HloInstruction* second_call =\n-      enclosing_computation->AddInstruction(call->CloneWithNewOperands(\n-          second_call_computation->root_instruction()->shape(),\n-          first_call_output_gtes));\n-  second_call->set_to_apply(second_call_computation);\n-  TF_RETURN_IF_ERROR(call->ReplaceAllUsesWith(second_call));\n+  TF_RETURN_IF_ERROR(\n+      SplitCallSite(call, first_call_computation, second_call_computation));\n   return true;\n }\n "
        }
    ],
    "stats": {
        "total": 55,
        "additions": 32,
        "deletions": 23
    }
}