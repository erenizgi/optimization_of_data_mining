{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] In Promise replace IsUnique() with NumRef() == 1\n\nThe meaning of AsyncValue::IsUnique() is fuzzy for the chain of indirect async values. Prefer simpler check for uniqueness in Future/Promise library.\n\nAlso update AsyncValue::IsUnique() documentation.\n\nPiperOrigin-RevId: 824256830",
    "sha": "87e3b84514ff12c6b272c236ac0a2e2c100f3de4",
    "files": [
        {
            "sha": "d5d7cec0c99066859eaa0960f6d2e4a586c9aa96",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value.h",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/87e3b84514ff12c6b272c236ac0a2e2c100f3de4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/87e3b84514ff12c6b272c236ac0a2e2c100f3de4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h?ref=87e3b84514ff12c6b272c236ac0a2e2c100f3de4",
            "patch": "@@ -88,7 +88,12 @@ class AsyncValue {\n   // Return reference count. This should be used for testing and debugging only.\n   uint32_t NumRef() const { return refcount_.load(std::memory_order_acquire); }\n \n-  // Return true if reference count is 1.\n+  // Return true if this async value is a unique reference to the underlying\n+  // payload. For concrete async values, this is equivalent to `NumRef() == 1`.\n+  // For indirect async values it means that the whole chain of indirect async\n+  // values has a reference count of 1. For unavailable indirect async values we\n+  // conservatively return false as we don't know to what async value it will be\n+  // forwarded.\n   bool IsUnique() const;\n \n   // Add a new reference to this object.\n@@ -806,10 +811,9 @@ class IndirectAsyncValue : public AsyncValue {\n \n   bool IsUnique() const {\n     // In addition to checking the refcount of this IndirectAsyncValue, we also\n-    // need to check the refcount of the underlying value. If the underlying\n-    // value is not available, we conservatively return false.\n-    return (refcount_.load(std::memory_order_acquire) == 1) && IsAvailable() &&\n-           value_->IsUnique();\n+    // need to check the refcount of the underlying value. If indirect async\n+    // value value is not forwarded, we conservatively return false.\n+    return (NumRef() == 1) && value_ && value_->IsUnique();\n   }\n \n  protected:\n@@ -1152,7 +1156,7 @@ inline void AsyncValue::Destroy() {\n \n inline bool AsyncValue::IsUnique() const {\n   if (kind() != Kind::kIndirect) {\n-    return refcount_.load(std::memory_order_acquire) == 1;\n+    return NumRef() == 1;\n   }\n \n   // If it is an IndirectAsyncValue, we also need to check the refcount of the"
        },
        {
            "sha": "27bf49e62c577a989f75dc8adf6723a37d5f4597",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/87e3b84514ff12c6b272c236ac0a2e2c100f3de4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/87e3b84514ff12c6b272c236ac0a2e2c100f3de4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=87e3b84514ff12c6b272c236ac0a2e2c100f3de4",
            "patch": "@@ -243,9 +243,15 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n     // instead of dropping the promise without fulfilling it in order to make\n     // debugging easier. Also, be aware that the current promise may still be\n     // used to mint a future.\n+    //\n+    // We use this API only when we are exclusive owner of the promise and can\n+    // guarantee that it didn't escape to other threads via pointers. Otherwise,\n+    // this is best effort check, because it uses two atomic operations and is\n+    // not atomic itself.\n     bool IsUniqueReference() const {\n-      CHECK(promise_) << \"Promise must wrap an async value\";\n-      return promise_.IsUnique() && !promise_.HasWaiter();\n+      CHECK(promise_ && !promise_.GetAsyncValue()->IsIndirect())\n+          << \"Promise must wrap a concrete async value\";\n+      return promise_.GetAsyncValue()->NumRef() == 1 && !promise_.HasWaiter();\n     }\n \n    protected:"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 18,
        "deletions": 8
    }
}