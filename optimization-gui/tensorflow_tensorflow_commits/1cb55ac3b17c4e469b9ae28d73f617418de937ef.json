{
    "author": "majnemer",
    "message": "[PjRT] Refactor SocketAddress to use sockaddr_storage.\n\nThis change replaces the union in `SocketAddress` with `sockaddr_storage` to provide a more unified way of handling both IPv4 and IPv6 addresses.\n\nKey changes include:\n*   Using `sockaddr_storage` for internal storage.\n*   Adding a `len()` method to return the correct size for socket operations.\n*   Refactoring `ToString()` to use `getnameinfo` for address formatting.\n*   Rewriting `Parse()` to handle IPv4 and IPv6 addresses more robustly using `absl::string_view` and standard parsing functions.\n*   Updating `SocketListener` methods to work with the new `SocketAddress` structure.\n\nPiperOrigin-RevId: 828782922",
    "sha": "1cb55ac3b17c4e469b9ae28d73f617418de937ef",
    "files": [
        {
            "sha": "3794d3e0dca32ec1a7c0cb433a0fa2c1a1761d51",
            "filename": "third_party/xla/xla/python/transfer/event_loop.cc",
            "status": "modified",
            "additions": 97,
            "deletions": 100,
            "changes": 197,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1cb55ac3b17c4e469b9ae28d73f617418de937ef/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fevent_loop.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1cb55ac3b17c4e469b9ae28d73f617418de937ef/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fevent_loop.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fevent_loop.cc?ref=1cb55ac3b17c4e469b9ae28d73f617418de937ef",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n \n #include <arpa/inet.h>\n #include <linux/tcp.h>\n+#include <netdb.h>\n #include <stddef.h>\n #include <stdint.h>\n #include <stdio.h>\n@@ -25,9 +26,11 @@ limitations under the License.\n \n #include <atomic>\n #include <cerrno>\n+#include <charconv>\n #include <memory>\n #include <queue>\n #include <string>\n+#include <system_error>  // NOLINT\n #include <utility>\n #include <vector>\n \n@@ -40,6 +43,8 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_format.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/strings/strip.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n@@ -222,8 +227,8 @@ class SocketListener::Handler : public PollEventLoop::Handler {\n   }\n \n   absl::StatusOr<int> Accept(SocketAddress& recv_addr) {\n-    socklen_t addr_len = sizeof(recv_addr);\n-    int cfd = accept4(fd_, reinterpret_cast<sockaddr*>(&recv_addr), &addr_len,\n+    socklen_t addr_len = sizeof(recv_addr.mutable_address());\n+    int cfd = accept4(fd_, &recv_addr.mutable_address(), &addr_len,\n                       accept_flags_ | SOCK_CLOEXEC);\n     if (cfd == -1) {\n       return absl::ErrnoToStatus(errno, \"accept\");\n@@ -252,7 +257,7 @@ absl::StatusOr<std::unique_ptr<SocketListener>> SocketListener::Listen(\n     absl::AnyInvocable<void(int socket_fd, const SocketAddress& addr)>\n         on_accept,\n     int accept_flags) {\n-  std::unique_ptr<SocketListener> result(new SocketListener());\n+  auto result = std::make_unique<SocketListener>();\n   int sfd = socket(addr.address().sa_family,\n                    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);\n   if (sfd == -1) {\n@@ -266,37 +271,21 @@ absl::StatusOr<std::unique_ptr<SocketListener>> SocketListener::Listen(\n   if (setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &value, sizeof(value)) != 0) {\n     return absl::ErrnoToStatus(errno, \"setsockopt\");\n   }\n-  if (bind(sfd, reinterpret_cast<const struct sockaddr*>(&addr.address()),\n-           addr.address().sa_family == AF_INET6 ? sizeof(sockaddr_in6)\n-                                                : sizeof(sockaddr_in)) != 0) {\n+  if (bind(sfd, &addr.address(), addr.len()) != 0) {\n     return absl::ErrnoToStatus(errno, \"bind\");\n   }\n   if (listen(sfd, 1024) != 0) {\n     return absl::ErrnoToStatus(errno, \"listen\");\n   }\n   result->handler_ =\n       new SocketListener::Handler(sfd, accept_flags, std::move(on_accept));\n-  if (addr.address().sa_family == AF_INET6) {\n-    sockaddr_in6 new_sock_name = addr.address_ipv6();\n-    sockaddr_in6 new_sock_name2;\n-    socklen_t addr_len = sizeof(new_sock_name2);\n-    if (getsockname(sfd, reinterpret_cast<struct sockaddr*>(&new_sock_name2),\n-                    &addr_len) != 0) {\n-      return absl::ErrnoToStatus(errno, \"getsockname\");\n-    }\n-    new_sock_name.sin6_port = new_sock_name2.sin6_port;\n-    result->addr_ = SocketAddress(new_sock_name);\n-  } else {\n-    sockaddr_in new_sock_name = addr.address_ipv4();\n-    sockaddr_in new_sock_name2;\n-    socklen_t addr_len = sizeof(new_sock_name2);\n-    if (getsockname(sfd, reinterpret_cast<struct sockaddr*>(&new_sock_name2),\n-                    &addr_len) != 0) {\n-      return absl::ErrnoToStatus(errno, \"getsockname\");\n-    }\n-    new_sock_name.sin_port = new_sock_name2.sin_port;\n-    result->addr_ = SocketAddress(new_sock_name);\n+\n+  sockaddr_storage bound_storage;\n+  socklen_t bound_len = sizeof(bound_storage);\n+  if (getsockname(sfd, (sockaddr*)&bound_storage, &bound_len) != 0) {\n+    return absl::ErrnoToStatus(errno, \"getsockname\");\n   }\n+  result->addr_ = SocketAddress(bound_storage);\n   return result;\n }\n \n@@ -317,103 +306,111 @@ void SocketListener::Start() {\n }\n \n SocketAddress::SocketAddress() {\n-  memset(this, 0, sizeof(SocketAddress));\n-  saddr6_.sin6_family = AF_INET6;\n+  memset(&storage_, 0, sizeof(storage_));\n+  storage_.ss_family = AF_INET6;\n }\n \n SocketAddress::SocketAddress(const sockaddr_in& saddr) {\n-  memcpy(&saddr4_, &saddr, sizeof(saddr));\n+  memcpy(&storage_, &saddr, sizeof(saddr));\n }\n \n SocketAddress::SocketAddress(const sockaddr_in6& saddr) {\n-  memcpy(&saddr6_, &saddr, sizeof(saddr));\n+  memcpy(&storage_, &saddr, sizeof(saddr));\n }\n \n-std::string SocketAddress::ToString() const {\n-  if (saddr_.sa_family == AF_INET6) {\n-    char tmp[INET6_ADDRSTRLEN + 16];\n-    tmp[0] = '[';\n-    inet_ntop(AF_INET6, &saddr6_.sin6_addr, &tmp[1], sizeof(tmp) - 1);\n-    int pos = strlen(&tmp[0]);\n-    pos += snprintf(&tmp[pos], sizeof(tmp) - pos, \"]:%d\",\n-                    ntohs(saddr6_.sin6_port));\n-    return std::string(tmp, pos);\n-  } else if (saddr_.sa_family == AF_INET) {\n-    char tmp[INET_ADDRSTRLEN + 16];\n-    inet_ntop(AF_INET, &saddr4_.sin_addr, &tmp[0], sizeof(tmp) - 1);\n-    int pos = strlen(&tmp[0]);\n-    pos +=\n-        snprintf(&tmp[pos], sizeof(tmp) - pos, \":%d\", ntohs(saddr4_.sin_port));\n-    return std::string(tmp, pos);\n-  } else {\n-    LOG(FATAL) << \"Invalid IPAddress\";\n+SocketAddress::SocketAddress(const sockaddr_storage& saddr) : storage_(saddr) {}\n+\n+socklen_t SocketAddress::len() const {\n+  switch (storage_.ss_family) {\n+    case AF_INET6:\n+      return sizeof(sockaddr_in6);\n+    case AF_INET:\n+      return sizeof(sockaddr_in);\n+    default:\n+      return sizeof(sockaddr_storage);\n   }\n }\n \n-int ParsePort(const std::string& addr, size_t it, uint32_t& parsed_port) {\n-  size_t port_pos = addr.find(':', it);\n-  if (port_pos == std::string::npos) {\n-    return -1;\n-  }\n-  for (size_t i = port_pos + 1; i < addr.size(); ++i) {\n-    if (!(addr[i] >= '0' && addr[i] <= '9')) {\n-      return -1;\n-    }\n-    parsed_port = parsed_port * 10 + (addr[i] - '0');\n-    if (parsed_port >= 65536) {\n-      return -1;\n+std::string SocketAddress::ToString() const {\n+  char host[NI_MAXHOST], serv[NI_MAXSERV];\n+  int flags = NI_NUMERICHOST | NI_NUMERICSERV;\n+  if (getnameinfo(&address(), len(), host, sizeof(host), serv, sizeof(serv),\n+                  flags) == 0) {\n+    if (storage_.ss_family == AF_INET6) {\n+      return absl::StrCat(\"[\", host, \"]:\", serv);\n     }\n+    return absl::StrCat(host, \":\", serv);\n+  }\n+  LOG(FATAL) << \"Invalid IPAddress\";\n+}\n+\n+absl::StatusOr<uint16_t> ParsePort(absl::string_view colon_port) {\n+  if (!absl::ConsumePrefix(&colon_port, \":\")) {\n+    return absl::InvalidArgumentError(\n+        absl::StrCat(\"Missing colon for port: '\", colon_port, \"'\"));\n+  }\n+  uint16_t parsed_port;\n+  const char* last = colon_port.data() + colon_port.size();\n+  auto [ptr, ec] =\n+      std::from_chars(colon_port.data(), last, parsed_port, /*base=*/10);\n+  if (ec != std::errc{}) {\n+    return absl::ErrnoToStatus(static_cast<int>(ec),\n+                               absl::StrCat(\"std::from_chars could not parse '\",\n+                                            colon_port, \"' as a valid port\"));\n+  }\n+  if (ptr != last) {\n+    return absl::InvalidArgumentError(\n+        absl::StrCat(\"Encountered non-numeric characters while parsing port: '\",\n+                     colon_port, \"'\"));\n   }\n-  return 0;\n+  return parsed_port;\n }\n \n-int SocketAddress::Parse(const std::string& addr, SocketAddress& out) {\n-  memset(&out, 0, sizeof(SocketAddress));\n-  if (!addr.empty() && addr.data()[0] == '[') {\n+absl::StatusOr<SocketAddress> SocketAddress::Parse(absl::string_view addr) {\n+  SocketAddress out;\n+  memset(&out.storage_, 0, sizeof(out.storage_));\n+  std::string ip_address;\n+  absl::string_view colon_port;\n+  if (absl::ConsumePrefix(&addr, \"[\")) {\n     size_t it = addr.find(']');\n     if (it == std::string::npos) {\n-      return -1;\n-    }\n-    if (it - 1 >= INET6_ADDRSTRLEN) {\n-      return -1;\n+      return absl::InvalidArgumentError(\n+          absl::StrCat(\"IPv6 address missing closing bracket: '\", addr, \"'\"));\n     }\n-    char tmp[INET6_ADDRSTRLEN];\n-    uint32_t parsed_port = 0;\n-    if (ParsePort(addr, it, parsed_port) != 0) {\n-      return -1;\n-    }\n-    out.saddr6_.sin6_family = AF_INET6;\n-    out.saddr6_.sin6_port = htons(static_cast<uint16_t>(parsed_port));\n-    memcpy(&tmp[0], &addr.data()[1], it - 1);\n-    tmp[it - 1] = 0;\n-    return inet_pton(AF_INET6, &tmp[0], &out.saddr6_.sin6_addr);\n+    ip_address = addr.substr(0, it);\n+    colon_port = addr.substr(it + 1);\n+    out.storage_.ss_family = AF_INET6;\n   } else {\n     size_t it = addr.find(':');\n     if (it == std::string::npos) {\n-      return -1;\n-    }\n-    if (it >= INET_ADDRSTRLEN) {\n-      return -1;\n-    }\n-    uint32_t parsed_port = 0;\n-    if (ParsePort(addr, it, parsed_port) != 0) {\n-      return -1;\n+      return absl::InvalidArgumentError(\n+          absl::StrCat(\"IPv4 address missing colon for port: '\", addr, \"'\"));\n     }\n-    char tmp[INET_ADDRSTRLEN];\n-    memcpy(&tmp[0], &addr.data()[0], it);\n-    tmp[it] = 0;\n-    out.saddr4_.sin_family = AF_INET;\n-    out.saddr4_.sin_port = htons(static_cast<uint16_t>(parsed_port));\n-    return inet_pton(AF_INET, &tmp[0], &out.saddr4_.sin_addr);\n-  }\n-  return -1;\n-}\n+    ip_address = addr.substr(0, it);\n+    colon_port = addr.substr(it);\n+    out.storage_.ss_family = AF_INET;\n+  }\n+  absl::StatusOr<uint16_t> parsed_port = ParsePort(colon_port);\n+  if (!parsed_port.ok()) {\n+    return parsed_port.status();\n+  }\n \n-absl::StatusOr<SocketAddress> SocketAddress::Parse(const std::string& addr) {\n-  SocketAddress out;\n-  if (Parse(addr, out) == -1) {\n-    return absl::InvalidArgumentError(\n-        absl::StrCat(\"Could not parse ip address: \", addr));\n+  void* sin_addr_dst;\n+  if (out.storage_.ss_family == AF_INET6) {\n+    sockaddr_in6* v6 = (sockaddr_in6*)&out.storage_;\n+    v6->sin6_port = htons(*parsed_port);\n+    sin_addr_dst = &v6->sin6_addr;\n+  } else {\n+    CHECK_EQ(out.storage_.ss_family, AF_INET);\n+    sockaddr_in* v4 = (sockaddr_in*)&out.storage_;\n+    v4->sin_port = htons(*parsed_port);\n+    sin_addr_dst = &v4->sin_addr;\n+  }\n+  if (inet_pton(out.storage_.ss_family, ip_address.c_str(), sin_addr_dst) ==\n+      -1) {\n+    return absl::ErrnoToStatus(\n+        errno, absl::StrCat(\"inet_pton failed when parsing address: '\",\n+                            ip_address, \"'\"));\n   }\n   return out;\n }"
        },
        {
            "sha": "d1f87c5cb789a45630fc6da23ba96c7abe80f8b6",
            "filename": "third_party/xla/xla/python/transfer/event_loop.h",
            "status": "modified",
            "additions": 26,
            "deletions": 11,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1cb55ac3b17c4e469b9ae28d73f617418de937ef/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fevent_loop.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1cb55ac3b17c4e469b9ae28d73f617418de937ef/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fevent_loop.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Ftransfer%2Fevent_loop.h?ref=1cb55ac3b17c4e469b9ae28d73f617418de937ef",
            "patch": "@@ -17,11 +17,14 @@ limitations under the License.\n \n #include <netinet/in.h>\n #include <poll.h>\n+#include <sys/socket.h>\n \n #include <deque>\n #include <memory>\n+#include <string>\n \n #include \"absl/functional/any_invocable.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -89,26 +92,38 @@ class SocketAddress {\n   SocketAddress();\n   explicit SocketAddress(const sockaddr_in& saddr);\n   explicit SocketAddress(const sockaddr_in6& saddr);\n+  explicit SocketAddress(const sockaddr_storage& saddr);\n \n   // Fetch address.\n-  const sockaddr& address() const { return saddr_; }\n-  const sockaddr_in6& address_ipv6() const { return saddr6_; }\n-  const sockaddr_in& address_ipv4() const { return saddr4_; }\n+  const sockaddr& address() const {\n+    // NOLINTNEXTLINE\n+    return *reinterpret_cast<const sockaddr*>(&storage_);\n+  }\n+  sockaddr& mutable_address() {\n+    // NOLINTNEXTLINE\n+    return *reinterpret_cast<sockaddr*>(&storage_);\n+  }\n+  const sockaddr_in6& address_ipv6() const {\n+    CHECK_EQ(storage_.ss_family, AF_INET6);\n+    // NOLINTNEXTLINE\n+    return *reinterpret_cast<const sockaddr_in6*>(&storage_);\n+  }\n+  const sockaddr_in& address_ipv4() const {\n+    CHECK_EQ(storage_.ss_family, AF_INET);\n+    // NOLINTNEXTLINE\n+    return *reinterpret_cast<const sockaddr_in*>(&storage_);\n+  }\n+\n+  socklen_t len() const;\n \n   // To String (parsable with Parse).\n   std::string ToString() const;\n \n   // Inverse of ToString().\n-  static absl::StatusOr<SocketAddress> Parse(const std::string& addr);\n+  static absl::StatusOr<SocketAddress> Parse(absl::string_view addr);\n \n  private:\n-  static int Parse(const std::string& addr, SocketAddress& out);\n-\n-  union {\n-    sockaddr saddr_;\n-    sockaddr_in saddr4_;\n-    sockaddr_in6 saddr6_;\n-  };\n+  sockaddr_storage storage_;\n };\n \n // Calls accept() on sockets."
        }
    ],
    "stats": {
        "total": 234,
        "additions": 123,
        "deletions": 111
    }
}