{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 826818362",
    "sha": "ac51b90ed68b0ab2ff7c06f7613f719ed44abe21",
    "files": [
        {
            "sha": "3e1dee0cd94042f43b6d6b5b2aaa1b61e802f907",
            "filename": "tensorflow/core/profiler/profiler.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 34,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac51b90ed68b0ab2ff7c06f7613f719ed44abe21/tensorflow%2Fcore%2Fprofiler%2Fprofiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac51b90ed68b0ab2ff7c06f7613f719ed44abe21/tensorflow%2Fcore%2Fprofiler%2Fprofiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fprofiler%2Fprofiler.cc?ref=ac51b90ed68b0ab2ff7c06f7613f719ed44abe21",
            "patch": "@@ -47,7 +47,7 @@ limitations under the License.\n namespace tensorflow {\n namespace tfprof {\n void completion(const char* buf, linenoiseCompletions* lc) {\n-  string buf_str = buf;\n+  std::string buf_str = buf;\n   if (buf_str.find(' ') == buf_str.npos) {\n     for (const char* opt : kCmds) {\n       if (absl::StartsWith(opt, buf_str)) {\n@@ -57,11 +57,12 @@ void completion(const char* buf, linenoiseCompletions* lc) {\n     return;\n   }\n \n-  string prefix;\n+  std::string prefix;\n   int last_dash = buf_str.find_last_of(' ');\n-  if (last_dash != string::npos) {\n+  if (last_dash != std::string::npos) {\n     prefix = buf_str.substr(0, last_dash + 1);\n-    buf_str = buf_str.substr(last_dash + 1, kint32max);\n+    buf_str =\n+        buf_str.substr(last_dash + 1, std::numeric_limits<int32_t>::max());\n   }\n   for (const char* opt : kOptions) {\n     if (absl::StartsWith(opt, buf_str)) {\n@@ -71,11 +72,11 @@ void completion(const char* buf, linenoiseCompletions* lc) {\n }\n \n int Run(int argc, char** argv) {\n-  string FLAGS_profile_path = \"\";\n-  string FLAGS_graph_path = \"\";\n-  string FLAGS_run_meta_path = \"\";\n-  string FLAGS_op_log_path = \"\";\n-  string FLAGS_checkpoint_path = \"\";\n+  std::string FLAGS_profile_path = \"\";\n+  std::string FLAGS_graph_path = \"\";\n+  std::string FLAGS_run_meta_path = \"\";\n+  std::string FLAGS_op_log_path = \"\";\n+  std::string FLAGS_checkpoint_path = \"\";\n   int32_t FLAGS_max_depth = 10;\n   int64_t FLAGS_min_bytes = 0;\n   int64_t FLAGS_min_peak_bytes = 0;\n@@ -88,15 +89,15 @@ int Run(int argc, char** argv) {\n   int64_t FLAGS_min_float_ops = 0;\n   int64_t FLAGS_min_occurrence = 0;\n   int64_t FLAGS_step = -1;\n-  string FLAGS_order_by = \"name\";\n-  string FLAGS_account_type_regexes = \".*\";\n-  string FLAGS_start_name_regexes = \".*\";\n-  string FLAGS_trim_name_regexes = \"\";\n-  string FLAGS_show_name_regexes = \".*\";\n-  string FLAGS_hide_name_regexes;\n+  std::string FLAGS_order_by = \"name\";\n+  std::string FLAGS_account_type_regexes = \".*\";\n+  std::string FLAGS_start_name_regexes = \".*\";\n+  std::string FLAGS_trim_name_regexes = \"\";\n+  std::string FLAGS_show_name_regexes = \".*\";\n+  std::string FLAGS_hide_name_regexes;\n   bool FLAGS_account_displayed_op_only = false;\n-  string FLAGS_select = \"micros\";\n-  string FLAGS_output = \"\";\n+  std::string FLAGS_select = \"micros\";\n+  std::string FLAGS_output = \"\";\n   for (int i = 0; i < argc; i++) {\n     absl::FPrintF(stderr, \"%s\\n\", argv[i]);\n   }\n@@ -137,7 +138,7 @@ int Run(int argc, char** argv) {\n       Flag(\"select\", &FLAGS_select, \"select\"),\n       Flag(\"output\", &FLAGS_output, \"output\"),\n   };\n-  string usage = Flags::Usage(argv[0], flag_list);\n+  std::string usage = Flags::Usage(argv[0], flag_list);\n   bool parse_ok = Flags::Parse(&argc, argv, flag_list);\n   if (!parse_ok) {\n     absl::PrintF(\"%s\", usage);\n@@ -153,37 +154,37 @@ int Run(int argc, char** argv) {\n     return 1;\n   }\n \n-  std::vector<string> account_type_regexes =\n+  std::vector<std::string> account_type_regexes =\n       absl::StrSplit(FLAGS_account_type_regexes, ',', absl::SkipEmpty());\n-  std::vector<string> start_name_regexes =\n+  std::vector<std::string> start_name_regexes =\n       absl::StrSplit(FLAGS_start_name_regexes, ',', absl::SkipEmpty());\n-  std::vector<string> trim_name_regexes =\n+  std::vector<std::string> trim_name_regexes =\n       absl::StrSplit(FLAGS_trim_name_regexes, ',', absl::SkipEmpty());\n-  std::vector<string> show_name_regexes =\n+  std::vector<std::string> show_name_regexes =\n       absl::StrSplit(FLAGS_show_name_regexes, ',', absl::SkipEmpty());\n-  std::vector<string> hide_name_regexes =\n+  std::vector<std::string> hide_name_regexes =\n       absl::StrSplit(FLAGS_hide_name_regexes, ',', absl::SkipEmpty());\n-  std::vector<string> select =\n+  std::vector<std::string> select =\n       absl::StrSplit(FLAGS_select, ',', absl::SkipEmpty());\n \n-  string output_type;\n-  std::map<string, string> output_options;\n+  std::string output_type;\n+  std::map<std::string, std::string> output_options;\n   absl::Status s = ParseOutput(FLAGS_output, &output_type, &output_options);\n   CHECK(s.ok()) << s;\n \n-  string cmd = \"\";\n+  std::string cmd = \"\";\n   if (argc == 1 && FLAGS_graph_path.empty() && FLAGS_profile_path.empty() &&\n       FLAGS_run_meta_path.empty()) {\n     PrintHelp();\n     return 0;\n   } else if (argc > 1) {\n-    if (string(argv[1]) == kCmds[6]) {\n+    if (std::string(argv[1]) == kCmds[6]) {\n       PrintHelp();\n       return 0;\n     }\n-    if (string(argv[1]) == kCmds[0] || string(argv[1]) == kCmds[1] ||\n-        string(argv[1]) == kCmds[2] || string(argv[1]) == kCmds[3] ||\n-        string(argv[1]) == kCmds[4]) {\n+    if (std::string(argv[1]) == kCmds[0] || std::string(argv[1]) == kCmds[1] ||\n+        std::string(argv[1]) == kCmds[2] || std::string(argv[1]) == kCmds[3] ||\n+        std::string(argv[1]) == kCmds[4]) {\n       cmd = argv[1];\n     }\n   }\n@@ -221,7 +222,7 @@ int Run(int argc, char** argv) {\n \n     std::unique_ptr<OpLogProto> op_log = std::make_unique<OpLogProto>();\n     if (!FLAGS_op_log_path.empty()) {\n-      string op_log_str;\n+      std::string op_log_str;\n       s = ReadFileToString(Env::Default(), FLAGS_op_log_path, &op_log_str);\n       if (!s.ok()) {\n         absl::FPrintF(stderr, \"Failed to read op_log_path: %s\\n\", s.ToString());\n@@ -235,7 +236,7 @@ int Run(int argc, char** argv) {\n     tf_stat = std::make_unique<TFStats>(\n         std::move(graph), nullptr, std::move(op_log), std::move(ckpt_reader));\n \n-    std::vector<string> run_meta_files =\n+    std::vector<std::string> run_meta_files =\n         absl::StrSplit(FLAGS_run_meta_path, ',', absl::SkipEmpty());\n     for (int i = 0; i < run_meta_files.size(); ++i) {\n       std::unique_ptr<RunMetadata> run_meta = std::make_unique<RunMetadata>();\n@@ -292,7 +293,7 @@ int Run(int argc, char** argv) {\n       break;\n     }\n     looped = true;\n-    string line_s = line;\n+    std::string line_s = line;\n     free(line);\n \n     if (line_s.empty()) {"
        },
        {
            "sha": "5bc5ea2f53be16c7f995e43d9265c5ad3bc27c49",
            "filename": "tensorflow/core/profiler/tfprof_options.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 27,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac51b90ed68b0ab2ff7c06f7613f719ed44abe21/tensorflow%2Fcore%2Fprofiler%2Ftfprof_options.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac51b90ed68b0ab2ff7c06f7613f719ed44abe21/tensorflow%2Fcore%2Fprofiler%2Ftfprof_options.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fprofiler%2Ftfprof_options.cc?ref=ac51b90ed68b0ab2ff7c06f7613f719ed44abe21",
            "patch": "@@ -32,8 +32,8 @@ limitations under the License.\n namespace tensorflow {\n namespace tfprof {\n namespace {\n-string KeyValueToStr(const std::map<string, string>& kv_map) {\n-  std::vector<string> kv_vec;\n+std::string KeyValueToStr(const std::map<std::string, std::string>& kv_map) {\n+  std::vector<std::string> kv_vec;\n   kv_vec.reserve(kv_map.size());\n   for (const auto& pair : kv_map) {\n     kv_vec.push_back(absl::StrCat(pair.first, \"=\", pair.second));\n@@ -42,18 +42,19 @@ string KeyValueToStr(const std::map<string, string>& kv_map) {\n }\n }  // namespace\n \n-absl::Status ParseOutput(const string& output_opt, string* output_type,\n-                         std::map<string, string>* output_options) {\n+absl::Status ParseOutput(const std::string& output_opt,\n+                         std::string* output_type,\n+                         std::map<std::string, std::string>* output_options) {\n   // The default is to use stdout.\n   if (output_opt.empty()) {\n     *output_type = kOutput[1];\n     return absl::OkStatus();\n   }\n \n-  std::set<string> output_types(kOutput,\n-                                kOutput + sizeof(kOutput) / sizeof(*kOutput));\n+  std::set<std::string> output_types(\n+      kOutput, kOutput + sizeof(kOutput) / sizeof(*kOutput));\n   auto opt_split = output_opt.find(':');\n-  std::vector<string> kv_split;\n+  std::vector<std::string> kv_split;\n   if (opt_split == output_opt.npos) {\n     if (output_types.find(output_opt) == output_types.end()) {\n       return absl::Status(\n@@ -74,8 +75,8 @@ absl::Status ParseOutput(const string& output_opt, string* output_type,\n                               absl::SkipEmpty());\n   }\n \n-  std::set<string> valid_options;\n-  std::set<string> required_options;\n+  std::set<std::string> valid_options;\n+  std::set<std::string> required_options;\n   if (*output_type == kOutput[0]) {\n     valid_options.insert(\n         kTimelineOpts,\n@@ -99,8 +100,8 @@ absl::Status ParseOutput(const string& output_opt, string* output_type,\n             sizeof(kPprofRequiredOpts) / sizeof(*kPprofRequiredOpts));\n   }\n \n-  for (const string& kv_str : kv_split) {\n-    const std::vector<string> kv =\n+  for (const std::string& kv_str : kv_split) {\n+    const std::vector<std::string> kv =\n         absl::StrSplit(kv_str, '=', absl::SkipEmpty());\n     if (kv.size() < 2) {\n       return absl::Status(\n@@ -113,11 +114,11 @@ absl::Status ParseOutput(const string& output_opt, string* output_type,\n           absl::StrFormat(\"Unrecognized options %s for output_type: %s\\n\",\n                           kv[0], *output_type));\n     }\n-    const std::vector<string> kv_without_key(kv.begin() + 1, kv.end());\n+    const std::vector<std::string> kv_without_key(kv.begin() + 1, kv.end());\n     (*output_options)[kv[0]] = absl::StrJoin(kv_without_key, \"=\");\n   }\n \n-  for (const string& opt : required_options) {\n+  for (const std::string& opt : required_options) {\n     if (output_options->find(opt) == output_options->end()) {\n       return absl::Status(\n           absl::StatusCode::kInvalidArgument,\n@@ -129,7 +130,7 @@ absl::Status ParseOutput(const string& output_opt, string* output_type,\n   return absl::OkStatus();\n }\n \n-absl::Status Options::FromProtoStr(const string& opts_proto_str,\n+absl::Status Options::FromProtoStr(const std::string& opts_proto_str,\n                                    Options* opts) {\n   OptionsProto opts_pb;\n   if (!opts_pb.ParseFromString(opts_proto_str)) {\n@@ -139,8 +140,8 @@ absl::Status Options::FromProtoStr(const string& opts_proto_str,\n                      opts_proto_str));\n   }\n \n-  string output_type;\n-  std::map<string, string> output_options;\n+  std::string output_type;\n+  std::map<std::string, std::string> output_options;\n   absl::Status s = ParseOutput(opts_pb.output(), &output_type, &output_options);\n   if (!s.ok()) return s;\n \n@@ -162,18 +163,19 @@ absl::Status Options::FromProtoStr(const string& opts_proto_str,\n       opts_pb.min_micros(), opts_pb.min_accelerator_micros(),\n       opts_pb.min_cpu_micros(), opts_pb.min_params(), opts_pb.min_float_ops(),\n       opts_pb.min_occurrence(), opts_pb.step(), opts_pb.order_by(),\n-      std::vector<string>(opts_pb.account_type_regexes().begin(),\n-                          opts_pb.account_type_regexes().end()),\n-      std::vector<string>(opts_pb.start_name_regexes().begin(),\n-                          opts_pb.start_name_regexes().end()),\n-      std::vector<string>(opts_pb.trim_name_regexes().begin(),\n-                          opts_pb.trim_name_regexes().end()),\n-      std::vector<string>(opts_pb.show_name_regexes().begin(),\n-                          opts_pb.show_name_regexes().end()),\n-      std::vector<string>(opts_pb.hide_name_regexes().begin(),\n-                          opts_pb.hide_name_regexes().end()),\n+      std::vector<std::string>(opts_pb.account_type_regexes().begin(),\n+                               opts_pb.account_type_regexes().end()),\n+      std::vector<std::string>(opts_pb.start_name_regexes().begin(),\n+                               opts_pb.start_name_regexes().end()),\n+      std::vector<std::string>(opts_pb.trim_name_regexes().begin(),\n+                               opts_pb.trim_name_regexes().end()),\n+      std::vector<std::string>(opts_pb.show_name_regexes().begin(),\n+                               opts_pb.show_name_regexes().end()),\n+      std::vector<std::string>(opts_pb.hide_name_regexes().begin(),\n+                               opts_pb.hide_name_regexes().end()),\n       opts_pb.account_displayed_op_only(),\n-      std::vector<string>(opts_pb.select().begin(), opts_pb.select().end()),\n+      std::vector<std::string>(opts_pb.select().begin(),\n+                               opts_pb.select().end()),\n       output_type, output_options);\n   return absl::OkStatus();\n }"
        },
        {
            "sha": "821a868b3e78160b8e40fe1243fb5229e92f7fe8",
            "filename": "tensorflow/core/profiler/tfprof_options.h",
            "status": "modified",
            "additions": 25,
            "deletions": 22,
            "changes": 47,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac51b90ed68b0ab2ff7c06f7613f719ed44abe21/tensorflow%2Fcore%2Fprofiler%2Ftfprof_options.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac51b90ed68b0ab2ff7c06f7613f719ed44abe21/tensorflow%2Fcore%2Fprofiler%2Ftfprof_options.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fprofiler%2Ftfprof_options.h?ref=ac51b90ed68b0ab2ff7c06f7613f719ed44abe21",
            "patch": "@@ -102,7 +102,8 @@ static const char* const kPprofRequiredOpts[] = {\n \n struct Options {\n  public:\n-  static absl::Status FromProtoStr(const string& opts_proto_str, Options* opts);\n+  static absl::Status FromProtoStr(const std::string& opts_proto_str,\n+                                   Options* opts);\n \n   virtual ~Options() = default;\n   Options()\n@@ -113,15 +114,16 @@ struct Options {\n           int64_t min_residual_bytes, int64_t min_output_bytes,\n           int64_t min_micros, int64_t min_accelerator_micros,\n           int64_t min_cpu_micros, int64_t min_params, int64_t min_float_ops,\n-          int64_t min_occurrence, int64_t step, const string& order_by,\n-          const std::vector<string>& account_type_regexes,\n-          const std::vector<string>& start_name_regexes,\n-          const std::vector<string>& trim_name_regexes,\n-          const std::vector<string>& show_name_regexes,\n-          const std::vector<string>& hide_name_regexes,\n-          bool account_displayed_op_only, const std::vector<string>& select,\n-          const string& output_type,\n-          const std::map<string, string>& output_options)\n+          int64_t min_occurrence, int64_t step, const std::string& order_by,\n+          const std::vector<std::string>& account_type_regexes,\n+          const std::vector<std::string>& start_name_regexes,\n+          const std::vector<std::string>& trim_name_regexes,\n+          const std::vector<std::string>& show_name_regexes,\n+          const std::vector<std::string>& hide_name_regexes,\n+          bool account_displayed_op_only,\n+          const std::vector<std::string>& select,\n+          const std::string& output_type,\n+          const std::map<std::string, std::string>& output_options)\n       : max_depth(max_depth),\n         min_bytes(min_bytes),\n         min_peak_bytes(min_peak_bytes),\n@@ -145,7 +147,7 @@ struct Options {\n         output_type(output_type),\n         output_options(output_options) {}\n \n-  string ToString() const;\n+  std::string ToString() const;\n \n   int max_depth;\n   int64_t min_bytes;\n@@ -159,26 +161,27 @@ struct Options {\n   int64_t min_float_ops;\n   int64_t min_occurrence;\n   int64_t step;\n-  string order_by;\n+  std::string order_by;\n \n-  std::vector<string> account_type_regexes;\n-  std::vector<string> start_name_regexes;\n-  std::vector<string> trim_name_regexes;\n-  std::vector<string> show_name_regexes;\n-  std::vector<string> hide_name_regexes;\n+  std::vector<std::string> account_type_regexes;\n+  std::vector<std::string> start_name_regexes;\n+  std::vector<std::string> trim_name_regexes;\n+  std::vector<std::string> show_name_regexes;\n+  std::vector<std::string> hide_name_regexes;\n   bool account_displayed_op_only;\n \n-  std::set<string> select;\n+  std::set<std::string> select;\n \n-  string output_type;\n-  std::map<string, string> output_options;\n+  std::string output_type;\n+  std::map<std::string, std::string> output_options;\n };\n \n // Parse the -output option.\n // 'output_opt': User input string with format: output_type:key=value,key=value.\n // 'output_type' and 'output_options' are extracted from 'output_opt'.\n-absl::Status ParseOutput(const string& output_opt, string* output_type,\n-                         std::map<string, string>* output_options);\n+absl::Status ParseOutput(const std::string& output_opt,\n+                         std::string* output_type,\n+                         std::map<std::string, std::string>* output_options);\n \n }  // namespace tfprof\n }  // namespace tensorflow"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 89,
        "deletions": 83
    }
}