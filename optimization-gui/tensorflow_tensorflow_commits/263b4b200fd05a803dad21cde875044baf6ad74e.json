{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 828810806",
    "sha": "263b4b200fd05a803dad21cde875044baf6ad74e",
    "files": [
        {
            "sha": "34efc30e9dfc2c0beb05658839a9b0e123d22bbe",
            "filename": "third_party/xla/xla/tsl/lib/io/block.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 28,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -28,24 +28,24 @@ limitations under the License.\n namespace tsl {\n namespace table {\n \n-inline uint32 Block::NumRestarts() const {\n-  assert(size_ >= sizeof(uint32));\n-  return core::DecodeFixed32(data_ + size_ - sizeof(uint32));\n+inline uint32_t Block::NumRestarts() const {\n+  assert(size_ >= sizeof(uint32_t));\n+  return core::DecodeFixed32(data_ + size_ - sizeof(uint32_t));\n }\n \n Block::Block(const BlockContents& contents)\n     : data_(contents.data.data()),\n       size_(contents.data.size()),\n       owned_(contents.heap_allocated) {\n-  if (size_ < sizeof(uint32)) {\n+  if (size_ < sizeof(uint32_t)) {\n     size_ = 0;  // Error marker\n   } else {\n-    size_t max_restarts_allowed = (size_ - sizeof(uint32)) / sizeof(uint32);\n+    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);\n     if (NumRestarts() > max_restarts_allowed) {\n       // The size is too small for NumRestarts()\n       size_ = 0;\n     } else {\n-      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32);\n+      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);\n     }\n   }\n }\n@@ -64,8 +64,8 @@ Block::~Block() {\n // If any errors are detected, returns NULL.  Otherwise, returns a\n // pointer to the key delta (just past the three decoded values).\n static inline const char* DecodeEntry(const char* p, const char* limit,\n-                                      uint32* shared, uint32* non_shared,\n-                                      uint32* value_length) {\n+                                      uint32_t* shared, uint32_t* non_shared,\n+                                      uint32_t* value_length) {\n   if (limit - p < 3) return nullptr;\n   *shared = reinterpret_cast<const unsigned char*>(p)[0];\n   *non_shared = reinterpret_cast<const unsigned char*>(p)[1];\n@@ -81,7 +81,7 @@ static inline const char* DecodeEntry(const char* p, const char* limit,\n       return nullptr;\n   }\n \n-  if (static_cast<uint32>(limit - p) < (*non_shared + *value_length)) {\n+  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {\n     return nullptr;\n   }\n   return p;\n@@ -90,13 +90,13 @@ static inline const char* DecodeEntry(const char* p, const char* limit,\n class Block::Iter : public Iterator {\n  private:\n   const char* const data_;     // underlying block contents\n-  uint32 const restarts_;      // Offset of restart array (list of fixed32)\n-  uint32 const num_restarts_;  // Number of uint32 entries in restart array\n+  const uint32_t restarts_;    // Offset of restart array (list of fixed32)\n+  const uint32_t num_restarts_;  // Number of uint32 entries in restart array\n \n   // current_ is offset in data_ of current entry.  >= restarts_ if !Valid\n-  uint32 current_;\n-  uint32 restart_index_;  // Index of restart block in which current_ falls\n-  string key_;\n+  uint32_t current_;\n+  uint32_t restart_index_;  // Index of restart block in which current_ falls\n+  std::string key_;\n   absl::string_view value_;\n   absl::Status status_;\n \n@@ -106,27 +106,27 @@ class Block::Iter : public Iterator {\n   }\n \n   // Return the offset in data_ just past the end of the current entry.\n-  inline uint32 NextEntryOffset() const {\n+  inline uint32_t NextEntryOffset() const {\n     return (value_.data() + value_.size()) - data_;\n   }\n \n-  uint32 GetRestartPoint(uint32 index) {\n+  uint32_t GetRestartPoint(uint32_t index) {\n     assert(index < num_restarts_);\n-    return core::DecodeFixed32(data_ + restarts_ + index * sizeof(uint32));\n+    return core::DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n   }\n \n-  void SeekToRestartPoint(uint32 index) {\n+  void SeekToRestartPoint(uint32_t index) {\n     key_.clear();\n     restart_index_ = index;\n     // current_ will be fixed by ParseNextKey();\n \n     // ParseNextKey() starts at the end of value_, so set value_ accordingly\n-    uint32 offset = GetRestartPoint(index);\n+    uint32_t offset = GetRestartPoint(index);\n     value_ = absl::string_view(data_ + offset, 0);\n   }\n \n  public:\n-  Iter(const char* data, uint32 restarts, uint32 num_restarts)\n+  Iter(const char* data, uint32_t restarts, uint32_t num_restarts)\n       : data_(data),\n         restarts_(restarts),\n         num_restarts_(num_restarts),\n@@ -154,12 +154,12 @@ class Block::Iter : public Iterator {\n   void Seek(absl::string_view target) override {\n     // Binary search in restart array to find the last restart point\n     // with a key < target\n-    uint32 left = 0;\n-    uint32 right = num_restarts_ - 1;\n+    uint32_t left = 0;\n+    uint32_t right = num_restarts_ - 1;\n     while (left < right) {\n-      uint32 mid = left + (right - left + 1) / 2;\n-      uint32 region_offset = GetRestartPoint(mid);\n-      uint32 shared, non_shared, value_length;\n+      uint32_t mid = left + (right - left + 1) / 2;\n+      uint32_t region_offset = GetRestartPoint(mid);\n+      uint32_t shared, non_shared, value_length;\n       const char* key_ptr =\n           DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,\n                       &non_shared, &value_length);\n@@ -217,7 +217,7 @@ class Block::Iter : public Iterator {\n     }\n \n     // Decode next entry\n-    uint32 shared, non_shared, value_length;\n+    uint32_t shared, non_shared, value_length;\n     p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n     if (p == nullptr || key_.size() < shared) {\n       CorruptionError();\n@@ -236,10 +236,10 @@ class Block::Iter : public Iterator {\n };\n \n Iterator* Block::NewIterator() {\n-  if (size_ < sizeof(uint32)) {\n+  if (size_ < sizeof(uint32_t)) {\n     return NewErrorIterator(errors::DataLoss(\"bad block contents\"));\n   }\n-  const uint32 num_restarts = NumRestarts();\n+  const uint32_t num_restarts = NumRestarts();\n   if (num_restarts == 0) {\n     return NewEmptyIterator();\n   } else {"
        },
        {
            "sha": "8c839c0bce20472ccc0966cf7e671a9df132530a",
            "filename": "third_party/xla/xla/tsl/lib/io/block.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -37,11 +37,11 @@ class Block {\n   Iterator* NewIterator();\n \n  private:\n-  uint32 NumRestarts() const;\n+  uint32_t NumRestarts() const;\n \n   const char* data_;\n   size_t size_;\n-  uint32 restart_offset_;  // Offset in data_ of restart array\n+  uint32_t restart_offset_;  // Offset in data_ of restart array\n   bool owned_;             // Block owns data_[]\n \n   // No copying allowed"
        },
        {
            "sha": "61dd61d8d6d0d11c6febc74e8fc0e582f8cbab06",
            "filename": "third_party/xla/xla/tsl/lib/io/block_builder.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock_builder.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -65,9 +65,9 @@ void BlockBuilder::Reset() {\n }\n \n size_t BlockBuilder::CurrentSizeEstimate() const {\n-  return (buffer_.size() +                     // Raw data buffer\n-          restarts_.size() * sizeof(uint32) +  // Restart array\n-          sizeof(uint32));                     // Restart array length\n+  return (buffer_.size() +                       // Raw data buffer\n+          restarts_.size() * sizeof(uint32_t) +  // Restart array\n+          sizeof(uint32_t));                     // Restart array length\n }\n \n absl::string_view BlockBuilder::Finish() {"
        },
        {
            "sha": "a27bbf1c3fe3b50f516b6c143a5006a8d4973c23",
            "filename": "third_party/xla/xla/tsl/lib/io/block_builder.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock_builder.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock_builder.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fblock_builder.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -53,11 +53,11 @@ class BlockBuilder {\n \n  private:\n   const Options* options_;\n-  string buffer_;                 // Destination buffer\n-  std::vector<uint32> restarts_;  // Restart points\n+  std::string buffer_;              // Destination buffer\n+  std::vector<uint32_t> restarts_;  // Restart points\n   int counter_;                   // Number of entries emitted since restart\n   bool finished_;                 // Has Finish() been called?\n-  string last_key_;\n+  std::string last_key_;\n \n   // No copying allowed\n   BlockBuilder(const BlockBuilder&);"
        },
        {
            "sha": "898a731c7e2e0c2a66a1acdcc9caa7f42ba4e6a7",
            "filename": "third_party/xla/xla/tsl/lib/io/buffered_file_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fbuffered_file_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fbuffered_file_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fbuffered_file_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -29,7 +29,7 @@ namespace {\n \n TEST(BufferedInputStream, Tell) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   std::unique_ptr<WritableFile> write_file;\n   TF_ASSERT_OK(env->NewWritableFile(fname, &write_file));"
        },
        {
            "sha": "ee3241e62f82d24b9a39ae1ec87ce11e0cba9ac8",
            "filename": "third_party/xla/xla/tsl/lib/io/buffered_inputstream_test.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 30,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fbuffered_inputstream_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fbuffered_inputstream_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fbuffered_inputstream_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -63,7 +63,7 @@ class ReadOnceInputStream : public InputStreamInterface {\n \n TEST(BufferedInputStream, ReadLine_Empty) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -73,14 +73,14 @@ TEST(BufferedInputStream, ReadLine_Empty) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     EXPECT_TRUE(absl::IsOutOfRange(in.ReadLine(&line)));\n   }\n }\n \n TEST(BufferedInputStream, ReadLine1) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(\n       WriteStringToFile(env, fname, \"line one\\nline two\\nline three\\n\"));\n@@ -91,7 +91,7 @@ TEST(BufferedInputStream, ReadLine1) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n     TF_ASSERT_OK(in.ReadLine(&line));\n@@ -106,7 +106,7 @@ TEST(BufferedInputStream, ReadLine1) {\n \n TEST(BufferedInputStream, ReadLine_NoTrailingNewLine) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"line one\\nline two\\nline three\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -116,7 +116,7 @@ TEST(BufferedInputStream, ReadLine_NoTrailingNewLine) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n     TF_ASSERT_OK(in.ReadLine(&line));\n@@ -131,7 +131,7 @@ TEST(BufferedInputStream, ReadLine_NoTrailingNewLine) {\n \n TEST(BufferedInputStream, ReadLine_EmptyLines) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(\n       WriteStringToFile(env, fname, \"line one\\n\\n\\nline two\\nline three\"));\n@@ -142,7 +142,7 @@ TEST(BufferedInputStream, ReadLine_EmptyLines) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n     TF_ASSERT_OK(in.ReadLine(&line));\n@@ -161,7 +161,7 @@ TEST(BufferedInputStream, ReadLine_EmptyLines) {\n \n TEST(BufferedInputStream, ReadLine_CRLF) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname,\n                                  \"line one\\r\\n\\r\\n\\r\\nline two\\r\\nline three\"));\n@@ -172,7 +172,7 @@ TEST(BufferedInputStream, ReadLine_CRLF) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n     TF_ASSERT_OK(in.ReadLine(&line));\n@@ -191,7 +191,7 @@ TEST(BufferedInputStream, ReadLine_CRLF) {\n \n TEST(BufferedInputStream, SkipLine1) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(\n       WriteStringToFile(env, fname, \"line one\\nline two\\nline three\\n\"));\n@@ -202,7 +202,7 @@ TEST(BufferedInputStream, SkipLine1) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.SkipLine());\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line two\");\n@@ -215,7 +215,7 @@ TEST(BufferedInputStream, SkipLine1) {\n \n TEST(BufferedInputStream, SkipLine_NoTrailingNewLine) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"line one\\nline two\\nline three\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -225,7 +225,7 @@ TEST(BufferedInputStream, SkipLine_NoTrailingNewLine) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.SkipLine());\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line two\");\n@@ -238,7 +238,7 @@ TEST(BufferedInputStream, SkipLine_NoTrailingNewLine) {\n \n TEST(BufferedInputStream, SkipLine_EmptyLines) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"line one\\n\\n\\nline two\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -248,7 +248,7 @@ TEST(BufferedInputStream, SkipLine_EmptyLines) {\n     std::unique_ptr<RandomAccessInputStream> input_stream(\n         new RandomAccessInputStream(file.get()));\n     BufferedInputStream in(input_stream.get(), buf_size);\n-    string line;\n+    std::string line;\n     TF_ASSERT_OK(in.SkipLine());\n     TF_ASSERT_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"\");\n@@ -260,7 +260,7 @@ TEST(BufferedInputStream, SkipLine_EmptyLines) {\n \n TEST(BufferedInputStream, ReadNBytes) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -324,7 +324,7 @@ TEST(BufferedInputStream, OutOfRangeCache) {\n \n TEST(BufferedInputStream, SkipNBytes) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -362,7 +362,7 @@ TEST(BufferedInputStream, SkipNBytes) {\n \n TEST(BufferedInputStream, ReadNBytesRandomAccessFile) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -398,7 +398,7 @@ TEST(BufferedInputStream, ReadNBytesRandomAccessFile) {\n \n TEST(BufferedInputStream, SkipNBytesRandomAccessFile) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -434,7 +434,7 @@ TEST(BufferedInputStream, SkipNBytesRandomAccessFile) {\n \n TEST(BufferedInputStream, Seek) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -467,7 +467,7 @@ TEST(BufferedInputStream, Seek_NotReset) {\n   // This test verifies seek backwards within the buffer doesn't reset\n   // input_stream\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n   std::unique_ptr<RandomAccessFile> file;\n@@ -489,35 +489,35 @@ TEST(BufferedInputStream, Seek_NotReset) {\n \n TEST(BufferedInputStream, ReadAll_Empty) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n-  const string expected = \"\";\n+  const std::string expected = \"\";\n   TF_ASSERT_OK(WriteStringToFile(env, fname, expected));\n   std::unique_ptr<RandomAccessFile> file;\n   TF_ASSERT_OK(env->NewRandomAccessFile(fname, &file));\n \n   for (auto buf_size : BufferSizes()) {\n     RandomAccessInputStream input_stream(file.get());\n     BufferedInputStream in(&input_stream, buf_size);\n-    string contents;\n+    std::string contents;\n     TF_ASSERT_OK(in.ReadAll(&contents));\n     EXPECT_EQ(expected, contents);\n   }\n }\n \n TEST(BufferedInputStream, ReadAll_Text) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n-  const string expected = \"line one\\nline two\\nline three\";\n+  const std::string expected = \"line one\\nline two\\nline three\";\n   TF_ASSERT_OK(WriteStringToFile(env, fname, expected));\n   std::unique_ptr<RandomAccessFile> file;\n   TF_ASSERT_OK(env->NewRandomAccessFile(fname, &file));\n \n   for (auto buf_size : BufferSizes()) {\n     RandomAccessInputStream input_stream(file.get());\n     BufferedInputStream in(&input_stream, buf_size);\n-    string contents;\n+    std::string contents;\n     TF_ASSERT_OK(in.ReadAll(&contents));\n     EXPECT_EQ(expected, contents);\n   }\n@@ -527,10 +527,10 @@ void BM_BufferedReaderSmallReads(::testing::benchmark::State& state) {\n   const int buff_size = state.range(0);\n   const int file_size = state.range(1);\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n \n-  const string file_elem = \"0123456789\";\n+  const std::string file_elem = \"0123456789\";\n   std::unique_ptr<WritableFile> write_file;\n   TF_ASSERT_OK(env->NewWritableFile(fname, &write_file));\n   for (int i = 0; i < file_size; ++i) {"
        },
        {
            "sha": "aeee0db931cae90a004341a9a7d3d759a65a6038",
            "filename": "third_party/xla/xla/tsl/lib/io/format.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fformat.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fformat.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fformat.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -28,10 +28,10 @@ limitations under the License.\n namespace tsl {\n namespace table {\n \n-void BlockHandle::EncodeTo(string* dst) const {\n+void BlockHandle::EncodeTo(std::string* dst) const {\n   // Sanity check that all fields have been set\n-  assert(offset_ != ~static_cast<uint64>(0));\n-  assert(size_ != ~static_cast<uint64>(0));\n+  assert(offset_ != ~static_cast<uint64_t>(0));\n+  assert(size_ != ~static_cast<uint64_t>(0));\n   core::PutVarint64(dst, offset_);\n   core::PutVarint64(dst, size_);\n }\n@@ -44,24 +44,24 @@ absl::Status BlockHandle::DecodeFrom(absl::string_view* input) {\n   }\n }\n \n-void Footer::EncodeTo(string* dst) const {\n+void Footer::EncodeTo(std::string* dst) const {\n #ifndef NDEBUG\n   const size_t original_size = dst->size();\n #endif\n   metaindex_handle_.EncodeTo(dst);\n   index_handle_.EncodeTo(dst);\n   dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding\n-  core::PutFixed32(dst, static_cast<uint32>(kTableMagicNumber & 0xffffffffu));\n-  core::PutFixed32(dst, static_cast<uint32>(kTableMagicNumber >> 32));\n+  core::PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));\n+  core::PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));\n   assert(dst->size() == original_size + kEncodedLength);\n }\n \n absl::Status Footer::DecodeFrom(absl::string_view* input) {\n   const char* magic_ptr = input->data() + kEncodedLength - 8;\n-  const uint32 magic_lo = core::DecodeFixed32(magic_ptr);\n-  const uint32 magic_hi = core::DecodeFixed32(magic_ptr + 4);\n-  const uint64 magic =\n-      ((static_cast<uint64>(magic_hi) << 32) | (static_cast<uint64>(magic_lo)));\n+  const uint32_t magic_lo = core::DecodeFixed32(magic_ptr);\n+  const uint32_t magic_hi = core::DecodeFixed32(magic_ptr + 4);\n+  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n+                          (static_cast<uint64_t>(magic_lo)));\n   if (magic != kTableMagicNumber) {\n     return errors::DataLoss(\"not an sstable (bad magic number)\");\n   }\n@@ -110,8 +110,8 @@ absl::Status ReadBlock(RandomAccessFile* file, const BlockHandle& handle,\n   // This checksum verification is optional.  We leave it on for now\n   const bool verify_checksum = true;\n   if (verify_checksum) {\n-    const uint32 crc = crc32c::Unmask(core::DecodeFixed32(data + n + 1));\n-    const uint32 actual = crc32c::Value(data, n + 1);\n+    const uint32_t crc = crc32c::Unmask(core::DecodeFixed32(data + n + 1));\n+    const uint32_t actual = crc32c::Value(data, n + 1);\n     if (actual != crc) {\n       delete[] buf;\n       s = errors::DataLoss(\"block checksum mismatch\");"
        },
        {
            "sha": "fa34bdd8ac75e862f147a670068d979cc548b70d",
            "filename": "third_party/xla/xla/tsl/lib/io/format.h",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fformat.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fformat.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fformat.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -38,22 +38,22 @@ class BlockHandle {\n   BlockHandle();\n \n   // The offset of the block in the file.\n-  uint64 offset() const { return offset_; }\n-  void set_offset(uint64 offset) { offset_ = offset; }\n+  uint64_t offset() const { return offset_; }\n+  void set_offset(uint64_t offset) { offset_ = offset; }\n \n   // The size of the stored block\n-  uint64 size() const { return size_; }\n-  void set_size(uint64 size) { size_ = size; }\n+  uint64_t size() const { return size_; }\n+  void set_size(uint64_t size) { size_ = size; }\n \n-  void EncodeTo(string* dst) const;\n+  void EncodeTo(std::string* dst) const;\n   absl::Status DecodeFrom(absl::string_view* input);\n \n   // Maximum encoding length of a BlockHandle\n   enum { kMaxEncodedLength = 10 + 10 };\n \n  private:\n-  uint64 offset_;\n-  uint64 size_;\n+  uint64_t offset_;\n+  uint64_t size_;\n };\n \n // Footer encapsulates the fixed information stored at the tail\n@@ -70,7 +70,7 @@ class Footer {\n   const BlockHandle& index_handle() const { return index_handle_; }\n   void set_index_handle(const BlockHandle& h) { index_handle_ = h; }\n \n-  void EncodeTo(string* dst) const;\n+  void EncodeTo(std::string* dst) const;\n   absl::Status DecodeFrom(absl::string_view* input);\n \n   // Encoded length of a Footer.  Note that the serialization of a\n@@ -86,7 +86,7 @@ class Footer {\n // kTableMagicNumber was picked by running\n //    echo http://code.google.com/p/leveldb/ | sha1sum\n // and taking the leading 64 bits.\n-static const uint64 kTableMagicNumber = 0xdb4775248b80fb57ull;\n+static const uint64_t kTableMagicNumber = 0xdb4775248b80fb57ull;\n \n // 1-byte type + 32-bit crc\n static const size_t kBlockTrailerSize = 5;\n@@ -105,7 +105,7 @@ extern absl::Status ReadBlock(RandomAccessFile* file, const BlockHandle& handle,\n // Implementation details follow.  Clients should ignore,\n \n inline BlockHandle::BlockHandle()\n-    : offset_(~static_cast<uint64>(0)), size_(~static_cast<uint64>(0)) {}\n+    : offset_(~static_cast<uint64_t>(0)), size_(~static_cast<uint64_t>(0)) {}\n \n }  // namespace table\n }  // namespace tsl"
        },
        {
            "sha": "9fbd9ecb8f1679c00a0921fc766558a33e4d4289",
            "filename": "third_party/xla/xla/tsl/lib/io/inputbuffer.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -130,15 +130,15 @@ absl::Status InputBuffer::ReadNBytes(int64_t bytes_to_read, char* result,\n   return status;\n }\n \n-absl::Status InputBuffer::ReadVarint32Fallback(uint32* result) {\n+absl::Status InputBuffer::ReadVarint32Fallback(uint32_t* result) {\n   absl::Status s = ReadVarintFallback(result, core::kMaxVarint32Bytes);\n   if (absl::IsDataLoss(s)) {\n     return errors::DataLoss(\"Stored data is too large to be a varint32.\");\n   }\n   return s;\n }\n \n-absl::Status InputBuffer::ReadVarint64Fallback(uint64* result) {\n+absl::Status InputBuffer::ReadVarint64Fallback(uint64_t* result) {\n   absl::Status s = ReadVarintFallback(result, core::kMaxVarint64Bytes);\n   if (absl::IsDataLoss(s)) {\n     return errors::DataLoss(\"Stored data is too large to be a varint64.\");\n@@ -148,7 +148,7 @@ absl::Status InputBuffer::ReadVarint64Fallback(uint64* result) {\n \n template <typename T>\n absl::Status InputBuffer::ReadVarintFallback(T* result, int max_bytes) {\n-  uint8 scratch = 0;\n+  uint8_t scratch = 0;\n   auto* p = reinterpret_cast<char*>(&scratch);\n   size_t unused_bytes_read = 0;\n "
        },
        {
            "sha": "b9d26f3bc451f3ed57715c5e0914fdf8329ec5ac",
            "filename": "third_party/xla/xla/tsl/lib/io/inputbuffer.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -67,10 +67,10 @@ class InputBuffer {\n                           size_t* bytes_read);\n \n   // Reads a single varint32.\n-  absl::Status ReadVarint32(uint32* result);\n+  absl::Status ReadVarint32(uint32_t* result);\n \n   // Reads a single varint64.\n-  absl::Status ReadVarint64(uint64* result);\n+  absl::Status ReadVarint64(uint64_t* result);\n \n   // Like ReadNBytes() without returning the bytes read.\n   absl::Status SkipNBytes(int64_t bytes_to_skip);\n@@ -95,10 +95,10 @@ class InputBuffer {\n   absl::Status FillBuffer();\n \n   // Internal slow-path routine used by ReadVarint32().\n-  absl::Status ReadVarint32Fallback(uint32* result);\n+  absl::Status ReadVarint32Fallback(uint32_t* result);\n \n   // Internal slow-path routine used by ReadVarint64().\n-  absl::Status ReadVarint64Fallback(uint64* result);\n+  absl::Status ReadVarint64Fallback(uint64_t* result);\n \n   // Helper method for reading a varint which can span at max `max_bytes`.\n   // If the varint is longer, a DataLoss error status is returned.\n@@ -134,7 +134,7 @@ extern template Status InputBuffer::ReadLine<std::string>(std::string* result);\n extern template Status InputBuffer::ReadLine<tstring>(tstring* result);\n \n // Inlined for performance.\n-inline absl::Status InputBuffer::ReadVarint32(uint32* result) {\n+inline absl::Status InputBuffer::ReadVarint32(uint32_t* result) {\n   if (pos_ + core::kMaxVarint32Bytes <= limit_) {\n     // Fast path: directly parse from buffered data.\n     // Reads strictly from the range [pos_, limit_).\n@@ -149,7 +149,7 @@ inline absl::Status InputBuffer::ReadVarint32(uint32* result) {\n }\n \n // Inlined for performance.\n-inline absl::Status InputBuffer::ReadVarint64(uint64* result) {\n+inline absl::Status InputBuffer::ReadVarint64(uint64_t* result) {\n   if (pos_ + core::kMaxVarint64Bytes <= limit_) {\n     // Fast path: directly parse from buffered data.\n     // Reads strictly from the range [pos_, limit_)."
        },
        {
            "sha": "682740aca7bf0addeadc44d192ad7488996a20c9",
            "filename": "third_party/xla/xla/tsl/lib/io/inputbuffer_test.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 34,
            "changes": 68,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputbuffer_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -37,30 +37,30 @@ static std::vector<int> BufferSizes() {\n \n TEST(InputBuffer, ReadLine_Empty) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string line;\n+    std::string line;\n     io::InputBuffer in(file.get(), buf_size);\n     EXPECT_TRUE(absl::IsOutOfRange(in.ReadLine(&line)));\n   }\n }\n \n TEST(InputBuffer, ReadLine1) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_CHECK_OK(\n       WriteStringToFile(env, fname, \"line one\\nline two\\nline three\\n\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string line;\n+    std::string line;\n     io::InputBuffer in(file.get(), buf_size);\n     TF_CHECK_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n@@ -76,14 +76,14 @@ TEST(InputBuffer, ReadLine1) {\n \n TEST(InputBuffer, ReadLine_NoTrailingNewLine) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"line one\\nline two\\nline three\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string line;\n+    std::string line;\n     io::InputBuffer in(file.get(), buf_size);\n     TF_CHECK_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n@@ -99,15 +99,15 @@ TEST(InputBuffer, ReadLine_NoTrailingNewLine) {\n \n TEST(InputBuffer, ReadLine_EmptyLines) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_CHECK_OK(\n       WriteStringToFile(env, fname, \"line one\\n\\n\\nline two\\nline three\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string line;\n+    std::string line;\n     io::InputBuffer in(file.get(), buf_size);\n     TF_CHECK_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n@@ -127,15 +127,15 @@ TEST(InputBuffer, ReadLine_EmptyLines) {\n \n TEST(InputBuffer, ReadLine_CRLF) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname,\n                                  \"line one\\r\\n\\r\\n\\r\\nline two\\r\\nline three\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string line;\n+    std::string line;\n     io::InputBuffer in(file.get(), buf_size);\n     TF_CHECK_OK(in.ReadLine(&line));\n     EXPECT_EQ(line, \"line one\");\n@@ -155,15 +155,15 @@ TEST(InputBuffer, ReadLine_CRLF) {\n \n TEST(InputBuffer, ReadNBytes) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   // ReadNBytes(int64, string*).\n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string read;\n+    std::string read;\n     io::InputBuffer in(file.get(), buf_size);\n     EXPECT_EQ(0, in.Tell());\n     TF_CHECK_OK(in.ReadNBytes(3, &read));\n@@ -229,14 +229,14 @@ TEST(InputBuffer, ReadNBytes) {\n \n TEST(InputBuffer, SkipNBytes) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string read;\n+    std::string read;\n     io::InputBuffer in(file.get(), buf_size);\n     EXPECT_EQ(0, in.Tell());\n     TF_CHECK_OK(in.SkipNBytes(3));\n@@ -265,14 +265,14 @@ TEST(InputBuffer, SkipNBytes) {\n \n TEST(InputBuffer, Seek) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string read;\n+    std::string read;\n     io::InputBuffer in(file.get(), buf_size);\n \n     TF_CHECK_OK(in.ReadNBytes(3, &read));\n@@ -301,23 +301,23 @@ TEST(InputBuffer, Seek) {\n \n TEST(InputBuffer, ReadVarint32) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n \n   // Generates data.\n-  std::vector<uint32> data;\n-  uint32 i = 0;\n+  std::vector<uint32_t> data;\n+  uint32_t i = 0;\n   for (; i < (1U << 10); i += 1) data.push_back(i);\n   for (; i < (1U << 15); i += 5) data.push_back(i);\n   for (; i < (1U << 31); i += 132817) data.push_back(i);\n-  data.push_back(std::numeric_limits<uint32>::max());\n+  data.push_back(std::numeric_limits<uint32_t>::max());\n \n   // Writes the varints.\n   {\n     std::unique_ptr<WritableFile> file;\n     TF_CHECK_OK(env->NewWritableFile(fname, &file));\n-    string varint;\n-    for (uint32 number : data) {\n+    std::string varint;\n+    for (uint32_t number : data) {\n       varint.clear();\n       core::PutVarint32(&varint, number);\n       TF_CHECK_OK(file->Append(absl::string_view(varint)));\n@@ -328,9 +328,9 @@ TEST(InputBuffer, ReadVarint32) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n     io::InputBuffer in(file.get(), buf_size);\n-    uint32 result = 0;\n+    uint32_t result = 0;\n \n-    for (uint32 expected : data) {\n+    for (uint32_t expected : data) {\n       TF_ASSERT_OK(in.ReadVarint32(&result));\n       EXPECT_EQ(expected, result);\n     }\n@@ -340,24 +340,24 @@ TEST(InputBuffer, ReadVarint32) {\n \n TEST(InputBuffer, ReadVarint64) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n \n   // Generates data.\n-  std::vector<uint64> data;\n-  uint64 i = 0;\n+  std::vector<uint64_t> data;\n+  uint64_t i = 0;\n   for (; i < (1U << 10); i += 1) data.push_back(i);\n   for (; i < (1U << 15); i += 5) data.push_back(i);\n   for (; i < (1U << 31); i += 164817) data.push_back(i);\n   for (; i < (1ULL << 63); i += 16481797854795663UL) data.push_back(i);\n-  data.push_back(std::numeric_limits<uint64>::max());\n+  data.push_back(std::numeric_limits<uint64_t>::max());\n \n   // Writes the varints.\n   {\n     std::unique_ptr<WritableFile> file;\n     TF_CHECK_OK(env->NewWritableFile(fname, &file));\n-    string varint;\n-    for (uint64 number : data) {\n+    std::string varint;\n+    for (uint64_t number : data) {\n       varint.clear();\n       core::PutVarint64(&varint, number);\n       TF_CHECK_OK(file->Append(absl::string_view(varint)));\n@@ -368,9 +368,9 @@ TEST(InputBuffer, ReadVarint64) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n     io::InputBuffer in(file.get(), buf_size);\n-    uint64 result = 0;\n+    uint64_t result = 0;\n \n-    for (uint64 expected : data) {\n+    for (uint64_t expected : data) {\n       TF_ASSERT_OK(in.ReadVarint64(&result));\n       EXPECT_EQ(expected, result);\n     }\n@@ -380,14 +380,14 @@ TEST(InputBuffer, ReadVarint64) {\n \n TEST(InputBuffer, Hint) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   for (auto buf_size : BufferSizes()) {\n     std::unique_ptr<RandomAccessFile> file;\n     TF_CHECK_OK(env->NewRandomAccessFile(fname, &file));\n-    string read;\n+    std::string read;\n     io::InputBuffer in(file.get(), buf_size);\n \n     TF_CHECK_OK(in.ReadNBytes(3, &read));"
        },
        {
            "sha": "6ab16d4fbf103c7073d83075e341cc11cffff0d6",
            "filename": "third_party/xla/xla/tsl/lib/io/inputstream_interface_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputstream_interface_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputstream_interface_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Finputstream_interface_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -25,7 +25,7 @@ namespace {\n \n class TestStringStream : public InputStreamInterface {\n  public:\n-  explicit TestStringStream(const string& content) : content_(content) {}\n+  explicit TestStringStream(const std::string& content) : content_(content) {}\n \n   absl::Status ReadNBytes(int64_t bytes_to_read, tstring* result) override {\n     result->clear();\n@@ -45,7 +45,7 @@ class TestStringStream : public InputStreamInterface {\n   }\n \n  private:\n-  string content_;\n+  std::string content_;\n   int64_t pos_ = 0;\n };\n "
        },
        {
            "sha": "b8ee11aa2078ea6a4e749b83dc0c10f0c1189034",
            "filename": "third_party/xla/xla/tsl/lib/io/proto_encode_helper.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fproto_encode_helper.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fproto_encode_helper.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fproto_encode_helper.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -41,7 +41,7 @@ class ProtoEncodeHelper {\n   const char* data() const { return base_; }\n   size_t size() const { return p_ - base_; }\n \n-  void WriteUint64(int tag, uint64 v) {\n+  void WriteUint64(int tag, uint64_t v) {\n     Encode32(combine(tag, WIRETYPE_VARINT));\n     Encode64(v);\n   }\n@@ -54,7 +54,7 @@ class ProtoEncodeHelper {\n     Encode32(v.size());\n     EncodeBytes(v.data(), v.size());\n   }\n-  void WriteVarlengthBeginning(int tag, uint32 len) {\n+  void WriteVarlengthBeginning(int tag, uint32_t len) {\n     Encode32(combine(tag, WIRETYPE_LENGTH_DELIMITED));\n     Encode32(len);\n   }\n@@ -67,8 +67,10 @@ class ProtoEncodeHelper {\n     WIRETYPE_VARINT = 0,\n     WIRETYPE_LENGTH_DELIMITED = 2,\n   };\n-  static uint32 combine(uint32 tag, uint32 type) { return ((tag << 3) | type); }\n-  inline void Encode32(uint32 v) {\n+  static uint32_t combine(uint32_t tag, uint32_t type) {\n+    return ((tag << 3) | type);\n+  }\n+  inline void Encode32(uint32_t v) {\n     if (v < 128) {\n       // Fast path for single-byte values.  Many of the calls will use a\n       // constant value for v, so the comparison will get optimized away\n@@ -79,7 +81,7 @@ class ProtoEncodeHelper {\n       p_ = core::EncodeVarint32(p_, v);\n     }\n   }\n-  void Encode64(uint64 v) { p_ = core::EncodeVarint64(p_, v); }\n+  void Encode64(uint64_t v) { p_ = core::EncodeVarint64(p_, v); }\n   void EncodeBool(bool v) {\n     *p_ = (v ? 1 : 0);  // Equal to varint32 encoding of 0 or 1\n     p_++;"
        },
        {
            "sha": "9c2dd2f88f7fe7c0643f6daec1f62d543a9e4ecc",
            "filename": "third_party/xla/xla/tsl/lib/io/random_inputstream_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frandom_inputstream_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frandom_inputstream_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frandom_inputstream_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -25,7 +25,7 @@ namespace {\n \n TEST(RandomInputStream, ReadNBytes) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/random_inputbuffer_test\";\n+  std::string fname = testing::TmpDir() + \"/random_inputbuffer_test\";\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   std::unique_ptr<RandomAccessFile> file;\n@@ -55,7 +55,7 @@ TEST(RandomInputStream, ReadNBytes) {\n #if defined(TF_CORD_SUPPORT)\n TEST(RandomInputStream, ReadNBytesWithCords) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/random_inputbuffer_test\";\n+  std::string fname = testing::TmpDir() + \"/random_inputbuffer_test\";\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   std::unique_ptr<RandomAccessFile> file;\n@@ -87,7 +87,7 @@ TEST(RandomInputStream, ReadNBytesWithCords) {\n \n TEST(RandomInputStream, SkipNBytes) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/random_inputbuffer_test\";\n+  std::string fname = testing::TmpDir() + \"/random_inputbuffer_test\";\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   std::unique_ptr<RandomAccessFile> file;\n@@ -118,7 +118,7 @@ TEST(RandomInputStream, SkipNBytes) {\n \n TEST(RandomInputStream, Seek) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/random_inputbuffer_seek_test\";\n+  std::string fname = testing::TmpDir() + \"/random_inputbuffer_seek_test\";\n   TF_ASSERT_OK(WriteStringToFile(env, fname, \"0123456789\"));\n \n   std::unique_ptr<RandomAccessFile> file;"
        },
        {
            "sha": "0ec1d146226a89130e8b7b99a153b436a0e4ee98",
            "filename": "third_party/xla/xla/tsl/lib/io/record_reader.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -29,7 +29,7 @@ namespace tsl {\n namespace io {\n \n RecordReaderOptions RecordReaderOptions::CreateRecordReaderOptions(\n-    const string& compression_type) {\n+    const std::string& compression_type) {\n   RecordReaderOptions options;\n \n #if defined(IS_SLIM_BUILD)\n@@ -86,7 +86,7 @@ RecordReader::RecordReader(RandomAccessFile* file,\n }\n \n namespace {\n-inline const char* GetChecksumErrorSuffix(uint64 offset) {\n+inline const char* GetChecksumErrorSuffix(uint64_t offset) {\n   if (offset == 0) {\n     return \" (Is this even a TFRecord file?)\";\n   }\n@@ -101,14 +101,14 @@ inline const char* GetChecksumErrorSuffix(uint64 offset) {\n // and is used only in error messages. For failures at offset 0,\n // a reminder about the file format is added, because TFRecord files\n // contain no explicit format marker.\n-absl::Status RecordReader::ReadChecksummed(uint64 offset, size_t n,\n+absl::Status RecordReader::ReadChecksummed(uint64_t offset, size_t n,\n                                            tstring* result) {\n-  if (n >= SIZE_MAX - sizeof(uint32)) {\n+  if (n >= SIZE_MAX - sizeof(uint32_t)) {\n     return errors::DataLoss(\"record size too large\",\n                             GetChecksumErrorSuffix(offset));\n   }\n \n-  const size_t expected = n + sizeof(uint32);\n+  const size_t expected = n + sizeof(uint32_t);\n   TF_RETURN_IF_ERROR(input_stream_->ReadNBytes(expected, result));\n \n   if (result->size() != expected) {\n@@ -120,7 +120,7 @@ absl::Status RecordReader::ReadChecksummed(uint64 offset, size_t n,\n     }\n   }\n \n-  const uint32 masked_crc = core::DecodeFixed32(result->data() + n);\n+  const uint32_t masked_crc = core::DecodeFixed32(result->data() + n);\n   if (crc32c::Unmask(masked_crc) != crc32c::Value(result->data(), n)) {\n     return errors::DataLoss(\"corrupted record at \", offset,\n                             GetChecksumErrorSuffix(offset));\n@@ -145,11 +145,11 @@ absl::Status RecordReader::GetMetadata(Metadata* md) {\n     // Within the loop, we always increment offset positively, so this\n     // loop should be guaranteed to either return after reaching EOF\n     // or encountering an error.\n-    uint64 offset = 0;\n+    uint64_t offset = 0;\n     tstring record;\n     while (true) {\n       // Read header, containing size of data.\n-      absl::Status s = ReadChecksummed(offset, sizeof(uint64), &record);\n+      absl::Status s = ReadChecksummed(offset, sizeof(uint64_t), &record);\n       if (!s.ok()) {\n         if (absl::IsOutOfRange(s)) {\n           // We should reach out of range when the record file is complete.\n@@ -159,7 +159,7 @@ absl::Status RecordReader::GetMetadata(Metadata* md) {\n       }\n \n       // Read the length of the data.\n-      const uint64 length = core::DecodeFixed64(record.data());\n+      const uint64_t length = core::DecodeFixed64(record.data());\n \n       // Skip reading the actual data since we just want the number\n       // of records and the size of the data.\n@@ -182,7 +182,7 @@ absl::Status RecordReader::GetMetadata(Metadata* md) {\n   return absl::OkStatus();\n }\n \n-absl::Status RecordReader::PositionInputStream(uint64 offset) {\n+absl::Status RecordReader::PositionInputStream(uint64_t offset) {\n   int64_t curr_pos = input_stream_->Tell();\n   int64_t desired_pos = static_cast<int64_t>(offset);\n   if (curr_pos > desired_pos || curr_pos < 0 /* EOF */ ||\n@@ -197,16 +197,16 @@ absl::Status RecordReader::PositionInputStream(uint64 offset) {\n   return absl::OkStatus();\n }\n \n-absl::Status RecordReader::ReadRecord(uint64* offset, tstring* record) {\n+absl::Status RecordReader::ReadRecord(uint64_t* offset, tstring* record) {\n   TF_RETURN_IF_ERROR(PositionInputStream(*offset));\n \n   // Read header data.\n-  absl::Status s = ReadChecksummed(*offset, sizeof(uint64), record);\n+  absl::Status s = ReadChecksummed(*offset, sizeof(uint64_t), record);\n   if (!s.ok()) {\n     last_read_failed_ = true;\n     return s;\n   }\n-  const uint64 length = core::DecodeFixed64(record->data());\n+  const uint64_t length = core::DecodeFixed64(record->data());\n \n   // Read data\n   s = ReadChecksummed(*offset + kHeaderSize, length, record);\n@@ -224,20 +224,20 @@ absl::Status RecordReader::ReadRecord(uint64* offset, tstring* record) {\n   return absl::OkStatus();\n }\n \n-absl::Status RecordReader::SkipRecords(uint64* offset, int num_to_skip,\n+absl::Status RecordReader::SkipRecords(uint64_t* offset, int num_to_skip,\n                                        int* num_skipped) {\n   TF_RETURN_IF_ERROR(PositionInputStream(*offset));\n \n   absl::Status s;\n   tstring record;\n   *num_skipped = 0;\n   for (int i = 0; i < num_to_skip; ++i) {\n-    s = ReadChecksummed(*offset, sizeof(uint64), &record);\n+    s = ReadChecksummed(*offset, sizeof(uint64_t), &record);\n     if (!s.ok()) {\n       last_read_failed_ = true;\n       return s;\n     }\n-    const uint64 length = core::DecodeFixed64(record.data());\n+    const uint64_t length = core::DecodeFixed64(record.data());\n \n     // Skip data\n     s = input_stream_->SkipNBytes(length + kFooterSize);"
        },
        {
            "sha": "7dce369860fc1d833c3f549f5269f836b9e790cb",
            "filename": "third_party/xla/xla/tsl/lib/io/record_reader.h",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -47,7 +47,7 @@ struct RecordReaderOptions {\n   int64_t buffer_size = 0;\n \n   static RecordReaderOptions CreateRecordReaderOptions(\n-      const string& compression_type);\n+      const std::string& compression_type);\n \n #if !defined(IS_SLIM_BUILD)\n   // Options specific to compression.\n@@ -68,8 +68,8 @@ class RecordReader {\n   //  uint32    masked crc of length\n   //  byte      data[length]\n   //  uint32    masked crc of data\n-  static constexpr size_t kHeaderSize = sizeof(uint64) + sizeof(uint32);\n-  static constexpr size_t kFooterSize = sizeof(uint32);\n+  static constexpr size_t kHeaderSize = sizeof(uint64_t) + sizeof(uint32_t);\n+  static constexpr size_t kFooterSize = sizeof(uint32_t);\n \n   // Statistics (sizes are in units of bytes)\n   struct Stats {\n@@ -94,14 +94,14 @@ class RecordReader {\n   // Read the record at \"*offset\" into *record and update *offset to\n   // point to the offset of the next record.  Returns OK on success,\n   // OUT_OF_RANGE for end of file, or something else for an error.\n-  absl::Status ReadRecord(uint64* offset, tstring* record);\n+  absl::Status ReadRecord(uint64_t* offset, tstring* record);\n \n   // Skip num_to_skip record starting at \"*offset\" and update *offset\n   // to point to the offset of the next num_to_skip + 1 record.\n   // Return OK on success, OUT_OF_RANGE for end of file, or something\n   // else for an error. \"*num_skipped\" records the number of records that\n   // are actually skipped. It should be equal to num_to_skip on success.\n-  absl::Status SkipRecords(uint64* offset, int num_to_skip, int* num_skipped);\n+  absl::Status SkipRecords(uint64_t* offset, int num_to_skip, int* num_skipped);\n \n   // Return the metadata of the Record file.\n   //\n@@ -115,8 +115,8 @@ class RecordReader {\n   absl::Status GetMetadata(Metadata* md);\n \n  private:\n-  absl::Status ReadChecksummed(uint64 offset, size_t n, tstring* result);\n-  absl::Status PositionInputStream(uint64 offset);\n+  absl::Status ReadChecksummed(uint64_t offset, size_t n, tstring* result);\n+  absl::Status PositionInputStream(uint64_t offset);\n \n   RecordReaderOptions options_;\n   std::unique_ptr<InputStreamInterface> input_stream_;\n@@ -156,11 +156,11 @@ class SequentialRecordReader {\n   }\n \n   // Return the current offset in the file.\n-  uint64 TellOffset() { return offset_; }\n+  uint64_t TellOffset() { return offset_; }\n \n   // Seek to this offset within the file and set this offset as the current\n   // offset. Trying to seek backward will throw error.\n-  absl::Status SeekOffset(uint64 offset) {\n+  absl::Status SeekOffset(uint64_t offset) {\n     if (offset < offset_)\n       return errors::InvalidArgument(\n           \"Trying to seek offset: \", offset,\n@@ -171,7 +171,7 @@ class SequentialRecordReader {\n \n  private:\n   RecordReader underlying_;\n-  uint64 offset_ = 0;\n+  uint64_t offset_ = 0;\n };\n \n }  // namespace io"
        },
        {
            "sha": "ad3b865411725c415e937e10b6074286548100b9",
            "filename": "third_party/xla/xla/tsl/lib/io/record_reader_writer_test.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 20,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader_writer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader_writer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_reader_writer_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -48,23 +48,23 @@ io::RecordReaderOptions GetMatchingReaderOptions(\n   return io::RecordReaderOptions::CreateRecordReaderOptions(\"\");\n }\n \n-uint64 GetFileSize(const string& fname) {\n+uint64_t GetFileSize(const std::string& fname) {\n   Env* env = Env::Default();\n-  uint64 fsize;\n+  uint64_t fsize;\n   TF_CHECK_OK(env->GetFileSize(fname, &fsize));\n   return fsize;\n }\n \n void VerifyFlush(const io::RecordWriterOptions& options) {\n-  std::vector<string> records = {\n+  std::vector<std::string> records = {\n       \"abcdefghijklmnopqrstuvwxyz\",\n       \"ZYXWVUTSRQPONMLKJIHGFEDCBA0123456789!@#$%^&*()\",\n       \"G5SyohOL9UmXofSOOwWDrv9hoLLMYPJbG9r38t3uBRcHxHj2PdKcPDuZmKW62RIY\",\n       \"aaaaaaaaaaaaaaaaaaaaaaaaaa\",\n   };\n \n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/record_reader_writer_flush_test\";\n+  std::string fname = testing::TmpDir() + \"/record_reader_writer_flush_test\";\n \n   std::unique_ptr<WritableFile> file;\n   TF_CHECK_OK(env->NewWritableFile(fname, &file));\n@@ -77,19 +77,19 @@ void VerifyFlush(const io::RecordWriterOptions& options) {\n \n   EXPECT_EQ(GetFileSize(fname), 0);\n   for (size_t i = 0; i < records.size(); i++) {\n-    uint64 start_size = GetFileSize(fname);\n+    uint64_t start_size = GetFileSize(fname);\n \n     // Write a new record.\n     TF_EXPECT_OK(writer.WriteRecord(records[i]));\n     TF_CHECK_OK(writer.Flush());\n     TF_CHECK_OK(file->Flush());\n \n     // Verify that file size has changed after file flush.\n-    uint64 new_size = GetFileSize(fname);\n+    uint64_t new_size = GetFileSize(fname);\n     EXPECT_GT(new_size, start_size);\n \n     // Verify that file has all records written so far and no more.\n-    uint64 offset = 0;\n+    uint64_t offset = 0;\n     tstring record;\n     for (size_t j = 0; j <= i; j++) {\n       // Check that j'th record is written correctly.\n@@ -123,7 +123,7 @@ TEST(RecordReaderWriterTest, TestZlibSyncFlush) {\n \n TEST(RecordReaderWriterTest, TestBasics) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/record_reader_writer_test\";\n+  std::string fname = testing::TmpDir() + \"/record_reader_writer_test\";\n \n   for (auto buf_size : BufferSizes()) {\n     {\n@@ -145,7 +145,7 @@ TEST(RecordReaderWriterTest, TestBasics) {\n       io::RecordReaderOptions options;\n       options.zlib_options.input_buffer_size = buf_size;\n       io::RecordReader reader(read_file.get(), options);\n-      uint64 offset = 0;\n+      uint64_t offset = 0;\n       tstring record;\n       TF_CHECK_OK(reader.ReadRecord(&offset, &record));\n       EXPECT_EQ(\"abc\", record);\n@@ -164,7 +164,8 @@ TEST(RecordReaderWriterTest, TestBasics) {\n \n TEST(RecordReaderWriterTest, TestSkipBasic) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/record_reader_writer_skip_basic_test\";\n+  std::string fname =\n+      testing::TmpDir() + \"/record_reader_writer_skip_basic_test\";\n \n   for (auto buf_size : BufferSizes()) {\n     {\n@@ -187,7 +188,7 @@ TEST(RecordReaderWriterTest, TestSkipBasic) {\n       io::RecordReaderOptions options;\n       options.zlib_options.input_buffer_size = buf_size;\n       io::RecordReader reader(read_file.get(), options);\n-      uint64 offset = 0;\n+      uint64_t offset = 0;\n       int num_skipped;\n       tstring record;\n       TF_CHECK_OK(reader.SkipRecords(&offset, 2, &num_skipped));\n@@ -200,7 +201,7 @@ TEST(RecordReaderWriterTest, TestSkipBasic) {\n \n TEST(RecordReaderWriterTest, TestSkipOutOfRange) {\n   Env* env = Env::Default();\n-  string fname =\n+  std::string fname =\n       testing::TmpDir() + \"/record_reader_writer_skip_out_of_range_test\";\n \n   for (auto buf_size : BufferSizes()) {\n@@ -223,7 +224,7 @@ TEST(RecordReaderWriterTest, TestSkipOutOfRange) {\n       io::RecordReaderOptions options;\n       options.zlib_options.input_buffer_size = buf_size;\n       io::RecordReader reader(read_file.get(), options);\n-      uint64 offset = 0;\n+      uint64_t offset = 0;\n       int num_skipped;\n       tstring record;\n       absl::Status s = reader.SkipRecords(&offset, 3, &num_skipped);\n@@ -235,7 +236,7 @@ TEST(RecordReaderWriterTest, TestSkipOutOfRange) {\n \n TEST(RecordReaderWriterTest, TestMalformedInput) {\n   Env* env = Env::Default();\n-  string fname =\n+  std::string fname =\n       testing::TmpDir() + \"/record_reader_writer_malformed_input_test\";\n \n   {\n@@ -253,7 +254,7 @@ TEST(RecordReaderWriterTest, TestMalformedInput) {\n     io::RecordReader reader(read_file.get());\n     tstring record;\n     // At offset 0, the error message reminds of the file type.\n-    uint64 offset = 0;\n+    uint64_t offset = 0;\n     absl::Status s = reader.ReadRecord(&offset, &record);\n     EXPECT_EQ(error::DATA_LOSS, s.code());\n     EXPECT_EQ(\"corrupted record at 0 (Is this even a TFRecord file?)\",\n@@ -269,7 +270,7 @@ TEST(RecordReaderWriterTest, TestMalformedInput) {\n \n TEST(RecordReaderWriterTest, TestSnappy) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/record_reader_writer_snappy_test\";\n+  std::string fname = testing::TmpDir() + \"/record_reader_writer_snappy_test\";\n \n   for (auto buf_size : BufferSizes()) {\n     // Snappy compression needs output buffer size > 1.\n@@ -295,7 +296,7 @@ TEST(RecordReaderWriterTest, TestSnappy) {\n       options.compression_type = io::RecordReaderOptions::SNAPPY_COMPRESSION;\n       options.zlib_options.input_buffer_size = buf_size;\n       io::RecordReader reader(read_file.get(), options);\n-      uint64 offset = 0;\n+      uint64_t offset = 0;\n       tstring record;\n       TF_CHECK_OK(reader.ReadRecord(&offset, &record));\n       EXPECT_EQ(\"abc\", record);\n@@ -307,7 +308,7 @@ TEST(RecordReaderWriterTest, TestSnappy) {\n \n TEST(RecordReaderWriterTest, TestZlib) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/record_reader_writer_zlib_test\";\n+  std::string fname = testing::TmpDir() + \"/record_reader_writer_zlib_test\";\n \n   for (auto buf_size : BufferSizes()) {\n     // Zlib compression needs output buffer size > 1.\n@@ -333,7 +334,7 @@ TEST(RecordReaderWriterTest, TestZlib) {\n       options.compression_type = io::RecordReaderOptions::ZLIB_COMPRESSION;\n       options.zlib_options.input_buffer_size = buf_size;\n       io::RecordReader reader(read_file.get(), options);\n-      uint64 offset = 0;\n+      uint64_t offset = 0;\n       tstring record;\n       TF_CHECK_OK(reader.ReadRecord(&offset, &record));\n       EXPECT_EQ(\"abc\", record);\n@@ -345,7 +346,8 @@ TEST(RecordReaderWriterTest, TestZlib) {\n \n TEST(RecordReaderWriterTest, TestUseAfterClose) {\n   Env* env = Env::Default();\n-  string fname = testing::TmpDir() + \"/record_reader_writer_flush_close_test\";\n+  std::string fname =\n+      testing::TmpDir() + \"/record_reader_writer_flush_close_test\";\n \n   {\n     std::unique_ptr<WritableFile> file;"
        },
        {
            "sha": "0bc224a195cf84ae6f323dba1ea807aadf39019c",
            "filename": "third_party/xla/xla/tsl/lib/io/record_writer.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_writer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_writer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_writer.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -33,7 +33,7 @@ bool IsSnappyCompressed(const RecordWriterOptions& options) {\n }  // namespace\n \n RecordWriterOptions RecordWriterOptions::CreateRecordWriterOptions(\n-    const string& compression_type) {\n+    const std::string& compression_type) {\n   RecordWriterOptions options;\n #if defined(IS_SLIM_BUILD)\n   if (compression_type != compression::kNone) {"
        },
        {
            "sha": "f48fa58b0bc82db79ab274426f593a1d5e6b1f25",
            "filename": "third_party/xla/xla/tsl/lib/io/record_writer.h",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_writer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_writer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecord_writer.h?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -46,7 +46,7 @@ struct RecordWriterOptions {\n   CompressionType compression_type = NONE;\n \n   static RecordWriterOptions CreateRecordWriterOptions(\n-      const string& compression_type);\n+      const std::string& compression_type);\n \n #if !defined(IS_SLIM_BUILD)\n   // Options specific to compression.\n@@ -62,8 +62,8 @@ class RecordWriter {\n   //  uint32    masked crc of length\n   //  byte      data[length]\n   //  uint32    masked crc of data\n-  static constexpr size_t kHeaderSize = sizeof(uint64) + sizeof(uint32);\n-  static constexpr size_t kFooterSize = sizeof(uint32);\n+  static constexpr size_t kHeaderSize = sizeof(uint64_t) + sizeof(uint32_t);\n+  static constexpr size_t kFooterSize = sizeof(uint32_t);\n \n   // Create a writer that will append data to \"*dest\".\n   // \"*dest\" must be initially empty.\n@@ -114,12 +114,12 @@ class RecordWriter {\n   WritableFile* dest_;\n   RecordWriterOptions options_;\n \n-  inline static uint32 MaskedCrc(const char* data, size_t n) {\n+  inline static uint32_t MaskedCrc(const char* data, size_t n) {\n     return crc32c::Mask(crc32c::Value(data, n));\n   }\n \n #if defined(TF_CORD_SUPPORT)\n-  inline static uint32 MaskedCrc(const absl::Cord& data) {\n+  inline static uint32_t MaskedCrc(const absl::Cord& data) {\n     return crc32c::Mask(crc32c::Value(data));\n   }\n #endif\n@@ -130,8 +130,8 @@ class RecordWriter {\n \n void RecordWriter::PopulateHeader(char* header, const char* data, size_t n) {\n   core::EncodeFixed64(header + 0, n);\n-  core::EncodeFixed32(header + sizeof(uint64),\n-                      MaskedCrc(header, sizeof(uint64)));\n+  core::EncodeFixed32(header + sizeof(uint64_t),\n+                      MaskedCrc(header, sizeof(uint64_t)));\n }\n \n void RecordWriter::PopulateFooter(char* footer, const char* data, size_t n) {\n@@ -141,8 +141,8 @@ void RecordWriter::PopulateFooter(char* footer, const char* data, size_t n) {\n #if defined(TF_CORD_SUPPORT)\n void RecordWriter::PopulateHeader(char* header, const absl::Cord& data) {\n   core::EncodeFixed64(header + 0, data.size());\n-  core::EncodeFixed32(header + sizeof(uint64),\n-                      MaskedCrc(header, sizeof(uint64)));\n+  core::EncodeFixed32(header + sizeof(uint64_t),\n+                      MaskedCrc(header, sizeof(uint64_t)));\n }\n \n void RecordWriter::PopulateFooter(char* footer, const absl::Cord& data) {"
        },
        {
            "sha": "138b937d6f0fefa344edd1fd5cb238b07a5b2b97",
            "filename": "third_party/xla/xla/tsl/lib/io/recordio_test.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecordio_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/263b4b200fd05a803dad21cde875044baf6ad74e/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecordio_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Frecordio_test.cc?ref=263b4b200fd05a803dad21cde875044baf6ad74e",
            "patch": "@@ -30,8 +30,8 @@ namespace {\n \n // Construct a string of the specified length made out of the supplied\n // partial string.\n-string BigString(const string& partial_string, size_t n) {\n-  string result;\n+std::string BigString(const std::string& partial_string, size_t n) {\n+  std::string result;\n   while (result.size() < n) {\n     result.append(partial_string);\n   }\n@@ -40,20 +40,20 @@ string BigString(const string& partial_string, size_t n) {\n }\n \n // Construct a string from a number\n-string NumberString(int n) {\n+std::string NumberString(int n) {\n   char buf[50];\n   snprintf(buf, sizeof(buf), \"%d.\", n);\n-  return string(buf);\n+  return std::string(buf);\n }\n \n // Return a skewed potentially long string\n-string RandomSkewedString(int i, random::SimplePhilox* rnd) {\n+std::string RandomSkewedString(int i, random::SimplePhilox* rnd) {\n   return BigString(NumberString(i), rnd->Skewed(17));\n }\n \n class StringDest : public WritableFile {\n  public:\n-  explicit StringDest(string* contents) : contents_(contents) {}\n+  explicit StringDest(std::string* contents) : contents_(contents) {}\n \n   absl::Status Close() override { return absl::OkStatus(); }\n   absl::Status Flush() override { return absl::OkStatus(); }\n@@ -74,15 +74,15 @@ class StringDest : public WritableFile {\n   }\n \n  private:\n-  string* contents_;\n+  std::string* contents_;\n };\n \n class StringSource : public RandomAccessFile {\n  public:\n-  explicit StringSource(string* contents)\n+  explicit StringSource(std::string* contents)\n       : contents_(contents), force_error_(false) {}\n \n-  absl::Status Read(uint64 offset, size_t n, absl::string_view* result,\n+  absl::Status Read(uint64_t offset, size_t n, absl::string_view* result,\n                     char* scratch) const override {\n     if (force_error_) {\n       force_error_ = false;\n@@ -103,17 +103,17 @@ class StringSource : public RandomAccessFile {\n   void force_error() { force_error_ = true; }\n \n  private:\n-  string* contents_;\n+  std::string* contents_;\n   mutable bool force_error_;\n };\n \n class RecordioTest : public ::testing::Test {\n  private:\n-  string contents_;\n+  std::string contents_;\n   StringDest dest_;\n   StringSource source_;\n   bool reading_;\n-  uint64 readpos_;\n+  uint64_t readpos_;\n   RecordWriter* writer_;\n   RecordReader* reader_;\n \n@@ -131,7 +131,7 @@ class RecordioTest : public ::testing::Test {\n     delete reader_;\n   }\n \n-  void Write(const string& msg) {\n+  void Write(const std::string& msg) {\n     ASSERT_TRUE(!reading_) << \"Write() after starting to read\";\n     TF_ASSERT_OK(writer_->WriteRecord(absl::string_view(msg)));\n   }\n@@ -145,7 +145,7 @@ class RecordioTest : public ::testing::Test {\n \n   size_t WrittenBytes() const { return contents_.size(); }\n \n-  string Read() {\n+  std::string Read() {\n     if (!reading_) {\n       reading_ = true;\n     }\n@@ -182,7 +182,7 @@ class RecordioTest : public ::testing::Test {\n     Write(\"bar\");\n     Write(BigString(\"x\", 10000));\n     reading_ = true;\n-    uint64 offset = WrittenBytes() + offset_past_end;\n+    uint64_t offset = WrittenBytes() + offset_past_end;\n     tstring record;\n     absl::Status s = reader_->ReadRecord(&offset, &record);\n     ASSERT_TRUE(absl::IsOutOfRange(s)) << s;\n@@ -250,7 +250,7 @@ TEST_F(RecordioTest, RandomRead) {\n \n void TestNonSequentialReads(const RecordWriterOptions& writer_options,\n                             const RecordReaderOptions& reader_options) {\n-  string contents;\n+  std::string contents;\n   StringDest dst(&contents);\n   RecordWriter writer(&dst, writer_options);\n   for (int i = 0; i < 10; ++i) {\n@@ -263,8 +263,8 @@ void TestNonSequentialReads(const RecordWriterOptions& writer_options,\n \n   tstring record;\n   // First read sequentially to fill in the offsets table.\n-  uint64 offsets[10] = {0};\n-  uint64 offset = 0;\n+  uint64_t offsets[10] = {0};\n+  uint64_t offset = 0;\n   for (int i = 0; i < 10; ++i) {\n     offsets[i] = offset;\n     TF_ASSERT_OK(reader.ReadRecord(&offset, &record)) << i;\n@@ -306,15 +306,15 @@ void AssertHasSubstr(absl::string_view s, absl::string_view expected) {\n \n void TestReadError(const RecordWriterOptions& writer_options,\n                    const RecordReaderOptions& reader_options) {\n-  const string wrote = BigString(\"well hello there!\", 100);\n-  string contents;\n+  const std::string wrote = BigString(\"well hello there!\", 100);\n+  std::string contents;\n   StringDest dst(&contents);\n   TF_ASSERT_OK(RecordWriter(&dst, writer_options).WriteRecord(wrote));\n \n   StringSource file(&contents);\n   RecordReader reader(&file, reader_options);\n \n-  uint64 offset = 0;\n+  uint64_t offset = 0;\n   tstring read;\n   file.force_error();\n   absl::Status status = reader.ReadRecord(&offset, &read);"
        }
    ],
    "stats": {
        "total": 444,
        "additions": 224,
        "deletions": 220
    }
}