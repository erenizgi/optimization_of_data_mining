{
    "author": "seantalts",
    "message": "[XLA:CPU] Refactor: intrinsic::Type into its own library, pull out naming functions.\n\nPiperOrigin-RevId: 821815511",
    "sha": "8d940b9cc754805c706ccace290373c7feb87481",
    "files": [
        {
            "sha": "36e40e2d539e8052a807782234ba501cefa3211e",
            "filename": "third_party/xla/xla/codegen/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -221,6 +221,7 @@ cc_library(\n         \"//xla/codegen/intrinsic:rsqrt\",\n         \"//xla/codegen/intrinsic:string_interner\",\n         \"//xla/codegen/intrinsic:tanh\",\n+        \"//xla/codegen/intrinsic:type\",\n         \"//xla/codegen/intrinsic:vec_name_mangler\",\n         \"//xla/service/llvm_ir:llvm_util\",\n         \"@com_google_absl//absl/container:flat_hash_map\","
        },
        {
            "sha": "d107107ceae8dc9f08b3f8bbbf1c6855a65432f8",
            "filename": "third_party/xla/xla/codegen/intrinsic/BUILD",
            "status": "modified",
            "additions": 39,
            "deletions": 10,
            "changes": 49,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2FBUILD?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -23,25 +23,17 @@ package_group(\n \n cc_library(\n     name = \"intrinsic\",\n-    srcs = [\"intrinsic.cc\"],\n     hdrs = [\"intrinsic.h\"],\n     deps = [\n-        \"//xla:shape_util\",\n-        \"//xla:util\",\n+        \":type\",\n+        \":vec_name_mangler\",\n         \"//xla:xla_data_proto_cc\",\n-        \"//xla/mlir/utils:type_util\",\n-        \"//xla/service/llvm_ir:llvm_util\",\n-        \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n-        \"@llvm-project//llvm:Support\",\n         \"@llvm-project//llvm:Target\",\n         \"@llvm-project//llvm:ir_headers\",\n         \"@llvm-project//mlir:FuncDialect\",\n         \"@llvm-project//mlir:IR\",\n-        \"@llvm-project//mlir:Support\",\n     ],\n )\n \n@@ -192,8 +184,12 @@ cc_library(\n     name = \"vec_name_mangler\",\n     hdrs = [\"vec_name_mangler.h\"],\n     deps = [\n+        \":type\",\n+        \"@com_google_absl//absl/algorithm:container\",\n+        \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n     ],\n )\n \n@@ -434,3 +430,36 @@ xla_cc_test(\n         \"@llvm-project//llvm:ir_headers\",\n     ],\n )\n+\n+cc_library(\n+    name = \"type\",\n+    srcs = [\"type.cc\"],\n+    hdrs = [\"type.h\"],\n+    deps = [\n+        \"//xla:shape_util\",\n+        \"//xla:util\",\n+        \"//xla:xla_data_proto_cc\",\n+        \"//xla/mlir/utils:type_util\",\n+        \"//xla/service/llvm_ir:llvm_util\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//llvm:ir_headers\",\n+        \"@llvm-project//mlir:IR\",\n+        \"@llvm-project//mlir:Support\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"type_test\",\n+    srcs = [\"type_test.cc\"],\n+    deps = [\n+        \":type\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//llvm:ir_headers\",\n+    ],\n+)"
        },
        {
            "sha": "e771f3a1be4214f289c206ddd7bf2e13d306e362",
            "filename": "third_party/xla/xla/codegen/intrinsic/intrinsic.h",
            "status": "modified",
            "additions": 4,
            "deletions": 71,
            "changes": 75,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fintrinsic.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fintrinsic.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fintrinsic.h?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -16,18 +16,12 @@ limitations under the License.\n #ifndef XLA_CODEGEN_INTRINSIC_INTRINSIC_H_\n #define XLA_CODEGEN_INTRINSIC_INTRINSIC_H_\n \n-#include <cstddef>\n #include <cstdint>\n-#include <optional>\n #include <string>\n-#include <variant>\n #include <vector>\n \n-#include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/match.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"llvm/IR/Function.h\"\n #include \"llvm/IR/Module.h\"\n@@ -36,69 +30,12 @@ limitations under the License.\n #include \"mlir/IR/Builders.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/BuiltinTypes.h\"\n-#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/codegen/intrinsic/type.h\"\n+#include \"xla/codegen/intrinsic/vec_name_mangler.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla::codegen::intrinsics {\n \n-// A scalar argument or result.\n-struct Scalar {\n-  PrimitiveType type;\n-};\n-\n-// A vector argument or result.\n-struct Vec {\n-  PrimitiveType type;\n-  size_t width;\n-};\n-\n-class Type : public std::variant<Scalar, Vec> {\n- public:\n-  using std::variant<Scalar, Vec>::variant;\n-  Type(PrimitiveType type, std::optional<size_t> vector_width);\n-\n-  std::string name() const;\n-  bool is_scalar() const;\n-  bool is_vector() const;\n-  PrimitiveType element_type() const;\n-  std::optional<size_t> vector_width() const;\n-  llvm::Type* to_ir_type(llvm::LLVMContext& context) const;\n-  mlir::Type to_ir_type(mlir::MLIRContext& context) const;\n-\n-  template <typename Sink>\n-  friend void AbslStringify(Sink& sink, const Type& type) {\n-    absl::Format(&sink, \"%s\", type.name());\n-  }\n-\n-  // Shortened builders for the scalar and vector types defined above.\n-  static constexpr Type S(PrimitiveType type) { return Scalar{type}; }\n-  static constexpr Type V(PrimitiveType type, size_t width) {\n-    return Vec{type, width};\n-  }\n-\n-  // Verifies that the two types have the same width.\n-  static absl::Status VerifySameWidth(const Type& a, const Type& b);\n-\n-  // Verifies that the two types have the same width and element type.\n-  static absl::Status VerifySameWidthAndElementType(const Type& a,\n-                                                    const Type& b);\n-\n-  // Returns the LLVM IR type for the given intrinsic type.\n-  static llvm::Type* TypeToIrType(Type type, llvm::LLVMContext& context);\n-\n-  // Returns the MLIR type for the given intrinsic type.\n-  static mlir::Type TypeToIrType(Type type, mlir::MLIRContext& context);\n-\n-  // Returns the intrinsic type for the given MLIR type.\n-  static Type TypeFromIrType(mlir::Type type);\n-\n-  // Returns the intrinsic type for the given LLVM type.\n-  static Type TypeFromIrType(llvm::Type* type);\n-\n-  // Returns the intrinsic type for the given type name, e.g. v4f32.\n-  static Type FromName(absl::string_view name);\n-};\n-\n enum class DeviceType {\n   kAmdCpu,\n   kIntelCpu,\n@@ -158,12 +95,8 @@ class Intrinsic {\n \n   template <typename... Types>\n   static std::string Name(Types... args) {\n-    std::vector<std::string> arg_names = {args.name()...};\n-    if (Derived::kLastArgIsReturnType) {\n-      arg_names.insert(--arg_names.end(), \"to\");\n-    }\n-    return absl::StrCat(\"xla.\", Derived::kName, \".\",\n-                        absl::StrJoin(arg_names, \".\"));\n+    return ::xla::codegen::intrinsic::FunctionName(\n+        Derived::kLastArgIsReturnType, {args...}, Derived::kName);\n   }\n \n   template <typename... Args>"
        },
        {
            "sha": "85a2870252b640f1c4adcac9fd3cd3af9c60f784",
            "filename": "third_party/xla/xla/codegen/intrinsic/type.cc",
            "status": "renamed",
            "additions": 25,
            "deletions": 31,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype.cc?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -13,7 +13,7 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include \"xla/codegen/intrinsic/intrinsic.h\"\n+#include \"xla/codegen/intrinsic/type.h\"\n \n #include <cctype>\n #include <cstddef>\n@@ -22,7 +22,6 @@ limitations under the License.\n #include <variant>\n \n #include \"absl/log/check.h\"\n-#include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n@@ -33,14 +32,14 @@ limitations under the License.\n #include \"llvm/Support/Casting.h\"\n #include \"mlir/IR/Builders.h\"\n #include \"mlir/IR/MLIRContext.h\"\n+#include \"mlir/IR/Types.h\"\n #include \"mlir/Support/LLVM.h\"\n #include \"xla/mlir/utils/type_util.h\"\n #include \"xla/primitive_util.h\"\n #include \"xla/service/llvm_ir/llvm_util.h\"\n #include \"xla/util.h\"\n-#include \"xla/xla_data.pb.h\"\n \n-namespace xla::codegen {\n+namespace xla::codegen::intrinsics {\n \n namespace {\n std::string LowercaseLLVMPrimitiveTypeName(PrimitiveType type) {\n@@ -69,8 +68,6 @@ PrimitiveType FromLowercaseLLVMTypeName(absl::string_view in) {\n }\n }  // namespace\n \n-namespace intrinsics {\n-\n Type::Type(PrimitiveType type, std::optional<size_t> vector_width) {\n   if (vector_width) {\n     emplace<1>(Vec{type, *vector_width});\n@@ -80,6 +77,27 @@ Type::Type(PrimitiveType type, std::optional<size_t> vector_width) {\n }\n \n namespace {\n+template <typename ScalarFn, typename VectorFn>\n+static absl::Status VerifyTypes(ScalarFn scalar, VectorFn vector, const Type& a,\n+                                const Type& b) {\n+  // A pair of scalar types.\n+  auto* sa = std::get_if<Scalar>(&a);\n+  auto* sb = std::get_if<Scalar>(&b);\n+  if (sa && sb) {\n+    return scalar(*sa, *sb);\n+  }\n+\n+  // A pair of vector types.\n+  auto* va = std::get_if<Vec>(&a);\n+  auto* vb = std::get_if<Vec>(&b);\n+  if (va && vb) {\n+    return vector(*va, *vb);\n+  }\n+\n+  return InvalidArgument(\"Expected types of the same kind, but got %s and %s\",\n+                         a.name(), b.name());\n+}\n+\n template <typename R, typename ScalarFn, typename VectorFn>\n static R Visit(ScalarFn scalar, VectorFn vector, const Type* type) {\n   if (auto* s = std::get_if<Scalar>(type)) {\n@@ -126,29 +144,6 @@ std::optional<size_t> Type::vector_width() const {\n       [](const Vec& vec) { return vec.width; }, this);\n }\n \n-namespace {\n-template <typename ScalarFn, typename VectorFn>\n-static absl::Status VerifyTypes(ScalarFn scalar, VectorFn vector, const Type& a,\n-                                const Type& b) {\n-  // A pair of scalar types.\n-  auto* sa = std::get_if<Scalar>(&a);\n-  auto* sb = std::get_if<Scalar>(&b);\n-  if (sa && sb) {\n-    return scalar(*sa, *sb);\n-  }\n-\n-  // A pair of vector types.\n-  auto* va = std::get_if<Vec>(&a);\n-  auto* vb = std::get_if<Vec>(&b);\n-  if (va && vb) {\n-    return vector(*va, *vb);\n-  }\n-\n-  return InvalidArgument(\"Expected types of the same kind, but got %s and %s\",\n-                         a.name(), b.name());\n-}\n-}  // namespace\n-\n absl::Status Type::VerifySameWidth(const Type& a, const Type& b) {\n   return VerifyTypes(\n       [&](const Scalar&, const Scalar&) { return absl::OkStatus(); },\n@@ -221,5 +216,4 @@ Type Type::TypeFromIrType(llvm::Type* type) {\n   return Type(llvm_ir::PrimitiveTypeFromIrType(type), std::nullopt);\n }\n \n-}  // namespace intrinsics\n-}  // namespace xla::codegen\n+}  // namespace xla::codegen::intrinsics",
            "previous_filename": "third_party/xla/xla/codegen/intrinsic/intrinsic.cc"
        },
        {
            "sha": "549c2dd95024dd777dde183a4b7e43509da71ab6",
            "filename": "third_party/xla/xla/codegen/intrinsic/type.h",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype.h?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -0,0 +1,98 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_CODEGEN_INTRINSIC_TYPE_H_\n+#define XLA_CODEGEN_INTRINSIC_TYPE_H_\n+\n+#include <cstddef>\n+#include <optional>\n+#include <string>\n+#include <variant>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/IR/Type.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"mlir/IR/Types.h\"\n+#include \"xla/xla_data.pb.h\"\n+namespace xla::codegen::intrinsics {\n+\n+// A scalar argument or result.\n+struct Scalar {\n+  PrimitiveType type;\n+\n+  bool operator==(const Scalar& other) const { return type == other.type; }\n+};\n+\n+// A vector argument or result.\n+struct Vec {\n+  PrimitiveType type;\n+  size_t width;\n+\n+  bool operator==(const Vec& other) const {\n+    return type == other.type && width == other.width;\n+  }\n+};\n+\n+class Type : public std::variant<Scalar, Vec> {\n+ public:\n+  using std::variant<Scalar, Vec>::variant;\n+  Type(PrimitiveType type, std::optional<size_t> vector_width);\n+\n+  std::string name() const;\n+  bool is_scalar() const;\n+  bool is_vector() const;\n+  PrimitiveType element_type() const;\n+  std::optional<size_t> vector_width() const;\n+  llvm::Type* to_ir_type(llvm::LLVMContext& context) const;\n+  mlir::Type to_ir_type(mlir::MLIRContext& context) const;\n+\n+  template <typename Sink>\n+  friend void AbslStringify(Sink& sink, const Type& type) {\n+    absl::Format(&sink, \"%s\", type.name());\n+  }\n+\n+  // Shortened builders for the scalar and vector types defined above.\n+  static constexpr Type S(PrimitiveType type) { return Scalar{type}; }\n+  static constexpr Type V(PrimitiveType type, size_t width) {\n+    return Vec{type, width};\n+  }\n+\n+  // Verifies that the two types have the same width.\n+  static absl::Status VerifySameWidth(const Type& a, const Type& b);\n+\n+  // Verifies that the two types have the same width and element type.\n+  static absl::Status VerifySameWidthAndElementType(const Type& a,\n+                                                    const Type& b);\n+\n+  // Returns the LLVM IR type for the given intrinsic type.\n+  static llvm::Type* TypeToIrType(Type type, llvm::LLVMContext& context);\n+\n+  // Returns the MLIR type for the given intrinsic type.\n+  static mlir::Type TypeToIrType(Type type, mlir::MLIRContext& context);\n+\n+  // Returns the intrinsic type for the given MLIR type.\n+  static Type TypeFromIrType(mlir::Type type);\n+\n+  // Returns the intrinsic type for the given LLVM type.\n+  static Type TypeFromIrType(llvm::Type* type);\n+\n+  // Returns the intrinsic type for the given type name, e.g. v4f32.\n+  static Type FromName(absl::string_view name);\n+};\n+\n+}  // namespace xla::codegen::intrinsics\n+\n+#endif  // XLA_CODEGEN_INTRINSIC_TYPE_H_"
        },
        {
            "sha": "497b141fc9528e683a0e369bca5bdfc822fb0e40",
            "filename": "third_party/xla/xla/codegen/intrinsic/type_test.cc",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Ftype_test.cc?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -0,0 +1,70 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/codegen/intrinsic/type.h\"\n+\n+#include <gtest/gtest.h>\n+#include \"llvm/IR/DerivedTypes.h\"\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/IR/Type.h\"\n+#include \"llvm/Support/TypeSize.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+\n+namespace xla::codegen::intrinsics {\n+namespace {\n+\n+TEST(TypeTest, TypeToIrType) {\n+  llvm::LLVMContext context;\n+  EXPECT_EQ(Type::S(F32).to_ir_type(context), llvm::Type::getFloatTy(context));\n+  EXPECT_EQ(Type::V(F32, 4).to_ir_type(context),\n+            llvm::VectorType::get(llvm::Type::getFloatTy(context),\n+                                  llvm::ElementCount::getFixed(4)));\n+}\n+\n+TEST(TypeTest, TypeFromIrType) {\n+  llvm::LLVMContext context;\n+  EXPECT_EQ(Type::TypeFromIrType(llvm::Type::getFloatTy(context)),\n+            Type::S(F32));\n+  EXPECT_EQ(\n+      Type::TypeFromIrType(llvm::VectorType::get(\n+          llvm::Type::getFloatTy(context), llvm::ElementCount::getFixed(4))),\n+      Type::V(F32, 4));\n+}\n+\n+TEST(TypeTest, VerifySameWidth) {\n+  TF_EXPECT_OK(Type::VerifySameWidth(Type::S(F32), Type::S(F32)));\n+  TF_EXPECT_OK(Type::VerifySameWidth(Type::V(F32, 4), Type::V(F32, 4)));\n+  EXPECT_FALSE(Type::VerifySameWidth(Type::V(F32, 4), Type::V(F32, 8)).ok());\n+}\n+\n+TEST(TypeTest, VerifySameWidthAndElementType) {\n+  TF_EXPECT_OK(Type::VerifySameWidthAndElementType(Type::S(F32), Type::S(F32)));\n+  TF_EXPECT_OK(\n+      Type::VerifySameWidthAndElementType(Type::V(F32, 4), Type::V(F32, 4)));\n+  EXPECT_FALSE(\n+      Type::VerifySameWidthAndElementType(Type::V(F32, 4), Type::V(F32, 8))\n+          .ok());\n+  EXPECT_FALSE(\n+      Type::VerifySameWidthAndElementType(Type::V(F32, 4), Type::V(BF16, 4))\n+          .ok());\n+}\n+\n+TEST(TypeTest, FromName) {\n+  EXPECT_EQ(Type::FromName(\"f32\"), Type::S(F32));\n+  EXPECT_EQ(Type::FromName(\"v4f32\"), Type::V(F32, 4));\n+}\n+\n+}  // namespace\n+}  // namespace xla::codegen::intrinsics"
        },
        {
            "sha": "5ce57f3c6017fab2aeabd3053f33be9b5e48e053",
            "filename": "third_party/xla/xla/codegen/intrinsic/vec_name_mangler.h",
            "status": "modified",
            "additions": 39,
            "deletions": 3,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fvec_name_mangler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fvec_name_mangler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fvec_name_mangler.h?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -16,14 +16,17 @@ limitations under the License.\n #ifndef XLA_CODEGEN_INTRINSIC_VEC_NAME_MANGLER_H_\n #define XLA_CODEGEN_INTRINSIC_VEC_NAME_MANGLER_H_\n \n-#include <algorithm>\n #include <cstddef>\n #include <string>\n #include <vector>\n \n+#include \"absl/algorithm/container.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/codegen/intrinsic/type.h\"\n \n namespace xla::codegen::intrinsic {\n \n@@ -54,12 +57,45 @@ inline std::string GetMangledNamePrefix(\n   std::string mask = is_masked ? \"M\" : \"N\";\n \n   std::vector<std::string> param_strings(param_cardinalities.size());\n-  std::transform(param_cardinalities.begin(), param_cardinalities.end(),\n-                 param_strings.begin(), VecParamCardinalityToString);\n+  absl::c_transform(param_cardinalities, param_strings.begin(),\n+                    VecParamCardinalityToString);\n   return absl::StrCat(\"_ZGV_LLVM_\", mask, vector_width,\n                       absl::StrJoin(param_strings, \"\"));\n }\n \n+inline std::string GetMangledNamePrefix(\n+    bool is_masked, bool last_arg_is_return_type,\n+    absl::Span<const intrinsics::Type> types) {\n+  std::vector<VecParamCardinality> param_cardinalities;\n+  auto front = types.front();\n+  // Remove the return type if it's in the types list:\n+  for (const auto& type : types.first(types.size() - last_arg_is_return_type)) {\n+    if (type.is_scalar()) {\n+      param_cardinalities.push_back(VecParamCardinality::kScalar);\n+    } else {\n+      param_cardinalities.push_back(VecParamCardinality::kVector);\n+    }\n+    CHECK(type.vector_width() == front.vector_width())\n+        << \"All types must have the same vector width.\";\n+  }\n+  return GetMangledNamePrefix(is_masked, front.vector_width().value_or(1),\n+                              param_cardinalities);\n+}\n+\n+inline std::string FunctionName(bool last_arg_is_return_type,\n+                                absl::Span<const intrinsics::Type> types,\n+                                absl::string_view func_name) {\n+  std::vector<std::string> type_names;\n+  type_names.reserve(types.size());\n+  for (const auto& type : types) {\n+    type_names.push_back(type.name());\n+  }\n+  if (last_arg_is_return_type) {\n+    type_names.insert(--type_names.end(), \"to\");\n+  }\n+  return absl::StrCat(\"xla.\", func_name, \".\", absl::StrJoin(type_names, \".\"));\n+}\n+\n }  // namespace xla::codegen::intrinsic\n \n #endif  // XLA_CODEGEN_INTRINSIC_VEC_NAME_MANGLER_H_"
        },
        {
            "sha": "c8274d45aba873a7d128e644cc4660dcdf929368",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 16,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8d940b9cc754805c706ccace290373c7feb87481/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc?ref=8d940b9cc754805c706ccace290373c7feb87481",
            "patch": "@@ -70,6 +70,7 @@ limitations under the License.\n #include \"xla/codegen/intrinsic/rsqrt.h\"\n #include \"xla/codegen/intrinsic/string_interner.h\"\n #include \"xla/codegen/intrinsic/tanh.h\"\n+#include \"xla/codegen/intrinsic/type.h\"\n #include \"xla/codegen/intrinsic/vec_name_mangler.h\"\n #include \"xla/service/llvm_ir/llvm_util.h\"\n #include \"xla/xla_data.pb.h\"\n@@ -154,22 +155,8 @@ class IntrinsicAdapter : public IntrinsicFunction {\n   }\n   std::string GenerateMangledSimdPrefix(\n       absl::Span<const Type> types) const override {\n-    std::vector<intrinsic::VecParamCardinality> param_cardinalities;\n-    auto front = types.front();\n-    // Remove the return type if it's in the types list:\n-    for (const auto& type :\n-         types.first(types.size() - Intrinsic::kLastArgIsReturnType)) {\n-      if (type.is_scalar()) {\n-        param_cardinalities.push_back(intrinsic::VecParamCardinality::kScalar);\n-      } else {\n-        param_cardinalities.push_back(intrinsic::VecParamCardinality::kVector);\n-      }\n-      CHECK(type.vector_width() == front.vector_width())\n-          << \"All types must have the same vector width.\";\n-    }\n-    return intrinsic::GetMangledNamePrefix(Intrinsic::kIsMasked,\n-                                           front.vector_width().value_or(1),\n-                                           param_cardinalities);\n+    return intrinsic::GetMangledNamePrefix(\n+        Intrinsic::kIsMasked, Intrinsic::kLastArgIsReturnType, types);\n   }\n };\n "
        }
    ],
    "stats": {
        "total": 410,
        "additions": 279,
        "deletions": 131
    }
}