{
    "author": "nvgrw",
    "message": "Clean up error_util_test(s).\n\nSplit former single test case into multiple test cases.\n\nPiperOrigin-RevId: 840804642",
    "sha": "67c6742b416af402fac5a9043f293fa1270ec2d2",
    "files": [
        {
            "sha": "673c3d9df1fdfcb2863809966812dabea37a4d42",
            "filename": "third_party/xla/xla/mlir/utils/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/67c6742b416af402fac5a9043f293fa1270ec2d2/third_party%2Fxla%2Fxla%2Fmlir%2Futils%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/67c6742b416af402fac5a9043f293fa1270ec2d2/third_party%2Fxla%2Fxla%2Fmlir%2Futils%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir%2Futils%2FBUILD?ref=67c6742b416af402fac5a9043f293fa1270ec2d2",
            "patch": "@@ -36,12 +36,10 @@ xla_cc_test(\n     deps = [\n         \":error_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n-        \"//xla/tsl/platform:status\",\n         \"//xla/tsl/platform:test_main\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_googletest//:gtest\",\n-        \"@llvm-project//llvm:Support\",\n         \"@llvm-project//mlir:IR\",\n     ],\n )"
        },
        {
            "sha": "a64576d432adae15efc89597b07c88d7d44ab083",
            "filename": "third_party/xla/xla/mlir/utils/error_util_test.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 38,
            "changes": 76,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/67c6742b416af402fac5a9043f293fa1270ec2d2/third_party%2Fxla%2Fxla%2Fmlir%2Futils%2Ferror_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/67c6742b416af402fac5a9043f293fa1270ec2d2/third_party%2Fxla%2Fxla%2Fmlir%2Futils%2Ferror_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir%2Futils%2Ferror_util_test.cc?ref=67c6742b416af402fac5a9043f293fa1270ec2d2",
            "patch": "@@ -18,56 +18,56 @@ limitations under the License.\n #include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n #include \"absl/strings/match.h\"\n-#include \"llvm/ADT/Twine.h\"\n #include \"mlir/IR/Builders.h\"\n+#include \"mlir/IR/Diagnostics.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n-#include \"xla/tsl/platform/status.h\"\n \n namespace mlir {\n namespace {\n \n-TEST(ErrorUtilTest, BaseScopedDiagnosticHandler) {\n-  MLIRContext context;\n-  auto id = StringAttr::get(&context, \"test.py\");\n-  auto loc = FileLineColLoc::get(&context, id, 0, 0);\n+class ErrorUtilTest : public ::testing::Test {\n+ protected:\n+  ErrorUtilTest()\n+      : id_(StringAttr::get(&context_, \"test.py\")),\n+        loc_(FileLineColLoc::get(&context_, id_, 0, 0)) {}\n \n-  // Test OK without diagnostic gets passed through.\n-  {\n-    TF_EXPECT_OK(\n-        BaseScopedDiagnosticHandler(&context).Combine(absl::OkStatus()));\n-  }\n+  MLIRContext context_;\n+  StringAttr id_;\n+  FileLineColLoc loc_;\n+};\n \n-  // Verify diagnostics are captured as Unknown status.\n-  {\n-    BaseScopedDiagnosticHandler handler(&context);\n-    emitError(loc) << \"Diagnostic message\";\n-    ASSERT_TRUE(absl::IsUnknown(handler.ConsumeStatus()));\n-  }\n+using BaseScopedDiagnosticHandlerTest = ErrorUtilTest;\n \n-  // Verify passed in errors are propagated.\n-  {\n-    absl::Status err = absl::InternalError(\"Passed in error\");\n-    ASSERT_TRUE(\n-        absl::IsInternal(BaseScopedDiagnosticHandler(&context).Combine(err)));\n-  }\n+TEST_F(BaseScopedDiagnosticHandlerTest, OkWithoutDiagnosticGetsPassedThrough) {\n+  TF_EXPECT_OK(\n+      BaseScopedDiagnosticHandler(&context_).Combine(absl::OkStatus()));\n+}\n+\n+TEST_F(BaseScopedDiagnosticHandlerTest,\n+       VerifyDiagnosticsAreCapturedAsUnknownStatus) {\n+  BaseScopedDiagnosticHandler handler(&context_);\n+  emitError(loc_) << \"Diagnostic message\";\n+  ASSERT_TRUE(absl::IsUnknown(handler.ConsumeStatus()));\n+}\n \n-  // Verify diagnostic reported are append to passed in error.\n-  {\n-    auto function = [&]() {\n-      emitError(loc) << \"Diagnostic message reported\";\n-      emitError(loc) << \"Second diagnostic message reported\";\n-      return absl::InternalError(\"Passed in error\");\n-    };\n+TEST_F(BaseScopedDiagnosticHandlerTest, VerifyPassedInErrorsArePropagated) {\n+  const absl::Status err = absl::InternalError(\"Passed in error\");\n+  ASSERT_TRUE(\n+      absl::IsInternal(BaseScopedDiagnosticHandler(&context_).Combine(err)));\n+}\n \n-    BaseScopedDiagnosticHandler ssdh(&context);\n-    absl::Status s = ssdh.Combine(function());\n-    ASSERT_TRUE(absl::IsInternal(s));\n-    EXPECT_TRUE(absl::StrContains(s.message(), \"Passed in error\"));\n-    EXPECT_TRUE(absl::StrContains(s.message(), \"Diagnostic message reported\"));\n-    EXPECT_TRUE(\n-        absl::StrContains(s.message(), \"Second diagnostic message reported\"));\n-  }\n+TEST_F(BaseScopedDiagnosticHandlerTest,\n+       VerifyThatReportedDiagnosticsAreAppendedToPassedInError) {\n+  BaseScopedDiagnosticHandler ssdh(&context_);\n+  emitError(loc_) << \"Diagnostic message reported\";\n+  emitError(loc_) << \"Second diagnostic message reported\";\n+  const absl::Status s = ssdh.Combine(absl::InternalError(\"Passed in error\"));\n+  ASSERT_TRUE(absl::IsInternal(s));\n+  EXPECT_TRUE(absl::StrContains(s.message(), \"Passed in error\"));\n+  EXPECT_TRUE(absl::StrContains(s.message(), \"Diagnostic message reported\"));\n+  EXPECT_TRUE(\n+      absl::StrContains(s.message(), \"Second diagnostic message reported\"));\n }\n \n }  // namespace"
        }
    ],
    "stats": {
        "total": 78,
        "additions": 38,
        "deletions": 40
    }
}