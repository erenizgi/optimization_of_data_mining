{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Validation] add CanCoexistWithoutOverlap function which is more efficient check of (cancoexist && !overlaps)\n\nPiperOrigin-RevId: 828682611",
    "sha": "713f63a8801d0257da695f7ea178592e00e50a92",
    "files": [
        {
            "sha": "391951d6e43642cd0f7b71399b3d8d67e854ae43",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 1,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/713f63a8801d0257da695f7ea178592e00e50a92/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/713f63a8801d0257da695f7ea178592e00e50a92/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc?ref=713f63a8801d0257da695f7ea178592e00e50a92",
            "patch": "@@ -249,10 +249,47 @@ bool AxisRef::Overlaps(const AxisRef& other) const {\n          other_sub_axis.pre_size < this_sub_axis.next_pre_size();\n }\n \n+bool AxisRef::CanCoexistWithoutOverlap(const AxisRef& other) const {\n+  // Check if the axes are on different mesh dimensions. If so, they can always\n+  // coexist and never overlap.\n+  if (mesh_axis_index() != other.mesh_axis_index()) {\n+    return true;\n+  }\n+\n+  // If one AxisRef is a full axis it will always overlap the other axis on the\n+  // same dimension.\n+  if (!sub_axis_info_.has_value() || !other.sub_axis_info_.has_value()) {\n+    return false;\n+  }\n+\n+  const SubAxis& this_sub_axis = sub_axis_info_.value();\n+  const SubAxis& other_sub_axis = other.sub_axis_info_.value();\n+\n+  int64_t this_pre_size = this_sub_axis.pre_size;\n+  int64_t other_pre_size = other_sub_axis.pre_size;\n+  int64_t this_next_pre_size = this_sub_axis.next_pre_size();\n+  int64_t other_next_pre_size = other_sub_axis.next_pre_size();\n+\n+  // Check for overlapping sub-axes\n+  bool overlaps = (this_next_pre_size > other_pre_size) &&\n+                  (other_next_pre_size > this_pre_size);\n+  if (overlaps) {\n+    return false;\n+  }\n+  // Assert that sub-axes can coexist.\n+  auto [min_pre_size, max_pre_size] =\n+      std::minmax(this_pre_size, other_pre_size);\n+  auto [min_next_pre_size, max_next_pre_size] =\n+      std::minmax(this_next_pre_size, other_next_pre_size);\n+\n+  // Sub-axes don't overlap, check if the gap is valid.\n+  return max_pre_size % min_next_pre_size == 0;\n+}\n+\n bool ValidateSpanOfAxes(absl::Span<const AxisRef> axes) {\n   for (int64_t i = 0; i < axes.size() - 1; ++i) {\n     for (int64_t j = i + 1; j < axes.size(); ++j) {\n-      if (!axes[i].CanCoexist(axes[j]) || axes[i].Overlaps(axes[j])) {\n+      if (!axes[i].CanCoexistWithoutOverlap(axes[j])) {\n         return false;\n       }\n     }"
        },
        {
            "sha": "4f729aaf158e3f4d2e53e2478912a23c4c1ed670",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/713f63a8801d0257da695f7ea178592e00e50a92/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/713f63a8801d0257da695f7ea178592e00e50a92/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=713f63a8801d0257da695f7ea178592e00e50a92",
            "patch": "@@ -176,8 +176,8 @@ class AxisRef {\n   static AxisRef FromProto(const AxisRefProto& proto);\n \n   bool CanCoexist(const AxisRef& other) const;\n-\n   bool Overlaps(const AxisRef& other) const;\n+  bool CanCoexistWithoutOverlap(const AxisRef& other) const;\n \n   // Validates that the given mesh is compatible for this axis ref.\n   absl::Status Validate(const Mesh& mesh) const;"
        },
        {
            "sha": "b4cb65ff46e6cc35814d32519c191b53c4fdcccc",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis_test.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/713f63a8801d0257da695f7ea178592e00e50a92/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/713f63a8801d0257da695f7ea178592e00e50a92/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc?ref=713f63a8801d0257da695f7ea178592e00e50a92",
            "patch": "@@ -288,4 +288,33 @@ TEST(MeshAndAxisTest, AxisRefOverlaps) {\n   overlaps(AxisRef(0, {4, 2}), AxisRef(0, {1, 2}), false);\n }\n \n+TEST(MeshAndAxisTest, AxisRefCanCoexistWithoutOverlap) {\n+  auto coexistWithoutOverlap = [](AxisRef a, AxisRef b, bool expected) {\n+    EXPECT_EQ(a.CanCoexistWithoutOverlap(b), expected);\n+    EXPECT_EQ(b.CanCoexistWithoutOverlap(a), expected);\n+  };\n+\n+  coexistWithoutOverlap(AxisRef(0), AxisRef(1), true);\n+  coexistWithoutOverlap(AxisRef(0), AxisRef(1, {1, 2}), true);\n+  coexistWithoutOverlap(AxisRef(0), AxisRef(1, {2, 2}), true);\n+  coexistWithoutOverlap(AxisRef(0, {1, 2}), AxisRef(0, {2, 4}), true);\n+  coexistWithoutOverlap(AxisRef(0, {1, 2}), AxisRef(0, {6, 2}), true);\n+  coexistWithoutOverlap(AxisRef(0, {1, 4}), AxisRef(0, {4, 2}), true);\n+  coexistWithoutOverlap(AxisRef(0, {1, 4}), AxisRef(0, {8, 2}), true);\n+  coexistWithoutOverlap(AxisRef(0, {4, 2}), AxisRef(0, {1, 2}), true);\n+\n+  coexistWithoutOverlap(AxisRef(0), AxisRef(0), false);\n+  coexistWithoutOverlap(AxisRef(0), AxisRef(0, {2, 2}), false);\n+  coexistWithoutOverlap(AxisRef(0), AxisRef(0, {2, 4}), false);\n+  coexistWithoutOverlap(AxisRef(0, {2, 2}), AxisRef(0, {2, 2}), false);\n+  coexistWithoutOverlap(AxisRef(0, {1, 2}), AxisRef(0, {1, 4}), false);\n+  coexistWithoutOverlap(AxisRef(2, {1, 2}), AxisRef(2, {1, 4}), false);\n+  coexistWithoutOverlap(AxisRef(0, {1, 4}), AxisRef(0, {2, 2}), false);\n+  coexistWithoutOverlap(AxisRef(0, {1, 4}), AxisRef(0, {2, 4}), false);\n+  coexistWithoutOverlap(AxisRef(0, {1, 2}), AxisRef(0, {1, 3}), false);\n+  coexistWithoutOverlap(AxisRef(0, {1, 2}), AxisRef(0, {3, 2}), false);\n+  coexistWithoutOverlap(AxisRef(0, {1, 3}), AxisRef(0, {2, 3}), false);\n+  coexistWithoutOverlap(AxisRef(0, {2, 8}), AxisRef(0, {4, 2}), false);\n+}\n+\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 70,
        "additions": 68,
        "deletions": 2
    }
}