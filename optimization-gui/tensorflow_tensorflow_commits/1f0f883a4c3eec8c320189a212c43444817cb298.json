{
    "author": "junwhanahn",
    "message": "Gracefully handle missing parameter/output shardings from single-device atom executables\n\n`PjRtExecutable::GetParameterShardings()` and `PjRtExecutable::GetOutputShardings()` may return `std::nullopt` for single-device executables, but their shardings are trivial and we can infer them from the device count.\n\nPiperOrigin-RevId: 841798186",
    "sha": "1f0f883a4c3eec8c320189a212c43444817cb298",
    "files": [
        {
            "sha": "097136f5b1c631f12739d2a83dba5a734f4c7798",
            "filename": "third_party/xla/xla/python/ifrt/ir/tests/ifrt-opt.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftests%2Fifrt-opt.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftests%2Fifrt-opt.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftests%2Fifrt-opt.cc?ref=1f0f883a4c3eec8c320189a212c43444817cb298",
            "patch": "@@ -67,11 +67,18 @@ class TestChildExecutableCompiler : public AtomProgramCompiler {\n            \"invalidated some method string_views.\";\n     auto mock_executable =\n         std::make_unique<testing::NiceMock<MockLoadedExecutable>>();\n+    int num_devices;\n+    if (options.executable_build_options.has_device_assignment()) {\n+      num_devices =\n+          options.executable_build_options.device_assignment().num_elements();\n+    } else {\n+      num_devices = 1;\n+    }\n     int num_parameters_to_propagate =\n         options.executable_build_options\n             .allow_spmd_sharding_propagation_to_parameters()\n             .size();\n-    if (num_parameters_to_propagate > 0) {\n+    if (num_devices > 1 && num_parameters_to_propagate > 0) {\n       xla::OpSharding op_sharding;\n       op_sharding.set_type(xla::OpSharding::REPLICATED);\n       std::vector<xla::OpSharding> parameter_shardings(\n@@ -83,7 +90,7 @@ class TestChildExecutableCompiler : public AtomProgramCompiler {\n         options.executable_build_options\n             .allow_spmd_sharding_propagation_to_output()\n             .size();\n-    if (num_outputs_to_propagate > 0) {\n+    if (num_devices > 1 && num_outputs_to_propagate > 0) {\n       // Always infer output shardings to be replicated for the lit tests.\n       xla::OpSharding op_sharding;\n       op_sharding.set_type(xla::OpSharding::REPLICATED);"
        },
        {
            "sha": "e8c49c453b68530a19c1687407dbe330bd91170f",
            "filename": "third_party/xla/xla/python/ifrt/ir/tests/ifrt_compile_and_propagate_shardings.mlir",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftests%2Fifrt_compile_and_propagate_shardings.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftests%2Fifrt_compile_and_propagate_shardings.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftests%2Fifrt_compile_and_propagate_shardings.mlir?ref=1f0f883a4c3eec8c320189a212c43444817cb298",
            "patch": "@@ -286,6 +286,36 @@ module @propagate_to_inputs {\n \n // -----\n \n+!array_unspecified = !ifrt.array<tensor<2x2xi32>,\n+                                 #ifrt.sharding_unspecified, [0]>\n+// CHECK-LABEL: @propagate_single_device\n+module @propagate_single_device {\n+  func.func @main(%arg0: !array_unspecified)\n+      -> !array_unspecified attributes {ifrt.function} {\n+    // CHECK: %[[OUT:.+]], %{{.+}} = ifrt.CallLoadedExecutable @[[CALLEE:.+]](%arg0)\n+    // CHECK-SAME: !ifrt.array<tensor<2x2xi32>, #ifrt.sharding_param<1x1 to [0] on 1>, [0]>\n+    // CHECK-SAME: -> !ifrt.array<tensor<2x2xi32>, #ifrt.sharding_param<1x1 to [0] on 1>, [0]>\n+    %0, %ctrl_0 = ifrt.Call @add_one_0::@main(%arg0) on devices [0]\n+        {ifrt.module_type = \"xla\"} : (!array_unspecified) -> !array_unspecified\n+    return %0 : !array_unspecified\n+  }\n+\n+  // CHECK: ifrt.LoadedExecutable @[[CALLEE]]\n+  // CHECK-SAME: on devices [0]\n+  // CHECK-SAME: !ifrt.array<tensor<2x2xi32>, #ifrt.sharding_param<1x1 to [0] on 1>, [0]>\n+  // CHECK-SAME: -> !ifrt.array<tensor<2x2xi32>, #ifrt.sharding_param<1x1 to [0] on 1>, [0]>\n+  module @add_one_0 attributes {sym_visibility = \"private\"} {\n+    func.func @main(%arg0: tensor<2x2xi32>) -> (tensor<2x2xi32>) {\n+      %0 = mhlo.constant dense<1> : tensor<2x2xi32>\n+      %1 = mhlo.add %arg0, %0 : tensor<2x2xi32>\n+      return %1 : tensor<2x2xi32>\n+    }\n+  }\n+\n+}\n+\n+// -----\n+\n !array = !ifrt.array<tensor<2x2xi32>,\n                      #ifrt.sharding_param<2x1 to [0] on 2>, [0, 1]>\n !array_unspecified = !ifrt.array<tensor<2x2xi32>,"
        },
        {
            "sha": "a828664243a673c841fa6ba7fbe50986b0a5cebf",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/ifrt_compile_and_propagate_shardings_pass.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 8,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_compile_and_propagate_shardings_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_compile_and_propagate_shardings_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_compile_and_propagate_shardings_pass.cc?ref=1f0f883a4c3eec8c320189a212c43444817cb298",
            "patch": "@@ -62,6 +62,7 @@ limitations under the License.\n #include \"xla/python/ifrt/ir/transforms/utils.h\"\n #include \"xla/python/ifrt/support/sharding_conversions.h\"\n #include \"xla/service/hlo.pb.h\"\n+#include \"xla/xla_data.pb.h\"\n \n namespace xla {\n namespace ifrt {\n@@ -388,10 +389,16 @@ IfrtCompileAndPropagateShardingsPass::GetInputShardingParams(\n     if (llvm::isa<IfrtUnspecifiedShardingAttr>(\n             in_array_type.getShardingAttr())) {\n       if (!in_shardings.has_value()) {\n-        in_shardings = compile_result.executable->GetParameterShardings();\n-        if (!in_shardings.has_value()) {\n-          return call_op.emitError()\n-                 << \"executable does not have input shardings\";\n+        if (call_op.getDevices().size() == 1) {\n+          // Use replicated sharding for single-device inputs without calling\n+          // `GetParameterShardings` since it may return `std::nullopt`.\n+          in_shardings.emplace(call_op.getOutputs().size());\n+        } else {\n+          in_shardings = compile_result.executable->GetParameterShardings();\n+          if (!in_shardings.has_value()) {\n+            return call_op.emitError()\n+                   << \"executable does not have input shardings\";\n+          }\n         }\n         if (in_shardings->size() != call_op.getOutputs().size()) {\n           return call_op.emitError()\n@@ -443,10 +450,16 @@ IfrtCompileAndPropagateShardingsPass::GetOutputShardingParams(\n     if (llvm::isa<IfrtUnspecifiedShardingAttr>(\n             out_array_type.getShardingAttr())) {\n       if (!out_shardings.has_value()) {\n-        out_shardings = compile_result.executable->GetOutputShardings();\n-        if (!out_shardings.has_value()) {\n-          return call_op.emitError()\n-                 << \"executable does not have output shardings\";\n+        if (call_op.getDevices().size() == 1) {\n+          // Use replicated sharding for single-device inputs without calling\n+          // `GetParameterShardings` since it may return `std::nullopt`.\n+          out_shardings.emplace(call_op.getOutputs().size());\n+        } else {\n+          out_shardings = compile_result.executable->GetOutputShardings();\n+          if (!out_shardings.has_value()) {\n+            return call_op.emitError()\n+                   << \"executable does not have output shardings\";\n+          }\n         }\n         if (out_shardings->size() != call_op.getOutputs().size()) {\n           return call_op.emitError()"
        },
        {
            "sha": "fe0f68ccbea178e593df02994061279871be1f1c",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/ifrt_verify_bound_external_loaded_executable_pass.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 24,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_verify_bound_external_loaded_executable_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f0f883a4c3eec8c320189a212c43444817cb298/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_verify_bound_external_loaded_executable_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_verify_bound_external_loaded_executable_pass.cc?ref=1f0f883a4c3eec8c320189a212c43444817cb298",
            "patch": "@@ -14,6 +14,7 @@ limitations under the License.\n ==============================================================================*/\n \n #include <memory>\n+#include <optional>\n #include <utility>\n #include <vector>\n \n@@ -130,50 +131,49 @@ void IfrtVerifyBoundExternalLoadedExecutablePass::runOnOperation() {\n       }\n \n       auto func_type = loaded_exec_op.getFunctionType();\n-      if (!exec_it->second->GetParameterShardings().has_value()) {\n+      std::optional<std::vector<xla::OpSharding>> parameter_shardings;\n+      if (loaded_exec_op.getDevices().size() == 1) {\n+        parameter_shardings.emplace(func_type.getNumInputs());\n+      } else {\n+        parameter_shardings = exec_it->second->GetParameterShardings();\n+      }\n+      if (!parameter_shardings.has_value()) {\n         return loaded_exec_op.emitOpError()\n                << \"cannot be bound to an executable without parameter \"\n                   \"shardings\";\n       }\n-      if (!exec_it->second->GetOutputShardings().has_value()) {\n+      std::optional<std::vector<xla::OpSharding>> output_shardings;\n+      if (loaded_exec_op.getDevices().size() == 1) {\n+        output_shardings.emplace(func_type.getNumResults());\n+      } else {\n+        output_shardings = exec_it->second->GetOutputShardings();\n+      }\n+      if (!output_shardings.has_value()) {\n         return loaded_exec_op.emitOpError()\n-               << \"cannot be bound to an executable without output shardings\";\n+               << \"cannot be bound to a multi-device executable without output \"\n+                  \"shardings\";\n       }\n-      if (func_type.getNumInputs() !=\n-          exec_it->second->GetParameterShardings()->size()) {\n+      if (func_type.getNumInputs() != parameter_shardings->size()) {\n         return loaded_exec_op.emitOpError()\n                << \"expects an executable with \" << func_type.getNumInputs()\n                << \" inputs, but was bound to an executable with \"\n-               << exec_it->second->GetParameterShardings()->size() << \" inputs\";\n+               << parameter_shardings->size() << \" inputs\";\n       }\n-      if (func_type.getNumResults() !=\n-          exec_it->second->GetOutputShardings()->size()) {\n+      if (func_type.getNumResults() != output_shardings->size()) {\n         return loaded_exec_op.emitOpError()\n                << \"expects an executable with \" << func_type.getNumResults()\n                << \" results, but was bound to an executable with \"\n-               << exec_it->second->GetOutputShardings()->size() << \" results\";\n+               << output_shardings->size() << \" results\";\n       }\n       // Verify that the input and output shardings of the LoadedExecutableOp\n       // are the same as the shardings of the bound executable.\n-      if (!exec_it->second->GetParameterShardings().has_value()) {\n-        return loaded_exec_op.emitOpError()\n-               << \"cannot be bound to an executable without parameter \"\n-                  \"shardings\";\n-      }\n-      if (!exec_it->second->GetOutputShardings().has_value()) {\n-        return loaded_exec_op.emitOpError()\n-               << \"cannot be bound to an executable without output \"\n-                  \"shardings\";\n-      }\n       auto sharding_equal_status = VerifyShardingsEqual(\n-          func_type.getInputs(), *exec_it->second->GetParameterShardings(),\n-          \"input\");\n+          func_type.getInputs(), *parameter_shardings, \"input\");\n       if (!sharding_equal_status.ok()) {\n         return loaded_exec_op.emitOpError() << sharding_equal_status.message();\n       }\n-      sharding_equal_status = VerifyShardingsEqual(\n-          func_type.getResults(), *exec_it->second->GetOutputShardings(),\n-          \"output\");\n+      sharding_equal_status = VerifyShardingsEqual(func_type.getResults(),\n+                                                   *output_shardings, \"output\");\n       if (!sharding_equal_status.ok()) {\n         return loaded_exec_op.emitOpError() << sharding_equal_status.message();\n       }"
        }
    ],
    "stats": {
        "total": 118,
        "additions": 84,
        "deletions": 34
    }
}