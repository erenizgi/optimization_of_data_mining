{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 826451988",
    "sha": "4d78e8088a85ffe515c78f9b9731459ba9286c3c",
    "files": [
        {
            "sha": "953a8e8cfa76c78834164d28b8e38f261f1323bd",
            "filename": "tensorflow/tools/proto_text/gen_proto_text_functions.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 11,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions.cc?ref=4d78e8088a85ffe515c78f9b9731459ba9286c3c",
            "patch": "@@ -45,8 +45,8 @@ static const char kPlaceholderFile[] =\n     \"tensorflow/tools/proto_text/placeholder.txt\";\n \n bool IsPlaceholderFile(const char* s) {\n-  string ph(kPlaceholderFile);\n-  string str(s);\n+  std::string ph(kPlaceholderFile);\n+  std::string str(s);\n   return str.size() >= strlen(kPlaceholderFile) &&\n          ph == str.substr(str.size() - ph.size());\n }\n@@ -76,14 +76,15 @@ int MainImpl(int argc, char** argv) {\n     return -1;\n   }\n \n-  const string output_root = argv[1];\n-  const string output_relative_path = kTensorFlowHeaderPrefix + string(argv[2]);\n+  const std::string output_root = argv[1];\n+  const std::string output_relative_path =\n+      kTensorFlowHeaderPrefix + std::string(argv[2]);\n \n-  string src_relative_path;\n+  std::string src_relative_path;\n   bool has_placeholder = false;\n   for (int i = 3; i < argc; ++i) {\n     if (IsPlaceholderFile(argv[i])) {\n-      const string s(argv[i]);\n+      const std::string s(argv[i]);\n       src_relative_path = s.substr(0, s.size() - strlen(kPlaceholderFile));\n       has_placeholder = true;\n     }\n@@ -102,13 +103,14 @@ int MainImpl(int argc, char** argv) {\n \n   for (int i = 3; i < argc; i++) {\n     if (IsPlaceholderFile(argv[i])) continue;\n-    const string proto_path = string(argv[i]).substr(src_relative_path.size());\n+    const std::string proto_path =\n+        std::string(argv[i]).substr(src_relative_path.size());\n \n     const tensorflow::protobuf::FileDescriptor* fd =\n         importer.Import(proto_path);\n \n     const int index = proto_path.find_last_of('.');\n-    string proto_path_no_suffix = proto_path.substr(0, index);\n+    std::string proto_path_no_suffix = proto_path.substr(0, index);\n \n     proto_path_no_suffix =\n         proto_path_no_suffix.substr(output_relative_path.size());\n@@ -118,8 +120,8 @@ int MainImpl(int argc, char** argv) {\n \n     // Three passes, one for each output file.\n     for (int pass = 0; pass < 3; ++pass) {\n-      string suffix;\n-      string data;\n+      std::string suffix;\n+      std::string data;\n       if (pass == 0) {\n         suffix = \".pb_text.h\";\n         data = code.header;\n@@ -131,7 +133,8 @@ int MainImpl(int argc, char** argv) {\n         data = code.cc;\n       }\n \n-      const string path = output_root + \"/\" + proto_path_no_suffix + suffix;\n+      const std::string path =\n+          output_root + \"/\" + proto_path_no_suffix + suffix;\n       FILE* f = fopen(path.c_str(), \"w\");\n       if (f == nullptr) {\n         // We don't expect this output to be generated. It was specified in the"
        },
        {
            "sha": "c422f13d01540b0cf634c3b2ed657e80ae8d0d27",
            "filename": "tensorflow/tools/proto_text/gen_proto_text_functions_lib.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 46,
            "changes": 94,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib.cc?ref=4d78e8088a85ffe515c78f9b9731459ba9286c3c",
            "patch": "@@ -36,14 +36,14 @@ namespace tensorflow {\n namespace {\n \n template <typename... Args>\n-string StrCat(const Args&... args) {\n+std::string StrCat(const Args&... args) {\n   std::ostringstream s;\n   std::vector<int> give_me_a_name{((s << args), 0)...};\n   return s.str();\n }\n \n template <typename... Args>\n-string StrAppend(string* to_append, const Args&... args) {\n+std::string StrAppend(std::string* to_append, const Args&... args) {\n   *to_append += StrCat(args...);\n   return *to_append;\n }\n@@ -60,7 +60,7 @@ string StrAppend(string* to_append, const Args&... args) {\n // the field names (it's a loop over all names), and tracking of has_seen.\n class Generator {\n  public:\n-  explicit Generator(const string& tf_header_prefix)\n+  explicit Generator(const std::string& tf_header_prefix)\n       : tf_header_prefix_(tf_header_prefix),\n         header_(&code_.header),\n         header_impl_(&code_.header_impl),\n@@ -73,9 +73,9 @@ class Generator {\n \n  private:\n   struct Section {\n-    explicit Section(string* str) : str(str) {}\n-    string* str;\n-    string indent;\n+    explicit Section(std::string* str) : str(str) {}\n+    std::string* str;\n+    std::string indent;\n   };\n \n   // Switches the currently active section to <section>.\n@@ -110,7 +110,7 @@ class Generator {\n   // <field_expr> is code that when emitted yields the field's value.\n   void AppendFieldValueAppend(const FieldDescriptor& field,\n                               const bool omit_default,\n-                              const string& field_expr);\n+                              const std::string& field_expr);\n \n   // Appends the print code for as single field.\n   void AppendFieldAppend(const FieldDescriptor& field);\n@@ -135,26 +135,26 @@ class Generator {\n   void AddNamespaceToCurrentSection(absl::string_view package, bool open);\n \n   // Appends the given headers as sorted #include lines.\n-  void AddHeadersToCurrentSection(const std::vector<string>& headers);\n+  void AddHeadersToCurrentSection(const std::vector<std::string>& headers);\n \n   // When adding #includes for tensorflow headers, prefix them with this.\n-  const string tf_header_prefix_;\n+  const std::string tf_header_prefix_;\n   ProtoTextFunctionCode code_;\n   Section* cur_ = nullptr;\n   Section header_;\n   Section header_impl_;\n   Section cc_;\n \n-  std::unordered_set<string> map_append_signatures_included_;\n+  std::unordered_set<std::string> map_append_signatures_included_;\n \n   Generator(const Generator&) = delete;\n   void operator=(const Generator&) = delete;\n };\n \n // Returns the prefix needed to reference objects defined in <fd>. E.g.\n // \"::tensorflow::test\".\n-string GetPackageReferencePrefix(const FileDescriptor* fd) {\n-  string result = \"::\";\n+std::string GetPackageReferencePrefix(const FileDescriptor* fd) {\n+  std::string result = \"::\";\n   absl::string_view package = fd->package();\n   for (size_t i = 0; i < package.size(); ++i) {\n     if (package[i] == '.') {\n@@ -168,67 +168,67 @@ string GetPackageReferencePrefix(const FileDescriptor* fd) {\n }\n \n // Returns the name of the class generated by proto to represent <d>.\n-string GetClassName(const Descriptor& d) {\n+std::string GetClassName(const Descriptor& d) {\n   if (d.containing_type() == nullptr) return std::string(d.name());\n   return StrCat(GetClassName(*d.containing_type()), \"_\", d.name());\n }\n \n // Returns the name of the class generated by proto to represent <ed>.\n-string GetClassName(const EnumDescriptor& ed) {\n+std::string GetClassName(const EnumDescriptor& ed) {\n   if (ed.containing_type() == nullptr) return std::string(ed.name());\n   return StrCat(GetClassName(*ed.containing_type()), \"_\", ed.name());\n }\n \n // Returns the qualified name that refers to the class generated by proto to\n // represent <d>.\n-string GetQualifiedName(const Descriptor& d) {\n+std::string GetQualifiedName(const Descriptor& d) {\n   return StrCat(GetPackageReferencePrefix(d.file()), GetClassName(d));\n }\n \n // Returns the qualified name that refers to the class generated by proto to\n // represent <ed>.\n-string GetQualifiedName(const EnumDescriptor& d) {\n+std::string GetQualifiedName(const EnumDescriptor& d) {\n   return StrCat(GetPackageReferencePrefix(d.file()), GetClassName(d));\n }\n \n // Returns the qualified name that refers to the generated\n // AppendProtoDebugString function for <d>.\n-string GetQualifiedAppendFn(const Descriptor& d) {\n+std::string GetQualifiedAppendFn(const Descriptor& d) {\n   return StrCat(GetPackageReferencePrefix(d.file()),\n                 \"internal::AppendProtoDebugString\");\n }\n \n // Returns the name of the generated function that returns an enum value's\n // string value.\n-string GetEnumNameFn(const EnumDescriptor& enum_d) {\n+std::string GetEnumNameFn(const EnumDescriptor& enum_d) {\n   return StrCat(\"EnumName_\", GetClassName(enum_d));\n }\n \n // Returns the qualified name of the function returned by GetEnumNameFn().\n-string GetQualifiedEnumNameFn(const EnumDescriptor& enum_d) {\n+std::string GetQualifiedEnumNameFn(const EnumDescriptor& enum_d) {\n   return StrCat(GetPackageReferencePrefix(enum_d.file()),\n                 GetEnumNameFn(enum_d));\n }\n \n // Returns the name of a generated header file, either the public api (if impl\n // is false) or the internal implementation header (if impl is true).\n-string GetProtoTextHeaderName(const FileDescriptor& fd, bool impl) {\n+std::string GetProtoTextHeaderName(const FileDescriptor& fd, bool impl) {\n   const int dot_index = fd.name().find_last_of('.');\n   return StrCat(fd.name().substr(0, dot_index),\n                 (impl ? \".pb_text-impl.h\" : \".pb_text.h\"));\n }\n \n // Returns the name of the header generated by the proto library for <fd>.\n-string GetProtoHeaderName(const FileDescriptor& fd) {\n+std::string GetProtoHeaderName(const FileDescriptor& fd) {\n   const int dot_index = fd.name().find_last_of('.');\n   return StrCat(fd.name().substr(0, dot_index), \".pb.h\");\n }\n \n // Returns the C++ class name for the given proto field.\n-string GetCppClass(const FieldDescriptor& d) {\n-  string cpp_class = d.cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE\n-                         ? GetQualifiedName(*d.message_type())\n-                         : std::string(d.cpp_type_name());\n+std::string GetCppClass(const FieldDescriptor& d) {\n+  std::string cpp_class = d.cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE\n+                              ? GetQualifiedName(*d.message_type())\n+                              : std::string(d.cpp_type_name());\n \n   // In open-source TensorFlow, the definition of int64 varies across\n   // platforms. The following line, which is manipulated during internal-\n@@ -243,16 +243,16 @@ string GetCppClass(const FieldDescriptor& d) {\n // Returns the string that can be used for a header guard for the generated\n // headers for <fd>, either for the public api (if impl is false) or the\n // internal implementation header (if impl is true).\n-string GetHeaderGuard(const FileDescriptor& fd, bool impl) {\n-  string s(fd.name());\n+std::string GetHeaderGuard(const FileDescriptor& fd, bool impl) {\n+  std::string s(fd.name());\n   std::replace(s.begin(), s.end(), '/', '_');\n   std::replace(s.begin(), s.end(), '.', '_');\n   return s + (impl ? \"_IMPL_H_\" : \"_H_\");\n }\n \n void Generator::AppendFieldValueAppend(const FieldDescriptor& field,\n                                        const bool omit_default,\n-                                       const string& field_expr) {\n+                                       const std::string& field_expr) {\n   // This does not emit code with proper presence semantics (e.g. it doesn't\n   // check 'has' fields on non-messages).\n   CHECK(!field.has_presence() || field.containing_oneof() != nullptr ||\n@@ -351,7 +351,7 @@ void Generator::AppendFieldAppend(const FieldDescriptor& field) {\n   } else {\n     const auto* oneof = field.containing_oneof();\n     if (oneof != nullptr) {\n-      string camel_name(field.camelcase_name());\n+      std::string camel_name(field.camelcase_name());\n       camel_name[0] = toupper(camel_name[0]);\n       Print(\"if (msg.\", oneof->name(), \"_case() == \",\n             GetQualifiedName(*oneof->containing_type()), \"::k\", camel_name,\n@@ -369,10 +369,11 @@ void Generator::AppendFieldAppend(const FieldDescriptor& field) {\n }\n \n void Generator::AppendEnumFunctions(const EnumDescriptor& enum_d) {\n-  const string sig = StrCat(\"const char* \", GetEnumNameFn(enum_d), \"(\\n    \",\n-                            GetQualifiedName(enum_d), \" value)\");\n+  const std::string sig =\n+      StrCat(\"const char* \", GetEnumNameFn(enum_d), \"(\\n    \",\n+             GetQualifiedName(enum_d), \" value)\");\n   SetOutput(&header_);\n-  Print().Print(\"// Enum text output for \", string(enum_d.full_name()));\n+  Print().Print(\"// Enum text output for \", std::string(enum_d.full_name()));\n   Print(sig, \";\");\n \n   SetOutput(&cc_);\n@@ -389,7 +390,7 @@ void Generator::AppendEnumFunctions(const EnumDescriptor& enum_d) {\n \n void Generator::AppendParseMessageFunction(const Descriptor& md) {\n   const bool map_append = (md.options().map_entry());\n-  string sig;\n+  std::string sig;\n   if (!map_append) {\n     sig = StrCat(\"bool ProtoParseFromString(\\n    const string& s,\\n    \",\n                  GetQualifiedName(md), \"* msg)\");\n@@ -476,8 +477,8 @@ void Generator::AppendParseMessageFunction(const Descriptor& md) {\n   for (int i = 0; i < md.field_count(); ++i) {\n     const FieldDescriptor* field = md.field(i);\n     absl::string_view field_name = field->name();\n-    string mutable_value_expr;\n-    string set_value_prefix;\n+    std::string mutable_value_expr;\n+    std::string set_value_prefix;\n     if (map_append) {\n       mutable_value_expr = StrCat(\"&map_\", field_name);\n       set_value_prefix = StrCat(\"map_\", field_name, \" = \");\n@@ -551,7 +552,7 @@ void Generator::AppendParseMessageFunction(const Descriptor& md) {\n           \"Scanner::LETTER_DIGIT_DASH_UNDERSCORE).\"\n           \"GetResult(nullptr, &value)) return false;\");\n       const auto* enum_d = field->enum_type();\n-      string value_prefix;\n+      std::string value_prefix;\n       if (enum_d->containing_type() == nullptr) {\n         value_prefix = GetPackageReferencePrefix(enum_d->file());\n       } else {\n@@ -561,7 +562,7 @@ void Generator::AppendParseMessageFunction(const Descriptor& md) {\n       for (int enum_i = 0; enum_i < enum_d->value_count(); ++enum_i) {\n         const auto* value_d = enum_d->value(enum_i);\n         absl::string_view value_name = value_d->name();\n-        string condition = StrCat(\"value == \\\"\", value_name, \"\\\"\");\n+        std::string condition = StrCat(\"value == \\\"\", value_name, \"\\\"\");\n \n         Print(enum_i == 0 ? \"\" : \"} else \", \"if (\", condition, \") {\");\n         Nest();\n@@ -628,14 +629,14 @@ void Generator::AppendParseMessageFunction(const Descriptor& md) {\n void Generator::AppendDebugStringFunctions(const Descriptor& md) {\n   SetOutput(&header_impl_).Print();\n   SetOutput(&header_).Print().Print(\"// Message-text conversion for \",\n-                                    string(md.full_name()));\n+                                    std::string(md.full_name()));\n \n   // Append the two debug string functions for <md>.\n   for (int short_pass = 0; short_pass < 2; ++short_pass) {\n     const bool short_debug = (short_pass == 1);\n \n     // Make the Get functions.\n-    const string sig = StrCat(\n+    const std::string sig = StrCat(\n         \"string \", short_debug ? \"ProtoShortDebugString\" : \"ProtoDebugString\",\n         \"(\\n    const \", GetQualifiedName(md), \"& msg)\");\n     SetOutput(&header_).Print(sig, \";\");\n@@ -652,7 +653,7 @@ void Generator::AppendDebugStringFunctions(const Descriptor& md) {\n   }\n \n   // Make the Append function.\n-  const string sig =\n+  const std::string sig =\n       StrCat(\"void AppendProtoDebugString(\\n\",\n              \"    ::tensorflow::strings::ProtoTextOutput* o,\\n    const \",\n              GetQualifiedName(md), \"& msg)\");\n@@ -703,7 +704,7 @@ void Generator::AppendMessageFunctions(const Descriptor& md) {\n void Generator::AddNamespaceToCurrentSection(absl::string_view package,\n                                              bool open) {\n   Print();\n-  std::vector<string> parts = {\"\"};\n+  std::vector<std::string> parts = {\"\"};\n   for (size_t i = 0; i < package.size(); ++i) {\n     if (package[i] == '.') {\n       parts.resize(parts.size() + 1);\n@@ -722,8 +723,9 @@ void Generator::AddNamespaceToCurrentSection(absl::string_view package,\n   }\n }\n \n-void Generator::AddHeadersToCurrentSection(const std::vector<string>& headers) {\n-  std::vector<string> sorted = headers;\n+void Generator::AddHeadersToCurrentSection(\n+    const std::vector<std::string>& headers) {\n+  std::vector<std::string> sorted = headers;\n   std::sort(sorted.begin(), sorted.end());\n   for (const auto& h : sorted) {\n     Print(\"#include \\\"\", h, \"\\\"\");\n@@ -783,7 +785,7 @@ void Generator::Generate(const FileDescriptor& fd) {\n   std::set<const Descriptor*> all_d;\n   GetAllFileDescriptorsFromFile(&fd, &all_fd, &all_d);\n \n-  std::vector<string> headers;\n+  std::vector<std::string> headers;\n \n   // Add header to header file.\n   SetOutput(&header_);\n@@ -862,8 +864,8 @@ void Generator::Generate(const FileDescriptor& fd) {\n \n }  // namespace\n \n-ProtoTextFunctionCode GetProtoTextFunctionCode(const FileDescriptor& fd,\n-                                               const string& tf_header_prefix) {\n+ProtoTextFunctionCode GetProtoTextFunctionCode(\n+    const FileDescriptor& fd, const std::string& tf_header_prefix) {\n   Generator gen(tf_header_prefix);\n   gen.Generate(fd);\n   return gen.code();"
        },
        {
            "sha": "edcf913b8c284c4cc6d89492daaf508086381179",
            "filename": "tensorflow/tools/proto_text/gen_proto_text_functions_lib.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib.h?ref=4d78e8088a85ffe515c78f9b9731459ba9286c3c",
            "patch": "@@ -22,9 +22,9 @@ limitations under the License.\n namespace tensorflow {\n \n struct ProtoTextFunctionCode {\n-  string header;       // for a file named proto_name + \".pb_text.h\"\n-  string header_impl;  // for a file named proto_name + \".pb_text-impl.h\"\n-  string cc;           // for a file named proto_name + \".pb_text.cc\"\n+  std::string header;       // for a file named proto_name + \".pb_text.h\"\n+  std::string header_impl;  // for a file named proto_name + \".pb_text-impl.h\"\n+  std::string cc;           // for a file named proto_name + \".pb_text.cc\"\n };\n \n // Returns the generated source code for a proto file descriptor.\n@@ -46,7 +46,7 @@ struct ProtoTextFunctionCode {\n //      in proto.\n ProtoTextFunctionCode GetProtoTextFunctionCode(\n     const tensorflow::protobuf::FileDescriptor& fd,\n-    const string& tf_header_prefix);\n+    const std::string& tf_header_prefix);\n \n }  // namespace tensorflow\n "
        },
        {
            "sha": "075922dc2be02016a3ee586d5a3d3e4fef9081c5",
            "filename": "tensorflow/tools/proto_text/gen_proto_text_functions_lib_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4d78e8088a85ffe515c78f9b9731459ba9286c3c/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Ftools%2Fproto_text%2Fgen_proto_text_functions_lib_test.cc?ref=4d78e8088a85ffe515c78f9b9731459ba9286c3c",
            "patch": "@@ -59,7 +59,7 @@ std::string PrintTextFormat(const tensorflow::protobuf::Message& message) {\n // new message using the generated parse function. Return the new message.\n template <typename T>\n T RoundtripParseProtoOrDie(const T& input, bool short_text) {\n-  const string s =\n+  const std::string s =\n       short_text ? PrintShortTextFormat(input) : PrintTextFormat(input);\n   T t;\n   EXPECT_TRUE(ProtoParseFromString(s, &t)) << \"Failed to parse \" << s;\n@@ -120,10 +120,10 @@ TEST(CreateProtoDebugStringLibTest, ValidSimpleTypes) {\n \n   // Max numeric values.\n   proto.Clear();\n-  proto.set_optional_int32(std::numeric_limits<int32>::max());\n+  proto.set_optional_int32(std::numeric_limits<int32_t>::max());\n   proto.set_optional_int64(std::numeric_limits<protobuf_int64>::max());\n-  proto.set_optional_uint32(std::numeric_limits<uint32>::max());\n-  proto.set_optional_uint64(std::numeric_limits<uint64>::max());\n+  proto.set_optional_uint32(std::numeric_limits<uint32_t>::max());\n+  proto.set_optional_uint64(std::numeric_limits<uint64_t>::max());\n   // TODO(b/67475677): Re-enable after resolving float precision issue\n   // proto.set_optional_float(std::numeric_limits<float>::max());\n   proto.set_optional_double(std::numeric_limits<double>::max());\n@@ -138,7 +138,7 @@ TEST(CreateProtoDebugStringLibTest, ValidSimpleTypes) {\n \n   // Lowest numeric values.\n   proto.Clear();\n-  proto.set_optional_int32(std::numeric_limits<int32>::lowest());\n+  proto.set_optional_int32(std::numeric_limits<int32_t>::lowest());\n   proto.set_optional_int64(std::numeric_limits<protobuf_int64>::lowest());\n   // TODO(b/67475677): Re-enable after resolving float precision issue\n   // proto.set_optional_float(std::numeric_limits<float>::lowest());\n@@ -361,14 +361,15 @@ TEST(CreateProtoDebugStringLibTest, RecursiveMessage) {\n }\n \n template <typename T>\n-T ParseProto(const string& value_text_proto) {\n+T ParseProto(const std::string& value_text_proto) {\n   T value;\n   EXPECT_TRUE(protobuf::TextFormat::ParseFromString(value_text_proto, &value))\n       << value_text_proto;\n   return value;\n }\n \n-TestAllTypes::NestedMessage ParseNestedMessage(const string& value_text_proto) {\n+TestAllTypes::NestedMessage ParseNestedMessage(\n+    const std::string& value_text_proto) {\n   return ParseProto<TestAllTypes::NestedMessage>(value_text_proto);\n }\n \n@@ -494,11 +495,11 @@ TEST(CreateProtoDebugStringLibTest, Enums) {\n   EXPECT_PARSE_FAILURE(\"optional_nested_enum: 'BAR'\");\n   EXPECT_PARSE_FAILURE(\"optional_nested_enum: \\\"BAR\\\" \");\n \n-  EXPECT_EQ(string(\"BAR\"),\n-            string(EnumName_TestAllTypes_NestedEnum(TestAllTypes::BAR)));\n+  EXPECT_EQ(std::string(\"BAR\"),\n+            std::string(EnumName_TestAllTypes_NestedEnum(TestAllTypes::BAR)));\n   // out of range - returns empty string (see NameOfEnum in proto library).\n-  EXPECT_EQ(string(\"\"), string(EnumName_TestAllTypes_NestedEnum(\n-                            static_cast<TestAllTypes_NestedEnum>(123))));\n+  EXPECT_EQ(std::string(\"\"), std::string(EnumName_TestAllTypes_NestedEnum(\n+                                 static_cast<TestAllTypes_NestedEnum>(123))));\n }\n \n TEST(CreateProtoDebugStringLibTest, Oneof) {"
        }
    ],
    "stats": {
        "total": 150,
        "additions": 78,
        "deletions": 72
    }
}