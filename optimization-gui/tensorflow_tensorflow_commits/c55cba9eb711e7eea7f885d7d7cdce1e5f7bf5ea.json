{
    "author": "jcai19",
    "message": "[XLA][Numerics][Hlo Value Tracking] Rename members in OriginalValueRecoveryTable\n\nThis renames replaced_original_array and replacing_original_array members of the data structure to old_original_array and new_original_array respectively for better clarity.\n\nPiperOrigin-RevId: 808629951",
    "sha": "c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea",
    "files": [
        {
            "sha": "c6027cf201c46ca9b8427a23ebf1eba994f8894b",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.cc",
            "status": "modified",
            "additions": 50,
            "deletions": 58,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc?ref=c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea",
            "patch": "@@ -1463,8 +1463,8 @@ std::string HloModule::OriginalValueRecoveryTable::ToString(\n     HloPrintOptions options) const {\n   std::string result;\n   for (const auto& p : GetOrderedHashMap(table_)) {\n-    const auto& replaced_original_array = p.first;\n-    const auto& replacing_original_array = p.second.first;\n+    const auto& old_original_array = p.first;\n+    const auto& new_original_array = p.second.first;\n     HloModule* recovery_module = p.second.second;\n     // Wraps the recovery module with double quotes so that it can be parsed as\n     // a string. This is to make sure it can be parsed as a standalone module\n@@ -1482,9 +1482,9 @@ std::string HloModule::OriginalValueRecoveryTable::ToString(\n                               .set_indent_amount(options.indent_amount() + 1)),\n                       \"\\n\", tab, \"\\\"\");\n     }\n-    absl::StrAppend(&result, tab, \"{\", replaced_original_array.ToString(),\n-                    \"} : {\", replacing_original_array.ToString(), \"}\",\n-                    recovery_module_string, \"\\n\");\n+    absl::StrAppend(&result, tab, \"{\", old_original_array.ToString(), \"} : {\",\n+                    new_original_array.ToString(), \"}\", recovery_module_string,\n+                    \"\\n\");\n   }\n   return result;\n }\n@@ -1493,14 +1493,12 @@ OriginalValueRecoveryTableProto HloModule::OriginalValueRecoveryTable::ToProto()\n     const {\n   OriginalValueRecoveryTableProto original_value_recovery_table_proto;\n   for (const auto& p : GetOrderedHashMap(table_)) {\n-    const auto& replaced_original_array = p.first;\n-    const auto& replacing_original_array = p.second.first;\n+    const auto& old_original_array = p.first;\n+    const auto& new_original_array = p.second.first;\n     HloModule* recovery_module = p.second.second;\n     auto* entry = original_value_recovery_table_proto.add_entries();\n-    *entry->mutable_replaced_original_array() =\n-        replaced_original_array.ToProto();\n-    *entry->mutable_replacing_original_array() =\n-        replacing_original_array.ToProto();\n+    *entry->mutable_old_original_array() = old_original_array.ToProto();\n+    *entry->mutable_new_original_array() = new_original_array.ToProto();\n     if (recovery_module) {\n       *entry->mutable_recovery_module() = recovery_module->ToProto();\n     }\n@@ -1515,10 +1513,10 @@ HloModule::OriginalValueRecoveryTable::FromProto(\n   OriginalValueRecoveryTable original_value_recovery_table;\n \n   for (const auto& entry : original_value_recovery_table_proto.entries()) {\n-    OriginalArray replaced_original_array =\n-                      OriginalArray::FromProto(entry.replaced_original_array()),\n-                  replacing_original_array = OriginalArray::FromProto(\n-                      entry.replacing_original_array());\n+    OriginalArray old_original_array =\n+                      OriginalArray::FromProto(entry.old_original_array()),\n+                  new_original_array =\n+                      OriginalArray::FromProto(entry.new_original_array());\n     std::unique_ptr<HloModule> recovery_module;\n     if (entry.has_recovery_module()) {\n       const HloModuleProto proto = entry.recovery_module();\n@@ -1528,8 +1526,8 @@ HloModule::OriginalValueRecoveryTable::FromProto(\n       TF_ASSIGN_OR_RETURN(recovery_module,\n                           HloModule::CreateFromProto(proto, config));\n     }\n-    original_value_recovery_table.table_[replaced_original_array] =\n-        std::make_pair(replacing_original_array, std::move(recovery_module));\n+    original_value_recovery_table.table_[old_original_array] =\n+        std::make_pair(new_original_array, std::move(recovery_module));\n   }\n   return original_value_recovery_table;\n }\n@@ -1559,27 +1557,24 @@ std::string GetOriginalValuePlaceholderInstructionName(\n }  // namespace\n \n void HloModule::OriginalValueRecoveryTable::AddRecoveryComputation(\n-    const HloInstruction* replaced_inst, HloInstruction* replacing_inst,\n+    const HloInstruction* old_inst, HloInstruction* new_inst,\n     std::function<std::optional<std::unique_ptr<HloModule>>(\n-        const ShapeIndex& index, const OriginalArray& replaced_original_array,\n-        const xla::Shape& replaced_array_shape,\n-        const xla::Shape& replacing_array_shape)>&&\n+        const ShapeIndex& index, const OriginalArray& old_original_array,\n+        const xla::Shape& old_array_shape, const xla::Shape& new_array_shape)>&&\n         build_recovery_computation) {\n-  CHECK(ShapeUtil::EqualStructure(replaced_inst->shape(),\n-                                  replacing_inst->shape()));\n-  std::shared_ptr<OriginalValue> replaced_original_value =\n-      replaced_inst->original_value();\n-  if (!replaced_original_value ||\n-      replaced_original_value->is_synthetic_call()) {\n+  CHECK(ShapeUtil::EqualStructure(old_inst->shape(), new_inst->shape()));\n+  std::shared_ptr<OriginalValue> old_original_value =\n+      old_inst->original_value();\n+  if (!old_original_value || old_original_value->is_synthetic_call()) {\n     return;\n   }\n-  if (replacing_inst->original_value() == nullptr) {\n-    replacing_inst->set_original_value(std::make_shared<OriginalValue>(\n-        TupleTree<std::optional<OriginalArray>>(replacing_inst->shape())));\n+  if (new_inst->original_value() == nullptr) {\n+    new_inst->set_original_value(std::make_shared<OriginalValue>(\n+        TupleTree<std::optional<OriginalArray>>(new_inst->shape())));\n   }\n-  for (const auto& [shape_index, replaced_original_array] :\n-       replaced_original_value->original_arrays()) {\n-    if (!replaced_original_array || table_.contains(*replaced_original_array)) {\n+  for (const auto& [shape_index, old_original_array] :\n+       old_original_value->original_arrays()) {\n+    if (!old_original_array || table_.contains(*old_original_array)) {\n       // If the replaced array is already tracked by the recovery table, we can\n       // ignore it since it is already handled by another path.\n       continue;\n@@ -1589,58 +1584,55 @@ void HloModule::OriginalValueRecoveryTable::AddRecoveryComputation(\n     std::optional<std::unique_ptr<HloModule>> recovery_computation(nullptr);\n     if (build_recovery_computation) {\n       recovery_computation = build_recovery_computation(\n-          shape_index, *replaced_original_array,\n-          ShapeUtil::GetSubshape(replaced_inst->shape(), shape_index),\n-          ShapeUtil::GetSubshape(replacing_inst->shape(), shape_index));\n+          shape_index, *old_original_array,\n+          ShapeUtil::GetSubshape(old_inst->shape(), shape_index),\n+          ShapeUtil::GetSubshape(new_inst->shape(), shape_index));\n     }\n     if (!recovery_computation) {\n       continue;\n     }\n-    std::optional<OriginalArray>* replacing_original_array =\n-        replacing_inst->original_value()->mutable_original_array(shape_index);\n+    std::optional<OriginalArray>* new_original_array =\n+        new_inst->original_value()->mutable_original_array(shape_index);\n     if (recovery_computation->get() == nullptr &&\n-        !replacing_original_array->has_value()) {\n+        !new_original_array->has_value()) {\n       // If the recovery computation is the identity computation and the\n       // replacing original array is not set, we can just propagate the replaced\n       // original array without setting any recovery computation.\n-      replacing_original_array->emplace(*replaced_original_array);\n+      new_original_array->emplace(*old_original_array);\n       continue;\n     }\n-    if (!*replacing_original_array) {\n-      replacing_original_array->emplace(\n+    if (!*new_original_array) {\n+      new_original_array->emplace(\n           OriginalArray{GetOriginalValuePlaceholderInstructionName(\n-                            replaced_original_array->instruction_name),\n+                            old_original_array->instruction_name),\n                         shape_index});\n     }\n-    table_.emplace(*replaced_original_array,\n-                   std::make_pair(**replacing_original_array,\n-                                  std::move(*recovery_computation)));\n+    table_.emplace(\n+        *old_original_array,\n+        std::make_pair(**new_original_array, std::move(*recovery_computation)));\n   }\n }\n \n void HloModule::OriginalValueRecoveryTable::BuildAndAddRecoveryComputation(\n-    const HloInstruction* replaced_inst, HloInstruction* replacing_inst,\n+    const HloInstruction* old_inst, HloInstruction* new_inst,\n     std::function<std::optional<HloInstruction*>(\n         xla::HloComputation::Builder& builder, const ShapeIndex& index,\n-        const OriginalArray& replaced_original_array,\n-        const xla::Shape& replaced_array_shape,\n-        const xla::Shape& replacing_array_shape)>&&\n+        const OriginalArray& old_original_array,\n+        const xla::Shape& old_array_shape, const xla::Shape& new_array_shape)>&&\n         build_recovery_computation) {\n   AddRecoveryComputation(\n-      replaced_inst, replacing_inst,\n-      [build_recovery_computation](const ShapeIndex& index,\n-                                   const OriginalArray& replaced_original_array,\n-                                   const xla::Shape& replaced_array_shape,\n-                                   const xla::Shape& replacing_array_shape)\n+      old_inst, new_inst,\n+      [build_recovery_computation](\n+          const ShapeIndex& index, const OriginalArray& old_original_array,\n+          const xla::Shape& old_array_shape, const xla::Shape& new_array_shape)\n           -> std::optional<std::unique_ptr<HloModule>> {\n         xla::HloComputation::Builder builder(\"recovery_computation\");\n         xla::HloModuleConfig config;\n         auto recovery_module =\n             std::make_unique<xla::HloModule>(\"recovery_module\", config);\n         std::optional<HloInstruction*> root_instruction =\n-            build_recovery_computation(builder, index, replaced_original_array,\n-                                       replaced_array_shape,\n-                                       replacing_array_shape);\n+            build_recovery_computation(builder, index, old_original_array,\n+                                       old_array_shape, new_array_shape);\n         if (!root_instruction) {\n           return std::nullopt;\n         }"
        },
        {
            "sha": "700f008656144989096dfb22fe8f9a60e143a119",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.h",
            "status": "modified",
            "additions": 29,
            "deletions": 31,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h?ref=c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea",
            "patch": "@@ -926,83 +926,81 @@ class HloModule {\n             original_value_recovery_table);\n \n     // Populates the original value recovery table for a transformation that\n-    // replaces `replaced_inst` with `replacing_inst`.\n+    // replaces `old_inst` with `new_inst`.\n     //\n     // This method facilitates tracking of \"original values\" across HLO passes.\n     // When an instruction is replaced, this method helps establish the link\n     // between the original values of the old instruction and the new one.\n     //\n     // It iterates through each `OriginalArray` associated with the\n-    // `replaced_inst`. For each, it invokes the `build_recovery_computation`\n+    // `old_inst`. For each, it invokes the `build_recovery_computation`\n     // callback to determine how to recover the original value. The callback can\n     // either provide a recovery computation (as an `HloModule`), indicate that\n-    // the original value can be directly propagated, or indicate that it cannot\n-    // be recovered. If the callback is not provided, the original value is\n-    // propagated by default. This is the same as if the callback always\n+    // the original value can be directly propagated, or that it cannot be\n+    // recovered. If the callback is not provided, the original value is\n+    // passed through unchanged. This is the same as if the callback always\n     // returns `nullptr` (see below).\n     //\n-    // Precondition: `replaced_inst` and `replacing_inst` must have shapes with\n+    // Precondition: `old_inst` and `new_inst` must have shapes with\n     // identical tuple structures.\n     //\n     // The `build_recovery_computation` callback has the following signature:\n     // `std::optional<std::unique_ptr<HloModule>>(\n     //     const ShapeIndex& index,\n-    //     const OriginalArray& replaced_original_array,\n-    //     const xla::Shape& replaced_array_shape,\n-    //     const xla::Shape& replacing_array_shape)`\n+    //     const OriginalArray& old_original_array,\n+    //     const xla::Shape& old_array_shape,\n+    //     const xla::Shape& new_array_shape)`\n     //\n-    // It is called for each `OriginalArray` in `replaced_inst` and should\n+    // It is called for each `OriginalArray` in `old_inst` and should\n     // return one of the following:\n     //\n     //  - A valid `std::unique_ptr<HloModule>`: This HLO module represents the\n     //    recovery computation. Its entry computation must take one parameter\n-    //    (the value corresponding to the `OriginalArray` in `replacing_inst`)\n-    //    and return the recovered value (which should match the value of the\n-    //    `OriginalArray` in `replaced_inst`). An entry will be added to the\n+    //    (the value corresponding to the `OriginalArray` in `new_inst`)\n+    //    and return the recovered value (which should produce the value of the\n+    //    `OriginalArray` in `old_inst`). An entry will be added to the\n     //    recovery table.\n     //\n     //  - `nullptr` (as a `std::unique_ptr<HloModule>`): This indicates that the\n-    //    original value is preserved identically.\n-    //    - If `replacing_inst` does not have an `OriginalArray` at this\n-    //      `ShapeIndex`, the `OriginalArray` from `replaced_inst` is directly\n+    //    original value should be passed through unchanged.\n+    //    - If `new_inst` does not have an `OriginalArray` at this\n+    //      `ShapeIndex`, the `OriginalArray` from `old_inst` is directly\n     //      propagated to it. No entry is added to the recovery table.\n-    //    - If `replacing_inst` already has an `OriginalArray`, an entry is\n+    //    - If `new_inst` already has an `OriginalArray`, an entry is\n     //      added to the table mapping the old `OriginalArray` to the new one\n     //      with a `nullptr` recovery module, signifying they are equivalent.\n     //\n     //  - `std::nullopt`: This indicates that the original value cannot be\n     //    recovered and should be dropped.\n     //\n     // This method will create `OriginalValue` and placeholder `OriginalArray`s\n-    // for `replacing_inst` if they don't already exist and a recovery is\n+    // for `new_inst` if they don't already exist and a recovery is\n     // established.\n     void AddRecoveryComputation(\n-        const HloInstruction* replaced_inst, HloInstruction* replacing_inst,\n+        const HloInstruction* old_inst, HloInstruction* new_inst,\n         std::function<std::optional<std::unique_ptr<HloModule>>(\n-            const ShapeIndex& index,\n-            const OriginalArray& replaced_original_array,\n-            const xla::Shape& replaced_array_shape,\n-            const xla::Shape& replacing_array_shape)>&&\n-            build_recovery_computation = nullptr);\n+            const ShapeIndex& index, const OriginalArray& old_original_array,\n+            const xla::Shape& old_array_shape,\n+            const xla::Shape& new_array_shape)>&& build_recovery_computation =\n+            nullptr);\n \n     // Similar to `AddRecoveryComputation`, but the callback is provided an\n     // HLO module builder so that caller can directly build the recovery\n     // computation with less boilerplate.\n     void BuildAndAddRecoveryComputation(\n-        const HloInstruction* replaced_inst, HloInstruction* replacing_inst,\n+        const HloInstruction* old_inst, HloInstruction* new_inst,\n         std::function<std::optional<HloInstruction*>(\n             xla::HloComputation::Builder& builder, const ShapeIndex& index,\n-            const OriginalArray& replaced_original_array,\n-            const xla::Shape& replaced_array_shape,\n-            const xla::Shape& replacing_array_shape)>&&\n-            build_recovery_computation);\n+            const OriginalArray& old_original_array,\n+            const xla::Shape& old_array_shape,\n+            const xla::Shape& new_array_shape)>&& build_recovery_computation);\n \n     bool empty() const { return table_.empty(); }\n \n-    void emplace(const OriginalArray& replaced_original_array,\n+    void emplace(const OriginalArray& old_original_array,\n                  std::pair<OriginalArray, std::unique_ptr<HloModule>>&&\n                      recovery_computation) {\n-      table_.emplace(replaced_original_array, std::move(recovery_computation));\n+      table_.emplace(old_original_array, std::move(recovery_computation));\n     }\n \n     iterator begin() { return table_.begin(); }"
        },
        {
            "sha": "f4452b51333e61849e3baeae81cb3a694daa76c4",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc?ref=c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea",
            "patch": "@@ -5268,14 +5268,12 @@ absl::Status AlgebraicSimplifierVisitor::HandleBroadcast(\n           .BuildAndAddRecoveryComputation(\n               operand, operand->mutable_operand(0),\n               [](xla::HloComputation::Builder& builder, const ShapeIndex& index,\n-                 const OriginalArray& replaced_original_array,\n-                 const xla::Shape& replaced_shape,\n-                 const xla::Shape& replacing_shape) {\n-                xla::HloInstruction* param =\n-                    builder.AddInstruction(xla::HloInstruction::CreateParameter(\n-                        0, replacing_shape, \"p\"));\n+                 const OriginalArray& old_original_array,\n+                 const xla::Shape& old_shape, const xla::Shape& new_shape) {\n+                xla::HloInstruction* param = builder.AddInstruction(\n+                    xla::HloInstruction::CreateParameter(0, new_shape, \"p\"));\n                 return builder.AddInstruction(\n-                    xla::HloInstruction::CreateReshape(replaced_shape, param));\n+                    xla::HloInstruction::CreateReshape(old_shape, param));\n               });\n       return ReplaceWithNewInstruction(\n           broadcast,"
        },
        {
            "sha": "6a8bf2aadec1dc394ef047c83d7f0a59ba168e3d",
            "filename": "third_party/xla/xla/service/hlo.proto",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fservice%2Fhlo.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fservice%2Fhlo.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo.proto?ref=c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea",
            "patch": "@@ -863,8 +863,8 @@ message HloPassMetadata {\n \n message OriginalValueRecoveryTableProto {\n   message Entry {\n-    OriginalArrayProto replaced_original_array = 1;\n-    OriginalArrayProto replacing_original_array = 2;\n+    OriginalArrayProto old_original_array = 1;\n+    OriginalArrayProto new_original_array = 2;\n     HloModuleProto recovery_module = 3;\n   }\n   repeated Entry entries = 1;"
        },
        {
            "sha": "c34168efa5c00c4ebe6ddb83346288984a71db54",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc?ref=c55cba9eb711e7eea7f885d7d7cdce1e5f7bf5ea",
            "patch": "@@ -6174,14 +6174,13 @@ void SpmdPartitioningVisitor::SetPartitionedHlo(\n     auto* module = const_cast<HloModule*>(hlo->parent()->parent());\n     module->mutable_original_value_recovery_table().AddRecoveryComputation(\n         hlo, partitioned_hlo.hlo(),\n-        [&](const ShapeIndex& index,\n-            const OriginalArray& replaced_original_array,\n-            const xla::Shape& replaced_array_shape,\n-            const xla::Shape& replacing_array_shape) {\n+        [&](const ShapeIndex& index, const OriginalArray& old_original_array,\n+            const xla::Shape& old_array_shape,\n+            const xla::Shape& new_array_shape) {\n           SpmdBuilder builder(\"recovery_computation\", nullptr);\n           auto* param =\n               builder.AddInstruction(xla::HloInstruction::CreateParameter(\n-                  0, replacing_array_shape, \"param\"));\n+                  0, new_array_shape, \"param\"));\n           if (sharding.IsTuple()) {\n             param->set_sharding(sharding.GetSubSharding(hlo->shape(), index));\n           } else {\n@@ -6203,7 +6202,7 @@ void SpmdPartitioningVisitor::SetPartitionedHlo(\n           partitioning_state.next_channel_id = &next_channel_id;\n           partitioning_state.reshard_cache = &reshard_cache;\n \n-          PartitionedHlo param_partitioned_hlo(param, replaced_array_shape,\n+          PartitionedHlo param_partitioned_hlo(param, old_array_shape,\n                                                partitioning_state);\n           // Creates computation to recover the partitioned value.\n           param_partitioned_hlo.Replicate();"
        }
    ],
    "stats": {
        "total": 195,
        "additions": 91,
        "deletions": 104
    }
}