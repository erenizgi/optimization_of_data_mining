{
    "author": "hyeontaek",
    "message": "[IFRT] Define utilities for `absl::Status` manipulation to use IFRT user contexts\n\nThis change introduces utilities for manipulating `absl::Status` to attach user\ncontexts to it.\n\nBased on a design discussion wiht junwhan@.\n\n* `AttachUserContextId`: Used when the (typically low-level) runtime knows a\nuser context ID to attach to an error.\n\n* `AttachUserContextRef`: Used by the IFRT implementation to attach a strong\nreference of `UserContextRef` to `absl::Status` so that it can be expendend\nwith `ExpandUserContexts` safely by the user.\n\n* `ReattachUserContextRefs`: Used by the IFRT implementation to ensure that the\ngiven `absl::Status` to have strong references to any user contexts previously\nattached using `AttachUserContextId` (or by serializing/deserializing\n`absl::Status`).\n\n* `ExpandUserContexts`: Used by IFRT users to make `absl::Status` to have the\nexpanded form of user contexts attached to it. Called when it is safe to do so,\ne.g., while holding Python GIL, for `jax::PyUserContext` that works best when\ncalled with GIL already held.\n\nPiperOrigin-RevId: 805477853",
    "sha": "523ac2126f944eefb0b36a46df0f85508ed19f2c",
    "files": [
        {
            "sha": "dfac08fd6af0167fbcd1e908263f046f9fe43dd5",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=523ac2126f944eefb0b36a46df0f85508ed19f2c",
            "patch": "@@ -1162,6 +1162,46 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"user_context_status_util\",\n+    srcs = [\"user_context_status_util.cc\"],\n+    hdrs = [\"user_context_status_util.h\"],\n+    visibility = internal_visibility([\n+        \":friends\",\n+        \":internal\",\n+        \":users\",\n+    ]),\n+    deps = [\n+        \":user_context\",\n+        \":user_context_registry\",\n+        \"//xla/tsl/platform:errors\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:cord\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"user_context_status_util_test\",\n+    srcs = [\"user_context_status_util_test.cc\"],\n+    deps = [\n+        \":user_context\",\n+        \":user_context_registry\",\n+        \":user_context_status_util\",\n+        \"//xla/tsl/concurrency:ref_count\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:status_to_from_proto\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:cord\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//llvm:Support\",\n+    ],\n+)\n+\n xla_cc_test(\n     name = \"custom_call_program_serdes_test\",\n     srcs = [\"custom_call_program_serdes_test.cc\"],"
        },
        {
            "sha": "d85bf48d3e771177ad7a322e5fdcffd5a150313e",
            "filename": "third_party/xla/xla/python/ifrt/user_context_status_util.cc",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util.cc?ref=523ac2126f944eefb0b36a46df0f85508ed19f2c",
            "patch": "@@ -0,0 +1,136 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt/user_context_status_util.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <utility>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/cord.h\"\n+#include \"absl/strings/numbers.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt/user_context_registry.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+namespace {\n+\n+constexpr absl::string_view kIfrtUserContextPayloadUrl =\n+    \"type.googleapis.com/ifrt.UserContext\";\n+\n+}  // namespace\n+\n+absl::Status AttachUserContextId(absl::Status status, UserContextId id) {\n+  if (status.ok()) {\n+    return status;\n+  }\n+  status.SetPayload(kIfrtUserContextPayloadUrl,\n+                    absl::Cord(absl::StrCat(id.value())));\n+  return status;\n+}\n+\n+absl::Status AttachUserContextRef(absl::Status status,\n+                                  UserContextRef user_context) {\n+  if (status.ok()) {\n+    return status;\n+  }\n+  auto user_context_id_str_holder =\n+      std::make_unique<std::string>(absl::StrCat(user_context->Id().value()));\n+  absl::string_view user_context_id_str_view = *user_context_id_str_holder;\n+  TrackedUserContextRef tracked_user_context =\n+      UserContextRegistry::Get().Register(std::move(user_context));\n+  status.SetPayload(\n+      kIfrtUserContextPayloadUrl,\n+      absl::MakeCordFromExternal(\n+          user_context_id_str_view,\n+          [user_context_id_str_holder = std::move(user_context_id_str_holder),\n+           tracked_user_context = std::move(tracked_user_context)]() {}));\n+  return status;\n+}\n+\n+absl::Status ReattachUserContextRefs(absl::Status status) {\n+  if (status.ok()) {\n+    return status;\n+  }\n+  std::optional<absl::Cord> payload =\n+      status.GetPayload(kIfrtUserContextPayloadUrl);\n+  if (!payload.has_value()) {\n+    return status;\n+  }\n+  uint64_t user_context_id;\n+  if (!absl::SimpleAtoi(payload->Flatten(), &user_context_id)) {\n+    return status;\n+  }\n+  TrackedUserContextRef tracked_user_context =\n+      UserContextRegistry::Get().Lookup(UserContextId(user_context_id));\n+  if (tracked_user_context == nullptr) {\n+    return status;\n+  }\n+  auto user_context_id_str_holder =\n+      std::make_unique<std::string>(payload->Flatten());\n+  absl::string_view user_context_id_str_view = *user_context_id_str_holder;\n+  status.SetPayload(\n+      kIfrtUserContextPayloadUrl,\n+      absl::MakeCordFromExternal(\n+          user_context_id_str_view,\n+          [user_context_id_str_holder = std::move(user_context_id_str_holder),\n+           tracked_user_context = std::move(tracked_user_context)]() {}));\n+  return status;\n+}\n+\n+absl::Status ExpandUserContexts(absl::Status status) {\n+  if (status.ok()) {\n+    return status;\n+  }\n+  std::optional<absl::Cord> payload =\n+      status.GetPayload(kIfrtUserContextPayloadUrl);\n+  if (!payload.has_value()) {\n+    return status;\n+  }\n+\n+  status.ErasePayload(kIfrtUserContextPayloadUrl);\n+\n+  uint64_t user_context_id;\n+  if (!absl::SimpleAtoi(payload->Flatten(), &user_context_id)) {\n+    tsl::errors::AppendToMessage(\n+        &status, \"\\n(failed to parse a user context ID: \", payload->Flatten(),\n+        \")\");\n+    return status;\n+  }\n+  TrackedUserContextRef user_context =\n+      UserContextRegistry::Get().Lookup(UserContextId(user_context_id));\n+  if (user_context == nullptr) {\n+    tsl::errors::AppendToMessage(\n+        &status, \"\\n(failed to find a user context for ID: \", user_context_id,\n+        \")\");\n+    return status;\n+  }\n+  tsl::errors::AppendToMessage(&status, \"\\n\",\n+                               user_context->user_context()->DebugString());\n+  return status;\n+}\n+\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "fa54c656d61e5c100e0f5bbf23c81d049a07f5dc",
            "filename": "third_party/xla/xla/python/ifrt/user_context_status_util.h",
            "status": "added",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util.h?ref=523ac2126f944eefb0b36a46df0f85508ed19f2c",
            "patch": "@@ -0,0 +1,85 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PYTHON_IFRT_USER_CONTEXT_STATUS_UTIL_H_\n+#define XLA_PYTHON_IFRT_USER_CONTEXT_STATUS_UTIL_H_\n+\n+#include \"absl/status/status.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+// Attaches a reference to a user context to the status payload. This is used\n+// when a user context ID is available, but `UserContextRef` is not available.\n+// This happens when only the ID can be plumbed, e.g., within a low-level\n+// runtime below IFRT.\n+//\n+// The low-level runtimes often cannot use this function directly because of\n+// layering constraint. Then, they may fork the implementation because the\n+// implementation does not rely on IFRT features.\n+//\n+// `status` may be OK. If so, this function call will return the original\n+// status as-is.\n+//\n+// If a user context was already attached to the status, it will be overwritten\n+// with the new user context.\n+absl::Status AttachUserContextId(absl::Status status, UserContextId id);\n+\n+// Attaches a reference to a user context to the status payload. As long as the\n+// status is alive, the attached user context will also be kept alive.\n+// This is used within IFRT implementations where it has a\n+// `UserContextRef` available to use.\n+//\n+// When the returned status is serialized and deserialized, the user context\n+// will be ignored, but its ID will be preserved, giving the same result of\n+// using `AttachUserContextId()`.\n+//\n+// `status` may be OK. If so, this function call will return the original\n+// status as-is.\n+//\n+// If a user context was already attached to the status, it will be overwritten\n+// with the new user context.\n+absl::Status AttachUserContextRef(absl::Status status,\n+                                  UserContextRef user_context);\n+\n+// Re-attaches any user contexts referenced by ID in the status payload if the\n+// user contexts are found in the `UserContextRegistry`. This is used when a\n+// status was originally updated with `AttachedUserContextId` or went through\n+// serialization and deserialization, and do not have `TrackedUserContextRef`s\n+// attached.\n+//\n+// This is expected to be called when an IFRT implementation receives a status\n+// with user context IDs from a low-level runtime, and wants to expand the user\n+// contexts on the same process.\n+//\n+// `status` may be OK. If so, this function call will return the original\n+// status as-is.\n+absl::Status ReattachUserContextRefs(absl::Status status);\n+\n+// Expands any user contexts attached to the status and appends them to the\n+// status message. This is used above IFRT, when the user knows when it is\n+// desirable to do the expansion (e.g., not on a scarce fiber and already\n+// holding Python GIL, in case the user context represents a Python traceback\n+// object).\n+//\n+// `status` may be OK. If so, this function call will return the original\n+// status as-is.\n+absl::Status ExpandUserContexts(absl::Status status);\n+\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_IFRT_USER_CONTEXT_STATUS_UTIL_H_"
        },
        {
            "sha": "e8f3d38f4f1df9f1a670939b98340dd51e132dc7",
            "filename": "third_party/xla/xla/python/ifrt/user_context_status_util_test.cc",
            "status": "added",
            "additions": 267,
            "deletions": 0,
            "changes": 267,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/523ac2126f944eefb0b36a46df0f85508ed19f2c/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_status_util_test.cc?ref=523ac2126f944eefb0b36a46df0f85508ed19f2c",
            "patch": "@@ -0,0 +1,267 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt/user_context_status_util.h\"\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <utility>\n+\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/cord.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt/user_context_registry.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/status_to_from_proto.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace {\n+\n+constexpr absl::string_view kIfrtUserContextPayloadUrl =\n+    \"type.googleapis.com/ifrt.UserContext\";\n+\n+class TestUserContext : public llvm::RTTIExtends<TestUserContext, UserContext> {\n+ public:\n+  static UserContextRef Create(UserContextId id) {\n+    return tsl::TakeRef<TestUserContext>(new TestUserContext(id));\n+  }\n+\n+  uint64_t Fingerprint() const override { return id_.value(); }\n+  UserContextId Id() const override { return id_; }\n+\n+  std::string DebugString() const override {\n+    return absl::StrCat(\"user context \", id_.value());\n+  }\n+\n+  // No new `ID` is not defined because tests below do not exercise RTTI.\n+\n+ private:\n+  explicit TestUserContext(UserContextId id) : id_(id) {}\n+\n+  UserContextId id_;\n+};\n+\n+TEST(UserContextStatusUtilTest, AttachUserContextId) {\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+  const UserContextId kUserContextId(100);\n+  absl::Status new_status = AttachUserContextId(status, kUserContextId);\n+  EXPECT_EQ(new_status.code(), status.code());\n+  EXPECT_EQ(new_status.message(), status.message());\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_TRUE(payload.has_value());\n+  EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId.value()));\n+}\n+\n+TEST(UserContextStatusUtilTest, AttachUserContextIdOverExistingPayload) {\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+  const UserContextId kUserContextId1(100);\n+  absl::Status new_status = AttachUserContextId(status, kUserContextId1);\n+  const UserContextId kUserContextId2(200);\n+  new_status = AttachUserContextId(new_status, kUserContextId2);\n+\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_TRUE(payload.has_value());\n+  EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId2.value()));\n+}\n+\n+TEST(UserContextStatusUtilTest, NoOpToAttachUserContextIdToOkStatus) {\n+  absl::Status status;\n+  const UserContextId kUserContextId(100);\n+  absl::Status new_status = AttachUserContextId(status, kUserContextId);\n+  TF_EXPECT_OK(new_status);\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_FALSE(payload.has_value());\n+}\n+\n+TEST(UserContextStatusUtilTest, AttachUserContextRef) {\n+  const UserContextId kUserContextId(100);\n+  TrackedUserContextRef tracked_user_context =\n+      UserContextRegistry::Get().Register(\n+          TestUserContext::Create(kUserContextId));\n+  EXPECT_EQ(tracked_user_context.use_count(), 1);\n+\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+\n+  absl::Status new_status =\n+      AttachUserContextRef(status, tracked_user_context->user_context());\n+  EXPECT_EQ(new_status.code(), status.code());\n+  EXPECT_EQ(new_status.message(), status.message());\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_TRUE(payload.has_value());\n+  EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId.value()));\n+  EXPECT_EQ(tracked_user_context.use_count(), 2);\n+}\n+\n+TEST(UserContextStatusUtilTest, AttachUserContextRefOverExistingPayload) {\n+  const UserContextId kUserContextId1(100);\n+  TrackedUserContextRef tracked_user_context1 =\n+      UserContextRegistry::Get().Register(\n+          TestUserContext::Create(kUserContextId1));\n+  EXPECT_EQ(tracked_user_context1.use_count(), 1);\n+  const UserContextId kUserContextId2(200);\n+  TrackedUserContextRef tracked_user_context2 =\n+      UserContextRegistry::Get().Register(\n+          TestUserContext::Create(kUserContextId2));\n+  EXPECT_EQ(tracked_user_context2.use_count(), 1);\n+\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+\n+  absl::Status new_status =\n+      AttachUserContextRef(status, tracked_user_context1->user_context());\n+  new_status =\n+      AttachUserContextRef(new_status, tracked_user_context2->user_context());\n+\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_TRUE(payload.has_value());\n+  EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId2.value()));\n+  EXPECT_EQ(tracked_user_context1.use_count(), 1);\n+  EXPECT_EQ(tracked_user_context2.use_count(), 2);\n+}\n+\n+TEST(UserContextStatusUtilTest, NoOpToAttachUserContextRefToOkStatus) {\n+  absl::Status status;\n+  const UserContextId kUserContextId(100);\n+  absl::Status new_status =\n+      AttachUserContextRef(status, TestUserContext::Create(kUserContextId));\n+  TF_EXPECT_OK(new_status);\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_FALSE(payload.has_value());\n+}\n+\n+TEST(UserContextStatusUtilTest,\n+     ReattachUserContextRefsWithoutLiveUserContextRefs) {\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+  const UserContextId kUserContextId(100);\n+  status = AttachUserContextId(std::move(status), kUserContextId);\n+\n+  status = ReattachUserContextRefs(std::move(status));\n+  std::optional<absl::Cord> payload =\n+      status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_TRUE(payload.has_value());\n+  EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId.value()));\n+}\n+\n+TEST(UserContextStatusUtilTest,\n+     ReattachUserContextRefsWithLiveUserContextRefs) {\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+  const UserContextId kUserContextId(100);\n+  status = AttachUserContextId(std::move(status), kUserContextId);\n+\n+  TrackedUserContextRef tracked_user_context =\n+      UserContextRegistry::Get().Register(\n+          TestUserContext::Create(kUserContextId));\n+  EXPECT_EQ(tracked_user_context.use_count(), 1);\n+\n+  status = ReattachUserContextRefs(std::move(status));\n+  {\n+    std::optional<absl::Cord> payload =\n+        status.GetPayload(kIfrtUserContextPayloadUrl);\n+    ASSERT_TRUE(payload.has_value());\n+    EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId.value()));\n+    EXPECT_EQ(tracked_user_context.use_count(), 2);\n+  }\n+\n+  status = ReattachUserContextRefs(std::move(status));\n+  {\n+    std::optional<absl::Cord> payload =\n+        status.GetPayload(kIfrtUserContextPayloadUrl);\n+    ASSERT_TRUE(payload.has_value());\n+    EXPECT_EQ(payload->Flatten(), absl::StrCat(kUserContextId.value()));\n+    EXPECT_EQ(tracked_user_context.use_count(), 2);\n+  }\n+}\n+\n+TEST(UserContextStatusUtilTest,\n+     NoOpToReattachUserContextRefsWithLiveUserContextRefsToOkStatus) {\n+  absl::Status status;\n+  absl::Status new_status = ReattachUserContextRefs(std::move(status));\n+  TF_EXPECT_OK(new_status);\n+  std::optional<absl::Cord> payload =\n+      new_status.GetPayload(kIfrtUserContextPayloadUrl);\n+  ASSERT_FALSE(payload.has_value());\n+}\n+\n+TEST(UserContextStatusUtilTest, ExpandUserContexts) {\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+  const UserContextId kUserContextId(100);\n+  status = AttachUserContextId(std::move(status), kUserContextId);\n+\n+  {\n+    absl::Status expanded_status = ExpandUserContexts(status);\n+    EXPECT_EQ(expanded_status.message(),\n+              \"test\\n\\t\\n(failed to find a user context for ID: 100)\");\n+    std::optional<absl::Cord> payload =\n+        expanded_status.GetPayload(kIfrtUserContextPayloadUrl);\n+    EXPECT_FALSE(payload.has_value());\n+  }\n+\n+  {\n+    TrackedUserContextRef tracked_user_context =\n+        UserContextRegistry::Get().Register(\n+            TestUserContext::Create(kUserContextId));\n+    status = ReattachUserContextRefs(std::move(status));\n+  }\n+  {\n+    absl::Status expanded_status = ExpandUserContexts(status);\n+    EXPECT_EQ(expanded_status.message(), \"test\\n\\t\\nuser context 100\");\n+    std::optional<absl::Cord> payload =\n+        expanded_status.GetPayload(kIfrtUserContextPayloadUrl);\n+    EXPECT_FALSE(payload.has_value());\n+  }\n+}\n+\n+TEST(UserContextStatusUtilTest, RoundtripPreserveUserContextIds) {\n+  absl::Status status = absl::InvalidArgumentError(\"test\");\n+  const UserContextId kUserContextId(100);\n+  status = AttachUserContextRef(std::move(status),\n+                                TestUserContext::Create(kUserContextId));\n+  {\n+    absl::Status expanded_status = ExpandUserContexts(status);\n+    EXPECT_EQ(expanded_status.message(), \"test\\n\\t\\nuser context 100\");\n+  }\n+\n+  tensorflow::StatusProto status_proto = tsl::StatusToProto(status);\n+  status = tsl::StatusFromProto(status_proto);\n+  {\n+    absl::Status expanded_status = ExpandUserContexts(status);\n+    EXPECT_EQ(expanded_status.message(),\n+              \"test\\n\\t\\n(failed to find a user context for ID: 100)\");\n+  }\n+  {\n+    TrackedUserContextRef tracked_user_context =\n+        UserContextRegistry::Get().Register(\n+            TestUserContext::Create(kUserContextId));\n+    absl::Status expanded_status =\n+        ExpandUserContexts(ReattachUserContextRefs(std::move(status)));\n+    EXPECT_EQ(expanded_status.message(), \"test\\n\\t\\nuser context 100\");\n+  }\n+}\n+\n+}  // namespace\n+}  // namespace ifrt\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 528,
        "additions": 528,
        "deletions": 0
    }
}