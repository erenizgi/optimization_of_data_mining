{
    "author": "ZixuanJiang",
    "message": "Replace `ValidateSingleDimensionAxes` with `ValidateSpanOfAxes`.\n\nPiperOrigin-RevId: 828772325",
    "sha": "d8653999e2e4f8811cb6684f7ffebe55c20da592",
    "files": [
        {
            "sha": "db93523be26e90c7bba16d0a28d59563e6b8f5f1",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=d8653999e2e4f8811cb6684f7ffebe55c20da592",
            "patch": "@@ -188,6 +188,7 @@ cc_library(\n         \":tile_assignment\",\n         \"//xla:array\",\n         \"//xla:xla_data_proto_cc\",\n+        \"//xla/tsl/platform:errors\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/log:check\","
        },
        {
            "sha": "9797b607e50da4fbc9f637b58f380f6509d3dd55",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc?ref=d8653999e2e4f8811cb6684f7ffebe55c20da592",
            "patch": "@@ -33,6 +33,7 @@ limitations under the License.\n #include \"llvm/ADT/STLExtras.h\"\n #include \"xla/array.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n+#include \"xla/tsl/platform/errors.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla {\n@@ -286,7 +287,7 @@ bool AxisRef::CanCoexistWithoutOverlap(const AxisRef& other) const {\n   return max_pre_size % min_next_pre_size == 0;\n }\n \n-bool ValidateSpanOfAxes(absl::Span<const AxisRef> axes) {\n+bool AxesCanCoexistWithoutOverlap(absl::Span<const AxisRef> axes) {\n   for (int64_t i = 0; i < axes.size() - 1; ++i) {\n     for (int64_t j = i + 1; j < axes.size(); ++j) {\n       if (!axes[i].CanCoexistWithoutOverlap(axes[j])) {\n@@ -297,4 +298,15 @@ bool ValidateSpanOfAxes(absl::Span<const AxisRef> axes) {\n   return true;\n }\n \n+absl::Status ValidateSpanOfAxes(absl::Span<const AxisRef> axes,\n+                                const Mesh& mesh) {\n+  for (const AxisRef& axis : axes) {\n+    TF_RETURN_IF_ERROR(axis.Validate(mesh));\n+  }\n+  if (!AxesCanCoexistWithoutOverlap(axes)) {\n+    return absl::InvalidArgumentError(\"Axes cannot coexist or axes overlap.\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "88c10e0da4136f283ae31cacf422c50240569ad1",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=d8653999e2e4f8811cb6684f7ffebe55c20da592",
            "patch": "@@ -188,7 +188,12 @@ class AxisRef {\n   absl::Status ValidateAxisRef();\n };\n \n-bool ValidateSpanOfAxes(absl::Span<const AxisRef> axes);\n+bool AxesCanCoexistWithoutOverlap(absl::Span<const AxisRef> axes);\n+\n+// The span of axes is valid if (1) all axes are valid for the given mesh, and\n+// (2) the axes can coexist without overlap.\n+absl::Status ValidateSpanOfAxes(absl::Span<const AxisRef> axes,\n+                                const Mesh& mesh);\n \n }  // namespace xla\n "
        },
        {
            "sha": "518d07308258313375b77c0751939009b2fb0493",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 49,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=d8653999e2e4f8811cb6684f7ffebe55c20da592",
            "patch": "@@ -131,59 +131,14 @@ void HandleMultiAxisRefPerDimension(std::vector<AxisRef>& axes,\n   out_aggregate_axes = permuted_aggregate_axes;\n }\n \n-bool ValidateSingleDimensionAxes(int64_t dim, std::vector<AxisRef>& axes,\n-                                 const Mesh& mesh_) {\n-  // If there's only one axis, nothing to check.\n-  if (axes.size() <= 1) {\n-    return true;\n-  }\n-  // --- Step 1: Deduplication ---\n-  // If one is a \"full\" axis (no sub_axis_info), it subsumes all other AxisRefs\n-  // with sub_axis_info.\n-  for (const AxisRef& axis : axes) {\n-    if (!axis.sub_axis_info().has_value()) {\n-      LOG(WARNING) << \"MeshAxesReplicaGroupList: Redundant axis definition at \"\n-                      \"dimension: \"\n-                   << dim\n-                   << \". Keeping only the full axis: \" << axis.ToString(mesh_);\n-      axes = {axis};\n-      return true;\n-    }\n-  }\n-  // --- Step 2: Overlap Check ---\n-  // At this point, all remaining axes MUST have sub_axis_info().\n-  // Verify that the remaining multiple sub-axes do not overlap.\n-  CHECK(ValidateSpanOfAxes(axes))\n-      << \"Overlapping sub-axes detected in set of axes: \"\n-      << absl::StrJoin(axes, \",\",\n-                       [&mesh_](std::string* out, const AxisRef& axis) {\n-                         absl::StrAppend(out, axis.ToString(mesh_));\n-                       });\n-\n-  return true;  // Passed all checks for this dimension.\n-}\n-\n MeshAxesReplicaGroupList::MeshAxesReplicaGroupList(Mesh mesh,\n                                                    std::vector<AxisRef> axes)\n     : mesh_(std::move(mesh)), axes_(std::move(axes)) {\n-  if (num_devices_per_group() == 1) {\n-    LOG(ERROR) << \"MeshAxesReplicaGroupList: \" << ToString()\n-               << \" has only one device per replica group.\";\n-  }\n+  CHECK_GT(num_devices_per_group(), 1)\n+      << \"MeshAxesReplicaGroupList: \" << ToString()\n+      << \" has only one device per replica group.\";\n \n-  absl::flat_hash_set<int64_t> dimensions;\n-  absl::flat_hash_map<int64_t, std::vector<AxisRef>> dim_to_axes;\n-  for (const AxisRef& axis : axes_) {\n-    CHECK_OK(axis.Validate(mesh_));\n-    dim_to_axes[axis.mesh_axis_index()].push_back(axis);\n-    dimensions.insert(axis.mesh_axis_index());\n-  }\n-\n-  // Validate input AxisRefs.\n-  for (int64_t dim : dimensions) {\n-    std::vector<AxisRef>& axes = dim_to_axes[dim];\n-    CHECK(ValidateSingleDimensionAxes(dim, axes, mesh_));\n-  }\n+  CHECK_OK(ValidateSpanOfAxes(axes_, mesh_));\n }\n \n int64_t MeshAxesReplicaGroupList::num_replica_groups() const {"
        },
        {
            "sha": "28bc2d387e3deaba79bc43432b11c48ece9c8b2f",
            "filename": "third_party/xla/xla/hlo/ir/replica_group_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 19,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d8653999e2e4f8811cb6684f7ffebe55c20da592/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc?ref=d8653999e2e4f8811cb6684f7ffebe55c20da592",
            "patch": "@@ -45,11 +45,9 @@ CollectiveDeviceListProto CreateDeviceListProto(\n TEST(MeshAxesReplicaGroupListTest, MaterializedReplicaGroups) {\n   Mesh mesh_xy({2, 2}, {\"x\", \"y\"});\n \n-  MeshAxesReplicaGroupList replica_group_none(mesh_xy, {});\n-  std::vector<std::vector<int64_t>> expected_replica_groups_none = {\n-      {0}, {1}, {2}, {3}};\n-  EXPECT_EQ(replica_group_none.flattened_replica_groups(),\n-            expected_replica_groups_none);\n+  EXPECT_DEATH(\n+      { MeshAxesReplicaGroupList replica_group_none(mesh_xy, {}); },\n+      \"has only one device per replica group\");\n \n   MeshAxesReplicaGroupList replica_group_x(mesh_xy, {AxisRef(0)});\n   std::vector<std::vector<int64_t>> expected_replica_groups_x = {{0, 2},\n@@ -264,11 +262,6 @@ TEST(MeshAxesReplicaGroupListTest, NumReplicaGroups) {\n   EXPECT_EQ(replica_group_across_a.num_devices_per_group(), 3);\n   EXPECT_EQ(replica_group_across_b.num_replica_groups(), 3);\n   EXPECT_EQ(replica_group_across_b.num_devices_per_group(), 5);\n-\n-  Mesh no_axes({2, 3, 5}, {\"p1\", \"p2\", \"p3\"});\n-  MeshAxesReplicaGroupList replica_group_across_no_axes(no_axes, /*axes=*/{});\n-  EXPECT_EQ(replica_group_across_no_axes.num_replica_groups(), 2 * 3 * 5);\n-  EXPECT_EQ(replica_group_across_no_axes.num_devices_per_group(), 1);\n }\n \n TEST(MeshAxesReplicaGroupListTest, ValidateSubAxesCoexistenceCheck) {\n@@ -284,7 +277,7 @@ TEST(MeshAxesReplicaGroupListTest, ValidateSubAxesCoexistenceCheck) {\n         MeshAxesReplicaGroupList overlapping_subaxes(\n             overlap_mesh, {AxisRef(0, {6, 5}), AxisRef(0, {10, 3})});\n       },\n-      \"Overlapping sub-axes\");\n+      \"Axes cannot coexist or axes overlap.\");\n }\n \n TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n@@ -319,8 +312,6 @@ TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n   // No subaxes and iota device assignment.\n   Mesh mesh_uvw({10, 12, 15}, {\"u\", \"v\", \"w\"});\n-  MeshAxesReplicaGroupList replica_group_across_none(mesh_uvw, {});\n-  EXPECT_EQ(replica_group_across_none.ToString(), \"@mesh<u=10,v=12,w=15> {}\");\n   MeshAxesReplicaGroupList replica_group_across_uv(mesh_uvw,\n                                                    {AxisRef(0), AxisRef(1)});\n   EXPECT_EQ(replica_group_across_uv.ToString(), \"@mesh<u=10,v=12,w=15> {u,v}\");\n@@ -330,9 +321,6 @@ TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n       TileAssignment(/*dims=*/{2, 4, 4, 2}, /*reshape_dims=*/{1, 4, 1, 16},\n                      /*transpose_perm=*/{2, 3, 0, 1}),\n       {\"a\", \"b\", \"c\", \"d\"});\n-  MeshAxesReplicaGroupList rg_abcd_across_none(mesh_abcd, {});\n-  EXPECT_EQ(rg_abcd_across_none.ToString(),\n-            \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {}\");\n   MeshAxesReplicaGroupList rg_abcd_across_multiple_axes_and_subaxes(\n       mesh_abcd, {AxisRef(0), AxisRef(1, {1, 2}), AxisRef(3)});\n   EXPECT_EQ(rg_abcd_across_multiple_axes_and_subaxes.ToString(),\n@@ -343,9 +331,6 @@ TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n   array.Reshape({10});\n   TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n   Mesh mesh_ooo(tile_assignment, {\"ooo\"});\n-  MeshAxesReplicaGroupList rg_ooo_across_none(mesh_ooo, {});\n-  EXPECT_EQ(rg_ooo_across_none.ToString(),\n-            \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {}\");\n   MeshAxesReplicaGroupList rg_ooo_across_ooo_5_2(mesh_ooo,\n                                                  {AxisRef(0, {5, 2})});\n   EXPECT_EQ(rg_ooo_across_ooo_5_2.ToString(),"
        }
    ],
    "stats": {
        "total": 98,
        "additions": 28,
        "deletions": 70
    }
}