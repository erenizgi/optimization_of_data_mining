{
    "author": "tensorflower-gardener",
    "message": "Use reuse semantics instead of copy semantics when calling DisassembleIntoSingleDeviceArrays, since disassemble always aliases.\n\nUse copy semantics instead of reuse semantics when calling CopyToHostBuffer, since copy to host always copies.\n\nPiperOrigin-RevId: 825815935",
    "sha": "512f1e48cb37029dc164857588ff55046c04f9f5",
    "files": [
        {
            "sha": "c55275a8acb82f4822eeecf23772f308633fecf9",
            "filename": "third_party/xla/xla/python/ifrt/array_impl_test_lib.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/512f1e48cb37029dc164857588ff55046c04f9f5/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/512f1e48cb37029dc164857588ff55046c04f9f5/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc?ref=512f1e48cb37029dc164857588ff55046c04f9f5",
            "patch": "@@ -462,7 +462,7 @@ TEST(ArrayImplTest, MakeArrayFromHostBufferReplicated) {\n \n   TF_ASSERT_OK_AND_ASSIGN(auto single_device_arrays,\n                           array->DisassembleIntoSingleDeviceArrays(\n-                              ArrayCopySemantics::kAlwaysCopy,\n+                              ArrayCopySemantics::kReuseInput,\n                               SingleDeviceShardSemantics::kAddressableShards));\n   ASSERT_EQ(single_device_arrays.size(), devices.size());\n   for (int i = 0; i < single_device_arrays.size(); ++i) {\n@@ -547,7 +547,7 @@ TEST(ArrayImplTest, MakeArraysFromHostBufferShardsAndCopyToHostBuffer) {\n     TF_ASSERT_OK_AND_ASSIGN(\n         auto single_device_arrays,\n         arrays[i]->DisassembleIntoSingleDeviceArrays(\n-            ArrayCopySemantics::kAlwaysCopy,\n+            ArrayCopySemantics::kReuseInput,\n             SingleDeviceShardSemantics::kAddressableShards));\n     ASSERT_EQ(single_device_arrays.size(), devices.size());\n     for (int j = 0; j < single_device_arrays.size(); ++j) {\n@@ -845,7 +845,7 @@ TEST(ArrayImplTest,\n     TF_ASSERT_OK_AND_ASSIGN(\n         auto single_device_arrays,\n         arrays[i]->DisassembleIntoSingleDeviceArrays(\n-            ArrayCopySemantics::kAlwaysCopy,\n+            ArrayCopySemantics::kReuseInput,\n             SingleDeviceShardSemantics::kAddressableShards));\n     ASSERT_EQ(single_device_arrays.size(), devices.size());\n     for (int j = 0; j < single_device_arrays.size(); ++j) {\n@@ -904,7 +904,7 @@ TEST(ArrayImplTest, HostBufferRoundTripAllMemoryKinds) {\n     std::vector<float> new_data(6);\n     tsl::Future<> future = array->CopyToHostBuffer(\n         static_cast<void*>(new_data.data()), /*byte_strides=*/std::nullopt,\n-        ArrayCopySemantics::kReuseInput);\n+        ArrayCopySemantics::kAlwaysCopy);\n     TF_ASSERT_OK(future.Await());\n     EXPECT_THAT(new_data, ElementsAreArray(data));\n   }\n@@ -1124,7 +1124,7 @@ TEST(ArrayImplTest, AssembleAndDisassembleArray) {\n     TF_ASSERT_OK_AND_ASSIGN(\n         auto single_device_arrays,\n         assembled_array->DisassembleIntoSingleDeviceArrays(\n-            ArrayCopySemantics::kAlwaysCopy,\n+            ArrayCopySemantics::kReuseInput,\n             SingleDeviceShardSemantics::kAddressableShards));\n \n     ASSERT_THAT(single_device_arrays, SizeIs(2));\n@@ -1180,7 +1180,7 @@ TEST(ArrayImplTest, AssembleAndDisassembleSingleDeviceArray) {\n \n   TF_ASSERT_OK_AND_ASSIGN(auto single_device_arrays,\n                           assembled_array->DisassembleIntoSingleDeviceArrays(\n-                              ArrayCopySemantics::kAlwaysCopy,\n+                              ArrayCopySemantics::kReuseInput,\n                               SingleDeviceShardSemantics::kAddressableShards));\n \n   ASSERT_THAT(single_device_arrays, SizeIs(1));\n@@ -1276,7 +1276,7 @@ TEST(ArrayImplTest, AssembleAndDisassembleNonAddressableArray) {\n     TF_ASSERT_OK_AND_ASSIGN(\n         auto single_device_arrays,\n         assembled_array->DisassembleIntoSingleDeviceArrays(\n-            ArrayCopySemantics::kAlwaysCopy,\n+            ArrayCopySemantics::kReuseInput,\n             SingleDeviceShardSemantics::kAddressableShards));\n \n     ASSERT_THAT(single_device_arrays, SizeIs(0));\n@@ -1351,7 +1351,7 @@ TEST(ArrayImplTest, CopyToDifferentDevice) {\n \n     TF_ASSERT_OK_AND_ASSIGN(\n         auto shards, arrays[i]->DisassembleIntoSingleDeviceArrays(\n-                         ArrayCopySemantics::kAlwaysCopy,\n+                         ArrayCopySemantics::kReuseInput,\n                          SingleDeviceShardSemantics::kAddressableShards));\n     for (const auto& shard : shards) {\n       std::vector<float> out_data(6);"
        },
        {
            "sha": "cb09f18213d9370c4ff79853d93a6e4834a2d8cc",
            "filename": "third_party/xla/xla/python/ifrt/test_util.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/512f1e48cb37029dc164857588ff55046c04f9f5/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ftest_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/512f1e48cb37029dc164857588ff55046c04f9f5/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ftest_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ftest_util.h?ref=512f1e48cb37029dc164857588ff55046c04f9f5",
            "patch": "@@ -68,7 +68,7 @@ void AssertPerShardData(\n               testing::ElementsAreArray(GetDeviceIds(expected_device_list)));\n   TF_ASSERT_OK_AND_ASSIGN(auto actual_per_shard_arrays,\n                           actual->DisassembleIntoSingleDeviceArrays(\n-                              ArrayCopySemantics::kAlwaysCopy,\n+                              ArrayCopySemantics::kReuseInput,\n                               SingleDeviceShardSemantics::kAddressableShards));\n   ASSERT_EQ(actual_per_shard_arrays.size(), expected_per_shard_data.size());\n   for (int i = 0; i < actual_per_shard_arrays.size(); ++i) {"
        },
        {
            "sha": "c9d64aac9c3622b39459c1ffefc1e6606462a8a6",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/512f1e48cb37029dc164857588ff55046c04f9f5/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/512f1e48cb37029dc164857588ff55046c04f9f5/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=512f1e48cb37029dc164857588ff55046c04f9f5",
            "patch": "@@ -1191,7 +1191,7 @@ IfrtBackend::HandleDisassembleIntoSingleDeviceArraysRequest(\n   // TODO(b/282757875): Consider other ArrayCopySemantics.\n   TF_ASSIGN_OR_RETURN(auto single_device_arrays,\n                       array->DisassembleIntoSingleDeviceArrays(\n-                          xla::ifrt::ArrayCopySemantics::kAlwaysCopy,\n+                          xla::ifrt::ArrayCopySemantics::kReuseInput,\n                           single_device_shard_semantics));\n \n   std::vector<uint64_t> response_handles ="
        }
    ],
    "stats": {
        "total": 20,
        "additions": 10,
        "deletions": 10
    }
}