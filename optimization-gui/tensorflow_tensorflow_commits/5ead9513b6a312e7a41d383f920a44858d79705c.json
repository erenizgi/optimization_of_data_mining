{
    "author": "ZixuanJiang",
    "message": "Refine divisibility checks in SPMD `PatternMatchMergeOrSplitSharding`.\n\nPiperOrigin-RevId: 798370221",
    "sha": "5ead9513b6a312e7a41d383f920a44858d79705c",
    "files": [
        {
            "sha": "6919d11f1440deb11465b7e3eeac89e1fd7bea59",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 24,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ead9513b6a312e7a41d383f920a44858d79705c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ead9513b6a312e7a41d383f920a44858d79705c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc?ref=5ead9513b6a312e7a41d383f920a44858d79705c",
            "patch": "@@ -2051,12 +2051,23 @@ PatternMatchMergeOrSplitSharding(const Shape& shape, const Shape& base_shape,\n \n   std::vector<int64_t> diff_index;\n   for (int64_t i = 0; i < target.TiledDataRank(); ++i) {\n-    if (source.tile_assignment().dim(i) != target.tile_assignment().dim(i)) {\n+    int64_t si = source.tile_assignment().dim(i);\n+    int64_t ti = target.tile_assignment().dim(i);\n+    if (si == ti) {\n+      continue;\n+    }\n+    if (ti == 1) {\n       diff_index.push_back(i);\n+      continue;\n     }\n-  }\n-  if (diff_index.size() < 2) {\n-    return std::nullopt;\n+    auto [min, max] = std::minmax(si, ti);\n+    if (max % min != 0) {\n+      continue;\n+    }\n+    if (CeilOfRatio(base_shape.dimensions(i), min) * min % max != 0) {\n+      continue;\n+    }\n+    diff_index.push_back(i);\n   }\n \n   // Iterate every pair of elements in diff_index.\n@@ -2086,38 +2097,20 @@ PatternMatchMergeOrSplitSharding(const Shape& shape, const Shape& base_shape,\n             // i is the dimension without size 1 in either source or target\n             // j is the dimension with size 1 in either source or target\n           }\n-          if (target.tile_assignment().dim(j) == 1) {\n-            // dim of size 1 is in the target\n-            if (shape.dimensions(i) % source.tile_assignment().dim(j) != 0) {\n-              continue;\n-            }\n-            new_dim_size = source.tile_assignment().dim(i);\n-          } else {\n-            // dim of size 1 is in the source\n-            if (base_shape.dimensions(i) % source.tile_assignment().dim(i) !=\n-                0) {\n-              continue;\n-            }\n-            new_dim_size = target.tile_assignment().dim(i);\n-          }\n+          new_dim_size = std::min(source.tile_assignment().dim(i),\n+                                  target.tile_assignment().dim(i));\n           break;\n         }\n         case 0: {\n           if (source.tile_assignment().dim(i) <\n               target.tile_assignment().dim(i)) {\n             std::swap(i, j);\n-            // After the swap, we always have the following.\n-            // source.tile_assignment().dim(i) > target.tile_assignment().dim(i)\n-            // source.tile_assignment().dim(j) < target.tile_assignment().dim(j)\n           }\n           if (source.tile_assignment().dim(i) !=\n               target.tile_assignment().dim(i) *\n                   target.tile_assignment().dim(j)) {\n             continue;\n           }\n-          if (base_shape.dimensions(i) % source.tile_assignment().dim(i) != 0) {\n-            continue;\n-          }\n           new_dim_size = target.tile_assignment().dim(i);\n           break;\n         }"
        }
    ],
    "stats": {
        "total": 41,
        "additions": 17,
        "deletions": 24
    }
}