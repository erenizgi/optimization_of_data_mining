{
    "author": "tensorflower-gardener",
    "message": "[XLA:GPU]: Add triton_xla.get_peer_ptr operation.\n\nThis operation allows to calculate an address on a peer device.\n\nPiperOrigin-RevId: 811271849",
    "sha": "ef9c73a29e776be6e724d34637d231d13738bf49",
    "files": [
        {
            "sha": "41b9fd3a080409ae72fff3b678d37c327d2abb12",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/ir/triton_xla_ops.td",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Fir%2Ftriton_xla_ops.td",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Fir%2Ftriton_xla_ops.td",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Fir%2Ftriton_xla_ops.td?ref=ef9c73a29e776be6e724d34637d231d13738bf49",
            "patch": "@@ -398,6 +398,29 @@ def TTXLA_GetRankOp : TTXLA_Op<\"get_rank\", [Pure]> {\n   let assemblyFormat = \"$metadata attr-dict `:` type($metadata) `->` type($result)\";\n }\n \n+def TTXLA_GetPeerPtrOp : TTXLA_Op<\"get_peer_ptr\", [Pure]> {\n+  let summary = [{\n+    Extract the pointer to the given symmetric memory `address` on the given\n+    `peer` device using the symmetric memory `metadata`.\n+    For this an operation first calculates an offset of the `address` to the\n+    current rank symmetric memory range, and the adds this offset to the \n+    symmetric memory range of the `peer` device.\n+  }];\n+  let arguments = (ins\n+    Arg<TT_PtrLike, \"\",\n+      [MemRead<GlobalMemory>]>:$address,\n+    I64:$peer_id,\n+    Arg<TT_PtrLike, \"\",\n+      [MemRead<GlobalMemory>]>:$metadata);\n+\n+  let results = (outs Arg<TT_PtrLike, \"\", [MemRead<GlobalMemory>]>:$result);\n+\n+  let assemblyFormat = [{\n+    $address `,` $peer_id `,` $metadata attr-dict `:`\n+    functional-type(operands, results)\n+  }];\n+}\n+\n \n #endif // XLA_BACKENDS_GPU_CODEGEN_TRITON_IR_TRITON_XLA_OPS_TD_\n "
        },
        {
            "sha": "73c166e0bb6449f5ee1b647a8258d4ce9be0c80e",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/transforms/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2FBUILD?ref=ef9c73a29e776be6e724d34637d231d13738bf49",
            "patch": "@@ -55,6 +55,7 @@ cc_library(\n         \"//xla/codegen:emitter_loc_op_builder\",\n         \"//xla/codegen/emitters/ir:xla\",\n         \"//xla/service/llvm_ir:llvm_util\",\n+        \"//xla/stream_executor/gpu:collective_kernel_metadata\",\n         \"//xla/stream_executor/gpu:tma_metadata\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log\","
        },
        {
            "sha": "55a7ec570939fddec29942ed96a076e362ae4f2f",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/transforms/tests/triton_xla_remote_access.mlir",
            "status": "modified",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftests%2Ftriton_xla_remote_access.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftests%2Ftriton_xla_remote_access.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftests%2Ftriton_xla_remote_access.mlir?ref=ef9c73a29e776be6e724d34637d231d13738bf49",
            "patch": "@@ -10,3 +10,44 @@ tt.func @get_rank(\n   %rank = triton_xla.get_rank %metadata : !tt.ptr<i64> -> i64\n   tt.return %rank : i64\n }\n+\n+tt.func @get_peer_ptr(\n+  %arg0: !tt.ptr<i64>, %peer_id: i64, %metadata: !tt.ptr<i64>\n+) -> !tt.ptr<i64> {\n+  // CHECK-NOT: triton_xla.get_peer_ptr\n+  // Offset to local_buffer_root_ptrs.\n+  // CHECK: %c72_i64 = arith.constant 72 : i64\n+\n+  // Byte size of a pointer.\n+  // CHECK-NEXT: %c8_i64 = arith.constant 8 : i64\n+\n+  // Load metadata->rank\n+  // CHECK-NEXT: %0 = tt.load %arg2 : !tt.ptr<i64>\n+\n+  // Calculate offset to current base pointer.\n+  // CHECK-NEXT: %1 = arith.muli %0, %c8_i64 : i64\n+\n+  // Load metadata->local_buffer_root_ptrs[metadata->rank].\n+  // CHECK-NEXT: %2 = arith.addi %1, %c72_i64 : i64\n+  // CHECK-NEXT: %3 = tt.addptr %arg2, %2 : !tt.ptr<i64>, i64\n+  // CHECK-NEXT: %4 = tt.load %3 : !tt.ptr<i64>\n+\n+  // Calculate offset to address.\n+  // CHECK-NEXT: %5 = tt.ptr_to_int %arg0 : !tt.ptr<i64> -> i64\n+  // CHECK-NEXT: %6 = arith.subi %5, %4 : i64\n+\n+  // Calculate offset to peer base pointer.\n+  // CHECK-NEXT: %7 = arith.muli %arg1, %c8_i64 : i64\n+  // CHECK-NEXT: %8 = arith.addi %7, %c72_i64 : i64\n+\n+  // Load metadata->local_buffer_root_ptrs[peer_id].\n+  // CHECK-NEXT: %9 = tt.addptr %arg2, %8 : !tt.ptr<i64>, i64\n+  // CHECK-NEXT: %10 = tt.load %9 : !tt.ptr<i64>\n+\n+  // Load metadata->local_buffer_root_ptrs[peer_id] + offset.\n+  // CHECK-NEXT: %11 = arith.addi %10, %6 : i64\n+  // CHECK-NEXT: %12 = tt.int_to_ptr %11 : i64 -> !tt.ptr<i64>\n+  // CHECK-NEXT: tt.return %12 : !tt.ptr<i64>\n+  %peer_ptr = triton_xla.get_peer_ptr %arg0, %peer_id, %metadata : (!tt.ptr<i64>, i64, !tt.ptr<i64>) -> !tt.ptr<i64>\n+  tt.return %peer_ptr : !tt.ptr<i64>\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "59814592786756e9dc2c051a9589403a5be144b8",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/transforms/triton_xla_lower_remote_access_pass.cc",
            "status": "modified",
            "additions": 95,
            "deletions": 14,
            "changes": 109,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftriton_xla_lower_remote_access_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef9c73a29e776be6e724d34637d231d13738bf49/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftriton_xla_lower_remote_access_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftriton_xla_lower_remote_access_pass.cc?ref=ef9c73a29e776be6e724d34637d231d13738bf49",
            "patch": "@@ -13,10 +13,14 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n+#include <cstddef>\n+#include <cstdint>\n #include <memory>\n #include <utility>\n \n+#include \"mlir/Dialect/Arith/IR/Arith.h\"\n #include \"mlir/IR/Builders.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/PatternMatch.h\"\n #include \"mlir/IR/Types.h\"\n #include \"mlir/IR/Value.h\"\n@@ -25,6 +29,7 @@ limitations under the License.\n #include \"mlir/Support/LogicalResult.h\"\n #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n #include \"xla/backends/gpu/codegen/triton/ir/triton_xla_ops.h\"\n+#include \"xla/stream_executor/gpu/collective_kernel_metadata.h\"\n #include \"triton/Dialect/Triton/IR/Dialect.h\"\n #include \"triton/Dialect/Triton/IR/Types.h\"\n \n@@ -34,38 +39,113 @@ namespace mlir::triton::xla {\n #include \"xla/backends/gpu/codegen/triton/transforms/passes.h.inc\"\n \n namespace {\n-LogicalResult LowerGetRankOp(GetRankOp get_rank, PatternRewriter& rewriter) {\n-  mlir::OpBuilder::InsertionGuard guard(rewriter);\n-  rewriter.setInsertionPoint(get_rank);\n \n+LogicalResult LowerGetRankOp(GetRankOp get_rank, PatternRewriter& rewriter) {\n   mlir::Value metadata = get_rank.getMetadata();\n-  auto metadata_type = dyn_cast<mlir::triton::PointerType>(metadata.getType());\n+  auto metadata_type = dyn_cast<PointerType>(metadata.getType());\n   if (!metadata_type) {\n     return rewriter.notifyMatchFailure(get_rank, \"Metadata is not a pointer\");\n   }\n \n-  mlir::Type expectedResultType = metadata_type.getPointeeType();\n-  if (get_rank->getResult(0).getType() != expectedResultType) {\n+  Type expected_result_type = metadata_type.getPointeeType();\n+  if (get_rank->getResult(0).getType() != expected_result_type) {\n     return rewriter.notifyMatchFailure(\n         get_rank, \"Call result type must match the pointer's element type\");\n   }\n \n   // The rank id is stored as a first element under the metadata pointer.\n-  // The structure of the metadata is defined in\n-  // `xla::gpu::CollectiveKernelMetadata`.\n-  mlir::Value loadOp = rewriter.create<mlir::triton::LoadOp>(\n-      get_rank.getLoc(), expectedResultType, metadata,\n+  Value loadOp = rewriter.create<LoadOp>(\n+      get_rank.getLoc(), expected_result_type, metadata,\n       /*mask=*/nullptr, /*other=*/nullptr, /*boundaryCheck=*/nullptr,\n       /*padding=*/nullptr,\n-      mlir::triton::CacheModifierAttr::get(get_rank.getContext(),\n-                                           mlir::triton::CacheModifier::NONE),\n-      mlir::triton::EvictionPolicyAttr::get(\n-          get_rank.getContext(), mlir::triton::EvictionPolicy::NORMAL),\n+      CacheModifierAttr::get(get_rank.getContext(), CacheModifier::NONE),\n+      EvictionPolicyAttr::get(get_rank.getContext(), EvictionPolicy::NORMAL),\n       /*isVolatile=*/rewriter.getBoolAttr(false));\n   rewriter.replaceOp(get_rank, loadOp);\n   return success();\n }\n \n+// The peer address should be computed as follows:\n+//\n+// offset = address - metadata->buffer_root_ptrs[metadata->rank].\n+// peer_address = metadata->buffer_root_ptrs[peer_id] + offset.\n+LogicalResult LowerGetPeerPtrOp(GetPeerPtrOp get_peer_ptr,\n+                                PatternRewriter& rewriter) {\n+  Value metadata = get_peer_ptr.getMetadata();\n+  auto metadata_type = dyn_cast<PointerType>(metadata.getType());\n+  if (!metadata_type) {\n+    return rewriter.notifyMatchFailure(get_peer_ptr,\n+                                       \"Metadata is not a pointer\");\n+  }\n+\n+  ImplicitLocOpBuilder builder(get_peer_ptr.getLoc(), rewriter);\n+  Value address = get_peer_ptr.getAddress();\n+  Value peer_id = get_peer_ptr.getPeerId();\n+  MLIRContext* ctx = rewriter.getContext();\n+\n+  // Pointer type.\n+  Type type_i64 = rewriter.getI64Type();\n+  Type result_type = get_peer_ptr.getResult().getType();\n+\n+  // Size of the pointer in bytes.\n+  Value pointer_size_bytes_const =\n+      builder.create<arith::ConstantIntOp>(type_i64, sizeof(int64_t));\n+\n+  // 1. Load metadata->rank.\n+  Value current_rank_load_op = builder.create<GetRankOp>(metadata);\n+\n+  // 2. Load metadata->local_buffer_root_ptrs[metadata->rank].\n+  Value local_buffers_ptrs_offset = builder.create<arith::ConstantIntOp>(\n+      type_i64, offsetof(CollectiveKernelMetadata, local_buffer_root_ptrs));\n+\n+  Value rank_offset =\n+      builder.create<arith::ExtUIOp>(type_i64, current_rank_load_op);\n+  Value current_rank_offset_bytes =\n+      builder.create<arith::MulIOp>(rank_offset, pointer_size_bytes_const);\n+  Value current_ptr_offset_bytes = builder.create<arith::AddIOp>(\n+      local_buffers_ptrs_offset, current_rank_offset_bytes);\n+\n+  Value current_range_address = builder.create<AddPtrOp>(\n+      metadata.getType(), metadata, current_ptr_offset_bytes);\n+\n+  Value current_range_address_value = builder.create<LoadOp>(\n+      type_i64, current_range_address,\n+      /*mask=*/nullptr, /*other=*/nullptr, /*boundaryCheck=*/nullptr,\n+      /*padding=*/nullptr, CacheModifierAttr::get(ctx, CacheModifier::NONE),\n+      EvictionPolicyAttr::get(ctx, EvictionPolicy::NORMAL),\n+      /*isVolatile=*/rewriter.getBoolAttr(false));\n+\n+  // 3. Calculate offset =\n+  //      address - metadata->local_buffer_root_ptrs[metadata->rank].\n+  Value current_range_address_int =\n+      builder.create<PtrToIntOp>(type_i64, address);\n+  Value offsetInt = builder.create<arith::SubIOp>(current_range_address_int,\n+                                                  current_range_address_value);\n+\n+  // 4. Load metadata->local_buffer_root_ptrs[peer_id].\n+  Value peer_index = builder.create<arith::ExtUIOp>(type_i64, peer_id);\n+  Value peer_index_offset_bytes =\n+      builder.create<arith::MulIOp>(peer_index, pointer_size_bytes_const);\n+  Value peer_range_offset_bytes = builder.create<arith::AddIOp>(\n+      local_buffers_ptrs_offset, peer_index_offset_bytes);\n+  Value peer_range_address = builder.create<AddPtrOp>(\n+      metadata.getType(), metadata, peer_range_offset_bytes);\n+\n+  Value peer_range_address_value = builder.create<LoadOp>(\n+      type_i64, peer_range_address,\n+      /*mask=*/nullptr, /*other=*/nullptr, /*boundaryCheck=*/nullptr,\n+      /*padding=*/nullptr, CacheModifierAttr::get(ctx, CacheModifier::NONE),\n+      EvictionPolicyAttr::get(ctx, EvictionPolicy::NORMAL),\n+      /*isVolatile=*/rewriter.getBoolAttr(false));\n+\n+  // 5. Calculate the result address: peerBasePtr + offset.\n+  Value result_int =\n+      builder.create<arith::AddIOp>(peer_range_address_value, offsetInt);\n+  Value result_address = builder.create<IntToPtrOp>(result_type, result_int);\n+  rewriter.replaceOp(get_peer_ptr, result_address);\n+  return success();\n+}\n+\n class TritonXLALowerRemoteAccessPass\n     : public impl::TritonXLALowerRemoteAccessPassBase<\n           TritonXLALowerRemoteAccessPass> {\n@@ -76,6 +156,7 @@ class TritonXLALowerRemoteAccessPass\n   void runOnOperation() override {\n     RewritePatternSet patterns(&getContext());\n     patterns.add(LowerGetRankOp);\n+    patterns.add(LowerGetPeerPtrOp);\n     if (failed(applyPatternsGreedily(getOperation(), std::move(patterns)))) {\n       return signalPassFailure();\n     }"
        }
    ],
    "stats": {
        "total": 174,
        "additions": 160,
        "deletions": 14
    }
}