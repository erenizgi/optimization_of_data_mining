{
    "author": "tensorflower-gardener",
    "message": "[IFRT Proxy]Create `ifrt_proxy::client::MpmdLoadedExecutable` which implements `MpmdLoadedExecutableInterface`.\n\nThis change creates the `MpmdLoadedExecutable` class in the IFRT proxy client to inherit from `xla::ifrt::MpmdLoadedExecutableInterface` and adds declarations/implementations for the MPMD-specific methods.\n\nPiperOrigin-RevId: 841145122",
    "sha": "974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
    "files": [
        {
            "sha": "852c0d29384626625402a50b0f0d4219878f2fd1",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -579,6 +579,7 @@ cc_library(\n         \":attribute_map\",\n         \":basic_device_list\",\n         \":ifrt\",\n+        \":mpmd_executable\",\n         \":user_context\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/hlo/ir:hlo\","
        },
        {
            "sha": "b71a27124a61df42a1cb3a3f5c0b391930f0838e",
            "filename": "third_party/xla/xla/python/ifrt/mock.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -48,6 +48,7 @@ char MockClient::ID = 0;\n char MockCompiler::ID = 0;\n char MockExecutable::ID = 0;\n char MockLoadedExecutable::ID = 0;\n+char MockMpmdLoadedExecutable::ID = 0;\n char MockHostCallback::ID = 0;\n char MockLoadedHostCallback::ID = 0;\n char MockSharding::ID = 0;"
        },
        {
            "sha": "6e73a68ba8091774ac7d15a44102b9069c6cac65",
            "filename": "third_party/xla/xla/python/ifrt/mock.h",
            "status": "modified",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -50,6 +50,7 @@ limitations under the License.\n #include \"xla/python/ifrt/index_domain.h\"\n #include \"xla/python/ifrt/layout.h\"\n #include \"xla/python/ifrt/memory.h\"\n+#include \"xla/python/ifrt/mpmd_executable.h\"\n #include \"xla/python/ifrt/program.h\"\n #include \"xla/python/ifrt/remap_plan.h\"\n #include \"xla/python/ifrt/shape.h\"\n@@ -359,6 +360,72 @@ class MockLoadedExecutable\n   static char ID;  // NOLINT\n };\n \n+class MockMpmdLoadedExecutable\n+    : public llvm::RTTIExtends<MockMpmdLoadedExecutable, MpmdLoadedExecutable> {\n+ public:\n+  MockMpmdLoadedExecutable() {\n+    static absl::NoDestructor<DeviceListRef> kEmptyDeviceList(\n+        BasicDeviceList::Create({}));\n+    ON_CALL(*this, devices()).WillByDefault(testing::Return(*kEmptyDeviceList));\n+  }\n+\n+  MOCK_METHOD((absl::StatusOr<absl::flat_hash_map<\n+                   std::string, absl::Span<xla::ifrt::Device* const>>>),\n+              GetMpmdAddressableDevices, (), (const, final));\n+  MOCK_METHOD(\n+      (absl::StatusOr<absl::flat_hash_map<std::string, CompiledMemoryStats>>),\n+      GetMpmdCompiledMemoryStats, (), (const, final));\n+  MOCK_METHOD((absl::StatusOr<\n+                  absl::flat_hash_map<std::string, xla::ifrt::AttributeMap>>),\n+              GetMpmdCostAnalysis, (), (const, final));\n+  MOCK_METHOD((absl::StatusOr<absl::flat_hash_map<\n+                   std::string, std::vector<std::shared_ptr<HloModule>>>>),\n+              GetMpmdHloModules, (), (const, final));\n+\n+  MOCK_METHOD(Client*, client, (), (const, final));\n+  MOCK_METHOD(absl::string_view, name, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::optional<std::string>>, Fingerprint, (),\n+              (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::unique_ptr<xla::ifrt::ExecutableVersion>>,\n+              executable_version, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::string>, Serialize, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::string>, GetHumanReadableProgramText, (),\n+              (const, final));\n+  MOCK_METHOD(UserContextRef, user_context, (), (const, final));\n+  MOCK_METHOD(tsl::Future<>, GetReadyFuture, (), (const, override));\n+  MOCK_METHOD(int, num_devices, (), (const, final));\n+  MOCK_METHOD(int64_t, SizeOfGeneratedCodeInBytes, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<CompiledMemoryStats>, GetCompiledMemoryStats, (),\n+              (const, final));\n+  MOCK_METHOD(std::optional<std::vector<xla::OpSharding>>,\n+              GetParameterShardings, (), (const, final));\n+  MOCK_METHOD(std::optional<std::vector<xla::OpSharding>>, GetOutputShardings,\n+              (), (const, final));\n+  MOCK_METHOD(\n+      absl::StatusOr<std::vector<std::shared_ptr<const xla::PjRtLayout>>>,\n+      GetParameterLayouts, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<absl::Span<const int>>, GetDonatableInputIndices,\n+              (), (const, final));\n+  MOCK_METHOD(\n+      absl::StatusOr<std::vector<std::shared_ptr<const xla::PjRtLayout>>>,\n+      GetOutputLayouts, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::vector<std::vector<absl::string_view>>>,\n+              GetOutputMemoryKinds, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<std::vector<std::shared_ptr<xla::HloModule>>>,\n+              GetHloModules, (), (const, final));\n+  MOCK_METHOD(absl::StatusOr<xla::ifrt::AttributeMap>, GetCostAnalysis, (),\n+              (const, final));\n+  MOCK_METHOD(absl::StatusOr<ExecuteResult>, Execute,\n+              (absl::Span<ArrayRef> args, const ExecuteOptions& options,\n+               std::optional<DeviceListRef> devices),\n+              (final));\n+  MOCK_METHOD(absl::Span<Device* const>, addressable_devices, (),\n+              (const, final));\n+  MOCK_METHOD(std::optional<DeviceListRef>, devices, (), (const, final));\n+\n+  static char ID;  // NOLINT\n+};\n+\n // host_callback.h\n \n class MockHostCallback final"
        },
        {
            "sha": "9892f3aebc5e624e673ee5f8ff2c701e3dc83eda",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/BUILD",
            "status": "modified",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -364,6 +364,7 @@ cc_library(\n     hdrs = [\"compiler.h\"],\n     deps = [\n         \":executable\",\n+        \":mpmd_executable\",\n         \":rpc_helper\",\n         \"//xla:debug_options_flags\",\n         \"//xla/pjrt:host_callback\",\n@@ -380,6 +381,8 @@ cc_library(\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:status_to_from_proto\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n@@ -672,3 +675,69 @@ cc_library(\n     hdrs = [\"global_flags.h\"],\n     deps = [if_google(\"//xla/python/ifrt_proxy/client/google:global_flags_google\", \":global_flags_oss\")],\n )\n+\n+cc_library(\n+    name = \"mpmd_executable\",\n+    srcs = [\"mpmd_executable.cc\"],\n+    hdrs = [\"mpmd_executable.h\"],\n+    deps = [\n+        \":executable\",\n+        \":rpc_helper\",\n+        \"//xla:xla_data_proto_cc\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/pjrt:pjrt_executable\",\n+        \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/python/ifrt\",\n+        \"//xla/python/ifrt:attribute_map\",\n+        \"//xla/python/ifrt:mpmd_executable\",\n+        \"//xla/python/ifrt:user_context\",\n+        \"//xla/python/ifrt:user_context_status_util\",\n+        \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n+        \"//xla/python/ifrt_proxy/common:versions\",\n+        \"//xla/tsl/concurrency:future\",\n+        \"//xla/tsl/concurrency:ref_count\",\n+        \"//xla/tsl/platform:status_to_from_proto\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@local_tsl//tsl/profiler/lib:traceme\",\n+    ],\n+)\n+\n+ifrt_proxy_cc_test(\n+    name = \"mpmd_executable_test\",\n+    srcs = [\"mpmd_executable_test.cc\"],\n+    deps = [\n+        \":client_session\",\n+        \":host_buffer\",\n+        \":mock_client_session\",\n+        \":mock_host_buffer\",\n+        \":mpmd_executable\",\n+        \":rpc_helper\",\n+        \":version\",\n+        \"//xla/pjrt:pjrt_executable\",\n+        \"//xla/python/ifrt\",\n+        \"//xla/python/ifrt:mock\",\n+        \"//xla/python/ifrt:serdes_version\",\n+        \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n+        \"//xla/python/ifrt_proxy/common:versions\",\n+        \"//xla/tsl/concurrency:future\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/util/proto:proto_matchers\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@com_google_protobuf//:protobuf\",\n+        \"@local_tsl//tsl/platform:protobuf\",\n+    ],\n+)"
        },
        {
            "sha": "c8746b7a187394c0eb6cfa7b497b953fdc89193e",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/compiler.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fcompiler.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -21,6 +21,8 @@\n #include <utility>\n #include <vector>\n \n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -38,6 +40,7 @@\n #include \"xla/python/ifrt/topology.h\"\n #include \"xla/python/ifrt/user_context_status_util.h\"\n #include \"xla/python/ifrt_proxy/client/executable.h\"\n+#include \"xla/python/ifrt_proxy/client/mpmd_executable.h\"\n #include \"xla/python/ifrt_proxy/client/rpc_helper.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n #include \"xla/python/ifrt_proxy/common/versions.h\"\n@@ -62,6 +65,7 @@ Compiler::Compiler(xla::ifrt::Client* client,\n absl::StatusOr<xla::ifrt::LoadedExecutableRef> Compiler::CompileAndLoad(\n     std::unique_ptr<Program> program,\n     std::unique_ptr<xla::ifrt::CompileOptions> options) {\n+  LOG(INFO) << \"yunnam_debug Compiler::CompileAndLoad\";\n   auto request = std::make_unique<CompileRequest>();\n   {\n     tsl::profiler::TraceMe traceme(\"IfrtProxyProgramSerialize\");\n@@ -139,6 +143,33 @@ absl::StatusOr<xla::ifrt::LoadedExecutableRef> Compiler::CompileAndLoad(\n                         client_->LookupDevice(DeviceId(device_id)));\n     addressable_devices.push_back(device);\n   }\n+  absl::StatusOr<\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>>\n+      mpmd_addressable_devices;\n+  bool is_mpmd_executable = false;\n+\n+  if (response->has_mpmd_addressable_devices()) {\n+    is_mpmd_executable = true;\n+    mpmd_addressable_devices =\n+        absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>();\n+    for (const auto& [name, devices_proto] :\n+         response->mpmd_addressable_devices().mpmd_addressable_devices()) {\n+      std::vector<xla::ifrt::Device*> current_devices;\n+      current_devices.reserve(devices_proto.mpmd_addressable_device_ids_size());\n+\n+      for (const auto& device_id :\n+           devices_proto.mpmd_addressable_device_ids()) {\n+        TF_ASSIGN_OR_RETURN(xla::ifrt::Device* const device,\n+                            client_->LookupDevice(DeviceId(device_id)));\n+        current_devices.push_back(device);\n+      }\n+      mpmd_addressable_devices->insert({name, std::move(current_devices)});\n+    }\n+  } else if (response->has_mpmd_addressable_devices_error()) {\n+    is_mpmd_executable = true;\n+    mpmd_addressable_devices = xla::ifrt::ReattachUserContextRefs(\n+        tsl::StatusFromProto(response->mpmd_addressable_devices_error()));\n+  }\n \n   absl::StatusOr<std::optional<std::string>> fingerprint;\n   switch (response->fingerprint_case()) {\n@@ -182,6 +213,15 @@ absl::StatusOr<xla::ifrt::LoadedExecutableRef> Compiler::CompileAndLoad(\n     TF_ASSIGN_OR_RETURN(device_list, client_->MakeDeviceList(devices));\n   }\n \n+  if (is_mpmd_executable) {\n+    return std::make_unique<MpmdLoadedExecutable>(\n+        client_, rpc_helper_, response->loaded_executable_handle(),\n+        response->name(), response->num_devices(), device_list,\n+        std::move(addressable_devices), std::move(mpmd_addressable_devices),\n+        std::move(fingerprint), std::move(ready_future),\n+        std::move(loaded_host_callbacks),\n+        std::move(loaded_host_callback_handles));\n+  }\n   return std::make_unique<LoadedExecutable>(\n       client_, rpc_helper_, response->loaded_executable_handle(),\n       response->name(), response->num_devices(), device_list,"
        },
        {
            "sha": "21c65490f156136ecc8ab17174753f2848d7b6b1",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/mpmd_executable.cc",
            "status": "added",
            "additions": 236,
            "deletions": 0,
            "changes": 236,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -0,0 +1,236 @@\n+// Copyright 2023 The OpenXLA Authors.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"xla/python/ifrt_proxy/client/mpmd_executable.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/pjrt/pjrt_executable.h\"\n+#include \"xla/python/ifrt/array.h\"\n+#include \"xla/python/ifrt/array_spec.h\"\n+#include \"xla/python/ifrt/attribute_map.h\"\n+#include \"xla/python/ifrt/client.h\"\n+#include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n+#include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/host_callback.h\"\n+#include \"xla/python/ifrt/user_context_status_util.h\"\n+#include \"xla/python/ifrt_proxy/client/executable.h\"\n+#include \"xla/python/ifrt_proxy/client/rpc_helper.h\"\n+#include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n+#include \"xla/python/ifrt_proxy/common/versions.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+#include \"xla/tsl/platform/status_to_from_proto.h\"\n+#include \"xla/xla_data.pb.h\"\n+#include \"tsl/profiler/lib/traceme.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace proxy {\n+\n+MpmdLoadedExecutable::MpmdLoadedExecutable(\n+    xla::ifrt::Client* client, std::shared_ptr<RpcHelper> rpc_helper,\n+    uint64_t handle, std::string name, int num_devices,\n+    std::optional<DeviceListRef> devices,\n+    std::vector<xla::ifrt::Device*> addressable_devices,\n+    absl::StatusOr<\n+        absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>>\n+        mpmd_addressable_devices,\n+    absl::StatusOr<std::optional<std::string>> fingerprint,\n+    tsl::Future<> ready_future,\n+    std::vector<tsl::RCReference<xla::ifrt::LoadedHostCallback>>\n+        loaded_host_callbacks,\n+    std::vector<uint64_t> loaded_host_callback_handles)\n+    : rpc_helper_(rpc_helper),\n+      handle_(handle),\n+      mpmd_addressable_devices_(std::move(mpmd_addressable_devices)) {\n+  loaded_executable_ = std::make_unique<ifrt::proxy::LoadedExecutable>(\n+      client, rpc_helper, handle, std::move(name), num_devices,\n+      std::move(devices), std::move(addressable_devices),\n+      std::move(fingerprint), std::move(ready_future),\n+      std::move(loaded_host_callbacks),\n+      std::move(loaded_host_callback_handles));\n+\n+  tsl::profiler::TraceMe traceme_ifrt_entrypoint(\n+      \"IfrtProxyEntrypointMpmdLoadedExecutableCreate\");\n+  auto [promise, future] =\n+      tsl::Future<std::shared_ptr<MpmdMetadata>>::MakePromise();\n+  mpmd_metadata_future_ = std::move(future);\n+\n+  auto req = std::make_unique<LoadedExecutableMpmdMetadataRequest>();\n+  req->set_mpmd_loaded_executable_handle(handle);\n+\n+  auto on_done =\n+      [promise = std::move(promise)](\n+          absl::StatusOr<std::shared_ptr<LoadedExecutableMpmdMetadataResponse>>\n+              response) mutable {\n+        if (!response.ok()) {\n+          LOG(ERROR) << \"LoadedExecutableMpmdMetadata: Got \"\n+                     << response.status();\n+          promise.Set(response.status());\n+          return;\n+        }\n+\n+        auto info = std::make_shared<MpmdMetadata>();\n+\n+        if (response.value()->has_mpmd_compiled_memory_stats()) {\n+          absl::flat_hash_map<std::string, xla::CompiledMemoryStats>\n+              mpmd_compiled_memory_stats;\n+          for (const auto& [name, stats_proto] :\n+               response.value()\n+                   ->mpmd_compiled_memory_stats()\n+                   .compiled_memory_stats()) {\n+            mpmd_compiled_memory_stats.insert(\n+                {name, xla::CompiledMemoryStats::FromProto(stats_proto)});\n+          }\n+          info->mpmd_compiled_memory_stats =\n+              std::move(mpmd_compiled_memory_stats);\n+        } else if (response.value()->has_mpmd_compiled_memory_stats_error()) {\n+          info->mpmd_compiled_memory_stats =\n+              xla::ifrt::ReattachUserContextRefs(tsl::StatusFromProto(\n+                  response.value()->mpmd_compiled_memory_stats_error()));\n+        } else {\n+          info->mpmd_compiled_memory_stats = absl::InternalError(\n+              \"IFRT Proxy server did not return mpmd compiled memory stats\");\n+        }\n+\n+        promise.Set(std::move(info));\n+      };\n+  rpc_helper_->LoadedExecutableMpmdMetadata(std::move(req))\n+      .OnReady(std::move(on_done));\n+}\n+\n+MpmdLoadedExecutable::~MpmdLoadedExecutable() {\n+  tsl::profiler::TraceMe traceme_ifrt_entrypoint(\n+      \"IfrtProxyEntrypointMpmdLoadedExecutableDestruct\");\n+}\n+\n+absl::StatusOr<\n+    absl::flat_hash_map<std::string, absl::Span<xla::ifrt::Device* const>>>\n+MpmdLoadedExecutable::GetMpmdAddressableDevices() const {\n+  if (rpc_helper_->protocol_version() <\n+      protocol_version::kMpmdLoadedExecutableMethods) {\n+    return absl::UnimplementedError(\n+        \"LoadedExecutable::GetMpmdAddressableDevices() is unimplemented by \"\n+        \"IFRT proxy\");\n+  }\n+\n+  if (!mpmd_addressable_devices_.ok()) {\n+    return mpmd_addressable_devices_.status();\n+  }\n+\n+  absl::flat_hash_map<std::string, absl::Span<xla::ifrt::Device* const>>\n+      devices_map_with_spans;\n+  devices_map_with_spans.reserve(mpmd_addressable_devices_->size());\n+  for (const auto& [mesh_name, device_vector] : *mpmd_addressable_devices_) {\n+    devices_map_with_spans[mesh_name] = absl::MakeConstSpan(device_vector);\n+  }\n+\n+  return devices_map_with_spans;\n+}\n+\n+absl::StatusOr<absl::flat_hash_map<std::string, xla::CompiledMemoryStats>>\n+MpmdLoadedExecutable::GetMpmdCompiledMemoryStats() const {\n+  if (rpc_helper_->protocol_version() <\n+      protocol_version::kMpmdLoadedExecutableMethods) {\n+    return absl::UnimplementedError(\n+        \"LoadedExecutable::GetMpmdCompiledMemoryStats() is unimplemented by \"\n+        \"IFRT proxy\");\n+  }\n+  auto info = mpmd_metadata_future_.Await();\n+  if (!info.ok()) {\n+    return info.status();\n+  }\n+  return (*info)->mpmd_compiled_memory_stats;\n+}\n+\n+absl::StatusOr<absl::flat_hash_map<\n+    std::string, std::vector<std::shared_ptr<xla::HloModule>>>>\n+MpmdLoadedExecutable::GetMpmdHloModules() const {\n+  return absl::UnimplementedError(\n+      \"IFRT service does not support LoadedExecutable::GetMpmdHloModules() \"\n+      \"since HloModule does not provide stable serialization\");\n+}\n+\n+absl::StatusOr<absl::flat_hash_map<std::string, xla::ifrt::AttributeMap>>\n+MpmdLoadedExecutable::GetMpmdCostAnalysis() const {\n+  if (rpc_helper_->protocol_version() <\n+      protocol_version::kMpmdLoadedExecutableMethods) {\n+    return absl::UnimplementedError(\n+        \"LoadedExecutable::GetMpmdCostAnalysis() is unimplemented by IFRT \"\n+        \"proxy\");\n+  }\n+  absl::MutexLock l(mpmd_cost_analysis_mu_);\n+  if (!mpmd_cost_analysis_response_.has_value()) {\n+    auto req = std::make_unique<LoadedExecutableMpmdCostAnalysisRequest>();\n+    req->set_loaded_executable_handle(handle_);\n+\n+    absl::StatusOr<std::shared_ptr<LoadedExecutableMpmdCostAnalysisResponse>>\n+        response = rpc_helper_->LoadedExecutableMpmdCostAnalysis(std::move(req))\n+                       .Await();\n+\n+    if (!response.ok()) {\n+      LOG(ERROR) << \"LoadedExecutableMpmdCostAnalysis: Got \"\n+                 << response.status();\n+      mpmd_cost_analysis_response_ = response.status();\n+      return *mpmd_cost_analysis_response_;\n+    }\n+    if (response.ok() && response.value()->has_attributes()) {\n+      absl::flat_hash_map<std::string, xla::ifrt::AttributeMap> temp_map;\n+      absl::Status status = absl::OkStatus();\n+      for (const auto& [name, attributes] :\n+           response.value()->attributes().attributes()) {\n+        absl::StatusOr<xla::ifrt::AttributeMap> attr_map =\n+            xla::ifrt::AttributeMap::FromProto(attributes);\n+        if (!attr_map.ok()) {\n+          LOG(ERROR) << \"Failed to deserialize AttributeMap for key '\" << name\n+                     << \"': \" << attr_map.status();\n+          status = attr_map.status();\n+          break;\n+        }\n+        temp_map.insert({name, *std::move(attr_map)});\n+      }\n+      if (!status.ok()) {\n+        mpmd_cost_analysis_response_ = status;\n+      } else {\n+        mpmd_cost_analysis_response_ = std::move(temp_map);\n+      }\n+    } else {\n+      mpmd_cost_analysis_response_ = xla::ifrt::ReattachUserContextRefs(\n+          tsl::StatusFromProto(response.value()->status()));\n+    }\n+  }\n+  return *mpmd_cost_analysis_response_;\n+}\n+\n+char MpmdLoadedExecutable::ID = 0;  // NOLINT\n+\n+}  // namespace proxy\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "7fce8e02ba73918d1800099aa6cef269aa631641",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/mpmd_executable.h",
            "status": "added",
            "additions": 187,
            "deletions": 0,
            "changes": 187,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable.h?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2025 The OpenXLA Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#ifndef XLA_PYTHON_IFRT_PROXY_CLIENT_MPMD_EXECUTABLE_H_\n+#define XLA_PYTHON_IFRT_PROXY_CLIENT_MPMD_EXECUTABLE_H_\n+\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/pjrt/pjrt_executable.h\"\n+#include \"xla/pjrt/pjrt_layout.h\"\n+#include \"xla/python/ifrt/array.h\"\n+#include \"xla/python/ifrt/attribute_map.h\"\n+#include \"xla/python/ifrt/client.h\"\n+#include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n+#include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/host_callback.h\"\n+#include \"xla/python/ifrt/mpmd_executable.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt_proxy/client/executable.h\"\n+#include \"xla/python/ifrt_proxy/client/rpc_helper.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace proxy {\n+\n+class MpmdLoadedExecutable final\n+    : public llvm::RTTIExtends<MpmdLoadedExecutable,\n+                               xla::ifrt::MpmdLoadedExecutable> {\n+ public:\n+  MpmdLoadedExecutable(\n+      xla::ifrt::Client* client, std::shared_ptr<RpcHelper> rpc_helper,\n+      uint64_t handle, std::string name, int num_devices,\n+      std::optional<DeviceListRef> devices,\n+      std::vector<xla::ifrt::Device*> addressable_devices,\n+      absl::StatusOr<\n+          absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>>\n+          mpmd_addressable_devices,\n+      absl::StatusOr<std::optional<std::string>> fingerprint,\n+      tsl::Future<> ready_future,\n+      std::vector<tsl::RCReference<xla::ifrt::LoadedHostCallback>>\n+          loaded_host_callbacks,\n+      std::vector<uint64_t> loaded_host_callback_handles);\n+\n+  ~MpmdLoadedExecutable() override;\n+\n+  xla::ifrt::Client* client() const override {\n+    return loaded_executable_->client();\n+  }\n+  absl::string_view name() const override { return loaded_executable_->name(); }\n+  absl::StatusOr<std::optional<std::string>> Fingerprint() const override {\n+    return loaded_executable_->Fingerprint();\n+  }\n+  absl::StatusOr<std::unique_ptr<xla::ifrt::ExecutableVersion>>\n+  executable_version() const override {\n+    return loaded_executable_->executable_version();\n+  }\n+  absl::StatusOr<std::string> Serialize() const override {\n+    return loaded_executable_->Serialize();\n+  }\n+  absl::StatusOr<std::string> GetHumanReadableProgramText() const override {\n+    return loaded_executable_->GetHumanReadableProgramText();\n+  }\n+  xla::ifrt::UserContextRef user_context() const override {\n+    return loaded_executable_->user_context();\n+  }\n+  tsl::Future<> GetReadyFuture() const override {\n+    return loaded_executable_->GetReadyFuture();\n+  }\n+\n+  int num_devices() const override { return loaded_executable_->num_devices(); }\n+  int64_t SizeOfGeneratedCodeInBytes() const override {\n+    return loaded_executable_->SizeOfGeneratedCodeInBytes();\n+  }\n+  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override {\n+    return loaded_executable_->GetCompiledMemoryStats();\n+  }\n+\n+  std::optional<std::vector<OpSharding>> GetParameterShardings()\n+      const override {\n+    return loaded_executable_->GetParameterShardings();\n+  }\n+  absl::StatusOr<absl::Span<const int>> GetDonatableInputIndices()\n+      const override {\n+    return loaded_executable_->GetDonatableInputIndices();\n+  }\n+  std::optional<std::vector<OpSharding>> GetOutputShardings() const override {\n+    return loaded_executable_->GetOutputShardings();\n+  }\n+  absl::StatusOr<std::vector<std::shared_ptr<const xla::PjRtLayout>>>\n+  GetParameterLayouts() const override {\n+    return loaded_executable_->GetParameterLayouts();\n+  }\n+  absl::StatusOr<std::vector<std::shared_ptr<const xla::PjRtLayout>>>\n+  GetOutputLayouts() const override {\n+    return loaded_executable_->GetOutputLayouts();\n+  }\n+  absl::StatusOr<std::vector<std::vector<absl::string_view>>>\n+  GetOutputMemoryKinds() const override {\n+    return loaded_executable_->GetOutputMemoryKinds();\n+  }\n+  absl::StatusOr<std::vector<std::shared_ptr<HloModule>>> GetHloModules()\n+      const override {\n+    return loaded_executable_->GetHloModules();\n+  }\n+\n+  absl::StatusOr<xla::ifrt::AttributeMap> GetCostAnalysis() const override {\n+    return loaded_executable_->GetCostAnalysis();\n+  }\n+\n+  absl::StatusOr<LoadedExecutable::ExecuteResult> Execute(\n+      absl::Span<xla::ifrt::ArrayRef> args, const ExecuteOptions& options,\n+      std::optional<xla::ifrt::DeviceListRef> devices) override {\n+    return loaded_executable_->Execute(args, options, devices);\n+  }\n+\n+  std::optional<DeviceListRef> devices() const override {\n+    return loaded_executable_->devices();\n+  };\n+  absl::Span<xla::ifrt::Device* const> addressable_devices() const override {\n+    return loaded_executable_->addressable_devices();\n+  }\n+\n+  absl::StatusOr<\n+      absl::flat_hash_map<std::string, absl::Span<xla::ifrt::Device* const>>>\n+  GetMpmdAddressableDevices() const override;\n+  absl::StatusOr<absl::flat_hash_map<std::string, xla::CompiledMemoryStats>>\n+  GetMpmdCompiledMemoryStats() const override;\n+  absl::StatusOr<absl::flat_hash_map<\n+      std::string, std::vector<std::shared_ptr<xla::HloModule>>>>\n+  GetMpmdHloModules() const override;\n+  absl::StatusOr<absl::flat_hash_map<std::string, xla::ifrt::AttributeMap>>\n+  GetMpmdCostAnalysis() const override;\n+\n+  static char ID;  // NOLINT\n+\n+ private:\n+  struct MpmdMetadata {\n+    absl::StatusOr<absl::flat_hash_map<std::string, CompiledMemoryStats>>\n+        mpmd_compiled_memory_stats;\n+  };\n+  std::shared_ptr<RpcHelper> rpc_helper_;\n+  const uint64_t handle_;\n+  mutable tsl::Future<std::shared_ptr<MpmdMetadata>> mpmd_metadata_future_;\n+  std::unique_ptr<ifrt::proxy::LoadedExecutable> loaded_executable_;\n+  const absl::StatusOr<\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>>\n+      mpmd_addressable_devices_;\n+  mutable absl::Mutex mpmd_cost_analysis_mu_;\n+  mutable std::optional<\n+      absl::StatusOr<absl::flat_hash_map<std::string, xla::ifrt::AttributeMap>>>\n+      mpmd_cost_analysis_response_ ABSL_GUARDED_BY(mpmd_cost_analysis_mu_);\n+};\n+\n+}  // namespace proxy\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_IFRT_PROXY_CLIENT_MPMD_EXECUTABLE_H_"
        },
        {
            "sha": "8c7f2222003b1296d84c5de8020a98ea53cfd933",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/mpmd_executable_test.cc",
            "status": "added",
            "additions": 406,
            "deletions": 0,
            "changes": 406,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fmpmd_executable_test.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -0,0 +1,406 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt_proxy/client/mpmd_executable.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/substitute.h\"\n+#include \"google/protobuf/text_format.h\"\n+#include \"xla/pjrt/pjrt_executable.h\"\n+#include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/mock.h\"\n+#include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/python/ifrt_proxy/client/client_session.h\"\n+#include \"xla/python/ifrt_proxy/client/host_buffer.h\"\n+#include \"xla/python/ifrt_proxy/client/mock_client_session.h\"\n+#include \"xla/python/ifrt_proxy/client/mock_host_buffer.h\"\n+#include \"xla/python/ifrt_proxy/client/rpc_helper.h\"\n+#include \"xla/python/ifrt_proxy/client/version.h\"\n+#include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n+#include \"xla/python/ifrt_proxy/common/versions.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/util/proto/proto_matchers.h\"\n+#include \"tsl/platform/protobuf.h\"  // IWYU pragma: keep\n+\n+using ::testing::_;\n+using ::testing::ElementsAre;\n+using ::testing::Eq;\n+using ::testing::HasSubstr;\n+using ::testing::Pair;\n+using ::testing::Pointee;\n+using ::testing::Return;\n+using ::testing::UnorderedElementsAre;\n+using ::tsl::proto_testing::EquivToProto;\n+using ::tsl::proto_testing::Partially;\n+using ::tsl::protobuf::TextFormat;\n+\n+namespace xla {\n+namespace ifrt {\n+namespace proxy {\n+namespace {\n+\n+IfrtProxyVersion Version(int protocol_version = kClientMaxVersion) {\n+  IfrtProxyVersion version;\n+  version.set_protocol_version(protocol_version);\n+  version.set_ifrt_serdes_version_number(\n+      SerDesVersion::current().version_number().value());\n+  return version;\n+}\n+\n+class MpmdLoadedExecutableTest : public ::testing::Test {\n+ protected:\n+  void SetUp() override {\n+    session_ = std::make_shared<MockClientSession>();\n+    rpc_helper_ = std::make_shared<RpcHelper>(Version(), session_);\n+\n+    host_buffer_store_ = std::make_shared<MockClientHostBufferStore>();\n+    rpc_helper_->set_host_buffer_store(host_buffer_store_);\n+\n+    ON_CALL(*session_, Enqueue(_))\n+        .WillByDefault(Return(tsl::Future<ClientSession::Response>(\n+            absl::InternalError(\"Request has no mock handlers\"))));\n+\n+    ON_CALL(device0_, Id()).WillByDefault(Return(DeviceId(0)));\n+    ON_CALL(device1_, Id()).WillByDefault(Return(DeviceId(1)));\n+  }\n+\n+  void ExpectBaseMetadataCall(uint64_t handle) {\n+    IfrtResponse default_response;\n+    EXPECT_CALL(*session_,\n+                Enqueue(Pointee(Partially(EquivToProto(absl::Substitute(\n+                    R\"pb(loaded_executable_metadata_request {\n+                           loaded_executable_handle: $0\n+                         })pb\",\n+                    handle))))))\n+        .WillOnce(MockClientSessionReturnResponse(default_response));\n+  }\n+\n+  void ExpectMpmdMetadataCall(uint64_t handle,\n+                              const IfrtResponse& mpmd_response) {\n+    IfrtResponse response = mpmd_response;\n+    response.mutable_response_metadata();\n+    if (!response.has_loaded_executable_mpmd_metadata_response()) {\n+      response.mutable_loaded_executable_mpmd_metadata_response();\n+    }\n+    EXPECT_CALL(*session_,\n+                Enqueue(Pointee(Partially(EquivToProto(absl::Substitute(\n+                    R\"pb(loaded_executable_mpmd_metadata_request {\n+                           mpmd_loaded_executable_handle: $0\n+                         })pb\",\n+                    handle))))))\n+        .WillOnce(MockClientSessionReturnResponse(response));\n+  }\n+\n+  void ExpectMpmdMetadataCall(uint64_t handle) {\n+    IfrtResponse default_response;\n+    default_response.mutable_response_metadata();\n+    default_response.mutable_loaded_executable_mpmd_metadata_response();\n+    ExpectMpmdMetadataCall(handle, default_response);\n+  }\n+\n+  void ExpectDestructorCall(uint64_t handle) {\n+    IfrtResponse destruct_response;\n+    EXPECT_CALL(*session_,\n+                Enqueue(Pointee(Partially(EquivToProto(absl::Substitute(\n+                    R\"pb(loaded_executable_destruct_request {\n+                           loaded_executable_handle: $0\n+                         })pb\",\n+                    handle))))))\n+        .WillOnce(MockClientSessionReturnResponse(destruct_response));\n+  }\n+\n+  void SetupConstructorExpectations(uint64_t handle,\n+                                    const IfrtResponse& mpmd_response) {\n+    ExpectBaseMetadataCall(handle);\n+    ExpectMpmdMetadataCall(handle, mpmd_response);\n+    ExpectDestructorCall(handle);\n+  }\n+\n+  void SetupConstructorExpectations(uint64_t handle) {\n+    IfrtResponse default_mpmd_response;\n+    default_mpmd_response.mutable_loaded_executable_mpmd_metadata_response();\n+    SetupConstructorExpectations(handle, default_mpmd_response);\n+  }\n+\n+  std::shared_ptr<MockClientSession> session_;\n+  std::shared_ptr<RpcHelper> rpc_helper_;\n+  std::shared_ptr<ClientHostBufferStore> host_buffer_store_;\n+  MockClient client_;\n+  MockDevice device0_;\n+  MockDevice device1_;\n+};\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdAddressableDevicesSuccess) {\n+  SetupConstructorExpectations(1234);\n+\n+  absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>> devices_map;\n+  devices_map[\"mesh0\"] = {&device0_};\n+  devices_map[\"mesh1\"] = {&device1_};\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/2, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/devices_map,\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto result, executable.GetMpmdAddressableDevices());\n+  EXPECT_THAT(result,\n+              UnorderedElementsAre(Pair(\"mesh0\", ElementsAre(&device0_)),\n+                                   Pair(\"mesh1\", ElementsAre(&device1_))));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdAddressableDevicesError) {\n+  SetupConstructorExpectations(1234);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/2, /*devices=*/{},\n+      /*addressable_devices=*/{},\n+      /*mpmd_addressable_devices=*/absl::InternalError(\"injected error\"),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(\n+      executable.GetMpmdAddressableDevices(),\n+      absl_testing::StatusIs(absl::StatusCode::kInternal, \"injected error\"));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdAddressableDevicesVersionCheck) {\n+  rpc_helper_ = std::make_shared<RpcHelper>(\n+      Version(protocol_version::kMpmdLoadedExecutableMethods - 1), session_);\n+  SetupConstructorExpectations(1234);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/2, /*devices=*/{},\n+      /*addressable_devices=*/{},\n+      /*mpmd_addressable_devices=*/absl::InternalError(\"injected error\"),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(executable.GetMpmdAddressableDevices(),\n+              absl_testing::StatusIs(absl::StatusCode::kUnimplemented,\n+                                     HasSubstr(\"GetMpmdAddressableDevices\")));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdCompiledMemoryStatsSuccess) {\n+  IfrtResponse response;\n+  ASSERT_TRUE(TextFormat::ParseFromString(\n+      R\"pb(\n+        loaded_executable_mpmd_metadata_response {\n+          mpmd_compiled_memory_stats {\n+            compiled_memory_stats {\n+              key: \"mesh0\"\n+              value { generated_code_size_in_bytes: 1024 }\n+            }\n+          }\n+        }\n+      )pb\",\n+      &response));\n+  SetupConstructorExpectations(1234, response);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto stats, executable.GetMpmdCompiledMemoryStats());\n+  EXPECT_THAT(stats, UnorderedElementsAre(Pair(\"mesh0\", _)));\n+  EXPECT_EQ(stats[\"mesh0\"].generated_code_size_in_bytes, 1024);\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdCompiledMemoryStatsRpcError) {\n+  ExpectBaseMetadataCall(1234);\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_mpmd_metadata_request {\n+                                    mpmd_loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .WillOnce(Return(tsl::Future<ClientSession::Response>(\n+          absl::UnavailableError(\"RPC failed\"))));\n+  ExpectDestructorCall(1234);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(executable.GetMpmdCompiledMemoryStats(),\n+              absl_testing::StatusIs(absl::StatusCode::kUnavailable,\n+                                     HasSubstr(\"RPC failed\")));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdCompiledMemoryStatsVersionCheck) {\n+  rpc_helper_ = std::make_shared<RpcHelper>(\n+      Version(protocol_version::kMpmdLoadedExecutableMethods - 1), session_);\n+  ExpectBaseMetadataCall(1234);\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_mpmd_metadata_request {\n+                                    mpmd_loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .WillOnce(Return(tsl::Future<ClientSession::Response>(\n+          absl::UnimplementedError(\"Should not be called\"))));\n+  ExpectDestructorCall(1234);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(executable.GetMpmdCompiledMemoryStats(),\n+              absl_testing::StatusIs(absl::StatusCode::kUnimplemented,\n+                                     HasSubstr(\"GetMpmdCompiledMemoryStats\")));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdHloModules) {\n+  SetupConstructorExpectations(1234);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(executable.GetMpmdHloModules(),\n+              absl_testing::StatusIs(absl::StatusCode::kUnimplemented));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdCostAnalysisSuccess) {\n+  SetupConstructorExpectations(1234);\n+\n+  IfrtResponse response;\n+  ASSERT_TRUE(TextFormat::ParseFromString(\n+      R\"pb(\n+        loaded_executable_mpmd_cost_analysis_response {\n+          attributes {\n+            attributes {\n+              key: \"mesh0\"\n+              value {\n+                attributes {\n+                  key: \"cost\"\n+                  value { float_value: 1.0 }\n+                }\n+              }\n+            }\n+          }\n+        }\n+      )pb\",\n+      &response));\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_mpmd_cost_analysis_request {\n+                                    loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .WillOnce(MockClientSessionReturnResponse(response));\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto result, executable.GetMpmdCostAnalysis());\n+  EXPECT_THAT(result, UnorderedElementsAre(Pair(\"mesh0\", _)));\n+  EXPECT_THAT(result.at(\"mesh0\").Get<float>(\"cost\"),\n+              absl_testing::IsOkAndHolds(Eq(1.0f)));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto result2, executable.GetMpmdCostAnalysis());\n+  EXPECT_THAT(result2, UnorderedElementsAre(Pair(\"mesh0\", _)));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdCostAnalysisRpcError) {\n+  SetupConstructorExpectations(1234);\n+\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_mpmd_cost_analysis_request {\n+                                    loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .WillOnce(Return(tsl::Future<ClientSession::Response>(\n+          absl::UnavailableError(\"RPC failed\"))));\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(executable.GetMpmdCostAnalysis(),\n+              absl_testing::StatusIs(absl::StatusCode::kUnavailable,\n+                                     HasSubstr(\"RPC failed\")));\n+}\n+\n+TEST_F(MpmdLoadedExecutableTest, GetMpmdCostAnalysisVersionCheck) {\n+  rpc_helper_ = std::make_shared<RpcHelper>(\n+      Version(protocol_version::kMpmdLoadedExecutableMethods - 1), session_);\n+  SetupConstructorExpectations(1234);\n+\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_mpmd_cost_analysis_request {\n+                                    loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .Times(0);\n+\n+  MpmdLoadedExecutable executable(\n+      &client_, rpc_helper_, /*handle=*/1234, /*name=*/\"mpmd_foo\",\n+      /*num_devices=*/1, /*devices=*/{},\n+      /*addressable_devices=*/{}, /*mpmd_addressable_devices=*/\n+      absl::flat_hash_map<std::string, std::vector<xla::ifrt::Device*>>(),\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  EXPECT_THAT(executable.GetMpmdCostAnalysis(),\n+              absl_testing::StatusIs(absl::StatusCode::kUnimplemented,\n+                                     HasSubstr(\"GetMpmdCostAnalysis\")));\n+}\n+\n+}  // namespace\n+}  // namespace proxy\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "bc728d0002e249f7bc9167bd1f8d7aee5d9d2e8e",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -471,7 +471,9 @@ RPC(FullyReplicatedShard, fully_replicated_shard);\n RPC(DeleteArray, delete_array);\n RPC(Compile, compile);\n RPC(LoadedExecutableMetadata, loaded_executable_metadata);\n+RPC(LoadedExecutableMpmdMetadata, loaded_executable_mpmd_metadata);\n RPC(LoadedExecutableCostAnalysis, loaded_executable_cost_analysis);\n+RPC(LoadedExecutableMpmdCostAnalysis, loaded_executable_mpmd_cost_analysis);\n RPC(LoadedExecutableHumanReadableProgramText,\n     loaded_executable_human_readable_program_text);\n RPC(LoadedExecutableExecute, loaded_executable_execute);"
        },
        {
            "sha": "47193c84f9abb5e5cecb9dbb3f9914b311efd70a",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.h?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -138,9 +138,15 @@ class RpcHelper {\n \n   ResponseFuture<LoadedExecutableMetadataResponse> LoadedExecutableMetadata(\n       std::unique_ptr<LoadedExecutableMetadataRequest> req);\n+  ResponseFuture<LoadedExecutableMpmdMetadataResponse>\n+  LoadedExecutableMpmdMetadata(\n+      std::unique_ptr<LoadedExecutableMpmdMetadataRequest> req);\n   ResponseFuture<LoadedExecutableCostAnalysisResponse>\n   LoadedExecutableCostAnalysis(\n       std::unique_ptr<LoadedExecutableCostAnalysisRequest> req);\n+  ResponseFuture<LoadedExecutableMpmdCostAnalysisResponse>\n+  LoadedExecutableMpmdCostAnalysis(\n+      std::unique_ptr<LoadedExecutableMpmdCostAnalysisRequest> req);\n   ResponseFuture<LoadedExecutableHumanReadableProgramTextResponse>\n   LoadedExecutableHumanReadableProgramText(\n       std::unique_ptr<LoadedExecutableHumanReadableProgramTextRequest> req);"
        },
        {
            "sha": "23894f6ea2938edfd54703c7614be97dde5d2ec0",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/VERSION.md",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FVERSION.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FVERSION.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FVERSION.md?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -116,3 +116,11 @@\n *   Added date: 2025-10-01\n *   Changes:\n     *   Added support for `LoadedExecutable::GetHumanReadableProgramText()`.\n+\n+## Version kMpmdLoadedExecutableMethods\n+\n+*   Added date: 2025-12-05\n+*   Changes:\n+    *   Added support for `MpmdLoadedExecutable::GetMpmdAddressableDevices()`.\n+    *   Added support for `MpmdLoadedExecutable::GetMpmdCompiledMemoryStats()`.\n+    *   Added support for `MpmdLoadedExecutable::GetMpmdCostAnalysis()`."
        },
        {
            "sha": "347a211608edbe5410c447eef6da19e2f18ce2b5",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/ifrt_service.proto",
            "status": "modified",
            "additions": 68,
            "deletions": 2,
            "changes": 70,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -37,7 +37,7 @@ message IfrtProxyVersion {\n   int32 ifrt_serdes_version_number = 2;\n }\n \n-// Next ID: 30.\n+// Next ID: 32.\n message IfrtRequest {\n   RequestMetadata request_metadata = 1;\n \n@@ -83,6 +83,12 @@ message IfrtRequest {\n         [deprecated = true];\n     LoadedExecutableDestructRequest loaded_executable_destruct_request = 18;\n \n+    // ===== MpmdLoadedExecutable =====\n+    LoadedExecutableMpmdMetadataRequest\n+        loaded_executable_mpmd_metadata_request = 30;\n+    LoadedExecutableMpmdCostAnalysisRequest\n+        loaded_executable_mpmd_cost_analysis_request = 31;\n+\n     // ===== LoadedHostCallback =====\n     LoadedHostCallbackPollRequest loaded_host_callback_poll_request = 21;\n     LoadedHostCallbackReturnRequest loaded_host_callback_return_request = 22;\n@@ -96,7 +102,7 @@ message IfrtRequest {\n   reserved 10;\n }\n \n-// Next ID: 30.\n+// Next ID: 32.\n message IfrtResponse {\n   ResponseMetadata response_metadata = 1;\n \n@@ -141,6 +147,12 @@ message IfrtResponse {\n         17;\n     LoadedExecutableDestructResponse loaded_executable_destruct_response = 18;\n \n+    // ===== MpmdLoadedExecutable =====\n+    LoadedExecutableMpmdMetadataResponse\n+        loaded_executable_mpmd_metadata_response = 30;\n+    LoadedExecutableMpmdCostAnalysisResponse\n+        loaded_executable_mpmd_cost_analysis_response = 31;\n+\n     // ===== LoadedHostCallback =====\n     LoadedHostCallbackPollResponse loaded_host_callback_poll_response = 21;\n     LoadedHostCallbackReturnResponse loaded_host_callback_return_response = 22;\n@@ -449,6 +461,12 @@ message CompileRequest {\n   repeated bytes host_callbacks = 3;\n }\n message CompileResponse {\n+  message MpmdDeviceList {\n+    repeated int32 mpmd_addressable_device_ids = 1;\n+  }\n+  message MpmdAddressableDevices {\n+    map<string, MpmdDeviceList> mpmd_addressable_devices = 1;\n+  }\n   fixed64 loaded_executable_handle = 1;\n   repeated fixed64 loaded_host_callback_handles = 8;\n \n@@ -458,6 +476,11 @@ message CompileResponse {\n   int32 num_devices = 3;\n   repeated int32 device_ids = 10;\n   repeated int32 addressable_device_ids = 5;\n+  oneof mpmd_addressable_devices_oneof {\n+    // MPMD addressable devices are only populated for MPMD executables.\n+    MpmdAddressableDevices mpmd_addressable_devices = 11;\n+    tensorflow.StatusProto mpmd_addressable_devices_error = 12;\n+  }\n   oneof fingerprint {\n     bytes fingerprint_value = 6;\n     tensorflow.StatusProto fingerprint_error = 7;\n@@ -492,6 +515,9 @@ message LoadedExecutableMetadataResponse {\n   message DonatedInputIndices {\n     repeated fixed32 donated_input_indices = 1;\n   }\n+  message MpmdCompiledMemoryStats {\n+    map<string, xla.CompiledMemoryStatsProto> compiled_memory_stats = 1;\n+  }\n \n   optional ShardingList parameter_shardings = 1;\n   optional ShardingList output_shardings = 2;\n@@ -517,6 +543,11 @@ message LoadedExecutableMetadataResponse {\n     tensorflow.StatusProto compiled_memory_stats_error = 11;\n   }\n \n+  oneof mpmd_compiled_memory_stats_oneof {\n+    MpmdCompiledMemoryStats mpmd_compiled_memory_stats = 13;\n+    tensorflow.StatusProto mpmd_compiled_memory_stats_error = 14;\n+  }\n+\n   int64 size_of_generated_code_in_bytes = 12;\n }\n \n@@ -597,6 +628,41 @@ message LoadedExecutableDestructRequest {\n }\n message LoadedExecutableDestructResponse {}\n \n+// ================ MpmdLoadedExecutable-related operations ================\n+\n+// Reads `MpmdLoadedExecutable`'s metadata that's typically available only after\n+// compilation. MpmdMetadata fields that are cheaper to calculate are available\n+// immediately as part of `CompileResponse`.\n+message LoadedExecutableMpmdMetadataRequest {\n+  fixed64 mpmd_loaded_executable_handle = 1;\n+}\n+message LoadedExecutableMpmdMetadataResponse {\n+  message MpmdCompiledMemoryStats {\n+    map<string, xla.CompiledMemoryStatsProto> compiled_memory_stats = 1;\n+  }\n+  oneof mpmd_compiled_memory_stats_oneof {\n+    MpmdCompiledMemoryStats mpmd_compiled_memory_stats = 1;\n+    tensorflow.StatusProto mpmd_compiled_memory_stats_error = 2;\n+  }\n+}\n+\n+// Queries the value of `MpmdLoadedExecutable::GetMpmdCostAnalysis()`. Separate\n+// from MpmdLoadedExecutableMetadataRequest since `GetMpmdCostAnalysis()` has\n+// non-trivial cost.\n+message LoadedExecutableMpmdCostAnalysisRequest {\n+  fixed64 loaded_executable_handle = 1;\n+}\n+\n+message LoadedExecutableMpmdCostAnalysisResponse {\n+  message MpmdAttributes {\n+    map<string, AttributeMapProto> attributes = 1;\n+  }\n+  oneof result {\n+    tensorflow.StatusProto status = 1;\n+    MpmdAttributes attributes = 2;\n+  }\n+}\n+\n // ================ LoadedHostCallback-related operations ================\n \n // Waits for the given host callback on the server to have any pending execution"
        },
        {
            "sha": "ec024d9cb18810141f45d57af92b7307b9db46f3",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/versions.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fversions.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fversions.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fversions.h?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -61,6 +61,11 @@ enum {\n   // GetHumanReadableProgramText in Executable.\n   kLoadedExecutableGetHumanReadableProgramText = 19,\n \n+  // kMpmdLoadedExecutableMethods implements MpmdLoadedExecutable methods such\n+  // as GetMpmdAddressableDevices, GetMpmdCompiledMemoryStats, and\n+  // GetMpmdCostAnalysis.\n+  kMpmdLoadedExecutableMethods = 20,\n+\n   // kSentiel is used to derive kCurrent below. Keep this as the last value of\n   // the enum.\n   kSentiel,"
        },
        {
            "sha": "340fa77003297768d612896ee368e9e1745f64e8",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -135,7 +135,9 @@ cc_library(\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/pjrt:pjrt_layout\",\n         \"//xla/python/ifrt\",\n+        \"//xla/python/ifrt:attribute_map\",\n         \"//xla/python/ifrt:basic_device_list\",\n+        \"//xla/python/ifrt:mpmd_executable\",\n         \"//xla/python/ifrt:program_serdes\",\n         \"//xla/python/ifrt:serdes\",\n         \"//xla/python/ifrt:serdes_any_version_accessor\",\n@@ -193,6 +195,7 @@ ifrt_proxy_cc_test(\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/hlo/testlib:test\",\n         \"//xla/pjrt:host_callback\",\n+        \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_layout\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:attribute_map\","
        },
        {
            "sha": "c6318aaa7f02d1775553af945f117944b95ce52f",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -49,6 +49,7 @@\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/array_spec.h\"\n+#include \"xla/python/ifrt/attribute_map.h\"\n #include \"xla/python/ifrt/basic_device_list.h\"\n #include \"xla/python/ifrt/compiler.h\"\n #include \"xla/python/ifrt/device.h\"\n@@ -57,6 +58,7 @@\n #include \"xla/python/ifrt/executable.h\"\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt/memory.h\"\n+#include \"xla/python/ifrt/mpmd_executable.h\"\n #include \"xla/python/ifrt/program.h\"\n #include \"xla/python/ifrt/program_serdes.h\"\n #include \"xla/python/ifrt/remap_plan.h\"\n@@ -615,8 +617,12 @@ tsl::Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n       return tsl::Future<Response>(HandleCompileRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kLoadedExecutableMetadataRequest:\n       return HandleLoadedExecutableMetadataRequest(std::move(request));\n+    case IfrtRequest::RequestCase::kLoadedExecutableMpmdMetadataRequest:\n+      return HandleLoadedExecutableMpmdMetadataRequest(std::move(request));\n     case IfrtRequest::RequestCase::kLoadedExecutableCostAnalysisRequest:\n       return HandleLoadedExecutableCostAnalysisRequest(std::move(request));\n+    case IfrtRequest::RequestCase::kLoadedExecutableMpmdCostAnalysisRequest:\n+      return HandleLoadedExecutableMpmdCostAnalysisRequest(std::move(request));\n     case IfrtRequest::RequestCase::\n         kLoadedExecutableHumanReadableProgramTextRequest:\n       return HandleLoadedExecutableHumanReadableProgramTextRequest(\n@@ -1460,6 +1466,28 @@ tsl::Future<BackendInterface::Response> IfrtBackend::HandleCompileRequest(\n     } else if (fingerprint->has_value()) {\n       compile_resp->set_fingerprint_value(std::move(fingerprint)->value());\n     }\n+    if (protocol_version() >= protocol_version::kMpmdLoadedExecutableMethods) {\n+      auto* mpmd_executable =\n+          llvm::dyn_cast<MpmdLoadedExecutable>(executable.get());\n+      // Only populate MPMD addressable devices for MPMD executables.\n+      if (mpmd_executable != nullptr) {\n+        auto mpmd_addressable_devices =\n+            mpmd_executable->GetMpmdAddressableDevices();\n+        if (mpmd_addressable_devices.ok()) {\n+          for (const auto& [name, devices] : *mpmd_addressable_devices) {\n+            auto& device_list =\n+                (*compile_resp->mutable_mpmd_addressable_devices()\n+                      ->mutable_mpmd_addressable_devices())[name];\n+            for (const auto* device : devices) {\n+              device_list.add_mpmd_addressable_device_ids(device->Id().value());\n+            }\n+          }\n+        } else {\n+          *compile_resp->mutable_mpmd_addressable_devices_error() =\n+              tsl::StatusToProto(mpmd_addressable_devices.status());\n+        }\n+      }\n+    }\n     // Register the ready future to `futures_`. Caller is expected to call\n     // `CheckFuture` exactly once to check for its status and erase it. In\n     // future, we may introduce separate mechanisms to remove futures from\n@@ -1602,6 +1630,60 @@ IfrtBackend::HandleLoadedExecutableMetadataRequest(\n   });\n }\n \n+tsl::Future<BackendInterface::Response>\n+IfrtBackend::HandleLoadedExecutableMpmdMetadataRequest(\n+    std::unique_ptr<IfrtRequest> request) {\n+  absl::StatusOr<std::shared_ptr<LoadedExecutableWithInfo>> executable_info =\n+      GetLoadedExecutable(request->loaded_executable_mpmd_metadata_request()\n+                              .mpmd_loaded_executable_handle());\n+\n+  if (!executable_info.ok()) {\n+    return tsl::Future<BackendInterface::Response>(executable_info.status());\n+  }\n+\n+  return AsyncExecute([executable_info = *std::move(executable_info),\n+                       request = std::shared_ptr<IfrtRequest>(\n+                           std::move(request))]() -> absl::StatusOr<Response> {\n+    std::unique_ptr<IfrtResponse> ifrt_resp =\n+        NewIfrtResponse(request->request_metadata().op_id());\n+    auto* metadata_resp =\n+        ifrt_resp->mutable_loaded_executable_mpmd_metadata_response();\n+\n+    const std::shared_ptr<xla::ifrt::LoadedExecutable>& base_executable =\n+        executable_info->executable;\n+    auto* mpmd_executable =\n+        llvm::dyn_cast<MpmdLoadedExecutable>(base_executable.get());\n+\n+    if (mpmd_executable == nullptr) {\n+      *metadata_resp->mutable_mpmd_compiled_memory_stats_error() =\n+          tsl::StatusToProto(absl::InvalidArgumentError(\n+              \"LoadedExecutable is not an MPMD executable\"));\n+    } else {\n+      auto mpmd_compiled_memory_stats =\n+          mpmd_executable->GetMpmdCompiledMemoryStats();\n+      if (mpmd_compiled_memory_stats.ok()) {\n+        for (const auto& [name, stats] : *mpmd_compiled_memory_stats) {\n+          xla::CompiledMemoryStatsProto& compiled_memory_stats =\n+              (*metadata_resp->mutable_mpmd_compiled_memory_stats()\n+                    ->mutable_compiled_memory_stats())[name];\n+          compiled_memory_stats = stats.ToProto();\n+          // `serialized_buffer_assignment` is a legacy field that is a\n+          // serialized proto that is undocumented, not semantically\n+          // well-defined across HLO versions, and is used only by one\n+          // Google-internal library as of Jul 2025. Do not send it across to\n+          // the proxy-client.\n+          compiled_memory_stats.clear_serialized_buffer_assignment();\n+        }\n+      } else {\n+        *metadata_resp->mutable_mpmd_compiled_memory_stats_error() =\n+            tsl::StatusToProto(mpmd_compiled_memory_stats.status());\n+      }\n+    }\n+\n+    return ifrt_resp;\n+  });\n+}\n+\n tsl::Future<BackendInterface::Response>\n IfrtBackend::HandleLoadedExecutableCostAnalysisRequest(\n     std::unique_ptr<IfrtRequest> request) {\n@@ -1628,6 +1710,48 @@ IfrtBackend::HandleLoadedExecutableCostAnalysisRequest(\n   return tsl::Future<BackendInterface::Response>(std::move(ifrt_resp));\n }\n \n+tsl::Future<BackendInterface::Response>\n+IfrtBackend::HandleLoadedExecutableMpmdCostAnalysisRequest(\n+    std::unique_ptr<IfrtRequest> request) {\n+  absl::StatusOr<std::shared_ptr<LoadedExecutableWithInfo>> executable_info =\n+      GetLoadedExecutable(\n+          request->loaded_executable_mpmd_cost_analysis_request()\n+              .loaded_executable_handle());\n+\n+  if (!executable_info.ok()) {\n+    return tsl::Future<BackendInterface::Response>(executable_info.status());\n+  }\n+\n+  const std::shared_ptr<xla::ifrt::LoadedExecutable>& base_executable =\n+      (*executable_info)->executable;\n+\n+  auto* mpmd_executable =\n+      llvm::dyn_cast<MpmdLoadedExecutable>(base_executable.get());\n+  if (mpmd_executable == nullptr) {\n+    return tsl::Future<BackendInterface::Response>(absl::InvalidArgumentError(\n+        \"LoadedExecutable is not an MPMD executable\"));\n+  }\n+\n+  absl::StatusOr<absl::flat_hash_map<std::string, xla::ifrt::AttributeMap>>\n+      mpmd_cost_analysis = mpmd_executable->GetMpmdCostAnalysis();\n+\n+  std::unique_ptr<IfrtResponse> ifrt_resp =\n+      NewIfrtResponse(request->request_metadata().op_id());\n+\n+  if (mpmd_cost_analysis.ok()) {\n+    auto* attributes_proto =\n+        ifrt_resp->mutable_loaded_executable_mpmd_cost_analysis_response()\n+            ->mutable_attributes();\n+    for (const auto& [key, value] : *mpmd_cost_analysis) {\n+      attributes_proto->mutable_attributes()->insert({key, value.ToProto()});\n+    }\n+  } else {\n+    *ifrt_resp->mutable_loaded_executable_mpmd_cost_analysis_response()\n+         ->mutable_status() = tsl::StatusToProto(mpmd_cost_analysis.status());\n+  }\n+  return tsl::Future<BackendInterface::Response>(std::move(ifrt_resp));\n+}\n+\n tsl::Future<BackendInterface::Response>\n IfrtBackend::HandleLoadedExecutableHumanReadableProgramTextRequest(\n     std::unique_ptr<IfrtRequest> request) {"
        },
        {
            "sha": "2ca312d98566fa1f0aef5f1e55a7a0a26e16f662",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -213,8 +213,12 @@ class IfrtBackend final : public BackendInterface {\n \n   tsl::Future<Response> HandleLoadedExecutableMetadataRequest(\n       std::unique_ptr<IfrtRequest> request);\n+  tsl::Future<Response> HandleLoadedExecutableMpmdMetadataRequest(\n+      std::unique_ptr<IfrtRequest> request);\n   tsl::Future<Response> HandleLoadedExecutableCostAnalysisRequest(\n       std::unique_ptr<IfrtRequest> request);\n+  tsl::Future<Response> HandleLoadedExecutableMpmdCostAnalysisRequest(\n+      std::unique_ptr<IfrtRequest> request);\n   tsl::Future<Response> HandleLoadedExecutableHumanReadableProgramTextRequest(\n       std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleLoadedExecutableExecuteRequest("
        },
        {
            "sha": "b6100518833f7b1d3e5a4d7acdc3c69607ff82d8",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend_test.cc",
            "status": "modified",
            "additions": 171,
            "deletions": 0,
            "changes": 171,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc?ref=974f8f4b73af5c0f3e1ee78b1a271b7e81ab5473",
            "patch": "@@ -46,6 +46,7 @@\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n #include \"xla/pjrt/host_callback.h\"\n+#include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/attribute_map.h\"\n@@ -1724,6 +1725,176 @@ TEST_P(IfrtBackendHandlerTest, GetDefaultPjRtLayoutSuccess) {\n   EXPECT_EQ(*layout_got, *kDefaultLayout);\n }\n \n+TEST_P(IfrtBackendHandlerTest, LoadedExecutableMetadataWithMpmd) {\n+  uint64_t handle;\n+  std::vector<xla::ifrt::Device*> mesh1_devices_backing = {\n+      mock_devices_[0].get()};\n+  {\n+    auto e = std::make_unique<MockMpmdLoadedExecutable>();\n+    MockMpmdLoadedExecutable* executable = e.get();\n+\n+    ON_CALL(*executable, name()).WillByDefault(Return(\"mpmd_exec\"));\n+    ON_CALL(*executable, num_devices()).WillByDefault(Return(1));\n+    auto device_list = BasicDeviceList::Create({});\n+    ON_CALL(*executable, devices()).WillByDefault(Return(device_list));\n+    ON_CALL(*executable, addressable_devices())\n+        .WillByDefault(Return(absl::Span<xla::ifrt::Device* const>({})));\n+    ON_CALL(*executable, Fingerprint())\n+        .WillByDefault(Return(\"mpmd_fingerprint\"));\n+    ON_CALL(*executable, GetReadyFuture())\n+        .WillByDefault(Return(tsl::Future<>(absl::OkStatus())));\n+\n+    ON_CALL(*executable, GetParameterShardings())\n+        .WillByDefault(Return(std::nullopt));\n+    ON_CALL(*executable, GetOutputShardings())\n+        .WillByDefault(Return(std::nullopt));\n+    ON_CALL(*executable, GetParameterLayouts())\n+        .WillByDefault(\n+            Return(std::vector<std::shared_ptr<const xla::PjRtLayout>>()));\n+    ON_CALL(*executable, GetOutputLayouts())\n+        .WillByDefault(\n+            Return(std::vector<std::shared_ptr<const xla::PjRtLayout>>()));\n+    ON_CALL(*executable, GetOutputMemoryKinds())\n+        .WillByDefault(Return(std::vector<std::vector<absl::string_view>>()));\n+    ON_CALL(*executable, GetDonatableInputIndices())\n+        .WillByDefault(Return(absl::Span<const int>()));\n+    ON_CALL(*executable, GetCompiledMemoryStats())\n+        .WillByDefault(Return(CompiledMemoryStats()));\n+    ON_CALL(*executable, SizeOfGeneratedCodeInBytes()).WillByDefault(Return(0));\n+\n+    absl::flat_hash_map<std::string, CompiledMemoryStats> stats;\n+    stats[\"mesh1\"] = CompiledMemoryStats();\n+    EXPECT_CALL(*executable, GetMpmdCompiledMemoryStats())\n+        .WillOnce(Return(stats));\n+\n+    TF_ASSERT_OK_AND_ASSIGN(CompileResponse response,\n+                            CompileTestLoadedExecutable(std::move(e)));\n+    handle = response.loaded_executable_handle();\n+  }\n+\n+  auto request = NewIfrtRequest(NewOpId());\n+  LoadedExecutableMpmdMetadataRequest* mpmd_metadata_request =\n+      request->mutable_loaded_executable_mpmd_metadata_request();\n+  mpmd_metadata_request->set_mpmd_loaded_executable_handle(handle);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::shared_ptr<IfrtResponse> response,\n+                          CallBackend(std::move(request)));\n+\n+  EXPECT_THAT(response, Pointee(Partially(EquivToProto(R\"pb(\n+                loaded_executable_mpmd_metadata_response {\n+                  mpmd_compiled_memory_stats {\n+                    compiled_memory_stats {\n+                      key: \"mesh1\"\n+                      value {}\n+                    }\n+                  }\n+                }\n+              )pb\"))));\n+}\n+\n+TEST_P(IfrtBackendHandlerTest, LoadedExecutableMpmdCostAnalysis) {\n+  uint64_t handle;\n+  {\n+    auto e = std::make_unique<MockMpmdLoadedExecutable>();\n+    MockMpmdLoadedExecutable* executable = e.get();\n+\n+    ON_CALL(*executable, name()).WillByDefault(Return(\"mpmd_exec\"));\n+    ON_CALL(*executable, num_devices()).WillByDefault(Return(1));\n+    auto device_list = BasicDeviceList::Create({});\n+    ON_CALL(*executable, devices()).WillByDefault(Return(device_list));\n+    ON_CALL(*executable, addressable_devices())\n+        .WillByDefault(Return(absl::Span<xla::ifrt::Device* const>()));\n+    ON_CALL(*executable, Fingerprint())\n+        .WillByDefault(Return(\"mpmd_fingerprint\"));\n+    ON_CALL(*executable, GetReadyFuture())\n+        .WillByDefault(Return(tsl::Future<>(absl::OkStatus())));\n+\n+    absl::flat_hash_map<std::string, xla::ifrt::AttributeMap> cost_analysis;\n+    xla::ifrt::AttributeMap mesh1_attrs(xla::ifrt::AttributeMap::Map{\n+        {\"cost\", xla::ifrt::AttributeMap::FloatValue{1.0f}}});\n+    cost_analysis.insert({\"mesh1\", std::move(mesh1_attrs)});\n+\n+    EXPECT_CALL(*executable, GetMpmdCostAnalysis())\n+        .WillOnce(Return(cost_analysis));\n+\n+    TF_ASSERT_OK_AND_ASSIGN(CompileResponse response,\n+                            CompileTestLoadedExecutable(std::move(e)));\n+    handle = response.loaded_executable_handle();\n+  }\n+\n+  auto request = NewIfrtRequest(NewOpId());\n+  request->mutable_loaded_executable_mpmd_cost_analysis_request()\n+      ->set_loaded_executable_handle(handle);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::shared_ptr<IfrtResponse> response,\n+                          CallBackend(std::move(request)));\n+\n+  EXPECT_THAT(response, Pointee(Partially(EquivToProto(R\"pb(\n+                loaded_executable_mpmd_cost_analysis_response {\n+                  attributes {\n+                    attributes {\n+                      key: \"mesh1\"\n+                      value {\n+                        attributes {\n+                          key: \"cost\"\n+                          value { float_value: 1.0 }\n+                        }\n+                      }\n+                    }\n+                  }\n+                }\n+              )pb\"))));\n+}\n+\n+TEST_P(IfrtBackendHandlerTest, CompileSuccessWithMpmdAddressableDevices) {\n+  auto executable = std::make_unique<MockMpmdLoadedExecutable>();\n+\n+  ON_CALL(*executable, name()).WillByDefault(Return(\"mpmd_exec\"));\n+  ON_CALL(*executable, num_devices()).WillByDefault(Return(1));\n+  auto empty_device_list = BasicDeviceList::Create({});\n+  ON_CALL(*executable, devices()).WillByDefault(Return(empty_device_list));\n+  ON_CALL(*executable, addressable_devices())\n+      .WillByDefault(Return(absl::Span<xla::ifrt::Device* const>()));\n+  ON_CALL(*executable, Fingerprint()).WillByDefault(Return(\"mpmd_fingerprint\"));\n+  ON_CALL(*executable, GetReadyFuture())\n+      .WillByDefault(Return(tsl::Future<>(absl::OkStatus())));\n+\n+  std::vector<xla::ifrt::Device*> mesh1_devices = {mock_devices_[0].get()};\n+  std::vector<xla::ifrt::Device*> mesh2_devices = {mock_devices_[1].get()};\n+\n+  absl::flat_hash_map<std::string, absl::Span<xla::ifrt::Device* const>>\n+      mpmd_addressable_devices_map;\n+  mpmd_addressable_devices_map[\"mesh1\"] = absl::MakeConstSpan(mesh1_devices);\n+  mpmd_addressable_devices_map[\"mesh2\"] = absl::MakeConstSpan(mesh2_devices);\n+\n+  if (Version().protocol_version() >=\n+      protocol_version::kMpmdLoadedExecutableMethods) {\n+    EXPECT_CALL(*executable, GetMpmdAddressableDevices())\n+        .WillOnce(Return(mpmd_addressable_devices_map));\n+  }\n+\n+  TF_ASSERT_OK_AND_ASSIGN(CompileResponse response,\n+                          CompileTestLoadedExecutable(std::move(executable)));\n+\n+  if (Version().protocol_version() >=\n+      protocol_version::kMpmdLoadedExecutableMethods) {\n+    EXPECT_THAT(response, Partially(EquivToProto(R\"pb(\n+                  mpmd_addressable_devices {\n+                    mpmd_addressable_devices {\n+                      key: \"mesh1\"\n+                      value { mpmd_addressable_device_ids: 0 }\n+                    }\n+                    mpmd_addressable_devices {\n+                      key: \"mesh2\"\n+                      value { mpmd_addressable_device_ids: 1 }\n+                    }\n+                  }\n+                )pb\")));\n+  } else {\n+    EXPECT_FALSE(response.has_mpmd_addressable_devices());\n+  }\n+}\n+\n INSTANTIATE_TEST_SUITE_P(\n     IfrtBackendHandlerTestWithAllVersions, IfrtBackendHandlerTest,\n     testing::Range(kServerMinVersion, kServerMaxVersion + 1),"
        }
    ],
    "stats": {
        "total": 1400,
        "additions": 1398,
        "deletions": 2
    }
}