{
    "author": "bchetioui",
    "message": "[XLA] Introduce `TiledHloSchedule` to specify tiling iteration patterns explicitly.\n\n`TiledHloSchedule` is designed to be passed to `ComputeTiledHloInstructions` in\norder to control the iteration patterns over blocks within a tiled program. The\nimmediate use case will be to support grid tiling, and to optimize the L2 cache\nhit rate in kernels involving reuse.\n\nPiperOrigin-RevId: 816317560",
    "sha": "838e33acdfb862533f5e5f7c9a24feaba99f282f",
    "files": [
        {
            "sha": "86580a0e98e0a6c4ab6c047dba7b179789231438",
            "filename": "third_party/xla/xla/codegen/tiling/BUILD",
            "status": "modified",
            "additions": 38,
            "deletions": 1,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD?ref=838e33acdfb862533f5e5f7c9a24feaba99f282f",
            "patch": "@@ -1,6 +1,6 @@\n+load(\"@rules_cc//cc:cc_library.bzl\", \"cc_library\")\n load(\"//xla:xla.default.bzl\", \"xla_cc_test\")\n load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\")\n-load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_library\")\n \n package(\n     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n@@ -112,6 +112,43 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"tiled_hlo_schedule\",\n+    srcs = [\"tiled_hlo_schedule.cc\"],\n+    hdrs = [\"tiled_hlo_schedule.h\"],\n+    deps = [\n+        \":symbolic_tile_analysis\",\n+        \"//xla/hlo/analysis:indexing_analysis\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"@com_google_absl//absl/algorithm:container\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"tiled_hlo_schedule_test\",\n+    srcs = [\"tiled_hlo_schedule_test.cc\"],\n+    deps = [\n+        \":symbolic_tile_analysis\",\n+        \":tiled_hlo_schedule\",\n+        \"//xla/hlo/analysis:indexing_analysis\",\n+        \"//xla/hlo/analysis:indexing_test_utils\",\n+        \"//xla/hlo/analysis:interval\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/testlib:verified_hlo_module\",\n+        \"//xla/service/gpu/model/experimental:symbolic_expr\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)\n+\n cc_library(\n     name = \"affine_map_evaluator\",\n     srcs = [\"affine_map_evaluator.cc\"],"
        },
        {
            "sha": "edef31f22b0ad88a98e5df0607455bd1c5a6a41b",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.cc",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc?ref=838e33acdfb862533f5e5f7c9a24feaba99f282f",
            "patch": "@@ -0,0 +1,126 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n+\n+#include <cstdint>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/algorithm/container.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"mlir/IR/AffineExpr.h\"\n+#include \"mlir/IR/AffineMap.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/hlo/analysis/indexing_map.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+\n+namespace xla {\n+\n+namespace {\n+\n+bool IsDotLike(const HloInstruction* hlo) {\n+  return hlo->opcode() == HloOpcode::kDot ||\n+         hlo->opcode() == HloOpcode::kScaledDot;\n+}\n+\n+// Given a parameter mapping, produces its \"input\" (or indexing) space, i.e.,\n+// for each parameter, the length of the dimension it abstracts over.\n+std::vector<int64_t> InputSpaceForParameterMapping(\n+    const TilingSpecification::ParameterMapping& parameter_mapping) {\n+  int64_t num_parameters = absl::c_accumulate(\n+      parameter_mapping, 0,\n+      [](int64_t sum,\n+         const TilingSpecification::InstructionAndNumTilingParameters&\n+             mapping) { return sum + mapping.num_tiling_parameters; });\n+  std::vector<int64_t> input_space;\n+  input_space.reserve(num_parameters);\n+\n+  for (const auto& [hlo, num_parameters] : parameter_mapping) {\n+    // TODO(b/419026602): handle reductions.\n+    if (IsDotLike(hlo)) {\n+      auto contracting_dimensions =\n+          hlo->dot_dimension_numbers().lhs_contracting_dimensions();\n+      // First, we need to add the contracting dimensions of the `dot`\n+      // instruction to the input space.\n+      for (int64_t contracting_dimension : contracting_dimensions) {\n+        input_space.push_back(\n+            hlo->operand(0)->shape().dimensions(contracting_dimension));\n+      }\n+      int64_t num_contracting_dimensions = contracting_dimensions.size();\n+      // Optionally, we also add the output dimensions of the `dot` instruction,\n+      // if they are actual parameters.\n+      if (num_parameters != num_contracting_dimensions) {\n+        CHECK_EQ(num_parameters,\n+                 num_contracting_dimensions + hlo->shape().dimensions().size());\n+        for (int64_t output_dimension : hlo->shape().dimensions()) {\n+          input_space.push_back(output_dimension);\n+        }\n+      }\n+      continue;\n+    }\n+\n+    CHECK_EQ(hlo->shape().dimensions().size(), num_parameters);\n+    for (int64_t dimension : hlo->shape().dimensions()) {\n+      input_space.push_back(dimension);\n+    }\n+  }\n+\n+  return input_space;\n+}\n+}  // namespace\n+\n+absl::StatusOr<IndexingMap> MajorToMinorTiledHloSchedule::RootSchedule(\n+    const HloInstruction* root,\n+    const TilingSpecification::ParameterMapping& parameter_mapping,\n+    mlir::MLIRContext* ctx) const {\n+  std::vector<int64_t> input_space =\n+      InputSpaceForParameterMapping(parameter_mapping);\n+  int64_t num_output_parameters = root->shape().dimensions().size();\n+\n+  std::vector<mlir::AffineExpr> result_exprs;\n+  result_exprs.reserve(num_output_parameters);\n+\n+  int64_t dim_offset = 0;\n+  for (const auto& [hlo, num_tiling_parameters] : parameter_mapping) {\n+    if (hlo != root) {\n+      dim_offset += num_tiling_parameters;\n+      continue;\n+    }\n+    int64_t num_hidden_parameters =\n+        num_tiling_parameters - num_output_parameters;\n+    for (int64_t parameter_index = num_hidden_parameters;\n+         parameter_index < num_tiling_parameters; ++parameter_index) {\n+      result_exprs.push_back(\n+          mlir::getAffineDimExpr(dim_offset + parameter_index, ctx));\n+    }\n+    CHECK_EQ(result_exprs.size(), num_output_parameters);\n+\n+    mlir::AffineMap affine_map = mlir::AffineMap::get(\n+        input_space.size(), /*symbolCount=*/0, result_exprs, ctx);\n+\n+    return IndexingMap::FromTensorSizes(affine_map, std::move(input_space),\n+                                        /*symbol_upper_bounds=*/{});\n+  }\n+  return absl::NotFoundError(absl::StrCat(\n+      \"No mapping found for root instruction: \", root->ToString()));\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "18957290fbb3ceb2390fb552f8343688470bba62",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.h",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h?ref=838e33acdfb862533f5e5f7c9a24feaba99f282f",
            "patch": "@@ -0,0 +1,66 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_CODEGEN_TILING_TILED_HLO_SCHEDULE_H_\n+#define XLA_CODEGEN_TILING_TILED_HLO_SCHEDULE_H_\n+\n+#include \"absl/status/statusor.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/hlo/analysis/indexing_map.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+\n+namespace xla {\n+\n+// A `TiledHloSchedule` exposes methods for scheduling a `TiledHloComputation`,\n+// i.e. it specifies an iteration order over tiles.\n+class TiledHloSchedule {\n+ public:\n+  virtual ~TiledHloSchedule() = default;\n+\n+  // Returns a schedule for the given root instruction as an indexing map.\n+  //\n+  // The resulting indexing map must satisfy the following properties:\n+  // (1) the map must have exactly as many parameters as there are tiling\n+  //     parameters in `parameter_mapping`;\n+  // (2) the parameters in the resulting map must appear in the same order as\n+  //     they appear in `parameter_mapping`;\n+  // (3) the map must have as many results as there are output dimensions in\n+  //     the instruction---although the results are allowed to be outside the\n+  //     range of the instruction's output space;\n+  // (4) iterating over the entire input space of the map must yield the\n+  //     entire output space of the instruction.\n+  virtual absl::StatusOr<IndexingMap> RootSchedule(\n+      const HloInstruction* root,\n+      const TilingSpecification::ParameterMapping& parameter_mapping,\n+      mlir::MLIRContext* ctx) const = 0;\n+};\n+\n+// The indexing map returned by this schedule uses parameters\n+// in major-to-minor order (i.e. in the order in which they are specified in\n+// the relevant parameter mapping).\n+class MajorToMinorTiledHloSchedule : public TiledHloSchedule {\n+ public:\n+  absl::StatusOr<IndexingMap> RootSchedule(\n+      const HloInstruction* root,\n+      const TilingSpecification::ParameterMapping& parameter_mapping,\n+      mlir::MLIRContext* ctx) const override;\n+};\n+\n+// TODO(b/417977182): implement the `PlanarSnakeTiledHloSchedule` schedule.\n+\n+}  // namespace xla\n+\n+#endif  // XLA_CODEGEN_TILING_TILED_HLO_SCHEDULE_H_"
        },
        {
            "sha": "d3c48a43e1d7f63dbaea27c353aae7c2e0062735",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule_test.cc",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/838e33acdfb862533f5e5f7c9a24feaba99f282f/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc?ref=838e33acdfb862533f5e5f7c9a24feaba99f282f",
            "patch": "@@ -0,0 +1,109 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/strings/substitute.h\"\n+#include \"mlir/IR/AffineExpr.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/hlo/analysis/indexing_map.h\"\n+#include \"xla/hlo/analysis/indexing_test_utils.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/testlib/verified_hlo_module.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+using ::testing::ElementsAre;\n+\n+class TiledHloScheduleTest : public HloHardwareIndependentTestBase {\n+ protected:\n+  mlir::MLIRContext ctx_;\n+};\n+\n+TEST_F(TiledHloScheduleTest,\n+       MajorToMinorTiledHloScheduleSatisfiesRootScheduleProperties) {\n+  constexpr int64_t batch_size = 5;\n+  constexpr int64_t lhs_non_contracting_size = 2;\n+  constexpr int64_t rhs_non_contracting_size = 4;\n+  constexpr int64_t contracting_size = 97;\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(absl::Substitute(\n+                              R\"(\n+ENTRY main {\n+  p0 = f32[$0,$1,$3] parameter(0)\n+  p1 = f32[$0,$3,$2] parameter(1)\n+  ROOT dot = f32[$0,$1,$2] dot(p0, p1),\n+    lhs_contracting_dims={2}, rhs_contracting_dims={1},\n+    lhs_batch_dims={0}, rhs_batch_dims={0}\n+})\",\n+                              batch_size, lhs_non_contracting_size,\n+                              rhs_non_contracting_size, contracting_size)));\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+\n+  // The dot instruction has 4 tiling parameters (1 batch, 2 non-contracting\n+  // dimensions, and 1 contracting dimension).\n+  constexpr int64_t kNumDotTilingParameters = 4;\n+  TilingSpecification::ParameterMapping parameter_mapping{\n+      {root, kNumDotTilingParameters}};\n+\n+  MajorToMinorTiledHloSchedule schedule;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      IndexingMap indexing_map,\n+      schedule.RootSchedule(root, parameter_mapping, &ctx_));\n+\n+  // (1) the map must have exactly as many parameters as there are tiling\n+  //     parameters in `parameter_mapping`.\n+  EXPECT_EQ(indexing_map.GetDimVarsCount(), kNumDotTilingParameters);\n+\n+  // (2) the parameters in the resulting map must appear in the same order as\n+  //     they appear in `parameter_mapping`.\n+  Interval contracting_interval{0, contracting_size - 1};\n+  Interval batch_interval{0, batch_size - 1};\n+  Interval lhs_non_contracting_interval{0, lhs_non_contracting_size - 1};\n+  Interval rhs_non_contracting_interval{0, rhs_non_contracting_size - 1};\n+\n+  auto bounds = indexing_map.GetDimensionBounds();\n+\n+  EXPECT_THAT(bounds, ElementsAre(contracting_interval, batch_interval,\n+                                  lhs_non_contracting_interval,\n+                                  rhs_non_contracting_interval));\n+  // (3) the map must have as many results as there are output dimensions in\n+  //     the instruction---although the results are allowed to be outside the\n+  //     range of the instruction's output space.\n+  EXPECT_EQ(indexing_map.GetNumResults(), root->shape().dimensions().size());\n+\n+  // (4) iterating over the entire input space of the map must yield the\n+  //     entire output space of the instruction.\n+  // TODO(b/449934916): fix the layering violation.\n+  gpu::SymbolicExprContext symbolic_expr_context(&ctx_);\n+  EXPECT_EQ(indexing_map.GetAffineMap(),\n+            ParseAffineMap(\"(d0, d1, d2, d3) -> (d1, d2, d3)\",\n+                           &symbolic_expr_context));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 340,
        "additions": 339,
        "deletions": 1
    }
}