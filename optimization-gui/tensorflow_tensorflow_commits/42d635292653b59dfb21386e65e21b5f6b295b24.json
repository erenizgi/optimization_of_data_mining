{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845710511",
    "sha": "42d635292653b59dfb21386e65e21b5f6b295b24",
    "files": [
        {
            "sha": "ce68ee2b4dea72f684b280cdce6b0d3f74cf9d8c",
            "filename": "tensorflow/core/lib/strings/base64_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fbase64_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fbase64_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fstrings%2Fbase64_test.cc?ref=42d635292653b59dfb21386e65e21b5f6b295b24",
            "patch": "@@ -20,7 +20,7 @@ limitations under the License.\n namespace tensorflow {\n \n TEST(Base64, EncodeDecode) {\n-  const string original = \"a simple test message!\";\n+  const std::string original = \"a simple test message!\";\n   tstring encoded;\n   TF_EXPECT_OK(Base64Encode(original, &encoded));\n   EXPECT_EQ(\"YSBzaW1wbGUgdGVzdCBtZXNzYWdlIQ\", encoded);"
        },
        {
            "sha": "8e69dbe7fc68093ee4ed5aa4e2345a8c15010299",
            "filename": "tensorflow/core/lib/strings/ordered_code.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code.cc?ref=42d635292653b59dfb21386e65e21b5f6b295b24",
            "patch": "@@ -134,7 +134,7 @@ static const char kFFCharacter = '\\000';  // Combined with kEscape2\n static const char kEscape1_Separator[2] = {kEscape1, kSeparator};\n \n // Append to \"*dest\" the \"len\" bytes starting from \"*src\".\n-inline static void AppendBytes(string* dest, const char* src, size_t len) {\n+inline static void AppendBytes(std::string* dest, const char* src, size_t len) {\n   dest->append(src, len);\n }\n \n@@ -164,7 +164,8 @@ const char* OrderedCode::TEST_SkipToNextSpecialByte(const char* start,\n \n // Helper routine to encode \"s\" and append to \"*dest\", escaping special\n // characters.\n-inline static void EncodeStringFragment(string* dest, absl::string_view s) {\n+inline static void EncodeStringFragment(std::string* dest,\n+                                        absl::string_view s) {\n   const char* p = s.data();\n   const char* limit = p + s.size();\n   const char* copy_start = p;\n@@ -191,12 +192,12 @@ inline static void EncodeStringFragment(string* dest, absl::string_view s) {\n   }\n }\n \n-void OrderedCode::WriteString(string* dest, absl::string_view s) {\n+void OrderedCode::WriteString(std::string* dest, absl::string_view s) {\n   EncodeStringFragment(dest, s);\n   AppendBytes(dest, kEscape1_Separator, 2);\n }\n \n-void OrderedCode::WriteNumIncreasing(string* dest, uint64 val) {\n+void OrderedCode::WriteNumIncreasing(std::string* dest, uint64_t val) {\n   // Values are encoded with a single byte length prefix, followed\n   // by the actual value in big-endian format with leading 0 bytes\n   // dropped.\n@@ -216,7 +217,8 @@ void OrderedCode::WriteNumIncreasing(string* dest, uint64 val) {\n // If parse succeeds, return true, consume encoding from\n // \"*src\", and if result != NULL append the decoded string to \"*result\".\n // Otherwise, return false and leave both undefined.\n-inline static bool ReadStringInternal(absl::string_view* src, string* result) {\n+inline static bool ReadStringInternal(absl::string_view* src,\n+                                      std::string* result) {\n   const char* start = src->data();\n   const char* string_limit = src->data() + src->size();\n \n@@ -271,11 +273,11 @@ inline static bool ReadStringInternal(absl::string_view* src, string* result) {\n   return false;\n }\n \n-bool OrderedCode::ReadString(absl::string_view* src, string* result) {\n+bool OrderedCode::ReadString(absl::string_view* src, std::string* result) {\n   return ReadStringInternal(src, result);\n }\n \n-bool OrderedCode::ReadNumIncreasing(absl::string_view* src, uint64* result) {\n+bool OrderedCode::ReadNumIncreasing(absl::string_view* src, uint64_t* result) {\n   if (src->empty()) {\n     return false;  // Not enough bytes\n   }\n@@ -294,7 +296,7 @@ bool OrderedCode::ReadNumIncreasing(absl::string_view* src, uint64* result) {\n   }\n \n   if (result) {\n-    uint64 tmp = 0;\n+    uint64_t tmp = 0;\n     for (size_t i = 0; i < len; i++) {\n       tmp <<= 8;\n       tmp |= static_cast<unsigned char>((*src)[1 + i]);\n@@ -305,7 +307,7 @@ bool OrderedCode::ReadNumIncreasing(absl::string_view* src, uint64* result) {\n   return true;\n }\n \n-void OrderedCode::TEST_Corrupt(string* str, int k) {\n+void OrderedCode::TEST_Corrupt(std::string* str, int k) {\n   int seen_seps = 0;\n   for (size_t i = 0; i + 1 < str->size(); i++) {\n     if ((*str)[i] == kEscape1 && (*str)[i + 1] == kSeparator) {\n@@ -389,7 +391,7 @@ static const char kLengthToHeaderBits[1 + kMaxSigned64Length][2] = {\n \n // This array maps encoding lengths to the header bits that overlap with\n // the payload and need fixing when reading.\n-static const uint64 kLengthToMask[1 + kMaxSigned64Length] = {\n+static const uint64_t kLengthToMask[1 + kMaxSigned64Length] = {\n     0ULL,\n     0x80ULL,\n     0xc000ULL,\n@@ -408,7 +410,7 @@ static const uint64 kLengthToMask[1 + kMaxSigned64Length] = {\n // bit position (the highest bit position in a positive int64 is 63).\n // For a negative number n, we count the bits in ~n.\n // That is, length = kBitsToLength[tsl::Log2Floor64(n < 0 ? ~n : n) + 1].\n-static const int8 kBitsToLength[1 + 63] = {\n+static const int8_t kBitsToLength[1 + 63] = {\n     1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4,\n     4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7,\n     7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10};\n@@ -418,23 +420,23 @@ static inline int SignedEncodingLength(int64_t n) {\n   return kBitsToLength[tsl::Log2Floor64(n < 0 ? ~n : n) + 1];\n }\n \n-static void StoreBigEndian64(char* dst, uint64 v) {\n+static void StoreBigEndian64(char* dst, uint64_t v) {\n   for (int i = 0; i < 8; i++) {\n     dst[i] = (v >> (56 - 8 * i)) & 0xff;\n   }\n }\n \n-static uint64 LoadBigEndian64(const char* src) {\n-  uint64 result = 0;\n+static uint64_t LoadBigEndian64(const char* src) {\n+  uint64_t result = 0;\n   for (int i = 0; i < 8; i++) {\n     unsigned char c = static_cast<unsigned char>(src[i]);\n-    result |= static_cast<uint64>(c) << (56 - 8 * i);\n+    result |= static_cast<uint64_t>(c) << (56 - 8 * i);\n   }\n   return result;\n }\n \n-void OrderedCode::WriteSignedNumIncreasing(string* dest, int64_t val) {\n-  const uint64 x = val < 0 ? ~val : val;\n+void OrderedCode::WriteSignedNumIncreasing(std::string* dest, int64_t val) {\n+  const uint64_t x = val < 0 ? ~val : val;\n   if (x < 64) {  // fast path for encoding length == 1\n     *dest += kLengthToHeaderBits[1][0] ^ val;\n     return;\n@@ -458,12 +460,12 @@ void OrderedCode::WriteSignedNumIncreasing(string* dest, int64_t val) {\n bool OrderedCode::ReadSignedNumIncreasing(absl::string_view* src,\n                                           int64_t* result) {\n   if (src->empty()) return false;\n-  const uint64 xor_mask = (!((*src)[0] & 0x80)) ? ~0ULL : 0ULL;\n+  const uint64_t xor_mask = (!((*src)[0] & 0x80)) ? ~0ULL : 0ULL;\n   const unsigned char first_byte = (*src)[0] ^ (xor_mask & 0xff);\n \n   // now calculate and test length, and set x to raw (unmasked) result\n   int len;\n-  uint64 x;\n+  uint64_t x;\n   if (first_byte != 0xff) {\n     len = 7 - tsl::Log2Floor64(first_byte ^ 0xff);\n     if (src->size() < static_cast<size_t>(len)) return false;"
        },
        {
            "sha": "2d2811ac5af30f2376627b56b67784173de5c58c",
            "filename": "tensorflow/core/lib/strings/ordered_code.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code.h?ref=42d635292653b59dfb21386e65e21b5f6b295b24",
            "patch": "@@ -54,9 +54,9 @@ class OrderedCode {\n   // Encoding routines: each one of the following routines append\n   // one item to \"*dest\" in an encoding where larger values are\n   // ordered lexicographically after smaller values.\n-  static void WriteString(string* dest, absl::string_view str);\n-  static void WriteNumIncreasing(string* dest, uint64 num);\n-  static void WriteSignedNumIncreasing(string* dest, int64_t num);\n+  static void WriteString(std::string* dest, absl::string_view str);\n+  static void WriteNumIncreasing(std::string* dest, uint64_t num);\n+  static void WriteSignedNumIncreasing(std::string* dest, int64_t num);\n \n   // -------------------------------------------------------------------\n   // Decoding routines: these extract an item earlier encoded using\n@@ -66,13 +66,13 @@ class OrderedCode {\n   // result.  In case of string result, the decoded string is appended to\n   // \"*result\".  Returns true if the next item was read successfully, false\n   // otherwise.\n-  static bool ReadString(absl::string_view* src, string* result);\n-  static bool ReadNumIncreasing(absl::string_view* src, uint64* result);\n+  static bool ReadString(absl::string_view* src, std::string* result);\n+  static bool ReadNumIncreasing(absl::string_view* src, uint64_t* result);\n   static bool ReadSignedNumIncreasing(absl::string_view* src, int64_t* result);\n \n   // Helper for testing: corrupt \"*str\" by changing the kth item separator\n   // in the string.\n-  static void TEST_Corrupt(string* str, int k);\n+  static void TEST_Corrupt(std::string* str, int k);\n \n   // Helper for testing.\n   // SkipToNextSpecialByte is an internal routine defined in the .cc file"
        },
        {
            "sha": "9ef3a8dafd2138913c9904e20cd8f9e40a50b144",
            "filename": "tensorflow/core/lib/strings/ordered_code_test.cc",
            "status": "modified",
            "additions": 89,
            "deletions": 84,
            "changes": 173,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/42d635292653b59dfb21386e65e21b5f6b295b24/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fstrings%2Fordered_code_test.cc?ref=42d635292653b59dfb21386e65e21b5f6b295b24",
            "patch": "@@ -32,8 +32,8 @@ namespace tensorflow {\n namespace strings {\n namespace {\n \n-string RandomString(random::SimplePhilox* rnd, size_t len) {\n-  string x;\n+std::string RandomString(random::SimplePhilox* rnd, size_t len) {\n+  std::string x;\n   for (size_t i = 0; i < len; i++) {\n     x += rnd->Uniform(256);\n   }\n@@ -45,33 +45,34 @@ string RandomString(random::SimplePhilox* rnd, size_t len) {\n \n // Read/WriteIncreasing are defined for string, uint64, int64 below.\n template <typename T>\n-void OCWriteIncreasing(string* dest, const T& val);\n+void OCWriteIncreasing(std::string* dest, const T& val);\n template <typename T>\n bool OCReadIncreasing(absl::string_view* src, T* result);\n \n // Read/WriteIncreasing<string>\n template <>\n-void OCWriteIncreasing<string>(string* dest, const string& val) {\n+void OCWriteIncreasing<std::string>(std::string* dest, const std::string& val) {\n   OrderedCode::WriteString(dest, val);\n }\n template <>\n-bool OCReadIncreasing<string>(absl::string_view* src, string* result) {\n+bool OCReadIncreasing<std::string>(absl::string_view* src,\n+                                   std::string* result) {\n   return OrderedCode::ReadString(src, result);\n }\n \n // Read/WriteIncreasing<uint64>\n template <>\n-void OCWriteIncreasing<uint64>(string* dest, const uint64& val) {\n+void OCWriteIncreasing<uint64_t>(std::string* dest, const uint64_t& val) {\n   OrderedCode::WriteNumIncreasing(dest, val);\n }\n template <>\n-bool OCReadIncreasing<uint64>(absl::string_view* src, uint64* result) {\n+bool OCReadIncreasing<uint64_t>(absl::string_view* src, uint64_t* result) {\n   return OrderedCode::ReadNumIncreasing(src, result);\n }\n \n // Read/WriteIncreasing<int64_t>\n template <>\n-void OCWriteIncreasing<int64_t>(string* dest, const int64_t& val) {\n+void OCWriteIncreasing<int64_t>(std::string* dest, const int64_t& val) {\n   OrderedCode::WriteSignedNumIncreasing(dest, val);\n }\n template <>\n@@ -80,14 +81,14 @@ bool OCReadIncreasing<int64_t>(absl::string_view* src, int64_t* result) {\n }\n \n template <typename T>\n-string OCWrite(T val) {\n-  string result;\n+std::string OCWrite(T val) {\n+  std::string result;\n   OCWriteIncreasing<T>(&result, val);\n   return result;\n }\n \n template <typename T>\n-void OCWriteToString(string* result, T val) {\n+void OCWriteToString(std::string* result, T val) {\n   OCWriteIncreasing<T>(result, val);\n }\n \n@@ -100,7 +101,7 @@ bool OCRead(absl::string_view* s, T* val) {\n // Numbers\n \n template <typename T>\n-T TestRead(const string& a) {\n+T TestRead(const std::string& a) {\n   // gracefully reject any proper prefix of an encoding\n   for (int i = 0; i < a.size() - 1; ++i) {\n     absl::string_view s(a.data(), i);\n@@ -124,9 +125,9 @@ void TestWriteRead(T expected) {\n // output.\n template <typename T, typename U>\n void TestWriteAppends(T first, U second) {\n-  string encoded;\n+  std::string encoded;\n   OCWriteToString<T>(&encoded, first);\n-  string encoded_first_only = encoded;\n+  std::string encoded_first_only = encoded;\n   OCWriteToString<U>(&encoded, second);\n   EXPECT_NE(encoded, encoded_first_only);\n   EXPECT_TRUE(absl::StartsWith(encoded, encoded_first_only));\n@@ -149,7 +150,7 @@ void TestNumbers(T multiplier) {\n   random::SimplePhilox rnd(&philox);\n   for (int bits = 1; bits <= std::numeric_limits<T>().digits; ++bits) {\n     // test random non-negative numbers with given number of significant bits\n-    const uint64 mask = (~0ULL) >> (64 - bits);\n+    const uint64_t mask = (~0ULL) >> (64 - bits);\n     for (int i = 0; i < 1000; i++) {\n       T x = rnd.Rand64() & mask;\n       TestWriteRead(multiplier * x);\n@@ -160,16 +161,18 @@ void TestNumbers(T multiplier) {\n }\n \n // Return true iff 'a' is \"before\" 'b'\n-bool CompareStrings(const string& a, const string& b) { return (a < b); }\n+bool CompareStrings(const std::string& a, const std::string& b) {\n+  return (a < b);\n+}\n \n template <typename T>\n void TestNumberOrdering() {\n   // first the negative numbers (if T is signed, otherwise no-op)\n-  string laststr = OCWrite<T>(std::numeric_limits<T>().min());\n+  std::string laststr = OCWrite<T>(std::numeric_limits<T>().min());\n   for (T num = std::numeric_limits<T>().min() / 2; num != 0; num /= 2) {\n-    string strminus1 = OCWrite<T>(num - 1);\n-    string str = OCWrite<T>(num);\n-    string strplus1 = OCWrite<T>(num + 1);\n+    std::string strminus1 = OCWrite<T>(num - 1);\n+    std::string str = OCWrite<T>(num);\n+    std::string strplus1 = OCWrite<T>(num + 1);\n \n     CHECK(CompareStrings(strminus1, str));\n     CHECK(CompareStrings(str, strplus1));\n@@ -185,9 +188,9 @@ void TestNumberOrdering() {\n   T num = 1;\n   while (num < std::numeric_limits<T>().max() / 2) {\n     num *= 2;\n-    string strminus1 = OCWrite<T>(num - 1);\n-    string str = OCWrite<T>(num);\n-    string strplus1 = OCWrite<T>(num + 1);\n+    std::string strminus1 = OCWrite<T>(num - 1);\n+    std::string str = OCWrite<T>(num);\n+    std::string strplus1 = OCWrite<T>(num + 1);\n \n     CHECK(CompareStrings(strminus1, str));\n     CHECK(CompareStrings(str, strplus1));\n@@ -199,7 +202,7 @@ void TestNumberOrdering() {\n }\n \n // Helper routine for testing TEST_SkipToNextSpecialByte\n-size_t FindSpecial(const string& x) {\n+size_t FindSpecial(const std::string& x) {\n   const char* p = x.data();\n   const char* limit = p + x.size();\n   const char* result = OrderedCode::TEST_SkipToNextSpecialByte(p, limit);\n@@ -209,15 +212,15 @@ size_t FindSpecial(const string& x) {\n // Helper function template to create strings from string literals (excluding\n // the terminal zero byte of the underlying character array).\n template <size_t N>\n-string ByteSequence(const char (&arr)[N]) {\n-  return string(arr, N - 1);\n+std::string ByteSequence(const char (&arr)[N]) {\n+  return std::string(arr, N - 1);\n }\n \n TEST(OrderedCode, SkipToNextSpecialByte) {\n   for (size_t len = 0; len < 256; len++) {\n     random::PhiloxRandom philox(301, 17);\n     random::SimplePhilox rnd(&philox);\n-    string x;\n+    std::string x;\n     while (x.size() < len) {\n       char c = 1 + rnd.Uniform(254);\n       ASSERT_NE(c, 0);\n@@ -228,7 +231,7 @@ TEST(OrderedCode, SkipToNextSpecialByte) {\n     for (size_t special_pos = 0; special_pos < len; special_pos++) {\n       for (size_t special_test = 0; special_test < 2; special_test++) {\n         const char special_byte = (special_test == 0) ? 0 : 255;\n-        string y = x;\n+        std::string y = x;\n         y[special_pos] = special_byte;\n         EXPECT_EQ(FindSpecial(y), special_pos);\n         if (special_pos < 16) {\n@@ -283,9 +286,9 @@ TEST(OrderedCode, ExhaustiveFindSpecial) {\n   EXPECT_EQ(count, 256 * 256 * 256 * 2);\n }\n \n-TEST(Uint64, EncodeDecode) { TestNumbers<uint64>(1); }\n+TEST(Uint64, EncodeDecode) { TestNumbers<uint64_t>(1); }\n \n-TEST(Uint64, Ordering) { TestNumberOrdering<uint64>(); }\n+TEST(Uint64, Ordering) { TestNumberOrdering<uint64_t>(); }\n \n TEST(Int64, EncodeDecode) {\n   TestNumbers<int64_t>(1);\n@@ -295,27 +298,27 @@ TEST(Int64, EncodeDecode) {\n TEST(Int64, Ordering) { TestNumberOrdering<int64_t>(); }\n \n // Returns the bitwise complement of s.\n-inline string StrNot(const string& s) {\n-  string result;\n-  for (string::const_iterator it = s.begin(); it != s.end(); ++it)\n+inline std::string StrNot(const std::string& s) {\n+  std::string result;\n+  for (std::string::const_iterator it = s.begin(); it != s.end(); ++it)\n     result.push_back(~*it);\n   return result;\n }\n \n template <typename T>\n-void TestInvalidEncoding(const string& s) {\n+void TestInvalidEncoding(const std::string& s) {\n   absl::string_view p(s);\n   EXPECT_FALSE(OCRead<T>(&p, nullptr));\n   EXPECT_EQ(s, p);\n }\n \n TEST(OrderedCodeInvalidEncodingsTest, Overflow) {\n   // 1U << 64, increasing and decreasing\n-  const string k2xx64U = \"\\x09\\x01\" + string(8, 0);\n-  TestInvalidEncoding<uint64>(k2xx64U);\n+  const std::string k2xx64U = \"\\x09\\x01\" + std::string(8, 0);\n+  TestInvalidEncoding<uint64_t>(k2xx64U);\n \n   // 1 << 63 and ~(1 << 63), increasing and decreasing\n-  const string k2xx63 = \"\\xff\\xc0\\x80\" + string(7, 0);\n+  const std::string k2xx63 = \"\\xff\\xc0\\x80\" + std::string(7, 0);\n   TestInvalidEncoding<int64_t>(k2xx63);\n   TestInvalidEncoding<int64_t>(StrNot(k2xx63));\n }\n@@ -332,11 +335,11 @@ TEST(OrderedCodeInvalidEncodingsDeathTest, NonCanonical) {\n \n   for (int n = 2; n <= 9; ++n) {\n     // The zero in non_minimal[1] is \"redundant\".\n-    string non_minimal =\n-        string(1, n - 1) + string(1, 0) + RandomString(&rnd, n - 2);\n+    std::string non_minimal =\n+        std::string(1, n - 1) + std::string(1, 0) + RandomString(&rnd, n - 2);\n     EXPECT_EQ(n, non_minimal.length());\n \n-    EXPECT_NE(OCWrite<uint64>(0), non_minimal);\n+    EXPECT_NE(OCWrite<uint64_t>(0), non_minimal);\n #ifndef NDEBUG\n     absl::string_view s(non_minimal);\n     EXPECT_DEATH(OrderedCode::ReadNumIncreasing(&s, nullptr),\n@@ -348,11 +351,12 @@ TEST(OrderedCodeInvalidEncodingsDeathTest, NonCanonical) {\n \n   for (int n = 2; n <= 10; ++n) {\n     // Header with 1 sign bit and n-1 size bits.\n-    string header = string(n / 8, 0xff) + string(1, 0xff << (8 - (n % 8)));\n+    std::string header =\n+        std::string(n / 8, 0xff) + std::string(1, 0xff << (8 - (n % 8)));\n     // There are more than 7 zero bits between header bits and \"payload\".\n-    string non_minimal = header +\n-                         string(1, rnd.Uniform(256) & ~*header.rbegin()) +\n-                         RandomString(&rnd, n - header.length() - 1);\n+    std::string non_minimal =\n+        header + std::string(1, rnd.Uniform(256) & ~*header.rbegin()) +\n+        RandomString(&rnd, n - header.length() - 1);\n     EXPECT_EQ(n, non_minimal.length());\n \n     EXPECT_NE(OCWrite<int64_t>(0), non_minimal);\n@@ -369,7 +373,7 @@ TEST(OrderedCodeInvalidEncodingsDeathTest, NonCanonical) {\n \n // Returns random number with specified number of bits,\n // i.e., in the range [2^(bits-1),2^bits).\n-uint64 NextBits(random::SimplePhilox* rnd, int bits) {\n+uint64_t NextBits(random::SimplePhilox* rnd, int bits) {\n   return (bits != 0)\n              ? (rnd->Rand64() % (1LL << (bits - 1))) + (1LL << (bits - 1))\n              : 0;\n@@ -385,7 +389,7 @@ void BM_WriteNum(::testing::benchmark::State& state, T multiplier) {\n   for (int i = 0; i < kValues; i++) {\n     values[i] = NextBits(&rnd, state.max_iterations % 64) * multiplier;\n   }\n-  string result;\n+  std::string result;\n   int index = 0;\n   for (auto i : state) {\n     result.clear();\n@@ -400,12 +404,12 @@ void BM_ReadNum(::testing::benchmark::State& state, T multiplier) {\n   random::SimplePhilox rnd(&philox);\n   // Use enough distinct values to confuse the branch predictor\n   constexpr int kValues = 64;\n-  string values[kValues];\n+  std::string values[kValues];\n   for (int i = 0; i < kValues; i++) {\n     T val = NextBits(&rnd, i % 64) * multiplier;\n     values[i] = OCWrite<T>(val);\n   }\n-  uint32 index = 0;\n+  uint32_t index = 0;\n   for (auto i : state) {\n     T val;\n     absl::string_view s = values[index++ % kValues];\n@@ -423,7 +427,7 @@ void BM_ReadNum(::testing::benchmark::State& state, T multiplier) {\n   }                                                         \\\n   BENCHMARK(BM_Read##name)\n \n-BENCHMARK_NUM(NumIncreasing, uint64, 1);\n+BENCHMARK_NUM(NumIncreasing, uint64_t, 1);\n BENCHMARK_NUM(SignedNum, int64_t, 1);\n BENCHMARK_NUM(SignedNumNegative, int64_t, -1);\n \n@@ -437,30 +441,30 @@ TEST(String, EncodeDecode) {\n   random::SimplePhilox rnd(&philox);\n \n   for (int len = 0; len < 256; len++) {\n-    const string a = RandomString(&rnd, len);\n+    const std::string a = RandomString(&rnd, len);\n     TestWriteRead(a);\n     for (int len2 = 0; len2 < 64; len2++) {\n-      const string b = RandomString(&rnd, len2);\n+      const std::string b = RandomString(&rnd, len2);\n \n       TestWriteAppends(a, b);\n \n-      string out;\n-      OCWriteToString<string>(&out, a);\n-      OCWriteToString<string>(&out, b);\n+      std::string out;\n+      OCWriteToString<std::string>(&out, a);\n+      OCWriteToString<std::string>(&out, b);\n \n-      string a2, b2, dummy;\n+      std::string a2, b2, dummy;\n       absl::string_view s = out;\n       absl::string_view s2 = out;\n-      CHECK(OCRead<string>(&s, &a2));\n-      CHECK(OCRead<string>(&s2, nullptr));\n+      CHECK(OCRead<std::string>(&s, &a2));\n+      CHECK(OCRead<std::string>(&s2, nullptr));\n       CHECK_EQ(s, s2);\n \n-      CHECK(OCRead<string>(&s, &b2));\n-      CHECK(OCRead<string>(&s2, nullptr));\n+      CHECK(OCRead<std::string>(&s, &b2));\n+      CHECK(OCRead<std::string>(&s2, nullptr));\n       CHECK_EQ(s, s2);\n \n-      CHECK(!OCRead<string>(&s, &dummy));\n-      CHECK(!OCRead<string>(&s2, nullptr));\n+      CHECK(!OCRead<std::string>(&s, &dummy));\n+      CHECK(!OCRead<std::string>(&s2, nullptr));\n       CHECK_EQ(a, a2);\n       CHECK_EQ(b, b2);\n       CHECK(s.empty());\n@@ -472,8 +476,8 @@ TEST(String, EncodeDecode) {\n // 'str' is a string literal that may contain '\\0'.\n #define STATIC_STR(str) StringPiece((str), sizeof(str) - 1)\n \n-string EncodeStringIncreasing(absl::string_view value) {\n-  string encoded;\n+std::string EncodeStringIncreasing(absl::string_view value) {\n+  std::string encoded;\n   OrderedCode::WriteString(&encoded, value);\n   return encoded;\n }\n@@ -515,27 +519,28 @@ TEST(String, Increasing) {\n }\n \n TEST(EncodingIsExpected, String) {\n-  std::vector<std::pair<string, string>> data = {\n-      {\"\", string(\"\\x00\\x01\", 2)},\n-      {\"foo\", string(\"foo\\x00\\x01\", 5)},\n-      {\"hello\", string(\"hello\\x00\\x01\", 7)},\n-      {string(\"\\x00\\x01\\xff\", 3), string(\"\\x00\\xff\\x01\\xff\\x00\\x00\\x01\", 7)},\n+  std::vector<std::pair<std::string, std::string>> data = {\n+      {\"\", std::string(\"\\x00\\x01\", 2)},\n+      {\"foo\", std::string(\"foo\\x00\\x01\", 5)},\n+      {\"hello\", std::string(\"hello\\x00\\x01\", 7)},\n+      {std::string(\"\\x00\\x01\\xff\", 3),\n+       std::string(\"\\x00\\xff\\x01\\xff\\x00\\x00\\x01\", 7)},\n   };\n   for (const auto& t : data) {\n-    string result;\n+    std::string result;\n     OrderedCode::WriteString(&result, t.first);\n     EXPECT_EQ(t.second, result);\n \n     absl::string_view in = result;\n-    string decoded;\n+    std::string decoded;\n     EXPECT_TRUE(OrderedCode::ReadString(&in, &decoded));\n     EXPECT_EQ(t.first, decoded);\n     EXPECT_EQ(\"\", in);\n   }\n }\n \n TEST(EncodingIsExpected, Unsigned) {\n-  std::vector<std::pair<uint64, string>> data = {\n+  std::vector<std::pair<uint64_t, std::string>> data = {\n       {0x0ull, ByteSequence(\"\\000\")},\n       {0x1ull, ByteSequence(\"\\001\\001\")},\n       {0x2ull, ByteSequence(\"\\001\\002\")},\n@@ -753,21 +758,21 @@ TEST(EncodingIsExpected, Unsigned) {\n        ByteSequence(\"\\010\\200\\000\\000\\000\\000\\000\\000\\001\")},\n   };\n   for (const auto& t : data) {\n-    uint64 num = t.first;\n-    string result;\n+    uint64_t num = t.first;\n+    std::string result;\n     OrderedCode::WriteNumIncreasing(&result, num);\n     EXPECT_EQ(t.second, result) << std::hex << num;\n \n     absl::string_view in = result;\n-    uint64 decoded;\n+    uint64_t decoded;\n     EXPECT_TRUE(OrderedCode::ReadNumIncreasing(&in, &decoded));\n     EXPECT_EQ(num, decoded);\n     EXPECT_EQ(\"\", in);\n   }\n }\n \n TEST(EncodingIsExpected, Signed) {\n-  std::vector<std::pair<int64_t, string>> data = {\n+  std::vector<std::pair<int64_t, std::string>> data = {\n       {0ll, ByteSequence(\"\\200\")},\n       {1ll, ByteSequence(\"\\201\")},\n       {2ll, ByteSequence(\"\\202\")},\n@@ -1201,7 +1206,7 @@ TEST(EncodingIsExpected, Signed) {\n   };\n   for (const auto& t : data) {\n     int64_t num = t.first;\n-    string result;\n+    std::string result;\n     OrderedCode::WriteSignedNumIncreasing(&result, num);\n     EXPECT_EQ(t.second, result) << std::hex << num;\n \n@@ -1216,34 +1221,34 @@ TEST(EncodingIsExpected, Signed) {\n void BM_WriteString(::testing::benchmark::State& state, int len) {\n   random::PhiloxRandom philox(301, 17);\n   random::SimplePhilox rnd(&philox);\n-  string x;\n+  std::string x;\n   for (int i = 0; i < len; i++) {\n     x += rnd.Uniform(256);\n   }\n-  string y;\n+  std::string y;\n \n   for (auto s : state) {\n     y.clear();\n-    OCWriteToString<string>(&y, x);\n+    OCWriteToString<std::string>(&y, x);\n   }\n   state.SetBytesProcessed(state.iterations() * len);\n }\n \n void BM_ReadString(::testing::benchmark::State& state, int len) {\n   random::PhiloxRandom philox(301, 17);\n   random::SimplePhilox rnd(&philox);\n-  string x;\n+  std::string x;\n   for (int i = 0; i < len; i++) {\n     x += rnd.Uniform(256);\n   }\n-  string data;\n-  OCWriteToString<string>(&data, x);\n-  string result;\n+  std::string data;\n+  OCWriteToString<std::string>(&data, x);\n+  std::string result;\n \n   for (auto i : state) {\n     result.clear();\n     absl::string_view s = data;\n-    OCRead<string>(&s, &result);\n+    OCRead<std::string>(&s, &result);\n   }\n   state.SetBytesProcessed(state.iterations() * len);\n }"
        }
    ],
    "stats": {
        "total": 227,
        "additions": 117,
        "deletions": 110
    }
}