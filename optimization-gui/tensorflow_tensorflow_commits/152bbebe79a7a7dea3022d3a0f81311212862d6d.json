{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add support for detached futures\n\nRunning OnReady and Map callbacks in the thread that calls promise.Set() can be dangerous for performance. Add an API to execute all callbacks in the given executor.\n\nPiperOrigin-RevId: 818964744",
    "sha": "152bbebe79a7a7dea3022d3a0f81311212862d6d",
    "files": [
        {
            "sha": "83825c973a4e5f413233e41da00928ee31adee14",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/152bbebe79a7a7dea3022d3a0f81311212862d6d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/152bbebe79a7a7dea3022d3a0f81311212862d6d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h?ref=152bbebe79a7a7dea3022d3a0f81311212862d6d",
            "patch": "@@ -452,6 +452,8 @@ class AsyncValuePtr {\n \n   AsyncValueRef<T> CopyRef() const { return AsyncValueRef<T>(FormRef(value_)); }\n \n+  RCReference<AsyncValue> CopyRCRef() const { return FormRef(value_); }\n+\n   T& get() const { return value_->template get<T>(); }\n   T* operator->() const { return &get(); }\n   T& operator*() const { return get(); }"
        },
        {
            "sha": "7846aba70b914648a96ff6294e4d7f055857bb99",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 124,
            "deletions": 5,
            "changes": 129,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/152bbebe79a7a7dea3022d3a0f81311212862d6d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/152bbebe79a7a7dea3022d3a0f81311212862d6d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=152bbebe79a7a7dea3022d3a0f81311212862d6d",
            "patch": "@@ -32,6 +32,7 @@ limitations under the License.\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/executor.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/logging.h\"\n \n namespace tsl {\n@@ -128,12 +129,28 @@ class FutureMoveControl</*is_move_only=*/false> {\n   FutureMoveControl& operator=(FutureMoveControl&&) = default;\n };\n \n+// A template helper to deduce the `Future` type from the `FutureBase` type.\n+// clang-format off\n+template <typename T>\n+struct FutureType;\n+template <>\n+struct FutureType<absl::Status>      { using type = void; };\n+template <typename T>\n+struct FutureType<absl::StatusOr<T>> { using type = T; };\n+// clang-format on\n+\n+template <typename T>\n+using future_type_t = typename FutureType<T>::type;  // NOLINT\n+\n // A base class for a stateful future Future<T> and a stateless future Future<>.\n // If `is_move_only` is true, Future derived from this class acts as a move-only\n // type and the value can be passed to the caller only using move assignment\n // (applied to Await and OnReady APIs).\n template <typename T, bool is_move_only = !std::is_copy_constructible_v<T>>\n class FutureBase : public FutureMoveControl<is_move_only> {\n+  static_assert(internal::is_status_v<T> || internal::is_status_or_v<T>,\n+                \"Future value type must be absl::Status or absl::StatusOr\");\n+\n  protected:\n   FutureBase() = default;\n \n@@ -310,6 +327,30 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n     }\n   }\n \n+  // Returns a detached `Future<T>` that by default will execute all `OnReady`\n+  // callbacks (and `Map` functors) on the given `executor`.\n+  //\n+  // When future value is set via the connected promise, all callbacks attached\n+  // to the future will be executed on a thread that sets the promise value.\n+  // This might lead to unexpectedly running expensive callbacks on a thread\n+  // that is not intended for that, i.e. if a promise is set by a non-blocking\n+  // thread that handles IO events, running expensive computation might lead to\n+  // overall performance degradation.\n+  //\n+  // Detached future guarantees that all pending callbacks will be executed on\n+  // the specified executor. If the future is ready when `OnReady` or `Map` is\n+  // called, then the callback will be executed immediately in the caller\n+  // thread. Users can explicitly override executor by using `OnReady` and `Map`\n+  // overloads that accept another executor instance.\n+  //\n+  // We use a trick we an extra template parameter to disable const& overload\n+  // when T is move-only, as we don't want to allow to create multiple futures\n+  // sharing the same async value promise.\n+  template <typename U = void,\n+            std::enable_if_t<!is_move_only && std::is_void_v<U>>* = nullptr>\n+  [[nodiscard]] Future<future_type_t<T>> Detach(Executor& executor) const&;\n+  [[nodiscard]] Future<future_type_t<T>> Detach(Executor& executor) &&;\n+\n   // Returns a Future<> that becomes ready when *this is ready. If *this\n   // completes with an error, the returned future will also be an error.\n   //\n@@ -513,8 +554,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     friend class Future;\n   };\n \n-  // Returns a pair of connected Promise and Future<T>. Setting the returned\n-  // promise will fulfill the connected future.\n+  // Returns a pair of connected Promise and Future<>. Setting the returned\n+  // promise will fulfill the connected future and will run pending callbacks in\n+  // the caller thread.\n   //\n   // - on_block_start is called before Await starts to block.\n   // - on_block_end is called after Await finishes blocking.\n@@ -527,6 +569,24 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n+  // Returns a pair of connected Promise and Future<T>. Setting the returned\n+  // promise will fulfill the connected future and will run all pending\n+  // callbacks on the given `executor`. If the future is ready when `OnReady` or\n+  // `Map` is called, then the callback will be executed immediately in the\n+  // caller thread. Users can explicitly override executor by using `OnReady`\n+  // and `Map` overloads that accept another executor instance.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<T>> MakePromise(\n+      Executor& executor, FutureHelpers::OnBlockStart on_block_start = nullptr,\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n+    auto [promise, future] =\n+        MakePromise(std::move(on_block_start), std::move(on_block_end));\n+    return std::make_pair(std::move(promise),\n+                          std::move(future).Detach(executor));\n+  }\n+\n   // Returns a future that is constructed from the result of invoking functor\n   // `f` on the given `executor`.\n   template <typename F, typename R = std::invoke_result_t<F>,\n@@ -542,6 +602,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   }\n \n   using Base::Await;\n+  using Base::Detach;\n   using Base::GetReadyFuture;\n   using Base::OnReady;\n \n@@ -867,7 +928,11 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   };\n \n   // Returns a pair of connected Promise and Future<>. Setting the returned\n-  // promise will fulfill the connected future.\n+  // promise will fulfill the connected future and will run all pending\n+  // callbacks in the caller thread.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n       FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n@@ -877,8 +942,26 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n-  // Returns a future that is constructed from the result of invoking functor\n-  // `f` on the given `executor`.\n+  // Returns a pair of connected Promise and Future<>. Setting the returned\n+  // promise will fulfill the connected future and will run all pending\n+  // callbacks on the given `executor`. If the future is ready when `OnReady` or\n+  // `Map` is called, then the callback will be executed immediately in the\n+  // caller thread. Users can explicitly override executor by using `OnReady`\n+  // and `Map` overloads that accept another executor instance.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<>> MakePromise(\n+      Executor& executor, FutureHelpers::OnBlockStart on_block_start = nullptr,\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n+    auto [promise, future] =\n+        MakePromise(std::move(on_block_start), std::move(on_block_end));\n+    return std::make_pair(std::move(promise),\n+                          std::move(future).Detach(executor));\n+  }\n+\n+  // Returns a future that is constructed from the result of invoking\n+  // functor `f` on the given `executor`.\n   template <typename F, typename R = std::invoke_result_t<F>,\n             std::enable_if_t<internal::is_status_v<R>>* = nullptr>\n   [[nodiscard]] static Future<> MakeOn(Executor& executor, F&& f) {\n@@ -892,6 +975,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n \n   using Base::Await;\n   using Base::BlockUntilReady;\n+  using Base::Detach;\n   using Base::OnReady;\n \n   // Returns an Future<R> that is constructed from the result of invoking\n@@ -1058,6 +1142,41 @@ using Promise = typename Future<T>::Promise;  // NOLINT\n \n namespace internal {\n \n+template <typename T, bool is_move_only>\n+template <typename U, std::enable_if_t<!is_move_only && std::is_void_v<U>>*>\n+Future<future_type_t<T>> FutureBase<T, is_move_only>::Detach(\n+    Executor& executor) const& {\n+  if (ABSL_PREDICT_FALSE(IsReady())) {\n+    return Future<future_type_t<T>>(promise_, on_block_start_, on_block_end_);\n+  }\n+\n+  RCReference<IndirectAsyncValue> detached = MakeIndirectAsyncValue<T>();\n+  promise_.AndThen(executor, [detached, ptr = promise_.AsPtr()] {\n+    detached->ForwardTo(ptr.CopyRCRef());\n+  });\n+  return Future<future_type_t<T>>(AsyncValueRef<T>(std::move(detached)),\n+                                  on_block_start_, on_block_end_);\n+}\n+\n+template <typename T, bool is_move_only>\n+Future<future_type_t<T>> FutureBase<T, is_move_only>::Detach(\n+    Executor& executor) && {\n+  if (ABSL_PREDICT_FALSE(IsReady())) {\n+    return Future<future_type_t<T>>(std::move(promise_),\n+                                    std::move(on_block_start_),\n+                                    std::move(on_block_end_));\n+  }\n+\n+  AsyncValuePtr<T> ptr = promise_.AsPtr();\n+  RCReference<IndirectAsyncValue> detached = MakeIndirectAsyncValue<T>();\n+  ptr.AndThen(executor, [detached, ref = std::move(promise_)]() mutable {\n+    detached->ForwardTo(ref.ReleaseRCRef());\n+  });\n+  return Future<future_type_t<T>>(AsyncValueRef<T>(std::move(detached)),\n+                                  std::move(on_block_start_),\n+                                  std::move(on_block_end_));\n+}\n+\n template <typename T, bool is_move_only>\n Future<> FutureBase<T, is_move_only>::GetReadyFuture() const {\n   auto [promise, future] = Future<>::MakePromise();"
        },
        {
            "sha": "571dd3f0dae02a961247293bb863b5c5866968eb",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 148,
            "deletions": 10,
            "changes": 158,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/152bbebe79a7a7dea3022d3a0f81311212862d6d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/152bbebe79a7a7dea3022d3a0f81311212862d6d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=152bbebe79a7a7dea3022d3a0f81311212862d6d",
            "patch": "@@ -559,9 +559,126 @@ TEST(FutureTest, MapDoesNotCopy) {\n   EXPECT_EQ(counter, 1);\n };\n \n+TEST(FutureTest, DetachDoesnNotCopy) {\n+  CountingExecutor executor;\n+  static int32_t counter = 0;\n+\n+  // A trivial class that counts how many times the copy constructor is called.\n+  struct Data {\n+    Data() = default;\n+\n+    Data(const Data& other) { ++counter; }\n+    Data(Data&& other) {}\n+\n+    Data& operator=(Data& other) = delete;\n+    Data& operator=(Data&& other) = delete;\n+  };\n+\n+  auto [promise, future] = Future<Data>::MakePromise();\n+  auto detached = future.Detach(executor);\n+\n+  Future<> m0 = future.Map([](const Data& data) {});\n+  Future<> m1 = detached.Map([](const Data& data) {});\n+\n+  promise.Set(Data{});\n+\n+  EXPECT_EQ(m0.Await(), absl::OkStatus());\n+  EXPECT_EQ(m1.Await(), absl::OkStatus());\n+\n+  EXPECT_EQ(counter, 0);\n+  EXPECT_EQ(executor.num_tasks, 1);\n+};\n+\n+TEST(FutureTest, DetachAndMap) {\n+  CountingExecutor executor;\n+\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  Future<> mapped = future.Detach(executor).Map([] {});\n+  promise.Set(absl::OkStatus());\n+\n+  EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+  EXPECT_EQ(executor.num_tasks, 1);\n+};\n+\n+TEST(FutureTest, MakeDetachedFuture) {\n+  CountingExecutor executor;\n+\n+  {  // Stateless future.\n+    auto [promise, future] = Future<>::MakePromise(executor);\n+    Future<> mapped = future.Map([] {});\n+    promise.Set(absl::OkStatus());\n+\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+    EXPECT_EQ(executor.num_tasks, 1);\n+  }\n+\n+  {  // Stateful future.\n+    auto [promise, future] = Future<int32_t>::MakePromise(executor);\n+    Future<> mapped = future.Map([](int32_t value) { EXPECT_EQ(value, 42); });\n+    promise.Set(42);\n+\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+    EXPECT_EQ(executor.num_tasks, 2);\n+  }\n+};\n+\n+TEST(FutureTest, DetachMoveOnly) {\n+  CountingExecutor executor;\n+  static int32_t counter = 0;\n+\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto detached = std::move(future).Detach(executor);\n+\n+  Future<> m0 = std::move(detached).Map([](std::unique_ptr<int32_t> value) {\n+    EXPECT_TRUE(value);\n+    EXPECT_EQ(*value, 42);\n+  });\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+  EXPECT_EQ(m0.Await(), absl::OkStatus());\n+\n+  EXPECT_EQ(counter, 0);\n+  EXPECT_EQ(executor.num_tasks, 1);\n+};\n+\n+TEST(DetachFutureTest, DetachOnThreadPool) {\n+  // We use static thread local counter to make sure that all callbacks are\n+  // executed on a thread inside the thread pool.\n+  static thread_local int32_t counter = 0;\n+\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n+  Executor* executor = thread_pool.AsExecutor();\n+\n+  {  // Test both lvalue and rvalue stateless detached futures.\n+    auto [promise, future] = Future<>::MakePromise();\n+    Future<> detached = future.Detach(*executor);\n+    detached.OnReady([](auto) { counter++; });\n+    future.Detach(*executor).OnReady([](auto) { counter++; });\n+    promise.Set(absl::OkStatus());\n+  }\n+\n+  {  // Test both lvalue and rvalue stateful detached futures.\n+    auto [promise, future] = Future<int32_t>::MakePromise();\n+    Future<int32_t> detached = future.Detach(*executor);\n+    detached.OnReady([](auto) { counter++; });\n+    future.Detach(*executor).OnReady([](auto) { counter++; });\n+    promise.Set(42);\n+  }\n+\n+  {  // Test detached future with move-only payload.\n+    auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+    std::move(future).Detach(*executor).OnReady([](auto) { counter++; });\n+    promise.Set(std::make_unique<int32_t>(42));\n+  }\n+\n+  // Check that no callbacks were executed on the thread that sets the promise.\n+  EXPECT_EQ(counter, 0);\n+}\n+\n TEST(FutureTest, MapOnExecutorDoesNotCopy) {\n-  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n-  tsl::Executor* executor = thread_pool.AsExecutor();\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n+  Executor* executor = thread_pool.AsExecutor();\n \n   static int32_t counter = 0;\n \n@@ -948,7 +1065,7 @@ TEST(FutureTest, MapOnExecutor) {\n }\n \n TEST(FutureTest, MapStatelessOnThreadPoolExecutor) {\n-  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n \n   std::vector<Future<>> mapped;\n   std::atomic<int32_t> counter = 0;\n@@ -963,12 +1080,12 @@ TEST(FutureTest, MapStatelessOnThreadPoolExecutor) {\n     promise.Set();\n   }\n \n-  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(JoinFutures(mapped).Await(), absl::OkStatus());\n   EXPECT_EQ(counter, 100);\n }\n \n TEST(FutureTest, MapStatefulOnThreadPoolExecutor) {\n-  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n \n   std::vector<Future<>> mapped;\n   std::atomic<int32_t> counter = 0;\n@@ -983,12 +1100,12 @@ TEST(FutureTest, MapStatefulOnThreadPoolExecutor) {\n     promise.Set(1);\n   }\n \n-  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(JoinFutures(mapped).Await(), absl::OkStatus());\n   EXPECT_EQ(counter, 100);\n }\n \n TEST(FutureTest, MapMoveOnlyOnThreadPoolExecutor) {\n-  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n \n   std::vector<Future<>> mapped;\n   std::atomic<int32_t> counter = 0;\n@@ -1004,12 +1121,12 @@ TEST(FutureTest, MapMoveOnlyOnThreadPoolExecutor) {\n     promise.Set(std::make_unique<int32_t>(1));\n   }\n \n-  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(JoinFutures(mapped).Await(), absl::OkStatus());\n   EXPECT_EQ(counter, 100);\n }\n \n TEST(FutureTest, MapMoveOnlyRvalueOnThreadPoolExecutor) {\n-  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n \n   std::vector<Future<>> mapped;\n   std::atomic<int32_t> counter = 0;\n@@ -1025,7 +1142,28 @@ TEST(FutureTest, MapMoveOnlyRvalueOnThreadPoolExecutor) {\n     }\n   }\n \n-  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(counter, 100);\n+}\n+\n+TEST(FutureTest, DetachStatefulOnThreadPoolExecutor) {\n+  thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n+  Executor* executor = thread_pool.AsExecutor();\n+\n+  std::vector<Future<>> mapped;\n+  std::atomic<int32_t> counter = 0;\n+\n+  {  // Create mapped future in a nested scope to make sure that `promise` and\n+    // `future` are destroyed before the end of the test.\n+    auto [promise, future] = Future<int32_t>::MakePromise();\n+    for (size_t i = 0; i < 100; ++i) {\n+      mapped.push_back(future.Detach(*executor).Map(\n+          [&](int32_t value) { counter += value; }));\n+    }\n+    promise.Set(1);\n+  }\n+\n+  EXPECT_EQ(JoinFutures(mapped).Await(), absl::OkStatus());\n   EXPECT_EQ(counter, 100);\n }\n "
        }
    ],
    "stats": {
        "total": 289,
        "additions": 274,
        "deletions": 15
    }
}