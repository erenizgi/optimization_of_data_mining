{
    "author": "jparkerh",
    "message": "rework phase compiler inheritance and depgraph\n\nThis covers some cleanup around phase compiler: split out the utility functions into their own files for clarity, move the c_api_phase_compiler under the c_api_client umbrella (it is a c_api_client component so it should be part of the c_api_client), clean up the internal extension files, etc.\nThis also enables us to define the GetCApiCompiler and getCApiPhaseCompiler alongside each other, not in completely different and split locations/deps.\n\nPiperOrigin-RevId: 815884187",
    "sha": "7354cce7139f5c105a7cef6d28484705c2365046",
    "files": [
        {
            "sha": "333735b09b007035933ed6e285c3a09380a0d45b",
            "filename": "third_party/xla/xla/pjrt/BUILD",
            "status": "modified",
            "additions": 35,
            "deletions": 29,
            "changes": 64,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -1227,31 +1227,9 @@ cc_library(\n     ],\n )\n \n-cc_library(\n-    name = \"pjrt_phase_compile\",\n-    srcs = [\"pjrt_phase_compile.cc\"],\n-    hdrs = [\"pjrt_phase_compile.h\"],\n-    visibility = [\"//visibility:public\"],\n-    deps = [\n-        \":pjrt_c_api_client\",\n-        \":pjrt_compiler\",\n-        \":pjrt_executable\",\n-        \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_helpers\",\n-        \"//xla/pjrt/c:pjrt_c_api_phase_compile_extension_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_phase_compile_internal\",\n-        \"//xla/tsl/platform:errors\",\n-        \"//xla/tsl/platform:statusor\",\n-        \"@com_google_absl//absl/cleanup\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n-        \"@local_tsl//tsl/platform:casts\",\n-    ],\n-)\n-\n cc_library(\n     name = \"pjrt_phase_compile_sample_plugin\",\n+    testonly = True,\n     srcs = [\"pjrt_phase_compile_sample_plugin.cc\"],\n     hdrs = [\"pjrt_phase_compile_sample_plugin.h\"],\n     visibility = [\"//visibility:private\"],\n@@ -1265,8 +1243,11 @@ cc_library(\n         \"//xla/pjrt/c:pjrt_c_api_phase_compile_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_phase_compile_internal\",\n         \"//xla/pjrt/c:pjrt_c_api_wrapper_impl\",\n+        \"//xla/pjrt/plugin/xla_cpu:cpu_client_options\",\n+        \"//xla/pjrt/plugin/xla_cpu:xla_cpu_pjrt_client\",\n         \"//xla/pjrt/proto:pjrt_partial_program_proto_cc\",\n         \"//xla/tsl/framework/mlir:status_scoped_diagnostic_handler\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n@@ -1313,26 +1294,51 @@ xla_cc_test(\n     srcs = [\"pjrt_phase_compile_extension_test.cc\"],\n     deps = [\n         \":pjrt_api\",\n-        \":pjrt_c_api_client\",\n         \":pjrt_compiler\",\n         \":pjrt_executable\",\n-        \":pjrt_phase_compile\",\n         \":pjrt_phase_compile_sample_plugin\",\n-        \"//xla/pjrt/c:pjrt_c_api_cpu_internal\",\n+        \":string_utils\",\n         \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_helpers\",\n         \"//xla/pjrt/c:pjrt_c_api_phase_compile_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_phase_compile_internal\",\n+        \"//xla/pjrt/c_api_client:pjrt_c_api_client\",\n         \"//xla/pjrt/proto:pjrt_partial_program_proto_cc\",\n         \"//xla/tsl/lib/core:status_test_util\",\n-        \"//xla/tsl/platform:status_matchers\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@llvm-project//mlir:IR\",\n         \"@llvm-project//mlir:Support\",\n         \"@stablehlo//:reference_api\",\n     ],\n )\n+\n+cc_library(\n+    name = \"string_utils\",\n+    srcs = [\"string_utils.cc\"],\n+    hdrs = [\"string_utils.h\"],\n+    deps = [\n+        \"//xla/pjrt/proto:compile_options_proto_cc\",\n+        \"//xla/pjrt/proto:pjrt_partial_program_proto_cc\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"partial_program_utils\",\n+    srcs = [\"partial_program_utils.cc\"],\n+    hdrs = [\"partial_program_utils.h\"],\n+    deps = [\n+        \"//xla/pjrt/proto:compile_options_proto_cc\",\n+        \"//xla/pjrt/proto:pjrt_partial_program_proto_cc\",\n+        \"@com_google_absl//absl/cleanup\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)"
        },
        {
            "sha": "8167f8294c0cc3d8f6f55a618c2dd61922a70acb",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -109,15 +109,16 @@ cc_library(\n         \":pjrt_c_api_helpers\",\n         \":pjrt_c_api_phase_compile_extension_hdrs\",\n         \":pjrt_c_api_wrapper_impl\",\n+        \"//xla/pjrt:partial_program_utils\",\n         \"//xla/pjrt:pjrt_compiler\",\n         \"//xla/pjrt:pjrt_executable\",\n+        \"//xla/pjrt:string_utils\",\n         \"//xla/pjrt/proto:compile_options_proto_cc\",\n         \"//xla/pjrt/proto:pjrt_partial_program_proto_cc\",\n-        \"@com_google_absl//absl/cleanup\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n     ],\n     alwayslink = True,\n )"
        },
        {
            "sha": "6b4de640120a37eaee809bec8f61d6e97c2338d4",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_phase_compile_internal.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 104,
            "changes": 116,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_phase_compile_internal.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_phase_compile_internal.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_phase_compile_internal.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -18,22 +18,22 @@ limitations under the License.\n #include <cstddef>\n #include <cstring>\n #include <string>\n-#include <utility>\n #include <vector>\n \n-#include \"absl/cleanup/cleanup.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_wrapper_impl.h\"\n+#include \"xla/pjrt/partial_program_utils.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/proto/compile_options.pb.h\"\n #include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n+#include \"xla/pjrt/string_utils.h\"\n \n namespace pjrt {\n \n@@ -51,114 +51,22 @@ absl::StatusOr<xla::CompileOptions> ParseCompileOptions(\n \n }  // namespace\n \n-std::vector<std::string> ConvertCharBuffersToCppStrings(\n-    const char** char_buffers, const size_t* char_buffer_sizes,\n-    size_t num_strings) {\n-  if (char_buffers == nullptr || char_buffer_sizes == nullptr) {\n-    return {};\n-  }\n-\n-  std::vector<std::string> cpp_strings;\n-  cpp_strings.reserve(num_strings);\n-  for (size_t i = 0; i < num_strings; ++i) {\n-    if (char_buffers[i] == nullptr) {\n-      cpp_strings.push_back(\"\");\n-    } else {\n-      cpp_strings.push_back(std::string(char_buffers[i], char_buffer_sizes[i]));\n-    }\n-  }\n-\n-  return cpp_strings;\n-}\n-\n-const char** ConvertCppStringsToCharBuffers(\n-    const std::vector<std::string>& strings, const size_t*& char_buffer_sizes) {\n-  auto char_buffers = new const char*[strings.size()];\n-  size_t* buffer_sizes = new size_t[strings.size()];\n-\n-  for (size_t i = 0; i < strings.size(); ++i) {\n-    const std::string& current_string = strings[i];\n-    char* buffer = new char[current_string.length() + 1];\n-    absl::SNPrintF(buffer, current_string.length() + 1, \"%s\", current_string);\n-    char_buffers[i] = buffer;\n-    buffer_sizes[i] = strlen(buffer);\n-  }\n-  char_buffer_sizes = buffer_sizes;\n-  return char_buffers;\n-}\n-\n-absl::StatusOr<std::vector<xla::PjRtPartialProgramProto>>\n-ConvertCharBuffersToPjRtPartialProgramProtos(const char** char_buffers,\n-                                             const size_t* char_buffer_sizes,\n-                                             size_t num_programs) {\n-  if (char_buffers == nullptr || char_buffer_sizes == nullptr) {\n-    return std::vector<xla::PjRtPartialProgramProto>();\n-  }\n-\n-  std::vector<xla::PjRtPartialProgramProto> partial_programs;\n-  partial_programs.reserve(num_programs);\n-  for (size_t i = 0; i < num_programs; ++i) {\n-    xla::PjRtPartialProgramProto partial_program;\n-    bool success =\n-        partial_program.ParseFromArray(char_buffers[i], char_buffer_sizes[i]);\n-    if (!success) {\n-      return absl::InvalidArgumentError(\n-          \"Failed to deserialize PjRtPartialProgramProto\");\n-    }\n-    partial_programs.push_back(partial_program);\n-  }\n-\n-  return partial_programs;\n-}\n-\n-absl::StatusOr<const char**> ConvertPjRtPartialProgramProtosToCharBuffers(\n-    const std::vector<xla::PjRtPartialProgramProto>& partial_programs,\n-    const size_t*& char_buffer_sizes) {\n-  const char** char_buffers = new const char*[partial_programs.size()]();\n-  size_t* buffer_sizes = new size_t[partial_programs.size()];\n-  absl::Cleanup cleanup_buffers = [char_buffers, buffer_sizes,\n-                                   partial_programs_size =\n-                                       partial_programs.size()] {\n-    for (size_t i = 0; i < partial_programs_size; ++i) {\n-      delete[] char_buffers[i];\n-    }\n-    delete[] char_buffers;\n-    delete[] buffer_sizes;\n-  };\n-\n-  for (size_t i = 0; i < partial_programs.size(); ++i) {\n-    const xla::PjRtPartialProgramProto& partial_program = partial_programs[i];\n-    size_t buffer_size = partial_program.ByteSizeLong();\n-    char* buffer = new char[buffer_size];\n-    bool success = partial_program.SerializeToArray(\n-        buffer, partial_program.ByteSizeLong());\n-    if (!success) {\n-      return absl::InvalidArgumentError(\n-          \"Failed to serialize PjRtPartialProgramProto\");\n-    }\n-    char_buffers[i] = buffer;\n-    buffer_sizes[i] = buffer_size;\n-  }\n-  char_buffer_sizes = buffer_sizes;\n-\n-  std::move(cleanup_buffers).Cancel();\n-  return char_buffers;\n-}\n-\n static PJRT_Error* PJRT_PhaseCompile_Run_Phase(\n     PJRT_PhaseCompile_Run_Phase_Args* args) {\n   PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n       \"PJRT_PhaseCompile_Run_Phase_Args\",\n       PJRT_PhaseCompile_Run_Phase_Args_STRUCT_SIZE, args->struct_size));\n \n-  std::vector<std::string> phases_to_run = ConvertCharBuffersToCppStrings(\n-      args->phases_to_run, args->phases_to_run_sizes, args->num_phases_to_run);\n+  std::vector<std::string> phases_to_run = xla::ConvertCharBuffersToCppStrings(\n+      absl::MakeSpan(args->phases_to_run, args->num_phases_to_run),\n+      absl::MakeConstSpan(args->phases_to_run_sizes, args->num_phases_to_run));\n \n   PJRT_ASSIGN_OR_RETURN(\n       std::vector<xla::PjRtPartialProgramProto> programs_in_protos,\n-      ConvertCharBuffersToPjRtPartialProgramProtos(args->input_programs,\n-                                                   args->input_programs_sizes,\n-                                                   args->num_input_programs));\n+      xla::ConvertCharBuffersToPjRtPartialProgramProtos(\n+          absl::MakeSpan(args->input_programs, args->num_input_programs),\n+          absl::MakeConstSpan(args->input_programs_sizes,\n+                              args->num_input_programs)));\n \n   PJRT_ASSIGN_OR_RETURN(\n       xla::CompileOptions options,\n@@ -175,7 +83,7 @@ static PJRT_Error* PJRT_PhaseCompile_Run_Phase(\n                             *args->topology->topology, phases_to_run));\n \n   PJRT_ASSIGN_OR_RETURN(args->output_programs,\n-                        ConvertPjRtPartialProgramProtosToCharBuffers(\n+                        xla::ConvertPjRtPartialProgramProtosToCharBuffers(\n                             programs_out, args->output_programs_sizes));\n   args->num_output_programs = programs_out.size();\n \n@@ -196,7 +104,7 @@ static PJRT_Error* PJRT_PhaseCompile_Get_Phase_Names(\n                         args->phase_compiler->compiler->GetPhaseNames());\n \n   args->phase_names =\n-      ConvertCppStringsToCharBuffers(phase_names, args->phase_names_sizes);\n+      xla::ConvertCppStringsToCharBuffers(phase_names, args->phase_names_sizes);\n   args->num_phase_names = phase_names.size();\n \n   return nullptr;"
        },
        {
            "sha": "c112bbf036f119e3b01a2e299f12ec1ab35b3d74",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_phase_compile_internal.h",
            "status": "modified",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_phase_compile_internal.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_phase_compile_internal.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_phase_compile_internal.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -16,46 +16,13 @@ limitations under the License.\n #ifndef XLA_PJRT_C_PJRT_C_API_PHASE_COMPILE_INTERNAL_H_\n #define XLA_PJRT_C_PJRT_C_API_PHASE_COMPILE_INTERNAL_H_\n \n-#include <cstddef>\n-#include <string>\n-#include <vector>\n \n-#include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n #include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n \n namespace pjrt {\n \n-// Converts an array of C-style character buffers along with their sizes to a\n-// vector of C++ strings.\n-std::vector<std::string> ConvertCharBuffersToCppStrings(\n-    const char** char_buffers, const size_t* char_buffer_sizes,\n-    size_t num_strings);\n-\n-// Converts a vector of C++ strings to an array of C-style character buffers and\n-// their sizes. This function allocates memory for the character buffers, the\n-// individual C-strings, and `char_buffer_sizes`.\n-const char** ConvertCppStringsToCharBuffers(\n-    const std::vector<std::string>& strings, const size_t*& char_buffer_sizes);\n-\n-// Converts an array of C-style character buffers along with their sizes to a\n-// vector of `PjRtPartialProgramProto`s.\n-absl::StatusOr<std::vector<xla::PjRtPartialProgramProto>>\n-ConvertCharBuffersToPjRtPartialProgramProtos(const char** char_buffers,\n-                                             const size_t* char_buffer_sizes,\n-                                             size_t num_programs);\n-\n-// Converts a vector of `PjRtPartialProgramProto`s to an array of C-style\n-// character buffers and their sizes. This function allocates memory for the\n-// `char_buffers`, the individual serialized protos, and `char_buffer_sizes`.\n-// In case the partial programs cannot be serialized, this function frees the\n-// allocated memory.\n-absl::StatusOr<const char**> ConvertPjRtPartialProgramProtosToCharBuffers(\n-    const std::vector<xla::PjRtPartialProgramProto>& partial_programs,\n-    const size_t*& char_buffer_sizes);\n-\n // Creates and initializes a PJRT_PhaseCompile_Extension struct. This function\n // is used by plugins to create and chain the phase compilation extension\n // into the PJRT C API structure."
        },
        {
            "sha": "e14baa666935a87115c9920c65e4414761fa5547",
            "filename": "third_party/xla/xla/pjrt/c_api_client/BUILD",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -26,8 +26,14 @@ package_group(\n \n cc_library(\n     name = \"pjrt_c_api_client\",\n-    srcs = [\"pjrt_c_api_client.cc\"],\n-    hdrs = [\"pjrt_c_api_client.h\"],\n+    srcs = [\n+        \"pjrt_c_api_client.cc\",\n+        \"pjrt_c_api_phase_compiler.cc\",\n+    ],\n+    hdrs = [\n+        \"pjrt_c_api_client.h\",\n+        \"pjrt_c_api_phase_compiler.h\",\n+    ],\n     visibility = internal_visibility([\":friends\"]),\n     deps = [\n         \"//xla:future\",\n@@ -42,6 +48,7 @@ cc_library(\n         \"//xla/hlo/translate/mhlo_to_hlo:mlir_hlo_to_hlo\",\n         \"//xla/mlir_hlo:mhlo_passes\",\n         \"//xla/pjrt:mlir_to_hlo\",\n+        \"//xla/pjrt:partial_program_utils\",\n         \"//xla/pjrt:pjrt_api\",\n         \"//xla/pjrt:pjrt_client\",\n         \"//xla/pjrt:pjrt_common\",\n@@ -50,11 +57,13 @@ cc_library(\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_future\",\n         \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/pjrt:string_utils\",\n         \"//xla/pjrt/c:pjrt_c_api_ffi_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_helpers\",\n         \"//xla/pjrt/c:pjrt_c_api_layouts_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_memory_descriptions_extension_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_phase_compile_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_profiler_extension_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_stream_extension_hdrs\",\n         \"//xla/pjrt/distributed:key_value_store_interface\","
        },
        {
            "sha": "61e80f04d6f4117e0ba93d4f7743aa3fe97b0ddb",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -20,14 +20,20 @@ limitations under the License.\n #include <functional>\n #include <memory>\n #include <optional>\n+#include <string>\n+#include <utility>\n #include <variant>\n+#include <vector>\n \n #include \"absl/cleanup/cleanup.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/inlined_vector.h\"\n #include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n@@ -39,6 +45,7 @@ limitations under the License.\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/translate/mhlo_to_hlo/mlir_hlo_to_hlo.h\"\n #include \"xla/layout.h\"\n #include \"xla/layout_util.h\"\n@@ -49,8 +56,10 @@ limitations under the License.\n #include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n #include \"xla/pjrt/c/pjrt_c_api_layouts_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_memory_descriptions_extension.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_profiler_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_stream_extension.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_phase_compiler.h\"\n #include \"xla/pjrt/distributed/key_value_store_interface.h\"\n #include \"xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.h\"\n #include \"xla/pjrt/extensions/executable_metadata/executable_metadata_extension.h\"\n@@ -74,6 +83,7 @@ limitations under the License.\n #include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/protobuf/coordination_service.pb.h\"\n+#include \"xla/util.h\"\n #include \"xla/xla.pb.h\"\n #include \"xla/xla_data.pb.h\"\n #include \"tsl/platform/casts.h\"\n@@ -3275,4 +3285,60 @@ absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler() {\n   return GetCApiCompiler(device_types[0]);\n }\n \n+absl::StatusOr<std::unique_ptr<PjRtPhaseCompiler>> GetCApiPhaseCompiler(\n+    absl::string_view device_type) {\n+  TF_ASSIGN_OR_RETURN(const PJRT_Api* c_api, pjrt::PjrtApi(device_type));\n+  if (c_api == nullptr) {\n+    return absl::InternalError(\n+        absl::StrCat(\"PJRT C API is nullptr for \", device_type));\n+  }\n+  // Ensure the Phase Compile extension is available and that the\n+  // 'phase_compile_get_compiler' and 'phase_compile_destroy_compiler'\n+  // callbacks are defined, as they are mandatory for the PjRtCApiPhaseCompiler\n+  // to function.\n+  auto phase_compile_extension =\n+      pjrt::FindExtension<PJRT_PhaseCompile_Extension>(\n+          c_api, PJRT_Extension_Type::PJRT_Extension_Type_PhaseCompile);\n+  if (phase_compile_extension == nullptr) {\n+    return absl::InternalError(\"Phase compile extension not found\");\n+  }\n+\n+  if (phase_compile_extension->phase_compile_get_compiler == nullptr) {\n+    return absl::InternalError(\n+        \"phase_compile_get_compiler callback of the phase compile extension \"\n+        \"must not be null\");\n+  }\n+  if (phase_compile_extension->phase_compile_destroy_compiler == nullptr) {\n+    return absl::InternalError(\n+        \"phase_compile_destroy_compiler callback of the phase compile \"\n+        \"extension must not be null\");\n+  }\n+\n+  PJRT_PhaseCompile_Get_Compiler_Args get_compiler_args;\n+  get_compiler_args.struct_size =\n+      PJRT_PhaseCompile_Get_Compiler_Args_STRUCT_SIZE;\n+  get_compiler_args.extension_start = nullptr;\n+  RETURN_STATUS_IF_PJRT_ERROR(\n+      phase_compile_extension->phase_compile_get_compiler(&get_compiler_args),\n+      c_api);\n+\n+  return std::make_unique<PjRtCApiPhaseCompiler>(\n+      c_api, phase_compile_extension, get_compiler_args.phase_compiler);\n+}\n+\n+absl::StatusOr<std::unique_ptr<PjRtPhaseCompiler>> GetCApiPhaseCompiler() {\n+  TF_ASSIGN_OR_RETURN(std::vector<std::string> device_types,\n+                      pjrt::GetRegisteredPjrtApis());\n+  if (device_types.empty()) {\n+    return absl::FailedPreconditionError(\"PJRT_Api is not initialized.\");\n+  }\n+  if (device_types.size() > 1) {\n+    return absl::FailedPreconditionError(\n+        \"More than one device type registered. Please use \"\n+        \"GetCApiPhaseCompiler(absl::string_view device_type) \"\n+        \"instead.\");\n+  }\n+  return GetCApiPhaseCompiler(device_types[0]);\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "78f422e882ddf977724f9aadab26791271b9f0f4",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -809,6 +809,11 @@ absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler(\n \n absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler();\n \n+absl::StatusOr<std::unique_ptr<PjRtPhaseCompiler>> GetCApiPhaseCompiler(\n+    absl::string_view device_type);\n+\n+absl::StatusOr<std::unique_ptr<PjRtPhaseCompiler>> GetCApiPhaseCompiler();\n+\n }  // namespace xla\n \n #endif  // XLA_PJRT_C_API_CLIENT_PJRT_C_API_CLIENT_H_"
        },
        {
            "sha": "265a965553f434eadc2a732899b3e247e253dc21",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_phase_compiler.cc",
            "status": "renamed",
            "additions": 59,
            "deletions": 72,
            "changes": 131,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_phase_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_phase_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_phase_compiler.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -13,30 +13,32 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include \"xla/pjrt/pjrt_phase_compile.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_phase_compiler.h\"\n \n #include <algorithm>\n #include <cstddef>\n-#include <memory>\n #include <string>\n #include <vector>\n \n #include \"absl/cleanup/cleanup.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n-#include \"xla/pjrt/c/pjrt_c_api_phase_compile_internal.h\"\n-#include \"xla/pjrt/pjrt_c_api_client.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_client.h\"\n+#include \"xla/pjrt/partial_program_utils.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n+#include \"xla/pjrt/string_utils.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"tsl/platform/casts.h\"\n \n-namespace pjrt {\n+namespace xla {\n+\n namespace {\n \n // Checks if the input partial programs are compatible with the first phase in\n@@ -63,17 +65,10 @@ absl::Status ValidatePhases(\n // Cleans up C buffers allocated by the caller-side code and passed to the\n // plugin-side code. Example buffers include those used to propagate\n // input programs, names of phases to run.\n-void CleanUpCallerDefinedCBuffers(const char** char_buffers,\n-                                  const size_t* char_buffer_sizes,\n-                                  size_t num_char_buffers) {\n-  if (char_buffers != nullptr) {\n-    for (size_t i = 0; i < num_char_buffers; ++i) {\n-      delete[] char_buffers[i];\n-    }\n+void CleanUpCallerDefinedCBuffers(absl::Span<const char* const> char_buffers) {\n+  for (const char* buffer : char_buffers) {\n+    delete[] buffer;\n   }\n-\n-  delete[] char_buffers;\n-  delete[] char_buffer_sizes;\n }\n \n // Cleans up C buffers allocated by the plugin-side code and passed to the\n@@ -95,61 +90,49 @@ void CleanUpPluginDefinedCBuffers(\n \n }  // namespace\n \n-absl::StatusOr<std::unique_ptr<CApiPjrtPhaseCompiler>> GetCApiPjrtPhaseCompiler(\n-    const PJRT_Api* api) {\n-  // Ensure the Phase Compile extension is available and that the\n-  // 'phase_compile_get_compiler' and 'phase_compile_destroy_compiler'\n-  // callbacks are defined, as they are mandatory for the CApiPjrtPhaseCompiler\n-  // to function.\n-  auto phase_compile_extension =\n-      pjrt::FindExtension<PJRT_PhaseCompile_Extension>(\n-          api, PJRT_Extension_Type::PJRT_Extension_Type_PhaseCompile);\n-  if (phase_compile_extension == nullptr) {\n-    return absl::InternalError(\"Phase compile extension not found\");\n-  }\n-\n-  if (phase_compile_extension->phase_compile_get_compiler == nullptr) {\n-    return absl::InternalError(\n-        \"phase_compile_get_compiler callback of the phase compile extension \"\n-        \"must not be null\");\n-  }\n-  if (phase_compile_extension->phase_compile_destroy_compiler == nullptr) {\n-    return absl::InternalError(\n-        \"phase_compile_destroy_compiler callback of the phase compile \"\n-        \"extension must not be null\");\n-  }\n-\n-  PJRT_PhaseCompile_Get_Compiler_Args get_compiler_args;\n-  get_compiler_args.struct_size =\n-      PJRT_PhaseCompile_Get_Compiler_Args_STRUCT_SIZE;\n-  get_compiler_args.extension_start = nullptr;\n-  RETURN_STATUS_IF_PJRT_ERROR(\n-      phase_compile_extension->phase_compile_get_compiler(&get_compiler_args),\n-      api);\n-\n-  return std::make_unique<CApiPjrtPhaseCompiler>(\n-      api, phase_compile_extension, get_compiler_args.phase_compiler);\n+PjRtCApiPhaseCompiler::PjRtCApiPhaseCompiler(\n+    const PJRT_Api* api,\n+    const PJRT_PhaseCompile_Extension* phase_compile_extension,\n+    const PJRT_PhaseCompiler* phase_compiler)\n+    : api_(api),\n+      phase_compile_extension_(phase_compile_extension),\n+      phase_compiler_(\n+          phase_compiler,\n+          [phase_compile_extension](const PJRT_PhaseCompiler* p_compiler) {\n+            PJRT_PhaseCompile_Destroy_Compiler_Args destroy_args;\n+            destroy_args.struct_size =\n+                PJRT_PhaseCompile_Destroy_Compiler_Args_STRUCT_SIZE;\n+            destroy_args.extension_start = nullptr;\n+            destroy_args.phase_compiler = p_compiler;\n+            phase_compile_extension->phase_compile_destroy_compiler(\n+                &destroy_args);\n+          }) {}\n+\n+// Returns the reference to the phase compiler.\n+const PJRT_PhaseCompiler* PjRtCApiPhaseCompiler::GetPhaseCompiler() const {\n+  return phase_compiler_.get();\n }\n \n absl::StatusOr<std::vector<std::string>>\n-CApiPjrtPhaseCompiler::GetPhaseNames() {\n+PjRtCApiPhaseCompiler::GetPhaseNames() {\n   PJRT_PhaseCompile_Get_PhaseNames_Args args;\n   args.struct_size = PJRT_PhaseCompile_Get_PhaseNames_Args_STRUCT_SIZE;\n   args.extension_start = nullptr;\n   args.phase_compiler = GetPhaseCompiler();\n   RETURN_STATUS_IF_PJRT_ERROR(\n       phase_compile_extension_->phase_compile_get_phase_names(&args), api_);\n \n-  std::vector<std::string> phase_names = ConvertCharBuffersToCppStrings(\n-      args.phase_names, args.phase_names_sizes, args.num_phase_names);\n+  std::vector<std::string> phase_names = xla::ConvertCharBuffersToCppStrings(\n+      absl::MakeSpan(args.phase_names, args.num_phase_names),\n+      absl::MakeConstSpan(args.phase_names_sizes, args.num_phase_names));\n   CleanUpPluginDefinedCBuffers(args.phase_names, args.phase_names_sizes,\n                                args.num_phase_names, phase_compile_extension_);\n \n   return phase_names;\n }\n \n absl::StatusOr<std::vector<xla::PjRtPartialProgramProto>>\n-CApiPjrtPhaseCompiler::RunPhases(\n+PjRtCApiPhaseCompiler::RunPhases(\n     xla::CompileOptions options,\n     const std::vector<xla::PjRtPartialProgramProto>& partial_programs_in,\n     const xla::PjRtTopologyDescription& topology,\n@@ -161,31 +144,34 @@ CApiPjrtPhaseCompiler::RunPhases(\n       tensorflow::down_cast<const xla::PjRtCApiTopologyDescription*>(&topology)\n           ->c_topology();\n \n-  const size_t* programs_in_buffer_sizes = nullptr;\n+  const size_t* programs_in_buffer_sizes;\n   TF_ASSIGN_OR_RETURN(const char** programs_in_buffers,\n-                      ConvertPjRtPartialProgramProtosToCharBuffers(\n+                      xla::ConvertPjRtPartialProgramProtosToCharBuffers(\n                           partial_programs_in, programs_in_buffer_sizes));\n   size_t num_programs_in = partial_programs_in.size();\n   absl::Cleanup cleanup_programs_in_buffers =\n       [programs_in_buffers, programs_in_buffer_sizes, num_programs_in] {\n-        CleanUpCallerDefinedCBuffers(programs_in_buffers,\n-                                     programs_in_buffer_sizes, num_programs_in);\n+        CleanUpCallerDefinedCBuffers(\n+            absl::MakeConstSpan(programs_in_buffers, num_programs_in));\n+        delete[] programs_in_buffer_sizes;\n+        delete[] programs_in_buffers;\n       };\n \n   TF_ASSIGN_OR_RETURN(const xla::CompileOptionsProto options_proto,\n                       options.ToProto());\n   std::string options_str = options_proto.SerializeAsString();\n \n-  const size_t* phases_to_run_buffer_sizes = nullptr;\n+  const size_t* phases_to_run_buffer_sizes;\n   size_t num_phases_to_run = phases_to_run.size();\n-  const char** phases_to_run_buffers =\n-      ConvertCppStringsToCharBuffers(phases_to_run, phases_to_run_buffer_sizes);\n-  absl::Cleanup cleanup_phases_to_run_buffers = [phases_to_run_buffers,\n-                                                 phases_to_run_buffer_sizes,\n-                                                 num_phases_to_run]() {\n-    CleanUpCallerDefinedCBuffers(phases_to_run_buffers,\n-                                 phases_to_run_buffer_sizes, num_phases_to_run);\n-  };\n+  const char** phases_to_run_buffers = xla::ConvertCppStringsToCharBuffers(\n+      phases_to_run, phases_to_run_buffer_sizes);\n+  absl::Cleanup cleanup_phases_to_run_buffers =\n+      [phases_to_run_buffers, phases_to_run_buffer_sizes, num_phases_to_run]() {\n+        CleanUpCallerDefinedCBuffers(\n+            absl::MakeConstSpan(phases_to_run_buffers, num_phases_to_run));\n+        delete[] phases_to_run_buffer_sizes;\n+        delete[] phases_to_run_buffers;\n+      };\n \n   PJRT_PhaseCompile_Run_Phase_Args run_args;\n   run_args.struct_size = PJRT_PhaseCompile_Run_Phase_Args_STRUCT_SIZE;\n@@ -204,16 +190,17 @@ CApiPjrtPhaseCompiler::RunPhases(\n   RETURN_STATUS_IF_PJRT_ERROR(\n       phase_compile_extension_->phase_compile_run_phases(&run_args), api_);\n \n-  TF_ASSIGN_OR_RETURN(\n-      std::vector<xla::PjRtPartialProgramProto> output_programs,\n-      ConvertCharBuffersToPjRtPartialProgramProtos(\n-          run_args.output_programs, run_args.output_programs_sizes,\n-          run_args.num_output_programs));\n+  TF_ASSIGN_OR_RETURN(std::vector<xla::PjRtPartialProgramProto> output_programs,\n+                      xla::ConvertCharBuffersToPjRtPartialProgramProtos(\n+                          absl::MakeSpan(run_args.output_programs,\n+                                         run_args.num_output_programs),\n+                          absl::MakeConstSpan(run_args.output_programs_sizes,\n+                                              run_args.num_output_programs)));\n   CleanUpPluginDefinedCBuffers(\n       run_args.output_programs, run_args.output_programs_sizes,\n       run_args.num_output_programs, phase_compile_extension_);\n \n   return output_programs;\n }\n \n-}  // namespace pjrt\n+}  // namespace xla",
            "previous_filename": "third_party/xla/xla/pjrt/pjrt_phase_compile.cc"
        },
        {
            "sha": "8d368526fddcf5a630cc0ea077d9c0e14b9add85",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_phase_compiler.h",
            "status": "renamed",
            "additions": 36,
            "deletions": 34,
            "changes": 70,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_phase_compiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_phase_compiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_phase_compiler.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -13,46 +13,33 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#ifndef XLA_PJRT_PJRT_PHASE_COMPILE_H_\n-#define XLA_PJRT_PJRT_PHASE_COMPILE_H_\n+#ifndef XLA_PJRT_C_API_CLIENT_PJRT_C_API_PHASE_COMPILER_H_\n+#define XLA_PJRT_C_API_CLIENT_PJRT_C_API_PHASE_COMPILER_H_\n \n #include <functional>\n #include <memory>\n #include <string>\n #include <vector>\n \n+#include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"mlir/IR/BuiltinOps.h\"\n+#include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n \n-// This file defines the C++ convenience wrappers and internal functions for\n-// the PJRT Phase Compile C API extension. It provides higher-level interfaces\n-// for interacting with the phase compilation features, bridging between the\n-// low-level C API and XLA's C++ components.\n+namespace xla {\n \n-namespace pjrt {\n-\n-class CApiPjrtPhaseCompiler {\n+// This class is a wrapper around the PJRT C API PhaseCompiler. It provides a\n+// C++ interface for the phase compiler.\n+class PjRtCApiPhaseCompiler : public PjRtPhaseCompiler {\n  public:\n-  CApiPjrtPhaseCompiler(\n+  PjRtCApiPhaseCompiler(\n       const PJRT_Api* api,\n       const PJRT_PhaseCompile_Extension* phase_compile_extension,\n-      const PJRT_PhaseCompiler* phase_compiler)\n-      : api_(api),\n-        phase_compile_extension_(phase_compile_extension),\n-        phase_compiler_(\n-            phase_compiler,\n-            [phase_compile_extension](const PJRT_PhaseCompiler* p_compiler) {\n-              PJRT_PhaseCompile_Destroy_Compiler_Args destroy_args;\n-              destroy_args.struct_size =\n-                  PJRT_PhaseCompile_Destroy_Compiler_Args_STRUCT_SIZE;\n-              destroy_args.extension_start = nullptr;\n-              destroy_args.phase_compiler = p_compiler;\n-              phase_compile_extension->phase_compile_destroy_compiler(\n-                  &destroy_args);\n-            }) {}\n+      const PJRT_PhaseCompiler* phase_compiler);\n \n   // Runs the compilation phase with the given phases 'phases_to_run' on the\n   // input programs 'partial_programs_in' and returns the output programs.\n@@ -63,17 +50,36 @@ class CApiPjrtPhaseCompiler {\n       xla::CompileOptions options,\n       const std::vector<xla::PjRtPartialProgramProto>& partial_programs_in,\n       const xla::PjRtTopologyDescription& topology,\n-      const std::vector<std::string>& phases_to_run);\n+      const std::vector<std::string>& phases_to_run) override;\n \n   // Returns the names of all the phases following the order of their\n   // registration.\n-  absl::StatusOr<std::vector<std::string>> GetPhaseNames();\n+  absl::StatusOr<std::vector<std::string>> GetPhaseNames() override;\n \n   // Returns the reference to the phase compiler.\n-  const PJRT_PhaseCompiler* GetPhaseCompiler() const {\n-    return phase_compiler_.get();\n+  const PJRT_PhaseCompiler* GetPhaseCompiler() const;\n+\n+  // Compiles the 'computation' and returns a 'PjRtExecutable'. The returned\n+  // PjRtExecutable must be loaded by a compatible client before execution.\n+  absl::StatusOr<std::unique_ptr<PjRtExecutable>> Compile(\n+      CompileOptions options, const XlaComputation& computation,\n+      const PjRtTopologyDescription& topology, PjRtClient* client) override {\n+    return absl::UnimplementedError(\n+        \"PjRtCApiPhaseCompiler::Compile is not implemented.\");\n+  }\n+\n+  // Variant of `Compile` that accepts an MLIR module.\n+  absl::StatusOr<std::unique_ptr<PjRtExecutable>> Compile(\n+      CompileOptions options, mlir::ModuleOp module,\n+      const PjRtTopologyDescription& topology, PjRtClient* client) override {\n+    return absl::UnimplementedError(\n+        \"PjRtCApiPhaseCompiler::Compile is not implemented.\");\n   }\n \n+  // CApiPhaseCompiler does not need to provide a registration of phases, as it\n+  // is wrapping a plugin-initialized phase compiler.\n+  absl::Status RegisterAllPhases() override { return absl::OkStatus(); }\n+\n  private:\n   const PJRT_Api* api_ = nullptr;  // Not owned.\n   const PJRT_PhaseCompile_Extension* phase_compile_extension_ =\n@@ -83,10 +89,6 @@ class CApiPjrtPhaseCompiler {\n       phase_compiler_;\n };\n \n-// Creates and initializes a `CApiPjrtPhaseCompiler` instance.\n-absl::StatusOr<std::unique_ptr<CApiPjrtPhaseCompiler>> GetCApiPjrtPhaseCompiler(\n-    const PJRT_Api* api);\n-\n-}  // namespace pjrt\n+}  // namespace xla\n \n-#endif  // XLA_PJRT_PJRT_PHASE_COMPILE_H_\n+#endif  // XLA_PJRT_C_API_CLIENT_PJRT_C_API_PHASE_COMPILER_H_",
            "previous_filename": "third_party/xla/xla/pjrt/pjrt_phase_compile.h"
        },
        {
            "sha": "c7568af47e565c4ddf2cb6c8459176e82c0b0eef",
            "filename": "third_party/xla/xla/pjrt/partial_program_utils.cc",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpartial_program_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpartial_program_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpartial_program_utils.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -0,0 +1,93 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/pjrt/partial_program_utils.h\"\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/cleanup/cleanup.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/pjrt/proto/compile_options.pb.h\"\n+#include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n+\n+namespace xla {\n+\n+absl::StatusOr<std::vector<xla::PjRtPartialProgramProto>>\n+ConvertCharBuffersToPjRtPartialProgramProtos(\n+    absl::Span<const char*> char_buffers,\n+    absl::Span<const size_t> char_buffer_sizes) {\n+  if (char_buffers.empty() || char_buffer_sizes.empty()) {\n+    return std::vector<xla::PjRtPartialProgramProto>();\n+  }\n+  if (char_buffers.size() != char_buffer_sizes.size()) {\n+    return absl::InvalidArgumentError(\n+        \"char_buffers and char_buffer_sizes must have the same size\");\n+  }\n+\n+  std::vector<xla::PjRtPartialProgramProto> partial_programs;\n+  partial_programs.reserve(char_buffers.size());\n+  for (size_t i = 0; i < char_buffers.size(); ++i) {\n+    xla::PjRtPartialProgramProto partial_program;\n+    bool success =\n+        partial_program.ParseFromArray(char_buffers[i], char_buffer_sizes[i]);\n+    if (!success) {\n+      return absl::InvalidArgumentError(\n+          \"Failed to deserialize PjRtPartialProgramProto\");\n+    }\n+    partial_programs.push_back(partial_program);\n+  }\n+\n+  return partial_programs;\n+}\n+\n+absl::StatusOr<const char**> ConvertPjRtPartialProgramProtosToCharBuffers(\n+    const std::vector<xla::PjRtPartialProgramProto>& partial_programs,\n+    const size_t*& char_buffer_sizes) {\n+  const size_t num_programs = partial_programs.size();\n+  const char** char_buffers = new const char*[num_programs]();\n+  size_t* buffer_sizes = new size_t[num_programs];\n+  absl::Cleanup cleanup_buffers = [char_buffers, buffer_sizes, num_programs] {\n+    for (size_t i = 0; i < num_programs; ++i) {\n+      delete[] char_buffers[i];\n+    }\n+    delete[] char_buffers;\n+    delete[] buffer_sizes;\n+  };\n+\n+  for (size_t i = 0; i < num_programs; ++i) {\n+    const xla::PjRtPartialProgramProto& partial_program = partial_programs[i];\n+    size_t buffer_size = partial_program.ByteSizeLong();\n+    char* buffer = new char[buffer_size];\n+    bool success = partial_program.SerializeToArray(buffer, buffer_size);\n+    if (!success) {\n+      return absl::InvalidArgumentError(\n+          \"Failed to serialize PjRtPartialProgramProto\");\n+    }\n+    char_buffers[i] = buffer;\n+    buffer_sizes[i] = buffer_size;\n+  }\n+  char_buffer_sizes = buffer_sizes;\n+\n+  std::move(cleanup_buffers).Cancel();\n+  return char_buffers;\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "5b4b8622caf6e5080a49f47e3dfb154ff943df92",
            "filename": "third_party/xla/xla/pjrt/partial_program_utils.h",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpartial_program_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpartial_program_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpartial_program_utils.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -0,0 +1,48 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PJRT_PARTIAL_PROGRAM_UTILS_H_\n+#define XLA_PJRT_PARTIAL_PROGRAM_UTILS_H_\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <vector>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/pjrt/proto/compile_options.pb.h\"\n+#include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n+\n+namespace xla {\n+\n+// Converts an array of C-style character buffers along with their sizes to a\n+// vector of `PjRtPartialProgramProto`s.\n+absl::StatusOr<std::vector<xla::PjRtPartialProgramProto>>\n+ConvertCharBuffersToPjRtPartialProgramProtos(\n+    absl::Span<const char*> char_buffers,\n+    absl::Span<const size_t> char_buffer_sizes);\n+\n+// Converts a vector of `PjRtPartialProgramProto`s to an array of C-style\n+// character buffers and their sizes. This function allocates memory for the\n+// `char_buffers`, the individual serialized protos, and `char_buffer_sizes`.\n+// In case the partial programs cannot be serialized, this function frees the\n+// allocated memory.\n+absl::StatusOr<const char**> ConvertPjRtPartialProgramProtosToCharBuffers(\n+    const std::vector<xla::PjRtPartialProgramProto>& partial_programs,\n+    const size_t*& char_buffer_sizes);\n+\n+}  // namespace xla\n+\n+#endif  // XLA_PJRT_PARTIAL_PROGRAM_UTILS_H_"
        },
        {
            "sha": "c08cbb2715694f4211d729b7227a10730a7f9dcf",
            "filename": "third_party/xla/xla/pjrt/pjrt_compiler.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_compiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_compiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_compiler.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -248,7 +248,7 @@ class PjRtPhaseCompiler : public PjRtCompiler {\n \n   // Returns a vector of strings containing the names of all registered phases\n   // in the order they were registered.\n-  absl::StatusOr<std::vector<std::string>> GetPhaseNames();\n+  virtual absl::StatusOr<std::vector<std::string>> GetPhaseNames();\n \n   // Compiles a set of input programs by running them through a specified\n   // sequence of compilation phases. This function internally calls\n@@ -257,7 +257,7 @@ class PjRtPhaseCompiler : public PjRtCompiler {\n   // of one phase is passed as input to the next. Returns the vector of\n   // `PjRtPartialProgramProto` objects resulting from the last executed phase,\n   // or an error status if any validation or compilation step fails.\n-  absl::StatusOr<std::vector<PjRtPartialProgramProto>> RunPhases(\n+  virtual absl::StatusOr<std::vector<PjRtPartialProgramProto>> RunPhases(\n       CompileOptions options,\n       const std::vector<PjRtPartialProgramProto>& input_programs,\n       const PjRtTopologyDescription& topology,"
        },
        {
            "sha": "2c51cdee5125aae639e68e5970807586c5b4d6a4",
            "filename": "third_party/xla/xla/pjrt/pjrt_phase_compile_extension_test.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 45,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_extension_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_extension_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_extension_test.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -13,7 +13,6 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include <cstdlib>\n #include <memory>\n #include <string>\n #include <utility>\n@@ -23,35 +22,30 @@ limitations under the License.\n #include <gtest/gtest.h>\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/OwningOpRef.h\"\n #include \"mlir/Support/LLVM.h\"\n #include \"stablehlo/reference/Api.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n-#include \"xla/pjrt/c/pjrt_c_api_cpu_internal.h\"\n-#include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n-#include \"xla/pjrt/c/pjrt_c_api_phase_compile_internal.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_client.h\"\n #include \"xla/pjrt/pjrt_api.h\"\n-#include \"xla/pjrt/pjrt_c_api_client.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n-#include \"xla/pjrt/pjrt_phase_compile.h\"\n #include \"xla/pjrt/pjrt_phase_compile_sample_plugin.h\"\n #include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n+#include \"xla/pjrt/string_utils.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n-#include \"xla/tsl/platform/status_matchers.h\"\n \n namespace pjrt {\n namespace {\n \n using ::testing::ElementsAre;\n using ::testing::HasSubstr;\n-using ::tsl::testing::IsOkAndHolds;\n-using ::tsl::testing::StatusIs;\n \n constexpr absl::string_view kStablehloModuleStr = R\"(\n   module {\n@@ -66,6 +60,17 @@ constexpr absl::string_view kStablehloModuleStr = R\"(\n constexpr absl::string_view kStablehloBytecodeFormat = \"bytecode\";\n constexpr absl::string_view kPhaseName = \"stablehlo_to_optimized_stablehlo\";\n \n+// We don't need a plugin registration target for this test, but we need to\n+// ensure that the plugin is registered before the first use of the phase\n+// compiler. Thus, we use a static initializer to ensure that the plugin is\n+// registered before the PhaseCompileExtensionTest class is instantiated.\n+bool sample_plugin_registered = []() {\n+  auto status = pjrt::SetPjrtApi(\n+      \"sample-cpu\",\n+      pjrt::phase_compile_sample_plugin::GetSamplePhaseCompilePjrtApi());\n+  return status.ok();\n+}();\n+\n std::vector<xla::PjRtPartialProgramProto> PrepareInputPartialPrograms(\n     const std::string& next_phase, const absl::string_view program_format) {\n   std::string program_code{kStablehloModuleStr};\n@@ -92,43 +97,16 @@ std::vector<xla::PjRtPartialProgramProto> PrepareInputPartialPrograms(\n \n class PhaseCompileExtensionTest : public ::testing::Test {\n  protected:\n-  std::unique_ptr<pjrt::CApiPjrtPhaseCompiler> phase_compile_extension_wrapper_;\n+  std::unique_ptr<xla::PjRtPhaseCompiler> phase_compile_extension_wrapper_;\n   const xla::PjRtTopologyDescription* topology_description_;\n   std::unique_ptr<xla::PjRtClient> client_;\n \n   PhaseCompileExtensionTest() {\n-    // For the CPU plugin, a few callbacks for the phase compile extension are\n-    // set to null. So we need to set them with the ones from the sample plugin\n-    // for testing.\n-\n-    // During the first test case, the registration won't have occurred yet, so\n-    // we expect a failure and need to register explicitly.\n-    auto api = PjrtApi(\"cpu\");\n-    if (!api.ok()) {\n-      CHECK_OK(pjrt::SetPjrtApi(\"cpu\", cpu_plugin::GetCpuPjrtApi()));\n-    }\n-    api = PjrtApi(\"cpu\");\n-    CHECK_OK(api);\n-    auto phase_compile_extension =\n-        pjrt::FindExtension<PJRT_PhaseCompile_Extension>(\n-            *api, PJRT_Extension_Type::PJRT_Extension_Type_PhaseCompile);\n-    PJRT_PhaseCompile_Extension sample_plugin_phase_compile_extension =\n-        pjrt::phase_compile_sample_plugin::CreateSamplePhaseCompileExtension();\n-    phase_compile_extension->phase_compile_get_compiler =\n-        sample_plugin_phase_compile_extension.phase_compile_get_compiler;\n-    phase_compile_extension->phase_compile_destroy_compiler =\n-        sample_plugin_phase_compile_extension.phase_compile_destroy_compiler;\n-\n-    // Get the phase compile extension wrapper.\n-    absl::StatusOr<std::unique_ptr<pjrt::CApiPjrtPhaseCompiler>>\n-        phase_compile_extension_wrapper_or_status =\n-            pjrt::GetCApiPjrtPhaseCompiler(*api);\n-    CHECK_OK(phase_compile_extension_wrapper_or_status);\n-    phase_compile_extension_wrapper_ =\n-        std::move(*phase_compile_extension_wrapper_or_status);\n+    auto phase_compile_extension = xla::GetCApiPhaseCompiler(\"sample-cpu\");\n+    phase_compile_extension_wrapper_ = std::move(*phase_compile_extension);\n \n     // Create a topology description.\n-    auto client_or_status = xla::GetCApiClient(\"cpu\");\n+    auto client_or_status = xla::GetCApiClient(\"sample-cpu\");\n     CHECK_OK(client_or_status);\n     client_ = std::move(*client_or_status);\n     auto topology_or_status = client_->GetTopologyDescription();\n@@ -178,10 +156,11 @@ TEST(BasicPhaseCompileExtensionTest,\n   ASSERT_EQ(error, nullptr);\n   // Convert the C-style phase names to C++ strings.\n   std::vector<std::string> converted_strings =\n-      pjrt::ConvertCharBuffersToCppStrings(\n-          get_phase_names_args.phase_names,\n-          get_phase_names_args.phase_names_sizes,\n-          get_phase_names_args.num_phase_names);\n+      xla::ConvertCharBuffersToCppStrings(\n+          absl::MakeSpan(get_phase_names_args.phase_names,\n+                         get_phase_names_args.num_phase_names),\n+          absl::MakeConstSpan(get_phase_names_args.phase_names_sizes,\n+                              get_phase_names_args.num_phase_names));\n \n   // Destroy the C-style buffer.\n   PJRT_PhaseCompile_C_Buffers_Destroy_Args destroy_c_buffers_args;"
        },
        {
            "sha": "f44484c66866f04f85973b6c192bb1973f116a06",
            "filename": "third_party/xla/xla/pjrt/pjrt_phase_compile_sample_plugin.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 2,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_sample_plugin.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_sample_plugin.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_sample_plugin.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -15,13 +15,12 @@ limitations under the License.\n \n #include \"xla/pjrt/pjrt_phase_compile_sample_plugin.h\"\n \n-#include <cstdio>\n-#include <cstdlib>\n #include <memory>\n #include <string>\n #include <utility>\n #include <vector>\n \n+#include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n@@ -46,6 +45,8 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n+#include \"xla/pjrt/plugin/xla_cpu/cpu_client_options.h\"\n+#include \"xla/pjrt/plugin/xla_cpu/xla_cpu_pjrt_client.h\"\n #include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n #include \"xla/tsl/framework/mlir/status_scoped_diagnostic_handler.h\"\n \n@@ -216,5 +217,37 @@ PJRT_PhaseCompile_Extension CreateSamplePhaseCompileExtension() {\n                                            PJRT_PhaseCompile_Destroy_Compiler);\n }\n \n+PJRT_Error* PJRT_Client_Create(PJRT_Client_Create_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_Client_Create_Args\", PJRT_Client_Create_Args_STRUCT_SIZE,\n+      args->struct_size));\n+\n+  xla::CpuClientOptions options;\n+  options.cpu_device_count = 4;\n+\n+  PJRT_ASSIGN_OR_RETURN(std::unique_ptr<xla::PjRtClient> client,\n+                        xla::GetXlaPjrtCpuClient(std::move(options)));\n+  args->client = pjrt::CreateWrapperClient(std::move(client));\n+  return nullptr;\n+}\n+\n+PJRT_Error* PJRT_CpuDeviceTopology_Create(\n+    PJRT_TopologyDescription_Create_Args* args) {\n+  return new PJRT_Error{\n+      absl::UnimplementedError(\"Topology not supported for CPU compilation.\")};\n+}\n+\n+const PJRT_Api* GetSamplePhaseCompilePjrtApi() {\n+  static PJRT_PhaseCompile_Extension phase_compile_extension =\n+      pjrt::phase_compile_sample_plugin::CreateSamplePhaseCompileExtension();\n+\n+  static const PJRT_Api pjrt_api = pjrt::CreatePjrtApi(\n+      PJRT_Client_Create, nullptr, PJRT_CpuDeviceTopology_Create,\n+      pjrt::PJRT_Plugin_Initialize_NoOp, &phase_compile_extension.base,\n+      pjrt::PJRT_Plugin_Attributes_Xla);\n+\n+  return &pjrt_api;\n+}\n+\n }  // namespace phase_compile_sample_plugin\n }  // namespace pjrt"
        },
        {
            "sha": "6a9324d9765a2af803810acc510f77ac43dd8d98",
            "filename": "third_party/xla/xla/pjrt/pjrt_phase_compile_sample_plugin.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_sample_plugin.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_sample_plugin.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_phase_compile_sample_plugin.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/OwningOpRef.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n+#include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_phase_compile_extension.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n@@ -83,6 +84,8 @@ class SamplePhaseCompiler : public xla::PjRtPhaseCompiler {\n // Creates a phase compile extension for the sample plugin.\n PJRT_PhaseCompile_Extension CreateSamplePhaseCompileExtension();\n \n+const PJRT_Api* GetSamplePhaseCompilePjrtApi();\n+\n }  // namespace phase_compile_sample_plugin\n }  // namespace pjrt\n "
        },
        {
            "sha": "c46b001a814c8b38c0571b6d796f5d17b35d75d4",
            "filename": "third_party/xla/xla/pjrt/string_utils.cc",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fstring_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fstring_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fstring_utils.cc?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -0,0 +1,66 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/pjrt/string_utils.h\"\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/strings/str_format.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/pjrt/proto/compile_options.pb.h\"\n+#include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n+\n+namespace xla {\n+\n+std::vector<std::string> ConvertCharBuffersToCppStrings(\n+    absl::Span<const char*> char_buffers,\n+    absl::Span<const size_t> char_buffer_sizes) {\n+  if (char_buffers.empty() || char_buffer_sizes.empty()) {\n+    return {};\n+  }\n+\n+  std::vector<std::string> cpp_strings;\n+  size_t num_strings = char_buffers.size();\n+  cpp_strings.reserve(num_strings);\n+  for (size_t i = 0; i < num_strings; ++i) {\n+    if (char_buffers[i] == nullptr) {\n+      cpp_strings.push_back(\"\");\n+    } else {\n+      cpp_strings.push_back(std::string(char_buffers[i], char_buffer_sizes[i]));\n+    }\n+  }\n+  return cpp_strings;\n+}\n+\n+const char** ConvertCppStringsToCharBuffers(\n+    const std::vector<std::string>& strings, const size_t*& char_buffer_sizes) {\n+  auto char_buffers = new const char*[strings.size()];\n+  size_t* buffer_sizes = new size_t[strings.size()];\n+\n+  for (size_t i = 0; i < strings.size(); ++i) {\n+    const std::string& current_string = strings[i];\n+    char* buffer = new char[current_string.length() + 1];\n+    absl::SNPrintF(buffer, current_string.length() + 1, \"%s\", current_string);\n+    char_buffers[i] = buffer;\n+    buffer_sizes[i] = strlen(buffer);\n+  }\n+  char_buffer_sizes = buffer_sizes;\n+  return char_buffers;\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "f6ff818c7c14473938f8ecd09ddf2b00a1884b9e",
            "filename": "third_party/xla/xla/pjrt/string_utils.h",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fstring_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7354cce7139f5c105a7cef6d28484705c2365046/third_party%2Fxla%2Fxla%2Fpjrt%2Fstring_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fstring_utils.h?ref=7354cce7139f5c105a7cef6d28484705c2365046",
            "patch": "@@ -0,0 +1,44 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PJRT_STRING_UTILS_H_\n+#define XLA_PJRT_STRING_UTILS_H_\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/types/span.h\"\n+#include \"xla/pjrt/proto/compile_options.pb.h\"\n+#include \"xla/pjrt/proto/pjrt_partial_program.pb.h\"\n+\n+namespace xla {\n+\n+// Converts an array of C-style character buffers along with their sizes to a\n+// vector of C++ strings.\n+std::vector<std::string> ConvertCharBuffersToCppStrings(\n+    absl::Span<const char*> char_buffers,\n+    absl::Span<const size_t> char_buffer_sizes);\n+\n+// Converts a vector of C++ strings to an array of C-style character buffers and\n+// their sizes. This function allocates memory for the character buffers, the\n+// individual C-strings, and `char_buffer_sizes`.\n+const char** ConvertCppStringsToCharBuffers(\n+    const std::vector<std::string>& strings, const size_t*& char_buffer_sizes);\n+\n+}  // namespace xla\n+\n+#endif  // XLA_PJRT_STRING_UTILS_H_"
        }
    ],
    "stats": {
        "total": 867,
        "additions": 542,
        "deletions": 325
    }
}