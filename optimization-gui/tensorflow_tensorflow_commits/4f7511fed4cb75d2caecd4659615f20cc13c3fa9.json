{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 812275269",
    "sha": "4f7511fed4cb75d2caecd4659615f20cc13c3fa9",
    "files": [
        {
            "sha": "0097b558f6d8b30166282018ad1af25cf7654334",
            "filename": "third_party/xla/xla/tsl/platform/default/env.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4f7511fed4cb75d2caecd4659615f20cc13c3fa9/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Fenv.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4f7511fed4cb75d2caecd4659615f20cc13c3fa9/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Fenv.cc?ref=4f7511fed4cb75d2caecd4659615f20cc13c3fa9",
            "patch": "@@ -104,12 +104,12 @@ class PThread : public Thread {\n     std::unique_ptr<ThreadParams> params(\n         reinterpret_cast<ThreadParams*>(params_arg));\n     {\n-      absl::MutexLock l(&name_mutex);\n+      absl::MutexLock l(name_mutex);\n       GetThreadNameRegistry().emplace(std::this_thread::get_id(), params->name);\n     }\n     params->fn();\n     {\n-      absl::MutexLock l(&name_mutex);\n+      absl::MutexLock l(name_mutex);\n       GetThreadNameRegistry().erase(std::this_thread::get_id());\n     }\n     return nullptr;\n@@ -168,7 +168,7 @@ class PosixEnv : public Env {\n \n   bool GetCurrentThreadName(string* name) override {\n     {\n-      absl::MutexLock l(&name_mutex);\n+      absl::MutexLock l(name_mutex);\n       auto thread_name =\n           GetThreadNameRegistry().find(std::this_thread::get_id());\n       if (thread_name != GetThreadNameRegistry().end()) {"
        },
        {
            "sha": "65bbf100b9bc65112fad5532135ace8c03b755e7",
            "filename": "third_party/xla/xla/tsl/platform/default/unbounded_work_queue.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4f7511fed4cb75d2caecd4659615f20cc13c3fa9/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Funbounded_work_queue.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4f7511fed4cb75d2caecd4659615f20cc13c3fa9/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Funbounded_work_queue.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Funbounded_work_queue.cc?ref=4f7511fed4cb75d2caecd4659615f20cc13c3fa9",
            "patch": "@@ -30,7 +30,7 @@ UnboundedWorkQueue::UnboundedWorkQueue(Env* env, absl::string_view thread_name,\n \n UnboundedWorkQueue::~UnboundedWorkQueue() {\n   {\n-    absl::MutexLock l(&work_queue_mu_);\n+    absl::MutexLock l(work_queue_mu_);\n     // Wake up all `PooledThreadFunc` threads and cause them to terminate before\n     // joining them when `threads_` is cleared.\n     cancelled_ = true;\n@@ -42,7 +42,7 @@ UnboundedWorkQueue::~UnboundedWorkQueue() {\n   }\n \n   {\n-    absl::MutexLock l(&thread_pool_mu_);\n+    absl::MutexLock l(thread_pool_mu_);\n     // Clear the list of pooled threads, which will eventually terminate due to\n     // the previous notification.\n     //\n@@ -56,7 +56,7 @@ UnboundedWorkQueue::~UnboundedWorkQueue() {\n void UnboundedWorkQueue::Schedule(WorkFunction fn) {\n   // Enqueue a work item for the new thread's function, and wake up a\n   // cached thread to process it.\n-  absl::MutexLock l(&work_queue_mu_);\n+  absl::MutexLock l(work_queue_mu_);\n   work_queue_.push_back(std::move(fn));\n   // NOTE: The queue may be non-empty, so we must account for queued work when\n   // considering how many threads are free.\n@@ -67,7 +67,7 @@ void UnboundedWorkQueue::Schedule(WorkFunction fn) {\n     Thread* new_thread =\n         env_->StartThread({}, thread_name_, [this]() { PooledThreadFunc(); });\n \n-    absl::MutexLock l(&thread_pool_mu_);\n+    absl::MutexLock l(thread_pool_mu_);\n     thread_pool_.emplace_back(new_thread);\n   }\n }\n@@ -81,7 +81,7 @@ void UnboundedWorkQueue::PooledThreadFunc() {\n   while (true) {\n     WorkFunction fn;\n     {\n-      absl::MutexLock l(&work_queue_mu_);\n+      absl::MutexLock l(work_queue_mu_);\n       ++num_idle_threads_;\n       // Wait for a new work function to be submitted, or the cache to be\n       // destroyed."
        }
    ],
    "stats": {
        "total": 16,
        "additions": 8,
        "deletions": 8
    }
}