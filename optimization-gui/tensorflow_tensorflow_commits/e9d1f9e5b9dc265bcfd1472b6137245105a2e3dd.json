{
    "author": "bhavani-subramanian",
    "message": "PR #32921: [XLA:GPU][oneAPI] SYCL memcpy functions and tests\n\nImported from GitHub PR https://github.com/openxla/xla/pull/32921\n\nCo-author: @kanvi-nervana\n\nThis PR implements SYCL memcpy functions and adds corresponding tests. It also implements some misc. features in `sycl_gpu_runtime` such as functions to get SYCL frequency, synchronize stream etc.\n\nIt depends on https://github.com/openxla/xla/pull/32918.\nCopybara import of the project:\n\n--\nab502809dd97114bd8b4ab4ac22501cf55e55118 by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nAdded SyclStreamPool and tests\n\n--\n1c3dc3a79b65726210f22017387226a29aae8617 by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nAdded SYCL memory management functions and tests\n\n--\n52933925f2b87a1e56ee90f80798db93a6d785e6 by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nAdded SYCL memcpy functions and tests\n\n--\n730f94b00b78db2c4692fc06276c77b9377cdebe by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nAddressed review comments:\n- Use a function for SyclAsyncHandler\n- Qualified all SYCL functions with ::sycl::\n- Use absl::flat_hash_map for StreamPoolMap\n- Removed `else` blocks after `return` statements\n- Added ABSL_ATTRIBUTE_NONNULL for stream_handle\n- Use TF_ASSERT_OK instead of ASSERT_TRUE(...ok())\n- Use EXPECT_THAT instead of EXPECT_EQ when checking error status\n\nMerging this change closes #32921\n\nPiperOrigin-RevId: 827880742",
    "sha": "e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
    "files": [
        {
            "sha": "0a7ebc144ff644ebf3f892eeb0eb29841f869d74",
            "filename": "third_party/xla/xla/stream_executor/sycl/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2FBUILD?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -228,6 +228,7 @@ sycl_library(\n     ],\n     deps = [\n         \":sycl_event\",\n+        \":sycl_gpu_runtime\",\n         \"//xla/stream_executor:event_based_timer\",\n         \"//xla/stream_executor:stream\",\n         \"//xla/stream_executor:stream_executor_h\",\n@@ -264,7 +265,8 @@ sycl_library(\n     deps = [\n         \":sycl_status\",\n         \"//xla/tsl/platform:statusor\",\n-        \"//xla/tsl/util:env_var\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/strings\",\n     ],\n )\n@@ -279,6 +281,7 @@ xla_test(\n     ],\n     deps = [\n         \":sycl_gpu_runtime\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "56249a3798898217b7315f1a4b7c04e825e7d023",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_context.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_context.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_context.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_context.cc?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -30,9 +30,7 @@ absl::StatusOr<uint64_t> SyclContext::GetDeviceTotalMemory(\n }\n \n absl::Status SyclContext::Synchronize() {\n-  // TODO(intel-tf): Add this feature once SyclStreamPool class is implemented.\n-  return absl::UnimplementedError(\n-      \"SyclContext::Synchronize is not implemented for SYCL platform.\");\n+  return SyclStreamPool::SynchronizeStreamPool(device_ordinal_);\n }\n \n }  // namespace stream_executor::sycl"
        },
        {
            "sha": "dbd295677fb6c2a29cdb9b8e3f27fae284a44430",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_gpu_runtime.cc",
            "status": "modified",
            "additions": 598,
            "deletions": 8,
            "changes": 606,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime.cc?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -17,11 +17,9 @@ limitations under the License.\n \n #include <cassert>\n #include <iostream>\n-#include <unordered_map>\n \n #include \"absl/base/call_once.h\"\n #include \"absl/synchronization/mutex.h\"\n-#include \"xla/tsl/util/env_var.h\"\n \n namespace stream_executor::sycl {\n \n@@ -32,10 +30,99 @@ absl::Status IsValidDeviceOrdinal(int device_ordinal,\n   TF_ASSIGN_OR_RETURN(int device_count, SyclDevicePool::GetDeviceCount());\n   if (device_ordinal >= 0 && device_ordinal < device_count) {\n     return absl::OkStatus();\n-  } else {\n-    return absl::InvalidArgumentError(absl::StrCat(\n-        function_name, \": Invalid device ordinal: \", device_ordinal));\n   }\n+  return absl::InvalidArgumentError(absl::StrCat(\n+      function_name, \": Invalid device ordinal: \", device_ordinal));\n+}\n+\n+// Returns true if the oneAPI version is 2024.2 or newer.\n+// oneAPI 2024.2 corresponds to __LIBSYCL_MAJOR_VERSION == 7 and\n+// __LIBSYCL_MINOR_VERSION == 2.\n+bool IsOneAPIVersionAtLeast2024_2() {\n+  return (__LIBSYCL_MAJOR_VERSION >= 7) && (__LIBSYCL_MINOR_VERSION >= 2);\n+}\n+\n+absl::Status MemcpyDeviceToHost(::sycl::queue* stream_handle, void* dst_host,\n+                                const void* src_device, size_t byte_count,\n+                                bool async = false) {\n+  try {\n+    ::sycl::event event =\n+        stream_handle->memcpy(dst_host, src_device, byte_count);\n+    if (!async) {\n+      event.wait();\n+    }\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(\n+        \"MemcpyDeviceToHost failed: \" + std::string(e.what()) +\n+        \", file = \" + __FILE__ + \", line = \" + std::to_string(__LINE__) + \".\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status MemcpyHostToDevice(::sycl::queue* stream_handle, void* dst_device,\n+                                const void* src_host, size_t byte_count,\n+                                bool async = false) {\n+  try {\n+    ::sycl::event event =\n+        stream_handle->memcpy(dst_device, src_host, byte_count);\n+    if (!async) {\n+      event.wait();\n+    }\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(\n+        \"MemcpyHostToDevice failed: \" + std::string(e.what()) +\n+        \", file = \" + __FILE__ + \", line = \" + std::to_string(__LINE__) + \".\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status MemcpyDeviceToDevice(::sycl::queue* stream_handle,\n+                                  void* dst_device, const void* src_device,\n+                                  size_t byte_count, bool async = false) {\n+  try {\n+    ::sycl::event event =\n+        stream_handle->memcpy(dst_device, src_device, byte_count);\n+    if (!async) {\n+      event.wait();\n+    }\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(\n+        \"MemcpyDeviceToDevice failed: \" + std::string(e.what()) +\n+        \", file = \" + __FILE__ + \", line = \" + std::to_string(__LINE__) + \".\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status MemsetDevice(::sycl::queue* stream_handle, void* dst_device,\n+                          unsigned char value, size_t count,\n+                          bool async = false) {\n+  try {\n+    ::sycl::event event =\n+        stream_handle->memset(dst_device, value, count * sizeof(uint8_t));\n+    if (!async) {\n+      event.wait();\n+    }\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(\"MemsetDevice failed: \" + std::string(e.what()) +\n+                               \", file = \" + __FILE__ +\n+                               \", line = \" + std::to_string(__LINE__) + \".\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status MemfillDevice(::sycl::queue* stream_handle, void* dst_device,\n+                           uint32_t value, size_t count, bool async = false) {\n+  try {\n+    ::sycl::event event = stream_handle->fill(dst_device, value, count);\n+    if (!async) {\n+      event.wait();\n+    }\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(\n+        \"MemfillDevice failed: \" + std::string(e.what()) +\n+        \", file = \" + __FILE__ + \", line = \" + std::to_string(__LINE__) + \".\");\n+  }\n+  return absl::OkStatus();\n }\n \n }  // namespace\n@@ -94,10 +181,9 @@ absl::StatusOr<int> SyclDevicePool::GetDeviceOrdinal(\n   auto it = std::find(device_pool_.begin(), device_pool_.end(), device);\n   if (it != device_pool_.end()) {\n     return static_cast<int>(it - device_pool_.begin());\n-  } else {\n-    return absl::InternalError(\n-        \"SyclDevicePool::GetDeviceOrdinal failed, got invalid device\");\n   }\n+  return absl::InternalError(\n+      \"SyclDevicePool::GetDeviceOrdinal failed, got invalid device\");\n }\n \n absl::StatusOr<::sycl::device> SyclDevicePool::GetDevice(int device_ordinal) {\n@@ -107,4 +193,508 @@ absl::StatusOr<::sycl::device> SyclDevicePool::GetDevice(int device_ordinal) {\n   return device_pool_[device_ordinal];\n }\n \n+StreamPoolMap SyclStreamPool::stream_pool_map_;\n+absl::Mutex SyclStreamPool::stream_pool_mu_(absl::kConstInit);\n+\n+void SyclAsyncHandler(::sycl::exception_list ex_list) {\n+  for (auto& e : ex_list) {\n+    try {\n+      std::rethrow_exception(e);\n+    } catch (::sycl::exception& e) {\n+      LOG(ERROR) << \"SYCL exception: \" << e.what() << \", file = \" << __FILE__\n+                 << \", line = \" << __LINE__ << \".\";\n+    }\n+  }\n+}\n+\n+absl::StatusOr<StreamPool*> SyclStreamPool::InitStreamPool(int device_ordinal) {\n+  {\n+    absl::ReaderMutexLock read_lock(&stream_pool_mu_);\n+    auto it = stream_pool_map_.find(device_ordinal);\n+    // Returns the existing non-empty stream pool for this device, if available.\n+    // The pool may be empty if DestroyStream was called on the last stream.\n+    if (it != stream_pool_map_.end() && !it->second.empty()) {\n+      VLOG(2) << \"Check 1: Returning existing stream pool for device ordinal \"\n+              << device_ordinal << \" whose size is \" << it->second.size();\n+      return &(it->second);\n+    }\n+  }\n+  // Creates a new stream pool for this device using the device and context.\n+  ::sycl::property_list prop_list{::sycl::property::queue::enable_profiling(),\n+                                  ::sycl::property::queue::in_order()};\n+  TF_ASSIGN_OR_RETURN(::sycl::device sycl_device,\n+                      SyclDevicePool::GetDevice(device_ordinal));\n+  TF_ASSIGN_OR_RETURN(::sycl::context sycl_context,\n+                      SyclDevicePool::GetDeviceContext());\n+\n+  VLOG(2) << \"Creating new stream pool for device ordinal \" << device_ordinal;\n+  absl::MutexLock write_lock(&stream_pool_mu_);\n+  auto it = stream_pool_map_.find(device_ordinal);\n+  // Double-checks that another thread has not already created the pool.\n+  if (it != stream_pool_map_.end() && !it->second.empty()) {\n+    VLOG(2) << \"Check 2: Returning existing stream pool for device ordinal \"\n+            << device_ordinal << \" whose size is \" << it->second.size();\n+    return &(it->second);\n+  }\n+\n+  StreamPool stream_pool = {std::make_shared<::sycl::queue>(\n+      sycl_context, sycl_device, SyclAsyncHandler, prop_list)};\n+\n+  // Use assignment (not insert) to update the stream pool if it was\n+  // previously destroyed.\n+  stream_pool_map_[device_ordinal] = std::move(stream_pool);\n+\n+  return &(stream_pool_map_[device_ordinal]);\n+}\n+\n+absl::StatusOr<StreamPtr> SyclStreamPool::GetDefaultStream(int device_ordinal) {\n+  TF_RETURN_IF_ERROR(\n+      IsValidDeviceOrdinal(device_ordinal, \"SyclStreamPool::GetDefaultStream\"));\n+  TF_ASSIGN_OR_RETURN(StreamPool * stream_pool,\n+                      SyclStreamPool::InitStreamPool(device_ordinal));\n+  // InitStreamPool always returns a valid pointer, so no null check is needed.\n+  absl::ReaderMutexLock read_lock(&stream_pool_mu_);\n+  if (stream_pool->empty()) {\n+    return absl::InternalError(\n+        absl::StrCat(\"SyclStreamPool::GetDefaultStream: Stream pool is empty \"\n+                     \"for device ordinal \",\n+                     device_ordinal,\n+                     \". The pool may have been destroyed by another thread.\"));\n+  }\n+  return stream_pool->front();\n+}\n+\n+absl::StatusOr<StreamPtr> SyclStreamPool::GetOrCreateStream(\n+    int device_ordinal, bool enable_multiple_streams) {\n+  VLOG(2) << \"SyclStreamPool::GetOrCreateStream called for device ordinal \"\n+          << device_ordinal\n+          << \", enable_multiple_streams: \" << enable_multiple_streams;\n+  if (!enable_multiple_streams) {\n+    return SyclStreamPool::GetDefaultStream(device_ordinal);\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal,\n+                                          \"SyclStreamPool::GetOrCreateStream\"));\n+  TF_ASSIGN_OR_RETURN(StreamPool * stream_pool,\n+                      SyclStreamPool::InitStreamPool(device_ordinal));\n+  // If multiple streams are enabled, create a new stream and add it\n+  // to the pool, unless the pool has reached kMaxStreamsPerDevice.\n+  absl::MutexLock write_lock(&stream_pool_mu_);\n+  if (stream_pool->size() >= kMaxStreamsPerDevice) {\n+    VLOG(2) << \"Stream pool size for device ordinal \" << device_ordinal\n+            << \" exceeds the maximum limit of \" << kMaxStreamsPerDevice;\n+    return absl::ResourceExhaustedError(\n+        absl::StrCat(\"SyclStreamPool::GetOrCreateStream: Maximum number of \"\n+                     \"streams reached for device ordinal \",\n+                     device_ordinal, \".\"));\n+  }\n+  VLOG(2) << \"Stream pool size for device ordinal \" << device_ordinal << \": \"\n+          << stream_pool->size();\n+  ::sycl::property_list prop_list{::sycl::property::queue::enable_profiling(),\n+                                  ::sycl::property::queue::in_order()};\n+  TF_ASSIGN_OR_RETURN(::sycl::device sycl_device,\n+                      SyclDevicePool::GetDevice(device_ordinal));\n+  TF_ASSIGN_OR_RETURN(::sycl::context sycl_context,\n+                      SyclDevicePool::GetDeviceContext());\n+  stream_pool->push_back(std::make_shared<::sycl::queue>(\n+      sycl_context, sycl_device, SyclAsyncHandler, prop_list));\n+  return stream_pool->back();\n+}\n+\n+absl::Status SyclStreamPool::SynchronizeStreamPool(int device_ordinal) {\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(\n+      device_ordinal, \"SyclStreamPool::SynchronizeStreamPool\"));\n+  TF_ASSIGN_OR_RETURN(StreamPool * stream_pool,\n+                      SyclStreamPool::InitStreamPool(device_ordinal));\n+  absl::ReaderMutexLock read_lock(&stream_pool_mu_);\n+  if (stream_pool->empty()) {\n+    return absl::InternalError(\n+        absl::StrCat(\"SyclStreamPool::SynchronizeStreamPool: Stream pool is \"\n+                     \"empty for device ordinal \",\n+                     device_ordinal,\n+                     \". The pool may have been destroyed by another thread.\"));\n+  }\n+  for (auto& stream : *stream_pool) {\n+    stream->wait();\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStreamPool::DestroyStream(int device_ordinal,\n+                                           StreamPtr& stream_handle) {\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclStreamPool::DestroyStream: Attempting to destroy a null stream \"\n+        \"handle.\");\n+  }\n+  TF_RETURN_IF_ERROR(\n+      IsValidDeviceOrdinal(device_ordinal, \"SyclStreamPool::DestroyStream\"));\n+  TF_ASSIGN_OR_RETURN(StreamPool * stream_pool,\n+                      SyclStreamPool::InitStreamPool(device_ordinal));\n+  absl::MutexLock write_lock(&stream_pool_mu_);\n+  if (stream_pool->empty()) {\n+    return absl::InternalError(\n+        absl::StrCat(\"SyclStreamPool::DestroyStream: Stream pool is empty for \"\n+                     \"device ordinal \",\n+                     device_ordinal,\n+                     \". The pool may have been destroyed by another thread.\"));\n+  }\n+  auto it = std::find(stream_pool->begin(), stream_pool->end(), stream_handle);\n+  if (it == stream_pool->end()) {\n+    return absl::NotFoundError(absl::StrCat(\n+        \"SyclStreamPool::DestroyStream: Stream handle for device ordinal \",\n+        device_ordinal, \" not found in the pool.\"));\n+  }\n+  // Remove the stream from the pool and reset the handle.\n+  // The stream pool remains, but may become empty.\n+  stream_pool->erase(it);\n+  stream_handle.reset();\n+  VLOG(2) << \"Successfully destroyed stream for device ordinal \"\n+          << device_ordinal << \", stream pool size is \" << stream_pool->size();\n+  return absl::OkStatus();\n+}\n+\n+absl::StatusOr<SyclTimerProperties> SyclGetTimerProperties(int device_ordinal) {\n+  TF_RETURN_IF_ERROR(\n+      IsValidDeviceOrdinal(device_ordinal, \"SyclGetTimerProperties\"));\n+  TF_ASSIGN_OR_RETURN(::sycl::device device,\n+                      SyclDevicePool::GetDevice(device_ordinal));\n+  ze_device_handle_t lz_device_handle =\n+      ::sycl::get_native<::sycl::backend::ext_oneapi_level_zero>(device);\n+  ze_device_properties_t lz_device_props{\n+      // timerResolution will be in cycles/sec (Hz) with this structure type.\n+      ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2,\n+  };\n+  ze_result_t status =\n+      zeDeviceGetProperties(lz_device_handle, &lz_device_props);\n+  if (status != ZE_RESULT_SUCCESS) {\n+    return absl::InternalError(\n+        absl::StrCat(\"SyclGetTimerProperties: zeDeviceGetProperties failed for \"\n+                     \"device ordinal \",\n+                     device_ordinal, \" with return code: \", status));\n+  }\n+  uint64_t timer_freq_hz = lz_device_props.timerResolution;\n+  uint64_t timestamp_mask =\n+      (1ull << lz_device_props.kernelTimestampValidBits) - 1ull;\n+  return SyclTimerProperties{timer_freq_hz, timestamp_mask};\n+}\n+\n+absl::Status SyclStreamSynchronize(::sycl::queue* stream_handle) {\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclStreamSynchronize: Null stream handle provided.\");\n+  }\n+  try {\n+    stream_handle->wait();\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(absl::StrCat(\n+        \"SyclStreamSynchronize: Failed to synchronize stream: \", e.what(),\n+        \", file = \", __FILE__, \", line = \", __LINE__));\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::StatusOr<std::optional<::sycl::event>> SyclGetRecentEventFromStream(\n+    ::sycl::queue* stream_handle) {\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclGetRecentEventFromStream: Null stream handle provided.\");\n+  }\n+  try {\n+    // Use the new DPC++/SYCL API when oneAPI version is at least 2024.2.\n+    std::optional<::sycl::event> event =\n+        IsOneAPIVersionAtLeast2024_2()\n+            ? stream_handle->ext_oneapi_get_last_event()\n+            : stream_handle->ext_oneapi_submit_barrier();\n+    return event;\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(absl::StrCat(\n+        \"SyclGetRecentEventFromStream: Failed to get event from stream: \",\n+        e.what(), \", file = \", __FILE__, \", line = \", __LINE__));\n+  }\n+}\n+\n+absl::Status SyclMemcpyDeviceToHost(int device_ordinal, void* dst_host,\n+                                    const void* src_device, size_t byte_count) {\n+  if (dst_host == nullptr || src_device == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyDeviceToHost: Null pointer provided for destination or \"\n+        \"source.\");\n+  }\n+  if (byte_count == 0) {\n+    LOG(WARNING) << \"SyclMemcpyDeviceToHost: Attempting to copy zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  TF_RETURN_IF_ERROR(\n+      IsValidDeviceOrdinal(device_ordinal, \"SyclMemcpyDeviceToHost\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  return MemcpyDeviceToHost(stream_handle.get(), dst_host, src_device,\n+                            byte_count);\n+}\n+\n+absl::Status SyclMemcpyHostToDevice(int device_ordinal, void* dst_device,\n+                                    const void* src_host, size_t byte_count) {\n+  if (dst_device == nullptr || src_host == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyHostToDevice: Null pointer provided for destination or \"\n+        \"source.\");\n+  }\n+  if (byte_count == 0) {\n+    LOG(WARNING) << \"SyclMemcpyHostToDevice: Attempting to copy zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  TF_RETURN_IF_ERROR(\n+      IsValidDeviceOrdinal(device_ordinal, \"SyclMemcpyHostToDevice\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  return MemcpyHostToDevice(stream_handle.get(), dst_device, src_host,\n+                            byte_count);\n+}\n+\n+absl::Status SyclMemcpyDeviceToDevice(int device_ordinal, void* dst_device,\n+                                      const void* src_device,\n+                                      size_t byte_count) {\n+  if (dst_device == nullptr || src_device == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyDeviceToDevice: Null pointer provided for destination or \"\n+        \"source.\");\n+  }\n+  if (byte_count == 0) {\n+    LOG(WARNING) << \"SyclMemcpyDeviceToDevice: Attempting to copy zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  TF_RETURN_IF_ERROR(\n+      IsValidDeviceOrdinal(device_ordinal, \"SyclMemcpyDeviceToDevice\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  return MemcpyDeviceToDevice(stream_handle.get(), dst_device, src_device,\n+                              byte_count);\n+}\n+\n+absl::Status SyclMemcpyDeviceToHostAsync(::sycl::queue* stream_handle,\n+                                         void* dst_host, const void* src_device,\n+                                         size_t byte_count) {\n+  if (dst_host == nullptr || src_device == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyDeviceToHostAsync: Null pointer provided for destination or \"\n+        \"source.\");\n+  }\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyDeviceToHostAsync: Null stream handle provided.\");\n+  }\n+  if (byte_count == 0) {\n+    LOG(WARNING)\n+        << \"SyclMemcpyDeviceToHostAsync: Attempting to copy zero bytes, \"\n+           \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  ::sycl::usm::alloc dst_alloc_type =\n+      ::sycl::get_pointer_type(dst_host, stream_handle->get_context());\n+  bool async = (dst_alloc_type == ::sycl::usm::alloc::host);\n+  return MemcpyDeviceToHost(stream_handle, dst_host, src_device, byte_count,\n+                            async);\n+}\n+\n+absl::Status SyclMemcpyHostToDeviceAsync(::sycl::queue* stream_handle,\n+                                         void* dst_device, const void* src_host,\n+                                         size_t byte_count) {\n+  if (dst_device == nullptr || src_host == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyHostToDeviceAsync: Null pointer provided for destination or \"\n+        \"source.\");\n+  }\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyHostToDeviceAsync: Null stream handle provided.\");\n+  }\n+  if (byte_count == 0) {\n+    LOG(WARNING)\n+        << \"SyclMemcpyHostToDeviceAsync: Attempting to copy zero bytes, \"\n+           \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  ::sycl::usm::alloc src_alloc_type =\n+      ::sycl::get_pointer_type(src_host, stream_handle->get_context());\n+  bool async = (src_alloc_type == ::sycl::usm::alloc::host);\n+  return MemcpyHostToDevice(stream_handle, dst_device, src_host, byte_count,\n+                            async);\n+}\n+\n+absl::Status SyclMemcpyDeviceToDeviceAsync(::sycl::queue* stream_handle,\n+                                           void* dst_device,\n+                                           const void* src_device,\n+                                           size_t byte_count) {\n+  if (dst_device == nullptr || src_device == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyDeviceToDeviceAsync: Null pointer provided for destination \"\n+        \"or source.\");\n+  }\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemcpyDeviceToDeviceAsync: Null stream handle provided.\");\n+  }\n+  if (byte_count == 0) {\n+    LOG(WARNING)\n+        << \"SyclMemcpyDeviceToDeviceAsync: Attempting to copy zero bytes, \"\n+           \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  return MemcpyDeviceToDevice(stream_handle, dst_device, src_device, byte_count,\n+                              /*async=*/true);\n+}\n+\n+absl::Status SyclMemsetDevice(int device_ordinal, void* dst_device,\n+                              unsigned char value, size_t count) {\n+  if (dst_device == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemsetDevice: Null pointer provided for destination.\");\n+  }\n+  if (count == 0) {\n+    LOG(WARNING) << \"SyclMemsetDevice: Attempting to set zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal, \"SyclMemsetDevice\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  return MemsetDevice(stream_handle.get(), dst_device, value, count);\n+}\n+\n+absl::Status SyclMemsetDeviceAsync(::sycl::queue* stream_handle,\n+                                   void* dst_device, unsigned char value,\n+                                   size_t count) {\n+  if (dst_device == nullptr || stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemsetDeviceAsync: Null pointer provided for destination or \"\n+        \"stream handle.\");\n+  }\n+  if (count == 0) {\n+    LOG(WARNING) << \"SyclMemsetDeviceAsync: Attempting to set zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  return MemsetDevice(stream_handle, dst_device, value, count, /*async=*/true);\n+}\n+\n+absl::Status SyclMemfillDevice(int device_ordinal, void* dst_device,\n+                               uint32_t value, size_t count) {\n+  if (dst_device == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemfillDevice: Null pointer provided for destination.\");\n+  }\n+  if (count == 0) {\n+    LOG(WARNING) << \"SyclMemfillDevice: Attempting to fill zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal, \"SyclMemfillDevice\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  return MemfillDevice(stream_handle.get(), dst_device, value, count);\n+}\n+\n+absl::Status SyclMemfillDeviceAsync(::sycl::queue* stream_handle,\n+                                    void* dst_device, uint32_t value,\n+                                    size_t count) {\n+  if (dst_device == nullptr || stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclMemfillDeviceAsync: Null pointer provided for destination or \"\n+        \"stream handle.\");\n+  }\n+  if (count == 0) {\n+    LOG(WARNING) << \"SyclMemfillDeviceAsync: Attempting to fill zero bytes, \"\n+                    \"skipping operation.\";\n+    return absl::OkStatus();\n+  }\n+  return MemfillDevice(stream_handle, dst_device, value, count, /*async=*/true);\n+}\n+\n+// TODO(intel-tf): Need OOM checks for all SYCL memory allocation functions.\n+absl::StatusOr<void*> SyclMallocDevice(int device_ordinal, size_t byte_count) {\n+  if (byte_count == 0) {\n+    LOG(WARNING) << \"SyclMallocDevice: Attempting to allocate zero bytes, \"\n+                    \"returning nullptr.\";\n+    return nullptr;\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal, \"SyclMallocDevice\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  try {\n+    // Use the default stream to allocate memory\n+    void* ptr = ::sycl::aligned_alloc_device(/*alignment=*/64, byte_count,\n+                                             *stream_handle);\n+    return ptr;\n+  } catch (const std::exception& e) {\n+    return absl::InternalError(absl::StrCat(\n+        \"SyclMallocDevice: Failed to allocate device memory: \", e.what(),\n+        \", file = \", __FILE__, \", line = \", __LINE__));\n+  }\n+}\n+\n+absl::StatusOr<void*> SyclMallocHost(int device_ordinal, size_t byte_count) {\n+  if (byte_count == 0) {\n+    LOG(WARNING) << \"SyclMallocHost: Attempting to allocate zero bytes, \"\n+                    \"returning nullptr.\";\n+    return nullptr;\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal, \"SyclMallocHost\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  try {\n+    // Use the default stream to allocate memory\n+    void* ptr = ::sycl::aligned_alloc_host(/*alignment=*/64, byte_count,\n+                                           *stream_handle);\n+    return ptr;\n+  } catch (const std::exception& e) {\n+    return absl::InternalError(absl::StrCat(\n+        \"SyclMallocHost: Failed to allocate host memory: \", e.what(),\n+        \", file = \", __FILE__, \", line = \", __LINE__));\n+  }\n+}\n+\n+absl::StatusOr<void*> SyclMallocShared(int device_ordinal, size_t byte_count) {\n+  if (byte_count == 0) {\n+    LOG(WARNING) << \"SyclMallocShared: Attempting to allocate zero bytes, \"\n+                    \"returning nullptr.\";\n+    return nullptr;\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal, \"SyclMallocShared\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  try {\n+    // Use the default stream to allocate memory\n+    void* ptr = ::sycl::aligned_alloc_shared(/*alignment=*/64, byte_count,\n+                                             *stream_handle);\n+    return ptr;\n+  } catch (const std::exception& e) {\n+    return absl::InternalError(absl::StrCat(\n+        \"SyclMallocShared: Failed to allocate shared memory: \", e.what(),\n+        \", file = \", __FILE__, \", line = \", __LINE__));\n+  }\n+}\n+\n+absl::Status SyclFree(int device_ordinal, void*& ptr) {\n+  if (ptr == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"SyclFree: Attempting to free a null pointer.\");\n+  }\n+  TF_RETURN_IF_ERROR(IsValidDeviceOrdinal(device_ordinal, \"SyclFree\"));\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetDefaultStream(device_ordinal));\n+  try {\n+    // Use the default stream to free memory\n+    ::sycl::free(ptr, *stream_handle);\n+    ptr = nullptr;\n+  } catch (const ::sycl::exception& e) {\n+    return absl::InternalError(\n+        absl::StrCat(\"SyclFree: Failed to free memory: \", e.what(),\n+                     \", file = \", __FILE__, \", line = \", __LINE__));\n+  }\n+  return absl::OkStatus();\n+}\n+\n }  // namespace stream_executor::sycl"
        },
        {
            "sha": "27dc280c019a99f3e20e7fd0a3c7c39bc9408e57",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_gpu_runtime.h",
            "status": "modified",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime.h?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -24,6 +24,8 @@ limitations under the License.\n #include <string>\n #include <vector>\n \n+#include \"absl/base/attributes.h\"\n+#include \"absl/container/flat_hash_map.h\"\n #include \"absl/strings/ascii.h\"\n #include \"xla/stream_executor/sycl/sycl_status.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -73,5 +75,182 @@ class SyclDevicePool {\n   SyclDevicePool() = delete;\n };\n \n+using StreamPtr = std::shared_ptr<::sycl::queue>;\n+using StreamPool = std::vector<StreamPtr>;\n+using StreamPoolMap = absl::flat_hash_map<int /*device_ordinal*/, StreamPool>;\n+\n+// TODO(intel-tf): kMaxStreamsPerDevice is the maximum number of streams that\n+// can be created per device via GetOrCreateStream when multiple streams are\n+// enabled.\n+//\n+// For now, we set it to 8 so that there is no unbounded growth. However, it can\n+// be adjusted based on the device capabilities and workload requirements.\n+//\n+// This feature will be enabled by default in the future once the performance\n+// implications are better understood.\n+constexpr int kMaxStreamsPerDevice = 8;\n+\n+// Manages pools of SYCL streams (queues) per device. All methods are static and\n+// thread-safe via a global mutex. For high concurrency workloads, consider\n+// refactoring to use per-device mutexes.\n+// This class cannot be instantiated and is intended to be used as a\n+// static utility.\n+class SyclStreamPool {\n+ public:\n+  // Returns the default (first in the pool) SYCL stream for the given device\n+  // ordinal. Returns an error if the device ordinal is invalid or the stream\n+  // pool is empty.\n+  static absl::StatusOr<StreamPtr> GetDefaultStream(int device_ordinal);\n+\n+  // Returns a SYCL stream for the given device ordinal.\n+  //\n+  // If multiple streams are not enabled, returns the default (first in the\n+  // pool) SYCL stream. If the stream pool is empty, returns an error.\n+  //\n+  // If multiple streams are enabled (via enable_multiple_streams), creates\n+  // a new stream up to the maximum limit (kMaxStreamsPerDevice). Returns an\n+  // error if the limit is reached.\n+  static absl::StatusOr<StreamPtr> GetOrCreateStream(\n+      int device_ordinal, bool enable_multiple_streams);\n+\n+  // Synchronizes all streams associated with the given device ordinal.\n+  static absl::Status SynchronizeStreamPool(int device_ordinal);\n+\n+  // Destroys a previously created SYCL stream for the given device ordinal.\n+  static absl::Status DestroyStream(int device_ordinal,\n+                                    StreamPtr& stream_handle);\n+\n+ private:\n+  // Global mutex protecting the stream pool.\n+  // TODO(intel-tf): We should consider using a more fine-grained locking\n+  // mechanism (ex. per-device mutex) in the future to avoid performance issues.\n+  static absl::Mutex stream_pool_mu_;\n+\n+  // The underlying stream pool for each device. The device ordinal\n+  // is used as the key.\n+  static StreamPoolMap stream_pool_map_ ABSL_GUARDED_BY(stream_pool_mu_);\n+\n+  // Initializes and returns a pointer to the stream pool for the given device\n+  // ordinal.\n+  static absl::StatusOr<StreamPool*> InitStreamPool(int device_ordinal);\n+\n+  // Prevent instantiation: this class is intended to be a static utility only\n+  SyclStreamPool() = delete;\n+};\n+\n+// Timer properties for SYCL device timing operations.\n+struct SyclTimerProperties {\n+  // Timer frequency in cycles per second (Hz).\n+  uint64_t frequency_hz;\n+\n+  // Bitmask for valid kernel timestamp bits.\n+  uint64_t timestamp_mask;\n+};\n+\n+// Returns the timer frequency (Hz) and valid timestamp bitmask for the given\n+// device ordinal using the Level Zero backend.\n+absl::StatusOr<SyclTimerProperties> SyclGetTimerProperties(int device_ordinal);\n+\n+// Synchronizes the given SYCL stream by blocking until all previously submitted\n+// tasks are complete.\n+absl::Status SyclStreamSynchronize(::sycl::queue* stream_handle)\n+    ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// Retrieves the most recent SYCL event associated with the given stream,\n+// if available.\n+absl::StatusOr<std::optional<::sycl::event>> SyclGetRecentEventFromStream(\n+    ::sycl::queue* stream_handle) ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// NOTE: Similar to standard memcpy, all SYCL memcpy functions work\n+// only when the source and destination buffers do not overlap. Add support for\n+// overlapping copies if needed via a SYCL kernel.\n+\n+// Copies data from a device buffer to a host buffer using the default SYCL\n+// stream for the specified device ordinal. The copy is synchronous and blocks\n+// until the operation is complete.\n+absl::Status SyclMemcpyDeviceToHost(int device_ordinal, void* dst_host,\n+                                    const void* src_device, size_t byte_count);\n+\n+// Copies data from a host buffer to a device buffer using the default SYCL\n+// stream for the specified device ordinal. The copy is synchronous and blocks\n+// until the operation is complete.\n+absl::Status SyclMemcpyHostToDevice(int device_ordinal, void* dst_device,\n+                                    const void* src_host, size_t byte_count);\n+\n+// Copies data between two device buffers using the default SYCL stream for\n+// the specified device ordinal. It supports both intra-device and\n+// inter-device transfers. The copy is synchronous and blocks until the\n+// operation is complete.\n+absl::Status SyclMemcpyDeviceToDevice(int device_ordinal, void* dst_device,\n+                                      const void* src_device,\n+                                      size_t byte_count);\n+\n+// Asynchronously copies data from a device buffer to a host buffer using the\n+// specified SYCL stream. The operation may return before the copy is complete.\n+absl::Status SyclMemcpyDeviceToHostAsync(::sycl::queue* stream_handle,\n+                                         void* dst_host, const void* src_device,\n+                                         size_t byte_count)\n+    ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// Asynchronously copies data from a host buffer to a device buffer using the\n+// specified SYCL stream. The operation may return before the copy is complete.\n+absl::Status SyclMemcpyHostToDeviceAsync(::sycl::queue* stream_handle,\n+                                         void* dst_device, const void* src_host,\n+                                         size_t byte_count)\n+    ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// Asynchronously copies data between two device buffers using the specified\n+// SYCL stream. It supports both intra-device and inter-device transfers. The\n+// operation may return before the copy is complete.\n+absl::Status SyclMemcpyDeviceToDeviceAsync(::sycl::queue* stream_handle,\n+                                           void* dst_device,\n+                                           const void* src_device,\n+                                           size_t byte_count)\n+    ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// Sets the device buffer to a byte value using the default SYCL stream\n+// for the specified device ordinal. The operation is synchronous\n+// and blocks until the operation is complete.\n+absl::Status SyclMemsetDevice(int device_ordinal, void* dst_device,\n+                              unsigned char value, size_t count);\n+\n+// Asynchronously sets the device buffer to a byte value using the specified\n+// SYCL stream. The operation may return before it is complete.\n+absl::Status SyclMemsetDeviceAsync(::sycl::queue* stream_handle,\n+                                   void* dst_device, unsigned char value,\n+                                   size_t count) ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// Sets the device buffer to an unsigned 32-bit value using the default SYCL\n+// stream for the specified device ordinal. The operation is synchronous and\n+// blocks until the operation is complete.\n+absl::Status SyclMemfillDevice(int device_ordinal, void* dst_device,\n+                               uint32_t value, size_t count);\n+\n+// Asynchronously sets the device buffer to an unsigned 32-bit value using the\n+// specified SYCL stream. The operation may return before it is complete.\n+absl::Status SyclMemfillDeviceAsync(::sycl::queue* stream_handle,\n+                                    void* dst_device, uint32_t value,\n+                                    size_t count) ABSL_ATTRIBUTE_NONNULL(1);\n+\n+// Allocates a block of memory on the given device ordinal using the default\n+// stream for that device. The memory is aligned to 64 bytes.\n+absl::StatusOr<void*> SyclMallocDevice(int device_ordinal, size_t byte_count);\n+\n+// Allocates a block of host-accessible memory on the given device ordinal\n+// using the default stream for that device. The memory is aligned to 64 bytes.\n+absl::StatusOr<void*> SyclMallocHost(int device_ordinal, size_t byte_count);\n+\n+// Allocates a block of shared memory that is accessible by both the host and\n+// the specified device ordinal, using the default stream for that device. The\n+// memory is aligned to 64 bytes.\n+absl::StatusOr<void*> SyclMallocShared(int device_ordinal, size_t byte_count);\n+\n+// Frees a previously allocated block of memory on the specified device ordinal\n+// using the default stream for that device. After successful deallocation, the\n+// pointer is set to nullptr.\n+// This function is thread-safe only for different pointers. Concurrent calls\n+// to free the same pointer requires synchronization by the caller.\n+absl::Status SyclFree(int device_ordinal, void*& ptr);\n+\n }  // namespace stream_executor::sycl\n #endif  // XLA_STREAM_EXECUTOR_SYCL_SYCL_GPU_RUNTIME_H_"
        },
        {
            "sha": "cc8e4d5675598012f70ba4a00e9899be98fa82e8",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_gpu_runtime_test.cc",
            "status": "modified",
            "additions": 638,
            "deletions": 3,
            "changes": 641,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_gpu_runtime_test.cc?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -15,25 +15,109 @@ limitations under the License.\n #include \"xla/stream_executor/sycl/sycl_gpu_runtime.h\"\n \n #include <gtest/gtest.h>\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/status_matchers.h\"\n \n namespace stream_executor::sycl {\n namespace {\n \n-TEST(SyclGpuRuntimeTest, GetDeviceCount) {\n+class SyclGpuRuntimeTest : public ::testing::Test {\n+ public:\n+  std::vector<::sycl::device> sycl_devices_;\n+\n+ protected:\n+  absl::StatusOr<void*> AllocateHostBuffer(int count) {\n+    TF_ASSIGN_OR_RETURN(\n+        void* buf, SyclMallocHost(kDefaultDeviceOrdinal, sizeof(int) * count));\n+    if (buf == nullptr) {\n+      return absl::InternalError(\n+          \"SyclGpuRuntimeTest::AllocateHostBuffer: Failed to allocate host \"\n+          \"buffer.\");\n+    }\n+    return buf;\n+  }\n+\n+  absl::StatusOr<void*> AllocateDeviceBuffer(\n+      int count, int device_ordinal = kDefaultDeviceOrdinal) {\n+    TF_ASSIGN_OR_RETURN(void* buf,\n+                        SyclMallocDevice(device_ordinal, sizeof(int) * count));\n+    if (buf == nullptr) {\n+      return absl::InternalError(\n+          \"SyclGpuRuntimeTest::AllocateDeviceBuffer: Failed to allocate \"\n+          \"device buffer.\");\n+    }\n+    return buf;\n+  }\n+\n+  void VerifyIntBuffer(void* buf, int count, int expected) {\n+    for (int i = 0; i < count; ++i) {\n+      EXPECT_EQ(static_cast<int*>(buf)[i], expected)\n+          << \"Buffer mismatch at index \" << i;\n+    }\n+  }\n+\n+  absl::StatusOr<void*> AllocateAndInitHostBuffer(int count, int value) {\n+    TF_ASSIGN_OR_RETURN(void* buf, AllocateHostBuffer(count));\n+    for (int i = 0; i < count; ++i) {\n+      static_cast<int*>(buf)[i] = value;\n+    }\n+    return buf;\n+  }\n+\n+  absl::StatusOr<void*> AllocateAndInitDeviceBuffer(\n+      int count, int value, int device_ordinal = kDefaultDeviceOrdinal) {\n+    TF_ASSIGN_OR_RETURN(void* buf, AllocateDeviceBuffer(count));\n+    TF_RETURN_IF_ERROR(\n+        SyclMemfillDevice(device_ordinal, buf, value, sizeof(int) * count));\n+    if (buf == nullptr) {\n+      return absl::InternalError(\n+          \"SyclGpuRuntimeTest::AllocateAndInitDeviceBuffer: Failed to fill \"\n+          \"device buffer.\");\n+    }\n+    return buf;\n+  }\n+\n+  void FreeAndNullify(void*& ptr, int device_ordinal = kDefaultDeviceOrdinal) {\n+    if (ptr != nullptr) {\n+      EXPECT_THAT(SyclFree(device_ordinal, ptr), absl_testing::IsOk());\n+      EXPECT_EQ(ptr, nullptr);\n+    }\n+  }\n+\n+ private:\n+  void SetUp() override {\n+    // Find the number of SYCL devices available. If there are none, skip the\n+    // test.\n+    TF_ASSERT_OK_AND_ASSIGN(int device_count, SyclDevicePool::GetDeviceCount());\n+    if (device_count <= 0) {\n+      GTEST_SKIP() << \"No SYCL devices found.\";\n+    } else {\n+      VLOG(2) << \"Found \" << device_count << \" SYCL devices.\";\n+    }\n+\n+    // Initialize the device pool with available devices.\n+    for (int i = 0; i < device_count; ++i) {\n+      TF_ASSERT_OK_AND_ASSIGN(::sycl::device sycl_device,\n+                              SyclDevicePool::GetDevice(i));\n+      sycl_devices_.push_back(sycl_device);\n+    }\n+  }\n+};\n+\n+TEST_F(SyclGpuRuntimeTest, GetDeviceCount) {\n   EXPECT_THAT(SyclDevicePool::GetDeviceCount(),\n               ::absl_testing::IsOkAndHolds(::testing::Gt(0)));\n }\n \n-TEST(SyclGpuRuntimeTest, GetDeviceOrdinal) {\n+TEST_F(SyclGpuRuntimeTest, GetDeviceOrdinal) {\n   TF_ASSERT_OK_AND_ASSIGN(::sycl::device sycl_device,\n                           SyclDevicePool::GetDevice(kDefaultDeviceOrdinal));\n   TF_ASSERT_OK_AND_ASSIGN(int device_ordinal,\n                           SyclDevicePool::GetDeviceOrdinal(sycl_device));\n   EXPECT_EQ(device_ordinal, kDefaultDeviceOrdinal);\n }\n \n-TEST(SyclGpuRuntimeTest, TestStaticDeviceContext) {\n+TEST_F(SyclGpuRuntimeTest, TestStaticDeviceContext) {\n   // Verify that GetDeviceContext returns the same context instance on multiple\n   // calls.\n   TF_ASSERT_OK_AND_ASSIGN(::sycl::context saved_sycl_context,\n@@ -43,5 +127,556 @@ TEST(SyclGpuRuntimeTest, TestStaticDeviceContext) {\n   EXPECT_EQ(saved_sycl_context, current_sycl_context);\n }\n \n+TEST_F(SyclGpuRuntimeTest, TestDefaultStreamSynchronizeAndDestroy) {\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetDefaultStream(kDefaultDeviceOrdinal));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK(SyclStreamPool::SynchronizeStreamPool(kDefaultDeviceOrdinal));\n+\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestCreateStreamSynchronizeAndDestroy) {\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK(SyclStreamPool::SynchronizeStreamPool(kDefaultDeviceOrdinal));\n+\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestStreamPoolCreateAfterDestroy) {\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  ASSERT_EQ(stream_handle, nullptr);\n+\n+  // Verify that we can create a new stream after destroying the previous one.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  // Clean up the stream after the test.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestStreamPoolCreate_Negative) {\n+  constexpr int kInvalidDeviceOrdinal = -1;\n+  EXPECT_THAT(\n+      SyclStreamPool::GetOrCreateStream(kInvalidDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false),\n+      absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestStreamPoolDestroy_Negative) {\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  ASSERT_EQ(stream_handle, nullptr);\n+\n+  // Try to destroy the stream again, which should be a no-op.\n+  EXPECT_THAT(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle),\n+      absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMaxStreamsPerDevice) {\n+  // Ensure that the maximum number of streams per device is respected.\n+  constexpr int kMaxStreams = 8;\n+  std::vector<StreamPtr> streams(kMaxStreams);\n+  for (int i = 0; i < kMaxStreams - 1; ++i) {\n+    TF_ASSERT_OK_AND_ASSIGN(streams[i], SyclStreamPool::GetOrCreateStream(\n+                                            kDefaultDeviceOrdinal,\n+                                            /*enable_multiple_streams=*/true));\n+    ASSERT_NE(streams[i], nullptr);\n+  }\n+\n+  // Attempt to create one more stream, which should fail.\n+  EXPECT_THAT(\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/true),\n+      absl_testing::StatusIs(absl::StatusCode::kResourceExhausted));\n+\n+  // Clean up the streams created.\n+  for (int i = 0; i < kMaxStreams - 1; ++i) {\n+    TF_ASSERT_OK(\n+        SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, streams[i]));\n+    EXPECT_EQ(streams[i], nullptr);\n+  }\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestGetTimerProperties) {\n+  TF_ASSERT_OK_AND_ASSIGN(SyclTimerProperties timer_props,\n+                          SyclGetTimerProperties(kDefaultDeviceOrdinal));\n+  EXPECT_GT(timer_props.frequency_hz, 0);\n+  EXPECT_GT(timer_props.timestamp_mask, 0);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestSyclGetRecentEventFromStream) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  // Ensure there is an event associated with the stream by filling some memory\n+  // on the device.\n+  TF_ASSERT_OK_AND_ASSIGN(void* device_buf,\n+                          AllocateAndInitDeviceBuffer(kCount, 0xDEADC0DE));\n+\n+  TF_ASSERT_OK(SyclStreamSynchronize(stream_handle.get()));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::optional<::sycl::event> event,\n+                          SyclGetRecentEventFromStream(stream_handle.get()));\n+\n+  ASSERT_TRUE(event.has_value());\n+\n+  // Expect the event to be in a valid state. The command_execution_status\n+  // should not be \"unknown\".\n+  EXPECT_NE(\n+      event.value().get_info<::sycl::info::event::command_execution_status>(),\n+      ::sycl::info::event_command_status::ext_oneapi_unknown);\n+\n+  FreeAndNullify(device_buf);\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemcopyDeviceToHost) {\n+  constexpr int kCount = 12;\n+  TF_ASSERT_OK_AND_ASSIGN(void* src_device,\n+                          AllocateAndInitDeviceBuffer(kCount, 0xDEADBEEF));\n+  TF_ASSERT_OK_AND_ASSIGN(void* dst_host, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDefaultDeviceOrdinal, dst_host,\n+                                      src_device, sizeof(int) * kCount));\n+\n+  VerifyIntBuffer(dst_host, kCount, 0xDEADBEEF);\n+\n+  FreeAndNullify(src_device);\n+  FreeAndNullify(dst_host);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemcopyHostToDeviceAndBack) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(void* src_host,\n+                          AllocateAndInitHostBuffer(kCount, 0xDEADC0DE));\n+  TF_ASSERT_OK_AND_ASSIGN(void* dst_device, AllocateDeviceBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyHostToDevice(kDefaultDeviceOrdinal, dst_device,\n+                                      src_host, sizeof(int) * kCount));\n+\n+  // Clear out the host buffer to ensure data is copied back correctly.\n+  for (int i = 0; i < kCount; ++i) {\n+    static_cast<int*>(src_host)[i] = 0;\n+  }\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDefaultDeviceOrdinal, src_host,\n+                                      dst_device, sizeof(int) * kCount));\n+\n+  VerifyIntBuffer(src_host, kCount, 0xDEADC0DE);\n+\n+  FreeAndNullify(src_host);\n+  FreeAndNullify(dst_device);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemcopyDeviceToDevice_SameDevice) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(void* src_device, AllocateDeviceBuffer(kCount));\n+  TF_ASSERT_OK_AND_ASSIGN(void* dst_device, AllocateDeviceBuffer(kCount));\n+\n+  // Test memcpy between two buffers within the same device.\n+  TF_ASSERT_OK(SyclMemcpyDeviceToDevice(kDefaultDeviceOrdinal, dst_device,\n+                                        src_device, sizeof(int) * kCount));\n+\n+  FreeAndNullify(src_device);\n+  FreeAndNullify(dst_device);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemcopyDeviceToHostAsync) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* src_device,\n+                          AllocateAndInitDeviceBuffer(kCount, 0xDEADBEEF));\n+  TF_ASSERT_OK_AND_ASSIGN(void* dst_host, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHostAsync(stream_handle.get(), dst_host,\n+                                           src_device, sizeof(int) * kCount));\n+\n+  // Synchronize the stream to ensure the copy is complete before checking\n+  // results.\n+  TF_ASSERT_OK(SyclStreamSynchronize(stream_handle.get()));\n+\n+  // Check the results after synchronization.\n+  VerifyIntBuffer(dst_host, kCount, 0xDEADBEEF);\n+\n+  FreeAndNullify(src_device);\n+  FreeAndNullify(dst_host);\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemcopyHostToDeviceAsync) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* src_host,\n+                          AllocateAndInitHostBuffer(kCount, 0xDEADC0DE));\n+  TF_ASSERT_OK_AND_ASSIGN(void* dst_device, AllocateDeviceBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyHostToDeviceAsync(stream_handle.get(), dst_device,\n+                                           src_host, sizeof(int) * kCount));\n+\n+  // Synchronize the stream to ensure the copy is complete before checking\n+  // results.\n+  TF_ASSERT_OK(SyclStreamSynchronize(stream_handle.get()));\n+\n+  // Verify the copy by reading back to host.\n+  // First, clear out the host buffer to ensure data is copied back correctly.\n+  for (int i = 0; i < kCount; ++i) {\n+    static_cast<int*>(src_host)[i] = 0;\n+  }\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDefaultDeviceOrdinal, src_host,\n+                                      dst_device, sizeof(int) * kCount));\n+\n+  VerifyIntBuffer(src_host, kCount, 0xDEADC0DE);\n+\n+  FreeAndNullify(src_host);\n+  FreeAndNullify(dst_device);\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemsetDevice) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      void* src_device,\n+      SyclMallocDevice(kDefaultDeviceOrdinal, sizeof(char) * kCount));\n+  ASSERT_NE(src_device, nullptr);\n+\n+  TF_ASSERT_OK(SyclMemsetDevice(kDefaultDeviceOrdinal, src_device, 'A',\n+                                sizeof(char) * kCount));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* dst_host, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDefaultDeviceOrdinal, dst_host,\n+                                      src_device, sizeof(char) * kCount));\n+\n+  for (int i = 0; i < kCount; ++i) {\n+    EXPECT_EQ(static_cast<char*>(dst_host)[i], 'A')\n+        << \"Mismatch at index \" << i;\n+  }\n+\n+  FreeAndNullify(src_device);\n+  FreeAndNullify(dst_host);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemsetDevice_Negative) {\n+  constexpr int kCount = 10;\n+  constexpr int kInvalidDeviceOrdinal = -1;\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* src_device, AllocateDeviceBuffer(kCount));\n+  ASSERT_NE(src_device, nullptr);\n+\n+  // Attempt to memset with an invalid device ordinal.\n+  EXPECT_THAT(SyclMemsetDevice(kInvalidDeviceOrdinal, src_device, 'A',\n+                               sizeof(char) * kCount),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  // Attempt to memset a null pointer.\n+  void* null_ptr = nullptr;\n+  EXPECT_THAT(SyclMemsetDevice(kDefaultDeviceOrdinal, null_ptr, 'A',\n+                               sizeof(char) * kCount),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  FreeAndNullify(src_device);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemsetDeviceAsync) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* device_buf, AllocateDeviceBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemsetDeviceAsync(stream_handle.get(), device_buf, 'B',\n+                                     sizeof(char) * kCount));\n+\n+  // Synchronize the stream to ensure the memset is complete before checking\n+  // results.\n+  TF_ASSERT_OK(SyclStreamSynchronize(stream_handle.get()));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* host_buf, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDefaultDeviceOrdinal, host_buf,\n+                                      device_buf, sizeof(char) * kCount));\n+\n+  for (int i = 0; i < kCount; ++i) {\n+    EXPECT_EQ(static_cast<char*>(host_buf)[i], 'B')\n+        << \"Mismatch at index \" << i;\n+  }\n+\n+  FreeAndNullify(device_buf);\n+  FreeAndNullify(host_buf);\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemfillDeviceAsync) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* device_buf, AllocateDeviceBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemfillDeviceAsync(stream_handle.get(), device_buf,\n+                                      0xDEADC0DE, sizeof(int) * kCount));\n+\n+  // Synchronize the stream to ensure the fill is complete before checking\n+  // results.\n+  TF_ASSERT_OK(SyclStreamSynchronize(stream_handle.get()));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* host_buf, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDefaultDeviceOrdinal, host_buf,\n+                                      device_buf, sizeof(int) * kCount));\n+\n+  VerifyIntBuffer(host_buf, kCount, 0xDEADC0DE);\n+\n+  FreeAndNullify(device_buf);\n+  FreeAndNullify(host_buf);\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  ASSERT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMemfillDeviceAsync_Negative) {\n+  constexpr int kCount = 10;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream_handle,\n+      SyclStreamPool::GetOrCreateStream(kDefaultDeviceOrdinal,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream_handle, nullptr);\n+\n+  // Attempt to fill a null pointer.\n+  void* null_ptr = nullptr;\n+  EXPECT_THAT(SyclMemfillDeviceAsync(stream_handle.get(), null_ptr, 0xFEEDEAF,\n+                                     sizeof(int) * kCount),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(\n+      SyclStreamPool::DestroyStream(kDefaultDeviceOrdinal, stream_handle));\n+  EXPECT_EQ(stream_handle, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMultiDeviceAllocationAndSyncCopy) {\n+  // Skip if less than 2 devices are available.\n+  if (sycl_devices_.size() < 2) {\n+    GTEST_SKIP() << \"Not enough SYCL devices available for this test.\";\n+  }\n+\n+  constexpr int kDevice0 = 0, kDevice1 = 1;\n+  constexpr int kCount = 16;\n+\n+  // Allocate and initialize on device 0.\n+  TF_ASSERT_OK_AND_ASSIGN(void* device0_buf, AllocateAndInitDeviceBuffer(\n+                                                 kCount, 0x1234ABCD, kDevice0));\n+  // Allocate on device 1.\n+  TF_ASSERT_OK_AND_ASSIGN(void* device1_buf,\n+                          AllocateDeviceBuffer(kCount, kDevice1));\n+\n+  // Try to copy from device 0 to device 1. It should work since cross-device\n+  // memcpy is supported.\n+  TF_ASSERT_OK(SyclMemcpyDeviceToDevice(kDevice0, device1_buf, device0_buf,\n+                                        sizeof(int) * kCount));\n+\n+  // Verify the copy by reading back to host.\n+  TF_ASSERT_OK_AND_ASSIGN(void* host_buf, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDevice1, host_buf, device1_buf,\n+                                      sizeof(int) * kCount));\n+\n+  VerifyIntBuffer(host_buf, kCount, 0x1234ABCD);\n+\n+  // Free the buffers.\n+  FreeAndNullify(device0_buf, kDevice0);\n+  FreeAndNullify(device1_buf, kDevice1);\n+  FreeAndNullify(host_buf, kDefaultDeviceOrdinal);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMultiDeviceAllocationAndAsyncCopy) {\n+  if (sycl_devices_.size() < 2) {\n+    GTEST_SKIP() << \"Not enough SYCL devices available for this test.\";\n+  }\n+\n+  constexpr int kDevice0 = 0, kDevice1 = 1;\n+  constexpr int kCount = 10;\n+\n+  // Create a stream for device-0.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      StreamPtr stream0,\n+      SyclStreamPool::GetOrCreateStream(kDevice0,\n+                                        /*enable_multiple_streams=*/false));\n+  ASSERT_NE(stream0, nullptr);\n+\n+  // Allocate and initialize on device-0.\n+  TF_ASSERT_OK_AND_ASSIGN(void* device0_buf, AllocateAndInitDeviceBuffer(\n+                                                 kCount, 0xDEADBEEF, kDevice0));\n+\n+  // Allocate on device 1.\n+  TF_ASSERT_OK_AND_ASSIGN(void* device1_buf,\n+                          AllocateDeviceBuffer(kCount, kDevice1));\n+\n+  // Copy from device-0 to device-1 using stream-0.\n+  TF_ASSERT_OK(SyclMemcpyDeviceToDeviceAsync(\n+      stream0.get(), device1_buf, device0_buf, sizeof(int) * kCount));\n+\n+  // Synchronize the stream to ensure the copy is complete.\n+  TF_ASSERT_OK(SyclStreamSynchronize(stream0.get()));\n+\n+  // Verify the copy by copying back to host.\n+  TF_ASSERT_OK_AND_ASSIGN(void* host_buf, AllocateHostBuffer(kCount));\n+\n+  TF_ASSERT_OK(SyclMemcpyDeviceToHost(kDevice1, host_buf, device1_buf,\n+                                      sizeof(int) * kCount));\n+\n+  VerifyIntBuffer(host_buf, kCount, 0xDEADBEEF);\n+\n+  // Free the buffers.\n+  FreeAndNullify(device0_buf, kDevice0);\n+  FreeAndNullify(device1_buf, kDevice1);\n+  FreeAndNullify(host_buf, kDefaultDeviceOrdinal);\n+\n+  // Destroy the stream after use.\n+  TF_ASSERT_OK(SyclStreamPool::DestroyStream(kDevice0, stream0));\n+  EXPECT_EQ(stream0, nullptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMallocAll_Positive) {\n+  TF_ASSERT_OK_AND_ASSIGN(void* host_ptr, AllocateHostBuffer(/*count=*/256));\n+  FreeAndNullify(host_ptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* device_ptr,\n+                          AllocateDeviceBuffer(/*count=*/256));\n+  FreeAndNullify(device_ptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* shared_ptr,\n+                          SyclMallocShared(kDefaultDeviceOrdinal,\n+                                           /*byte_count=*/1024));\n+  EXPECT_NE(shared_ptr, nullptr);\n+  FreeAndNullify(shared_ptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMallocAll_InvalidDeviceOrdinal) {\n+  constexpr int kInvalidDeviceOrdinal = -1;\n+  EXPECT_THAT(SyclMallocHost(kInvalidDeviceOrdinal, 10).status(),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+  EXPECT_THAT(SyclMallocDevice(kInvalidDeviceOrdinal, 20).status(),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+  EXPECT_THAT(SyclMallocShared(kInvalidDeviceOrdinal, 30).status(),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestMallocAll_ZeroAllocation) {\n+  constexpr size_t kByteCount = 0;\n+  TF_ASSERT_OK_AND_ASSIGN(void* host_ptr,\n+                          SyclMallocHost(kDefaultDeviceOrdinal, kByteCount));\n+  EXPECT_EQ(host_ptr, nullptr)\n+      << \"Expected nullptr for zero allocation on host memory.\";\n+  FreeAndNullify(host_ptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* device_ptr,\n+                          SyclMallocDevice(kDefaultDeviceOrdinal, kByteCount));\n+  EXPECT_EQ(device_ptr, nullptr)\n+      << \"Expected nullptr for zero allocation on device memory.\";\n+  FreeAndNullify(device_ptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* shared_ptr,\n+                          SyclMallocShared(kDefaultDeviceOrdinal, kByteCount));\n+  EXPECT_EQ(shared_ptr, nullptr)\n+      << \"Expected nullptr for zero allocation on shared memory.\";\n+  FreeAndNullify(shared_ptr);\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestSyclFree_Negative) {\n+  constexpr int kInvalidDeviceOrdinal = -1;\n+  void* null_ptr = nullptr;  // Null pointer should not cause issues.\n+\n+  // Attempt to free with an invalid device ordinal.\n+  EXPECT_THAT(SyclFree(kInvalidDeviceOrdinal, null_ptr),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  // Attempt to free a null pointer.\n+  EXPECT_THAT(SyclFree(kDefaultDeviceOrdinal, null_ptr),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument))\n+      << \"Expected error when trying to free a null pointer.\";\n+}\n+\n+TEST_F(SyclGpuRuntimeTest, TestSyclFree_DoubleFree) {\n+  TF_ASSERT_OK_AND_ASSIGN(void* device_ptr, AllocateDeviceBuffer(10));\n+  TF_ASSERT_OK(SyclFree(kDefaultDeviceOrdinal, device_ptr));\n+  EXPECT_EQ(device_ptr, nullptr);\n+\n+  // Try to free again, which should return an error.\n+  EXPECT_THAT(SyclFree(kDefaultDeviceOrdinal, device_ptr),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n }  // namespace\n }  // namespace stream_executor::sycl"
        },
        {
            "sha": "4bf9353279be5a0a4b65040a27f5cdf00ced2f62",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_timer.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 7,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer.cc?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -55,23 +55,25 @@ absl::StatusOr<float> GetEventElapsedTime(StreamExecutor* executor,\n \n   // Get the frequency and mask for the device to convert timestamps to\n   // milliseconds.\n-  // TODO(intel-tf): Remove the hardcoded frequency and mask values once\n-  // SyclGetFrequencyMask is implemented for all devices in SYCL GPU runtime.\n-  constexpr uint64_t frequency = 12500000;  // 12.5 MHz\n-  constexpr uint64_t mask = 4294967295;     // 0xFFFFFFFF\n+  // We assume that all SYCL devices have the same frequency and mask, so\n+  // we use kDefaultDeviceOrdinal.\n+  TF_ASSIGN_OR_RETURN(SyclTimerProperties timer_props,\n+                      SyclGetTimerProperties(kDefaultDeviceOrdinal));\n \n   const uint64_t kernel_start_time = start_timestamp.global.kernelStart;\n   const uint64_t kernel_end_time = end_timestamp.global.kernelEnd;\n   uint64_t elapsed_ticks;\n   if (kernel_start_time < kernel_end_time) {\n     elapsed_ticks = kernel_end_time - kernel_start_time;\n   } else {\n-    elapsed_ticks = (mask + 1ull) + kernel_end_time - kernel_start_time;\n+    elapsed_ticks = (timer_props.timestamp_mask + 1ull) + kernel_end_time -\n+                    kernel_start_time;\n   }\n   float elapsed_milliseconds =\n-      static_cast<float>(elapsed_ticks) * kMsecInSec / frequency;\n+      static_cast<float>(elapsed_ticks) * kMsecInSec / timer_props.frequency_hz;\n \n-  VLOG(1) << \"Frequency: \" << frequency << \", mask: \" << mask;\n+  VLOG(1) << \"Frequency: \" << timer_props.frequency_hz\n+          << \", mask: \" << timer_props.timestamp_mask;\n   VLOG(1) << \"The duration between start and stop events is \"\n           << elapsed_milliseconds << \" ms.\";\n   return elapsed_milliseconds;"
        },
        {
            "sha": "984608b5b160e771f1942ed825f5f9e5806e1c0c",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_timer.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer.h?ref=e9d1f9e5b9dc265bcfd1472b6137245105a2e3dd",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include \"xla/stream_executor/stream.h\"\n #include \"xla/stream_executor/stream_executor.h\"\n #include \"xla/stream_executor/sycl/sycl_event.h\"\n+#include \"xla/stream_executor/sycl/sycl_gpu_runtime.h\"\n \n namespace stream_executor::sycl {\n "
        }
    ],
    "stats": {
        "total": 1452,
        "additions": 1430,
        "deletions": 22
    }
}