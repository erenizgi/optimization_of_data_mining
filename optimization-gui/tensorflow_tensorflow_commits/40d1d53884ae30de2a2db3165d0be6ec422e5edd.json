{
    "author": "GleasonK",
    "message": "[StableHLO Optim] Add Dynamic Slice folding, short circuit on SliceOp folding for splats.\n\nPiperOrigin-RevId: 811989733",
    "sha": "40d1d53884ae30de2a2db3165d0be6ec422e5edd",
    "files": [
        {
            "sha": "9e54519b128d8579fec572f6d914b4d84772a073",
            "filename": "third_party/xla/third_party/stablehlo/temporary.patch",
            "status": "modified",
            "additions": 105,
            "deletions": 6,
            "changes": 111,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/40d1d53884ae30de2a2db3165d0be6ec422e5edd/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/40d1d53884ae30de2a2db3165d0be6ec422e5edd/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch?ref=40d1d53884ae30de2a2db3165d0be6ec422e5edd",
            "patch": "@@ -258,7 +258,45 @@ diff --ruN a/stablehlo/stablehlo/tests/chlo/chlo_legalize_to_stablehlo_broadcast\n diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir\n --- stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir\n +++ stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.mlir\n-@@ -712,18 +712,412 @@\n+@@ -601,6 +601,37 @@\n+ // -----\n+ \n+ ////////\n++// SliceOp / DynamicSliceOp\n++\n++// CHECK-LABEL: @slice_fold\n++func.func @slice_fold(%arg0: tensor<6x1xi32>) -> tensor<1x1xi32> {\n++  %c = stablehlo.constant dense<[[0], [1], [2], [3], [4], [5]]> : tensor<6x1xi32>\n++  %0 = stablehlo.slice %c [2:3, 0:1] : (tensor<6x1xi32>) -> tensor<1x1xi32>\n++  // CHECK: stablehlo.constant dense<2> : tensor<1x1xi32>\n++  return %0 : tensor<1x1xi32>\n++}\n++\n++// CHECK-LABEL: @slice_fold_splat\n++func.func @slice_fold_splat(%arg0: tensor<6x1xi32>) -> tensor<1x1xi32> {\n++  %c = stablehlo.constant dense<1> : tensor<6x1xi32>\n++  %0 = stablehlo.slice %c [2:3, 0:1] : (tensor<6x1xi32>) -> tensor<1x1xi32>\n++  // CHECK: stablehlo.constant dense<1> : tensor<1x1xi32>\n++  return %0 : tensor<1x1xi32>\n++}\n++\n++// CHECK-LABEL: @dynamic_slice_fold\n++func.func @dynamic_slice_fold(%arg0: tensor<i32>, %arg1: tensor<i32>) -> tensor<1x1xi32> {\n++  %0 = stablehlo.constant dense<256> : tensor<6x1xi32>\n++  %1 = \"stablehlo.dynamic_slice\"(%0, %arg0, %arg1) <{slice_sizes = array<i64: 1, 1>}> : (tensor<6x1xi32>, tensor<i32>, tensor<i32>) -> tensor<1x1xi32>\n++\n++  // CHECK: %[[RESULT:.*]] = stablehlo.constant dense<256> : tensor<1x1xi32>\n++  // CHECK: return %[[RESULT]]\n++  return %1 : tensor<1x1xi32>\n++}\n++\n++// -----\n++\n++////////\n+ // ConvertOp\n+ \n+ // CHECK-LABEL: func @eval_convert_f32_to_i64\n+@@ -712,18 +743,412 @@\n  // -----\n  \n  ////////\n@@ -679,7 +717,7 @@ diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_folder.ml\n  \n  ////////\n  // SetDimensionSizeOp\n-@@ -748,6 +1142,19 @@\n+@@ -748,6 +1173,19 @@\n    // CHECK-NEXT: return [[RESULT0]]\n    %0 = stablehlo.set_dimension_size %arg0, %c, dim = 0 : (tensor<10xf32>, tensor<i32>) -> tensor<?xf32, #stablehlo.bounds<10>>\n    return %0 : tensor<?xf32, #stablehlo.bounds<10>>\n@@ -1161,7 +1199,60 @@ diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFold\n  };\n  \n  template <typename RangeType>\n-@@ -1163,31 +1318,169 @@\n+@@ -1128,15 +1283,21 @@\n+       return rewriter.notifyMatchFailure(\n+           op, \"expected operand with static ranked tensor type\");\n+ \n+-    ElementsAttr els;\n++    DenseElementsAttr els;\n+     if (!matchPattern(operand, m_Constant(&els)))\n+       return rewriter.notifyMatchFailure(\n+           op, \"expected constant integer or float operand\");\n+ \n++    // Short circuit on splat resizes\n++    if (els.isSplat()) {\n++      rewriter.replaceOpWithNewOp<ConstantOp>(op, els.resizeSplat(resultType));\n++      return success();\n++    }\n++\n+     DenseElementsAttr resAttr;\n+-    if (auto data = els.tryGetValues<APInt>())\n++    if (auto data = els.tryGetValues<APInt>(); succeeded(data))\n+       resAttr = sliceType(op, *data);\n+-    else if (auto data = els.tryGetValues<APFloat>())\n++    else if (auto data = els.tryGetValues<APFloat>(); succeeded(data))\n+       resAttr = sliceType(op, *data);\n+     else\n+       return rewriter.notifyMatchFailure(op.getLoc(),\n+@@ -1147,6 +1308,27 @@\n+   }\n+ };\n+ \n++// Pattern: dynamic_slice(splat_cst, start, end) -> resized_splat_cst\n++struct FoldDynamicSliceOpPattern : public FoldOpRewritePattern<DynamicSliceOp> {\n++  using FoldOpRewritePattern::FoldOpRewritePattern;\n++\n++  LogicalResult matchAndRewrite(DynamicSliceOp op,\n++                                PatternRewriter& rewriter) const override {\n++    auto resultType = op.getType();\n++    if (failed(validateStaticShapeResult(rewriter, op, resultType)))\n++      return failure();\n++\n++    SplatElementsAttr inputSplatAttr;\n++    if (!matchPattern(op.getOperand(), m_Constant(&inputSplatAttr)) ||\n++        !inputSplatAttr)\n++      return rewriter.notifyMatchFailure(op, \"Input must be a splat constant.\");\n++\n++    rewriter.replaceOpWithNewOp<ConstantOp>(\n++        op, inputSplatAttr.resizeSplat(resultType));\n++    return success();\n++  }\n++};\n++\n+ struct FoldSubtractOpPattern final\n+     : ShapeOpRewritePattern<mlir::stablehlo::SubtractOp> {\n+   using ShapeOpRewritePattern::ShapeOpRewritePattern;\n+@@ -1163,31 +1345,169 @@\n    }\n  };\n  \n@@ -1355,7 +1446,7 @@ diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFold\n  };\n  \n  struct FoldIotaOpPattern : public FoldOpRewritePattern<IotaOp> {\n-@@ -1316,13 +1609,9 @@\n+@@ -1316,13 +1636,9 @@\n  \n      for (auto [inputValue, bodyArg] :\n           llvm::zip_equal(op.getOperands(), body.getArguments())) {\n@@ -1372,7 +1463,7 @@ diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFold\n          return rewriter.notifyMatchFailure(op,\n                                             \"Input must be a splat constant.\");\n  \n-@@ -1332,7 +1621,7 @@\n+@@ -1332,7 +1648,7 @@\n              op, \"Could not get the shape of the body argument.\");\n  \n        bodyArgConstantAttrs.push_back(DenseElementsAttr::get(\n@@ -1381,7 +1472,7 @@ diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFold\n      }\n  \n      for (BlockArgument bodyArg : body.getArguments()) {\n-@@ -1570,11 +1859,25 @@\n+@@ -1570,11 +1886,25 @@\n      PatternBenefit benefit) {\n    populateStablehloShapeFolderPatterns(context, patterns, options, benefit);\n  \n@@ -1408,6 +1499,14 @@ diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveFold\n                  FoldTransposeOpPattern,               //\n                  FoldWhileOpIfDeadAndPresumedPure,     //\n                  FoldWhileOpPattern,                   //\n+@@ -1605,6 +1935,7 @@\n+   patterns->add<FoldConcatenateOpPattern>(context, options, benefit);\n+   patterns->add<FoldConvertOpPattern>(context, options, benefit);\n+   patterns->add<FoldDivOpPattern>(context, options, benefit);\n++  patterns->add<FoldDynamicSliceOpPattern>(context, options, benefit);\n+   patterns->add<FoldGetDimensionSizeOpPattern>(context, options, benefit);\n+   patterns->add<FoldMaxOpPattern>(context, options, benefit);\n+   patterns->add<FoldMinOpPattern>(context, options, benefit);\n diff --ruN a/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplification.cpp b/stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplification.cpp\n --- stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplification.cpp\n +++ stablehlo/stablehlo/transforms/optimization/StablehloAggressiveSimplification.cpp"
        }
    ],
    "stats": {
        "total": 111,
        "additions": 105,
        "deletions": 6
    }
}