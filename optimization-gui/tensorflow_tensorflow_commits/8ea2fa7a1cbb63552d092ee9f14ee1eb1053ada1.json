{
    "author": "tensorflower-gardener",
    "message": "Remove expensive temp in `GetPariticipantCountsForReplicaGroups`.\n\nDon't copy replica groups in GetPariticipantCountsForReplicaGroups.\nThis does not seem to be needed in most cases.\n\nPiperOrigin-RevId: 803781056",
    "sha": "8ea2fa7a1cbb63552d092ee9f14ee1eb1053ada1",
    "files": [
        {
            "sha": "7ce67fcdf3b247836102cf1f773d43c2aa1f7da1",
            "filename": "third_party/xla/xla/service/collective_ops_utils.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8ea2fa7a1cbb63552d092ee9f14ee1eb1053ada1/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8ea2fa7a1cbb63552d092ee9f14ee1eb1053ada1/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.cc?ref=8ea2fa7a1cbb63552d092ee9f14ee1eb1053ada1",
            "patch": "@@ -582,10 +582,9 @@ absl::StatusOr<std::vector<int64_t>> GetPariticipantCountsForReplicaGroups(\n     absl::Span<const ReplicaGroup> replica_groups,\n     CollectiveOpGroupMode group_mode) {\n   std::vector<int64_t> participant_counts;\n-  std::vector<ReplicaGroup> participating_replica_groups =\n-      SpanToVector(replica_groups);\n \n   // If replica groups are empty, assume a group with all replicas.\n+  std::optional<ReplicaGroup> all_replica_groups;\n   if (replica_groups.empty()) {\n     if (group_mode == CollectiveOpGroupMode::kFlattenedID) {\n       // replica groups contain flattened-ids and cannot be empty.\n@@ -602,16 +601,17 @@ absl::StatusOr<std::vector<int64_t>> GetPariticipantCountsForReplicaGroups(\n       total_participant_count = num_replicas;\n     }\n \n-    ReplicaGroup replica_group = ReplicaGroup();\n+    all_replica_groups.emplace();\n+    all_replica_groups->mutable_replica_ids()->Reserve(total_participant_count);\n     for (int id = 0; id < total_participant_count; id++) {\n-      replica_group.add_replica_ids(id);\n+      all_replica_groups->add_replica_ids(id);\n     }\n-    participating_replica_groups.push_back(replica_group);\n+    replica_groups = absl::MakeConstSpan(&*all_replica_groups, 1);\n   }\n \n   switch (group_mode) {\n     case CollectiveOpGroupMode::kCrossReplica: {\n-      for (const auto& replica_group : participating_replica_groups) {\n+      for (const auto& replica_group : replica_groups) {\n         for (int partition_id = 0; partition_id < num_partitions;\n              ++partition_id) {\n           participant_counts.push_back(replica_group.replica_ids().size());\n@@ -620,20 +620,20 @@ absl::StatusOr<std::vector<int64_t>> GetPariticipantCountsForReplicaGroups(\n       return participant_counts;\n     }\n     case CollectiveOpGroupMode::kCrossPartition: {\n-      for (const auto& replica_group : participating_replica_groups) {\n+      for (const auto& replica_group : replica_groups) {\n         participant_counts.push_back(replica_group.replica_ids().size());\n       }\n       return participant_counts;\n     }\n     case CollectiveOpGroupMode::kCrossReplicaAndPartition: {\n-      for (const auto& replica_group : participating_replica_groups) {\n+      for (const auto& replica_group : replica_groups) {\n         participant_counts.push_back(replica_group.replica_ids().size() *\n                                      num_partitions);\n       }\n       return participant_counts;\n     }\n     case CollectiveOpGroupMode::kFlattenedID: {\n-      for (const auto& replica_group : participating_replica_groups) {\n+      for (const auto& replica_group : replica_groups) {\n         participant_counts.push_back(replica_group.replica_ids().size());\n       }\n       return participant_counts;"
        }
    ],
    "stats": {
        "total": 18,
        "additions": 9,
        "deletions": 9
    }
}