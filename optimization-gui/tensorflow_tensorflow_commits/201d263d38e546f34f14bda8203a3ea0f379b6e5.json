{
    "author": "tensorflower-gardener",
    "message": "Enhance SymbolicExprContext and SymbolicMap Equality\n\nWe are introducing an operator== for SymbolicExprContext to allow comparison based on the underlying mlir::MLIRContext pointer and updating the SymbolicMap::operator== has been updated to use this new SymbolicExprContext::operator==.\n\nThis change ensures that two SymbolicMap instances are considered equal if they have the same number of dimensions, symbols, and expressions, even if they are associated with different SymbolicExprContext objects, as long as those contexts point to the same mlir::MLIRContext. This is crucial because SymbolicExpr instances are uniqued within a specific StorageUniquer, so expressions from contexts sharing the same MLIRContext are inherently equivalent. This is needed to make IndexingMapTest::IndexingMapSupportsAbslHashAndEqAndNe to pass with SymbolicMaps.\n\nPiperOrigin-RevId: 830414101",
    "sha": "201d263d38e546f34f14bda8203a3ea0f379b6e5",
    "files": [
        {
            "sha": "d1226701f84e8d3272f9d3befd2874f6a37bf5b7",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.cc?ref=201d263d38e546f34f14bda8203a3ea0f379b6e5",
            "patch": "@@ -941,6 +941,10 @@ SymbolicExpr SymbolicExprContext::Parse(absl::string_view expr_str) {\n   return Parser(expr_str, this).Parse();\n }\n \n+bool SymbolicExprContext::operator==(const SymbolicExprContext& other) const {\n+  return mlir_context_ == other.mlir_context_;\n+}\n+\n void SymbolicExpr::Walk(\n     const std::function<void(SymbolicExpr)>& callback) const {\n   if (!*this) {"
        },
        {
            "sha": "9c41fced0d3535d3b6fa0684114dc4c624858091",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr.h?ref=201d263d38e546f34f14bda8203a3ea0f379b6e5",
            "patch": "@@ -162,6 +162,11 @@ class SymbolicExprContext {\n   SymbolicExpr CreateBinaryOp(SymbolicExprType type, SymbolicExpr lhs,\n                               SymbolicExpr rhs);\n \n+  bool operator==(const SymbolicExprContext& other) const;\n+  bool operator!=(const SymbolicExprContext& other) const {\n+    return !(*this == other);\n+  }\n+\n   mlir::MLIRContext* GetMLIRContext() const { return mlir_context_; }\n \n  private:"
        },
        {
            "sha": "0b12121a255d2ac75979b689910123a885e1d8e0",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_expr_test.cc?ref=201d263d38e546f34f14bda8203a3ea0f379b6e5",
            "patch": "@@ -352,5 +352,18 @@ TEST_F(SymbolicExprTest, Hashing) {\n   EXPECT_EQ(set.size(), 6);\n }\n \n+TEST_F(SymbolicExprTest, SymbolicExprContextEq) {\n+  mlir::MLIRContext mlir_context2;\n+  SymbolicExprContext ctx2(&mlir_context2);\n+\n+  // Different MLIRContexts should result in different SymbolicExprContexts.\n+  EXPECT_NE(ctx, ctx2);\n+\n+  // Same MLIRContext should result in same StorageUniquer and thus equal\n+  // SymbolicExprContexts.\n+  SymbolicExprContext ctx3(&mlir_context);\n+  EXPECT_EQ(ctx, ctx3);\n+}\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "468190d2e1ec03303a28b9750057ac3635643d54",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc?ref=201d263d38e546f34f14bda8203a3ea0f379b6e5",
            "patch": "@@ -212,8 +212,11 @@ SymbolicMap SymbolicMap::Replace(SymbolicExpr expr,\n }\n \n bool SymbolicMap::operator==(const SymbolicMap& other) const {\n-  return ctx_ == other.ctx_ && num_dimensions_ == other.num_dimensions_ &&\n-         num_symbols_ == other.num_symbols_ && exprs_ == other.exprs_;\n+  const bool same_context =\n+      (ctx_ == other.ctx_) ||\n+      (ctx_ != nullptr && other.ctx_ != nullptr && *ctx_ == *other.ctx_);\n+  return (same_context && num_dimensions_ == other.num_dimensions_ &&\n+          num_symbols_ == other.num_symbols_ && exprs_ == other.exprs_);\n }\n \n llvm::SmallBitVector GetUnusedDimensionsBitVector(const SymbolicMap& map) {"
        },
        {
            "sha": "59d3baa1695ca8b2d2d24c2cc518138237428176",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_test.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/201d263d38e546f34f14bda8203a3ea0f379b6e5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc?ref=201d263d38e546f34f14bda8203a3ea0f379b6e5",
            "patch": "@@ -352,6 +352,29 @@ TEST_F(SymbolicMapTest, CompressSymbols) {\n                \"Attempting to compress a used symbol: 2\");\n }\n \n+TEST_F(SymbolicMapTest, EqualityWithDifferentContexts) {\n+  mlir::MLIRContext mlir_context2;\n+  SymbolicExprContext ctx2(&mlir_context2);\n+  // ctx2 and ctx3 will have the same MLIRContext, and thus the same\n+  // StorageUniquer, so they should be considered equal.\n+  SymbolicExprContext ctx3(&mlir_context2);\n+\n+  SymbolicExpr d0_ctx1 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d0_ctx2 = CreateDimExpr(&ctx2, 0);\n+  SymbolicExpr d0_ctx3 = CreateDimExpr(&ctx3, 0);\n+\n+  SymbolicMap map1 = SymbolicMap::Get(&ctx, 1, 0, {d0_ctx1});\n+  SymbolicMap map2 = SymbolicMap::Get(&ctx2, 1, 0, {d0_ctx2});\n+  SymbolicMap map3 = SymbolicMap::Get(&ctx3, 1, 0, {d0_ctx3});\n+\n+  // Maps with different contexts should not be equal.\n+  EXPECT_TRUE(map1 != map2);\n+\n+  // Maps with the same UniquerStorage and expressions should be equal even if\n+  // they have different SymbolicExprContexts.\n+  EXPECT_TRUE(map2 == map3);\n+}\n+\n TEST_F(SymbolicMapTest, Hashing) {\n   absl::flat_hash_set<SymbolicMap> set;\n "
        }
    ],
    "stats": {
        "total": 52,
        "additions": 50,
        "deletions": 2
    }
}