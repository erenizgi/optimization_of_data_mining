{
    "author": "WillFroom",
    "message": "[XLA:CPU/GPU][XTile] Fix duplicated traversal in tiling analysis.\n\nWe are hitting an exponential edge case in the CpuGpuFusionTest.Fibonacci test, this is due to us revisiting nodes as they do not compare equal as we keep adding the operands.\n\nPiperOrigin-RevId: 840817438",
    "sha": "de8c244151ecf02989f50e2e1f498da3518d2f88",
    "files": [
        {
            "sha": "a373ed7c1ced60a34f8e3b4c068de9fcf1444c92",
            "filename": "third_party/xla/xla/codegen/tiling/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD?ref=de8c244151ecf02989f50e2e1f498da3518d2f88",
            "patch": "@@ -372,6 +372,7 @@ cc_library(\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/container:hash_container_defaults\",\n         \"@com_google_absl//absl/container:inlined_vector\",\n         \"@com_google_absl//absl/hash\",\n         \"@com_google_absl//absl/log\","
        },
        {
            "sha": "af166ae57df5cf91fe295f4344ca76284d04e3a3",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 8,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc?ref=de8c244151ecf02989f50e2e1f498da3518d2f88",
            "patch": "@@ -31,6 +31,7 @@ limitations under the License.\n #include \"absl/algorithm/container.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n+#include \"absl/container/hash_container_defaults.h\"\n #include \"absl/container/inlined_vector.h\"\n #include \"absl/hash/hash.h\"\n #include \"absl/log/check.h\"\n@@ -64,7 +65,6 @@ limitations under the License.\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/analysis/indexing_map_serialization.h\"\n #include \"xla/hlo/analysis/interval.h\"\n-#include \"xla/hlo/analysis/symbolic_expr.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n@@ -335,7 +335,8 @@ absl::StatusOr<IndexingMap> ComputeTileOffsetIndexing(\n //   during the construction of TiledHloComputation from\n //   SymbolicTiledHloInstructions, we know that instruction are already sorted\n //   in def-before-use order.\n-template <typename T>\n+template <typename T, typename Hash = absl::DefaultHashContainerHash<T>,\n+          typename Eq = absl::DefaultHashContainerEq<T>>\n class OrderedUniquePtrValueHashSet {\n  public:\n   // Inserts an element into the set.\n@@ -360,12 +361,12 @@ class OrderedUniquePtrValueHashSet {\n \n  private:\n   struct PtrHash {\n-    size_t operator()(const T* v) const { return absl::HashOf(*v); }\n+    size_t operator()(const T* v) const { return Hash()(*v); }\n   };\n \n   struct PtrEqual {\n     bool operator()(const T* lhs, const T* rhs) const {\n-      return lhs == rhs || *lhs == *rhs;\n+      return lhs == rhs || Eq()(*lhs, *rhs);\n     }\n   };\n \n@@ -388,6 +389,35 @@ bool IsWithinNestedGemmFusion(const HloInstruction* hlo) {\n   return false;\n }\n \n+// !!!Warning!!! Do not blindly copy this hash operator: it is an implementation\n+// detail specific to this analysis. It may give unexpected results in the\n+// general case as it ignores operands.\n+struct UnsafeSymbolicTiledHloInstructionOperandAgnosticHash {\n+  size_t operator()(const SymbolicTiledHloInstruction& value) const {\n+    return absl::HashOf(value.hlo(), value.indexing_map(),\n+                        value.runtime_variables());\n+  }\n+};\n+\n+// !!!Warning!!! See above comment.\n+struct UnsafeSymbolicTiledHloInstructionOperandAgnosticEq {\n+  bool operator()(const SymbolicTiledHloInstruction& lhs,\n+                  const SymbolicTiledHloInstruction& rhs) const {\n+    return lhs.hlo() == rhs.hlo() && lhs.indexing_map() == rhs.indexing_map() &&\n+           lhs.runtime_variables() == rhs.runtime_variables();\n+  }\n+};\n+\n+// As we traverse the fusion root to leaf and add operands to instructions as we\n+// go, we ignore the operands from the hash / equality operators as they are not\n+// intrinsic to two instructions being the same or not and will always end up\n+// being the same after complete traversal.\n+using UnsafeSymbolicTiledHloInstructionOrderedSet =\n+    OrderedUniquePtrValueHashSet<\n+        SymbolicTiledHloInstruction,\n+        UnsafeSymbolicTiledHloInstructionOperandAgnosticHash,\n+        UnsafeSymbolicTiledHloInstructionOperandAgnosticEq>;\n+\n // Detects pathological cases on which symbolic tile derivation should bail out.\n // Note that this function bypasses temporary limitations of the infrastructure,\n // and not actual fundamental limitations.\n@@ -1068,8 +1098,7 @@ ComposeIndexingResult ComposeInstructionIndexing(\n     SymbolicTiledHloInstruction* tiled_hlo_instruction,\n     const OperandIndexing& operand_indexing,\n     IndexingMap::SimplifyPointDimensions simplification_mode,\n-    OrderedUniquePtrValueHashSet<SymbolicTiledHloInstruction>&\n-        tiled_hlo_instructions_set,\n+    UnsafeSymbolicTiledHloInstructionOrderedSet& tiled_hlo_instructions_set,\n     HloInstructionAdaptor operand, HloInstructionAdaptor& instruction_adaptor,\n     int64_t operand_pos,\n     const TilingSpecification::ParameterMapping& parameter_mapping) {\n@@ -1175,8 +1204,7 @@ std::vector<OperandIndexingSet> GetOperandIndexingMaps(\n     IndexingMap::SimplifyPointDimensions simplification_mode,\n     EmitterSpecificConstraintsBuilder emitter_specific_constraints_builder,\n     std::vector<SymbolicTiledHloInstruction*> root_runtime_variables) {\n-  OrderedUniquePtrValueHashSet<SymbolicTiledHloInstruction>\n-      tiled_hlo_instructions_set;\n+  UnsafeSymbolicTiledHloInstructionOrderedSet tiled_hlo_instructions_set;\n \n   // TODO(b/372454662): Once we get rid of the restriction of only one real\n   // root, this needs to be adapted."
        },
        {
            "sha": "23beabca918ab31357598511504995ba35ab8a13",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis_test.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc?ref=de8c244151ecf02989f50e2e1f498da3518d2f88",
            "patch": "@@ -2613,5 +2613,58 @@ ENTRY main {\n                                          num_m_tiles, num_n_tiles, tile_n)));\n }\n \n+// Check that we don't hit the exponential complexity edge case (it will timeout\n+// if we do).\n+TEST_F(SymbolicTileAnalysisTest, FibonacciSucceeds) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+fibonacci {\n+    fib0 = f32[5] parameter(0)\n+    fib1 = f32[5] parameter(1)\n+    fib2 = f32[5] add(f32[5] fib0, f32[5] fib1)\n+    fib3 = f32[5] add(f32[5] fib2, f32[5] fib1)\n+    fib4 = f32[5] add(f32[5] fib3, f32[5] fib2)\n+    fib5 = f32[5] add(f32[5] fib4, f32[5] fib3)\n+    fib6 = f32[5] add(f32[5] fib5, f32[5] fib4)\n+    fib7 = f32[5] add(f32[5] fib6, f32[5] fib5)\n+    fib8 = f32[5] add(f32[5] fib7, f32[5] fib6)\n+    fib9 = f32[5] add(f32[5] fib8, f32[5] fib7)\n+    fib10 = f32[5] add(f32[5] fib9, f32[5] fib8)\n+    fib11 = f32[5] add(f32[5] fib10, f32[5] fib9)\n+    fib12 = f32[5] add(f32[5] fib11, f32[5] fib10)\n+    fib13 = f32[5] add(f32[5] fib12, f32[5] fib11)\n+    fib14 = f32[5] add(f32[5] fib13, f32[5] fib12)\n+    fib15 = f32[5] add(f32[5] fib14, f32[5] fib13)\n+    fib16 = f32[5] add(f32[5] fib15, f32[5] fib14)\n+    fib17 = f32[5] add(f32[5] fib16, f32[5] fib15)\n+    fib18 = f32[5] add(f32[5] fib17, f32[5] fib16)\n+    fib19 = f32[5] add(f32[5] fib18, f32[5] fib17)\n+    fib20 = f32[5] add(f32[5] fib19, f32[5] fib18)\n+    fib21 = f32[5] add(f32[5] fib20, f32[5] fib19)\n+    fib22 = f32[5] add(f32[5] fib21, f32[5] fib20)\n+    fib23 = f32[5] add(f32[5] fib22, f32[5] fib21)\n+    fib24 = f32[5] add(f32[5] fib23, f32[5] fib22)\n+    fib25 = f32[5] add(f32[5] fib24, f32[5] fib23)\n+    fib26 = f32[5] add(f32[5] fib25, f32[5] fib24)\n+    fib27 = f32[5] add(f32[5] fib26, f32[5] fib25)\n+    fib28 = f32[5] add(f32[5] fib27, f32[5] fib26)\n+    fib29 = f32[5] add(f32[5] fib28, f32[5] fib27)\n+    fib30 = f32[5] add(f32[5] fib29, f32[5] fib28)\n+    fib31 = f32[5] add(f32[5] fib30, f32[5] fib29)\n+    fib32 = f32[5] add(f32[5] fib31, f32[5] fib30)\n+    fib33 = f32[5] add(f32[5] fib32, f32[5] fib31)\n+    fib34 = f32[5] add(f32[5] fib33, f32[5] fib32)\n+    ROOT fib35 = f32[5] add(f32[5] fib34, f32[5] fib33)\n+}\n+\n+ENTRY main {\n+  p0 = f32[5] parameter(0)\n+  p1 = f32[5] parameter(1)\n+  ROOT fusion = f32[5] fusion(p0, p1), kind=kCustom, calls=fibonacci\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+}\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "ad1e3966f1d4292efd38609eded9ac8c1ce1110d",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tiled_hlo_instruction.h",
            "status": "modified",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tiled_hlo_instruction.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/de8c244151ecf02989f50e2e1f498da3518d2f88/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tiled_hlo_instruction.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tiled_hlo_instruction.h?ref=de8c244151ecf02989f50e2e1f498da3518d2f88",
            "patch": "@@ -99,32 +99,6 @@ class SymbolicTiledHloInstruction {\n   std::vector<SymbolicTiledHloInstruction*> runtime_variables_;\n };\n \n-inline bool operator==(const SymbolicTiledHloInstruction& lhs,\n-                       const SymbolicTiledHloInstruction& rhs) {\n-  return lhs.hlo() == rhs.hlo() && lhs.indexing_map() == rhs.indexing_map() &&\n-         lhs.runtime_variables() == rhs.runtime_variables() &&\n-         lhs.operands() == rhs.operands();\n-}\n-\n-inline bool operator!=(const SymbolicTiledHloInstruction& lhs,\n-                       const SymbolicTiledHloInstruction& rhs) {\n-  return !(lhs == rhs);\n-}\n-\n-template <typename H>\n-H AbslHashValue(H h, const SymbolicTiledHloInstruction& tiled_hlo_instruction) {\n-  h = H::combine(std::move(h), tiled_hlo_instruction.hlo(),\n-                 tiled_hlo_instruction.indexing_map());\n-  for (const auto& runtime_variable :\n-       tiled_hlo_instruction.runtime_variables()) {\n-    h = H::combine(std::move(h), runtime_variable);\n-  }\n-  for (const auto& operand : tiled_hlo_instruction.operands()) {\n-    h = H::combine(std::move(h), operand);\n-  }\n-  return h;\n-}\n-\n }  // namespace xla\n \n #endif  // XLA_CODEGEN_TILING_SYMBOLIC_TILED_HLO_INSTRUCTION_H_"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 90,
        "deletions": 34
    }
}