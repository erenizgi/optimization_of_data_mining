{
    "author": "bmass02",
    "message": "Integrate SparseCore offloading metadata into grouping logic to accurately group SparseCore execution with TensorCore.\n\nPiperOrigin-RevId: 842931062",
    "sha": "2f41ba94e4625718e339800da9527fac595b8e9d",
    "files": [
        {
            "sha": "175eabf5b957bcd09bb8a5d0036935a8871da9b9",
            "filename": "third_party/xla/xla/tsl/profiler/utils/BUILD",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2FBUILD?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -297,6 +297,7 @@ cc_library(\n     deps = [\n         \":tf_xplane_visitor\",\n         \":timespan\",\n+        \":tpu_xplane_utils\",\n         \":xplane_builder\",\n         \":xplane_schema\",\n         \":xplane_utils\",\n@@ -311,8 +312,8 @@ cc_library(\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/strings\",\n-        \"@local_tsl//tsl/platform:dso_loader\",\n         \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n     ],\n )\n@@ -344,6 +345,7 @@ tsl_cc_test(\n         \":preprocess_xplane\",\n         \":tf_xplane_visitor\",\n         \":timespan\",\n+        \":trace_utils\",\n         \":xplane_builder\",\n         \":xplane_schema\",\n         \":xplane_test_utils\",\n@@ -353,8 +355,10 @@ tsl_cc_test(\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:types\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/profiler/lib:context_types_hdrs\",\n         \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n     ],\n )"
        },
        {
            "sha": "20a74dd74eea91a8b7627f48fda187c1e8498dd7",
            "filename": "third_party/xla/xla/tsl/profiler/utils/group_events.cc",
            "status": "modified",
            "additions": 236,
            "deletions": 131,
            "changes": 367,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events.cc?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -15,11 +15,8 @@ limitations under the License.\n \n #include \"xla/tsl/profiler/utils/group_events.h\"\n \n-#include <algorithm>\n #include <cstdint>\n #include <functional>\n-#include <iterator>\n-#include <map>\n #include <memory>\n #include <optional>\n #include <queue>\n@@ -31,18 +28,21 @@ limitations under the License.\n #include \"absl/base/no_destructor.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/functional/bind_front.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n+#include \"absl/strings/match.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"xla/tsl/lib/gtl/map_util.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/types.h\"\n #include \"xla/tsl/profiler/utils/tf_xplane_visitor.h\"\n #include \"xla/tsl/profiler/utils/timespan.h\"\n+#include \"xla/tsl/profiler/utils/tpu_xplane_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_builder.h\"\n #include \"xla/tsl/profiler/utils/xplane_schema.h\"\n #include \"xla/tsl/profiler/utils/xplane_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_visitor.h\"\n-#include \"tsl/platform/dso_loader.h\"\n #include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n namespace tsl {\n@@ -144,16 +144,13 @@ void SetContextGroup(const GroupingEventStats& stats, EventNode* event,\n }\n \n void ConnectContextGroups(const ContextGroupMap& context_groups) {\n-  for (auto& type_id_group : context_groups) {\n-    for (auto& id_group : type_id_group.second) {\n-      const ContextGroup& group = id_group.second;\n+  for (auto& [type, id_group] : context_groups) {\n+    for (auto& [id, group] : id_group) {\n       if (group.producers.size() >= 64 && group.consumers.size() >= 64) {\n         LOG_EVERY_N(WARNING, 1000)\n-            << \"id:\" << id_group.first\n+            << \"type: \" << type << \" id: \" << id\n             << \" producers:\" << group.producers.size() << \" : \"\n-            << group.producers[0]->GetEventVisitor().Name()\n-            << \" consumers:\" << group.consumers.size() << \" : \"\n-            << group.consumers[0]->GetEventVisitor().Name();\n+            << \" consumers:\" << group.consumers.size() << \" : \";\n         continue;\n       }\n \n@@ -166,6 +163,13 @@ void ConnectContextGroups(const ContextGroupMap& context_groups) {\n   }\n }\n \n+bool IsTPUParentLineEvent(const XEventVisitor& event) {\n+  return event.LineName() == kStepLineName ||\n+         event.LineName() == kSparseCoreStepLineName ||\n+         event.LineName() == kXlaModuleLineName ||\n+         event.LineName() == kSparseCoreModuleLineName;\n+}\n+\n bool IsImplicitRootEvent(const XEventVisitor& event) {\n   static const absl::NoDestructor<absl::flat_hash_set<int64_t>>\n       kImplicitRootEvents({\n@@ -174,8 +178,9 @@ bool IsImplicitRootEvent(const XEventVisitor& event) {\n           HostEventType::kRunGraph,\n           HostEventType::kExecutorStateProcess,\n       });\n-  return event.Type().has_value() &&\n-         kImplicitRootEvents->contains(*event.Type());\n+  return (event.Type().has_value() &&\n+          kImplicitRootEvents->contains(*event.Type())) ||\n+         IsTPUParentLineEvent(event);\n }\n \n void ProcessRootEvent(int64_t group_id, EventNode* root_event,\n@@ -269,7 +274,7 @@ std::string EventNode::GetGroupName() const {\n   std::string name;\n   if (std::optional<XStatVisitor> stat = GetContextStat(StatType::kGraphType)) {\n     absl::StrAppend(&name, stat->StrOrRefValue(), \" \");\n-  } else if (!(IsImplicitRootEvent(visitor_))) {\n+  } else if (!IsImplicitRootEvent(visitor_)) {\n     absl::StrAppend(&name, GetEventVisitor().Name(), \" \");\n   }\n   int64_t step_num = group_id_.value_or(0);\n@@ -381,41 +386,133 @@ void EventForest::FindEventNodeAndApply(\n   }\n }\n \n-void EventForest::ConnectIntraThread(XPlane* plane, XPlaneVisitor* visitor,\n-                                     ContextGroupMap* context_groups) {\n-  bool is_host_plane = (visitor->Name() == kHostThreadsPlaneName);\n+// Finds the primary line used for grouping TPU events (StepLine or ModuleLine).\n+// Returns nullptr if no suitable grouping line is found.\n+XLine* GetGroupingLineForTPU(XPlane* plane) {\n+  XLine* step_line = nullptr;\n+  XLine* module_line = nullptr;\n+  for (auto& line : *plane->mutable_lines()) {\n+    if (line.name() == kStepLineName ||\n+        line.name() == kSparseCoreStepLineName) {\n+      step_line = &line;\n+    } else if (line.name() == kXlaModuleLineName ||\n+               line.name() == kSparseCoreModuleLineName) {\n+      module_line = &line;\n+    }\n+  }\n+\n+  if (step_line != nullptr && step_line->events_size() > 0) {\n+    // Prefer the step line for grouping if it is not empty.\n+    return step_line;\n+  }\n+  if (module_line != nullptr && module_line->events_size() > 0) {\n+    // Fall back to the module line for inference grouping.\n+    return module_line;\n+  }\n+  return nullptr;\n+}\n+\n+void EventForest::ConnectIntraThreadTPU(XPlane* plane, XPlaneVisitor* visitor,\n+                                        ContextGroupMap* context_groups) {\n+  std::optional<int64_t> tc_id = GetTensorCoreId(visitor->Name());\n+  std::optional<int64_t> sc_id = GetSparseCoreId(visitor->Name());\n+  if (!tc_id.has_value() && !sc_id.has_value()) {\n+    LOG(ERROR) << \"TensorCore or SparseCore ID is missing. Skipping grouping \"\n+                  \"for device plane: \"\n+               << visitor->Name();\n+    return;\n+  }\n+  XLine* grouping_line = GetGroupingLineForTPU(plane);\n+  if (grouping_line == nullptr) {\n+    LOG(ERROR) << \"No grouping line found. Skipping grouping for device plane: \"\n+               << visitor->Name();\n+    return;\n+  }\n+\n+  // Step 1: Connect the grouping events and store them as the parent nodes for\n+  // future connection delegation. NOTE: This will need to be updated to support\n+  // sub-step grouping.\n+  std::vector<EventNode*> parent_nodes;\n+  parent_nodes.reserve(grouping_line->events_size());\n+  for (auto& event : *grouping_line->mutable_events()) {\n+    XEventVisitor event_visitor(visitor, grouping_line, &event);\n+    int64_t event_type = GetEventType(/*is_host_plane=*/false, event_visitor);\n+    EventNode* step_node =\n+        &event_node_map_[event_type].emplace_back(std::move(event_visitor));\n+    GroupingEventStats stats(step_node->GetEventVisitor());\n+    parent_nodes.push_back(step_node);\n+    SetContextGroup(stats, step_node, context_groups);\n+  }\n+  // Step 2: Process all other events and propagate their connection metadata to\n+  // the parent nodes.\n   for (auto& line : *plane->mutable_lines()) {\n-    if (line.name() == kTensorCoreSyncFlagLineName ||\n-        line.name() == kSparseCoreSyncsLineName) {\n-      VLOG(1) << \"Skipping Xline with name: \" << line.name()\n-              << \" in plane: \" << visitor->Name();\n+    if (&line == grouping_line) {\n       continue;\n     }\n-    std::vector<EventNode*> parent_nodes;\n+    int parent_index = 0;  // Reset index for each line\n     for (auto& event : *line.mutable_events()) {\n       XEventVisitor event_visitor(visitor, &line, &event);\n-      int64_t event_type = GetEventType(is_host_plane, event_visitor);\n-      EventNode* cur_node =\n-          &event_node_map_[event_type].emplace_back(std::move(event_visitor));\n-      GroupingEventStats stats(cur_node->GetEventVisitor());\n-      if (stats.root_level.has_value()) {\n-        cur_node->SetRootLevel(*stats.root_level);\n+      GroupingEventStats stats(event_visitor);\n+      // Find the first step node that *may* be the parent of this event.\n+      while (parent_index < parent_nodes.size() &&\n+             parent_nodes[parent_index]\n+                     ->GetEventVisitor()\n+                     .GetTimespan()\n+                     .end_ps() <= event_visitor.GetTimespan().begin_ps()) {\n+        parent_index++;\n       }\n-      // Update `context_groups` for `ConnectInterThread`.\n-      SetContextGroup(stats, cur_node, context_groups);\n-      // Async events are ignored when processing the nesting relationship.\n-      if (!stats.is_async) {\n-        while (!parent_nodes.empty()) {\n-          EventNode* parent_node = parent_nodes.back();\n-          if (parent_node->GetEventVisitor().GetTimespan().Includes(\n-                  cur_node->GetEventVisitor().GetTimespan())) {\n-            parent_node->AddChild(cur_node);\n-            break;\n-          } else {\n+      if (parent_index == parent_nodes.size()) {\n+        // Short-circuit when we've reached the end of the parent line.\n+        break;\n+      }\n+      if (parent_nodes[parent_index]->GetEventVisitor().GetTimespan().Includes(\n+              event_visitor.GetTimespan())) {\n+        // For device events, the parent nodes will consume the\n+        // producer/consumer stats of children to reduce the number of nodes\n+        // in DAG.\n+        SetContextGroup(stats, parent_nodes[parent_index], context_groups);\n+      }\n+    }\n+  }\n+  // Step 3: [Only for TensorCore] Store the parent nodes for later if they fail\n+  // to be grouped with the host events.\n+  if (tc_id.has_value()) {\n+    tensor_core_root_events_per_core_.emplace_back(std::move(parent_nodes));\n+  }\n+}\n+\n+void EventForest::ConnectIntraThread(XPlane* plane, XPlaneVisitor* visitor,\n+                                     ContextGroupMap* context_groups) {\n+  bool is_host_plane = (visitor->Name() == kHostThreadsPlaneName);\n+  if (absl::StartsWith(visitor->Name(), kTpuPlanePrefix)) {\n+    ConnectIntraThreadTPU(plane, visitor, context_groups);\n+  } else {\n+    for (auto& line : *plane->mutable_lines()) {\n+      std::vector<EventNode*> parent_nodes;\n+      for (auto& event : *line.mutable_events()) {\n+        XEventVisitor event_visitor(visitor, &line, &event);\n+        int64_t event_type = GetEventType(is_host_plane, event_visitor);\n+        EventNode* cur_node =\n+            &event_node_map_[event_type].emplace_back(std::move(event_visitor));\n+        GroupingEventStats stats(cur_node->GetEventVisitor());\n+        if (stats.root_level.has_value()) {\n+          cur_node->SetRootLevel(*stats.root_level);\n+        }\n+        // Update `context_groups` for `ConnectInterThread`.\n+        SetContextGroup(stats, cur_node, context_groups);\n+        // Async events are ignored when processing the nesting relationship.\n+        if (!stats.is_async) {\n+          while (!parent_nodes.empty()) {\n+            EventNode* parent_node = parent_nodes.back();\n+            if (parent_node->GetEventVisitor().GetTimespan().Includes(\n+                    cur_node->GetEventVisitor().GetTimespan())) {\n+              parent_node->AddChild(cur_node);\n+              break;\n+            }\n             parent_nodes.pop_back();\n           }\n+          parent_nodes.push_back(cur_node);\n         }\n-        parent_nodes.push_back(cur_node);\n       }\n     }\n   }\n@@ -468,7 +565,7 @@ bool RootNeedsGrouping(const EventNode* root) {\n   // different levels are grouped separately.\n   const EventNode* root_parent = FindParentWithComparator(\n       [root](const EventNode* parent) {\n-        return parent->RootLevel() == root->RootLevel();\n+        return parent->IsRoot() && parent->RootLevel() == root->RootLevel();\n       },\n       root,\n       /*include_self=*/false);\n@@ -493,28 +590,56 @@ void EventForest::CreateEventGroups() {\n     for (EventNode* root_event : tf_loop_root_events_) {\n       ProcessRootEvent(group_id++, root_event, &group_metadata_map_);\n     }\n-    return;\n-  }\n+  } else {\n+    // Iterate over all events and collect all root events.\n+    EventList root_events;\n+    EventList implicit_root_events;\n+    for (auto& [event_type, events] : event_node_map_) {\n+      for (EventNode& event : events) {\n+        if (!event.IsRoot()) {\n+          continue;\n+        }\n+        std::optional<XStatVisitor> step_id_stat =\n+            event.GetEventVisitor().GetStat(StatType::kStepId);\n+        // If this is a root event that associated with tf.data, skip.\n+        if (step_id_stat &&\n+            tf_data_step_ids_.contains(step_id_stat->IntValue())) {\n+          continue;\n+        }\n+        root_events.push_back(&event);\n+      }\n+    }\n \n-  // Iterate over all events and collect all root events.\n-  EventList root_events;\n-  for (auto& [event_type, events] : event_node_map_) {\n-    for (EventNode& event : events) {\n-      if (!event.RootLevel()) continue;\n-      std::optional<XStatVisitor> step_id_stat =\n-          event.GetEventVisitor().GetStat(StatType::kStepId);\n-      // If this is a root event that associated with tf.data, skip.\n-      if (step_id_stat && tf_data_step_ids_.contains(step_id_stat->IntValue()))\n-        continue;\n-      root_events.push_back(&event);\n+    SortRootEventList(&root_events);\n+\n+    for (EventNode* root_event : root_events) {\n+      if (RootNeedsGrouping(root_event)) {\n+        ProcessRootEvent(group_id++, root_event, &group_metadata_map_);\n+      }\n     }\n   }\n \n-  SortRootEventList(&root_events);\n-\n-  for (EventNode* root_event : root_events) {\n-    if (RootNeedsGrouping(root_event)) {\n-      ProcessRootEvent(group_id++, root_event, &group_metadata_map_);\n+  // Check if any TPU root events were grouped. If not, group all in lock step.\n+  bool tpu_needs_grouping = absl::c_all_of(\n+      tensor_core_root_events_per_core_, [](const auto& core_root_events) {\n+        return absl::c_all_of(core_root_events, [](const auto& event) {\n+          return RootNeedsGrouping(event);\n+        });\n+      });\n+  if (tpu_needs_grouping) {\n+    for (auto& core_root_events : tensor_core_root_events_per_core_) {\n+      // Do not change the group_id. This is a cheap way to align the TensorCore\n+      // and SparseCore device step events. But can be incorrect if somehow one\n+      // core started from an earlier step.\n+      uint64_t device_step_group_id = group_id;\n+      for (EventNode* root_event : core_root_events) {\n+        // If the device step event hasn't been grouped, then treat it as a root\n+        // event and group it.\n+        if (RootNeedsGrouping(root_event)) {\n+          ProcessRootEvent(device_step_group_id++, root_event,\n+                           &group_metadata_map_);\n+        }\n+      }\n     }\n   }\n }\n@@ -615,6 +740,10 @@ void EventForest::ProcessTensorFlowLoop() {\n void EventForest::AddPlane(\n     const std::function<XPlaneVisitor(const XPlane*)> visitor_factory,\n     XPlane* plane) {\n+  if (registered_planes_.contains(plane)) {\n+    return;\n+  }\n+  registered_planes_.insert(plane);\n   CreateStatMetadata(plane);\n   planes_.push_back({plane, visitor_factory(plane)});\n }\n@@ -828,32 +957,55 @@ void MergeHostSteps(const XStatMetadata& group_id_stat_metadata,\n       GetStatTypeStr(StatType::kDeviceDurationPs));\n   auto device_offset_stat_metadata = *plane_builder->GetOrCreateStatMetadata(\n       GetStatTypeStr(StatType::kDeviceOffsetPs));\n+  auto step_idle_time_stat_metadata = *plane_builder->GetOrCreateStatMetadata(\n+      GetStatTypeStr(StatType::kStepIdleTimePs));\n   std::optional<int64_t> merged_group_id;\n   std::optional<Timespan> merged_device_timespan;\n   std::optional<XEventBuilder> merged_step_builder;\n+  int64_t merged_step_idle_time = 0;\n   absl::flat_hash_set<const XEvent*> events_to_remove;\n   for (XEvent& step_event : *step_line->mutable_events()) {\n     XEventVisitor step_visitor(&plane_visitor, step_line, &step_event);\n     auto group_id = GetGroupId(step_visitor, group_id_stat_metadata);\n-    if (!group_id) {\n+    if (!group_id.has_value()) {\n       // Discard ungrouped event.\n       // This usually happens at the beginning of a trace collected using\n       // sampling mode, since the host is ahead of the device.\n       merged_group_id.reset();\n       merged_step_builder.reset();\n+      merged_step_idle_time = 0;\n       events_to_remove.insert(&step_event);\n     } else if (merged_group_id != group_id) {\n       // Start a new step with the current event.\n       merged_group_id = group_id;\n       merged_device_timespan.reset();\n-      if (step_visitor.GetStat(StatType::kDeviceOffsetPs).has_value() &&\n-          step_visitor.GetStat(StatType::kDeviceDurationPs).has_value()) {\n+      if (std::optional<XStatVisitor> current_step_idle_time =\n+              step_visitor.GetStat(StatType::kStepIdleTimePs,\n+                                   step_idle_time_stat_metadata);\n+          current_step_idle_time.has_value()) {\n+        merged_step_idle_time = current_step_idle_time->IntOrUintValue();\n+      }\n+      if (step_visitor\n+              .GetStat(StatType::kDeviceOffsetPs, device_offset_stat_metadata)\n+              .has_value() &&\n+          step_visitor\n+              .GetStat(StatType::kDeviceDurationPs,\n+                       device_duration_stat_metadata)\n+              .has_value()) {\n         merged_device_timespan = GetDeviceEventTimespan(step_visitor);\n       }\n       merged_step_builder.emplace(step_line, plane_builder, &step_event);\n+      merged_step_builder->SetOrAddStatValue(step_idle_time_stat_metadata,\n+                                             merged_step_idle_time);\n     } else {\n       // Multi-module step: extend the previous step until the end of the\n       // current event and discard the current event.\n+      if (std::optional<XStatVisitor> current_step_idle_time =\n+              step_visitor.GetStat(StatType::kStepIdleTimePs,\n+                                   step_idle_time_stat_metadata);\n+          current_step_idle_time.has_value()) {\n+        merged_step_idle_time += current_step_idle_time->IntOrUintValue();\n+      }\n       if (merged_device_timespan.has_value()) {\n         merged_device_timespan->ExpandToInclude(\n             GetDeviceEventTimespan(step_visitor));\n@@ -864,6 +1016,8 @@ void MergeHostSteps(const XStatMetadata& group_id_stat_metadata,\n             merged_device_timespan->duration_ps());\n       }\n       merged_step_builder->SetEndTimestampPs(step_visitor.EndTimestampPs());\n+      merged_step_builder->SetOrAddStatValue(step_idle_time_stat_metadata,\n+                                             merged_step_idle_time);\n       events_to_remove.insert(&step_event);\n     }\n   }\n@@ -902,89 +1056,40 @@ void GroupHostAndPlanes(\n   event_forest->GroupEvents();\n }\n \n-void GroupXplaneEvents(tensorflow::profiler::XPlane* plane,\n-                       const GroupMetadataMap& group_metadata_map) {\n-  // For each device_trace, the following happens:\n-  // (1) Find the module line and the step line.\n-  // (2) Assigns group_id to step events. group_id is read from the module\n-  //     events nested by the step events.\n-  // (3) Assigns group_id to other events nested by the grouped module events.\n-  XLine* module_line = nullptr;\n+// Groups the events in the device plane using the step line or module line as\n+// the grouping line depending on whether the loop is on the device or host.\n+void GroupTpuXPlaneEvents(tensorflow::profiler::XPlane* plane,\n+                          const GroupMetadataMap& group_metadata_map) {\n   XLine* step_line = nullptr;\n   std::vector<XLine*> other_lines;\n   for (XLine& line : *plane->mutable_lines()) {\n-    if (line.name() == \"XLA Modules\") {\n-      module_line = &line;\n-    } else if (line.name() == \"Steps\") {\n+    if (line.name() == kStepLineName ||\n+        line.name() == kSparseCoreStepLineName) {\n       step_line = &line;\n     } else {\n       other_lines.push_back(&line);\n     }\n   }\n-\n-  if (!module_line) return;\n-\n+  XLine* grouping_line = GetGroupingLineForTPU(plane);\n+  if (grouping_line == nullptr) {\n+    return;\n+  }\n   XPlaneBuilder plane_builder(plane);\n   const XStatMetadata* group_id_stat_metadata =\n       plane_builder.GetOrCreateStatMetadata(GetStatTypeStr(StatType::kGroupId));\n   // NOTE: Create plane_visitor after adding new stat metadata to\n   // plane_builder, so plane_visitor picks up the changes.\n   XPlaneVisitor plane_visitor = CreateTfXPlaneVisitor(plane);\n-  const XLine* group_line = module_line;\n-  if (step_line) {\n-    bool device_loop = (step_line->events_size() > module_line->events_size());\n-    if (device_loop) {\n-      int32_t group_id = 0;\n-      for (XEvent& event : *step_line->mutable_events()) {\n-        XEventBuilder step_builder(step_line, &plane_builder, &event);\n-        XEventVisitor step_visitor(&plane_visitor, step_line, &event);\n-        if (!step_visitor.GetStat(StatType::kGroupId).has_value()) {\n-          step_builder.AddStatValue(*group_id_stat_metadata, group_id++);\n-        }\n-      }\n-      group_line = step_line;\n-    } else {  // host loop\n-      if (group_line) {\n-        // Determine whether the module line has been grouped.\n-        bool is_grouped = false;\n-        for (XEvent& event : *module_line->mutable_events()) {\n-          XEventVisitor module_visitor(&plane_visitor, module_line, &event);\n-          if (module_visitor.GetStat(StatType::kGroupId).has_value()) {\n-            is_grouped = true;\n-            break;\n-          }\n-        }\n-        if (!is_grouped) {\n-          // If the module line has not been grouped, then:\n-          // (1) Assign group_id to each step event.\n-          int32_t group_id = 0;\n-          for (XEvent& event : *step_line->mutable_events()) {\n-            XEventBuilder step_builder(step_line, &plane_builder, &event);\n-            XEventVisitor step_visitor(&plane_visitor, step_line, &event);\n-            if (!step_visitor.GetStat(StatType::kGroupId).has_value()) {\n-              step_builder.AddStatValue(*group_id_stat_metadata, group_id++);\n-            }\n-          }\n-          // (2) Group the module events nested by the step events.\n-          GroupLine(*group_id_stat_metadata, plane_visitor, *step_line,\n-                    &plane_builder, module_line);\n-        }\n-        // Host loop steps take the group_id from their module.\n-        GroupLine(*group_id_stat_metadata, plane_visitor, *group_line,\n-                  &plane_builder, step_line);\n-        // Merge consecutive steps with the same group_id.\n-        MergeHostSteps(*group_id_stat_metadata, plane_visitor, &plane_builder,\n-                       step_line);\n-        XLineBuilder step_line_builder(step_line, &plane_builder);\n-        AddGroupMetadataToStepEvents(group_metadata_map, step_line_builder);\n-      }\n-    }\n+  if (step_line != nullptr) {\n+    // Merge consecutive steps with the same group_id.\n+    MergeHostSteps(*group_id_stat_metadata, plane_visitor, &plane_builder,\n+                   step_line);\n+    XLineBuilder step_line_builder(step_line, &plane_builder);\n+    AddGroupMetadataToStepEvents(group_metadata_map, step_line_builder);\n   }\n-  if (group_line) {\n-    for (XLine* line : other_lines) {\n-      GroupLine(*group_id_stat_metadata, plane_visitor, *group_line,\n-                &plane_builder, line);\n-    }\n+  for (XLine* line : other_lines) {\n+    GroupLine(*group_id_stat_metadata, plane_visitor, *grouping_line,\n+              &plane_builder, line);\n   }\n }\n \n@@ -1008,7 +1113,7 @@ void GroupTpuEventsOSS(\n   for (XPlane* plane : device_traces) {\n     threads.emplace_back(Env::Default()->StartThread(\n         thread_options, \"group_xplane_events\",\n-        absl::bind_front(GroupXplaneEvents, plane,\n+        absl::bind_front(GroupTpuXPlaneEvents, plane,\n                          std::ref(group_metadata_map))));\n   }\n }"
        },
        {
            "sha": "51c3cf4c3c94c015267007119f30ac39b21fe91f",
            "filename": "third_party/xla/xla/tsl/profiler/utils/group_events.h",
            "status": "modified",
            "additions": 19,
            "deletions": 4,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events.h?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #ifndef XLA_TSL_PROFILER_UTILS_GROUP_EVENTS_H_\n #define XLA_TSL_PROFILER_UTILS_GROUP_EVENTS_H_\n \n+#include <cstdint>\n #include <deque>\n #include <functional>\n #include <memory>\n@@ -101,7 +102,12 @@ class EventNode {\n \n   void SetRootLevel(int root_level) { root_level_ = root_level; }\n \n-  int RootLevel() const { return root_level_; }\n+  // Returns the root level of this event.\n+  // NOTE: return 0 if this event is not a root event to maintain the legacy\n+  // behavior.\n+  int RootLevel() const { return root_level_.value_or(0); }\n+\n+  bool IsRoot() const { return root_level_.has_value(); }\n \n   bool IsCompiledFunc() const;\n \n@@ -121,7 +127,7 @@ class EventNode {\n   // Root event level.\n   // By default root_level_ is set to 0, which means it is not a root event.\n   // Events with root_level_ greater than 0 are considered as root events.\n-  int root_level_ = 0;\n+  std::optional<int> root_level_;\n };\n \n using EventNodeMap =\n@@ -173,6 +179,9 @@ class EventForest {\n       std::function<XPlaneVisitor(const tensorflow::profiler::XPlane*)>\n           visitor_factory,\n       tensorflow::profiler::XPlane* plane);\n+  void ConnectIntraThreadTPU(tensorflow::profiler::XPlane* plane,\n+                             XPlaneVisitor* visitor,\n+                             ContextGroupMap* context_groups);\n \n   // Creates an EventNode for each event in event_node_map and connect events\n   // according to the nesting relationship within the thread.\n@@ -216,12 +225,16 @@ class EventForest {\n \n   EventNodeMap event_node_map_;\n   std::vector<XPlaneVisitor> visitors_;\n+  absl::flat_hash_set<XPlane*> registered_planes_;\n   // std::deque for pointer stability.\n   std::deque<std::pair<tensorflow::profiler::XPlane*, XPlaneVisitor>> planes_;\n   // The \"step\" id (actually it is \"function\" id that are associated with\n   // the tf.data pipeline.\n   absl::flat_hash_set<int64_t> tf_data_step_ids_;\n   EventList tf_loop_root_events_;\n+  // The root events for TPUs per core.\n+  std::vector<std::vector<EventNode*>> tensor_core_root_events_per_core_;\n+  std::vector<std::vector<EventNode*>> sparse_core_root_events_per_core_;\n   GroupMetadataMap group_metadata_map_;\n };\n \n@@ -246,8 +259,10 @@ void GroupHostAndPlanes(\n     const std::vector<tensorflow::profiler::XPlane*>& device_traces,\n     EventForest* event_forest);\n \n-void GroupXplaneEvents(tensorflow::profiler::XPlane* plane,\n-                       const GroupMetadataMap& group_metadata_map);\n+// Groups the events in the provided TPU plane by the step line or module line\n+// depending on whether the loop is on the device or host.\n+void GroupTpuXPlaneEvents(tensorflow::profiler::XPlane* plane,\n+                          const GroupMetadataMap& group_metadata_map);\n \n void GroupTpuEventsOSS(\n     tensorflow::profiler::XSpace* space,"
        },
        {
            "sha": "04e2e33f178bbae7750841a3aeb548fbffc56910",
            "filename": "third_party/xla/xla/tsl/profiler/utils/group_events_test.cc",
            "status": "modified",
            "additions": 514,
            "deletions": 12,
            "changes": 526,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fgroup_events_test.cc?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -19,18 +19,21 @@ limitations under the License.\n #include <optional>\n \n #include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/flat_hash_set.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/types.h\"\n #include \"xla/tsl/profiler/utils/preprocess_xplane.h\"\n #include \"xla/tsl/profiler/utils/tf_xplane_visitor.h\"\n #include \"xla/tsl/profiler/utils/timespan.h\"\n+#include \"xla/tsl/profiler/utils/trace_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_builder.h\"\n #include \"xla/tsl/profiler/utils/xplane_schema.h\"\n #include \"xla/tsl/profiler/utils/xplane_test_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_visitor.h\"\n+#include \"tsl/profiler/lib/context_types.h\"\n #include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n namespace tsl {\n@@ -734,19 +737,20 @@ TEST(GroupTPUEventsTest, TpuProgramCallbackTest) {\n \n TEST(GroupTPUEventsTest, ModuleRootEventTest) {\n   tensorflow::profiler::XSpace space;\n-  tensorflow::profiler::XPlane* device_plane = space.add_planes();\n+  tensorflow::profiler::XPlane* device_plane =\n+      GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0);\n   XPlaneBuilder device_plane_builder(device_plane);\n-  device_plane_builder.ReserveLines(1);\n+  device_plane_builder.ReserveLines(3);\n   auto step_line = device_plane_builder.GetOrCreateLine(0);\n   step_line.SetName(\"Steps\");\n   CreateXEvent(&device_plane_builder, &step_line, \"1\", 100, 200,\n                {{StatType::kStepNum, int64_t{1}}});\n   auto module_line = device_plane_builder.GetOrCreateLine(1);\n   module_line.SetName(\"XLA Modules\");\n-  CreateXEvent(&device_plane_builder, &module_line, \"module\", 105, 199,\n+  CreateXEvent(&device_plane_builder, &module_line, \"module\", 105, 194,\n                {{StatType::kRunId, int64_t{123}},\n                 {StatType::kQueueId, int64_t{0}},\n-                {StatType::kDeviceOrdinal, int64_t{1}}});\n+                {StatType::kDeviceOrdinal, int64_t{0}}});\n   auto hlo_line = device_plane_builder.GetOrCreateLine(2);\n   hlo_line.SetName(\"XLA Ops\");\n   CreateXEvent(&device_plane_builder, &hlo_line, \"matmul\", 110, 190, {});\n@@ -771,19 +775,23 @@ TEST(GroupTPUEventsTest, MergeHostStepsTest) {\n   CreateXEvent(\n       &host_plane_builder, &main_thread, \"train\", 100, 10,\n       {{StatType::kStepNum, int64_t{1}}, {StatType::kIsRoot, int64_t{1}}});\n-  CreateXEvent(&host_plane_builder, &main_thread, \"DoEnqueueProgram\", 100, 1,\n+  CreateXEvent(&host_plane_builder, &main_thread,\n+               HostEventType::kDoEnqueueProgram, 100, 1,\n                {{StatType::kRunId, int64_t{2}},\n                 {StatType::kQueueId, int64_t{0}},\n                 {StatType::kDeviceOrdinal, int64_t{0}}});\n-  CreateXEvent(&host_plane_builder, &main_thread, \"DoEnqueueProgram\", 101, 2,\n+  CreateXEvent(&host_plane_builder, &main_thread,\n+               HostEventType::kDoEnqueueProgram, 101, 2,\n                {{StatType::kRunId, int64_t{3}},\n                 {StatType::kQueueId, int64_t{0}},\n                 {StatType::kDeviceOrdinal, int64_t{0}}});\n-  CreateXEvent(&host_plane_builder, &main_thread, \"DoEnqueueProgram\", 103, 2,\n+  CreateXEvent(&host_plane_builder, &main_thread,\n+               HostEventType::kDoEnqueueProgram, 103, 2,\n                {{StatType::kRunId, int64_t{4}},\n                 {StatType::kQueueId, int64_t{0}},\n                 {StatType::kDeviceOrdinal, int64_t{0}}});\n-  CreateXEvent(&host_plane_builder, &main_thread, \"DoEnqueueProgram\", 105, 4,\n+  CreateXEvent(&host_plane_builder, &main_thread,\n+               HostEventType::kDoEnqueueProgram, 105, 4,\n                {{StatType::kRunId, int64_t{5}},\n                 {StatType::kQueueId, int64_t{0}},\n                 {StatType::kDeviceOrdinal, int64_t{0}}});\n@@ -796,13 +804,13 @@ TEST(GroupTPUEventsTest, MergeHostStepsTest) {\n       &device_plane_builder, &module_line, \"jit_something(1)\", 1000, 10,\n       {{StatType::kRunId, int64_t{2}}, {StatType::kQueueId, int64_t{0}}});\n   CreateXEvent(\n-      &device_plane_builder, &module_line, \"jit_something(2)\", 1015, 100,\n+      &device_plane_builder, &module_line, \"jit_something(1)\", 1015, 100,\n       {{StatType::kRunId, int64_t{3}}, {StatType::kQueueId, int64_t{0}}});\n   CreateXEvent(\n-      &device_plane_builder, &module_line, \"jit_something(3)\", 1125, 50,\n+      &device_plane_builder, &module_line, \"jit_something(1)\", 1125, 50,\n       {{StatType::kRunId, int64_t{4}}, {StatType::kQueueId, int64_t{0}}});\n   CreateXEvent(\n-      &device_plane_builder, &module_line, \"jit_something(4)\", 1180, 25,\n+      &device_plane_builder, &module_line, \"jit_something(1)\", 1180, 25,\n       {{StatType::kRunId, int64_t{5}}, {StatType::kQueueId, int64_t{0}}});\n   auto step_line = device_plane_builder.GetOrCreateLine(1);\n   step_line.SetName(kStepLineName);\n@@ -818,11 +826,97 @@ TEST(GroupTPUEventsTest, MergeHostStepsTest) {\n   CreateXEvent(&device_plane_builder, &step_line, \"3\", 1180, 25,\n                {{StatType::kDeviceOffsetPs, int64_t{1180}},\n                 {StatType::kDeviceDurationPs, int64_t{25}}});\n+  auto op_line = device_plane_builder.GetOrCreateLine(2);\n+  op_line.SetName(kXlaOpLineName);\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.start.1\", 1000, 5,\n+               {{StatType::kTcOffloadStartId, int64_t{1}},\n+                {StatType::kOffloadCoreId, int64_t{0}},\n+                {StatType::kOffloadExecutionIndex, int64_t{0}},\n+                {StatType::kProducerId, int64_t{1}},\n+                {StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kScOffload)}});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.done.1\", 1005, 5, {});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.start.1\", 1015, 5,\n+               {{StatType::kTcOffloadStartId, int64_t{1}},\n+                {StatType::kOffloadCoreId, int64_t{0}},\n+                {StatType::kOffloadExecutionIndex, int64_t{1}},\n+                {StatType::kProducerId, int64_t{2}},\n+                {StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kScOffload)}});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.done.1\", 1020, 95, {});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.start.1\", 1125, 5,\n+               {{StatType::kTcOffloadStartId, int64_t{1}},\n+                {StatType::kOffloadCoreId, int64_t{0}},\n+                {StatType::kOffloadExecutionIndex, int64_t{2}},\n+                {StatType::kProducerId, int64_t{3}},\n+                {StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kScOffload)}});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.done.1\", 1130, 45, {});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.start.1\", 1180, 5,\n+               {{StatType::kTcOffloadStartId, int64_t{1}},\n+                {StatType::kOffloadCoreId, int64_t{0}},\n+                {StatType::kOffloadExecutionIndex, int64_t{3}},\n+                {StatType::kProducerId, int64_t{4}},\n+                {StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kScOffload)}});\n+  CreateXEvent(&device_plane_builder, &op_line, \"offload.done.1\", 1185, 20, {});\n+\n+  // TPU SparseCore Plane (device_id 0, core_type 1)\n+  XPlane* sparsecore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0, 0);\n+  XPlaneBuilder sc_plane_builder(sparsecore_plane);\n+  sc_plane_builder.ReserveLines(3);\n+\n+  auto sc_module_line = sc_plane_builder.GetOrCreateLine(0);\n+  sc_module_line.SetName(kSparseCoreModuleLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(1)\", 1001, 8,\n+               {\n+                   {StatType::kTcOffloadStartId, int64_t{1}},\n+               });\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(1)\", 1016, 98,\n+               {\n+                   {StatType::kTcOffloadStartId, int64_t{1}},\n+               });\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(1)\", 1126, 48,\n+               {\n+                   {StatType::kTcOffloadStartId, int64_t{1}},\n+               });\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(1)\", 1181, 23,\n+               {\n+                   {StatType::kTcOffloadStartId, int64_t{1}},\n+               });\n+\n+  auto sc_step_line = sc_plane_builder.GetOrCreateLine(1);\n+  sc_step_line.SetName(kSparseCoreStepLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 0\", 1000, 10, {});\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 1\", 1015, 100, {});\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 2\", 1125, 50, {});\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 3\", 1180, 25, {});\n+\n+  auto sc_op_line = sc_plane_builder.GetOrCreateLine(2);\n+  sc_op_line.SetName(kSparseCoreOpLineName);\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"sc_op_1\", 1001, 8,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{1}}});\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"sc_op_1\", 1016, 98,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{2}}});\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"sc_op_1\", 1126, 48,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{3}}});\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"sc_op_1\", 1181, 23,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{4}}});\n+\n   // Make sure to preprocess so that the Runtime events have a Producer/Consumer\n   // event set created.\n   PreprocessXSpace(&space);\n   EventForest event_forest;\n-  GroupTpuEventsOSS(&space, {device_plane}, &event_forest);\n+  GroupTpuEventsOSS(&space, {device_plane, sparsecore_plane}, &event_forest);\n+  EXPECT_EQ(event_forest.GetGroupMetadataMap().size(), 1);\n   auto visitor = CreateTfXPlaneVisitor(device_plane);\n   bool step_line_found = false;\n   visitor.ForEachLine([&](const XLineVisitor& line) {\n@@ -838,6 +932,414 @@ TEST(GroupTPUEventsTest, MergeHostStepsTest) {\n     EXPECT_EQ(GetDeviceEventTimespan(step_event).end_ps(), 1205);\n   });\n   EXPECT_TRUE(step_line_found);\n+\n+  auto sc_visitor = CreateTfXPlaneVisitor(sparsecore_plane);\n+  bool sc_step_line_found = false;\n+  sc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    if (line.Name() != kSparseCoreStepLineName) {\n+      return;\n+    }\n+    sc_step_line_found = true;\n+    EXPECT_EQ(line.NumEvents(), 1);\n+    auto step_event = line.GetFirstEvent();\n+    EXPECT_EQ(step_event.GetTimespan().begin_ps(), 1000);\n+    EXPECT_EQ(step_event.GetTimespan().end_ps(), 1205);\n+    EXPECT_EQ(GetDeviceEventTimespan(step_event).begin_ps(), 1000);\n+    EXPECT_EQ(GetDeviceEventTimespan(step_event).end_ps(), 1205);\n+  });\n+  EXPECT_TRUE(sc_step_line_found);\n+}\n+\n+TEST(GroupTPUEventsTest, MergeOffloadedScSteps) {\n+  tensorflow::profiler::XSpace space;\n+  // No host plane in this test.\n+\n+  // TPU TensorCore Plane (device_id 0)\n+  XPlane* tensorcore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0);\n+  XPlaneBuilder tc_plane_builder(tensorcore_plane);\n+  tc_plane_builder.ReserveLines(3);\n+\n+  auto tc_module_line = tc_plane_builder.GetOrCreateLine(0);\n+  tc_module_line.SetName(kXlaModuleLineName);\n+  // The module event is strictly within the step event (1000-2000).\n+  CreateXEvent(&tc_plane_builder, &tc_module_line, \"jit_tc_module\", 1010, 980,\n+               {{StatType::kRunId, int64_t{1}}});\n+\n+  auto tc_step_line = tc_plane_builder.GetOrCreateLine(1);\n+  tc_step_line.SetName(kStepLineName);\n+  CreateXEvent(&tc_plane_builder, &tc_step_line, \"tc step 0\", 1000, 1000,\n+               {{StatType::kDeviceOffsetPs, int64_t{1000}},\n+                {StatType::kDeviceDurationPs, int64_t{1000}}});\n+\n+  auto tc_op_line = tc_plane_builder.GetOrCreateLine(2);\n+  tc_op_line.SetName(kXlaOpLineName);\n+  // First offload\n+  CreateXEvent(&tc_plane_builder, &tc_op_line, \"offload.start.1\", 1050, 50,\n+               {{StatType::kTcOffloadStartId, int64_t{1}},\n+                {StatType::kOffloadCoreId, int64_t{0}},\n+                {StatType::kOffloadExecutionIndex, int64_t{0}},\n+                {StatType::kProducerId, int64_t{1}},\n+                {StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kScOffload)}});\n+  CreateXEvent(&tc_plane_builder, &tc_op_line, \"offload.done.1\", 1100, 400, {});\n+  // Second offload\n+  CreateXEvent(&tc_plane_builder, &tc_op_line, \"offload.start.1\", 1550, 50,\n+               {{StatType::kTcOffloadStartId, int64_t{1}},\n+                {StatType::kOffloadCoreId, int64_t{0}},\n+                {StatType::kOffloadExecutionIndex, int64_t{1}},\n+                {StatType::kProducerId, int64_t{2}},\n+                {StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kScOffload)}});\n+  CreateXEvent(&tc_plane_builder, &tc_op_line, \"offload.done.1\", 1600, 400, {});\n+\n+  // TPU SparseCore Plane (device_id 0, core_type 1)\n+  XPlane* sparsecore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0, 1);\n+  XPlaneBuilder sc_plane_builder(sparsecore_plane);\n+  sc_plane_builder.ReserveLines(3);\n+\n+  auto sc_module_line = sc_plane_builder.GetOrCreateLine(0);\n+  sc_module_line.SetName(kSparseCoreModuleLineName);\n+  // These module events are strictly within their respective step events.\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(1)\", 1101, 398,\n+               {{StatType::kTcOffloadStartId, int64_t{1}}});\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(1)\", 1601, 398,\n+               {{StatType::kTcOffloadStartId, int64_t{1}}});\n+\n+  auto sc_step_line = sc_plane_builder.GetOrCreateLine(1);\n+  sc_step_line.SetName(kSparseCoreStepLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 0\", 1100, 400, {});\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 1\", 1600, 400, {});\n+\n+  auto sc_op_line = sc_plane_builder.GetOrCreateLine(2);\n+  sc_op_line.SetName(kSparseCoreOpLineName);\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"sc_op_1a\", 1110, 100,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{1}}});\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"sc_op_2a\", 1610, 100,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{2}}});\n+\n+  // Make sure to preprocess so that the Runtime events have a Producer/Consumer\n+  // event set created.\n+  PreprocessXSpace(&space);\n+  EventForest event_forest;\n+  GroupTpuEventsOSS(&space, {tensorcore_plane, sparsecore_plane},\n+                    &event_forest);\n+\n+  // We expect only one group as all events are linked.\n+  const GroupMetadataMap& group_metadata_map =\n+      event_forest.GetGroupMetadataMap();\n+  EXPECT_EQ(group_metadata_map.size(), 1);\n+  const int64_t expected_group_id = group_metadata_map.begin()->first;\n+\n+  // Check the merged TensorCore step event.\n+  auto tc_visitor = CreateTfXPlaneVisitor(tensorcore_plane);\n+  tc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(absl::StrCat(tensorcore_plane->name(), \": \", line.Name(),\n+                                \" \", event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      EXPECT_EQ(group_id_stat->IntOrUintValue(), expected_group_id);\n+    });\n+  });\n+\n+  // Check the merged SparseCore step event.\n+  auto sc_visitor = CreateTfXPlaneVisitor(sparsecore_plane);\n+  sc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(absl::StrCat(sparsecore_plane->name(), \": \", line.Name(),\n+                                \" \", event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      EXPECT_EQ(group_id_stat->IntOrUintValue(), expected_group_id);\n+    });\n+    if (line.Name() == kSparseCoreStepLineName) {\n+      EXPECT_EQ(line.NumEvents(), 1);\n+      auto step_event = line.GetFirstEvent();\n+      EXPECT_EQ(step_event.GetTimespan().begin_ps(), 1100);\n+      EXPECT_EQ(step_event.GetTimespan().end_ps(), 2000);\n+    }\n+  });\n+}\n+\n+TEST(GroupTPUEventsTest, GroupOffloadedSparseCoreModulesHostLoopTest) {\n+  tensorflow::profiler::XSpace space;\n+  tensorflow::profiler::XPlane* host_plane = GetOrCreateHostXPlane(&space);\n+  XPlaneBuilder host_plane_builder(host_plane);\n+  host_plane_builder.ReserveLines(1);\n+  auto main_thread = host_plane_builder.GetOrCreateLine(0);\n+  main_thread.SetName(\"main\");\n+\n+  CreateXEvent(&host_plane_builder, &main_thread, \"host step 0\", 0, 200,\n+               {{StatType::kIsRoot, int64_t{1}}});\n+  // Host event for TensorCore.\n+  CreateXEvent(&host_plane_builder, &main_thread, \"DoEnqueueProgram\", 100, 10,\n+               {{StatType::kRunId, int64_t{1}},\n+                {StatType::kQueueId, int64_t{0}},\n+                {StatType::kReplicaId, int64_t{0}},\n+                {StatType::kDeviceOrdinal, int64_t{0}},\n+                {StatType::kCoreType, int64_t{0}}});  // kTpuTensorCore\n+\n+  // TPU TensorCore Plane (device_id 0)\n+  XPlane* tensorcore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0);\n+  XPlaneBuilder tc_plane_builder(tensorcore_plane);\n+  tc_plane_builder.ReserveLines(3);\n+\n+  auto tc_module_line = tc_plane_builder.GetOrCreateLine(0);\n+  tc_module_line.SetName(kXlaModuleLineName);\n+  CreateXEvent(&tc_plane_builder, &tc_module_line, \"jit(123)\", 1000, 1000,\n+               {{StatType::kRunId, int64_t{1}},\n+                {StatType::kQueueId, int64_t{0}},\n+                {StatType::kReplicaId, int64_t{0}},\n+                {StatType::kCoreType, int64_t{0}}});\n+\n+  auto tc_step_line = tc_plane_builder.GetOrCreateLine(1);\n+  tc_step_line.SetName(kStepLineName);\n+  CreateXEvent(&tc_plane_builder, &tc_step_line, \"tc step 0\", 1000, 1000, {});\n+\n+  auto tc_op_line = tc_plane_builder.GetOrCreateLine(2);\n+  tc_op_line.SetName(kXlaOpLineName);\n+  CreateXEvent(\n+      &tc_plane_builder, &tc_op_line, \"offload_start\", 1050, 100,\n+      {{StatType::kTcOffloadStartId, int64_t{123}},\n+       {StatType::kOffloadCoreId, int64_t{0}},\n+       {StatType::kOffloadExecutionIndex, int64_t{0}},\n+       {StatType::kProducerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kProducerId, int64_t{1}}});\n+  CreateXEvent(&tc_plane_builder, &tc_op_line, \"offload_done\", 1200, 750, {});\n+\n+  // TPU SparseCore Plane (device_id 1)\n+  XPlane* sparsecore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0, 0);\n+  XPlaneBuilder sc_plane_builder(sparsecore_plane);\n+  sc_plane_builder.ReserveLines(3);\n+\n+  auto sc_module_line = sc_plane_builder.GetOrCreateLine(0);\n+  sc_module_line.SetName(kSparseCoreModuleLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(123)\", 1100, 800,\n+               {{StatType::kTcOffloadStartId, int64_t{123}}});\n+\n+  auto sc_step_line = sc_plane_builder.GetOrCreateLine(1);\n+  sc_step_line.SetName(kSparseCoreStepLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 0\", 1100, 800, {});\n+\n+  auto sc_op_line = sc_plane_builder.GetOrCreateLine(2);\n+  sc_op_line.SetName(kSparseCoreOpLineName);\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"offloaded_start.copy\", 1100, 10,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{1}}});\n+  CreateXEvent(&sc_plane_builder, &sc_op_line, \"offloaded_done.copy\", 1120, 180,\n+               {});\n+\n+  // Preprocess to create Producer/Consumer events.\n+  PreprocessXSpace(&space);\n+  EventForest event_forest;\n+  GroupTpuEventsOSS(&space, {tensorcore_plane, sparsecore_plane},\n+                    &event_forest);\n+\n+  // We expect one group, where all events are grouped under the same group.\n+  EXPECT_EQ(event_forest.GetGroupMetadataMap().size(), 1);\n+  const int64_t expected_group_id =\n+      event_forest.GetGroupMetadataMap().begin()->first;\n+\n+  // Check Host events.\n+  XPlaneVisitor host_visitor = CreateTfXPlaneVisitor(host_plane);\n+  int host_event_idx = 0;\n+  host_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(absl::StrCat(host_plane->name(), \": \", line.Name(), \" \",\n+                                event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      EXPECT_EQ(group_id_stat->IntValue(), expected_group_id);\n+      host_event_idx++;\n+    });\n+  });\n+  EXPECT_EQ(host_event_idx, 2);\n+\n+  // Check TensorCore events.\n+  XPlaneVisitor tc_visitor = CreateTfXPlaneVisitor(tensorcore_plane);\n+  tc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(absl::StrCat(tensorcore_plane->name(), \": \",\n+\n+                                line.Name(), \" \", event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      // TensorCore events are associated with run_id 1, likely getting group_id\n+      // 0.\n+      EXPECT_EQ(group_id_stat->IntValue(), expected_group_id);\n+    });\n+  });\n+\n+  // Check SparseCore events.\n+  XPlaneVisitor sc_visitor = CreateTfXPlaneVisitor(sparsecore_plane);\n+  sc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(\n+          absl::StrCat(sparsecore_plane->name(), \": \",\n+                       ParseDeviceOrdinal(sparsecore_plane->name()).value(),\n+                       \" \", line.Name(), \" \", event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      // SparseCore events are associated with run_id 2, likely getting\n+      // group_id 1.\n+      EXPECT_EQ(group_id_stat->IntValue(), expected_group_id);\n+    });\n+  });\n+}\n+\n+TEST(GroupTPUEventsTest, GroupOffloadedSparseCoreModulesDeviceLoopTest) {\n+  tensorflow::profiler::XSpace space;\n+  tensorflow::profiler::XPlane* host_plane = GetOrCreateHostXPlane(&space);\n+  XPlaneBuilder host_plane_builder(host_plane);\n+  host_plane_builder.ReserveLines(2);\n+  auto main_thread = host_plane_builder.GetOrCreateLine(0);\n+  main_thread.SetName(\"main\");\n+\n+  // Tf Loop event\n+  CreateXEvent(\n+      &host_plane_builder, &main_thread, HostEventType::kExecutorStateProcess,\n+      100, 10,\n+      {{StatType::kStepId, int64_t{1}}, {StatType::kIterNum, int64_t{99}}});\n+  CreateXEvent(&host_plane_builder, &main_thread,\n+               HostEventType::kTpuSystemExecute, 100, 9,\n+               {{StatType::kProducerType,\n+                 static_cast<int64_t>(ContextType::kTfrtTpuRuntime)},\n+                {StatType::kProducerId, int64_t{1}}});\n+\n+  auto enqueue_thread = host_plane_builder.GetOrCreateLine(1);\n+  enqueue_thread.SetName(\"tf_enqueue\");\n+  CreateXEvent(&host_plane_builder, &enqueue_thread,\n+               \"tpu::System::Execute=>IssueSequencedEvent\", 102, 10,\n+               {{StatType::kConsumerType,\n+                 static_cast<int64_t>(ContextType::kTfrtTpuRuntime)},\n+                {StatType::kConsumerId, int64_t{1}}});\n+  CreateXEvent(&host_plane_builder, &enqueue_thread,\n+               HostEventType::kDoEnqueueProgram, 103, 8,\n+               {{StatType::kRunId, int64_t{1}},\n+                {StatType::kQueueId, int64_t{0}},\n+                {StatType::kCoreType, int64_t{0}},\n+                {StatType::kDeviceOrdinal, int64_t{0}}});\n+\n+  // TPU TensorCore Plane (device_id 0)\n+  XPlane* tensorcore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0);\n+  XPlaneBuilder tc_plane_builder(tensorcore_plane);\n+  tc_plane_builder.ReserveLines(3);\n+\n+  auto tc_module_line = tc_plane_builder.GetOrCreateLine(0);\n+  tc_module_line.SetName(kXlaModuleLineName);\n+  // The module event encompasses the step event's time range (1000-2000).\n+  CreateXEvent(&tc_plane_builder, &tc_module_line, \"jit(123)\", 900, 1200,\n+               {{StatType::kRunId, int64_t{1}},\n+                {StatType::kQueueId, int64_t{0}},\n+                {StatType::kReplicaId, int64_t{0}},\n+                {StatType::kCoreType, int64_t{0}}});\n+\n+  auto tc_step_line = tc_plane_builder.GetOrCreateLine(1);\n+  tc_step_line.SetName(kStepLineName);\n+  CreateXEvent(&tc_plane_builder, &tc_step_line, \"tc step 0\", 1000, 1000, {});\n+\n+  auto tc_op_line = tc_plane_builder.GetOrCreateLine(2);\n+  tc_op_line.SetName(kXlaOpLineName);\n+  CreateXEvent(\n+      &tc_plane_builder, &tc_op_line, \"offload_start\", 1050, 100,\n+      {{StatType::kTcOffloadStartId, int64_t{123}},\n+       {StatType::kOffloadCoreId, int64_t{0}},\n+       {StatType::kOffloadExecutionIndex, int64_t{0}},\n+       {StatType::kProducerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kProducerId, int64_t{1}}});\n+  CreateXEvent(&tc_plane_builder, &tc_op_line, \"offload_done\", 1200, 750, {});\n+\n+  // TPU SparseCore Plane (device_id 1)\n+  XPlane* sparsecore_plane = GetOrCreateTpuXPlane(&space, 0, \"TPUv4\", 0, 0, 0);\n+  XPlaneBuilder sc_plane_builder(sparsecore_plane);\n+  sc_plane_builder.ReserveLines(3);\n+\n+  auto sc_module_line = sc_plane_builder.GetOrCreateLine(0);\n+  sc_module_line.SetName(kSparseCoreModuleLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_module_line, \"offloaded(123)\", 1100, 800,\n+               {{StatType::kTcOffloadStartId, int64_t{123}}});\n+\n+  auto sc_step_line = sc_plane_builder.GetOrCreateLine(1);\n+  sc_step_line.SetName(kSparseCoreStepLineName);\n+  CreateXEvent(&sc_plane_builder, &sc_step_line, \"sc step 0\", 1100, 800, {});\n+\n+  auto sc_op_line = sc_plane_builder.GetOrCreateLine(2);\n+  sc_op_line.SetName(kSparseCoreOpLineName);\n+  CreateXEvent(\n+      &sc_plane_builder, &sc_op_line, \"offloaded_start.copy\", 1100, 100,\n+      {{StatType::kConsumerType, static_cast<int64_t>(ContextType::kScOffload)},\n+       {StatType::kConsumerId, int64_t{1}}});\n+  CreateXEvent(&sc_plane_builder, &sc_op_line, \"offloaded_done.copy\", 1300, 100,\n+               {});\n+\n+  // Preprocess to create Producer/Consumer events.\n+  PreprocessXSpace(&space);\n+  EventForest event_forest;\n+  GroupTpuEventsOSS(&space, {tensorcore_plane, sparsecore_plane},\n+                    &event_forest);\n+\n+  // We expect two groups, one for the host events and one for the device\n+  // events.\n+  EXPECT_EQ(event_forest.GetGroupMetadataMap().size(), 2);\n+\n+  // Check Host events.\n+  XPlaneVisitor host_visitor = CreateTfXPlaneVisitor(host_plane);\n+  int host_event_idx = 0;\n+  host_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(absl::StrCat(host_plane->name(), \": \", line.Name(), \" \",\n+                                event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      EXPECT_EQ(group_id_stat->IntValue(), 0);\n+      host_event_idx++;\n+    });\n+  });\n+  EXPECT_EQ(host_event_idx, 4);\n+\n+  // Check TensorCore events.\n+  XPlaneVisitor tc_visitor = CreateTfXPlaneVisitor(tensorcore_plane);\n+  tc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      if (line.Name() == kXlaModuleLineName) {\n+        // The module event encompasses multiple steps, so it cannot be grouped.\n+        return;\n+      }\n+      SCOPED_TRACE(absl::StrCat(tensorcore_plane->name(), \": \",\n+\n+                                line.Name(), \" \", event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      EXPECT_EQ(group_id_stat->IntValue(), 1);\n+    });\n+  });\n+\n+  // Check SparseCore events.\n+  XPlaneVisitor sc_visitor = CreateTfXPlaneVisitor(sparsecore_plane);\n+  sc_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      SCOPED_TRACE(\n+          absl::StrCat(sparsecore_plane->name(), \": \",\n+                       ParseDeviceOrdinal(sparsecore_plane->name()).value(),\n+                       \" \", line.Name(), \" \", event.Name()));\n+      std::optional<XStatVisitor> group_id_stat =\n+          event.GetStat(StatType::kGroupId);\n+      ASSERT_TRUE(group_id_stat.has_value());\n+      EXPECT_EQ(group_id_stat->IntValue(), 1);\n+    });\n+  });\n }\n \n }  // namespace"
        },
        {
            "sha": "f95fc81f1769ede1e11742e96047942e762a9593",
            "filename": "third_party/xla/xla/tsl/profiler/utils/xplane_test_utils.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_test_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_test_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_test_utils.cc?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -16,11 +16,13 @@ limitations under the License.\n \n #include <cstdint>\n #include <initializer_list>\n+#include <optional>\n #include <string>\n #include <utility>\n #include <variant>\n \n #include \"absl/container/flat_hash_map.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/platform/types.h\"\n #include \"xla/tsl/profiler/utils/xplane_builder.h\"\n@@ -58,8 +60,13 @@ XPlane* GetOrCreateHostXPlane(XSpace* space) {\n XPlane* GetOrCreateTpuXPlane(XSpace* space, int32_t device_ordinal,\n                              absl::string_view device_type,\n                              double peak_tera_flops_per_second,\n-                             double peak_hbm_bw_gigabytes_per_second) {\n+                             double peak_hbm_bw_gigabytes_per_second,\n+                             std::optional<int32_t> sparsecore_core_id) {\n   std::string name = TpuPlaneName(device_ordinal);\n+  if (sparsecore_core_id.has_value()) {\n+    name = std::string(\n+        absl::StrCat(name, \" SparseCore \", sparsecore_core_id.value()));\n+  }\n   XPlane* xplane = FindOrAddMutablePlaneWithName(space, name);\n   XPlaneBuilder builder(xplane);\n   builder.AddStatValue(*builder.GetOrCreateStatMetadata("
        },
        {
            "sha": "7d2a38c2ec1e4f03adec7bccbb226cf7215b9e2d",
            "filename": "third_party/xla/xla/tsl/profiler/utils/xplane_test_utils.h",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_test_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_test_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_test_utils.h?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -15,7 +15,9 @@ limitations under the License.\n #ifndef XLA_TSL_PROFILER_UTILS_XPLANE_TEST_UTILS_H_\n #define XLA_TSL_PROFILER_UTILS_XPLANE_TEST_UTILS_H_\n \n+#include <cstdint>\n #include <initializer_list>\n+#include <optional>\n #include <utility>\n #include <variant>\n \n@@ -34,10 +36,10 @@ XPlane* GetOrCreateHostXPlane(XSpace* space);\n \n XPlane* GetOrCreateGpuXPlane(XSpace* space, int32_t device_ordinal);\n \n-XPlane* GetOrCreateTpuXPlane(XSpace* space, int32_t device_ordinal,\n-                             absl::string_view device_type,\n-                             double peak_tera_flops_per_second,\n-                             double peak_hbm_bw_gigabytes_per_second);\n+XPlane* GetOrCreateTpuXPlane(\n+    XSpace* space, int32_t device_ordinal, absl::string_view device_type,\n+    double peak_tera_flops_per_second, double peak_hbm_bw_gigabytes_per_second,\n+    std::optional<int32_t> sparsecore_core_id = std::nullopt);\n \n void CreateXEvent(\n     XPlaneBuilder* plane_builder, XLineBuilder* line_builder,"
        },
        {
            "sha": "f5f8b0fdfaf0adca9a0a22e782b7383f232d544a",
            "filename": "third_party/xla/xla/tsl/profiler/utils/xplane_visitor.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_visitor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f41ba94e4625718e339800da9527fac595b8e9d/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_visitor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_visitor.h?ref=2f41ba94e4625718e339800da9527fac595b8e9d",
            "patch": "@@ -169,6 +169,8 @@ class XEventVisitor : public XStatsOwner<XEvent> {\n \n   absl::string_view Name() const { return metadata_->name(); }\n \n+  absl::string_view LineName() const { return line_->name(); }\n+\n   std::optional<int64_t> Type() const { return type_; }\n \n   bool HasDisplayName() const { return !metadata_->display_name().empty(); }"
        }
    ],
    "stats": {
        "total": 943,
        "additions": 790,
        "deletions": 153
    }
}