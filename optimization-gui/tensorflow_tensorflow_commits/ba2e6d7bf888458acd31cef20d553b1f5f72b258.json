{
    "author": "junwhanahn",
    "message": "Move `Promise` out of `Future`\n\nIt is more natural to define promise and future as two separate types instead of one nested inside the other. The `Future<T>::Promise` alias is kept for existing users, but will be removed after migrating them.\n\nPiperOrigin-RevId: 850633060",
    "sha": "ba2e6d7bf888458acd31cef20d553b1f5f72b258",
    "files": [
        {
            "sha": "f6ead9d34d87a9ffe85008e4700145835d03bce3",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 162,
            "deletions": 141,
            "changes": 303,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ba2e6d7bf888458acd31cef20d553b1f5f72b258/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ba2e6d7bf888458acd31cef20d553b1f5f72b258/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=ba2e6d7bf888458acd31cef20d553b1f5f72b258",
            "patch": "@@ -59,6 +59,13 @@ namespace tsl {\n template <class T = void>\n class Future;\n \n+// Promise<T> provides a facility to store a value or an error that is later\n+// acquired asynchronously via a Future<T> constructed from the promise object.\n+// Note that the promise object is meant to be used only once (set value or\n+// error).\n+template <class T = void>\n+class Promise;\n+\n // Returns a `Future` that will be successful if all `futures` complete\n // successfully, or return a first encountered error.\n Future<> JoinFutures(absl::Span<const Future<>> futures);\n@@ -209,72 +216,6 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n  protected:\n   static constexpr bool IsMoveOnly() { return is_move_only; }\n \n-  // Future<T>::Promise provides a facility to store a value or an error\n-  // that is later acquired asynchronously via a Future<T> constructed from\n-  // the promise object. Note that the promise object is meant to be used only\n-  // once (set value or error).\n-  class Promise {\n-   public:\n-    Promise() = default;\n-\n-    Promise(Promise&& other) = default;\n-    Promise& operator=(Promise&& other) = default;\n-\n-    ~Promise() {\n-      if (promise_ && !IsUniqueReference() && promise_.IsUnavailable()) {\n-        // At this point, we know that the underlying AsyncValueRef will\n-        // otherwise not fulfilled ever because `Promise` is move-only.\n-        promise_.emplace(\n-            absl::InternalError(\"Promise destroyed without being set\"));\n-      }\n-    }\n-\n-    explicit operator bool() const { return static_cast<bool>(promise_); }\n-\n-    // Returns if this promise is the unique reference to the underlying value.\n-    // That is, this method returns true only if all of the following conditions\n-    // are satisfied:\n-    //\n-    // - The promise is the only reference to the underlying value, i.e., there\n-    //   are no other promises or futures associated with this value.\n-    // - There are no OnReady callbacks registered to this promise.\n-    //\n-    // This may be used by the caller of `Set()` to short-circuit the work to\n-    // fulfill the promise if no one will ever consume the value. Even in that\n-    // case, consider fulfilling the promise with an error (e.g., `CANCELLED`)\n-    // instead of dropping the promise without fulfilling it in order to make\n-    // debugging easier. Also, be aware that the current promise may still be\n-    // used to mint a future.\n-    //\n-    // We use this API only when we are exclusive owner of the promise and can\n-    // guarantee that it didn't escape to other threads via pointers. Otherwise,\n-    // this is best effort check, because it uses two atomic operations and is\n-    // not atomic itself.\n-    bool IsUniqueReference() const {\n-      CHECK(promise_ && !promise_.GetAsyncValue()->IsIndirect())\n-          << \"Promise must wrap a concrete async value\";\n-      return promise_.GetAsyncValue()->NumRef() == 1 && !promise_.HasWaiter();\n-    }\n-\n-   protected:\n-    explicit Promise(tsl::AsyncValueRef<T> promise)\n-        : promise_(std::move(promise)) {}\n-\n-    template <typename... Args>\n-    void emplace(Args&&... args) const {\n-      CHECK(promise_) << \"Promise must wrap an async value\";\n-      CHECK(promise_.IsUnavailable())\n-          << \"Promise must not be fulfilled more than once\";\n-      promise_.template emplace<Args...>(std::forward<Args>(args)...);\n-    }\n-\n-    // Takes a reference to the underlying AsyncValueRef container.\n-    tsl::AsyncValueRef<T> ref() const { return promise_; }\n-\n-   private:\n-    tsl::AsyncValueRef<T> promise_;\n-  };\n-\n   class ProfilingCleanup {\n    public:\n     ProfilingCleanup(const FutureBase* parent,\n@@ -420,7 +361,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   AsyncValuePtr<T> promise() const { return promise_.AsPtr(); }\n \n  private:\n-  friend class tsl::FutureHelpers;\n+  friend class ::tsl::FutureHelpers;\n \n   // Wraps a callback into a functor compatible with AsyncValue::AndThen.\n   template <typename F>\n@@ -453,6 +394,71 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   FutureHelpers::OnBlockEnd on_block_end_;\n };\n \n+template <typename T>\n+class PromiseBase {\n+ public:\n+  PromiseBase() = default;\n+\n+  PromiseBase(PromiseBase&& other) = default;\n+  PromiseBase& operator=(PromiseBase&& other) = default;\n+\n+  ~PromiseBase() {\n+    if (promise_ && !IsUniqueReference() && promise_.IsUnavailable()) {\n+      // At this point, we know that the underlying AsyncValueRef will\n+      // otherwise not fulfilled ever because `Promise` is move-only.\n+      promise_.emplace(\n+          absl::InternalError(\"Promise destroyed without being set\"));\n+    }\n+  }\n+\n+  explicit operator bool() const { return static_cast<bool>(promise_); }\n+\n+  // Returns if this promise is the unique reference to the underlying value.\n+  // That is, this method returns true only if all of the following conditions\n+  // are satisfied:\n+  //\n+  // - The promise is the only reference to the underlying value, i.e., there\n+  //   are no other promises or futures associated with this value.\n+  // - There are no OnReady callbacks registered to this promise.\n+  //\n+  // This may be used by the caller of `Set()` to short-circuit the work to\n+  // fulfill the promise if no one will ever consume the value. Even in that\n+  // case, consider fulfilling the promise with an error (e.g., `CANCELLED`)\n+  // instead of dropping the promise without fulfilling it in order to make\n+  // debugging easier. Also, be aware that the current promise may still be\n+  // used to mint a future.\n+  //\n+  // We use this API only when we are exclusive owner of the promise and can\n+  // guarantee that it didn't escape to other threads via pointers. Otherwise,\n+  // this is best effort check, because it uses two atomic operations and is\n+  // not atomic itself.\n+  bool IsUniqueReference() const {\n+    CHECK(promise_ && !promise_.GetAsyncValue()->IsIndirect())\n+        << \"Promise must wrap a concrete async value\";\n+    return promise_.GetAsyncValue()->NumRef() == 1 && !promise_.HasWaiter();\n+  }\n+\n+ protected:\n+  friend class ::tsl::Future<internal::future_type_t<T>>;\n+\n+  explicit PromiseBase(tsl::AsyncValueRef<T> promise)\n+      : promise_(std::move(promise)) {}\n+\n+  template <typename... Args>\n+  void emplace(Args&&... args) const {\n+    CHECK(promise_) << \"Promise must wrap an async value\";\n+    CHECK(promise_.IsUnavailable())\n+        << \"Promise must not be fulfilled more than once\";\n+    promise_.template emplace<Args...>(std::forward<Args>(args)...);\n+  }\n+\n+  // Takes a reference to the underlying AsyncValueRef container.\n+  tsl::AsyncValueRef<T> ref() const { return promise_; }\n+\n+ private:\n+  tsl::AsyncValueRef<T> promise_;\n+};\n+\n // A type predicate to check if a type combination of `R` and `U` is\n // valid for `Future<T>::Map(...)` methods defined below.\n template <typename R, typename U>\n@@ -519,6 +525,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n       \"Future<T> already has an implicit absl::StatusOr<T> semantics\");\n \n  public:\n+  // Deprecated alias for `tsl::Promise<T>`.\n+  using Promise = ::tsl::Promise<T>;\n+\n   Future() = default;\n \n   // Constructs an immediately available future with the given value.\n@@ -535,43 +544,6 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n                        !std::is_convertible_v<U, absl::StatusOr<T>>>* = nullptr>\n   explicit Future(U&& value) : Base(std::forward<U>(value)) {}\n \n-  class [[nodiscard]] Promise : public Base::Promise {\n-   public:\n-    using Base::Promise::Promise;\n-\n-    // Sets the value of the promise. Must be called at most once.\n-    //\n-    // After Set is called, value will be delivered to waiters on the Future\n-    // constructed from a promise, via blocking or callbacks.\n-    void Set(absl::StatusOr<T> value) {\n-      Base::Promise::emplace(std::move(value));\n-    }\n-\n-    // A helper function to convert move-only Promise to shared_ptr, which is\n-    // useful when the promise has to be captured by a std::function.\n-    std::shared_ptr<Promise> ToShared() && {\n-      return std::make_shared<Promise>(std::move(*this));\n-    }\n-\n-    // Returns a future associated with the promise. We use a trick we an extra\n-    // template parameter to disable converting promise to future for move-only\n-    // types, as it is illegal to create multiple move-only futures sharing the\n-    // underlying async value storage. For move-only types, the only way to\n-    // create a future is to call `MakePromise`.\n-    template <typename U = void,\n-              std::enable_if_t<!is_move_only && std::is_void_v<U>>* = nullptr>\n-    [[nodiscard]] Future<T> future(\n-        FutureHelpers::OnBlockStart on_block_start = nullptr,\n-        FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n-      return Future<T>(*this, std::move(on_block_start),\n-                       std::move(on_block_end));\n-    }\n-\n-   private:\n-    friend class Future<T>;\n-    friend class internal::PromiseMaker<T>;\n-  };\n-\n   ABSL_DEPRECATED(\"Use `tsl::MakePromise<T>` instead\")\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<T>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n@@ -703,6 +675,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n \n  private:\n   friend class FutureHelpers;\n+  friend class ::tsl::Promise<T>;\n   friend class internal::PromiseMaker<T>;\n \n   // Wraps a map functor into a callback compatible with Future<>::OnReady.\n@@ -717,12 +690,54 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   // - on_block_start is called before Await starts to block.\n   // - on_block_end is called after Await finishes blocking.\n-  Future(const Promise& promise, FutureHelpers::OnBlockStart on_block_start,\n+  Future(const internal::PromiseBase<absl::StatusOr<T>>& promise,\n+         FutureHelpers::OnBlockStart on_block_start,\n          FutureHelpers::OnBlockEnd on_block_end)\n       : Base(promise.ref(), std::move(on_block_start),\n              std::move(on_block_end)) {}\n };\n \n+template <typename T>\n+class [[nodiscard]] Promise : public internal::PromiseBase<absl::StatusOr<T>> {\n+  using Base = internal::PromiseBase<absl::StatusOr<T>>;\n+\n+ public:\n+  Promise() = default;\n+\n+  // Sets the value of the promise. Must be called at most once.\n+  //\n+  // After Set is called, value will be delivered to waiters on the Future\n+  // constructed from a promise, via blocking or callbacks.\n+  void Set(absl::StatusOr<T> value) { Base::emplace(std::move(value)); }\n+\n+  // A helper function to convert move-only Promise to shared_ptr, which is\n+  // useful when the promise has to be captured by a std::function.\n+  std::shared_ptr<Promise> ToShared() && {\n+    return std::make_shared<Promise>(std::move(*this));\n+  }\n+\n+  // Returns a future associated with the promise. We use a trick we an extra\n+  // template parameter to disable converting promise to future for move-only\n+  // types, as it is illegal to create multiple move-only futures sharing the\n+  // underlying async value storage. For move-only types, the only way to\n+  // create a future is to call `MakePromise`.\n+  template <typename U = void,\n+            std::enable_if_t<std::is_copy_constructible_v<T> &&\n+                             std::is_void_v<U>>* = nullptr>\n+  [[nodiscard]] Future<T> future(\n+      FutureHelpers::OnBlockStart on_block_start = nullptr,\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n+    return Future<T>(*this, std::move(on_block_start), std::move(on_block_end));\n+  }\n+\n+ private:\n+  friend class Future<T>;\n+  friend class internal::PromiseMaker<T>;\n+\n+  explicit Promise(tsl::AsyncValueRef<absl::StatusOr<T>> promise)\n+      : Base(std::move(promise)) {}\n+};\n+\n // Future<void> specialization for communicating stateless events.\n //\n // See Future<T> documentation above for more details.\n@@ -731,6 +746,9 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   using Base = internal::FutureBase<absl::Status>;\n \n  public:\n+  // Deprecated alias for `tsl::Promise<>`.\n+  using Promise = ::tsl::Promise<>;\n+\n   Future() = default;\n \n   // Constructor for a future that is immediately ready with a given status.\n@@ -751,38 +769,6 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   Future(U&& status)  // NOLINT\n       : Future(absl::Status(std::forward<U>(status))) {}\n \n-  class [[nodiscard]] Promise : public Base::Promise {\n-   public:\n-    using Base::Promise::Promise;\n-\n-    // Sets the promise completed with a given status. Must be called at most\n-    // once.\n-    //\n-    // After Set is called, completion event will be delivered to waiters on the\n-    // Future constructed from a promise, via blocking or callbacks.\n-    void Set(absl::Status status = absl::OkStatus()) {\n-      Base::Promise::emplace(std::move(status));\n-    }\n-\n-    // A helper function to convert move-only Promise to shared_ptr, which is\n-    // useful when the promise has to be captured by a std::function.\n-    std::shared_ptr<Promise> ToShared() && {\n-      return std::make_shared<Promise>(std::move(*this));\n-    }\n-\n-    // Returns a future associated with the promise.\n-    [[nodiscard]] Future<> future(\n-        FutureHelpers::OnBlockStart on_block_start = nullptr,\n-        FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n-      return Future<>(*this, std::move(on_block_start),\n-                      std::move(on_block_end));\n-    }\n-\n-   private:\n-    friend class Future<void>;\n-    friend class internal::PromiseMaker<void>;\n-  };\n-\n   ABSL_DEPRECATED(\"Use `tsl::MakePromise<>` instead\")\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n@@ -872,6 +858,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n \n  private:\n   friend class FutureHelpers;\n+  friend class ::tsl::Promise<void>;\n   friend class internal::PromiseMaker<void>;\n \n   // Wraps a map functor into a callback compatible with Future<>::OnReady.\n@@ -891,15 +878,49 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   //\n   // - on_block_start is called before Await starts to block.\n   // - on_block_end is called after Await finishes blocking.\n-  Future(const Promise& promise, FutureHelpers::OnBlockStart on_block_start,\n+  Future(const internal::PromiseBase<absl::Status>& promise,\n+         FutureHelpers::OnBlockStart on_block_start,\n          FutureHelpers::OnBlockEnd on_block_end)\n       : Base(promise.ref(), std::move(on_block_start),\n              std::move(on_block_end)) {}\n };\n \n-// Bring Promise implementation into the tsl namespace.\n-template <typename T = void>\n-using Promise = typename Future<T>::Promise;  // NOLINT\n+template <>\n+class [[nodiscard]] Promise<void> : public internal::PromiseBase<absl::Status> {\n+  using Base = internal::PromiseBase<absl::Status>;\n+\n+ public:\n+  Promise() = default;\n+\n+  // Sets the promise completed with a given status. Must be called at most\n+  // once.\n+  //\n+  // After Set is called, completion event will be delivered to waiters on the\n+  // Future constructed from a promise, via blocking or callbacks.\n+  void Set(absl::Status status = absl::OkStatus()) {\n+    Base::emplace(std::move(status));\n+  }\n+\n+  // A helper function to convert move-only Promise to shared_ptr, which is\n+  // useful when the promise has to be captured by a std::function.\n+  std::shared_ptr<Promise> ToShared() && {\n+    return std::make_shared<Promise>(std::move(*this));\n+  }\n+\n+  // Returns a future associated with the promise.\n+  [[nodiscard]] Future<> future(\n+      FutureHelpers::OnBlockStart on_block_start = nullptr,\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n+    return Future<>(*this, std::move(on_block_start), std::move(on_block_end));\n+  }\n+\n+ private:\n+  friend class Future<void>;\n+  friend class internal::PromiseMaker<void>;\n+\n+  explicit Promise(tsl::AsyncValueRef<absl::Status> promise)\n+      : Base(std::move(promise)) {}\n+};\n \n namespace internal {\n "
        }
    ],
    "stats": {
        "total": 303,
        "additions": 162,
        "deletions": 141
    }
}