{
    "author": "tensorflower-gardener",
    "message": "Iterate on the functions of the map in a deterministic order to create function names deterministically.\n\nWhen a function has multiple instances with different manual axes, and dedup-functions-fully is on, it will have different copies of the same function.\n\nFor example:\n\nsdy.manual_computation(%arg0) manual_axes={\"x\"} (%arg1: tensor<4xf32>) {\n  sdy.named_computation<\"foo\">(%arg1) (%arg2: tensor<4xf32>) {}\n}\nsdy.manual_computation(%arg0) manual_axes={\"y\"} (%arg1: tensor<4xf32>) {\n  sdy.named_computation<\"foo\">(%arg1) (%arg2: tensor<4xf32>) {}\n}\nsdy.named_computation<\"foo\">(%arg0) (%arg1: tensor<8xf32>) {}\n\n----->\n\nsdy.manual_computation(%arg0) manual_axes={\"x\"} (%arg1: tensor<4xf32>) {\n  call @foo(%arg1)\n}\nsdy.manual_computation(%arg0) manual_axes={\"y\"} (%arg1: tensor<4xf32>) {\n  call @foo_0(%arg1)\n}\ncall @foo_1(%arg0)\n\nThe order of the iteration on the map/vector determines the which 'foo' will become 'foo_0', 'foo_1', or stay as 'foo'.\n\nPiperOrigin-RevId: 825074314",
    "sha": "10fd9cfebb43b6445913d9f258c393a7ac484a25",
    "files": [
        {
            "sha": "c393b86afde5dcdad04ab2cfa4c3c76599a67af0",
            "filename": "third_party/xla/xla/service/spmd/shardy/round_trip_common/export_named_computations.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 6,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/10fd9cfebb43b6445913d9f258c393a7ac484a25/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fround_trip_common%2Fexport_named_computations.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/10fd9cfebb43b6445913d9f258c393a7ac484a25/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fround_trip_common%2Fexport_named_computations.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fround_trip_common%2Fexport_named_computations.cc?ref=10fd9cfebb43b6445913d9f258c393a7ac484a25",
            "patch": "@@ -157,10 +157,15 @@ class ExportNamedComputationsPass\n     mlir::Block& moduleBlock = moduleOp.getRegion().front();\n \n     if (dedupFunctionsFully) {\n+      using FuncNameKey = std::pair<StringRef, ManualAxesAttr>;\n       llvm::SmallDenseMap<ComputationKey, int64_t> funcCallSiteCounts;\n-      llvm::SmallDenseMap<std::pair<StringRef, ManualAxesAttr>,\n-                          std::pair<NamedComputationOp, int64_t>>\n+      llvm::SmallDenseMap<FuncNameKey, std::pair<NamedComputationOp, int64_t>>\n           funcToNamedComputations;\n+      // TODO(enver): Instead of a SmallDenseMap and a separate SmallVector to\n+      // guarantee a deterministic iteration order, consider using\n+      // llvm::MapVector.\n+      // Required to iterate on functions in a deterministic order.\n+      llvm::SmallVector<FuncNameKey> funcNames;\n       moduleOp.walk([&](NamedComputationOp namedComputationOp) {\n         ManualAxesAttr manualAxesAttr =\n             namedComputationOp->getAttrOfType<ManualAxesAttr>(kManualAxes);\n@@ -172,20 +177,24 @@ class ExportNamedComputationsPass\n                                 TensorShardingPerValueAttr()),\n                             manualAxesAttr);\n         const int64_t callSiteCount = funcCallSiteCounts[key]++;\n+        FuncNameKey funcNameKey =\n+            std::pair(namedComputationOp.getName(), manualAxesAttr);\n         if (auto [it, inserted] = funcToNamedComputations.try_emplace(\n-                std::pair(namedComputationOp.getName(), manualAxesAttr),\n-                namedComputationOp, callSiteCount);\n+                funcNameKey, namedComputationOp, callSiteCount);\n             !inserted) {\n           auto& [cachedNamedComputationOp, cachedCallSiteCount] = it->second;\n           if (callSiteCount > cachedCallSiteCount) {\n             cachedNamedComputationOp = namedComputationOp;\n             cachedCallSiteCount = callSiteCount;\n           }\n+        } else {  // inserted is true.\n+          funcNames.push_back(funcNameKey);\n         }\n       });\n \n-      for (auto& [_, namedComputationCountPair] : funcToNamedComputations) {\n-        auto& [namedComputationOp, callSiteCount] = namedComputationCountPair;\n+      for (FuncNameKey funcNameKey : funcNames) {\n+        auto& [namedComputationOp, callSiteCount] =\n+            funcToNamedComputations.find(funcNameKey)->second;\n         mlir::IRRewriter rewriter(namedComputationOp);\n         rewriter.setInsertionPointToEnd(&moduleBlock);\n         ManualAxesAttr manualAxesAttr ="
        }
    ],
    "stats": {
        "total": 21,
        "additions": 15,
        "deletions": 6
    }
}