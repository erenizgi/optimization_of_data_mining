{
    "author": "boomanaiden154",
    "message": "Integrate LLVM at llvm/llvm-project@c6e23ab80753\n\nUpdates LLVM usage to match\n[c6e23ab80753](https://github.com/llvm/llvm-project/commit/c6e23ab80753)\n\nPiperOrigin-RevId: 842350626",
    "sha": "27c6b3b944f7e5e9847d9597d8d6ec51e25c7472",
    "files": [
        {
            "sha": "dd3d4e4de4509df95596f74f3c7d2a12c55fb23d",
            "filename": "third_party/xla/third_party/llvm/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/27c6b3b944f7e5e9847d9597d8d6ec51e25c7472/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/27c6b3b944f7e5e9847d9597d8d6ec51e25c7472/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl?ref=27c6b3b944f7e5e9847d9597d8d6ec51e25c7472",
            "patch": "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n \n def repo(name):\n     \"\"\"Imports LLVM.\"\"\"\n-    LLVM_COMMIT = \"8dee997a8558b460b82b23fb43b197d68258baac\"\n-    LLVM_SHA256 = \"6a26975000c2cb45787813317bfeeadeafa0cba762e9434fb7940481ec4b27de\"\n+    LLVM_COMMIT = \"c6e23ab80753a01dce270f5f8a133fbec942315d\"\n+    LLVM_SHA256 = \"5a6b8aacd2d87ce9c4456843a76d0a54fd7cd0ae788ed3f19e7487ecd2ce4326\"\n \n     tf_http_archive(\n         name = name,"
        },
        {
            "sha": "13d339429b010115f263a3fcd474ab088b6156ff",
            "filename": "third_party/xla/third_party/shardy/temporary.patch",
            "status": "modified",
            "additions": 5,
            "deletions": 1147,
            "changes": 1152,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/27c6b3b944f7e5e9847d9597d8d6ec51e25c7472/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/27c6b3b944f7e5e9847d9597d8d6ec51e25c7472/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch?ref=27c6b3b944f7e5e9847d9597d8d6ec51e25c7472",
            "patch": "@@ -1,1157 +1,15 @@\n-diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch\n-index f04aa96..509398d 100644\n---- a/third_party/llvm/generated.patch\n-+++ b/third_party/llvm/generated.patch\n-@@ -1,1137 +1 @@\n- Auto generated patch. Do not edit or delete it, even if empty.\n--diff -ruN --strip-trailing-cr a/clang/docs/LanguageExtensions.rst b/clang/docs/LanguageExtensions.rst\n----- a/clang/docs/LanguageExtensions.rst\n--+++ b/clang/docs/LanguageExtensions.rst\n--@@ -1833,23 +1833,6 @@\n-- \n-- Clang provides a few builtin aliases to improve the throughput of certain metaprogramming facilities.\n-- \n---__builtin_common_reference\n-----------------------------\n---\n---.. code-block:: c++\n---\n---  template <template <class, class, template <class> class, template <class> class> class BasicCommonReferenceT,\n---            template <class... Args> CommonTypeT,\n---            template <class> HasTypeMember,\n---            class HasNoTypeMember,\n---            class... Ts>\n---  using __builtin_common_reference = ...;\n---\n---This alias is used for implementing ``std::common_reference``. If ``std::common_reference`` should contain a ``type``\n---member, it is an alias to ``HasTypeMember<TheCommonReference>``. Otherwse it is an alias to ``HasNoTypeMember``. The\n---``CommonTypeT`` is usually ``std::common_type_t``. ``BasicCommonReferenceT`` is usually an alias template to\n---``basic_common_reference<T, U, TX, UX>::type``.\n---\n-- __builtin_common_type\n-- ---------------------\n-- \n--diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/BuiltinTemplates.td b/clang/include/clang/Basic/BuiltinTemplates.td\n----- a/clang/include/clang/Basic/BuiltinTemplates.td\n--+++ b/clang/include/clang/Basic/BuiltinTemplates.td\n--@@ -10,11 +10,11 @@\n--   string Name = name;\n-- }\n-- \n---class Template<list<TemplateArg> args, string name = \"\"> : TemplateArg<name> {\n--+class Template<list<TemplateArg> args, string name> : TemplateArg<name> {\n--   list<TemplateArg> Args = args;\n-- }\n-- \n---class Class<string name = \"\", bit is_variadic = 0> : TemplateArg<name> {\n--+class Class<string name, bit is_variadic = 0> : TemplateArg<name> {\n--   bit IsVariadic = is_variadic;\n-- }\n-- \n--@@ -56,32 +56,6 @@\n--    Class<\"HasNoTypeMember\">,\n--    Class<\"Ts\", /*is_variadic=*/1>]>;\n-- \n---// template <template <class,\"\n---//                     class,\"\n---//                     template <class> class,\"\n---//                     template <class> class> class BasicCommonReferenceT,\"\n---//           template <class... Args> class CommonTypeT,\"\n---//           template <class> class HasTypeMember,\"\n---//           class HasNoTypeMember,\"\n---//           class... Ts>\"\n---def __builtin_common_reference : CPlusPlusBuiltinTemplate<\n---            [Template<[Class<>,\n---                       Class<>,\n---                       Template<[Class<>]>,\n---                       Template<[Class<>]>], \"BasicCommonReferenceT\">,\n---             Template<[Class<\"Args\", /*is_variadic=*/1>], \"CommonTypeT\">,\n---             Template<[Class<>], \"HasTypeMember\">,\n---             Class<\"HasNoTypeMember\">,\n---             Class<\"Ts\", /*is_variadic=*/1>]>;\n---\n---foreach Ref = [\"\", \"lvalue\", \"rvalue\"] in {\n---  foreach Const = [\"\", \"const\"] in {\n---    foreach Volatile = [\"\", \"volatile\"] in {\n---      def __clang_internal_xref_#Ref#Const#Volatile : CPlusPlusBuiltinTemplate<[Class<>]>;\n---    }\n---  }\n---}\n---\n-- // template <uint32_t Opcode,\n-- //           uint32_t Size,\n-- //           uint32_t Alignment,\n--diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h\n----- a/clang/include/clang/Sema/Sema.h\n--+++ b/clang/include/clang/Sema/Sema.h\n--@@ -15322,17 +15322,6 @@\n--   QualType BuiltinDecay(QualType BaseType, SourceLocation Loc);\n--   QualType BuiltinAddReference(QualType BaseType, UTTKind UKind,\n--                                SourceLocation Loc);\n---\n---  QualType BuiltinAddRValueReference(QualType BaseType, SourceLocation Loc) {\n---    return BuiltinAddReference(BaseType, UnaryTransformType::AddRvalueReference,\n---                               Loc);\n---  }\n---\n---  QualType BuiltinAddLValueReference(QualType BaseType, SourceLocation Loc) {\n---    return BuiltinAddReference(BaseType, UnaryTransformType::AddLvalueReference,\n---                               Loc);\n---  }\n---\n--   QualType BuiltinRemoveExtent(QualType BaseType, UTTKind UKind,\n--                                SourceLocation Loc);\n--   QualType BuiltinRemoveReference(QualType BaseType, UTTKind UKind,\n--@@ -15347,9 +15336,6 @@\n--   QualType BuiltinChangeSignedness(QualType BaseType, UTTKind UKind,\n--                                    SourceLocation Loc);\n-- \n---  bool BuiltinIsConvertible(QualType From, QualType To, SourceLocation Loc,\n---                            bool CheckNothrow = false);\n---\n--   bool BuiltinIsBaseOf(SourceLocation RhsTLoc, QualType LhsT, QualType RhsT);\n-- \n--   /// Ensure that the type T is a literal type.\n--diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplate.cpp b/clang/lib/Sema/SemaTemplate.cpp\n----- a/clang/lib/Sema/SemaTemplate.cpp\n--+++ b/clang/lib/Sema/SemaTemplate.cpp\n--@@ -3212,36 +3212,6 @@\n--   }\n-- }\n-- \n---static QualType InstantiateTemplate(Sema &S, ElaboratedTypeKeyword Keyword,\n---                                    TemplateName Template,\n---                                    ArrayRef<TemplateArgument> Args,\n---                                    SourceLocation Loc) {\n---  TemplateArgumentListInfo ArgList;\n---  for (auto Arg : Args) {\n---    if (Arg.getKind() == TemplateArgument::Type) {\n---      ArgList.addArgument(TemplateArgumentLoc(\n---          Arg, S.Context.getTrivialTypeSourceInfo(Arg.getAsType())));\n---    } else {\n---      ArgList.addArgument(\n---          S.getTrivialTemplateArgumentLoc(Arg, QualType(), Loc));\n---    }\n---  }\n---\n---  EnterExpressionEvaluationContext UnevaluatedContext(\n---      S, Sema::ExpressionEvaluationContext::Unevaluated);\n---  Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n---  Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n---\n---  QualType Instantiation =\n---      S.CheckTemplateIdType(Keyword, Template, Loc, ArgList, /*Scope=*/nullptr,\n---                            /*ForNestedNameSpecifier=*/false);\n---\n---  if (SFINAE.hasErrorOccurred())\n---    return QualType();\n---\n---  return Instantiation;\n---}\n---\n-- static QualType builtinCommonTypeImpl(Sema &S, ElaboratedTypeKeyword Keyword,\n--                                       TemplateName BaseTemplate,\n--                                       SourceLocation TemplateLoc,\n--@@ -3254,7 +3224,25 @@\n--       return builtinCommonTypeImpl(S, Keyword, BaseTemplate, TemplateLoc,\n--                                    {T1, T2});\n-- \n---    return InstantiateTemplate(S, Keyword, BaseTemplate, {T1, T2}, TemplateLoc);\n--+    TemplateArgumentListInfo Args;\n--+    Args.addArgument(TemplateArgumentLoc(\n--+        T1, S.Context.getTrivialTypeSourceInfo(T1.getAsType())));\n--+    Args.addArgument(TemplateArgumentLoc(\n--+        T2, S.Context.getTrivialTypeSourceInfo(T2.getAsType())));\n--+\n--+    EnterExpressionEvaluationContext UnevaluatedContext(\n--+        S, Sema::ExpressionEvaluationContext::Unevaluated);\n--+    Sema::SFINAETrap SFINAE(S, /*ForValidityCheck=*/true);\n--+    Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n--+\n--+    QualType BaseTemplateInst = S.CheckTemplateIdType(\n--+        Keyword, BaseTemplate, TemplateLoc, Args,\n--+        /*Scope=*/nullptr, /*ForNestedNameSpecifier=*/false);\n--+\n--+    if (SFINAE.hasErrorOccurred())\n--+      return QualType();\n--+\n--+    return BaseTemplateInst;\n--   };\n-- \n--   // Note A: For the common_type trait applied to a template parameter pack T of\n--@@ -3361,233 +3349,6 @@\n--   }\n-- }\n-- \n---static QualType CopyCV(QualType From, QualType To) {\n---  if (From.isConstQualified())\n---    To.addConst();\n---  if (From.isVolatileQualified())\n---    To.addVolatile();\n---  return To;\n---}\n---\n---// Let COND-RES(X, Y) be\n---//  decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()())\n---static QualType CondRes(Sema &S, QualType X, QualType Y, SourceLocation Loc) {\n---  EnterExpressionEvaluationContext UnevaluatedContext(\n---      S, Sema::ExpressionEvaluationContext::Unevaluated);\n---  Sema::SFINAETrap SFINAE(S, /*AccessCheckingSFINAE=*/true);\n---  Sema::ContextRAII TUContext(S, S.Context.getTranslationUnitDecl());\n---\n---  // false\n---  OpaqueValueExpr CondExpr(SourceLocation(), S.Context.BoolTy, VK_PRValue);\n---  ExprResult Cond = &CondExpr;\n---\n---  // declval<X(&)()>()()\n---  OpaqueValueExpr LHSExpr(Loc, X.getNonLValueExprType(S.Context),\n---                          Expr::getValueKindForType(X));\n---  ExprResult LHS = &LHSExpr;\n---\n---  // declval<Y(&)()>()()\n---  OpaqueValueExpr RHSExpr(Loc, Y.getNonLValueExprType(S.Context),\n---                          Expr::getValueKindForType(Y));\n---  ExprResult RHS = &RHSExpr;\n---\n---  ExprValueKind VK = VK_PRValue;\n---  ExprObjectKind OK = OK_Ordinary;\n---\n---  // decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()())\n---  QualType Result = S.CheckConditionalOperands(Cond, LHS, RHS, VK, OK, Loc);\n---\n---  if (SFINAE.hasErrorOccurred())\n---    return QualType();\n---  if (VK == VK_LValue)\n---    return S.BuiltinAddLValueReference(Result, Loc);\n---  if (VK == VK_XValue)\n---    return S.BuiltinAddRValueReference(Result, Loc);\n---  return Result;\n---}\n---\n---static QualType CommonRef(Sema &S, QualType A, QualType B, SourceLocation Loc) {\n---  // Given types A and B, let X be remove_reference_t<A>, let Y be\n---  // remove_reference_t<B>, and let COMMON-​REF(A, B) be:\n---  assert(A->isReferenceType() && B->isReferenceType() &&\n---         \"A and B have to be ref qualified for a COMMON-REF\");\n---  auto X = A.getNonReferenceType();\n---  auto Y = B.getNonReferenceType();\n---\n---  // If A and B are both lvalue reference types, COMMON-REF(A, B) is\n---  // COND-RES(COPYCV(X, Y) &, COPYCV(​Y, X) &) if that type exists and is a\n---  // reference type.\n---  if (A->isLValueReferenceType() && B->isLValueReferenceType()) {\n---    auto CR = CondRes(S, S.BuiltinAddLValueReference(CopyCV(X, Y), Loc),\n---                      S.BuiltinAddLValueReference(CopyCV(Y, X), Loc), Loc);\n---    if (CR.isNull() || !CR->isReferenceType())\n---      return QualType();\n---    return CR;\n---  }\n---\n---  // Otherwise, let C be remove_reference_t<COMMON-REF(X&, Y&)>&&. If A and B\n---  // are both rvalue reference types, C is well-formed, and\n---  // is_convertible_v<A, C> && is_convertible_v<B, C> is true, then\n---  // COMMON-REF(A, B) is C.\n---  if (A->isRValueReferenceType() && B->isRValueReferenceType()) {\n---    auto C = CommonRef(S, S.BuiltinAddLValueReference(X, Loc),\n---                       S.BuiltinAddLValueReference(Y, Loc), Loc);\n---    if (C.isNull())\n---      return QualType();\n---\n---    C = C.getNonReferenceType();\n---\n---    if (S.BuiltinIsConvertible(A, C, Loc) && S.BuiltinIsConvertible(B, C, Loc))\n---      return S.BuiltinAddRValueReference(C, Loc);\n---    return QualType();\n---  }\n---\n---  // Otherwise, if A is an lvalue reference and B is an rvalue reference, then\n---  // COMMON-REF(A, B) is COMMON-REF(B, A).\n---  if (A->isLValueReferenceType() && B->isRValueReferenceType())\n---    std::swap(A, B);\n---\n---  // Otherwise, let D be COMMON-REF(const X&, Y&). If A is an rvalue reference\n---  // and B is an lvalue reference and D is well-formed and\n---  // is_convertible_v<A, D> is true, then COMMON-REF(A, B) is D.\n---  if (A->isRValueReferenceType() && B->isLValueReferenceType()) {\n---    auto X2 = X;\n---    X2.addConst();\n---    auto D = CommonRef(S, S.BuiltinAddLValueReference(X2, Loc),\n---                       S.BuiltinAddLValueReference(Y, Loc), Loc);\n---    if (!D.isNull() && S.BuiltinIsConvertible(A, D, Loc))\n---      return D;\n---    return QualType();\n---  }\n---\n---  // Otherwise, COMMON-REF(A, B) is ill-formed.\n---  // This is implemented by returning from the individual branches above.\n---\n---  llvm_unreachable(\"The above cases should be exhaustive\");\n---}\n---\n---static QualType builtinCommonReferenceImpl(Sema &S,\n---                                           ElaboratedTypeKeyword Keyword,\n---                                           TemplateName CommonReference,\n---                                           TemplateName CommonType,\n---                                           SourceLocation TemplateLoc,\n---                                           ArrayRef<TemplateArgument> Ts) {\n---  switch (Ts.size()) {\n---  // If sizeof...(T) is zero, there shall be no member type.\n---  case 0:\n---    return QualType();\n---\n---  // Otherwise, if sizeof...(T) is one, let T0 denote the sole type in the\n---  // pack T. The member typedef type shall denote the same type as T0.\n---  case 1:\n---    return Ts[0].getAsType();\n---\n---  // Otherwise, if sizeof...(T) is two, let T1 and T2 denote the two types in\n---  // the pack T. Then\n---  case 2: {\n---    auto T1 = Ts[0].getAsType();\n---    auto T2 = Ts[1].getAsType();\n---\n---    // Let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is\n---    // well-formed, and is_convertible_v<add_pointer_t<T1>, add_pointer_t<R>> &&\n---    // is_convertible_v<add_pointer_t<T2>, add_pointer_t<R>> is true, then the\n---    // member typedef type denotes R.\n---    if (T1->isReferenceType() && T2->isReferenceType()) {\n---      QualType R = CommonRef(S, T1, T2, TemplateLoc);\n---      if (!R.isNull()) {\n---        if (S.BuiltinIsConvertible(S.BuiltinAddPointer(T1, TemplateLoc),\n---                                   S.BuiltinAddPointer(R, TemplateLoc),\n---                                   TemplateLoc) &&\n---            S.BuiltinIsConvertible(S.BuiltinAddPointer(T2, TemplateLoc),\n---                                   S.BuiltinAddPointer(R, TemplateLoc),\n---                                   TemplateLoc)) {\n---          return R;\n---        }\n---      }\n---    }\n---\n---    // Otherwise, if basic_common_reference<remove_cvref_t<T1>,\n---    // remove_cvref_t<T2>, ​XREF(​T1), XREF(T2)>​::​type is well-formed,\n---    // then the member typedef type denotes that type.\n---    {\n---      auto getXRef = [&](QualType T) {\n---        BuiltinTemplateDecl *Quals[12] = {\n---            S.Context.get__clang_internal_xref_Decl(),\n---            S.Context.get__clang_internal_xref_constDecl(),\n---            S.Context.get__clang_internal_xref_volatileDecl(),\n---            S.Context.get__clang_internal_xref_constvolatileDecl(),\n---            S.Context.get__clang_internal_xref_lvalueDecl(),\n---            S.Context.get__clang_internal_xref_lvalueconstDecl(),\n---            S.Context.get__clang_internal_xref_lvaluevolatileDecl(),\n---            S.Context.get__clang_internal_xref_lvalueconstvolatileDecl(),\n---            S.Context.get__clang_internal_xref_rvalueDecl(),\n---            S.Context.get__clang_internal_xref_rvalueconstDecl(),\n---            S.Context.get__clang_internal_xref_rvaluevolatileDecl(),\n---            S.Context.get__clang_internal_xref_rvalueconstvolatileDecl(),\n---        };\n---        size_t Index = 0;\n---        if (T->isLValueReferenceType()) {\n---          T = T.getNonReferenceType();\n---          Index += 4;\n---        } else if (T->isRValueReferenceType()) {\n---          T = T.getNonReferenceType();\n---          Index += 8;\n---        }\n---        if (T.isConstQualified())\n---          Index += 1;\n---\n---        if (T.isVolatileQualified())\n---          Index += 2;\n---\n---        return Quals[Index];\n---      };\n---\n---      auto BCR = InstantiateTemplate(S, Keyword, CommonReference,\n---                                     {S.BuiltinRemoveCVRef(T1, TemplateLoc),\n---                                      S.BuiltinRemoveCVRef(T2, TemplateLoc),\n---                                      TemplateName{getXRef(T1)},\n---                                      TemplateName{getXRef(T2)}},\n---                                     TemplateLoc);\n---      if (!BCR.isNull())\n---        return BCR;\n---    }\n---\n---    // Otherwise, if COND-RES(T1, T2) is well-formed, then the member typedef\n---    // type denotes that type.\n---    if (auto CR = CondRes(S, T1, T2, TemplateLoc); !CR.isNull())\n---      return CR;\n---\n---    // Otherwise, if common_type_t<T1, T2> is well-formed, then the member\n---    // typedef type denotes that type.\n---    if (auto CT =\n---            InstantiateTemplate(S, Keyword, CommonType, {T1, T2}, TemplateLoc);\n---        !CT.isNull())\n---      return CT;\n---\n---    // Otherwise, there shall be no member type.\n---    return QualType();\n---  }\n---\n---  // Otherwise, if sizeof...(T) is greater than two, let T1, T2, and Rest,\n---  // respectively, denote the first, second, and (pack of) remaining types\n---  // comprising T. Let C be the type common_reference_t<T1, T2>. Then:\n---  default: {\n---    auto T1 = Ts[0];\n---    auto T2 = Ts[1];\n---    auto Rest = Ts.drop_front(2);\n---    auto C = builtinCommonReferenceImpl(S, Keyword, CommonReference, CommonType,\n---                                        TemplateLoc, {T1, T2});\n---    if (C.isNull())\n---      return QualType();\n---    llvm::SmallVector<TemplateArgument, 4> Args;\n---    Args.emplace_back(C);\n---    Args.append(Rest.begin(), Rest.end());\n---    return builtinCommonReferenceImpl(S, Keyword, CommonReference, CommonType,\n---                                      TemplateLoc, Args);\n---  }\n---  }\n---}\n---\n-- static bool isInVkNamespace(const RecordType *RT) {\n--   DeclContext *DC = RT->getDecl()->getDeclContext();\n--   if (!DC)\n--@@ -3746,89 +3507,6 @@\n--     return HasNoTypeMember;\n--   }\n-- \n---  case BTK__builtin_common_reference: {\n---    assert(Converted.size() == 5);\n---    if (llvm::any_of(Converted, [](auto &C) { return C.isDependent(); }))\n---      return QualType();\n---\n---    TemplateName BasicCommonReference = Converted[0].getAsTemplate();\n---    TemplateName CommonType = Converted[1].getAsTemplate();\n---    TemplateName HasTypeMember = Converted[2].getAsTemplate();\n---    QualType HasNoTypeMember = Converted[3].getAsType();\n---    ArrayRef<TemplateArgument> Ts = Converted[4].getPackAsArray();\n---    if (auto CR =\n---            builtinCommonReferenceImpl(SemaRef, Keyword, BasicCommonReference,\n---                                       CommonType, TemplateLoc, Ts);\n---        !CR.isNull()) {\n---      TemplateArgumentListInfo TAs;\n---      TAs.addArgument(TemplateArgumentLoc(\n---          TemplateArgument(CR), SemaRef.Context.getTrivialTypeSourceInfo(\n---                                    CR, TemplateArgs[1].getLocation())));\n---      return SemaRef.CheckTemplateIdType(Keyword, HasTypeMember, TemplateLoc,\n---                                         TAs, /*Scope=*/nullptr,\n---                                         /*ForNestedNameSpecifier=*/false);\n---    }\n---    return HasNoTypeMember;\n---  }\n---\n---  case BTK__clang_internal_xref_:\n---  case BTK__clang_internal_xref_const:\n---  case BTK__clang_internal_xref_volatile:\n---  case BTK__clang_internal_xref_constvolatile:\n---  case BTK__clang_internal_xref_lvalue:\n---  case BTK__clang_internal_xref_lvalueconst:\n---  case BTK__clang_internal_xref_lvaluevolatile:\n---  case BTK__clang_internal_xref_lvalueconstvolatile:\n---  case BTK__clang_internal_xref_rvalue:\n---  case BTK__clang_internal_xref_rvalueconst:\n---  case BTK__clang_internal_xref_rvaluevolatile:\n---  case BTK__clang_internal_xref_rvalueconstvolatile: {\n---    if (llvm::any_of(Converted, [](auto &C) { return C.isDependent(); }))\n---      return QualType();\n---\n---    auto BTK = BTD->getBuiltinTemplateKind();\n---    auto anyOf = [&](auto... Vals) { return ((BTK == Vals) || ...); };\n---\n---    bool AddCV = anyOf(BTK__clang_internal_xref_constvolatile,\n---                       BTK__clang_internal_xref_lvalueconstvolatile,\n---                       BTK__clang_internal_xref_rvalueconstvolatile);\n---\n---    bool AddConst = AddCV || anyOf(BTK__clang_internal_xref_const,\n---                                   BTK__clang_internal_xref_lvalueconst,\n---                                   BTK__clang_internal_xref_rvalueconst);\n---\n---    bool AddVolatile = AddCV || anyOf(BTK__clang_internal_xref_volatile,\n---                                      BTK__clang_internal_xref_lvaluevolatile,\n---                                      BTK__clang_internal_xref_rvaluevolatile);\n---\n---    bool AddLValue = anyOf(BTK__clang_internal_xref_lvalue,\n---                           BTK__clang_internal_xref_lvalueconst,\n---                           BTK__clang_internal_xref_lvaluevolatile,\n---                           BTK__clang_internal_xref_lvalueconstvolatile);\n---\n---    bool AddRValue = anyOf(BTK__clang_internal_xref_rvalue,\n---                           BTK__clang_internal_xref_rvalueconst,\n---                           BTK__clang_internal_xref_rvaluevolatile,\n---                           BTK__clang_internal_xref_rvalueconstvolatile);\n---\n---    assert(Converted.size() == 1);\n---\n---    QualType T = Converted[0].getAsType();\n---\n---    if (AddConst)\n---      T.addConst();\n---\n---    if (AddVolatile)\n---      T.addVolatile();\n---\n---    if (AddLValue)\n---      T = SemaRef.BuiltinAddLValueReference(T, TemplateLoc);\n---    else if (AddRValue)\n---      T = SemaRef.BuiltinAddRValueReference(T, TemplateLoc);\n---\n---    return T;\n---  }\n---\n--   case BTK__hlsl_spirv_type: {\n--     assert(Converted.size() == 4);\n-- \n--diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaType.cpp b/clang/lib/Sema/SemaType.cpp\n----- a/clang/lib/Sema/SemaType.cpp\n--+++ b/clang/lib/Sema/SemaType.cpp\n--@@ -32,8 +32,6 @@\n-- #include \"clang/Lex/Preprocessor.h\"\n-- #include \"clang/Sema/DeclSpec.h\"\n-- #include \"clang/Sema/DelayedDiagnostic.h\"\n---#include \"clang/Sema/EnterExpressionEvaluationContext.h\"\n---#include \"clang/Sema/Initialization.h\"\n-- #include \"clang/Sema/Lookup.h\"\n-- #include \"clang/Sema/ParsedAttr.h\"\n-- #include \"clang/Sema/ParsedTemplate.h\"\n--@@ -10074,81 +10072,6 @@\n--   return Context.getQualifiedType(Underlying, BaseType.getQualifiers());\n-- }\n-- \n---bool Sema::BuiltinIsConvertible(QualType From, QualType To, SourceLocation Loc,\n---                                bool CheckNothrow) {\n---  if (To->isVoidType())\n---    return From->isVoidType();\n---\n---  // [meta.rel]\n---  // From and To shall be complete types, cv void, or arrays of unknown bound.\n---  if ((!From->isIncompleteArrayType() && !From->isVoidType() &&\n---       RequireCompleteType(\n---           Loc, From, diag::err_incomplete_type_used_in_type_trait_expr)) ||\n---      (!To->isIncompleteArrayType() && !To->isVoidType() &&\n---       RequireCompleteType(Loc, To,\n---                           diag::err_incomplete_type_used_in_type_trait_expr)))\n---    return false;\n---\n---  // C++11 [meta.rel]p4:\n---  //   Given the following function prototype:\n---  //\n---  //     template <class T>\n---  //       typename add_rvalue_reference<T>::type create();\n---  //\n---  //   the predicate condition for a template specialization\n---  //   is_convertible<From, To> shall be satisfied if and only if\n---  //   the return expression in the following code would be\n---  //   well-formed, including any implicit conversions to the return\n---  //   type of the function:\n---  //\n---  //     To test() {\n---  //       return create<From>();\n---  //     }\n---  //\n---  //   Access checking is performed as if in a context unrelated to To and\n---  //   From. Only the validity of the immediate context of the expression\n---  //   of the return-statement (including conversions to the return type)\n---  //   is considered.\n---  //\n---  // We model the initialization as a copy-initialization of a temporary\n---  // of the appropriate type, which for this expression is identical to the\n---  // return statement (since NRVO doesn't apply).\n---\n---  // Functions aren't allowed to return function or array types.\n---  if (To->isFunctionType() || To->isArrayType())\n---    return false;\n---\n---  // A function definition requires a non-abstract return type.\n---  if (isAbstractType(Loc, To))\n---    return false;\n---\n---  From = BuiltinAddRValueReference(From, Loc);\n---\n---  // Build a fake source and destination for initialization.\n---  InitializedEntity ToEntity(InitializedEntity::InitializeTemporary(To));\n---  OpaqueValueExpr FromExpr(Loc, From.getNonLValueExprType(Context),\n---                           Expr::getValueKindForType(From));\n---  InitializationKind Kind =\n---      InitializationKind::CreateCopy(Loc, SourceLocation());\n---\n---  // Perform the initialization in an unevaluated context within a SFINAE\n---  // trap at translation unit scope.\n---  EnterExpressionEvaluationContext Unevaluated(\n---      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n---  Sema::SFINAETrap SFINAE(*this, /*AccessCheckingSFINAE=*/true);\n---  Sema::ContextRAII TUContext(*this, Context.getTranslationUnitDecl());\n---  Expr *FromExprPtr = &FromExpr;\n---  InitializationSequence Init(*this, ToEntity, Kind, FromExprPtr);\n---  if (Init.Failed())\n---    return false;\n---\n---  ExprResult Result = Init.Perform(*this, ToEntity, Kind, FromExprPtr);\n---  if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n---    return false;\n---\n---  return !CheckNothrow || canThrow(Result.get()) == CT_Cannot;\n---}\n---\n-- QualType Sema::BuildUnaryTransformType(QualType BaseType, UTTKind UKind,\n--                                        SourceLocation Loc) {\n--   if (BaseType->isDependentType())\n--diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTypeTraits.cpp b/clang/lib/Sema/SemaTypeTraits.cpp\n----- a/clang/lib/Sema/SemaTypeTraits.cpp\n--+++ b/clang/lib/Sema/SemaTypeTraits.cpp\n--@@ -1212,6 +1212,76 @@\n--                                     const TypeSourceInfo *Rhs,\n--                                     SourceLocation KeyLoc);\n-- \n--+static ExprResult CheckConvertibilityForTypeTraits(\n--+    Sema &Self, const TypeSourceInfo *Lhs, const TypeSourceInfo *Rhs,\n--+    SourceLocation KeyLoc, llvm::BumpPtrAllocator &OpaqueExprAllocator) {\n--+\n--+  QualType LhsT = Lhs->getType();\n--+  QualType RhsT = Rhs->getType();\n--+\n--+  // C++0x [meta.rel]p4:\n--+  //   Given the following function prototype:\n--+  //\n--+  //     template <class T>\n--+  //       typename add_rvalue_reference<T>::type create();\n--+  //\n--+  //   the predicate condition for a template specialization\n--+  //   is_convertible<From, To> shall be satisfied if and only if\n--+  //   the return expression in the following code would be\n--+  //   well-formed, including any implicit conversions to the return\n--+  //   type of the function:\n--+  //\n--+  //     To test() {\n--+  //       return create<From>();\n--+  //     }\n--+  //\n--+  //   Access checking is performed as if in a context unrelated to To and\n--+  //   From. Only the validity of the immediate context of the expression\n--+  //   of the return-statement (including conversions to the return type)\n--+  //   is considered.\n--+  //\n--+  // We model the initialization as a copy-initialization of a temporary\n--+  // of the appropriate type, which for this expression is identical to the\n--+  // return statement (since NRVO doesn't apply).\n--+\n--+  // Functions aren't allowed to return function or array types.\n--+  if (RhsT->isFunctionType() || RhsT->isArrayType())\n--+    return ExprError();\n--+\n--+  // A function definition requires a complete, non-abstract return type.\n--+  if (!Self.isCompleteType(Rhs->getTypeLoc().getBeginLoc(), RhsT) ||\n--+      Self.isAbstractType(Rhs->getTypeLoc().getBeginLoc(), RhsT))\n--+    return ExprError();\n--+\n--+  // Compute the result of add_rvalue_reference.\n--+  if (LhsT->isObjectType() || LhsT->isFunctionType())\n--+    LhsT = Self.Context.getRValueReferenceType(LhsT);\n--+\n--+  // Build a fake source and destination for initialization.\n--+  InitializedEntity To(InitializedEntity::InitializeTemporary(RhsT));\n--+  Expr *From = new (OpaqueExprAllocator.Allocate<OpaqueValueExpr>())\n--+      OpaqueValueExpr(KeyLoc, LhsT.getNonLValueExprType(Self.Context),\n--+                      Expr::getValueKindForType(LhsT));\n--+  InitializationKind Kind =\n--+      InitializationKind::CreateCopy(KeyLoc, SourceLocation());\n--+\n--+  // Perform the initialization in an unevaluated context within a SFINAE\n--+  // trap at translation unit scope.\n--+  EnterExpressionEvaluationContext Unevaluated(\n--+      Self, Sema::ExpressionEvaluationContext::Unevaluated);\n--+  Sema::SFINAETrap SFINAE(Self, /*ForValidityCheck=*/true);\n--+  Sema::ContextRAII TUContext(Self, Self.Context.getTranslationUnitDecl());\n--+  InitializationSequence Init(Self, To, Kind, From);\n--+  if (Init.Failed())\n--+    return ExprError();\n--+\n--+  ExprResult Result = Init.Perform(Self, To, Kind, From);\n--+  if (Result.isInvalid() || SFINAE.hasErrorOccurred())\n--+    return ExprError();\n--+\n--+  return Result;\n--+}\n--+\n-- static APValue EvaluateSizeTTypeTrait(Sema &S, TypeTrait Kind,\n--                                       SourceLocation KWLoc,\n--                                       ArrayRef<TypeSourceInfo *> Args,\n--@@ -1372,8 +1442,9 @@\n--           S.Context.getPointerType(T.getNonReferenceType()));\n--       TypeSourceInfo *UPtr = S.Context.CreateTypeSourceInfo(\n--           S.Context.getPointerType(U.getNonReferenceType()));\n---      return S.BuiltinIsConvertible(UPtr->getType(), TPtr->getType(),\n---                                    RParenLoc);\n--+      return !CheckConvertibilityForTypeTraits(S, UPtr, TPtr, RParenLoc,\n--+                                               OpaqueExprAllocator)\n--+                  .isInvalid();\n--     }\n-- \n--     if (Kind == clang::TT_IsNothrowConstructible)\n--@@ -1624,9 +1695,20 @@\n--   }\n--   case BTT_IsConvertible:\n--   case BTT_IsConvertibleTo:\n---  case BTT_IsNothrowConvertible:\n---    return Self.BuiltinIsConvertible(LhsT, RhsT, KeyLoc,\n---                                     BTT == BTT_IsNothrowConvertible);\n--+  case BTT_IsNothrowConvertible: {\n--+    if (RhsT->isVoidType())\n--+      return LhsT->isVoidType();\n--+    llvm::BumpPtrAllocator OpaqueExprAllocator;\n--+    ExprResult Result = CheckConvertibilityForTypeTraits(Self, Lhs, Rhs, KeyLoc,\n--+                                                         OpaqueExprAllocator);\n--+    if (Result.isInvalid())\n--+      return false;\n--+\n--+    if (BTT != BTT_IsNothrowConvertible)\n--+      return true;\n--+\n--+    return Self.canThrow(Result.get()) == CT_Cannot;\n--+  }\n-- \n--   case BTT_IsAssignable:\n--   case BTT_IsNothrowAssignable:\n--diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/type-trait-common-reference.cpp b/clang/test/SemaCXX/type-trait-common-reference.cpp\n----- a/clang/test/SemaCXX/type-trait-common-reference.cpp\n--+++ b/clang/test/SemaCXX/type-trait-common-reference.cpp\n--@@ -1,136 +0,0 @@\n---// RUN: %clang_cc1 -triple x86_64-apple-darwin10 -fsyntax-only -verify -std=c++17 -Wno-vla-cxx-extension %s\n---// RUN: %clang_cc1 -triple x86_64-apple-darwin10 -fsyntax-only -verify -std=c++20 -Wno-vla-cxx-extension %s\n---\n---#if !__has_builtin(__builtin_common_reference)\n---#  error\n---#endif\n---\n---// expected-note@*:* {{template <template <class, class, template <class> class, template <class> class> class, template <class ...> class, template <class> class, class, class ...>}}\n---\n---void test() {\n---  __builtin_common_reference<> a; // expected-error {{too few template arguments for template '__builtin_common_reference'}}\n---  __builtin_common_reference<1> b; // expected-error {{template argument for template template parameter must be a class template or type alias template}}\n---  __builtin_common_reference<int, 1> c; // expected-error {{template argument for template template parameter must be a class template or type alias template}}\n---}\n---\n---struct empty_type {};\n---\n---template <class T>\n---struct type_identity {\n---  using type = T;\n---};\n---\n---template <class...>\n---struct common_type;\n---\n---template <class... Args>\n---using common_type_t = typename common_type<Args...>::type;\n---\n---template <class, class, template <class> class, template <class> class>\n---struct basic_common_reference {};\n---\n---template <class T, class U, template <class> class TX, template <class> class UX>\n---using basic_common_reference_t = typename basic_common_reference<T, U, TX, UX>::type;\n---\n---void test_vla() {\n---  int i = 4;\n---  int VLA[i];\n---  __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, decltype(VLA)> d; // expected-error {{variably modified type 'decltype(VLA)' (aka 'int[i]') cannot be used as a template argument}}\n---}\n---\n---template <class... Args>\n---using common_reference_base = __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, Args...>;\n---\n---template <class... Args>\n---struct common_reference : common_reference_base<Args...> {};\n---\n---template <class... Args>\n---using common_reference_t = typename __builtin_common_reference<basic_common_reference_t, common_type_t, type_identity, empty_type, Args...>::type;\n---\n---struct Incomplete;\n---\n---template<>\n---struct common_type<Incomplete, Incomplete>;\n---\n---static_assert(__is_same(common_reference_base<>, empty_type));\n---\n---static_assert(__is_same(common_reference_base<Incomplete>, type_identity<Incomplete>));\n---static_assert(__is_same(common_reference_base<char>, type_identity<char>));\n---static_assert(__is_same(common_reference_base<int>, type_identity<int>));\n---static_assert(__is_same(common_reference_base<const int>, type_identity<const int>));\n---static_assert(__is_same(common_reference_base<volatile int>, type_identity<volatile int>));\n---static_assert(__is_same(common_reference_base<const volatile int>, type_identity<const volatile int>));\n---static_assert(__is_same(common_reference_base<int[]>, type_identity<int[]>));\n---static_assert(__is_same(common_reference_base<const int[]>, type_identity<const int[]>));\n---static_assert(__is_same(common_reference_base<void(&)()>, type_identity<void(&)()>));\n---\n---static_assert(__is_same(common_reference_base<int[], int[]>, type_identity<int*>));\n---static_assert(__is_same(common_reference_base<int, int>, type_identity<int>));\n---static_assert(__is_same(common_reference_base<int, long>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<long, int>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<long, long>, type_identity<long>));\n---\n---static_assert(__is_same(common_reference_base<const int, long>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<const volatile int, long>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<int, const long>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<int, const volatile long>, type_identity<long>));\n---\n---static_assert(__is_same(common_reference_base<int*, long*>, empty_type));\n---static_assert(__is_same(common_reference_base<const unsigned int *const &, const unsigned int *const &>, type_identity<const unsigned int *const &>));\n---\n---static_assert(__is_same(common_reference_base<int, long, float>, type_identity<float>));\n---static_assert(__is_same(common_reference_base<unsigned, char, long>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<long long, long long, long>, type_identity<long long>));\n---\n---static_assert(__is_same(common_reference_base<int [[clang::address_space(1)]]>, type_identity<int [[clang::address_space(1)]]>));\n---static_assert(__is_same(common_reference_base<int [[clang::address_space(1)]], int>, type_identity<int>));\n---static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], int>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], int [[clang::address_space(1)]]>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], long [[clang::address_space(1)]]>, type_identity<long>));\n---static_assert(__is_same(common_reference_base<long [[clang::address_space(1)]], long [[clang::address_space(2)]]>, type_identity<long>));\n---\n---struct S {};\n---struct T : S {};\n---struct U {};\n---\n---static_assert(__is_same(common_reference_base<S&&, T&&>, type_identity<S&&>));\n---\n---static_assert(__is_same(common_reference_base<int S::*, int S::*>, type_identity<int S::*>));\n---static_assert(__is_same(common_reference_base<int S::*, int T::*>, type_identity<int T::*>));\n---static_assert(__is_same(common_reference_base<int S::*, long S::*>, empty_type));\n---\n---static_assert(__is_same(common_reference_base<int (S::*)(), int (S::*)()>, type_identity<int (S::*)()>));\n---static_assert(__is_same(common_reference_base<int (S::*)(), int (T::*)()>, type_identity<int (T::*)()>));\n---static_assert(__is_same(common_reference_base<int (S::*)(), long (S::*)()>, empty_type));\n---\n---static_assert(__is_same(common_reference_base<int&, int&>, type_identity<int&>));\n---static_assert(__is_same(common_reference_base<int&, const int&>, type_identity<const int&>));\n---static_assert(__is_same(common_reference_base<volatile int&, const int&>, type_identity<const volatile int&>));\n---\n---template <class T, class U>\n---struct my_pair;\n---\n---template <class T1, class U1, class T2, class U2, template <class> class TX, template <class> class UX>\n---struct basic_common_reference<my_pair<T1, U1>, my_pair<T2, U2>, TX, UX> {\n---  using type = my_pair<common_reference_t<TX<T1>, UX<T2>>, common_reference_t<TX<U1>, UX<U2>>>;\n---};\n---\n---static_assert(__is_same(common_reference_base<my_pair<const int&, int&>, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, volatile int&>>));\n---static_assert(__is_same(common_reference_base<const my_pair<int, int>&, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, const volatile int&>>));\n---static_assert(__is_same(common_reference_base<const int&, const volatile int&>, type_identity<const volatile int&>));\n---static_assert(__is_same(common_reference_base<int&&, const volatile int&>, type_identity<int>));\n---static_assert(__is_same(common_reference_base<my_pair<int, int>&&, my_pair<int&, volatile int&>>, type_identity<my_pair<const int&, int>>));\n---static_assert(__is_same(common_reference_base<my_pair<int, int>&&, my_pair<int&, int>&&>, type_identity<my_pair<const int&, int&&>>));\n---\n---struct conversion_operator {\n---  operator volatile int&&() volatile;\n---};\n---\n---static_assert(__is_same(common_reference_base<volatile conversion_operator&&, volatile int&&>, type_identity<volatile int&&>));\n---\n---struct reference_wrapper {\n---  reference_wrapper(int&);\n---  operator int&() const;\n---};\n---\n---static_assert(__is_same(common_reference_base<const reference_wrapper&, int&>, empty_type));\n--diff -ruN --strip-trailing-cr a/libcxx/include/__locale_dir/num.h b/libcxx/include/__locale_dir/num.h\n----- a/libcxx/include/__locale_dir/num.h\n--+++ b/libcxx/include/__locale_dir/num.h\n--@@ -436,6 +436,7 @@\n--         ++__first;\n--         if (__first == __last) {\n--           __err |= ios_base::eofbit;\n--+          __v = 0;\n--           return __first;\n--         }\n--         // __c2 == 'x' || __c2 == 'X'\n--@@ -444,6 +445,7 @@\n--           ++__first;\n--         } else {\n--           __base = 8;\n--+          __parsed_num = true; // We only swallowed '0', so we've started to parse a number\n--         }\n--       } else {\n--         __base = 10;\n--diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap.in b/libcxx/include/module.modulemap.in\n----- a/libcxx/include/module.modulemap.in\n--+++ b/libcxx/include/module.modulemap.in\n--@@ -1517,7 +1517,6 @@\n--       header \"__iterator/iterator_traits.h\"\n--       export std_core.type_traits.integral_constant\n--       export std_core.type_traits.is_convertible\n---      export std_core.type_traits.nat\n--     }\n--     module iterator_with_data         { header \"__iterator/iterator_with_data.h\" }\n--     module iterator                   { header \"__iterator/iterator.h\" }\n--diff -ruN --strip-trailing-cr a/libcxx/include/__type_traits/common_reference.h b/libcxx/include/__type_traits/common_reference.h\n----- a/libcxx/include/__type_traits/common_reference.h\n--+++ b/libcxx/include/__type_traits/common_reference.h\n--@@ -18,37 +18,16 @@\n-- #include <__type_traits/is_reference.h>\n-- #include <__type_traits/remove_cvref.h>\n-- #include <__type_traits/remove_reference.h>\n---#include <__type_traits/type_identity.h>\n-- #include <__utility/declval.h>\n-- \n-- #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n-- #  pragma GCC system_header\n-- #endif\n-- \n---#if _LIBCPP_STD_VER >= 20\n---\n-- _LIBCPP_BEGIN_NAMESPACE_STD\n-- \n---template <class...>\n---struct _LIBCPP_NO_SPECIALIZATIONS common_reference;\n---\n---template <class... _Types>\n---using common_reference_t = typename common_reference<_Types...>::type;\n---\n---template <class, class, template <class> class, template <class> class>\n---struct basic_common_reference {};\n---\n---#  if __has_builtin(__builtin_common_reference)\n---\n---template <class _Tp, class _Up, template <class> class _Tx, template <class> class _Ux>\n---using __basic_common_reference_t = basic_common_reference<_Tp, _Up, _Tx, _Ux>::type;\n---\n---template <class... _Args>\n---struct _LIBCPP_NO_SPECIALIZATIONS common_reference\n---    : __builtin_common_reference<__basic_common_reference_t, common_type_t, type_identity, __empty, _Args...> {};\n---\n---#  else\n---\n--+// common_reference\n--+#if _LIBCPP_STD_VER >= 20\n-- // Let COND_RES(X, Y) be:\n-- template <class _Xp, class _Yp>\n-- using __cond_res _LIBCPP_NODEBUG = decltype(false ? std::declval<_Xp (&)()>()() : std::declval<_Yp (&)()>()());\n--@@ -130,10 +109,19 @@\n-- \n-- // Note C: For the common_reference trait applied to a parameter pack [...]\n-- \n--+template <class...>\n--+struct _LIBCPP_NO_SPECIALIZATIONS common_reference;\n--+\n--+template <class... _Types>\n--+using common_reference_t = typename common_reference<_Types...>::type;\n--+\n--+template <class, class, template <class> class, template <class> class>\n--+struct basic_common_reference {};\n--+\n-- _LIBCPP_DIAGNOSTIC_PUSH\n---#    if __has_warning(\"-Winvalid-specialization\")\n--+#  if __has_warning(\"-Winvalid-specialization\")\n-- _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(\"-Winvalid-specialization\")\n---#    endif\n--+#  endif\n-- // bullet 1 - sizeof...(T) == 0\n-- template <>\n-- struct common_reference<> {};\n--@@ -207,10 +195,8 @@\n-- template <class...>\n-- struct _LIBCPP_NO_SPECIALIZATIONS common_reference {};\n-- \n---#  endif // __has_builtin(__builtin_common_reference)\n--+#endif // _LIBCPP_STD_VER >= 20\n-- \n-- _LIBCPP_END_NAMESPACE_STD\n-- \n---#endif // _LIBCPP_STD_VER >= 20\n---\n-- #endif // _LIBCPP___TYPE_TRAITS_COMMON_REFERENCE_H\n--diff -ruN --strip-trailing-cr a/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp b/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n----- a/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n--+++ b/libcxx/test/std/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members/get_long.pass.cpp\n--@@ -670,5 +670,101 @@\n--       assert(v == std::numeric_limits<long>::min());\n--     }\n-- \n--+  { // Check that auto-detection of the base works properly\n--+    ios.flags(ios.flags() & ~std::ios::basefield);\n--+    { // zeroes\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"0\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 1), ios, err, v);\n--+        assert(base(iter) == str + 1);\n--+        assert(err == ios.eofbit);\n--+        assert(v == 0);\n--+      }\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"00\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n--+        assert(base(iter) == str + 2);\n--+        assert(err == ios.eofbit);\n--+        assert(v == 0);\n--+      }\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"0x0\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n--+        assert(base(iter) == str + 3);\n--+        assert(err == ios.eofbit);\n--+        assert(v == 0);\n--+      }\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"0X0\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n--+        assert(base(iter) == str + 3);\n--+        assert(err == ios.eofbit);\n--+        assert(v == 0);\n--+      }\n--+    }\n--+    { // first character after base is out of range\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"08\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n--+        assert(base(iter) == str + 1);\n--+        assert(err == ios.goodbit);\n--+        assert(v == 0);\n--+      }\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"1a\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 2), ios, err, v);\n--+        assert(base(iter) == str + 1);\n--+        assert(err == ios.goodbit);\n--+        assert(v == 1);\n--+      }\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"0xg\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n--+        assert(base(iter) == str + 2);\n--+        assert(err == ios.failbit);\n--+        assert(v == 0);\n--+      }\n--+      {\n--+        v                          = -1;\n--+        const char str[]           = \"0Xg\";\n--+        std::ios_base::iostate err = ios.goodbit;\n--+\n--+        cpp17_input_iterator<const char*> iter =\n--+            f.get(cpp17_input_iterator<const char*>(str), cpp17_input_iterator<const char*>(str + 3), ios, err, v);\n--+        assert(base(iter) == str + 2);\n--+        assert(err == ios.failbit);\n--+        assert(v == 0);\n--+      }\n--+    }\n--+  }\n--+\n--   return 0;\n-- }\n--diff -ruN --strip-trailing-cr a/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td b/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n----- a/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n--+++ b/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td\n--@@ -948,8 +948,7 @@\n--     auto [id, args] = NVVM::MBarrierArriveExpectTxOp::getIntrinsicIDAndArgs(\n--                       *op, moduleTranslation, builder);\n-- \n---    int addrSpace = llvm::cast<LLVMPointerType>(op.getAddr().getType()).getAddressSpace();\n---    if (addrSpace != NVVM::NVVMMemorySpace::SharedCluster)\n--+    if (op.getNumResults() > 0)\n--       $res = createIntrinsicCall(builder, id, args);\n--     else\n--       createIntrinsicCall(builder, id, args);\n--@@ -985,9 +984,7 @@\n--   string llvmBuilder = [{\n--     auto [id, args] = NVVM::MBarrierArriveDropExpectTxOp::getIntrinsicIDAndArgs(\n--                       *op, moduleTranslation, builder);\n---\n---    int addrSpace = llvm::cast<LLVMPointerType>(op.getAddr().getType()).getAddressSpace();\n---    if (addrSpace != NVVM::NVVMMemorySpace::SharedCluster)\n--+    if (op.getNumResults() > 0)\n--       $res = createIntrinsicCall(builder, id, args);\n--     else\n--       createIntrinsicCall(builder, id, args);\n--diff -ruN --strip-trailing-cr a/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir b/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n----- a/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n--+++ b/mlir/test/Integration/GPU/CUDA/TensorCore/sm80/wmma-matmul-f64.mlir\n--@@ -44,6 +44,7 @@\n--   gpu.host_register %2 : memref<*xf64>\n--   gpu.host_register %20 : memref<*xf64>\n--   gpu.host_register %33 : memref<*xf64>\n--+  gpu.host_register %34 : memref<*xf64>\n-- \n--   gpu.launch blocks(%bx, %by, %bz) in (%grid_x = %c1, %grid_y = %c1, %grid_z = %c1)\n--              threads(%tx, %ty, %tz) in (%block_x = %c32, %block_y = %c1, %block_z = %c1) {\n--diff -ruN --strip-trailing-cr a/utils/bazel/configure.bzl b/utils/bazel/configure.bzl\n----- a/utils/bazel/configure.bzl\n--+++ b/utils/bazel/configure.bzl\n--@@ -27,7 +27,6 @@\n--     \"XCore\",\n-- ]\n-- \n---\n-- MAX_TRAVERSAL_STEPS = 1000000  # \"big number\" upper bound on total visited dirs\n-- \n-- def _overlay_directories(repository_ctx):\n--@@ -44,7 +43,9 @@\n--     for _ in range(MAX_TRAVERSAL_STEPS):\n--         rel_dir = stack.pop()\n-- \n---        overlay_dirs = set()\n--+        # TODO: `set()` is only available in bazel 8.1.\n--+        # Use `set()` after downstream users are on more recent versions.\n--+        overlay_dirs = {}\n-- \n--         # Symlink overlay files, overlay dirs will be handled in future iterations.\n--         for entry in overlay_root.get_child(rel_dir).readdir():\n--@@ -53,7 +54,7 @@\n-- \n--             if entry.is_dir:\n--                 stack.append(full_rel_path)\n---                overlay_dirs.add(name)\n--+                overlay_dirs[name] = None\n--             else:\n--                 src_path = overlay_root.get_child(full_rel_path)\n--                 dst_path = target_root.get_child(full_rel_path)\n--@@ -62,7 +63,7 @@\n--         # Symlink source dirs (if not themselves overlaid) and files.\n--         for src_entry in src_root.get_child(rel_dir).readdir():\n--             name = src_entry.basename\n---            if name in overlay_dirs:\n--+            if name in overlay_dirs.keys():\n--                 # Skip: overlay has a directory with this name\n--                 continue\n-- \n diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl\n-index f8f483c..5e3d8f2 100644\n+index 5e3d8f2..dd3d4e4 100644\n --- a/third_party/llvm/workspace.bzl\n +++ b/third_party/llvm/workspace.bzl\n @@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n  \n  def repo(name):\n      \"\"\"Imports LLVM.\"\"\"\n--    LLVM_COMMIT = \"ac66ae45cd22a7958ace645a035831000bfcbf51\"\n--    LLVM_SHA256 = \"3bb51316595bbe99da8bee121f1fc39993176afc5b55f72a5d5010214dcd24a8\"\n-+    LLVM_COMMIT = \"8dee997a8558b460b82b23fb43b197d68258baac\"\n-+    LLVM_SHA256 = \"6a26975000c2cb45787813317bfeeadeafa0cba762e9434fb7940481ec4b27de\"\n+-    LLVM_COMMIT = \"8dee997a8558b460b82b23fb43b197d68258baac\"\n+-    LLVM_SHA256 = \"6a26975000c2cb45787813317bfeeadeafa0cba762e9434fb7940481ec4b27de\"\n++    LLVM_COMMIT = \"c6e23ab80753a01dce270f5f8a133fbec942315d\"\n++    LLVM_SHA256 = \"5a6b8aacd2d87ce9c4456843a76d0a54fd7cd0ae788ed3f19e7487ecd2ce4326\"\n  \n      tf_http_archive(\n          name = name,"
        },
        {
            "sha": "22625dcbb1fff335f617f2c7b6130b4e75712c9d",
            "filename": "third_party/xla/third_party/shardy/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/27c6b3b944f7e5e9847d9597d8d6ec51e25c7472/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/27c6b3b944f7e5e9847d9597d8d6ec51e25c7472/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl?ref=27c6b3b944f7e5e9847d9597d8d6ec51e25c7472",
            "patch": "@@ -3,8 +3,8 @@\n load(\"//third_party:repo.bzl\", \"tf_http_archive\", \"tf_mirror_urls\")\n \n def repo():\n-    SHARDY_COMMIT = \"e0131b277694a847e26d0ce4ce489423f399e26c\"\n-    SHARDY_SHA256 = \"54341c51d72c773217023a77db3b53253bcf49faa5a3d59d088e8b3e75d976be\"\n+    SHARDY_COMMIT = \"bda4ef8940c146fed6477d03b375c06d04475003\"\n+    SHARDY_SHA256 = \"4d54264a91c6ae7977ea072eef92a4df0ffa4b5cc97bdf814095b0f8f7f6d5ce\"\n \n     tf_http_archive(\n         name = \"shardy\","
        }
    ],
    "stats": {
        "total": 1160,
        "additions": 9,
        "deletions": 1151
    }
}