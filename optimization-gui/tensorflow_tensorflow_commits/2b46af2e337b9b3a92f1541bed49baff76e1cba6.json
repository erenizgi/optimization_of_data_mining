{
    "author": "ZixuanJiang",
    "message": "Fix types and comments in replica groups V2.\n\nPiperOrigin-RevId: 837229986",
    "sha": "2b46af2e337b9b3a92f1541bed49baff76e1cba6",
    "files": [
        {
            "sha": "433405a85ee7198adea64d06fce7f2ef44a0bcd5",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 14,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b46af2e337b9b3a92f1541bed49baff76e1cba6/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b46af2e337b9b3a92f1541bed49baff76e1cba6/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc?ref=2b46af2e337b9b3a92f1541bed49baff76e1cba6",
            "patch": "@@ -2950,8 +2950,9 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n   // We perform the following steps on the original tile assignment:\n   // 1. Expand target dims: [8,8,16]->[2,4,2,4,16]\n   // 2. Transpose to make target dims minor: [2,4,2,4,16]->[2,2,16,4,4] with\n-  // (0,1,2,3,4) -> (0,2,4,1,3)\n-  // 3. Reshape to get groups of size 16: [2,4,16,2,4]->[2,2,16,16]\n+  //    (0,1,2,3,4) -> (0,2,4,1,3)\n+  // 3. Reshape to [num_replica_groups, num_devices_per_group]:\n+  //    [2,2,16,4,4]->[2x2x16, 4x4].\n   int64_t total_group_size = std::accumulate(\n       group_sizes.begin(), group_sizes.end(), 1, std::multiplies<int64_t>());\n   int64_t num_replica_groups =\n@@ -3002,13 +3003,11 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n     return std::nullopt;\n   }\n \n-  // Step 3: Final reshape to get groups of size total_group_size. This is done\n-  // implicitly by creating an IotaReplicaGroupList with num_replica_groups,\n-  // total_group_size.\n-  IotaReplicaGroupList groups(\n-      num_replica_groups, total_group_size,\n-      tranposed_tile_assignment.value().reshape_dims(),\n-      tranposed_tile_assignment.value().transpose_perm());\n+  // Step 3: Final reshape to [num_replica_groups, num_devices_per_group]. This\n+  // is done implicitly by creating an IotaReplicaGroupList.\n+  IotaReplicaGroupList groups(num_replica_groups, total_group_size,\n+                              tranposed_tile_assignment->reshape_dims(),\n+                              tranposed_tile_assignment->transpose_perm());\n   return groups;\n }\n \n@@ -3069,16 +3068,16 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsForReplication(\n // Expands partition group list across all replicas. Expects that provided\n // partition group list utilizes all the partitions.\n CollectiveDeviceList ExpandPartitionGroupListAcrossReplicas(\n-    IotaReplicaGroupList partition_group_list, int num_replicas,\n-    int num_partitions) {\n-  int partition_group_count = partition_group_list.num_replica_groups();\n-  int partition_group_size = partition_group_list.num_devices_per_group();\n+    IotaReplicaGroupList partition_group_list, int64_t num_replicas,\n+    int64_t num_partitions) {\n+  int64_t partition_group_count = partition_group_list.num_replica_groups();\n+  int64_t partition_group_size = partition_group_list.num_devices_per_group();\n   // Verify that partition group list utilizes all partitions.\n   CHECK_EQ((partition_group_count * partition_group_size), num_partitions);\n \n   // Total number of replica groups is number of partitions groups * num of\n   // replicas.\n-  int replica_group_count = partition_group_count * num_replicas;\n+  int64_t replica_group_count = partition_group_count * num_replicas;\n \n   // Newly generated replica group list expands the pattern within one replica\n   // across all replicas. For example, if we want to expand a partition group"
        },
        {
            "sha": "ac9f08edb110384926b1318b253b71fcfb11519a",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b46af2e337b9b3a92f1541bed49baff76e1cba6/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b46af2e337b9b3a92f1541bed49baff76e1cba6/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h?ref=2b46af2e337b9b3a92f1541bed49baff76e1cba6",
            "patch": "@@ -630,8 +630,8 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsForReplication(\n // Expands partition group list across all replicas. Expects that provided\n // partition_group_list utilizes all the partitions.\n CollectiveDeviceList ExpandPartitionGroupListAcrossReplicas(\n-    IotaReplicaGroupList partition_group_list, int num_replicas,\n-    int num_partitions);\n+    IotaReplicaGroupList partition_group_list, int64_t num_replicas,\n+    int64_t num_partitions);\n \n namespace detail {\n "
        }
    ],
    "stats": {
        "total": 31,
        "additions": 15,
        "deletions": 16
    }
}