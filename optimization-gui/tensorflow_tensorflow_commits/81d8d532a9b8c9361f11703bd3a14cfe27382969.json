{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832174916",
    "sha": "81d8d532a9b8c9361f11703bd3a14cfe27382969",
    "files": [
        {
            "sha": "d6432e96e38abdb5a6feaac1cdb2970cef37e313",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/81d8d532a9b8c9361f11703bd3a14cfe27382969/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/81d8d532a9b8c9361f11703bd3a14cfe27382969/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=81d8d532a9b8c9361f11703bd3a14cfe27382969",
            "patch": "@@ -642,7 +642,7 @@ PjRtStreamExecutorClient::LinearizeHostBufferInto(\n     options.dims = dims;\n     options.permutation = permutation;\n     options.input_layout = TransposePlan::Striding{*byte_strides};\n-    absl::MutexLock lock(&transpose_mu_);\n+    absl::MutexLock lock(transpose_mu_);\n     TF_ASSIGN_OR_RETURN(transpose, transpose_cache_.GetOrCreate(options));\n   }\n \n@@ -942,7 +942,7 @@ absl::Status PjRtStreamExecutorClient::DmaMap(void* data, size_t buffer_size) {\n     return absl::InternalError(absl::StrFormat(\n         \"Failed to register host memory at address: %ps\", data));\n   }\n-  absl::MutexLock lock(&dma_maps_mutex_);\n+  absl::MutexLock lock(dma_maps_mutex_);\n   dma_maps_.insert({data, buffer_size});\n   return absl::OkStatus();\n }\n@@ -959,7 +959,7 @@ absl::Status PjRtStreamExecutorClient::DmaUnmap(void* data) {\n     return absl::InternalError(absl::StrFormat(\n         \"Failed to unregister host memory at address: %ps\", data));\n   }\n-  absl::MutexLock lock(&dma_maps_mutex_);\n+  absl::MutexLock lock(dma_maps_mutex_);\n   dma_maps_.erase(data);\n   return absl::OkStatus();\n }\n@@ -1532,7 +1532,7 @@ class StreamExecutorCopyToDeviceStream : public CopyToDeviceStream {\n           {{\"channel_id\", channel_id_}});\n     });\n \n-    absl::ReleasableMutexLock lock(&mu_);\n+    absl::ReleasableMutexLock lock(mu_);\n \n     VLOG(3) << \"Add chunk to a H2D channel #\" << channel_id_ << \": \"\n             << \"size=\" << chunk.size() << \", \"\n@@ -2248,7 +2248,7 @@ PjRtStreamExecutorLoadedExecutable::Execute(\n             ExecuteHelper(argument_handles[i], replica, partition, run_id,\n                           options, returned_futures.has_value());\n \n-        absl::MutexLock lock(&mu);\n+        absl::MutexLock lock(mu);\n         --running;\n         if (!results[i].ok()) {\n           if (failed == 0) {\n@@ -2263,7 +2263,7 @@ PjRtStreamExecutorLoadedExecutable::Execute(\n       mu.AssertHeld();\n       return running == 0 || failed > 0;\n     };\n-    absl::MutexLock lock(&mu);\n+    absl::MutexLock lock(mu);\n     mu.Await(absl::Condition(&done_running_or_failed));\n     if (failed > 0) {\n       auto done_running = [&]() {\n@@ -2960,7 +2960,7 @@ PjRtStreamExecutorClient::Load(std::unique_ptr<PjRtExecutable> executable,\n \n bool PjRtStreamExecutorClient::IsDmaMapped(const void* data_start,\n                                            int64_t transfer_size) {\n-  absl::MutexLock lock(&dma_maps_mutex_);\n+  absl::MutexLock lock(dma_maps_mutex_);\n   if (!dma_maps_.empty()) {\n     void* data_end = (char*)data_start + transfer_size;\n     for (const auto& [map_start, map_size] : dma_maps_) {"
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}