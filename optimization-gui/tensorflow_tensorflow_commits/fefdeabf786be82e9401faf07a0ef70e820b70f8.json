{
    "author": "shawnwang18",
    "message": "PR #31354: [XLA:GPU]  Add some VLOG debug prints for the summary results of command_buffer_scheduling pass\n\nImported from GitHub PR https://github.com/openxla/xla/pull/31354\n\nüìù Summary of Changes\n[XLA:GPU]  Add some VLOG debug prints for the summary results of command_buffer_scheduling pass\n\nüöÄ Kind of Contribution\nPlease remove what does not apply: üìö Documentation\n\nüß™ Unit Tests:\nOnly add some VLOG debugs, not unittest.\n\nCopybara import of the project:\n\n--\nacd13a0252601ae37c4797e660df3e30feb13dd2 by Shawn Wang <shawnw@nvidia.com>:\n\nadd command buffer scheduling debug summary report\n\nMerging this change closes #31354\n\nPiperOrigin-RevId: 807655787",
    "sha": "fefdeabf786be82e9401faf07a0ef70e820b70f8",
    "files": [
        {
            "sha": "872d0385176f68ac04c8aa1aa4c1c7edf4a6bcc4",
            "filename": "third_party/xla/xla/service/gpu/transforms/command_buffer_scheduling.cc",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fefdeabf786be82e9401faf07a0ef70e820b70f8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcommand_buffer_scheduling.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fefdeabf786be82e9401faf07a0ef70e820b70f8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcommand_buffer_scheduling.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcommand_buffer_scheduling.cc?ref=fefdeabf786be82e9401faf07a0ef70e820b70f8",
            "patch": "@@ -991,6 +991,7 @@ absl::StatusOr<bool> CommandBufferScheduling::Run(\n   auto order = module->MakeComputationPostOrder();\n   std::reverse(order.begin(), order.end());\n   absl::flat_hash_set<HloComputation*> processed_command_buffers;\n+  std::vector<HloComputation*> command_buffer_computations;\n \n   auto changed = false;\n   for (HloComputation* comp : order) {\n@@ -1023,6 +1024,9 @@ absl::StatusOr<bool> CommandBufferScheduling::Run(\n           RewriteCommandBuffer(comp, seq, std::move(command_buffer)));\n       changed = true;\n \n+      // Track created command buffer computations for diagnostics.\n+      command_buffer_computations.push_back(command_buffer_computation);\n+\n       // All computations reachable from a command buffer computation are nested\n       // command buffers (i.e. body computations attached to a while operation).\n       for (HloComputation* called :\n@@ -1033,6 +1037,59 @@ absl::StatusOr<bool> CommandBufferScheduling::Run(\n   }\n   TF_RETURN_IF_ERROR(module->schedule().Update());\n \n+  if (VLOG_IS_ON(3)) {\n+    // Collect all instructions that are part of any created command buffer\n+    // computations (including their embedded computations).\n+    absl::flat_hash_set<const HloInstruction*> in_command_buffers;\n+    for (HloComputation* cb_comp : command_buffer_computations) {\n+      for (HloInstruction* inst : cb_comp->instructions()) {\n+        if (inst != nullptr && !IsNoOp(inst)) in_command_buffers.insert(inst);\n+      }\n+      for (HloComputation* embedded : cb_comp->MakeEmbeddedComputationsList()) {\n+        for (HloInstruction* inst : embedded->instructions()) {\n+          if (inst != nullptr && !IsNoOp(inst)) in_command_buffers.insert(inst);\n+        }\n+      }\n+    }\n+\n+    // Build a set of command buffer computations to identify their call sites.\n+    absl::flat_hash_set<HloComputation*> cb_comps(\n+        command_buffer_computations.begin(), command_buffer_computations.end());\n+\n+    // Compute coverage and log instructions not captured by any command buffer.\n+    int64_t total_insts = 0;\n+    int64_t not_in_cb_count = 0;\n+    for (HloComputation* comp_all : module->computations()) {\n+      for (HloInstruction* inst : comp_all->instructions()) {\n+        if (inst == nullptr) continue;\n+        // Skip no-op instructions from coverage and diagnostics.\n+        if (IsNoOp(inst)) continue;\n+        // Ignore the kCall that invokes a command buffer computation.\n+        if (inst->opcode() == HloOpcode::kCall) {\n+          bool is_cb_call = false;\n+          for (HloComputation* called : inst->called_computations()) {\n+            if (cb_comps.contains(called)) {\n+              is_cb_call = true;\n+              break;\n+            }\n+          }\n+          if (is_cb_call) continue;\n+        }\n+        total_insts++;\n+        if (!in_command_buffers.contains(inst)) {\n+          not_in_cb_count++;\n+          VLOG(3) << \"Not in command buffer: module=\" << module->name()\n+                  << \" computation=\" << comp_all->name()\n+                  << \" instruction:\" << inst->ToString();\n+        }\n+      }\n+    }\n+\n+    VLOG(3) << \"Command buffer coverage: \" << (total_insts - not_in_cb_count)\n+            << \"/\" << total_insts << \" instructions captured; \"\n+            << not_in_cb_count << \" not captured.\";\n+  }\n+\n   return changed;\n }\n "
        }
    ],
    "stats": {
        "total": 57,
        "additions": 57,
        "deletions": 0
    }
}