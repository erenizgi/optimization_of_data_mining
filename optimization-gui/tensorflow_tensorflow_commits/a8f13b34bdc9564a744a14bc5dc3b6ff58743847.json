{
    "author": "tensorflower-gardener",
    "message": "Reverts 99eed4f43a33018f52ce1ac1107ee7ec45e5fbf4\n\nPiperOrigin-RevId: 840451729",
    "sha": "a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
    "files": [
        {
            "sha": "f58bf888d460bbed50f4e68d9ccbc2fc73f78e94",
            "filename": "third_party/xla/xla/codegen/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -171,7 +171,6 @@ cc_library(\n         \"//xla/codegen/intrinsic:tanh\",\n         \"//xla/codegen/intrinsic:type\",\n         \"//xla/codegen/intrinsic:vec_name_mangler\",\n-        \"//xla/codegen/intrinsic/cpp:_cpp_gen_intrinsics\",\n         \"//xla/service/llvm_ir:llvm_util\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\","
        },
        {
            "sha": "bfc15e5531369278d83ed3ab779ba2ed10c99f11",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -89,37 +89,3 @@ xla_cc_test(\n         \"@com_google_googletest//:gtest_main\",\n     ],\n )\n-\n-cc_library(\n-    name = \"_cpp_gen_intrinsics\",\n-    srcs = [\"cpp_gen_intrinsics.cc\"],\n-    hdrs = [\"cpp_gen_intrinsics.h\"],\n-    deps = [\n-        \":eigen_unary_ll\",\n-        \"//xla/codegen/intrinsic\",\n-        \"//xla/service/llvm_ir:llvm_util\",\n-        \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/strings:string_view\",\n-        \"@llvm-project//llvm:IRReader\",\n-        \"@llvm-project//llvm:Linker\",\n-        \"@llvm-project//llvm:Support\",\n-        \"@llvm-project//llvm:Target\",\n-        \"@llvm-project//llvm:TransformUtils\",\n-        \"@llvm-project//llvm:ir_headers\",\n-    ],\n-)\n-\n-cc_library(\n-    name = \"_intrinsic_declarations\",\n-    hdrs = [\"intrinsic_declarations.h\"],\n-    deps = [\n-        \":_cpp_gen_intrinsics\",\n-        \"//xla:xla_data_proto_cc\",\n-        \"//xla/codegen/intrinsic\",\n-        \"//xla/codegen/intrinsic:type\",\n-        \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/strings:string_view\",\n-        \"@llvm-project//llvm:ir_headers\",\n-    ],\n-)"
        },
        {
            "sha": "90271f0caf8092c0a5aa9b24a5c83450a8e0dab0",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cc_to_llvm_ir.bzl",
            "status": "modified",
            "additions": 30,
            "deletions": 52,
            "changes": 82,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -25,15 +25,14 @@ def _cc_ir_header_impl(ctx):\n     compilation_contexts = [dep[CcInfo].compilation_context for dep in ctx.attr.deps]\n     output_header = ctx.outputs.out_header\n \n+    ir_file = ctx.actions.declare_file(\"{}.ll\".format(ctx.label.name))\n+\n     cxx_flags = [\n         \"-S\",\n         \"-emit-llvm\",\n         \"-O3\",\n-        \"-DNDEBUG\",\n-        \"-mprefer-vector-width=512\",\n         \"-DEIGEN_VECTORIZE_GENERIC\",\n     ]\n-\n     compilation_outputs = cc_common.compile(\n         actions = ctx.actions,\n         feature_configuration = feature_configuration,\n@@ -44,69 +43,48 @@ def _cc_ir_header_impl(ctx):\n         name = \"{}_compiler\".format(ctx.label.name),\n     )\n \n-    # Windows builds may produce objects and not pic_objects.\n-    # We accept either, preferring pic_objects if available.\n-    objs = compilation_outputs[1].pic_objects\n-    if not objs:\n-        objs = compilation_outputs[1].objects\n-        if not objs:\n-            objs_str = \"\"\n-            for objs in compilation_outputs:\n-                objs_str += \"\\n\"\n-                for obj in objs:\n-                    objs_str += \", \" + str(obj)\n-            fail(\"No objects found in compilation_outputs. Compilation outputs: {}\".format(objs_str))\n-\n-    temp_ir_output = objs[0]\n+    # Copy the compiler's output to our declared intermediate file.\n+    if len(compilation_outputs[1].pic_objects) > 0:\n+        temp_ir_output = compilation_outputs[1].pic_objects[0]\n+    else:\n+        temp_ir_output = compilation_outputs[1].objects[0]\n+    ctx.actions.run_shell(\n+        inputs = [temp_ir_output],\n+        outputs = [ir_file],\n+        command = \"cp {} {}\".format(temp_ir_output.path, ir_file.path),\n+        mnemonic = \"CopyLLVMIR\",\n+    )\n+\n+    # Prepare the C++ variable definition for the header.\n+    ir_definition = 'inline constexpr char k{base_name}Ir[] = R\"IR($(cat {input}))IR\";'.format(\n+        base_name = to_camel_case(ctx.attr.base_name),\n+        input = ir_file.path,\n+    )\n \n     # Generate the final C++ header file.\n-    # We use a python one-liner to perform a binary-safe copy.\n-    # 1. 'wb' mode writes the C++ preamble.\n-    # 2. We read the input as binary ('rb').\n-    # 3. We check for the UTF-8 BOM (\\xef\\xbb\\xbf) and strip it if present.\n-    #    NOTE: We use double backslashes (\\\\x) so Starlark passes the literal characters\n-    #    to Python, allowing Python to interpret the hex escape sequence.\n-    # 4. We append the rest of the file and the C++ closing syntax.\n     ctx.actions.run_shell(\n-        inputs = [temp_ir_output],\n+        inputs = [ir_file],\n         outputs = [output_header],\n         mnemonic = \"EmbeddingLLVMIR\",\n         command = \"\"\"\n-set -e\n-input_path=$1\n-output_path=$2\n-variable_name=$3\n-namespace=$4\n-\n-# 1. Write the header start\n-cat <<EOF > \"$output_path\"\n+cat <<EOF > {output}\n #pragma once\n \n // Generated by cc_ir_header rule. DO NOT EDIT.\n \n-namespace $namespace {\n-\n-inline constexpr char ${variable_name}[] = R\"IR(\n-EOF\n-\n-# 2. Append the IR content using Python for binary safety and BOM stripping.\n-python -c \"import sys; d = open(sys.argv[1], 'rb').read(); d = d[3:] if d.startswith(b'\\\\xef\\\\xbb\\\\xbf') else d; open(sys.argv[2], 'ab').write(d)\" \"$input_path\" \"$output_path\"\n+namespace {namespace} {{\n \n-# 3. Append the header end\n-cat <<EOF >> \"$output_path\"\n-)IR\";\n+{defs}\n \n-} // namespace $namespace\n+}} // namespace {namespace}\n EOF\n-\"\"\",\n-        arguments = [\n-            temp_ir_output.path,\n-            output_header.path,\n-            \"k{}Ir\".format(to_camel_case(ctx.attr.base_name)),\n-            ctx.attr.namespace,\n-        ],\n+\"\"\".format(\n+            output = output_header.path,\n+            defs = ir_definition,\n+            namespace = ctx.attr.namespace,\n+        ),\n+        progress_message = \"Embedding LLVM IR into header for %s\" % ctx.label,\n     )\n-\n     compilation_context = cc_common.create_compilation_context(headers = depset([output_header]))\n     cc_info = CcInfo(compilation_context = compilation_context)\n "
        },
        {
            "sha": "3984fc9d63250a868837bef592251ab9fb58f1ec",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 89,
            "changes": 89,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.cc?ref=be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9",
            "patch": "@@ -1,89 +0,0 @@\n-/* Copyright 2025 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n-\n-#include <memory>\n-#include <string>\n-#include <utility>\n-#include <vector>\n-\n-#include \"absl/log/check.h\"\n-#include \"absl/log/log.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"llvm/IR/Attributes.h\"\n-#include \"llvm/IR/Function.h\"\n-#include \"llvm/IR/Module.h\"\n-#include \"llvm/IRReader/IRReader.h\"\n-#include \"llvm/Linker/Linker.h\"\n-#include \"llvm/Support/MemoryBufferRef.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n-#include \"xla/codegen/intrinsic/cpp/eigen_unary_ll.h\"\n-#include \"xla/codegen/intrinsic/intrinsic.h\"\n-#include \"xla/service/llvm_ir/llvm_util.h\"\n-\n-namespace xla::codegen {\n-\n-std::string GetCppGenIrString(const intrinsics::IntrinsicOptions& options) {\n-  return ::llvm_ir::kEigenUnaryLlIr;\n-}\n-\n-void CppGenIntrinsicLibrary::LinkIntoModule(llvm::Module& dst_module) const {\n-  llvm::SMDiagnostic err;\n-  llvm::LLVMContext& context = dst_module.getContext();\n-  auto lib_module = llvm::parseIR(llvm::MemoryBufferRef(ir_text_, source_name_),\n-                                  err, context);\n-  CHECK(lib_module != nullptr)\n-      << \"Failed to parse IR: \" << err.getMessage().str() << \"\\n\"\n-      << ir_text_;\n-\n-  llvm::Linker linker(dst_module);\n-\n-  std::vector<std::string> lib_functions;\n-  for (const auto& func : *lib_module) {\n-    if (!func.isDeclaration()) {\n-      lib_functions.push_back(func.getName().str());\n-    }\n-  }\n-  const llvm::DataLayout& hostDataLayout = dst_module.getDataLayout();\n-  lib_module->setDataLayout(hostDataLayout);\n-  if (linker.linkModules(dst_module, std::move(lib_module))) {\n-    LOG(FATAL) << \"LLVM Linker failed to link CppGen library.\";\n-  }\n-  for (const auto& func : lib_functions) {\n-    llvm::Function* linked_func = dst_module.getFunction(func);\n-    if (linked_func && !linked_func->isDeclaration()) {\n-      linked_func->setLinkage(llvm::Function::InternalLinkage);\n-      linked_func->addFnAttr(llvm::Attribute::AlwaysInline);\n-    }\n-  }\n-}\n-llvm::Function* GetCppGenFunction(llvm::Module* module,\n-                                  absl::string_view name) {\n-  llvm::Function* func = module->getFunction(name);\n-  CHECK(func != nullptr)\n-      << \"CppGen function '\" << name\n-      << \"' was not found in the module. Ensure the \"\n-         \"function name is correct and the library \"\n-         \"containing it was linked by IntrinsicFunctionLib.\\n\"\n-      << llvm_ir::DumpToString(module);\n-  ;\n-  if (!func->isDeclaration()) {\n-    func->setLinkage(llvm::Function::InternalLinkage);\n-    func->addFnAttr(llvm::Attribute::AlwaysInline);\n-  }\n-  return func;\n-}\n-}  // namespace xla::codegen"
        },
        {
            "sha": "63dc72d770ca975d69e960aea727210497ca1071",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h",
            "status": "removed",
            "additions": 0,
            "deletions": 60,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcpp_gen_intrinsics.h?ref=be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9",
            "patch": "@@ -1,60 +0,0 @@\n-/* Copyright 2025 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef XLA_CODEGEN_INTRINSIC_CPP_CPP_GEN_INTRINSICS_H_\n-#define XLA_CODEGEN_INTRINSIC_CPP_CPP_GEN_INTRINSICS_H_\n-\n-#include <string>\n-\n-#include \"absl/strings/string_view.h\"\n-#include \"llvm/IR/Attributes.h\"\n-#include \"llvm/IR/Function.h\"\n-#include \"llvm/IR/LLVMContext.h\"\n-#include \"llvm/IR/Module.h\"\n-#include \"llvm/IRReader/IRReader.h\"\n-#include \"llvm/Target/TargetMachine.h\"\n-#include \"llvm/Transforms/Utils/Cloning.h\"\n-#include \"llvm/Transforms/Utils/ValueMapper.h\"\n-#include \"xla/codegen/intrinsic/intrinsic.h\"\n-\n-namespace xla::codegen {\n-\n-std::string GetCppGenIrString(const intrinsics::IntrinsicOptions& options);\n-\n-// Helper for Intrinsic<T> classes that use CppGen backend for some types.\n-// Looks up a function by name in the module (assuming it was linked from\n-// a CppGen library) and configures its linkage and attributes for inlining.\n-llvm::Function* GetCppGenFunction(llvm::Module* module, absl::string_view name);\n-\n-class CppGenIntrinsicLibrary {\n- public:\n-  explicit CppGenIntrinsicLibrary(absl::string_view ir_text,\n-                                  absl::string_view source_name)\n-      : ir_text_(ir_text), source_name_(source_name) {}\n-\n-  // Links the CppGen library into the given module. This will insert all\n-  // of the function definitions in the ir_text into the dst_module and set\n-  // internal linkage and the alwaysinline attribute on each of them so they\n-  // can be inlined and removed later.\n-  void LinkIntoModule(llvm::Module& dst_module) const;\n-\n- private:\n-  std::string ir_text_;\n-  std::string source_name_;\n-};\n-\n-}  // namespace xla::codegen\n-\n-#endif  // XLA_CODEGEN_INTRINSIC_CPP_CPP_GEN_INTRINSICS_H_"
        },
        {
            "sha": "248b760e32af71bad695904a74f7da5fb3d48510",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -36,33 +36,12 @@ inline VecType VectorTanh(const VecType x) {\n // XLA entrypoints, renamed with asm in header file.\n //===--------------------------------------------------------------------===//\n \n-using FloatArrayType = Eigen::Array<float, 16, 1>;\n-\n // Single precision\n float tanh_f32(float x) { return Eigen::internal::ptanh_float(x); }\n-Vec4f tanh_v4f32(Vec4f x) {\n-  FloatArrayType buffer;\n-  *reinterpret_cast<Vec4f*>(&buffer) = x;\n-  buffer = buffer.tanh();\n-  return *reinterpret_cast<Vec4f*>(&buffer);\n-}\n-Vec8f tanh_v8f32(Vec8f x) {\n-  FloatArrayType buffer;\n-  *reinterpret_cast<Vec8f*>(&buffer) = x;\n-  buffer = buffer.tanh();\n-  return *reinterpret_cast<Vec8f*>(&buffer);\n-}\n Vec16f tanh_v16f32(Vec16f x) { return VectorTanh(x); }\n \n // Double precision\n-using DoubleArrayType = Eigen::Array<double, 8, 1>;\n double tanh_f64(double x) { return Eigen::internal::ptanh_double(x); }\n-Vec4d tanh_v4f64(Vec4d x) {\n-  DoubleArrayType buffer;\n-  *reinterpret_cast<Vec4d*>(&buffer) = x;\n-  buffer = buffer.tanh();\n-  return *reinterpret_cast<Vec4d*>(&buffer);\n-}\n Vec8d tanh_v8f64(Vec8d x) { return VectorTanh(x); }\n \n }  // namespace xla::codegen"
        },
        {
            "sha": "1248cde5ef117682cc1e05b0f6f2ef8347b0ac92",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary.h",
            "status": "modified",
            "additions": 4,
            "deletions": 9,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.h?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -20,17 +20,12 @@ limitations under the License.\n namespace xla::codegen {\n \n // Single precision\n-// Right now these are unused and we rename them to avoid shadowing the current\n-// tanh implementation.\n-float tanh_f32(float x) asm(\"xla.unused.tanh.f32\");\n-Vec4f tanh_v4f32(Vec4f x) asm(\"xla.unused.tanh.v4f32\");\n-Vec8f tanh_v8f32(Vec8f x) asm(\"xla.unused.tanh.v8f32\");\n-Vec16f tanh_v16f32(Vec16f x) asm(\"xla.unused.tanh.v16f32\");\n+float tanh_f32(float x) asm(\"xla.tanh.f32\");\n+Vec16f tanh_v16f32(Vec16f x) asm(\"xla.tanh.v16f32\");\n \n // Double precision\n-double tanh_f64(double x) asm(\"xla.unused.tanh.f64\");\n-Vec4d tanh_v4f64(Vec4d x) asm(\"xla.unused.tanh.v4f64\");\n-Vec8d tanh_v8f64(Vec8d x) asm(\"xla.unused.tanh.v8f64\");\n+double tanh_f64(double x) asm(\"xla.tanh.f64\");\n+Vec8d tanh_v8f64(Vec8d x) asm(\"xla.tanh.v8f64\");\n \n }  // namespace xla::codegen\n "
        },
        {
            "sha": "eae40e857c50572eda519bf4b3e1af858f9ee306",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 47,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #include \"xla/codegen/intrinsic/cpp/eigen_unary.h\"\n \n #include <cmath>\n+#include <string>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n@@ -29,56 +30,13 @@ using ::testing::ContainsRegex;\n using ::testing::Not;\n using ::xla::codegen::intrinsic::NearUlps;\n \n-constexpr int kTanhUlps = 5;\n+constexpr int kTanhUlps = 4;\n \n TEST(EigenUnaryTest, FastTanhfIsCorrect) {\n-  Vec16f x = {1.0f,  2.0f,  -1.0f, 4.0f,   8.0f,   16.0f,  32.0f, 200.0f,\n+  Vec16f x = {1.0f,  2.0f,  -1.0f, 4.0f,   8.0f,   16.0f,  32.0f, 64.0f,\n               -2.0f, -4.0f, -8.0f, -16.0f, -32.0f, -64.0f, 0.0f,  0.5f};\n   Vec16f y = tanh_v16f32(x);\n   for (int i = 0; i < 16; ++i) {\n-    EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps))\n-        << x[i] << \" \" << std::tanh(x[i]);\n-  }\n-}\n-\n-TEST(EigenUnaryTest, FastTanhdIsCorrect) {\n-  Vec4d x = {1.0, 2.0, -1.0, 4.0};\n-  Vec4d y = tanh_v4f64(x);\n-  for (int i = 0; i < 4; ++i) {\n-    EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps));\n-  }\n-}\n-\n-TEST(EigenUnaryTest, LinspaceInputsTanhfCorrectness) {\n-  constexpr float start = -100.0f;\n-  constexpr float end = 100.0f;\n-  constexpr int steps = 1000 * 16;\n-  constexpr float step = (end - start) / steps;\n-\n-  for (int i = 0; i < steps; i += 16) {\n-    Vec16f x;\n-    for (int j = 0; j < 16; ++j) {\n-      x[j] = start + (i + j) * step;\n-    }\n-    Vec16f y = tanh_v16f32(x);\n-    for (int j = 0; j < 16; ++j) {\n-      EXPECT_THAT(y[j], NearUlps(std::tanh(x[j]), kTanhUlps));\n-    }\n-  }\n-}\n-\n-TEST(EigenUnaryTest, v4f32TanhIsCorrect) {\n-  Vec4f x = {1.0f, 2.0f, -1.0f, 4.0f};\n-  Vec4f y = tanh_v4f32(x);\n-  for (int i = 0; i < 4; ++i) {\n-    EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps));\n-  }\n-}\n-\n-TEST(EigenUnaryTest, v8f32TanhIsCorrect) {\n-  Vec8f x = {1.0f, 2.0f, -1.0f, 4.0f, 8.0f, 16.0f, 32.0f, 64.0f};\n-  Vec8f y = tanh_v8f32(x);\n-  for (int i = 0; i < 8; ++i) {\n     EXPECT_THAT(y[i], NearUlps(std::tanh(x[i]), kTanhUlps));\n   }\n }\n@@ -98,8 +56,8 @@ TEST(EigenUnaryTest, FastTanhfIsVectorized) {\n   EXPECT_THAT(ir, ContainsRegex(\"<16 x float>.*0x3E4DF2A3C0000000\"));\n   EXPECT_THAT(ir, Not(ContainsRegex(\"llvm.x86\")));\n   EXPECT_THAT(ir, Not(ContainsRegex(\"llvm.aarch64\")));\n-  EXPECT_THAT(ir, ContainsRegex(\"xla.unused.tanh.v16f32\"));\n-  EXPECT_THAT(ir, ContainsRegex(\"xla.unused.tanh.v8f64\"));\n+  EXPECT_THAT(ir, ContainsRegex(\"xla.tanh.v16f32\"));\n+  EXPECT_THAT(ir, ContainsRegex(\"xla.tanh.v8f64\"));\n }\n \n }  // namespace"
        },
        {
            "sha": "f452f2c256226b15e72e7c15121094896107f099",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/intrinsic_declarations.h",
            "status": "removed",
            "additions": 0,
            "deletions": 53,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fintrinsic_declarations.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fintrinsic_declarations.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fintrinsic_declarations.h?ref=be4b3a802b8baefd8071b83a7fa34c2bbcc80ef9",
            "patch": "@@ -1,53 +0,0 @@\n-/* Copyright 2025 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef XLA_CODEGEN_INTRINSIC_CPP_INTRINSIC_DECLARATIONS_H_\n-#define XLA_CODEGEN_INTRINSIC_CPP_INTRINSIC_DECLARATIONS_H_\n-\n-#include <vector>\n-\n-#include \"absl/log/check.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"llvm/IR/Attributes.h\"\n-#include \"llvm/IR/Function.h\"\n-#include \"llvm/IR/Module.h\"\n-#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n-#include \"xla/codegen/intrinsic/intrinsic.h\"\n-#include \"xla/codegen/intrinsic/type.h\"\n-#include \"xla/xla_data.pb.h\"\n-\n-namespace xla::codegen::intrinsics {\n-\n-class EigenTanh : public Intrinsic<EigenTanh> {\n- public:\n-  static constexpr absl::string_view kName = \"tanh\";\n-\n-  static std::vector<std::vector<Type>> SupportedVectorTypes(\n-      absl::string_view features) {\n-    return {\n-        {Type::S(xla::F32)},     {Type::V(xla::F32, 4)}, {Type::V(xla::F32, 8)},\n-        {Type::V(xla::F32, 16)}, {Type::S(xla::F64)},    {Type::V(xla::F64, 4)},\n-        {Type::V(xla::F64, 8)},\n-    };\n-  }\n-\n-  static absl::StatusOr<llvm::Function*> CreateDefinition(\n-      llvm::Module* module, const IntrinsicOptions& options, Type type) {\n-    return GetCppGenFunction(module, Name(type));\n-  }\n-};\n-}  // namespace xla::codegen::intrinsics\n-\n-#endif  // XLA_CODEGEN_INTRINSIC_CPP_INTRINSIC_DECLARATIONS_H_"
        },
        {
            "sha": "23809838c1ebbe831ade98de4df5fac59b0b6fe1",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 31,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -52,7 +52,6 @@ limitations under the License.\n #include \"llvm/Passes/StandardInstrumentations.h\"\n #include \"llvm/Support/Casting.h\"\n #include \"llvm/Support/TypeSize.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/GlobalDCE.h\"\n #include \"llvm/Transforms/IPO/SCCP.h\"\n@@ -61,9 +60,7 @@ limitations under the License.\n #include \"llvm/Transforms/Scalar/DCE.h\"\n #include \"llvm/Transforms/Scalar/EarlyCSE.h\"\n #include \"llvm/Transforms/Scalar/SCCP.h\"\n-#include \"llvm/Transforms/Utils/Cloning.h\"\n #include \"llvm/Transforms/Utils/ModuleUtils.h\"\n-#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n #include \"xla/codegen/intrinsic/erf.h\"\n #include \"xla/codegen/intrinsic/exp.h\"\n #include \"xla/codegen/intrinsic/fptrunc.h\"\n@@ -75,7 +72,6 @@ limitations under the License.\n #include \"xla/codegen/intrinsic/tanh.h\"\n #include \"xla/codegen/intrinsic/type.h\"\n #include \"xla/codegen/intrinsic/vec_name_mangler.h\"\n-#include \"xla/codegen/intrinsic_function.h\"\n #include \"xla/service/llvm_ir/llvm_util.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -147,16 +143,8 @@ class IntrinsicAdapter : public IntrinsicFunction {\n   }\n };\n \n-IntrinsicFunctionLib::IntrinsicFunctionLib(const IntrinsicOptions& options)\n+IntrinsicFunctionLib::IntrinsicFunctionLib(IntrinsicOptions options)\n     : options_(options) {\n-  if (options.device_type == intrinsics::DeviceType::kIntelCpu ||\n-      options.device_type == intrinsics::DeviceType::kAmdCpu ||\n-      options.device_type == intrinsics::DeviceType::kArmCpu) {\n-    auto eigen_lib = std::make_unique<CppGenIntrinsicLibrary>(\n-        GetCppGenIrString(options), \"eigen\");\n-    ir_libraries_.push_back(std::move(eigen_lib));\n-  }\n-\n   intrinsic_functions_.push_back(\n       std::make_unique<IntrinsicAdapter<intrinsics::Ldexp>>());\n   intrinsic_functions_.push_back(\n@@ -229,12 +217,10 @@ std::vector<llvm::VecDesc> IntrinsicFunctionLib::Vectorizations() {\n   for (const auto& math_func : intrinsic_functions_) {\n     // For each floating point type supported, we add all vector widths to every\n     // other vector width as a possible vectorization.\n-    std::vector<std::vector<Type>> supported_types =\n-        math_func->SupportedVectorTypes(options_.features);\n-    for (int i = 0; i < supported_types.size(); ++i) {\n-      const std::vector<Type>& target_types = supported_types[i];\n-      for (int j = 0; j < supported_types.size(); ++j) {\n-        const std::vector<Type>& vector_types = supported_types[j];\n+    for (const auto& target_types :\n+         math_func->SupportedVectorTypes(options_.features)) {\n+      for (const auto& vector_types :\n+           math_func->SupportedVectorTypes(options_.features)) {\n         if (!ElementTypesMatch(target_types, vector_types) ||\n             target_types.front().is_vector()) {\n           continue;\n@@ -243,8 +229,6 @@ std::vector<llvm::VecDesc> IntrinsicFunctionLib::Vectorizations() {\n             math_func->GenerateVectorizedFunctionName(target_types));\n         absl::string_view vec_name = intrinsic::StringInterner::Get().Intern(\n             math_func->GenerateVectorizedFunctionName(vector_types));\n-        CHECK(targets_.find(vec_name) == targets_.end())\n-            << \"Duplicate implementations for \" << vec_name;\n         targets_[vec_name] = math_func->FunctionName();\n         if (target_name == vec_name) {\n           continue;\n@@ -291,21 +275,16 @@ void CreateDefinitionAndReplaceDeclaration(llvm::Module& module,\n \n absl::flat_hash_set<absl::string_view>\n IntrinsicFunctionLib::DefineIntrinsicFunctions(llvm::Module& module) {\n-  bool ir_libraries_linked = false;\n   // Find each called target function, generate the definition and insert it\n   // into the module.\n+  // Keep track of the function names we replaced so we can remove them from\n+  // llvm.compiler.used later.\n   absl::flat_hash_set<absl::string_view> replaced_functions;\n   for (const auto& [function_name, signatures] :\n        GetCalledApproximatableFunctions(module, targets_)) {\n     for (const auto& math_func : intrinsic_functions_) {\n       if (math_func->FunctionName() == function_name) {\n         for (const auto& signature : signatures) {\n-          if (!ir_libraries_linked) {\n-            for (const auto& lib : ir_libraries_) {\n-              lib->LinkIntoModule(module);\n-            }\n-          }\n-\n           CreateDefinitionAndReplaceDeclaration(module, signature, options_,\n                                                 *math_func);\n           replaced_functions.insert(signature);\n@@ -314,9 +293,8 @@ IntrinsicFunctionLib::DefineIntrinsicFunctions(llvm::Module& module) {\n     }\n   }\n \n-  CHECK(!llvm::verifyModule(module, &llvm::errs()))\n-      << \"Module is invalid after optimization\\n\"\n-      << llvm_ir::DumpToString(&module);\n+  CHECK(!llvm::verifyModule(module)) << \"Module is invalid after optimization\\n\"\n+                                     << llvm_ir::DumpToString(&module);\n   return replaced_functions;\n }\n "
        },
        {
            "sha": "2907dcc0badb85ba418572e030e195e722732a65",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.h",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -24,7 +24,6 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/IR/Module.h\"\n-#include \"xla/codegen/intrinsic/cpp/cpp_gen_intrinsics.h\"\n #include \"xla/codegen/intrinsic/intrinsic.h\"\n #include \"xla/codegen/intrinsic_function.h\"\n #include \"xla/xla_data.pb.h\"\n@@ -42,7 +41,7 @@ namespace xla::codegen {\n // Retains storage of the strings required for VecDescs in the instance.\n class IntrinsicFunctionLib {\n  public:\n-  explicit IntrinsicFunctionLib(const intrinsics::IntrinsicOptions& options);\n+  explicit IntrinsicFunctionLib(intrinsics::IntrinsicOptions options);\n \n   // Returns a vector of vectorization information for functions that have\n   // vectorized approximations. This enables LLVM vectorization\n@@ -63,7 +62,6 @@ class IntrinsicFunctionLib {\n   std::vector<std::unique_ptr<IntrinsicFunction>> intrinsic_functions_;\n   absl::flat_hash_map<absl::string_view, absl::string_view> targets_;\n   const intrinsics::IntrinsicOptions options_;\n-  std::vector<std::unique_ptr<CppGenIntrinsicLibrary>> ir_libraries_;\n };\n \n }  // namespace xla::codegen"
        },
        {
            "sha": "c25e038f6e884925886c844d76ede5ffa3639e17",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a8f13b34bdc9564a744a14bc5dc3b6ff58743847/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib_test.cc?ref=a8f13b34bdc9564a744a14bc5dc3b6ff58743847",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/strings/match.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n@@ -44,7 +45,7 @@ TEST(IntrinsicLibTest, ExpVectorizations) {\n   std::vector<llvm::VecDesc> vec_descs = lib.Vectorizations();\n   std::vector<std::string> vec_descs_str;\n   for (const auto& vec_desc : vec_descs) {\n-    if (vec_desc.getScalarFnName().starts_with(\"xla.exp\")) {\n+    if (absl::StrContains(vec_desc.getScalarFnName().str(), \"xla.exp\")) {\n       vec_descs_str.push_back(ToString(vec_desc));\n     }\n   }\n@@ -54,6 +55,7 @@ TEST(IntrinsicLibTest, ExpVectorizations) {\n                                  \"xla.exp.f64:xla.exp.v4f64:4:_ZGV_LLVM_N4v\",\n                                  \"xla.exp.f64:xla.exp.v8f64:8:_ZGV_LLVM_N8v\"));\n }\n+\n }  // namespace\n \n }  // namespace xla::codegen::intrinsics"
        }
    ],
    "stats": {
        "total": 453,
        "additions": 52,
        "deletions": 401
    }
}