{
    "author": "WillFroom",
    "message": "[XLA:CPU/GPU] Check that values are scalars before casting in ExpandFloatOpsPass.\n\nPiperOrigin-RevId: 833242551",
    "sha": "bca597caa1d6087e890e9babb62975fc378e4189",
    "files": [
        {
            "sha": "d2283480a1b37228eb6e0170629b91cc31acaaf0",
            "filename": "third_party/xla/xla/codegen/emitters/transforms/expand_float_ops.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 3,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bca597caa1d6087e890e9babb62975fc378e4189/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fexpand_float_ops.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bca597caa1d6087e890e9babb62975fc378e4189/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fexpand_float_ops.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fexpand_float_ops.cc?ref=bca597caa1d6087e890e9babb62975fc378e4189",
            "patch": "@@ -505,6 +505,11 @@ struct RewriteTruncFPattern : public mlir::OpRewritePattern<ma::TruncFOp> {\n   mlir::LogicalResult matchAndRewrite(\n       ma::TruncFOp op, mlir::PatternRewriter& rewriter) const override {\n     using FloatValue = mlir::TypedValue<mlir::FloatType>;\n+\n+    if (!op.getType().isFloat()) {\n+      return rewriter.notifyMatchFailure(op, \"not a scalar float\");\n+    }\n+\n     auto src = mlir::cast<FloatValue>(op.getOperand());\n     auto dst_ty = mlir::cast<mlir::FloatType>(op.getType());\n     if (dst_ty.getWidth() > 8) {\n@@ -523,6 +528,11 @@ struct RewriteExtFPattern : public mlir::OpRewritePattern<ma::ExtFOp> {\n   mlir::LogicalResult matchAndRewrite(\n       ma::ExtFOp op, mlir::PatternRewriter& rewriter) const override {\n     using FloatValue = mlir::TypedValue<mlir::FloatType>;\n+\n+    if (!op.getType().isFloat()) {\n+      return rewriter.notifyMatchFailure(op, \"not a scalar float\");\n+    }\n+\n     auto src = mlir::cast<FloatValue>(op.getOperand());\n     auto dst_ty = mlir::cast<mlir::FloatType>(op.getType());\n     if (src.getType().getWidth() > 8) {\n@@ -541,6 +551,10 @@ struct RewriteF8Cst : public mlir::OpRewritePattern<ma::CmpFOp> {\n \n   mlir::LogicalResult matchAndRewrite(\n       ma::CmpFOp op, mlir::PatternRewriter& rewriter) const override {\n+    if (!op.getLhs().getType().isFloat()) {\n+      return rewriter.notifyMatchFailure(op, \"not a scalar cmpf\");\n+    }\n+\n     using FloatValue = mlir::TypedValue<mlir::FloatType>;\n     auto lhs = mlir::cast<FloatValue>(op.getLhs());\n     auto rhs = mlir::cast<FloatValue>(op.getRhs());\n@@ -584,7 +598,10 @@ struct RewriteAbsFPattern : public mlir::OpRewritePattern<mlir::math::AbsFOp> {\n   mlir::LogicalResult matchAndRewrite(\n       mlir::math::AbsFOp op, mlir::PatternRewriter& rewriter) const override {\n     using FloatValue = mlir::TypedValue<mlir::FloatType>;\n-    auto src = mlir::cast<FloatValue>(op.getOperand());\n+    auto src = mlir::dyn_cast<FloatValue>(op.getOperand());\n+    if (!src) {\n+      return rewriter.notifyMatchFailure(op, \"not a scalar float\");\n+    }\n     // LowerGpuOpsToNVVMOps has a lowering for abs that doesn't work with bf16.\n     // Once that's removed, remove the code for BF16 here.\n     if (src.getType().getWidth() > 8 && !src.getType().isBF16()) {\n@@ -615,7 +632,7 @@ struct RewriteIToFpPattern : public mlir::OpRewritePattern<Op> {\n \n   mlir::LogicalResult matchAndRewrite(\n       Op op, mlir::PatternRewriter& rewriter) const override {\n-    if (op.getType().getIntOrFloatBitWidth() > 8) {\n+    if (!op.getType().isFloat() || op.getType().getIntOrFloatBitWidth() > 8) {\n       return rewriter.notifyMatchFailure(op, \"not an f8 (or less) itofp\");\n     }\n     Value to_float =\n@@ -631,7 +648,8 @@ struct RewriteFpToIPattern : public mlir::OpRewritePattern<Op> {\n \n   mlir::LogicalResult matchAndRewrite(\n       Op op, mlir::PatternRewriter& rewriter) const override {\n-    if (op.getIn().getType().getIntOrFloatBitWidth() > 8) {\n+    if (!op.getIn().getType().isFloat() ||\n+        op.getIn().getType().getIntOrFloatBitWidth() > 8) {\n       return rewriter.notifyMatchFailure(op, \"not an f8 (or less) fptoi\");\n     }\n     Value to_f32 = rewriter.create<ma::ExtFOp>("
        }
    ],
    "stats": {
        "total": 24,
        "additions": 21,
        "deletions": 3
    }
}