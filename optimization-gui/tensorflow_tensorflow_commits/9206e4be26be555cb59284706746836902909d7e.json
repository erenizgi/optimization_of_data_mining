{
    "author": "akuegel",
    "message": "[XLA:GPU] Add a pass to convert sorts into scatter if possible.\n\nThis optimizes a pattern where essentially an inverse permutation needs to be\ncomputed, which is more efficient to do on GPU via scatter.\n\nPiperOrigin-RevId: 841607051",
    "sha": "9206e4be26be555cb59284706746836902909d7e",
    "files": [
        {
            "sha": "f175a711fa1e576db6aa8e1fc533adbe4b638c7f",
            "filename": "third_party/xla/xla/hlo/transforms/expanders/BUILD",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2FBUILD?ref=9206e4be26be555cb59284706746836902909d7e",
            "patch": "@@ -371,6 +371,35 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"permutation_sort_expander\",\n+    srcs = [\"permutation_sort_expander.cc\"],\n+    hdrs = [\"permutation_sort_expander.h\"],\n+    deps = [\n+        \":op_expander_pass\",\n+        \"//xla:comparison_util\",\n+        \"//xla:literal_util\",\n+        \"//xla:shape_util\",\n+        \"//xla:util\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"permutation_sort_expander_test\",\n+    srcs = [\"permutation_sort_expander_test.cc\"],\n+    deps = [\n+        \":permutation_sort_expander\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/utils:hlo_matchers\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"reshape_decomposer\",\n     srcs = [\"reshape_decomposer.cc\"],"
        },
        {
            "sha": "5af2a3e00566794b31da377fe98695d43ea685fc",
            "filename": "third_party/xla/xla/hlo/transforms/expanders/permutation_sort_expander.cc",
            "status": "added",
            "additions": 166,
            "deletions": 0,
            "changes": 166,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander.cc?ref=9206e4be26be555cb59284706746836902909d7e",
            "patch": "@@ -0,0 +1,166 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/transforms/expanders/permutation_sort_expander.h\"\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"xla/comparison_util.h\"\n+#include \"xla/hlo/ir/hlo_casting_utils.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_instructions.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/literal_util.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/shape_util.h\"\n+\n+namespace xla {\n+namespace {\n+bool IsSimpleLessThanComparator(HloComputation* compare) {\n+  HloInstruction* root = compare->root_instruction();\n+  if (HloPredicateIsNotOp<HloOpcode::kCompare>(root)) {\n+    return false;\n+  }\n+  if (root->comparison_direction() != ComparisonDirection::kLt) {\n+    return false;\n+  }\n+  return root->operand(0) == compare->parameter_instruction(0) &&\n+         root->operand(1) == compare->parameter_instruction(1);\n+}\n+}  // namespace\n+\n+bool PermutationSortExpander::InstructionMatchesPattern(\n+    HloInstruction* instruction) {\n+  if (HloPredicateIsNotOp<HloOpcode::kSort>(instruction)) {\n+    return false;\n+  }\n+  if (!IsSimpleLessThanComparator(instruction->to_apply())) {\n+    return false;\n+  }\n+  const HloInstruction* sort_key = instruction->operand(0);\n+  int64_t dimension_to_sort = instruction->dimensions(0);\n+  if (instruction->operand_count() == 2 &&\n+      HloPredicateIsOp<HloOpcode::kGetTupleElement>(sort_key)) {\n+    const HloInstruction* other_sort = sort_key->operand(0);\n+    // Check whether the 'values' parameter is the result of another sort with\n+    // the same sort dimension.\n+    if (HloPredicateIsOp<HloOpcode::kSort>(other_sort) &&\n+        other_sort->operand_count() >= 2 &&\n+        other_sort->dimensions(0) == dimension_to_sort &&\n+        HloPredicateIsOp<HloOpcode::kIota>(\n+            other_sort->operand(sort_key->tuple_index()))) {\n+      auto* iota = Cast<HloIotaInstruction>(\n+          other_sort->operand(sort_key->tuple_index()));\n+      // The sort operand needs to be an integral iota, and the iota dimension\n+      // needs to be the dimension that was sorted.\n+      return iota->iota_dimension() == dimension_to_sort &&\n+             ShapeUtil::ElementIsIntegral(iota->shape());\n+    }\n+  }\n+  return false;\n+}\n+\n+absl::StatusOr<HloInstruction*> PermutationSortExpander::ExpandInstruction(\n+    HloInstruction* instruction) {\n+  // We use the following construction method for a Scatter that applies\n+  // the permutation from `keys` to the `values` parameter.\n+  // - Set updates of the scatter to be a reshaped `values` parameter of sort\n+  //   (adding `rank` many 1 dimensions at the end).\n+  // - Take the `keys` parameter of the second sort and reshape it to have\n+  //   another `1` dimension at the end. This is the permutation we want to\n+  //   apply in the `dimension_to_sort` dimension.\n+  // - We want to create scatter indices such that the most minor dimension\n+  //   represents the indices in order from most major to most minor where the\n+  //   scatter updates should be stored. This can be done with a concatenate of\n+  //   iotas with different iota dimensions, except the index that corresponds\n+  //   to the dimension to sort. For that we will use the reshaped `keys`\n+  //   parameter. E.g. with rank 3 and dimension_to_sort = 1, we would have\n+  //   concatenate of (iota with iota_dimension=0, keys, iota with\n+  //   iota_dimension = 2).\n+  int64_t dimension_to_sort = instruction->dimensions(0);\n+  HloInstruction* sort_key = instruction->mutable_operand(0);\n+  int rank = static_cast<int>(sort_key->shape().dimensions().size());\n+  Shape extended_shape = sort_key->shape();\n+  ShapeUtil::AppendMinorDimension(1, &extended_shape);\n+  HloInstruction* reshaped_permutation = instruction->AddInstruction(\n+      HloInstruction::CreateReshape(extended_shape, sort_key));\n+  std::vector<HloInstruction*> concat_operands;\n+  concat_operands.reserve(rank);\n+  for (int64_t i = 0; i < rank; ++i) {\n+    if (i == dimension_to_sort) {\n+      concat_operands.push_back(reshaped_permutation);\n+    } else {\n+      concat_operands.push_back(instruction->AddInstruction(\n+          HloInstruction::CreateIota(extended_shape, i)));\n+    }\n+  }\n+  Shape concat_shape = sort_key->shape();\n+  ShapeUtil::AppendMinorDimension(rank, &concat_shape);\n+  HloInstruction* scatter_indices =\n+      rank > 1 ? instruction->AddInstruction(HloInstruction::CreateConcatenate(\n+                     concat_shape, concat_operands, rank))\n+               : reshaped_permutation;\n+\n+  // We don't care about the operand, it will be completely overridden by\n+  // the updates. Initialize it to zero.\n+  HloInstruction* values = instruction->mutable_operand(1);\n+  Shape update_shape = values->shape();\n+  HloInstruction* zero =\n+      instruction->AddInstruction(HloInstruction::CreateConstant(\n+          LiteralUtil::Zero(update_shape.element_type())));\n+  HloInstruction* scatter_operand =\n+      instruction->AddInstruction(HloInstruction::CreateBroadcast(\n+          update_shape, zero, /*broadcast_dimensions=*/{}));\n+\n+  // Construct the updates operand of scatter.\n+  for (int64_t i = 0; i < rank; ++i) {\n+    ShapeUtil::AppendMinorDimension(1, &update_shape);\n+  }\n+  HloInstruction* scatter_updates = instruction->AddInstruction(\n+      HloInstruction::CreateReshape(update_shape, values));\n+\n+  // Construct the updates computation, which simply replaces the operand\n+  // values with the update values.\n+  HloComputation::Builder b(\"update_replace_computation\");\n+  Shape scalar_shape = ShapeUtil::MakeShape(S32, {});\n+  b.AddInstruction(\n+      HloInstruction::CreateParameter(0, scalar_shape, \"scalar_lhs\"));\n+  HloInstruction* scalar_rhs = b.AddInstruction(\n+      HloInstruction::CreateParameter(1, scalar_shape, \"scalar_rhs\"));\n+  HloComputation* update_replace_computation =\n+      instruction->parent()->parent()->AddEmbeddedComputation(\n+          b.Build(scalar_rhs));\n+\n+  ScatterDimensionNumbers dim_numbers;\n+  dim_numbers.set_index_vector_dim(rank);\n+  for (int64_t i = 0; i < rank; ++i) {\n+    dim_numbers.add_update_window_dims(rank + i);\n+    dim_numbers.add_scatter_dims_to_operand_dims(i);\n+  }\n+  HloInstruction* scatter =\n+      instruction->AddInstruction(HloInstruction::CreateScatter(\n+          values->shape(), scatter_operand, scatter_indices, scatter_updates,\n+          update_replace_computation, dim_numbers,\n+          /*indices_are_sorted=*/false, /*unique_indices=*/true));\n+  return instruction->AddInstruction(HloInstruction::CreateTuple(\n+      {instruction->AddInstruction(\n+           HloInstruction::CreateIota(sort_key->shape(), dimension_to_sort)),\n+       scatter}));\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "70face3a8e9e30511c56da8266d5317e1e6b7d1b",
            "filename": "third_party/xla/xla/hlo/transforms/expanders/permutation_sort_expander.h",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander.h?ref=9206e4be26be555cb59284706746836902909d7e",
            "patch": "@@ -0,0 +1,51 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_HLO_TRANSFORMS_EXPANDERS_PERMUTATION_SORT_EXPANDER_H_\n+#define XLA_HLO_TRANSFORMS_EXPANDERS_PERMUTATION_SORT_EXPANDER_H_\n+\n+#include <utility>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/transforms/expanders/op_expander_pass.h\"\n+#include \"xla/util.h\"\n+\n+namespace xla {\n+\n+// Replaces key-value sorts where the key operand can be proved to contain\n+// unordered indices between 0 and sort dimension size - 1. Such patterns\n+// compute the inverse permutation, which can be done more efficiently using\n+// Scatter.\n+class PermutationSortExpander : public OpExpanderPass {\n+ public:\n+  explicit PermutationSortExpander(HloPredicate extra_filter = nullptr)\n+      : OpExpanderPass(std::move(extra_filter)) {}\n+\n+  absl::string_view name() const override {\n+    return \"permutation_sort_simplifier\";\n+  }\n+\n+ protected:\n+  bool InstructionMatchesPattern(HloInstruction* instruction) override;\n+\n+  absl::StatusOr<HloInstruction*> ExpandInstruction(\n+      HloInstruction* instruction) override;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_HLO_TRANSFORMS_EXPANDERS_PERMUTATION_SORT_EXPANDER_H_"
        },
        {
            "sha": "0351221da62b0dc0644c413ff64382e294507c8e",
            "filename": "third_party/xla/xla/hlo/transforms/expanders/permutation_sort_expander_test.cc",
            "status": "added",
            "additions": 206,
            "deletions": 0,
            "changes": 206,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fexpanders%2Fpermutation_sort_expander_test.cc?ref=9206e4be26be555cb59284706746836902909d7e",
            "patch": "@@ -0,0 +1,206 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/transforms/expanders/permutation_sort_expander.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status_matchers.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/utils/hlo_matchers.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+namespace op = xla::testing::opcode_matchers;\n+\n+using ::absl_testing::IsOkAndHolds;\n+using PermutationSortExpanderTest = HloHardwareIndependentTestBase;\n+\n+TEST_F(PermutationSortExpanderTest, ReplacePermutationSortWithScatter) {\n+  const char* hlo_string = R\"(\n+    HloModule permutation_sort\n+\n+    lt_f32 {\n+      p.0.lhs = f32[] parameter(0)\n+      p.0.rhs = f32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT, type=TOTALORDER\n+    }\n+\n+    lt_s32 {\n+      p.0.lhs = s32[] parameter(0)\n+      p.0.rhs = s32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT\n+    }\n+\n+    ENTRY sort_computation {\n+      keys = f32[64,8732]{1,0} parameter(0)\n+      values = s32[64,8732]{1,0} iota(), iota_dimension=1\n+      sort = (f32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(keys, values), dimensions={1}, to_apply=lt_f32\n+      gte = s32[64,8732]{1,0} get-tuple-element(sort), index=1\n+      ROOT sort2 = (s32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(gte, values), dimensions={1}, to_apply=lt_s32\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  EXPECT_THAT(PermutationSortExpander().Run(module.get()), IsOkAndHolds(true));\n+  auto root = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(root,\n+              op::Tuple(op::Iota(),\n+                        op::Scatter(op::Broadcast(op::Constant()),\n+                                    op::Concatenate(op::Iota(), op::Reshape()),\n+                                    op::Reshape())));\n+}\n+\n+TEST_F(PermutationSortExpanderTest, DontReplaceIfWrongComparisonDirection) {\n+  const char* hlo_string = R\"(\n+    HloModule permutation_sort\n+\n+    lt_f32 {\n+      p.0.lhs = f32[] parameter(0)\n+      p.0.rhs = f32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT, type=TOTALORDER\n+    }\n+\n+    lt_s32 {\n+      p.0.lhs = s32[] parameter(0)\n+      p.0.rhs = s32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=GT\n+    }\n+\n+    ENTRY sort_computation {\n+      keys = f32[64,8732]{1,0} parameter(0)\n+      values = s32[64,8732]{1,0} iota(), iota_dimension=1\n+      sort = (f32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(keys, values), dimensions={1}, to_apply=lt_f32\n+      gte = s32[64,8732]{1,0} get-tuple-element(sort), index=1\n+      ROOT sort2 = (s32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(gte, values), dimensions={1}, to_apply=lt_s32\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  EXPECT_THAT(PermutationSortExpander().Run(module.get()), IsOkAndHolds(false));\n+}\n+\n+TEST_F(PermutationSortExpanderTest, DontReplaceIfComparingWrongParameters) {\n+  const char* hlo_string = R\"(\n+    HloModule permutation_sort\n+\n+    lt_f32 {\n+      p.0.lhs = f32[] parameter(0)\n+      p.0.rhs = f32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT, type=TOTALORDER\n+    }\n+\n+    lt_s32 {\n+      p.0.lhs = s32[] parameter(0)\n+      p.0.rhs = s32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.rhs, p.0.lhs), direction=LT\n+    }\n+\n+    ENTRY sort_computation {\n+      keys = f32[64,8732]{1,0} parameter(0)\n+      values = s32[64,8732]{1,0} iota(), iota_dimension=1\n+      sort = (f32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(keys, values), dimensions={1}, to_apply=lt_f32\n+      gte = s32[64,8732]{1,0} get-tuple-element(sort), index=1\n+      ROOT sort2 = (s32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(gte, values), dimensions={1}, to_apply=lt_s32\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  EXPECT_THAT(PermutationSortExpander().Run(module.get()), IsOkAndHolds(false));\n+}\n+\n+TEST_F(PermutationSortExpanderTest, DontReplacePermutationSortIfNonIntegral) {\n+  // Same as ReplacePermutationSortWithScatter except that the iota has F32\n+  // type.\n+  const char* hlo_string = R\"(\n+    HloModule permutation_sort\n+\n+    lt_f32 {\n+      p.0.lhs = f32[] parameter(0)\n+      p.0.rhs = f32[] parameter(1)\n+      p.1.lhs = f32[] parameter(2)\n+      p.1.rhs = f32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT, type=TOTALORDER\n+    }\n+\n+    ENTRY sort_computation {\n+      keys = f32[64,8732]{1,0} parameter(0)\n+      values = f32[64,8732]{1,0} iota(), iota_dimension=1\n+      sort = (f32[64,8732]{1,0}, f32[64,8732]{1,0}) sort(keys, values), dimensions={1}, to_apply=lt_f32\n+      gte = f32[64,8732]{1,0} get-tuple-element(sort), index=1\n+      ROOT sort2 = (f32[64,8732]{1,0}, f32[64,8732]{1,0}) sort(gte, values), dimensions={1}, to_apply=lt_f32\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  EXPECT_THAT(PermutationSortExpander().Run(module.get()), IsOkAndHolds(false));\n+}\n+\n+TEST_F(PermutationSortExpanderTest, DontReplacePermutationSortWrongDimensions) {\n+  // Same as ReplacePermutationSortWithScatter except that the sort dimensions\n+  // don't match.\n+  const char* hlo_string = R\"(\n+   HloModule permutation_sort\n+\n+    lt_f32 {\n+      p.0.lhs = f32[] parameter(0)\n+      p.0.rhs = f32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT, type=TOTALORDER\n+    }\n+\n+    lt_s32 {\n+      p.0.lhs = s32[] parameter(0)\n+      p.0.rhs = s32[] parameter(1)\n+      p.1.lhs = s32[] parameter(2)\n+      p.1.rhs = s32[] parameter(3)\n+      ROOT lt = pred[] compare(p.0.lhs, p.0.rhs), direction=LT\n+    }\n+\n+    ENTRY sort_computation {\n+      keys = f32[64,8732]{1,0} parameter(0)\n+      values = s32[64,8732]{1,0} iota(), iota_dimension=1\n+      sort = (f32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(keys, values), dimensions={1}, to_apply=lt_f32\n+      gte = s32[64,8732]{1,0} get-tuple-element(sort), index=1\n+      ROOT sort2 = (s32[64,8732]{1,0}, s32[64,8732]{1,0}) sort(gte, values), dimensions={0}, to_apply=lt_s32\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  EXPECT_THAT(PermutationSortExpander().Run(module.get()), IsOkAndHolds(false));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        },
        {
            "sha": "038abc6f3c5dd63fef30e2a300fd7a3db72af0e7",
            "filename": "third_party/xla/xla/service/gpu/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD?ref=9206e4be26be555cb59284706746836902909d7e",
            "patch": "@@ -1656,6 +1656,7 @@ cc_library(\n         \"//xla/hlo/transforms/expanders:eigh_expander\",\n         \"//xla/hlo/transforms/expanders:logistic_expander\",\n         \"//xla/hlo/transforms/expanders:optimization_barrier_expander\",\n+        \"//xla/hlo/transforms/expanders:permutation_sort_expander\",\n         \"//xla/hlo/transforms/expanders:qr_expander\",\n         \"//xla/hlo/transforms/expanders:ragged_dot_rewriter\",\n         \"//xla/hlo/transforms/expanders:real_imag_expander\","
        },
        {
            "sha": "55c74ba56d3ecb74bb58af41372768b8e8b0b80c",
            "filename": "third_party/xla/xla/service/gpu/gpu_compiler.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9206e4be26be555cb59284706746836902909d7e/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc?ref=9206e4be26be555cb59284706746836902909d7e",
            "patch": "@@ -97,6 +97,7 @@ limitations under the License.\n #include \"xla/hlo/transforms/expanders/eigh_expander.h\"\n #include \"xla/hlo/transforms/expanders/logistic_expander.h\"\n #include \"xla/hlo/transforms/expanders/optimization_barrier_expander.h\"\n+#include \"xla/hlo/transforms/expanders/permutation_sort_expander.h\"\n #include \"xla/hlo/transforms/expanders/qr_expander.h\"\n #include \"xla/hlo/transforms/expanders/ragged_dot_rewriter.h\"\n #include \"xla/hlo/transforms/expanders/real_imag_expander.h\"\n@@ -607,6 +608,11 @@ absl::Status RunOptimizationPasses(\n   pipeline.AddPass<RngExpander>();\n   pipeline.AddPass<RngBitGeneratorExpander>(RandomAlgorithm::RNG_PHILOX);\n \n+  // Replaces sort with scatter where possible. Needs to run before\n+  // SortRewriter, as this rewrite is even more efficient than what SortRewriter\n+  // would do.\n+  pipeline.AddPass<PermutationSortExpander>();\n+\n   // SortRewriter needs to ask the device how much scratch space is needed,\n   // which isn't feasible if we don't have a device.\n   if (hlo_module->config().debug_options().xla_gpu_enable_cub_radix_sort()) {"
        }
    ],
    "stats": {
        "total": 459,
        "additions": 459,
        "deletions": 0
    }
}