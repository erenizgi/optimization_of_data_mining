{
    "author": "qukhan",
    "message": "Improve Fast Walsh Hadamard Transform implementation performance.\n\nA template implementation with static bounds for the FWHT lets the compiler\nbetter unroll the case for which the array to compute the transform on is\nlarge enough.\n\nChanged the small cases implementation to a template holding static sizes to\nallow the compiler to unroll these loops more aggressively.\n\n| **Cloudtop**  |        |    Time | Speedup |  |    Time | Speedup |  |    Time | Speedup |  |     Time | Speedup |\n|---------------|-------:|--------:|--------:|--|--------:|--------:|--|--------:|--------:|--|---------:|--------:|\n| Base          |        | 28,6 ns |         |  | 36,7 ns |         |  |  727 ns |         |  |  8112 ns |         |\n| Static unroll | by 16  | 24,8 ns |  x 1,15 |  | 23,8 ns |  x 1,54 |  |  471 ns |  x 1,54 |  |  5612 ns |  x 1,45 |\n|               | by 32  | 18,6 ns |  x 1,54 |  | 31,2 ns |  x 1,18 |  |  457 ns |  x 1,59 |  |  5489 ns |  x 1,48 |\n|               | by 64  | 18,5 ns |  x 1,55 |  | 31,2 ns |  x 1,18 |  |  216 ns |  x 3,37 |  |  1982 ns |  x 4,09 |\n|               | by 128 | 23,6 ns |  x 1,21 |  | 41,4 ns |  x 0,89 |  |  212 ns |  x 3,43 |  |  1922 ns |  x 4,22 |\n|               | by 256 | 23,2 ns |  x 1,23 |  | 40,7 ns |  x 0,90 |  |  227 ns |  x 3,20 |  |  2111 ns |  x 3,84 |\n| Array size    |        |       8 |         |  |      16 |         |  |     256 |         |  |     2048 |         |\n\n| **Pixel 9**   |        |    Time | Speedup |  |    Time | Speedup |  |    Time | Speedup |  |     Time | Speedup |\n|---------------|-------:|--------:|--------:|--|--------:|--------:|--|--------:|--------:|--|---------:|--------:|\n| Base          |        | 17,8 ns |         |  | 95,8 ns |         |  | 1064 ns |         |  | 10484 ns |         |\n| Static unroll | by 16  | 18,5 ns |  x 0,96 |  | 46,2 ns |  x 2,07 |  | 1001 ns |  x 1,06 |  | 10274 ns |  x 1,02 |\n|               | by 32  | 17,4 ns |  x 1,02 |  | 35,9 ns |  x 2,67 |  | 1090 ns |  x 0,98 |  | 11030 ns |  x 0,95 |\n|               | by 64  | 17,6 ns |  x 1,01 |  | 42,1 ns |  x 2,28 |  |  781 ns |  x 1,36 |  |  8684 ns |  x 1,21 |\n|               | by 128 | 17,8 ns |  x 1,00 |  | 42,5 ns |  x 2,25 |  |  858 ns |  x 1,24 |  |  8959 ns |  x 1,17 |\n|               | by 256 | 17,8 ns |  x 1,00 |  | 37,2 ns |  x 2,58 |  |  783 ns |  x 1,36 |  |  8513 ns |  x 1,23 |\n| Array size    |        |       8 |         |  |      16 |         |  |     256 |         |  |     2048 |         |\n\nPiperOrigin-RevId: 804574721",
    "sha": "d0cb5ea0e95053e6f2591c414a1b290878014b8f",
    "files": [
        {
            "sha": "c103bb3839ea2773439f179f8a7e9a7472948381",
            "filename": "tensorflow/lite/kernels/hadamard_rotation.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 48,
            "changes": 101,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d0cb5ea0e95053e6f2591c414a1b290878014b8f/tensorflow%2Flite%2Fkernels%2Fhadamard_rotation.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d0cb5ea0e95053e6f2591c414a1b290878014b8f/tensorflow%2Flite%2Fkernels%2Fhadamard_rotation.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Flite%2Fkernels%2Fhadamard_rotation.cc?ref=d0cb5ea0e95053e6f2591c414a1b290878014b8f",
            "patch": "@@ -39,57 +39,66 @@ struct OpData {\n   std::vector<int> random_binary_vector;\n };\n \n-// Fast Walsh Hadamard Transform. Updates `data` in place.\n-void FWHTGeneral(float* data, int n, bool normalize) {\n-  if ((n & (n - 1)) != 0) {\n-    std::cerr << \"Error: Input size must be a power of 2.\" << std::endl;\n-    return;\n-  }\n-\n-  int h = 1;\n-  while (h < n) {\n-    for (int i = 0; i < n; i += h * 2) {\n-      for (int j = i; j < i + h; ++j) {\n-        float x = data[j];\n-        float y = data[j + h];\n+// FWHT implementation for fixed bounds.\n+//\n+// The compiler is capable of fully unrolling this, which gives much better\n+// performance.\n+template <size_t N, size_t H>\n+void FWHTStaticSize(float* data) {\n+  for (size_t h = H; h < N; h *= 2) {\n+    for (size_t i = 0; i < N; i += 2 * h) {\n+      for (size_t j = i; j < i + h; ++j) {\n+        const float x = data[j];\n+        const float y = data[j + h];\n         data[j] = x + y;\n         data[j + h] = x - y;\n       }\n     }\n-    h *= 2;\n-  }\n-  if (normalize) {\n-    // Calculate the inverse square root once.\n-    const float norm_factor = 1.0f / std::sqrt(static_cast<float>(n));\n-    for (int k = 0; k < n; ++k) {\n-      data[k] *= norm_factor;\n-    }\n   }\n }\n \n-// Same FWHT algorithm, with loops explicitly unrolled for sizes >= 16.\n+// Fast Walsh Hadamard Transform. Updates `data` in place.\n+template <size_t kUnrollThreshold = 64>\n void FWHTFast(float* data, int hadamard_size) {\n-  std::vector<float> output(hadamard_size);\n-  int num_chunks = hadamard_size / 16;\n-\n-  float* in = data;\n-  // Use general, iterative loops algorithm for sizes up to 16.\n-  for (int chunk = 0; chunk < num_chunks; ++chunk, in += 16) {\n-    FWHTGeneral(in, 16, false);\n+  if ((hadamard_size & (hadamard_size - 1)) != 0) {\n+    std::cerr << \"hadamard_size needs to be a power of 2\\n\";\n+    return;\n   }\n-  // Finish the bigger butterflies with explicit unrolling.\n-  for (int chunk_size = 16; chunk_size < hadamard_size; chunk_size *= 2) {\n-    float* in1 = &data[0];\n-    float* in2 = &data[chunk_size];\n-    for (int i = 0; i < hadamard_size;\n-         i += chunk_size * 2, in1 += chunk_size, in2 += chunk_size) {\n-      for (int j = i; j < i + chunk_size; j += 16) {\n-        // Compiler will unroll this fixed size loop easily.\n-        for (int k = 0; k < 16; k++) {\n-          float x = *in1;\n-          float y = *in2;\n-          *in1++ = x + y;\n-          *in2++ = x - y;\n+  if (hadamard_size < kUnrollThreshold) {\n+    // For small sizes, we run an \"unoptimized\" loop. This avoids unrolling the\n+    // loops for every valid size under kUnrollSize.\n+    for (size_t h = 1; h < hadamard_size; h *= 2) {\n+      for (size_t i = 0; i < hadamard_size; i += 2 * h) {\n+        for (size_t j = i; j < i + h; ++j) {\n+          const float x = data[j];\n+          const float y = data[j + h];\n+          data[j] = x + y;\n+          data[j + h] = x - y;\n+        }\n+      }\n+    }\n+  } else {\n+    const int num_chunks = hadamard_size / kUnrollThreshold;\n+    float* in = data;\n+    // Use general, iterative loops algorithm for sizes up to kUnrollLimit.\n+    for (int chunk = 0; chunk < num_chunks; ++chunk, in += kUnrollThreshold) {\n+      FWHTStaticSize<kUnrollThreshold, 1>(in);\n+    }\n+    // Finish the bigger butterflies manually.\n+    for (int chunk_size = kUnrollThreshold; chunk_size < hadamard_size;\n+         chunk_size *= 2) {\n+      float* in1 = &data[0];\n+      float* in2 = &data[chunk_size];\n+      for (int i = 0; i < hadamard_size;\n+           i += chunk_size * 2, in1 += chunk_size, in2 += chunk_size) {\n+        for (int j = i; j < i + chunk_size; j += kUnrollThreshold) {\n+          // Compiler will unroll this fixed size loop easily.\n+          for (int k = 0; k < kUnrollThreshold; k++) {\n+            float x = *in1;\n+            float y = *in2;\n+            *in1++ = x + y;\n+            *in2++ = x - y;\n+          }\n         }\n       }\n     }\n@@ -167,17 +176,13 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n \n   memcpy(output->data.f, input_tensor->data.f, input_tensor->bytes);\n \n-  int num_hadamards_per_feature = input_feature_size / hadamard_size;\n+  const int num_hadamards_per_feature = input_feature_size / hadamard_size;\n   const int total_transforms =\n       input_batch * input_features * num_hadamards_per_feature;\n   for (int i = 0; i < total_transforms; ++i) {\n     int chunk_start = i * hadamard_size;\n     // Update output->data.f in place.\n-    if (hadamard_size < 16) {\n-      FWHTGeneral(&output->data.f[chunk_start], hadamard_size, true);\n-    } else {\n-      FWHTFast(&output->data.f[chunk_start], hadamard_size);\n-    }\n+    FWHTFast(&output->data.f[chunk_start], hadamard_size);\n   }\n \n   return kTfLiteOk;"
        }
    ],
    "stats": {
        "total": 101,
        "additions": 53,
        "deletions": 48
    }
}