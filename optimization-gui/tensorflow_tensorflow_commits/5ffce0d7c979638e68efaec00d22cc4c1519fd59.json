{
    "author": "akuegel",
    "message": "[XLA:GPU] Fix bugs when sorting two elements with a fused iota.\n\nThe first bug was that we did not pass the right HloInstruction to EmitIota().\nThe second bug happens if the comparison determines that the two elements don't\nhave to be swapped. Then we would not write the computed iota into the output\nbuffer, as we only write elements if they need to be swapped.\n\nPiperOrigin-RevId: 846637328",
    "sha": "5ffce0d7c979638e68efaec00d22cc4c1519fd59",
    "files": [
        {
            "sha": "167eefc4256b7aa0f495f98f3951a2a68f04c059",
            "filename": "third_party/xla/xla/backends/gpu/codegen/llvm/sort_util.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 8,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ffce0d7c979638e68efaec00d22cc4c1519fd59/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fllvm%2Fsort_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ffce0d7c979638e68efaec00d22cc4c1519fd59/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fllvm%2Fsort_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fllvm%2Fsort_util.cc?ref=5ffce0d7c979638e68efaec00d22cc4c1519fd59",
            "patch": "@@ -73,7 +73,7 @@ absl::Status EmitCompareLoopBody(\n     std::function<void(int64_t operand, llvm::Value* index, llvm::Value* value)>\n         write_element,\n     const EmitCallToNestedComputationCallback& emit_compare_callback,\n-    llvm::IRBuilderBase* b, bool needs_bounds_checks = true) {\n+    llvm::IRBuilderBase* b, bool force_write, bool needs_bounds_checks = true) {\n   auto index_typed_constant = [&](int64_t value) {\n     return llvm::ConstantInt::get(index_type, value);\n   };\n@@ -211,7 +211,18 @@ absl::Status EmitCompareLoopBody(\n           llvm::Value* is_smaller_than = b->CreateICmpNE(\n               result, llvm::ConstantInt::get(result->getType(), 0),\n               \"boolean_predicate\");\n-          ksl.If(\"is_smaller_than\", is_smaller_than, [&]() {\n+          auto write_original_order = [&]() {\n+            for (int64_t i = 0; i < num_values; ++i) {\n+              // Don't swap the values.\n+              auto value1 = b->CreateLoad(values_to_compare_types[i * 2],\n+                                          values_to_compare[i * 2]);\n+              auto value2 = b->CreateLoad(values_to_compare_types[i * 2 + 1],\n+                                          values_to_compare[i * 2 + 1]);\n+              write_element(i, current_keys_index, value2);\n+              write_element(i, compare_keys_index, value1);\n+            }\n+          };\n+          auto write_swapped_order = [&]() {\n             for (int64_t i = 0; i < num_values; ++i) {\n               // Swap the values.\n               auto value1 = b->CreateLoad(values_to_compare_types[i * 2],\n@@ -221,7 +232,18 @@ absl::Status EmitCompareLoopBody(\n               write_element(i, current_keys_index, value1);\n               write_element(i, compare_keys_index, value2);\n             }\n-          });\n+          };\n+          if (force_write) {\n+            // If we don't use shared memory, we have to make sure that values\n+            // that were emitted as part of the first iteration get written to\n+            // global memory, even if the comparison determined that no swap is\n+            // necessary.\n+            ksl.If(\"is_smaller_than\", is_smaller_than, write_swapped_order,\n+                   write_original_order);\n+          } else {\n+            ksl.If(\"is_smaller_than\", is_smaller_than, write_swapped_order);\n+          }\n+\n           return absl::OkStatus();\n         }));\n   }\n@@ -359,22 +381,22 @@ absl::Status EmitTiledCompareLoop(\n                 unroll_factor / 2, params.size(), element_pair_index, xor_mask,\n                 tiled_keys_index.GetType(), element_address,\n                 element_address_pointee_type, write_element,\n-                emit_compare_callback, b);\n+                emit_compare_callback, b, /*force_write=*/false);\n           },\n           [&]() {\n             return EmitCompareLoopBody(\n                 tile_size, num_threads, unroll_factor / 2, params.size(),\n                 element_pair_index, xor_mask, tiled_keys_index.GetType(),\n                 element_address, element_address_pointee_type, write_element,\n-                emit_compare_callback, b,\n+                emit_compare_callback, b, /*force_write=*/false,\n                 /*needs_bounds_checks=*/false);\n           }));\n     } else {\n       RETURN_IF_ERROR(EmitCompareLoopBody(\n           tile_size, num_threads, unroll_factor / 2, params.size(),\n           element_pair_index, xor_mask, tiled_keys_index.GetType(),\n           element_address, element_address_pointee_type, write_element,\n-          emit_compare_callback, b,\n+          emit_compare_callback, b, /*force_write=*/false,\n           /*needs_bounds_checks=*/false));\n     }\n     // Wait until all comparisons have happened.\n@@ -506,7 +528,8 @@ absl::Status EmitSortInPlace(\n         llvm::Value* element;\n         if (emit_iota_operands &&\n             HloPredicateIsOp<HloOpcode::kIota>(sort->operand(operand))) {\n-          ASSIGN_OR_RETURN(element, EmitIota(sort, keys_index, module, b));\n+          ASSIGN_OR_RETURN(\n+              element, EmitIota(sort->operand(operand), keys_index, module, b));\n         } else {\n           if (!primitive_util::IsSubByteNonPredType(element_type)) {\n             return values_arrays[operand].EmitArrayElementAddress(keys_index,\n@@ -536,7 +559,8 @@ absl::Status EmitSortInPlace(\n           dimension_to_sort_bound, /*num_threads=*/1, unroll_factor / 2,\n           values_arrays.size(), tiles_index[rank - 1], xor_masks[0],\n           tiles_index.GetType(), element_address, element_address_pointee_type,\n-          write_element, emit_compare_callback, b));\n+          write_element, emit_compare_callback, b,\n+          /*force_write=*/emit_iota_operands));\n     }\n     return absl::OkStatus();\n   };"
        },
        {
            "sha": "130a1eb950b0b51373a5eb5ef28242e7a87ce8a7",
            "filename": "third_party/xla/xla/service/gpu/tests/sorting_test.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ffce0d7c979638e68efaec00d22cc4c1519fd59/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fsorting_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ffce0d7c979638e68efaec00d22cc4c1519fd59/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fsorting_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fsorting_test.cc?ref=5ffce0d7c979638e68efaec00d22cc4c1519fd59",
            "patch": "@@ -176,6 +176,36 @@ TEST_F(SortingTest, SortFusionWithIotaOperand) {\n   EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text, ErrorSpec{1e-5, 1e-5}));\n }\n \n+TEST_F(SortingTest, SortFusionWithIotaOperandTinySortDim) {\n+  const char* hlo_text = R\"(\n+    HloModule module\n+\n+    sorting_computation {\n+      %lhs_key = s32[] parameter(0)\n+      %rhs_key = s32[] parameter(1)\n+      %lhs_index = s32[] parameter(2)\n+      %rhs_index = s32[] parameter(3)\n+      %lt_key = pred[] compare(%lhs_key, %rhs_key), direction=LT\n+      %gt_key = pred[] compare(%rhs_key, %lhs_key), direction=LT\n+      %eq_key = pred[] compare(%lt_key, %gt_key), direction=EQ\n+      %lt_index = pred[] compare(%lhs_index, %rhs_index), direction=LT\n+      ROOT res = pred[] select(%eq_key, %lt_index, %lt_key)\n+    }\n+\n+    sort_fusion {\n+      p0 = s32[2]{0} parameter(0)\n+      iota = s32[2]{0} iota(), iota_dimension=0\n+      ROOT sort = (s32[2]{0}, s32[2]{0}) sort(p0, iota), dimensions={0}, is_stable=true, to_apply=sorting_computation\n+    }\n+\n+    ENTRY main {\n+      p = s32[2]{0} parameter(0)\n+      ROOT fusion = (s32[2]{0}, s32[2]{0}) fusion(p), kind=kInput, calls=sort_fusion\n+    }\n+  )\";\n+  EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text, ErrorSpec{1e-5, 1e-5}));\n+}\n+\n // Test that verifies the IgnoreMemorySpace option works correctly\n TEST_F(SortingTest, LayoutsInShapesEqualWithIgnoreMemorySpace) {\n   const char* hlo_text = R\"("
        }
    ],
    "stats": {
        "total": 70,
        "additions": 62,
        "deletions": 8
    }
}