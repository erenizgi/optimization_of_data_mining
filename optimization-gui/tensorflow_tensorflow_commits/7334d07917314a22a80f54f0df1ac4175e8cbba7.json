{
    "author": "unknown",
    "message": "[XLA:GPU] Add check_thunk_result_consistency tool for verifying checksum consistency\n\nWhen implementing this it turned out that the log is currently missing some information needed to reliably distinguish input/output checksums and different thunk executions. This adds the needed fields to the proto, but emitting them in the log will be a separate change.\n\nWith the extra data missing, the tool assumes all checksums refer to outputs, and each thunk execution is going to give the same results each time. The tests include the extra data, so once that's implement it should(TM) just work.\n\nPiperOrigin-RevId: 825040798",
    "sha": "7334d07917314a22a80f54f0df1ac4175e8cbba7",
    "files": [
        {
            "sha": "b6ecc208191a0ff25f59cb209a2dc296ba391543",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -1,6 +1,6 @@\n load(\"@local_config_cuda//cuda:build_defs.bzl\", \"cuda_library\")\n load(\"@rules_cc//cc:cc_library.bzl\", \"cc_library\")\n-load(\"//xla:xla.default.bzl\", \"xla_cc_test\", \"xla_internal\")\n+load(\"//xla:xla.default.bzl\", \"xla_cc_test\", \"xla_internal\", \"xla_py_proto_library\")\n load(\"//xla/tests:build_defs.bzl\", \"xla_test\")\n load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\", \"nvtx_headers\")\n load(\"//xla/tsl:tsl.default.bzl\", \"get_compatible_with_portable\")\n@@ -2445,6 +2445,11 @@ tf_proto_library(\n     ],\n )\n \n+xla_py_proto_library(\n+    name = \"thunk_proto_py\",\n+    deps = [\":thunk_proto\"],\n+)\n+\n tf_proto_library(\n     name = \"dynamic_slice_thunk_proto\",\n     srcs = [\n@@ -3093,6 +3098,11 @@ tf_proto_library(\n     srcs = [\"buffer_debug_log.proto\"],\n )\n \n+xla_py_proto_library(\n+    name = \"buffer_debug_log_proto_py\",\n+    deps = [\":buffer_debug_log_proto\"],\n+)\n+\n cc_library(\n     name = \"thunk_buffer_id\",\n     hdrs = [\"thunk_buffer_id.h\"],"
        },
        {
            "sha": "c789739ebaed528b7a90cc8f1b4bcbeacb4e70eb",
            "filename": "third_party/xla/xla/backends/gpu/runtime/buffer_debug_log.proto",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fbuffer_debug_log.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fbuffer_debug_log.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fbuffer_debug_log.proto?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -26,8 +26,20 @@ message BufferDebugLogEntryProto {\n   // Thunk::buffer_uses().\n   uint64 buffer_idx = 2;\n \n-  // The value of the buffer.\n-  uint32 value = 3;\n+  // The checksum of the buffer.\n+  uint32 checksum = 3;\n+\n+  // If true, the entry refers to a thunk input buffer, and the checksum is\n+  // calculated based on the buffer value before the thunk execution.\n+  //\n+  // If false, it refers to thunk output, and the checksum is calculated based\n+  // on the buffer value after the thunk execution.\n+  bool is_input_buffer = 4;\n+\n+  // ID of the thunk execution that produced this entry. Entries with the same\n+  // (thunk_id, execution_id) describe buffers used by a single execution of a\n+  // thunk.\n+  uint32 execution_id = 5;\n }\n \n // A dump of a `BufferDebugLog` contents."
        },
        {
            "sha": "835cf26efa3246f8a9c2da2351ddca7f32cce392",
            "filename": "third_party/xla/xla/stream_executor/gpu/buffer_debug_log.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fstream_executor%2Fgpu%2Fbuffer_debug_log.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fstream_executor%2Fgpu%2Fbuffer_debug_log.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fgpu%2Fbuffer_debug_log.cc?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -103,7 +103,7 @@ absl::StatusOr<xla::gpu::BufferDebugLogProto> BufferDebugLog::ReadProto(\n         buffer_debug_log_proto.add_entries();\n     entry_proto->set_thunk_id(entry.entry_id.thunk_id().value());\n     entry_proto->set_buffer_idx(entry.entry_id.buffer_idx());\n-    entry_proto->set_value(entry.value);\n+    entry_proto->set_checksum(entry.value);\n   }\n \n   return buffer_debug_log_proto;"
        },
        {
            "sha": "4430154a3354427e5afef301664be27f50ca2f43",
            "filename": "third_party/xla/xla/stream_executor/gpu/buffer_debug_log_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fstream_executor%2Fgpu%2Fbuffer_debug_log_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Fstream_executor%2Fgpu%2Fbuffer_debug_log_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fgpu%2Fbuffer_debug_log_test.cc?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -144,8 +144,8 @@ TEST_F(BufferDebugLogTest, ReadAsProto) {\n                           device_log.ReadProto(*stream_));\n \n   EXPECT_THAT(log_proto, EqualsProto(R\"pb(\n-                entries { thunk_id: 123 buffer_idx: 4 value: 12341234 }\n-                entries { thunk_id: 567 buffer_idx: 8 value: 56785678 }\n+                entries { thunk_id: 123 buffer_idx: 4 checksum: 12341234 }\n+                entries { thunk_id: 567 buffer_idx: 8 checksum: 56785678 }\n               )pb\"));\n }\n "
        },
        {
            "sha": "e1761a3a75f09d2868fc62e749e9271cfdd8e63f",
            "filename": "third_party/xla/xla/tools/buffer_debug_log/BUILD",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2FBUILD?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -0,0 +1,47 @@\n+# Tools and utilities for analyzing the BufferDebugLogProto dumps.\n+\n+load(\"//xla:py_strict.bzl\", \"py_strict_test\")\n+load(\"//xla:pytype.bzl\", \"pytype_strict_binary\", \"pytype_strict_library\")\n+\n+package(\n+    # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n+    default_visibility = [\"//xla:internal\"],\n+    licenses = [\"notice\"],\n+)\n+\n+pytype_strict_library(\n+    name = \"checksum_mismatch_report\",\n+    srcs = [\"checksum_mismatch_report.py\"],\n+    deps = [\n+        \"//xla/backends/gpu/runtime:buffer_debug_log_proto_py\",\n+        \"//xla/backends/gpu/runtime:thunk_proto_py\",\n+    ],\n+)\n+\n+py_strict_test(\n+    name = \"checksum_mismatch_report_test\",\n+    srcs = [\"checksum_mismatch_report_test.py\"],\n+    deps = [\n+        \":checksum_mismatch_report\",\n+        \"//xla/backends/gpu/runtime:buffer_debug_log_proto_py\",\n+        \"//xla/backends/gpu/runtime:thunk_proto_py\",\n+        \"@absl_py//absl/testing:absltest\",\n+        \"@com_google_protobuf//:protobuf_python\",\n+    ],\n+)\n+\n+pytype_strict_binary(\n+    name = \"check_thunk_output_consistency\",\n+    srcs = [\n+        \"check_thunk_output_consistency.py\",\n+    ],\n+    main = \"check_thunk_output_consistency.py\",\n+    deps = [\n+        \":checksum_mismatch_report\",\n+        \"//xla/backends/gpu/runtime:buffer_debug_log_proto_py\",\n+        \"//xla/backends/gpu/runtime:thunk_proto_py\",\n+        \"@absl_py//absl:app\",\n+        \"@absl_py//absl/flags\",\n+        \"@com_google_protobuf//:protobuf_python\",\n+    ],\n+)"
        },
        {
            "sha": "d8189dcc5cf377af1353c79096331ffaa26d4677",
            "filename": "third_party/xla/xla/tools/buffer_debug_log/check_thunk_output_consistency.py",
            "status": "added",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fcheck_thunk_output_consistency.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fcheck_thunk_output_consistency.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fcheck_thunk_output_consistency.py?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -0,0 +1,117 @@\n+# Copyright 2025 The OpenXLA Authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"A tool to analyze buffer debug logs.\n+\n+To generate the log files, run the HLO with\n+--xla_gpu_experimental_enable_checksum_tracing_on_thunks.\n+\"\"\"\n+\n+from collections.abc import Sequence\n+\n+from absl import app\n+from absl import flags\n+from google.protobuf import message\n+from google.protobuf import text_format\n+\n+from xla.backends.gpu.runtime import buffer_debug_log_pb2\n+from xla.backends.gpu.runtime import thunk_pb2\n+from xla.tools.buffer_debug_log import checksum_mismatch_report\n+\n+\n+def parse_binary_or_text_proto(data: bytes, proto_type):\n+  \"\"\"Parses a binary or text proto.\"\"\"\n+  try:\n+    return proto_type.FromString(data)\n+  except message.DecodeError:\n+    pass\n+  return text_format.Parse(data, proto_type())\n+\n+\n+_METADATA_FILE = flags.DEFINE_string(\n+    \"metadata-file\", None, \"Path to the thunk metadata proto file.\"\n+)\n+\n+\n+def _print_formatted_report(\n+    report: checksum_mismatch_report.ChecksumMismatchReport,\n+):\n+  \"\"\"Prints a ChecksumMismatchReport to stdout in a human-readable format.\"\"\"\n+\n+  if not report.mismatches:\n+    print(\"\\N{WHITE HEAVY CHECK MARK} All results are perfectly consistent.\")\n+    return\n+\n+  print(\n+      \"\\N{OCTAGONAL SIGN} Different outputs detected among identical\"\n+      \" thunk executions:\"\n+  )\n+  for thunk_id, mismatches_by_inputs in report.mismatches.items():\n+    if not mismatches_by_inputs:\n+      continue\n+\n+    def describe_thunk(thunk_id: checksum_mismatch_report.ThunkId):\n+      result = f\"In outputs of thunk {thunk_id}\"\n+      metadata = \" (metadata missing)\"\n+      if report.thunk_metadata:\n+        thunk_metadata = report.thunk_metadata.get(thunk_id)\n+        if thunk_metadata:\n+          metadata = f\" (kind: {thunk_metadata.thunk_kind}, profile_annotation:\"\n+          metadata += f\" {thunk_metadata.profile_annotation})\"\n+      return result + metadata\n+\n+    print(describe_thunk(thunk_id))\n+    for _, mismatches_by_buffer_idx in sorted(mismatches_by_inputs.items()):\n+      for buffer_idx, checksums in mismatches_by_buffer_idx.items():\n+        print(f\"  buffer {buffer_idx}: checksums={checksums}\")\n+\n+\n+def main(argv: Sequence[str]) -> None:\n+  if len(argv) < 2:\n+    raise app.UsageError(\n+        \"Usage: buffer-debug.py [--metadata-file METADATA_PROTO_PATH]\"\n+        \" LOG_PROTO_PATHS...\"\n+    )\n+\n+  log_protos = {}\n+  for module_id, arg in enumerate(argv[1:]):\n+    try:\n+      with open(arg, \"rb\") as f:\n+        log_protos[module_id] = parse_binary_or_text_proto(\n+            f.read(), buffer_debug_log_pb2.BufferDebugLogProto\n+        )\n+    except Exception as e:\n+      e.add_note(f\"when reading {arg}\")\n+      raise\n+\n+  if _METADATA_FILE.value:\n+    try:\n+      with open(_METADATA_FILE.value, \"rb\") as f:\n+        metadata_proto = parse_binary_or_text_proto(\n+            f.read(), thunk_pb2.ThunkMetadataListProto\n+        )\n+    except Exception as e:\n+      e.add_note(f\"when reading {_METADATA_FILE.value}\")\n+      raise\n+  else:\n+    metadata_proto = thunk_pb2.ThunkMetadataListProto()\n+\n+  report = checksum_mismatch_report.ChecksumMismatchReport.from_protos(\n+      log_protos, metadata_proto\n+  )\n+  _print_formatted_report(report)\n+\n+\n+if __name__ == \"__main__\":\n+  app.run(main)"
        },
        {
            "sha": "d9f4b6098c5deb6d07ef5612273e691e83adf23b",
            "filename": "third_party/xla/xla/tools/buffer_debug_log/checksum_mismatch_report.py",
            "status": "added",
            "additions": 250,
            "deletions": 0,
            "changes": 250,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fchecksum_mismatch_report.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fchecksum_mismatch_report.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fchecksum_mismatch_report.py?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -0,0 +1,250 @@\n+# Copyright 2025 The OpenXLA Authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Utilities for detecting checksum mismatches in buffer debug logs.\n+\n+The log is generated by running with\n+--xla_gpu_experimental_enable_checksum_tracing_on_thunks.\n+\"\"\"\n+\n+import collections\n+import dataclasses\n+import itertools\n+from typing import Callable, Iterable, NewType, Optional, Self, TypeVar\n+\n+from xla.backends.gpu.runtime import buffer_debug_log_pb2\n+from xla.backends.gpu.runtime import thunk_pb2\n+\n+\n+ModuleExecutionId = NewType(\"ModuleExecutionId\", int)\n+ThunkId = NewType(\"ThunkId\", int)\n+BufferIdx = NewType(\"BufferIdx\", int)\n+Checksum = NewType(\"Checksum\", int)\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class BufferChecksums:\n+  \"\"\"A set of buffer checksums with order-independent hashing.\"\"\"\n+\n+  checksums: dict[BufferIdx, Checksum]\n+\n+  def __hash__(self):\n+    return hash(tuple(sorted(self.checksums.items())))\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class ThunkMetadata:\n+  \"\"\"Thunk metadata, read from ThunkMetadataListProto.\n+\n+  Stored in a separate type to enable type checking.\n+  \"\"\"\n+\n+  thunk_id: ThunkId\n+  thunk_kind: str\n+  profile_annotation: Optional[str]\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class ThunkExecution:\n+  \"\"\"The details of a single execution of a thunk.\"\"\"\n+\n+  # An ID of the HLO module execution that produced this thunk execution.\n+  module_execution_id: int\n+  # An ID of the thunk execution within a HLO module execution. If a thunk\n+  # executes in a loop, there will create multiple entries with same thunk_id\n+  # but different execution IDs.\n+  thunk_execution_id: int\n+  # The ID of the thunk that was executed. Details about the thunk can be found\n+  # in ThunkMetadata.\n+  thunk_id: ThunkId\n+  # Checksums of buffers with defined contents before thunk execution.\n+  # These are used to identify repeats of the same computation that are expected\n+  # to produce the same results.\n+  input_checksums: BufferChecksums\n+  # Checksums of buffers with defined contents after thunk execution.\n+  # These are the values we want to verify are consistent across executions.\n+  output_checksums: BufferChecksums\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class ChecksumMismatchReport:\n+  \"\"\"A report of checksum mismatches for a thunk.\"\"\"\n+\n+  thunk_metadata: dict[ThunkId, ThunkMetadata]\n+  # Thunks for which different executions produced different results. The value\n+  # is a input checksums => output checksum sets dict containing the info about\n+  # inconsistent outptus, and the checksums of inputs that caused them.\n+  mismatches: dict[\n+      ThunkId, dict[BufferChecksums, dict[BufferIdx, set[Checksum]]]\n+  ]\n+\n+  @classmethod\n+  def from_protos(\n+      cls,\n+      log_protos: dict[\n+          ModuleExecutionId, buffer_debug_log_pb2.BufferDebugLogProto\n+      ],\n+      metadata_proto: thunk_pb2.ThunkMetadataListProto,\n+  ) -> Self:\n+    \"\"\"Creates a ChecksumMismatchReport from protobufs.\n+\n+    Args:\n+      log_protos: A dict of BufferDebugLogProto keyed by module execution ID.\n+      metadata_proto: A ThunkMetadataListProto.\n+\n+    Preconditions:\n+      - All log protos must refer to the same HLO module.\n+      - metadata proto must describe the same HLO module as the log protos or be\n+        an empty proto.\n+    \"\"\"\n+    metadata = _parse_metadata(metadata_proto)\n+\n+    executions = itertools.chain.from_iterable(\n+        _parse_log(module_execution_id, log_proto)\n+        for module_execution_id, log_proto in log_protos.items()\n+    )\n+    mismatches = _find_inconsistent_thunks(executions)\n+\n+    return cls(metadata, mismatches)\n+\n+\n+K = TypeVar(\"K\")\n+T = TypeVar(\"T\")\n+\n+\n+def group_by(\n+    values: Iterable[T], key_getter: Callable[[T], K]\n+) -> dict[K, list[T]]:\n+  \"\"\"Groups a sequence by a key function.\"\"\"\n+  result = collections.defaultdict(list)\n+  for item in values:\n+    result[key_getter(item)].append(item)\n+  return result\n+\n+\n+def _parse_metadata(\n+    metadata_proto: thunk_pb2.ThunkMetadataListProto,\n+) -> dict[ThunkId, ThunkMetadata]:\n+  \"\"\"Parses a ThunkMetadataListProto into a dict of ThunkMetadata.\"\"\"\n+  metadata_by_thunk_id: dict[ThunkId, ThunkMetadata] = {}\n+  for metadata in metadata_proto.thunk_metadata:\n+    thunk_id = ThunkId(metadata.thunk_info.thunk_id)\n+    metadata_by_thunk_id[thunk_id] = ThunkMetadata(\n+        thunk_id=thunk_id,\n+        thunk_kind=metadata.thunk_kind,\n+        profile_annotation=metadata.thunk_info.profile_annotation,\n+    )\n+\n+  return metadata_by_thunk_id\n+\n+\n+def _parse_log(\n+    module_execution: int,\n+    log_proto: buffer_debug_log_pb2.BufferDebugLogProto,\n+) -> list[ThunkExecution]:\n+  \"\"\"Parses a BufferDebugLogProto and ThunkMetadataListProto into a list of ThunkExecutions.\"\"\"\n+\n+  entries_by_execution = group_by(\n+      log_proto.entries, lambda entry: (entry.thunk_id, entry.execution_id)\n+  )\n+  executions = [\n+      ThunkExecution(\n+          module_execution_id=module_execution,\n+          thunk_execution_id=execution_id,\n+          thunk_id=thunk_id,\n+          input_checksums=BufferChecksums({\n+              entry.buffer_idx: entry.checksum\n+              for entry in entries\n+              if entry.is_input_buffer\n+          }),\n+          output_checksums=BufferChecksums({\n+              entry.buffer_idx: entry.checksum\n+              for entry in entries\n+              if not entry.is_input_buffer\n+          }),\n+      )\n+      for (thunk_id, execution_id), entries in entries_by_execution.items()\n+  ]\n+  return executions\n+\n+\n+def _find_inconsistent_output_checksums(\n+    executions: list[ThunkExecution],\n+) -> dict[BufferIdx, set[Checksum]]:\n+  \"\"\"Finds mismatches in output checksums for a list of identical executions.\n+\n+  Args:\n+    executions: A list of executions of the same thunk on the same input\n+      arguments.\n+\n+  Returns:\n+    A dict of buffers whose contents were not consistent across executions with\n+    the same inputs, based on the checksum value. The value is a set of\n+    checksums observed for that buffer.\n+  \"\"\"\n+  checksums_by_buffer_idx: dict[BufferIdx, set[Checksum]] = (\n+      collections.defaultdict(set)\n+  )\n+  for execution in executions:\n+    for buffer_idx, checksum in execution.output_checksums.checksums.items():\n+      checksums_by_buffer_idx[buffer_idx].add(checksum)\n+\n+  return {\n+      buffer_idx: checksums\n+      for buffer_idx, checksums in checksums_by_buffer_idx.items()\n+      if len(checksums) > 1\n+  }\n+\n+\n+def _find_inconsistent_thunks(\n+    executions: Iterable[ThunkExecution],\n+) -> dict[ThunkId, dict[BufferChecksums, dict[BufferIdx, set[Checksum]]]]:\n+  \"\"\"Finds thunks with inconsistent output checksums across identical executions.\n+\n+  Args:\n+    executions: A arbitrary list of thunk executions.\n+\n+  Returns:\n+    A dict of thunks whose outputs were inconsistent across identical\n+    executions.\n+\n+    The value is a dict keyed by the set of input checksums, with values\n+    identifying the output buffers with inconsistent checksums, along with the\n+    set of observed checksums for each.\n+  \"\"\"\n+  executions_by_thunk_id: dict[ThunkId, list[ThunkExecution]] = group_by(\n+      executions,\n+      lambda e: e.thunk_id,\n+  )\n+\n+  mismatches: dict[\n+      ThunkId, dict[BufferChecksums, dict[BufferIdx, set[Checksum]]]\n+  ] = {}\n+  for thunk_id, executions in executions_by_thunk_id.items():\n+    executions_by_inputs: dict[BufferChecksums, list[ThunkExecution]] = (\n+        group_by(executions, lambda e: e.input_checksums)\n+    )\n+\n+    mismatches_by_inputs: dict[\n+        BufferChecksums, dict[BufferIdx, set[Checksum]]\n+    ] = {}\n+    for input_checksums, executions in executions_by_inputs.items():\n+      m = _find_inconsistent_output_checksums(executions)\n+      if m:\n+        mismatches_by_inputs[input_checksums] = m\n+\n+    if mismatches_by_inputs:\n+      mismatches[thunk_id] = mismatches_by_inputs\n+\n+  return mismatches"
        },
        {
            "sha": "6ad14efb5d4302f0094238f4d78bea911bf07a74",
            "filename": "third_party/xla/xla/tools/buffer_debug_log/checksum_mismatch_report_test.py",
            "status": "added",
            "additions": 228,
            "deletions": 0,
            "changes": 228,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fchecksum_mismatch_report_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7334d07917314a22a80f54f0df1ac4175e8cbba7/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fchecksum_mismatch_report_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fbuffer_debug_log%2Fchecksum_mismatch_report_test.py?ref=7334d07917314a22a80f54f0df1ac4175e8cbba7",
            "patch": "@@ -0,0 +1,228 @@\n+# Copyright 2025 The OpenXLA Authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+from absl.testing import absltest\n+from google.protobuf import text_format\n+\n+from xla.backends.gpu.runtime import buffer_debug_log_pb2\n+from xla.backends.gpu.runtime import thunk_pb2\n+from xla.tools.buffer_debug_log import checksum_mismatch_report\n+\n+\n+class ChecksumMismatchReportTest(absltest.TestCase):\n+\n+  def test_from_protos_loads_metadata(self):\n+    test_log = \"\"\n+    test_metadata = \"\"\"\n+thunk_metadata {\n+  thunk_info {\n+    thunk_id: 100\n+    profile_annotation: \"thunk1\"\n+  }\n+  thunk_kind: \"kGemm\"\n+}\n+thunk_metadata {\n+  thunk_info {\n+    thunk_id: 101\n+    profile_annotation: \"thunk2\"\n+  }\n+  thunk_kind: \"kConv\"\n+}\n+\"\"\"\n+    log_proto = text_format.Parse(\n+        test_log, buffer_debug_log_pb2.BufferDebugLogProto()\n+    )\n+    metadata_proto = text_format.Parse(\n+        test_metadata,\n+        thunk_pb2.ThunkMetadataListProto(),\n+    )\n+\n+    report = checksum_mismatch_report.ChecksumMismatchReport.from_protos(\n+        {0: log_proto}, metadata_proto\n+    )\n+\n+    self.assertEqual(\n+        report.thunk_metadata,\n+        {\n+            100: checksum_mismatch_report.ThunkMetadata(\n+                thunk_id=100,\n+                thunk_kind=\"kGemm\",\n+                profile_annotation=\"thunk1\",\n+            ),\n+            101: checksum_mismatch_report.ThunkMetadata(\n+                thunk_id=101,\n+                thunk_kind=\"kConv\",\n+                profile_annotation=\"thunk2\",\n+            ),\n+        },\n+    )\n+\n+  def test_from_protos_finds_mismatches_in_single_proto(self):\n+    test_log = \"\"\"\n+entries {\n+  thunk_id: 100\n+  execution_id: 10\n+  buffer_idx: 0\n+  is_input_buffer: true\n+  checksum: 11111111\n+}\n+entries {\n+  thunk_id: 100\n+  execution_id: 10\n+  buffer_idx: 1\n+  is_input_buffer: false\n+  checksum: 22222222\n+}\n+entries {\n+  thunk_id: 100\n+  execution_id: 11\n+  buffer_idx: 0\n+  is_input_buffer: true\n+  checksum: 11111111\n+}\n+entries {\n+  thunk_id: 100\n+  execution_id: 11\n+  buffer_idx: 1\n+  is_input_buffer: false\n+  checksum: 33333333\n+}\n+\"\"\"\n+    test_metadata = \"\"\n+    log_proto = text_format.Parse(\n+        test_log, buffer_debug_log_pb2.BufferDebugLogProto()\n+    )\n+    metadata_proto = text_format.Parse(\n+        test_metadata,\n+        thunk_pb2.ThunkMetadataListProto(),\n+    )\n+\n+    report = checksum_mismatch_report.ChecksumMismatchReport.from_protos(\n+        {0: log_proto}, metadata_proto\n+    )\n+\n+    self.assertEqual(\n+        report.mismatches,\n+        {\n+            # thunk ID\n+            100: {\n+                # input checksums\n+                checksum_mismatch_report.BufferChecksums({0: 11111111}): {\n+                    # output buffer index => checksums\n+                    1: {22222222, 33333333},\n+                },\n+            },\n+        },\n+    )\n+\n+  def test_from_protos_finds_mismatches_in_multiple_protos(self):\n+    test_log_template = \"\"\"\n+entries {{\n+  thunk_id: 100\n+  execution_id: 10\n+  buffer_idx: 0\n+  is_input_buffer: true\n+  checksum: 11111111\n+}}\n+entries {{\n+  thunk_id: 100\n+  execution_id: 10\n+  buffer_idx: 1\n+  is_input_buffer: false\n+  checksum: {output_checksum}\n+}}\n+\"\"\"\n+    test_logs = [\n+        test_log_template.format(output_checksum=checksum)\n+        for checksum in [22222222, 33333333]\n+    ]\n+    test_metadata = \"\"\n+    log_protos = {\n+        module_id: text_format.Parse(\n+            test_log, buffer_debug_log_pb2.BufferDebugLogProto()\n+        )\n+        for module_id, test_log in enumerate(test_logs)\n+    }\n+    metadata_proto = text_format.Parse(\n+        test_metadata,\n+        thunk_pb2.ThunkMetadataListProto(),\n+    )\n+\n+    report = checksum_mismatch_report.ChecksumMismatchReport.from_protos(\n+        log_protos, metadata_proto\n+    )\n+\n+    self.assertEqual(\n+        report.mismatches,\n+        {\n+            # thunk ID\n+            100: {\n+                # input checksums\n+                checksum_mismatch_report.BufferChecksums({0: 11111111}): {\n+                    # output buffer index => checksums\n+                    1: {22222222, 33333333},\n+                },\n+            },\n+        },\n+    )\n+\n+  def test_from_protos_does_not_include_consistent_executions(self):\n+    test_log = \"\"\"\n+entries {\n+  thunk_id: 100\n+  execution_id: 10\n+  buffer_idx: 0\n+  is_input_buffer: true\n+  checksum: 11111111\n+}\n+entries {\n+  thunk_id: 100\n+  execution_id: 10\n+  buffer_idx: 1\n+  is_input_buffer: false\n+  checksum: 22222222\n+}\n+entries {\n+  thunk_id: 100\n+  execution_id: 11\n+  buffer_idx: 0\n+  is_input_buffer: true\n+  checksum: 11111111\n+}\n+entries {\n+  thunk_id: 100\n+  execution_id: 11\n+  buffer_idx: 1\n+  is_input_buffer: false\n+  checksum: 22222222\n+}\n+\"\"\"\n+    test_metadata = \"\"\n+    log_proto = text_format.Parse(\n+        test_log, buffer_debug_log_pb2.BufferDebugLogProto()\n+    )\n+    metadata_proto = text_format.Parse(\n+        test_metadata,\n+        thunk_pb2.ThunkMetadataListProto(),\n+    )\n+\n+    report = checksum_mismatch_report.ChecksumMismatchReport.from_protos(\n+        {0: log_proto}, metadata_proto\n+    )\n+\n+    self.assertEmpty(report.mismatches)\n+\n+\n+if __name__ == \"__main__\":\n+  absltest.main()"
        }
    ],
    "stats": {
        "total": 676,
        "additions": 670,
        "deletions": 6
    }
}