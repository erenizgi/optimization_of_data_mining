{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 829327365",
    "sha": "7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
    "files": [
        {
            "sha": "f6293e0a2063bb924b78f874a126e55c1303291e",
            "filename": "tensorflow/compiler/aot/aot_only_var_handle_op.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Faot_only_var_handle_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Faot_only_var_handle_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Faot_only_var_handle_op.cc?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -31,7 +31,7 @@ class XlaAotOnlyVarHandleOp : public XlaOpKernel {\n   void Compile(XlaOpKernelContext* context) override;\n \n  private:\n-  string name_;\n+  std::string name_;\n };\n \n XlaAotOnlyVarHandleOp::XlaAotOnlyVarHandleOp(OpKernelConstruction* c)"
        },
        {
            "sha": "ee4af4ca65a20fea9d174626558f2ca191488366",
            "filename": "tensorflow/compiler/aot/benchmark.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fbenchmark.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fbenchmark.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fbenchmark.cc?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -37,10 +37,10 @@ namespace benchmark {\n //\n // TODO(b/33546473): Refactor tensorflow::Env::NowMicros() so that we can re-use\n // the implementation without pulling in all of the Env dependencies.\n-static uint64 NowMicros() {\n+static uint64_t NowMicros() {\n   struct timeval tv;\n   gettimeofday(&tv, nullptr);\n-  return static_cast<uint64>(tv.tv_sec) * 1000000 + tv.tv_usec;\n+  return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;\n }\n \n void DumpStatsToStdout(const Stats& stats) {"
        },
        {
            "sha": "a6ef88d7559b1d50d646b46b10482954b85ad5b5",
            "filename": "tensorflow/compiler/aot/codegen.cc",
            "status": "modified",
            "additions": 46,
            "deletions": 42,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcodegen.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcodegen.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcodegen.cc?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -70,7 +70,7 @@ namespace {\n using xla::cpu::BufferAllocationInfo;\n \n // Convert an XLA type into a C++ type.\n-absl::Status XLATypeToCpp(xla::PrimitiveType type, string* str) {\n+absl::Status XLATypeToCpp(xla::PrimitiveType type, std::string* str) {\n   switch (type) {\n     case xla::PRED:\n       *str = \"bool\";\n@@ -151,11 +151,11 @@ std::vector<BufferAllocationInfo> ExtractTempBufferAllocationInfos(\n // are used to generate methods for args and results.\n absl::Status AddRewritesForShape(\n     int i, const xla::Shape& shape,\n-    std::vector<std::pair<string, string>>* rewrites) {\n-  string type;\n+    std::vector<std::pair<std::string, std::string>>* rewrites) {\n+  std::string type;\n   TF_RETURN_IF_ERROR(XLATypeToCpp(shape.element_type(), &type));\n-  std::vector<string> dim_vars;\n-  string dim_sizes, indices;\n+  std::vector<std::string> dim_vars;\n+  std::string dim_sizes, indices;\n   int count = 1;\n   if (shape.dimensions().size() == 0 ||\n       (shape.dimensions().size() == 1 && shape.dimensions(0) == 1)) {\n@@ -186,8 +186,9 @@ absl::Status AddRewritesForShape(\n // TODO(toddw): If this becomes a problem, we should be able to change the\n // algorithm to O(N) by using a state machine, e.g. regexps or a real\n // text-templating mechanism.\n-string RewriteWithName(const string& name, string code,\n-                       const std::vector<std::pair<string, string>>& rewrites) {\n+std::string RewriteWithName(\n+    const std::string& name, std::string code,\n+    const std::vector<std::pair<std::string, std::string>>& rewrites) {\n   absl::StrReplaceAll(rewrites, &code);\n   absl::StrReplaceAll({{\"{{NAME}}\", name}}, &code);\n   return code;\n@@ -197,7 +198,7 @@ string RewriteWithName(const string& name, string code,\n absl::Status GenArgMethods(const tf2xla::Config& config,\n                            const xla::ProgramShapeProto& ps,\n                            const CompileResult& compile_result,\n-                           string* methods) {\n+                           std::string* methods) {\n   const int num_args = ps.parameters_size();\n   // feed_size() + variable_size() is the maximum number of args as an\n   // implementation may not create an argument for an unused variable.\n@@ -207,11 +208,11 @@ absl::Status GenArgMethods(const tf2xla::Config& config,\n         config.variable_size(), \") and num_args(\", num_args, \")\");\n   }\n   for (int i = 0; i < config.feed_size(); ++i) {\n-    std::vector<std::pair<string, string>> rewrites;\n+    std::vector<std::pair<std::string, std::string>> rewrites;\n     TF_ASSIGN_OR_RETURN(xla::Shape shape,\n                         xla::Shape::FromProto(ps.parameters(i)));\n     TF_RETURN_IF_ERROR(AddRewritesForShape(i, shape, &rewrites));\n-    const string code = R\"(\n+    const std::string code = R\"(\n   void set_arg{{NAME}}_data(const void* data) {\n     set_arg_data({{I}}, data);\n   }\n@@ -247,7 +248,7 @@ absl::Status GenArgMethods(const tf2xla::Config& config,\n // Generate methods for results (outputs).\n absl::Status GenResultMethods(const tf2xla::Config& config,\n                               const xla::ProgramShapeProto& ps,\n-                              string* methods) {\n+                              std::string* methods) {\n   if (ps.result().element_type() != xla::TUPLE) {\n     // The XlaCompiler we use to build the xla computation always generates a\n     // tuple result, and we rely on this to simplify code generation.\n@@ -266,11 +267,11 @@ absl::Status GenResultMethods(const tf2xla::Config& config,\n                                    ps.result().tuple_shapes_size(), \")\");\n   }\n   for (int i = 0; i < config.fetch_size(); ++i) {\n-    std::vector<std::pair<string, string>> rewrites;\n+    std::vector<std::pair<std::string, std::string>> rewrites;\n     TF_ASSIGN_OR_RETURN(xla::Shape shape,\n                         xla::Shape::FromProto(ps.result().tuple_shapes(i)));\n     TF_RETURN_IF_ERROR(AddRewritesForShape(i, shape, &rewrites));\n-    string code = R\"(\n+    std::string code = R\"(\n   {{TYPE}}* result{{NAME}}_data() {\n     return static_cast<{{TYPE}}*>(result_data({{I}}));\n   }\n@@ -303,14 +304,14 @@ absl::Status GenResultMethods(const tf2xla::Config& config,\n // Generate methods for variables.\n absl::Status GenVariableMethods(const tf2xla::Config& config,\n                                 const xla::ProgramShapeProto& ps,\n-                                string* methods) {\n+                                std::string* methods) {\n   const int num_args = ps.parameters_size();\n   for (int i = config.feed_size(); i < num_args; ++i) {\n-    std::vector<std::pair<string, string>> rewrites;\n+    std::vector<std::pair<std::string, std::string>> rewrites;\n     TF_ASSIGN_OR_RETURN(xla::Shape shape,\n                         xla::Shape::FromProto(ps.parameters(i)));\n     TF_RETURN_IF_ERROR(AddRewritesForShape(i, shape, &rewrites));\n-    const string code = R\"(\n+    const std::string code = R\"(\n   void set_var_{{NAME}}_data({{MAYBE_CONST}}{{TYPE}}* data) {\n     set_arg_data({{I}}, data);\n   }\n@@ -344,7 +345,8 @@ absl::Status GenVariableMethods(const tf2xla::Config& config,\n }\n \n // Generate shape infos for args (inputs).\n-absl::Status GenArgShapeInfos(const xla::ProgramShapeProto& ps, string* infos) {\n+absl::Status GenArgShapeInfos(const xla::ProgramShapeProto& ps,\n+                              std::string* infos) {\n   for (int i = 0; i < ps.parameters_size(); ++i) {\n     const xla::ShapeProto& shape = ps.parameters(i);\n     if (shape.element_type() == xla::TUPLE) {\n@@ -382,7 +384,7 @@ absl::Status GenArgShapeInfos(const xla::ProgramShapeProto& ps, string* infos) {\n \n // Generate shape infos for results.\n absl::Status GenResultShapeInfos(const xla::ProgramShapeProto& ps,\n-                                 string* infos) {\n+                                 std::string* infos) {\n   if (ps.result().element_type() != xla::TUPLE) {\n     return absl::InternalError(\"codegen requires the XLA result to be a tuple\");\n   }\n@@ -416,7 +418,7 @@ absl::Status GenResultShapeInfos(const xla::ProgramShapeProto& ps,\n // tf2xla::{Feed,Fetch,Variable}. Each feed or fetch name results in a C-style\n // string literal in the array, with nullptr terminating the array.\n template <typename T>\n-string GenNameToIndexCode(const T& entries, bool generate) {\n+std::string GenNameToIndexCode(const T& entries, bool generate) {\n   // No need for a static array if we're not supposed to generate the data.\n   if (!generate) {\n     return \"{\\n    return nullptr;\\n  }\";\n@@ -431,7 +433,7 @@ string GenNameToIndexCode(const T& entries, bool generate) {\n     end = i;\n   }\n   // Emit string literals up to the last non-empty name.\n-  string code = \"{\\n    static const char* kNames[] = {\";\n+  std::string code = \"{\\n    static const char* kNames[] = {\";\n   for (int i = 0; i < end; ++i) {\n     if (i > 0) {\n       code += \", \";\n@@ -832,18 +834,19 @@ absl::Status ExtendRewrites(\n absl::Status GenerateHeader(\n     const CodegenOpts& opts, const tf2xla::Config& config,\n     const CompileResult& compile_result, const MetadataResult& metadata_result,\n-    const EmbeddedConstantBuffers& embedded_constant_buffers, string* header) {\n+    const EmbeddedConstantBuffers& embedded_constant_buffers,\n+    std::string* header) {\n   TF_RETURN_IF_ERROR(ValidateConfig(config));\n   TF_RETURN_IF_ERROR(ValidateFeedFetchCppNames(config));\n \n   absl::Span<const BufferAllocationInfo> buffer_infos =\n       compile_result.aot->buffer_allocation_infos();\n \n-  const std::vector<int32> arg_index_table =\n+  const std::vector<int32_t> arg_index_table =\n       ::xla::cpu::CreateArgIndexTable(buffer_infos);\n-  const std::vector<int32> result_index_table =\n+  const std::vector<int32_t> result_index_table =\n       ::xla::cpu::CreateResultIndexTable(buffer_infos);\n-  std::vector<string> buffer_infos_as_strings =\n+  std::vector<std::string> buffer_infos_as_strings =\n       BufferAllocationInfosToCppExpression(buffer_infos);\n \n   // Compute sizes and generate methods.\n@@ -852,11 +855,11 @@ absl::Status GenerateHeader(\n   std::vector<BufferAllocationInfo> buffer_infos_for_temps =\n       ExtractTempBufferAllocationInfos(buffer_infos);\n   const xla::ProgramShapeProto& ps = compile_result.program_shape;\n-  string methods_arg, methods_result, methods_variable;\n+  std::string methods_arg, methods_result, methods_variable;\n   TF_RETURN_IF_ERROR(GenArgMethods(config, ps, compile_result, &methods_arg));\n   TF_RETURN_IF_ERROR(GenResultMethods(config, ps, &methods_result));\n   TF_RETURN_IF_ERROR(GenVariableMethods(config, ps, &methods_variable));\n-  string arg_shape_infos, result_shape_infos;\n+  std::string arg_shape_infos, result_shape_infos;\n   TF_RETURN_IF_ERROR(GenArgShapeInfos(ps, &arg_shape_infos));\n   TF_RETURN_IF_ERROR(\n       CheckEqual(ps.parameters_size(), arg_index_table.size(),\n@@ -876,19 +879,19 @@ absl::Status GenerateHeader(\n   const size_t temp_bytes_total = TotalBufferBytes(buffer_infos_for_temps);\n \n   // Create rewrite strings for namespace start and end.\n-  string ns_start;\n-  for (const string& n : opts.namespaces) {\n+  std::string ns_start;\n+  for (const std::string& n : opts.namespaces) {\n     ns_start += absl::StrCat(\"namespace \", n, \" {\\n\");\n   }\n   ns_start += \"\\n\";\n-  string ns_end(\"\\n\");\n+  std::string ns_end(\"\\n\");\n   for (int i = opts.namespaces.size() - 1; i >= 0; --i) {\n-    const string& n = opts.namespaces[i];\n+    const std::string& n = opts.namespaces[i];\n     ns_end += absl::StrCat(\"}  // end namespace \", n, \"\\n\");\n   }\n \n   // Generate metadata.\n-  const string arg_names_code =\n+  const std::string arg_names_code =\n       GenNameToIndexCode(config.feed(), opts.gen_name_to_index);\n \n   auto variable_copy = config.variable();\n@@ -897,12 +900,12 @@ absl::Status GenerateHeader(\n       var.set_name(var.node_name());\n     }\n   }\n-  const string variable_names_code =\n+  const std::string variable_names_code =\n       GenNameToIndexCode(variable_copy, opts.gen_name_to_index);\n \n-  const string result_names_code =\n+  const std::string result_names_code =\n       GenNameToIndexCode(config.fetch(), opts.gen_name_to_index);\n-  const string include_xla_data_proto =\n+  const std::string include_xla_data_proto =\n       opts.gen_program_shape\n           ? R\"(#include \"xla/xla_data.pb.h\")\"\n           : \"\";\n@@ -1151,7 +1154,7 @@ class {{CLASS}} final : public tensorflow::{{COMPUTATION_CLASS_BASE}} {\n   }\n \n   // The replacement strategy is naive, but good enough for our purposes.\n-  std::vector<std::pair<string, string>> rewrites = {\n+  std::vector<std::pair<std::string, std::string>> rewrites = {\n       {\"{{ARG_BYTES_ALIGNED}}\", absl::StrCat(arg_bytes_aligned)},\n       {\"{{ARG_BYTES_TOTAL}}\", absl::StrCat(arg_bytes_total)},\n       {\"{{ARG_NAMES_CODE}}\", arg_names_code},\n@@ -1190,10 +1193,10 @@ class {{CLASS}} final : public tensorflow::{{COMPUTATION_CLASS_BASE}} {\n   return absl::OkStatus();\n }\n \n-static string CreateUniqueIdentifier(const CodegenOpts& opts,\n-                                     absl::string_view suffix) {\n-  string result = \"__tfcompile\";\n-  for (const string& n : opts.namespaces) {\n+static std::string CreateUniqueIdentifier(const CodegenOpts& opts,\n+                                          absl::string_view suffix) {\n+  std::string result = \"__tfcompile\";\n+  for (const std::string& n : opts.namespaces) {\n     absl::StrAppend(&result, \"_\", n);\n   }\n \n@@ -1299,14 +1302,15 @@ absl::Status GenerateMetadata(const CodegenOpts& opts,\n   return absl::OkStatus();\n }\n \n-absl::Status ParseCppClass(const string& cpp_class, string* class_name,\n-                           std::vector<string>* namespaces) {\n+absl::Status ParseCppClass(const std::string& cpp_class,\n+                           std::string* class_name,\n+                           std::vector<std::string>* namespaces) {\n   class_name->clear();\n   namespaces->clear();\n   if (cpp_class.empty()) {\n     return errors::InvalidArgument(\"empty cpp_class: \" + cpp_class);\n   }\n-  std::vector<string> parts = absl::StrSplit(cpp_class, \"::\");\n+  std::vector<std::string> parts = absl::StrSplit(cpp_class, \"::\");\n   if (parts.front().empty()) {\n     // Allow a fully qualified name that starts with \"::\".\n     parts.erase(parts.begin());"
        },
        {
            "sha": "ff7d96720b4eba6329fddc0a0f6e837eb1b0acdd",
            "filename": "tensorflow/compiler/aot/codegen.h",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcodegen.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcodegen.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcodegen.h?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -32,14 +32,14 @@ namespace tfcompile {\n // and the generated metadata object file.\n struct CodegenOpts {\n   // The name of the generated C++ class, wrapping the generated function.\n-  string class_name;\n+  std::string class_name;\n \n   // Target triple for the architecture we're targeting.\n-  string target_triple;\n+  std::string target_triple;\n \n   // Namespaces specifies a list of C++ namespaces to add to the generated\n   // header.  If empty, all symbols will be in the global namespace.\n-  std::vector<string> namespaces;\n+  std::vector<std::string> namespaces;\n \n   // If true, generate name-to-index data for Lookup{Arg,Result}Index methods.\n   bool gen_name_to_index = false;\n@@ -62,27 +62,27 @@ struct CodegenOpts {\n struct MetadataResult {\n   // These are top level \"extern C\" declarations that are expected to be visible\n   // wherever program_shape_access_shim is emitted.\n-  std::vector<string> header_variable_decls;\n+  std::vector<std::string> header_variable_decls;\n \n   // program_shape_access_shim is a C++ expression that constructs the\n   // xla::ProgramShapeProto instance for the CompileResult passed to\n   // GenerateMetadata.\n-  string program_shape_access_shim;\n+  std::string program_shape_access_shim;\n \n   // hlo_profile_printer_data_access_shim is a C++ expression that constructs\n   // the xla::HloProfilePrinterData instance for the CompileResult passed to\n   // GenerateMetadata.  If the xla::HloProfilePrinterData is null then this is a\n   // C++ expression that evaluates to nullptr at runtime.\n   // This is set only for AOT legacy.\n-  string hlo_profile_printer_data_access_shim;\n+  std::string hlo_profile_printer_data_access_shim;\n \n   // cpu_executable_access_shim is a C++ expression that constructs\n   // a protobuf required to construct a CpuExecutable.\n   // This is set only for AOT thunks.\n-  string cpu_executable_access_shim;\n+  std::string cpu_executable_access_shim;\n \n   // The contents of the object (\".o\") file.\n-  string object_file_data;\n+  std::string object_file_data;\n };\n \n // Generates a set of constant buffers embedded into an object file.\n@@ -105,14 +105,16 @@ absl::Status GenerateMetadata(const CodegenOpts& opts,\n absl::Status GenerateHeader(\n     const CodegenOpts& opts, const tf2xla::Config& config,\n     const CompileResult& compile_result, const MetadataResult& metadata_result,\n-    const EmbeddedConstantBuffers& embedded_constant_buffers, string* header);\n+    const EmbeddedConstantBuffers& embedded_constant_buffers,\n+    std::string* header);\n \n // ParseCppClass parses `cpp_class` into its `class_name` and `namespaces`\n // components.  The syntax is [[<optional_namespace>::],...]<class_name>.  This\n // mirrors the C++ syntax for referring to a class, where multiple namespaces\n // may precede the class name, separated by double-colons.\n-absl::Status ParseCppClass(const string& cpp_class, string* class_name,\n-                           std::vector<string>* namespaces);\n+absl::Status ParseCppClass(const std::string& cpp_class,\n+                           std::string* class_name,\n+                           std::vector<std::string>* namespaces);\n \n // ValidateCppIdent returns OK iff ident is a valid C++ identifier.  The msg is\n // appended to error messages."
        },
        {
            "sha": "ec0f336d87f716e6601d6fba4522e2318b6eb508",
            "filename": "tensorflow/compiler/aot/codegen_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 14,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcodegen_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcodegen_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcodegen_test.cc?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -53,7 +53,7 @@ TEST(ValidateCppIdent, Simple) {\n   TF_EXPECT_OK(ValidateCppIdent(\"_abc\", \"\"));\n   TF_EXPECT_OK(ValidateCppIdent(\"_abc123\", \"\"));\n   // Make sure we didn't skip a valid letter or digit\n-  string ident;\n+  std::string ident;\n   for (char c = 'a'; c <= 'z'; c++) {\n     ident.append(1, c);\n   }\n@@ -78,18 +78,19 @@ TEST(ValidateCppIdent, Simple) {\n \n class ParseCppClassTest : public ::testing::Test {\n  protected:\n-  void ExpectOK(const string& cpp_class, const string& want_class_name,\n-                const std::vector<string>& want_namespaces) {\n-    string class_name;\n-    std::vector<string> namespaces;\n+  void ExpectOK(const std::string& cpp_class,\n+                const std::string& want_class_name,\n+                const std::vector<std::string>& want_namespaces) {\n+    std::string class_name;\n+    std::vector<std::string> namespaces;\n     TF_EXPECT_OK(ParseCppClass(cpp_class, &class_name, &namespaces));\n     EXPECT_EQ(class_name, want_class_name);\n     EXPECT_EQ(namespaces, want_namespaces);\n   }\n \n-  void ExpectFail(const string& cpp_class) {\n-    string class_name;\n-    std::vector<string> namespaces;\n+  void ExpectFail(const std::string& cpp_class) {\n+    std::string class_name;\n+    std::vector<std::string> namespaces;\n     EXPECT_NE(ParseCppClass(cpp_class, &class_name, &namespaces),\n               absl::OkStatus())\n         << cpp_class;\n@@ -110,7 +111,7 @@ TEST_F(ParseCppClassTest, ParseOK) {\n   ExpectOK(\"::_foo::MyClass\", \"MyClass\", {\"_foo\"});\n   ExpectOK(\"::_foo::_MyClass\", \"_MyClass\", {\"_foo\"});\n   // Make sure we didn't skip a valid letter or digit\n-  string ident;\n+  std::string ident;\n   for (char c = 'a'; c <= 'z'; c++) {\n     ident.append(1, c);\n   }\n@@ -143,10 +144,10 @@ TEST_F(ParseCppClassTest, ParseFail) {\n }\n \n static void CompareWithGoldenFile(\n-    const string& tensorflow_relative_golden_file_name,\n-    const string& expected_contents, bool ignore_cr) {\n+    const std::string& tensorflow_relative_golden_file_name,\n+    const std::string& expected_contents, bool ignore_cr) {\n   // Get rid of all CR characters, we may be running under windows.\n-  string sanitized_expected_contents(expected_contents);\n+  std::string sanitized_expected_contents(expected_contents);\n   if (ignore_cr) {\n     sanitized_expected_contents.erase(\n         std::remove(sanitized_expected_contents.begin(),\n@@ -159,15 +160,15 @@ static void CompareWithGoldenFile(\n   // blaz test --test_strategy=local \\\n   //   \"third_party/tensorflow/compiler/aot:codegen_test\"\n   const bool update_golden = false;\n-  string golden_file_name =\n+  std::string golden_file_name =\n       GetDataDependencyFilepath(tensorflow_relative_golden_file_name);\n \n   if (update_golden) {\n     TF_EXPECT_OK(\n         WriteStringToFile(Env::Default(), golden_file_name, expected_contents));\n   }\n \n-  string golden_file_contents;\n+  std::string golden_file_contents;\n   TF_ASSERT_OK(ReadFileToString(Env::Default(), golden_file_name,\n                                 &golden_file_contents));\n   if (ignore_cr) {"
        },
        {
            "sha": "48c92bf346926f2a5b500a2ad85207360e78b68f",
            "filename": "tensorflow/compiler/aot/compile.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcompile.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcompile.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcompile.cc?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -212,7 +212,7 @@ absl::Status CompileGraph(GraphDef graph_def, const tf2xla::Config& config,\n   return CompileXla(client, computation, aot_opts, compile_result);\n }\n \n-static absl::Status ReadProtoFile(const string& fname,\n+static absl::Status ReadProtoFile(const std::string& fname,\n                                   protobuf::Message* proto) {\n   if (absl::EndsWith(fname, \".pbtxt\")) {\n     return ReadTextProto(Env::Default(), fname, proto);\n@@ -297,7 +297,7 @@ absl::Status Main(const MainFlags& flags) {\n   TF_RETURN_IF_ERROR(ReadProtoFile(flags.config, &config));\n   TF_RETURN_IF_ERROR(ValidateConfig(config));\n   if (flags.dump_fetch_nodes) {\n-    std::set<string> nodes;\n+    std::set<std::string> nodes;\n     for (const tf2xla::Fetch& fetch : config.fetch()) {\n       nodes.insert(fetch.id().node_name());\n     }\n@@ -368,7 +368,7 @@ absl::Status Main(const MainFlags& flags) {\n       GenerateMetadata(codegen_opts, compile_result, &metadata_result));\n   TF_RETURN_IF_ERROR(WriteStringToFile(env, flags.out_metadata_object,\n                                        metadata_result.object_file_data));\n-  string header;\n+  std::string header;\n   TF_RETURN_IF_ERROR(GenerateHeader(codegen_opts, config, compile_result,\n                                     metadata_result, embedded_constant_buffers,\n                                     &header));"
        },
        {
            "sha": "2a0418126b8aaf86b5d7cbf027accd7663d9d033",
            "filename": "tensorflow/compiler/aot/compile.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcompile.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fcompile.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcompile.h?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -38,7 +38,7 @@ struct CompileResult {\n   // Contains object file and meta-info.\n   std::unique_ptr<xla::cpu::CpuAotCompilationResult> aot;\n   xla::ProgramShapeProto program_shape;  // Static shape of args and results.\n-  string entry_point;                    // Name of generated function.\n+  std::string entry_point;               // Name of generated function.\n   int pointer_size = 0;                  // Size of a pointer in bytes.\n };\n "
        },
        {
            "sha": "1626686ba465add4ce09989f3d05f4f97fc80b0a",
            "filename": "tensorflow/compiler/aot/embedded_protocol_buffers.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fembedded_protocol_buffers.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fembedded_protocol_buffers.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fembedded_protocol_buffers.cc?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -41,9 +41,9 @@ using xla::llvm_ir::AsStringRef;\n \n static void AddEmbeddedProtocolBufferToLlvmModule(\n     llvm::Module* module, const ::tensorflow::protobuf::MessageLite& proto,\n-    absl::string_view unique_identifier, string* protobuf_array_symbol_name,\n-    int64_t* protobuf_array_size) {\n-  string protobuf_array_contents = proto.SerializeAsString();\n+    absl::string_view unique_identifier,\n+    std::string* protobuf_array_symbol_name, int64_t* protobuf_array_size) {\n+  std::string protobuf_array_contents = proto.SerializeAsString();\n   *protobuf_array_symbol_name =\n       absl::StrCat(unique_identifier, \"_protobuf_array_contents\");\n   *protobuf_array_size = protobuf_array_contents.size();\n@@ -58,10 +58,10 @@ static void AddEmbeddedProtocolBufferToLlvmModule(\n       protobuf_array_initializer, AsStringRef(*protobuf_array_symbol_name));\n }\n \n-static string CreateCPPShimExpression(\n+static std::string CreateCPPShimExpression(\n     absl::string_view qualified_cpp_protobuf_name,\n     absl::string_view protobuf_array_symbol_name, int64_t protobuf_array_size) {\n-  string code =\n+  std::string code =\n       \"[]() {\\n\"\n       \"    {{PROTOBUF_NAME}}* proto = new {{PROTOBUF_NAME}};\\n\"\n       \"    proto->ParseFromArray(&{{ARRAY_SYMBOL}}[0], {{ARRAY_SIZE}});\\n\"\n@@ -77,7 +77,7 @@ static string CreateCPPShimExpression(\n       });\n }\n \n-static absl::StatusOr<string> CodegenModule(\n+static absl::StatusOr<std::string> CodegenModule(\n     llvm::TargetMachine* target_machine, std::unique_ptr<llvm::Module> module) {\n   llvm::SmallVector<char, 0> stream_buffer;\n   llvm::raw_svector_ostream ostream(stream_buffer);\n@@ -91,7 +91,7 @@ static absl::StatusOr<string> CodegenModule(\n \n   codegen_passes.run(*module);\n \n-  return string(stream_buffer.begin(), stream_buffer.end());\n+  return std::string(stream_buffer.begin(), stream_buffer.end());\n }\n \n static absl::StatusOr<std::unique_ptr<llvm::TargetMachine>>\n@@ -124,9 +124,9 @@ absl::StatusOr<EmbeddedProtocolBuffers> CreateEmbeddedProtocolBuffers(\n   EmbeddedProtocolBuffers result;\n \n   for (const ProtobufToEmbed& protobuf_to_embed : protobufs_to_embed) {\n-    string cpp_shim, cpp_variable_decl;\n+    std::string cpp_shim, cpp_variable_decl;\n     if (protobuf_to_embed.message) {\n-      string protobuf_array_symbol_name;\n+      std::string protobuf_array_symbol_name;\n       int64_t protobuf_array_size;\n \n       AddEmbeddedProtocolBufferToLlvmModule("
        },
        {
            "sha": "aa3553f3b6a85b7592c09d84e9e8575d903ba2d7",
            "filename": "tensorflow/compiler/aot/embedded_protocol_buffers.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fembedded_protocol_buffers.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fembedded_protocol_buffers.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fembedded_protocol_buffers.h?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -37,11 +37,11 @@ struct EmbeddedProtocolBuffers {\n   struct CPPShim {\n     // `expression` is a C++ expression that creates an instance of said\n     // protocol buffer when executed.\n-    string expression;\n+    std::string expression;\n \n     // `variable_decl` is an \"extern C\" array declaration that is used in\n     // `expression`.  It must be visible wherever `expression` is emitted.\n-    string variable_decl;\n+    std::string variable_decl;\n   };\n \n   // Each cpp_shim corresponds to one embedded protocol buffer.\n@@ -50,20 +50,20 @@ struct EmbeddedProtocolBuffers {\n   // The contents of the object (\".o\") file the protocol buffers are embbed in.\n   // This needs to be linked in to any program that wants to execute any of the\n   // expressions in `cpp_shims`.\n-  string object_file_data;\n+  std::string object_file_data;\n };\n \n // Describes a protocol buffer to embed into an object file.\n struct ProtobufToEmbed {\n   // `symbol_prefix` is prefix that is guaranteed to be unique across the binary\n   // or DSO the generated object file will be linked into.\n-  string symbol_prefix;\n+  std::string symbol_prefix;\n \n   // `qualified_cpp_protobuf_name` is a qualified (\"qualified\" as in C++\n   // namespace qualified) protocol buffer name.  This is only used in\n   // CPPShim::expression so relatively qualified names are fine as long as\n   // they're valid wherever CPPShim::expression is emitted.\n-  string qualified_cpp_protobuf_name;\n+  std::string qualified_cpp_protobuf_name;\n \n   // `message` is the protocol buffer to be embedded.  It is allowed to be\n   // nullptr, in which case the generated C++ shim expression is just `nullptr`,"
        },
        {
            "sha": "5d0f93f7d67b8863647b59c7ea614a05d7ba8bf2",
            "filename": "tensorflow/compiler/aot/flags.h",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fflags.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6/tensorflow%2Fcompiler%2Faot%2Fflags.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fflags.h?ref=7de7e9ee93a204fdf0a0a590b52a85ea5c9887d6",
            "patch": "@@ -27,27 +27,27 @@ namespace tfcompile {\n // Flags for the tfcompile binary.  See *.cc file for descriptions.\n \n struct MainFlags {\n-  string graph;\n-  string debug_info;\n-  string debug_info_path_begin_marker;\n-  string config;\n+  std::string graph;\n+  std::string debug_info;\n+  std::string debug_info_path_begin_marker;\n+  std::string config;\n   bool dump_fetch_nodes = false;\n-  string target_triple;\n-  string target_cpu;\n-  string target_features;\n-  string entry_point;\n-  string cpp_class;\n-  string out_function_object;\n-  string out_metadata_object;\n-  string out_header;\n-  string out_constant_buffers_object;\n-  string out_session_module;\n-  string mlir_components;\n+  std::string target_triple;\n+  std::string target_cpu;\n+  std::string target_features;\n+  std::string entry_point;\n+  std::string cpp_class;\n+  std::string out_function_object;\n+  std::string out_metadata_object;\n+  std::string out_header;\n+  std::string out_constant_buffers_object;\n+  std::string out_session_module;\n+  std::string mlir_components;\n   bool experimental_quantize = false;\n \n   // Sanitizer pass options\n   bool sanitize_dataflow = false;\n-  string sanitize_abilists_dataflow;\n+  std::string sanitize_abilists_dataflow;\n \n   // C++ codegen options\n   bool gen_name_to_index = false;"
        }
    ],
    "stats": {
        "total": 215,
        "additions": 111,
        "deletions": 104
    }
}