{
    "author": "KanishAnand",
    "message": "Refactor Mesh ctor's\n\nPiperOrigin-RevId: 826410314",
    "sha": "adfd891fde7a75726ff7060908c8c4ab26e15ee3",
    "files": [
        {
            "sha": "1f0b8993f0db61008acec699332c83f9ef450bdd",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 21,
            "deletions": 3,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/adfd891fde7a75726ff7060908c8c4ab26e15ee3/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/adfd891fde7a75726ff7060908c8c4ab26e15ee3/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=adfd891fde7a75726ff7060908c8c4ab26e15ee3",
            "patch": "@@ -17,13 +17,15 @@ limitations under the License.\n #define XLA_HLO_IR_MESH_AND_AXIS_H_\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n #include <string>\n #include <utility>\n #include <vector>\n \n #include \"absl/log/check.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/array.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -36,11 +38,27 @@ namespace xla {\n // optimized array representation in iota based cases which is the most common\n // case.\n //\n-// Example: device_assignment {{3, 0, 2}, {1, 4, 5}} with axes names\n-// {\"data\", \"model\"} represents a 2 * 3 mesh of 6 devices, with \"data\" axis of\n-// size 2 and \"model\" axis of size 3.\n+// Example: device_assignment {{3, 0, 2}, {1, 4, 5}} with axes names {\"data\",\n+// \"model\"} represents the mesh [\"data\"=2, \"model\"=3].\n class Mesh {\n  public:\n+  // Constructs an iota device assignment mesh with given axes sizes and names.\n+  //\n+  // Example: axes_sizes {2, 3} and axes_names {\"data\", \"model\"} represent the\n+  // mesh [\"data\"=2, \"model\"=3] with iota device list. We use `TileAssignment`\n+  // optimized for iota based cases which will not store the entire array.\n+  explicit Mesh(absl::Span<const int64_t> axes_sizes,\n+                absl::Span<const std::string> axes_names)\n+      : Mesh(TileAssignment(axes_sizes), axes_names) {}\n+\n+  // Constructs a mesh with given device assignment and axes names. This ctor\n+  // should **ONLY** be used for non-iota based device assignments.\n+  explicit Mesh(Array<int64_t> device_assignment,\n+                absl::Span<const std::string> axes_names)\n+      : Mesh(TileAssignment(std::make_shared<Array<int64_t>>(\n+                 std::move(device_assignment))),\n+             axes_names) {}\n+\n   explicit Mesh(TileAssignment device_assignment,\n                 absl::Span<const std::string> axes_names)\n       : device_assignment_(std::move(device_assignment)),"
        },
        {
            "sha": "c145714f23ea7e1096e511ca109851e57c4737a9",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 25,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/adfd891fde7a75726ff7060908c8c4ab26e15ee3/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/adfd891fde7a75726ff7060908c8c4ab26e15ee3/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc?ref=adfd891fde7a75726ff7060908c8c4ab26e15ee3",
            "patch": "@@ -46,12 +46,9 @@ TEST(MeshAndAxisTest, MeshEquality) {\n   std::vector<std::string> axes_abc = {\"a\", \"b\", \"c\"};\n   std::vector<std::string> axes_abcd = {\"a\", \"b\", \"c\", \"d\"};\n   std::vector<std::string> axes_efgh = {\"e\", \"f\", \"g\", \"h\"};\n-  EXPECT_EQ(Mesh(TileAssignment({{1, 2, 3}}), axes_abc),\n-            Mesh(TileAssignment({{1, 2, 3}}), axes_abc));\n-  EXPECT_NE(Mesh(TileAssignment({{1, 2, 3, 4}}), axes_abcd),\n-            Mesh(TileAssignment({{1, 2, 3, 4}}), axes_efgh));\n-  EXPECT_NE(Mesh(TileAssignment({{1, 2, 3}}), axes_abc),\n-            Mesh(TileAssignment({{1, 2, 3, 4}}), axes_abcd));\n+  EXPECT_EQ(Mesh({1, 2, 3}, axes_abc), Mesh({1, 2, 3}, axes_abc));\n+  EXPECT_NE(Mesh({1, 2, 3, 4}, axes_abcd), Mesh({1, 2, 3, 4}, axes_efgh));\n+  EXPECT_NE(Mesh({1, 2, 3}, axes_abc), Mesh({1, 2, 3, 4}, axes_abcd));\n }\n \n TEST(MeshAndAxisTest, AxesToProto) {\n@@ -91,9 +88,7 @@ TEST(MeshAndAxisTest, MeshToAndFromProtoIotaTiling) {\n   proto.mutable_axes(1)->set_size(3);\n   proto.mutable_axes(2)->set_size(6);\n \n-  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3, 6});\n-  std::vector<std::string> axes_abc = {\"a\", \"b\", \"c\"};\n-  Mesh mesh(TileAssignment(iota), axes_abc);\n+  Mesh mesh({2, 3, 6}, {\"a\", \"b\", \"c\"});\n \n   EXPECT_THAT(mesh.ToProto(), EqualsProto(proto));\n   EXPECT_EQ(mesh, Mesh::FromProto(proto));\n@@ -117,12 +112,13 @@ TEST(MeshAndAxisTest, MeshToProtoIotaTilingWithReshapeDims) {\n   }\n \n   std::vector<std::string> axes_names = {\"axis1\", \"axis2\", \"axis3\"};\n-  EXPECT_THAT(Mesh(TileAssignment(IotaTileAssignment::Create(\n-                       /*dims=*/{4, 4, 1}, /*reshape_dims=*/{4, 2, 2},\n-                       /*transpose_perm=*/{1, 0, 2})),\n-                   axes_names)\n-                  .ToProto(),\n-              EqualsProto(expected));\n+  EXPECT_THAT(\n+      Mesh(TileAssignment(IotaTileAssignment::Create(\n+               /*dims=*/{4, 4, 1},\n+               /*reshape_dims=*/{4, 2, 2}, /*transpose_perm=*/{1, 0, 2})),\n+           axes_names)\n+          .ToProto(),\n+      EqualsProto(expected));\n }\n \n TEST(MeshAndAxisTest, MeshToProtoNonIotaTiling) {\n@@ -138,10 +134,7 @@ TEST(MeshAndAxisTest, MeshToProtoNonIotaTiling) {\n \n   Array2D<int64_t> array({{6, 3}, {0, 1}, {5, 2}, {7, 4}});\n   std::vector<std::string> axes_xy = {\"x\", \"y\"};\n-  EXPECT_THAT(\n-      Mesh(TileAssignment(std::make_shared<Array<int64_t>>(array)), axes_xy)\n-          .ToProto(),\n-      EqualsProto(expected));\n+  EXPECT_THAT(Mesh(array, axes_xy).ToProto(), EqualsProto(expected));\n }\n \n TEST(MeshAndAxisTest, MeshFromProtoNonIotaTiling) {\n@@ -157,22 +150,19 @@ TEST(MeshAndAxisTest, MeshFromProtoNonIotaTiling) {\n \n   Array2D<int64_t> array({{0, 1}, {6, 3}, {7, 4}, {5, 2}});\n   std::vector<std::string> axes_xy = {\"x\", \"y\"};\n-  EXPECT_EQ(\n-      Mesh(TileAssignment(std::make_shared<Array<int64_t>>(array)), axes_xy),\n-      Mesh::FromProto(expected));\n+  EXPECT_EQ(Mesh(array, axes_xy), Mesh::FromProto(expected));\n }\n \n TEST(MeshAndAxisTest, MeshRoundtripProto) {\n   // Iota tiling.\n   std::vector<std::string> axes_xy = {\"data\", \"model\"};\n-  Mesh mesh_iota(TileAssignment(IotaTileAssignment::Create({5, 3})), axes_xy);\n+  Mesh mesh_iota({5, 3}, axes_xy);\n   EXPECT_THAT(mesh_iota, Mesh::FromProto(mesh_iota.ToProto()));\n \n   // Non-iota tiling.\n   Array2D<int64_t> array(\n       {{14, 7, 6}, {12, 0, 8}, {11, 10, 5}, {11, 9, 3}, {2, 13, 4}});\n-  Mesh mesh_non_iota(TileAssignment(std::make_shared<Array<int64_t>>(array)),\n-                     axes_xy);\n+  Mesh mesh_non_iota(array, axes_xy);\n   EXPECT_THAT(mesh_non_iota, Mesh::FromProto(mesh_non_iota.ToProto()));\n }\n "
        }
    ],
    "stats": {
        "total": 64,
        "additions": 36,
        "deletions": 28
    }
}