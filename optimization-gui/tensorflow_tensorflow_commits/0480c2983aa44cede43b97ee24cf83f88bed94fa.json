{
    "author": "sergachev",
    "message": "PR #30856: Let bitcast decomposition fail on element count mismatches.\n\nImported from GitHub PR https://github.com/openxla/xla/pull/30856\n\nCopybara import of the project:\n\n--\n0d91b66ac409a26c2b6595b227a8135722029261 by Ilia Sergachev <isergachev@nvidia.com>:\n\nLet bitcast decomposition fail on bitwidth mismatches.\n\nMerging this change closes #30856\n\nPiperOrigin-RevId: 802983139",
    "sha": "0480c2983aa44cede43b97ee24cf83f88bed94fa",
    "files": [
        {
            "sha": "b52094c3c4a74e334030e4ff9e61b10513fb6f27",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/fusion_emitter.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc?ref=0480c2983aa44cede43b97ee24cf83f88bed94fa",
            "patch": "@@ -690,6 +690,7 @@ absl::StatusOr<ScalarOrTensor> EmitTiledBitcast(\n \n   // Any Bitcast is decomposable to a transpose+reshape+transpose.\n   auto trt = ShapeUtil::DecomposeBitcastToTrt(input_shape, output_shape);\n+  TF_RET_CHECK(trt.has_value());\n \n   // When replacing the `bitcast` with `transpose` + `reshape` + `transpose` we\n   // need to provide the tile sizes at output of each op. We already have the\n@@ -705,22 +706,22 @@ absl::StatusOr<ScalarOrTensor> EmitTiledBitcast(\n   // different, even in rank, compared to the tile sizes of the final shape of\n   // the bitcast, so it's not possible to easily propagate them from the output.\n   std::vector<int64_t> transpose1_tile_sizes =\n-      Permute(tiled_bitcast.operand(0)->tile_sizes(), trt.transpose1_dims);\n+      Permute(tiled_bitcast.operand(0)->tile_sizes(), trt->transpose1_dims);\n   Value normalized_input =\n-      trt.IsTranspose1Identity()\n+      trt->IsTranspose1Identity()\n           ? input\n           : EmitTiledTranspose(b, transpose1_tile_sizes,\n-                               llvm::to_vector(trt.transpose1_dims), input);\n+                               llvm::to_vector(trt->transpose1_dims), input);\n \n   // Like the first transpose above, the tile sizes after the second transpose\n   // are a permutation (according to transpose2_dims) of the tile sizes of\n   // the reshape. Since we know the tile sizes of the final transpose and need\n   // the tile sizes of the reshape, we compute the tile sizes backwards, taking\n   // the inverse permutation.\n   std::vector<int64_t> reshape_tile_sizes =\n-      PermuteInverse(tiled_bitcast.tile_sizes(), trt.transpose2_dims);\n+      PermuteInverse(tiled_bitcast.tile_sizes(), trt->transpose2_dims);\n   Value normalized_reshape;\n-  if (ShapeUtil::Equal(trt.transpose1_shape, trt.reshape_shape)) {\n+  if (ShapeUtil::Equal(trt->transpose1_shape, trt->reshape_shape)) {\n     normalized_reshape = normalized_input;\n   } else {\n     TF_ASSIGN_OR_RETURN(auto reshape,\n@@ -732,10 +733,10 @@ absl::StatusOr<ScalarOrTensor> EmitTiledBitcast(\n   // The final transpose simply uses the tile sizes computed for the original\n   // bitcast by the tiling analysis.\n   return ScalarOrTensor{\n-      trt.IsTranspose2Identity()\n+      trt->IsTranspose2Identity()\n           ? normalized_reshape\n           : EmitTiledTranspose(b, tiled_bitcast.tile_sizes(),\n-                               llvm::to_vector(trt.transpose2_dims),\n+                               llvm::to_vector(trt->transpose2_dims),\n                                normalized_reshape)};\n }\n "
        },
        {
            "sha": "9e6d6f9abb1c174f8b1de87d831de952acf92c94",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_analysis.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.cc?ref=0480c2983aa44cede43b97ee24cf83f88bed94fa",
            "patch": "@@ -1267,9 +1267,12 @@ IndexingMap GetBitcastMap(const Shape& input_shape, const Shape& output_shape,\n                           MLIRContext* mlir_context) {\n   ShapeUtil::BitcastDecomposition decomposed_bitcast =\n       ShapeUtil::DecomposeBitcast(input_shape, output_shape);\n+  if (!decomposed_bitcast.has_value()) {\n+    return IndexingMap::GetUndefined();\n+  }\n \n   if (std::holds_alternative<ShapeUtil::BitcastDecompositionTranspose>(\n-          decomposed_bitcast)) {\n+          *decomposed_bitcast)) {\n     auto permutation = ShapeUtil::DeduceTransposeDimensionsForBitcast(\n         input_shape, output_shape);\n     CHECK(permutation.has_value())\n@@ -1280,15 +1283,15 @@ IndexingMap GetBitcastMap(const Shape& input_shape, const Shape& output_shape,\n         input_shape.dimensions(), {});\n   }\n   if (std::holds_alternative<ShapeUtil::BitcastDecompositionReshape>(\n-          decomposed_bitcast)) {\n+          *decomposed_bitcast)) {\n     // Note: ComputeReshapeIndexingMap assumes it's computing an output->input\n     // indexing, so input and output are reversed.\n     return IndexingMap::FromTensorSizes(\n         ComputeReshapeIndexingMap(output_shape, input_shape, mlir_context),\n         input_shape.dimensions(), {});\n   }\n   // `trt` stands for transpose-reshape-transpose decomposition of bitcast.\n-  auto trt = std::get<ShapeUtil::BitcastDecompositionTrt>(decomposed_bitcast);\n+  auto trt = std::get<ShapeUtil::BitcastDecompositionTrt>(*decomposed_bitcast);\n   auto transpose_map_1 =\n       ComputeTransposeIndexingMap(trt.transpose1_dims, mlir_context);\n   auto reshape_map = ComputeReshapeIndexingMap("
        },
        {
            "sha": "fc1a80067ea6d38513079d8c409b782b47f1c658",
            "filename": "third_party/xla/xla/service/llvm_ir/ir_array.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fir_array.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fir_array.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fllvm_ir%2Fir_array.cc?ref=0480c2983aa44cede43b97ee24cf83f88bed94fa",
            "patch": "@@ -345,27 +345,28 @@ IrArray::Index IrArray::Index::SourceIndexOfBitcast(\n \n   const ShapeUtil::BitcastDecomposition decomposition =\n       ShapeUtil::DecomposeBitcast(operand_shape, shape);\n+  CHECK(decomposition.has_value());\n \n   // In case the bitcast is just a reshape, we can use SourceIndexOfReshape()\n   // instead. This will reuse linear() if possible, so we don't have to build a\n   // new 'linear_index'.\n   if (std::holds_alternative<ShapeUtil::BitcastDecompositionReshape>(\n-          decomposition)) {\n+          *decomposition)) {\n     return SourceIndexOfReshape(shape, operand_shape, builder);\n   }\n \n   if (std::holds_alternative<ShapeUtil::BitcastDecompositionTranspose>(\n-          decomposition)) {\n+          *decomposition)) {\n     const auto& decomposition_transpose =\n-        std::get<ShapeUtil::BitcastDecompositionTranspose>(decomposition);\n+        std::get<ShapeUtil::BitcastDecompositionTranspose>(*decomposition);\n     return SourceIndexOfTranspose(shape, operand_shape,\n                                   decomposition_transpose.transpose_dims);\n   }\n \n   CHECK(std::holds_alternative<ShapeUtil::BitcastDecompositionTrt>(\n-      decomposition));\n+      *decomposition));\n   const auto& decomposition_trt =\n-      std::get<ShapeUtil::BitcastDecompositionTrt>(decomposition);\n+      std::get<ShapeUtil::BitcastDecompositionTrt>(*decomposition);\n \n   Index index = *this;\n   if (!decomposition_trt.IsTranspose2Identity()) {"
        },
        {
            "sha": "09b84aa12a8f1b95fad6286833eec5b0ccb98499",
            "filename": "third_party/xla/xla/shape_util.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fshape_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fshape_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fshape_util.cc?ref=0480c2983aa44cede43b97ee24cf83f88bed94fa",
            "patch": "@@ -1691,11 +1691,18 @@ bool ShapeUtil::BitcastDecompositionTrt::IsTranspose2Identity() const {\n   return absl::c_is_sorted(transpose2_dims);\n }\n \n-/* static */ ShapeUtil::BitcastDecompositionTrt\n+bool ShapeUtil::IsDecomposableBitcast(const Shape& input_shape,\n+                                      const Shape& output_shape) {\n+  return input_shape.has_layout() && output_shape.has_layout() &&\n+         ElementsIn(input_shape) == ElementsIn(output_shape);\n+}\n+\n+/* static */ std::optional<ShapeUtil::BitcastDecompositionTrt>\n ShapeUtil::DecomposeBitcastToTrt(const Shape& input_shape,\n                                  const Shape& output_shape) {\n-  CHECK(input_shape.has_layout()) << input_shape.ToString();\n-  CHECK(output_shape.has_layout()) << output_shape.ToString();\n+  if (!IsDecomposableBitcast(input_shape, output_shape)) {\n+    return std::nullopt;\n+  }\n \n   BitcastDecompositionTrt decomposition;\n   decomposition.transpose1_shape =\n@@ -1732,8 +1739,9 @@ ShapeUtil::DecomposeBitcastToTrt(const Shape& input_shape,\n \n /* static */ ShapeUtil::BitcastDecomposition ShapeUtil::DecomposeBitcast(\n     const Shape& input_shape, const Shape& output_shape) {\n-  CHECK(input_shape.has_layout()) << input_shape.ToString();\n-  CHECK(output_shape.has_layout()) << output_shape.ToString();\n+  if (!IsDecomposableBitcast(input_shape, output_shape)) {\n+    return std::nullopt;\n+  }\n \n   if (ShapeUtil::ReshapeIsBitcast(input_shape, output_shape,\n                                   /*ignore_element_type=*/true)) {"
        },
        {
            "sha": "a4e134bcb3000e3e25609d02b41b00dd2e3bfa79",
            "filename": "third_party/xla/xla/shape_util.h",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fshape_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fshape_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fshape_util.h?ref=0480c2983aa44cede43b97ee24cf83f88bed94fa",
            "patch": "@@ -925,6 +925,9 @@ class ShapeUtil {\n   DeduceTransposeDimensionsForBitcast(const Shape& input_shape,\n                                       const Shape& output_shape);\n \n+  static bool IsDecomposableBitcast(const Shape& input_shape,\n+                                    const Shape& output_shape);\n+\n   // This means that the bitcast can be decomposed to a single reshape.\n   struct BitcastDecompositionReshape {};\n \n@@ -933,7 +936,8 @@ class ShapeUtil {\n     std::vector<int64_t> transpose_dims;\n   };\n \n-  // Every bitcast from A to B can be represented as a sequence of:\n+  // Every bitcast from A to B of same bitwidth can be represented as a sequence\n+  // of:\n   // 1) Transpose to a normalized layout of A\n   // 2) Reshape to a normalized layout of B\n   // 3) Transpose from (2) to B\n@@ -956,14 +960,14 @@ class ShapeUtil {\n   };\n \n   // A variant type holding one of the possible bitcast decompositions.\n-  using BitcastDecomposition =\n+  using BitcastDecomposition = std::optional<\n       std::variant<BitcastDecompositionReshape, BitcastDecompositionTranspose,\n-                   BitcastDecompositionTrt>;\n+                   BitcastDecompositionTrt>>;\n \n   // Decomposes a bitcast to a sequence of transpose, reshape, transpose.\n   //\n   // See the comment on BitcastDecompositionTrt.\n-  static BitcastDecompositionTrt DecomposeBitcastToTrt(\n+  static std::optional<BitcastDecompositionTrt> DecomposeBitcastToTrt(\n       const Shape& input_shape, const Shape& output_shape);\n \n   // Decomposes a bitcast to one of the possible decompositions."
        },
        {
            "sha": "77e241e4c0b465845018a86a217cd8913fa6df16",
            "filename": "third_party/xla/xla/shape_util_test.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 12,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fshape_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0480c2983aa44cede43b97ee24cf83f88bed94fa/third_party%2Fxla%2Fxla%2Fshape_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fshape_util_test.cc?ref=0480c2983aa44cede43b97ee24cf83f88bed94fa",
            "patch": "@@ -1395,7 +1395,7 @@ TEST(ShapeUtilTest, DecomposeBitcastToReshape) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   EXPECT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionReshape>(\n-      decomposition));\n+      *decomposition));\n }\n \n TEST(ShapeUtilTest, DecomposeBitcastToReshape2) {\n@@ -1408,7 +1408,7 @@ TEST(ShapeUtilTest, DecomposeBitcastToReshape2) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   EXPECT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionReshape>(\n-      decomposition));\n+      *decomposition));\n }\n \n TEST(ShapeUtilTest, DecomposeBitcastToTranspose) {\n@@ -1422,9 +1422,9 @@ TEST(ShapeUtilTest, DecomposeBitcastToTranspose) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   ASSERT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionTranspose>(\n-      decomposition));\n+      *decomposition));\n   ShapeUtil::BitcastDecompositionTranspose decomposition_transpose =\n-      std::get<ShapeUtil::BitcastDecompositionTranspose>(decomposition);\n+      std::get<ShapeUtil::BitcastDecompositionTranspose>(*decomposition);\n   EXPECT_EQ(decomposition_transpose.transpose_dims, kExpectedTransposeDims);\n }\n \n@@ -1444,9 +1444,9 @@ TEST(ShapeUtilTest, DecomposeBitcastToReshapeAndTranspose) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   ASSERT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionTrt>(\n-      decomposition));\n+      *decomposition));\n   ShapeUtil::BitcastDecompositionTrt decomposition_trt =\n-      std::get<ShapeUtil::BitcastDecompositionTrt>(decomposition);\n+      std::get<ShapeUtil::BitcastDecompositionTrt>(*decomposition);\n   EXPECT_EQ(decomposition_trt.transpose1_dims, kExpectedTranspose1Dims);\n   EXPECT_TRUE(decomposition_trt.IsTranspose1Identity());\n   EXPECT_EQ(decomposition_trt.transpose1_shape, kExpectedTranspose1Shape);\n@@ -1471,9 +1471,9 @@ TEST(ShapeUtilTest, DecomposeBitcastToReshapeAndTranspose2) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   ASSERT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionTrt>(\n-      decomposition));\n+      *decomposition));\n   ShapeUtil::BitcastDecompositionTrt decomposition_trt =\n-      std::get<ShapeUtil::BitcastDecompositionTrt>(decomposition);\n+      std::get<ShapeUtil::BitcastDecompositionTrt>(*decomposition);\n   EXPECT_EQ(decomposition_trt.transpose1_dims, kExpectedTranspose1Dims);\n   EXPECT_TRUE(decomposition_trt.IsTranspose1Identity());\n   EXPECT_EQ(decomposition_trt.transpose1_shape, kExpectedTranspose1Shape);\n@@ -1498,9 +1498,9 @@ TEST(ShapeUtilTest, DecomposeBitcastToTransposeAndReshape) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   ASSERT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionTrt>(\n-      decomposition));\n+      *decomposition));\n   ShapeUtil::BitcastDecompositionTrt decomposition_trt =\n-      std::get<ShapeUtil::BitcastDecompositionTrt>(decomposition);\n+      std::get<ShapeUtil::BitcastDecompositionTrt>(*decomposition);\n   EXPECT_EQ(decomposition_trt.transpose1_dims, kExpectedTranspose1Dims);\n   EXPECT_FALSE(decomposition_trt.IsTranspose1Identity());\n   EXPECT_EQ(decomposition_trt.transpose1_shape, kExpectedTranspose1Shape);\n@@ -1526,9 +1526,9 @@ TEST(ShapeUtilTest, DecomposeBitcastToTrt) {\n       ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape);\n \n   ASSERT_TRUE(std::holds_alternative<ShapeUtil::BitcastDecompositionTrt>(\n-      decomposition));\n+      *decomposition));\n   ShapeUtil::BitcastDecompositionTrt decomposition_trt =\n-      std::get<ShapeUtil::BitcastDecompositionTrt>(decomposition);\n+      std::get<ShapeUtil::BitcastDecompositionTrt>(*decomposition);\n   EXPECT_EQ(decomposition_trt.transpose1_dims, kExpectedTranspose1Dims);\n   EXPECT_FALSE(decomposition_trt.IsTranspose1Identity());\n   EXPECT_EQ(decomposition_trt.transpose1_shape, kExpectedTranspose1Shape);\n@@ -1537,6 +1537,18 @@ TEST(ShapeUtilTest, DecomposeBitcastToTrt) {\n   EXPECT_FALSE(decomposition_trt.IsTranspose2Identity());\n }\n \n+TEST(ShapeUtilTest, FailOnNonDecomposableBitcast) {\n+  const Shape kInputShape =\n+      ShapeUtil::MakeShapeWithDenseLayout(S4, {3, 2}, {1, 0});\n+  const Shape kOutputShape = ShapeUtil::MakeShapeWithDenseLayout(S8, {3}, {0});\n+  EXPECT_FALSE(ShapeUtil::IsDecomposableBitcast(kInputShape, kOutputShape));\n+  EXPECT_FALSE(\n+      ShapeUtil::DecomposeBitcast(kInputShape, kOutputShape).has_value());\n+\n+  EXPECT_TRUE(ShapeUtil::IsDecomposableBitcast(\n+      kInputShape, ShapeUtil::ChangeElementType(kInputShape, S8)));\n+}\n+\n TEST(ShapeUtilTest, ReorderDimensionsTest) {\n   EXPECT_EQ(ShapeUtil::ReorderLogicalDimensions(\n                 ShapeUtil::MakeShapeWithDenseLayout(F32, {16, 3, 12, 17},"
        }
    ],
    "stats": {
        "total": 101,
        "additions": 65,
        "deletions": 36
    }
}