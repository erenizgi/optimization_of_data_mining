{
    "author": "tensorflower-gardener",
    "message": "Move `xla::Interval` to a separate header file.\n\nThis change refactors the `xla::Interval` struct and its related functions from `indexing_map.h` into a new file, `interval.h/cc`. This improves modularity and allows SymbolicMap to depend on `Interval` without pulling in all of `indexing_map.h` and having circular dependences.\n\nPiperOrigin-RevId: 810808483",
    "sha": "65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
    "files": [
        {
            "sha": "d87e542d631dc73da200adc53efd49b3980b79b5",
            "filename": "third_party/xla/xla/hlo/analysis/BUILD",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -621,6 +621,29 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"interval\",\n+    srcs = [\"interval.cc\"],\n+    hdrs = [\"interval.h\"],\n+    deps = [\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/numeric:int128\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@llvm-project//llvm:Support\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"interval_test\",\n+    srcs = [\"interval_test.cc\"],\n+    deps = [\n+        \":interval\",\n+        \"//xla/tests:hlo_test_base\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:test\",\n+    ],\n+)\n+\n cc_library(\n     name = \"indexing_analysis\",\n     srcs = [\n@@ -634,6 +657,7 @@ cc_library(\n         \"indexing_map_serialization.h\",\n     ],\n     deps = [\n+        \":interval\",\n         \"//xla:permutation_util\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n@@ -666,6 +690,7 @@ xla_cc_test(\n     deps = [\n         \":indexing_analysis\",\n         \":indexing_test_utils\",\n+        \":interval\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:verified_hlo_module\",\n         \"//xla/tests:xla_internal_test_main\",\n@@ -685,6 +710,7 @@ xla_cc_test(\n     deps = [\n         \":indexing_analysis\",\n         \":indexing_test_utils\",\n+        \":interval\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"@com_google_absl//absl/strings:string_view\",\n@@ -701,6 +727,7 @@ cc_library(\n     hdrs = [\"indexing_test_utils.h\"],\n     deps = [\n         \":indexing_analysis\",\n+        \":interval\",\n         \"//xla:status_macros\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:verified_hlo_module\",\n@@ -729,6 +756,7 @@ xla_cc_test(\n     deps = [\n         \":indexing_analysis\",\n         \":indexing_test_utils\",\n+        \":interval\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/utils:hlo_traversal\",\n         \"//xla/tests:xla_internal_test_main\","
        },
        {
            "sha": "cfea502b8d5fe4ff673b5160577c9fa149248f46",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_map.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 136,
            "changes": 137,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.cc?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -48,6 +48,7 @@ limitations under the License.\n #include \"mlir/IR/AffineMap.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/Support/LLVM.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n #include \"tsl/platform/logging.h\"  // IWYU pragma: keep\n \n namespace xla {\n@@ -867,142 +868,6 @@ std::ostream& operator<<(std::ostream& out, VariableKind var_type) {\n   return out;\n }\n \n-std::ostream& operator<<(std::ostream& out, const Interval& interval) {\n-  out << absl::StrFormat(\"[%d, %d]\", interval.lower, interval.upper);\n-  return out;\n-}\n-\n-std::string Interval::ToString() const {\n-  std::stringstream ss;\n-  ss << *this;\n-  return ss.str();\n-}\n-\n-inline llvm::raw_ostream& operator<<(llvm::raw_ostream& os,\n-                                     const Interval& interval) {\n-  os << absl::StrFormat(\"[%d, %d]\", interval.lower, interval.upper);\n-  return os;\n-}\n-\n-int64_t Interval::GetLoopTripCount() const {\n-  if (!IsFeasible()) {\n-    return 0;\n-  }\n-  DCHECK((static_cast<absl::int128>(upper) - lower + 1) <=\n-         std::numeric_limits<int64_t>::max());\n-  return upper - lower + 1;\n-}\n-\n-Interval::ComparisonResult Interval::Gt(const Interval& b) const {\n-  if (!IsFeasible() || !b.IsFeasible()) {\n-    return {std::nullopt};\n-  }\n-  if (lower > b.upper) {\n-    return {true};\n-  }\n-  if (upper <= b.lower) {\n-    return {false};\n-  }\n-  return {std::nullopt};\n-}\n-\n-Interval::ComparisonResult Interval::Eq(const Interval& b) const {\n-  Interval intersection = Intersect(b);\n-  if (!intersection.IsFeasible()) {\n-    return {false};\n-  }\n-  if (intersection.IsPoint() && IsPoint() && b.IsPoint()) {\n-    return {true};\n-  }\n-  return {std::nullopt};\n-}\n-\n-Interval Interval::operator+(const Interval& rhs) const {\n-  int64_t out_lower;\n-  int64_t out_upper;\n-\n-  constexpr int64_t kMin = std::numeric_limits<int64_t>::min();\n-  constexpr int64_t kMax = std::numeric_limits<int64_t>::max();\n-\n-  bool lower_overflow = llvm::AddOverflow(lower, rhs.lower, out_lower);\n-  bool upper_overflow = llvm::AddOverflow(upper, rhs.upper, out_upper);\n-\n-  if (lower_overflow || lower == kMin || rhs.lower == kMin) {\n-    if (lower < 0 || rhs.lower < 0) {\n-      out_lower = kMin;\n-    } else {\n-      out_lower = kMax;\n-      out_upper = kMax;\n-    }\n-  }\n-\n-  if (upper_overflow || upper == kMax || rhs.upper == kMax) {\n-    if (upper > 0 || rhs.upper > 0) {\n-      out_upper = kMax;\n-    } else {\n-      out_upper = kMin;\n-      out_lower = kMin;\n-    }\n-  }\n-\n-  return {out_lower, out_upper};\n-}\n-\n-Interval Interval::operator*(const Interval& rhs) const {\n-  constexpr int64_t kMin = std::numeric_limits<int64_t>::min();\n-  constexpr int64_t kMax = std::numeric_limits<int64_t>::max();\n-\n-  auto mul = [&](int64_t p) {\n-    int64_t l = lower;\n-    int64_t u = upper;\n-    if (p < 0) {\n-      std::swap(l, u);\n-    }\n-    int64_t out_lower;\n-    int64_t out_upper;\n-    if (llvm::MulOverflow(l, p, out_lower) ||\n-        // -1 * max is min + 1, and doesn't overflow. We consider max a\n-        // special sentinel value, so the result should be min (= saturated).\n-        (p == -1 && l == kMax)) {\n-      out_lower = kMin;\n-    }\n-    if (llvm::MulOverflow(u, p, out_upper)) {\n-      out_upper = kMax;\n-    }\n-    return Interval{out_lower, out_upper};\n-  };\n-\n-  return mul(rhs.lower).Union(mul(rhs.upper));\n-}\n-\n-Interval Interval::operator-() const {\n-  int64_t ub = lower == std::numeric_limits<int64_t>::min()\n-                   ? std::numeric_limits<int64_t>::max()\n-                   : -lower;\n-  int64_t lb = upper == std::numeric_limits<int64_t>::max()\n-                   ? std::numeric_limits<int64_t>::min()\n-                   : -upper;\n-  return Interval{lb, ub};\n-}\n-\n-Interval Interval::FloorDiv(int64_t rhs) const {\n-  auto saturate_div = [](int64_t lhs, int64_t rhs) {\n-    constexpr int64_t kMin = std::numeric_limits<int64_t>::min();\n-    constexpr int64_t kMax = std::numeric_limits<int64_t>::max();\n-    if (lhs == kMin) {\n-      return rhs > 0 ? kMin : kMax;\n-    }\n-    if (lhs == kMax) {\n-      return rhs > 0 ? kMax : kMin;\n-    }\n-    return llvm::divideFloorSigned(lhs, rhs);\n-  };\n-\n-  int64_t a = saturate_div(lower, rhs);\n-  int64_t b = saturate_div(upper, rhs);\n-  return {std::min(a, b), std::max(a, b)};\n-}\n-\n bool operator==(const IndexingMap::Variable& lhs,\n                 const IndexingMap::Variable& rhs) {\n   return lhs.bounds == rhs.bounds;"
        },
        {
            "sha": "f76f68b99bc34ba01f83d1e250c41f5093e7679b",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_map.h",
            "status": "modified",
            "additions": 1,
            "deletions": 115,
            "changes": 116,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.h?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -35,6 +35,7 @@ limitations under the License.\n #include \"mlir/IR/AffineMap.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/Support/LLVM.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n \n namespace xla {\n@@ -59,121 +60,6 @@ absl::string_view ToVariableName(VariableKind var_kind);\n VariableKind ToVariableType(absl::string_view var_name);\n std::ostream& operator<<(std::ostream& out, VariableKind var_type);\n \n-// Interval represents a closed interval [lower_bound, upper_bound].\n-struct Interval {\n-  std::string ToString() const;\n-  bool IsPoint() const { return lower == upper; }\n-  bool IsFeasible() const { return lower <= upper; }\n-\n-  // Returns the number of elements in the interval. Asserts that the number of\n-  // elements fits in an int64_t. For this reason, this should only be used for\n-  // intervals corresponding to symbols, not for general intervals. Use\n-  // `IsFeasible` to check if the interval is non-empty.\n-  int64_t GetLoopTripCount() const;\n-\n-  bool Contains(int64_t value) const {\n-    return value >= lower && value <= upper;\n-  }\n-\n-  // Returns true if this interval contains the entire other interval.\n-  bool Contains(Interval other) const { return Intersect(other) == other; }\n-\n-  // The result of a range comparison. We wrap std::optional in a struct to\n-  // avoid accidental implicit conversion to bool:\n-  // if (range < 42) {\n-  //   Executed if the result of the comparison is known to be false!\n-  // }\n-  struct ComparisonResult {\n-    // true or false if the result is known, nullopt otherwise.\n-    std::optional<bool> result;\n-\n-    ComparisonResult operator!() const {\n-      if (result) return {!*result};\n-      return {result};\n-    }\n-    bool operator==(const ComparisonResult& other) const {\n-      return result == other.result;\n-    }\n-    bool operator==(bool other) const { return result && *result == other; }\n-    bool operator==(std::nullopt_t) const { return !result; }\n-    bool operator!=(std::nullopt_t) const { return result.has_value(); }\n-    bool operator*() const { return *result; }\n-  };\n-\n-  // All comparison operators here return true or false if the result is known,\n-  // or nullopt if it may be either true or false.\n-  // We don't use operators here, because the \"==\" used for hashing is not the\n-  // same as \"Eq\".\n-  ComparisonResult Gt(const Interval& b) const;\n-  ComparisonResult Lt(const Interval& b) const { return b.Gt(*this); }\n-  ComparisonResult Ge(const Interval& b) const { return !b.Gt(*this); }\n-  ComparisonResult Le(const Interval& b) const { return !this->Gt(b); }\n-  // This is not the same as \"==\".  See the implementations.\n-  ComparisonResult Eq(const Interval& b) const;\n-  // This is not the same as \"!=\".  See the implementations.\n-  ComparisonResult Ne(const Interval& b) const { return !this->Eq(b); }\n-\n-  Interval Intersect(const Interval& rhs) const {\n-    Interval result{std::max(lower, rhs.lower), std::min(upper, rhs.upper)};\n-    if (result.upper < result.lower) {\n-      // Normalize empty results such that NumElements returns 0.\n-      result.upper = result.lower - 1;\n-    }\n-    return result;\n-  }\n-\n-  Interval Union(const Interval& rhs) const {\n-    return {std::min(lower, rhs.lower), std::max(upper, rhs.upper)};\n-  }\n-\n-  // Computes the range of the sum of the two intervals. Implements saturating\n-  // semantics (i.e. overflow and underflow get clamped to the maximum and\n-  // minimum int64). Additionally, bounds of the minimum/maximum value are\n-  // considered to be possibly saturated, i.e. `{-2 ** 63, 0} + {42, 42}`\n-  // returns `{-2 ** 63, 42}`, not `{-2 ** 63 + 42, 42}`.\n-  Interval operator+(const Interval& rhs) const;\n-  // Computes the range of the product of the two intervals. Implements\n-  // saturating semantics.\n-  Interval operator*(const Interval& rhs) const;\n-  // Computes the range of the difference of the two intervals. Implements\n-  // saturating semantics.\n-  Interval operator-(const Interval& rhs) const { return *this + (-rhs); }\n-  Interval operator-() const;\n-  Interval FloorDiv(int64_t rhs) const;\n-\n-  Interval min(const Interval& rhs) const {\n-    return {std::min(lower, rhs.lower), std::min(upper, rhs.upper)};\n-  }\n-\n-  Interval max(const Interval& rhs) const {\n-    return {std::max(lower, rhs.lower), std::max(upper, rhs.upper)};\n-  }\n-\n-  // This is not the same as \"Eq\".  See the implementations.\n-  bool operator==(const Interval& rhs) const {\n-    return lower == rhs.lower && upper == rhs.upper;\n-  }\n-  // This is not the same as \"Ne\".  See the implementations.\n-  bool operator!=(const Interval& rhs) const { return !(*this == rhs); }\n-\n-  int64_t lower = 0;\n-  int64_t upper = 0;\n-};\n-\n-std::ostream& operator<<(std::ostream& out, const Interval& interval);\n-inline llvm::raw_ostream& operator<<(llvm::raw_ostream& os,\n-                                     const Interval& interval);\n-\n-template <typename H>\n-H AbslHashValue(H h, const Interval& range) {\n-  return H::combine(std::move(h), range.lower, range.upper);\n-}\n-\n-// For use in llvm::hash_combine.\n-inline size_t hash_value(const Interval& range) {\n-  return llvm::hash_combine(range.lower, range.upper);\n-}\n-\n class IndexingMap;\n \n // Evaluates lower and upper bounds for expressions given the domain."
        },
        {
            "sha": "46b73686d7bb0c9a9c55a6430d32f105f7eec77a",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_map_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 132,
            "changes": 133,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map_test.cc?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -15,7 +15,6 @@ limitations under the License.\n \n #include \"xla/hlo/analysis/indexing_map.h\"\n \n-#include <cstdint>\n #include <limits>\n #include <memory>\n #include <optional>\n@@ -34,6 +33,7 @@ limitations under the License.\n #include \"mlir/IR/MLIRContext.h\"\n #include \"xla/hlo/analysis/indexing_map_serialization.h\"\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/verified_hlo_module.h\"\n #include \"tsl/platform/statusor.h\"\n@@ -1382,137 +1382,6 @@ TEST_F(IndexingMapTest, RangeEvaluatorTest) {\n   EXPECT_TRUE(range_evaluator.IsAlwaysNegativeOrZero(d3));\n }\n \n-TEST(IntervalComparisonTest, PointComparisons) {\n-  Interval interval{12, 64};\n-  auto point = [](int64_t n) { return Interval{n, n}; };\n-  EXPECT_EQ(interval.Gt(point(11)), true);\n-  EXPECT_EQ(interval.Gt(point(12)), std::nullopt);\n-  EXPECT_EQ(interval.Gt(point(65)), false);\n-\n-  EXPECT_EQ(interval.Lt(point(65)), true);\n-  EXPECT_EQ(interval.Lt(point(64)), std::nullopt);\n-  EXPECT_EQ(interval.Lt(point(10)), false);\n-\n-  EXPECT_EQ(interval.Eq(point(11)), false);\n-  EXPECT_EQ(interval.Eq(point(12)), std::nullopt);\n-  EXPECT_EQ(interval.Eq(point(15)), std::nullopt);\n-  EXPECT_EQ(interval.Eq(point(65)), false);\n-\n-  EXPECT_EQ(interval.Ne(point(11)), true);\n-  EXPECT_EQ(interval.Ne(point(15)), std::nullopt);\n-  EXPECT_EQ(interval.Ne(point(65)), true);\n-\n-  EXPECT_EQ(interval.Ge(point(12)), true);\n-  EXPECT_EQ(interval.Ge(point(64)), std::nullopt);\n-  EXPECT_EQ(interval.Ge(point(65)), false);\n-\n-  EXPECT_EQ(interval.Le(point(11)), false);\n-  EXPECT_EQ(interval.Le(point(64)), true);\n-  EXPECT_EQ(interval.Le(point(63)), std::nullopt);\n-  EXPECT_EQ(interval.Le(point(65)), true);\n-\n-  EXPECT_EQ(point(15).Eq(point(15)), true);\n-  EXPECT_EQ(point(15).Eq(point(16)), false);\n-\n-  EXPECT_EQ(point(15).Ne(point(15)), false);\n-  EXPECT_EQ(point(15).Ne(point(16)), true);\n-}\n-\n-TEST(IntervalComparisonTest, RangeComparisons) {\n-  Interval interval{12, 64};\n-  auto range = [](int64_t l, int64_t u) { return Interval{l, u}; };\n-  EXPECT_EQ(interval.Gt(range(-10, 11)), true);\n-  EXPECT_EQ(interval.Gt(range(-10, 12)), std::nullopt);\n-  EXPECT_EQ(interval.Gt(interval), std::nullopt);\n-  EXPECT_EQ(interval.Gt(range(10, 20)), std::nullopt);\n-  EXPECT_EQ(interval.Gt(range(50, 60)), std::nullopt);\n-  EXPECT_EQ(interval.Gt(range(64, 100)), false);\n-  EXPECT_EQ(interval.Gt(range(65, 100)), false);\n-\n-  EXPECT_EQ(interval.Lt(range(65, 100)), true);\n-  EXPECT_EQ(interval.Lt(range(64, 100)), std::nullopt);\n-  EXPECT_EQ(interval.Lt(interval), std::nullopt);\n-  EXPECT_EQ(interval.Lt(range(50, 60)), std::nullopt);\n-  EXPECT_EQ(interval.Lt(range(10, 20)), std::nullopt);\n-  EXPECT_EQ(interval.Lt(range(-10, 12)), false);\n-  EXPECT_EQ(interval.Lt(range(-10, 11)), false);\n-\n-  EXPECT_EQ(interval.Eq(interval), std::nullopt);\n-  EXPECT_EQ(interval.Eq(range(65, 100)), false);\n-  EXPECT_EQ(interval.Eq(range(0, 11)), false);\n-}\n-\n-MATCHER_P(IntervalIs, interval, \"\") {\n-  std::pair<int64_t, int64_t> arg_pair{arg.lower, arg.upper};\n-  return ::testing::ExplainMatchResult(\n-      ::testing::Pair(interval.lower, interval.upper), arg_pair,\n-      result_listener);\n-}\n-\n-TEST(IntervalMathTest, Addition) {\n-  Interval a{12, 64};\n-  Interval b{-100, 120};\n-  Interval sum{12 - 100, 64 + 120};\n-  EXPECT_THAT(a + b, IntervalIs(sum));\n-}\n-\n-TEST(IntervalMathTest, AdditionSaturating) {\n-  Interval a{12, 64};\n-  Interval b{-100, 120};\n-  Interval c{100, std::numeric_limits<int64_t>::max() - 80};\n-  Interval any{std::numeric_limits<int64_t>::min(),\n-               std::numeric_limits<int64_t>::max()};\n-  Interval positive{0, std::numeric_limits<int64_t>::max()};\n-  Interval negative{std::numeric_limits<int64_t>::min(), 0};\n-  auto range = [](int64_t l, int64_t u) { return Interval{l, u}; };\n-\n-  EXPECT_THAT(positive + negative, IntervalIs(any));\n-  EXPECT_THAT(any + any, IntervalIs(any));\n-  EXPECT_THAT(b + any, IntervalIs(any));\n-\n-  EXPECT_THAT(c + any, IntervalIs(any));\n-  EXPECT_THAT(c + positive,\n-              IntervalIs(range(100, std::numeric_limits<int64_t>::max())));\n-  Interval c_plus_negative{negative.lower, c.upper};\n-  EXPECT_THAT(c + negative, IntervalIs(c_plus_negative));\n-\n-  Interval a_plus_c{112, std::numeric_limits<int64_t>::max() - 16};\n-  EXPECT_THAT(a + c, IntervalIs(a_plus_c));\n-  Interval b_plus_c{0, std::numeric_limits<int64_t>::max()};\n-  EXPECT_THAT(b + c, IntervalIs(b_plus_c));\n-}\n-\n-TEST(IntervalMathTest, Multiplication) {\n-  Interval pos{10, 100};\n-  Interval neg{-10, -1};\n-  Interval both_small{-5, 6};\n-  Interval both_large{-20, 1000};\n-\n-  auto range = [](int64_t l, int64_t u) { return Interval{l, u}; };\n-  EXPECT_THAT(pos * neg, IntervalIs(range(-1000, -10)));\n-  EXPECT_THAT(pos * both_small, IntervalIs(range(-500, 600)));\n-  EXPECT_THAT(pos * both_large, IntervalIs(range(-2000, 100000)));\n-  EXPECT_THAT(neg * both_small, IntervalIs(range(-60, 50)));\n-  EXPECT_THAT(neg * both_large, IntervalIs(range(-10000, 200)));\n-  EXPECT_THAT(both_small * both_large, IntervalIs(range(-5000, 6000)));\n-}\n-\n-TEST(IntervalMathTest, MultiplicationSaturating) {\n-  Interval any{std::numeric_limits<int64_t>::min(),\n-               std::numeric_limits<int64_t>::max()};\n-  Interval bit33{42, std::numeric_limits<uint32_t>::max()};\n-  Interval bit33_sq{42 * 42, std::numeric_limits<int64_t>::max()};\n-  EXPECT_THAT(bit33 * bit33, IntervalIs(bit33_sq));\n-  EXPECT_THAT(any * any, IntervalIs(any));\n-\n-  Interval greater_41{42, std::numeric_limits<int64_t>::max()};\n-  Interval neg_one{-1, -1};\n-  Interval less_neg_41{std::numeric_limits<int64_t>::min(), -42};\n-  EXPECT_THAT(greater_41 * neg_one, IntervalIs(less_neg_41));\n-  EXPECT_THAT(less_neg_41 * neg_one, IntervalIs(greater_41));\n-  EXPECT_THAT(any * neg_one, IntervalIs(any));\n-}\n-\n template <typename T>\n void ExpectSupportsAbslHashAndEqAndNe(absl::Span<const T> values) {\n   EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(values));"
        },
        {
            "sha": "42a708ee5e6cd2e2c9c5238b70f43b782ef60053",
            "filename": "third_party/xla/xla/hlo/analysis/interval.cc",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval.cc?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -0,0 +1,167 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/analysis/interval.h\"\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <limits>\n+#include <optional>\n+#include <ostream>\n+#include <string>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/numeric/int128.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"llvm/Support/MathExtras.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n+\n+namespace xla {\n+\n+std::ostream& operator<<(std::ostream& out, const Interval& interval) {\n+  out << absl::StrFormat(\"[%d, %d]\", interval.lower, interval.upper);\n+  return out;\n+}\n+\n+std::string Interval::ToString() const {\n+  return absl::StrFormat(\"[%d, %d]\", lower, upper);\n+}\n+\n+inline llvm::raw_ostream& operator<<(llvm::raw_ostream& os,\n+                                     const Interval& interval) {\n+  os << absl::StrFormat(\"[%d, %d]\", interval.lower, interval.upper);\n+  return os;\n+}\n+\n+int64_t Interval::GetLoopTripCount() const {\n+  if (!IsFeasible()) {\n+    return 0;\n+  }\n+  DCHECK((static_cast<absl::int128>(upper) - lower + 1) <=\n+         std::numeric_limits<int64_t>::max());\n+  return upper - lower + 1;\n+}\n+\n+Interval::ComparisonResult Interval::Gt(const Interval& b) const {\n+  if (!IsFeasible() || !b.IsFeasible()) {\n+    return {std::nullopt};\n+  }\n+  if (lower > b.upper) {\n+    return {true};\n+  }\n+  if (upper <= b.lower) {\n+    return {false};\n+  }\n+  return {std::nullopt};\n+}\n+\n+Interval::ComparisonResult Interval::Eq(const Interval& b) const {\n+  Interval intersection = Intersect(b);\n+  if (!intersection.IsFeasible()) {\n+    return {false};\n+  }\n+  if (intersection.IsPoint() && IsPoint() && b.IsPoint()) {\n+    return {true};\n+  }\n+  return {std::nullopt};\n+}\n+\n+Interval Interval::operator+(const Interval& rhs) const {\n+  int64_t out_lower;\n+  int64_t out_upper;\n+\n+  constexpr int64_t kMin = std::numeric_limits<int64_t>::min();\n+  constexpr int64_t kMax = std::numeric_limits<int64_t>::max();\n+\n+  bool lower_overflow = llvm::AddOverflow(lower, rhs.lower, out_lower);\n+  bool upper_overflow = llvm::AddOverflow(upper, rhs.upper, out_upper);\n+\n+  if (lower_overflow || lower == kMin || rhs.lower == kMin) {\n+    if (lower < 0 || rhs.lower < 0) {\n+      out_lower = kMin;\n+    } else {\n+      out_lower = kMax;\n+      out_upper = kMax;\n+    }\n+  }\n+\n+  if (upper_overflow || upper == kMax || rhs.upper == kMax) {\n+    if (upper > 0 || rhs.upper > 0) {\n+      out_upper = kMax;\n+    } else {\n+      out_upper = kMin;\n+      out_lower = kMin;\n+    }\n+  }\n+\n+  return {out_lower, out_upper};\n+}\n+\n+Interval Interval::operator*(const Interval& rhs) const {\n+  constexpr int64_t kMin = std::numeric_limits<int64_t>::min();\n+  constexpr int64_t kMax = std::numeric_limits<int64_t>::max();\n+\n+  auto mul = [&](int64_t p) {\n+    int64_t l = lower;\n+    int64_t u = upper;\n+    if (p < 0) {\n+      std::swap(l, u);\n+    }\n+    int64_t out_lower;\n+    int64_t out_upper;\n+    if (llvm::MulOverflow(l, p, out_lower) ||\n+        // -1 * max is min + 1, and doesn't overflow. We consider max a\n+        // special sentinel value, so the result should be min (= saturated).\n+        (p == -1 && l == kMax)) {\n+      out_lower = kMin;\n+    }\n+    if (llvm::MulOverflow(u, p, out_upper)) {\n+      out_upper = kMax;\n+    }\n+    return Interval{out_lower, out_upper};\n+  };\n+\n+  return mul(rhs.lower).Union(mul(rhs.upper));\n+}\n+\n+Interval Interval::operator-() const {\n+  int64_t ub = lower == std::numeric_limits<int64_t>::min()\n+                   ? std::numeric_limits<int64_t>::max()\n+                   : -lower;\n+  int64_t lb = upper == std::numeric_limits<int64_t>::max()\n+                   ? std::numeric_limits<int64_t>::min()\n+                   : -upper;\n+  return Interval{lb, ub};\n+}\n+\n+Interval Interval::FloorDiv(int64_t rhs) const {\n+  auto saturate_div = [](int64_t lhs, int64_t rhs) {\n+    constexpr int64_t kMin = std::numeric_limits<int64_t>::min();\n+    constexpr int64_t kMax = std::numeric_limits<int64_t>::max();\n+    if (lhs == kMin) {\n+      return rhs > 0 ? kMin : kMax;\n+    }\n+    if (lhs == kMax) {\n+      return rhs > 0 ? kMax : kMin;\n+    }\n+    return llvm::divideFloorSigned(lhs, rhs);\n+  };\n+\n+  int64_t a = saturate_div(lower, rhs);\n+  int64_t b = saturate_div(upper, rhs);\n+  return {std::min(a, b), std::max(a, b)};\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "e095460de0862bcabbdc2e0330fa1b9ed0336973",
            "filename": "third_party/xla/xla/hlo/analysis/interval.h",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval.h?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -0,0 +1,148 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_HLO_ANALYSIS_INTERVAL_H_\n+#define XLA_HLO_ANALYSIS_INTERVAL_H_\n+\n+#include <algorithm>\n+#include <cstddef>\n+#include <cstdint>\n+#include <optional>\n+#include <ostream>\n+#include <string>\n+\n+#include \"llvm/ADT/Hashing.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n+\n+namespace xla {\n+\n+// Interval represents a closed interval [lower_bound, upper_bound].\n+struct Interval {\n+  std::string ToString() const;\n+  bool IsPoint() const { return lower == upper; }\n+  bool IsFeasible() const { return lower <= upper; }\n+\n+  // Returns the number of elements in the interval. Asserts that the number of\n+  // elements fits in an int64_t. For this reason, this should only be used for\n+  // intervals corresponding to symbols, not for general intervals. Use\n+  // `IsFeasible` to check if the interval is non-empty.\n+  int64_t GetLoopTripCount() const;\n+\n+  bool Contains(int64_t value) const {\n+    return value >= lower && value <= upper;\n+  }\n+\n+  // Returns true if this interval contains the entire other interval.\n+  bool Contains(Interval other) const { return Intersect(other) == other; }\n+\n+  // The result of a range comparison. We wrap std::optional in a struct to\n+  // avoid accidental implicit conversion to bool:\n+  // if (range < 42) {\n+  //   Executed if the result of the comparison is known to be false!\n+  // }\n+  struct ComparisonResult {\n+    // true or false if the result is known, nullopt otherwise.\n+    std::optional<bool> result;\n+\n+    ComparisonResult operator!() const {\n+      if (result) return {!*result};\n+      return {result};\n+    }\n+    bool operator==(const ComparisonResult& other) const {\n+      return result == other.result;\n+    }\n+    bool operator==(bool other) const { return result && *result == other; }\n+    bool operator==(std::nullopt_t) const { return !result; }\n+    bool operator!=(std::nullopt_t) const { return result.has_value(); }\n+    bool operator*() const { return *result; }\n+  };\n+\n+  // All comparison operators here return true or false if the result is known,\n+  // or nullopt if it may be either true or false.\n+  // We don't use operators here, because the \"==\" used for hashing is not the\n+  // same as \"Eq\".\n+  ComparisonResult Gt(const Interval& b) const;\n+  ComparisonResult Lt(const Interval& b) const { return b.Gt(*this); }\n+  ComparisonResult Ge(const Interval& b) const { return !b.Gt(*this); }\n+  ComparisonResult Le(const Interval& b) const { return !this->Gt(b); }\n+  // This is not the same as \"==\".  See the implementations.\n+  ComparisonResult Eq(const Interval& b) const;\n+  // This is not the same as \"!=\".  See the implementations.\n+  ComparisonResult Ne(const Interval& b) const { return !this->Eq(b); }\n+\n+  Interval Intersect(const Interval& rhs) const {\n+    Interval result{std::max(lower, rhs.lower), std::min(upper, rhs.upper)};\n+    if (result.upper < result.lower) {\n+      // Normalize empty results such that NumElements returns 0.\n+      result.upper = result.lower - 1;\n+    }\n+    return result;\n+  }\n+\n+  Interval Union(const Interval& rhs) const {\n+    return {std::min(lower, rhs.lower), std::max(upper, rhs.upper)};\n+  }\n+\n+  // Computes the range of the sum of the two intervals. Implements saturating\n+  // semantics (i.e. overflow and underflow get clamped to the maximum and\n+  // minimum int64). Additionally, bounds of the minimum/maximum value are\n+  // considered to be possibly saturated, i.e. `{-2 ** 63, 0} + {42, 42}`\n+  // returns `{-2 ** 63, 42}`, not `{-2 ** 63 + 42, 42}`.\n+  Interval operator+(const Interval& rhs) const;\n+  // Computes the range of the product of the two intervals. Implements\n+  // saturating semantics.\n+  Interval operator*(const Interval& rhs) const;\n+  // Computes the range of the difference of the two intervals. Implements\n+  // saturating semantics.\n+  Interval operator-(const Interval& rhs) const { return *this + (-rhs); }\n+  Interval operator-() const;\n+  Interval FloorDiv(int64_t rhs) const;\n+\n+  Interval min(const Interval& rhs) const {\n+    return {std::min(lower, rhs.lower), std::min(upper, rhs.upper)};\n+  }\n+\n+  Interval max(const Interval& rhs) const {\n+    return {std::max(lower, rhs.lower), std::max(upper, rhs.upper)};\n+  }\n+\n+  // This is not the same as \"Eq\".  See the implementations.\n+  bool operator==(const Interval& rhs) const {\n+    return lower == rhs.lower && upper == rhs.upper;\n+  }\n+  // This is not the same as \"Ne\".  See the implementations.\n+  bool operator!=(const Interval& rhs) const { return !(*this == rhs); }\n+\n+  int64_t lower = 0;\n+  int64_t upper = 0;\n+};\n+\n+std::ostream& operator<<(std::ostream& out, const Interval& interval);\n+inline llvm::raw_ostream& operator<<(llvm::raw_ostream& os,\n+                                     const Interval& interval);\n+\n+template <typename H>\n+H AbslHashValue(H h, const Interval& range) {\n+  return H::combine(std::move(h), range.lower, range.upper);\n+}\n+\n+// For use in llvm::hash_combine.\n+inline size_t hash_value(const Interval& range) {\n+  return llvm::hash_combine(range.lower, range.upper);\n+}\n+\n+}  // namespace xla\n+\n+#endif  // XLA_HLO_ANALYSIS_INTERVAL_H_"
        },
        {
            "sha": "8422f104eeb2649b60b775b94183283f01424233",
            "filename": "third_party/xla/xla/hlo/analysis/interval_test.cc",
            "status": "added",
            "additions": 161,
            "deletions": 0,
            "changes": 161,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/65b085fdad24ed5c2e2fa52c98a15c58ca417f60/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Finterval_test.cc?ref=65b085fdad24ed5c2e2fa52c98a15c58ca417f60",
            "patch": "@@ -0,0 +1,161 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/analysis/interval.h\"\n+\n+#include <cstdint>\n+#include <limits>\n+#include <optional>\n+#include <utility>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+namespace xla {\n+namespace {\n+\n+TEST(IntervalComparisonTest, PointComparisons) {\n+  Interval interval{12, 64};\n+  auto point = [](int64_t n) { return Interval{n, n}; };\n+  EXPECT_EQ(interval.Gt(point(11)), true);\n+  EXPECT_EQ(interval.Gt(point(12)), std::nullopt);\n+  EXPECT_EQ(interval.Gt(point(65)), false);\n+\n+  EXPECT_EQ(interval.Lt(point(65)), true);\n+  EXPECT_EQ(interval.Lt(point(64)), std::nullopt);\n+  EXPECT_EQ(interval.Lt(point(10)), false);\n+\n+  EXPECT_EQ(interval.Eq(point(11)), false);\n+  EXPECT_EQ(interval.Eq(point(12)), std::nullopt);\n+  EXPECT_EQ(interval.Eq(point(15)), std::nullopt);\n+  EXPECT_EQ(interval.Eq(point(65)), false);\n+\n+  EXPECT_EQ(interval.Ne(point(11)), true);\n+  EXPECT_EQ(interval.Ne(point(15)), std::nullopt);\n+  EXPECT_EQ(interval.Ne(point(65)), true);\n+\n+  EXPECT_EQ(interval.Ge(point(12)), true);\n+  EXPECT_EQ(interval.Ge(point(64)), std::nullopt);\n+  EXPECT_EQ(interval.Ge(point(65)), false);\n+\n+  EXPECT_EQ(interval.Le(point(11)), false);\n+  EXPECT_EQ(interval.Le(point(64)), true);\n+  EXPECT_EQ(interval.Le(point(63)), std::nullopt);\n+  EXPECT_EQ(interval.Le(point(65)), true);\n+\n+  EXPECT_EQ(point(15).Eq(point(15)), true);\n+  EXPECT_EQ(point(15).Eq(point(16)), false);\n+\n+  EXPECT_EQ(point(15).Ne(point(15)), false);\n+  EXPECT_EQ(point(15).Ne(point(16)), true);\n+}\n+\n+TEST(IntervalComparisonTest, RangeComparisons) {\n+  Interval interval{12, 64};\n+  auto range = [](int64_t l, int64_t u) { return Interval{l, u}; };\n+  EXPECT_EQ(interval.Gt(range(-10, 11)), true);\n+  EXPECT_EQ(interval.Gt(range(-10, 12)), std::nullopt);\n+  EXPECT_EQ(interval.Gt(interval), std::nullopt);\n+  EXPECT_EQ(interval.Gt(range(10, 20)), std::nullopt);\n+  EXPECT_EQ(interval.Gt(range(50, 60)), std::nullopt);\n+  EXPECT_EQ(interval.Gt(range(64, 100)), false);\n+  EXPECT_EQ(interval.Gt(range(65, 100)), false);\n+\n+  EXPECT_EQ(interval.Lt(range(65, 100)), true);\n+  EXPECT_EQ(interval.Lt(range(64, 100)), std::nullopt);\n+  EXPECT_EQ(interval.Lt(interval), std::nullopt);\n+  EXPECT_EQ(interval.Lt(range(50, 60)), std::nullopt);\n+  EXPECT_EQ(interval.Lt(range(10, 20)), std::nullopt);\n+  EXPECT_EQ(interval.Lt(range(-10, 12)), false);\n+  EXPECT_EQ(interval.Lt(range(-10, 11)), false);\n+\n+  EXPECT_EQ(interval.Eq(interval), std::nullopt);\n+  EXPECT_EQ(interval.Eq(range(65, 100)), false);\n+  EXPECT_EQ(interval.Eq(range(0, 11)), false);\n+}\n+\n+MATCHER_P(IntervalIs, interval, \"\") {\n+  std::pair<int64_t, int64_t> arg_pair{arg.lower, arg.upper};\n+  return ::testing::ExplainMatchResult(\n+      ::testing::Pair(interval.lower, interval.upper), arg_pair,\n+      result_listener);\n+}\n+\n+TEST(IntervalMathTest, Addition) {\n+  Interval a{12, 64};\n+  Interval b{-100, 120};\n+  Interval sum{12 - 100, 64 + 120};\n+  EXPECT_THAT(a + b, IntervalIs(sum));\n+}\n+\n+TEST(IntervalMathTest, AdditionSaturating) {\n+  Interval a{12, 64};\n+  Interval b{-100, 120};\n+  Interval c{100, std::numeric_limits<int64_t>::max() - 80};\n+  Interval any{std::numeric_limits<int64_t>::min(),\n+               std::numeric_limits<int64_t>::max()};\n+  Interval positive{0, std::numeric_limits<int64_t>::max()};\n+  Interval negative{std::numeric_limits<int64_t>::min(), 0};\n+  auto range = [](int64_t l, int64_t u) { return Interval{l, u}; };\n+\n+  EXPECT_THAT(positive + negative, IntervalIs(any));\n+  EXPECT_THAT(any + any, IntervalIs(any));\n+  EXPECT_THAT(b + any, IntervalIs(any));\n+\n+  EXPECT_THAT(c + any, IntervalIs(any));\n+  EXPECT_THAT(c + positive,\n+              IntervalIs(range(100, std::numeric_limits<int64_t>::max())));\n+  Interval c_plus_negative{negative.lower, c.upper};\n+  EXPECT_THAT(c + negative, IntervalIs(c_plus_negative));\n+\n+  Interval a_plus_c{112, std::numeric_limits<int64_t>::max() - 16};\n+  EXPECT_THAT(a + c, IntervalIs(a_plus_c));\n+  Interval b_plus_c{0, std::numeric_limits<int64_t>::max()};\n+  EXPECT_THAT(b + c, IntervalIs(b_plus_c));\n+}\n+\n+TEST(IntervalMathTest, Multiplication) {\n+  Interval pos{10, 100};\n+  Interval neg{-10, -1};\n+  Interval both_small{-5, 6};\n+  Interval both_large{-20, 1000};\n+\n+  auto range = [](int64_t l, int64_t u) { return Interval{l, u}; };\n+  EXPECT_THAT(pos * neg, IntervalIs(range(-1000, -10)));\n+  EXPECT_THAT(pos * both_small, IntervalIs(range(-500, 600)));\n+  EXPECT_THAT(pos * both_large, IntervalIs(range(-2000, 100000)));\n+  EXPECT_THAT(neg * both_small, IntervalIs(range(-60, 50)));\n+  EXPECT_THAT(neg * both_large, IntervalIs(range(-10000, 200)));\n+  EXPECT_THAT(both_small * both_large, IntervalIs(range(-5000, 6000)));\n+}\n+\n+TEST(IntervalMathTest, MultiplicationSaturating) {\n+  Interval any{std::numeric_limits<int64_t>::min(),\n+               std::numeric_limits<int64_t>::max()};\n+  Interval bit33{42, std::numeric_limits<uint32_t>::max()};\n+  Interval bit33_sq{42 * 42, std::numeric_limits<int64_t>::max()};\n+  EXPECT_THAT(bit33 * bit33, IntervalIs(bit33_sq));\n+  EXPECT_THAT(any * any, IntervalIs(any));\n+\n+  Interval greater_41{42, std::numeric_limits<int64_t>::max()};\n+  Interval neg_one{-1, -1};\n+  Interval less_neg_41{std::numeric_limits<int64_t>::min(), -42};\n+  EXPECT_THAT(greater_41 * neg_one, IntervalIs(less_neg_41));\n+  EXPECT_THAT(less_neg_41 * neg_one, IntervalIs(greater_41));\n+  EXPECT_THAT(any * neg_one, IntervalIs(any));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 890,
        "additions": 507,
        "deletions": 383
    }
}