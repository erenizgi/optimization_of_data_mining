{
    "author": "ezhulenev",
    "message": "[xla:ffi] Keep FFI handler metadata with handler registration\n\nPiperOrigin-RevId: 822741325",
    "sha": "2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
    "files": [
        {
            "sha": "f956644fb32cfdd910ddd9f90337b429836d2048",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_conversion_pass.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_conversion_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_conversion_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_conversion_pass.cc?ref=2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
            "patch": "@@ -206,7 +206,7 @@ bool IsConvertible(const CustomCallThunk& custom_call_thunk,\n   absl::StatusOr<ffi::HandlerRegistration> registration =\n       ffi::FindHandler(target_name, \"gpu\");\n   return registration.ok()\n-             ? ffi::IsCommandBufferCompatible(registration->traits)\n+             ? ffi::IsCommandBufferCompatible(registration->metadata)\n              : false;\n }\n "
        },
        {
            "sha": "b7ff8a5b29d15052b31569e05e1869a81d413182",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
            "patch": "@@ -1609,13 +1609,17 @@ class Handler : public Ffi {\n       return err;\n     }\n \n+    // Set the API version to the version of the FFI headers used by a handler.\n     extension->metadata->api_version = XLA_FFI_Api_Version{\n         XLA_FFI_Api_Version_STRUCT_SIZE,\n-        /*extension_start=*/nullptr, XLA_FFI_API_MAJOR, XLA_FFI_API_MINOR};\n+        /*extension_start=*/nullptr,\n+        XLA_FFI_API_MAJOR,\n+        XLA_FFI_API_MINOR,\n+    };\n \n     // Collect all traits and store them in the metadata.\n     XLA_FFI_Handler_Traits traits = 0;\n-    for (const auto& trait : traits_) {\n+    for (const Traits& trait : traits_) {\n       traits |= static_cast<XLA_FFI_Handler_Traits>(trait);\n     }\n     extension->metadata->traits = traits;\n@@ -1737,7 +1741,8 @@ class Handler : public Ffi {\n     // Find index of every attribute in the sorted attributes vector.\n     for (size_t i = 0; i < attrs_.size(); ++i) {\n       attrs_idx_.push_back(std::distance(\n-          sorted.begin(), std::find(sorted.begin(), sorted.end(), attrs_[i])));\n+          sorted.begin(),\n+          std::find(sorted.begin(), sorted.end(), attrs_[i])));  // NOLINT\n     }\n   }\n "
        },
        {
            "sha": "543a059db9586afa00fbba236e5dea26f1908f2e",
            "filename": "third_party/xla/xla/ffi/ffi_api.cc",
            "status": "modified",
            "additions": 55,
            "deletions": 29,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc?ref=2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
            "patch": "@@ -116,8 +116,8 @@ static bool IsSupportedApiVersion(const XLA_FFI_Api_Version& api_version) {\n          version <= kMaxSupportedApiVersion;\n }\n \n-bool IsCommandBufferCompatible(XLA_FFI_Handler_Traits traits) {\n-  return traits & XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE;\n+bool IsCommandBufferCompatible(const XLA_FFI_Metadata& metadata) {\n+  return metadata.traits & XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE;\n }\n \n static XLA_FFI_ExecutionContext CreateExecutionContext(\n@@ -175,16 +175,16 @@ tsl::AsyncValueRef<tsl::Chain> TakeFuture(XLA_FFI_Future* future) {\n     return chain->AsRef();\n   }\n \n-  // If the future is already completed, immediately return the underlying async\n-  // value and delete the XLA_FFI_Future.\n+  // If the future is already completed, immediately return the underlying\n+  // async value and delete the XLA_FFI_Future.\n   if (ABSL_PREDICT_TRUE(future->async_value.IsAvailable())) {\n     tsl::AsyncValueRef<tsl::Chain> async_value = std::move(future->async_value);\n     delete future;\n     return async_value;\n   }\n \n-  // If the future is not completed, return a copy of the underlying async value\n-  // and keep XLA_FFI_Future alive until it is completed.\n+  // If the future is not completed, return a copy of the underlying async\n+  // value and keep XLA_FFI_Future alive until it is completed.\n   tsl::AsyncValueRef<tsl::Chain> async_value = future->async_value;\n   async_value.AndThen([future] { delete future; });\n   return async_value;\n@@ -201,8 +201,8 @@ static absl::StatusOr<XLA_FFI_Future*> Call(Handler& handler,\n \n   XLA_FFI_Error* error = nullptr;\n \n-  // FFI handlers might be defined in external libraries and use exceptions, so\n-  // take extra care to catch them and convert to a status.\n+  // FFI handlers might be defined in external libraries and use exceptions,\n+  // so take extra care to catch them and convert to a status.\n   try {\n     if constexpr (std::is_same_v<Handler, Ffi>) {\n       error = handler.Call(&ffi_call_frame);\n@@ -386,6 +386,20 @@ static std::vector<std::string> GetHandlerStages(\n   return stages;\n }\n \n+static bool CheckMetadata(const XLA_FFI_Metadata& a,\n+                          const XLA_FFI_Metadata& b) {\n+  return a.api_version.major_version == b.api_version.major_version &&\n+         a.api_version.minor_version == b.api_version.minor_version &&\n+         a.traits == b.traits &&\n+         a.state_type_id.type_id == b.state_type_id.type_id;\n+}\n+\n+static bool CheckHandlerBundle(const XLA_FFI_Handler_Bundle& a,\n+                               const XLA_FFI_Handler_Bundle& b) {\n+  return a.instantiate == b.instantiate && a.prepare == b.prepare &&\n+         a.initialize == b.initialize && a.execute == b.execute;\n+}\n+\n static absl::Status RegisterHandler(absl::string_view name,\n                                     absl::string_view platform,\n                                     XLA_FFI_Handler_Bundle bundle,\n@@ -405,45 +419,57 @@ static absl::Status RegisterHandler(absl::string_view name,\n   if (!IsSupportedApiVersion(metadata.api_version)) {\n     return InvalidArgument(\n         \"XLA FFI handler registration for %s on platform %s (canonical %s) \"\n-        \"failed because the handler's API version (%d.%d) is incompatible with \"\n-        \"the framework's API version (%d.%d). Minimum supported API version is \"\n+        \"failed because the handler's API version (%d.%d) is incompatible \"\n+        \"with \"\n+        \"the framework's API version (%d.%d). Minimum supported API version \"\n+        \"is \"\n         \"(%d.%d).\",\n         name, platform, canonical_platform, metadata.api_version.major_version,\n         metadata.api_version.minor_version, kMaxSupportedApiVersion.first,\n         kMaxSupportedApiVersion.second, kMinSupportedApiVersion.first,\n         kMinSupportedApiVersion.second);\n   }\n \n-  // Incorporate handler traits.\n-  traits |= metadata.traits;\n+  // Incorporate handler traits passed explicitly via handler registration\n+  // API.\n+  metadata.traits |= traits;\n+\n+  // Incorporate state type id from the instantiate implementation if present.\n+  if (bundle.instantiate) {\n+    TF_ASSIGN_OR_RETURN(XLA_FFI_Metadata instantiate_metadata,\n+                        GetMetadata(bundle.instantiate));\n+    metadata.state_type_id = instantiate_metadata.state_type_id;\n+  }\n \n   VLOG(2) << absl::StreamFormat(\n       \"Register XLA FFI handler for '%s'; platform=%s (canonical=%s), \"\n-      \"stages=[%s], command_buffer_compatible=%v\",\n+      \"stages=[%s], metadata=%v\",\n       name, platform, canonical_platform,\n-      absl::StrJoin(GetHandlerStages(bundle), \", \"),\n-      IsCommandBufferCompatible(traits));\n-\n-  auto emplaced =\n-      GetHandlerRegistry().try_emplace(MakeHandlerKey(name, canonical_platform),\n-                                       HandlerRegistration{bundle, traits});\n-  if (!emplaced.second) {\n-    auto existing = emplaced.first->second;\n-    if (existing.traits != traits) {\n+      absl::StrJoin(GetHandlerStages(bundle), \", \"), metadata);\n+\n+  HandlerRegistration registration{metadata, bundle};\n+  auto [it, emplaced] = GetHandlerRegistry().try_emplace(\n+      MakeHandlerKey(name, canonical_platform), registration);\n+\n+  // We might accidentally link the same FFI library multiple times (because\n+  // linking shared libraries is hard), and we choose to ignore this problem as\n+  // long as we register exactly the same handler.\n+  if (!emplaced) {\n+    const HandlerRegistration& existing = it->second;\n+    if (!CheckMetadata(existing.metadata, metadata)) {\n       return InvalidArgument(\n           \"Duplicate FFI handler registration for %s on platform %s \"\n-          \"(canonical %s) with different traits\",\n-          name, platform, canonical_platform);\n+          \"(canonical %s) with different metadata: %v vs %v\",\n+          name, platform, canonical_platform, existing.metadata, metadata);\n     }\n-    if (existing.bundle.prepare != bundle.prepare ||\n-        existing.bundle.initialize != bundle.initialize ||\n-        existing.bundle.execute != bundle.execute) {\n+    if (!CheckHandlerBundle(existing.bundle, bundle)) {\n       return InvalidArgument(\n           \"Duplicate FFI handler registration for %s on platform %s \"\n           \"(canonical %s) with different bundle addresses\",\n           name, platform, canonical_platform);\n     }\n   }\n+\n   return absl::OkStatus();\n }\n \n@@ -681,8 +707,8 @@ static XLA_FFI_Error* XLA_FFI_Type_Register(XLA_FFI_Type_Register_Args* args) {\n   TypeRegistry::TypeId type_id(args->type_id->type_id);\n   TypeRegistry::TypeInfo type_info = {args->type_info->deleter};\n \n-  // If type_id is unknown, we are registering a new type and XLA will assign a\n-  // unique type id to it.\n+  // If type_id is unknown, we are registering a new type and XLA will assign\n+  // a unique type id to it.\n   if (type_id == TypeRegistry::kUnknownTypeId) {\n     auto assigned_type_id =\n         TypeRegistry::AssignExternalTypeId(type_name, type_info);"
        },
        {
            "sha": "86c403c10f564f9990a34008ef98c5ee8e4e32c4",
            "filename": "third_party/xla/xla/ffi/ffi_api.h",
            "status": "modified",
            "additions": 53,
            "deletions": 3,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.h?ref=2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
            "patch": "@@ -19,10 +19,12 @@ limitations under the License.\n #include <cstdint>\n #include <string>\n #include <variant>\n+#include <vector>\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/ffi/api/api.h\"\n@@ -142,11 +144,11 @@ class ScopedExecutionContext {\n //===----------------------------------------------------------------------===//\n \n struct HandlerRegistration {\n-  XLA_FFI_Handler_Bundle bundle = {};\n-  XLA_FFI_Handler_Traits traits = {};\n+  XLA_FFI_Metadata metadata;\n+  XLA_FFI_Handler_Bundle bundle;\n };\n \n-bool IsCommandBufferCompatible(XLA_FFI_Handler_Traits traits);\n+bool IsCommandBufferCompatible(const XLA_FFI_Metadata& metadata);\n \n // Returns registered FFI handler for a given name and platform, or an error if\n // it's not found in the static registry.\n@@ -163,6 +165,54 @@ StaticRegisteredHandlers(absl::string_view platform);\n \n const XLA_FFI_Api* GetXlaFfiApi();\n \n+//===----------------------------------------------------------------------===//\n+// Helper functions\n+//===----------------------------------------------------------------------===//\n+\n+// Decodes XLA FFI traits packed into a 32-bit integer into a vector of traits.\n+inline std::vector<Traits> DecodeTraits(XLA_FFI_Handler_Traits traits) {\n+  std::vector<Traits> result;\n+  if (traits & XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE) {\n+    result.push_back(Traits::kCmdBufferCompatible);\n+  }\n+  return result;\n+}\n+\n+//===----------------------------------------------------------------------===//\n+// Pretty printinting for FFI C++ types.\n+//===----------------------------------------------------------------------===//\n+\n+template <typename Sink>\n+static void AbslStringify(Sink& sink, Traits traits) {\n+  switch (traits) {\n+    case Traits::kCmdBufferCompatible:\n+      absl::Format(&sink, \"cmd_buffer_compatible\");\n+      break;\n+  }\n+}\n+\n }  // namespace xla::ffi\n \n+//===----------------------------------------------------------------------===//\n+// Pretty printinting for FFI C types.\n+//===----------------------------------------------------------------------===//\n+\n+template <typename Sink>\n+static void AbslStringify(Sink& sink, const XLA_FFI_TypeId& type_id) {\n+  if (type_id.type_id == XLA_FFI_UNKNOWN_TYPE_ID.type_id) {\n+    absl::Format(&sink, \"unknown\");\n+  } else {\n+    absl::Format(&sink, \"%d\", type_id.type_id);\n+  }\n+}\n+\n+template <typename Sink>\n+static void AbslStringify(Sink& sink, const XLA_FFI_Metadata& metadata) {\n+  absl::Format(&sink, \"{api_version: %d.%d, traits: [%s], state: %v}\",\n+               metadata.api_version.major_version,\n+               metadata.api_version.minor_version,\n+               absl::StrJoin(xla::ffi::DecodeTraits(metadata.traits), \", \"),\n+               metadata.state_type_id);\n+}\n+\n #endif  // XLA_FFI_FFI_API_H_"
        },
        {
            "sha": "7f18d80e7954d4db394c78e2381389c78b17a119",
            "filename": "third_party/xla/xla/ffi/ffi_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc?ref=2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
            "patch": "@@ -105,8 +105,9 @@ TEST(FfiTest, StaticHandlerRegistration) {\n   TF_ASSERT_OK(handler0.status());\n   TF_ASSERT_OK(handler1.status());\n \n-  ASSERT_EQ(handler0->traits, XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n-  ASSERT_EQ(handler1->traits, 0);\n+  ASSERT_EQ(handler0->metadata.traits,\n+            XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n+  ASSERT_EQ(handler1->metadata.traits, 0);\n \n   // Check that platform name was canonicalized an we can find handlers\n   // registered for \"Host\" platform as \"Cpu\" handlers.\n@@ -122,7 +123,8 @@ TEST(FfiTest, RegistrationTraitsBackwardsCompatibility) {\n                            XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n   auto handler = FindHandler(\"traits-bwd-compat\", \"Host\");\n   TF_ASSERT_OK(handler.status());\n-  ASSERT_EQ(handler->traits, XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n+  ASSERT_EQ(handler->metadata.traits,\n+            XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n }\n \n // Declare XLA FFI handler as a function (extern \"C\" declaration).\n@@ -139,7 +141,7 @@ TEST(FfiTest, StaticHandlerSymbolRegistration) {\n   auto handler0 = FindHandler(\"no-op-sym-0\", \"Cpu\");\n \n   TF_ASSERT_OK(handler0.status());\n-  ASSERT_EQ(handler0->traits, 0);\n+  ASSERT_EQ(handler0->metadata.traits, 0);\n }\n \n TEST(FfiTest, ForwardError) {"
        },
        {
            "sha": "606f345abd012f3bad589915756b854218ccc2b2",
            "filename": "third_party/xla/xla/service/gpu/transforms/command_buffer_scheduling.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcommand_buffer_scheduling.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2cdd8ff5ce642e94bd206306af00fac1d34ec2a0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcommand_buffer_scheduling.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcommand_buffer_scheduling.cc?ref=2cdd8ff5ce642e94bd206306af00fac1d34ec2a0",
            "patch": "@@ -258,7 +258,7 @@ static bool IsCommand(const HloCustomCallInstruction* hlo,\n   // Check if FFI handler is compatible with command buffers.\n   auto registration = ffi::FindHandler(hlo->custom_call_target(), \"gpu\");\n   return registration.ok()\n-             ? ffi::IsCommandBufferCompatible(registration->traits)\n+             ? ffi::IsCommandBufferCompatible(registration->metadata)\n              : false;\n }\n "
        }
    ],
    "stats": {
        "total": 165,
        "additions": 124,
        "deletions": 41
    }
}