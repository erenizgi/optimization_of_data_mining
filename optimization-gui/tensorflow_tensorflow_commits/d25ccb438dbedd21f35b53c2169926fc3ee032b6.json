{
    "author": "tensorflower-gardener",
    "message": "Reverts cef240807a4380a8f175ab37c54dcfa0e71af24d\n\nPiperOrigin-RevId: 826374657",
    "sha": "d25ccb438dbedd21f35b53c2169926fc3ee032b6",
    "files": [
        {
            "sha": "7d1274de103bb8295a24b9a16b3736a639fd5ffd",
            "filename": "third_party/xla/xla/array.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Farray.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Farray.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Farray.h?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include <cstdint>\n #include <cstring>\n #include <functional>\n+#include <initializer_list>\n #include <iterator>\n #include <limits>\n #include <memory>"
        },
        {
            "sha": "a72a14aab8c979440c1cdbf75aa9304a4deadb7f",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 7,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -60,7 +60,6 @@ cc_library(\n     deps = [\n         \":backend_config\",\n         \":hlo_sharding\",\n-        \":mesh_and_axis\",\n         \":named_sharding\",\n         \":ptrvec\",\n         \":tile_assignment\",\n@@ -124,7 +123,6 @@ cc_library(\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/types:span\",\n-        \"@com_google_protobuf//:protobuf_lite\",\n         \"@highwayhash\",\n         \"@highwayhash//:arch_specific\",\n         \"@highwayhash//:hh_types\",\n@@ -190,7 +188,6 @@ cc_library(\n         \"//xla:xla_data_proto_cc\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n     ],\n@@ -418,13 +415,9 @@ xla_cc_test(\n     srcs = [\"replica_group_test.cc\"],\n     deps = [\n         \":hlo\",\n-        \":mesh_and_axis\",\n-        \":tile_assignment\",\n-        \"//xla:array\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/service:hlo_proto_cc\",\n         \"//xla/tsl/platform:test_main\",\n-        \"@com_google_absl//absl/base:log_severity\",\n         \"@com_google_googletest//:gtest\",\n     ],\n )\n@@ -440,6 +433,8 @@ xla_cc_test(\n         \"//xla/tsl/util/proto:proto_matchers\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:status_matchers\",\n+        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n "
        },
        {
            "sha": "f60f6fd0e43245188f4d29c4483532e9dde3e838",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 0,
            "deletions": 36,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -23,8 +23,6 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/log/check.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_join.h\"\n #include \"absl/types/span.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/xla_data.pb.h\"\n@@ -57,36 +55,13 @@ class Mesh {\n            axes_names_ == other.axes_names_;\n   }\n \n-  std::string ToString() const {\n-    std::string mesh_str = \"@mesh\";\n-    // Add the mesh axes names and sizes.\n-    std::vector<std::string> formatted_axes_names;\n-    formatted_axes_names.reserve(axes_names_.size());\n-    for (int64_t i = 0; i < axes_names_.size(); ++i) {\n-      formatted_axes_names.push_back(\n-          absl::StrCat(axes_names_[i], \"=\", device_assignment_.dim(i)));\n-    }\n-\n-    // Add the device assignment if it is not an iota case.\n-    std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n-    std::string device_assignment_str = \"\";\n-    if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n-      device_assignment_str =\n-          absl::StrCat(\"(\", device_assignment_.ArrayToString(), \")\");\n-    }\n-    absl::StrAppend(&mesh_str, \"<\", absl::StrJoin(formatted_axes_names, \",\"),\n-                    \">\", device_assignment_str);\n-    return mesh_str;\n-  }\n-\n   bool operator!=(const Mesh& other) const { return !(*this == other); }\n \n   MeshProto ToProto() const;\n \n   static Mesh FromProto(const MeshProto& proto);\n \n   TileAssignment device_assignment() const { return device_assignment_; }\n-  std::vector<std::string> axis_names() const { return axes_names_; }\n \n  private:\n   // Dimensions of the `device_assignment_` array correspond to the axes of the\n@@ -138,17 +113,6 @@ class AxisRef {\n     return true;\n   }\n \n-  std::string ToString(const Mesh& mesh) const {\n-    CHECK_GE(mesh_axis_index_, 0);\n-    CHECK_LT(mesh_axis_index_, mesh.axis_names().size());\n-    std::string axis_str = mesh.axis_names()[mesh_axis_index()];\n-    if (sub_axis_info_.has_value()) {\n-      absl::StrAppend(&axis_str, \":(\", sub_axis_info_->pre_size, \")\",\n-                      sub_axis_info_->size);\n-    }\n-    return axis_str;\n-  }\n-\n   bool operator!=(const xla::AxisRef& other) const { return !(*this == other); }\n \n   AxisRefProto ToProto() const;"
        },
        {
            "sha": "57f8d26b941e20cbfd79c9705d7e0c5c1dd526cc",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -176,23 +176,4 @@ TEST(MeshAndAxisTest, MeshRoundtripProto) {\n   EXPECT_THAT(mesh_non_iota, Mesh::FromProto(mesh_non_iota.ToProto()));\n }\n \n-TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n-  Mesh mesh_uvw(TileAssignment(IotaTileAssignment::Create(\n-                    /*dims=*/{10, 12, 15})),\n-                /*axes_names=*/{\"u\", \"v\", \"w\"});\n-  EXPECT_EQ(mesh_uvw.ToString(), \"@mesh<u=10,v=12,w=15>\");\n-\n-  Mesh mesh_abcd(TileAssignment(IotaTileAssignment::Create(\n-                     /*dims=*/{2, 4, 4, 2}, /*reshape_dims=*/{1, 4, 1, 16},\n-                     /*transpose_perm=*/{2, 3, 0, 1})),\n-                 /*axes_names=*/{\"a\", \"b\", \"c\", \"d\"});\n-  EXPECT_EQ(mesh_abcd.ToString(), \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0))\");\n-\n-  Array<int64_t> array({{8, 3, 7, 5, 4, 2, 6, 0, 1, 9}});\n-  array.Reshape({10});\n-  TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n-  Mesh mesh_ooo(tile_assignment, /*axes_names=*/{\"ooo\"});\n-  EXPECT_EQ(mesh_ooo.ToString(), \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9)\");\n-}\n-\n }  // namespace xla"
        },
        {
            "sha": "f693c50db3b5401de0ed89e12a6538f1e736e19c",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 61,
            "changes": 61,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -17,7 +17,6 @@ limitations under the License.\n \n #include <cstdint>\n #include <memory>\n-#include <optional>\n #include <string>\n #include <vector>\n \n@@ -27,8 +26,6 @@ limitations under the License.\n #include \"absl/strings/str_join.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n-#include \"xla/hlo/ir/mesh_and_axis.h\"\n-#include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/printer.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/tsl/platform/logging.h\"  // IWYU pragma: keep\n@@ -48,63 +45,6 @@ std::string ReplicaGroupsToString(\n   return absl::StrCat(\"{\", absl::StrJoin(replica_group_str, \",\"), \"}\");\n }\n \n-/************** MeshAxesReplicaGroupList implementation ***********************/\n-int64_t MeshAxesReplicaGroupList::num_replica_groups() const {\n-  return mesh_.device_assignment().num_elements() / num_devices_per_group();\n-}\n-\n-int64_t MeshAxesReplicaGroupList::num_devices_per_group() const {\n-  // Number of devices per replica group is equal to the product of the sizes of\n-  // all axes.\n-  int64_t devices_per_group = 1;\n-  for (const AxisRef& axis : axes_) {\n-    int64_t axis_size =\n-        axis.sub_axis_info().has_value()\n-            ? axis.sub_axis_info()->size\n-            : mesh_.device_assignment().dim(axis.mesh_axis_index());\n-    devices_per_group *= axis_size;\n-  }\n-  return devices_per_group;\n-}\n-\n-void MeshAxesReplicaGroupList::Print(Printer* printer) const {\n-  printer->Append(ToString());\n-}\n-\n-std::string MeshAxesReplicaGroupList::ToString() const {\n-  std::string rg_str = \"\";\n-  // Add the axes defining the replica group, using names from the mesh.\n-  std::vector<std::string> group_axes_str;\n-  group_axes_str.reserve(axes_.size());\n-  for (const AxisRef& axis : axes_) {\n-    std::string axis_str = axis.ToString(mesh_);\n-    group_axes_str.push_back(axis_str);\n-  }\n-  absl::StrAppend(&rg_str, mesh_.ToString(), \" {\",\n-                  absl::StrJoin(group_axes_str, \",\"), \"}\");\n-  return rg_str;\n-}\n-\n-MeshAxesReplicaGroupListProto MeshAxesReplicaGroupList::ToProto() const {\n-  MeshAxesReplicaGroupListProto proto;\n-  *proto.mutable_mesh() = mesh_.ToProto();\n-  for (const AxisRef& axis : axes_) {\n-    *proto.add_axes() = axis.ToProto();\n-  }\n-  return proto;\n-}\n-\n-MeshAxesReplicaGroupList MeshAxesReplicaGroupList::FromProto(\n-    const MeshAxesReplicaGroupListProto& proto) {\n-  Mesh mesh = Mesh::FromProto(proto.mesh());\n-  std::vector<AxisRef> axes;\n-  for (const AxisRefProto& axis_proto : proto.axes()) {\n-    axes.push_back(AxisRef::FromProto(axis_proto));\n-  }\n-  return MeshAxesReplicaGroupList(mesh, axes);\n-}\n-\n-/************** IotaReplicaGroupList implementation ***************************/\n int64_t IotaReplicaGroupList::num_replica_groups() const {\n   DCHECK_GE(num_replica_groups_, 0);\n   return num_replica_groups_;\n@@ -181,7 +121,6 @@ std::shared_ptr<std::vector<ReplicaGroup>> ExpandIota(\n }\n }  // namespace\n \n-/************** CollectiveDeviceList implementation ***************************/\n const std::vector<ReplicaGroup>& CollectiveDeviceList::replica_groups() const {\n   if (replica_groups_ == nullptr) {\n     CHECK(iota_replica_group_list_.has_value());"
        },
        {
            "sha": "f1b612fe8c77b5d86682595bfe23c75a639541cf",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.h",
            "status": "modified",
            "additions": 0,
            "deletions": 39,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -24,11 +24,8 @@ limitations under the License.\n #include <utility>\n #include <vector>\n \n-#include \"absl/log/log.h\"\n #include \"absl/types/span.h\"\n-#include \"google/protobuf/repeated_ptr_field.h\"\n #include \"xla/array.h\"\n-#include \"xla/hlo/ir/mesh_and_axis.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/printer.h\"\n #include \"xla/service/hlo.pb.h\"\n@@ -37,42 +34,6 @@ limitations under the License.\n \n namespace xla {\n \n-class MeshAxesReplicaGroupList {\n- public:\n-  explicit MeshAxesReplicaGroupList(Mesh mesh, std::vector<AxisRef> axes)\n-      : mesh_(std::move(mesh)), axes_(std::move(axes)) {\n-    if (num_devices_per_group() == 1) {\n-      LOG(ERROR) << \"MeshAxesReplicaGroupList: \" << ToString()\n-                 << \" has only one device per replica group.\";\n-    }\n-  }\n-\n-  bool operator==(const MeshAxesReplicaGroupList& other) const {\n-    return mesh_ == other.mesh_ && axes_ == other.axes_;\n-  }\n-\n-  template <typename H>\n-  friend H AbslHashValue(H h, const MeshAxesReplicaGroupList& c) {\n-    return H::combine(std::move(h), c.mesh_, c.axes_);\n-  }\n-\n-  int64_t num_replica_groups() const;\n-  int64_t num_devices_per_group() const;\n-\n-  void Print(Printer* printer) const;\n-\n-  std::string ToString() const;\n-\n-  MeshAxesReplicaGroupListProto ToProto() const;\n-\n-  static MeshAxesReplicaGroupList FromProto(\n-      const MeshAxesReplicaGroupListProto& proto);\n-\n- private:\n-  Mesh mesh_;\n-  std::vector<AxisRef> axes_;\n-};\n-\n std::string ReplicaGroupsToString(\n     absl::Span<const ReplicaGroup> replica_groups);\n "
        },
        {
            "sha": "74fb67f876f0ace8e45a87720aa6bbb81db81b7e",
            "filename": "third_party/xla/xla/hlo/ir/replica_group_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 116,
            "changes": 116,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -16,16 +16,10 @@ limitations under the License.\n #include \"xla/hlo/ir/replica_group.h\"\n \n #include <cstdint>\n-#include <memory>\n #include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n-#include \"testing/base/public/mock-log.h\"\n-#include \"absl/base/log_severity.h\"\n-#include \"xla/array.h\"\n-#include \"xla/hlo/ir/mesh_and_axis.h\"\n-#include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -43,116 +37,6 @@ CollectiveDeviceListProto CreateDeviceListProto(\n   return proto;\n }\n \n-TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSize) {\n-  Mesh all_axes(TileAssignment(IotaTileAssignment::Create(\n-                    /*dims=*/{4, 4})),\n-                /*axes_names=*/{\"x\", \"y\"});\n-  MeshAxesReplicaGroupList replica_group_across_all_axes(\n-      all_axes,\n-      /*axes=*/{AxisRef(0), AxisRef(1)});\n-  EXPECT_EQ(replica_group_across_all_axes.num_replica_groups(), 1);\n-  EXPECT_EQ(replica_group_across_all_axes.num_devices_per_group(), 16);\n-\n-  Mesh one_axes(TileAssignment(IotaTileAssignment::Create(\n-                    /*dims=*/{3, 5})),\n-                /*axes_names=*/{\"a\", \"b\"});\n-  MeshAxesReplicaGroupList replica_group_across_a(one_axes,\n-                                                  /*axes=*/{AxisRef(0)});\n-  MeshAxesReplicaGroupList replica_group_across_b(one_axes,\n-                                                  /*axes=*/{AxisRef(1)});\n-  EXPECT_EQ(replica_group_across_a.num_replica_groups(), 5);\n-  EXPECT_EQ(replica_group_across_a.num_devices_per_group(), 3);\n-  EXPECT_EQ(replica_group_across_b.num_replica_groups(), 3);\n-  EXPECT_EQ(replica_group_across_b.num_devices_per_group(), 5);\n-\n-  Mesh no_axes(TileAssignment(IotaTileAssignment::Create(\n-                   /*dims=*/{2, 3, 5})),\n-               /*axes_names=*/{\"p1\", \"p2\", \"p3\"});\n-  testing::ScopedMockLog log(testing::kDoNotCaptureLogsYet);\n-  EXPECT_CALL(log,\n-              Log(base_logging::ERROR, testing::_,\n-                  testing::HasSubstr(\"has only one device per replica group\")))\n-      .Times(1);\n-  log.StartCapturingLogs();\n-  MeshAxesReplicaGroupList replica_group_across_no_axes(no_axes,\n-                                                        /*axes=*/{});\n-  EXPECT_EQ(replica_group_across_no_axes.num_replica_groups(), 2 * 3 * 5);\n-  EXPECT_EQ(replica_group_across_no_axes.num_devices_per_group(), 1);\n-}\n-\n-TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n-  Mesh mesh_one_subaxis(TileAssignment(IotaTileAssignment::Create(\n-                            /*dims=*/{2, 6, 10})),\n-                        /*axes_names=*/{\"axis1\", \"axis2\", \"axis3\"});\n-  MeshAxesReplicaGroupList replica_group_across_axis1_subaxis(\n-      mesh_one_subaxis,\n-      /*axes=*/{AxisRef(0, {1, 2})});\n-  MeshAxesReplicaGroupList replica_group_across_axis2_subaxis(\n-      mesh_one_subaxis,\n-      /*axes=*/{AxisRef(1, {2, 3})});\n-  EXPECT_EQ(replica_group_across_axis1_subaxis.num_replica_groups(), 60);\n-  EXPECT_EQ(replica_group_across_axis1_subaxis.num_devices_per_group(), 2);\n-  EXPECT_EQ(replica_group_across_axis2_subaxis.num_replica_groups(), 40);\n-  EXPECT_EQ(replica_group_across_axis2_subaxis.num_devices_per_group(), 3);\n-\n-  Mesh mesh_multiple_subaxis(TileAssignment(IotaTileAssignment::Create(\n-                                 /*dims=*/{2 * 3, 5 * 7, 11 * 13})),\n-                             /*axes_names=*/{\"alpha\", \"beta\", \"gamma\"});\n-  MeshAxesReplicaGroupList replica_group_across_multiple_subaxis1(\n-      mesh_multiple_subaxis,\n-      /*axes=*/{AxisRef(0, {1, 2}), AxisRef(1, {1, 5}), AxisRef(2, {1, 11})});\n-  MeshAxesReplicaGroupList replica_group_across_multiple_subaxis2(\n-      mesh_multiple_subaxis,\n-      /*axes=*/{AxisRef(0, {2, 3}), AxisRef(1, {5, 7}), AxisRef(2, {11, 13})});\n-  EXPECT_EQ(replica_group_across_multiple_subaxis1.num_replica_groups(),\n-            3 * 7 * 13);\n-  EXPECT_EQ(replica_group_across_multiple_subaxis1.num_devices_per_group(),\n-            2 * 5 * 11);\n-  EXPECT_EQ(replica_group_across_multiple_subaxis2.num_replica_groups(),\n-            2 * 5 * 11);\n-  EXPECT_EQ(replica_group_across_multiple_subaxis2.num_devices_per_group(),\n-            3 * 7 * 13);\n-}\n-\n-TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n-  // No subaxes and iota device assignment.\n-  Mesh mesh_uvw(TileAssignment(IotaTileAssignment::Create(\n-                    /*dims=*/{10, 12, 15})),\n-                /*axes_names=*/{\"u\", \"v\", \"w\"});\n-  MeshAxesReplicaGroupList replica_group_across_none(mesh_uvw, /*axes=*/{});\n-  EXPECT_EQ(replica_group_across_none.ToString(), \"@mesh<u=10,v=12,w=15> {}\");\n-  MeshAxesReplicaGroupList replica_group_across_uv(\n-      mesh_uvw,\n-      /*axes=*/{AxisRef(0), AxisRef(1)});\n-  EXPECT_EQ(replica_group_across_uv.ToString(), \"@mesh<u=10,v=12,w=15> {u,v}\");\n-\n-  // Subaxes and replica group v2 iota style device assignment.\n-  Mesh mesh_abcd(TileAssignment(IotaTileAssignment::Create(\n-                     /*dims=*/{2, 4, 4, 2}, /*reshape_dims=*/{1, 4, 1, 16},\n-                     /*transpose_perm=*/{2, 3, 0, 1})),\n-                 /*axes_names=*/{\"a\", \"b\", \"c\", \"d\"});\n-  MeshAxesReplicaGroupList rg_abcd_across_none(mesh_abcd, /*axes=*/{});\n-  EXPECT_EQ(rg_abcd_across_none.ToString(),\n-            \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {}\");\n-  MeshAxesReplicaGroupList rg_abcd_across_multiple_axes_and_subaxes(\n-      mesh_abcd, /*axes=*/{AxisRef(0), AxisRef(1, {1, 2}), AxisRef(3)});\n-  EXPECT_EQ(rg_abcd_across_multiple_axes_and_subaxes.ToString(),\n-            \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {a,b:(1)2,d}\");\n-\n-  // Subaxes and random device assignment.\n-  Array<int64_t> array({{8, 3, 7, 5, 4, 2, 6, 0, 1, 9}});\n-  array.Reshape({10});\n-  TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n-  Mesh mesh_ooo(tile_assignment, /*axes_names=*/{\"ooo\"});\n-  MeshAxesReplicaGroupList rg_ooo_across_none(mesh_ooo, /*axes=*/{});\n-  EXPECT_EQ(rg_ooo_across_none.ToString(),\n-            \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {}\");\n-  MeshAxesReplicaGroupList rg_ooo_across_ooo_5_2(mesh_ooo,\n-                                                 /*axes=*/{AxisRef(0, {5, 2})});\n-  EXPECT_EQ(rg_ooo_across_ooo_5_2.ToString(),\n-            \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {ooo:(5)2}\");\n-}\n-\n TEST(CollectiveDeviceListTest, DefaultListToString) {\n   EXPECT_EQ(CollectiveDeviceList().ToString(true), \"{}\");\n   EXPECT_EQ(CollectiveDeviceList().ToString(false), \"{}\");"
        },
        {
            "sha": "42fba88b23ecc64f2d1bc78afb048584822b7a1c",
            "filename": "third_party/xla/xla/xla_data.proto",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fxla_data.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d25ccb438dbedd21f35b53c2169926fc3ee032b6/third_party%2Fxla%2Fxla%2Fxla_data.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fxla_data.proto?ref=d25ccb438dbedd21f35b53c2169926fc3ee032b6",
            "patch": "@@ -1192,19 +1192,6 @@ message ReplicaGroup {\n   repeated int64 replica_ids = 1;\n }\n \n-// Represents a list of replica groups (a list of list of devices) via a mesh\n-// and list of axes. The replica groups correspond to the partitions of the\n-// device ids which would arise if a collective operation was performed over the\n-// specified axes.\n-message MeshAxesReplicaGroupListProto {\n-  // The mesh used to define the full set of axes and devices ids.\n-  MeshProto mesh = 1;\n-  // The axes defining the replica groups. These groups are implicitly defined\n-  // by the device ids which would communicate together if a collective\n-  // operation is performed over these axes.\n-  repeated AxisRefProto axes = 2;\n-}\n-\n // Represents a list of replica groups (a list of list of devices) with\n // reshaping and transposing an iota array (iota tile assignment). Can be used\n // to represent certain common patterns of device lists in a compact, scalable"
        }
    ],
    "stats": {
        "total": 294,
        "additions": 3,
        "deletions": 291
    }
}