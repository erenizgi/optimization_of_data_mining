{
    "author": "emilyfertig",
    "message": "[PjRt-IFRT] For cross-host transfers, call the new CrossHost{Send,Receive}Buffers API if the plugin implements it.\n\nThis enables efficient cross-host transfers on GPU.\n\nPiperOrigin-RevId: 840867337",
    "sha": "d231250a664edc0014f48dde0b66f7ef57e02e51",
    "files": [
        {
            "sha": "827415e8e05152200ab851a5c45a50923979864d",
            "filename": "third_party/xla/xla/pjrt/pjrt_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d231250a664edc0014f48dde0b66f7ef57e02e51/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d231250a664edc0014f48dde0b66f7ef57e02e51/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h?ref=d231250a664edc0014f48dde0b66f7ef57e02e51",
            "patch": "@@ -1032,7 +1032,7 @@ class PjRtClient {\n       absl::Span<PjRtBuffer* const> buffers,\n       absl::Span<const PjRtGlobalDeviceId> dst_global_device_ids,\n       std::vector<CrossHostTransferKey> transfer_keys) {\n-    return absl::InternalError(\n+    return absl::UnimplementedError(\n         \"Cross-host data transfers are not supported by this client.\");\n   }\n "
        },
        {
            "sha": "c2d4458ba0663faf19379c6b66688994cfa1161f",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_client.cc",
            "status": "modified",
            "additions": 94,
            "deletions": 26,
            "changes": 120,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d231250a664edc0014f48dde0b66f7ef57e02e51/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d231250a664edc0014f48dde0b66f7ef57e02e51/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc?ref=d231250a664edc0014f48dde0b66f7ef57e02e51",
            "patch": "@@ -1313,13 +1313,23 @@ PjRtClient::CopyArraysForCrossHost(absl::Span<ArrayRef> arrays,\n                                    std::optional<MemoryKind> memory_kind) {\n   std::vector<ArrayRef> new_arrays;\n   new_arrays.reserve(arrays.size());\n-  std::vector<PjRtBuffers> recv_buffers;\n+  std::vector<std::vector<std::unique_ptr<PjRtBuffer>>> recv_buffers;\n   recv_buffers.reserve(dst_devices->AddressableDeviceList()->size());\n+  auto on_send_done = [](absl::Status status) {\n+    if (!status.ok()) {\n+      LOG(ERROR) << \"xla::PjRtClient::CrossHostSendBuffers failed: \" << status;\n+    }\n+  };\n+  auto on_recv_done = [](absl::Status status) {\n+    if (!status.ok()) {\n+      LOG(ERROR) << \"Cross-host receive buffer failed: \" << status;\n+    }\n+  };\n   int j = 0;  // Counter for the addressable buffers.\n   for (int i = 0; i < dst_devices->size(); ++i) {\n     // TODO(emilyaf): Extend CreateNewTransferKey to take N and return N keys\n     // as a performance optimization.\n-    std::vector<int64_t> transfer_keys;\n+    std::vector<CrossHostTransferKey> transfer_keys;\n     transfer_keys.reserve(arrays.size());\n     for (int k = 0; k < arrays.size(); ++k) {\n       transfer_keys.push_back(CreateNewTransferKey());\n@@ -1337,23 +1347,49 @@ PjRtClient::CopyArraysForCrossHost(absl::Span<ArrayRef> arrays,\n             dst_devices->devices()[i]->DebugString()));\n       }\n \n-      PjRtArray::PjRtBuffers send_buffers;\n+      // Create vector of dst devices; we send each array to\n+      // dst_devices->devices()[i].\n+      TF_ASSIGN_OR_RETURN(\n+          xla::PjRtGlobalDeviceId dst_global_device_id,\n+          GetPjRtGlobalDeviceId(dst_devices->devices()[i]->Id()));\n+      std::vector<PjRtGlobalDeviceId> dst_global_device_ids(\n+          arrays.size(), dst_global_device_id);\n+\n+      // Create send buffers.\n+      std::vector<PjRtBuffer*> send_buffers;\n       send_buffers.reserve(arrays.size());\n       for (ArrayRef& array : arrays) {\n         if (auto* const pjrt_array = llvm::dyn_cast<PjRtArray>(array.get())) {\n           auto buffers = pjrt_array->pjrt_buffers();\n-          send_buffers.push_back(buffers[j]);\n+          send_buffers.push_back(buffers[j].get());\n         } else {\n           // TODO(emilyaf): Support string arrays.\n           return absl::InvalidArgumentError(\n               \"Unsupported array type for cross-host \"\n               \"PjRtClient::CopyArraysForCrossHost\");\n         }\n       }\n-      TF_RETURN_IF_ERROR(\n-          CrossHostSendBuffers(send_buffers, std::move(transfer_keys)));\n+\n+      // If the PJRT plugin implements the `CrossHostSendBuffers` API, use it.\n+      // Otherwise, call this class's `CrossHostSendBuffers` method to use the\n+      // plugin's `CopyToRemoteDevice` API, getting the buffer descriptors from\n+      // the KV store.\n+      absl::StatusOr<std::vector<Future<>>> send_futures =\n+          pjrt_client_->CrossHostSendBuffers(\n+              send_buffers, std::move(dst_global_device_ids), transfer_keys);\n+      if (send_futures.ok()) {\n+        for (Future<>& send_future : *send_futures) {\n+          send_future.OnReady(on_send_done);\n+        }\n+      } else if (absl::IsUnimplemented(send_futures.status())) {\n+        TF_RETURN_IF_ERROR(\n+            CrossHostSendBuffers(send_buffers, std::move(transfer_keys)));\n+      } else {\n+        return send_futures.status();\n+      }\n       ++j;\n     } else if (dst_devices->devices()[i]->IsAddressable()) {\n+      // Create vector of shapes to receive.\n       std::vector<xla::Shape> recv_shapes;\n       recv_shapes.reserve(arrays.size());\n       for (const ArrayRef& array : arrays) {\n@@ -1371,14 +1407,42 @@ PjRtClient::CopyArraysForCrossHost(absl::Span<ArrayRef> arrays,\n               \"PjRtClient::CopyArraysForCrossHost\");\n         }\n       }\n+\n+      // Get the dst device we receive into.\n       TF_ASSIGN_OR_RETURN(\n           xla::PjRtGlobalDeviceId pjrt_global_device_id,\n           GetPjRtGlobalDeviceId(dst_devices->devices()[i]->Id()));\n       TF_ASSIGN_OR_RETURN(xla::PjRtDevice * pjrt_device,\n                           pjrt_client_->LookupDevice(pjrt_global_device_id));\n-      TF_ASSIGN_OR_RETURN(recv_buffers.emplace_back(),\n-                          CrossHostReceiveBuffers(recv_shapes, pjrt_device,\n-                                                  std::move(transfer_keys)));\n+\n+      // Create vector of src devices; we receive each array from\n+      // src_devices->devices()[i].\n+      TF_ASSIGN_OR_RETURN(\n+          xla::PjRtGlobalDeviceId src_global_device_id,\n+          GetPjRtGlobalDeviceId(src_devices->devices()[i]->Id()));\n+      std::vector<PjRtGlobalDeviceId> src_global_device_ids(\n+          arrays.size(), src_global_device_id);\n+\n+      // If the PJRT plugin implements the `CrossHostReceiveBuffers` API, use\n+      // it. Otherwise, call this class's `CrossHostReceiveBuffers` method to\n+      // use the plugin's `MakeCrossHostReceiveBuffers` API, transmitting the\n+      // buffer descriptors via the KV store.\n+      absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n+          received_buffers = pjrt_client_->CrossHostReceiveBuffers(\n+              pjrt_device, recv_shapes, std::move(src_global_device_ids),\n+              transfer_keys);\n+      if (received_buffers.ok()) {\n+        recv_buffers.push_back(std::move(*received_buffers));\n+      } else if (absl::IsUnimplemented(received_buffers.status())) {\n+        TF_ASSIGN_OR_RETURN(recv_buffers.emplace_back(),\n+                            CrossHostReceiveBuffers(recv_shapes, pjrt_device,\n+                                                    std::move(transfer_keys)));\n+      } else {\n+        return received_buffers.status();\n+      }\n+      for (auto& buffer : recv_buffers.back()) {\n+        buffer->GetReadyFuture().OnReady(on_recv_done);\n+      }\n     }\n   }\n \n@@ -1428,7 +1492,9 @@ PjRtClient::CopyArraysForCrossHostFallback(\n                                memory_kind);\n }\n \n-int64_t PjRtClient::CreateNewTransferKey() { return next_transfer_key_++; }\n+CrossHostTransferKey PjRtClient::CreateNewTransferKey() {\n+  return CrossHostTransferKey(next_transfer_key_++);\n+}\n \n absl::Status PjRtClient::WatchGlobalProcessInfo(\n     tsl::CoordinationServiceAgent& agent) {\n@@ -1507,7 +1573,8 @@ absl::Status PjRtClient::WatchGlobalProcessInfo(\n }\n \n absl::Status PjRtClient::CrossHostSendBuffers(\n-    PjRtBuffers buffers, const std::vector<int64_t>& keys) {\n+    std::vector<PjRtBuffer*> buffers,\n+    const std::vector<CrossHostTransferKey>& keys) {\n   if (keys.size() != buffers.size()) {\n     return absl::InternalError(\n         \"CrossHostSendBuffers: keys must be the same size as buffers.\");\n@@ -1518,7 +1585,7 @@ absl::Status PjRtClient::CrossHostSendBuffers(\n     auto [promise, descriptor_future] = tsl::Future<std::string>::MakePromise();\n     work_queue_->Schedule(\n         [this, k = keys[i], promise = std::move(promise).ToShared()]() mutable {\n-          std::string key = absl::StrCat(kKeyPrefix, k);\n+          std::string key = absl::StrCat(kKeyPrefix, k.value());\n           absl::StatusOr<std::string> descriptor =\n               kv_store_->Get(key, cross_host_transfer_timeout_);\n           if (!descriptor.ok()) {\n@@ -1528,16 +1595,24 @@ absl::Status PjRtClient::CrossHostSendBuffers(\n           promise->Set(std::move(*descriptor));\n         });\n     auto on_done = [](absl::Status status, bool sends_were_enqueued) {\n-      CHECK_OK(status);\n+      if (!status.ok()) {\n+        LOG(ERROR) << \"`xla::PjRtBuffer::CopyToRemoteDevice` failed: \"\n+                   << status;\n+      }\n+      if (!sends_were_enqueued) {\n+        LOG(ERROR) << \"`xla::PjRtBuffer::CopyToRemoteDevice` did not enqueue \"\n+                      \"sends.\";\n+      }\n     };\n     buffers[i]->CopyToRemoteDevice(std::move(descriptor_future), on_done);\n   }\n   return absl::OkStatus();\n }\n \n-absl::StatusOr<PjRtArray::PjRtBuffers> PjRtClient::CrossHostReceiveBuffers(\n-    absl::Span<const xla::Shape> shapes, xla::PjRtDevice* device,\n-    std::vector<int64_t> keys) {\n+absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n+PjRtClient::CrossHostReceiveBuffers(absl::Span<const xla::Shape> shapes,\n+                                    xla::PjRtDevice* device,\n+                                    std::vector<CrossHostTransferKey> keys) {\n   auto notifier = [this, keys = std::move(keys)](\n                       absl::StatusOr<xla::PjRtCrossHostRecvState> recv_state) {\n     if (!recv_state.ok()) {\n@@ -1567,7 +1642,7 @@ absl::StatusOr<PjRtArray::PjRtBuffers> PjRtClient::CrossHostReceiveBuffers(\n       return;\n     }\n     for (int i = 0, n = keys.size(); i < n; ++i) {\n-      std::string key = absl::StrCat(kKeyPrefix, keys[i]);\n+      std::string key = absl::StrCat(kKeyPrefix, keys[i].value());\n       absl::Status kv_status = kv_store_->Set(\n           key, recv_state->descriptors[i].serialized_descriptors.front());\n       if (!kv_status.ok()) {\n@@ -1581,15 +1656,8 @@ absl::StatusOr<PjRtArray::PjRtBuffers> PjRtClient::CrossHostReceiveBuffers(\n       }\n     }\n   };\n-  TF_ASSIGN_OR_RETURN(auto recv_buffers,\n-                      pjrt_client_->MakeCrossHostReceiveBuffers(\n-                          shapes, device, std::move(notifier)));\n-  PjRtArray::PjRtBuffers buffers;\n-  buffers.reserve(recv_buffers.size());\n-  for (auto& recv_buffer : recv_buffers) {\n-    buffers.push_back(std::move(recv_buffer));\n-  }\n-  return buffers;\n+  return pjrt_client_->MakeCrossHostReceiveBuffers(shapes, device,\n+                                                   std::move(notifier));\n }\n \n absl::StatusOr<std::vector<xla::ifrt::ArrayRef>> PjRtClient::RemapArrays("
        },
        {
            "sha": "040775d7a98dd13094199072654b2f5035c599b0",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_client.h",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d231250a664edc0014f48dde0b66f7ef57e02e51/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d231250a664edc0014f48dde0b66f7ef57e02e51/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.h?ref=d231250a664edc0014f48dde0b66f7ef57e02e51",
            "patch": "@@ -388,15 +388,19 @@ class PjRtClient final\n       DeviceListRef dst_devices, std::optional<MemoryKind> memory_kind);\n \n   // Extracts receive descriptors from a key-value store and sends buffers to a\n-  // remote device.\n-  absl::Status CrossHostSendBuffers(PjRtBuffers buffers,\n-                                    const std::vector<int64_t>& keys);\n+  // remote device. This is used when the backend does not implement the\n+  // CrossHostSendBuffers API.\n+  absl::Status CrossHostSendBuffers(\n+      std::vector<PjRtBuffer*> buffers,\n+      const std::vector<CrossHostTransferKey>& keys);\n \n   // Populates a key-value store with receive descriptors and places buffers\n-  // from a cross-host send onto device.\n-  absl::StatusOr<PjRtBuffers> CrossHostReceiveBuffers(\n-      absl::Span<const xla::Shape> shapes, xla::PjRtDevice* device,\n-      std::vector<int64_t> keys);\n+  // from a cross-host send onto device. This is used when the backend does not\n+  // implement the CrossHostReceiveBuffers API.\n+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n+  CrossHostReceiveBuffers(absl::Span<const xla::Shape> shapes,\n+                          xla::PjRtDevice* device,\n+                          std::vector<CrossHostTransferKey> keys);\n \n   // Copies arrays from source to destination devices when at least one of the\n   // (source, destination) pairs is cross-host using an experimental DCN\n@@ -409,7 +413,7 @@ class PjRtClient final\n   // Creates a unique identifier for each cross-host transfer. Every process\n   // must call it, regardless of whether it participates in the cross-host\n   // transfer, so that the returned value must be the same in all processes.\n-  int64_t CreateNewTransferKey();\n+  CrossHostTransferKey CreateNewTransferKey();\n \n   // If true, the backend implements the cross-host transfer APIs.\n   bool pjrt_supports_cross_host_transfers_ = false;"
        }
    ],
    "stats": {
        "total": 142,
        "additions": 107,
        "deletions": 35
    }
}