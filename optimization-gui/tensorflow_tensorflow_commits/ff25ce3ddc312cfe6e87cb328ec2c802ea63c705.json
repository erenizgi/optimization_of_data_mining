{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add benchmarks for mapping Futures\n\nPiperOrigin-RevId: 814699729",
    "sha": "ff25ce3ddc312cfe6e87cb328ec2c802ea63c705",
    "files": [
        {
            "sha": "c266f88fc14da73255e434b30f5259cc209f93fe",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 5,
            "changes": 61,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ff25ce3ddc312cfe6e87cb328ec2c802ea63c705/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ff25ce3ddc312cfe6e87cb328ec2c802ea63c705/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=ff25ce3ddc312cfe6e87cb328ec2c802ea63c705",
            "patch": "@@ -828,17 +828,68 @@ static void BM_CreateOkFuture(benchmark::State& state) {\n   }\n }\n \n-static void BM_StatelessMapTo(benchmark::State& state) {\n-  std::shared_ptr<float> value = std::make_shared<float>(42.0f);\n+static void BM_CopyFuture(benchmark::State& state) {\n+  Future<> future(absl::OkStatus());\n \n   for (auto _ : state) {\n-    Future<> future(absl::OkStatus());\n-    Future<std::shared_ptr<float>> mapped = future.MapTo(value);\n+    Future<> copy = future;\n+    benchmark::DoNotOptimize(copy);\n+  }\n+}\n+\n+static void BM_MapStatelessFuture(benchmark::State& state) {\n+  Future<> future(absl::OkStatus());\n+\n+  for (auto _ : state) {\n+    Future<int32_t> mapped = future.Map([] { return 42; });\n+    benchmark::DoNotOptimize(mapped);\n+  }\n+}\n+\n+static void BM_TryMapStatelessFuture(benchmark::State& state) {\n+  Future<> future(absl::OkStatus());\n+\n+  for (auto _ : state) {\n+    Future<int32_t> mapped =\n+        future.Map([]() -> absl::StatusOr<int32_t> { return 42; });\n+    benchmark::DoNotOptimize(mapped);\n+  }\n+}\n+\n+static void BM_MapToFromStatelessFuture(benchmark::State& state) {\n+  Future<> future(absl::OkStatus());\n+\n+  for (auto _ : state) {\n+    Future<int32_t> mapped = future.MapTo(42);\n+    benchmark::DoNotOptimize(mapped);\n+  }\n+}\n+\n+static void BM_MapStatefulFuture(benchmark::State& state) {\n+  Future<int32_t> future(42);\n+\n+  for (auto _ : state) {\n+    Future<int32_t> mapped = future.Map([](int32_t x) { return x + 1; });\n+    benchmark::DoNotOptimize(mapped);\n+  }\n+}\n+\n+static void BM_TryMapStatefulFuture(benchmark::State& state) {\n+  Future<int32_t> future(42);\n+\n+  for (auto _ : state) {\n+    Future<int32_t> mapped =\n+        future.Map([](int32_t x) -> absl::StatusOr<int32_t> { return x + 1; });\n     benchmark::DoNotOptimize(mapped);\n   }\n }\n \n BENCHMARK(BM_CreateOkFuture);\n-BENCHMARK(BM_StatelessMapTo);\n+BENCHMARK(BM_CopyFuture);\n+BENCHMARK(BM_MapStatelessFuture);\n+BENCHMARK(BM_TryMapStatelessFuture);\n+BENCHMARK(BM_MapToFromStatelessFuture);\n+BENCHMARK(BM_MapStatefulFuture);\n+BENCHMARK(BM_TryMapStatefulFuture);\n \n }  // namespace tsl"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 56,
        "deletions": 5
    }
}