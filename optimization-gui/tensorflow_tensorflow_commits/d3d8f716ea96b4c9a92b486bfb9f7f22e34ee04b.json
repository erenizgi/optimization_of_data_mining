{
    "author": "ishark",
    "message": "Add the restarted tasks to unsynced tasks only after the cluster registration barrier has passed.\n\nThe cluster initialization barrier (`kClusterRegisterBarrierId`) requires all tasks to connect. This change ensures that unsynced tasks are not excluded from this barrier, as it is crucial for MegaScale initialization and topology discovery during JAX setup.\n\nPiperOrigin-RevId: 804932086",
    "sha": "d3d8f716ea96b4c9a92b486bfb9f7f22e34ee04b",
    "files": [
        {
            "sha": "8667719a50774fadc33d1e74c5af0a47e46ebcc7",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/coordination/coordination_service.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3d8f716ea96b4c9a92b486bfb9f7f22e34ee04b/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fcoordination%2Fcoordination_service.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3d8f716ea96b4c9a92b486bfb9f7f22e34ee04b/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fcoordination%2Fcoordination_service.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Fcoordination%2Fcoordination_service.cc?ref=d3d8f716ea96b4c9a92b486bfb9f7f22e34ee04b",
            "patch": "@@ -532,13 +532,6 @@ CoordinationService::ConnectAfterBarrierPasses(absl::string_view task_name,\n     if (s.ok() && incarnation == task_state->GetTaskIncarnation()) {\n       // Connect task to service.\n       task_state->Connect();\n-      if (task_state->IsRecoverable() &&\n-          absl::GetFlag(FLAGS_leave_barriers_on_recoverable_agent_restart)) {\n-        // We want to mark the task unsynced when it connects again. When the\n-        // task passes a barrier with other tasks, it will be removed from the\n-        // unsynced set.\n-        unsynced_recoverable_jobs_.insert(task);\n-      }\n       done(absl::OkStatus());\n       ClusterStateUpdated();\n     } else if (s.ok() || absl::IsCancelled(s)) {\n@@ -621,6 +614,20 @@ void CoordinationService::RegisterTaskAsync(const CoordinatedTask& task,\n       // and the barrier has not succeeded yet.\n       // There is no state that needs to be cleaned up.\n       task_cluster_state->SetTaskIncarnation(incarnation);\n+      // If the task is recoverable and rejoins after the cluster register\n+      // barrier has passed, we want to mark the task unsynced when it connects\n+      // again. When the task passes a barrier with other tasks, it will be\n+      // removed from the unsynced set.\n+      if (task_cluster_state->IsRecoverable() &&\n+          absl::GetFlag(FLAGS_leave_barriers_on_recoverable_agent_restart)) {\n+        if (barriers_.contains(kClusterRegisterBarrierId) &&\n+            barriers_[kClusterRegisterBarrierId].passed) {\n+          // We want to mark the task unsynced when it connects again. When the\n+          // task passes a barrier with other tasks, it will be removed from the\n+          // unsynced set.\n+          unsynced_recoverable_jobs_.insert(GetTaskName(task));\n+        }\n+      }\n       BarrierAsyncLocked(\n           kClusterRegisterBarrierId, kUniqueBarrierCounter,\n           cluster_register_timeout_, task, {},"
        }
    ],
    "stats": {
        "total": 21,
        "additions": 14,
        "deletions": 7
    }
}