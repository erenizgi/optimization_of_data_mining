{
    "author": "khasanovaa",
    "message": "Rename \"address computation thunk\" to \"dynamic slice thunk\" in comments and VLOGs.\n\nPiperOrigin-RevId: 816118273",
    "sha": "e888e92fb9201c1a6cc15713371d776436dc87e9",
    "files": [
        {
            "sha": "c396d1c5fc1dadddfae807ec91b11451797e22f1",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_cmd.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e888e92fb9201c1a6cc15713371d776436dc87e9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e888e92fb9201c1a6cc15713371d776436dc87e9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.cc?ref=e888e92fb9201c1a6cc15713371d776436dc87e9",
            "patch": "@@ -2452,7 +2452,7 @@ absl::StatusOr<const se::CommandBuffer::Command*> DynamicSliceFusionCmd::Record(\n     return offsets_alloc[offsets_allocs_base_.at(arg_idx) + offset_idx];\n   };\n \n-  VLOG(2) << \"Execute address computation thunk: slices=\" << slices_.size();\n+  VLOG(2) << \"Execute dynamic slice thunk: slices=\" << slices_.size();\n   for (auto [argument_idx, slice] : llvm::enumerate(slices_)) {\n     // Skip arguments that do not have buffer slices (tokens).\n     if (!slice.embedded_thunk_argument.has_value()) {"
        },
        {
            "sha": "384c18a396710d6c569d00dfd17ca42c923db10c",
            "filename": "third_party/xla/xla/backends/gpu/runtime/dynamic_slice_thunk.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e888e92fb9201c1a6cc15713371d776436dc87e9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e888e92fb9201c1a6cc15713371d776436dc87e9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.cc?ref=e888e92fb9201c1a6cc15713371d776436dc87e9",
            "patch": "@@ -223,7 +223,7 @@ absl::Status DynamicSliceThunk::ExecuteOnStream(const ExecuteParams& params) {\n     return offsets_alloc[offsets_allocs_base_.at(arg_idx) + offset_idx];\n   };\n \n-  VLOG(2) << \"Execute address computation thunk: slices=\" << slices_.size();\n+  VLOG(2) << \"Execute dynamic slice thunk: slices=\" << slices_.size();\n   for (auto [argument_idx, slice] : llvm::enumerate(slices_)) {\n     // Skip arguments that do not have buffer slices (tokens).\n     if (!slice.embedded_thunk_argument.has_value()) {"
        },
        {
            "sha": "757f0475135eac3c8638566f3d2ce2bcb1080c0d",
            "filename": "third_party/xla/xla/backends/gpu/runtime/dynamic_slice_thunk_test.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 27,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e888e92fb9201c1a6cc15713371d776436dc87e9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e888e92fb9201c1a6cc15713371d776436dc87e9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc?ref=e888e92fb9201c1a6cc15713371d776436dc87e9",
            "patch": "@@ -199,7 +199,7 @@ absl::StatusOr<std::unique_ptr<DynamicSliceThunk>> CreateSlicedGemmThunk(\n       Thunk::ThunkInfo(), config, slice_lhs_fake, slice_rhs, slice_out,\n       slice_workspace, /*deterministic=*/true));\n \n-  // Wrapping address computation thunk around the GEMM thunk.\n+  // Wrapping dynamic slice thunk around the GEMM thunk.\n   std::vector<DynamicSliceThunk::Offset> lhs_offsets{slice_lhs_offset_0,\n                                                      slice_lhs_offset_1};\n   return std::make_unique<DynamicSliceThunk>(\n@@ -239,7 +239,7 @@ TEST_F(DynamicSliceThunkTest, SlicedGemm) {\n   int64_t out_length = sizeof(float) * 1 * 1;\n   int64_t offset_length = sizeof(int64_t);\n \n-  // Execute address computation thunk.\n+  // Execute dynamic slice thunk.\n   //\n   // Given a `lhs` tensor of shape f32[2,4]{1,0}\n   // The `lhs` slice that we want to use will be equivalent to this static\n@@ -288,7 +288,7 @@ TEST_F(DynamicSliceThunkTest, SlicedGemm) {\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -372,7 +372,7 @@ CreateMultipleSlicedOperandsGemmThunk(\n       Thunk::ThunkInfo(), config, slice_lhs_fake, slice_rhs_fake, slice_out,\n       slice_workspace, /*deterministic=*/true));\n \n-  // Wrapping address computation thunk around the GEMM thunk.\n+  // Wrapping dynamic slice thunk around the GEMM thunk.\n   std::vector<DynamicSliceThunk::Offset> lhs_offsets{slice_lhs_offset_0,\n                                                      slice_lhs_offset_1};\n   std::vector<DynamicSliceThunk::Offset> rhs_offsets{slice_rhs_offset_0,\n@@ -479,7 +479,7 @@ TEST_F(DynamicSliceThunkTest, MultipleSlicedOperandsGemm) {\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Execute address computation thunk and verify that it executed a GEMM on the\n+  // Execute dynamic slice thunk and verify that it executed a GEMM on the\n   // right slices.\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n@@ -522,7 +522,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpy) {\n   int64_t slice_length = sizeof(int32_t) * dst_count;\n \n   // Step 1:\n-  // Prepare embedded and address computation thunks.\n+  // Prepare embedded and dynamic slice thunks.\n \n   // Preparing buffer allocation slices for thunk creations.\n   std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(2);\n@@ -575,7 +575,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpy) {\n                               /*attributes=*/CustomCallThunk::AttributesMap(),\n                               /*called_computation=*/nullptr));\n \n-  // Wrapping address computation thunk around the custom call thunk.\n+  // Wrapping dynamic slice thunk around the custom call thunk.\n   std::vector<DynamicSliceThunk::Offset> slice_offsets{\n       slice_offset_0, slice_offset_1, slice_offset_2, slice_offset_3};\n   DynamicSliceThunk thunk(\n@@ -589,7 +589,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpy) {\n       {sizeof(int64_t), std::nullopt});\n \n   // Step 2:\n-  // Execute address computation thunk.\n+  // Execute dynamic slice thunk.\n   //\n   // Given a `src` tensor of shape s32[8,8,10,8]{3,2,1,0}\n   // The `src` slice that we want to copy from will be equivalent to this static\n@@ -630,7 +630,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpy) {\n   TF_ASSERT_OK(thunk.Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk.ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -662,7 +662,7 @@ TEST_F(DynamicSliceThunkTest, SlicedOutputMemcpy) {\n   int64_t slice_length = sizeof(int32_t) * slice_count;\n \n   // Step 1:\n-  // Prepare embedded and address computation thunks.\n+  // Prepare embedded and dynamic slice thunks.\n \n   // Preparing buffer allocation slices for thunk creations.\n   std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(2);\n@@ -738,7 +738,7 @@ TEST_F(DynamicSliceThunkTest, SlicedOutputMemcpy) {\n                               /*attributes=*/CustomCallThunk::AttributesMap(),\n                               /*called_computation=*/nullptr));\n \n-  // Wrapping address computation thunk around the custom call thunk.\n+  // Wrapping dynamic slice thunk around the custom call thunk.\n   std::vector<DynamicSliceThunk::Offset> slice_src_offsets{\n       slice_src_offset_0, slice_src_offset_1, slice_src_offset_2,\n       slice_src_offset_3};\n@@ -758,7 +758,7 @@ TEST_F(DynamicSliceThunkTest, SlicedOutputMemcpy) {\n       {sizeof(int64_t), sizeof(int64_t)});\n \n   // Step 2:\n-  // Execute address computation thunk.\n+  // Execute dynamic slice thunk.\n   //\n   // Given a `src` tensor of shape s32[8,8,10,2]{3,2,1,0}\n   // The `src` slice that we want to copy from will be equivalent to this static\n@@ -824,7 +824,7 @@ TEST_F(DynamicSliceThunkTest, SlicedOutputMemcpy) {\n   TF_ASSERT_OK(thunk.Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk.ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -920,7 +920,7 @@ CreateSlicedGemmArbitraryArgumentOrderThunk(\n       Thunk::ThunkInfo(), config, slice_lhs_fake, slice_rhs_fake,\n       slice_out_fake, slice_workspace_fake, /*deterministic=*/true));\n \n-  // Wrapping address computation thunk around the GEMM thunk.\n+  // Wrapping dynamic slice thunk around the GEMM thunk.\n   std::vector<DynamicSliceThunk::Offset> lhs_offsets{slice_lhs_offset_0,\n                                                      slice_lhs_offset_1};\n   return std::make_unique<DynamicSliceThunk>(\n@@ -962,7 +962,7 @@ TEST_F(DynamicSliceThunkTest, SlicedGemmArbitraryArgumentOrder) {\n   int64_t out_length = sizeof(float) * 1 * 1;\n   int64_t offset_length = sizeof(int64_t);\n \n-  // Execute address computation thunk.\n+  // Execute dynamic slice thunk.\n   //\n   // Given a `lhs` tensor of shape f32[2,4]{1,0}\n   // The `lhs` slice that we want to use will be equivalent to this static\n@@ -1011,7 +1011,7 @@ TEST_F(DynamicSliceThunkTest, SlicedGemmArbitraryArgumentOrder) {\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -1096,7 +1096,7 @@ CreateSlicedGemmArbitraryNumberOfArgumentsThunk(\n       Thunk::ThunkInfo(), config, slice_lhs_fake, slice_rhs_fake,\n       slice_out_fake, slice_workspace_fake, /*deterministic=*/true));\n \n-  // Wrapping address computation thunk around the GEMM thunk.\n+  // Wrapping dynamic slice thunk around the GEMM thunk.\n   std::vector<DynamicSliceThunk::Offset> lhs_offsets{slice_lhs_offset_0,\n                                                      slice_lhs_offset_1};\n   return std::make_unique<DynamicSliceThunk>(\n@@ -1188,7 +1188,7 @@ TEST_F(DynamicSliceThunkTest, SlicedGemmArbitraryNumberOfArguments) {\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -1265,7 +1265,7 @@ CreateSlicedTupledOperandGemmThunk(\n       Thunk::ThunkInfo(), config, slice_lhs_fake, slice_rhs, slice_out,\n       slice_workspace, /*deterministic=*/true));\n \n-  // Wrapping address computation thunk around the GEMM thunk.\n+  // Wrapping dynamic slice thunk around the GEMM thunk.\n   std::vector<DynamicSliceThunk::Offset> lhs_offsets{slice_lhs_offset_0,\n                                                      slice_lhs_offset_1};\n   return std::make_unique<DynamicSliceThunk>(\n@@ -1359,7 +1359,7 @@ TEST_F(DynamicSliceThunkTest, SlicedTupledOperandGemm) {\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -1384,7 +1384,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpyOOB) {\n   int64_t slice_length = sizeof(int32_t) * slice_count;\n \n   // Step 1:\n-  // Prepare embedded and address computation thunks.\n+  // Prepare embedded and dynamic slice thunks.\n \n   // Preparing buffer allocation slices for thunk creations.\n   std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(2);\n@@ -1460,7 +1460,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpyOOB) {\n                               /*attributes=*/CustomCallThunk::AttributesMap(),\n                               /*called_computation=*/nullptr));\n \n-  // Wrapping address computation thunk around the custom call thunk.\n+  // Wrapping dynamic slice thunk around the custom call thunk.\n   std::vector<DynamicSliceThunk::Offset> slice_src_offsets{\n       slice_src_offset_0, slice_src_offset_1, slice_src_offset_2,\n       slice_src_offset_3};\n@@ -1480,7 +1480,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpyOOB) {\n       {sizeof(int64_t), sizeof(int64_t)});\n \n   // Step 2:\n-  // Execute address computation thunk.\n+  // Execute dynamic slice thunk.\n   //\n   // Given a `src` tensor of shape s32[8,8,10,2]{3,2,1,0}\n   // The `src` slice that we want to copy from will be equivalent to this static\n@@ -1548,7 +1548,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpyOOB) {\n   TF_ASSERT_OK(thunk.Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk.ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -1647,7 +1647,7 @@ CreateSlicedOperandsSameBufferGemmThunk(\n       Thunk::ThunkInfo(), config, slice_lhs_fake, slice_rhs_fake,\n       slice_out_fake, slice_workspace_fake, /*deterministic=*/true));\n \n-  // Wrapping address computation thunk around the GEMM thunk.\n+  // Wrapping dynamic slice thunk around the GEMM thunk.\n   std::vector<DynamicSliceThunk::Offset> lhs_offsets{slice_lhs_offset_0,\n                                                      slice_lhs_offset_1};\n   return std::make_unique<DynamicSliceThunk>(\n@@ -1740,7 +1740,7 @@ TEST_F(DynamicSliceThunkTest, SlicedOperandsSameBufferGemm) {\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));\n   TF_ASSERT_OK(stream->BlockHostUntilDone());\n \n@@ -1964,7 +1964,7 @@ TEST_F(DynamicSliceThunkTest,\n   TF_ASSERT_OK(thunk->Initialize(\n       {executor, source, &allocations, stream.get(), stream.get()}));\n \n-  // Executing address computation thunk.\n+  // Executing dynamic slice thunk.\n   ResourceRequests resource_requests;\n   TF_ASSERT_OK(thunk->Prepare(prepare_params, resource_requests));\n   TF_ASSERT_OK(thunk->ExecuteOnStream(params));"
        }
    ],
    "stats": {
        "total": 58,
        "additions": 29,
        "deletions": 29
    }
}