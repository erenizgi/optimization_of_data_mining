{
    "author": "ezhulenev",
    "message": "[xla] Prepare to MaybeOwningDeviceAddress migration\n\nPiperOrigin-RevId: 841784507",
    "sha": "eed57fa340139e372413b2695de32db1ae75fe8a",
    "files": [
        {
            "sha": "8973a3631eccdf7f140cd08fff6e4ecaada798b6",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 19,
            "deletions": 8,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=eed57fa340139e372413b2695de32db1ae75fe8a",
            "patch": "@@ -4080,28 +4080,39 @@ xla_cc_test(\n )\n \n cc_library(\n-    name = \"maybe_owning_device_memory\",\n-    srcs = [\"maybe_owning_device_memory.cc\"],\n-    hdrs = [\"maybe_owning_device_memory.h\"],\n+    name = \"maybe_owning_device_address\",\n+    srcs = [\"maybe_owning_device_address.cc\"],\n+    hdrs = [\"maybe_owning_device_address.h\"],\n     deps = [\n+        \"//xla:types\",\n         \"//xla/stream_executor:device_address\",\n         \"//xla/stream_executor:device_address_allocator\",\n-        \"//xla/stream_executor:device_memory\",\n-        \"//xla/stream_executor:device_memory_allocator\",\n+        \"@com_google_absl//absl/base:core_headers\",\n     ],\n )\n \n xla_cc_test(\n-    name = \"maybe_owning_device_memory_test\",\n-    srcs = [\"maybe_owning_device_memory_test.cc\"],\n+    name = \"maybe_owning_device_address_test\",\n+    srcs = [\"maybe_owning_device_address_test.cc\"],\n     deps = [\n-        \":maybe_owning_device_memory\",\n+        \":maybe_owning_device_address\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\",\n         \"//xla/tsl/platform:test_main\",\n     ],\n )\n \n+cc_library(\n+    name = \"maybe_owning_device_memory\",\n+    hdrs = [\"maybe_owning_device_memory.h\"],\n+    deps = [\n+        \":maybe_owning_device_address\",\n+        \"//xla/stream_executor:device_memory\",\n+        \"//xla/stream_executor:device_memory_allocator\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+    ],\n+)\n+\n cc_library(\n     name = \"float8_fnuz_ir_emitter\",\n     srcs = ["
        },
        {
            "sha": "6f8e252ebac99d745a86f439abe8956f0b2316b2",
            "filename": "third_party/xla/xla/service/maybe_owning_device_address.cc",
            "status": "renamed",
            "additions": 13,
            "deletions": 17,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address.cc?ref=eed57fa340139e372413b2695de32db1ae75fe8a",
            "patch": "@@ -13,7 +13,7 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include \"xla/service/maybe_owning_device_memory.h\"\n+#include \"xla/service/maybe_owning_device_address.h\"\n \n #include <cstdint>\n #include <optional>\n@@ -25,33 +25,29 @@ limitations under the License.\n \n namespace xla {\n \n-stream_executor::DeviceAddressBase MaybeOwningDeviceMemory::AsDeviceMemoryBase()\n-    const {\n+se::DeviceAddressBase MaybeOwningDeviceAddress::AsDeviceAddress() const {\n   if (HasOwnership()) {\n-    return *std::get<stream_executor::ScopedDeviceAddress<uint8_t>>(mem_);\n+    return *std::get<se::ScopedDeviceAddress<uint8_t>>(mem_);\n   }\n-  return std::get<stream_executor::DeviceAddressBase>(mem_);\n+  return std::get<se::DeviceAddressBase>(mem_);\n }\n \n-bool MaybeOwningDeviceMemory::HasOwnership() const {\n-  return std::holds_alternative<stream_executor::ScopedDeviceAddress<uint8_t>>(\n-      mem_);\n+bool MaybeOwningDeviceAddress::HasOwnership() const {\n+  return std::holds_alternative<se::ScopedDeviceAddress<uint8_t>>(mem_);\n }\n \n-std::optional<stream_executor::ScopedDeviceAddress<uint8_t>>\n-MaybeOwningDeviceMemory::Release() {\n+std::optional<se::ScopedDeviceAddress<uint8_t>>\n+MaybeOwningDeviceAddress::Release() {\n   if (!HasOwnership()) {\n     return {};\n   }\n-  return std::move(\n-      std::get<stream_executor::ScopedDeviceAddress<uint8_t>>(mem_));\n+  return std::move(std::get<se::ScopedDeviceAddress<uint8_t>>(mem_));\n }\n \n-const stream_executor::ScopedDeviceAddress<uint8_t>*\n-MaybeOwningDeviceMemory::AsOwningDeviceMemory() const {\n-  return HasOwnership()\n-             ? &std::get<stream_executor::ScopedDeviceAddress<uint8_t>>(mem_)\n-             : nullptr;\n+const se::ScopedDeviceAddress<uint8_t>*\n+MaybeOwningDeviceAddress::AsScopedDeviceAddress() const {\n+  return HasOwnership() ? &std::get<se::ScopedDeviceAddress<uint8_t>>(mem_)\n+                        : nullptr;\n }\n \n }  // namespace xla",
            "previous_filename": "third_party/xla/xla/service/maybe_owning_device_memory.cc"
        },
        {
            "sha": "8a6f52e15adcaf29f24a885e5f1b54620af06d8d",
            "filename": "third_party/xla/xla/service/maybe_owning_device_address.h",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address.h?ref=eed57fa340139e372413b2695de32db1ae75fe8a",
            "patch": "@@ -0,0 +1,88 @@\n+/* Copyright 2018 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_SERVICE_MAYBE_OWNING_DEVICE_ADDRESS_H_\n+#define XLA_SERVICE_MAYBE_OWNING_DEVICE_ADDRESS_H_\n+\n+#include <cstdint>\n+#include <optional>\n+#include <utility>\n+#include <variant>\n+\n+#include \"absl/base/macros.h\"\n+#include \"xla/stream_executor/device_address.h\"\n+#include \"xla/stream_executor/device_address_allocator.h\"\n+#include \"xla/types.h\"  // IWYU pragma: keep\n+\n+namespace xla {\n+\n+// MaybeOwningDeviceAddress represents either an owned or unowned device\n+// address. Like std::variant<se::ScopedDeviceAddress<uint8_t>, DeviceMemory>.\n+// When the object goes output of scope, it will free the underlying device\n+// address if it owns it.\n+class MaybeOwningDeviceAddress {\n+ public:\n+  MaybeOwningDeviceAddress() = default;\n+  MaybeOwningDeviceAddress(MaybeOwningDeviceAddress&&) = default;\n+  MaybeOwningDeviceAddress& operator=(MaybeOwningDeviceAddress&&) = default;\n+\n+  explicit MaybeOwningDeviceAddress(se::ScopedDeviceAddress<uint8_t> owned)\n+      : mem_(std::move(owned)) {}\n+\n+  explicit MaybeOwningDeviceAddress(se::DeviceAddressBase unowned)\n+      : mem_(unowned) {}\n+\n+  MaybeOwningDeviceAddress& operator=(se::DeviceAddressBase unowned) {\n+    mem_ = unowned;\n+    return *this;\n+  }\n+\n+  MaybeOwningDeviceAddress& operator=(se::ScopedDeviceAddress<uint8_t> owned) {\n+    mem_ = std::move(owned);\n+    return *this;\n+  }\n+\n+  // Fetches the underlying DeviceAddressBase. The caller of this function is\n+  // *not* responsible for freeing the address.\n+  se::DeviceAddressBase AsDeviceAddress() const;\n+\n+  // Release the se::ScopedDeviceAddress<uint8_t> without freeing\n+  // it, and moves the ownership of the address from the object to the caller.\n+  //\n+  // A nullopt is returned if the HasOwnership() == false;\n+  std::optional<se::ScopedDeviceAddress<uint8_t>> Release();\n+\n+  // If the device address is owned, returns a pointer to the internal\n+  // ScopedDeviceAddress, otherwise nullptr is returned.\n+  const se::ScopedDeviceAddress<uint8_t>* AsScopedDeviceAddress() const;\n+\n+  ABSL_DEPRECATE_AND_INLINE()\n+  se::DeviceAddressBase AsDeviceMemoryBase() const { return AsDeviceAddress(); }\n+\n+  ABSL_DEPRECATE_AND_INLINE()\n+  const se::ScopedDeviceAddress<uint8_t>* AsOwningDeviceMemory() const {\n+    return AsScopedDeviceAddress();\n+  }\n+\n+  // Returns true if has ownership over underlying address.\n+  bool HasOwnership() const;\n+\n+ private:\n+  std::variant<se::DeviceAddressBase, se::ScopedDeviceAddress<uint8_t>> mem_;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_SERVICE_MAYBE_OWNING_DEVICE_ADDRESS_H_"
        },
        {
            "sha": "d2dbcc46aad3cade616ba32ac37c6e4f117ca367",
            "filename": "third_party/xla/xla/service/maybe_owning_device_address_test.cc",
            "status": "renamed",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_address_test.cc?ref=eed57fa340139e372413b2695de32db1ae75fe8a",
            "patch": "@@ -13,21 +13,22 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include \"xla/service/maybe_owning_device_memory.h\"\n+#include \"xla/service/maybe_owning_device_address.h\"\n \n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n \n namespace xla {\n namespace {\n \n-using MaybeOwningDeviceMemoryTest = ::testing::Test;\n+using MaybeOwningDeviceAddressTest = ::testing::Test;\n \n-TEST(MaybeOwningDeviceMemoryTest, DefaultConstructed) {\n-  MaybeOwningDeviceMemory memory;\n+TEST(MaybeOwningDeviceAddressTest, DefaultConstructed) {\n+  MaybeOwningDeviceAddress memory;\n   EXPECT_FALSE(memory.HasOwnership());\n-  EXPECT_EQ(memory.AsDeviceMemoryBase().opaque(), nullptr);\n-  EXPECT_EQ(memory.AsDeviceMemoryBase().size(), 0);\n+\n+  EXPECT_EQ(memory.AsDeviceAddress().opaque(), nullptr);\n+  EXPECT_EQ(memory.AsDeviceAddress().size(), 0);\n }\n \n //===-----------------------------------------------------------------------===/\n@@ -36,7 +37,7 @@ TEST(MaybeOwningDeviceMemoryTest, DefaultConstructed) {\n \n void BM_DefaultConstructed(benchmark::State& state) {\n   for (auto s : state) {\n-    MaybeOwningDeviceMemory memory;\n+    MaybeOwningDeviceAddress memory;\n     benchmark::DoNotOptimize(memory);\n   }\n }",
            "previous_filename": "third_party/xla/xla/service/maybe_owning_device_memory_test.cc"
        },
        {
            "sha": "897003ffb17429d8cd1f5c0a863b89d48ae38578",
            "filename": "third_party/xla/xla/service/maybe_owning_device_memory.h",
            "status": "modified",
            "additions": 6,
            "deletions": 66,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_memory.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eed57fa340139e372413b2695de32db1ae75fe8a/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_memory.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmaybe_owning_device_memory.h?ref=eed57fa340139e372413b2695de32db1ae75fe8a",
            "patch": "@@ -1,4 +1,4 @@\n-/* Copyright 2018 The OpenXLA Authors.\n+/* Copyright 2025 The OpenXLA Authors.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n@@ -16,76 +16,16 @@ limitations under the License.\n #ifndef XLA_SERVICE_MAYBE_OWNING_DEVICE_MEMORY_H_\n #define XLA_SERVICE_MAYBE_OWNING_DEVICE_MEMORY_H_\n \n-#include <cstdint>\n-#include <optional>\n-#include <utility>\n-#include <variant>\n-\n-#include \"xla/stream_executor/device_address.h\"\n-#include \"xla/stream_executor/device_address_allocator.h\"\n+#include \"absl/base/macros.h\"\n+#include \"xla/service/maybe_owning_device_address.h\"\n #include \"xla/stream_executor/device_memory.h\"  // IWYU pragma: keep\n #include \"xla/stream_executor/device_memory_allocator.h\"  // IWYU pragma: keep\n \n namespace xla {\n \n-// MaybeOwningDeviceMemory represents either an owned or unowned\n-// device memory. Like std::variant<se::ScopedDeviceAddress<uint8_t>,\n-// DeviceMemory>. When the object goes output of scope, it will free the\n-// underlying memory if it owns it.\n-class MaybeOwningDeviceMemory {\n- public:\n-  MaybeOwningDeviceMemory() = default;\n-  ~MaybeOwningDeviceMemory() = default;\n-\n-  explicit MaybeOwningDeviceMemory(\n-      stream_executor::ScopedDeviceAddress<uint8_t> owned)\n-      : mem_(std::move(owned)) {}\n-\n-  explicit MaybeOwningDeviceMemory(stream_executor::DeviceAddressBase unowned)\n-      : mem_(unowned) {}\n-\n-  MaybeOwningDeviceMemory(MaybeOwningDeviceMemory&&) = default;\n-\n-  MaybeOwningDeviceMemory& operator=(\n-      stream_executor::DeviceAddressBase unowned) {\n-    mem_ = unowned;\n-    return *this;\n-  }\n-\n-  MaybeOwningDeviceMemory& operator=(\n-      stream_executor::ScopedDeviceAddress<uint8_t> owned) {\n-    mem_ = std::move(owned);\n-    return *this;\n-  }\n-\n-  MaybeOwningDeviceMemory& operator=(MaybeOwningDeviceMemory&&) = default;\n-\n-  // Fetches the underlying DeviceAddressBase from a\n-  // MaybeOwningDeviceMemory. The caller of this function is *not*\n-  // responsible for freeing the memory.\n-  stream_executor::DeviceAddressBase AsDeviceMemoryBase() const;\n-\n-  // Release the stream_executor::ScopedDeviceAddress<uint8_t> without freeing\n-  // it, and moves the ownership of the memory buffer from the object to the\n-  // caller.\n-  //\n-  // A nullopt is returned if the HasOwnership() == false;\n-  std::optional<stream_executor::ScopedDeviceAddress<uint8_t>> Release();\n-\n-  // If the device memory is owned, returns a pointer to the internal\n-  // OwningDeviceMemory, otherwise nullptr is returned.\n-  const stream_executor::ScopedDeviceAddress<uint8_t>* AsOwningDeviceMemory()\n-      const;\n-\n-  // Returns true if the device_memory has ownership over underlying memory.\n-  bool HasOwnership() const;\n-\n- private:\n-  std::variant<stream_executor::DeviceAddressBase,\n-               stream_executor::ScopedDeviceAddress<uint8_t>>\n-      mem_;\n-};\n+using MaybeOwningDeviceMemory ABSL_DEPRECATE_AND_INLINE() =\n+    MaybeOwningDeviceAddress;\n \n-}  // namespace xla\n+}\n \n #endif  // XLA_SERVICE_MAYBE_OWNING_DEVICE_MEMORY_H_"
        }
    ],
    "stats": {
        "total": 232,
        "additions": 134,
        "deletions": 98
    }
}