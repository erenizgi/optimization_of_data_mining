{
    "author": "junwhanahn",
    "message": "Allow implicit conversion from `absl::StatusOr<T>` to `tsl::Future<T>`\n\nThis makes `Future<T>` more ergonomic to use in functions that return `Future<T>`. For example,\n\n```\nFuture<int> Foo() {\n  const absl::StatusOr<int> bar = Bar();\n  if (some_condition) {\n    return Future<int>(bar.status());\n  }\n  ...\n}\n```\n\ncan now be written as\n\n```\nFuture<int> Foo() {\n  ASSIGN_OR_RETURN(const int bar, Bar());\n  ...\n}\n```\n\nNote that `Future<>` already allows implicit conversion from `absl::Status`, so this helps with consistency as well.\n\nThe implicit conversion is allowed only for `U` that is convertible to `absl::StatusOr<T>` (this is necessary to handle `absl::Status` or its variants since C++ allows only one level of implicit conversion). In-place construction from `std::is_constructible` types is excluded from this to avoid potential confusion.\n\nPiperOrigin-RevId: 850611482",
    "sha": "f65a7fb648e10c9e1e5d1ef706432dc23ffe877f",
    "files": [
        {
            "sha": "fd8983c744316871d78ad4cef22c625e621e784f",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f65a7fb648e10c9e1e5d1ef706432dc23ffe877f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f65a7fb648e10c9e1e5d1ef706432dc23ffe877f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=f65a7fb648e10c9e1e5d1ef706432dc23ffe877f",
            "patch": "@@ -169,6 +169,7 @@ tsl_cc_test(\n         \":executor\",\n         \":future\",\n         \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:status_macros\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\",\n         \"//xla/tsl/platform:test_main\","
        },
        {
            "sha": "fb8de1eead8fd03bad3878f7ebd4e8921b99774c",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f65a7fb648e10c9e1e5d1ef706432dc23ffe877f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f65a7fb648e10c9e1e5d1ef706432dc23ffe877f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=f65a7fb648e10c9e1e5d1ef706432dc23ffe877f",
            "patch": "@@ -517,11 +517,17 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   Future() = default;\n \n   // Constructs an immediately available future with the given value.\n-  explicit Future(absl::StatusOr<T> value) : Base(std::move(value)) {}\n+  template <\n+      typename U,\n+      std::enable_if_t<std::is_convertible_v<U, absl::StatusOr<T>>>* = nullptr>\n+  Future(U&& value)  // NOLINT\n+      : Base(std::forward<U>(value)) {}\n \n   // Constructs and immediately available future from the given value.\n-  template <typename U,\n-            std::enable_if_t<std::is_constructible_v<T, U>>* = nullptr>\n+  template <\n+      typename U,\n+      std::enable_if_t<std::is_constructible_v<T, U> &&\n+                       !std::is_convertible_v<U, absl::StatusOr<T>>>* = nullptr>\n   explicit Future(U&& value) : Base(std::forward<U>(value)) {}\n \n   class [[nodiscard]] Promise : public Base::Promise {"
        },
        {
            "sha": "77597afa3034cf10741538982faf7b21406f49ba",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f65a7fb648e10c9e1e5d1ef706432dc23ffe877f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f65a7fb648e10c9e1e5d1ef706432dc23ffe877f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=f65a7fb648e10c9e1e5d1ef706432dc23ffe877f",
            "patch": "@@ -31,10 +31,13 @@ limitations under the License.\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n+#include \"xla/tsl/platform/status_macros.h\"\n \n namespace tsl {\n \n using ::absl_testing::IsOk;\n+using ::absl_testing::IsOkAndHolds;\n+using ::absl_testing::StatusIs;\n using ::testing::Not;\n \n // Inline executor that counts the number of tasks executed.\n@@ -154,6 +157,33 @@ TEST(FutureTest, MoveAssignedFuture) {\n   EXPECT_TRUE(move_assigned.IsReady());\n }\n \n+TEST(FutureTest, StatusImplicitConversion) {\n+  Future<> future = absl::OkStatus();\n+  EXPECT_OK(future.Await());\n+\n+  future = absl::InternalError(\"test\");\n+  EXPECT_THAT(future.Await(), StatusIs(absl::StatusCode::kInternal, \"test\"));\n+}\n+\n+TEST(FutureTest, ValueImplicitConversion) {\n+  Future<int> future = 42;\n+  EXPECT_THAT(future.Await(), IsOkAndHolds(42));\n+\n+  future = absl::InternalError(\"test\");\n+  EXPECT_THAT(future.Await(), StatusIs(absl::StatusCode::kInternal, \"test\"));\n+}\n+\n+TEST(FutureTest, StatusMacro) {\n+  auto f = [&](absl::StatusOr<int> value) -> tsl::Future<int> {\n+    ASSIGN_OR_RETURN(const int x, value);\n+    return x;\n+  };\n+\n+  EXPECT_THAT(f(42).Await(), IsOkAndHolds(42));\n+  EXPECT_THAT(f(absl::InternalError(\"test\")).Await(),\n+              StatusIs(absl::StatusCode::kInternal, \"test\"));\n+}\n+\n TEST(FutureTest, AwaitMoveOnlyFuture) {\n   auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n "
        }
    ],
    "stats": {
        "total": 43,
        "additions": 40,
        "deletions": 3
    }
}