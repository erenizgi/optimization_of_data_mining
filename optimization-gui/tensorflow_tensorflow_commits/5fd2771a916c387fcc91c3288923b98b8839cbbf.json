{
    "author": "ezhulenev",
    "message": "[xla] Use PjRtFuture::Promise::ToShared instead of std::make_shared\n\nPiperOrigin-RevId: 806062172",
    "sha": "5fd2771a916c387fcc91c3288923b98b8839cbbf",
    "files": [
        {
            "sha": "401dcd6f01071d075d19d1f4669a43b621243f3f",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=5fd2771a916c387fcc91c3288923b98b8839cbbf",
            "patch": "@@ -2656,8 +2656,7 @@ void PjRtCApiBuffer::MakePromiseTrackEvent() {\n PjRtFuture<> PjRtCApiBuffer::GetReadyFuture() {\n   if (readiness_promise_ == nullptr) {\n     auto [promise, future] = PjRtFuture<>::MakePromise();\n-    readiness_promise_ =\n-        std::make_shared<PjRtFuture<>::Promise>(std::move(promise));\n+    readiness_promise_ = std::move(promise).ToShared();\n     readiness_future_ = std::move(future);\n     MakePromiseTrackEvent();\n   }"
        },
        {
            "sha": "a8bdf687ccb5c5f734f01721042970b5512b6b4c",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/grpc_client_session.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session.cc?ref=5fd2771a916c387fcc91c3288923b98b8839cbbf",
            "patch": "@@ -125,7 +125,7 @@ GrpcClientSession::GrpcClientSession(\n Future<std::shared_ptr<IfrtResponse>> GrpcClientSession::Enqueue(\n     std::unique_ptr<IfrtRequest> request) {\n   auto [promise, future] = Future<std::shared_ptr<IfrtResponse>>::MakePromise();\n-  auto shared_promise = std::make_shared<decltype(promise)>(std::move(promise));\n+  auto shared_promise = std::move(promise).ToShared();\n   absl::Status status = Enqueue(\n       std::move(request),\n       [promise = std::move(shared_promise),"
        },
        {
            "sha": "48504b38d2edf47ff319a6a8f79b2a619b883023",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/grpc_host_buffer.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 45,
            "changes": 87,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_host_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_host_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_host_buffer.cc?ref=5fd2771a916c387fcc91c3288923b98b8839cbbf",
            "patch": "@@ -100,49 +100,48 @@ Future<> GrpcClientHostBufferStore::Store(uint64_t handle,\n   std::unique_ptr<std::string> buffered_data;\n \n   auto reservation = ScopedAcquireSemaphore(store_throttler_);\n-  work_queue_->Schedule(\n-      [this, reservation = std::move(reservation), handle,\n-       promise = std::make_shared<Future<>::Promise>(std::move(promise)), data,\n-       flow]() mutable -> void {\n-        auto span = flow.Span<XFlowHelper::kRecv>();\n-        GrpcHostBufferStoreMetadata metadata;\n-        metadata.set_session_id(session_id_);\n-        metadata.set_handle(handle);\n-        metadata.set_buffer_size(data.size());\n-        VLOG(3) << \"GrpcClientHostBufferStore::Store start \"\n-                << metadata.ShortDebugString();\n-\n-        ::grpc::ClientContext context;\n-        context.AddMetadata(\"ifrt-proxy-grpc-host-buffer-store-metadata-bin\",\n-                            metadata.SerializeAsString());\n-\n-        GrpcHostBufferStoreResponse response;\n-        auto writer = stub_->HostBufferStore(&context, &response);\n-\n-        {\n-          tsl::profiler::TraceMe trace_me_send_data([size = data.size()]() {\n-            return tsl::profiler::TraceMeEncode(\n-                \"GrpcClientHostBufferStore::StoreAsync_Send\", {{\"size\", size}});\n-          });\n-          for (int64_t offset = 0; offset < data.size(); offset += kChunkSize) {\n-            GrpcHostBufferStoreRequest request;\n-            SetDataFromStringView(request, data.substr(offset, kChunkSize));\n-            writer->Write(request);\n-          }\n-\n-          if (!writer->WritesDone()) {\n-            absl::Status s = xla::FromGrpcStatus(writer->Finish());\n-            promise->Set(absl::InternalError(absl::StrCat(\n-                \"Failed to write all host buffer chunks, Finish() returned: \",\n-                s.ToString())));\n-            return;\n-          }\n-        }\n-\n-        VLOG(3) << \"GrpcClientHostBufferStore::Store done \"\n-                << metadata.ShortDebugString();\n-        promise->Set(xla::FromGrpcStatus(writer->Finish()));\n+  work_queue_->Schedule([this, reservation = std::move(reservation), handle,\n+                         promise = std::move(promise).ToShared(), data,\n+                         flow]() mutable -> void {\n+    auto span = flow.Span<XFlowHelper::kRecv>();\n+    GrpcHostBufferStoreMetadata metadata;\n+    metadata.set_session_id(session_id_);\n+    metadata.set_handle(handle);\n+    metadata.set_buffer_size(data.size());\n+    VLOG(3) << \"GrpcClientHostBufferStore::Store start \"\n+            << metadata.ShortDebugString();\n+\n+    ::grpc::ClientContext context;\n+    context.AddMetadata(\"ifrt-proxy-grpc-host-buffer-store-metadata-bin\",\n+                        metadata.SerializeAsString());\n+\n+    GrpcHostBufferStoreResponse response;\n+    auto writer = stub_->HostBufferStore(&context, &response);\n+\n+    {\n+      tsl::profiler::TraceMe trace_me_send_data([size = data.size()]() {\n+        return tsl::profiler::TraceMeEncode(\n+            \"GrpcClientHostBufferStore::StoreAsync_Send\", {{\"size\", size}});\n       });\n+      for (int64_t offset = 0; offset < data.size(); offset += kChunkSize) {\n+        GrpcHostBufferStoreRequest request;\n+        SetDataFromStringView(request, data.substr(offset, kChunkSize));\n+        writer->Write(request);\n+      }\n+\n+      if (!writer->WritesDone()) {\n+        absl::Status s = xla::FromGrpcStatus(writer->Finish());\n+        promise->Set(absl::InternalError(absl::StrCat(\n+            \"Failed to write all host buffer chunks, Finish() returned: \",\n+            s.ToString())));\n+        return;\n+      }\n+    }\n+\n+    VLOG(3) << \"GrpcClientHostBufferStore::Store done \"\n+            << metadata.ShortDebugString();\n+    promise->Set(xla::FromGrpcStatus(writer->Finish()));\n+  });\n   return std::move(future);\n }\n \n@@ -201,9 +200,7 @@ Future<absl::Cord> GrpcClientHostBufferStore::Lookup(uint64_t handle) {\n \n   auto reservation = ScopedAcquireSemaphore(lookup_throttler_);\n   work_queue_->Schedule([this, reservation = std::move(reservation), handle,\n-                         promise =\n-                             std::make_shared<Future<absl::Cord>::Promise>(\n-                                 std::move(promise)),\n+                         promise = std::move(promise).ToShared(),\n                          flow]() mutable -> void {\n     auto span = flow.Span<XFlowHelper::kRecv>();\n     GrpcHostBufferLookupRequest request;"
        },
        {
            "sha": "4f701808eb365ca767aa221b93108ebe5a311739",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=5fd2771a916c387fcc91c3288923b98b8839cbbf",
            "patch": "@@ -667,9 +667,7 @@ Future<BackendInterface::Response> IfrtBackend::AsyncExecute(\n     ++in_flight_count_;\n   }\n   auto [promise, future] = Future<Response>::MakePromise();\n-  auto f = [this,\n-            promise =\n-                std::make_shared<Future<Response>::Promise>(std::move(promise)),\n+  auto f = [this, promise = std::move(promise).ToShared(),\n             handle_fn = std::move(handle_fn)]() mutable {\n     promise->Set(handle_fn());\n     {"
        },
        {
            "sha": "b509a6d65c1d692ed1947f5ee9cbfc8adac2adb4",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_client.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 14,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd2771a916c387fcc91c3288923b98b8839cbbf/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc?ref=5fd2771a916c387fcc91c3288923b98b8839cbbf",
            "patch": "@@ -660,8 +660,7 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n       Future<BasicStringArray::Buffers>::MakePromise();\n \n   auto buffer_copier = [state = buffer_copying_state,\n-                        promise = std::make_shared<decltype(buffers_promise)>(\n-                            std::move(buffers_promise))](\n+                        promise = std::move(buffers_promise).ToShared()](\n                            absl::StatusOr<BasicStringArray::Buffers> strbuf,\n                            int shard_index) mutable {\n     absl::MutexLock lock(&state->mu);\n@@ -1508,18 +1507,17 @@ absl::Status PjRtClient::CrossHostSendBuffers(\n   // keys together to reduce the number of threads used.\n   for (int i = 0; i < keys.size(); ++i) {\n     auto [promise, descriptor_future] = PjRtFuture<std::string>::MakePromise();\n-    work_queue_->Schedule([this, k = keys[i],\n-                           promise = std::make_shared<decltype(promise)>(\n-                               std::move(promise))]() mutable {\n-      std::string key = absl::StrCat(kKeyPrefix, k);\n-      absl::StatusOr<std::string> descriptor =\n-          kv_store_->Get(key, cross_host_transfer_timeout_);\n-      if (!descriptor.ok()) {\n-        LOG(FATAL) << \"Failed to get descriptor for key \" << key << \": \"\n-                   << descriptor.status();\n-      }\n-      promise->Set(std::move(*descriptor));\n-    });\n+    work_queue_->Schedule(\n+        [this, k = keys[i], promise = std::move(promise).ToShared()]() mutable {\n+          std::string key = absl::StrCat(kKeyPrefix, k);\n+          absl::StatusOr<std::string> descriptor =\n+              kv_store_->Get(key, cross_host_transfer_timeout_);\n+          if (!descriptor.ok()) {\n+            LOG(FATAL) << \"Failed to get descriptor for key \" << key << \": \"\n+                       << descriptor.status();\n+          }\n+          promise->Set(std::move(*descriptor));\n+        });\n     auto on_done = [](absl::Status status, bool sends_were_enqueued) {\n       CHECK_OK(status);\n     };"
        }
    ],
    "stats": {
        "total": 122,
        "additions": 57,
        "deletions": 65
    }
}