{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845711508",
    "sha": "4f02ba06660ddd909021904ae18e0b6e19643c6d",
    "files": [
        {
            "sha": "4ffe789dd282d7461f15591bb771583d242511f2",
            "filename": "tensorflow/core/lib/wav/wav_io.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4f02ba06660ddd909021904ae18e0b6e19643c6d/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4f02ba06660ddd909021904ae18e0b6e19643c6d/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io.h?ref=4f02ba06660ddd909021904ae18e0b6e19643c6d",
            "patch": "@@ -65,9 +65,9 @@ extern template Status EncodeAudioAsS16LEWav<tstring>(const float* audio,\n // The results are output as floats within the range -1 to 1,\n absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,\n                                           std::vector<float>* float_values,\n-                                          uint32* sample_count,\n-                                          uint16* channel_count,\n-                                          uint32* sample_rate);\n+                                          uint32_t* sample_count,\n+                                          uint16_t* channel_count,\n+                                          uint32_t* sample_rate);\n \n // Everything below here is only exposed publicly for testing purposes.\n \n@@ -88,8 +88,8 @@ absl::Status ReadValue(const std::string& data, T* value, int* offset) {\n     memcpy(value, data.data() + *offset, sizeof(T));\n   } else {\n     *value = 0;\n-    const uint8* data_buf =\n-        reinterpret_cast<const uint8*>(data.data() + *offset);\n+    const uint8_t* data_buf =\n+        reinterpret_cast<const uint8_t*>(data.data() + *offset);\n     int shift = 0;\n     for (int i = 0; i < sizeof(T); ++i, shift += 8) {\n       *value = *value | (data_buf[i] << shift);"
        },
        {
            "sha": "68d0c0fa35fbe70623af98f0aff54f7d046743a7",
            "filename": "tensorflow/core/lib/wav/wav_io_test.cc",
            "status": "modified",
            "additions": 219,
            "deletions": 104,
            "changes": 323,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4f02ba06660ddd909021904ae18e0b6e19643c6d/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4f02ba06660ddd909021904ae18e0b6e19643c6d/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io_test.cc?ref=4f02ba06660ddd909021904ae18e0b6e19643c6d",
            "patch": "@@ -31,10 +31,10 @@ namespace wav {\n \n // These are defined in wav_io.cc, and the signatures are here so we don't have\n // to expose them in the public header.\n-absl::Status ExpectText(const string& data, const string& expected_text,\n-                        int* offset);\n-absl::Status ReadString(const string& data, int expected_length, string* value,\n-                        int* offset);\n+absl::Status ExpectText(const std::string& data,\n+                        const std::string& expected_text, int* offset);\n+absl::Status ReadString(const std::string& data, int expected_length,\n+                        std::string* value, int* offset);\n \n TEST(WavIO, BadArguments) {\n   float audio[] = {0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f};\n@@ -76,7 +76,7 @@ TEST(WavIO, BadArguments) {\n \n TEST(WavIO, BasicEven) {\n   float audio[] = {0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f};\n-  string result;\n+  std::string result;\n   TF_EXPECT_OK(EncodeAudioAsS16LEWav(audio, 44100, 2, 3, &result));\n   EXPECT_EQ(56, result.size());\n   TF_EXPECT_OK(EncodeAudioAsS16LEWav(audio, 22050, 1, 6, &result));\n@@ -87,19 +87,19 @@ TEST(WavIO, BasicEven) {\n \n TEST(WavIO, BasicOdd) {\n   float audio[] = {0.0f, 0.1f, 0.2f, 0.3f, 0.4f};\n-  string result;\n+  std::string result;\n   TF_EXPECT_OK(EncodeAudioAsS16LEWav(audio, 22050, 1, 5, &result));\n   EXPECT_EQ(54, result.size());\n }\n \n TEST(WavIO, EncodeThenDecode) {\n   float audio[] = {0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f};\n-  string wav_data;\n+  std::string wav_data;\n   TF_ASSERT_OK(EncodeAudioAsS16LEWav(audio, 44100, 2, 3, &wav_data));\n   std::vector<float> decoded_audio;\n-  uint32 decoded_sample_count;\n-  uint16 decoded_channel_count;\n-  uint32 decoded_sample_rate;\n+  uint32_t decoded_sample_count;\n+  uint16_t decoded_channel_count;\n+  uint32_t decoded_sample_rate;\n   TF_ASSERT_OK(DecodeLin16WaveAsFloatVector(\n       wav_data, &decoded_audio, &decoded_sample_count, &decoded_channel_count,\n       &decoded_sample_rate));\n@@ -112,59 +112,129 @@ TEST(WavIO, EncodeThenDecode) {\n }\n \n TEST(WavIO, BasicMono) {\n-  std::vector<uint8> wav_data = {\n-      'R', 'I', 'F', 'F',  // ChunkID\n-      44, 0, 0, 0,         // ChunkSize: 36 + SubChunk2Size\n-      'W', 'A', 'V', 'E',  // Format\n-      'f', 'm', 't', ' ',  // Subchunk1ID\n-      16, 0, 0, 0,         // Subchunk1Size\n-      1, 0,                // AudioFormat: 1=PCM\n-      1, 0,                // NumChannels\n-      0x44, 0xac, 0, 0,    // SampleRate: 44100\n-      0x88, 0x58, 0x1, 0,  // BytesPerSecond: SampleRate * NumChannels *\n-                           //                 BitsPerSample/8\n-      2, 0,                // BytesPerSample: NumChannels * BitsPerSample/8\n-      16, 0,               // BitsPerSample\n-      'd', 'a', 't', 'a',  // Subchunk2ID\n-      8, 0, 0, 0,          // Subchunk2Size: NumSamples * NumChannels *\n-                           //                BitsPerSample/8\n-      0, 0,                // Sample 1: 0\n-      0xff, 0x7f,          // Sample 2: 32767 (saturated)\n-      0, 0,                // Sample 3: 0\n-      0x00, 0x80,          // Sample 4: -32768 (saturated)\n+  std::vector<uint8_t> wav_data = {\n+      'R',\n+      'I',\n+      'F',\n+      'F',  // ChunkID\n+      44,\n+      0,\n+      0,\n+      0,  // ChunkSize: 36 + SubChunk2Size\n+      'W',\n+      'A',\n+      'V',\n+      'E',  // Format\n+      'f',\n+      'm',\n+      't',\n+      ' ',  // Subchunk1ID\n+      16,\n+      0,\n+      0,\n+      0,  // Subchunk1Size\n+      1,\n+      0,  // AudioFormat: 1=PCM\n+      1,\n+      0,  // NumChannels\n+      0x44,\n+      0xac,\n+      0,\n+      0,  // SampleRate: 44100\n+      0x88,\n+      0x58,\n+      0x1,\n+      0,  // BytesPerSecond: SampleRate * NumChannels *\n+          //                 BitsPerSample/8\n+      2,\n+      0,  // BytesPerSample: NumChannels * BitsPerSample/8\n+      16,\n+      0,  // BitsPerSample\n+      'd',\n+      'a',\n+      't',\n+      'a',  // Subchunk2ID\n+      8,\n+      0,\n+      0,\n+      0,  // Subchunk2Size: NumSamples * NumChannels *\n+          //                BitsPerSample/8\n+      0,\n+      0,  // Sample 1: 0\n+      0xff,\n+      0x7f,  // Sample 2: 32767 (saturated)\n+      0,\n+      0,  // Sample 3: 0\n+      0x00,\n+      0x80,  // Sample 4: -32768 (saturated)\n   };\n-  string expected(wav_data.begin(), wav_data.end());\n+  std::string expected(wav_data.begin(), wav_data.end());\n   float audio[] = {0.0f, 1.0f, 0.0f, -1.0f};\n-  string result;\n+  std::string result;\n   TF_EXPECT_OK(EncodeAudioAsS16LEWav(audio, 44100, 1, 4, &result));\n   EXPECT_EQ(expected, result);\n }\n \n TEST(WavIO, BasicStereo) {\n-  std::vector<uint8> wav_data = {\n-      'R', 'I', 'F', 'F',  // ChunkID\n-      44, 0, 0, 0,         // ChunkSize: 36 + SubChunk2Size\n-      'W', 'A', 'V', 'E',  // Format\n-      'f', 'm', 't', ' ',  // Subchunk1ID\n-      16, 0, 0, 0,         // Subchunk1Size\n-      1, 0,                // AudioFormat: 1=PCM\n-      2, 0,                // NumChannels\n-      0x44, 0xac, 0, 0,    // SampleRate: 44100\n-      0x10, 0xb1, 0x2, 0,  // BytesPerSecond: SampleRate * NumChannels *\n-                           //                 BitsPerSample/8\n-      4, 0,                // BytesPerSample: NumChannels * BitsPerSample/8\n-      16, 0,               // BitsPerSample\n-      'd', 'a', 't', 'a',  // Subchunk2ID\n-      8, 0, 0, 0,          // Subchunk2Size: NumSamples * NumChannels *\n-                           //                BitsPerSample/8\n-      0, 0,                // Sample 1: 0\n-      0xff, 0x7f,          // Sample 2: 32767 (saturated)\n-      0, 0,                // Sample 3: 0\n-      0x00, 0x80,          // Sample 4: -32768 (saturated)\n+  std::vector<uint8_t> wav_data = {\n+      'R',\n+      'I',\n+      'F',\n+      'F',  // ChunkID\n+      44,\n+      0,\n+      0,\n+      0,  // ChunkSize: 36 + SubChunk2Size\n+      'W',\n+      'A',\n+      'V',\n+      'E',  // Format\n+      'f',\n+      'm',\n+      't',\n+      ' ',  // Subchunk1ID\n+      16,\n+      0,\n+      0,\n+      0,  // Subchunk1Size\n+      1,\n+      0,  // AudioFormat: 1=PCM\n+      2,\n+      0,  // NumChannels\n+      0x44,\n+      0xac,\n+      0,\n+      0,  // SampleRate: 44100\n+      0x10,\n+      0xb1,\n+      0x2,\n+      0,  // BytesPerSecond: SampleRate * NumChannels *\n+          //                 BitsPerSample/8\n+      4,\n+      0,  // BytesPerSample: NumChannels * BitsPerSample/8\n+      16,\n+      0,  // BitsPerSample\n+      'd',\n+      'a',\n+      't',\n+      'a',  // Subchunk2ID\n+      8,\n+      0,\n+      0,\n+      0,  // Subchunk2Size: NumSamples * NumChannels *\n+          //                BitsPerSample/8\n+      0,\n+      0,  // Sample 1: 0\n+      0xff,\n+      0x7f,  // Sample 2: 32767 (saturated)\n+      0,\n+      0,  // Sample 3: 0\n+      0x00,\n+      0x80,  // Sample 4: -32768 (saturated)\n   };\n-  string expected(wav_data.begin(), wav_data.end());\n+  std::string expected(wav_data.begin(), wav_data.end());\n   float audio[] = {0.0f, 1.0f, 0.0f, -1.0f};\n-  string result;\n+  std::string result;\n   TF_EXPECT_OK(EncodeAudioAsS16LEWav(audio, 44100, 2, 2, &result));\n   EXPECT_EQ(expected, result);\n }\n@@ -175,38 +245,83 @@ TEST(WavIO, BasicStereo) {\n // large WAV files are not common, and are unsupported by many readers.\n // See b/72655902.\n TEST(WavIO, ChunkSizeOverflow) {\n-  std::vector<uint8> wav_data = {\n-      'R', 'I', 'F', 'F',      // ChunkID\n-      60, 0, 0, 0,             // ChunkSize: 36 + SubChunk2Size\n-      'W', 'A', 'V', 'E',      // Format\n-      'f', 'm', 't', ' ',      // Subchunk1ID\n-      16, 0, 0, 0,             // Subchunk1Size\n-      1, 0,                    // AudioFormat: 1=PCM\n-      1, 0,                    // NumChannels\n-      0x44, 0xac, 0, 0,        // SampleRate: 44100\n-      0x88, 0x58, 0x1, 0,      // BytesPerSecond: SampleRate * NumChannels *\n-                               //                 BitsPerSample/8\n-      2, 0,                    // BytesPerSample: NumChannels * BitsPerSample/8\n-      16, 0,                   // BitsPerSample\n-      'd', 'a', 't', 'a',      // Subchunk2ID\n-      8, 0, 0, 0,              // Subchunk2Size: NumSamples * NumChannels *\n-                               //                BitsPerSample/8\n-      0, 0,                    // Sample 1: 0\n-      0xff, 0x7f,              // Sample 2: 32767 (saturated)\n-      0, 0,                    // Sample 3: 0\n-      0x00, 0x80,              // Sample 4: -32768 (saturated)\n-      'f', 'o', 'o', 'o',      // Subchunk2ID\n-      0xff, 0xff, 0xff, 0xf8,  // Chunk size that could cause an infinite loop.\n-      0, 0,                    // Sample 1: 0\n-      0xff, 0x7f,              // Sample 2: 32767 (saturated)\n-      0, 0,                    // Sample 3: 0\n-      0x00, 0x80,              // Sample 4: -32768 (saturated)\n+  std::vector<uint8_t> wav_data = {\n+      'R',\n+      'I',\n+      'F',\n+      'F',  // ChunkID\n+      60,\n+      0,\n+      0,\n+      0,  // ChunkSize: 36 + SubChunk2Size\n+      'W',\n+      'A',\n+      'V',\n+      'E',  // Format\n+      'f',\n+      'm',\n+      't',\n+      ' ',  // Subchunk1ID\n+      16,\n+      0,\n+      0,\n+      0,  // Subchunk1Size\n+      1,\n+      0,  // AudioFormat: 1=PCM\n+      1,\n+      0,  // NumChannels\n+      0x44,\n+      0xac,\n+      0,\n+      0,  // SampleRate: 44100\n+      0x88,\n+      0x58,\n+      0x1,\n+      0,  // BytesPerSecond: SampleRate * NumChannels *\n+          //                 BitsPerSample/8\n+      2,\n+      0,  // BytesPerSample: NumChannels * BitsPerSample/8\n+      16,\n+      0,  // BitsPerSample\n+      'd',\n+      'a',\n+      't',\n+      'a',  // Subchunk2ID\n+      8,\n+      0,\n+      0,\n+      0,  // Subchunk2Size: NumSamples * NumChannels *\n+          //                BitsPerSample/8\n+      0,\n+      0,  // Sample 1: 0\n+      0xff,\n+      0x7f,  // Sample 2: 32767 (saturated)\n+      0,\n+      0,  // Sample 3: 0\n+      0x00,\n+      0x80,  // Sample 4: -32768 (saturated)\n+      'f',\n+      'o',\n+      'o',\n+      'o',  // Subchunk2ID\n+      0xff,\n+      0xff,\n+      0xff,\n+      0xf8,  // Chunk size that could cause an infinite loop.\n+      0,\n+      0,  // Sample 1: 0\n+      0xff,\n+      0x7f,  // Sample 2: 32767 (saturated)\n+      0,\n+      0,  // Sample 3: 0\n+      0x00,\n+      0x80,  // Sample 4: -32768 (saturated)\n   };\n-  string wav_data_string(wav_data.begin(), wav_data.end());\n+  std::string wav_data_string(wav_data.begin(), wav_data.end());\n   std::vector<float> decoded_audio;\n-  uint32 decoded_sample_count;\n-  uint16 decoded_channel_count;\n-  uint32 decoded_sample_rate;\n+  uint32_t decoded_sample_count;\n+  uint16_t decoded_channel_count;\n+  uint32_t decoded_sample_rate;\n   absl::Status decode_status = DecodeLin16WaveAsFloatVector(\n       wav_data_string, &decoded_audio, &decoded_sample_count,\n       &decoded_channel_count, &decoded_sample_rate);\n@@ -244,10 +359,10 @@ TEST(WavIO, IncrementOffset) {\n }\n \n TEST(WavIO, ExpectText) {\n-  std::vector<uint8> test_data = {\n+  std::vector<uint8_t> test_data = {\n       'E', 'x', 'p', 'e', 'c', 't', 'e', 'd',\n   };\n-  string test_string(test_data.begin(), test_data.end());\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n   TF_EXPECT_OK(ExpectText(test_string, \"Expected\", &offset));\n@@ -267,13 +382,13 @@ TEST(WavIO, ExpectText) {\n }\n \n TEST(WavIO, ReadString) {\n-  std::vector<uint8> test_data = {\n+  std::vector<uint8_t> test_data = {\n       'E', 'x', 'p', 'e', 'c', 't', 'e', 'd',\n   };\n-  string test_string(test_data.begin(), test_data.end());\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n-  string read_value;\n+  std::string read_value;\n   TF_EXPECT_OK(ReadString(test_string, 2, &read_value, &offset));\n   EXPECT_EQ(\"Ex\", read_value);\n   EXPECT_EQ(2, offset);\n@@ -287,8 +402,8 @@ TEST(WavIO, ReadString) {\n }\n \n TEST(WavIO, ReadValueInt8) {\n-  std::vector<uint8> test_data = {0x00, 0x05, 0xff, 0x80};\n-  string test_string(test_data.begin(), test_data.end());\n+  std::vector<uint8_t> test_data = {0x00, 0x05, 0xff, 0x80};\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n   int8_t read_value;\n@@ -313,11 +428,11 @@ TEST(WavIO, ReadValueInt8) {\n }\n \n TEST(WavIO, ReadValueUInt8) {\n-  std::vector<uint8> test_data = {0x00, 0x05, 0xff, 0x80};\n-  string test_string(test_data.begin(), test_data.end());\n+  std::vector<uint8_t> test_data = {0x00, 0x05, 0xff, 0x80};\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n-  uint8 read_value;\n+  uint8_t read_value;\n   TF_EXPECT_OK(ReadValue(test_string, &read_value, &offset));\n   EXPECT_EQ(0, read_value);\n   EXPECT_EQ(1, offset);\n@@ -339,14 +454,14 @@ TEST(WavIO, ReadValueUInt8) {\n }\n \n TEST(WavIO, ReadValueInt16) {\n-  std::vector<uint8> test_data = {\n+  std::vector<uint8_t> test_data = {\n       0x00, 0x00,  // 0\n       0xff, 0x00,  // 255\n       0x00, 0x01,  // 256\n       0xff, 0xff,  // -1\n       0x00, 0x80,  // -32768\n   };\n-  string test_string(test_data.begin(), test_data.end());\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n   int16_t read_value;\n@@ -375,17 +490,17 @@ TEST(WavIO, ReadValueInt16) {\n }\n \n TEST(WavIO, ReadValueUInt16) {\n-  std::vector<uint8> test_data = {\n+  std::vector<uint8_t> test_data = {\n       0x00, 0x00,  // 0\n       0xff, 0x00,  // 255\n       0x00, 0x01,  // 256\n       0xff, 0xff,  // 65535\n       0x00, 0x80,  // 32768\n   };\n-  string test_string(test_data.begin(), test_data.end());\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n-  uint16 read_value;\n+  uint16_t read_value;\n   TF_EXPECT_OK(ReadValue(test_string, &read_value, &offset));\n   EXPECT_EQ(0, read_value);\n   EXPECT_EQ(2, offset);\n@@ -411,14 +526,14 @@ TEST(WavIO, ReadValueUInt16) {\n }\n \n TEST(WavIO, ReadValueInt32) {\n-  std::vector<uint8> test_data = {\n+  std::vector<uint8_t> test_data = {\n       0x00, 0x00, 0x00, 0x00,  // 0\n       0xff, 0x00, 0x00, 0x00,  // 255\n       0x00, 0xff, 0x00, 0x00,  // 65280\n       0x00, 0x00, 0xff, 0x00,  // 16,711,680\n       0xff, 0xff, 0xff, 0xff,  // -1\n   };\n-  string test_string(test_data.begin(), test_data.end());\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n   int32_t read_value;\n@@ -447,17 +562,17 @@ TEST(WavIO, ReadValueInt32) {\n }\n \n TEST(WavIO, ReadValueUInt32) {\n-  std::vector<uint8> test_data = {\n+  std::vector<uint8_t> test_data = {\n       0x00, 0x00, 0x00, 0x00,  // 0\n       0xff, 0x00, 0x00, 0x00,  // 255\n       0x00, 0xff, 0x00, 0x00,  // 65280\n       0x00, 0x00, 0xff, 0x00,  // 16,711,680\n       0xff, 0xff, 0xff, 0xff,  // 4,294,967,295\n   };\n-  string test_string(test_data.begin(), test_data.end());\n+  std::string test_string(test_data.begin(), test_data.end());\n \n   int offset = 0;\n-  uint32 read_value;\n+  uint32_t read_value;\n   TF_EXPECT_OK(ReadValue(test_string, &read_value, &offset));\n   EXPECT_EQ(0, read_value);\n   EXPECT_EQ(4, offset);"
        }
    ],
    "stats": {
        "total": 333,
        "additions": 224,
        "deletions": 109
    }
}