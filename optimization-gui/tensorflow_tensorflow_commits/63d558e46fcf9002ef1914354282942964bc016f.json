{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Mesh + AxesRef] add to/from proto functions + equality op to XLA definitions of Mesh and AxesRef.\n\nPiperOrigin-RevId: 825107889",
    "sha": "63d558e46fcf9002ef1914354282942964bc016f",
    "files": [
        {
            "sha": "7fa0eb4beec6331d66784a27c71ad02684b75fc7",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 22,
            "deletions": 1,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/63d558e46fcf9002ef1914354282942964bc016f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/63d558e46fcf9002ef1914354282942964bc016f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=63d558e46fcf9002ef1914354282942964bc016f",
            "patch": "@@ -183,7 +183,12 @@ cc_library(\n     hdrs = [\"mesh_and_axis.h\"],\n     deps = [\n         \":tile_assignment\",\n-        \"@com_google_absl//absl/strings\",\n+        \"//xla:array\",\n+        \"//xla:xla_data_proto_cc\",\n+        \"@com_google_absl//absl/algorithm:container\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n     ],\n )\n \n@@ -416,6 +421,22 @@ xla_cc_test(\n     ],\n )\n \n+xla_cc_test(\n+    name = \"mesh_and_axis_test\",\n+    srcs = [\"mesh_and_axis_test.cc\"],\n+    deps = [\n+        \":mesh_and_axis\",\n+        \":tile_assignment\",\n+        \"//xla:array\",\n+        \"//xla:array2d\",\n+        \"//xla/tsl/util/proto:proto_matchers\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:status_matchers\",\n+        \"@local_tsl//tsl/platform:test\",\n+    ],\n+)\n+\n xla_cc_test(\n     name = \"hlo_casting_utils_test\",\n     srcs = [\"hlo_casting_utils_test.cc\"],"
        },
        {
            "sha": "8f5fd76557819595fe74f5d1e3ffe2075f820ee0",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/63d558e46fcf9002ef1914354282942964bc016f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/63d558e46fcf9002ef1914354282942964bc016f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=63d558e46fcf9002ef1914354282942964bc016f",
            "patch": "@@ -17,11 +17,19 @@ limitations under the License.\n #define XLA_HLO_IR_MESH_AND_AXIS_H_\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n #include <string>\n+#include <utility>\n #include <vector>\n \n+#include \"absl/algorithm/container.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n+#include \"xla/array.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n+#include \"xla/xla_data.pb.h\"\n \n namespace xla {\n \n@@ -36,6 +44,76 @@ namespace xla {\n // {\"data\", \"model\"} represents a 2 * 3 mesh of 6 devices, with \"data\" axis of\n // size 2 and \"model\" axis of size 3.\n class Mesh {\n+ public:\n+  explicit Mesh(TileAssignment device_assignment,\n+                absl::Span<const std::string> axes_names)\n+      : device_assignment_(std::move(device_assignment)),\n+        axes_names_(axes_names.begin(), axes_names.end()) {\n+    CHECK_EQ(device_assignment_.dimensions().size(), axes_names_.size())\n+        << \"Number of axes names must match number of dimensions in the \"\n+           \"device assignment.\";\n+  }\n+\n+  bool operator==(const Mesh& other) const {\n+    return device_assignment_ == other.device_assignment_ &&\n+           axes_names_ == other.axes_names_;\n+  }\n+\n+  bool operator!=(const Mesh& other) const { return !(*this == other); }\n+\n+  MeshProto ToProto() const {\n+    MeshProto proto;\n+    std::vector<MeshProto::MeshAxis> axes;\n+    axes.reserve(axes_names_.size());\n+\n+    for (auto [name, size] :\n+         llvm::zip_equal(axes_names_, device_assignment_.dimensions())) {\n+      MeshProto::MeshAxis axis;\n+      axis.set_name(name);\n+      axis.set_size(size);\n+      axes.push_back(std::move(axis));\n+    }\n+    proto.mutable_axes()->Assign(axes.begin(), axes.end());\n+\n+    std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n+    // Only add device ids for non-iota cases.\n+    if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n+      proto.mutable_device_ids()->Assign(device_assignment_.array().begin(),\n+                                         device_assignment_.array().end());\n+    }\n+    return proto;\n+  }\n+\n+  static Mesh FromProto(const MeshProto& proto) {\n+    // TODO(b/454008727): Add validators for Mesh and AxisRef FromProto methods.\n+    std::vector<int64_t> mesh_axis_sizes;\n+    std::vector<std::string> mesh_axis_names;\n+    mesh_axis_sizes.reserve(proto.axes_size());\n+    mesh_axis_names.reserve(proto.axes_size());\n+    for (const auto& axis : proto.axes()) {\n+      mesh_axis_sizes.push_back(axis.size());\n+      mesh_axis_names.push_back(axis.name());\n+    }\n+\n+    // If device ids are not specified, create a mesh with iota tiling.\n+    if (proto.device_ids_size() == 0) {\n+      TileAssignment device_assignment =\n+          TileAssignment(IotaTileAssignment::Create(mesh_axis_sizes));\n+      return Mesh(device_assignment, mesh_axis_names);\n+    }\n+    // Otherwise, create a mesh with the specific device id ordering.\n+    std::vector<int64_t> device_ids(proto.device_ids().begin(),\n+                                    proto.device_ids().end());\n+    Array<int64_t> device_ids_array(mesh_axis_sizes);\n+    absl::c_copy(device_ids, device_ids_array.begin());\n+\n+    TileAssignment tile_assignment =\n+        TileAssignment(std::make_shared<Array<int64_t>>(device_ids_array));\n+    return Mesh(tile_assignment, absl::MakeSpan(mesh_axis_names));\n+  }\n+\n+  TileAssignment device_assignment() const { return device_assignment_; }\n+\n  private:\n   // Dimensions of the `device_assignment_` array correspond to the axes of the\n   // mesh.\n@@ -59,6 +137,56 @@ class AxisRef {\n   // `mesh.axes_names_`.\n   int64_t mesh_axis_index_;\n   std::optional<SubAxis> sub_axis_info_;\n+\n+ public:\n+  explicit AxisRef(int64_t mesh_axis_index)\n+      : mesh_axis_index_(mesh_axis_index) {}\n+\n+  explicit AxisRef(int64_t mesh_axis_index, SubAxis sub_axis_info)\n+      : mesh_axis_index_(mesh_axis_index), sub_axis_info_(sub_axis_info) {}\n+\n+  explicit AxisRef(int64_t mesh_axis_index, int64_t sub_axis_pre_size,\n+                   int64_t sub_axis_size)\n+      : mesh_axis_index_(mesh_axis_index),\n+        sub_axis_info_({sub_axis_pre_size, sub_axis_size}) {}\n+\n+  bool operator==(const xla::AxisRef& other) const {\n+    if (mesh_axis_index_ != other.mesh_axis_index_) {\n+      return false;\n+    }\n+    if (sub_axis_info_.has_value() != other.sub_axis_info_.has_value()) {\n+      return false;\n+    }\n+    if (sub_axis_info_.has_value()) {\n+      return sub_axis_info_->pre_size == other.sub_axis_info_->pre_size &&\n+             sub_axis_info_->size == other.sub_axis_info_->size;\n+    }\n+    return true;\n+  }\n+\n+  bool operator!=(const xla::AxisRef& other) const { return !(*this == other); }\n+\n+  AxisRefProto ToProto() const {\n+    AxisRefProto proto;\n+    proto.set_mesh_axis_index(mesh_axis_index_);\n+    if (sub_axis_info_.has_value()) {\n+      proto.mutable_sub_axis_info()->set_pre_size(sub_axis_info_->pre_size);\n+      proto.mutable_sub_axis_info()->set_size(sub_axis_info_->size);\n+    }\n+    return proto;\n+  }\n+\n+  static AxisRef FromProto(const AxisRefProto& proto) {\n+    AxisRef axis_ref(proto.mesh_axis_index());\n+    if (proto.has_sub_axis_info()) {\n+      axis_ref.sub_axis_info_ = {proto.sub_axis_info().pre_size(),\n+                                 proto.sub_axis_info().size()};\n+    }\n+    return axis_ref;\n+  }\n+\n+  int64_t mesh_axis_index() const { return mesh_axis_index_; }\n+  std::optional<SubAxis> sub_axis_info() const { return sub_axis_info_; }\n };\n \n }  // namespace xla"
        },
        {
            "sha": "57f8d26b941e20cbfd79c9705d7e0c5c1dd526cc",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis_test.cc",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/63d558e46fcf9002ef1914354282942964bc016f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/63d558e46fcf9002ef1914354282942964bc016f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc?ref=63d558e46fcf9002ef1914354282942964bc016f",
            "patch": "@@ -0,0 +1,179 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/types/span.h\"\n+#include \"xla/array.h\"\n+#include \"xla/array2d.h\"\n+#include \"xla/hlo/ir/tile_assignment.h\"\n+#include \"xla/tsl/util/proto/proto_matchers.h\"\n+\n+using ::tsl::proto_testing::EqualsProto;\n+\n+namespace xla {\n+\n+TEST(MeshAndAxisTest, AxisRefEquality) {\n+  EXPECT_EQ(AxisRef(1), AxisRef(1));\n+  EXPECT_EQ(AxisRef(3, {1, 2}), AxisRef(3, {1, 2}));\n+  EXPECT_NE(AxisRef(2), AxisRef(4));\n+  EXPECT_NE(AxisRef(0), AxisRef(0, {1, 2}));\n+  EXPECT_NE(AxisRef(2, {1, 2}), AxisRef(3, {1, 2}));\n+  EXPECT_NE(AxisRef(2, {1, 2}), AxisRef(2, {2, 2}));\n+  EXPECT_NE(AxisRef(2, {1, 2}), AxisRef(2, {1, 4}));\n+}\n+\n+TEST(MeshAndAxisTest, MeshEquality) {\n+  std::vector<std::string> axes_abc = {\"a\", \"b\", \"c\"};\n+  std::vector<std::string> axes_abcd = {\"a\", \"b\", \"c\", \"d\"};\n+  std::vector<std::string> axes_efgh = {\"e\", \"f\", \"g\", \"h\"};\n+  EXPECT_EQ(Mesh(TileAssignment({{1, 2, 3}}), axes_abc),\n+            Mesh(TileAssignment({{1, 2, 3}}), axes_abc));\n+  EXPECT_NE(Mesh(TileAssignment({{1, 2, 3, 4}}), axes_abcd),\n+            Mesh(TileAssignment({{1, 2, 3, 4}}), axes_efgh));\n+  EXPECT_NE(Mesh(TileAssignment({{1, 2, 3}}), axes_abc),\n+            Mesh(TileAssignment({{1, 2, 3, 4}}), axes_abcd));\n+}\n+\n+TEST(MeshAndAxisTest, AxesToProto) {\n+  AxisRefProto expected;\n+  expected.set_mesh_axis_index(123);\n+  EXPECT_THAT(AxisRef(123).ToProto(), EqualsProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, AxesToProtoWithSubAxis) {\n+  AxisRefProto expected;\n+  expected.set_mesh_axis_index(2);\n+  expected.mutable_sub_axis_info()->set_pre_size(2);\n+  expected.mutable_sub_axis_info()->set_size(8);\n+  EXPECT_THAT(AxisRef(2, {2, 8}).ToProto(), EqualsProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, AxesFromProto) {\n+  AxisRefProto expected;\n+  expected.set_mesh_axis_index(1);\n+  EXPECT_THAT(AxisRef(1), AxisRef::FromProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, AxesFromProtoWithSubAxis) {\n+  AxisRefProto expected;\n+  expected.set_mesh_axis_index(10);\n+  expected.mutable_sub_axis_info()->set_pre_size(4);\n+  expected.mutable_sub_axis_info()->set_size(32);\n+  EXPECT_THAT(AxisRef(10, {4, 32}), AxisRef::FromProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, MeshToAndFromProtoIotaTiling) {\n+  MeshProto proto;\n+  proto.add_axes()->set_name(\"a\");\n+  proto.add_axes()->set_name(\"b\");\n+  proto.add_axes()->set_name(\"c\");\n+  proto.mutable_axes(0)->set_size(2);\n+  proto.mutable_axes(1)->set_size(3);\n+  proto.mutable_axes(2)->set_size(6);\n+\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3, 6});\n+  std::vector<std::string> axes_abc = {\"a\", \"b\", \"c\"};\n+  Mesh mesh(TileAssignment(iota), axes_abc);\n+\n+  EXPECT_THAT(mesh.ToProto(), EqualsProto(proto));\n+  EXPECT_EQ(mesh, Mesh::FromProto(proto));\n+}\n+\n+TEST(MeshAndAxisTest, MeshToProtoIotaTilingWithReshapeDims) {\n+  MeshProto expected;\n+  expected.add_axes()->set_name(\"axis1\");\n+  expected.add_axes()->set_name(\"axis2\");\n+  expected.add_axes()->set_name(\"axis3\");\n+  expected.mutable_axes(0)->set_size(4);\n+  expected.mutable_axes(1)->set_size(4);\n+  expected.mutable_axes(2)->set_size(1);\n+  // When dims=[4,4,1] reshape_dims=[4,2,2], transpose_perm=[1,0,2] (swap dim 0\n+  // and dim 1) corresponds to [4,4,1]<=[4,2,2]T(1,0,2) which in full array V1\n+  // format is [0,1,4,5,8,9,12,13,2,3,6,7,10,11,14,15].\n+  std::vector<int> expected_device_ids = {0, 1, 4, 5, 8,  9,  12, 13,\n+                                          2, 3, 6, 7, 10, 11, 14, 15};\n+  for (int i = 0; i < expected_device_ids.size(); ++i) {\n+    expected.add_device_ids(expected_device_ids[i]);\n+  }\n+\n+  std::vector<std::string> axes_names = {\"axis1\", \"axis2\", \"axis3\"};\n+  EXPECT_THAT(Mesh(TileAssignment(IotaTileAssignment::Create(\n+                       /*dims=*/{4, 4, 1}, /*reshape_dims=*/{4, 2, 2},\n+                       /*transpose_perm=*/{1, 0, 2})),\n+                   axes_names)\n+                  .ToProto(),\n+              EqualsProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, MeshToProtoNonIotaTiling) {\n+  MeshProto expected;\n+  expected.add_axes()->set_name(\"x\");\n+  expected.add_axes()->set_name(\"y\");\n+  expected.mutable_axes(0)->set_size(4);\n+  expected.mutable_axes(1)->set_size(2);\n+  std::vector<int> random_expected_device_ids = {6, 3, 0, 1, 5, 2, 7, 4};\n+  for (int i = 0; i < random_expected_device_ids.size(); ++i) {\n+    expected.add_device_ids(random_expected_device_ids[i]);\n+  }\n+\n+  Array2D<int64_t> array({{6, 3}, {0, 1}, {5, 2}, {7, 4}});\n+  std::vector<std::string> axes_xy = {\"x\", \"y\"};\n+  EXPECT_THAT(\n+      Mesh(TileAssignment(std::make_shared<Array<int64_t>>(array)), axes_xy)\n+          .ToProto(),\n+      EqualsProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, MeshFromProtoNonIotaTiling) {\n+  MeshProto expected;\n+  expected.add_axes()->set_name(\"x\");\n+  expected.add_axes()->set_name(\"y\");\n+  expected.mutable_axes(0)->set_size(4);\n+  expected.mutable_axes(1)->set_size(2);\n+  std::vector<int> random_expected_device_ids = {0, 1, 6, 3, 7, 4, 5, 2};\n+  for (int i = 0; i < random_expected_device_ids.size(); ++i) {\n+    expected.add_device_ids(random_expected_device_ids[i]);\n+  }\n+\n+  Array2D<int64_t> array({{0, 1}, {6, 3}, {7, 4}, {5, 2}});\n+  std::vector<std::string> axes_xy = {\"x\", \"y\"};\n+  EXPECT_EQ(\n+      Mesh(TileAssignment(std::make_shared<Array<int64_t>>(array)), axes_xy),\n+      Mesh::FromProto(expected));\n+}\n+\n+TEST(MeshAndAxisTest, MeshRoundtripProto) {\n+  // Iota tiling.\n+  std::vector<std::string> axes_xy = {\"data\", \"model\"};\n+  Mesh mesh_iota(TileAssignment(IotaTileAssignment::Create({5, 3})), axes_xy);\n+  EXPECT_THAT(mesh_iota, Mesh::FromProto(mesh_iota.ToProto()));\n+\n+  // Non-iota tiling.\n+  Array2D<int64_t> array(\n+      {{14, 7, 6}, {12, 0, 8}, {11, 10, 5}, {11, 9, 3}, {2, 13, 4}});\n+  Mesh mesh_non_iota(TileAssignment(std::make_shared<Array<int64_t>>(array)),\n+                     axes_xy);\n+  EXPECT_THAT(mesh_non_iota, Mesh::FromProto(mesh_non_iota.ToProto()));\n+}\n+\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 330,
        "additions": 329,
        "deletions": 1
    }
}