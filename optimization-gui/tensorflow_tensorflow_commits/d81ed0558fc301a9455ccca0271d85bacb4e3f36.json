{
    "author": "congliuthu",
    "message": "[XLA] Add DeadDynamicUpdateSliceElimination pass.\n\nPiperOrigin-RevId: 840491728",
    "sha": "d81ed0558fc301a9455ccca0271d85bacb4e3f36",
    "files": [
        {
            "sha": "6805b7140e0cc2ec1feb20fad92bf3380e7856ca",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/BUILD",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD?ref=d81ed0558fc301a9455ccca0271d85bacb4e3f36",
            "patch": "@@ -1861,6 +1861,41 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"dead_dynamic_update_slice_elimination\",\n+    srcs = [\"dead_dynamic_update_slice_elimination.cc\"],\n+    hdrs = [\"dead_dynamic_update_slice_elimination.h\"],\n+    deps = [\n+        \"//xla:shape_util\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/pass:hlo_pass\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/algorithm:container\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"dead_dynamic_update_slice_elimination_test\",\n+    srcs = [\"dead_dynamic_update_slice_elimination_test.cc\"],\n+    deps = [\n+        \":dead_dynamic_update_slice_elimination\",\n+        \":hlo_dce\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/testlib:pattern_matcher_gmock\",\n+        \"//xla/service:pattern_matcher\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n xla_cc_test(\n     name = \"call_parameter_cleanup_test\",\n     srcs = [\"call_parameter_cleanup_test.cc\"],"
        },
        {
            "sha": "ef7058daa766f316bab00bbad635ed264e23cd0d",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/dead_dynamic_update_slice_elimination.cc",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination.cc?ref=d81ed0558fc301a9455ccca0271d85bacb4e3f36",
            "patch": "@@ -0,0 +1,176 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/transforms/simplifiers/dead_dynamic_update_slice_elimination.h\"\n+\n+#include <cstdint>\n+#include <optional>\n+#include <vector>\n+\n+#include \"absl/algorithm/container.h\"\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/hlo/ir/hlo_casting_utils.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_instructions.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/primitive_util.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+std::optional<int64_t> GetConstantAsInt64(const HloInstruction* inst) {\n+  if (!inst->IsConstant() || !ShapeUtil::IsScalar(inst->shape())) {\n+    return std::nullopt;\n+  }\n+  return primitive_util::PrimitiveTypeSwitch<std::optional<int64_t>>(\n+      [&](auto primitive_type_constant) -> std::optional<int64_t> {\n+        if constexpr (primitive_util::IsIntegralType(primitive_type_constant)) {\n+          using NativeT = primitive_util::NativeTypeOf<primitive_type_constant>;\n+          return static_cast<int64_t>(\n+              inst->literal().GetFirstElement<NativeT>());\n+        }\n+        return std::nullopt;\n+      },\n+      inst->shape().element_type());\n+}\n+\n+std::optional<std::vector<int64_t>> GetStartIndices(const HloInstruction* dus) {\n+  absl::Span<HloInstruction* const> start_indices_operands =\n+      absl::MakeSpan(dus->operands())\n+          .subspan(xla::Cast<HloDynamicUpdateSliceInstruction>(dus)\n+                       ->first_index_operand_number());\n+  std::vector<int64_t> start_indices;\n+  for (HloInstruction* operand : start_indices_operands) {\n+    std::optional<int64_t> start_index = GetConstantAsInt64(operand);\n+    if (!start_index.has_value()) {\n+      return std::nullopt;\n+    }\n+    start_indices.push_back(*start_index);\n+  }\n+  return start_indices;\n+}\n+\n+// Checks if the ranges [start1, end1) and [start2, end2) overlap.\n+//\n+// Example:\n+// RangesOverlap(0, 10, 5, 15) -> true\n+// RangesOverlap(0, 10, 10, 20) -> false\n+// RangesOverlap(0, 10, 15, 20) -> false\n+bool RangesOverlap(int64_t start1, int64_t end1, int64_t start2, int64_t end2) {\n+  return start1 < end2 && start2 < end1;\n+}\n+\n+// If true, the updated elements of the dynamic-update-slice is not accessed\n+// by the slice user.\n+bool IsDusUpdateUnused(const std::vector<int64_t>& dus_starts,\n+                       const Shape& update_shape,\n+                       const HloInstruction* slice_user) {\n+  if (slice_user->opcode() != HloOpcode::kSlice) {\n+    return false;\n+  }\n+  // Get Slice ranges\n+  const std::vector<int64_t>& slice_starts = slice_user->slice_starts();\n+  const std::vector<int64_t>& slice_limits = slice_user->slice_limits();\n+\n+  // The slice accesses the updated part IFF there is an overlap in *ALL*\n+  // dimensions. If there is no overlap in any dimension, the slice is safe,\n+  // i.e., it doesn't access the updated elements.\n+  for (int dim = 0; dim < update_shape.dimensions().size(); ++dim) {\n+    int64_t dus_start = dus_starts[dim];\n+    int64_t dus_limit = dus_start + update_shape.dimensions(dim);\n+    int64_t slice_start = slice_starts[dim];\n+    int64_t slice_limit = slice_limits[dim];\n+    if (RangesOverlap(dus_start, dus_limit, slice_start, slice_limit)) {\n+      continue;\n+    }\n+    // Disjoint in this dimension, so slice does not overlap with update.\n+    return true;\n+  }\n+  // Overlap in all dimensions, so slice reads updated values.\n+  return false;\n+}\n+\n+// Helper function to process a single DynamicUpdateSlice instruction.\n+// Returns true if the module was changed.\n+absl::StatusOr<bool> ProcessDynamicUpdateSlice(HloInstruction* dus,\n+                                               HloComputation* comp) {\n+  const std::optional<std::vector<int64_t>> dus_starts = GetStartIndices(dus);\n+  if (!dus_starts.has_value()) {\n+    // Not a constant start index, cannot simplify.\n+    return false;\n+  }\n+  const std::vector<int64_t>& dus_starts_vec = *dus_starts;\n+  HloInstruction* update_operand = dus->mutable_operand(1);\n+  if (dus_starts_vec.size() != update_operand->shape().dimensions().size()) {\n+    // DUS start indices size does not match update operand shape dimensions\n+    // size.\n+    VLOG(1) << \"DUS start indices size does not match update operand shape \"\n+               \"dimensions size: \"\n+            << dus->ToString();\n+    return false;\n+  }\n+\n+  bool is_dus_update_unused =\n+      dus->user_count() > 0 &&\n+      absl::c_all_of(dus->users(), [&](HloInstruction* user) {\n+        return IsDusUpdateUnused(dus_starts_vec, update_operand->shape(), user);\n+      });\n+  VLOG(2) << \"  is_dus_update_unused: \" << is_dus_update_unused;\n+  if (is_dus_update_unused) {\n+    TF_RETURN_IF_ERROR(dus->ReplaceAllUsesWith(dus->mutable_operand(0)));\n+    TF_RETURN_IF_ERROR(comp->RemoveInstruction(dus));\n+    return true;  // Changed\n+  }\n+  return false;  // Not changed\n+}\n+\n+}  // namespace\n+\n+absl::StatusOr<bool> DeadDynamicUpdateSliceElimination::RunImpl(\n+    HloModule* module,\n+    const absl::flat_hash_set<absl::string_view>& execution_threads) {\n+  bool changed = false;\n+  auto computations_range = module->computations(execution_threads);\n+  std::vector<HloComputation*> computations(computations_range.begin(),\n+                                            computations_range.end());\n+  for (HloComputation* computation : computations) {\n+    std::vector<HloInstruction*> post_order_instructions =\n+        computation->MakeInstructionPostOrder();\n+    for (auto it = post_order_instructions.rbegin();\n+         it != post_order_instructions.rend(); ++it) {\n+      HloInstruction* instruction = *it;\n+      if (instruction->opcode() != HloOpcode::kDynamicUpdateSlice) {\n+        continue;\n+      }\n+      VLOG(2) << \"Processing DUS: \" << instruction->ToString();\n+      TF_ASSIGN_OR_RETURN(bool dus_changed,\n+                          ProcessDynamicUpdateSlice(instruction, computation));\n+      if (dus_changed) {\n+        changed = true;\n+      }\n+    }\n+  }\n+  return changed;\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "5f17372119f5ea36bbb2bfa2762902f3151e9d6b",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/dead_dynamic_update_slice_elimination.h",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination.h?ref=d81ed0558fc301a9455ccca0271d85bacb4e3f36",
            "patch": "@@ -0,0 +1,52 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_HLO_TRANSFORMS_SIMPLIFIERS_DEAD_DYNAMIC_UPDATE_SLICE_ELIMINATION_H_\n+#define XLA_HLO_TRANSFORMS_SIMPLIFIERS_DEAD_DYNAMIC_UPDATE_SLICE_ELIMINATION_H_\n+\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/pass/hlo_pass_interface.h\"\n+\n+namespace xla {\n+\n+// HLO pass that removes dynamic-update-slice (DUS) instructions if the region\n+// they modify is never accessed by any downstream operations.\n+//\n+// This optimization applies if all users of a DUS are slice instructions, its\n+// indices are constant, and none of its slice users read from the region\n+// updated by the DUS. If these conditions are met, the pass replaces all uses\n+// of the DUS with its input operand and removes the DUS instruction. The\n+// optimization is applied from root to top, so that if any DUS is removed that\n+// makes certain upstream DUSs removable, those will also be removed in the same\n+// pass.\n+class DeadDynamicUpdateSliceElimination : public HloModulePass {\n+ public:\n+  DeadDynamicUpdateSliceElimination() = default;\n+  ~DeadDynamicUpdateSliceElimination() override = default;\n+  absl::string_view name() const override { return \"dead-dus-elimination\"; }\n+\n+  // Run the pass on the given module. Returns whether the module was changed\n+  // (instructions were removed).\n+  absl::StatusOr<bool> RunImpl(\n+      HloModule* module,\n+      const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_HLO_TRANSFORMS_SIMPLIFIERS_DEAD_DYNAMIC_UPDATE_SLICE_ELIMINATION_H_"
        },
        {
            "sha": "9a96ddff60554ab163116339795ce2a27cdc1fc1",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/dead_dynamic_update_slice_elimination_test.cc",
            "status": "added",
            "additions": 140,
            "deletions": 0,
            "changes": 140,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d81ed0558fc301a9455ccca0271d85bacb4e3f36/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fdead_dynamic_update_slice_elimination_test.cc?ref=d81ed0558fc301a9455ccca0271d85bacb4e3f36",
            "patch": "@@ -0,0 +1,140 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/transforms/simplifiers/dead_dynamic_update_slice_elimination.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/testlib/pattern_matcher_gmock.h\"\n+#include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n+#include \"xla/service/pattern_matcher.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+namespace m = ::xla::match;\n+\n+class DeadDynamicUpdateSliceEliminationTest\n+    : public HloHardwareIndependentTestBase {};\n+\n+TEST_F(DeadDynamicUpdateSliceEliminationTest, NoDeadDUS) {\n+  const absl::string_view kHlo = R\"(\n+HloModule module\n+\n+ENTRY main {\n+  %constant.0 = bf16[] constant(0)\n+  %idx.1806 = s32[] constant(1806)\n+  %idx.0 = s32[] constant(0)\n+  %param.0 = bf16[2408,16] parameter(0)\n+  %update_block = bf16[301,16] broadcast(%constant.0), dimensions={}\n+  %dus = bf16[2408,16] dynamic-update-slice(%param.0, %update_block, %idx.1806, %idx.0)\n+  ROOT %slice = bf16[602,16] slice(%dus), slice={[1505:2107], [0:16]}\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(kHlo));\n+  DeadDynamicUpdateSliceElimination dds;\n+  EXPECT_FALSE(dds.Run(module.get()).value());\n+}\n+\n+TEST_F(DeadDynamicUpdateSliceEliminationTest, MultiUsersNoDeadDUS) {\n+  const absl::string_view kHlo = R\"(\n+HloModule module\n+\n+ENTRY main {\n+  %constant.0 = bf16[] constant(0)\n+  %idx.1806 = s32[] constant(1806)\n+  %idx.0 = s32[] constant(0)\n+  %param.0 = bf16[2408,16] parameter(0)\n+  %update_block = bf16[301,16] broadcast(%constant.0), dimensions={}\n+  %dus = bf16[2408,16] dynamic-update-slice(%param.0, %update_block, %idx.1806, %idx.0)\n+  %slice.0 = bf16[301,16] slice(%dus), slice={[1505:1806], [0:16]}\n+  %slice.1 = bf16[301,16] slice(%dus), slice={[1806:2107], [0:16]}\n+  ROOT %tuple = (bf16[301,16], bf16[301,16]) tuple(%slice.0, %slice.1)\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(kHlo));\n+  DeadDynamicUpdateSliceElimination dds;\n+  EXPECT_FALSE(dds.Run(module.get()).value());\n+}\n+\n+TEST_F(DeadDynamicUpdateSliceEliminationTest, RemoveDeadDUS) {\n+  const absl::string_view kHlo = R\"(\n+HloModule module\n+\n+ENTRY main {\n+  %constant.0 = bf16[] constant(0)\n+  %idx.1806 = s32[] constant(1806)\n+  %idx.0 = s32[] constant(0)\n+  %param.0 = bf16[2408,16] parameter(0)\n+  %update_block = bf16[301,16] broadcast(%constant.0), dimensions={}\n+  %dus = bf16[2408,16] dynamic-update-slice(%param.0, %update_block, %idx.1806, %idx.0)\n+  ROOT %slice = bf16[301,16] slice(%dus), slice={[1505:1806], [0:16]}\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(kHlo));\n+  DeadDynamicUpdateSliceElimination dds;\n+  EXPECT_TRUE(dds.Run(module.get()).value());\n+  HloDCE dce;\n+  EXPECT_TRUE(dce.Run(module.get()).value());\n+  HloInstruction* root = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(root, GmockMatch(m::Slice(m::Parameter(0))));\n+}\n+\n+TEST_F(DeadDynamicUpdateSliceEliminationTest, RemoveDeadDUSChain) {\n+  const absl::string_view kHlo = R\"(\n+HloModule module\n+\n+ENTRY main {\n+  %param.0 = bf16[256,2408,1,16,256] parameter(0)\n+  %constant.bf16.0 = bf16[] constant(0)\n+  %broadcast.12717 = bf16[256,301,1,16,256] broadcast(%constant.bf16.0), dimensions={}\n+  %constant.6347 = s32[] constant(0)\n+  %constant.6386 = s32[] constant(2107)\n+  %constant.6387 = s32[] constant(1806)\n+  %constant.6388 = s32[] constant(1505)\n+  %constant.6389 = s32[] constant(1204)\n+  %constant.6390 = s32[] constant(903)\n+  %constant.6391 = s32[] constant(602)\n+  %constant.6392 = s32[] constant(301)\n+  %dynamic-update-slice.643 = bf16[256,2408,1,16,256] dynamic-update-slice(%param.0, %broadcast.12717, %constant.6347, %constant.6386, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.214 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.643), slice={[0:256], [1806:2107], [0:1], [0:16], [0:256]}\n+  %dynamic-update-slice.644 = bf16[256,2408,1,16,256] dynamic-update-slice(%dynamic-update-slice.643, %broadcast.12717, %constant.6347, %constant.6387, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.215 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.644), slice={[0:256], [1505:1806], [0:1], [0:16], [0:256]}\n+  %dynamic-update-slice.645 = bf16[256,2408,1,16,256] dynamic-update-slice(%dynamic-update-slice.644, %broadcast.12717, %constant.6347, %constant.6388, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.216 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.645), slice={[0:256], [1204:1505], [0:1], [0:16], [0:256]}\n+  %dynamic-update-slice.646 = bf16[256,2408,1,16,256] dynamic-update-slice(%dynamic-update-slice.645, %broadcast.12717, %constant.6347, %constant.6389, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.217 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.646), slice={[0:256], [903:1204], [0:1], [0:16], [0:256]}\n+  %dynamic-update-slice.647 = bf16[256,2408,1,16,256] dynamic-update-slice(%dynamic-update-slice.646, %broadcast.12717, %constant.6347, %constant.6390, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.218 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.647), slice={[0:256], [602:903], [0:1], [0:16], [0:256]}\n+  %dynamic-update-slice.648 = bf16[256,2408,1,16,256] dynamic-update-slice(%dynamic-update-slice.647, %broadcast.12717, %constant.6347, %constant.6391, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.219 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.648), slice={[0:256], [301:602], [0:1], [0:16], [0:256]}\n+  %dynamic-update-slice.649 = bf16[256,2408,1,16,256] dynamic-update-slice(%dynamic-update-slice.648, %broadcast.12717, %constant.6347, %constant.6392, %constant.6347, %constant.6347, %constant.6347)\n+  %gather.220 = bf16[256,301,1,16,256] slice(%dynamic-update-slice.649), slice={[0:256], [0:301], [0:1], [0:16], [0:256]}\n+  ROOT %result = (bf16[256,301,1,16,256], bf16[256,301,1,16,256], bf16[256,301,1,16,256], bf16[256,301,1,16,256], bf16[256,301,1,16,256], bf16[256,301,1,16,256], bf16[256,301,1,16,256]) tuple(%gather.214, %gather.215, %gather.216, %gather.217, %gather.218, %gather.219, %gather.220)\n+}\n+)\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(kHlo));\n+  DeadDynamicUpdateSliceElimination dds;\n+  EXPECT_TRUE(dds.Run(module.get()).value());\n+  for (HloInstruction* instruction :\n+       module->entry_computation()->instructions()) {\n+    EXPECT_NE(instruction->opcode(), HloOpcode::kDynamicUpdateSlice);\n+  }\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 403,
        "additions": 403,
        "deletions": 0
    }
}