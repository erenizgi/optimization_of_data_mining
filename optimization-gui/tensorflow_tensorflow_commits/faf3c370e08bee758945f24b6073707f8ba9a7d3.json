{
    "author": "ZixuanJiang",
    "message": "[XLA] Remove obsolete shmap & sdy manual computation inliner handling.\n\nFrontend attributes are now in place to correctly model this behavior, so this logic is no longer needed.\n\nPiperOrigin-RevId: 850144990",
    "sha": "faf3c370e08bee758945f24b6073707f8ba9a7d3",
    "files": [
        {
            "sha": "1523eb504e5226aa239fd1d24ed5bcb26ee044fe",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=faf3c370e08bee758945f24b6073707f8ba9a7d3",
            "patch": "@@ -1026,7 +1026,6 @@ cc_library(\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/hlo/transforms/simplifiers:hlo_dce\",\n         \"//xla/hlo/utils:hlo_query\",\n-        \"//xla/service/spmd/shardy:constants\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\","
        },
        {
            "sha": "dc9142648882b06f90ea77d57757e1697e5de1d8",
            "filename": "third_party/xla/xla/service/call_inliner.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc?ref=faf3c370e08bee758945f24b6073707f8ba9a7d3",
            "patch": "@@ -28,7 +28,6 @@ limitations under the License.\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/match.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n@@ -45,7 +44,6 @@ limitations under the License.\n #include \"xla/hlo/utils/hlo_query.h\"\n #include \"xla/service/call_graph.h\"\n #include \"xla/service/hlo_domain_isolator.h\"\n-#include \"xla/service/spmd/shardy/constants.h\"\n #include \"xla/status_macros.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -334,23 +332,6 @@ bool CallInliner::IsInlineableCallOp(HloInstruction* instruction) const {\n   if (!prerequisite) {\n     return false;\n   }\n-  if (instruction->GetModule()->config().use_shardy_partitioner() &&\n-      (absl::StrContains(instruction->to_apply()->name(), \"shmap_body\") ||\n-       absl::StrContains(instruction->to_apply()->name(),\n-                         sdy::kManualComputationFuncName.str()))) {\n-    // TODO(b/436603025). Remove this special handling by marking the\n-    // instruction as uninlineable with the frontend attribute.\n-    //\n-    // Specific inlining rules when needing to round-trip from MLIR->HLO->MLIR\n-    // when using Shardy (github.com/openxla/shardy).\n-    //\n-    // - shmap_body: We do not want to inline the bodies of JAX shard maps to\n-    //   import them into an `sdy.ManualComputationOp`. This is for the MHLO\n-    //   round-trip pipeline\n-    // - kManualComputationFuncName: Same as shmap_body except for the SDY\n-    //   round-trip pipeline.\n-    return false;\n-  }\n   return InlineComposites(instruction, composites_to_preserve_);\n }\n "
        },
        {
            "sha": "5bcac704d39dc12a72bc4df09efaf9d178506d6c",
            "filename": "third_party/xla/xla/service/call_inliner_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 88,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner_test.cc?ref=faf3c370e08bee758945f24b6073707f8ba9a7d3",
            "patch": "@@ -511,94 +511,6 @@ TEST_F(CallInlinerTest, InlineCallWithOverriddenAttributeInlineableFalse) {\n   EXPECT_EQ(call, nullptr);\n }\n \n-TEST_F(CallInlinerTest, UseShardyMhloToHloShmapBodyNotInlined) {\n-  const char* const hloString = R\"(\n-    HloModule jit_f, entry_computation_layout={(f32[8,8]{1,0})->f32[8,8]{1,0}}\n-\n-    %prefix_shmap_body_suffix.4 (Arg_0.5: f32[1,8]) -> f32[1,8] {\n-      %Arg_0.5 = f32[1,8]{1,0} parameter(0)\n-      ROOT %add.6 = f32[1,8]{1,0} add(f32[1,8]{1,0} %Arg_0.5, f32[1,8]{1,0} %Arg_0.5), metadata={source_file=\"-\" source_line=11}\n-    }\n-\n-    ENTRY %main.10 (Arg_0.1: f32[8,8]) -> f32[8,8] {\n-      %Arg_0.1 = f32[8,8]{1,0} parameter(0)\n-      %custom-call.2 = f32[8,8]{1,0} custom-call(f32[8,8]{1,0} %Arg_0.1), custom_call_target=\"Sharding\", sharding={devices=[8,1]<=[8]}, metadata={source_file=\"-\" source_line=3}\n-      %custom-call.3 = f32[1,8]{1,0} custom-call(f32[8,8]{1,0} %custom-call.2), custom_call_target=\"SPMDFullToShardShape\", sharding={manual}, metadata={source_file=\"-\" source_line=4}\n-      %call.7 = f32[1,8]{1,0} call(f32[1,8]{1,0} %custom-call.3), to_apply=%prefix_shmap_body_suffix.4\n-      %custom-call.8 = f32[1,8]{1,0} custom-call(f32[1,8]{1,0} %call.7), custom_call_target=\"Sharding\", sharding={manual}, metadata={source_file=\"-\" source_line=6}\n-      ROOT %custom-call.9 = f32[8,8]{1,0} custom-call(f32[1,8]{1,0} %custom-call.8), custom_call_target=\"SPMDShardToFullShape\", sharding={devices=[8,1]<=[8]}, metadata={source_file=\"-\" source_line=7}\n-    })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hloString));\n-  module->mutable_config().set_use_shardy_partitioner(true);\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed, CallInliner().Run(module.get()));\n-  VLOG(1) << module->ToString();\n-  // The single call in the module is not inlined.\n-  EXPECT_FALSE(changed);\n-\n-  HloInstruction* call = FindInstruction(module.get(), xla::HloOpcode::kCall);\n-  EXPECT_NE(call, nullptr);\n-  EXPECT_TRUE(call->has_to_apply());\n-  EXPECT_EQ(call->to_apply()->name(), \"prefix_shmap_body_suffix.4\");\n-}\n-\n-// Don't inline when the name starts with \"xla.sdy.manual_computation_body\".\n-TEST_F(CallInlinerTest, UseShardManualComputationBodyNotInlined) {\n-  const char* const hloString = R\"(\n-    HloModule jit_f, entry_computation_layout={(f32[8,8]{1,0})->f32[8,8]{1,0}}\n-\n-    %xla.sdy.manual_computation_body.4 (Arg_0.5: f32[1,8]) -> f32[1,8] {\n-      %Arg_0.5 = f32[1,8]{1,0} parameter(0)\n-      ROOT %add.6 = f32[1,8]{1,0} add(f32[1,8]{1,0} %Arg_0.5, f32[1,8]{1,0} %Arg_0.5), metadata={source_file=\"-\" source_line=11}\n-    }\n-\n-    ENTRY %main.10 (Arg_0.1: f32[8,8]) -> f32[8,8] {\n-      %Arg_0.1 = f32[8,8]{1,0} parameter(0)\n-      %custom-call.3 = f32[1,8]{1,0} custom-call(f32[8,8]{1,0} %Arg_0.1), custom_call_target=\"SPMDFullToShardShape\", sharding={manual}, metadata={source_file=\"-\" source_line=4}\n-      %call.7 = f32[1,8]{1,0} call(f32[1,8]{1,0} %custom-call.3), to_apply=%xla.sdy.manual_computation_body.4\n-      ROOT %custom-call.9 = f32[8,8]{1,0} custom-call(f32[1,8]{1,0} %call.7), custom_call_target=\"SPMDShardToFullShape\", sharding={devices=[8,1]<=[8]}, metadata={source_file=\"-\" source_line=7}\n-    })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hloString));\n-  module->mutable_config().set_use_shardy_partitioner(true);\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed, CallInliner().Run(module.get()));\n-  // The single call in the module is not inlined.\n-  EXPECT_FALSE(changed);\n-\n-  HloInstruction* call = FindInstruction(module.get(), xla::HloOpcode::kCall);\n-  EXPECT_NE(call, nullptr);\n-  EXPECT_TRUE(call->has_to_apply());\n-  EXPECT_EQ(call->to_apply()->name(), \"xla.sdy.manual_computation_body.4\");\n-}\n-\n-// Make sure we check the name of the called function contains the string, not\n-// just the prefix/suffix.\n-TEST_F(CallInlinerTest, UseShardManualComputationBodySurroundedNotInlined) {\n-  const char* const hloString = R\"(\n-    HloModule jit_f, entry_computation_layout={(f32[8,8]{1,0})->f32[8,8]{1,0}}\n-\n-    %my_model.___call__.fwd.xla.sdy.manual_computation_body_14.1234 (Arg_0.5: f32[1,8]) -> f32[1,8] {\n-      %Arg_0.5 = f32[1,8]{1,0} parameter(0)\n-      ROOT %add.6 = f32[1,8]{1,0} add(f32[1,8]{1,0} %Arg_0.5, f32[1,8]{1,0} %Arg_0.5), metadata={source_file=\"-\" source_line=11}\n-    }\n-\n-    ENTRY %main.10 (Arg_0.1: f32[8,8]) -> f32[8,8] {\n-      %Arg_0.1 = f32[8,8]{1,0} parameter(0)\n-      %custom-call.3 = f32[1,8]{1,0} custom-call(f32[8,8]{1,0} %Arg_0.1), custom_call_target=\"SPMDFullToShardShape\", sharding={manual}, metadata={source_file=\"-\" source_line=4}\n-      %call.7 = f32[1,8]{1,0} call(f32[1,8]{1,0} %custom-call.3), to_apply=%my_model.___call__.fwd.xla.sdy.manual_computation_body_14.1234\n-      ROOT %custom-call.9 = f32[8,8]{1,0} custom-call(f32[1,8]{1,0} %call.7), custom_call_target=\"SPMDShardToFullShape\", sharding={devices=[8,1]<=[8]}, metadata={source_file=\"-\" source_line=7}\n-    })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(hloString));\n-  module->mutable_config().set_use_shardy_partitioner(true);\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed, CallInliner().Run(module.get()));\n-  // The single call in the module is not inlined.\n-  EXPECT_FALSE(changed);\n-\n-  HloInstruction* call = FindInstruction(module.get(), xla::HloOpcode::kCall);\n-  EXPECT_NE(call, nullptr);\n-  EXPECT_TRUE(call->has_to_apply());\n-  EXPECT_EQ(call->to_apply()->name(),\n-            \"my_model.___call__.fwd.xla.sdy.manual_computation_body_14.1234\");\n-}\n-\n TEST_F(CallInlinerTest, ControlDepsPropagateToRootOfInlinedInstructions) {\n   const char* hlo = R\"(\n   HloModule test"
        },
        {
            "sha": "cec431efb23d0b9153117618f75e5be07f3a6cac",
            "filename": "third_party/xla/xla/service/spmd/shardy/shardy_xla_pass.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fshardy_xla_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fshardy_xla_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fshardy_xla_pass.cc?ref=faf3c370e08bee758945f24b6073707f8ba9a7d3",
            "patch": "@@ -409,12 +409,6 @@ bool eraseInlineableAttrForShardyManualComputations(HloModule* module) {\n       if (absl::StrContains(instruction->to_apply()->name(),\n                             sdy::kManualComputationFuncName.str())) {\n         instruction->erase_frontend_attribute(kXlaInlineableAttr);\n-        // TODO(b/436603025). CallInliner do not inline the Shardy related\n-        // manual computations based on the callee name. We have to rename the\n-        // callee to a name such that it can be inlined. If we can remove the\n-        // special handling in CallInliner, we can remove this renaming.\n-        module->SetAndUniquifyComputationName(instruction->to_apply(),\n-                                              \"inlineable_callee\");\n         changed = true;\n       }\n     }"
        },
        {
            "sha": "851134528508ac0ea0fb2a66b2f3945013dfc9fb",
            "filename": "third_party/xla/xla/service/spmd/shardy/shardy_xla_pass_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fshardy_xla_pass_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/faf3c370e08bee758945f24b6073707f8ba9a7d3/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fshardy_xla_pass_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fshardy_xla_pass_test.cc?ref=faf3c370e08bee758945f24b6073707f8ba9a7d3",
            "patch": "@@ -1116,7 +1116,6 @@ TEST_F(ShardyXLATest, UpdateInlineableAttr) {\n   HloInstruction* root = module->entry_computation()->root_instruction();\n   EXPECT_EQ(root->opcode(), HloOpcode::kCall);\n   EXPECT_FALSE(root->has_frontend_attributes());\n-  EXPECT_EQ(root->to_apply()->name(), \"inlineable_callee\");\n }\n \n TEST_F(ShardyXLATest, ManualComputationCallOpWithToken) {"
        }
    ],
    "stats": {
        "total": 115,
        "additions": 0,
        "deletions": 115
    }
}