{
    "author": "krishnaharidasan",
    "message": "Make xla::ifrt::AttributeMap thread-safe\n\nPiperOrigin-RevId: 842793185",
    "sha": "6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0",
    "files": [
        {
            "sha": "59ee58576058f8389a745681e58ed758e4b9aa68",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0",
            "patch": "@@ -165,6 +165,7 @@ cc_library(\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n     ],\n )\n \n@@ -176,6 +177,7 @@ xla_cc_test(\n         \":attribute_map\",\n         \":serdes_test_util\",\n         \":serdes_version\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\","
        },
        {
            "sha": "dd727de8b9eab57ec27510b72613e5866b529f81",
            "filename": "third_party/xla/xla/python/ifrt/attribute_map.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.cc?ref=6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0",
            "patch": "@@ -28,6 +28,7 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n+#include \"absl/synchronization/mutex.h\"\n #include \"xla/python/ifrt/attribute_map.pb.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n \n@@ -82,6 +83,7 @@ void AttributeMap::ToProto(AttributeMapProto& proto,\n   proto.Clear();\n   proto.set_version_number(SerDesVersionNumber(0).value());\n \n+  absl::ReaderMutexLock lock(mu_);\n   for (const auto& [key, value] : map_) {\n     AttributeMapProto::Value value_proto;\n     std::visit(\n@@ -110,6 +112,7 @@ void AttributeMap::ToProto(AttributeMapProto& proto,\n \n std::string AttributeMap::DebugString(size_t max_string_length,\n                                       size_t max_int64_list_size) const {\n+  absl::ReaderMutexLock lock(mu_);\n   auto formatter = [=](std::string* out,\n                        const AttributeMap::Map::value_type& key_value) {\n     absl::StrAppend(out, key_value.first, \"=\");"
        },
        {
            "sha": "964969b718bf1b1cfbe949856da78a4f27b64b92",
            "filename": "third_party/xla/xla/python/ifrt/attribute_map.h",
            "status": "modified",
            "additions": 72,
            "deletions": 8,
            "changes": 80,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.h?ref=6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0",
            "patch": "@@ -24,12 +24,13 @@ limitations under the License.\n #include <variant>\n #include <vector>\n \n-#include \"absl/base/attributes.h\"\n+#include \"absl/base/thread_annotations.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/functional/function_ref.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/synchronization/mutex.h\"\n #include \"xla/python/ifrt/attribute_map.pb.h\"\n #include \"xla/python/ifrt/serdes_default_version_accessor.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n@@ -38,6 +39,8 @@ namespace xla {\n namespace ifrt {\n \n // Attribute map that contains UTF-8 keys and variant values.\n+//\n+// This class is thread-safe.\n class AttributeMap {\n  public:\n   // Supported value types for `AttributeMap`. Modeled after\n@@ -89,11 +92,9 @@ class AttributeMap {\n \n   explicit AttributeMap(Map map) : map_(std::move(map)) {}\n \n-  ABSL_DEPRECATED(\"map() is not thread-safe. Use Get() function instead.\")\n-  const Map& map() const { return map_; }\n-\n   template <typename T>\n   absl::StatusOr<T> Get(const std::string& key) const {\n+    absl::ReaderMutexLock lock(mu_);\n     if constexpr (std::is_same_v<T, Value>) {\n       auto it = map_.find(key);\n       if (it == map_.end()) {\n@@ -115,6 +116,28 @@ class AttributeMap {\n     }\n   }\n \n+  template <typename T>\n+  absl::Status Set(const std::string& key, T value) {\n+    absl::MutexLock lock(mu_);\n+    using ValueType = std::decay_t<T>;\n+    if constexpr (std::is_same_v<ValueType, std::string> ||\n+                  std::is_same_v<ValueType, const char*> ||\n+                  std::is_convertible_v<ValueType, std::string>) {\n+      map_.insert_or_assign(key, StringValue(std::move(value)));\n+    } else if constexpr (std::is_same_v<ValueType, bool>) {\n+      map_.insert_or_assign(key, BoolValue(std::move(value)));\n+    } else if constexpr (std::is_same_v<ValueType, int64_t>) {\n+      map_.insert_or_assign(key, Int64Value(std::move(value)));\n+    } else if constexpr (std::is_same_v<ValueType, std::vector<int64_t>>) {\n+      map_.insert_or_assign(key, Int64ListValue(std::move(value)));\n+    } else if constexpr (std::is_same_v<ValueType, float>) {\n+      map_.insert_or_assign(key, FloatValue(std::move(value)));\n+    } else {\n+      static_assert(false, \"Unsupported type for AttributeMap::Set\");\n+    }\n+    return absl::OkStatus();\n+  }\n+\n   // Deserializes `AttributeMapProto` into `AttributeMap`.\n   static absl::StatusOr<AttributeMap> FromProto(const AttributeMapProto& proto);\n \n@@ -138,25 +161,65 @@ class AttributeMap {\n     sink.Append(attribute_map.DebugString());\n   }\n \n-  bool IsEmpty() const { return map_.empty(); }\n+  bool IsEmpty() const {\n+    absl::ReaderMutexLock lock(mu_);\n+    return map_.empty();\n+  }\n \n   // Invokes `f` for each key-value pair in the attribute map.\n   void ForEach(\n       absl::FunctionRef<void(const std::string&, const Value&)> f) const {\n+    absl::ReaderMutexLock lock(mu_);\n     for (const auto& [key, value] : map_) {\n       f(key, value);\n     }\n   }\n \n   bool operator==(const AttributeMap& other) const {\n+    absl::ReaderMutexLock lock1(mu_);\n+    absl::ReaderMutexLock lock2(other.mu_);\n     return map_ == other.map_;\n   }\n \n-  size_t size() const { return map_.size(); }\n+  size_t size() const {\n+    absl::ReaderMutexLock lock(mu_);\n+    return map_.size();\n+  }\n+\n+  // Copyable and movable.\n+  AttributeMap(const AttributeMap& other) {\n+    absl::ReaderMutexLock lock(other.mu_);\n+    map_ = other.map_;\n+  }\n+  AttributeMap& operator=(const AttributeMap& other) {\n+    Map map;\n+    {\n+      absl::ReaderMutexLock lock(other.mu_);\n+      map = other.map_;\n+    }\n+    absl::MutexLock lock(mu_);\n+    map_ = std::move(map);\n+    return *this;\n+  }\n+  AttributeMap(AttributeMap&& other) {\n+    absl::MutexLock lock(other.mu_);\n+    map_ = std::move(other.map_);\n+  }\n+  AttributeMap& operator=(AttributeMap&& other) {\n+    Map map;\n+    {\n+      absl::MutexLock lock(other.mu_);\n+      map = std::move(other.map_);\n+    }\n+    absl::MutexLock lock(mu_);\n+    map_ = std::move(map);\n+    return *this;\n+  }\n \n  private:\n   template <typename T, typename V>\n-  absl::StatusOr<T> Get(const std::string& key) const {\n+  absl::StatusOr<T> Get(const std::string& key) const\n+      ABSL_SHARED_LOCKS_REQUIRED(mu_) {\n     auto it = map_.find(key);\n     if (it == map_.end()) {\n       return absl::NotFoundError(absl::StrCat(\"Key not found: \", key));\n@@ -169,7 +232,8 @@ class AttributeMap {\n     return value->value;\n   }\n \n-  Map map_;\n+  mutable absl::Mutex mu_;\n+  Map map_ ABSL_GUARDED_BY(mu_);\n };\n \n }  // namespace ifrt"
        },
        {
            "sha": "e81a3b8448a73533e00bb4a59c1089c0a7dd8ebc",
            "filename": "third_party/xla/xla/python/ifrt/attribute_map_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map_test.cc?ref=6c2d0e79349528e9f51a1cdb1e5f169e9969f2f0",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"xla/python/ifrt/serdes_test_util.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n \n namespace xla {\n@@ -80,6 +81,24 @@ TEST(AttributeMapTest, Get) {\n                        HasSubstr(\"Value type mismatch for key: string\")));\n }\n \n+TEST(AttributeMapTest, Set) {\n+  AttributeMap map({});\n+  TF_ASSERT_OK(map.Set(\"string\", \"value\"));\n+  TF_ASSERT_OK(map.Set(\"bool\", true));\n+  TF_ASSERT_OK(map.Set(\"int64\", int64_t{123}));\n+  TF_ASSERT_OK(map.Set(\"int64_list\", std::vector<int64_t>{1, 2}));\n+  TF_ASSERT_OK(map.Set(\"float\", 1.23f));\n+  EXPECT_EQ(map, AttributeMap({\n+                     {\"string\", AttributeMap::StringValue(\"value\")},\n+                     {\"bool\", AttributeMap::BoolValue(true)},\n+                     {\"int64\", AttributeMap::Int64Value(123)},\n+                     {\"int64_list\",\n+                      AttributeMap::Int64ListValue({int64_t{1}, int64_t{2}})},\n+                     {\"float\", AttributeMap::FloatValue(1.23f)},\n+                 }))\n+      << map.DebugString();\n+}\n+\n class AttributeMapSerDesTest : public testing::TestWithParam<SerDesVersion> {\n  public:\n   AttributeMapSerDesTest() : version_(GetParam()) {}"
        }
    ],
    "stats": {
        "total": 104,
        "additions": 96,
        "deletions": 8
    }
}