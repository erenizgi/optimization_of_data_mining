{
    "author": "tensorflower-gardener",
    "message": "Integrate LLVM at llvm/llvm-project@a6da68ed36d7\n\nUpdates LLVM usage to match\n[a6da68ed36d7](https://github.com/llvm/llvm-project/commit/a6da68ed36d7)\n\nPiperOrigin-RevId: 803177684",
    "sha": "5dd7021d7cf83048bd937e3369acf6c1fa8a02c2",
    "files": [
        {
            "sha": "217385de4003f17d6151f51efad69947fa57ad57",
            "filename": "third_party/xla/third_party/llvm/generated.patch",
            "status": "modified",
            "additions": 215,
            "deletions": 357,
            "changes": 572,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch?ref=5dd7021d7cf83048bd937e3369acf6c1fa8a02c2",
            "patch": "@@ -72,24 +72,6 @@ diff -ruN --strip-trailing-cr a/clang/include/clang/AST/TypeLoc.h b/clang/includ\n             \"Inconsistent nested-name-specifier pointer\");\n      getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n    }\n-diff -ruN --strip-trailing-cr a/clang/include/clang/ASTMatchers/ASTMatchers.h b/clang/include/clang/ASTMatchers/ASTMatchers.h\n---- a/clang/include/clang/ASTMatchers/ASTMatchers.h\n-+++ b/clang/include/clang/ASTMatchers/ASTMatchers.h\n-@@ -5739,6 +5739,14 @@\n-   return Builder->removeBindings(Predicate);\n- }\n- \n-+/// Matches a declaration if it declares the same entity as the node previously\n-+/// bound to \\p ID.\n-+AST_MATCHER_P(Decl, declaresSameEntityAsBoundNode, std::string, ID) {\n-+  return Builder->removeBindings([&](const internal::BoundNodesMap &Nodes) {\n-+    return !clang::declaresSameEntity(&Node, Nodes.getNodeAs<Decl>(ID));\n-+  });\n-+}\n-+\n- /// Matches the condition variable statement in an if statement.\n- ///\n- /// Given\n diff -ruN --strip-trailing-cr a/clang/include/clang/Serialization/ASTReader.h b/clang/include/clang/Serialization/ASTReader.h\n --- a/clang/include/clang/Serialization/ASTReader.h\n +++ b/clang/include/clang/Serialization/ASTReader.h\n@@ -225,6 +207,34 @@ diff -ruN --strip-trailing-cr a/clang/lib/AST/ASTImporter.cpp b/clang/lib/AST/AS\n    if (T->isCanonicalUnqualified())\n      return Importer.getToContext().getCanonicalTagType(*ToDeclOrErr);\n  \n+diff -ruN --strip-trailing-cr a/clang/lib/AST/ByteCode/InterpBuiltin.cpp b/clang/lib/AST/ByteCode/InterpBuiltin.cpp\n+--- a/clang/lib/AST/ByteCode/InterpBuiltin.cpp\n++++ b/clang/lib/AST/ByteCode/InterpBuiltin.cpp\n+@@ -1830,6 +1830,7 @@\n+     assert(Call->getArg(1)->getType()->isVectorType() &&\n+            ASTCtx.hasSameUnqualifiedType(Call->getArg(0)->getType(),\n+                                          Call->getArg(1)->getType()));\n++    (void)ASTCtx;\n+     ZeroArg = S.Stk.pop<Pointer>();\n+     assert(ZeroArg.getFieldDesc()->isPrimitiveArray());\n+   }\n+@@ -2728,6 +2729,8 @@\n+   if (!Arg1Type->isVectorType()) {\n+     assert(!Arg2Type->isVectorType());\n+     assert(!Arg3Type->isVectorType());\n++    (void)Arg2Type;\n++    (void)Arg3Type;\n+ \n+     const Floating &Z = S.Stk.pop<Floating>();\n+     const Floating &Y = S.Stk.pop<Floating>();\n+@@ -2753,6 +2756,7 @@\n+   assert(NumElems == Arg2Type->castAs<VectorType>()->getNumElements() &&\n+          NumElems == Arg3Type->castAs<VectorType>()->getNumElements());\n+   assert(ElemT->isRealFloatingType());\n++  (void)ElemT;\n+ \n+   const Pointer &VZ = S.Stk.pop<Pointer>();\n+   const Pointer &VY = S.Stk.pop<Pointer>();\n diff -ruN --strip-trailing-cr a/clang/lib/AST/DeclarationName.cpp b/clang/lib/AST/DeclarationName.cpp\n --- a/clang/lib/AST/DeclarationName.cpp\n +++ b/clang/lib/AST/DeclarationName.cpp\n@@ -236,37 +246,6 @@ diff -ruN --strip-trailing-cr a/clang/lib/AST/DeclarationName.cpp b/clang/lib/AS\n  \n    if (const RecordType *ClassRec = ClassType->getAs<RecordType>()) {\n      ClassRec->getOriginalDecl()->printName(OS, Policy);\n-diff -ruN --strip-trailing-cr a/clang/lib/AST/Decl.cpp b/clang/lib/AST/Decl.cpp\n---- a/clang/lib/AST/Decl.cpp\n-+++ b/clang/lib/AST/Decl.cpp\n-@@ -1604,17 +1604,20 @@\n-   // We have just computed the linkage for this decl. By induction we know\n-   // that all other computed linkages match, check that the one we just\n-   // computed also does.\n--  NamedDecl *Old = nullptr;\n--  for (auto *I : D->redecls()) {\n--    auto *T = cast<NamedDecl>(I);\n--    if (T == D)\n-+  // We can't assume the redecl chain is well formed at this point,\n-+  // so keep track of already visited declarations.\n-+  for (llvm::SmallPtrSet<const Decl *, 4> AlreadyVisited{D}; /**/; /**/) {\n-+    D = cast<NamedDecl>(const_cast<NamedDecl *>(D)->getNextRedeclarationImpl());\n-+    if (!AlreadyVisited.insert(D).second)\n-+      break;\n-+    if (D->isInvalidDecl())\n-       continue;\n--    if (!T->isInvalidDecl() && T->hasCachedLinkage()) {\n--      Old = T;\n-+    if (auto OldLinkage = D->getCachedLinkage();\n-+        OldLinkage != Linkage::Invalid) {\n-+      assert(LV.getLinkage() == OldLinkage);\n-       break;\n-     }\n-   }\n--  assert(!Old || Old->getCachedLinkage() == D->getCachedLinkage());\n- #endif\n- \n-   return LV;\n diff -ruN --strip-trailing-cr a/clang/lib/AST/MicrosoftMangle.cpp b/clang/lib/AST/MicrosoftMangle.cpp\n --- a/clang/lib/AST/MicrosoftMangle.cpp\n +++ b/clang/lib/AST/MicrosoftMangle.cpp\n@@ -417,21 +396,10 @@ diff -ruN --strip-trailing-cr a/clang/lib/AST/TypeLoc.cpp b/clang/lib/AST/TypeLo\n        /*NameLoc=*/Loc, /*LAngleLoc=*/Loc, /*RAngleLoc=*/Loc);\n    initializeArgLocs(Context, getTypePtr()->template_arguments(), getArgInfos(),\n                      Loc);\n-diff -ruN --strip-trailing-cr a/clang/lib/ASTMatchers/Dynamic/Registry.cpp b/clang/lib/ASTMatchers/Dynamic/Registry.cpp\n---- a/clang/lib/ASTMatchers/Dynamic/Registry.cpp\n-+++ b/clang/lib/ASTMatchers/Dynamic/Registry.cpp\n-@@ -240,6 +240,7 @@\n-   REGISTER_MATCHER(enumDecl);\n-   REGISTER_MATCHER(enumType);\n-   REGISTER_MATCHER(equalsBoundNode);\n-+  REGISTER_MATCHER(declaresSameEntityAsBoundNode);\n-   REGISTER_MATCHER(equalsIntegralValue);\n-   REGISTER_MATCHER(explicitCastExpr);\n-   REGISTER_MATCHER(exportDecl);\n diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp\n --- a/clang/lib/Sema/SemaDecl.cpp\n +++ b/clang/lib/Sema/SemaDecl.cpp\n-@@ -18028,7 +18028,8 @@\n+@@ -18032,7 +18032,8 @@\n            }\n          }\n        } else if (auto *RD = dyn_cast<CXXRecordDecl>(PrevDecl);\n@@ -444,33 +412,15 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/Sem\n diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp\n --- a/clang/lib/Sema/SemaDeclCXX.cpp\n +++ b/clang/lib/Sema/SemaDeclCXX.cpp\n-@@ -1373,10 +1373,13 @@\n-         S.BuildReferenceType(T, E.get()->isLValue(), Loc, B->getDeclName());\n-     if (RefType.isNull())\n-       return true;\n--    auto *RefVD = VarDecl::Create(\n--        S.Context, Src->getDeclContext(), Loc, Loc,\n--        B->getDeclName().getAsIdentifierInfo(), RefType,\n--        S.Context.getTrivialTypeSourceInfo(T, Loc), Src->getStorageClass());\n-+\n-+    // Don't give this VarDecl a TypeSourceInfo, since this is a synthesized\n-+    // entity and this type was never written in source code.\n-+    auto *RefVD =\n-+        VarDecl::Create(S.Context, Src->getDeclContext(), Loc, Loc,\n-+                        B->getDeclName().getAsIdentifierInfo(), RefType,\n-+                        /*TInfo=*/nullptr, Src->getStorageClass());\n-     RefVD->setLexicalDeclContext(Src->getLexicalDeclContext());\n-     RefVD->setTSCSpec(Src->getTSCSpec());\n-     RefVD->setImplicit();\n-@@ -4565,6 +4568,7 @@\n+@@ -4568,6 +4568,7 @@\n        MarkAnyDeclReferenced(TyD->getLocation(), TyD, /*OdrUse=*/false);\n  \n        TypeLocBuilder TLB;\n +      // FIXME: This is missing building the UsingType for TyD, if any.\n        if (const auto *TD = dyn_cast<TagDecl>(TyD)) {\n          BaseType = Context.getTagType(ElaboratedTypeKeyword::None,\n                                        SS.getScopeRep(), TD, /*OwnsTag=*/false);\n-@@ -4578,6 +4582,12 @@\n+@@ -4581,6 +4582,12 @@\n          TLB.push<TypedefTypeLoc>(BaseType).set(\n              /*ElaboratedKeywordLoc=*/SourceLocation(),\n              SS.getWithLocInContext(Context), IdLoc);\n@@ -645,13 +595,14 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/\n      return getDerived().RebuildTemplateName(\n          SubstPack->getArgumentPack(), SubstPack->getAssociatedDecl(),\n          SubstPack->getIndex(), SubstPack->getFinal());\n-@@ -5414,20 +5414,10 @@\n+@@ -5414,21 +5414,10 @@\n          TLB, TL.castAs<DependentNameTypeLoc>(), /*DeducedTSTContext=*/false,\n          ObjectType, UnqualLookup);\n    }\n -  case TypeLoc::Typedef:\n -  case TypeLoc::TemplateSpecialization:\n -  case TypeLoc::SubstTemplateTypeParm:\n+-  case TypeLoc::SubstTemplateTypeParmPack:\n -  case TypeLoc::PackIndexing:\n -  case TypeLoc::Enum:\n -  case TypeLoc::Record:\n@@ -669,20 +620,7 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/\n    }\n  }\n  \n-@@ -7668,8 +7658,11 @@\n-   } else if (isa<TypedefType>(Result)) {\n-     TLB.push<TypedefTypeLoc>(Result).set(TL.getElaboratedKeywordLoc(),\n-                                          QualifierLoc, TL.getNameLoc());\n-+  } else if (isa<UnresolvedUsingType>(Result)) {\n-+    auto NewTL = TLB.push<UnresolvedUsingTypeLoc>(Result);\n-+    NewTL.set(TL.getElaboratedKeywordLoc(), QualifierLoc, TL.getNameLoc());\n-   } else {\n--    DependentNameTypeLoc NewTL = TLB.push<DependentNameTypeLoc>(Result);\n-+    auto NewTL = TLB.push<DependentNameTypeLoc>(Result);\n-     NewTL.setElaboratedKeywordLoc(TL.getElaboratedKeywordLoc());\n-     NewTL.setQualifierLoc(QualifierLoc);\n-     NewTL.setNameLoc(TL.getNameLoc());\n-@@ -17364,13 +17357,12 @@\n+@@ -17386,13 +17375,12 @@\n    return SemaRef.BuildBitIntType(IsUnsigned, NumBitsExpr, Loc);\n  }\n  \n@@ -726,24 +664,6 @@ diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReader.cpp b/clang/li\n  \n        diagnoseOdrViolations();\n      }\n-diff -ruN --strip-trailing-cr a/clang/test/Analysis/anonymous-decls.cpp b/clang/test/Analysis/anonymous-decls.cpp\n---- a/clang/test/Analysis/anonymous-decls.cpp\n-+++ b/clang/test/Analysis/anonymous-decls.cpp\n-@@ -78,12 +78,12 @@\n- // CHECK-NEXT:   8: decomposition-a-b\n- // CHECK-NEXT:   9: [B3.7]([B3.8])\n- // CHECK-NEXT:  10: [B3.9]\n--// CHECK-NEXT:  11: std::tuple_element<0UL, std::pair<int, int>>::type a = get<0UL>(decomposition-a-b);\n-+// CHECK-NEXT:  11: std::tuple_element<0UL, std::pair<int, int>>::type &&a = get<0UL>(decomposition-a-b);\n- // CHECK-NEXT:  12: get<1UL>\n- // CHECK-NEXT:  13: [B3.12] (ImplicitCastExpr, FunctionToPointerDecay, tuple_element<1L, pair<int, int> >::type (*)(pair<int, int> &))\n- // CHECK-NEXT:  14: decomposition-a-b\n- // CHECK-NEXT:  15: [B3.13]([B3.14])\n- // CHECK-NEXT:  16: [B3.15]\n--// CHECK-NEXT:  17: std::tuple_element<1UL, std::pair<int, int>>::type b = get<1UL>(decomposition-a-b);\n-+// CHECK-NEXT:  17: std::tuple_element<1UL, std::pair<int, int>>::type &&b = get<1UL>(decomposition-a-b);\n- // CHECK-NEXT:   Preds (1): B1\n- // CHECK-NEXT:   Succs (1): B2\n diff -ruN --strip-trailing-cr a/clang/test/Analysis/ctu-import-type-decl-definition.c b/clang/test/Analysis/ctu-import-type-decl-definition.c\n --- a/clang/test/Analysis/ctu-import-type-decl-definition.c\n +++ b/clang/test/Analysis/ctu-import-type-decl-definition.c\n@@ -1009,33 +929,6 @@ diff -ruN --strip-trailing-cr a/clang/test/Index/recursive-cxx-member-calls.cpp\n  // CHECK: 87:35: ParmDecl=Str:87:35 (Definition) Extent=[87:25 - 87:38]\n  // CHECK: 87:25: TypeRef=class llvm::StringRef:38:7 Extent=[87:25 - 87:34]\n  // CHECK: 87:42: MemberRef=Str:84:13 Extent=[87:42 - 87:45]\n-diff -ruN --strip-trailing-cr a/clang/test/Modules/GH153933.cpp b/clang/test/Modules/GH153933.cpp\n---- a/clang/test/Modules/GH153933.cpp\n-+++ b/clang/test/Modules/GH153933.cpp\n-@@ -0,0 +1,23 @@\n-+// RUN: rm -rf %t\n-+// RUN: mkdir -p %t\n-+// RUN: split-file %s %t\n-+//\n-+// RUN: %clang_cc1 -std=c++20 %t/B.cppm -emit-module-interface -o %t/B.pcm\n-+// RUN: %clang_cc1 -std=c++20 -fsyntax-only -fprebuilt-module-path=%t %t/C.cpp\n-+\n-+//--- A.hpp\n-+template<class> struct A {};\n-+template<class T> struct B {\n-+  virtual A<T> v() { return {}; }\n-+};\n-+B<void> x;\n-+\n-+//--- B.cppm\n-+module;\n-+#include \"A.hpp\"\n-+export module B;\n-+using ::x;\n-+\n-+//--- C.cpp\n-+#include \"A.hpp\"\n-+import B;\n diff -ruN --strip-trailing-cr a/clang/test/PCH/cxx-explicit-specifier.cpp b/clang/test/PCH/cxx-explicit-specifier.cpp\n --- a/clang/test/PCH/cxx-explicit-specifier.cpp\n +++ b/clang/test/PCH/cxx-explicit-specifier.cpp\n@@ -1159,21 +1052,6 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/return.cpp b/clang/test/SemaC\n                            // expected-error@-1 {{destructor '~ST' must not return void expression}}\n    };\n  \n-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/using-decl-templates.cpp b/clang/test/SemaCXX/using-decl-templates.cpp\n---- a/clang/test/SemaCXX/using-decl-templates.cpp\n-+++ b/clang/test/SemaCXX/using-decl-templates.cpp\n-@@ -153,3 +153,11 @@\n- }\n- } // namespace sss\n- } // namespace func_templ\n-+\n-+namespace DependentName {\n-+  template <typename T> struct S {\n-+    using typename T::Ty;\n-+    static Ty Val;\n-+  };\n-+  template <typename T> typename S<T>::Ty S<T>::Val;\n-+} // DependentName\n diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/class-template-ctor-initializer.cpp b/clang/test/SemaTemplate/class-template-ctor-initializer.cpp\n --- a/clang/test/SemaTemplate/class-template-ctor-initializer.cpp\n +++ b/clang/test/SemaTemplate/class-template-ctor-initializer.cpp\n@@ -1328,9 +1206,8 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/nested-name-spec-templat\n --- a/clang/test/SemaTemplate/nested-name-spec-template.cpp\n +++ b/clang/test/SemaTemplate/nested-name-spec-template.cpp\n @@ -1,5 +1,5 @@\n--// RUN: %clang_cc1 -fsyntax-only -verify %s\n+ // RUN: %clang_cc1 -fsyntax-only -verify %s -Wno-c++20-extensions\n -// RUN: %clang_cc1 -fsyntax-only -verify -std=c++98 %s\n-+// RUN: %clang_cc1 -fsyntax-only -verify %s -Wno-c++20-extensions\n +// RUN: %clang_cc1 -fsyntax-only -verify -Wno-c++11-extensions -std=c++98 %s\n  // RUN: %clang_cc1 -fsyntax-only -verify -std=c++11 %s\n  \n@@ -1350,24 +1227,10 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/nested-name-spec-templat\n  }\n  \n  N::M::Promote<int>::type *ret_intptr5(int* ip) { return ip; }\n-@@ -167,3 +160,53 @@\n-   };\n-   template struct C<int>;\n- } // namespace unresolved_using\n-+\n-+#if __cplusplus >= 201703L\n-+namespace SubstTemplateTypeParmPackType {\n-+  template <int...> struct A {};\n-+\n-+  template <class... Ts> void f() {\n-+    []<int ... Is>(A<Is...>) { (Ts::g(Is) && ...); }(A<0>{});\n-+  };\n-+\n-+  struct B { static void g(int); };\n-+\n-+  template void f<B>();\n-+} // namespace SubstTemplateTypeParmPackType\n-+#endif\n+@@ -181,3 +174,39 @@\n+   template void f<B>();\n+ } // namespace SubstTemplateTypeParmPackType\n+ #endif\n +\n +namespace DependentUnaryTransform {\n +  template <class T> using decay_t = __decay(T);\n@@ -1427,60 +1290,6 @@ diff -ruN --strip-trailing-cr a/clang/unittests/AST/DeclTest.cpp b/clang/unittes\n +  ASSERT_NE(FD, nullptr);\n +  ASSERT_EQ(FD->getQualifiedNameAsString(), \"x::y::Foo::Foo<T>\");\n +}\n-diff -ruN --strip-trailing-cr a/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp b/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp\n---- a/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp\n-+++ b/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp\n-@@ -29,11 +29,13 @@\n-   const auto HasGoodReturnType =\n-       cxxMethodDecl(returns(hasCanonicalType(lValueReferenceType(pointee(\n-           unless(isConstQualified()),\n--          anyOf(autoType(), hasDeclaration(equalsBoundNode(\"class\"))))))));\n-+          anyOf(autoType(),\n-+                hasDeclaration(declaresSameEntityAsBoundNode(\"class\"))))))));\n- \n-   const auto IsSelf = qualType(hasCanonicalType(\n--      anyOf(hasDeclaration(equalsBoundNode(\"class\")),\n--            referenceType(pointee(hasDeclaration(equalsBoundNode(\"class\")))))));\n-+      anyOf(hasDeclaration(declaresSameEntityAsBoundNode(\"class\")),\n-+            referenceType(pointee(\n-+                hasDeclaration(declaresSameEntityAsBoundNode(\"class\")))))));\n-   const auto IsAssign =\n-       cxxMethodDecl(unless(anyOf(isDeleted(), isPrivate(), isImplicit())),\n-                     hasName(\"operator=\"), ofClass(recordDecl().bind(\"class\")))\n-diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp b/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp\n---- a/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp\n-+++ b/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp\n-@@ -176,3 +176,11 @@\n-   }\n- };\n- }\n-+\n-+namespace GH153770 {\n-+  struct A;\n-+  struct A {\n-+    A() = default;\n-+    A& operator=(const A&) = default;\n-+  };\n-+} // namespace GH153770\n-diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp b/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp\n---- a/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp\n-+++ b/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp\n-@@ -0,0 +1,15 @@\n-+// RUN: %check_clang_tidy -std=c++20 %s modernize-type-traits %t\n-+\n-+namespace std {\n-+template <class> struct tuple_size {\n-+  static const int value = 1;\n-+};\n-+template <int, class> struct tuple_element {\n-+  using type = int;\n-+};\n-+}\n-+\n-+struct A {};\n-+template <int> int get(const A&);\n-+\n-+auto [a] = A();\n diff -ruN --strip-trailing-cr a/libcxx/include/tuple b/libcxx/include/tuple\n --- a/libcxx/include/tuple\n +++ b/libcxx/include/tuple\n@@ -1722,132 +1531,181 @@ diff -ruN --strip-trailing-cr a/lldb/source/Plugins/SymbolFile/NativePDB/SymbolF\n  \n    // Now that we know the forward -> full mapping of all type indices, we can\n    // re-write all the indices.  At the end of this process, we want a mapping\n-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n---- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n-+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n-@@ -9786,6 +9786,19 @@\n-                \"Must only have a single non-zero incoming value\");\n-         EPI.VectorTripCount = Inc;\n-       }\n-+      // If we didn't find a non-zero vector trip count, all incoming values\n-+      // must be zero, which also means the vector trip count is zero. Pick the\n-+      // first zero as vector trip count.\n-+      // TODO: We should not choose VF * UF so the main vector loop is known to\n-+      // be dead.\n-+      if (!EPI.VectorTripCount) {\n-+        assert(\n-+            EPResumeVal->getNumIncomingValues() > 0 &&\n-+            all_of(EPResumeVal->incoming_values(),\n-+                   [](Value *Inc) { return match(Inc, m_SpecificInt(0)); }) &&\n-+            \"all incoming values must be 0\");\n-+        EPI.VectorTripCount = EPResumeVal->getOperand(0);\n-+      }\n-       VPValue *VPV = Plan.getOrAddLiveIn(EPResumeVal);\n-       assert(all_of(IV->users(),\n-                     [](const VPUser *U) {\n-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll b/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll\n---- a/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll\n-+++ b/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll\n-@@ -333,3 +333,91 @@\n- exit:\n-   ret void\n+diff -ruN --strip-trailing-cr a/mlir/include/mlir/AsmParser/AsmParser.h b/mlir/include/mlir/AsmParser/AsmParser.h\n+--- a/mlir/include/mlir/AsmParser/AsmParser.h\n++++ b/mlir/include/mlir/AsmParser/AsmParser.h\n+@@ -53,8 +53,7 @@\n+ /// null terminated.\n+ Attribute parseAttribute(llvm::StringRef attrStr, MLIRContext *context,\n+                          Type type = {}, size_t *numRead = nullptr,\n+-                         bool isKnownNullTerminated = false,\n+-                         llvm::StringMap<Attribute> *attributesCache = nullptr);\n++                         bool isKnownNullTerminated = false);\n+ \n+ /// This parses a single MLIR type to an MLIR context if it was valid. If not,\n+ /// an error diagnostic is emitted to the context.\n+diff -ruN --strip-trailing-cr a/mlir/lib/AsmParser/DialectSymbolParser.cpp b/mlir/lib/AsmParser/DialectSymbolParser.cpp\n+--- a/mlir/lib/AsmParser/DialectSymbolParser.cpp\n++++ b/mlir/lib/AsmParser/DialectSymbolParser.cpp\n+@@ -245,15 +245,6 @@\n+       return nullptr;\n+   }\n+ \n+-  if constexpr (std::is_same_v<Symbol, Attribute>) {\n+-    auto &cache = p.getState().symbols.attributesCache;\n+-    auto cacheIt = cache.find(symbolData);\n+-    // Skip cached attribute if it has type.\n+-    if (cacheIt != cache.end() && !p.getToken().is(Token::colon))\n+-      return cacheIt->second;\n+-\n+-    return cache[symbolData] = createSymbol(dialectName, symbolData, loc);\n+-  }\n+   return createSymbol(dialectName, symbolData, loc);\n  }\n-+\n-+; TODO: Choose smaller VF * UF for main loop, so we do not create a dead vector loop.\n-+define void @small_trip_count_loop(ptr %arg, ptr %arg2) {\n-+; CHECK-LABEL: @small_trip_count_loop(\n-+; CHECK-NEXT:  iter.check:\n-+; CHECK-NEXT:    [[ARG3:%.*]] = ptrtoint ptr [[ARG:%.*]] to i64\n-+; CHECK-NEXT:    [[ARG21:%.*]] = ptrtoint ptr [[ARG2:%.*]] to i64\n-+; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH:%.*]], label [[VECTOR_MEMCHECK:%.*]]\n-+; CHECK:       vector.memcheck:\n-+; CHECK-NEXT:    [[TMP0:%.*]] = sub i64 [[ARG21]], [[ARG3]]\n-+; CHECK-NEXT:    [[DIFF_CHECK:%.*]] = icmp ult i64 [[TMP0]], 64\n-+; CHECK-NEXT:    br i1 [[DIFF_CHECK]], label [[VEC_EPILOG_SCALAR_PH]], label [[VECTOR_MAIN_LOOP_ITER_CHECK:%.*]]\n-+; CHECK:       vector.main.loop.iter.check:\n-+; CHECK-NEXT:    br i1 true, label [[VEC_EPILOG_PH:%.*]], label [[VECTOR_PH:%.*]]\n-+; CHECK:       vector.ph:\n-+; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n-+; CHECK:       vector.body:\n-+; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 16\n-+; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 32\n-+; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 48\n-+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <16 x i8>, ptr [[ARG]], align 1\n-+; CHECK-NEXT:    [[WIDE_LOAD4:%.*]] = load <16 x i8>, ptr [[TMP1]], align 1\n-+; CHECK-NEXT:    [[WIDE_LOAD5:%.*]] = load <16 x i8>, ptr [[TMP2]], align 1\n-+; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <16 x i8>, ptr [[TMP3]], align 1\n-+; CHECK-NEXT:    [[TMP4:%.*]] = add <16 x i8> [[WIDE_LOAD]], splat (i8 10)\n-+; CHECK-NEXT:    [[TMP5:%.*]] = add <16 x i8> [[WIDE_LOAD4]], splat (i8 10)\n-+; CHECK-NEXT:    [[TMP6:%.*]] = add <16 x i8> [[WIDE_LOAD5]], splat (i8 10)\n-+; CHECK-NEXT:    [[TMP7:%.*]] = add <16 x i8> [[WIDE_LOAD6]], splat (i8 10)\n-+; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 16\n-+; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 32\n-+; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 48\n-+; CHECK-NEXT:    store <16 x i8> [[TMP4]], ptr [[ARG2]], align 1\n-+; CHECK-NEXT:    store <16 x i8> [[TMP5]], ptr [[TMP8]], align 1\n-+; CHECK-NEXT:    store <16 x i8> [[TMP6]], ptr [[TMP9]], align 1\n-+; CHECK-NEXT:    store <16 x i8> [[TMP7]], ptr [[TMP10]], align 1\n-+; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]\n-+; CHECK:       middle.block:\n-+; CHECK-NEXT:    br i1 false, label [[EXIT:%.*]], label [[VEC_EPILOG_ITER_CHECK:%.*]]\n-+; CHECK:       vec.epilog.iter.check:\n-+; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH]], label [[VEC_EPILOG_PH]]\n-+; CHECK:       vec.epilog.ph:\n-+; CHECK-NEXT:    [[VEC_EPILOG_RESUME_VAL:%.*]] = phi i32 [ 0, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MAIN_LOOP_ITER_CHECK]] ]\n-+; CHECK-NEXT:    br label [[VEC_EPILOG_VECTOR_BODY:%.*]]\n-+; CHECK:       vec.epilog.vector.body:\n-+; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ [[VEC_EPILOG_RESUME_VAL]], [[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]\n-+; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 [[INDEX]]\n-+; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <16 x i8>, ptr [[TMP11]], align 1\n-+; CHECK-NEXT:    [[TMP12:%.*]] = add <16 x i8> [[WIDE_LOAD7]], splat (i8 10)\n-+; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 [[INDEX]]\n-+; CHECK-NEXT:    store <16 x i8> [[TMP12]], ptr [[TMP13]], align 1\n-+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 16\n-+; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], 16\n-+; CHECK-NEXT:    br i1 [[TMP14]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]\n-+; CHECK:       vec.epilog.middle.block:\n-+; CHECK-NEXT:    br i1 false, label [[EXIT]], label [[VEC_EPILOG_SCALAR_PH]]\n-+; CHECK:       vec.epilog.scalar.ph:\n-+; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 16, [[VEC_EPILOG_MIDDLE_BLOCK]] ], [ 0, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MEMCHECK]] ], [ 0, [[ITER_CHECK:%.*]] ]\n-+; CHECK-NEXT:    br label [[LOOP:%.*]]\n-+; CHECK:       loop:\n-+; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[VEC_EPILOG_SCALAR_PH]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]\n-+; CHECK-NEXT:    [[GEP_A:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 [[IV]]\n-+; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[GEP_A]], align 1\n-+; CHECK-NEXT:    [[SELECT:%.*]] = add i8 [[LOAD]], 10\n-+; CHECK-NEXT:    [[GEP_B:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 [[IV]]\n-+; CHECK-NEXT:    store i8 [[SELECT]], ptr [[GEP_B]], align 1\n-+; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1\n-+; CHECK-NEXT:    [[EC:%.*]] = icmp eq i32 [[IV]], 20\n-+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP12:![0-9]+]]\n-+; CHECK:       exit:\n-+; CHECK-NEXT:    ret void\n-+;\n-+entry:\n-+  br label %loop\n-+\n-+loop:\n-+  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n-+  %gep.A = getelementptr inbounds i8, ptr %arg, i32 %iv\n-+  %load = load i8, ptr %gep.A, align 1\n-+  %select = add i8 %load, 10\n-+  %gep.B = getelementptr inbounds i8, ptr %arg2, i32 %iv\n-+  store i8 %select, ptr %gep.B, align 1\n-+  %iv.next = add i32 %iv, 1\n-+  %ec = icmp eq i32 %iv, 20\n-+  br i1 %ec, label %exit, label %loop\n-+\n-+exit:\n-+  ret void\n-+}\n-diff -ruN --strip-trailing-cr a/llvm/tools/llvm-c-test/debuginfo.c b/llvm/tools/llvm-c-test/debuginfo.c\n---- a/llvm/tools/llvm-c-test/debuginfo.c\n-+++ b/llvm/tools/llvm-c-test/debuginfo.c\n-@@ -448,6 +448,7 @@\n-   assert(ME != NULL);\n-   assert(numEntries == 2);\n- \n-+  LLVMDisposeValueMetadataEntries(ME);\n-   LLVMDisposeDIBuilder(Builder);\n-   LLVMDisposeModule(M);\n+ \n+@@ -346,7 +337,6 @@\n+ template <typename T, typename ParserFn>\n+ static T parseSymbol(StringRef inputStr, MLIRContext *context,\n+                      size_t *numReadOut, bool isKnownNullTerminated,\n+-                     llvm::StringMap<Attribute> *attributesCache,\n+                      ParserFn &&parserFn) {\n+   // Set the buffer name to the string being parsed, so that it appears in error\n+   // diagnostics.\n+@@ -358,9 +348,6 @@\n+   SourceMgr sourceMgr;\n+   sourceMgr.AddNewSourceBuffer(std::move(memBuffer), SMLoc());\n+   SymbolState aliasState;\n+-  if (attributesCache)\n+-    aliasState.attributesCache = *attributesCache;\n+-\n+   ParserConfig config(context);\n+   ParserState state(sourceMgr, config, aliasState, /*asmState=*/nullptr,\n+                     /*codeCompleteContext=*/nullptr);\n+@@ -371,11 +358,6 @@\n+   if (!symbol)\n+     return T();\n+ \n+-  if constexpr (std::is_same_v<T, Attribute>) {\n+-    if (attributesCache)\n+-      *attributesCache = state.symbols.attributesCache;\n+-  }\n+-\n+   // Provide the number of bytes that were read.\n+   Token endTok = parser.getToken();\n+   size_t numRead =\n+@@ -392,15 +374,13 @@\n+ \n+ Attribute mlir::parseAttribute(StringRef attrStr, MLIRContext *context,\n+                                Type type, size_t *numRead,\n+-                               bool isKnownNullTerminated,\n+-                               llvm::StringMap<Attribute> *attributesCache) {\n++                               bool isKnownNullTerminated) {\n+   return parseSymbol<Attribute>(\n+-      attrStr, context, numRead, isKnownNullTerminated, attributesCache,\n++      attrStr, context, numRead, isKnownNullTerminated,\n+       [type](Parser &parser) { return parser.parseAttribute(type); });\n+ }\n+ Type mlir::parseType(StringRef typeStr, MLIRContext *context, size_t *numRead,\n+                      bool isKnownNullTerminated) {\n+   return parseSymbol<Type>(typeStr, context, numRead, isKnownNullTerminated,\n+-                           /*attributesCache=*/nullptr,\n+                            [](Parser &parser) { return parser.parseType(); });\n+ }\n+diff -ruN --strip-trailing-cr a/mlir/lib/AsmParser/ParserState.h b/mlir/lib/AsmParser/ParserState.h\n+--- a/mlir/lib/AsmParser/ParserState.h\n++++ b/mlir/lib/AsmParser/ParserState.h\n+@@ -40,9 +40,6 @@\n+ \n+   /// A map from unique integer identifier to DistinctAttr.\n+   DenseMap<uint64_t, DistinctAttr> distinctAttributes;\n+-\n+-  /// A map from unique string identifier to Attribute.\n+-  llvm::StringMap<Attribute> attributesCache;\n+ };\n+ \n+ //===----------------------------------------------------------------------===//\n+diff -ruN --strip-trailing-cr a/mlir/lib/Bytecode/Reader/BytecodeReader.cpp b/mlir/lib/Bytecode/Reader/BytecodeReader.cpp\n+--- a/mlir/lib/Bytecode/Reader/BytecodeReader.cpp\n++++ b/mlir/lib/Bytecode/Reader/BytecodeReader.cpp\n+@@ -895,10 +895,6 @@\n+   SmallVector<AttrEntry> attributes;\n+   SmallVector<TypeEntry> types;\n+ \n+-  /// The map of cached attributes, used to avoid re-parsing the same\n+-  /// attribute multiple times.\n+-  llvm::StringMap<Attribute> attributesCache;\n+-\n+   /// A location used for error emission.\n+   Location fileLoc;\n+ \n+@@ -1239,7 +1235,7 @@\n+         ::parseType(asmStr, context, &numRead, /*isKnownNullTerminated=*/true);\n+   else\n+     result = ::parseAttribute(asmStr, context, Type(), &numRead,\n+-                              /*isKnownNullTerminated=*/true, &attributesCache);\n++                              /*isKnownNullTerminated=*/true);\n+   if (!result)\n+     return failure();\n+ \n+diff -ruN --strip-trailing-cr a/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp b/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp\n+--- a/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp\n++++ b/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp\n+@@ -532,6 +532,9 @@\n+     // Vector transfer ops with rank > 1 should be lowered with VectorToSCF.\n+     vector::populateVectorTransferLoweringPatterns(patterns,\n+                                                    /*maxTransferRank=*/1);\n++    // Transform N-D vector.from_elements to 1-D vector.from_elements before\n++    // conversion.\n++    vector::populateVectorFromElementsLoweringPatterns(patterns);\n+     if (failed(applyPatternsGreedily(getOperation(), std::move(patterns))))\n+       return signalPassFailure();\n+   }\n+diff -ruN --strip-trailing-cr a/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp b/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp\n+--- a/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp\n++++ b/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp\n+@@ -27,6 +27,7 @@\n+ #include \"mlir/Dialect/Math/IR/Math.h\"\n+ #include \"mlir/Dialect/MemRef/IR/MemRef.h\"\n+ #include \"mlir/Dialect/NVGPU/IR/NVGPUDialect.h\"\n++#include \"mlir/Dialect/Vector/Transforms/LoweringPatterns.h\"\n+ #include \"mlir/Transforms/DialectConversion.h\"\n+ #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n+ \n+@@ -369,6 +370,9 @@\n+     {\n+       RewritePatternSet patterns(m.getContext());\n+       populateGpuRewritePatterns(patterns);\n++      // Transform N-D vector.from_elements to 1-D vector.from_elements before\n++      // conversion.\n++      vector::populateVectorFromElementsLoweringPatterns(patterns);\n+       if (failed(applyPatternsGreedily(m, std::move(patterns))))\n+         return signalPassFailure();\n+     }\n+diff -ruN --strip-trailing-cr a/mlir/test/IR/recursive-distinct-attr.mlir b/mlir/test/IR/recursive-distinct-attr.mlir\n+--- a/mlir/test/IR/recursive-distinct-attr.mlir\n++++ b/mlir/test/IR/recursive-distinct-attr.mlir\n+@@ -1,13 +0,0 @@\n+-// RUN: mlir-opt -emit-bytecode %s | mlir-opt --mlir-print-debuginfo | FileCheck %s\n+-\n+-// Verify that the distinct attribute which is used transitively\n+-// through two aliases does not end up duplicated when round-tripped\n+-// through bytecode.\n+-\n+-// CHECK: distinct[0]\n+-// CHECK-NOT: distinct[1]\n+-#attr_ugly = #test<attr_ugly begin distinct[0]<> end>\n+-#attr_ugly1 = #test<attr_ugly begin #attr_ugly end>\n+-\n+-module attributes {test.alias = #attr_ugly, test.alias1 = #attr_ugly1} {\n+-}\n+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel\n+--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel\n++++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel\n+@@ -5718,6 +5718,7 @@\n+         \":NVGPUDialect\",\n+         \":NVVMDialect\",\n+         \":TransformUtils\",\n++        \":VectorTransforms\",\n+     ],\n+ )\n  "
        },
        {
            "sha": "8bcb8f958a7a2ba6bc07a53baa9adfcb2978a328",
            "filename": "third_party/xla/third_party/llvm/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl?ref=5dd7021d7cf83048bd937e3369acf6c1fa8a02c2",
            "patch": "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n \n def repo(name):\n     \"\"\"Imports LLVM.\"\"\"\n-    LLVM_COMMIT = \"cb2f0d0a5f14c183e7182aba0f0e54a518de9e3f\"\n-    LLVM_SHA256 = \"e8ece380fdb57dc6f8e42df9db872a1ade5056c5379075e3e2f99c89200aea69\"\n+    LLVM_COMMIT = \"a6da68ed36d7ecb9edf00262d2a2c1129689399f\"\n+    LLVM_SHA256 = \"a5ba622b3a1342fdb763dfa29e1cd70838731932a8cc662fcac4910d67048613\"\n \n     tf_http_archive(\n         name = name,"
        },
        {
            "sha": "bebb8df2ff530a67e5df92b9bc2641f88a50d0ed",
            "filename": "third_party/xla/third_party/shardy/temporary.patch",
            "status": "modified",
            "additions": 1194,
            "deletions": 2078,
            "changes": 3272,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch?ref=5dd7021d7cf83048bd937e3369acf6c1fa8a02c2"
        },
        {
            "sha": "dc1fc1de452b6e4f24f5c88b6697390dd1877b82",
            "filename": "third_party/xla/third_party/shardy/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl?ref=5dd7021d7cf83048bd937e3369acf6c1fa8a02c2",
            "patch": "@@ -3,8 +3,8 @@\n load(\"//third_party:repo.bzl\", \"tf_http_archive\", \"tf_mirror_urls\")\n \n def repo():\n-    SHARDY_COMMIT = \"77d9192e7cf10ad63821f9a5200d1d7fa34f2328\"\n-    SHARDY_SHA256 = \"af8b36bfe0a3b3e7427a86da005e4f2b0f3a0a464359dc0163d114d0f6156c53\"\n+    SHARDY_COMMIT = \"a95b171d7845fd58403315388b2c31da71d4a277\"\n+    SHARDY_SHA256 = \"d3f7bee0b0e73d9553f7566d31071d7e2c336c7a429ebf362b90996c6c4018a4\"\n \n     tf_http_archive(\n         name = \"shardy\","
        },
        {
            "sha": "500a98c3b2ce79dda46ae25829f58cda03ff4e4b",
            "filename": "third_party/xla/xla/backends/gpu/codegen/emitters/tests/transpose/packed_transpose_s16.hlo",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Ftests%2Ftranspose%2Fpacked_transpose_s16.hlo",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Ftests%2Ftranspose%2Fpacked_transpose_s16.hlo",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Ftests%2Ftranspose%2Fpacked_transpose_s16.hlo?ref=5dd7021d7cf83048bd937e3369acf6c1fa8a02c2",
            "patch": "@@ -11,7 +11,6 @@ fusion {\n // CHECK-SAME:      %[[OUTPU:.*]]: tensor<4x2x6x10x64xi16>\n \n // CHECK-DAG:  %[[C1:.*]] = arith.constant 1 : index\n-// CHECK-DAG:  %[[VC0:.*]] = arith.constant dense<0> : vector<2x2xi16>\n \n // CHECK:  xla_gpu.allocate_shared : tensor<64x64xi16>\n \n@@ -27,22 +26,19 @@ fusion {\n // CHECK:        %[[V0:.*]] = vector.transfer_read %[[SHMEM_SYNC]]\n // CHECK-SAME:     : tensor<64x64xi16>, vector<2xi16>\n // CHECK:        %[[V1:.*]] = vector.extract %[[V0]][0] : i16 from vector<2xi16>\n-// CHECK:        %[[V2:.*]] = vector.insert %[[V1]], %[[VC0]] [0, 0]\n // CHECK:        %[[V3:.*]] = vector.extract %[[V0]][1] : i16 from vector<2xi16>\n-// CHECK:        %[[V4:.*]] = vector.insert %[[V3]], %[[V2]] [1, 0]\n // CHECK:        %[[V5:.*]] = arith.addi\n \n // Reading the second horizontal vector.\n // CHECK:        %[[V6:.*]] = vector.transfer_read %[[SHMEM_SYNC]][%[[V5]]\n // CHECK-SAME:     : tensor<64x64xi16>, vector<2xi16>\n // CHECK:        %[[V7:.*]] = vector.extract %{{.*}}[0] : i16 from vector<2xi16>\n-// CHECK:        %[[V8:.*]] = vector.insert %{{.*}}[0, 1]\n // CHECK:        %[[V9:.*]] = vector.extract %{{.*}}[1] : i16 from vector<2xi16>\n-// CHECK:        %[[V10:.*]] = vector.insert %{{.*}}[1, 1]\n+// CHECK:        %[[V10:.*]] = vector.from_elements %[[V1]], %[[V7]], %[[V3]], %[[V9]] : vector<2x2xi16>\n \n // Writing back the transpose <VECTOR_SIZE x VECTOR_SIZE> vector.\n // CHECK:        xla.loop\n // CHECK:          vector.extract %[[V10]]\n // CHECK:          tensor.insert\n // CHECK:          xla.yield %{{.*}} : tensor<4x2x6x10x64xi16>\n-// CHECK:        }\n\\ No newline at end of file\n+// CHECK:        }"
        },
        {
            "sha": "fbf32f148feff1b013459e101c08b044eddd078b",
            "filename": "third_party/xla/xla/backends/gpu/codegen/emitters/tests/transpose/packed_transpose_two_heroes.hlo",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Ftests%2Ftranspose%2Fpacked_transpose_two_heroes.hlo",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dd7021d7cf83048bd937e3369acf6c1fa8a02c2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Ftests%2Ftranspose%2Fpacked_transpose_two_heroes.hlo",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Femitters%2Ftests%2Ftranspose%2Fpacked_transpose_two_heroes.hlo?ref=5dd7021d7cf83048bd937e3369acf6c1fa8a02c2",
            "patch": "@@ -12,8 +12,9 @@ fusion {\n   ROOT tuple = (s16[4,2,6,10,64], bf16[4,2,6,10,64]) tuple(tr0, tr1)\n }\n \n-// CHECK-DAG:  arith.constant dense<0> : vector<2x2xi16>\n-// CHECK-DAG:  arith.constant dense<0.000000e+00> : vector<2x2xbf16>\n-\n // CHECK:  xla_gpu.allocate_shared : tensor<64x64xi16>\n-// CHECK:  xla_gpu.allocate_shared : tensor<64x64xbf16>\n\\ No newline at end of file\n+// CHECK:  xla_gpu.allocate_shared : tensor<64x64xbf16>\n+// CHECK:      vector.from_elements\n+// CHECK-SAME:   vector<2x2xi16>\n+// CHECK:      vector.from_elements\n+// CHECK-SAME:   vector<2x2xbf16>"
        }
    ],
    "stats": {
        "total": 3869,
        "additions": 1420,
        "deletions": 2449
    }
}