{
    "author": "hawkinsp",
    "message": "Reverts 5a3a4bcd44baf08c22af3f007f9c28d75c8ec405\n\nPiperOrigin-RevId: 819762394",
    "sha": "baf408c724fc745a53964b11d7fd642b30c85574",
    "files": [
        {
            "sha": "04670447eb7b1764d5b39b1e24f7b1fc7f2309b1",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/baf408c724fc745a53964b11d7fd642b30c85574/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/baf408c724fc745a53964b11d7fd642b30c85574/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=baf408c724fc745a53964b11d7fd642b30c85574",
            "patch": "@@ -718,6 +718,11 @@ void PjRtStreamExecutorBuffer::ScopedHold::ConvertUsageHold(\n   SetState(kConverted);\n }\n \n+bool PjRtStreamExecutorBuffer::IsOnCpu() const {\n+  return memory_space() != nullptr &&\n+         memory_space()->kind() == PinnedHostMemorySpace::kKind;\n+}\n+\n bool PjRtStreamExecutorClient::IsOnCpu(PjRtMemorySpace* memory_space) {\n   return memory_space->kind() == PinnedHostMemorySpace::kKind;\n }\n@@ -1399,6 +1404,30 @@ void PjRtStreamExecutorBuffer::ConvertUsageHold(TrackedDeviceBuffer* buffer,\n   DecrementUsage();\n }\n \n+absl::StatusOr<size_t> PjRtStreamExecutorBuffer::GetOnDeviceSizeInBytes()\n+    const {\n+  absl::MutexLock lock(&mu_);\n+  if (device_buffer() == nullptr || !device_buffer()->device_memory()) {\n+    return InvalidArgument(\n+        \"GetOnDeviceSizeInBytes called on deleted or donated buffer\");\n+  }\n+  return device_buffer()->device_memory()->mem().size();\n+}\n+\n+Future<> PjRtStreamExecutorBuffer::CopyRawToHost(void* dst, int64_t offset,\n+                                                 int64_t transfer_size) {\n+  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n+  return se_client->CopyRawSubBufferToHost(this, Future<void*>(dst), offset,\n+                                           transfer_size);\n+}\n+\n+Future<> PjRtStreamExecutorBuffer::CopyRawToHostFuture(Future<void*> dst,\n+                                                       int64_t offset,\n+                                                       int64_t transfer_size) {\n+  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n+  return se_client->CopyRawSubBufferToHost(this, dst, offset, transfer_size);\n+}\n+\n PjRtStreamExecutorBuffer::ScopedHold\n PjRtStreamExecutorBuffer::GetBufferWithHold(ScopedHold::Type type) {\n   absl::MutexLock lock(&mu_);"
        },
        {
            "sha": "5f71ce677bd076586f9fe2e8251195c055ed8334",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/baf408c724fc745a53964b11d7fd642b30c85574/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/baf408c724fc745a53964b11d7fd642b30c85574/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=baf408c724fc745a53964b11d7fd642b30c85574",
            "patch": "@@ -600,6 +600,14 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n   PjRtStreamExecutorBuffer& operator=(const PjRtStreamExecutorBuffer&) = delete;\n   PjRtStreamExecutorBuffer& operator=(PjRtStreamExecutorBuffer&&) = delete;\n \n+  absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n+\n+  Future<> CopyRawToHost(void* dst, int64_t offset,\n+                         int64_t transfer_size) override;\n+\n+  Future<> CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                               int64_t transfer_size) override;\n+\n   // Drops the buffer's reference to its associated device memory, leaving the\n   // buffer in an invalid state. The memory will be freed lazily when all async\n   // operations using the buffer have completed, according to the allocation\n@@ -629,6 +637,8 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n \n   Future<> GetReadyFuture() override;\n \n+  bool IsOnCpu() const override;\n+\n   // Similar to Delete, drops the buffer's reference to its associated device\n   // memory, leaving the buffer in an invalid state, but returns the\n   // TrackedDeviceBuffer rather than freeing the device memory, so that another"
        },
        {
            "sha": "c3535afd0adf1206cafc4cb9b95ffaede2b79e74",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 94,
            "changes": 126,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/baf408c724fc745a53964b11d7fd642b30c85574/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/baf408c724fc745a53964b11d7fd642b30c85574/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=baf408c724fc745a53964b11d7fd642b30c85574",
            "patch": "@@ -16,7 +16,6 @@ limitations under the License.\n #include \"xla/pjrt/se_raw_buffer.h\"\n \n #include <cstdint>\n-#include <cstring>\n #include <memory>\n #include <optional>\n #include <utility>\n@@ -132,55 +131,23 @@ PjRtStreamExecutorRawBuffer::CopyRawHostToDeviceAndReturnEvent(\n     const void* src, int64_t offset, int64_t transfer_size) {\n   se::Stream* stream = local_device_->host_to_device_stream();\n   auto device_event = BufferSequencingEvent::Create(client_->thread_pool());\n-  client_->thread_pool()->Schedule([client = client_, device_event,\n-                                    local_device = local_device_, stream, src,\n-                                    offset, transfer_size,\n-                                    buf = tsl::FormRef(this)]() mutable {\n-    se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n-    if (transfer_size < sub_buffer.size()) {\n-      sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n-    }\n-    client->WaitForAllocation(stream, *buf);\n-    std::shared_ptr<void> staging_buffer;\n-    auto status = [&]() -> absl::Status {\n-      if (transfer_size > 0) {\n-        if (client->should_stage_host_to_device_transfers() &&\n-            !client->IsDmaMapped(src, transfer_size)) {\n-          if (client->host_memory_allocator() == nullptr) {\n-            return absl::InvalidArgumentError(\n-                \"host_memory_allocator should be initialized for \"\n-                \"staging buffer transfer.\");\n-          }\n-          void* ptr = client->host_memory_allocator()->AllocateRaw(\n-              tsl::Allocator::kAllocatorAlignment, transfer_size);\n-          staging_buffer = std::shared_ptr<void>(\n-              ptr,\n-              [host_memory_allocator = client->host_memory_allocator()](\n-                  void* ptr) { host_memory_allocator->DeallocateRaw(ptr); });\n-          auto copy_to_staging_buffer = [src, transfer_size,\n-                                         staging_buffer]() mutable {\n-            std::memcpy(staging_buffer.get(), src, transfer_size);\n-          };\n-          TF_RETURN_IF_ERROR(stream->DoHostCallback(copy_to_staging_buffer));\n-          TF_RETURN_IF_ERROR(\n-              stream->Memcpy(&sub_buffer, staging_buffer.get(), transfer_size));\n-        } else {\n-          TF_RETURN_IF_ERROR(stream->Memcpy(&sub_buffer, src, transfer_size));\n+  client_->thread_pool()->Schedule(\n+      [client = client_, device_event, local_device = local_device_, stream,\n+       src, offset, transfer_size, buf = tsl::FormRef(this)]() mutable {\n+        se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n+        if (transfer_size < sub_buffer.size()) {\n+          sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n         }\n-      }\n-      return absl::OkStatus();\n-    }();\n-    if (status.ok()) {\n-      status =\n-          client->AllocateAndRecordEvent(device_event, local_device, stream);\n-      if (staging_buffer) {\n-        device_event.AndThen([staging_buffer = std::move(staging_buffer)]() {});\n-      }\n-    }\n-    if (!status.ok()) {\n-      client->SetEventAsError(device_event, status);\n-    }\n-  });\n+        client->WaitForAllocation(stream, *buf);\n+        auto status = stream->Memcpy(&sub_buffer, src, transfer_size);\n+        if (status.ok()) {\n+          status = client->AllocateAndRecordEvent(device_event, local_device,\n+                                                  stream);\n+        }\n+        if (!status.ok()) {\n+          client->SetEventAsError(device_event, status);\n+        }\n+      });\n   return tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(\n       std::move(device_event), \"PjRtStreamExecutorRawBuffer\",\n       \"CopyRawHostToDevice\");\n@@ -191,52 +158,23 @@ PjRtStreamExecutorRawBuffer::CopyRawDeviceToHostAndReturnEvent(\n     void* dst, int64_t offset, int64_t transfer_size) {\n   se::Stream* stream = local_device_->GetDeviceToHostStream();\n   auto device_event = BufferSequencingEvent::Create(client_->thread_pool());\n-  client_->thread_pool()->Schedule([client = client_, device_event,\n-                                    local_device = local_device_, stream, dst,\n-                                    offset, transfer_size,\n-                                    buf = tsl::FormRef(this)]() mutable {\n-    se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n-    if (transfer_size < sub_buffer.size()) {\n-      sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n-    }\n-    client->WaitForAllocation(stream, *buf);\n-    auto status = [&]() -> absl::Status {\n-      if (transfer_size > 0) {\n-        if (client->should_stage_host_to_device_transfers() &&\n-            !client->IsDmaMapped(dst, transfer_size)) {\n-          if (client->host_memory_allocator() == nullptr) {\n-            return absl::InvalidArgumentError(\n-                \"host_memory_allocator should be initialized for \"\n-                \"staging buffer transfer.\");\n-          }\n-          void* ptr = client->host_memory_allocator()->AllocateRaw(\n-              tsl::Allocator::kAllocatorAlignment, transfer_size);\n-          std::shared_ptr<void> staging_buffer = std::shared_ptr<void>(\n-              ptr,\n-              [host_memory_allocator = client->host_memory_allocator()](\n-                  void* ptr) { host_memory_allocator->DeallocateRaw(ptr); });\n-          TF_RETURN_IF_ERROR(\n-              stream->Memcpy(staging_buffer.get(), sub_buffer, transfer_size));\n-          auto copy_from_staging_buffer = [dst, transfer_size,\n-                                           staging_buffer]() mutable {\n-            std::memcpy(dst, staging_buffer.get(), transfer_size);\n-          };\n-          // TODO(parkers): This failing maybe consitutes a race.\n-          TF_RETURN_IF_ERROR(stream->DoHostCallback(copy_from_staging_buffer));\n-        } else {\n-          TF_RETURN_IF_ERROR(stream->Memcpy(dst, sub_buffer, transfer_size));\n+  client_->thread_pool()->Schedule(\n+      [client = client_, device_event, local_device = local_device_, stream,\n+       dst, offset, transfer_size, buf = tsl::FormRef(this)]() mutable {\n+        se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n+        if (transfer_size < sub_buffer.size()) {\n+          sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n         }\n-      }\n-      return absl::OkStatus();\n-    }();\n-    if (status.ok()) {\n-      status =\n-          client->AllocateAndRecordEvent(device_event, local_device, stream);\n-    }\n-    if (!status.ok()) {\n-      client->SetEventAsError(device_event, status);\n-    }\n-  });\n+        client->WaitForAllocation(stream, *buf);\n+        auto status = stream->Memcpy(dst, sub_buffer, transfer_size);\n+        if (status.ok()) {\n+          status = client->AllocateAndRecordEvent(device_event, local_device,\n+                                                  stream);\n+        }\n+        if (!status.ok()) {\n+          client->SetEventAsError(device_event, status);\n+        }\n+      });\n   return tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(\n       std::move(device_event), \"PjRtStreamExecutorRawBuffer\",\n       \"CopyRawDeviceToHost\");"
        }
    ],
    "stats": {
        "total": 165,
        "additions": 71,
        "deletions": 94
    }
}