{
    "author": "tensorflower-gardener",
    "message": "[SymbolicExpr] Implement basic canonicalization\n\nPiperOrigin-RevId: 797322873",
    "sha": "bcff4467d24a9e16ed400c098f0c2f6f9465c8b4",
    "files": [
        {
            "sha": "d327bded25bfbbfb5849aa1932fa5851612d7792",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD?ref=bcff4467d24a9e16ed400c098f0c2f6f9465c8b4",
            "patch": "@@ -214,6 +214,7 @@ cc_library(\n     srcs = [\"symbolic_expr.cc\"],\n     hdrs = [\"symbolic_expr.h\"],\n     deps = [\n+        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\","
        },
        {
            "sha": "16ddc1abf31ccfa8ef332ad55f1d781c8f026059",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.cc",
            "status": "modified",
            "additions": 194,
            "deletions": 3,
            "changes": 197,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc?ref=bcff4467d24a9e16ed400c098f0c2f6f9465c8b4",
            "patch": "@@ -21,10 +21,11 @@ limitations under the License.\n #include <cmath>\n #include <cstddef>\n #include <cstdint>\n-#include <cstring>\n #include <string>\n #include <tuple>\n+#include <utility>\n \n+#include \"absl/algorithm/container.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/strings/ascii.h\"\n@@ -33,6 +34,7 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"absl/strings/strip.h\"\n #include \"absl/types/span.h\"\n+#include \"llvm/ADT/SmallVector.h\"\n #include \"llvm/Support/MathExtras.h\"\n #include \"mlir/Support/StorageUniquer.h\"\n \n@@ -186,6 +188,146 @@ class Parser {\n   SymbolicExprContext* context_;\n };\n \n+// Returns {BASE, COEFF}, where expr is equivalent to BASE * COEFF.\n+std::pair<SymbolicExpr, int64_t> GetBaseAndCoeff(SymbolicExpr expr) {\n+  if (expr.GetType() == SymbolicExprType::kMul) {\n+    SymbolicExpr lhs = expr.GetLHS();\n+    SymbolicExpr rhs = expr.GetRHS();\n+\n+    if (rhs.GetType() == SymbolicExprType::kConstant) {\n+      auto [base, coeff] = GetBaseAndCoeff(lhs);\n+      return {base, coeff * rhs.GetValue()};\n+    }\n+    if (lhs.GetType() == SymbolicExprType::kConstant) {\n+      auto [base, coeff] = GetBaseAndCoeff(rhs);\n+      return {base, coeff * lhs.GetValue()};\n+    }\n+  }\n+  return {expr, 1};\n+}\n+\n+// Helper function to recursively extract terms from an Add expression.\n+void ExtractTerms(SymbolicExpr expr,\n+                  llvm::SmallVector<std::pair<SymbolicExpr, int64_t>>& terms) {\n+  if (expr.GetType() == SymbolicExprType::kAdd) {\n+    ExtractTerms(expr.GetLHS(), terms);\n+    ExtractTerms(expr.GetRHS(), terms);\n+  } else {\n+    auto [base, coeff] = GetBaseAndCoeff(expr);\n+    terms.push_back({base, coeff});\n+  }\n+}\n+\n+SymbolicExpr CanonicalizeAdd(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  // Constant folding\n+  if (lhs.GetType() == SymbolicExprType::kConstant &&\n+      rhs.GetType() == SymbolicExprType::kConstant) {\n+    return ctx->CreateConstant(lhs.GetValue() + rhs.GetValue());\n+  }\n+  // Neutral element\n+  if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n+    return rhs;\n+  }\n+  if (rhs.GetType() == SymbolicExprType::kConstant && rhs.GetValue() == 0) {\n+    return lhs;\n+  }\n+\n+  // Flattening and term collection\n+  llvm::SmallVector<std::pair<SymbolicExpr, int64_t>> terms;\n+  ExtractTerms(lhs, terms);\n+  ExtractTerms(rhs, terms);\n+\n+  absl::c_sort(terms,\n+               [](const auto& a, const auto& b) { return a.first < b.first; });\n+\n+  llvm::SmallVector<SymbolicExpr> exprs;\n+  int64_t const_val = 0;\n+\n+  for (int i = 0; i < terms.size(); ++i) {\n+    SymbolicExpr current_base = terms[i].first;\n+    int64_t current_coeff = terms[i].second;\n+\n+    while (i + 1 < terms.size() && terms[i + 1].first == current_base) {\n+      current_coeff += terms[i + 1].second;\n+      i++;\n+    }\n+\n+    if (current_coeff == 0) {\n+      continue;\n+    }\n+\n+    if (current_base.GetType() == SymbolicExprType::kConstant) {\n+      const_val += current_base.GetValue() * current_coeff;\n+    } else {\n+      exprs.push_back((current_base * current_coeff).Canonicalize());\n+    }\n+  }\n+\n+  // Add the combined constant term as an expression\n+  if (const_val != 0) {\n+    exprs.push_back(ctx->CreateConstant(const_val));\n+  }\n+  if (exprs.empty()) {\n+    return ctx->CreateConstant(0);\n+  }\n+  // Sort all terms, including the constant\n+  absl::c_sort(exprs);\n+\n+  SymbolicExpr result = exprs[0];\n+  for (size_t i = 1; i < exprs.size(); ++i) {\n+    result = ctx->CreateBinaryOp(SymbolicExprType::kAdd, result, exprs[i]);\n+  }\n+  return result;\n+}\n+\n+SymbolicExpr CanonicalizeMul(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  if (lhs.GetType() == SymbolicExprType::kConstant &&\n+      rhs.GetType() == SymbolicExprType::kConstant) {\n+    return ctx->CreateConstant(lhs.GetValue() * rhs.GetValue());\n+  }\n+\n+  // Commutativity: C * X => X * C\n+  if (lhs.GetType() == SymbolicExprType::kConstant) {\n+    std::swap(lhs, rhs);\n+  }\n+\n+  // Neutral Elements\n+  if (rhs.GetType() == SymbolicExprType::kConstant) {\n+    if (rhs.GetValue() == 0) {\n+      return rhs;  // x * 0 = 0\n+    }\n+    if (rhs.GetValue() == 1) {\n+      return lhs;  // x * 1 = x\n+    }\n+  }\n+\n+  // Associativity: (X * C1) * C2 => X * (C1 * C2)\n+  if (lhs.GetType() == SymbolicExprType::kMul &&\n+      lhs.GetRHS().GetType() == SymbolicExprType::kConstant &&\n+      rhs.GetType() == SymbolicExprType::kConstant) {\n+    return (lhs.GetLHS() * (lhs.GetRHS().GetValue() * rhs.GetValue()))\n+        .Canonicalize();\n+  }\n+\n+  // Distribute Mul over Add: (A + B) * C => (A * C) + (B * C)\n+  if (lhs.GetType() == SymbolicExprType::kAdd) {\n+    return ((lhs.GetLHS() * rhs) + (lhs.GetRHS() * rhs)).Canonicalize();\n+  }\n+  if (rhs.GetType() == SymbolicExprType::kAdd) {\n+    return ((lhs * rhs.GetLHS()) + (lhs * rhs.GetRHS())).Canonicalize();\n+  }\n+\n+  SymbolicExpr res_lhs = lhs, res_rhs = rhs;\n+  if (res_rhs < res_lhs) {\n+    std::swap(res_lhs, res_rhs);\n+  }\n+  return ctx->CreateBinaryOp(SymbolicExprType::kMul, res_lhs, res_rhs);\n+}\n+\n }  // namespace\n \n class SymbolicExprStorage : public mlir::StorageUniquer::BaseStorage {\n@@ -245,6 +387,37 @@ SymbolicExpr SymbolicExpr::GetRHS() const { return impl_->rhs_; }\n \n int64_t SymbolicExpr::GetValue() const { return impl_->value_; }\n \n+bool SymbolicExpr::operator<(const SymbolicExpr& other) const {\n+  CHECK(*this && other);\n+  SymbolicExprType lhs_type = GetType();\n+  SymbolicExprType rhs_type = other.GetType();\n+\n+  const bool lhs_is_const = (lhs_type == SymbolicExprType::kConstant);\n+  const bool rhs_is_const = (rhs_type == SymbolicExprType::kConstant);\n+  if (lhs_is_const != rhs_is_const) {\n+    // Non-constants come before constants.\n+    return rhs_is_const;\n+  }\n+\n+  if (lhs_type != rhs_type) {\n+    return lhs_type < rhs_type;\n+  }\n+\n+  switch (lhs_type) {\n+    case SymbolicExprType::kVariable:\n+    case SymbolicExprType::kConstant:\n+      return GetValue() < other.GetValue();\n+    case SymbolicExprType::kAdd:\n+    case SymbolicExprType::kMul:\n+      if (GetLHS() != other.GetLHS()) {\n+        return GetLHS() < other.GetLHS();\n+      }\n+      return GetRHS() < other.GetRHS();\n+    default:\n+      return GetImpl() < other.GetImpl();\n+  }\n+}\n+\n std::string SymbolicExpr::ToString() const {\n   switch (GetType()) {\n     case SymbolicExprType::kConstant:\n@@ -340,8 +513,26 @@ SymbolicExpr SymbolicExpr::ReplaceVariables(\n   }\n }\n \n-// TODO(b/433697083): Implement canonicalization.\n-SymbolicExpr SymbolicExpr::Canonicalize() const { return *this; }\n+SymbolicExpr SymbolicExpr::Canonicalize() const {\n+  if (!*this) {\n+    return *this;\n+  }\n+\n+  switch (GetType()) {\n+    case SymbolicExprType::kConstant:\n+    case SymbolicExprType::kVariable:\n+      return *this;\n+    case SymbolicExprType::kAdd:\n+      return CanonicalizeAdd(this->GetLHS().Canonicalize(),\n+                             this->GetRHS().Canonicalize());\n+    case SymbolicExprType::kMul:\n+      return CanonicalizeMul(this->GetLHS().Canonicalize(),\n+                             this->GetRHS().Canonicalize());\n+    default:\n+      // TODO(b/433693793): Implement canonicalization for other types.\n+      return *this;\n+  }\n+}\n \n SymbolicExpr SymbolicExpr::operator+(int64_t v) const {\n   return *this + GetContext()->CreateConstant(v);"
        },
        {
            "sha": "4ada56603fdc2b809be2d4c1ae605320e123ca79",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h?ref=bcff4467d24a9e16ed400c098f0c2f6f9465c8b4",
            "patch": "@@ -58,6 +58,7 @@ class SymbolicExpr {\n   bool operator!() const { return impl_ == nullptr; }\n   bool operator==(SymbolicExpr other) const { return impl_ == other.impl_; }\n   bool operator!=(SymbolicExpr other) const { return !(*this == other); }\n+  bool operator<(const SymbolicExpr& other) const;\n \n   SymbolicExprContext* GetContext() const;\n   SymbolicExprType GetType() const;"
        },
        {
            "sha": "a135066c601b4325e8bfc3240d0847d80200ad68",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bcff4467d24a9e16ed400c098f0c2f6f9465c8b4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc?ref=bcff4467d24a9e16ed400c098f0c2f6f9465c8b4",
            "patch": "@@ -124,18 +124,21 @@ TEST_F(SymbolicExprTest, UniquingWorks) {\n   EXPECT_NE(add1, add3);\n }\n \n-TEST_F(SymbolicExprTest, DISABLED_Canonicalization) {\n+TEST_F(SymbolicExprTest, Canonicalization) {\n   SymbolicExpr constants = (c2 * 3) + 5;\n   EXPECT_EQ(constants.Canonicalize().ToString(), \"11\");\n \n+  SymbolicExpr add_commutativity = c2 + v0;\n+  EXPECT_EQ(add_commutativity.Canonicalize().ToString(), \"(v0 + 2)\");\n+\n   SymbolicExpr neutral_element = (v0 + 0) * 1 + (v1 * 0);\n   EXPECT_EQ(neutral_element.Canonicalize().ToString(), \"v0\");\n \n-  SymbolicExpr add_associativity = (v0 + 2) + 3;\n-  EXPECT_EQ(add_associativity.Canonicalize().ToString(), \"(v0 + 5)\");\n+  SymbolicExpr add_combining_constants = (c2 + v0) + 3;\n+  EXPECT_EQ(add_combining_constants.Canonicalize().ToString(), \"(v0 + 5)\");\n \n-  SymbolicExpr add_commutativity = c2 + v0;\n-  EXPECT_EQ(add_commutativity.Canonicalize().ToString(), \"(v0 + 2)\");\n+  SymbolicExpr mul_combining_constants = (c2 * v0) * 3;\n+  EXPECT_EQ(mul_combining_constants.Canonicalize().ToString(), \"(v0 * 6)\");\n \n   SymbolicExpr combination = (v0 * 3) + (v0 * 2);\n   EXPECT_EQ(combination.Canonicalize().ToString(), \"(v0 * 5)\");\n@@ -164,6 +167,11 @@ TEST_F(SymbolicExprTest, DISABLED_Canonicalization) {\n   EXPECT_EQ(complex_expression.Canonicalize().ToString(),\n             \"(((v0 * 3) + (v1 * -1)) + 5)\");\n \n+  SymbolicExpr nested_dist = (c2 * (v0 + 1) + 3) * 4;\n+  EXPECT_EQ(nested_dist.Canonicalize().ToString(), \"((v0 * 8) + 20)\");\n+}\n+\n+TEST_F(SymbolicExprTest, DISABLED_Canonicalization_MinMaxDiv) {\n   // Min - Max\n   EXPECT_EQ((c2.min(5) + c2.max(7)).Canonicalize().ToString(), \"9\");\n   EXPECT_EQ((v0.max(v0)).Canonicalize().ToString(), \"v0\");"
        }
    ],
    "stats": {
        "total": 217,
        "additions": 209,
        "deletions": 8
    }
}