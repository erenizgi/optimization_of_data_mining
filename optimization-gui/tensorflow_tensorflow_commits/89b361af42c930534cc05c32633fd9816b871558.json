{
    "author": "deepikarajani24",
    "message": "PR #31097: Add HNS Rename folder and storage layout API\n\nImported from GitHub PR https://github.com/openxla/xla/pull/31097\n\nüìù Summary of Changes\nAdding rename folder API for HNS bucket in the existing rename method. In order to identify if bucket is HNS enabled using storage layout api\n\nüéØ Justification\nRename on HSN bucekt without this new API involves slow copy of every object and subfolders. This is an efficient, fast atomic operation which customers can use in their checkpointing workload\n\nüöÄ Kind of Contribution\nPlease remove what does not apply: üêõ Bug Fix, ‚ö°Ô∏è Performance Improvement,\n‚ú® New Feature, üß™ Tests\n\nüìä Benchmark (for Performance Improvements)\nN/A. This PR is a filesystem enhancement (improving GCS HNS rename operations) and does not directly affect the computational performance or compilation time of the HLO benchmarks.\n\nüß™ Unit Tests:\nWhat unit tests were added? For example, a new pass should be tested on minimal\nHLO. The transformation can be tested with FileCheck tests or assertions on the\ntransformed HLO.\nN/A for the HLO examples, as this is a C++ filesystem change.\nUnit tests were added to gcs_file_system_test.cc to validate the new rename logic and its fallbacks:\n- The successful HNS rename path, including multi-poll LRO logic.\n- Correct parsing of JSON error responses from the LRO.\n- The critical fallback to the legacy copy/delete logic for non-HNS buckets.\n\nüß™ Execution Tests:\nWhat execution tests were added? For example, a new optimization should be\ntested with an end-to-end execution test triggering the optimization and\nasserting correctness. Please provide test cases running with at most 2 GPUs.\nN/A\n\nCopybara import of the project:\n\n--\n2e7ffed187e8aa00407d2c80f65334357cc193ff by Deepika Rajani <deepikarajani@google.com>:\n\nadd rename folder HNS API support in existing rename API\n\n--\n6a5985d6103943b6e3be3776b246e5aef22dca0c by Deepika Rajani <deepikarajani@google.com>:\n\nAdd storage layout API to indentify if bucekt is HNS enabled\n\n--\n247ef65a78d6a6cdc39ab54671cb6e58ccb7167b by Deepika Rajani <deepikarajani@google.com>:\n\nformatted the code with clang-format\n\n--\n0030e58bdd03895504bc9b21eabe148986b5f411 by Deepika Rajani <deepikarajani@google.com>:\n\nFix clang tidy issues in gcs_file_system.cc\n\n--\n9e945e23d812d18331544a0b6d5e28769562c72e by Deepika Rajani <deepikarajani@google.com>:\n\nfix clang-tidy warnings\n\nMerging this change closes #31097\n\nPiperOrigin-RevId: 811244008",
    "sha": "89b361af42c930534cc05c32633fd9816b871558",
    "files": [
        {
            "sha": "65eebbcd5b991472684a4e98e379371cd6ccdfe4",
            "filename": "third_party/xla/xla/tsl/platform/cloud/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2FBUILD?ref=89b361af42c930534cc05c32633fd9816b871558",
            "patch": "@@ -133,6 +133,7 @@ cc_library(\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/time\",\n         \"@jsoncpp_git//:jsoncpp\",\n         \"@local_tsl//tsl/platform:numbers\",\n         \"@local_tsl//tsl/platform:path\",\n@@ -395,7 +396,7 @@ tsl_cc_test(\n \n tsl_cc_test(\n     name = \"gcs_file_system_test\",\n-    size = \"small\",\n+    size = \"medium\",\n     srcs = [\"gcs_file_system_test.cc\"],\n     deps = [\n         \":gcs_file_system\",\n@@ -406,6 +407,7 @@ tsl_cc_test(\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/profiler/backends/cpu:traceme_recorder_impl\",\n         \"//xla/tsl/profiler/utils:time_utils_impl\",\n+        \"@com_google_absl//absl/status\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@local_tsl//tsl/platform:str_util\",\n         \"@local_tsl//tsl/platform:strcat\","
        },
        {
            "sha": "b6b53799e0839c99f59bb17945f83a35a4688b85",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_file_system.cc",
            "status": "modified",
            "additions": 182,
            "deletions": 1,
            "changes": 183,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.cc?ref=89b361af42c930534cc05c32633fd9816b871558",
            "patch": "@@ -22,6 +22,8 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n #include \"tsl/platform/retrying_file_system.h\"\n \n #ifndef _WIN32\n@@ -103,6 +105,11 @@ constexpr size_t kMatchingPathsCacheDefaultMaxEntries = 1024;\n // Number of bucket locations cached, most workloads wont touch more than one\n // bucket so this limit is set fairly low\n constexpr size_t kBucketLocationCacheMaxEntries = 10;\n+// Number of bucket storage layout cached, most workloads wont touch more than\n+// one bucket so this limit is set fairly low\n+constexpr size_t kStorageLayoutCacheMaxEntries = 10;\n+// LRUCache that has 30 mins expiration.\n+constexpr uint64 kStorageLayoutCacheMaxAgeSecs = 30 * 60;\n // ExpiringLRUCache doesnt support any \"cache forever\" option\n constexpr size_t kCacheNeverExpire = std::numeric_limits<uint64>::max();\n // The file statistics returned by Stat() for directories.\n@@ -891,6 +898,9 @@ GcsFileSystem::GcsFileSystem(bool make_default_cache,\n   bucket_location_cache_.reset(new ExpiringLRUCache<string>(\n       kCacheNeverExpire, kBucketLocationCacheMaxEntries));\n \n+  storage_layout_cache_ = std::make_unique<ExpiringLRUCache<Json::Value>>(\n+      kStorageLayoutCacheMaxAgeSecs, kStorageLayoutCacheMaxEntries);\n+\n   int64_t resolve_frequency_secs;\n   if (GetEnvVar(kResolveCacheSecs, strings::safe_strto64,\n                 &resolve_frequency_secs)) {\n@@ -1008,6 +1018,8 @@ GcsFileSystem::GcsFileSystem(\n           matching_paths_cache_max_age, matching_paths_cache_max_entries)),\n       bucket_location_cache_(new BucketLocationCache(\n           kCacheNeverExpire, kBucketLocationCacheMaxEntries)),\n+      storage_layout_cache_(new StorageLayoutCache(\n+          kStorageLayoutCacheMaxAgeSecs, kStorageLayoutCacheMaxEntries)),\n       allowed_locations_(allowed_locations),\n       compose_append_(compose_append),\n       additional_header_(additional_header) {}\n@@ -1653,6 +1665,58 @@ absl::Status GcsFileSystem::GetBucketMetadata(\n   return request->Send();\n }\n \n+absl::Status GcsFileSystem::GetStorageLayout(const string& bucket,\n+                                             std::vector<char>* result_buffer) {\n+  std::unique_ptr<HttpRequest> request;\n+  TF_RETURN_IF_ERROR(CreateHttpRequest(&request));\n+\n+  request->SetUri(absl::StrCat(kGcsUriBase, \"b/\", bucket, \"/storageLayout\"));\n+\n+  if (result_buffer != nullptr) {\n+    request->SetResultBuffer(result_buffer);\n+  }\n+\n+  request->SetTimeouts(timeouts_.connect, timeouts_.idle, timeouts_.metadata);\n+  return request->Send();\n+}\n+\n+absl::Status GcsFileSystem::ParseIsHnsEnabled(\n+    const Json::Value& storage_layout_json, bool* is_hns) {\n+  *is_hns = false;\n+  const auto hns_node =\n+      storage_layout_json.get(\"hierarchicalNamespace\", Json::Value::null);\n+\n+  if (!hns_node.isNull() && hns_node.isObject()) {\n+    bool enabled = false;\n+    if (hns_node.isMember(\"enabled\")) {\n+      TF_RETURN_IF_ERROR(GetBoolValue(hns_node, \"enabled\", &enabled));\n+\n+      *is_hns = enabled;\n+    }\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status GcsFileSystem::IsBucketHnsEnabled(const string& bucket,\n+                                               bool* is_hns) {\n+  Json::Value storage_layout;\n+\n+  auto compute_func = [this](const string& bucket, Json::Value* layout_json) {\n+    std::vector<char> layout_buffer;\n+    absl::Status layout_status = GetStorageLayout(bucket, &layout_buffer);\n+    if (!layout_status.ok()) {\n+      return layout_status;  // Propagate all errors.\n+    }\n+    return ParseJson(layout_buffer, layout_json);\n+  };\n+\n+  // Look up the full JSON object in the new cache.\n+  TF_RETURN_IF_ERROR(storage_layout_cache_->LookupOrCompute(\n+      bucket, &storage_layout, compute_func));\n+\n+  return ParseIsHnsEnabled(storage_layout, is_hns);\n+}\n+\n absl::Status GcsFileSystem::FolderExists(const string& dirname, bool* result) {\n   StatCache::ComputeFunc compute_func = [this](const string& dirname,\n                                                GcsFileStat* stat) {\n@@ -1994,7 +2058,29 @@ absl::Status GcsFileSystem::RenameFile(const string& src, const string& target,\n   if (!IsDirectory(src, token).ok()) {\n     return RenameObject(src, target);\n   }\n-  // Rename all individual objects in the directory one by one.\n+\n+  // It's a directory. Parse both source and target to check the buckets.\n+  string src_bucket, src_object;\n+  TF_RETURN_IF_ERROR(ParseGcsPath(src, true, &src_bucket, &src_object));\n+\n+  string target_bucket, target_object;\n+  TF_RETURN_IF_ERROR(\n+      ParseGcsPath(target, true, &target_bucket, &target_object));\n+\n+  // If buckets are the same, we can check for HNS and use the fast rename API.\n+  if (src_bucket == target_bucket) {\n+    bool hns_enabled = false;\n+    TF_RETURN_IF_ERROR(IsBucketHnsEnabled(src_bucket, &hns_enabled));\n+\n+    if (hns_enabled) {\n+      return RenameFolderHns(src, target);\n+    }\n+  }\n+\n+  // FALLBACK: Use the iterative rename in two cases:\n+  // 1. The buckets are different (cross-bucket rename).\n+  // 2. The buckets are the same, but HNS is not enabled.\n+  VLOG(1) << \"Falling back to iterative rename for directory \" << src;\n   std::vector<string> children;\n   TF_RETURN_IF_ERROR(\n       GetChildrenBounded(src, UINT64_MAX, &children, true /* recursively */,\n@@ -2122,6 +2208,100 @@ absl::Status GcsFileSystem::DeleteRecursively(const string& dirname,\n   return absl::OkStatus();\n }\n \n+absl::Status GcsFileSystem::RenameFolderHns(const string& src,\n+                                            const string& target) {\n+  VLOG(1) << \"GcsFileSystem::RenameFolderHns invoked. From: '\" << src\n+          << \"' to: '\" << target << \"'\";\n+\n+  string src_bucket, src_object, target_bucket, target_object;\n+  TF_RETURN_IF_ERROR(ParseGcsPath(src, false, &src_bucket, &src_object));\n+  TF_RETURN_IF_ERROR(\n+      ParseGcsPath(target, false, &target_bucket, &target_object));\n+\n+  std::unique_ptr<HttpRequest> request;\n+  TF_RETURN_IF_ERROR(CreateHttpRequest(&request));\n+\n+  const std::string uri_to_send =\n+      absl::StrCat(kGcsUriBase, \"b/\", src_bucket, \"/folders/\",\n+                   request->EscapeString(src_object), \"/renameTo/folders/\",\n+                   request->EscapeString(target_object));\n+\n+  request->SetUri(uri_to_send);\n+  request->SetPostEmptyBody();\n+  request->SetTimeouts(timeouts_.connect, timeouts_.idle, timeouts_.metadata);\n+  std::vector<char> output_buffer;\n+  request->SetResultBuffer(&output_buffer);\n+\n+  VLOG(2) << \"Sending rename folder request to URI: \" << uri_to_send;\n+\n+  TF_RETURN_WITH_CONTEXT_IF_ERROR(request->Send(),\n+                                  \" when initiating rename for folder \", src);\n+\n+  // Parse the long-running operation object from the response.\n+  Json::Value operation_response;\n+  TF_RETURN_IF_ERROR(ParseJson(output_buffer, &operation_response));\n+\n+  bool done = false;\n+  if (operation_response.isMember(\"done\")) {\n+    TF_RETURN_IF_ERROR(GetBoolValue(operation_response, \"done\", &done));\n+    if (done) {\n+      if (operation_response.isMember(\"error\")) {\n+        return errors::Internal(\"RenameFolderHns for '\", src,\n+                                \"' failed immediately with an error: \",\n+                                operation_response[\"error\"].toStyledString());\n+      }\n+      VLOG(1) << \"RenameFolderHns finished immediately for \" << src;\n+      return absl::OkStatus();\n+    }\n+  }\n+\n+  std::string operation_name;\n+  TF_RETURN_IF_ERROR(\n+      GetStringValue(operation_response, \"name\", &operation_name));\n+\n+  absl::string_view operation_id = io::Basename(operation_name);\n+\n+  VLOG(2) << \"RenameFolderHns: polling operation ID '\" << operation_id << \"'\";\n+\n+  const absl::Duration kPollingInterval = absl::Seconds(20);\n+\n+  while (true) {\n+    absl::SleepFor(kPollingInterval);\n+    std::unique_ptr<HttpRequest> poll_request;\n+    TF_RETURN_IF_ERROR(CreateHttpRequest(&poll_request));\n+\n+    poll_request->SetUri(absl::StrCat(kGcsUriBase, \"b/\", src_bucket,\n+                                      \"/operations/\", operation_id));\n+    poll_request->SetTimeouts(timeouts_.connect, timeouts_.idle,\n+                              timeouts_.metadata);\n+    std::vector<char> poll_output_buffer;\n+    poll_request->SetResultBuffer(&poll_output_buffer);\n+\n+    TF_RETURN_WITH_CONTEXT_IF_ERROR(poll_request->Send(),\n+                                    \" when polling operation \", operation_id);\n+\n+    TF_RETURN_IF_ERROR(ParseJson(poll_output_buffer, &operation_response));\n+\n+    if (operation_response.isMember(\"error\")) {\n+      return errors::Internal(\"RenameFolderHns for '\", src,\n+                              \"' failed with an error: \",\n+                              operation_response[\"error\"].toStyledString());\n+    }\n+\n+    if (operation_response.isMember(\"done\")) {\n+      bool done = false;\n+      TF_RETURN_IF_ERROR(GetBoolValue(operation_response, \"done\", &done));\n+      if (done) {\n+        break;\n+      }\n+    }\n+    VLOG(3) << \"Polling rename folder operation...\";\n+  }\n+\n+  VLOG(1) << \"RenameFolderHns: finished successfully for \" << src;\n+  return absl::OkStatus();\n+}\n+\n // Flushes all caches for filesystem metadata and file contents. Useful for\n // reclaiming memory once filesystem operations are done (e.g. model is loaded),\n // or for resetting the filesystem to a consistent state.\n@@ -2131,6 +2311,7 @@ void GcsFileSystem::FlushCaches(TransactionToken* token) {\n   stat_cache_->Clear();\n   matching_paths_cache_->Clear();\n   bucket_location_cache_->Clear();\n+  storage_layout_cache_->Clear();\n }\n \n void GcsFileSystem::SetStats(GcsStatsInterface* stats) {"
        },
        {
            "sha": "b8c52c18ea1b4824b16bb74c06a1dfa0a3168502",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_file_system.h",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.h?ref=89b361af42c930534cc05c32633fd9816b871558",
            "patch": "@@ -23,6 +23,7 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/synchronization/mutex.h\"\n+#include \"json/json.h\"\n #include \"xla/tsl/platform/cloud/auth_provider.h\"\n #include \"xla/tsl/platform/cloud/compute_engine_metadata_client.h\"\n #include \"xla/tsl/platform/cloud/compute_engine_zone_provider.h\"\n@@ -202,6 +203,8 @@ class GcsFileSystem : public FileSystem {\n   absl::Status GetFileSize(const string& fname, TransactionToken* token,\n                            uint64* file_size) override;\n \n+  absl::Status IsBucketHnsEnabled(const string& bucket, bool* is_hns);\n+\n   absl::Status RenameFile(const string& src, const string& target,\n                           TransactionToken* token) override;\n \n@@ -398,6 +401,20 @@ class GcsFileSystem : public FileSystem {\n   absl::Status GetBucketMetadata(const string& bucket,\n                                  std::vector<char>* result_buffer);\n \n+  /// \\brief Retrieves the `storageLayout` metadata for a given GCS bucket.\n+  /// The raw JSON response is stored in `result_buffer`.\n+  absl::Status GetStorageLayout(const string& bucket,\n+                                std::vector<char>* result_buffer);\n+\n+  /// \\brief Parses the `storageLayout` JSON to determine if HNS is enabled.\n+  /// Sets the `is_hns` output parameter to the result.\n+  absl::Status ParseIsHnsEnabled(const Json::Value& storage_layout_json,\n+                                 bool* is_hns);\n+\n+  /// \\brief Renames a folder on an HNS-enabled bucket using a fast, server-side\n+  /// GCS API. This function polls the long-running operation for completion.\n+  absl::Status RenameFolderHns(const string& src, const string& target);\n+\n   /// \\brief Checks if the object exists. Returns OK if the check succeeded.\n   ///\n   /// 'result' is set if the function returns OK. 'result' cannot be nullptr.\n@@ -460,6 +477,10 @@ class GcsFileSystem : public FileSystem {\n \n   using BucketLocationCache = ExpiringLRUCache<string>;\n   std::unique_ptr<BucketLocationCache> bucket_location_cache_;\n+\n+  using StorageLayoutCache = ExpiringLRUCache<Json::Value>;\n+  std::unique_ptr<StorageLayoutCache> storage_layout_cache_;\n+\n   std::unordered_set<string> allowed_locations_;\n   bool compose_append_;\n "
        },
        {
            "sha": "b21fc239e055d3c35a36adfcbf9f5fe7e679f5cf",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_file_system_test.cc",
            "status": "modified",
            "additions": 314,
            "deletions": 1,
            "changes": 315,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89b361af42c930534cc05c32633fd9816b871558/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system_test.cc?ref=89b361af42c930534cc05c32633fd9816b871558",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n \n #include <fstream>\n \n+#include \"absl/status/status.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/cloud/http_request_fake.h\"\n #include \"xla/tsl/platform/errors.h\"\n@@ -2495,7 +2496,12 @@ TEST(GcsFileSystemTest, RenameFile_Folder) {\n            \"Timeouts: 5 1 10\\n\",\n            \"{\\\"items\\\": [ \"\n            \"  { \\\"name\\\": \\\"path1/subfolder/file1.txt\\\" }]}\"),\n-       // Requesting the full list of files in the folder.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/storageLayout\\n\"\n+           \"Auth Token: fake_token\\nTimeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"bucket\"})\"),  // No \"hierarchicalNamespace\" field\n+                                      // Requesting the full list of files in\n+                                      // the folder.\n        new FakeHttpRequest(\n            \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n            \"fields=items%2Fname%2CnextPageToken&prefix=path1%2F\\n\"\n@@ -2569,6 +2575,237 @@ TEST(GcsFileSystemTest, RenameFile_Folder) {\n       fs.RenameFile(\"gs://bucket/path1\", \"gs://bucket/path2/\", nullptr));\n }\n \n+TEST(GcsFileSystemTest, RenameFile_HnsFolder) {\n+  std::vector<HttpRequest*> requests(\n+      {// 1. Mock the IsDirectory() check.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n+           \"fields=items%2Fname%2CnextPageToken&prefix=path1%2F&maxResults=1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"items\": [{\"name\": \"path1/some_file.txt\"}]})\"),\n+\n+       // 2. Mock the IsHnsEnabled() check. The response contain the\n+       // `hierarchicalNamespace` object.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/storageLayout\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"hierarchicalNamespace\": {\"enabled\": true}})\"),\n+\n+       // 3. Mock the initial POST request for the fast RenameFolderHns API.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/folders/\"\n+           \"path1%2F/renameTo/folders/path2%2F\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Post: yes\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/hns-rename-op\"})\"),\n+\n+       // 4. Mock the polling GET request for the long-running operation.\n+       new FakeHttpRequest(\"Uri: \"\n+                           \"https://www.googleapis.com/storage/v1/b/bucket/\"\n+                           \"operations/hns-rename-op\\n\"\n+                           \"Auth Token: fake_token\\n\"\n+                           \"Timeouts: 5 1 10\\n\",\n+                           R\"({\"done\": true})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 16, 64, 0, 3600, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  TF_EXPECT_OK(\n+      fs.RenameFile(\"gs://bucket/path1/\", \"gs://bucket/path2/\", nullptr));\n+}\n+\n+TEST(GcsFileSystemTest, RenameFile_NonHnsBucket_Fallback) {\n+  std::vector<HttpRequest*> requests(\n+      {// 1. Mock the IsDirectory() check.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n+           \"fields=items%2Fname%2CnextPageToken&prefix=folder%2F&maxResults=1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"items\": [{\"name\": \"folder/file1.txt\"}]})\"),\n+\n+       // 2. Mock the IsBucketHnsEnabled() check via the new storageLayout\n+       // endpoint.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/storageLayout\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"bucket\"})\"),  // No \"hierarchicalNamespace\" field\n+\n+       // 3. Mock the GetChildren() call for the iterative fallback.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n+           \"fields=items%2Fname%2CnextPageToken&prefix=folder%2F\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"items\": [{\"name\": \"folder/file1.txt\"}]})\"),\n+\n+       // 4. Mock the RenameObject (copy + delete) for the child object.\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o/\"\n+           \"folder%2Ffile1.txt/rewriteTo/b/bucket/o/new_folder%2Ffile1.txt\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Post: yes\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"done\": true})\"),\n+       new FakeHttpRequest(\"Uri: \"\n+                           \"https://www.googleapis.com/storage/v1/b/bucket/o/\"\n+                           \"folder%2Ffile1.txt\\n\"\n+                           \"Auth Token: fake_token\\n\"\n+                           \"Timeouts: 5 1 10\\n\"\n+                           \"Delete: yes\\n\",\n+                           \"\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 16, 64, 0, 3600, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  TF_EXPECT_OK(\n+      fs.RenameFile(\"gs://bucket/folder/\", \"gs://bucket/new_folder/\", nullptr));\n+}\n+\n+TEST(GcsFileSystemTest, RenameFile_HnsFolder_Success) {\n+  std::vector<HttpRequest*> requests(\n+      {new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n+           \"fields=items%2Fname%2CnextPageToken&prefix=path%2Fsource-folder%2F&\"\n+           \"maxResults=1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"items\": [{\"name\": \"path/source-folder/file.txt\"}]})\"),\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/storageLayout\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"hierarchicalNamespace\": {\"enabled\": true}})\"),\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/folders/\"\n+           \"path%2Fsource-folder%2F/renameTo/folders/path%2Fdest-folder%2F\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Post: yes\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/rename-op-12345\"})\"),\n+       new FakeHttpRequest(\n+           \"Uri: \"\n+           \"https://www.googleapis.com/storage/v1/b/bucket/operations/\"\n+           \"rename-op-12345\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"operations/rename-op-12345\", \"done\": true})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 16, 64, 0, 3600, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  TF_EXPECT_OK(fs.RenameFile(\"gs://bucket/path/source-folder/\",\n+                             \"gs://bucket/path/dest-folder/\", nullptr));\n+}\n+\n+TEST(GcsFileSystemTest, RenameFile_HnsFolder_SucceedsOnSecondPoll) {\n+  std::vector<HttpRequest*> requests(\n+      {new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n+           \"fields=items%2Fname%2CnextPageToken&prefix=path%2Fsource%2F&\"\n+           \"maxResults=1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"items\": [{\"name\": \"path/source/file.txt\"}]})\"),\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/storageLayout\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"hierarchicalNamespace\": {\"enabled\": true}})\"),\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/folders/\"\n+           \"path%2Fsource%2F/renameTo/folders/path%2Fdest%2F\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Post: yes\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/hns-op-1\"})\"),\n+       new FakeHttpRequest(\n+           \"Uri: \"\n+           \"https://www.googleapis.com/storage/v1/b/bucket/operations/\"\n+           \"hns-op-1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/hns-op-1\", \"done\": false})\"),\n+       new FakeHttpRequest(\n+           \"Uri: \"\n+           \"https://www.googleapis.com/storage/v1/b/bucket/operations/\"\n+           \"hns-op-1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/hns-op-1\", \"done\": true})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 16, 64, 0, 3600, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  TF_EXPECT_OK(fs.RenameFile(\"gs://bucket/path/source/\",\n+                             \"gs://bucket/path/dest/\", nullptr));\n+}\n+\n+TEST(GcsFileSystemTest, RenameFile_HnsFolder_FailsDuringPolling) {\n+  std::vector<HttpRequest*> requests(\n+      {new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o?\"\n+           \"fields=items%2Fname%2CnextPageToken&prefix=path%2Fsource%2F&\"\n+           \"maxResults=1\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"items\": [{\"name\": \"path/source/file.txt\"}]})\"),\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/storageLayout\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"hierarchicalNamespace\": {\"enabled\": true}})\"),\n+       new FakeHttpRequest(\n+           \"Uri: https://www.googleapis.com/storage/v1/b/bucket/folders/\"\n+           \"path%2Fsource%2F/renameTo/folders/path%2Fdest%2F\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Post: yes\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/hns-op-2\"})\"),\n+       new FakeHttpRequest(\n+           \"Uri: \"\n+           \"https://www.googleapis.com/storage/v1/b/bucket/operations/\"\n+           \"hns-op-2\\n\"\n+           \"Auth Token: fake_token\\n\"\n+           \"Timeouts: 5 1 10\\n\",\n+           R\"({\"name\": \"projects/_/buckets/bucket/operations/hns-op-2\", \"done\": true,\n+              \"error\": {\"code\": 13, \"message\": \"An internal error occurred.\"}})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 16, 64, 0, 3600, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  auto status = fs.RenameFile(\"gs://bucket/path/source/\",\n+                              \"gs://bucket/path/dest/\", nullptr);\n+\n+  EXPECT_EQ(status.code(), absl::StatusCode::kInternal);\n+  EXPECT_THAT(status.message(),\n+              ::testing::HasSubstr(\"An internal error occurred.\"));\n+}\n+\n TEST(GcsFileSystemTest, RenameFile_Object) {\n   std::vector<HttpRequest*> requests(\n       {new FakeHttpRequest(\n@@ -2856,6 +3093,82 @@ TEST(GcsFileSystemTest, RenameFile_Object_Incomplete) {\n       \"gs://bucket/path/src.txt\", \"gs://bucket/path/dst.txt\", nullptr)));\n }\n \n+TEST(GcsFileSystemTest, IsBucketHnsEnabled_ReturnsTrueForHnsEnabledBucket) {\n+  std::vector<HttpRequest*> requests({new FakeHttpRequest(\n+      \"Uri: https://www.googleapis.com/storage/v1/b/hns-bucket/storageLayout\\n\"\n+      \"Auth Token: fake_token\\n\"\n+      \"Timeouts: 5 1 10\\n\",\n+      R\"({\"hierarchicalNamespace\": {\"enabled\": true}})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 0, 0, 0, 0, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  bool is_hns = false;\n+  absl::Status status = fs.IsBucketHnsEnabled(\"hns-bucket\", &is_hns);\n+\n+  // ASSERT: The call should succeed and return true.\n+  TF_EXPECT_OK(status);\n+  EXPECT_TRUE(is_hns);\n+}\n+\n+TEST(GcsFileSystemTest, IsBucketHnsEnabled_ReturnsFalseForFlatBucket) {\n+  std::vector<HttpRequest*> requests({new FakeHttpRequest(\n+      \"Uri: https://www.googleapis.com/storage/v1/b/flat-bucket/storageLayout\\n\"\n+      \"Auth Token: fake_token\\n\"\n+      \"Timeouts: 5 1 10\\n\",\n+      R\"({\"name\": \"flat-bucket\"})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 0, 0, 0, 0, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  bool is_hns = true;  // Start with true to ensure it's set to false.\n+\n+  absl::Status status = fs.IsBucketHnsEnabled(\"flat-bucket\", &is_hns);\n+\n+  // ASSERT: The call should succeed and return false.\n+  TF_EXPECT_OK(status);\n+  EXPECT_FALSE(is_hns);\n+}\n+\n+TEST(GcsFileSystemTest, IsBucketHnsEnabled_UsesCacheOnSecondCall) {\n+  // Provide only ONE mock request. If a second network call is made,\n+  // the test will fail.\n+  std::vector<HttpRequest*> requests({new FakeHttpRequest(\n+      \"Uri: \"\n+      \"https://www.googleapis.com/storage/v1/b/cached-bucket/storageLayout\\n\"\n+      \"Auth Token: fake_token\\n\"\n+      \"Timeouts: 5 1 10\\n\",\n+      R\"({\"hierarchicalNamespace\": {\"enabled\": true}})\")});\n+\n+  GcsFileSystem fs(std::unique_ptr<AuthProvider>(new FakeAuthProvider),\n+                   std::unique_ptr<HttpRequest::Factory>(\n+                       new FakeHttpRequestFactory(&requests)),\n+                   nullptr, 0, 0, 0, 0, 0, 0, 0, kTestRetryConfig,\n+                   kTestTimeoutConfig, *kAllowedLocationsDefault, nullptr,\n+                   false);\n+\n+  // Call the method twice.\n+  // The first call should make a network request and populate the cache.\n+  bool is_hns_first_call = false;\n+  TF_EXPECT_OK(fs.IsBucketHnsEnabled(\"cached-bucket\", &is_hns_first_call));\n+  EXPECT_TRUE(is_hns_first_call);\n+\n+  // The second call should hit the cache and not make a network request.\n+  // The FakeHttpRequestFactory will fail the test if it receives an unexpected\n+  // call.\n+  bool is_hns_second_call = false;\n+  TF_EXPECT_OK(fs.IsBucketHnsEnabled(\"cached-bucket\", &is_hns_second_call));\n+  EXPECT_TRUE(is_hns_second_call);\n+}\n+\n TEST(GcsFileSystemTest, Stat_Object) {\n   std::vector<HttpRequest*> requests({new FakeHttpRequest(\n       \"Uri: https://www.googleapis.com/storage/v1/b/bucket/o/\""
        }
    ],
    "stats": {
        "total": 523,
        "additions": 520,
        "deletions": 3
    }
}