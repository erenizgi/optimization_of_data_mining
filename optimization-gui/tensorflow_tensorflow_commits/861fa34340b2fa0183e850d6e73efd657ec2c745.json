{
    "author": "bchetioui",
    "message": "[XLA]Â Move `TilingSpecification` and `Tiling` from `symbolic_tile_analysis.{cc,h}` to `tiled_specification.{cc,h}`.\n\nWe likewise move the tests.\n\nThis change is necessary in order to avoid a cyclic dependency between\n`tiled_hlo_schedule` and `symbolic_tile_analysis`---since schedules depend on\n`TilingSpecification`, and `SymbolicTileAnalysis` will need to depend on\nschedules in a forthcoming change.\n\nPiperOrigin-RevId: 816663596",
    "sha": "861fa34340b2fa0183e850d6e73efd657ec2c745",
    "files": [
        {
            "sha": "4b54099de638e7a8096d755ceeb0b3916d109046",
            "filename": "third_party/xla/xla/codegen/tiling/BUILD",
            "status": "modified",
            "additions": 48,
            "deletions": 2,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -117,7 +117,7 @@ cc_library(\n     srcs = [\"tiled_hlo_schedule.cc\"],\n     hdrs = [\"tiled_hlo_schedule.h\"],\n     deps = [\n-        \":symbolic_tile_analysis\",\n+        \":tiling_specification\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n         \"//xla/hlo/ir:hlo\",\n         \"@com_google_absl//absl/algorithm:container\",\n@@ -133,8 +133,8 @@ xla_cc_test(\n     name = \"tiled_hlo_schedule_test\",\n     srcs = [\"tiled_hlo_schedule_test.cc\"],\n     deps = [\n-        \":symbolic_tile_analysis\",\n         \":tiled_hlo_schedule\",\n+        \":tiling_specification\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n         \"//xla/hlo/analysis:indexing_test_utils\",\n         \"//xla/hlo/analysis:interval\",\n@@ -289,6 +289,47 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"tiling_specification\",\n+    srcs = [\"tiling_specification.cc\"],\n+    hdrs = [\"tiling_specification.h\"],\n+    deps = [\n+        \":constraint_expression\",\n+        \":symbolic_tiled_hlo_instruction\",\n+        \":tiled_hlo_computation\",\n+        \"//xla/hlo/analysis:indexing_analysis\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/utils:hlo_traversal\",\n+        \"//xla/service:instruction_fusion\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/container:inlined_vector\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"tiling_specification_test\",\n+    srcs = [\"tiling_specification_test.cc\"],\n+    deps = [\n+        \":symbolic_tile_analysis\",\n+        \":tiling_specification\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/testlib:verified_hlo_module\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)\n+\n cc_library(\n     name = \"symbolic_tile_analysis\",\n     srcs = [\"symbolic_tile_analysis.cc\"],\n@@ -300,9 +341,11 @@ cc_library(\n         \":tiled_hlo_computation\",\n         \":tiled_hlo_fusion_instruction\",\n         \":tiled_hlo_instruction\",\n+        \":tiling_specification\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n+        \"//xla/hlo/analysis:interval\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/utils:hlo_traversal\",\n         \"//xla/service:instruction_fusion\",\n@@ -338,6 +381,8 @@ xla_cc_test(\n         \":symbolic_tiled_hlo_instruction\",\n         \":tiled_hlo_computation\",\n         \":tiled_hlo_fusion_instruction\",\n+        \":tiled_hlo_instruction\",\n+        \":tiling_specification\",\n         \"//xla:util\",\n         \"//xla/hlo/analysis:indexing_test_utils\",\n         \"//xla/hlo/ir:hlo\",\n@@ -354,6 +399,7 @@ xla_cc_test(\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\","
        },
        {
            "sha": "1d0599894c83b0d6dc4635f8f50e9d32255a183c",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 100,
            "changes": 105,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -55,11 +55,14 @@ limitations under the License.\n #include \"xla/codegen/tiling/constraint_expression.h\"\n #include \"xla/codegen/tiling/symbolic_tile.h\"\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n #include \"xla/codegen/tiling/tiled_hlo_fusion_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_analysis.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/analysis/indexing_map_serialization.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n@@ -719,27 +722,6 @@ ParameterMappingFromFusionAdaptor(const HloFusionAdaptor& fusion_adaptor,\n   return parameter_mapping;\n }\n \n-// Helper to implement `TilingSpecification::DimensionIndexForParameter`.\n-absl::StatusOr<int64_t> ParameterIndexImpl(\n-    const TilingSpecification::ParameterMapping& parameter_mapping,\n-    const HloInstruction* hlo, int64_t index) {\n-  int64_t offset = 0;\n-  for (const auto& [instruction, num_parameters] : parameter_mapping) {\n-    if (instruction == hlo) {\n-      if (index >= num_parameters) {\n-        return absl::FailedPreconditionError(absl::StrCat(\n-            \"Index \", index, \" is out of bounds for instruction \",\n-            hlo->ToString(), \" with num parameters \", num_parameters));\n-      }\n-      return offset + index;\n-    }\n-\n-    offset += num_parameters;\n-  }\n-  return absl::NotFoundError(\n-      absl::StrCat(\"No tile sizes found for instruction: \", hlo->ToString()));\n-}\n-\n // Drop instructions from a vector for which the corresponding bit in `to_drop`\n // is set. `to_drop` might be smaller than `elements` in which case the\n // remaining elements are assumed to be `false`.\n@@ -772,83 +754,6 @@ llvm::SmallVector<const TiledHloInstruction*> MapToTiledInstructions(\n \n }  // anonymous namespace\n \n-absl::StatusOr<absl::Span<const int64_t>> Tiling::TileSizesForInstruction(\n-    const HloInstruction* hlo) const {\n-  if (auto it = tile_sizes_.find(hlo); it != tile_sizes_.end()) {\n-    return it->second;\n-  }\n-\n-  return absl::NotFoundError(\n-      absl::StrCat(\"No tile sizes found for instruction: \", hlo->ToString()));\n-}\n-\n-absl::StatusOr<FlatTiling> Tiling::Flatten(\n-    const TilingSpecification& tiling_specification) const {\n-  FlatTiling flat_tile_sizes;\n-  flat_tile_sizes.reserve(tiling_specification.num_parameters());\n-  for (const auto& mapping : tiling_specification.parameter_mapping()) {\n-    TF_ASSIGN_OR_RETURN(absl::Span<const int64_t> tile_sizes,\n-                        TileSizesForInstruction(mapping.instruction));\n-    if (tile_sizes.size() != mapping.num_tiling_parameters) {\n-      return absl::FailedPreconditionError(\n-          absl::StrCat(\"Instruction \", mapping.instruction->ToString(),\n-                       \" was expected to have \", mapping.num_tiling_parameters,\n-                       \" tile sizes but had \", tile_sizes.size(), \".\"));\n-    }\n-    flat_tile_sizes.insert(flat_tile_sizes.end(), tile_sizes.begin(),\n-                           tile_sizes.end());\n-  }\n-\n-  return flat_tile_sizes;\n-}\n-\n-/*static*/ absl::StatusOr<Tiling> Tiling::Unflatten(\n-    absl::Span<const int64_t> flat_tile_sizes,\n-    const TilingSpecification& tiling_specification) {\n-  if (flat_tile_sizes.size() != tiling_specification.num_parameters()) {\n-    return absl::FailedPreconditionError(\n-        absl::StrCat(\"Expected \", tiling_specification.num_parameters(),\n-                     \" tile sizes but got \", flat_tile_sizes.size(), \".\"));\n-  }\n-\n-  TileMapping tile_mapping;\n-  int64_t offset = 0;\n-  for (const auto& [hlo, num_parameters] :\n-       tiling_specification.parameter_mapping()) {\n-    auto start_it = flat_tile_sizes.begin() + offset;\n-    auto end_it = start_it + num_parameters;\n-    tile_mapping[hlo] = {start_it, end_it};\n-    offset += num_parameters;\n-  }\n-  return Tiling(std::move(tile_mapping));\n-}\n-\n-absl::StatusOr<int64_t> TilingSpecification::ParameterIndex(\n-    const HloInstruction* hlo, int64_t index) const {\n-  return ParameterIndexImpl(parameter_mapping_, hlo, index);\n-}\n-\n-bool Tiling::ConformsTo(const TilingSpecification& tiling_specification) const {\n-  int64_t num_instructions = tile_sizes_.size();\n-  int64_t expected_num_instructions =\n-      tiling_specification.parameter_mapping().size();\n-  if (num_instructions != expected_num_instructions) {\n-    VLOG(1) << \"Tiling tiles \" << num_instructions << \" instructions, but \"\n-            << expected_num_instructions\n-            << \" instructions were expected to be \"\n-               \"tiled.\";\n-    return false;\n-  }\n-\n-  // Linearization takes care of checking that we have the right number of\n-  // tile sizes specified for each instruction.\n-  absl::StatusOr<FlatTiling> flat_tile_sizes_or = Flatten(tiling_specification);\n-  if (!flat_tile_sizes_or.ok()) {\n-    return false;\n-  }\n-\n-  return tiling_specification.constraints().IsSatisfiedBy(*flat_tile_sizes_or);\n-}\n \n // Extracts `HloInstruction`s from a span of `HloInstructionAdaptor`s.\n absl::InlinedVector<const HloInstruction*, 2> ToInstructions(\n@@ -1084,8 +989,8 @@ IndexingMap InsertTilingParameterForContractingDimensions(\n       CHECK(symbol);  // Crash OK\n       // Replace range variable at index contracting_dimension in the indexing\n       // map with the parameter at (hlo, parameter_index).\n-      absl::StatusOr<int64_t> dim_index =\n-          ParameterIndexImpl(parameter_mapping, consumer, parameter_index);\n+      absl::StatusOr<int64_t> dim_index = TilingSpecification::ParameterIndex(\n+          parameter_mapping, consumer, parameter_index);\n       // This also can only fail if our traversal logic is broken.\n       CHECK_OK(dim_index);  // Crash OK\n       parameter_index_by_symbol_position.insert("
        },
        {
            "sha": "de43bb9388472aa6c44b48365642ff60b34fb4e8",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis.h",
            "status": "modified",
            "additions": 1,
            "deletions": 169,
            "changes": 170,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.h?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -24,16 +24,15 @@ limitations under the License.\n #include <variant>\n #include <vector>\n \n-#include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/inlined_vector.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/types/span.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/constraint_expression.h\"\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n@@ -54,173 +53,6 @@ class SymbolicTileAnalysis;\n using SymbolicTileAnalysisOrError =\n     std::variant<SymbolicTileAnalysis, FusionDecision>;\n \n-// A `TilingSpecification` describes the structure of a set of expected tile\n-// sizes, by indicating how many tile sizes must be specified for each\n-// instruction within a set. When creating a `TilingSpecification` from a\n-// fusion, we're interested in finding out how many tile sizes need to be\n-// defined in aggregate in order to tile the whole fusion.\n-//\n-// To support that use case, `TilingSpecification`s derived from fusions only\n-// map instructions to the new tile sizes that they require we define. At the\n-// output of the fusion, we must define a tile size for each axis of the output;\n-// on an instruction that is not an output of the fusion, we must define a tile\n-// size iff that instruction contracts a dimension---i.e. if it introduces a new\n-// dimension to tile that is not visible at the output of the fusion. For\n-// example, take the following fusion computation:\n-//\n-//   fusion_computation {\n-//     p0 = f32[128,256] parameter(0)\n-//     p1 = f32[256,128] parameter(1)\n-//     dot = f32[128,128] dot(p0, p1),\n-//       lhs_contracting_dimensions={1}, rhs_contracting_dimensions={0}\n-//     ROOT abs = f32[128,128] abs(dot)\n-//   }.\n-//\n-// The tiling specification for this fusion would require that we define two\n-// tile sizes at the output, as well as one additional tile size for the\n-// contracting dimension introduced by the `dot` instruction. Ergo, the\n-// specification would be:\n-//   {\n-//     abs: 2\n-//     dot: 1\n-//   }\n-//\n-// The intent is for `TilingSpecification`s to be used in order to construct\n-// `Tiling`s for a fusion, with the guarantee that if the `Tiling`\n-// satisfies the `TilingSpecification`, then the `Tiling` contains exactly\n-// as many parameters as necessary to tile the whole fusion.\n-//\n-// TODO(b/419026602): reductions are ignored for now. This will need to handle\n-// them.\n-class TilingSpecification {\n- public:\n-  // Associates a number of tiling parameters to an instruction. Since there is\n-  // never any ambiguity about the ordering of tiling parameters within a single\n-  // instruction, this is sufficient information to describe both how many\n-  // tiling parameters are introduced for the given instruction, as well as\n-  // their semantics (i.e. what contracting dimension they correspond to, or\n-  // what output dimension they correspond to).\n-  struct InstructionAndNumTilingParameters {\n-    // The instruction that this `InstructionAndNumTilingParameters` is\n-    // associated with.\n-    const HloInstruction* instruction;\n-    // The number of tile sizes that must be specified for the instruction.\n-    int64_t num_tiling_parameters;\n-  };\n-\n-  // An ordered sequence of `InstructionAndNumTilingParameters`s. Since\n-  // parameter mapping within a single `InstructionAndNumTilingParameters`\n-  // is unambiguous, this abstraction provides enough information to describe\n-  // the ordering of a set of tiling parameters---e.g. for a whole fusion.\n-  using ParameterMapping = std::vector<InstructionAndNumTilingParameters>;\n-\n-  // Returns the parameter mapping for the entire fusion the specification is\n-  // derived from.\n-  //\n-  // The instructions are guaranteed to be in use-before-def order, and it is\n-  // guaranteed that an instruction will only ever appear at most once.\n-  const ParameterMapping& parameter_mapping() const {\n-    return parameter_mapping_;\n-  }\n-\n-  // Returns the constraints for the parameters of the tiling specification.\n-  const ConstraintExpression& constraints() const { return constraints_; }\n-\n-  // Given the index of a tile size parameter for the given HLO instruction,\n-  // returns its overall parameter index within the `TilingSpecification`'s\n-  // parameter mapping.\n-  absl::StatusOr<int64_t> ParameterIndex(const HloInstruction* hlo,\n-                                         int64_t index) const;\n-\n-  // Returns the total number of parameters in the tiling specification.\n-  int64_t num_parameters() const { return num_parameters_; }\n-\n- private:\n-  // `SymbolicTileAnalysis` is the only class allowed to construct\n-  // `TilingSpecification`s.\n-  friend class SymbolicTileAnalysis;\n-  explicit TilingSpecification(ParameterMapping parameter_mapping,\n-                               ConstraintExpression constraints)\n-      : parameter_mapping_(std::move(parameter_mapping)),\n-        constraints_(std::move(constraints)) {\n-    num_parameters_ = 0;\n-    for (const auto& [_, num_tiling_parameters] : parameter_mapping_) {\n-      num_parameters_ += num_tiling_parameters;\n-    }\n-  };\n-\n-  ParameterMapping parameter_mapping_;\n-  ConstraintExpression constraints_;\n-  int64_t num_parameters_;\n-};\n-\n-// A sequence of tile sizes.\n-//\n-// This is an inlined vector to avoid too many heap allocations.\n-using FlatTiling = absl::InlinedVector<int64_t, 4>;\n-\n-// `Tiling`s are instantiations of `TilingSpecification`s, and the conformance\n-// of a `Tiling` `t` to a `TilingSpecification` `spec` can be checked by calling\n-// `t.ConformsTo(spec)`.\n-//\n-// A given instruction may be mapped to either\n-//  1. a sequence of \"output\" tile sizes, corresponding to tiling of its output\n-//     shape;\n-//  2. a sequence of \"hidden\" tile sizes, corresponding to tiling of its\n-//     contraction dimensions;\n-//  3. both of the above.\n-//\n-// In the case of 3., the parameters are ordered such that the \"hidden\" tile\n-// sizes are listed first.\n-//\n-// Given a HLO opcode in isolation, there is never any ambiguity about which\n-// tile sizes are \"output\" or \"hidden\": if an opcode can be assigned \"hidden\"\n-// tile sizes, then we can always expect them to have a mapping---while \"output\"\n-// tile sizes only appear optionally.\n-//\n-// TODO(b/419026602): reductions are ignored for now. This will need to handle\n-// them.\n-class Tiling {\n- public:\n-  using TileMapping = absl::flat_hash_map<const HloInstruction*, FlatTiling>;\n-  explicit Tiling(TileMapping tile_sizes)\n-      : tile_sizes_(std::move(tile_sizes)) {}\n-\n-  // Returns `true` if the tiling conforms to the given tiling specification.\n-  // To conform to a tiling specification, the tiling must specify exactly the\n-  // right number of tile sizes for each exposed parameter in the tiling\n-  // specification.\n-  bool ConformsTo(const TilingSpecification& tiling_specification) const;\n-\n-  // Returns the tile sizes for the given instruction. Raises an error if the\n-  // queried instruction should not be assigned tile sizes.\n-  absl::StatusOr<absl::Span<const int64_t>> TileSizesForInstruction(\n-      const HloInstruction* hlo) const;\n-\n-  // Returns the underlying mapping from instructions to tile sizes.\n-  const TileMapping& tile_sizes() const { return tile_sizes_; }\n-\n-  // Returns a flattened list of tile sizes that conforms to the parameter\n-  // mapping defined by the parameter `TilingSpecification`.\n-  //\n-  // Note that `Flatten` does not check whether this tiling conforms to the\n-  // parameter `TilingSpecification`, and it is the caller's responsibility to\n-  // ensure that this is the case.\n-  absl::StatusOr<FlatTiling> Flatten(\n-      const TilingSpecification& tiling_specification) const;\n-\n-  // Returns a `Tiling` that conforms to the parameter `TilingSpecification`\n-  // from the given flattened list of tile sizes.\n-  //\n-  // `Unflatten` is the dual of `Flatten`.\n-  static absl::StatusOr<Tiling> Unflatten(\n-      absl::Span<const int64_t> flat_tile_sizes,\n-      const TilingSpecification& tiling_specification);\n-\n- private:\n-  TileMapping tile_sizes_;\n-};\n-\n // Holds the indexing information for the roots of the computation.\n struct RootIndexing {\n   RootIndexing(int64_t real_root_index,"
        },
        {
            "sha": "8f6f7308b38b31b4fd270dd07c82533905a62d1a",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 261,
            "changes": 264,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -31,6 +31,7 @@ limitations under the License.\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n@@ -39,6 +40,8 @@ limitations under the License.\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n #include \"xla/codegen/tiling/tiled_hlo_fusion_instruction.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n@@ -58,7 +61,6 @@ namespace {\n \n using absl_testing::IsOkAndHolds;\n using detail::GetFlatTilingsForInputSpace;\n-using ::testing::ElementsAre;\n using ::testing::ElementsAreArray;\n using ::testing::ExplainMatchResult;\n using ::testing::IsEmpty;\n@@ -90,14 +92,6 @@ MATCHER_P(MatchConstraintExpressionString, constraint_expression_string, \"\") {\n       result_listener);\n }\n \n-MATCHER_P2(InstructionMapping, instruction, num_tiling_parameters,\n-           \"A matcher for \"\n-           \"`TilingSpecification::InstructionAndNumTilingParameters`s.\") {\n-  return ExplainMatchResult(instruction, arg.instruction, result_listener) &&\n-         ExplainMatchResult(num_tiling_parameters, arg.num_tiling_parameters,\n-                            result_listener);\n-}\n-\n // Returns a map from parameter number to the tiled instruction corresponding to\n // the parameter. Note that parameters and their indexing are coming from the\n // ENTRY computation not from the fusion.\n@@ -2349,258 +2343,6 @@ ENTRY main {\n                   \"pid_0 in [0, 35]\"));\n }\n \n-using TilingSpecificationTest = SymbolicTileAnalysisTest;\n-\n-TEST_F(TilingSpecificationTest, TilingSpecificationDerivesOutputParameters) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  ROOT p0 = f32[137,115] parameter(0)\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  ROOT fusion = f32[137,115] fusion(p0), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  EXPECT_THAT(\n-      tiling_spec.parameter_mapping(),\n-      ElementsAre(InstructionMapping(root->fused_expression_root(), 2)));\n-}\n-\n-TEST_F(TilingSpecificationTest, TilingSpecificationDerivesHiddenDotParameters) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-  ROOT abs = f32[137,137] abs(dot)\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* abs = root->fused_expression_root();\n-  const HloInstruction* dot = abs->operand(0);\n-\n-  EXPECT_THAT(\n-      tiling_spec.parameter_mapping(),\n-      ElementsAre(InstructionMapping(abs, 2), InstructionMapping(dot, 1)));\n-}\n-\n-TEST_F(TilingSpecificationTest,\n-       TilingSpecificationDerivesOutputAndHiddenParametersOnTheSameOperation) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* dot = root->fused_expression_root();\n-\n-  EXPECT_THAT(tiling_spec.parameter_mapping(),\n-              ElementsAre(InstructionMapping(dot, 3)));\n-}\n-\n-TEST_F(TilingSpecificationTest,\n-       TilingSpecificationDerivesHiddenParametersInNestedFusions) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-nested_computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-}\n-\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  dot_output = f32[137,137] fusion(p0, p1), kind=kLoop, calls=nested_computation\n-  ROOT abs = f32[137,137] abs(dot_output)\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* abs = root->fused_expression_root();\n-  const HloInstruction* dot = abs->operand(0)->fused_expression_root();\n-\n-  EXPECT_THAT(\n-      tiling_spec.parameter_mapping(),\n-      ElementsAre(InstructionMapping(abs, 2), InstructionMapping(dot, 1)));\n-}\n-\n-TEST_F(TilingSpecificationTest,\n-       TilingWithIncorrectSetOfNestedTileSizesDoesNotConformToSpecification) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* dot = root->fused_expression_root();\n-  ASSERT_EQ(dot->opcode(), HloOpcode::kDot);\n-\n-  // An underspecified tiling does not conform to a tiling specification.\n-  Tiling underspecified_nested_tiling(Tiling::TileMapping{{dot, {1}}});\n-  EXPECT_FALSE(underspecified_nested_tiling.ConformsTo(tiling_spec));\n-\n-  // An overspecified tiling does not conform to a tiling specification either.\n-  Tiling overspecified_nested_tiling(Tiling::TileMapping{{dot, {1, 1, 1, 1}}});\n-  EXPECT_FALSE(overspecified_nested_tiling.ConformsTo(tiling_spec));\n-}\n-\n-TEST_F(TilingSpecificationTest,\n-       TilingWithIncorrectSetOfOutputTileSizesDoesNotConformToSpecification) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-  ROOT abs = f32[137,137] abs(dot)\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* abs = root->fused_expression_root();\n-  const HloInstruction* dot = abs->operand(0);\n-\n-  // An underspecified tiling does not conform to a tiling specification.\n-  Tiling underspecified_output_tiling(\n-      Tiling::TileMapping{{dot, {1}}, {abs, {1}}});\n-  EXPECT_FALSE(underspecified_output_tiling.ConformsTo(tiling_spec));\n-\n-  // An overspecified tiling does not conform to a tiling specification either.\n-  Tiling overspecified_output_tiling(\n-      Tiling::TileMapping{{dot, {1}}, {abs, {1, 1, 1}}});\n-  EXPECT_FALSE(overspecified_output_tiling.ConformsTo(tiling_spec));\n-}\n-\n-TEST_F(TilingSpecificationTest,\n-       TilingWithIncorrectSetOfTiledInstructionsDoesNotConformToSpecification) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* dot = root->fused_expression_root();\n-  ASSERT_EQ(dot->opcode(), HloOpcode::kDot);\n-\n-  // An underspecified tiling does not conform to a tiling specification.\n-  Tiling underspecified_tiling(Tiling::TileMapping{{}});\n-  EXPECT_FALSE(underspecified_tiling.ConformsTo(tiling_spec));\n-\n-  // A tiling along of irrelevant operations does not conform to a tiling\n-  // specification.\n-  Tiling off_topic_tiling(Tiling::TileMapping{{dot->operand(0), {1}}});\n-  EXPECT_FALSE(off_topic_tiling.ConformsTo(tiling_spec));\n-\n-  // An overspecified tiling does not conform to a tiling specification either.\n-  Tiling overspecified_tiling(\n-      Tiling::TileMapping{{dot, {1, 1, 1}}, {dot->operand(0), {1}}});\n-\n-  EXPECT_FALSE(overspecified_tiling.ConformsTo(tiling_spec));\n-}\n-\n-TEST_F(TilingSpecificationTest,\n-       TilingWithExactlyConformantSetOfParametersConformsToSpecification) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-computation {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT dot = f32[137,137] dot(p0, p1),\n-    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-}\n-\n-ENTRY main {\n-  p0 = f32[137,115] parameter(0)\n-  p1 = f32[115,137] parameter(1)\n-  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n-\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-  const HloInstruction* dot = root->fused_expression_root();\n-  ASSERT_EQ(dot->opcode(), HloOpcode::kDot);\n-\n-  Tiling exact_tiling(Tiling::TileMapping{{dot, {1, 1, 1}}});\n-  EXPECT_TRUE(exact_tiling.ConformsTo(tiling_spec));\n-}\n-\n TEST_F(SymbolicTileAnalysisTest,\n        SymbolicTilesAlwaysDependOnAllTheHiddenParameters) {\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,"
        },
        {
            "sha": "b5c1aee772a37130591cce5325f4159e85e45469",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -27,7 +27,7 @@ limitations under the License.\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/AffineMap.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\""
        },
        {
            "sha": "402463cb634746997a0317cf941d8a5d859eb955",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -18,7 +18,7 @@ limitations under the License.\n \n #include \"absl/status/statusor.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n "
        },
        {
            "sha": "7a8e011170646596d116498514f30c8608110575",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -23,7 +23,7 @@ limitations under the License.\n #include \"absl/strings/substitute.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n #include \"xla/hlo/analysis/interval.h\""
        },
        {
            "sha": "f8c8a0840594fb13b675dc9aecf4eec5316be835",
            "filename": "third_party/xla/xla/codegen/tiling/tiling_specification.cc",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification.cc?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -0,0 +1,124 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n+\n+#include <cstdint>\n+#include <utility>\n+\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+\n+absl::StatusOr<int64_t> TilingSpecification::ParameterIndex(\n+    const TilingSpecification::ParameterMapping& parameter_mapping,\n+    const HloInstruction* hlo, int64_t index) {\n+  int64_t offset = 0;\n+  for (const auto& [instruction, num_parameters] : parameter_mapping) {\n+    if (instruction == hlo) {\n+      if (index >= num_parameters) {\n+        return absl::FailedPreconditionError(absl::StrCat(\n+            \"Index \", index, \" is out of bounds for instruction \",\n+            hlo->ToString(), \" with num parameters \", num_parameters));\n+      }\n+      return offset + index;\n+    }\n+\n+    offset += num_parameters;\n+  }\n+  return absl::NotFoundError(\n+      absl::StrCat(\"No tile sizes found for instruction: \", hlo->ToString()));\n+}\n+\n+absl::StatusOr<absl::Span<const int64_t>> Tiling::TileSizesForInstruction(\n+    const HloInstruction* hlo) const {\n+  if (auto it = tile_sizes_.find(hlo); it != tile_sizes_.end()) {\n+    return it->second;\n+  }\n+\n+  return absl::NotFoundError(\n+      absl::StrCat(\"No tile sizes found for instruction: \", hlo->ToString()));\n+}\n+\n+absl::StatusOr<FlatTiling> Tiling::Flatten(\n+    const TilingSpecification& tiling_specification) const {\n+  FlatTiling flat_tile_sizes;\n+  flat_tile_sizes.reserve(tiling_specification.num_parameters());\n+  for (const auto& mapping : tiling_specification.parameter_mapping()) {\n+    TF_ASSIGN_OR_RETURN(absl::Span<const int64_t> tile_sizes,\n+                        TileSizesForInstruction(mapping.instruction));\n+    if (tile_sizes.size() != mapping.num_tiling_parameters) {\n+      return absl::FailedPreconditionError(\n+          absl::StrCat(\"Instruction \", mapping.instruction->ToString(),\n+                       \" was expected to have \", mapping.num_tiling_parameters,\n+                       \" tile sizes but had \", tile_sizes.size(), \".\"));\n+    }\n+    flat_tile_sizes.insert(flat_tile_sizes.end(), tile_sizes.begin(),\n+                           tile_sizes.end());\n+  }\n+\n+  return flat_tile_sizes;\n+}\n+\n+/*static*/ absl::StatusOr<Tiling> Tiling::Unflatten(\n+    absl::Span<const int64_t> flat_tile_sizes,\n+    const TilingSpecification& tiling_specification) {\n+  if (flat_tile_sizes.size() != tiling_specification.num_parameters()) {\n+    return absl::FailedPreconditionError(\n+        absl::StrCat(\"Expected \", tiling_specification.num_parameters(),\n+                     \" tile sizes but got \", flat_tile_sizes.size(), \".\"));\n+  }\n+\n+  TileMapping tile_mapping;\n+  int64_t offset = 0;\n+  for (const auto& [hlo, num_parameters] :\n+       tiling_specification.parameter_mapping()) {\n+    auto start_it = flat_tile_sizes.begin() + offset;\n+    auto end_it = start_it + num_parameters;\n+    tile_mapping[hlo] = {start_it, end_it};\n+    offset += num_parameters;\n+  }\n+  return Tiling(std::move(tile_mapping));\n+}\n+\n+bool Tiling::ConformsTo(const TilingSpecification& tiling_specification) const {\n+  int64_t num_instructions = tile_sizes_.size();\n+  int64_t expected_num_instructions =\n+      tiling_specification.parameter_mapping().size();\n+  if (num_instructions != expected_num_instructions) {\n+    VLOG(1) << \"Tiling tiles \" << num_instructions << \" instructions, but \"\n+            << expected_num_instructions\n+            << \" instructions were expected to be \"\n+               \"tiled.\";\n+    return false;\n+  }\n+\n+  // Linearization takes care of checking that we have the right number of\n+  // tile sizes specified for each instruction.\n+  absl::StatusOr<FlatTiling> flat_tile_sizes_or = Flatten(tiling_specification);\n+  if (!flat_tile_sizes_or.ok()) {\n+    return false;\n+  }\n+\n+  return tiling_specification.constraints().IsSatisfiedBy(*flat_tile_sizes_or);\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "9d15b09816a2005874127b41125a80783b39bede",
            "filename": "third_party/xla/xla/codegen/tiling/tiling_specification.h",
            "status": "added",
            "additions": 211,
            "deletions": 0,
            "changes": 211,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification.h?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -0,0 +1,211 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_CODEGEN_TILING_TILING_SPECIFICATION_H_\n+#define XLA_CODEGEN_TILING_TILING_SPECIFICATION_H_\n+\n+#include <cstdint>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/inlined_vector.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/codegen/tiling/constraint_expression.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+\n+namespace xla {\n+\n+// A `TilingSpecification` describes the structure of a set of expected tile\n+// sizes, by indicating how many tile sizes must be specified for each\n+// instruction within a set. When creating a `TilingSpecification` from a\n+// fusion, we're interested in finding out how many tile sizes need to be\n+// defined in aggregate in order to tile the whole fusion.\n+//\n+// To support that use case, `TilingSpecification`s derived from fusions only\n+// map instructions to the new tile sizes that they require we define. At the\n+// output of the fusion, we must define a tile size for each axis of the output;\n+// on an instruction that is not an output of the fusion, we must define a tile\n+// size iff that instruction contracts a dimension---i.e. if it introduces a new\n+// dimension to tile that is not visible at the output of the fusion. For\n+// example, take the following fusion computation:\n+//\n+//   fusion_computation {\n+//     p0 = f32[128,256] parameter(0)\n+//     p1 = f32[256,128] parameter(1)\n+//     dot = f32[128,128] dot(p0, p1),\n+//       lhs_contracting_dimensions={1}, rhs_contracting_dimensions={0}\n+//     ROOT abs = f32[128,128] abs(dot)\n+//   }.\n+//\n+// The tiling specification for this fusion would require that we define two\n+// tile sizes at the output, as well as one additional tile size for the\n+// contracting dimension introduced by the `dot` instruction. Ergo, the\n+// specification would be:\n+//   {\n+//     abs: 2\n+//     dot: 1\n+//   }\n+//\n+// The intent is for `TilingSpecification`s to be used in order to construct\n+// `Tiling`s for a fusion, with the guarantee that if the `Tiling`\n+// satisfies the `TilingSpecification`, then the `Tiling` contains exactly\n+// as many parameters as necessary to tile the whole fusion.\n+//\n+// TODO(b/419026602): reductions are ignored for now. This will need to handle\n+// them.\n+class TilingSpecification {\n+ public:\n+  // Associates a number of tiling parameters to an instruction. Since there is\n+  // never any ambiguity about the ordering of tiling parameters within a single\n+  // instruction, this is sufficient information to describe both how many\n+  // tiling parameters are introduced for the given instruction, as well as\n+  // their semantics (i.e. what contracting dimension they correspond to, or\n+  // what output dimension they correspond to).\n+  struct InstructionAndNumTilingParameters {\n+    // The instruction that this `InstructionAndNumTilingParameters` is\n+    // associated with.\n+    const HloInstruction* instruction;\n+    // The number of tile sizes that must be specified for the instruction.\n+    int64_t num_tiling_parameters;\n+  };\n+\n+  // An ordered sequence of `InstructionAndNumTilingParameters`s. Since\n+  // parameter mapping within a single `InstructionAndNumTilingParameters`\n+  // is unambiguous, this abstraction provides enough information to describe\n+  // the ordering of a set of tiling parameters---e.g. for a whole fusion.\n+  using ParameterMapping = std::vector<InstructionAndNumTilingParameters>;\n+\n+  // Returns the parameter mapping for the entire fusion the specification is\n+  // derived from.\n+  //\n+  // The instructions are guaranteed to be in use-before-def order, and it is\n+  // guaranteed that an instruction will only ever appear at most once.\n+  const ParameterMapping& parameter_mapping() const {\n+    return parameter_mapping_;\n+  }\n+\n+  // Returns the constraints for the parameters of the tiling specification.\n+  const ConstraintExpression& constraints() const { return constraints_; }\n+\n+  // Given the index of a tile size parameter for the given HLO instruction,\n+  // returns its overall parameter index within the `TilingSpecification`'s\n+  // parameter mapping.\n+  absl::StatusOr<int64_t> ParameterIndex(const HloInstruction* hlo,\n+                                         int64_t index) const {\n+    return ParameterIndex(parameter_mapping_, hlo, index);\n+  };\n+\n+  // Given the index of a tile size parameter for a given HLO instruction,\n+  // returns its overall parameter index within the given parameter mapping.\n+  static absl::StatusOr<int64_t> ParameterIndex(\n+      const TilingSpecification::ParameterMapping& parameter_mapping,\n+      const HloInstruction* hlo, int64_t index);\n+\n+  // Returns the total number of parameters in the tiling specification.\n+  int64_t num_parameters() const { return num_parameters_; }\n+\n+ private:\n+  // `SymbolicTileAnalysis` is the only class allowed to construct\n+  // `TilingSpecification`s.\n+  friend class SymbolicTileAnalysis;\n+  explicit TilingSpecification(ParameterMapping parameter_mapping,\n+                               ConstraintExpression constraints)\n+      : parameter_mapping_(std::move(parameter_mapping)),\n+        constraints_(std::move(constraints)) {\n+    num_parameters_ = 0;\n+    for (const auto& [_, num_tiling_parameters] : parameter_mapping_) {\n+      num_parameters_ += num_tiling_parameters;\n+    }\n+  };\n+\n+  ParameterMapping parameter_mapping_;\n+  ConstraintExpression constraints_;\n+  int64_t num_parameters_;\n+};\n+\n+// A sequence of tile sizes.\n+//\n+// This is an inlined vector to avoid too many heap allocations.\n+using FlatTiling = absl::InlinedVector<int64_t, 4>;\n+\n+// `Tiling`s are instantiations of `TilingSpecification`s, and the conformance\n+// of a `Tiling` `t` to a `TilingSpecification` `spec` can be checked by calling\n+// `t.ConformsTo(spec)`.\n+//\n+// A given instruction may be mapped to either\n+//  1. a sequence of \"output\" tile sizes, corresponding to tiling of its output\n+//     shape;\n+//  2. a sequence of \"hidden\" tile sizes, corresponding to tiling of its\n+//     contraction dimensions;\n+//  3. both of the above.\n+//\n+// In the case of 3., the parameters are ordered such that the \"hidden\" tile\n+// sizes are listed first.\n+//\n+// Given a HLO opcode in isolation, there is never any ambiguity about which\n+// tile sizes are \"output\" or \"hidden\": if an opcode can be assigned \"hidden\"\n+// tile sizes, then we can always expect them to have a mapping---while \"output\"\n+// tile sizes only appear optionally.\n+//\n+// TODO(b/419026602): reductions are ignored for now. This will need to handle\n+// them.\n+class Tiling {\n+ public:\n+  using TileMapping = absl::flat_hash_map<const HloInstruction*, FlatTiling>;\n+  explicit Tiling(TileMapping tile_sizes)\n+      : tile_sizes_(std::move(tile_sizes)) {}\n+\n+  // Returns `true` if the tiling conforms to the given tiling specification.\n+  // To conform to a tiling specification, the tiling must specify exactly the\n+  // right number of tile sizes for each exposed parameter in the tiling\n+  // specification.\n+  bool ConformsTo(const TilingSpecification& tiling_specification) const;\n+\n+  // Returns the tile sizes for the given instruction. Raises an error if the\n+  // queried instruction should not be assigned tile sizes.\n+  absl::StatusOr<absl::Span<const int64_t>> TileSizesForInstruction(\n+      const HloInstruction* hlo) const;\n+\n+  // Returns the underlying mapping from instructions to tile sizes.\n+  const TileMapping& tile_sizes() const { return tile_sizes_; }\n+\n+  // Returns a flattened list of tile sizes that conforms to the parameter\n+  // mapping defined by the parameter `TilingSpecification`.\n+  //\n+  // Note that `Flatten` does not check whether this tiling conforms to the\n+  // parameter `TilingSpecification`, and it is the caller's responsibility to\n+  // ensure that this is the case.\n+  absl::StatusOr<FlatTiling> Flatten(\n+      const TilingSpecification& tiling_specification) const;\n+\n+  // Returns a `Tiling` that conforms to the parameter `TilingSpecification`\n+  // from the given flattened list of tile sizes.\n+  //\n+  // `Unflatten` is the dual of `Flatten`.\n+  static absl::StatusOr<Tiling> Unflatten(\n+      absl::Span<const int64_t> flat_tile_sizes,\n+      const TilingSpecification& tiling_specification);\n+\n+ private:\n+  TileMapping tile_sizes_;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_CODEGEN_TILING_TILING_SPECIFICATION_H_"
        },
        {
            "sha": "5685fa2dd868999c1140ef7468393571cecf2eec",
            "filename": "third_party/xla/xla/codegen/tiling/tiling_specification_test.cc",
            "status": "added",
            "additions": 316,
            "deletions": 0,
            "changes": 316,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/861fa34340b2fa0183e850d6e73efd657ec2c745/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiling_specification_test.cc?ref=861fa34340b2fa0183e850d6e73efd657ec2c745",
            "patch": "@@ -0,0 +1,316 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n+\n+#include <memory>\n+#include <optional>\n+#include <utility>\n+#include <variant>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/log/check.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/testlib/verified_hlo_module.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+using ::testing::ElementsAre;\n+\n+MATCHER_P2(InstructionMapping, instruction, num_tiling_parameters,\n+           \"A matcher for \"\n+           \"`TilingSpecification::InstructionAndNumTilingParameters`s.\") {\n+  return ExplainMatchResult(instruction, arg.instruction, result_listener) &&\n+         ExplainMatchResult(num_tiling_parameters, arg.num_tiling_parameters,\n+                            result_listener);\n+}\n+\n+class TilingSpecificationTest : public HloHardwareIndependentTestBase {\n+ public:\n+  SymbolicTileAnalysis AnalyzeModule(HloModule* module) {\n+    SymbolicTileAnalysisOrError analysis_or_error =\n+        SymbolicTileAnalysis::AnalyzeComputation(\n+            *module->entry_computation()\n+                 ->root_instruction()\n+                 ->fused_instructions_computation(),\n+            &mlir_context_, /*emitter_specific_constraints_builder=*/nullptr);\n+\n+    CHECK(std::holds_alternative<SymbolicTileAnalysis>(analysis_or_error));\n+    return std::get<SymbolicTileAnalysis>(std::move(analysis_or_error));\n+  }\n+\n+  mlir::MLIRContext mlir_context_;\n+};\n+\n+TEST_F(TilingSpecificationTest, TilingSpecificationDerivesOutputParameters) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  ROOT p0 = f32[137,115] parameter(0)\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  ROOT fusion = f32[137,115] fusion(p0), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(\n+      tiling_spec.parameter_mapping(),\n+      ElementsAre(InstructionMapping(root->fused_expression_root(), 2)));\n+}\n+\n+TEST_F(TilingSpecificationTest, TilingSpecificationDerivesHiddenDotParameters) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+  ROOT abs = f32[137,137] abs(dot)\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* abs = root->fused_expression_root();\n+  const HloInstruction* dot = abs->operand(0);\n+\n+  EXPECT_THAT(\n+      tiling_spec.parameter_mapping(),\n+      ElementsAre(InstructionMapping(abs, 2), InstructionMapping(dot, 1)));\n+}\n+\n+TEST_F(TilingSpecificationTest,\n+       TilingSpecificationDerivesOutputAndHiddenParametersOnTheSameOperation) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* dot = root->fused_expression_root();\n+\n+  EXPECT_THAT(tiling_spec.parameter_mapping(),\n+              ElementsAre(InstructionMapping(dot, 3)));\n+}\n+\n+TEST_F(TilingSpecificationTest,\n+       TilingSpecificationDerivesHiddenParametersInNestedFusions) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+nested_computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  dot_output = f32[137,137] fusion(p0, p1), kind=kLoop, calls=nested_computation\n+  ROOT abs = f32[137,137] abs(dot_output)\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* abs = root->fused_expression_root();\n+  const HloInstruction* dot = abs->operand(0)->fused_expression_root();\n+\n+  EXPECT_THAT(\n+      tiling_spec.parameter_mapping(),\n+      ElementsAre(InstructionMapping(abs, 2), InstructionMapping(dot, 1)));\n+}\n+\n+TEST_F(TilingSpecificationTest,\n+       TilingWithIncorrectSetOfNestedTileSizesDoesNotConformToSpecification) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* dot = root->fused_expression_root();\n+  ASSERT_EQ(dot->opcode(), HloOpcode::kDot);\n+\n+  // An underspecified tiling does not conform to a tiling specification.\n+  Tiling underspecified_nested_tiling(Tiling::TileMapping{{dot, {1}}});\n+  EXPECT_FALSE(underspecified_nested_tiling.ConformsTo(tiling_spec));\n+\n+  // An overspecified tiling does not conform to a tiling specification either.\n+  Tiling overspecified_nested_tiling(Tiling::TileMapping{{dot, {1, 1, 1, 1}}});\n+  EXPECT_FALSE(overspecified_nested_tiling.ConformsTo(tiling_spec));\n+}\n+\n+TEST_F(TilingSpecificationTest,\n+       TilingWithIncorrectSetOfOutputTileSizesDoesNotConformToSpecification) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+  ROOT abs = f32[137,137] abs(dot)\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* abs = root->fused_expression_root();\n+  const HloInstruction* dot = abs->operand(0);\n+\n+  // An underspecified tiling does not conform to a tiling specification.\n+  Tiling underspecified_output_tiling(\n+      Tiling::TileMapping{{dot, {1}}, {abs, {1}}});\n+  EXPECT_FALSE(underspecified_output_tiling.ConformsTo(tiling_spec));\n+\n+  // An overspecified tiling does not conform to a tiling specification either.\n+  Tiling overspecified_output_tiling(\n+      Tiling::TileMapping{{dot, {1}}, {abs, {1, 1, 1}}});\n+  EXPECT_FALSE(overspecified_output_tiling.ConformsTo(tiling_spec));\n+}\n+\n+TEST_F(TilingSpecificationTest,\n+       TilingWithIncorrectSetOfTiledInstructionsDoesNotConformToSpecification) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* dot = root->fused_expression_root();\n+  ASSERT_EQ(dot->opcode(), HloOpcode::kDot);\n+\n+  // An underspecified tiling does not conform to a tiling specification.\n+  Tiling underspecified_tiling(Tiling::TileMapping{{}});\n+  EXPECT_FALSE(underspecified_tiling.ConformsTo(tiling_spec));\n+\n+  // A tiling along of irrelevant operations does not conform to a tiling\n+  // specification.\n+  Tiling off_topic_tiling(Tiling::TileMapping{{dot->operand(0), {1}}});\n+  EXPECT_FALSE(off_topic_tiling.ConformsTo(tiling_spec));\n+\n+  // An overspecified tiling does not conform to a tiling specification either.\n+  Tiling overspecified_tiling(\n+      Tiling::TileMapping{{dot, {1, 1, 1}}, {dot->operand(0), {1}}});\n+\n+  EXPECT_FALSE(overspecified_tiling.ConformsTo(tiling_spec));\n+}\n+\n+TEST_F(TilingSpecificationTest,\n+       TilingWithExactlyConformantSetOfParametersConformsToSpecification) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+computation {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT dot = f32[137,137] dot(p0, p1),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = f32[137,115] parameter(0)\n+  p1 = f32[115,137] parameter(1)\n+  ROOT fusion = f32[137,137] fusion(p0, p1), kind=kLoop, calls=computation\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = AnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const TilingSpecification& tiling_spec = analysis->GetTilingSpecification();\n+\n+  const HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* dot = root->fused_expression_root();\n+  ASSERT_EQ(dot->opcode(), HloOpcode::kDot);\n+\n+  Tiling exact_tiling(Tiling::TileMapping{{dot, {1, 1, 1}}});\n+  EXPECT_TRUE(exact_tiling.ConformsTo(tiling_spec));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 1246,
        "additions": 711,
        "deletions": 535
    }
}