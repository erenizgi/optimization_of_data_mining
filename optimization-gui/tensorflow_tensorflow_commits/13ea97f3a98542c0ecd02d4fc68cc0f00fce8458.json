{
    "author": "pschuh",
    "message": "Update PjRtStreamExecutorClient main execute path to use CommonPjRtBuffer::ScopedHold. Crucially\nthis now passes reference_held=true always. This is fine because the only time\nthis was ever passed as false was if this was already on the compute stream and\nthis bool is basically ignored if the stream is the compute stream (see\nMaybeWaitForEventOnStream).\n\nPiperOrigin-RevId: 822758577",
    "sha": "13ea97f3a98542c0ecd02d4fc68cc0f00fce8458",
    "files": [
        {
            "sha": "1e417c53e00a8328d1a59db005b74d3c00fb7d16",
            "filename": "third_party/xla/xla/pjrt/gpu/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2FBUILD?ref=13ea97f3a98542c0ecd02d4fc68cc0f00fce8458",
            "patch": "@@ -79,6 +79,7 @@ cc_library(\n         \"//xla/core/collectives:communicator\",\n         \"//xla/core/collectives:rank_id\",\n         \"//xla/hlo/builder:xla_computation\",\n+        \"//xla/pjrt:abstract_tracked_device_buffer\",\n         \"//xla/pjrt:common_pjrt_client\",\n         \"//xla/pjrt:device_event\",\n         \"//xla/pjrt:event_pool\","
        },
        {
            "sha": "721b2c91f80436b7a6ded2135365bf451b5c9bf3",
            "filename": "third_party/xla/xla/pjrt/gpu/se_gpu_pjrt_client.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc?ref=13ea97f3a98542c0ecd02d4fc68cc0f00fce8458",
            "patch": "@@ -60,6 +60,7 @@ limitations under the License.\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/layout.h\"\n #include \"xla/literal.h\"\n+#include \"xla/pjrt/abstract_tracked_device_buffer.h\"\n #include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/distributed/client.h\"\n #include \"xla/pjrt/distributed/in_memory_key_value_store.h\"\n@@ -1043,11 +1044,14 @@ StreamExecutorGpuClient::MakeCrossHostReceiveBuffers(\n                                 definition_event));\n \n   // Acquire a hold on the buffer to access the underlying memory.\n-  PjRtStreamExecutorBuffer::ScopedHold hold = buffer->GetBufferWithUsageHold();\n+  CommonPjRtBuffer::ScopedHold hold =\n+      buffer->GetBufferWithHold(CommonPjRtBuffer::ScopedHold::kUsage);\n \n   auto recv = [this, gpu_collectives, notifier, local_device, definition_event,\n-               stream, mem = hold->device_memory(), shape = shapes[0],\n-               dtype = buffer->element_type()]() mutable {\n+               stream,\n+               mem = tensorflow::down_cast<TrackedDeviceBuffer*>(hold.buffer())\n+                         ->device_memory(),\n+               shape = shapes[0], dtype = buffer->element_type()]() mutable {\n     auto f = [&]() -> absl::Status {\n       // Create a CliqueId.\n       TF_ASSIGN_OR_RETURN(CliqueId clique_id,"
        },
        {
            "sha": "ae0f2977d9686e81505cbae6344352462d1d617d",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 70,
            "deletions": 55,
            "changes": 125,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=13ea97f3a98542c0ecd02d4fc68cc0f00fce8458",
            "patch": "@@ -727,15 +727,16 @@ PjRtStreamExecutorBuffer::DonateWithControlDependency(Future<> dependency) {\n   VLOG(1) << \"PjRtStreamExecutorBuffer::DonateWithControlDependency\";\n   std::unique_ptr<PjRtBuffer> new_buffer;\n \n-  auto tracked_buffer =\n-      GetBufferWithHold(PjRtStreamExecutorBuffer::ScopedHold::kDonation);\n+  auto hold = GetBufferWithHold(CommonPjRtBuffer::ScopedHold::kDonation);\n \n-  if (!tracked_buffer.ok()) {\n+  if (!hold.ok()) {\n     return InvalidArgument(\n         \"Invalid buffer passed to DonateWithControlDependency: %s\",\n-        tracked_buffer.status().ToString());\n+        hold.status().ToString());\n   }\n \n+  auto* tracked_buffer =\n+      tensorflow::down_cast<TrackedDeviceBuffer*>(hold.buffer());\n   // Copy all the data in the existing tracked_buffer.\n   const auto& original_definition_events = tracked_buffer->definition_events();\n   absl::InlinedVector<BufferSequencingEventRef, 4> definition_events;\n@@ -774,7 +775,7 @@ PjRtStreamExecutorBuffer::DonateWithControlDependency(Future<> dependency) {\n         local_device->ReturnStreamToPool(std::move(stream));\n       });\n \n-  tracked_buffer.ConfirmDonation();\n+  hold.ConfirmDonation();\n   return new_buffer;\n }\n \n@@ -1420,7 +1421,9 @@ Future<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n           \"GetReadyFuture() called on deleted or donated buffer\"));\n     }\n     if (!definition_future_) {\n-      definition_events = device_buffer()->definition_events();\n+      definition_events =\n+          tensorflow::down_cast<TrackedDeviceBuffer*>(device_buffer())\n+              ->definition_events();\n       std::tie(definition_promise, definition_future_) =\n           Future<>::MakePromise();\n     }\n@@ -1563,12 +1566,12 @@ absl::Status CheckCompatibleShapes(bool strict_shape_checking,\n // Makes a tuple from the arguments to an execution.\n static absl::StatusOr<std::pair<ShapeTree<PjRtStreamExecutorExecutionInput>,\n                                 BufferSequencingEventRef>>\n-MakeTupleHelper(\n-    PjRtStreamExecutorClient* client, LocalDeviceState* local_device,\n-    bool strict_shape_checking, const Shape& tupled_parameter_shape,\n-    absl::Span<PjRtBuffer* const> py_buffers,\n-    absl::Span<const PjRtStreamExecutorBuffer::ScopedHold> device_buffers,\n-    int device_ordinal) {\n+MakeTupleHelper(PjRtStreamExecutorClient* client,\n+                LocalDeviceState* local_device, bool strict_shape_checking,\n+                const Shape& tupled_parameter_shape,\n+                absl::Span<PjRtBuffer* const> py_buffers,\n+                absl::Span<const CommonPjRtBuffer::ScopedHold> device_buffers,\n+                int device_ordinal) {\n   se::DeviceMemoryAllocator* allocator = client->allocator();\n   TransferManager* transfer_manager =\n       client->client()->backend().transfer_manager();\n@@ -1610,11 +1613,11 @@ MakeTupleHelper(\n                                       local_device, allocator)};\n   ++input_iterator;\n   // Then set each sub-tuple in turn from the parameters.\n-  for (const PjRtStreamExecutorBuffer::ScopedHold& device_buffer :\n-       device_buffers) {\n+  for (const CommonPjRtBuffer::ScopedHold& device_buffer : device_buffers) {\n     input_iterator->second = {\n-        device_buffer.type() == PjRtStreamExecutorBuffer::ScopedHold::kDonation,\n-        device_buffer->device_memory()};\n+        device_buffer.type() == CommonPjRtBuffer::ScopedHold::kDonation,\n+        tensorflow::down_cast<TrackedDeviceBuffer*>(device_buffer.buffer())\n+            ->device_memory()};\n     ++input_iterator;\n   }\n   CHECK(input_iterator == iterator_end);\n@@ -1643,8 +1646,7 @@ MakeTupleHelper(\n absl::StatusOr<std::unique_ptr<PjRtBuffer>> OutputBufferHelper(\n     ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer,\n     BufferSequencingEventRef definition_event, PjRtClient* client,\n-    PjRtDevice* device, LocalDeviceState* local_device,\n-    std::vector<tsl::RCReference<RawSEDeviceMemory>>& buffers_to_release) {\n+    PjRtDevice* device, LocalDeviceState* local_device) {\n   if (result_buffer.shape().IsTuple()) {\n     return absl::InternalError(\"OutputBufferHelper called on tuple.\");\n   }\n@@ -1680,9 +1682,6 @@ absl::StatusOr<std::unique_ptr<PjRtBuffer>> OutputBufferHelper(\n   auto pjrt_buffer = std::make_unique<PjRtStreamExecutorBuffer>(\n       result_buffer.shape(), std::move(out_buffer), client, device,\n       memory_space);\n-  RecordUsage(pjrt_buffer->GetBufferWithUsageHold(), local_device, local_device,\n-              definition_event, local_device->compute_stream(),\n-              &buffers_to_release);\n   return std::unique_ptr<PjRtBuffer>(std::move(pjrt_buffer));\n }\n \n@@ -1798,7 +1797,7 @@ PjRtStreamExecutorLoadedExecutable::MakeExecutionInputsAndWaitForEvents(\n     int device_ordinal, const ExecuteOptions& options,\n     absl::Span<const Shape> executable_parameter_shapes,\n     absl::Span<PjRtBuffer* const> argument_handles,\n-    absl::Span<const PjRtStreamExecutorBuffer::ScopedHold> device_buffers,\n+    absl::Span<const CommonPjRtBuffer::ScopedHold> device_buffers,\n     absl::flat_hash_set<BufferSequencingEvent*>& events) const {\n   std::vector<ShapeTree<PjRtStreamExecutorExecutionInput>> execution_inputs;\n   LocalDeviceState* device_state = &(client_->device_state(device_ordinal));\n@@ -1834,11 +1833,12 @@ PjRtStreamExecutorLoadedExecutable::MakeExecutionInputsAndWaitForEvents(\n           execution_inputs.back();\n       auto input_iterator = execution_input.begin();\n       auto iterator_end = execution_input.end();\n-      const auto& buf = device_buffers[i]->device_memory();\n+      const auto& buf = tensorflow::down_cast<TrackedDeviceBuffer*>(\n+                            device_buffers[i].buffer())\n+                            ->device_memory();\n       CHECK(input_iterator != iterator_end);\n       input_iterator->second = {\n-          device_buffers[i].type() ==\n-              PjRtStreamExecutorBuffer::ScopedHold::kDonation,\n+          device_buffers[i].type() == CommonPjRtBuffer::ScopedHold::kDonation,\n           buf};\n       ++input_iterator;\n       CHECK(input_iterator == iterator_end);\n@@ -2154,7 +2154,7 @@ PjRtStreamExecutorLoadedExecutable::EnqueueExecution(\n     absl::Span<PjRtBuffer* const> argument_handles, int replica, int partition,\n     int executable_idx, const RunId& run_id, const ExecuteOptions& options,\n     PjRtDevice* device,\n-    std::vector<PjRtStreamExecutorBuffer::ScopedHold>* device_buffers,\n+    std::vector<CommonPjRtBuffer::ScopedHold>* device_buffers,\n     std::shared_ptr<DeviceAssignment> device_assignment,\n     std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks) const {\n   int device_ordinal = tensorflow::down_cast<PjRtStreamExecutorDevice*>(device)\n@@ -2194,16 +2194,17 @@ PjRtStreamExecutorLoadedExecutable::EnqueueExecution(\n     TF_RETURN_IF_ERROR(TestBufferDonationClashes(\n         handle, donation_clashes, must_donate, i, replica, partition));\n     device_buffers->emplace_back(handle->GetBufferWithHold(\n-        must_donate ? PjRtStreamExecutorBuffer::ScopedHold::kDonation\n-                    : PjRtStreamExecutorBuffer::ScopedHold::kUsage));\n-    PjRtStreamExecutorBuffer::ScopedHold& device_buffer =\n-        device_buffers->back();\n-    if (!device_buffer.ok()) {\n+        must_donate ? CommonPjRtBuffer::ScopedHold::kDonation\n+                    : CommonPjRtBuffer::ScopedHold::kUsage));\n+    CommonPjRtBuffer::ScopedHold& hold = device_buffers->back();\n+    if (!hold.ok()) {\n       return InvalidArgument(\n           \"Invalid buffer passed to Execute() as argument %d to replica %d: \"\n           \"%s\",\n-          i, replica, device_buffer.status().ToString());\n+          i, replica, hold.status().ToString());\n     }\n+    auto* device_buffer =\n+        tensorflow::down_cast<TrackedDeviceBuffer*>(hold.buffer());\n     // If we are trying to donate the buffer wait on the usage events as well\n     // as the definition events to ensure that all reads have been completed\n     // before the buffer is mutated. Usage holds are excluded during a donation\n@@ -2408,9 +2409,7 @@ PjRtStreamExecutorLoadedExecutable::MakeOutputBuffers(\n     int device_ordinal, const ExecuteOptions& options,\n     ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer,\n     BufferSequencingEventRef definition_event, PjRtDevice* device,\n-    std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks,\n-    std::vector<tsl::RCReference<RawSEDeviceMemory>>& buffers_to_release)\n-    const {\n+    std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks) const {\n   tsl::profiler::TraceMe traceme(\"MakeOutputBuffers\");\n   std::vector<std::unique_ptr<PjRtBuffer>> outputs;\n   LocalDeviceState* device_state = &(client_->device_state(device_ordinal));\n@@ -2426,7 +2425,7 @@ PjRtStreamExecutorLoadedExecutable::MakeOutputBuffers(\n       TF_ASSIGN_OR_RETURN(\n           std::unique_ptr<PjRtBuffer> buffer,\n           OutputBufferHelper(std::move(tuple_buffer), definition_event, client_,\n-                             device, device_state, buffers_to_release));\n+                             device, device_state));\n       outputs.push_back(std::move(buffer));\n     }\n     if (device_state->allocation_model() == LocalDeviceState::kSynchronous) {\n@@ -2438,7 +2437,7 @@ PjRtStreamExecutorLoadedExecutable::MakeOutputBuffers(\n     TF_ASSIGN_OR_RETURN(\n         std::unique_ptr<PjRtBuffer> buffer,\n         OutputBufferHelper(std::move(result_buffer), definition_event, client_,\n-                           device, device_state, buffers_to_release));\n+                           device, device_state));\n     outputs.push_back(std::move(buffer));\n   }\n   return outputs;\n@@ -2447,13 +2446,15 @@ PjRtStreamExecutorLoadedExecutable::MakeOutputBuffers(\n static absl::Status GetFirstInputError(\n     absl::Span<PjRtBuffer* const> argument_handles) {\n   for (auto* handle : argument_handles) {\n-    auto* buffer = tensorflow::down_cast<PjRtStreamExecutorBuffer*>(handle);\n-    PjRtStreamExecutorBuffer::ScopedHold hold =\n-        buffer->GetBufferWithUsageHold();\n+    auto* buffer = tensorflow::down_cast<CommonPjRtBuffer*>(handle);\n+    CommonPjRtBuffer::ScopedHold hold =\n+        buffer->GetBufferWithHold(CommonPjRtBuffer::ScopedHold::kUsage);\n     if (!hold.ok()) {\n       return hold.status();\n     }\n-    for (const auto& event : hold->definition_events()) {\n+    auto* tracked_buffer =\n+        tensorflow::down_cast<TrackedDeviceBuffer*>(hold.buffer());\n+    for (const auto& event : tracked_buffer->definition_events()) {\n       if (event->IsPredeterminedError()) {\n         return event->GetDefinedStatus();\n       }\n@@ -2524,7 +2525,7 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n   int executable_idx = executables_.size() > 1 ? partition : 0;\n \n   std::vector<absl::AnyInvocable<void() &&>> compute_callbacks;\n-  std::vector<PjRtStreamExecutorBuffer::ScopedHold> device_buffers;\n+  std::vector<CommonPjRtBuffer::ScopedHold> device_buffers;\n   device_buffers.reserve(argument_handles.size());\n   absl::StatusOr<ShapeTree<tsl::RCReference<RawSEDeviceMemory>>>\n       result_buffer_or_status =\n@@ -2543,33 +2544,46 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n   LocalDeviceState* device_state = &(client_->device_state(device_ordinal));\n   se::Stream* stream = device_state->compute_stream();\n \n-  auto definition_event = device_state->GetEventForComputeStreamSyncPoint(\n+  auto definition_event_or = device_state->GetEventForComputeStreamSyncPoint(\n       device_state->GetNextComputeStreamSyncPoint(), client_->thread_pool());\n-  if (!definition_event.ok()) {\n+  if (!definition_event_or.ok()) {\n     StallStreamOnError(device_state, stream);\n-    for (PjRtStreamExecutorBuffer::ScopedHold& b : device_buffers) {\n-      if (b.type() == PjRtStreamExecutorBuffer::ScopedHold::kDonation) {\n+    for (CommonPjRtBuffer::ScopedHold& b : device_buffers) {\n+      if (b.type() == CommonPjRtBuffer::ScopedHold::kDonation) {\n         // Even though there was an error we need to call ConfirmDonation, which\n         // renders b invalid, since the computation has been enqueued and b has\n         // been donated.\n         b.ConfirmDonation();\n       }\n     }\n-    return definition_event.status();\n+    return definition_event_or.status();\n+  }\n+  std::vector<tsl::RCReference<RawSEDeviceMemory>> leaves_to_release;\n+  if (device_state->allocation_model() == LocalDeviceState::kSynchronous) {\n+    leaves_to_release.reserve(result_buffer.leaf_count());\n+    for (auto& node : result_buffer.leaves()) {\n+      leaves_to_release.push_back(node.second);\n+    }\n   }\n   std::vector<tsl::RCReference<RawSEDeviceMemory>> buffers_to_release;\n+  auto definition_event = tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(\n+      *definition_event_or, \"PjRtStreamExecutorLoadedExecutable\", \"Execute\");\n   TF_ASSIGN_OR_RETURN(\n       std::vector<std::unique_ptr<PjRtBuffer>> outputs,\n       MakeOutputBuffers(device_ordinal, options, std::move(result_buffer),\n-                        *definition_event, device, compute_callbacks,\n-                        buffers_to_release));\n+                        *definition_event_or, device, compute_callbacks));\n \n-  for (PjRtStreamExecutorBuffer::ScopedHold& b : device_buffers) {\n-    if (b.type() == PjRtStreamExecutorBuffer::ScopedHold::kUsage) {\n-      RecordUsage(std::move(b), device_state, device_state, *definition_event,\n-                  stream, &buffers_to_release);\n+  for (CommonPjRtBuffer::ScopedHold& b : device_buffers) {\n+    if (b.type() == CommonPjRtBuffer::ScopedHold::kUsage) {\n+      if (device_state->allocation_model() == LocalDeviceState::kSynchronous) {\n+        buffers_to_release.push_back(\n+            tensorflow::down_cast<PjRtStreamExecutorRawBuffer*>(\n+                b.buffer()->GetRawBuffer(b.parent()->memory_space()).get())\n+                ->device_buffer());\n+      }\n+      b.ConvertUsageHold(definition_event);\n     } else {\n-      CHECK(b.type() == PjRtStreamExecutorBuffer::ScopedHold::kDonation);\n+      CHECK(b.type() == CommonPjRtBuffer::ScopedHold::kDonation);\n       b.ConfirmDonation();\n     }\n   }\n@@ -2583,7 +2597,8 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n   }\n   definition_event->AndThen(\n       [callbacks{std::move(compute_callbacks)},\n-       buffers_to_release{std::move(buffers_to_release)}]() mutable {\n+       buffers_to_release{std::move(buffers_to_release)},\n+       leaves_to_release = std::move(leaves_to_release)]() mutable {\n         for (auto& fn : callbacks) {\n           std::move(fn)();\n         }"
        },
        {
            "sha": "2c064841f302d2216ae47614008957a4eb197689",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/13ea97f3a98542c0ecd02d4fc68cc0f00fce8458/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=13ea97f3a98542c0ecd02d4fc68cc0f00fce8458",
            "patch": "@@ -824,15 +824,15 @@ class PjRtStreamExecutorLoadedExecutable : public PjRtLoadedExecutable {\n       int device_ordinal, const ExecuteOptions& options,\n       absl::Span<const Shape> executable_parameter_shapes,\n       absl::Span<PjRtBuffer* const> argument_handles,\n-      absl::Span<const PjRtStreamExecutorBuffer::ScopedHold> device_buffers,\n+      absl::Span<const CommonPjRtBuffer::ScopedHold> device_buffers,\n       absl::flat_hash_set<BufferSequencingEvent*>& events) const;\n \n   absl::StatusOr<ShapeTree<tsl::RCReference<RawSEDeviceMemory>>>\n   EnqueueExecution(\n       absl::Span<PjRtBuffer* const> argument_handles, int replica,\n       int partition, int executable_idx, const RunId& run_id,\n       const ExecuteOptions& options, PjRtDevice* device,\n-      std::vector<PjRtStreamExecutorBuffer::ScopedHold>* device_buffers,\n+      std::vector<CommonPjRtBuffer::ScopedHold>* device_buffers,\n       std::shared_ptr<DeviceAssignment> device_assignment,\n       std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks) const;\n \n@@ -841,9 +841,7 @@ class PjRtStreamExecutorLoadedExecutable : public PjRtLoadedExecutable {\n       int device_ordinal, const ExecuteOptions& options,\n       ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer,\n       BufferSequencingEventRef definition_event, PjRtDevice* device,\n-      std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks,\n-      std::vector<tsl::RCReference<RawSEDeviceMemory>>& buffers_to_release)\n-      const;\n+      std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks) const;\n \n   absl::StatusOr<Result> ExecuteHelper(\n       absl::Span<PjRtBuffer* const> argument_handles, int replica,"
        }
    ],
    "stats": {
        "total": 144,
        "additions": 81,
        "deletions": 63
    }
}