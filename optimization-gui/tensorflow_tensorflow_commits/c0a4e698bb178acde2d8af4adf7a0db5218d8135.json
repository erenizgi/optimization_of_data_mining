{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809661029",
    "sha": "c0a4e698bb178acde2d8af4adf7a0db5218d8135",
    "files": [
        {
            "sha": "86ed80dc386c2685ecaeef5acaa2c7c08690d212",
            "filename": "third_party/xla/xla/tsl/lib/io/cache.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c0a4e698bb178acde2d8af4adf7a0db5218d8135/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fcache.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c0a4e698bb178acde2d8af4adf7a0db5218d8135/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fcache.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fcache.cc?ref=c0a4e698bb178acde2d8af4adf7a0db5218d8135",
            "patch": "@@ -177,7 +177,7 @@ class LRUCache {\n   void Erase(Slice key, uint32_t hash);\n   void Prune();\n   size_t TotalCharge() const {\n-    absl::MutexLock l(&mutex_);\n+    absl::MutexLock l(mutex_);\n     return usage_;\n   }\n \n@@ -263,7 +263,7 @@ void LRUCache::LRU_Append(LRUHandle* list, LRUHandle* e) {\n }\n \n Cache::Handle* LRUCache::Lookup(Slice key, uint32_t hash) {\n-  absl::MutexLock l(&mutex_);\n+  absl::MutexLock l(mutex_);\n   LRUHandle* e = table_.Lookup(key, hash);\n   if (e != nullptr) {\n     Ref(e);\n@@ -272,14 +272,14 @@ Cache::Handle* LRUCache::Lookup(Slice key, uint32_t hash) {\n }\n \n void LRUCache::Release(Cache::Handle* handle) {\n-  absl::MutexLock l(&mutex_);\n+  absl::MutexLock l(mutex_);\n   Unref(reinterpret_cast<LRUHandle*>(handle));\n }\n \n Cache::Handle* LRUCache::Insert(Slice key, uint32_t hash, void* value,\n                                 size_t charge,\n                                 void (*deleter)(Slice key, void* value)) {\n-  absl::MutexLock l(&mutex_);\n+  absl::MutexLock l(mutex_);\n \n   LRUHandle* e =\n       reinterpret_cast<LRUHandle*>(malloc(sizeof(LRUHandle) - 1 + key.size()));\n@@ -328,12 +328,12 @@ bool LRUCache::FinishErase(LRUHandle* e) {\n }\n \n void LRUCache::Erase(Slice key, uint32_t hash) {\n-  absl::MutexLock l(&mutex_);\n+  absl::MutexLock l(mutex_);\n   FinishErase(table_.Remove(key, hash));\n }\n \n void LRUCache::Prune() {\n-  absl::MutexLock l(&mutex_);\n+  absl::MutexLock l(mutex_);\n   while (lru_.next != &lru_) {\n     LRUHandle* e = lru_.next;\n     assert(e->refs == 1);\n@@ -388,7 +388,7 @@ class ShardedLRUCache : public Cache {\n     return reinterpret_cast<LRUHandle*>(handle)->value;\n   }\n   uint64_t NewId() override {\n-    absl::MutexLock l(&id_mutex_);\n+    absl::MutexLock l(id_mutex_);\n     return ++(last_id_);\n   }\n   void Prune() override {"
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}