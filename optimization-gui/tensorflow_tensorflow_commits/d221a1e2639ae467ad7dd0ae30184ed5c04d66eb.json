{
    "author": "hyeontaek",
    "message": "[IFRT] Add `WithUserContext` and `WithCurrentUserContext` wrapper\n\n`WithUserContext` takes a function and a `UserContextRef` and sets it up with `UserContextScope` when the returned function is called.\n\n`WithCurrentUserContext` is a shorthand for `WithUserContext` that captures `UserContextScope::current()`.\n\nThis is a helper for handing over the user context into a function or callback that runs on a different thread or in a deferred way.\n\nPiperOrigin-RevId: 814441984",
    "sha": "d221a1e2639ae467ad7dd0ae30184ed5c04d66eb",
    "files": [
        {
            "sha": "6d5fd33fad76d64da481c420728feea38f09b7f6",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=d221a1e2639ae467ad7dd0ae30184ed5c04d66eb",
            "patch": "@@ -1212,6 +1212,32 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"with_user_context\",\n+    hdrs = [\"with_user_context.h\"],\n+    visibility = internal_visibility([\n+        \":friends\",\n+        \":internal\",\n+        \":users\",\n+    ]),\n+    deps = [\":user_context\"],\n+)\n+\n+xla_cc_test(\n+    name = \"with_user_context_test\",\n+    srcs = [\"with_user_context_test.cc\"],\n+    deps = [\n+        \":user_context\",\n+        \":user_context_test_util\",\n+        \":with_user_context\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n xla_cc_test(\n     name = \"custom_call_program_serdes_test\",\n     srcs = [\"custom_call_program_serdes_test.cc\"],"
        },
        {
            "sha": "7ab409d6c7e2b2cc04d6aa9831146519b75408b4",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD?ref=d221a1e2639ae467ad7dd0ae30184ed5c04d66eb",
            "patch": "@@ -75,6 +75,7 @@ cc_library(\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:attribute_map\",\n         \"//xla/python/ifrt:user_context\",\n+        \"//xla/python/ifrt:with_user_context\",\n         \"//xla/python/ifrt/hlo:hlo_program\",\n         \"//xla/python/ifrt/ir\",\n         \"//xla/python/ifrt/ir:atom_program_compiler\","
        },
        {
            "sha": "1d436920af7131ac78d0acdc6cdfaf6964767d69",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/multi_threaded_atom_program_compiler.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc?ref=d221a1e2639ae467ad7dd0ae30184ed5c04d66eb",
            "patch": "@@ -46,7 +46,7 @@ limitations under the License.\n #include \"xla/python/ifrt/ir/ifrt_ops.h\"\n #include \"xla/python/ifrt/ir/transforms/utils.h\"\n #include \"xla/python/ifrt/shape.h\"\n-#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt/with_user_context.h\"\n #include \"xla/service/compilation_environments.h\"\n #include \"xla/service/computation_placer.h\"\n #include \"xla/service/hlo.pb.h\"\n@@ -203,14 +203,14 @@ absl::StatusOr<CompileFuture> MultiThreadedAtomProgramCompiler::CompileXla(\n       /*context=*/nullptr,  // Shares the same long-living context.\n       mlir::OwningOpRef<mlir::ModuleOp>(module_op.clone()));\n   auto [promise, future] = CompileFuture::MakePromise();\n-  ScheduleWork(thread_pool, [this, hlo_program = std::move(hlo_program),\n-                             compile_options = std::move(compile_options),\n-                             user_context = UserContextScope::current(),\n-                             promise = std::move(promise)]() mutable {\n-    UserContextScope user_context_scope(std::move(user_context));\n-    promise.Set(compiler_->CompileXla(std::move(hlo_program),\n-                                      std::move(compile_options)));\n-  });\n+  ScheduleWork(\n+      thread_pool,\n+      WithCurrentUserContext([this, hlo_program = std::move(hlo_program),\n+                              compile_options = std::move(compile_options),\n+                              promise = std::move(promise)]() mutable {\n+        promise.Set(compiler_->CompileXla(std::move(hlo_program),\n+                                          std::move(compile_options)));\n+      }));\n   return std::move(future);\n }\n "
        },
        {
            "sha": "8b1789a43d30c48ac09f68f29c353904eb1508f9",
            "filename": "third_party/xla/xla/python/ifrt/with_user_context.h",
            "status": "added",
            "additions": 103,
            "deletions": 0,
            "changes": 103,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fwith_user_context.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fwith_user_context.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fwith_user_context.h?ref=d221a1e2639ae467ad7dd0ae30184ed5c04d66eb",
            "patch": "@@ -0,0 +1,103 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PYTHON_IFRT_WITH_USER_CONTEXT_H_\n+#define XLA_PYTHON_IFRT_WITH_USER_CONTEXT_H_\n+\n+#include <functional>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"xla/python/ifrt/user_context.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+namespace internal {\n+\n+// Internal implementation of `WithUserContext` and `WithCurrentUserContext`.\n+template <typename Functor>\n+class WithUserContextFunctorImpl {\n+ public:\n+  explicit WithUserContextFunctorImpl(const Functor& functor,\n+                                      UserContextRef user_context)\n+      : functor_(functor), user_context_(std::move(user_context)) {}\n+\n+  explicit WithUserContextFunctorImpl(Functor&& functor,\n+                                      UserContextRef user_context)\n+      : functor_(std::forward<Functor>(functor)),\n+        user_context_(std::move(user_context)) {}\n+\n+  template <typename... Args>\n+  std::invoke_result_t<Functor&, Args&&...> operator()(Args&&... args) & {\n+    UserContextScope user_context_scope(user_context_);\n+    return std::invoke(functor_, std::forward<Args>(args)...);\n+  }\n+\n+  template <typename... Args>\n+  std::invoke_result_t<Functor&&, Args&&...> operator()(Args&&... args) && {\n+    UserContextScope user_context_scope(user_context_);\n+    return std::invoke(std::move(functor_), std::forward<Args>(args)...);\n+  }\n+\n+  template <typename... Args>\n+  std::invoke_result_t<const Functor&, Args&&...> operator()(\n+      Args&&... args) const& {\n+    UserContextScope user_context_scope(user_context_);\n+    return std::invoke(functor_, std::forward<Args>(args)...);\n+  }\n+\n+  template <typename... Args>\n+  std::invoke_result_t<const Functor&&, Args&&...> operator()(\n+      Args&&... args) const&& {\n+    UserContextScope user_context_scope(user_context_);\n+    return std::invoke(std::move(functor_), std::forward<Args>(args)...);\n+  }\n+\n+ private:\n+  Functor functor_;\n+  UserContextRef user_context_;\n+};\n+\n+// Template alias to hide the details of the computed return type of\n+// `WithUserContext` and `WithCurrentUserContext`.\n+template <typename Functor>\n+using WithUserContextFunctor =\n+    WithUserContextFunctorImpl<std::decay_t<Functor>>;\n+\n+}  // namespace internal\n+\n+// Takes an invocable of some kind and returns an invocable that will set the\n+// given user context before invoking `invocable`.\n+template <typename Functor>\n+internal::WithUserContextFunctor<Functor> WithUserContext(\n+    Functor&& invocable, UserContextRef user_context) {\n+  return internal::WithUserContextFunctor<Functor>(\n+      std::forward<Functor>(invocable), std::move(user_context));\n+}\n+\n+// Takes an invocable of some kind and returns an invocable that will set the\n+// current user context before invoking `invocable`.\n+template <typename Functor>\n+internal::WithUserContextFunctor<Functor> WithCurrentUserContext(\n+    Functor&& invocable) {\n+  return internal::WithUserContextFunctor<Functor>(\n+      std::forward<Functor>(invocable), UserContextScope::current());\n+}\n+\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_IFRT_WITH_USER_CONTEXT_H_"
        },
        {
            "sha": "b50fcbdae5cac34e8aeb5a29dd7854e45e565e8e",
            "filename": "third_party/xla/xla/python/ifrt/with_user_context_test.cc",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fwith_user_context_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d221a1e2639ae467ad7dd0ae30184ed5c04d66eb/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fwith_user_context_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fwith_user_context_test.cc?ref=d221a1e2639ae467ad7dd0ae30184ed5c04d66eb",
            "patch": "@@ -0,0 +1,128 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt/with_user_context.h\"\n+\n+#include <functional>\n+#include <optional>\n+#include <utility>\n+\n+#include <gtest/gtest.h>\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/python/ifrt/user_context_test_util.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace {\n+\n+absl::Status CheckUserContext() {\n+  if (UserContextScope::current() == nullptr) {\n+    return absl::InternalError(\"no user context\");\n+  }\n+  if (UserContextScope::current()->Id() != UserContextId(100)) {\n+    return absl::InternalError(absl::StrCat(\n+        \"wrong user context:\", UserContextScope::current()->Id().value()));\n+  }\n+  return absl::OkStatus();\n+}\n+\n+TEST(WithUserContextTest, Function) {\n+  {\n+    std::function<absl::Status()> f =\n+        WithUserContext(std::function<absl::Status()>(CheckUserContext),\n+                        TestUserContext::Create(UserContextId(100)));\n+    TF_EXPECT_OK(f());\n+    TF_EXPECT_OK(std::move(f)());\n+  }\n+  {\n+    const std::function<absl::Status()> f =\n+        WithUserContext(std::function<absl::Status()>(CheckUserContext),\n+                        TestUserContext::Create(UserContextId(100)));\n+    TF_EXPECT_OK(f());\n+    TF_EXPECT_OK(std::move(f)());\n+  }\n+}\n+\n+TEST(WithUserContextTest, AnyInvocable) {\n+  {\n+    absl::AnyInvocable<absl::Status()> f =\n+        WithUserContext(absl::AnyInvocable<absl::Status()>(CheckUserContext),\n+                        TestUserContext::Create(UserContextId(100)));\n+    TF_EXPECT_OK(f());\n+    TF_EXPECT_OK(std::move(f)());\n+  }\n+  {\n+    const absl::AnyInvocable<absl::Status() const> f = WithUserContext(\n+        absl::AnyInvocable<absl::Status() const>(CheckUserContext),\n+        TestUserContext::Create(UserContextId(100)));\n+    TF_EXPECT_OK(f());\n+    TF_EXPECT_OK(std::move(f)());\n+  }\n+}\n+\n+TEST(WithCurrentUserContextTest, Function) {\n+  std::function<absl::Status()> f;\n+  {\n+    UserContextScope user_context_scope(\n+        TestUserContext::Create(UserContextId(100)));\n+    f = WithCurrentUserContext(std::function<absl::Status()>(CheckUserContext));\n+    TF_EXPECT_OK(f());\n+    TF_EXPECT_OK(std::move(f)());\n+  }\n+  {\n+    std::optional<const std::function<absl::Status()>> f;\n+    {\n+      UserContextScope user_context_scope(\n+          TestUserContext::Create(UserContextId(100)));\n+      f.emplace(WithCurrentUserContext(\n+          std::function<absl::Status()>(CheckUserContext)));\n+      TF_EXPECT_OK((*f)());\n+      TF_EXPECT_OK((*std::move(f))());\n+    }\n+  }\n+}\n+\n+TEST(WithCurrentUserContextTest, AnyInvocable) {\n+  {\n+    absl::AnyInvocable<absl::Status()> f;\n+    {\n+      UserContextScope user_context_scope(\n+          TestUserContext::Create(UserContextId(100)));\n+      f = WithCurrentUserContext(\n+          absl::AnyInvocable<absl::Status()>(CheckUserContext));\n+    }\n+    TF_EXPECT_OK(f());\n+    TF_EXPECT_OK(std::move(f)());\n+  }\n+  {\n+    std::optional<const absl::AnyInvocable<absl::Status() const>> f;\n+    {\n+      UserContextScope user_context_scope(\n+          TestUserContext::Create(UserContextId(100)));\n+      f.emplace(WithCurrentUserContext(\n+          absl::AnyInvocable<absl::Status() const>(CheckUserContext)));\n+    }\n+    TF_EXPECT_OK((*f)());\n+    TF_EXPECT_OK((*std::move(f))());\n+  }\n+}\n+\n+}  // namespace\n+}  // namespace ifrt\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 276,
        "additions": 267,
        "deletions": 9
    }
}