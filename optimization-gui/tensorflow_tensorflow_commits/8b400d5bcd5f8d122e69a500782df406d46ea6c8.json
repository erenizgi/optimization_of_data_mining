{
    "author": "tensorflower-gardener",
    "message": "[XLA] Make CheckReplicaGroups() skippable in HloVerifier\n\nPiperOrigin-RevId: 797643761",
    "sha": "8b400d5bcd5f8d122e69a500782df406d46ea6c8",
    "files": [
        {
            "sha": "b51657e28cbe71557a98e1f15a06f11ea0025e00",
            "filename": "third_party/xla/xla/hlo/testlib/hlo_hardware_independent_test_base.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fhlo%2Ftestlib%2Fhlo_hardware_independent_test_base.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fhlo%2Ftestlib%2Fhlo_hardware_independent_test_base.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftestlib%2Fhlo_hardware_independent_test_base.cc?ref=8b400d5bcd5f8d122e69a500782df406d46ea6c8",
            "patch": "@@ -76,6 +76,11 @@ HloHardwareIndependentTestBase::HloHardwareIndependentTestBase(\n       verify_no_collective_deadlocks);\n }\n \n+HloHardwareIndependentTestBase::HloHardwareIndependentTestBase(\n+    HloVerifierOpts&& verifier_opts) {\n+  hlo_verifier_ = std::make_unique<HloVerifier>(std::move(verifier_opts));\n+}\n+\n std::unique_ptr<HloModule>\n HloHardwareIndependentTestBase::CreateNewUnverifiedModule(\n     const std::string& name) const {"
        },
        {
            "sha": "7e411573db764fb71863006c1517f630015a79bd",
            "filename": "third_party/xla/xla/hlo/testlib/hlo_hardware_independent_test_base.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fhlo%2Ftestlib%2Fhlo_hardware_independent_test_base.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fhlo%2Ftestlib%2Fhlo_hardware_independent_test_base.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftestlib%2Fhlo_hardware_independent_test_base.h?ref=8b400d5bcd5f8d122e69a500782df406d46ea6c8",
            "patch": "@@ -85,6 +85,8 @@ class HloHardwareIndependentTestBase : public ::testing::Test {\n       HloPredicate instruction_can_change_layout_func = {},\n       bool verify_no_collective_deadlocks = false);\n \n+  explicit HloHardwareIndependentTestBase(HloVerifierOpts&& verifier_opts);\n+\n   // Creates a new HLO module for a test. The module created will have\n   // TestName() for its name; it will also automatically populate its debug\n   // options from command-line flags. If you want a fresh HloModule object and"
        },
        {
            "sha": "1f96b96a63c217edbae98222dddc406f1e156a40",
            "filename": "third_party/xla/xla/service/hlo_verifier.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 23,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc?ref=8b400d5bcd5f8d122e69a500782df406d46ea6c8",
            "patch": "@@ -498,13 +498,16 @@ static absl::Status CheckReplicaGroups(HloInstruction* hlo,\n }\n \n static absl::Status CheckCommonAllGatherInvariants(\n-    HloInstruction* hlo, int64_t* computed_shard_count) {\n+    HloInstruction* hlo, int64_t* computed_shard_count,\n+    bool check_replica_groups) {\n   auto ag = Cast<HloAllGatherInstruction>(hlo);\n   CHECK_NE(computed_shard_count, nullptr) << \"Expected a shard count as input\";\n   TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n                       GetCollectiveOpGroupMode(ag->channel_id().has_value(),\n                                                ag->use_global_device_ids()));\n-  TF_RETURN_IF_ERROR(CheckReplicaGroups(ag, group_mode));\n+  if (check_replica_groups) {\n+    TF_RETURN_IF_ERROR(CheckReplicaGroups(ag, group_mode));\n+  }\n   TF_RET_CHECK(ag->all_gather_dimension() >= 0);\n   TF_RET_CHECK(ag->operand_count() >= 1);\n \n@@ -547,7 +550,8 @@ static absl::Status CheckCommonAllGatherInvariants(\n absl::Status ShapeVerifier::HandleAllGather(HloInstruction* hlo) {\n   auto ag = Cast<HloAllGatherInstruction>(hlo);\n   int64_t shard_count;\n-  TF_RETURN_IF_ERROR(CheckCommonAllGatherInvariants(hlo, &shard_count));\n+  TF_RETURN_IF_ERROR(CheckCommonAllGatherInvariants(\n+      hlo, &shard_count, opts_.ShouldCheckReplicaGroups()));\n   std::vector<const Shape*> operand_shapes;\n   for (const HloInstruction* operand : hlo->operands()) {\n     operand_shapes.push_back(&operand->shape());\n@@ -560,7 +564,8 @@ absl::Status ShapeVerifier::HandleAllGather(HloInstruction* hlo) {\n absl::Status ShapeVerifier::HandleAllGatherStart(HloInstruction* hlo) {\n   auto ag = Cast<HloAllGatherInstruction>(hlo);\n   int64_t shard_count;\n-  TF_RETURN_IF_ERROR(CheckCommonAllGatherInvariants(hlo, &shard_count));\n+  TF_RETURN_IF_ERROR(CheckCommonAllGatherInvariants(\n+      hlo, &shard_count, opts_.ShouldCheckReplicaGroups()));\n   std::vector<const Shape*> operand_shapes;\n   for (const HloInstruction* operand : hlo->operands()) {\n     operand_shapes.push_back(&operand->shape());\n@@ -577,12 +582,13 @@ absl::Status ShapeVerifier::HandleAllGatherDone(HloInstruction* hlo) {\n \n absl::Status ShapeVerifier::HandleAllReduce(HloInstruction* hlo) {\n   auto ar = Cast<HloAllReduceInstruction>(hlo);\n-  TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n-                      GetCollectiveOpGroupMode(ar->channel_id().has_value(),\n-                                               ar->use_global_device_ids()));\n-  TF_RETURN_IF_ERROR(\n-      CheckReplicaGroups(ar, group_mode, /*uniform_replica_group_size=*/false));\n-\n+  if (opts_.ShouldCheckReplicaGroups()) {\n+    TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n+                        GetCollectiveOpGroupMode(ar->channel_id().has_value(),\n+                                                 ar->use_global_device_ids()));\n+    TF_RETURN_IF_ERROR(CheckReplicaGroups(\n+        ar, group_mode, /*uniform_replica_group_size=*/false));\n+  }\n   std::vector<const Shape*> operand_shapes;\n   for (const HloInstruction* operand : hlo->operands()) {\n     operand_shapes.push_back(&operand->shape());\n@@ -595,7 +601,9 @@ absl::Status ShapeVerifier::HandleReduceScatter(HloInstruction* hlo) {\n   TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n                       GetCollectiveOpGroupMode(ars->channel_id().has_value(),\n                                                ars->use_global_device_ids()));\n-  TF_RETURN_IF_ERROR(CheckReplicaGroups(ars, group_mode));\n+  if (opts_.ShouldCheckReplicaGroups()) {\n+    TF_RETURN_IF_ERROR(CheckReplicaGroups(ars, group_mode));\n+  }\n   TF_RET_CHECK(ars->scatter_dimension() >= 0);\n   TF_RET_CHECK(ars->operand_count() >= 1);\n \n@@ -635,12 +643,13 @@ absl::Status ShapeVerifier::HandleReduceScatter(HloInstruction* hlo) {\n \n absl::Status ShapeVerifier::HandleAllReduceStart(HloInstruction* hlo) {\n   auto ar = Cast<HloAllReduceInstruction>(hlo);\n-  TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n-                      GetCollectiveOpGroupMode(ar->channel_id().has_value(),\n-                                               ar->use_global_device_ids()));\n-  TF_RETURN_IF_ERROR(\n-      CheckReplicaGroups(ar, group_mode, /*uniform_replica_group_size=*/false));\n-\n+  if (opts_.ShouldCheckReplicaGroups()) {\n+    TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n+                        GetCollectiveOpGroupMode(ar->channel_id().has_value(),\n+                                                 ar->use_global_device_ids()));\n+    TF_RETURN_IF_ERROR(CheckReplicaGroups(\n+        ar, group_mode, /*uniform_replica_group_size=*/false));\n+  }\n   std::vector<const Shape*> operand_shapes;\n   for (const HloInstruction* operand : hlo->operands()) {\n     operand_shapes.push_back(&operand->shape());\n@@ -660,8 +669,9 @@ absl::Status ShapeVerifier::HandleAllToAll(HloInstruction* hlo) {\n                       GetCollectiveOpGroupMode(\n                           all_to_all->channel_id().has_value(), std::nullopt));\n \n-  TF_RETURN_IF_ERROR(CheckReplicaGroups(hlo, group_mode));\n-\n+  if (opts_.ShouldCheckReplicaGroups()) {\n+    TF_RETURN_IF_ERROR(CheckReplicaGroups(hlo, group_mode));\n+  }\n   TF_RET_CHECK(all_to_all != nullptr);\n   const int64_t split_count = GetSubgroupSize(all_to_all, group_mode);\n   if (all_to_all->split_dimension()) {\n@@ -683,11 +693,14 @@ absl::Status ShapeVerifier::HandleAllToAll(HloInstruction* hlo) {\n \n absl::Status ShapeVerifier::HandleRaggedAllToAll(HloInstruction* hlo) {\n   auto* all_to_all = Cast<HloRaggedAllToAllInstruction>(hlo);\n-  TF_ASSIGN_OR_RETURN(CollectiveOpGroupMode group_mode,\n-                      GetCollectiveOpGroupMode(\n-                          all_to_all->channel_id().has_value(), std::nullopt));\n+  if (opts_.ShouldCheckReplicaGroups()) {\n+    TF_ASSIGN_OR_RETURN(\n+        CollectiveOpGroupMode group_mode,\n+        GetCollectiveOpGroupMode(all_to_all->channel_id().has_value(),\n+                                 std::nullopt));\n \n-  TF_RETURN_IF_ERROR(CheckReplicaGroups(hlo, group_mode));\n+    TF_RETURN_IF_ERROR(CheckReplicaGroups(hlo, group_mode));\n+  }\n \n   const int64_t kNumRaggedOperands = 6;\n   TF_RET_CHECK(all_to_all != nullptr);"
        },
        {
            "sha": "34df3b6eaaba41004d0f9539b4e5f14adbcb25d8",
            "filename": "third_party/xla/xla/service/hlo_verifier.h",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.h?ref=8b400d5bcd5f8d122e69a500782df406d46ea6c8",
            "patch": "@@ -114,6 +114,11 @@ struct HloVerifierOpts {\n     return std::move(*this);\n   }\n \n+  HloVerifierOpts&& WithCheckReplicaGroups(bool check_replica_groups_p) {\n+    check_replica_groups = check_replica_groups_p;\n+    return std::move(*this);\n+  }\n+\n   bool IsLayoutSensitive() const { return layout_sensitive; }\n \n   bool CheckForCollectiveDeadlocks() const {\n@@ -133,6 +138,8 @@ struct HloVerifierOpts {\n \n   int64_t ShapeSize(const Shape& shape) const { return shape_size(shape); }\n \n+  bool ShouldCheckReplicaGroups() const { return check_replica_groups; }\n+\n   // If the verifier is layout-sensitive, shapes must be equal to what's\n   // expected.  Otherwise, the shapes must simply be compatible.\n   bool layout_sensitive = false;\n@@ -174,6 +181,10 @@ struct HloVerifierOpts {\n   // Check if collectives in the given module will result in a deadlock.\n   bool verify_no_collective_deadlocks = false;\n \n+  // Check if replica groups in collectives are consistent with replica count\n+  // and partition count.\n+  bool check_replica_groups = true;\n+\n   HloPredicate instruction_can_change_layout;\n \n   // Returns a target-specific shape size."
        },
        {
            "sha": "0c874fdbd381ba672ca54385c229764a5fb5dc42",
            "filename": "third_party/xla/xla/service/hlo_verifier_test.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b400d5bcd5f8d122e69a500782df406d46ea6c8/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc?ref=8b400d5bcd5f8d122e69a500782df406d46ea6c8",
            "patch": "@@ -121,6 +121,13 @@ class HloVerifierTestForCollectiveDeadlocks\n             /*verify_no_collective_deadlocks=*/true) {}\n };\n \n+class HloVeriferSkipCheckReplicaGroups : public HloHardwareIndependentTestBase {\n+ public:\n+  HloVeriferSkipCheckReplicaGroups()\n+      : HloHardwareIndependentTestBase(\n+            HloVerifierOpts{}.WithCheckReplicaGroups(false)) {}\n+};\n+\n TEST_F(HloVerifierTest, DifferentOperandParents) {\n   HloComputation::Builder builder(TestName());\n   const Shape scalar_shape = ShapeUtil::MakeShape(F32, {});\n@@ -4654,6 +4661,47 @@ TEST_F(HloVerifierTest, VerifyMatchingSendSameChannelDifferentAttributes) {\n                             \"same channel must be identical\")));\n }\n \n+TEST_F(HloVerifierTest, MismatchPartitionCount) {\n+  const char* const hlo = R\"(\n+HloModule all_gather_module\n+\n+ENTRY main {\n+  %data = f32[1024]{0} parameter(0)\n+  // all-gather on 4 partitions.\n+  ROOT %ag = f32[4096]{0} all-gather(%data),\n+    dimensions={0}, replica_groups={{0,1,2,3}},\n+    use_global_device_ids=true, channel_id=1\n+}\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                          ParseAndReturnUnverifiedModule(hlo));\n+  module->mutable_config().set_replica_count(1);\n+  module->mutable_config().set_num_partitions(8);\n+  EXPECT_THAT(\n+      verifier().Run(module.get()),\n+      absl_testing::StatusIs(absl::StatusCode::kInternal,\n+                             HasSubstr(\"replica groups should contain\")));\n+}\n+\n+TEST_F(HloVeriferSkipCheckReplicaGroups, MismatchPartitionCount) {\n+  const char* const hlo = R\"(\n+HloModule all_gather_module\n+\n+ENTRY main {\n+  %data = f32[1024]{0} parameter(0)\n+  // all-gather on 4 partitions.\n+  ROOT %ag = f32[4096]{0} all-gather(%data),\n+    dimensions={0}, replica_groups={{0,1,2,3}},\n+    use_global_device_ids=true, channel_id=1\n+}\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                          ParseAndReturnUnverifiedModule(hlo));\n+  module->mutable_config().set_replica_count(1);\n+  module->mutable_config().set_num_partitions(8);\n+  EXPECT_THAT(verifier().Run(module.get()), absl_testing::IsOk());\n+}\n+\n TEST_F(HloVerifierTest, ScaledDotWithNoScalesFails) {\n   static constexpr absl::string_view kScaledDotHloString = R\"(\n     HloModule module"
        }
    ],
    "stats": {
        "total": 125,
        "additions": 102,
        "deletions": 23
    }
}