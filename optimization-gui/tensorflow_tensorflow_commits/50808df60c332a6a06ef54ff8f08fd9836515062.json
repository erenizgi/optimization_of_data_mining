{
    "author": "tensorflower-gardener",
    "message": "Add random perturbations to the xla_tpu_msa_sort_order_overrides flag\n\nGiven a user seed, will update the MSA sort order priority of a (small?) number of randomly selected instructions during compilation.\n\nThis causes small perturbations on the compiler's prefetching decisions, which allows for 2 main features:\n\n1. finding out if there is a single instruction which was given a \"wrong\" priority by the compiler so it can be fixed\n- to do this, we run some benchmark many times with different seeds until we find a seed that drastically reduces the compiled code's runtime\n- once we found that seed, we can use binary search to decrease the \"selection range\" and zero-in on the one specific offending instruction\n\n2. finding a lot of small changes that together reduce the runtime\n- we can do this using a \"hill-climbing\" method\n- try many perturbations until you find one slightly better than the baseline.\n- try many followup perturbations (perturbing the best perturbation from the previous stage) until you find one slightly better again\n- repeat until no more improvements are found\n\nNOTE: Right now there's not \"good way\" of finding which instructions had their priority adjusted (especially important in (1) to find the one offending instruction). The only way to do so is to increase the log-level of the compilation debug print and then look at the logs.\nPiperOrigin-RevId: 821309046",
    "sha": "50808df60c332a6a06ef54ff8f08fd9836515062",
    "files": [
        {
            "sha": "ff7db6b67d64c4f437ce34a7a89d83adb8c6cf21",
            "filename": "third_party/xla/xla/service/memory_space_assignment/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2FBUILD?ref=50808df60c332a6a06ef54ff8f08fd9836515062",
            "patch": "@@ -216,8 +216,12 @@ cc_library(\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_googlesource_code_re2//:re2\",\n+        \"@highwayhash\",\n+        \"@highwayhash//:arch_specific\",\n+        \"@highwayhash//:hh_types\",\n         \"@local_tsl//tsl/platform:statusor\",\n     ],\n )"
        },
        {
            "sha": "0f1ed29b50357ac49dc92cc0e688513d16ccdf1a",
            "filename": "third_party/xla/xla/service/memory_space_assignment/memory_space_assignment.proto",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment.proto?ref=50808df60c332a6a06ef54ff8f08fd9836515062",
            "patch": "@@ -131,6 +131,33 @@ message PreferredPrefetchOverrides {\n   repeated PreferredPrefetchOverride overrides = 1;\n }\n \n+// Specifies details on how to randomally select HloPositions for perturbation.\n+//\n+// Each HloPosition is randomally assigned (based on the seed) to a value in the\n+// range [0...1). If it is within the range\n+// [selection_range_begin...selection_range_end) it will have its prefetch\n+// priority overridden based on the value of MsaSortOrderOverrideOptions.\n+// Anything outside this range will be left as-is.\n+//\n+// We use the selection range (rather than just supplying the probability) to be\n+// able to binary search in the case where there's just one instruction that\n+// needs to have its priority fixed.\n+//\n+// The probability of any HloPosition to be perturbed is\n+// selection_range_end-selection_range_begin.\n+//\n+// NOTE: different HloPositions with the same computation graph (the same\n+// instruction fingerprint) will be considered as identical, and hence will\n+// receive the same priority from the HloRandomFilter.\n+message HloRandomFilter {\n+  // Defaults to 1234\n+  optional int64 seed = 1;\n+  // Defaults to 0.\n+  optional double selection_range_begin = 2;\n+  // Defaults to 1.\n+  optional double selection_range_end = 3;\n+}\n+\n // A message that identifies one or more HloPositions.\n message HloPositionMatcher {\n   // Regex to match the entire instruction HLO. The HLO string is constructed\n@@ -149,6 +176,8 @@ message HloPositionMatcher {\n   optional int64 size_lte = 5;\n   // Filters instructions that have a use that matches the filter.\n   optional HloOperandFilter hlo_use_filter = 6;\n+  // Filters instructions randomly.\n+  optional HloRandomFilter hlo_random_filter = 7;\n }\n \n // Options to override preferred prefetch time for an operand.\n@@ -162,6 +191,10 @@ message MsaSortOrderOverrideOptions {\n     // multiple buffers are to be assigned last (within the same override\n     // config) other tie breakers and stable sort order will take effect.\n     bool assign_last = 2;\n+    // Set the specific priority value, where lower values means \"before\" higher\n+    // values. If multiple buffers are to be assigned the same value, other tie\n+    // breakers and stable sort order will take effect.\n+    int64 assign_value = 3;\n   }\n }\n "
        },
        {
            "sha": "399c6c7cde60a7d45b04c25f13c147dcb4de5da0",
            "filename": "third_party/xla/xla/service/memory_space_assignment/memory_space_assignment_test.cc",
            "status": "modified",
            "additions": 165,
            "deletions": 120,
            "changes": 285,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc?ref=50808df60c332a6a06ef54ff8f08fd9836515062",
            "patch": "@@ -5992,6 +5992,15 @@ ENTRY main {\n             kAlternateMemorySpace);\n }\n \n+#define EXPECT_INSTRUCTION_IN(instruction_name, expected_memory_space) \\\n+  {                                                                    \\\n+    HloInstruction* instruction =                                      \\\n+        FindInstruction(module.get(), instruction_name);               \\\n+    EXPECT_EQ(instruction->shape().layout().memory_space(),            \\\n+              expected_memory_space)                                   \\\n+        << \"Instruction name:\" << instruction_name;                    \\\n+  }\n+\n TEST_F(MemorySpaceAssignmentTest,\n        MemoryBoundednessOverrideSortOrderAssignFirst) {\n   absl::string_view hlo_string = R\"(\n@@ -6033,32 +6042,20 @@ TEST_F(MemorySpaceAssignmentTest,\n       /*hlo_cost_options_override=*/std::nullopt,\n       /*optional_msa_sort_order_overrides=*/msa_sort_order_overrides);\n   // Parameters are in the default memory space.\n-  const HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n-  EXPECT_EQ(p0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n-  EXPECT_EQ(p1->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p1\", kDefaultMemorySpace);\n   // Check that all negates are in alternate memory space except negate4.\n   // negate4 is a program output, so it has to land in default memory.\n-  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n-  EXPECT_EQ(negate0->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate1 = FindInstruction(module.get(), \"negate1\");\n-  EXPECT_EQ(negate1->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate2 = FindInstruction(module.get(), \"negate2\");\n-  EXPECT_EQ(negate2->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate3 = FindInstruction(module.get(), \"negate3\");\n-  EXPECT_EQ(negate3->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate4 = FindInstruction(module.get(), \"negate4\");\n-  EXPECT_EQ(negate4->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh0 = FindInstruction(module.get(), \"tanh0\");\n-  EXPECT_EQ(tanh0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh1 = FindInstruction(module.get(), \"tanh1\");\n-  EXPECT_EQ(tanh1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh2 = FindInstruction(module.get(), \"tanh2\");\n-  EXPECT_EQ(tanh2->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh3 = FindInstruction(module.get(), \"tanh3\");\n-  EXPECT_EQ(tanh3->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh4 = FindInstruction(module.get(), \"tanh4\");\n-  EXPECT_EQ(tanh4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate0\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate1\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate2\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate3\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate4\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh2\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh3\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh4\", kDefaultMemorySpace);\n }\n \n TEST_F(MemorySpaceAssignmentTest,\n@@ -6103,32 +6100,20 @@ TEST_F(MemorySpaceAssignmentTest,\n       /*hlo_cost_options_override=*/std::nullopt,\n       /*optional_msa_sort_order_overrides=*/msa_sort_order_overrides);\n   // Parameters are in the default memory space.\n-  const HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n-  EXPECT_EQ(p0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n-  EXPECT_EQ(p1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n-  EXPECT_EQ(negate0->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate1 = FindInstruction(module.get(), \"negate1\");\n-  EXPECT_EQ(negate1->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate2 = FindInstruction(module.get(), \"negate2\");\n-  EXPECT_EQ(negate2->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate3 = FindInstruction(module.get(), \"negate3\");\n-  EXPECT_EQ(negate3->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate4 = FindInstruction(module.get(), \"negate4\");\n+  EXPECT_INSTRUCTION_IN(\"p0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate0\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate1\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate2\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate3\", kAlternateMemorySpace);\n   // negate4 is a program output, so it has to land in default memory.\n-  EXPECT_EQ(negate4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate4\", kDefaultMemorySpace);\n   // Check that all tanhs are in default memory space.\n-  const HloInstruction* tanh0 = FindInstruction(module.get(), \"tanh0\");\n-  EXPECT_EQ(tanh0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh1 = FindInstruction(module.get(), \"tanh1\");\n-  EXPECT_EQ(tanh1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh2 = FindInstruction(module.get(), \"tanh2\");\n-  EXPECT_EQ(tanh2->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh3 = FindInstruction(module.get(), \"tanh3\");\n-  EXPECT_EQ(tanh3->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh4 = FindInstruction(module.get(), \"tanh4\");\n-  EXPECT_EQ(tanh4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh2\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh3\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh4\", kDefaultMemorySpace);\n }\n \n TEST_F(MemorySpaceAssignmentTest,\n@@ -6179,32 +6164,20 @@ TEST_F(MemorySpaceAssignmentTest,\n       /*hlo_cost_options_override=*/std::nullopt,\n       /*optional_msa_sort_order_overrides=*/msa_sort_order_overrides);\n   // Parameters are in the default memory space.\n-  const HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n-  EXPECT_EQ(p0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n-  EXPECT_EQ(p1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n-  EXPECT_EQ(negate0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  HloInstruction* negate1 = FindInstruction(module.get(), \"negate1\");\n-  EXPECT_EQ(negate1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  HloInstruction* negate2 = FindInstruction(module.get(), \"negate2\");\n-  EXPECT_EQ(negate2->shape().layout().memory_space(), kDefaultMemorySpace);\n-  HloInstruction* negate3 = FindInstruction(module.get(), \"negate3\");\n-  EXPECT_EQ(negate3->shape().layout().memory_space(), kDefaultMemorySpace);\n-  HloInstruction* negate4 = FindInstruction(module.get(), \"negate4\");\n-  EXPECT_EQ(negate4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate2\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate3\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate4\", kDefaultMemorySpace);\n   // Check that all tanhs are in alternate memory space except tanh4. tanh4\n   // is a program output, so it has to land in default memory.\n-  const HloInstruction* tanh0 = FindInstruction(module.get(), \"tanh0\");\n-  EXPECT_EQ(tanh0->shape().layout().memory_space(), kAlternateMemorySpace);\n-  const HloInstruction* tanh1 = FindInstruction(module.get(), \"tanh1\");\n-  EXPECT_EQ(tanh1->shape().layout().memory_space(), kAlternateMemorySpace);\n-  const HloInstruction* tanh2 = FindInstruction(module.get(), \"tanh2\");\n-  EXPECT_EQ(tanh2->shape().layout().memory_space(), kAlternateMemorySpace);\n-  const HloInstruction* tanh3 = FindInstruction(module.get(), \"tanh3\");\n-  EXPECT_EQ(tanh3->shape().layout().memory_space(), kAlternateMemorySpace);\n-  const HloInstruction* tanh4 = FindInstruction(module.get(), \"tanh4\");\n-  EXPECT_EQ(tanh4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh0\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh1\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh2\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh3\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh4\", kDefaultMemorySpace);\n }\n \n TEST_F(MemorySpaceAssignmentTest,\n@@ -6255,32 +6228,20 @@ TEST_F(MemorySpaceAssignmentTest,\n       /*hlo_cost_options_override=*/std::nullopt,\n       /*optional_msa_sort_order_overrides=*/msa_sort_order_overrides);\n   // Parameters are in the default memory space.\n-  const HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n-  EXPECT_EQ(p0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n-  EXPECT_EQ(p1->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p1\", kDefaultMemorySpace);\n   // Check that all negates are in alternate memory space except negate4.\n   // negate4 is a program output, so it has to land in default memory.\n-  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n-  EXPECT_EQ(negate0->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate1 = FindInstruction(module.get(), \"negate1\");\n-  EXPECT_EQ(negate1->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate2 = FindInstruction(module.get(), \"negate2\");\n-  EXPECT_EQ(negate2->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate3 = FindInstruction(module.get(), \"negate3\");\n-  EXPECT_EQ(negate3->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate4 = FindInstruction(module.get(), \"negate4\");\n-  EXPECT_EQ(negate4->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh0 = FindInstruction(module.get(), \"tanh0\");\n-  EXPECT_EQ(tanh0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh1 = FindInstruction(module.get(), \"tanh1\");\n-  EXPECT_EQ(tanh1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh2 = FindInstruction(module.get(), \"tanh2\");\n-  EXPECT_EQ(tanh2->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh3 = FindInstruction(module.get(), \"tanh3\");\n-  EXPECT_EQ(tanh3->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh4 = FindInstruction(module.get(), \"tanh4\");\n-  EXPECT_EQ(tanh4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate0\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate1\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate2\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate3\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate4\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh2\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh3\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh4\", kDefaultMemorySpace);\n }\n \n TEST_F(MemorySpaceAssignmentTest,\n@@ -6326,32 +6287,116 @@ TEST_F(MemorySpaceAssignmentTest,\n       /*hlo_cost_options_override=*/std::nullopt,\n       /*optional_msa_sort_order_overrides=*/msa_sort_order_overrides);\n   // Parameters are in the default memory space.\n-  const HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n-  EXPECT_EQ(p0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n-  EXPECT_EQ(p1->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p1\", kDefaultMemorySpace);\n   // Check that all negates are in alternate memory space except negate4.\n   // negate4 is a program output, so it has to land in default memory.\n-  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n-  EXPECT_EQ(negate0->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate1 = FindInstruction(module.get(), \"negate1\");\n-  EXPECT_EQ(negate1->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate2 = FindInstruction(module.get(), \"negate2\");\n-  EXPECT_EQ(negate2->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate3 = FindInstruction(module.get(), \"negate3\");\n-  EXPECT_EQ(negate3->shape().layout().memory_space(), kAlternateMemorySpace);\n-  HloInstruction* negate4 = FindInstruction(module.get(), \"negate4\");\n-  EXPECT_EQ(negate4->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh0 = FindInstruction(module.get(), \"tanh0\");\n-  EXPECT_EQ(tanh0->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh1 = FindInstruction(module.get(), \"tanh1\");\n-  EXPECT_EQ(tanh1->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh2 = FindInstruction(module.get(), \"tanh2\");\n-  EXPECT_EQ(tanh2->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh3 = FindInstruction(module.get(), \"tanh3\");\n-  EXPECT_EQ(tanh3->shape().layout().memory_space(), kDefaultMemorySpace);\n-  const HloInstruction* tanh4 = FindInstruction(module.get(), \"tanh4\");\n-  EXPECT_EQ(tanh4->shape().layout().memory_space(), kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate0\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate1\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate2\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate3\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate4\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh2\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh3\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh4\", kDefaultMemorySpace);\n+}\n+\n+TEST_F(MemorySpaceAssignmentTest,\n+       MemoryBoundednessOverrideSortOrderByRandomFingerprintAssignFirst) {\n+  absl::string_view hlo_string = R\"(\n+  HloModule module, is_scheduled=true\n+\n+  ENTRY entry {\n+    p0 = f32[3,4]{1,0} parameter(0)\n+    p1 = f32[3,4]{1,0} parameter(1)\n+    tanh0 = f32[3,4]{1,0} tanh(p0)\n+    negate0 = f32[3,4]{1,0} negate(p1)\n+    tanh1 = f32[3,4]{1,0} tanh(tanh0)\n+    negate1 = f32[3,4]{1,0} negate(negate0)\n+    tanh2 = f32[3,4]{1,0} tanh(tanh1)\n+    negate2 = f32[3,4]{1,0} negate(negate1)\n+    tanh3 = f32[3,4]{1,0} tanh(tanh2)\n+    negate3 = f32[3,4]{1,0} negate(negate2)\n+    tanh4 = f32[3,4]{1,0} tanh(tanh3)\n+    negate4 = f32[3,4]{1,0} negate(negate3)\n+    ROOT tuple = (f32[3,4]{1,0}, f32[3,4]{1,0}) tuple(tanh4, negate4)\n+  }\n+  )\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  // Override MSA sort order and try to assign all negates to alternate memory\n+  // first. Alternate memory size is enough to fit 2 f32[4,3] tensors at a time.\n+  const std::string text_proto = R\"pb(\n+    overrides {\n+      hlo_position_matcher {\n+        hlo_random_filter {\n+          seed: 123456\n+          selection_range_begin: 0.\n+          selection_range_end: 0.5\n+        }\n+      }\n+      override_options { assign_first: true }\n+    })pb\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto msa_sort_order_overrides,\n+                          ParseTextProto<MsaSortOrderOverrides>(text_proto));\n+\n+  // Show that with this random seed and bound values, we get tanh to pass the\n+  // random filter while negate do not pass the filter.\n+  //\n+  // NOTE that all tanh functions are considered \"identical\" since the filter\n+  // it only uses the \"fingerprint\" of the instruction which is based on the\n+  // computation graph and does not include the name. Same for the negate\n+  // functions.\n+  const auto& hlo_position_matcher =\n+      msa_sort_order_overrides.overrides(0).hlo_position_matcher();\n+  EXPECT_TRUE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"tanh0\")));\n+  EXPECT_TRUE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"tanh1\")));\n+  EXPECT_TRUE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"tanh2\")));\n+  EXPECT_TRUE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"tanh3\")));\n+  EXPECT_TRUE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"tanh4\")));\n+\n+  EXPECT_FALSE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"negate0\")));\n+  EXPECT_FALSE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"negate1\")));\n+  EXPECT_FALSE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"negate2\")));\n+  EXPECT_FALSE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"negate3\")));\n+  EXPECT_FALSE(MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+      hlo_position_matcher, *FindInstruction(module.get(), \"negate4\")));\n+\n+  AssignMemorySpaceUsingCostAnalysis(\n+      module.get(), /*memory_space_options_override=*/std::nullopt,\n+      /*cost_analysis_options_override=*/std::nullopt,\n+      /*hlo_cost_options_override=*/std::nullopt,\n+      /*optional_msa_sort_order_overrides=*/msa_sort_order_overrides);\n+  // Parameters are in the default memory space.\n+  EXPECT_INSTRUCTION_IN(\"p0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"p1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate0\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate1\", kDefaultMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate2\", kDefaultMemorySpace);\n+  // Since the max size is 128 bytes, there's enough space for negate3 to be\n+  // assigned to alternate memory even though it doesn't have priority\n+  EXPECT_INSTRUCTION_IN(\"negate3\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"negate4\", kDefaultMemorySpace);\n+  // Check that all tanh are in alternate memory space except tanh4.\n+  // tanh4 is a program output, so it has to land in default memory.\n+  EXPECT_INSTRUCTION_IN(\"tanh0\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh1\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh2\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh3\", kAlternateMemorySpace);\n+  EXPECT_INSTRUCTION_IN(\"tanh4\", kDefaultMemorySpace);\n }\n \n TEST_F(MemorySpaceAssignmentTest, SimpleWhileTupleTest) {"
        },
        {
            "sha": "fc7ae9bca271f5977d79ca1bd4508249e91f5d54",
            "filename": "third_party/xla/xla/service/memory_space_assignment/utils.cc",
            "status": "modified",
            "additions": 92,
            "deletions": 16,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Futils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Futils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Futils.cc?ref=50808df60c332a6a06ef54ff8f08fd9836515062",
            "patch": "@@ -18,16 +18,23 @@ limitations under the License.\n #include <cstdint>\n #include <limits>\n #include <optional>\n+#include <random>\n+#include <string>\n \n #include \"absl/algorithm/container.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"highwayhash/arch_specific.h\"\n+#include \"highwayhash/hh_types.h\"\n+#include \"highwayhash/highwayhash.h\"\n #include \"re2/re2.h\"\n #include \"xla/hlo/ir/hlo_casting_utils.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/utils/hlo_live_range.h\"\n #include \"xla/service/heap_simulator/heap_simulator.h\"\n #include \"xla/service/hlo_value.h\"\n@@ -38,6 +45,12 @@ limitations under the License.\n \n namespace xla {\n namespace memory_space_assignment {\n+namespace {\n+\n+// The default seed used by HloRandomFilter when no seed is given.\n+const int64_t kRandomFilterDefaultSeed = 1234;\n+\n+}  // namespace\n \n bool MemorySpaceAssignmentUtils::IsValueAllowedInAlternateMemory(\n     const HloValue* value, int64_t alternate_memory_space) {\n@@ -147,6 +160,78 @@ bool MemorySpaceAssignmentUtils::DoesUseMatchFilter(\n   return true;\n }\n \n+double GetInstructionUniformRandom(const HloInstruction& instruction,\n+                                   int64_t seed) {\n+  // We use the instruction Fingerprint because it's robust across different\n+  // runs and compilations, as well as because it depends only on the\n+  // isomorphic computation graph of the instruction rather than the variable\n+  // names. We would like to make identical decisions for identical\n+  // instructions.\n+  //\n+  // See HloPrintOptions::Fingerprint() for details.\n+  //\n+  // If in the future that turns out to not be good enough, we can also pass an\n+  // option in the proto to choose different string representations of the\n+  // instructions - for example, the name or \"instruction.ToString()\" if we want\n+  // a finer grained perturbation, or alternatively the\n+  // \"instruction.SignatureString()\" if we want a coarser perturbation.\n+  const std::string& instruction_identifier =\n+      instruction.ToString(HloPrintOptions::Fingerprint());\n+  std::string instruction_seed_str = absl::StrCat(\n+      instruction_identifier.size(), \":\", instruction_identifier, \":\", seed);\n+\n+  // We use highwayhash as our hashing function, because it is \"Strong\",\n+  // relatively fast, and \"all (64/128/256 bit) variants of HighwayHash frozen,\n+  // i.e. unchanging forever\" which is good for test stability and repeatability\n+  // of experiments.\n+\n+  // PI in hex\n+  static constexpr highwayhash::HHKey hash_key = {\n+      0x3243F6A8885A308Dull,\n+      0x313198A2E0370734ull,\n+      0x4A4093822299F31Dull,\n+      0x0082EFA98EC4E6C8ull,\n+  };\n+\n+  highwayhash::HHStateT<HH_TARGET> state(hash_key);\n+  highwayhash::HHResult64 seed_result;\n+  highwayhash::HighwayHashT(&state, instruction_seed_str.data(),\n+                            instruction_seed_str.size(), &seed_result);\n+\n+  // Assuming highwayhash is a \"good\" hash and uniformly distributed across all\n+  // 64 bits, we could probably skip the step of going through the random\n+  // library to generate our uniform [0...1) random.\n+  //\n+  // We add this anyway to make it clear we're looking for a uniform random\n+  // number.\n+  std::mt19937_64 gen(seed_result);\n+  return std::uniform_real_distribution<double>()(gen);\n+}\n+\n+bool MemorySpaceAssignmentUtils::DoesInstructionMatchRandomFilter(\n+    const HloPositionMatcher& filter, const HloInstruction& instruction) {\n+  if (!filter.has_hlo_random_filter()) {\n+    // This HloPositionMatcher doesn't have a random filter. We return that we\n+    // aren't blocking this instruction.\n+    return true;\n+  }\n+  const auto& hlo_random_filter = filter.hlo_random_filter();\n+  double selection_range_begin = 0.;\n+  if (hlo_random_filter.has_selection_range_begin()) {\n+    selection_range_begin = hlo_random_filter.selection_range_begin();\n+  }\n+  double selection_range_end = 1.;\n+  if (hlo_random_filter.has_selection_range_end()) {\n+    selection_range_end = hlo_random_filter.selection_range_end();\n+  }\n+  int64_t seed = kRandomFilterDefaultSeed;\n+  if (hlo_random_filter.has_seed()) {\n+    seed = hlo_random_filter.seed();\n+  }\n+  double rnd = GetInstructionUniformRandom(instruction, seed);\n+  return rnd >= selection_range_begin && rnd < selection_range_end;\n+}\n+\n bool MemorySpaceAssignmentUtils::DoesPositionMatchFilter(\n     const HloPositionMatcher& filter,\n     const MsaBufferInterval& buffer_interval) {\n@@ -165,7 +250,8 @@ bool MemorySpaceAssignmentUtils::DoesPositionMatchFilter(\n     return false;\n   }\n   return DoesInstructionMatchFilter(filter, *instruction) &&\n-         DoesBufferIntervalMatchHloUseFilter(filter, buffer_interval);\n+         DoesBufferIntervalMatchHloUseFilter(filter, buffer_interval) &&\n+         DoesInstructionMatchRandomFilter(filter, *instruction);\n }\n \n bool MemorySpaceAssignmentUtils::DoesInstructionMatchFilter(\n@@ -301,21 +387,9 @@ MemorySpaceAssignmentUtils::GetOverriddenPreferredPrefetchTime(\n bool MemorySpaceAssignmentUtils::DoesCrossProgramPrefetchBufferMatchAnyFilter(\n     const MsaSortOrderOverrides& sort_order_overrides,\n     const MsaBufferInterval& buffer_interval) {\n-  for (const MsaSortOrderOverride& override :\n-       sort_order_overrides.overrides()) {\n-    if (override.has_apply_to_cross_program_prefetches() &&\n-        override.apply_to_cross_program_prefetches() &&\n-        MemorySpaceAssignmentUtils::DoesPositionMatchFilter(\n-            override.hlo_position_matcher(), buffer_interval) &&\n-        override.override_options().has_assign_first() &&\n-        override.override_options().assign_first()) {\n-      VLOG(3) << \"Cross program prefetch buffer \"\n-              << buffer_interval.buffer->ToString()\n-              << \" matches sort order override \" << override.DebugString();\n-      return true;\n-    }\n-  }\n-  return false;\n+  return GetBufferIntervalOverridePriority(\n+             sort_order_overrides, buffer_interval,\n+             /*is_cross_program_prefetch=*/true) < 0;\n }\n \n int64_t MemorySpaceAssignmentUtils::GetBufferIntervalOverridePriority(\n@@ -342,6 +416,8 @@ int64_t MemorySpaceAssignmentUtils::GetBufferIntervalOverridePriority(\n         return std::numeric_limits<int64_t>::lowest() + i;\n       case MsaSortOrderOverrideOptions::kAssignLast:\n         return std::numeric_limits<int64_t>::max() - i;\n+      case MsaSortOrderOverrideOptions::kAssignValue:\n+        return override.override_options().assign_value();\n       case MsaSortOrderOverrideOptions::OPTIONS_NOT_SET:\n         continue;\n     }"
        },
        {
            "sha": "df7817d3aa2693fa25c9dfd0306eff9d5fd4ce76",
            "filename": "third_party/xla/xla/service/memory_space_assignment/utils.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Futils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/50808df60c332a6a06ef54ff8f08fd9836515062/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Futils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Futils.h?ref=50808df60c332a6a06ef54ff8f08fd9836515062",
            "patch": "@@ -41,8 +41,7 @@ class MemorySpaceAssignmentUtils {\n   // Returns true if this buffer is allowed to be placed in the alternate\n   // memory.\n   static bool IsIntervalAllowedInAlternateMemory(\n-      const GlobalDecreasingSizeBestFitHeap<HloValue>::BufferInterval& interval,\n-      int64_t alternate_memory_space);\n+      const MsaBufferInterval& interval, int64_t alternate_memory_space);\n \n   // Returns true if the HloValue is allowed to be placed in alternate memory.\n   static bool IsValueAllowedInAlternateMemory(const HloValue* value,\n@@ -54,6 +53,9 @@ class MemorySpaceAssignmentUtils {\n   static bool DoesInstructionMatchFilter(const HloPositionMatcher& filter,\n                                          const HloInstruction& instruction);\n \n+  static bool DoesInstructionMatchRandomFilter(\n+      const HloPositionMatcher& filter, const HloInstruction& instruction);\n+\n   static bool DoesPositionMatchFilter(const HloPositionMatcher& filter,\n                                       const MsaBufferInterval& buffer_interval);\n "
        }
    ],
    "stats": {
        "total": 436,
        "additions": 298,
        "deletions": 138
    }
}