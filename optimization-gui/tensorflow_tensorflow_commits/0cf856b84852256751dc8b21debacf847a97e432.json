{
    "author": "tensorflower-gardener",
    "message": "[SymbolicExpr] Refactor SymbolicMap::ToString to mimic mlir::AffineMap format.\n\nUpdates the `SymbolicMap::ToString()` method to produce output in a format similar to MLIR's AffineMap, for example: `(d0, d1)[s0, s1] -> ((d0 + s0), (d1 * s1))`.\n\nThis involves:\n-   Modifying `SymbolicMap::ToString()` to construct the new string format.\n-   Updating `SymbolicExpr::ToString()` to accept a `num_dims` parameter to correctly distinguish between dimension and symbol variables in the output string (e.g., `d0` vs `s0`).\n-   Adjusting test cases in `symbolic_map_test.cc` to match the new expected string format.\n\nPiperOrigin-RevId: 801820444",
    "sha": "0cf856b84852256751dc8b21debacf847a97e432",
    "files": [
        {
            "sha": "d56a6a5f37d56eb0563c73f5701252992c42d2d5",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD?ref=0cf856b84852256751dc8b21debacf847a97e432",
            "patch": "@@ -219,7 +219,6 @@ cc_library(\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/strings\",\n-        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n     ],"
        },
        {
            "sha": "5e073cf6637792560816278d4d4121eb7d138058",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 7,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc?ref=0cf856b84852256751dc8b21debacf847a97e432",
            "patch": "@@ -590,26 +590,36 @@ bool SymbolicExpr::operator<(const SymbolicExpr& other) const {\n   }\n }\n \n-std::string SymbolicExpr::ToString() const {\n+std::string SymbolicExpr::ToString(int64_t num_dims) const {\n   switch (GetType()) {\n     case SymbolicExprType::kConstant:\n       return std::to_string(GetValue());\n-    case SymbolicExprType::kVariable:\n-      return absl::StrCat(\"v\", GetValue());\n+    case SymbolicExprType::kVariable: {\n+      int64_t var_id = GetValue();\n+      if (num_dims == -1) {\n+        return absl::StrCat(\"v\", var_id);\n+      }\n+      // If num_dims is provided, then the first num_dims variables are\n+      // dimensions, and the rest are symbols.\n+      if (var_id < num_dims) {\n+        return absl::StrCat(\"d\", var_id);\n+      }\n+      return absl::StrCat(\"s\", var_id - num_dims);\n+    }\n     case SymbolicExprType::kAdd:\n     case SymbolicExprType::kMul:\n     case SymbolicExprType::kFloorDiv:\n     case SymbolicExprType::kCeilDiv:\n     case SymbolicExprType::kMod: {\n       auto bin_op_str = GetBinaryOpString(GetType());\n-      return absl::StrCat(\"(\", GetLHS().ToString(), \" \", bin_op_str, \" \",\n-                          GetRHS().ToString(), \")\");\n+      return absl::StrCat(\"(\", GetLHS().ToString(num_dims), \" \", bin_op_str,\n+                          \" \", GetRHS().ToString(num_dims), \")\");\n     }\n     case SymbolicExprType::kMax:\n     case SymbolicExprType::kMin: {\n       auto bin_op_str = GetBinaryOpString(GetType());\n-      return absl::StrCat(bin_op_str, \"(\", GetLHS().ToString(), \", \",\n-                          GetRHS().ToString(), \")\");\n+      return absl::StrCat(bin_op_str, \"(\", GetLHS().ToString(num_dims), \", \",\n+                          GetRHS().ToString(num_dims), \")\");\n     }\n     default:\n       LOG(FATAL) << \"unknown type on symbolic expressions\";"
        },
        {
            "sha": "a03d62cd19161eef4c4dc3aac7b5e7e840fdfd5c",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h?ref=0cf856b84852256751dc8b21debacf847a97e432",
            "patch": "@@ -66,7 +66,9 @@ class SymbolicExpr {\n   SymbolicExpr GetLHS() const;\n   SymbolicExpr GetRHS() const;\n   int64_t GetValue() const;\n-  std::string ToString() const;\n+  // If num_dims is provided, then the first num_dims variables are dimensions,\n+  // and the rest are symbols.\n+  std::string ToString(int64_t num_dims = -1) const;\n   int64_t Evaluate(absl::Span<const int64_t> variable_values) const;\n   SymbolicExpr ReplaceVariables(\n       absl::Span<const SymbolicExpr> substitutions) const;"
        },
        {
            "sha": "2acd764938b69f03ef8eaf40937e8db693e88eab",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc?ref=0cf856b84852256751dc8b21debacf847a97e432",
            "patch": "@@ -49,6 +49,18 @@ TEST_F(SymbolicExprTest, CreateAndPrint) {\n                   \"((((v0 + 42) * max(min(v1, 2), 0)) floordiv 2) ceildiv 2)\"));\n }\n \n+TEST_F(SymbolicExprTest, PrintWithDifferentNumDimensions) {\n+  SymbolicExpr expr = v0 * 2 + v1;\n+\n+  EXPECT_THAT(expr.ToString(), MatchIndexingString(\"((v0 * 2) + v1)\"));\n+  // Only symbols\n+  EXPECT_THAT(expr.ToString(0), MatchIndexingString(\"((s0 * 2) + s1)\"));\n+  // One dimension and one symbol\n+  EXPECT_THAT(expr.ToString(1), MatchIndexingString(\"((d0 * 2) + s0)\"));\n+  // Only dimensions\n+  EXPECT_THAT(expr.ToString(2), MatchIndexingString(\"((d0 * 2) + d1)\"));\n+}\n+\n TEST_F(SymbolicExprTest, ParseAndPrint) {\n   const std::string kStringContainingAllOperators =\n       \"((((v0 + 42) * max(min(v1, 2), 0)) floordiv 2) ceildiv 2)\";"
        },
        {
            "sha": "ce61821b37c626c013075a1d9701024912063de0",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 10,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map.cc?ref=0cf856b84852256751dc8b21debacf847a97e432",
            "patch": "@@ -73,17 +73,23 @@ SymbolicMap::SymbolicMap(SymbolicExprContext* ctx, int64_t num_dimensions,\n }\n \n std::string SymbolicMap::ToString() const {\n-  std::string str = absl::StrCat(\"SymbolicMap(dims=\", num_dimensions_,\n-                                 \", symbols=\", num_symbols_, \", results=[\");\n-  absl::StrAppend(&str, absl::StrJoin(exprs_, \",\\\\n\",\n-                                      [](std::string* out, const auto& expr) {\n-                                        absl::StrAppend(out, \"  \", expr);\n-                                      }));\n-  if (!IsEmpty()) {\n-    absl::StrAppend(&str, \"\\\\n\");\n+  std::string out = \"(\";\n+  for (int i = 0; i < GetNumDims(); ++i) {\n+    absl::StrAppend(&out, (i > 0 ? \", \" : \"\"), \"d\", i);\n   }\n-  absl::StrAppend(&str, \"])\");\n-  return str;\n+  out += \")[\";\n+  for (int i = 0; i < GetNumSymbols(); ++i) {\n+    absl::StrAppend(&out, (i > 0 ? \", \" : \"\"), \"s\", i);\n+  }\n+  out += \"] -> (\";\n+\n+  absl::StrAppend(\n+      &out,\n+      absl::StrJoin(GetResults(), \", \", [&](std::string* s, const auto& expr) {\n+        absl::StrAppend(s, expr.ToString(GetNumDims()));\n+      }));\n+  out += \")\";\n+  return out;\n }\n \n bool SymbolicMap::IsIdentity() const {"
        },
        {
            "sha": "f6f508db1115635598789957626d13c653f9515b",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 9,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0cf856b84852256751dc8b21debacf847a97e432/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_test.cc?ref=0cf856b84852256751dc8b21debacf847a97e432",
            "patch": "@@ -26,17 +26,27 @@ namespace {\n \n using ::testing::ElementsAre;\n \n-// TODO(karupayun): Make ToString print similarly to AffineMap. It should be\n-// aware of the dimension and symbol names.\n TEST(SymbolicMapTest, ToString) {\n   SymbolicExprContext ctx;\n-  SymbolicMap map =\n-      SymbolicMap::Get(&ctx, 2, 1,\n-                       {ctx.CreateVariable(0) + ctx.CreateVariable(2),\n-                        ctx.CreateVariable(1) * ctx.CreateVariable(3)});\n-  EXPECT_EQ(map.ToString(),\n-            \"SymbolicMap(dims=2, symbols=1, results=[  (v0 + v2),\\\\n  (v1 * \"\n-            \"v3)\\\\n])\");\n+  SymbolicExpr d0 = ctx.CreateVariable(0);\n+  SymbolicExpr d1 = ctx.CreateVariable(1);\n+  SymbolicExpr s0 = ctx.CreateVariable(2);\n+  SymbolicExpr s1 = ctx.CreateVariable(3);\n+\n+  SymbolicMap map = SymbolicMap::Get(&ctx, 2, 2, {d0 + s0, d1 * s1});\n+  EXPECT_EQ(map.ToString(), \"(d0, d1)[s0, s1] -> ((d0 + s0), (d1 * s1))\");\n+\n+  SymbolicMap empty_map = SymbolicMap::Get(&ctx, 0, 0, {});\n+  EXPECT_EQ(empty_map.ToString(), \"()[] -> ()\");\n+\n+  SymbolicMap dims_only = SymbolicMap::Get(&ctx, 2, 0, {d0, d1});\n+  EXPECT_EQ(dims_only.ToString(), \"(d0, d1)[] -> (d0, d1)\");\n+\n+  SymbolicExpr s0_no_dims = ctx.CreateVariable(0);\n+  SymbolicExpr s1_no_dims = ctx.CreateVariable(1);\n+  SymbolicMap symbols_only =\n+      SymbolicMap::Get(&ctx, 0, 2, {s0_no_dims, s1_no_dims});\n+  EXPECT_EQ(symbols_only.ToString(), \"()[s0, s1] -> (s0, s1)\");\n }\n \n TEST(SymbolicMapTest, IsEmpty) {"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 67,
        "deletions": 28
    }
}