{
    "author": "hyeontaek",
    "message": "[IFRT] Fix a race condition in `UserContextRegistry`\n\nThere is a small window where `TrackedUserContext` is being destroyed by having\nno more strong references (`TrackedUserContextRef`) but has not finished\ncalling `UserContextRegistry::Unregister()`. During this window, the entry for\n`TrackedUserContext` exists in the registry, but a new strong reference\n`TrackedUserContextRef` cannot be created from a weak reference. This creates a\nproblem if there are multiple threads concurrently registering user contexts\nwith the same ID (e.g., fingerprinting-based ID), or unregistration and lookup\nhappen concurrently.\n\nThis change fixes this race condition by tracking the raw pointer to\n`TrackedUserContext`. The registry can preemptively unregister such a stale\nitem, and unregisteration can ignore the already removed entry in such a way.\nLookups are also updated to gracefully handle stale entry, ignoring its\npresence in the registry.\n\nPiperOrigin-RevId: 806371795",
    "sha": "9cbb39f55ff4c50663d2651bc0c1010ee12a8017",
    "files": [
        {
            "sha": "68627b3c5d5ca9b04e8d0d998524dcce4755673f",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=9cbb39f55ff4c50663d2651bc0c1010ee12a8017",
            "patch": "@@ -1143,7 +1143,6 @@ cc_library(\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/base:no_destructor\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n-        \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/synchronization\",\n     ],\n )\n@@ -1155,7 +1154,11 @@ xla_cc_test(\n         \":user_context\",\n         \":user_context_registry\",\n         \"//xla/tsl/concurrency:ref_count\",\n+        \"//xla/tsl/platform:env\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/memory\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@llvm-project//llvm:Support\",\n     ],"
        },
        {
            "sha": "94a1d37674168c5b9baf88faa6ce35316a29b9a2",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 17,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc?ref=9cbb39f55ff4c50663d2651bc0c1010ee12a8017",
            "patch": "@@ -20,7 +20,6 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/base/no_destructor.h\"\n-#include \"absl/log/check.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"xla/python/ifrt/user_context.h\"\n \n@@ -41,26 +40,31 @@ TrackedUserContextRef UserContextRegistry::Register(\n     // If the user context is already registered, return the existing\n     // `TrackedUserContextRef`. This will avoid duplicate `Unregister()` calls\n     // for the same user context ID.\n-    TrackedUserContextRef tracked_user_context = it->second.lock();\n-    CHECK(tracked_user_context != nullptr)\n-        << \"Unexpected dangling reference for user context ID: \" << id;\n-    return tracked_user_context;\n+    TrackedUserContextRef tracked_user_context = it->second.first.lock();\n+    if (tracked_user_context != nullptr) {\n+      return tracked_user_context;\n+    }\n+    // We can fail to obtain a shared pointer when `TrackedUserContext` just has\n+    // lost the last reference, but it has not called `Unregister()` yet. We\n+    // proactively unregister the stale entry and proceed to register a new one.\n+    registry_.erase(it);\n   }\n   auto tracked_user_context = std::shared_ptr<TrackedUserContext>(\n       new TrackedUserContext(id, std::move(user_context)));\n-  registry_.insert(\n-      {id, std::weak_ptr<TrackedUserContext>(tracked_user_context)});\n+  registry_.insert({id,\n+                    {std::weak_ptr<TrackedUserContext>(tracked_user_context),\n+                     tracked_user_context.get()}});\n   return tracked_user_context;\n }\n \n TrackedUserContextRef UserContextRegistry::Lookup(UserContextId id) const {\n   absl::MutexLock lock(&mu_);\n   auto it = registry_.find(id);\n   if (it != registry_.end()) {\n-    TrackedUserContextRef tracked_user_context = it->second.lock();\n-    CHECK(tracked_user_context != nullptr)\n-        << \"Unexpected dangling reference for user context ID: \" << id;\n-    return tracked_user_context;\n+    // This may return `nullptr` if the `TrackedUserContext` has been destroyed\n+    // but `Unregister()` has not been called yet. This is acceptable behavior\n+    // because `nullptr` means that no matching `UserContext` is found.\n+    return it->second.first.lock();\n   }\n   return nullptr;\n }\n@@ -70,17 +74,21 @@ std::vector<TrackedUserContextRef> UserContextRegistry::LookupAll() const {\n   std::vector<TrackedUserContextRef> tracked_user_contexts;\n   tracked_user_contexts.reserve(registry_.size());\n   for (auto it = registry_.begin(); it != registry_.end(); ++it) {\n-    TrackedUserContextRef tracked_user_context = it->second.lock();\n-    CHECK(tracked_user_context != nullptr)\n-        << \"Unexpected dangling reference for user context ID: \" << it->first;\n-    tracked_user_contexts.push_back(std::move(tracked_user_context));\n+    TrackedUserContextRef tracked_user_context = it->second.first.lock();\n+    if (tracked_user_context != nullptr) {\n+      tracked_user_contexts.push_back(std::move(tracked_user_context));\n+    }\n   }\n   return tracked_user_contexts;\n }\n \n-void UserContextRegistry::Unregister(UserContextId id) {\n+void UserContextRegistry::Unregister(\n+    UserContextId id, const TrackedUserContext* tracked_user_context) {\n   absl::MutexLock lock(&mu_);\n-  CHECK_EQ(registry_.erase(id), 1);\n+  auto it = registry_.find(id);\n+  if (it != registry_.end() && it->second.second == tracked_user_context) {\n+    registry_.erase(it);\n+  }\n }\n \n }  // namespace ifrt"
        },
        {
            "sha": "5b2003f56fea1314941bf69a63809c943af70ae9",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry.h",
            "status": "modified",
            "additions": 12,
            "deletions": 6,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.h?ref=9cbb39f55ff4c50663d2651bc0c1010ee12a8017",
            "patch": "@@ -79,14 +79,20 @@ class UserContextRegistry {\n  private:\n   friend TrackedUserContext;\n \n-  // Removes a `TrackedUserContext` entry identified by `id` from the\n-  // registry.\n-  void Unregister(UserContextId id);\n+  // Removes a `TrackedUserContext` entry identified by `id` from the registry.\n+  // If the existing entry does not point to `tracked_user_context`, this is a\n+  // no-op.\n+  void Unregister(UserContextId id,\n+                  const TrackedUserContext* tracked_user_context);\n \n   mutable absl::Mutex mu_;\n   // A map from `UserContext::Fingerprint()` to a weak reference of\n-  // `TrackedUserContext`.\n-  absl::flat_hash_map<UserContextId, std::weak_ptr<TrackedUserContext>>\n+  // `TrackedUserContext`. The raw pointer is used for handling a race condition\n+  // between `Register()` and destruction of `TrackedUserContext` for the same\n+  // ID.\n+  absl::flat_hash_map<\n+      UserContextId,\n+      std::pair<std::weak_ptr<TrackedUserContext>, const TrackedUserContext*>>\n       registry_ ABSL_GUARDED_BY(mu_);\n };\n \n@@ -98,7 +104,7 @@ class TrackedUserContext {\n   TrackedUserContext(const TrackedUserContext&) = delete;\n   TrackedUserContext(TrackedUserContext&&) = delete;\n \n-  ~TrackedUserContext() { UserContextRegistry::Get().Unregister(id_); }\n+  ~TrackedUserContext() { UserContextRegistry::Get().Unregister(id_, this); }\n \n   const UserContextRef& user_context() const { return user_context_; }\n "
        },
        {
            "sha": "a8e5717b68cfef6f90b4b0f7af16ee00f922d010",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry_test.cc",
            "status": "modified",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9cbb39f55ff4c50663d2651bc0c1010ee12a8017/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry_test.cc?ref=9cbb39f55ff4c50663d2651bc0c1010ee12a8017",
            "patch": "@@ -16,14 +16,20 @@ limitations under the License.\n #include \"xla/python/ifrt/user_context_registry.h\"\n \n #include <cstdint>\n+#include <memory>\n #include <string>\n+#include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/log/check.h\"\n+#include \"absl/memory/memory.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/synchronization/barrier.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/python/ifrt/user_context.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n+#include \"xla/tsl/platform/env.h\"\n \n namespace xla {\n namespace ifrt {\n@@ -97,6 +103,58 @@ TEST(UserContextRegistryTest, Unregister) {\n   EXPECT_EQ(UserContextRegistry::Get().Lookup(kUserContextId), nullptr);\n }\n \n+TEST(UserContextRegistryTest, ConcurrentAccess) {\n+  const int kNumThreads = 4;\n+  const int kRepeats = 100000;\n+\n+  absl::Barrier barrier(kNumThreads);\n+  std::vector<std::unique_ptr<tsl::Thread>> threads;\n+\n+  const UserContextId kUserContextId(100);\n+  for (int i = 0; i < 2; ++i) {\n+    threads.push_back(absl::WrapUnique(\n+        tsl::Env::Default()->StartThread(tsl::ThreadOptions(), \"test\", [&]() {\n+          barrier.Block();\n+          for (int i = 0; i < kRepeats; ++i) {\n+            UserContextRef user_context =\n+                TestUserContext::Create(kUserContextId);\n+            TrackedUserContextRef tracked_user_context =\n+                UserContextRegistry::Get().Register(user_context);\n+            CHECK_NE(tracked_user_context, nullptr);\n+            CHECK_EQ(tracked_user_context->user_context()->Id(),\n+                     kUserContextId);\n+          }\n+        })));\n+  }\n+  threads.push_back(absl::WrapUnique(\n+      tsl::Env::Default()->StartThread(tsl::ThreadOptions(), \"test\", [&]() {\n+        barrier.Block();\n+        for (int i = 0; i < kRepeats; ++i) {\n+          TrackedUserContextRef tracked_user_context =\n+              UserContextRegistry::Get().Lookup(kUserContextId);\n+          if (tracked_user_context != nullptr) {\n+            CHECK_EQ(tracked_user_context->user_context()->Id(),\n+                     kUserContextId);\n+          }\n+        }\n+      })));\n+  threads.push_back(absl::WrapUnique(\n+      tsl::Env::Default()->StartThread(tsl::ThreadOptions(), \"test\", [&]() {\n+        barrier.Block();\n+        for (int i = 0; i < kRepeats; ++i) {\n+          std::vector<TrackedUserContextRef> tracked_user_contexts =\n+              UserContextRegistry::Get().LookupAll();\n+          if (!tracked_user_contexts.empty()) {\n+            CHECK_EQ(tracked_user_contexts.size(), 1);\n+            CHECK_EQ(tracked_user_contexts.front()->user_context()->Id(),\n+                     kUserContextId);\n+          }\n+        }\n+      })));\n+  CHECK_EQ(threads.size(), kNumThreads);\n+  threads.clear();  // Join all threads.\n+}\n+\n }  // namespace\n }  // namespace ifrt\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 123,
        "additions": 99,
        "deletions": 24
    }
}