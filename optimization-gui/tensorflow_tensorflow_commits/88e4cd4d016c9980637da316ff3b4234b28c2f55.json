{
    "author": "bchetioui",
    "message": "[XLA] Use `TiledHloSchedule` in `SymbolicTileAnalysis`.\n\nWe can now produce arbitrary iteration patterns for output tiles, simply by\nparametrizing calls to `ComputeTiledHloInstructions` with different\n`TiledHloSchedule`s.\n\nPiperOrigin-RevId: 821796530",
    "sha": "88e4cd4d016c9980637da316ff3b4234b28c2f55",
    "files": [
        {
            "sha": "ffa94d166fa4e91c470dff2bbd88969b08bb8e61",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -239,6 +239,7 @@ cc_library(\n         \"//xla/codegen/tiling:tiled_hlo_computation\",\n         \"//xla/codegen/tiling:tiled_hlo_fusion_instruction\",\n         \"//xla/codegen/tiling:tiled_hlo_instruction\",\n+        \"//xla/codegen/tiling:tiled_hlo_schedule\",\n         \"//xla/codegen/xtile/ir:xtile\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/service:hlo_module_config\","
        },
        {
            "sha": "91d6103c13cec031b1efb604717b1d1e4761e06b",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/fusion_emitter.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -107,6 +107,7 @@ limitations under the License.\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n #include \"xla/codegen/tiling/tiled_hlo_fusion_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/builder/xla_builder.h\"\n #include \"xla/hlo/ir/hlo_casting_utils.h\"\n@@ -1780,7 +1781,7 @@ absl::Status EmitGeneric(mlir::OpBuilder builder,\n   TF_RET_CHECK(root_index < symbolic_tile_analysis.GetRoots().size());\n   TF_ASSIGN_OR_RETURN(TiledHloComputation tiled_hlo_computation,\n                       symbolic_tile_analysis.ComputeTiledHloInstructions(\n-                          tiling,\n+                          tiling, CreateMajorToMinorTiledHloSchedule,\n                           /*constraints_are_known_satisfied=*/false,\n                           /*compute_all_tile_offset_indexing_maps=*/true));\n   VLOG(3) << \"EmitGeneric: tiled HLO computation:\\n\""
        },
        {
            "sha": "a25587cad1fcdecdad9fd1bb1700cb045b987ccd",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 65,
            "changes": 112,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.cc?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -58,6 +58,7 @@ limitations under the License.\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n #include \"xla/codegen/tiling/tiled_hlo_fusion_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n #include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_analysis.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n@@ -151,60 +152,12 @@ llvm::SmallVector<int64_t> GetNumberOfTilesPerDimension(\n   return result;\n }\n \n-// Helper to produce a map from a program id to tile offsets.\n-//\n-// `tile_offsets_indexing` takes in as many parameters as there are tiling\n-// parameters in the whole fusion, but we don't always want to linearize\n-// indexing into the whole parameter space.\n-//\n-// In order to linearize indices over only a subset of the axes, we provide a\n-// vector `major_to_minor_active_tiling_parameters` that indicates which\n-// parameters are \"active\" (i.e. where the relevant axis should be taken into\n-// account), and in which order (major-to-minor) the axes should be processed.\n-IndexingMap LinearizeTileOffsets(\n-    const IndexingMap& tile_offsets_indexing,\n-    absl::Span<const int64_t> num_output_tiles_per_dim,\n-    absl::Span<const int64_t> major_to_minor_active_tiling_parameters,\n-    gpu::SymbolicExprContext* symbolic_expr_context) {\n-  MLIRContext* mlir_context = symbolic_expr_context->GetMLIRContext();\n-  // Gather the active output tile sizes in major-to-minor order so as to\n-  // produce the right delinearized index.\n-  std::vector<int64_t> active_num_output_tiles_per_dim;\n-  active_num_output_tiles_per_dim.reserve(\n-      major_to_minor_active_tiling_parameters.size());\n-  for (int64_t dim_id : major_to_minor_active_tiling_parameters) {\n-    active_num_output_tiles_per_dim.push_back(num_output_tiles_per_dim[dim_id]);\n-  }\n-  int64_t num_tiles = Product(num_output_tiles_per_dim);\n-  CHECK_EQ(num_tiles, Product(active_num_output_tiles_per_dim));\n-  mlir::AffineExpr program_id = mlir::getAffineDimExpr(0, mlir_context);\n-  std::vector<mlir::AffineExpr> tile_exprs(\n-      num_output_tiles_per_dim.size(),\n-      mlir::getAffineConstantExpr(0, mlir_context));\n-  for (auto [dim_id, tile_expr] :\n-       llvm::zip(major_to_minor_active_tiling_parameters,\n-                 DelinearizeIndex(active_num_output_tiles_per_dim, program_id,\n-                                  symbolic_expr_context))) {\n-    tile_exprs[dim_id] = tile_expr;\n-  }\n-  std::vector<IndexingMap::Variable> dim_vars{{0, num_tiles - 1, \"pid_0\"}};\n-  IndexingMap program_id_to_output_dims{\n-      mlir::AffineMap::get(\n-          /*dimCount=*/1, /*symbolCount=*/0, tile_exprs, mlir_context),\n-      dim_vars, /*range_vars=*/{}, /*rt_vars=*/{}};\n-  auto linearized_tile_offsets_indexing =\n-      ComposeIndexingMaps(program_id_to_output_dims, tile_offsets_indexing);\n-  linearized_tile_offsets_indexing.Simplify();\n-  linearized_tile_offsets_indexing.RescaleSymbols();\n-  linearized_tile_offsets_indexing.RemoveUnusedSymbols();\n-  return linearized_tile_offsets_indexing;\n-}\n-\n // Creates the concrete tiling of an output of the computation from the\n // indexing map of the computation's root and the tile sizes.\n absl::StatusOr<OutputTilingInfo> ComputeOutputTilingInfo(\n     const IndexingMap& root_indexing, absl::Span<const int64_t> tile_sizes,\n     absl::Span<const int64_t> major_to_minor_active_tiling_parameters,\n+    const TiledHloSchedule& schedule,\n     gpu::SymbolicExprContext* symbolic_expr_context,\n     const std::optional<absl::Span<const Interval>>&\n         parent_output_tile_dim_bounds = std::nullopt) {\n@@ -223,6 +176,8 @@ absl::StatusOr<OutputTilingInfo> ComputeOutputTilingInfo(\n   llvm::SmallVector<std::pair<mlir::AffineExpr, Interval>> constraints;\n \n   std::vector<Interval> all_dim_bounds = root_indexing.GetDimensionBounds();\n+  std::vector<DimensionInfo> iteration_space;\n+  iteration_space.reserve(major_to_minor_active_tiling_parameters.size());\n   for (int64_t dim_id : major_to_minor_active_tiling_parameters) {\n     const Interval& dim_bounds = all_dim_bounds[dim_id];\n     int64_t tile_size = tile_sizes[dim_id];\n@@ -261,6 +216,7 @@ absl::StatusOr<OutputTilingInfo> ComputeOutputTilingInfo(\n                        ToString(root_indexing)));\n     }\n     outer_loop_bounds[dim_id] = upper_bound;\n+    iteration_space.push_back({dim_id, upper_bound});\n \n     // TODO(b/393299275): naming is not correct as that might also be a nested\n     // tile parameter.\n@@ -277,16 +233,15 @@ absl::StatusOr<OutputTilingInfo> ComputeOutputTilingInfo(\n       dim_vars, /*range_vars=*/{}, /*rt_vars=*/root_indexing.GetRTVars(),\n       constraints};\n \n-  // TODO(b/417977182): revisit linearization. This makes it hard to do things\n-  // like grid tiling, for instance.\n-  IndexingMap linear_output_tile_offset_indexing = LinearizeTileOffsets(\n-      output_tile_offset_indexing, outer_loop_bounds,\n-      major_to_minor_active_tiling_parameters, symbolic_expr_context);\n+  TF_ASSIGN_OR_RETURN(\n+      IndexingMap program_id_to_tile_offsets,\n+      schedule.Schedule(output_tile_offset_indexing, iteration_space,\n+                        symbolic_expr_context));\n   return OutputTilingInfo{outer_loop_bounds,\n                           output_tile_offset_indexing,\n                           {major_to_minor_active_tiling_parameters.begin(),\n                            major_to_minor_active_tiling_parameters.end()},\n-                          linear_output_tile_offset_indexing};\n+                          program_id_to_tile_offsets};\n }\n \n // Extension of SymbolicTiledHloInstruction for fusions that holds the analysis\n@@ -931,6 +886,7 @@ SymbolicTileAnalysis::AnalyzeNestedFusion(\n           root->parameter_number());\n     }\n   }\n+  CHECK_EQ(nested_roots.size(), 1);\n   RootIndexing nested_root_indexing{/*real_root_index=*/0,\n                                     /*roots=*/nested_roots,\n                                     /*real_root_indexing=*/indexing_map};\n@@ -1414,7 +1370,27 @@ namespace {\n // returns a FailedPrecondition error if not.\n absl::StatusOr<bool> IsSafeForBufferSharing(\n     const TiledHloInstruction& output, int64_t reference_num_output_tiles,\n+    const TiledHloSchedule& schedule,\n     gpu::SymbolicExprContext* symbolic_expr_context) {\n+  // TODO(b/453611980): this function can not behave well with regards to\n+  // schedules other than the default major-to-minor. This is because\n+  // non-trivial schedules require understanding the semantics of the iteration\n+  // space (i.e. what tiling parameters correspond to what dimension of the\n+  // iteration space), and the call to `ComputeOutputTilingInfo` below will\n+  // sometimes use a different number of tiling parameters, or a different\n+  // ordering for them, without giving us the ability to easily recoup this\n+  // information.\n+  //\n+  // To remediate this issue in the short-term, we just return an error if a\n+  // non-default schedule is provided here. In the long-term, the proper\n+  // solution will be to construct a single iteration space that will be used\n+  // consistently for tiling and scheduling. (This is already the case\n+  // everywhere else than here.)\n+  if (!dynamic_cast<const MajorToMinorTiledHloSchedule*>(&schedule)) {\n+    return absl::UnimplementedError(\n+        \"Buffer sharing is only supported with the default schedule\");\n+  }\n+\n   // For expanding reshapes, we can have the case that the number of\n   // blocks are different. This is not supported by the triton emitter.\n   llvm::SmallVector<int64_t> num_tiles_per_dim =\n@@ -1430,11 +1406,10 @@ absl::StatusOr<bool> IsSafeForBufferSharing(\n   auto iota = llvm::seq<int64_t>(0, output.hlo()->shape().dimensions().size());\n   std::vector<int64_t> major_to_minor_active_tiling_parameters(iota.begin(),\n                                                                iota.end());\n-\n   TF_ASSIGN_OR_RETURN(\n       auto tiling_info,\n       ComputeOutputTilingInfo(identity_indexing_map, output.tile_sizes(),\n-                              major_to_minor_active_tiling_parameters,\n+                              major_to_minor_active_tiling_parameters, schedule,\n                               symbolic_expr_context));\n \n   // Check whether the tile_offsets_indexing expression is the same as one\n@@ -1454,6 +1429,7 @@ absl::StatusOr<std::vector<const TiledHloInstruction*>> InitializeTiledRoots(\n     absl::Span<const HloInstruction* const> roots,\n     const std::vector<std::unique_ptr<TiledHloInstruction>>&\n         tiled_hlo_instructions,\n+    const TiledHloSchedule& schedule,\n     absl::Span<const int64_t> num_output_tiles_per_dim,\n     gpu::SymbolicExprContext* symbolic_expr_context) {\n   // TODO(b/390559452): Investigate whether it is faster to use linear lookup.\n@@ -1486,7 +1462,7 @@ absl::StatusOr<std::vector<const TiledHloInstruction*>> InitializeTiledRoots(\n         bool valid, IsSafeForBufferSharing(*tiled_hlo_instr,\n                                            /*reference_num_output_tiles=*/\n                                            Product(num_output_tiles_per_dim),\n-                                           symbolic_expr_context));\n+                                           schedule, symbolic_expr_context));\n     if (!valid) {\n       continue;\n     }\n@@ -1527,6 +1503,7 @@ std::vector<int64_t> ExtractDimensionIds(AffineExpr expr) {\n absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructionsImpl(\n     const SymbolicTileAnalysis& analysis,\n     const FlatTiling& flat_tiling_parameters,\n+    const TiledHloSchedule& tiled_hlo_schedule,\n     std::vector<int64_t> major_to_minor_active_tiling_parameters,\n     bool compute_all_tile_offset_indexing_maps,\n     const std::optional<absl::Span<const Interval>>&\n@@ -1536,6 +1513,7 @@ absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructionsImpl(\n                         TiledHloInstruction*>\n         symbolic_to_tiled_hlo_map) {\n   const IndexingMap& real_root_indexing = analysis.GetRealRootIndexing();\n+\n   for (mlir::AffineExpr expr : real_root_indexing.GetAffineMap().getResults()) {\n     for (int64_t dim_id : ExtractDimensionIds(expr)) {\n       if (absl::c_find(major_to_minor_active_tiling_parameters, dim_id) ==\n@@ -1614,7 +1592,7 @@ absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructionsImpl(\n       OutputTilingInfo output_tiling_info,\n       ComputeOutputTilingInfo(real_root_indexing, flat_tiling_parameters,\n                               major_to_minor_active_tiling_parameters,\n-                              symbolic_expr_context,\n+                              tiled_hlo_schedule, symbolic_expr_context,\n                               parent_output_tile_dim_bounds));\n \n   VLOG(3) << \"output_tiling_info: \" << output_tiling_info.ToString(\"; \");\n@@ -1684,7 +1662,7 @@ absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructionsImpl(\n           auto tiled_hlo_computation,\n           ComputeTiledHloInstructionsImpl(\n               symbolic_fusion_tiling->analysis_, flat_tiling_parameters,\n-              major_to_minor_active_tiling_parameters,\n+              tiled_hlo_schedule, major_to_minor_active_tiling_parameters,\n               compute_all_tile_offset_indexing_maps, fusion_tile_dim_bounds,\n               symbolic_expr_context, symbolic_to_tiled_hlo_map));\n \n@@ -1713,9 +1691,9 @@ absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructionsImpl(\n   auto tiled_hlo_instructions = tiled_hlo_instructions_set.ExtractData();\n   TF_ASSIGN_OR_RETURN(\n       auto tiled_roots,\n-      InitializeTiledRoots(analysis.GetRoots(), tiled_hlo_instructions,\n-                           output_tiling_info.num_output_tiles_per_dim,\n-                           symbolic_expr_context));\n+      InitializeTiledRoots(\n+          analysis.GetRoots(), tiled_hlo_instructions, tiled_hlo_schedule,\n+          output_tiling_info.num_output_tiles_per_dim, symbolic_expr_context));\n   return TiledHloComputation::FromSortedTiledHloInstructions(\n       std::move(tiled_hlo_instructions), tiled_roots,\n       output_tiling_info.num_output_tiles_per_dim);\n@@ -1725,7 +1703,8 @@ absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructionsImpl(\n \n absl::StatusOr<TiledHloComputation>\n SymbolicTileAnalysis::ComputeTiledHloInstructions(\n-    const Tiling& tiling, bool constraints_are_known_satisfied,\n+    const Tiling& tiling, const TiledHloScheduleBuilder& schedule_builder,\n+    bool constraints_are_known_satisfied,\n     bool compute_all_tile_offset_indexing_maps) const {\n   // We first check that the provided tiling satisfies the constraints, if\n   // necessary. We do this here instead of in `ComputeTiledHloInstructionsImpl`\n@@ -1742,8 +1721,11 @@ SymbolicTileAnalysis::ComputeTiledHloInstructions(\n   TF_ASSIGN_OR_RETURN(FlatTiling flat_tiling_parameters,\n                       tiling.Flatten(GetTilingSpecification()));\n \n+  TF_ASSIGN_OR_RETURN(std::unique_ptr<TiledHloSchedule> tiled_hlo_schedule,\n+                      schedule_builder(GetTilingSpecification()));\n+\n   return ComputeTiledHloInstructionsImpl(\n-      *this, flat_tiling_parameters,\n+      *this, flat_tiling_parameters, *tiled_hlo_schedule,\n       /*major_to_minor_active_tiling_parameters=*/{},\n       compute_all_tile_offset_indexing_maps,\n       /*parent_output_tile_dim_bounds=*/std::nullopt, symbolic_expr_context_,"
        },
        {
            "sha": "a7d311d552b0d9095c31c52a3cbb216a6b5ce144",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis.h",
            "status": "modified",
            "additions": 18,
            "deletions": 8,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis.h?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -32,6 +32,7 @@ limitations under the License.\n #include \"mlir/IR/MLIRContext.h\"\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n #include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n@@ -100,6 +101,10 @@ using EmitterSpecificConstraintsBuilder =\n         const std::vector<std::unique_ptr<SymbolicTiledHloInstruction>>&,\n         const HloFusionAdaptor&)>;\n \n+using TiledHloScheduleBuilder =\n+    std::function<absl::StatusOr<std::unique_ptr<TiledHloSchedule>>(\n+        const TilingSpecification&)>;\n+\n // Constructs and holds symbolic tiles for all the instructions within a\n // computation. The analysis may hold several different symbolic tiles for the\n // same instruction if the instruction is indexed in several different ways in\n@@ -140,13 +145,19 @@ class SymbolicTileAnalysis {\n   // constraints are satisfied by the chosen tiling parameters. Setting\n   // `constraints_are_known_satisfied` to true bypasses this check.\n   //\n-  // `TiledHloInstruction` will have tile offset indexing map set if either:\n-  // - compute_all_tile_offset_indexing_maps == true, or\n-  // - there are at least two `TiledHloInstruction`s with the same hash. In that\n-  //   case we need tile offset indexing map to decide if we can deduplicate\n-  //   those instruction.\n+  // `TiledHloInstruction`s will have their `tile_offset_indexing_map` set if\n+  // either:\n+  // - `compute_all_tile_offset_indexing_maps` is set, or\n+  // - `compute_all_tile_offset_indexing_maps` is not set, but there are at\n+  //   least two `TiledHloInstruction`s with the same hash. In that case,\n+  //   `tile_offset_indexing_map`s are necessary to deduplicate operations.\n+  // In either case, the iteration pattern for the `TiledHloInstruction`s will\n+  // be dictated by the schedule derived from the provided schedule builder.\n   absl::StatusOr<TiledHloComputation> ComputeTiledHloInstructions(\n-      const ::xla::Tiling& tiling, bool constraints_are_known_satisfied = false,\n+      const Tiling& tiling,\n+      const TiledHloScheduleBuilder& schedule_builder =\n+          CreateMajorToMinorTiledHloSchedule,\n+      bool constraints_are_known_satisfied = false,\n       bool compute_all_tile_offset_indexing_maps = false) const;\n \n   // Returns the roots of the computation in increasing order of their output\n@@ -189,8 +200,7 @@ class SymbolicTileAnalysis {\n   //\n   // Returns `false` if the tiling does not conform to the tiling\n   // specification.\n-  absl::StatusOr<bool> ParametersSatisfyConstraints(\n-      const ::xla::Tiling& tiling) const;\n+  absl::StatusOr<bool> ParametersSatisfyConstraints(const Tiling& tiling) const;\n \n   // Return the underlying MLIRContext.\n   mlir::MLIRContext* GetMLIRContext() const {"
        },
        {
            "sha": "8e94c481401174e728f76a4de6f747e563c5b7c3",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_analysis_test.cc",
            "status": "modified",
            "additions": 168,
            "deletions": 46,
            "changes": 214,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_analysis_test.cc?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -34,13 +34,15 @@ limitations under the License.\n #include \"absl/status/status_matchers.h\"\n #include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/strings/substitute.h\"\n #include \"absl/types/span.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"xla/codegen/tiling/constraint_expression.h\"\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n #include \"xla/codegen/tiling/tiled_hlo_fusion_instruction.h\"\n #include \"xla/codegen/tiling/tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n #include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n@@ -189,6 +191,8 @@ class SymbolicTileAnalysisTest : public HloHardwareIndependentTestBase {\n   }\n \n   mlir::MLIRContext mlir_context_;\n+  TiledHloScheduleBuilder default_schedule_builder_ =\n+      CreateMajorToMinorTiledHloSchedule;\n   gpu::SymbolicExprContext symbolic_expr_context_{&mlir_context_};\n };\n \n@@ -221,6 +225,7 @@ ENTRY main {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({1, 10})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -277,7 +282,8 @@ ENTRY main {\n \n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              Tiling({{fusion_root, FlatTiling({1, 10})}})));\n+                              Tiling({{fusion_root, FlatTiling({1, 10})}}),\n+                              default_schedule_builder_));\n \n   const TiledHloInstruction* root = tiled_hlo_computation.GetRoots()[0];\n \n@@ -309,6 +315,7 @@ ENTRY entry_computation {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({1, 8})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -368,7 +375,8 @@ ENTRY main {\n \n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis.ComputeTiledHloInstructions(\n-                              Tiling({{fusion_root, FlatTiling({1, 97})}})));\n+                              Tiling({{fusion_root, FlatTiling({1, 97})}}),\n+                              default_schedule_builder_));\n \n   const TiledHloInstruction* root = tiled_hlo_computation.GetRoots()[0];\n \n@@ -465,11 +473,12 @@ ENTRY entry_computation {\n                                        ->fused_expression_root()\n                                        ->operand(0);\n \n-  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n-                          analysis->ComputeTiledHloInstructions(\n-                              Tiling({{add_root, FlatTiling({2, 4})}}),\n-                              /*constraints_are_known_satisfied=*/false,\n-                              /*compute_all_tile_offset_indexing_maps=*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TiledHloComputation tiled_hlo_computation,\n+      analysis->ComputeTiledHloInstructions(\n+          Tiling({{add_root, FlatTiling({2, 4})}}), default_schedule_builder_,\n+          /*constraints_are_known_satisfied=*/false,\n+          /*compute_all_tile_offset_indexing_maps=*/false));\n   const auto& roots = tiled_hlo_computation.GetRoots();\n   EXPECT_EQ(roots.size(), 2);\n   EXPECT_THAT(*roots[0], MatchTiledHloInstruction(\n@@ -514,7 +523,7 @@ ENTRY entry_computation {\n                                              ->operand(0);\n \n   auto maybe_tiled_hlo_computation = analysis->ComputeTiledHloInstructions(\n-      Tiling({{broadcast_root, FlatTiling({1, 4})}}),\n+      Tiling({{broadcast_root, FlatTiling({1, 4})}}), default_schedule_builder_,\n       /*constraints_are_known_satisfied=*/false,\n       /*compute_all_tile_offset_indexing_maps=*/false);\n   EXPECT_THAT(\n@@ -552,6 +561,7 @@ ENTRY entry_computation {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{reshape_root, FlatTiling({1, 4})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/false));\n   const auto& roots = tiled_hlo_computation.GetRoots();\n@@ -600,7 +610,7 @@ ENTRY entry_computation {\n                                            ->operand(0);\n \n   auto maybe_tiled_hlo_computation = analysis->ComputeTiledHloInstructions(\n-      Tiling({{reshape_root, FlatTiling({1, 16})}}),\n+      Tiling({{reshape_root, FlatTiling({1, 16})}}), default_schedule_builder_,\n       /*constraints_are_known_satisfied=*/false,\n       /*compute_all_tile_offset_indexing_maps=*/false);\n   EXPECT_THAT(\n@@ -637,7 +647,7 @@ ENTRY entry_computation {\n                                            ->operand(0);\n \n   auto maybe_tiled_hlo_computation = analysis->ComputeTiledHloInstructions(\n-      Tiling({{reshape_root, FlatTiling({1, 16})}}),\n+      Tiling({{reshape_root, FlatTiling({1, 16})}}), default_schedule_builder_,\n       /*constraints_are_known_satisfied=*/false,\n       /*compute_all_tile_offset_indexing_maps=*/false);\n   EXPECT_THAT(\n@@ -672,11 +682,12 @@ ENTRY entry_computation {\n                                            ->fused_expression_root()\n                                            ->operand(0);\n \n-  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n-                          analysis->ComputeTiledHloInstructions(\n-                              Tiling({{reshape_root, FlatTiling({4})}}),\n-                              /*constraints_are_known_satisfied=*/false,\n-                              /*compute_all_tile_offset_indexing_maps=*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TiledHloComputation tiled_hlo_computation,\n+      analysis->ComputeTiledHloInstructions(\n+          Tiling({{reshape_root, FlatTiling({4})}}), default_schedule_builder_,\n+          /*constraints_are_known_satisfied=*/false,\n+          /*compute_all_tile_offset_indexing_maps=*/false));\n   const auto& roots = tiled_hlo_computation.GetRoots();\n   EXPECT_EQ(roots.size(), 2);\n   EXPECT_THAT(*roots[0], MatchTiledHloInstruction(\n@@ -715,6 +726,7 @@ ENTRY main {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({2, 4, 2})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -760,6 +772,7 @@ ENTRY main {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({2, 2})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -816,7 +829,7 @@ ENTRY main {\n   Tiling tiling(Tiling::TileMapping{{dot_hlo, {8, 2, 2}}});\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              tiling,\n+                              tiling, default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -879,7 +892,7 @@ ENTRY main {\n       {dot_hlo, {kContractingTileSize, kLhsTileSize, kRhsTileSize}}});\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              tiling,\n+                              tiling, default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -986,7 +999,7 @@ ENTRY main {\n       module->entry_computation()->root_instruction()->fused_expression_root();\n \n   auto result = analysis->ComputeTiledHloInstructions(\n-      Tiling({{fusion_root, FlatTiling({2})}}),\n+      Tiling({{fusion_root, FlatTiling({2})}}), default_schedule_builder_,\n       /*constraints_are_known_satisfied=*/false,\n       /*compute_all_tile_offset_indexing_maps=*/true);\n   ASSERT_THAT(result.status(),\n@@ -1067,12 +1080,14 @@ ENTRY main {\n \n   // Passing tile parameters that do not satisfy the constraints should result\n   // in an error...\n-  EXPECT_THAT(analysis->ComputeTiledHloInstructions(impossible_tile_parameters),\n+  EXPECT_THAT(analysis->ComputeTiledHloInstructions(impossible_tile_parameters,\n+                                                    default_schedule_builder_),\n               absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n \n   // ... unless we pinky-promise (lie) that they satisfy the constraints ;)\n   TF_EXPECT_OK(analysis->ComputeTiledHloInstructions(\n-      impossible_tile_parameters, /*constraints_are_known_satisfied=*/true));\n+      impossible_tile_parameters, default_schedule_builder_,\n+      /*constraints_are_known_satisfied=*/true));\n }\n \n TEST_F(SymbolicTileAnalysisTest, EmitterSpecificConstraintsAreUsedCorrectly) {\n@@ -1396,6 +1411,7 @@ ENTRY main {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({1, 1})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -1449,6 +1465,7 @@ ENTRY main {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({1, 1})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -1508,11 +1525,12 @@ ENTRY entry_computation {\n   const HloInstruction* fusion_root =\n       module->entry_computation()->root_instruction()->fused_expression_root();\n \n-  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n-                          analysis->ComputeTiledHloInstructions(\n-                              Tiling({{fusion_root, FlatTiling({1})}}),\n-                              /*constraints_are_known_satisfied=*/false,\n-                              /*compute_all_tile_offset_indexing_maps=*/true));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TiledHloComputation tiled_hlo_computation,\n+      analysis->ComputeTiledHloInstructions(\n+          Tiling({{fusion_root, FlatTiling({1})}}), default_schedule_builder_,\n+          /*constraints_are_known_satisfied=*/false,\n+          /*compute_all_tile_offset_indexing_maps=*/true));\n   const TiledHloInstruction* d2 = tiled_hlo_computation.GetRoots()[0];\n   const TiledHloInstruction* d1 = d2->operand(0);\n   const TiledHloInstruction* convert = d1->operand(0);\n@@ -1609,6 +1627,7 @@ ENTRY e {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({2, 4, 8})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n   const TiledHloInstruction* dot = tiled_hlo_computation.GetRoots()[0];\n@@ -1682,7 +1701,7 @@ ENTRY e {\n   Tiling tiling = Tiling(Tiling::TileMapping({{root, {1, 1, 1, 1, 32}}}));\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              tiling,\n+                              tiling, default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n   absl::flat_hash_map<int64_t, const TiledHloInstruction*> parameter_tiling =\n@@ -1743,7 +1762,7 @@ ENTRY e {\n       Tiling::TileMapping{{ds_hlo, {2, 4}}, {ds_hlo->operand(0), {8}}});\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              tiling,\n+                              tiling, default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n   const TiledHloInstruction* dynamic_slice =\n@@ -1865,11 +1884,12 @@ ENTRY main {\n   const HloInstruction* fusion_root =\n       module->entry_computation()->root_instruction()->fused_expression_root();\n \n-  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n-                          analysis->ComputeTiledHloInstructions(\n-                              Tiling({{fusion_root, FlatTiling({4})}}),\n-                              /*constraints_are_known_satisfied=*/false,\n-                              /*compute_all_tile_offset_indexing_maps=*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TiledHloComputation tiled_hlo_computation,\n+      analysis->ComputeTiledHloInstructions(\n+          Tiling({{fusion_root, FlatTiling({4})}}), default_schedule_builder_,\n+          /*constraints_are_known_satisfied=*/false,\n+          /*compute_all_tile_offset_indexing_maps=*/false));\n \n   const TiledHloInstruction* iota = tiled_hlo_computation.GetRoots()[0];\n   EXPECT_THAT(iota->tile_offsets_indexing().status(), absl_testing::IsOk());\n@@ -1922,7 +1942,7 @@ ENTRY main {\n   Tiling dot_tiling = Tiling(Tiling::TileMapping({{dot_hlo, {8, 128, 32}}}));\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              /*tiling=*/dot_tiling,\n+                              /*tiling=*/dot_tiling, default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -1994,11 +2014,12 @@ ENTRY main {\n   const HloInstruction* fusion_root =\n       module->entry_computation()->root_instruction()->fused_expression_root();\n \n-  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n-                          analysis->ComputeTiledHloInstructions(\n-                              Tiling({{fusion_root, FlatTiling({2})}}),\n-                              /*constraints_are_known_satisfied=*/false,\n-                              /*compute_all_tile_offset_indexing_maps=*/true));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TiledHloComputation tiled_hlo_computation,\n+      analysis->ComputeTiledHloInstructions(\n+          Tiling({{fusion_root, FlatTiling({2})}}), default_schedule_builder_,\n+          /*constraints_are_known_satisfied=*/false,\n+          /*compute_all_tile_offset_indexing_maps=*/true));\n   const TiledHloInstruction* root = tiled_hlo_computation.GetRoots()[0];\n   EXPECT_THAT(*root, MatchTiledHloInstruction(\n                          /*tile_sizes=*/{2}, /*tile_strides=*/{1},\n@@ -2111,11 +2132,12 @@ ENTRY main {\n   const HloInstruction* fusion_root =\n       module->entry_computation()->root_instruction()->fused_expression_root();\n \n-  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n-                          analysis->ComputeTiledHloInstructions(\n-                              Tiling({{fusion_root, FlatTiling({32})}}),\n-                              /*constraints_are_known_satisfied=*/false,\n-                              /*compute_all_tile_offset_indexing_maps=*/true));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TiledHloComputation tiled_hlo_computation,\n+      analysis->ComputeTiledHloInstructions(\n+          Tiling({{fusion_root, FlatTiling({32})}}), default_schedule_builder_,\n+          /*constraints_are_known_satisfied=*/false,\n+          /*compute_all_tile_offset_indexing_maps=*/true));\n \n   // Gather the three nested fusions present in the module, in order.\n   std::vector<const TiledHloFusionInstruction*> nested_fusions(3, nullptr);\n@@ -2157,7 +2179,7 @@ ENTRY main {\n   // results in the tiling being rejected, even if we pretend that `33`\n   // satisfies the constraints.\n   auto tiled_hlo_computation_or = analysis->ComputeTiledHloInstructions(\n-      Tiling({{fusion_root, FlatTiling({33})}}),\n+      Tiling({{fusion_root, FlatTiling({33})}}), default_schedule_builder_,\n       /*constraints_are_known_satisfied=*/true,\n       /*compute_all_tile_offset_indexing_maps=*/false);\n \n@@ -2213,6 +2235,7 @@ ENTRY main {\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n                               Tiling({{fusion_root, FlatTiling({16, 32})}}),\n+                              default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -2259,7 +2282,7 @@ ENTRY main {\n   // results in the tiling being rejected, even if we pretend that `33`\n   // satisfies the constraints.\n   auto tiled_hlo_computation_or = analysis->ComputeTiledHloInstructions(\n-      Tiling({{fusion_root, FlatTiling({16, 33})}}),\n+      Tiling({{fusion_root, FlatTiling({16, 33})}}), default_schedule_builder_,\n       /*constraints_are_known_satisfied=*/true,\n       /*compute_all_tile_offset_indexing_maps=*/false);\n \n@@ -2313,7 +2336,7 @@ ENTRY main {\n   Tiling tiling(Tiling::TileMapping{{dot_hlo, {32, 16, 16}}});\n   TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n                           analysis->ComputeTiledHloInstructions(\n-                              tiling,\n+                              tiling, default_schedule_builder_,\n                               /*constraints_are_known_satisfied=*/false,\n                               /*compute_all_tile_offset_indexing_maps=*/true));\n \n@@ -2419,5 +2442,104 @@ ENTRY main {\n       analysis->GetTilingSpecification().constraints().IsAlwaysSatisfied());\n }\n \n+TEST_F(SymbolicTileAnalysisTest,\n+       DotIndexingWorksAsExpectedWithTransposedDotSchedule) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+\n+lhs {\n+  ROOT p0 = f32[2,4,8] parameter(0)\n+}\n+\n+rhs {\n+  ROOT p0 = f32[2,8,16] parameter(0)\n+}\n+\n+fusion {\n+  p0 = f32[2,4,8] parameter(0)\n+  p1 = f32[2,8,16] parameter(1)\n+\n+  lhs = f32[2,4,8] fusion(p0), kind=kCustom, calls=lhs\n+  rhs = f32[2,8,16] fusion(p1), kind=kCustom, calls=rhs\n+\n+  ROOT dot = f32[2,4,16] dot(lhs, rhs),\n+    lhs_batch_dims={0}, rhs_batch_dims={0},\n+    lhs_contracting_dims={2}, rhs_contracting_dims={1}\n+}\n+\n+ENTRY main {\n+  p0 = f32[2,4,8] parameter(0)\n+  p1 = f32[2,8,16] parameter(1)\n+  ROOT fusion = f32[2,4,16] fusion(p0, p1), kind=kLoop, calls=fusion\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const HloInstruction* dot_hlo =\n+      module->entry_computation()->root_instruction()->fused_expression_root();\n+  constexpr int tile_batch = 1;\n+  constexpr int tile_m = 2;\n+  constexpr int tile_n = 8;\n+  constexpr int tile_k = 8;\n+  Tiling tiling(\n+      Tiling::TileMapping{{dot_hlo, {tile_k, tile_batch, tile_m, tile_n}}});\n+  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n+                          analysis->ComputeTiledHloInstructions(\n+                              tiling, TransposedDotTiledHloSchedule::Create,\n+                              /*constraints_are_known_satisfied=*/false,\n+                              /*compute_all_tile_offset_indexing_maps=*/true));\n+\n+  int64_t m = dot_hlo->shape().dimensions(1);\n+  int64_t n = dot_hlo->shape().dimensions(2);\n+\n+  ASSERT_EQ(dot_hlo->shape().dimensions(0) % tile_batch, 0);\n+  ASSERT_EQ(m % tile_m, 0);\n+  ASSERT_EQ(n % tile_n, 0);\n+\n+  int num_m_tiles = m / tile_m;\n+  int num_n_tiles = n / tile_n;\n+\n+  const TiledHloInstruction* dot = tiled_hlo_computation.GetRoots()[0];\n+  EXPECT_THAT(*dot,\n+              MatchTiledHloInstruction(\n+                  /*tile_sizes=*/{1, 2, 8}, /*tile_strides=*/{1, 1, 1},\n+                  /*tile_offsets_indexing=*/\n+                  absl::Substitute(R\"(\n+    (pid_0) -> (pid_0 floordiv 4, (pid_0 mod $0) * $1, ((pid_0 floordiv $0) mod $2) * $3),\n+    domain:\n+    pid_0 in [0, 7]\n+  )\",\n+                                   num_m_tiles, tile_m, num_n_tiles, tile_n)));\n+\n+  const auto* lhs_fusion =\n+      static_cast<const TiledHloFusionInstruction*>(dot->operand(0));\n+  const TiledHloInstruction* lhs =\n+      lhs_fusion->called_computation()->GetRoots().front();\n+\n+  EXPECT_THAT(*lhs, MatchTiledHloInstruction(\n+                        /*tile_sizes=*/{1, 2, 8}, /*tile_strides=*/{1, 1, 1},\n+                        /*tile_offsets_indexing=*/\n+                        absl::Substitute(R\"(\n+    (pid_0) -> (pid_0 floordiv 4, (pid_0 mod $0) * $1, 0),\n+    domain:\n+    pid_0 in [0, 7]\n+  )\",\n+                                         num_m_tiles, tile_m)));\n+\n+  const auto* rhs_fusion =\n+      static_cast<const TiledHloFusionInstruction*>(dot->operand(1));\n+  const TiledHloInstruction* rhs =\n+      rhs_fusion->called_computation()->GetRoots().front();\n+\n+  EXPECT_THAT(*rhs, MatchTiledHloInstruction(\n+                        /*tile_sizes=*/{1, 8, 8}, /*tile_strides=*/{1, 1, 1},\n+                        /*tile_offsets_indexing=*/\n+                        absl::Substitute(R\"(\n+    (pid_0) -> (pid_0 floordiv 4, 0, ((pid_0 floordiv $0) mod $1) * $2),\n+    domain:\n+    pid_0 in [0, 7]\n+  )\",\n+                                         num_m_tiles, num_n_tiles, tile_n)));\n+}\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "145283a04f86ae3c82fe511358f7e88c551cb4a7",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 2,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n #include <vector>\n \n@@ -114,6 +115,15 @@ absl::StatusOr<IndexingMap> MajorToMinorScheduleImpl(\n }\n }  // namespace\n \n+absl::StatusOr<std::unique_ptr<TiledHloSchedule>>\n+CreateMajorToMinorTiledHloSchedule(\n+    const TilingSpecification& tiling_specification) {\n+  // The major-to-minor schedule can just throw away the specification since\n+  // it doesn't need to know about any specific of parameters to produce a\n+  // schedule.\n+  return std::make_unique<MajorToMinorTiledHloSchedule>();\n+}\n+\n absl::StatusOr<IndexingMap> MajorToMinorTiledHloSchedule::Schedule(\n     const IndexingMap& tile_offsets_indexing, IterationSpace iteration_space,\n     gpu::SymbolicExprContext* ctx) const {\n@@ -122,7 +132,7 @@ absl::StatusOr<IndexingMap> MajorToMinorTiledHloSchedule::Schedule(\n   return MajorToMinorScheduleImpl(tile_offsets_indexing, iteration_space, ctx);\n }\n \n-absl::StatusOr<TransposedDotTiledHloSchedule>\n+absl::StatusOr<std::unique_ptr<TransposedDotTiledHloSchedule>>\n TransposedDotTiledHloSchedule::Create(\n     const TilingSpecification& tiling_specification) {\n   const TilingSpecification::ParameterMapping& parameter_mapping =\n@@ -191,7 +201,8 @@ TransposedDotTiledHloSchedule::Create(\n   TF_ASSIGN_OR_RETURN(int64_t n_dim_id, tiling_specification.ParameterIndex(\n                                             dot, n_local_parameter_index));\n \n-  return TransposedDotTiledHloSchedule(m_dim_id, n_dim_id);\n+  return std::unique_ptr<TransposedDotTiledHloSchedule>(\n+      new TransposedDotTiledHloSchedule(m_dim_id, n_dim_id));\n }\n \n absl::StatusOr<IndexingMap> TransposedDotTiledHloSchedule::Schedule("
        },
        {
            "sha": "eb27821d73175a1e4dac44ae136de0de182f29c3",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.h",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n #define XLA_CODEGEN_TILING_TILED_HLO_SCHEDULE_H_\n \n #include <cstdint>\n+#include <memory>\n \n #include \"absl/status/statusor.h\"\n #include \"absl/types/span.h\"\n@@ -81,6 +82,12 @@ class MajorToMinorTiledHloSchedule : public TiledHloSchedule {\n       gpu::SymbolicExprContext* ctx) const override;\n };\n \n+// Convenience function to produce a `MajorToMinorTiledHloSchedule` that\n+// can be passed to `SymbolicTileAnalysis::ComputeTiledHloInstructions`.\n+absl::StatusOr<std::unique_ptr<TiledHloSchedule>>\n+CreateMajorToMinorTiledHloSchedule(\n+    const TilingSpecification& tiling_specification);\n+\n // Given a `TilingSpecification` where some of the output tile sizes are\n // provided by a `dot` operation with one left-hand-side and one\n // right-hand-side non-contracting dimensions, this schedule transposes the\n@@ -99,7 +106,7 @@ class TransposedDotTiledHloSchedule : public TiledHloSchedule {\n       const IndexingMap& tile_offsets_indexing, IterationSpace iteration_space,\n       gpu::SymbolicExprContext* ctx) const override;\n \n-  static absl::StatusOr<TransposedDotTiledHloSchedule> Create(\n+  static absl::StatusOr<std::unique_ptr<TransposedDotTiledHloSchedule>> Create(\n       const TilingSpecification& tiling_specification);\n \n  private:"
        },
        {
            "sha": "a6b9ddf3053dfda4b07a0ecd81da98dbc4d63975",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -340,7 +340,7 @@ ENTRY main {\n \n   MajorToMinorTiledHloSchedule major_to_minor_scheduler;\n   TF_ASSERT_OK_AND_ASSIGN(\n-      TransposedDotTiledHloSchedule transposed_scheduler,\n+      std::unique_ptr<TransposedDotTiledHloSchedule> transposed_scheduler,\n       TransposedDotTiledHloSchedule::Create(tiling_specification));\n \n   IndexingMap offsets_indexing = *ParseIndexingMap(R\"(\n@@ -366,8 +366,8 @@ ENTRY main {\n                                         &symbolic_expr_context_));\n   TF_ASSERT_OK_AND_ASSIGN(\n       IndexingMap transposed_scheduled_indexing,\n-      transposed_scheduler.Schedule(offsets_indexing, iteration_space,\n-                                    &symbolic_expr_context_));\n+      transposed_scheduler->Schedule(offsets_indexing, iteration_space,\n+                                     &symbolic_expr_context_));\n \n   int64_t m_bound = iteration_space[3].dimension_size;\n   int64_t n_bound = iteration_space[4].dimension_size;"
        },
        {
            "sha": "8536e6c2b77d4be0ee63ac30cc8efd602b76bc81",
            "filename": "third_party/xla/xla/service/gpu/model/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2FBUILD?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -704,6 +704,9 @@ xla_cc_test(\n         \"//xla/backends/gpu/codegen:fusions\",\n         \"//xla/codegen/tiling:symbolic_tile_analysis\",\n         \"//xla/codegen/tiling:tiled_hlo_computation\",\n+        \"//xla/codegen/tiling:tiled_hlo_instruction\",\n+        \"//xla/codegen/tiling:tiled_hlo_schedule\",\n+        \"//xla/codegen/tiling:tiling_specification\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/utils:hlo_traversal\",\n@@ -712,12 +715,11 @@ xla_cc_test(\n         \"//xla/service/gpu:hlo_fusion_analysis\",\n         \"//xla/service/gpu/model/experimental:symbolic_expr\",\n         \"//xla/stream_executor:device_description\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@llvm-project//mlir:IR\",\n-        \"@local_tsl//tsl/platform:statusor\",\n-        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n "
        },
        {
            "sha": "d61340e6b374d211e7e2677bbebf84ec4a4d90c3",
            "filename": "third_party/xla/xla/service/gpu/model/coalescing_analysis_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fcoalescing_analysis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/88e4cd4d016c9980637da316ff3b4234b28c2f55/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fcoalescing_analysis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fcoalescing_analysis_test.cc?ref=88e4cd4d016c9980637da316ff3b4234b28c2f55",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include <utility>\n #include <vector>\n \n+#include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n@@ -28,6 +29,9 @@ limitations under the License.\n #include \"xla/backends/gpu/codegen/fusions.h\"\n #include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n #include \"xla/codegen/tiling/tiled_hlo_computation.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_instruction.h\"\n+#include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n@@ -39,9 +43,8 @@ limitations under the License.\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/stream_executor/device_description.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/statusor.h\"\n-#include \"tsl/platform/test.h\"\n \n namespace xla {\n namespace gpu {\n@@ -595,6 +598,7 @@ class CoalescingForTiledHloTest : public CoalescingTest {\n     TiledHloComputation tiled_hlo_computation =\n         *symbolic_tile_analysis.ComputeTiledHloInstructions(\n             Tiling({{root, FlatTiling(tile_sizes.begin(), tile_sizes.end())}}),\n+            CreateMajorToMinorTiledHloSchedule,\n             /*constraints_are_known_satisfied=*/true,\n             /*compute_all_tile_offset_indexing_maps=*/true);\n \n@@ -618,6 +622,7 @@ class CoalescingForTiledHloTest : public CoalescingTest {\n     TiledHloComputation tiled_hlo_computation =\n         *symbolic_tile_analysis.ComputeTiledHloInstructions(\n             Tiling({{root, FlatTiling(tile_sizes.begin(), tile_sizes.end())}}),\n+            CreateMajorToMinorTiledHloSchedule,\n             /*constraints_are_known_satisfied=*/true,\n             /*compute_all_tile_offset_indexing_maps=*/true);\n "
        }
    ],
    "stats": {
        "total": 401,
        "additions": 271,
        "deletions": 130
    }
}