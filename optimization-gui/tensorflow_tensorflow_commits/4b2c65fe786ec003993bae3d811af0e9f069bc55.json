{
    "author": "subhankarshah",
    "message": "Fix a bug in explicit prefetching, when we allowed a program input with multiple uses to be block prefetched some assumptions became invalid. a) The list of prefetch end times will no longer be sorted and b) the first use time and last use time will no longer be same, which means copy-done-before-time != end-time.\n\nPiperOrigin-RevId: 800657568",
    "sha": "4b2c65fe786ec003993bae3d811af0e9f069bc55",
    "files": [
        {
            "sha": "3dd6d7d662188560515f0717376bb5a300cd79a4",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4b2c65fe786ec003993bae3d811af0e9f069bc55/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4b2c65fe786ec003993bae3d811af0e9f069bc55/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc?ref=4b2c65fe786ec003993bae3d811af0e9f069bc55",
            "patch": "@@ -2025,7 +2025,8 @@ int64_t MsaAlgorithm::MaxReservedScopedMemory() {\n }\n \n std::optional<int64_t> MsaAlgorithm::EarliestBlockAllocatedWeightStartTime(\n-    int64_t definition_time, int64_t use_time, int64_t buffer_size,\n+    int64_t earliest_start_time_candidate, int64_t first_use_time,\n+    int64_t last_use_time, int64_t buffer_size,\n     int64_t block_allocated_weights_bytes_limit,\n     std::vector<int64_t>& prefetch_end_times) {\n   auto can_find_chunk_within_limit =\n@@ -2042,20 +2043,21 @@ std::optional<int64_t> MsaAlgorithm::EarliestBlockAllocatedWeightStartTime(\n         return chunk_candidate.chunk_end() <=\n                block_allocated_weights_bytes_limit;\n       };\n-  if (can_find_chunk_within_limit(definition_time, use_time, buffer_size,\n+  if (can_find_chunk_within_limit(earliest_start_time_candidate, last_use_time,\n+                                  buffer_size,\n                                   block_allocated_weights_bytes_limit)) {\n-    return definition_time;\n+    return earliest_start_time_candidate;\n   }\n   // Find the first start_time = end_time + 1, where end_time comes from the\n   // prefetch_end_times list.\n   auto it_begin =\n       std::upper_bound(prefetch_end_times.begin(), prefetch_end_times.end(),\n-                       definition_time - 1);\n+                       earliest_start_time_candidate - 1);\n   auto it_end = std::upper_bound(prefetch_end_times.begin(),\n-                                 prefetch_end_times.end(), use_time - 1);\n+                                 prefetch_end_times.end(), first_use_time - 1);\n   for (auto it = it_begin; it != it_end; ++it) {\n     int64_t start_time = *it + 1;\n-    if (can_find_chunk_within_limit(start_time, use_time, buffer_size,\n+    if (can_find_chunk_within_limit(start_time, last_use_time, buffer_size,\n                                     block_allocated_weights_bytes_limit)) {\n       return start_time;\n     }\n@@ -2137,13 +2139,14 @@ void MsaAlgorithm::AllocateBlockAllocatedWeights() {\n     int64_t buffer_size = buffer_intervals_.at(value).size;\n     int64_t earliest_start_time_candidate =\n         std::max(definition_time, previous_start_time);\n-\n+    CHECK_LE(earliest_start_time_candidate, first_use_time);\n     // Find the earliest start time for which a chunk can be allocated for the\n     // block allocated weight.\n     std::optional<int64_t> optional_start_time =\n         EarliestBlockAllocatedWeightStartTime(\n-            earliest_start_time_candidate, end_time, buffer_size,\n-            block_allocated_weights_bytes_limit, prefetch_end_times);\n+            earliest_start_time_candidate, first_use_time, end_time,\n+            buffer_size, block_allocated_weights_bytes_limit,\n+            prefetch_end_times);\n \n     if (!optional_start_time.has_value()) {\n       LOG(WARNING) << \"Could not find a chunk for block allocated weight: \"\n@@ -2199,7 +2202,9 @@ void MsaAlgorithm::AllocateBlockAllocatedWeights() {\n         /*resource=*/0.0);\n \n     previous_start_time = start_time;\n-    prefetch_end_times.push_back(end_time);\n+    auto const sorted_position = std::lower_bound(\n+        prefetch_end_times.begin(), prefetch_end_times.end(), end_time);\n+    prefetch_end_times.insert(sorted_position, end_time);\n \n     // Bookkeeping Checklist:\n     // Commit the chunk to the alternate memory."
        },
        {
            "sha": "6cff5ba115a7d49b40fba99d739ee7a3bed8bf9f",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4b2c65fe786ec003993bae3d811af0e9f069bc55/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4b2c65fe786ec003993bae3d811af0e9f069bc55/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h?ref=4b2c65fe786ec003993bae3d811af0e9f069bc55",
            "patch": "@@ -346,8 +346,8 @@ class MsaAlgorithm : public GlobalDecreasingSizeBestFitHeap<HloValue> {\n   // use_time and the end time is the use_time. The chunk.end() should be less\n   // than the block_allocated_weights_bytes_limit.\n   std::optional<int64_t> EarliestBlockAllocatedWeightStartTime(\n-      int64_t definition_time, int64_t use_time, int64_t buffer_size,\n-      int64_t block_allocated_weights_bytes_limit,\n+      int64_t definition_time, int64_t first_use_time, int64_t last_use_time,\n+      int64_t buffer_size, int64_t block_allocated_weights_bytes_limit,\n       std::vector<int64_t>& prefetch_end_times);\n \n  protected:"
        },
        {
            "sha": "b2ab913e3360d39dca64a4ee06fb2aeb8d39b25d",
            "filename": "third_party/xla/xla/service/memory_space_assignment/memory_space_assignment_test.cc",
            "status": "modified",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4b2c65fe786ec003993bae3d811af0e9f069bc55/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4b2c65fe786ec003993bae3d811af0e9f069bc55/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc?ref=4b2c65fe786ec003993bae3d811af0e9f069bc55",
            "patch": "@@ -14907,6 +14907,103 @@ ENTRY entry {\n             kAlternateMemorySpace);\n }\n \n+TEST_F(MemorySpaceAssignmentTest, TestBlockAllocationsWithMultipleUses) {\n+  // When allowing multiple uses of block allocated weights, we only prefetch\n+  // the weight once, making sure that the prefetches are scheduled before the\n+  // first use time. This was a bug in the original implementation of block\n+  // allocations. This test case tests the fix. In this test the parameters p0\n+  // and p1 have multiple uses, we test that we prefetch them exactly once.\n+  absl::string_view hlo_string = R\"(\n+HloModule module, is_scheduled=true\n+\n+ENTRY entry {\n+  p0 = f32[2,3]{1,0} parameter(0)\n+  p1 = f32[2,3]{1,0} parameter(1)\n+  p2 = f32[2,3]{1,0} parameter(2)\n+  p3 = f32[2,3]{1,0} parameter(3)\n+  p4 = f32[2,3]{1,0} parameter(4)\n+  p5 = f32[2,3]{1,0} parameter(5)\n+  negate0 = f32[2,3]{1,0} negate(p0)\n+  negate1 = f32[2,3]{1,0} negate(negate0)\n+  negate2 = f32[2,3]{1,0} negate(negate1)\n+  add3 = f32[2,3]{1,0} add(p1, negate2)\n+  negate4 = f32[2,3]{1,0} negate(add3)\n+  negate5 = f32[2,3]{1,0} negate(negate4)\n+  add6 = f32[2,3]{1,0} add(p2, negate5)\n+  negate7 = f32[2,3]{1,0} negate(add6)\n+  negate8 = f32[2,3]{1,0} negate(negate7)\n+  add9 = f32[2,3]{1,0} add(p3, negate8)\n+  negate10 = f32[2,3]{1,0} negate(add9)\n+  negate11 = f32[2,3]{1,0} negate(negate10)\n+  add12 = f32[2,3]{1,0} add(p4, negate11)\n+  add13 = f32[2,3]{1,0} add(p1, add12)\n+  add14 = f32[2,3]{1,0} add(p0, add13)\n+  ROOT add15 = f32[2,3]{1,0} add(p5, add14)\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  Options memory_space_options = DefaultMemorySpaceOptions();\n+  memory_space_options.max_size_in_bytes = 72;\n+  memory_space_options.reserved_bytes_for_block_allocated_weights = 72;\n+  HloInstruction* p0 = FindInstruction(module.get(), \"p0\");\n+  HloPosition p0_position{p0, {}};\n+  HloInstruction* p1 = FindInstruction(module.get(), \"p1\");\n+  HloPosition p1_position{p1, {}};\n+  HloInstruction* p2 = FindInstruction(module.get(), \"p2\");\n+  HloPosition p2_position{p2, {}};\n+  HloInstruction* p3 = FindInstruction(module.get(), \"p3\");\n+  HloPosition p3_position{p3, {}};\n+  HloInstruction* p4 = FindInstruction(module.get(), \"p4\");\n+  HloPosition p4_position{p4, {}};\n+  HloInstruction* p5 = FindInstruction(module.get(), \"p5\");\n+  HloPosition p5_position{p5, {}};\n+  memory_space_options.block_allocated_weights_positions = {\n+      p5_position, p4_position, p3_position,\n+      p2_position, p1_position, p0_position};\n+  memory_space_options.max_outstanding_prefetches_for_block_allocations = 10;\n+  XLA_VLOG_LINES(3, \"Before MSA: \\n\" + module->ToString());\n+  AssignMemorySpaceUsingCostAnalysis(module.get(), memory_space_options);\n+  XLA_VLOG_LINES(3, \"After MSA: \\n\" + module->ToString());\n+  HloInstruction* negate0 = FindInstruction(module.get(), \"negate0\");\n+  const HloInstruction* negate0_operand0 = negate0->operand(0);\n+  EXPECT_EQ(negate0_operand0->opcode(), HloOpcode::kCopyDone);\n+  EXPECT_EQ(negate0_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add3 = FindInstruction(module.get(), \"add3\");\n+  const HloInstruction* add3_operand0 = add3->operand(0);\n+  EXPECT_EQ(add3_operand0->opcode(), HloOpcode::kCopyDone);\n+  EXPECT_EQ(add3_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add6 = FindInstruction(module.get(), \"add6\");\n+  const HloInstruction* add6_operand0 = add6->operand(0);\n+  EXPECT_EQ(add6_operand0->opcode(), HloOpcode::kCopyDone);\n+  EXPECT_EQ(add6_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add9 = FindInstruction(module.get(), \"add9\");\n+  const HloInstruction* add9_operand0 = add9->operand(0);\n+  EXPECT_EQ(add9_operand0->opcode(), HloOpcode::kCopyDone);\n+  EXPECT_EQ(add9_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add12 = FindInstruction(module.get(), \"add12\");\n+  const HloInstruction* add12_operand0 = add12->operand(0);\n+  EXPECT_EQ(add12_operand0->opcode(), HloOpcode::kCopyDone);\n+  EXPECT_EQ(add12_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+  HloInstruction* add13 = FindInstruction(module.get(), \"add13\");\n+  const HloInstruction* add13_operand0 = add13->operand(0);\n+  // Check that the prefetch of p1 is reused for add13.\n+  EXPECT_EQ(add13_operand0, add3_operand0);\n+  HloInstruction* add14 = FindInstruction(module.get(), \"add14\");\n+  const HloInstruction* add14_operand0 = add14->operand(0);\n+  // Check that the prefetch of p0 is reused for add14.\n+  EXPECT_EQ(add14_operand0, negate0_operand0);\n+  HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n+  const HloInstruction* add15_operand0 = add15->operand(0);\n+  EXPECT_EQ(add15_operand0->opcode(), HloOpcode::kCopyDone);\n+  EXPECT_EQ(add15_operand0->shape().layout().memory_space(),\n+            kAlternateMemorySpace);\n+}\n+\n TEST_F(MemorySpaceAssignmentTest,\n        TestBlockAllocatedWeightsDoubleBufferedWithColoring) {\n   absl::string_view hlo_string = R\"("
        }
    ],
    "stats": {
        "total": 126,
        "additions": 114,
        "deletions": 12
    }
}