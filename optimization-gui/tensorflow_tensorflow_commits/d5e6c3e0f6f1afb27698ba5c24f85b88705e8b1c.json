{
    "author": "tensorflower-gardener",
    "message": "Replace `absl::StrFormat` with `absl::StrCat` for simple string concatenations.\n\nThis change uses `absl::StrCat` for building annotation strings, which is more efficient for simple concatenations than `absl::StrFormat`.\n\nAlso, removes an unnecessary `else` block after a `return` (Clang tidy warning)\n\nPiperOrigin-RevId: 813758874",
    "sha": "d5e6c3e0f6f1afb27698ba5c24f85b88705e8b1c",
    "files": [
        {
            "sha": "f549647b9d0386251d34601bb25adb4e53933d3b",
            "filename": "third_party/xla/xla/backends/gpu/runtime/annotation.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 18,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d5e6c3e0f6f1afb27698ba5c24f85b88705e8b1c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fannotation.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d5e6c3e0f6f1afb27698ba5c24f85b88705e8b1c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fannotation.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fannotation.cc?ref=d5e6c3e0f6f1afb27698ba5c24f85b88705e8b1c",
            "patch": "@@ -30,7 +30,7 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/status/status.h\"\n-#include \"absl/strings/str_format.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_split.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/ir/dfs_hlo_visitor_with_default.h\"\n@@ -243,11 +243,12 @@ class SourceLocationVisitor : public ConstDfsHloVisitorWithDefault {\n \n std::string MakeTitle(const HloModule& mod, absl::string_view longest_prefix) {\n   if (longest_prefix.empty()) {\n-    return absl::StrFormat(\"XlaModule:#hlo_module=%s,program_id=%d#\",\n-                           mod.name(), mod.unique_id());\n+    return absl::StrCat(\"XlaModule:#hlo_module=\", mod.name(),\n+                        \",program_id=\", mod.unique_id(), \"#\");\n   }\n-  return absl::StrFormat(\"XlaModule:#prefix=%s,hlo_module=%s,program_id=%d#\",\n-                         longest_prefix, mod.name(), mod.unique_id());\n+  return absl::StrCat(\"XlaModule:#prefix=\", longest_prefix,\n+                      \",hlo_module=\", mod.name(),\n+                      \",program_id=\", mod.unique_id(), \"#\");\n }\n \n std::string FormatSourceLocations(HloInstruction const& inst,\n@@ -305,7 +306,7 @@ std::pair<StringHandle, int32_t> GetLongestSourceLocationPrefix(\n }  // namespace\n \n ModuleAnnotation::ModuleAnnotation(absl::string_view module_name_)\n-    : title_str_(absl::StrFormat(\"XlaModule:#hlo_module=%s#\", module_name_)),\n+    : title_str_(absl::StrCat(\"XlaModule:#hlo_module=\", module_name_, \"#\")),\n       title_(RegisterString(title_str_)),\n       module_name_(RegisterString(std::string{module_name_})) {}\n \n@@ -383,21 +384,20 @@ std::string MakeKernelName(absl::string_view prefix,\n   // and attach the longest prefix to this launch.\n   absl::string_view op_name = GetLongestOpNamePrefix(inst);\n   if (op_name.empty()) {\n-    return absl::StrFormat(\"Thunk:#hlo_op=%s#\", inst.name());\n-  } else if (op_name.substr(0, prefix.size()) != prefix) {\n+    return absl::StrCat(\"Thunk:#hlo_op=\", inst.name(), \"#\");\n+  }\n+  if (op_name.substr(0, prefix.size()) != prefix) {\n     // the op_name we got for this instruction does not start with the prefix\n     // that we thought was common to all instructions in the module\n-    return absl::StrFormat(\"Thunk:#name=%s,hlo_op=%s#\", op_name, inst.name());\n-  } else {\n-    // remove the prefix that's in the parent module annotation\n-    auto short_name = op_name.substr(prefix.size());\n-    // remove the leading / if there is one (prefix might be an empty string)\n-    if (!short_name.empty() && short_name.front() == '/') {\n-      short_name = short_name.substr(1);\n-    }\n-    return absl::StrFormat(\"Thunk:#name=%s,hlo_op=%s#\", short_name,\n-                           inst.name());\n+    return absl::StrCat(\"Thunk:#name=\", op_name, \",hlo_op=\", inst.name(), \"#\");\n+  }\n+  // remove the prefix that's in the parent module annotation\n+  auto short_name = op_name.substr(prefix.size());\n+  // remove the leading / if there is one (prefix might be an empty string)\n+  if (!short_name.empty() && short_name.front() == '/') {\n+    short_name = short_name.substr(1);\n   }\n+  return absl::StrCat(\"Thunk:#name=\", short_name, \",hlo_op=\", inst.name(), \"#\");\n }\n }  // namespace\n "
        }
    ],
    "stats": {
        "total": 36,
        "additions": 18,
        "deletions": 18
    }
}