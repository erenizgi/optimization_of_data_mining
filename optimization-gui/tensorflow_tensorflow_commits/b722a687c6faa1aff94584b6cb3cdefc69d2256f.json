{
    "author": "apivovarov",
    "message": "Add nullptr comparison and boolean conversion to MaybeOwning.\n\nThis change introduces `operator==`, `operator!=` for comparing `MaybeOwning` with `nullptr_t`, and an `explicit operator bool()` to `MaybeOwning`. These allow for more idiomatic checks against null. Updated several call sites to use these new operators, simplifying expressions like `obj.get() == nullptr` to `obj == nullptr` or `obj.get() != nullptr` to `obj`.\n\nPiperOrigin-RevId: 842119942",
    "sha": "b722a687c6faa1aff94584b6cb3cdefc69d2256f",
    "files": [
        {
            "sha": "f3731f64821230ac549d4db4d981b92e25d6d572",
            "filename": "third_party/xla/xla/backends/cpu/nanort/ifrt_client.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client.cc?ref=b722a687c6faa1aff94584b6cb3cdefc69d2256f",
            "patch": "@@ -511,7 +511,7 @@ class NanoArray final : public NanoValue<NanoArray, ifrt::Array> {\n     OwnedDataPtr owned_data(\n         tsl::port::AlignedMalloc(std::max<size_t>(size, Align()), Align()),\n         [](void* ptr) { tsl::port::AlignedFree(ptr); });\n-    if (ABSL_PREDICT_FALSE(owned_data.get() == nullptr)) {\n+    if (ABSL_PREDICT_FALSE(owned_data == nullptr)) {\n       return Internal(\"Failed to allocate memory for NanoArray. Errno: %s\",\n                       strerror(errno));\n     }"
        },
        {
            "sha": "fe9502af64f15c59737fd64cbd51e4bd6f607801",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc?ref=b722a687c6faa1aff94584b6cb3cdefc69d2256f",
            "patch": "@@ -1751,7 +1751,7 @@ void HloModule::OriginalValueRecoveryTable::AddRecoveryComputation(\n     std::optional<OriginalArray>* new_original_array =\n         new_inst->original_value()->mutable_original_array(shape_index);\n     if (!*new_original_array) {\n-      if (recovery_computation->get() == nullptr) {\n+      if (*recovery_computation == nullptr) {\n         // If the recovery computation is a nullptr, it means this is an\n         // identity computation and we can just pass through the original array.\n         new_original_array->emplace(*old_original_array);"
        },
        {
            "sha": "04bd39a670bea353d4376426e53d38323efcb69b",
            "filename": "third_party/xla/xla/maybe_owning.h",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fmaybe_owning.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fmaybe_owning.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmaybe_owning.h?ref=b722a687c6faa1aff94584b6cb3cdefc69d2256f",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #ifndef XLA_MAYBE_OWNING_H_\n #define XLA_MAYBE_OWNING_H_\n \n+#include <cstddef>\n #include <cstdint>\n #include <memory>\n \n@@ -76,6 +77,31 @@ class MaybeOwning final {\n \n   bool OwnsPtr() const { return kOwningBitMask & ptr_and_owning_bit_; }\n \n+  friend bool operator==(const MaybeOwning& mo, std::nullptr_t) {\n+    // A MaybeOwning is considered null if its internal pointer is null.\n+    // The get() method correctly removes the mask and returns the raw pointer.\n+    return mo.get() == nullptr;\n+  }\n+\n+  friend bool operator==(std::nullptr_t, const MaybeOwning& mo) {\n+    // Maintain symmetry for the comparison order\n+    return mo.get() == nullptr;\n+  }\n+\n+  friend bool operator!=(const MaybeOwning& mo, std::nullptr_t) {\n+    return mo.get() != nullptr;\n+  }\n+\n+  friend bool operator!=(std::nullptr_t, const MaybeOwning& mo) {\n+    return mo.get() != nullptr;\n+  }\n+\n+  explicit operator bool() const {\n+    // The class is considered 'true' if the underlying pointer is not null.\n+    // We use the existing get() method, which correctly handles the mask.\n+    return get() != nullptr;\n+  }\n+\n  private:\n   enum : uint64_t {\n     kOwningBitMask = 1UL,"
        },
        {
            "sha": "a98c18b53adc896eb097f9afc3365e2260b10851",
            "filename": "third_party/xla/xla/service/gpu/gpu_compiler.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc?ref=b722a687c6faa1aff94584b6cb3cdefc69d2256f",
            "patch": "@@ -56,6 +56,7 @@ limitations under the License.\n #include \"llvm/TargetParser/Triple.h\"\n #include \"llvm/Transforms/Utils/Cloning.h\"\n #include \"llvm/Transforms/Utils/SplitModule.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/Support/LLVM.h\"\n #include \"google/protobuf/text_format.h\"\n #include \"xla/backends/cpu/nanort/nanort_client.h\"\n@@ -69,7 +70,6 @@ limitations under the License.\n #include \"xla/core/host_offloading/hlo_host_device_type_call_wrapper.h\"\n #include \"xla/core/host_offloading/host_compute_asyncifier.h\"\n #include \"xla/hlo/analysis/alias_info.h\"\n-#include \"xla/hlo/analysis/symbolic_expr.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/hlo/ir/hlo_casting_utils.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n@@ -2224,7 +2224,7 @@ absl::StatusOr<GpuCompiler::BackendCompileResult> GpuCompiler::CompileAndLink(\n   // function per module. If caching is not used limit the number of modules to\n   // the number of threads.\n   int num_modules = CountFunctions(*llvm_module);\n-  if (thread_pool.get() != nullptr && !use_cache) {\n+  if (thread_pool && !use_cache) {\n     num_modules = std::max(1, std::min(thread_pool->NumThreads(), num_modules));\n   }\n   if (compile_module_results.llvm_module_constants != nullptr) {\n@@ -2262,7 +2262,7 @@ absl::StatusOr<GpuCompiler::BackendCompileResult> GpuCompiler::CompileAndLink(\n     absl::StatusOr<BackendCompileResult> result;\n   };\n   std::vector<NamedCompileResult> compile_results(llvm_modules.size());\n-  if (thread_pool.get() != nullptr) {\n+  if (thread_pool) {\n     absl::BlockingCounter counter(llvm_modules.size());\n     for (int i = 0; i < llvm_modules.size(); ++i) {\n       thread_pool.get_mutable()->Schedule("
        },
        {
            "sha": "1d72dbb4cd05b02edaaf3f0fe49a4bfeb094491d",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b722a687c6faa1aff94584b6cb3cdefc69d2256f/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h?ref=b722a687c6faa1aff94584b6cb3cdefc69d2256f",
            "patch": "@@ -357,7 +357,7 @@ class AsyncValueRef {\n     SetError(absl::InternalError(message_view));\n   }\n \n-  explicit operator bool() const { return value_.get() != nullptr; }\n+  explicit operator bool() const { return value_ != nullptr; }\n   bool operator==(const AsyncValueRef& r) const { return value_ == r.value_; }\n   bool operator!=(const AsyncValueRef& r) const { return value_ != r.value_; }\n "
        }
    ],
    "stats": {
        "total": 38,
        "additions": 32,
        "deletions": 6
    }
}