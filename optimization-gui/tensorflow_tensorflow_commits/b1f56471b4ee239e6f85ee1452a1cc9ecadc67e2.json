{
    "author": "loislo",
    "message": "[XLA:GPU] Pure mechanical change. Split the pass to 4 files. One is the pass itself, one file for the filters, two more with the specific thunks.\n\nPiperOrigin-RevId: 830413121",
    "sha": "b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
    "files": [
        {
            "sha": "a509f351d1fbd8906b77499bae9a62fc4cca5c3d",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -2996,8 +2996,18 @@ xla_test(\n \n cc_library(\n     name = \"thunk_buffer_debug_pass\",\n-    srcs = [\"thunk_buffer_debug_pass.cc\"],\n-    hdrs = [\"thunk_buffer_debug_pass.h\"],\n+    srcs = [\n+        \"thunk_buffer_debug_checksum.cc\",\n+        \"thunk_buffer_debug_filter.cc\",\n+        \"thunk_buffer_debug_float_check.cc\",\n+        \"thunk_buffer_debug_pass.cc\",\n+    ],\n+    hdrs = [\n+        \"thunk_buffer_debug_checksum.h\",\n+        \"thunk_buffer_debug_filter.h\",\n+        \"thunk_buffer_debug_float_check.h\",\n+        \"thunk_buffer_debug_pass.h\",\n+    ],\n     deps = [\n         \":buffer_debug_log_entry_metadata_store\",\n         \":buffer_debug_log_structs\","
        },
        {
            "sha": "9132d7b31fe8875eff7bf5cb8964a6b9b20cc55c",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_checksum.cc",
            "status": "added",
            "additions": 269,
            "deletions": 0,
            "changes": 269,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.cc?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -0,0 +1,269 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_checksum.h\"\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/base/nullability.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/functional/bind_front.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"xla/backends/gpu/runtime/buffer_debug_log_entry_metadata_store.h\"\n+#include \"xla/backends/gpu/runtime/buffer_debug_log_structs.h\"\n+#include \"xla/backends/gpu/runtime/buffers_checksum_thunk.h\"\n+#include \"xla/backends/gpu/runtime/custom_call_thunk.h\"\n+#include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n+#include \"xla/backends/gpu/runtime/shaped_slice.h\"\n+#include \"xla/backends/gpu/runtime/thunk.h\"\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_filter.h\"\n+#include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n+#include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n+#include \"xla/ffi/ffi.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/runtime/buffer_use.h\"\n+#include \"xla/service/buffer_assignment.h\"\n+#include \"xla/service/dump.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/stream_executor/gpu/buffer_debug_log.h\"\n+#include \"xla/stream_executor/stream.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla::gpu {\n+\n+namespace se = stream_executor;\n+\n+// With BufferDebugLogEntry size of 8 bytes, this is enough to hold ~8K entries.\n+constexpr size_t kLogSizeBytes = 64 * 1024;\n+\n+namespace {\n+\n+// If the thunk has any interesting buffers to check, turns it into a sequence\n+// of:\n+// - BuffersDebugChecksumThunk checking the buffers before execution\n+// - The original thunk\n+// - BuffersDebugChecksumThunk checking the buffers after execution\n+//\n+// If the thunk got wrapped, the data dependencies between the thunks will be\n+// configured to ensure `predecessor_thunk` executes before the wrapped thunk\n+// and `successor_thunk` executes after.\n+//\n+// If the thunk has no interesting buffers to check, it is returned as is. It\n+// can never return nullptr.\n+std::unique_ptr<Thunk> WrapWithChecksumThunk(\n+    std::unique_ptr<Thunk> thunk, BufferAllocation::Slice log_slice,\n+    const Thunk& predecessor_thunk, Thunk& successor_thunk,\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store) {\n+  const auto& thunk_buffers = thunk->buffer_uses();\n+  if (thunk_buffers.empty()) {\n+    return thunk;\n+  }\n+\n+  absl::flat_hash_map<size_t, BufferAllocation::Slice> buffers_to_check_before;\n+  absl::flat_hash_map<size_t, BufferAllocation::Slice> buffers_to_check_after;\n+\n+  for (size_t buffer_idx = 0; buffer_idx < thunk_buffers.size(); ++buffer_idx) {\n+    const BufferUse& use = thunk_buffers[buffer_idx];\n+    if (use.HasDefinedContentsOnInput()) {\n+      buffers_to_check_before.emplace(buffer_idx, use.slice());\n+    }\n+    if (use.HasDefinedContentsOnOutput()) {\n+      buffers_to_check_after.emplace(buffer_idx, use.slice());\n+    }\n+  }\n+\n+  if (buffers_to_check_before.empty() && buffers_to_check_after.empty()) {\n+    return thunk;\n+  }\n+\n+  std::vector<std::unique_ptr<Thunk>> thunk_and_checks;\n+  if (!buffers_to_check_before.empty()) {\n+    auto buffer_debug_before_thunk =\n+        std::make_unique<BuffersDebugChecksumThunk>(\n+            Thunk::ThunkInfo(), log_slice, thunk->thunk_info().thunk_id,\n+            std::move(buffers_to_check_before),\n+            /*runs_before_checked_thunk=*/true, metadata_store);\n+    thunk->add_control_predecessor(buffer_debug_before_thunk.get());\n+    thunk_and_checks.push_back(std::move(buffer_debug_before_thunk));\n+  }\n+\n+  Thunk* thunk_ptr = thunk.get();\n+  thunk_and_checks.push_back(std::move(thunk));\n+\n+  if (!buffers_to_check_after.empty()) {\n+    auto buffer_debug_after_thunk = std::make_unique<BuffersDebugChecksumThunk>(\n+        Thunk::ThunkInfo(), log_slice, thunk_ptr->thunk_info().thunk_id,\n+        std::move(buffers_to_check_after),\n+        /*runs_before_checked_thunk=*/false, metadata_store);\n+    buffer_debug_after_thunk->add_control_predecessor(thunk_ptr);\n+    thunk_and_checks.push_back(std::move(buffer_debug_after_thunk));\n+  }\n+\n+  auto wrapped_thunk = std::make_unique<SequentialThunk>(\n+      Thunk::ThunkInfo(), std::move(thunk_and_checks));\n+  wrapped_thunk->add_control_predecessor(&predecessor_thunk);\n+  successor_thunk.add_control_predecessor(wrapped_thunk.get());\n+  return wrapped_thunk;\n+}\n+\n+// Saves the contents of the BufferDebugLog stored in `log_buffer` to a file..\n+//\n+// `metadata_store` is used to retrieve the metadata for the log entries.\n+// The filename is derived from the HLO module name and the log dump path\n+// configured in `debug_options`.\n+absl::Status DumpBufferDebugChecksumLog(\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n+    se::Stream* stream, const HloComputation* absl_nonnull hlo_computation,\n+    xla::ffi::Buffer<U8> log_buffer) {\n+  VLOG(1) << \"HLO computation ptr: \" << hlo_computation;\n+  const HloModule* hlo_module = hlo_computation->parent();\n+  VLOG(1) << \"HLO module ptr: \" << hlo_module;\n+  VLOG(1) << \"HLO module name: \" << hlo_module->name();\n+  CHECK(hlo_module != nullptr);\n+  const DebugOptions& debug_options = hlo_module->config().debug_options();\n+\n+  se::gpu::BufferDebugLog buffer_debug_log =\n+      se::gpu::BufferDebugLog::FromDeviceMemoryUnchecked(\n+          log_buffer.device_memory());\n+  TF_ASSIGN_OR_RETURN(\n+      std::vector<BufferDebugLogEntry> log_entries,\n+      buffer_debug_log.ReadFromDevice<BufferDebugLogEntry>(*stream));\n+  BufferDebugLogProto buffer_debug_log_proto =\n+      metadata_store->EntriesToProto(log_entries);\n+\n+  VLOG(1) << \"read \" << buffer_debug_log_proto.entries_size() << \" entries\";\n+  DumpPerExecutionProtobufToFile(*hlo_module, buffer_debug_log_proto,\n+                                 debug_options, \"buffer_debug_log\", nullptr);\n+  int non_zero_float_check_modules_count = 0;\n+  for (const auto& entry : buffer_debug_log_proto.entries()) {\n+    if (entry.check_type() ==\n+            BufferDebugLogEntryProto::CHECK_TYPE_FLOAT_CHECKS &&\n+        entry.checksum() > 0) {\n+      LOG(ERROR) << \"Found entry with non zero float check count \"\n+                 << entry.checksum() << \" for thunk \" << entry.thunk_id()\n+                 << \" and execution \" << entry.execution_id()\n+                 << \" for module: \\n\"\n+                 << hlo_module->ToString();\n+      non_zero_float_check_modules_count++;\n+    }\n+  }\n+  if (non_zero_float_check_modules_count > 0 &&\n+      hlo_module->config().debug_options().xla_gpu_detect_nan() ==\n+          DebugOptions::NAN_CHECK_DETECTION_MODE_FAIL) {\n+    LOG(FATAL) << \"Found \" << non_zero_float_check_modules_count\n+               << \" modules with non zero float check count\";\n+  }\n+  return absl::OkStatus();\n+}\n+\n+XLA_FFI_DEFINE_HANDLER_SYMBOL(\n+    kBufferDebugChecksumLogInitHandler,\n+    [](se::Stream* absl_nonnull stream, xla::ffi::Buffer<U8> log_buffer) {\n+      return se::gpu::BufferDebugLog::CreateOnDevice<BufferDebugLogEntry>(\n+                 *stream, log_buffer.device_memory())\n+          .status();\n+    },\n+    xla::ffi::Ffi::Bind().Ctx<xla::ffi::Stream>().Arg<xla::ffi::Buffer<U8>>());\n+\n+absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateDebugInitThunk(\n+    BufferAllocation::Slice log_slice,\n+    const HloModule* absl_nonnull hlo_module) {\n+  ShapedSlice shaped_log_slice{\n+      /*slice=*/log_slice,\n+      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n+  };\n+\n+  XLA_FFI_Handler_Bundle buffer_debug_init_bundle{};\n+  buffer_debug_init_bundle.execute = kBufferDebugChecksumLogInitHandler;\n+  return CustomCallThunk::Create(\n+      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_init\",\n+      buffer_debug_init_bundle, /*operands=*/{shaped_log_slice},\n+      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n+}\n+\n+absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateBufferDebugDumpThunk(\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n+    BufferAllocation::Slice log_slice,\n+    const HloModule* absl_nonnull hlo_module) {\n+  ShapedSlice shaped_log_slice{\n+      /*slice=*/log_slice,\n+      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n+  };\n+\n+  CustomCallThunk::OwnedHandlerBundle dump_bundle{};\n+  dump_bundle.execute =\n+      xla::ffi::Ffi::Bind()\n+          .Ctx<xla::ffi::Stream>()\n+          .Ctx<xla::ffi::CalledComputation>()\n+          .Arg<xla::ffi::Buffer<U8>>()\n+          .To(absl::bind_front(DumpBufferDebugChecksumLog, metadata_store));\n+  return CustomCallThunk::Create(\n+      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_dump\",\n+      std::move(dump_bundle),\n+      /*operands=*/{shaped_log_slice},\n+      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n+}\n+\n+}  // namespace\n+absl::Status RunChecksumPassInternal(SequentialThunk* root_thunk,\n+                                     const DebugOptions& debug_options,\n+                                     const HloModule* absl_nonnull hlo_module,\n+                                     ThunkPassBufferAllocator& allocator) {\n+  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n+      std::make_shared<BufferDebugLogEntryMetadataStore>();\n+\n+  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n+                      allocator.NewEmptyAllocation(kLogSizeBytes));\n+  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n+\n+  TF_ASSIGN_OR_RETURN(auto buffer_debug_init_thunk,\n+                      CreateDebugInitThunk(log_slice, hlo_module));\n+\n+  TF_ASSIGN_OR_RETURN(\n+      auto buffer_debug_dump_thunk,\n+      CreateBufferDebugDumpThunk(metadata_store, log_slice, hlo_module));\n+\n+  ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n+  root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n+    if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n+      return thunk;\n+    }\n+    VLOG(1) << \"Wrapping with checksum thunk\";\n+    return WrapWithChecksumThunk(std::move(thunk), log_slice,\n+                                 /*predecessor_thunk=*/*buffer_debug_init_thunk,\n+                                 /*successor_thunk=*/*buffer_debug_dump_thunk,\n+                                 metadata_store);\n+  });\n+\n+  ThunkSequence& thunks = root_thunk->thunks();\n+  thunks.reserve(thunks.size() + 2);\n+  thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n+  thunks.push_back(std::move(buffer_debug_dump_thunk));\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace xla::gpu"
        },
        {
            "sha": "d13f4c788eb85bc9f4ccdaa65bd3599e7c9e83eb",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_checksum.h",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.h?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -0,0 +1,34 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_CHECKSUM_H_\n+#define XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_CHECKSUM_H_\n+\n+#include \"absl/base/nullability.h\"\n+#include \"absl/status/status.h\"\n+#include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n+#include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+\n+namespace xla::gpu {\n+\n+absl::Status RunChecksumPassInternal(SequentialThunk* root_thunk,\n+                                     const DebugOptions& debug_options,\n+                                     const HloModule* absl_nonnull hlo_module,\n+                                     ThunkPassBufferAllocator& allocator);\n+\n+}  // namespace xla::gpu\n+\n+#endif  // XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_CHECKSUM_H_"
        },
        {
            "sha": "0c5687821c4595e111c2381e0a0cdf8d82bb4915",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_filter.cc",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_filter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_filter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_filter.cc?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -0,0 +1,128 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_filter.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/algorithm/container.h\"\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"re2/re2.h\"\n+#include \"xla/backends/gpu/runtime/thunk.h\"\n+#include \"xla/backends/gpu/runtime/thunk_id.h\"\n+#include \"xla/ffi/ffi.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla::gpu {\n+\n+namespace {\n+\n+// A function that decides whether the thunk should be instrumented\n+// (kInstrument) or not (kSkip).\n+using ThunkFilter = absl::AnyInvocable<InstrumentAction(const Thunk&) const>;\n+\n+// Creates a thunk filter that filters thunks by their IDs, based the allowed\n+// ranges passed in debug options.\n+ThunkFilter CreateThunkIdFilter(const DebugOptions& debug_options) {\n+  std::vector<std::pair<int64_t, int64_t>> thunk_id_ranges;\n+  for (const auto& range :\n+       debug_options.xla_gpu_experimental_thunk_buffer_debug_filter()\n+           .thunk_id_ranges()) {\n+    VLOG(1) << \"Thunk filter: id range [\" << range.first() << \", \"\n+            << range.last() << \"]\";\n+    thunk_id_ranges.emplace_back(range.first(), range.last());\n+  }\n+\n+  return [id_ranges = std::move(thunk_id_ranges)](const Thunk& thunk) {\n+    if (id_ranges.empty()) {\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    const ThunkId thunk_id = thunk.thunk_info().thunk_id;\n+    if (absl::c_any_of(id_ranges, [&](const auto& range) {\n+          VLOG(2) << \"Thunk filter: check ID range: \" << range.first\n+                  << \" <= \" << thunk_id.value() << \" <= \" << range.second;\n+          return range.first <= thunk_id.value() &&\n+                 thunk_id.value() <= range.second;\n+        })) {\n+      VLOG(2) << \"Thunk filter: ID matches\";\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    VLOG(2) << \"Thunk filter: ID does not match\";\n+    return InstrumentAction::kSkip;\n+  };\n+}\n+\n+// Creates a thunk filter that filters thunks by matching their profile\n+// annotations against regexes configured in debug options.\n+ThunkFilter CreateProfileAnnotationRegexFilter(\n+    const DebugOptions& debug_options) {\n+  std::vector<std::unique_ptr<RE2>> profile_annotation_regexes;\n+  for (const auto& regex :\n+       debug_options.xla_gpu_experimental_thunk_buffer_debug_filter()\n+           .profile_annotation_regexes()) {\n+    VLOG(1) << \"Thunk filter: profile annotation regex: \" << regex;\n+    profile_annotation_regexes.push_back(std::make_unique<RE2>(regex));\n+  }\n+  return [regexes = std::move(profile_annotation_regexes)](const Thunk& thunk) {\n+    if (regexes.empty()) {\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    const std::string& profile_annotation =\n+        thunk.thunk_info().profile_annotation;\n+    if (absl::c_any_of(regexes, [&](const auto& regex) {\n+          VLOG(2) << \"Thunk filter: check profile annotation regex: \"\n+                  << regex->pattern();\n+          return RE2::PartialMatch(profile_annotation, *regex);\n+        })) {\n+      VLOG(2) << \"Thunk filter: profile annotation matches\";\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    VLOG(2) << \"Thunk filter: profile annotation does not match\";\n+    return InstrumentAction::kSkip;\n+  };\n+}\n+\n+}  // namespace\n+\n+// Creates a thunk filter that filters thunks by all the conditions configured\n+// in debug options.\n+ThunkFilter CreateThunkFilter(const DebugOptions& debug_options) {\n+  std::vector<ThunkFilter> filters;\n+  filters.push_back(CreateThunkIdFilter(debug_options));\n+  filters.push_back(CreateProfileAnnotationRegexFilter(debug_options));\n+\n+  return [filters = std::move(filters)](const Thunk& thunk) {\n+    VLOG(2) << \"Thunk filter: check ID \" << thunk.thunk_info().thunk_id\n+            << \", profile annotation \" << thunk.thunk_info().profile_annotation;\n+    if (absl::c_all_of(filters, [&](const auto& filter) {\n+          return filter(thunk) == InstrumentAction::kInstrument;\n+        })) {\n+      return InstrumentAction::kInstrument;\n+    }\n+    return InstrumentAction::kSkip;\n+  };\n+}\n+\n+}  // namespace xla::gpu"
        },
        {
            "sha": "2d4d8cc97e0970af603f332195c847b6189432f7",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_filter.h",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_filter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_filter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_filter.h?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -0,0 +1,39 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_FILTER_H_\n+#define XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_FILTER_H_\n+\n+#include \"absl/functional/any_invocable.h\"\n+#include \"xla/backends/gpu/runtime/thunk.h\"\n+\n+namespace xla::gpu {\n+\n+// A boolean-like value returned from thunk filters to indicate whether the\n+// thunk should be instrumented or left as is.\n+enum class InstrumentAction : bool {\n+  // Don't instrument the thunk, leave it as is.\n+  kSkip,\n+  // Instrument the thunk.\n+  kInstrument,\n+};\n+\n+using ThunkFilter = absl::AnyInvocable<InstrumentAction(const Thunk&) const>;\n+\n+ThunkFilter CreateThunkFilter(const DebugOptions& debug_options);\n+\n+}  // namespace xla::gpu\n+\n+#endif  // XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_FILTER_H_"
        },
        {
            "sha": "06b1b5cf02d8bcf37c3bf3b6116846d6a51c748f",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_float_check.cc",
            "status": "added",
            "additions": 270,
            "deletions": 0,
            "changes": 270,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.cc?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -0,0 +1,270 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_float_check.h\"\n+\n+#include <cstddef>\n+#include <cstring>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/base/nullability.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/functional/bind_front.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"xla/backends/gpu/runtime/buffer_debug_log_entry_metadata_store.h\"\n+#include \"xla/backends/gpu/runtime/buffer_debug_log_structs.h\"\n+#include \"xla/backends/gpu/runtime/buffers_float_check_thunk.h\"\n+#include \"xla/backends/gpu/runtime/custom_call_thunk.h\"\n+#include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n+#include \"xla/backends/gpu/runtime/shaped_slice.h\"\n+#include \"xla/backends/gpu/runtime/thunk.h\"\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_filter.h\"\n+#include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n+#include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n+#include \"xla/ffi/ffi.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/runtime/buffer_use.h\"\n+#include \"xla/service/buffer_assignment.h\"\n+#include \"xla/service/dump.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/stream_executor/gpu/buffer_debug_log.h\"\n+#include \"xla/stream_executor/stream.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla::gpu {\n+\n+namespace se = stream_executor;\n+\n+// With BufferDebugLogEntry size of 8 bytes, this is enough to hold ~8K entries.\n+constexpr size_t kLogSizeBytes = 64 * 1024;\n+\n+namespace {\n+\n+std::unique_ptr<Thunk> WrapWithFloatCheckThunk(\n+    std::unique_ptr<Thunk> thunk, BufferAllocation::Slice log_slice,\n+    const Thunk& predecessor_thunk, Thunk& successor_thunk,\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store) {\n+  const auto& thunk_buffers = thunk->buffer_uses();\n+  if (thunk_buffers.empty()) {\n+    VLOG(1) << \"No buffers in thunk \" << thunk->thunk_info().thunk_id\n+            << \", skipping\";\n+    return thunk;\n+  }\n+\n+  absl::flat_hash_map<size_t, BufferAllocation::Slice> buffers_to_check;\n+  for (size_t buffer_idx = 0; buffer_idx < thunk_buffers.size(); ++buffer_idx) {\n+    VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n+            << thunk->thunk_info().thunk_id;\n+    const BufferUse& use = thunk_buffers[buffer_idx];\n+    const BufferAllocation::Slice& slice = use.slice();\n+    if (slice.allocation() == nullptr) {\n+      VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n+              << thunk->thunk_info().thunk_id\n+              << \" has null allocation, skipping\";\n+      continue;\n+    }\n+    if (slice.element_type() != PrimitiveType::F32 &&\n+        slice.element_type() != PrimitiveType::BF16) {\n+      VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n+              << thunk->thunk_info().thunk_id\n+              << \" has unsupported element type \"\n+              << PrimitiveType_Name(slice.element_type()) << \", skipping\";\n+      continue;\n+    }\n+    if (!use.HasDefinedContentsOnOutput()) {\n+      VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n+              << thunk->thunk_info().thunk_id\n+              << \" has no defined contents, skipping\";\n+      continue;\n+    }\n+    buffers_to_check.emplace(buffer_idx, use.slice());\n+    VLOG(1) << \"Found buffer \" << buffer_idx << \" in thunk \"\n+            << thunk->thunk_info().thunk_id << \" with element type \"\n+            << PrimitiveType_Name(slice.element_type()) << \" and size \"\n+            << slice.size();\n+  }\n+\n+  if (buffers_to_check.empty()) {\n+    return thunk;\n+  }\n+\n+  VLOG(1) << \"Wrapping thunk \" << thunk->thunk_info().thunk_id\n+          << \" with float check thunk due to presence of buffers: \"\n+          << buffers_to_check.size();\n+  std::vector<std::unique_ptr<Thunk>> thunk_and_checks;\n+  Thunk* thunk_ptr = thunk.get();\n+  thunk_and_checks.push_back(std::move(thunk));\n+  auto buffer_debug_float_check_thunk =\n+      std::make_unique<BuffersDebugFloatCheckThunk>(\n+          Thunk::ThunkInfo(), log_slice, thunk_ptr->thunk_info().thunk_id,\n+          std::move(buffers_to_check),\n+          /*runs_before_checked_thunk=*/false, std::move(metadata_store));\n+  buffer_debug_float_check_thunk->add_control_predecessor(thunk_ptr);\n+  thunk_and_checks.push_back(std::move(buffer_debug_float_check_thunk));\n+  auto wrapped_thunk = std::make_unique<SequentialThunk>(\n+      Thunk::ThunkInfo(), std::move(thunk_and_checks));\n+  wrapped_thunk->add_control_predecessor(&predecessor_thunk);\n+  successor_thunk.add_control_predecessor(wrapped_thunk.get());\n+  return wrapped_thunk;\n+}\n+\n+// Saves the contents of the BufferDebugLog stored in `log_buffer` to a file..\n+//\n+// `metadata_store` is used to retrieve the metadata for the log entries.\n+// The filename is derived from the HLO module name and the log dump path\n+// configured in `debug_options`.\n+absl::Status BufferDebugFloatCheck(\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n+    se::Stream* stream, const HloComputation* absl_nonnull hlo_computation,\n+    xla::ffi::Buffer<U8> log_buffer) {\n+  VLOG(1) << \"HLO computation ptr: \" << hlo_computation;\n+  const HloModule* hlo_module = hlo_computation->parent();\n+  VLOG(1) << \"HLO module ptr: \" << hlo_module;\n+  VLOG(1) << \"HLO module name: \" << hlo_module->name();\n+  CHECK(hlo_module != nullptr);\n+  const DebugOptions& debug_options = hlo_module->config().debug_options();\n+\n+  se::gpu::BufferDebugLog buffer_debug_log =\n+      se::gpu::BufferDebugLog::FromDeviceMemoryUnchecked(\n+          log_buffer.device_memory());\n+  TF_ASSIGN_OR_RETURN(\n+      std::vector<BufferDebugLogEntry> log_entries,\n+      buffer_debug_log.ReadFromDevice<BufferDebugLogEntry>(*stream));\n+  BufferDebugLogProto buffer_debug_log_proto =\n+      metadata_store->EntriesToProto(log_entries);\n+\n+  VLOG(1) << \"read \" << buffer_debug_log_proto.entries_size() << \" entries\";\n+  DumpPerExecutionProtobufToFile(*hlo_module, buffer_debug_log_proto,\n+                                 debug_options, \"buffer_debug_log\", nullptr);\n+  int non_zero_float_check_modules_count = 0;\n+  for (const auto& entry : buffer_debug_log_proto.entries()) {\n+    if (entry.check_type() ==\n+            BufferDebugLogEntryProto::CHECK_TYPE_FLOAT_CHECKS &&\n+        entry.checksum() > 0) {\n+      LOG(ERROR) << \"Found entry with non zero float check count \"\n+                 << entry.checksum() << \" for thunk \" << entry.thunk_id()\n+                 << \" and execution \" << entry.execution_id()\n+                 << \" for module: \\n\"\n+                 << hlo_module->ToString();\n+      non_zero_float_check_modules_count++;\n+    }\n+  }\n+  if (non_zero_float_check_modules_count > 0 &&\n+      hlo_module->config().debug_options().xla_gpu_detect_nan() ==\n+          DebugOptions::NAN_CHECK_DETECTION_MODE_FAIL) {\n+    LOG(FATAL) << \"Found \" << non_zero_float_check_modules_count\n+               << \" modules with non zero float check count\";\n+  }\n+  return absl::OkStatus();\n+}\n+\n+XLA_FFI_DEFINE_HANDLER_SYMBOL(\n+    kBufferDebugFloatCheckLogInitHandler,\n+    [](se::Stream* absl_nonnull stream, xla::ffi::Buffer<U8> log_buffer) {\n+      return se::gpu::BufferDebugLog::CreateOnDevice<BufferDebugLogEntry>(\n+                 *stream, log_buffer.device_memory())\n+          .status();\n+    },\n+    xla::ffi::Ffi::Bind().Ctx<xla::ffi::Stream>().Arg<xla::ffi::Buffer<U8>>());\n+\n+absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateDebugInitThunk(\n+    BufferAllocation::Slice log_slice,\n+    const HloModule* absl_nonnull hlo_module) {\n+  ShapedSlice shaped_log_slice{\n+      /*slice=*/log_slice,\n+      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n+  };\n+\n+  XLA_FFI_Handler_Bundle buffer_debug_init_bundle{};\n+  buffer_debug_init_bundle.execute = kBufferDebugFloatCheckLogInitHandler;\n+  return CustomCallThunk::Create(\n+      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_init\",\n+      buffer_debug_init_bundle, /*operands=*/{shaped_log_slice},\n+      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n+}\n+\n+absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateBufferDebugDumpThunk(\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n+    BufferAllocation::Slice log_slice,\n+    const HloModule* absl_nonnull hlo_module) {\n+  ShapedSlice shaped_log_slice{\n+      /*slice=*/log_slice,\n+      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n+  };\n+\n+  CustomCallThunk::OwnedHandlerBundle float_check_bundle{};\n+  float_check_bundle.execute =\n+      xla::ffi::Ffi::Bind()\n+          .Ctx<xla::ffi::Stream>()\n+          .Ctx<xla::ffi::CalledComputation>()\n+          .Arg<xla::ffi::Buffer<U8>>()\n+          .To(absl::bind_front(BufferDebugFloatCheck, metadata_store));\n+  return CustomCallThunk::Create(\n+      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_dump\",\n+      std::move(float_check_bundle),\n+      /*operands=*/{shaped_log_slice},\n+      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n+}\n+\n+}  // namespace\n+\n+absl::Status RunFloatCheckPassInternal(SequentialThunk* root_thunk,\n+                                       const DebugOptions& debug_options,\n+                                       const HloModule* absl_nonnull hlo_module,\n+                                       ThunkPassBufferAllocator& allocator) {\n+  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n+      std::make_shared<BufferDebugLogEntryMetadataStore>();\n+\n+  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n+                      allocator.NewEmptyAllocation(kLogSizeBytes));\n+  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n+\n+  TF_ASSIGN_OR_RETURN(auto buffer_debug_init_thunk,\n+                      CreateDebugInitThunk(log_slice, hlo_module));\n+\n+  TF_ASSIGN_OR_RETURN(\n+      auto buffer_debug_dump_thunk,\n+      CreateBufferDebugDumpThunk(metadata_store, log_slice, hlo_module));\n+\n+  ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n+  root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n+    if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n+      return thunk;\n+    }\n+    VLOG(1) << \"Wrapping with float check thunk\";\n+    return WrapWithFloatCheckThunk(\n+        std::move(thunk), log_slice,\n+        /*predecessor_thunk=*/*buffer_debug_init_thunk,\n+        /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n+  });\n+\n+  ThunkSequence& thunks = root_thunk->thunks();\n+  thunks.reserve(thunks.size() + 2);\n+  thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n+  thunks.push_back(std::move(buffer_debug_dump_thunk));\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace xla::gpu"
        },
        {
            "sha": "9ab900694b2fbbfdf7fa108e485787b17665026e",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_float_check.h",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.h?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -0,0 +1,33 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_FLOAT_CHECK_H_\n+#define XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_FLOAT_CHECK_H_\n+\n+#include \"absl/base/nullability.h\"\n+#include \"absl/status/status.h\"\n+#include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n+#include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+\n+namespace xla::gpu {\n+\n+absl::Status RunFloatCheckPassInternal(SequentialThunk* root_thunk,\n+                                       const DebugOptions& debug_options,\n+                                       const HloModule* absl_nonnull hlo_module,\n+                                       ThunkPassBufferAllocator& allocator);\n+}\n+\n+#endif  // XLA_BACKENDS_GPU_RUNTIME_THUNK_BUFFER_DEBUG_FLOAT_CHECK_H_"
        },
        {
            "sha": "996b2f00739e12be8e627df3fc78b877ea7bb711",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 448,
            "changes": 451,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc?ref=b1f56471b4ee239e6f85ee1452a1cc9ecadc67e2",
            "patch": "@@ -15,472 +15,27 @@ limitations under the License.\n \n #include \"xla/backends/gpu/runtime/thunk_buffer_debug_pass.h\"\n \n-#include <cstddef>\n-#include <cstdint>\n-#include <cstring>\n-#include <memory>\n-#include <string>\n-#include <utility>\n-#include <vector>\n-\n-#include \"absl/algorithm/container.h\"\n #include \"absl/base/nullability.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/functional/any_invocable.h\"\n-#include \"absl/functional/bind_front.h\"\n-#include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n-#include \"re2/re2.h\"\n-#include \"xla/backends/gpu/runtime/buffer_debug_log_entry_metadata_store.h\"\n-#include \"xla/backends/gpu/runtime/buffer_debug_log_structs.h\"\n-#include \"xla/backends/gpu/runtime/buffers_checksum_thunk.h\"\n-#include \"xla/backends/gpu/runtime/buffers_float_check_thunk.h\"\n-#include \"xla/backends/gpu/runtime/custom_call_thunk.h\"\n #include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n-#include \"xla/backends/gpu/runtime/shaped_slice.h\"\n-#include \"xla/backends/gpu/runtime/thunk.h\"\n-#include \"xla/backends/gpu/runtime/thunk_id.h\"\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_checksum.h\"\n+#include \"xla/backends/gpu/runtime/thunk_buffer_debug_float_check.h\"\n #include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n-#include \"xla/ffi/api/c_api.h\"\n-#include \"xla/ffi/attribute_map.h\"\n #include \"xla/ffi/ffi.h\"\n-#include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n-#include \"xla/runtime/buffer_use.h\"\n-#include \"xla/service/buffer_assignment.h\"\n-#include \"xla/service/dump.h\"\n-#include \"xla/shape.h\"\n #include \"xla/stream_executor/device_description.h\"\n-#include \"xla/stream_executor/gpu/buffer_debug_log.h\"\n-#include \"xla/stream_executor/stream.h\"\n #include \"xla/tsl/platform/errors.h\"\n-#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla::gpu {\n \n-namespace se = stream_executor;\n-\n-// With BufferDebugLogEntry size of 8 bytes, this is enough to hold ~8K entries.\n-constexpr size_t kLogSizeBytes = 64 * 1024;\n-\n-namespace {\n-\n-// If the thunk has any interesting buffers to check, turns it into a sequence\n-// of:\n-// - BuffersDebugChecksumThunk checking the buffers before execution\n-// - The original thunk\n-// - BuffersDebugChecksumThunk checking the buffers after execution\n-//\n-// If the thunk got wrapped, the data dependencies between the thunks will be\n-// configured to ensure `predecessor_thunk` executes before the wrapped thunk\n-// and `successor_thunk` executes after.\n-//\n-// If the thunk has no interesting buffers to check, it is returned as is. It\n-// can never return nullptr.\n-std::unique_ptr<Thunk> WrapWithChecksumThunk(\n-    std::unique_ptr<Thunk> thunk, BufferAllocation::Slice log_slice,\n-    const Thunk& predecessor_thunk, Thunk& successor_thunk,\n-    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store) {\n-  const auto& thunk_buffers = thunk->buffer_uses();\n-  if (thunk_buffers.empty()) {\n-    return thunk;\n-  }\n-\n-  absl::flat_hash_map<size_t, BufferAllocation::Slice> buffers_to_check_before;\n-  absl::flat_hash_map<size_t, BufferAllocation::Slice> buffers_to_check_after;\n-\n-  for (size_t buffer_idx = 0; buffer_idx < thunk_buffers.size(); ++buffer_idx) {\n-    const BufferUse& use = thunk_buffers[buffer_idx];\n-    if (use.HasDefinedContentsOnInput()) {\n-      buffers_to_check_before.emplace(buffer_idx, use.slice());\n-    }\n-    if (use.HasDefinedContentsOnOutput()) {\n-      buffers_to_check_after.emplace(buffer_idx, use.slice());\n-    }\n-  }\n-\n-  if (buffers_to_check_before.empty() && buffers_to_check_after.empty()) {\n-    return thunk;\n-  }\n-\n-  std::vector<std::unique_ptr<Thunk>> thunk_and_checks;\n-  if (!buffers_to_check_before.empty()) {\n-    auto buffer_debug_before_thunk =\n-        std::make_unique<BuffersDebugChecksumThunk>(\n-            Thunk::ThunkInfo(), log_slice, thunk->thunk_info().thunk_id,\n-            std::move(buffers_to_check_before),\n-            /*runs_before_checked_thunk=*/true, metadata_store);\n-    thunk->add_control_predecessor(buffer_debug_before_thunk.get());\n-    thunk_and_checks.push_back(std::move(buffer_debug_before_thunk));\n-  }\n-\n-  Thunk* thunk_ptr = thunk.get();\n-  thunk_and_checks.push_back(std::move(thunk));\n-\n-  if (!buffers_to_check_after.empty()) {\n-    auto buffer_debug_after_thunk = std::make_unique<BuffersDebugChecksumThunk>(\n-        Thunk::ThunkInfo(), log_slice, thunk_ptr->thunk_info().thunk_id,\n-        std::move(buffers_to_check_after),\n-        /*runs_before_checked_thunk=*/false, metadata_store);\n-    buffer_debug_after_thunk->add_control_predecessor(thunk_ptr);\n-    thunk_and_checks.push_back(std::move(buffer_debug_after_thunk));\n-  }\n-\n-  auto wrapped_thunk = std::make_unique<SequentialThunk>(\n-      Thunk::ThunkInfo(), std::move(thunk_and_checks));\n-  wrapped_thunk->add_control_predecessor(&predecessor_thunk);\n-  successor_thunk.add_control_predecessor(wrapped_thunk.get());\n-  return wrapped_thunk;\n-}\n-\n-std::unique_ptr<Thunk> WrapWithFloatCheckThunk(\n-    std::unique_ptr<Thunk> thunk, BufferAllocation::Slice log_slice,\n-    const Thunk& predecessor_thunk, Thunk& successor_thunk,\n-    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store) {\n-  const auto& thunk_buffers = thunk->buffer_uses();\n-  if (thunk_buffers.empty()) {\n-    VLOG(1) << \"No buffers in thunk \" << thunk->thunk_info().thunk_id\n-            << \", skipping\";\n-    return thunk;\n-  }\n-\n-  absl::flat_hash_map<size_t, BufferAllocation::Slice> buffers_to_check;\n-  for (size_t buffer_idx = 0; buffer_idx < thunk_buffers.size(); ++buffer_idx) {\n-    VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n-            << thunk->thunk_info().thunk_id;\n-    const BufferUse& use = thunk_buffers[buffer_idx];\n-    const BufferAllocation::Slice& slice = use.slice();\n-    if (slice.allocation() == nullptr) {\n-      VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n-              << thunk->thunk_info().thunk_id\n-              << \" has null allocation, skipping\";\n-      continue;\n-    }\n-    if (slice.element_type() != PrimitiveType::F32 &&\n-        slice.element_type() != PrimitiveType::BF16) {\n-      VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n-              << thunk->thunk_info().thunk_id\n-              << \" has unsupported element type \"\n-              << PrimitiveType_Name(slice.element_type()) << \", skipping\";\n-      continue;\n-    }\n-    if (!use.HasDefinedContentsOnOutput()) {\n-      VLOG(1) << \"Buffer \" << buffer_idx << \" in thunk \"\n-              << thunk->thunk_info().thunk_id\n-              << \" has no defined contents, skipping\";\n-      continue;\n-    }\n-    buffers_to_check.emplace(buffer_idx, use.slice());\n-    VLOG(1) << \"Found buffer \" << buffer_idx << \" in thunk \"\n-            << thunk->thunk_info().thunk_id << \" with element type \"\n-            << PrimitiveType_Name(slice.element_type()) << \" and size \"\n-            << slice.size();\n-  }\n-\n-  if (buffers_to_check.empty()) {\n-    return thunk;\n-  }\n-\n-  VLOG(1) << \"Wrapping thunk \" << thunk->thunk_info().thunk_id\n-          << \" with float check thunk due to presence of buffers: \"\n-          << buffers_to_check.size();\n-  std::vector<std::unique_ptr<Thunk>> thunk_and_checks;\n-  Thunk* thunk_ptr = thunk.get();\n-  thunk_and_checks.push_back(std::move(thunk));\n-  auto buffer_debug_float_check_thunk =\n-      std::make_unique<BuffersDebugFloatCheckThunk>(\n-          Thunk::ThunkInfo(), log_slice, thunk_ptr->thunk_info().thunk_id,\n-          std::move(buffers_to_check),\n-          /*runs_before_checked_thunk=*/false, std::move(metadata_store));\n-  buffer_debug_float_check_thunk->add_control_predecessor(thunk_ptr);\n-  thunk_and_checks.push_back(std::move(buffer_debug_float_check_thunk));\n-  auto wrapped_thunk = std::make_unique<SequentialThunk>(\n-      Thunk::ThunkInfo(), std::move(thunk_and_checks));\n-  wrapped_thunk->add_control_predecessor(&predecessor_thunk);\n-  successor_thunk.add_control_predecessor(wrapped_thunk.get());\n-  return wrapped_thunk;\n-}\n-\n-// Saves the contents of the BufferDebugLog stored in `log_buffer` to a file..\n-//\n-// `metadata_store` is used to retrieve the metadata for the log entries.\n-// The filename is derived from the HLO module name and the log dump path\n-// configured in `debug_options`.\n-absl::Status DumpBufferDebugChecksumLog(\n-    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n-    se::Stream* stream, const HloComputation* absl_nonnull hlo_computation,\n-    xla::ffi::Buffer<U8> log_buffer) {\n-  VLOG(1) << \"HLO computation ptr: \" << hlo_computation;\n-  const HloModule* hlo_module = hlo_computation->parent();\n-  VLOG(1) << \"HLO module ptr: \" << hlo_module;\n-  VLOG(1) << \"HLO module name: \" << hlo_module->name();\n-  CHECK(hlo_module != nullptr);\n-  const DebugOptions& debug_options = hlo_module->config().debug_options();\n-\n-  se::gpu::BufferDebugLog buffer_debug_log =\n-      se::gpu::BufferDebugLog::FromDeviceMemoryUnchecked(\n-          log_buffer.device_memory());\n-  TF_ASSIGN_OR_RETURN(\n-      std::vector<BufferDebugLogEntry> log_entries,\n-      buffer_debug_log.ReadFromDevice<BufferDebugLogEntry>(*stream));\n-  BufferDebugLogProto buffer_debug_log_proto =\n-      metadata_store->EntriesToProto(log_entries);\n-\n-  VLOG(1) << \"read \" << buffer_debug_log_proto.entries_size() << \" entries\";\n-  DumpPerExecutionProtobufToFile(*hlo_module, buffer_debug_log_proto,\n-                                 debug_options, \"buffer_debug_log\", nullptr);\n-  int non_zero_float_check_modules_count = 0;\n-  for (const auto& entry : buffer_debug_log_proto.entries()) {\n-    if (entry.check_type() ==\n-            BufferDebugLogEntryProto::CHECK_TYPE_FLOAT_CHECKS &&\n-        entry.checksum() > 0) {\n-      LOG(ERROR) << \"Found entry with non zero float check count \"\n-                 << entry.checksum() << \" for thunk \" << entry.thunk_id()\n-                 << \" and execution \" << entry.execution_id()\n-                 << \" for module: \\n\"\n-                 << hlo_module->ToString();\n-      non_zero_float_check_modules_count++;\n-    }\n-  }\n-  if (non_zero_float_check_modules_count > 0 &&\n-      hlo_module->config().debug_options().xla_gpu_detect_nan() ==\n-          DebugOptions::NAN_CHECK_DETECTION_MODE_FAIL) {\n-    LOG(FATAL) << \"Found \" << non_zero_float_check_modules_count\n-               << \" modules with non zero float check count\";\n-  }\n-  return absl::OkStatus();\n-}\n-\n-// A boolean-like value returned from thunk filters to indicate whether the\n-// thunk should be instrumented or left as is.\n-enum class InstrumentAction : bool {\n-  // Don't instrument the thunk, leave it as is.\n-  kSkip,\n-  // Instrument the thunk.\n-  kInstrument,\n-};\n-\n-// A function that decides whether the thunk should be instrumented\n-// (kInstrument) or not (kSkip).\n-using ThunkFilter = absl::AnyInvocable<InstrumentAction(const Thunk&) const>;\n-\n-// Creates a thunk filter that filters thunks by their IDs, based the allowed\n-// ranges passed in debug options.\n-ThunkFilter CreateThunkIdFilter(const DebugOptions& debug_options) {\n-  std::vector<std::pair<int64_t, int64_t>> thunk_id_ranges;\n-  for (const auto& range :\n-       debug_options.xla_gpu_experimental_thunk_buffer_debug_filter()\n-           .thunk_id_ranges()) {\n-    VLOG(1) << \"Thunk filter: id range [\" << range.first() << \", \"\n-            << range.last() << \"]\";\n-    thunk_id_ranges.emplace_back(range.first(), range.last());\n-  }\n-\n-  return [id_ranges = std::move(thunk_id_ranges)](const Thunk& thunk) {\n-    if (id_ranges.empty()) {\n-      return InstrumentAction::kInstrument;\n-    }\n-\n-    const ThunkId thunk_id = thunk.thunk_info().thunk_id;\n-    if (absl::c_any_of(id_ranges, [&](const auto& range) {\n-          VLOG(2) << \"Thunk filter: check ID range: \" << range.first\n-                  << \" <= \" << thunk_id.value() << \" <= \" << range.second;\n-          return range.first <= thunk_id.value() &&\n-                 thunk_id.value() <= range.second;\n-        })) {\n-      VLOG(2) << \"Thunk filter: ID matches\";\n-      return InstrumentAction::kInstrument;\n-    }\n-\n-    VLOG(2) << \"Thunk filter: ID does not match\";\n-    return InstrumentAction::kSkip;\n-  };\n-}\n-\n-// Creates a thunk filter that filters thunks by matching their profile\n-// annotations against regexes configured in debug options.\n-ThunkFilter CreateProfileAnnotationRegexFilter(\n-    const DebugOptions& debug_options) {\n-  std::vector<std::unique_ptr<RE2>> profile_annotation_regexes;\n-  for (const auto& regex :\n-       debug_options.xla_gpu_experimental_thunk_buffer_debug_filter()\n-           .profile_annotation_regexes()) {\n-    VLOG(1) << \"Thunk filter: profile annotation regex: \" << regex;\n-    profile_annotation_regexes.push_back(std::make_unique<RE2>(regex));\n-  }\n-  return [regexes = std::move(profile_annotation_regexes)](const Thunk& thunk) {\n-    if (regexes.empty()) {\n-      return InstrumentAction::kInstrument;\n-    }\n-\n-    const std::string& profile_annotation =\n-        thunk.thunk_info().profile_annotation;\n-    if (absl::c_any_of(regexes, [&](const auto& regex) {\n-          VLOG(2) << \"Thunk filter: check profile annotation regex: \"\n-                  << regex->pattern();\n-          return RE2::PartialMatch(profile_annotation, *regex);\n-        })) {\n-      VLOG(2) << \"Thunk filter: profile annotation matches\";\n-      return InstrumentAction::kInstrument;\n-    }\n-\n-    VLOG(2) << \"Thunk filter: profile annotation does not match\";\n-    return InstrumentAction::kSkip;\n-  };\n-}\n-\n-// Creates a thunk filter that filters thunks by all the conditions configured\n-// in debug options.\n-ThunkFilter CreateThunkFilter(const DebugOptions& debug_options) {\n-  std::vector<ThunkFilter> filters;\n-  filters.push_back(CreateThunkIdFilter(debug_options));\n-  filters.push_back(CreateProfileAnnotationRegexFilter(debug_options));\n-\n-  return [filters = std::move(filters)](const Thunk& thunk) {\n-    VLOG(2) << \"Thunk filter: check ID \" << thunk.thunk_info().thunk_id\n-            << \", profile annotation \" << thunk.thunk_info().profile_annotation;\n-    if (absl::c_all_of(filters, [&](const auto& filter) {\n-          return filter(thunk) == InstrumentAction::kInstrument;\n-        })) {\n-      return InstrumentAction::kInstrument;\n-    }\n-    return InstrumentAction::kSkip;\n-  };\n-}\n-\n-XLA_FFI_DEFINE_HANDLER_SYMBOL(\n-    kBufferDebugChecksumLogInitHandler,\n-    [](se::Stream* absl_nonnull stream, xla::ffi::Buffer<U8> log_buffer) {\n-      return se::gpu::BufferDebugLog::CreateOnDevice<BufferDebugLogEntry>(\n-                 *stream, log_buffer.device_memory())\n-          .status();\n-    },\n-    xla::ffi::Ffi::Bind().Ctx<xla::ffi::Stream>().Arg<xla::ffi::Buffer<U8>>());\n-\n-absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateDebugInitThunk(\n-    BufferAllocation::Slice log_slice,\n-    const HloModule* absl_nonnull hlo_module) {\n-  ShapedSlice shaped_log_slice{\n-      /*slice=*/log_slice,\n-      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n-  };\n-\n-  XLA_FFI_Handler_Bundle buffer_debug_init_bundle{};\n-  buffer_debug_init_bundle.execute = kBufferDebugChecksumLogInitHandler;\n-  return CustomCallThunk::Create(\n-      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_init\",\n-      buffer_debug_init_bundle, /*operands=*/{shaped_log_slice},\n-      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n-}\n-\n-absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateBufferDebugDumpThunk(\n-    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n-    BufferAllocation::Slice log_slice,\n-    const HloModule* absl_nonnull hlo_module) {\n-  ShapedSlice shaped_log_slice{\n-      /*slice=*/log_slice,\n-      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n-  };\n-\n-  CustomCallThunk::OwnedHandlerBundle dump_bundle{};\n-  dump_bundle.execute =\n-      xla::ffi::Ffi::Bind()\n-          .Ctx<xla::ffi::Stream>()\n-          .Ctx<xla::ffi::CalledComputation>()\n-          .Arg<xla::ffi::Buffer<U8>>()\n-          .To(absl::bind_front(DumpBufferDebugChecksumLog, metadata_store));\n-  return CustomCallThunk::Create(\n-      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_dump\",\n-      std::move(dump_bundle),\n-      /*operands=*/{shaped_log_slice},\n-      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n-}\n-\n-absl::Status RunChecksumPassInternal(SequentialThunk* root_thunk,\n-                                     const DebugOptions& debug_options,\n-                                     const HloModule* absl_nonnull hlo_module,\n-                                     ThunkPassBufferAllocator& allocator) {\n-  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n-      std::make_shared<BufferDebugLogEntryMetadataStore>();\n-\n-  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n-                      allocator.NewEmptyAllocation(kLogSizeBytes));\n-  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n-\n-  TF_ASSIGN_OR_RETURN(auto buffer_debug_init_thunk,\n-                      CreateDebugInitThunk(log_slice, hlo_module));\n-\n-  TF_ASSIGN_OR_RETURN(\n-      auto buffer_debug_dump_thunk,\n-      CreateBufferDebugDumpThunk(metadata_store, log_slice, hlo_module));\n-\n-  ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n-  root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n-    if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n-      return thunk;\n-    }\n-    VLOG(1) << \"Wrapping with checksum thunk\";\n-    return WrapWithChecksumThunk(std::move(thunk), log_slice,\n-                                 /*predecessor_thunk=*/*buffer_debug_init_thunk,\n-                                 /*successor_thunk=*/*buffer_debug_dump_thunk,\n-                                 metadata_store);\n-  });\n-\n-  ThunkSequence& thunks = root_thunk->thunks();\n-  thunks.reserve(thunks.size() + 2);\n-  thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n-  thunks.push_back(std::move(buffer_debug_dump_thunk));\n-  return absl::OkStatus();\n-}\n-\n-absl::Status RunFloatCheckPassInternal(SequentialThunk* root_thunk,\n-                                       const DebugOptions& debug_options,\n-                                       const HloModule* absl_nonnull hlo_module,\n-                                       ThunkPassBufferAllocator& allocator) {\n-  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n-      std::make_shared<BufferDebugLogEntryMetadataStore>();\n-\n-  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n-                      allocator.NewEmptyAllocation(kLogSizeBytes));\n-  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n-\n-  TF_ASSIGN_OR_RETURN(auto buffer_debug_init_thunk,\n-                      CreateDebugInitThunk(log_slice, hlo_module));\n-\n-  TF_ASSIGN_OR_RETURN(\n-      auto buffer_debug_dump_thunk,\n-      CreateBufferDebugDumpThunk(metadata_store, log_slice, hlo_module));\n-\n-  ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n-  root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n-    if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n-      return thunk;\n-    }\n-    VLOG(1) << \"Wrapping with float check thunk\";\n-    return WrapWithFloatCheckThunk(\n-        std::move(thunk), log_slice,\n-        /*predecessor_thunk=*/*buffer_debug_init_thunk,\n-        /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n-  });\n-\n-  ThunkSequence& thunks = root_thunk->thunks();\n-  thunks.reserve(thunks.size() + 2);\n-  thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n-  thunks.push_back(std::move(buffer_debug_dump_thunk));\n-  return absl::OkStatus();\n-}\n-\n-}  // namespace\n-\n absl::StatusOr<bool> ThunkBufferDebugPass::Run(\n     SequentialThunk* root_thunk, const DebugOptions& debug_options,\n     const HloModule* absl_nullable hlo_module,\n     const se::DeviceDescription& device_info,\n     ThunkPassBufferAllocator& allocator) {\n   VLOG(1) << \"ThunkBufferDebugPass running\";\n+\n   if (hlo_module == nullptr) {\n     // We need the HLO module to dump the buffer debug log proto to a file. If\n     // it's not available, there's no point in doing extra work."
        }
    ],
    "stats": {
        "total": 1238,
        "additions": 788,
        "deletions": 450
    }
}