{
    "author": "ezhulenev",
    "message": "[xla:pjrt] Migtate PjRt APIs to xla::Future and xla::Promise\n\nPiperOrigin-RevId: 812115056",
    "sha": "f731ab7ca578fd7b3d79389c6e9af28925717df8",
    "files": [
        {
            "sha": "1be1503813bd5d284f4c44247bc4f774ded093c4",
            "filename": "third_party/xla/xla/pjrt/BUILD",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -100,6 +100,7 @@ cc_library(\n         \":pjrt_client\",\n         \":pjrt_future\",\n         \":raw_buffer\",\n+        \"//xla:future\",\n         \"//xla:util\",\n         \"//xla/tsl/concurrency:async_value\",\n         \"//xla/tsl/concurrency:ref_count\",\n@@ -109,7 +110,6 @@ cc_library(\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@local_tsl//tsl/profiler/lib:traceme\",\n     ],\n@@ -137,6 +137,7 @@ cc_library(\n         \":pjrt_client\",\n         \":pjrt_future\",\n         \":raw_buffer\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n@@ -271,6 +272,7 @@ cc_library(\n         \":pjrt_future\",\n         \":pjrt_layout\",\n         \":utils\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n@@ -625,6 +627,7 @@ cc_library(\n         \":transpose\",\n         \":utils\",\n         \"//xla:executable_run_options\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:shape_tree\",\n         \"//xla:shape_util\",\n@@ -701,6 +704,7 @@ xla_cc_test(\n         \":pjrt_executable\",\n         \":pjrt_future\",\n         \":pjrt_stream_executor_client\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:literal_comparison\",\n         \"//xla:literal_util\",\n@@ -934,6 +938,7 @@ cc_library(\n         \":pjrt_executable\",\n         \":pjrt_future\",\n         \":pjrt_layout\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n@@ -1035,6 +1040,7 @@ cc_library(\n         \":pjrt_compiler\",\n         \":pjrt_executable\",\n         \":pjrt_future\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n@@ -1085,6 +1091,7 @@ cc_library(\n         \":pjrt_client\",\n         \":pjrt_executable\",\n         \":pjrt_future\",\n+        \"//xla:future\",\n         \"//xla:shape_util\",\n         \"//xla/ffi:ffi_api\",\n         \"//xla/ffi/api:ffi\",\n@@ -1104,6 +1111,7 @@ xla_cc_test(\n     deps = [\n         \":host_callback\",\n         \":pjrt_client\",\n+        \"//xla:future\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n@@ -1220,6 +1228,7 @@ cc_library(\n     visibility = internal_visibility([\":friends\"]),\n     deps = [\n         \":pjrt_future\",\n+        \"//xla:future\",\n         \"//xla/tsl/concurrency:async_value\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"@com_google_absl//absl/functional:any_invocable\",\n@@ -1239,6 +1248,7 @@ cc_library(\n         \":device_event\",\n         \":pjrt_client\",\n         \":pjrt_future\",\n+        \"//xla:future\",\n         \"//xla:literal\",\n         \"//xla:shape_util\",\n         \"//xla/tsl/concurrency:async_value\","
        },
        {
            "sha": "873bf4c4dee232f7e89d08e460639e773fe331dc",
            "filename": "third_party/xla/xla/pjrt/abstract_tracked_device_buffer.h",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n@@ -64,15 +65,15 @@ class AbstractTrackedDeviceBuffer {\n   // Clones an abstract buffer with an additional control dependency.\n   virtual absl::StatusOr<std::unique_ptr<AbstractTrackedDeviceBuffer>>\n   CloneWithControlDependency(PjRtMemorySpace* memory_space,\n-                             PjRtFuture<> dependency) {\n+                             Future<> dependency) {\n     return Unimplemented(\"DonateWithControlDependency is not supported.\");\n   }\n \n   // Returns a future that becomes available when all definition events are\n   // complete.\n-  virtual PjRtFuture<> GetReadyFuture(PjRtMemorySpace* memory_space) {\n-    return PjRtFuture<>(Unimplemented(\"GetReadyFuture not supported for %s\",\n-                                      memory_space->DebugString()));\n+  virtual Future<> GetReadyFuture(PjRtMemorySpace* memory_space) {\n+    return Future<>(Unimplemented(\"GetReadyFuture not supported for %s\",\n+                                  memory_space->DebugString()));\n   }\n \n   // Waits for all usage and definition events to complete synchronously\n@@ -294,7 +295,7 @@ class CommonPjRtBuffer : public PjRtBuffer {\n   }\n \n   mutable absl::Mutex mu_;\n-  PjRtFuture<> definition_future_ ABSL_GUARDED_BY(mu_);\n+  Future<> definition_future_ ABSL_GUARDED_BY(mu_);\n   PjRtMemorySpace* const memory_space_;\n \n  private:"
        },
        {
            "sha": "f31b4bcdee8b55b1181a1507d9a5e57348a72d38",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 38,
            "changes": 76,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -38,6 +38,7 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/future.h\"\n #include \"xla/layout.h\"\n #include \"xla/layout_util.h\"\n #include \"xla/literal.h\"\n@@ -67,36 +68,35 @@ namespace xla {\n \n void CommonPjRtClient::TrackFuture(PjRtMemorySpace* memory_space,\n                                    absl::string_view debug_info,\n-                                   const PjRtFuture<>& future) {}\n+                                   const Future<>& future) {}\n \n-PjRtFuture<> CommonPjRtClient::CreateProfiledFuture(\n-    PjRtMemorySpace* memory_space, const char* callee_type,\n-    const char* callee_method, PjRtFuture<> future) {\n-  return PjRtFutureHelpers::WithProfiling(\n+Future<> CommonPjRtClient::CreateProfiledFuture(PjRtMemorySpace* memory_space,\n+                                                const char* callee_type,\n+                                                const char* callee_method,\n+                                                Future<> future) {\n+  return FutureHelpers::WithProfiling(\n       std::move(future),\n       /*on_block_start=*/\n       [callee_type, callee_method] {\n         tsl::profiler::TraceMeProducer traceme(\n             [&] { return absl::StrCat(callee_type, \"::\", callee_method); });\n         VLOG(1) << callee_type << \"::\" << callee_method;\n-        PjRtFutureHelpers::ProfilingKeys keys;\n+        FutureHelpers::ProfilingKeys keys;\n         keys.traceme_context_id = traceme.GetContextId();\n         return keys;\n       },\n       /*on_block_end=*/\n-      [callee_type, callee_method](PjRtFutureHelpers::ProfilingKeys keys) {\n+      [callee_type, callee_method](FutureHelpers::ProfilingKeys keys) {\n         tsl::profiler::TraceMeConsumer traceme(\n             [&] { return absl::StrCat(callee_type, \"::\", callee_method); },\n             keys.traceme_context_id);\n       });\n }\n \n-std::pair<PjRtFuture<>::Promise, PjRtFuture<>>\n-CommonPjRtClient::CreateLinkedUserPromise(PjRtMemorySpace* memory_space,\n-                                          const char* callee_type,\n-                                          const char* callee_method,\n-                                          absl::string_view debug_info) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n+std::pair<Promise<>, Future<>> CommonPjRtClient::CreateLinkedUserPromise(\n+    PjRtMemorySpace* memory_space, const char* callee_type,\n+    const char* callee_method, absl::string_view debug_info) {\n+  auto [promise, future] = Future<>::MakePromise();\n   auto profiled_future = CreateProfiledFuture(memory_space, callee_type,\n                                               callee_method, std::move(future));\n   TrackFuture(memory_space, debug_info, profiled_future);\n@@ -310,7 +310,7 @@ absl::StatusOr<xla::Shape> CommonPjRtClient::MakeDefaultShapeForMemorySpace(\n }\n \n void CommonPjRtBufferImpl::CopyToRemoteDevice(\n-    PjRtFuture<std::string> serialized_descriptor, RemoteSendCallback on_done) {\n+    Future<std::string> serialized_descriptor, RemoteSendCallback on_done) {\n   auto* common_client = tensorflow::down_cast<CommonPjRtClient*>(client());\n   std::vector<tsl::RCReference<tsl::AsyncValue>> definition_events;\n   tsl::RCReference<PjRtDeviceEventPromise> usage_event_promise;\n@@ -360,7 +360,7 @@ void CommonPjRtClient::ScheduleRemoteSend(\n     tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n     std::vector<tsl::RCReference<tsl::AsyncValue>> definition_events,\n     tsl::RCReference<PjRtDeviceEventPromise> usage_event_promise,\n-    PjRtFuture<std::string> serialized_descriptor,\n+    Future<std::string> serialized_descriptor,\n     PjRtBuffer::RemoteSendCallback on_done) {\n   auto error = absl::UnimplementedError(\n       absl::StrCat(\"ScheduleRemoteSend is not implemented for %s\",\n@@ -717,11 +717,11 @@ CommonPjRtBufferImpl::CopyToMemorySpaceFallbackThroughLiteral(\n   std::unique_ptr<PjRtBuffer> dst_buffer = manager->RetrieveBuffer(0);\n \n   auto literal = std::make_unique<Literal>();\n-  PjRtFuture<> d2h_future = LazyToLiteral(\n+  Future<> d2h_future = LazyToLiteral(\n       [raw_literal = literal.get(),\n-       shape = std::move(shape)]() -> PjRtFuture<MutableLiteralBase*> {\n+       shape = std::move(shape)]() -> Future<MutableLiteralBase*> {\n         *raw_literal = Literal(shape);\n-        return PjRtFuture<MutableLiteralBase*>(raw_literal);\n+        return Future<MutableLiteralBase*>(raw_literal);\n       });\n   d2h_future.OnReady(\n       [manager = std::move(manager),\n@@ -774,34 +774,34 @@ CommonPjRtBufferImpl::DirectCopyToMemorySpace(\n   return dst_buffer;\n }\n \n-PjRtFuture<> CommonPjRtBufferImpl::LazyToLiteral(\n-    absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator) {\n+Future<> CommonPjRtBufferImpl::LazyToLiteral(\n+    absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) {\n   return ToLiteralImpl(nullptr, std::move(generator));\n }\n \n-PjRtFuture<> CommonPjRtBufferImpl::ToLiteral(MutableLiteralBase* literal) {\n+Future<> CommonPjRtBufferImpl::ToLiteral(MutableLiteralBase* literal) {\n   return ToLiteralImpl(literal, [] {\n-    return PjRtFuture<MutableLiteralBase*>(\n+    return Future<MutableLiteralBase*>(\n         FailedPrecondition(\"ToLiteral generator should never be called\"));\n   });\n }\n \n-PjRtFuture<> CommonPjRtBufferImpl::ToLiteralImpl(\n+Future<> CommonPjRtBufferImpl::ToLiteralImpl(\n     MutableLiteralBase* literal,\n-    absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator) {\n+    absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) {\n   tsl::profiler::TraceMe traceme(\"CommonPjRtBuffer::ToLiteral\");\n   VLOG(1) << \"CommonPjRtBuffer::ToLiteral\";\n   auto common_client = tensorflow::down_cast<CommonPjRtClient*>(client());\n   if (!common_client->allows_recursion() && ThisThreadIsInsideHostCallback()) {\n     // Because TPU is single threaded, and the host callback currently blocking\n     // the TPU, we should not block on any outstanding computations because that\n     // risks deadlocking the TPU.\n-    return PjRtFuture<>(\n+    return Future<>(\n         InvalidArgument(\"ToLiteral() called from inside host callback.\"));\n   }\n   absl::StatusOr<Shape> device_shape = logical_on_device_shape();\n   if (!device_shape.ok()) {\n-    return PjRtFuture<>(device_shape.status());\n+    return Future<>(device_shape.status());\n   }\n \n   // TODO(zhangqiaorjc): Fast path if zero device_buffer wait events.\n@@ -828,7 +828,7 @@ PjRtFuture<> CommonPjRtBufferImpl::ToLiteralImpl(\n       },\n       \"ToLiteral()\");\n   if (!hold_status.ok()) {\n-    return PjRtFuture<>(std::move(hold_status));\n+    return Future<>(std::move(hold_status));\n   }\n \n   auto [promise, result] = common_client->CreateLinkedUserPromise(\n@@ -899,7 +899,7 @@ PjRtFuture<> CommonPjRtBufferImpl::ToLiteralImpl(\n         if (literal != nullptr) {\n           copy_literal_async(literal);\n         } else {\n-          PjRtFuture<MutableLiteralBase*> generated = std::move(generator)();\n+          Future<MutableLiteralBase*> generated = std::move(generator)();\n           generated.OnReady(\n               [copy_literal_async = std::move(copy_literal_async)](\n                   const absl::StatusOr<MutableLiteralBase*>& value) mutable {\n@@ -966,14 +966,14 @@ CommonPjRtBufferImpl::AcquireExternalReference() {\n                                                       std::move(raw_buffer)));\n }\n \n-PjRtFuture<> CommonPjRtBufferImpl::CopyRawToHost(void* dst, int64_t offset,\n-                                                 int64_t transfer_size) {\n-  return CopyRawToHostFuture(PjRtFuture<void*>(dst), offset, transfer_size);\n+Future<> CommonPjRtBufferImpl::CopyRawToHost(void* dst, int64_t offset,\n+                                             int64_t transfer_size) {\n+  return CopyRawToHostFuture(Future<void*>(dst), offset, transfer_size);\n }\n \n-PjRtFuture<> CommonPjRtBufferImpl::CopyRawToHostFuture(PjRtFuture<void*> dst,\n-                                                       int64_t offset,\n-                                                       int64_t transfer_size) {\n+Future<> CommonPjRtBufferImpl::CopyRawToHostFuture(Future<void*> dst,\n+                                                   int64_t offset,\n+                                                   int64_t transfer_size) {\n   auto buf_client = tensorflow::down_cast<CommonPjRtClient*>(client());\n   std::vector<tsl::RCReference<tsl::AsyncValue>> definition_events;\n   tsl::RCReference<CommonPjRtRawBuffer> raw_buffer;\n@@ -1012,7 +1012,7 @@ PjRtFuture<> CommonPjRtBufferImpl::CopyRawToHostFuture(PjRtFuture<void*> dst,\n       },\n       \"CopyRawSubBufferToHost()\");\n   if (!hold_status.ok()) {\n-    return PjRtFuture<>(std::move(hold_status));\n+    return Future<>(std::move(hold_status));\n   }\n \n   if (buf_client->event_tracking_enabled()) {\n@@ -1186,7 +1186,7 @@ CommonPjRtBufferImpl::ReleaseDeviceMemoryOwnership(\n }\n \n absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-CommonPjRtBufferImpl::DonateWithControlDependency(PjRtFuture<> dependency) {\n+CommonPjRtBufferImpl::DonateWithControlDependency(Future<> dependency) {\n   auto hold = GetBufferWithHold(CommonPjRtBuffer::ScopedHold::kDonation);\n   if (!hold.ok()) {\n     return InvalidArgument(\n@@ -1208,10 +1208,10 @@ CommonPjRtBufferImpl::DonateWithControlDependency(PjRtFuture<> dependency) {\n       memory_space());\n }\n \n-PjRtFuture<> CommonPjRtBufferImpl::GetReadyFuture() {\n+Future<> CommonPjRtBufferImpl::GetReadyFuture() {\n   absl::MutexLock lock(mu_);\n   if (!device_buffer()) {\n-    return PjRtFuture<>(InvalidArgument(\n+    return Future<>(InvalidArgument(\n         \"GetReadyFuture() called on deleted or donated buffer\"));\n   }\n   if (!definition_future_) {"
        },
        {
            "sha": "a5df20475bf114b4599251b95cf8f2790271908c",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.h",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -33,6 +33,7 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/future.h\"\n #include \"xla/layout.h\"\n #include \"xla/literal.h\"\n #include \"xla/pjrt/abstract_tracked_device_buffer.h\"\n@@ -125,19 +126,19 @@ class CommonPjRtClient : public PjRtClient {\n   // event_tracking_enabled()).\n   virtual void TrackFuture(PjRtMemorySpace* memory_space,\n                            absl::string_view debug_info,\n-                           const PjRtFuture<>& future);\n+                           const Future<>& future);\n \n   // Creates a future from a user-provided future with profiling and\n   // traceme scopes.\n-  virtual PjRtFuture<> CreateProfiledFuture(PjRtMemorySpace* memory_space,\n-                                            const char* callee_type,\n-                                            const char* callee_method,\n-                                            PjRtFuture<> future);\n+  virtual Future<> CreateProfiledFuture(PjRtMemorySpace* memory_space,\n+                                        const char* callee_type,\n+                                        const char* callee_method,\n+                                        Future<> future);\n \n-  // Create a linked PjRtFuture<> and ::Promise pair for operations on\n+  // Create a linked Future<> and Promise<> pair for operations on\n   // buffers in memory_space which populates debug information like linked\n   // tracmes.\n-  std::pair<PjRtFuture<>::Promise, PjRtFuture<>> CreateLinkedUserPromise(\n+  std::pair<Promise<>, Future<>> CreateLinkedUserPromise(\n       PjRtMemorySpace* memory_space, const char* callee_type,\n       const char* callee_method, absl::string_view debug_info);\n \n@@ -236,7 +237,7 @@ class CommonPjRtClient : public PjRtClient {\n       tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n       std::vector<tsl::RCReference<tsl::AsyncValue>> definition_events,\n       tsl::RCReference<PjRtDeviceEventPromise> usage_event_promise,\n-      PjRtFuture<std::string> serialized_descriptor,\n+      Future<std::string> serialized_descriptor,\n       PjRtBuffer::RemoteSendCallback on_done);\n };\n \n@@ -269,15 +270,15 @@ class CommonPjRtBufferImpl : public CommonPjRtBuffer {\n   ReleaseDeviceMemoryOwnership(bool wait_for_operations_to_complete) override;\n \n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> DonateWithControlDependency(\n-      PjRtFuture<> dependency) override;\n+      Future<> dependency) override;\n \n-  PjRtFuture<> GetReadyFuture() override;\n+  Future<> GetReadyFuture() override;\n \n   // The implementation of logical_on_device_shape may involve a blocking\n   // device to host transfer to read the metadata of dynamic shape.\n   absl::StatusOr<Shape> logical_on_device_shape() override;\n \n-  void CopyToRemoteDevice(PjRtFuture<std::string> serialized_descriptor,\n+  void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n                           RemoteSendCallback on_done) override;\n \n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n@@ -301,21 +302,20 @@ class CommonPjRtBufferImpl : public CommonPjRtBuffer {\n   CopyToMemorySpaceSyncThroughLiteral(PjRtMemorySpace* dst_memory_space);\n \n   using PjRtBuffer::ToLiteralSync;\n-  PjRtFuture<> ToLiteral(MutableLiteralBase* literal) override;\n-  PjRtFuture<> LazyToLiteral(\n-      absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator)\n-      override;\n+  Future<> ToLiteral(MutableLiteralBase* literal) override;\n+  Future<> LazyToLiteral(\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override;\n \n   absl::StatusOr<tsl::RCReference<PjRtRawBuffer>> CreateRawAliasOfBuffer();\n \n   absl::StatusOr<std::unique_ptr<ExternalReference>> AcquireExternalReference()\n       override;\n \n-  PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,\n-                             int64_t transfer_size) override;\n+  Future<> CopyRawToHost(void* dst, int64_t offset,\n+                         int64_t transfer_size) override;\n \n-  PjRtFuture<> CopyRawToHostFuture(PjRtFuture<void*> dst, int64_t offset,\n-                                   int64_t transfer_size) override;\n+  Future<> CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                               int64_t transfer_size) override;\n \n   void Delete() override;\n \n@@ -324,9 +324,9 @@ class CommonPjRtBufferImpl : public CommonPjRtBuffer {\n  protected:\n   // Shared implementation for ToLiteral and LazyToLiteral. If `literal` is\n   // null, will call the function in the generator.\n-  PjRtFuture<> ToLiteralImpl(\n+  Future<> ToLiteralImpl(\n       MutableLiteralBase* literal,\n-      absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator);\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator);\n \n  private:\n   const Shape on_device_shape_;"
        },
        {
            "sha": "095bc2232c26eadd125ab1ade539cb903a9232ae",
            "filename": "third_party/xla/xla/pjrt/device_event.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fdevice_event.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fdevice_event.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdevice_event.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n@@ -87,7 +88,7 @@ class PjRtDeviceEvent : public PjRtDeviceEventOrPromise {\n   const absl::Status& status() const { return async_value()->GetError(); }\n \n   // Converts a device-event into a future.\n-  virtual PjRtFuture<> GetReadyFuture() = 0;\n+  virtual Future<> GetReadyFuture() = 0;\n };\n \n // Instead of taking a device event as an argument, apis may instead decide to"
        },
        {
            "sha": "9a2d2001af77ab369d49a4cc7d1c020c84fcb9b3",
            "filename": "third_party/xla/xla/pjrt/host_callback.h",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"xla/ffi/api/ffi.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n@@ -67,15 +68,15 @@ class ThreadSafePjRtChunkQueue {\n   }\n \n   // Pop a PjRtChunk future from the queue.\n-  PjRtFuture<PjRtChunk> Pop() {\n+  Future<PjRtChunk> Pop() {\n     absl::MutexLock lock(&mu_);\n     if (queue_.empty()) {\n-      auto [promise, future] = PjRtFuture<PjRtChunk>::MakePromise();\n+      auto [promise, future] = Future<PjRtChunk>::MakePromise();\n       promises_.push_back(std::move(promise));\n       return std::move(future);\n     }\n \n-    auto chunk = PjRtFuture<PjRtChunk>(std::move(queue_.front()));\n+    auto chunk = Future<PjRtChunk>(std::move(queue_.front()));\n     queue_.pop_front();\n     return chunk;\n   }\n@@ -84,7 +85,7 @@ class ThreadSafePjRtChunkQueue {\n   absl::Mutex mu_;\n   std::deque<PjRtChunk> queue_ ABSL_GUARDED_BY(mu_);\n   // Contains unfulfilled pop promises.\n-  std::deque<PjRtFuture<PjRtChunk>::Promise> promises_ ABSL_GUARDED_BY(mu_);\n+  std::deque<Promise<PjRtChunk>> promises_ ABSL_GUARDED_BY(mu_);\n };\n \n struct HostCallbackArgInfo {"
        },
        {
            "sha": "157a43f800baa3d92c63eea164570a65b5a49757",
            "filename": "third_party/xla/xla/pjrt/host_callback_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback_test.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -25,6 +25,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/notification.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/tests/literal_test_util.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n@@ -64,11 +65,11 @@ class TestStream : public CopyToDeviceStream {\n         chunk_(chunk),\n         done_(done) {}\n \n-  PjRtFuture<> AddChunk(PjRtChunk chunk) override {\n+  Future<> AddChunk(PjRtChunk chunk) override {\n     CHECK(!done_.HasBeenNotified());\n     chunk_ = std::move(chunk);\n     done_.Notify();\n-    return PjRtFuture<>(absl::OkStatus());\n+    return Future<>(absl::OkStatus());\n   }\n \n  private:"
        },
        {
            "sha": "d2a264ba95fba7b5ee94064a99b1fb54b3d45566",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 20,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -43,6 +43,7 @@ limitations under the License.\n #include \"mlir/Pass/PassManager.h\"\n #include \"mlir/Support/LogicalResult.h\"\n #include \"xla/ffi/execution_context.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/translate/mhlo_to_hlo/mlir_hlo_to_hlo.h\"\n@@ -98,7 +99,7 @@ namespace xla {\n         error, pjrt::MakeErrorDeleter(c_api));                           \\\n     absl::Status _status = pjrt::PjrtErrorToStatus(_error.get(), c_api); \\\n     if (!_status.ok()) {                                                 \\\n-      return PjRtFuture<>(_status);                                      \\\n+      return Future<>(_status);                                          \\\n     }                                                                    \\\n   } while (false)\n \n@@ -1956,7 +1957,7 @@ CApiCopyToDeviceStream::~CApiCopyToDeviceStream() {\n       c_api_->PJRT_CopyToDeviceStream_Destroy(&destroy_args), c_api_);\n }\n \n-PjRtFuture<> CApiCopyToDeviceStream::AddChunk(PjRtChunk chunk) {\n+Future<> CApiCopyToDeviceStream::AddChunk(PjRtChunk chunk) {\n   PJRT_Chunk c_chunk = ::pjrt::ConvertFromCppChunk(std::move(chunk));\n \n   PJRT_CopyToDeviceStream_AddChunk_Args add_chunk_args;\n@@ -2230,7 +2231,7 @@ absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>>\n PjRtCApiLoadedExecutable::Execute(\n     absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n     const ExecuteOptions& options,\n-    std::optional<std::vector<PjRtFuture<>>>& returned_futures) const {\n+    std::optional<std::vector<Future<>>>& returned_futures) const {\n   std::vector<std::vector<PJRT_Buffer*>> c_argument_lists_storage;\n   std::vector<int64_t> non_donatable_input_indices_storage;\n   std::vector<int> task_ids_storage;\n@@ -2285,7 +2286,7 @@ PjRtCApiLoadedExecutable::Execute(\n       pjrt_c_api()->PJRT_LoadedExecutable_Execute(&args), pjrt_c_api());\n \n   if (device_complete_events.has_value()) {\n-    std::vector<PjRtFuture<>> device_complete_futures;\n+    std::vector<Future<>> device_complete_futures;\n     device_complete_futures.reserve(args.num_devices);\n     for (int i = 0; i < args.num_devices; ++i) {\n       device_complete_futures.push_back(pjrt::ConvertCEventToCppFuture(\n@@ -2314,7 +2315,7 @@ PjRtCApiLoadedExecutable::Execute(\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n PjRtCApiLoadedExecutable::ExecuteWithSingleDevice(\n     absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-    const ExecuteOptions& options, std::optional<PjRtFuture<>>& returned_future,\n+    const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n     bool fill_future) const {\n   if (!options.send_callbacks.empty() || !options.recv_callbacks.empty()) {\n     return absl::Status(absl::StatusCode::kUnimplemented,\n@@ -2377,7 +2378,7 @@ PjRtCApiLoadedExecutable::ExecuteWithSingleDevice(\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n PjRtCApiLoadedExecutable::ExecuteSharded(\n     absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-    const ExecuteOptions& options, std::optional<PjRtFuture<>>& returned_future,\n+    const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n     bool fill_future) const {\n   return ExecuteWithSingleDevice(argument_handles, device, options,\n                                  returned_future, fill_future);\n@@ -2386,7 +2387,7 @@ PjRtCApiLoadedExecutable::ExecuteSharded(\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n PjRtCApiLoadedExecutable::ExecutePortable(\n     absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-    const ExecuteOptions& options, std::optional<PjRtFuture<>>& returned_future,\n+    const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n     bool fill_future) const {\n   return ExecuteWithSingleDevice(argument_handles, device, options,\n                                  returned_future, fill_future);\n@@ -2593,17 +2594,17 @@ absl::StatusOr<std::vector<int64_t>> PjRtCApiBuffer::logical_dimensions() {\n                               args.unpadded_dims + args.num_dims);\n }\n \n-PjRtFuture<> PjRtCApiBuffer::LazyToLiteral(\n-    absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator) {\n-  PjRtFuture<MutableLiteralBase*> future = std::move(generator)();\n+Future<> PjRtCApiBuffer::LazyToLiteral(\n+    absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) {\n+  Future<MutableLiteralBase*> future = std::move(generator)();\n   const absl::StatusOr<MutableLiteralBase*>& literal = future.Await();\n   if (!literal.ok()) {\n-    return PjRtFuture<>(literal.status());\n+    return Future<>(literal.status());\n   }\n   return ToLiteral(literal.value());\n }\n \n-PjRtFuture<> PjRtCApiBuffer::ToLiteral(MutableLiteralBase* literal) {\n+Future<> PjRtCApiBuffer::ToLiteral(MutableLiteralBase* literal) {\n   PJRT_Buffer_ToHostBuffer_Args args;\n   args.struct_size = PJRT_Buffer_ToHostBuffer_Args_STRUCT_SIZE;\n   args.extension_start = nullptr;\n@@ -2612,7 +2613,7 @@ PjRtFuture<> PjRtCApiBuffer::ToLiteral(MutableLiteralBase* literal) {\n   const xla::Shape& shape = literal->shape();\n \n   if (!shape.IsArray()) {\n-    return PjRtFuture<>(\n+    return Future<>(\n         Unimplemented(\"PjRtCApiBuffer::ToLiteral: Shapes other than array are\"\n                       \"not supported.\"));\n   }\n@@ -2624,7 +2625,7 @@ PjRtFuture<> PjRtCApiBuffer::ToLiteral(MutableLiteralBase* literal) {\n     c_layout_data =\n         pjrt::ConvertToBufferMemoryLayoutData(literal->shape().layout());\n     if (!c_layout_data.ok()) {\n-      return PjRtFuture<>(c_layout_data.status());\n+      return Future<>(c_layout_data.status());\n     }\n     args.host_layout = &(c_layout_data->c_layout);\n   } else {\n@@ -2638,7 +2639,7 @@ PjRtFuture<> PjRtCApiBuffer::ToLiteral(MutableLiteralBase* literal) {\n       ::pjrt::MakeErrorDeleter(api)};\n \n   if (error != nullptr) {\n-    return PjRtFuture<>(::pjrt::PjrtErrorToStatus(error.get(), api));\n+    return Future<>(::pjrt::PjrtErrorToStatus(error.get(), api));\n   }\n \n   return pjrt::ConvertCEventToCppFuture(args.event, api);\n@@ -2702,8 +2703,8 @@ bool PjRtCApiBuffer::IsDeleted() const {\n   return args.is_deleted;\n }\n \n-PjRtFuture<> PjRtCApiBuffer::CopyRawToHost(void* dst, int64_t offset,\n-                                           int64_t transfer_size) {\n+Future<> PjRtCApiBuffer::CopyRawToHost(void* dst, int64_t offset,\n+                                       int64_t transfer_size) {\n   PJRT_Buffer_CopyRawToHost_Args args;\n   args.struct_size = PJRT_Buffer_CopyRawToHost_Args_STRUCT_SIZE;\n   args.extension_start = nullptr;\n@@ -2800,9 +2801,9 @@ void PjRtCApiBuffer::MakePromiseTrackEvent() {\n   }\n }\n \n-PjRtFuture<> PjRtCApiBuffer::GetReadyFuture() {\n+Future<> PjRtCApiBuffer::GetReadyFuture() {\n   if (readiness_promise_ == nullptr) {\n-    auto [promise, future] = PjRtFuture<>::MakePromise();\n+    auto [promise, future] = Future<>::MakePromise();\n     readiness_promise_ = std::move(promise).ToShared();\n     readiness_future_ = std::move(future);\n     MakePromiseTrackEvent();\n@@ -2840,7 +2841,7 @@ PjRtCApiBuffer::AcquireExternalReference() {\n }\n \n void PjRtCApiBuffer::CopyToRemoteDevice(\n-    PjRtFuture<std::string> serialized_descriptor, RemoteSendCallback on_done) {\n+    Future<std::string> serialized_descriptor, RemoteSendCallback on_done) {\n   PJRT_CrossHostTransfers_Extension* extension =\n       client_->FindExtension<PJRT_CrossHostTransfers_Extension>(\n           PJRT_Extension_Type::PJRT_Extension_Type_CrossHostTransfers);"
        },
        {
            "sha": "f29c6530f2df6dde8df4d99bd5beeb01c10fe041",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 15,
            "deletions": 18,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -37,6 +37,7 @@ limitations under the License.\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/types/span.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/layout.h\"\n@@ -474,15 +475,14 @@ class PjRtCApiBuffer : public PjRtBuffer {\n   absl::StatusOr<std::unique_ptr<ExternalReference>> AcquireExternalReference()\n       override;\n \n-  PjRtFuture<> ToLiteral(MutableLiteralBase* literal) override;\n-  PjRtFuture<> LazyToLiteral(\n-      absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator)\n-      override;\n+  Future<> ToLiteral(MutableLiteralBase* literal) override;\n+  Future<> LazyToLiteral(\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override;\n \n   absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n \n-  PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,\n-                             int64_t transfer_size) override;\n+  Future<> CopyRawToHost(void* dst, int64_t offset,\n+                         int64_t transfer_size) override;\n \n   void Delete() override;\n \n@@ -497,10 +497,10 @@ class PjRtCApiBuffer : public PjRtBuffer {\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n       PjRtMemorySpace* dst_memory_space) override;\n \n-  void CopyToRemoteDevice(PjRtFuture<std::string> serialized_descriptor,\n+  void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n                           RemoteSendCallback on_done) override;\n \n-  PjRtFuture<> GetReadyFuture() override;\n+  Future<> GetReadyFuture() override;\n \n   bool IsOnCpu() const override;\n \n@@ -524,9 +524,9 @@ class PjRtCApiBuffer : public PjRtBuffer {\n   // This is a shared_ptr to keep the underlying future alive even if\n   // `readiness_promise` is destroyed before `readiness_event`, and the callback\n   // we set on `readiness_event` modifies `readiness_promise_`.\n-  std::shared_ptr<PjRtFuture<>::Promise> readiness_promise_;\n+  std::shared_ptr<Promise<>> readiness_promise_;\n   // Future tied to the `readiness_promise_`.\n-  PjRtFuture<> readiness_future_;\n+  Future<> readiness_future_;\n   // Set and cached the first time layout() is called.\n   mutable std::shared_ptr<const PjRtLayout> layout_;\n   // Set and cached the first time is_dynamic_dimension() is called.\n@@ -671,19 +671,16 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n   absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(\n       absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n       const ExecuteOptions& options,\n-      std::optional<std::vector<PjRtFuture<>>>& returned_futures)\n-      const override;\n+      std::optional<std::vector<Future<>>>& returned_futures) const override;\n \n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n       bool fill_future) const override;\n \n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n       bool fill_future) const override;\n \n   void Delete() override;\n@@ -750,7 +747,7 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n   ExecuteWithSingleDevice(absl::Span<PjRtBuffer* const> argument_handles,\n                           PjRtDevice* device, const ExecuteOptions& options,\n-                          std::optional<PjRtFuture<>>& returned_future,\n+                          std::optional<Future<>>& returned_future,\n                           bool fill_future) const;\n \n   PjRtCApiClient* client_;\n@@ -768,7 +765,7 @@ class CApiCopyToDeviceStream : public CopyToDeviceStream {\n                          const PJRT_Api* c_api);\n   ~CApiCopyToDeviceStream() override;\n \n-  PjRtFuture<> AddChunk(PjRtChunk chunk) override;\n+  Future<> AddChunk(PjRtChunk chunk) override;\n \n  private:\n   PJRT_CopyToDeviceStream* c_stream_;"
        },
        {
            "sha": "8aeb459a59135db3d56446c94d9a3ddd01b956c1",
            "filename": "third_party/xla/xla/pjrt/pjrt_client.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/substitute.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n@@ -54,10 +55,9 @@ absl::StatusOr<std::uintptr_t> PjRtClient::UnsafeBufferPointer(\n   return absl::bit_cast<std::uintptr_t>(ptr);\n }\n \n-PjRtFuture<> PjRtBuffer::CopyRawToHostFuture(PjRtFuture<void*> dst,\n-                                             int64_t offset,\n-                                             int64_t transfer_size) {\n-  return PjRtFuture<>(absl::UnimplementedError(\n+Future<> PjRtBuffer::CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                                         int64_t transfer_size) {\n+  return Future<>(absl::UnimplementedError(\n       \"PjRtBuffer::CopyRawToHostFuture is not implemented\"));\n }\n "
        },
        {
            "sha": "1df48b2bb95fea62f65cbca7bbd8ac669544c571",
            "filename": "third_party/xla/xla/pjrt/pjrt_client.h",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -42,6 +42,7 @@ limitations under the License.\n #include \"absl/synchronization/notification.h\"\n #include \"absl/types/span.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/layout.h\"\n #include \"xla/literal.h\"\n@@ -376,7 +377,7 @@ class CopyToDeviceStream {\n   //\n   // The transfer is started immediately, and the returned future is fulfilled\n   // when the transfer completes or fails.\n-  virtual PjRtFuture<> AddChunk(PjRtChunk chunk) = 0;\n+  virtual Future<> AddChunk(PjRtChunk chunk) = 0;\n \n   // Returns the total amount of data the stream expects to be transferred.\n   int64_t total_bytes() const { return total_bytes_; }\n@@ -1095,14 +1096,14 @@ class PjRtBuffer {\n   // Return value is a future the caller can use to discover when the copy has\n   // completed. The transfer respects the layout of `literal`; to specify a\n   // particular layout, set the layout before calling `ToLiteral`.\n-  virtual PjRtFuture<> ToLiteral(MutableLiteralBase* literal) = 0;\n+  virtual Future<> ToLiteral(MutableLiteralBase* literal) = 0;\n   // This version of ToLiteral allows the implementation to defer the\n   // construction of the literal (e.g. until the underlying buffer is ready).\n   // The specific timing of calling `generator` is implementation defined, and\n   // might be done eagerly, but it is guaranteed to be earlier than when the\n   // returned future becomes ready.\n-  virtual PjRtFuture<> LazyToLiteral(\n-      absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator) = 0;\n+  virtual Future<> LazyToLiteral(\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) = 0;\n \n   // Synchronous overload of ToLiteral, as a convenience.\n   absl::Status ToLiteralSync(MutableLiteralBase* literal) {\n@@ -1169,8 +1170,8 @@ class PjRtBuffer {\n   // Note that the underlying driver may have requirements\n   // on the alignment of `dst` and `offset` as well. Look at implementations of\n   // this method for specific alignment requirements.\n-  virtual PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,\n-                                     int64_t transfer_size) = 0;\n+  virtual Future<> CopyRawToHost(void* dst, int64_t offset,\n+                                 int64_t transfer_size) = 0;\n \n   // As above, but the transfer will not happen until `dst` is fulfilled with a\n   // valid pointer. If `dst` is fulfilled with a non-Ok status, then the\n@@ -1183,9 +1184,8 @@ class PjRtBuffer {\n   //\n   // The default implementation always returns a future that is fulfilled with\n   // an UNIMPLEMENTED error.\n-  virtual PjRtFuture<> CopyRawToHostFuture(PjRtFuture<void*> dst,\n-                                           int64_t offset,\n-                                           int64_t transfer_size);\n+  virtual Future<> CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                                       int64_t transfer_size);\n \n   // Drops the buffer's reference to its associated device memory, leaving the\n   // buffer in an invalid state. The memory will be freed lazily when all async\n@@ -1263,7 +1263,7 @@ class PjRtBuffer {\n   // comment for PjRtClient.\n   using RemoteSendCallback =\n       std::function<void(absl::Status status, bool sends_were_enqueued)>;\n-  virtual void CopyToRemoteDevice(PjRtFuture<std::string> serialized_descriptor,\n+  virtual void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n                                   RemoteSendCallback on_done) = 0;\n \n   // Donates 'this' and returns a new buffer that is ready only when both 'this'\n@@ -1275,7 +1275,7 @@ class PjRtBuffer {\n   // If either 'this' or 'dependency' transitions to error, then the returned\n   // buffer will transition to error.\n   virtual absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-  DonateWithControlDependency(PjRtFuture<> dependency) {\n+  DonateWithControlDependency(Future<> dependency) {\n     return absl::UnimplementedError(\n         \"DonateWithControlDependency is not supported.\");\n   }\n@@ -1289,7 +1289,7 @@ class PjRtBuffer {\n   // the buffer has been deleted or donated then the returned future will stay\n   // valid (will not transition to error as a consequence of buffer deletion)\n   // even if the buffer is subsequently donated or deleted.\n-  virtual PjRtFuture<> GetReadyFuture() = 0;\n+  virtual Future<> GetReadyFuture() = 0;\n \n   // Whether this buffer is on CPU and thus allows for certain optimizations.\n   virtual bool IsOnCpu() const = 0;\n@@ -1368,12 +1368,12 @@ class PjRtLoadedExecutable {\n   virtual absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>>\n   Execute(absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n           const ExecuteOptions& options,\n-          std::optional<std::vector<PjRtFuture<>>>& returned_futures) const = 0;\n+          std::optional<std::vector<Future<>>>& returned_futures) const = 0;\n   // Convenience wrapper for Execute that never returns futures.\n   absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(\n       absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n       const ExecuteOptions& options) const {\n-    std::optional<std::vector<PjRtFuture<>>> returned_futures;\n+    std::optional<std::vector<Future<>>> returned_futures;\n     return Execute(std::move(argument_handles), options, returned_futures);\n   }\n \n@@ -1390,21 +1390,21 @@ class PjRtLoadedExecutable {\n   virtual absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n   ExecuteSharded(absl::Span<PjRtBuffer* const> argument_handles,\n                  PjRtDevice* device, const ExecuteOptions& options,\n-                 std::optional<PjRtFuture<>>& returned_future,\n+                 std::optional<Future<>>& returned_future,\n                  bool fill_future) const = 0;\n   // Convenience wrapper for ExecuteSharded that always returns a future.\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n       const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future) const {\n+      std::optional<Future<>>& returned_future) const {\n     return ExecuteSharded(std::move(argument_handles), device, options,\n                           returned_future, /*fill_future=*/true);\n   }\n   // Convenience wrapper for ExecuteSharded that never returns a future.\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n       const ExecuteOptions& options) const {\n-    std::optional<PjRtFuture<>> returned_future;\n+    std::optional<Future<>> returned_future;\n     return ExecuteSharded(std::move(argument_handles), device, options,\n                           returned_future, /*fill_future=*/false);\n   }\n@@ -1422,21 +1422,21 @@ class PjRtLoadedExecutable {\n   virtual absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n   ExecutePortable(absl::Span<PjRtBuffer* const> argument_handles,\n                   PjRtDevice* device, const ExecuteOptions& options,\n-                  std::optional<PjRtFuture<>>& returned_future,\n+                  std::optional<Future<>>& returned_future,\n                   bool fill_future) const = 0;\n   // Convenience wrapper for ExecutePortable that always returns a future.\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n       const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future) const {\n+      std::optional<Future<>>& returned_future) const {\n     return ExecutePortable(std::move(argument_handles), device, options,\n                            returned_future, /*fill_future=*/true);\n   }\n   // Convenience wrapper for ExecutePortable that never returns a future.\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n       const ExecuteOptions& options) const {\n-    std::optional<PjRtFuture<>> returned_future;\n+    std::optional<Future<>> returned_future;\n     return ExecutePortable(std::move(argument_handles), device, options,\n                            returned_future, /*fill_future=*/false);\n   }\n@@ -1543,7 +1543,7 @@ class PjRtLoadedExecutable {\n   // combining the result buffers with a future that becomes ready when the\n   // execution completes.\n   struct Result {\n-    std::optional<PjRtFuture<>> future;\n+    std::optional<Future<>> future;\n     std::vector<std::unique_ptr<PjRtBuffer>> buffers;\n   };\n "
        },
        {
            "sha": "4f14a355778fcebc30697f09fcbcde0d22aa8611",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 43,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -100,6 +100,7 @@ limitations under the License.\n #include \"xla/client/executable_build_options.h\"\n #include \"xla/client/local_client.h\"\n #include \"xla/executable_run_options.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n@@ -840,7 +841,7 @@ PjRtStreamExecutorBuffer::ReleaseDeviceMemoryOwnership(\n }\n \n absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-PjRtStreamExecutorBuffer::DonateWithControlDependency(PjRtFuture<> dependency) {\n+PjRtStreamExecutorBuffer::DonateWithControlDependency(Future<> dependency) {\n   VLOG(1) << \"PjRtStreamExecutorBuffer::DonateWithControlDependency\";\n   std::unique_ptr<PjRtBuffer> new_buffer;\n \n@@ -1516,32 +1517,32 @@ void PjRtStreamExecutorBuffer::ConvertUsageHold(TrackedDeviceBuffer* buffer,\n   DecrementUsage();\n }\n \n-PjRtFuture<> PjRtStreamExecutorBuffer::LazyToLiteral(\n-    absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator) {\n+Future<> PjRtStreamExecutorBuffer::LazyToLiteral(\n+    absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) {\n   auto buffer = std::move(generator)();\n   return ToLiteralHelper(std::move(buffer));\n }\n \n-PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteral(MutableLiteralBase* literal) {\n-  return ToLiteralHelper(PjRtFuture<MutableLiteralBase*>(literal));\n+Future<> PjRtStreamExecutorBuffer::ToLiteral(MutableLiteralBase* literal) {\n+  return ToLiteralHelper(Future<MutableLiteralBase*>(literal));\n }\n \n-PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n-    PjRtFuture<MutableLiteralBase*> literal) {\n+Future<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n+    Future<MutableLiteralBase*> literal) {\n   VLOG(3) << \"PjRtStreamExecutorBuffer::ToLiteral\";\n   if (IsEmptyTuple()) {\n-    return PjRtFuture<>(InvalidArgument(\"ToLiteral called on empty tuple\"));\n+    return Future<>(InvalidArgument(\"ToLiteral called on empty tuple\"));\n   }\n   LocalDeviceState* local_device = device_->local_device_state();\n   se::Stream* stream = local_device->GetDeviceToHostStream();\n   auto device_buffer = GetBufferWithUsageHold();\n   if (!device_buffer.ok()) {\n-    return PjRtFuture<>(\n+    return Future<>(\n         InvalidArgument(\"ToLiteral() called on deleted or donated buffer: %s\",\n                         device_buffer.status().ToString()));\n   }\n \n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n+  auto [promise, future] = Future<>::MakePromise();\n   auto usage_event = BufferSequencingEvent::Create(client_->thread_pool());\n \n   TransferManager* transfer_manager =\n@@ -1565,8 +1566,8 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n   device_buffer.ConvertUsageHold(stream, usage_event, /*reference_held=*/true);\n \n   auto [literal_and_transpose_promise, literal_and_transpose_future] =\n-      PjRtFuture<std::pair<MutableLiteralBase*,\n-                           std::shared_ptr<TransposePlan>>>::MakePromise();\n+      Future<std::pair<MutableLiteralBase*,\n+                       std::shared_ptr<TransposePlan>>>::MakePromise();\n \n   literal.OnReady(\n       [client = client_, on_device_shape{on_device_shape_},\n@@ -1724,18 +1725,18 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n   first_definition_event->ExecuteOrAddToFutureTasks(\n       \"async_to_literal\", std::move(async_to_literal));\n \n-  return PjRtFutureHelpers::WithProfiling(\n+  return FutureHelpers::WithProfiling(\n       std::move(future),\n       /*on_block_start=*/\n       []() {\n         tsl::profiler::TraceMeProducer traceme(\n             \"PjRtStreamExecutorBuffer::ToLiteral\");\n         VLOG(3) << \"PjRtStreamExecutorBuffer::ToLiteral\";\n-        return PjRtFutureHelpers::ProfilingKeys(\n+        return FutureHelpers::ProfilingKeys(\n             {/*traceme_context_id =*/traceme.GetContextId()});\n       },\n       /*on_block_end=*/\n-      [](PjRtFutureHelpers::ProfilingKeys keys) {\n+      [](FutureHelpers::ProfilingKeys keys) {\n         tsl::profiler::TraceMeConsumer traceme(\n             \"PjRtStreamExecutorBuffer::ToLiteral\", keys.traceme_context_id);\n       });\n@@ -1751,14 +1752,15 @@ absl::StatusOr<size_t> PjRtStreamExecutorBuffer::GetOnDeviceSizeInBytes()\n   return device_buffer()->device_memory()->mem().size();\n }\n \n-PjRtFuture<> PjRtStreamExecutorBuffer::CopyRawToHost(void* dst, int64_t offset,\n-                                                     int64_t transfer_size) {\n-  return client_->CopyRawSubBufferToHost(this, PjRtFuture<void*>(dst), offset,\n+Future<> PjRtStreamExecutorBuffer::CopyRawToHost(void* dst, int64_t offset,\n+                                                 int64_t transfer_size) {\n+  return client_->CopyRawSubBufferToHost(this, Future<void*>(dst), offset,\n                                          transfer_size);\n }\n \n-PjRtFuture<> PjRtStreamExecutorBuffer::CopyRawToHostFuture(\n-    PjRtFuture<void*> dst, int64_t offset, int64_t transfer_size) {\n+Future<> PjRtStreamExecutorBuffer::CopyRawToHostFuture(Future<void*> dst,\n+                                                       int64_t offset,\n+                                                       int64_t transfer_size) {\n   return client_->CopyRawSubBufferToHost(this, dst, offset, transfer_size);\n }\n \n@@ -1941,7 +1943,7 @@ PjRtStreamExecutorBuffer::CopyToMemorySpace(PjRtMemorySpace* dst_memory_space) {\n }\n \n void PjRtStreamExecutorBuffer::CopyToRemoteDevice(\n-    PjRtFuture<std::string> serialized_descriptor, RemoteSendCallback on_done) {\n+    Future<std::string> serialized_descriptor, RemoteSendCallback on_done) {\n   VLOG(3) << \"PjRtStreamExecutorBuffer::CopyToRemoteDevice\";\n   auto desc = serialized_descriptor.Await();\n   if (desc.ok()) {\n@@ -1951,20 +1953,20 @@ void PjRtStreamExecutorBuffer::CopyToRemoteDevice(\n   }\n }\n \n-PjRtFuture<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n+Future<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n   absl::InlinedVector<BufferSequencingEventRef, 2> definition_events;\n-  PjRtFuture<>::Promise definition_promise;\n-  PjRtFuture<> definition_future;\n+  Promise<> definition_promise;\n+  Future<> definition_future;\n   {\n     absl::MutexLock lock(&mu_);\n     if (device_buffer() == nullptr) {\n-      return PjRtFuture<>(InvalidArgument(\n+      return Future<>(InvalidArgument(\n           \"GetReadyFuture() called on deleted or donated buffer\"));\n     }\n     if (!definition_future_) {\n       definition_events = device_buffer()->definition_events();\n       std::tie(definition_promise, definition_future_) =\n-          PjRtFuture<>::MakePromise();\n+          Future<>::MakePromise();\n     }\n     definition_future = definition_future_;\n   }\n@@ -1975,7 +1977,7 @@ PjRtFuture<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n     auto async_wait_for_events =\n         [definition_events = std::move(definition_events),\n          local_device_state = std::move(local_device_state),\n-         definition_promise = std::make_shared<PjRtFuture<>::Promise>(\n+         definition_promise = std::make_shared<Promise<>>(\n              std::move(definition_promise))]() mutable {\n           std::unique_ptr<se::Stream> stream;\n           absl::Status defined_status =\n@@ -2023,18 +2025,18 @@ PjRtFuture<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n         std::move(async_wait_for_events));\n   }\n \n-  return PjRtFutureHelpers::WithProfiling(\n+  return FutureHelpers::WithProfiling(\n       std::move(definition_future),\n       /*on_block_start=*/\n       [] {\n         tsl::profiler::TraceMeProducer traceme(\n             \"PjRtStreamExecutorBuffer::Await\");\n         VLOG(3) << \"PjRtStreamExecutorBuffer::Await\";\n-        return PjRtFutureHelpers::ProfilingKeys(\n+        return FutureHelpers::ProfilingKeys(\n             {/*traceme_context_id=*/traceme.GetContextId()});\n       },\n       /*on_block_end=*/\n-      [](PjRtFutureHelpers::ProfilingKeys keys) {\n+      [](FutureHelpers::ProfilingKeys keys) {\n         tsl::profiler::TraceMeConsumer traceme(\n             \"PjRtStreamExecutorBuffer::Await\", keys.traceme_context_id);\n       });\n@@ -2504,7 +2506,7 @@ class StreamExecutorCopyToDeviceStream : public CopyToDeviceStream {\n         dst_(dst),\n         done_(std::move(done)) {}\n \n-  PjRtFuture<> AddChunk(PjRtChunk chunk) final {\n+  Future<> AddChunk(PjRtChunk chunk) final {\n     tsl::profiler::TraceMe trace([&] {\n       return tsl::profiler::TraceMeEncode(\n           \"StreamExecutorCopyToDeviceStream::AddChunk\",\n@@ -2522,15 +2524,15 @@ class StreamExecutorCopyToDeviceStream : public CopyToDeviceStream {\n       done_.SetError(absl::InvalidArgumentError(absl::StrFormat(\n           \"Chunk size (%d) was not a multiple of the granule size (%d)\",\n           chunk.size(), granule_size_in_bytes())));\n-      return PjRtFuture<>(done_.GetError());\n+      return Future<>(done_.GetError());\n     }\n \n     if (current_bytes_ + chunk.size() > total_bytes_) {\n       done_.SetError(absl::InvalidArgumentError(\n           absl::StrFormat(\"Adding chunk of size %d would overflow buffer of \"\n                           \"size %d (%d already transferred)\",\n                           chunk.size(), total_bytes_, current_bytes_)));\n-      return PjRtFuture<>(done_.GetError());\n+      return Future<>(done_.GetError());\n     }\n \n     se::DeviceMemoryBase dst(\n@@ -2544,15 +2546,15 @@ class StreamExecutorCopyToDeviceStream : public CopyToDeviceStream {\n     auto copied = stream_->Memcpy(&dst, chunk.data(), chunk.size());\n     if (!copied.ok()) {\n       done_.SetError(copied);\n-      return PjRtFuture<>(done_.GetError());\n+      return Future<>(done_.GetError());\n     }\n \n     // Delete chunk once the memcpy operation completes.\n     auto* chunk_ptr = std::make_unique<PjRtChunk>(std::move(chunk)).release();\n     auto deleted = stream_->DoHostCallback([chunk_ptr]() { delete chunk_ptr; });\n     if (!deleted.ok()) {\n       done_.SetError(deleted);\n-      return PjRtFuture<>(done_.GetError());\n+      return Future<>(done_.GetError());\n     }\n \n     // Record done event once processed the last chunk. It is the caller\n@@ -2562,12 +2564,12 @@ class StreamExecutorCopyToDeviceStream : public CopyToDeviceStream {\n       auto recorded = stream_->RecordEvent(done_.get().get());\n       if (!recorded.ok()) {\n         done_.SetError(recorded);\n-        return PjRtFuture<>(done_.GetError());\n+        return Future<>(done_.GetError());\n       }\n       done_.SetStateConcrete();\n     }\n \n-    return PjRtFuture<>(absl::OkStatus());\n+    return Future<>(absl::OkStatus());\n   }\n \n  private:\n@@ -3044,7 +3046,7 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n         outputs.push_back(std::move(error_buffer));\n       }\n     }\n-    auto future = std::make_optional(PjRtFuture<>(input_error));\n+    auto future = std::make_optional(Future<>(input_error));\n     return Result({std::move(future), /*buffers=*/std::move(outputs)});\n   }\n \n@@ -3113,9 +3115,9 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n     }\n   }\n \n-  std::optional<PjRtFuture<>> maybe_future;\n+  std::optional<Future<>> maybe_future;\n   if (fill_future) {\n-    auto [promise, future] = PjRtFuture<>::MakePromise();\n+    auto [promise, future] = Future<>::MakePromise();\n     maybe_future = std::move(future);\n     compute_callbacks.push_back(\n         [promise = std::move(promise)]() mutable { promise.Set(); });\n@@ -3156,7 +3158,7 @@ absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>>\n PjRtStreamExecutorLoadedExecutable::Execute(\n     absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n     const ExecuteOptions& options,\n-    std::optional<std::vector<PjRtFuture<>>>& returned_futures) const {\n+    std::optional<std::vector<Future<>>>& returned_futures) const {\n   if (device_assignment_ == nullptr) {\n     return InvalidArgument(\"Execute expects a non-null device_assignment\");\n   }\n@@ -3298,7 +3300,7 @@ PjRtStreamExecutorLoadedExecutable::Execute(\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n PjRtStreamExecutorLoadedExecutable::ExecuteSharded(\n     absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-    const ExecuteOptions& options, std::optional<PjRtFuture<>>& returned_future,\n+    const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n     bool fill_future) const {\n   if (device_assignment_ == nullptr) {\n     return InvalidArgument(\"ExecuteShard expects a non-null device_assignment\");\n@@ -3327,7 +3329,7 @@ PjRtStreamExecutorLoadedExecutable::ExecuteSharded(\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n PjRtStreamExecutorLoadedExecutable::ExecutePortable(\n     absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-    const ExecuteOptions& options, std::optional<PjRtFuture<>>& returned_future,\n+    const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n     bool fill_future) const {\n   if (device_assignment_ != nullptr) {\n     return InvalidArgument(\"ExecutePortable gets a non-portable executable\");"
        },
        {
            "sha": "f63526d77d84bf03b4943e95d2810cbe8c750457",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 19,
            "deletions": 23,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -42,6 +42,7 @@ limitations under the License.\n #include \"xla/client/executable_build_options.h\"\n #include \"xla/client/local_client.h\"\n #include \"xla/executable_run_options.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/layout.h\"\n@@ -425,11 +426,10 @@ class PjRtStreamExecutorClient : public CommonPjRtClient {\n             /*sends_were_enqueued=*/false);\n   }\n \n-  virtual PjRtFuture<> CopyRawSubBufferToHost(PjRtBuffer* buffer,\n-                                              PjRtFuture<void*> dst,\n-                                              int64_t offset,\n-                                              int64_t transfer_size) {\n-    return PjRtFuture<>(Unimplemented(\"Raw copies to host not implemented.\"));\n+  virtual Future<> CopyRawSubBufferToHost(PjRtBuffer* buffer, Future<void*> dst,\n+                                          int64_t offset,\n+                                          int64_t transfer_size) {\n+    return Future<>(Unimplemented(\"Raw copies to host not implemented.\"));\n   }\n \n   virtual tsl::RCReference<PjRtDeviceEvent> CopyRawHostToDevice(\n@@ -615,18 +615,17 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBuffer {\n   ReleaseDeviceMemoryOwnership(bool wait_for_operations_to_complete) override;\n \n   using PjRtBuffer::ToLiteralSync;\n-  PjRtFuture<> ToLiteral(MutableLiteralBase* literal) override;\n-  PjRtFuture<> LazyToLiteral(\n-      absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator)\n-      override;\n+  Future<> ToLiteral(MutableLiteralBase* literal) override;\n+  Future<> LazyToLiteral(\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override;\n \n   absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n \n-  PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,\n-                             int64_t transfer_size) override;\n+  Future<> CopyRawToHost(void* dst, int64_t offset,\n+                         int64_t transfer_size) override;\n \n-  PjRtFuture<> CopyRawToHostFuture(PjRtFuture<void*> dst, int64_t offset,\n-                                   int64_t transfer_size) override;\n+  Future<> CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                               int64_t transfer_size) override;\n \n   // Drops the buffer's reference to its associated device memory, leaving the\n   // buffer in an invalid state. The memory will be freed lazily when all async\n@@ -652,10 +651,10 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBuffer {\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n       PjRtMemorySpace* dst_memory_space) override;\n \n-  void CopyToRemoteDevice(PjRtFuture<std::string> serialized_descriptor,\n+  void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n                           RemoteSendCallback on_done) override;\n \n-  PjRtFuture<> GetReadyFuture() override;\n+  Future<> GetReadyFuture() override;\n \n   bool IsOnCpu() const override;\n \n@@ -678,7 +677,7 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBuffer {\n       bool wait_for_operations_to_complete);\n \n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> DonateWithControlDependency(\n-      PjRtFuture<> dependency) override;\n+      Future<> dependency) override;\n \n  private:\n   friend class PjRtClient;\n@@ -705,7 +704,7 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBuffer {\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToDeviceMemorySpace(\n       PjRtDevice* dst_device, PjRtMemorySpace* dst_memory_space = nullptr);\n \n-  PjRtFuture<> ToLiteralHelper(PjRtFuture<MutableLiteralBase*> literal);\n+  Future<> ToLiteralHelper(Future<MutableLiteralBase*> literal);\n \n   PjRtStreamExecutorClient* const client_;\n   const Shape on_device_shape_;\n@@ -811,21 +810,18 @@ class PjRtStreamExecutorLoadedExecutable : public PjRtLoadedExecutable {\n   absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(\n       absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n       const ExecuteOptions& options,\n-      std::optional<std::vector<PjRtFuture<>>>& returned_futures)\n-      const override;\n+      std::optional<std::vector<Future<>>>& returned_futures) const override;\n \n   using PjRtLoadedExecutable::ExecuteSharded;\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n       bool fill_future) const override;\n \n   using PjRtLoadedExecutable::ExecutePortable;\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n       bool fill_future) const override;\n \n   void Delete() override { executables_.clear(); }"
        },
        {
            "sha": "b3c95a5aa1425558e03666f7b22a995476a8ac07",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client_test.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -29,6 +29,7 @@ limitations under the License.\n #include \"absl/synchronization/mutex.h\"\n #include \"xla/client/client_library.h\"\n #include \"xla/client/local_client.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_builder.h\"\n #include \"xla/hlo/testlib/test.h\"\n #include \"xla/literal.h\"\n@@ -151,7 +152,7 @@ TEST(PjRtStreamExecutorClientTest, DonateWithControlDependency) {\n       std::unique_ptr<PjRtBuffer> buffer,\n       client->BufferFromHostLiteral(literal, client->memory_spaces()[0]));\n \n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n+  auto [promise, future] = Future<>::MakePromise();\n   auto blocked_buffer =\n       std::move(*(buffer->DonateWithControlDependency(future)));\n   EXPECT_TRUE(buffer->IsDeleted());"
        },
        {
            "sha": "ae70ebc3f3f7bed84361783f8b2bc6d740e07d11",
            "filename": "third_party/xla/xla/pjrt/raw_buffer.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -23,6 +23,7 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/async_work_runner.h\"\n #include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n@@ -40,12 +41,12 @@ std::vector<RegisterRawBufferFactory::FactoryFuncT>& GetFactoryFuncs() {\n   return *funcs;\n }\n \n-PjRtFuture<> CommonPjRtRawBuffer::CopyRawHostToDevice(const void* src,\n-                                                      int64_t offset,\n-                                                      int64_t transfer_size) {\n+Future<> CommonPjRtRawBuffer::CopyRawHostToDevice(const void* src,\n+                                                  int64_t offset,\n+                                                  int64_t transfer_size) {\n   auto event = CopyRawHostToDeviceAndReturnEvent(src, offset, transfer_size);\n   if (!event.ok()) {\n-    return PjRtFuture<>(event.status());\n+    return Future<>(event.status());\n   }\n   return (*event)->GetReadyFuture();\n }\n@@ -69,11 +70,11 @@ CommonPjRtRawBuffer::MultiSlice(absl::Span<const SliceInfo> slices) {\n                                                memory_space()->DebugString()));\n }\n \n-PjRtFuture<> CommonPjRtRawBuffer::CopyRawDeviceToHost(void* dst, int64_t offset,\n-                                                      int64_t transfer_size) {\n+Future<> CommonPjRtRawBuffer::CopyRawDeviceToHost(void* dst, int64_t offset,\n+                                                  int64_t transfer_size) {\n   auto event = CopyRawDeviceToHostAndReturnEvent(dst, offset, transfer_size);\n   if (!event.ok()) {\n-    return PjRtFuture<>(event.status());\n+    return Future<>(event.status());\n   }\n   return (*event)->GetReadyFuture();\n }"
        },
        {
            "sha": "196288bbe2974bda568c6516a224f1bdf38c5b58",
            "filename": "third_party/xla/xla/pjrt/raw_buffer.h",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n \n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"xla/future.h\"\n #include \"xla/literal.h\"\n #include \"xla/pjrt/async_work_runner.h\"\n #include \"xla/pjrt/device_event.h\"\n@@ -60,8 +61,8 @@ class PjRtRawBuffer : public tsl::ReferenceCounted<PjRtRawBuffer> {\n   // Note that the underlying driver may have requirements\n   // on the alignment of `src` and `offset` as well. Look at implementations of\n   // this method for specific alignment requirements.\n-  virtual PjRtFuture<> CopyRawHostToDevice(const void* src, int64_t offset,\n-                                           int64_t transfer_size) = 0;\n+  virtual Future<> CopyRawHostToDevice(const void* src, int64_t offset,\n+                                       int64_t transfer_size) = 0;\n \n   // Transfers a sub-range of the on-device representation of the buffer.\n   // offset+transfer_size must be less than GetOnDeviceSizeInBytes. The\n@@ -71,8 +72,8 @@ class PjRtRawBuffer : public tsl::ReferenceCounted<PjRtRawBuffer> {\n   // Note that the underlying driver may have requirements\n   // on the alignment of `dst` and `offset` as well. Look at implementations of\n   // this method for specific alignment requirements.\n-  virtual PjRtFuture<> CopyRawDeviceToHost(void* dst, int64_t offset,\n-                                           int64_t transfer_size) = 0;\n+  virtual Future<> CopyRawDeviceToHost(void* dst, int64_t offset,\n+                                       int64_t transfer_size) = 0;\n };\n \n // Adds methods common to all implementations of PjRtRawBuffer based on device\n@@ -94,8 +95,8 @@ class CommonPjRtRawBuffer : public PjRtRawBuffer {\n   CopyRawHostToDeviceAndReturnEvent(const void* src, int64_t offset,\n                                     int64_t transfer_size) = 0;\n \n-  PjRtFuture<> CopyRawHostToDevice(const void* src, int64_t offset,\n-                                   int64_t transfer_size) override;\n+  Future<> CopyRawHostToDevice(const void* src, int64_t offset,\n+                               int64_t transfer_size) override;\n \n   // Transfers a sub-range of the on-device representation of the buffer.\n   // offset+transfer_size must be less than GetOnDeviceSizeInBytes. The\n@@ -109,8 +110,8 @@ class CommonPjRtRawBuffer : public PjRtRawBuffer {\n   CopyRawDeviceToHostAndReturnEvent(void* dst, int64_t offset,\n                                     int64_t transfer_size) = 0;\n \n-  PjRtFuture<> CopyRawDeviceToHost(void* dst, int64_t offset,\n-                                   int64_t transfer_size) override;\n+  Future<> CopyRawDeviceToHost(void* dst, int64_t offset,\n+                               int64_t transfer_size) override;\n \n   // A sliced buffer is a view into the offset and range of this buffer.\n   //\n@@ -145,7 +146,7 @@ class CommonPjRtRawBuffer : public PjRtRawBuffer {\n   // Interprets buffer contents as having shape and linearizes these contents\n   // async into the provided literal.\n   virtual void CopyToLiteralAsync(\n-      PjRtFuture<>::Promise promise,\n+      Promise<> promise,\n       tsl::RCReference<PjRtDeviceEventPromise> device_promise,\n       MutableLiteralBase* literal, xla::Shape shape) = 0;\n "
        },
        {
            "sha": "7a3803ff97f86f13e41e3448111899d8448c4fb0",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/pjrt/pjrt_stream_executor_client.h\"\n@@ -36,8 +37,8 @@ limitations under the License.\n \n namespace xla {\n \n-PjRtFuture<> PjRtStreamExecutorDeviceEvent::GetReadyFuture() {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n+Future<> PjRtStreamExecutorDeviceEvent::GetReadyFuture() {\n+  auto [promise, future] = Future<>::MakePromise();\n   event_.AndThen([promise = std::move(promise), event = event_]() mutable {\n     if (auto* error = event.GetErrorIfPresent()) {\n       promise.Set(*error);\n@@ -46,17 +47,17 @@ PjRtFuture<> PjRtStreamExecutorDeviceEvent::GetReadyFuture() {\n     }\n   });\n \n-  return PjRtFutureHelpers::WithProfiling(\n+  return FutureHelpers::WithProfiling(\n       std::move(future),\n       /*on_block_start=*/\n       [callee_method = callee_method_, callee_type = callee_type_]() {\n         tsl::profiler::TraceMeProducer traceme(\n             [&] { return absl::StrCat(callee_type, \"::\", callee_method); });\n-        return PjRtFutureHelpers::ProfilingKeys({traceme.GetContextId()});\n+        return FutureHelpers::ProfilingKeys({traceme.GetContextId()});\n       },\n       /*on_block_end=*/\n       [callee_method = callee_method_,\n-       callee_type = callee_type_](PjRtFutureHelpers::ProfilingKeys keys) {\n+       callee_type = callee_type_](FutureHelpers::ProfilingKeys keys) {\n         tsl::profiler::TraceMeConsumer traceme(\n             [&] { return absl::StrCat(callee_type, \"::\", callee_method); },\n             keys.traceme_context_id);\n@@ -147,8 +148,7 @@ void PjRtStreamExecutorRawBuffer::ReadDynamicShape(\n }\n \n void PjRtStreamExecutorRawBuffer::CopyToLiteralAsync(\n-    PjRtFuture<>::Promise promise,\n-    tsl::RCReference<PjRtDeviceEventPromise> device_promise,\n+    Promise<> promise, tsl::RCReference<PjRtDeviceEventPromise> device_promise,\n     MutableLiteralBase* literal, xla::Shape shape) {\n   device_promise->SetError(\n       absl::UnimplementedError(\"Cannot CopyToLiteralAsync.\"));"
        },
        {
            "sha": "c35c2cd7a77eb439c6c8568b83a1e4d8932bb07b",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <utility>\n \n #include \"absl/status/statusor.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/pjrt/pjrt_stream_executor_client.h\"\n #include \"xla/pjrt/raw_buffer.h\"\n@@ -47,7 +48,7 @@ class PjRtStreamExecutorDeviceEvent : public PjRtDeviceEvent {\n     return event_.GetAsyncValue();\n   }\n \n-  PjRtFuture<> GetReadyFuture() override;\n+  Future<> GetReadyFuture() override;\n \n  private:\n   tsl::AsyncValueRef<BufferSequencingEvent> event_;\n@@ -104,7 +105,7 @@ class PjRtStreamExecutorRawBuffer : public CommonPjRtRawBuffer {\n                         xla::Shape shape) override;\n \n   void CopyToLiteralAsync(\n-      PjRtFuture<>::Promise promise,\n+      Promise<> promise,\n       tsl::RCReference<PjRtDeviceEventPromise> device_promise,\n       MutableLiteralBase* literal, xla::Shape shape) override;\n   void CopyTo(tsl::RCReference<CommonPjRtRawBuffer> dst_raw_buffer,"
        },
        {
            "sha": "a8fd3b2f464a0fa75b62bc2067314874ca69fdd3",
            "filename": "third_party/xla/xla/pjrt/tf_pjrt_client.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.cc?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -25,6 +25,7 @@ limitations under the License.\n #include \"absl/log/log.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/future.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n \n@@ -57,7 +58,7 @@ absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>>\n TfPjRtExecutable::Execute(\n     absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n     const ExecuteOptions& options,\n-    std::optional<std::vector<PjRtFuture<>>>& returned_futures) const {\n+    std::optional<std::vector<Future<>>>& returned_futures) const {\n   std::vector<std::vector<PjRtBuffer*>> unwrapped_argument_handles;\n   unwrapped_argument_handles.reserve(argument_handles.size());\n   for (auto& handles : argument_handles) {\n@@ -83,7 +84,7 @@ absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n TfPjRtExecutable::ExecuteSharded(absl::Span<PjRtBuffer* const> argument_handles,\n                                  PjRtDevice* device,\n                                  const ExecuteOptions& options,\n-                                 std::optional<PjRtFuture<>>& returned_future,\n+                                 std::optional<Future<>>& returned_future,\n                                  bool fill_future) const {\n   std::vector<PjRtBuffer*> unwrapped_argument_handles;\n   unwrapped_argument_handles.reserve(argument_handles.size());\n@@ -102,7 +103,7 @@ TfPjRtExecutable::ExecuteSharded(absl::Span<PjRtBuffer* const> argument_handles,\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n TfPjRtExecutable::ExecutePortable(\n     absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-    const ExecuteOptions& options, std::optional<PjRtFuture<>>& returned_future,\n+    const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n     bool fill_future) const {\n   std::vector<PjRtBuffer*> unwrapped_argument_handles;\n   unwrapped_argument_handles.reserve(argument_handles.size());"
        },
        {
            "sha": "da91ae5fbc2511fde929302a263e9179350d3bf1",
            "filename": "third_party/xla/xla/pjrt/tf_pjrt_client.h",
            "status": "modified",
            "additions": 11,
            "deletions": 14,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f731ab7ca578fd7b3d79389c6e9af28925717df8/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.h?ref=f731ab7ca578fd7b3d79389c6e9af28925717df8",
            "patch": "@@ -35,6 +35,7 @@ limitations under the License.\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/types/span.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n+#include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/layout.h\"\n@@ -77,19 +78,18 @@ class TfPjRtBuffer : public PjRtBuffer {\n       override {\n     return wrapped_->AcquireExternalReference();\n   }\n-  PjRtFuture<> ToLiteral(MutableLiteralBase* literal) override {\n+  Future<> ToLiteral(MutableLiteralBase* literal) override {\n     return wrapped_->ToLiteral(literal);\n   }\n-  PjRtFuture<> LazyToLiteral(\n-      absl::AnyInvocable<PjRtFuture<MutableLiteralBase*>() &&> generator)\n-      override {\n+  Future<> LazyToLiteral(\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override {\n     return wrapped_->LazyToLiteral(std::move(generator));\n   }\n   absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override {\n     return wrapped_->GetOnDeviceSizeInBytes();\n   }\n-  PjRtFuture<> CopyRawToHost(void* dst, int64_t offset,\n-                             int64_t transfer_size) override {\n+  Future<> CopyRawToHost(void* dst, int64_t offset,\n+                         int64_t transfer_size) override {\n     return wrapped_->CopyRawToHost(dst, offset, transfer_size);\n   }\n   void Delete() override { wrapped_->Delete(); }\n@@ -101,12 +101,12 @@ class TfPjRtBuffer : public PjRtBuffer {\n   bool IsDeleted() const override { return wrapped_->IsDeleted(); }\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n       PjRtMemorySpace* dst_memory_space) override;\n-  void CopyToRemoteDevice(PjRtFuture<std::string> serialized_descriptor,\n+  void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n                           RemoteSendCallback on_done) override {\n     wrapped_->CopyToRemoteDevice(std::move(serialized_descriptor),\n                                  std::move(on_done));\n   }\n-  PjRtFuture<> GetReadyFuture() override { return wrapped_->GetReadyFuture(); }\n+  Future<> GetReadyFuture() override { return wrapped_->GetReadyFuture(); }\n   bool IsOnCpu() const override { return wrapped_->IsOnCpu(); }\n \n   // Not thread-safe. The caller should promises to have some external\n@@ -158,19 +158,16 @@ class TfPjRtExecutable : public PjRtLoadedExecutable {\n   absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(\n       absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n       const ExecuteOptions& options,\n-      std::optional<std::vector<PjRtFuture<>>>& returned_futures)\n-      const override;\n+      std::optional<std::vector<Future<>>>& returned_futures) const override;\n   using PjRtLoadedExecutable::ExecuteSharded;\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n       bool fill_future) const override;\n   using PjRtLoadedExecutable::ExecutePortable;\n   absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n       absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options,\n-      std::optional<PjRtFuture<>>& returned_future,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n       bool fill_future) const override;\n \n   void Delete() override { return wrapped_->Delete(); }"
        }
    ],
    "stats": {
        "total": 500,
        "additions": 256,
        "deletions": 244
    }
}