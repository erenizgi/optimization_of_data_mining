{
    "author": "mwhittaker",
    "message": "Remove unused `CoordinationClientCache`.\n\nPiperOrigin-RevId: 843362068",
    "sha": "b650c8ec468c0a73e515e8bd334696d815ef1f36",
    "files": [
        {
            "sha": "fc6c3a9001f0af657936b8c6535918fcb2ca938d",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 26,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -103,7 +103,9 @@ xla_cc_test(\n         \":coordination_service\",\n         \":coordination_service_error_util\",\n         \":test_device_proto_cc\",\n+        \"//xla/service:global_device_id\",\n         \"//xla/tsl/distributed_runtime:call_options\",\n+        \"//xla/tsl/distributed_runtime/coordination:coordination_service\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:status\",\n@@ -245,32 +247,6 @@ xla_cc_test(\n     ],\n )\n \n-xla_cc_test(\n-    name = \"coordination_service_recoverable_job_test\",\n-    srcs = [\"coordination_service_recoverable_job_test.cc\"],\n-    deps = [\n-        \":coordination_client\",\n-        \":coordination_service\",\n-        \":coordination_service_agent\",\n-        \":grpc_coordination_client\",\n-        \":grpc_coordination_service_impl\",\n-        \"//xla/tsl/distributed_runtime/rpc:async_service_interface\",\n-        \"//xla/tsl/lib/core:status_test_util\",\n-        \"//xla/tsl/platform:env\",\n-        \"//xla/tsl/platform:status\",\n-        \"//xla/tsl/platform:test\",\n-        \"//xla/tsl/protobuf:coordination_config_proto_cc_impl\",\n-        \"@com_github_grpc_grpc//:grpc++\",\n-        \"@com_google_absl//absl/base:core_headers\",\n-        \"@com_google_absl//absl/container:flat_hash_map\",\n-        \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/memory\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/synchronization\",\n-        \"@com_google_googletest//:gtest_main\",\n-    ],\n-)\n-\n xla_cc_test(\n     name = \"client_server_test\",\n     size = \"medium\","
        },
        {
            "sha": "07fd5fe468f4155bf713f233087814ad272807b7",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/client_server_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -115,8 +115,8 @@ class ClientServerTest : public ::testing::Test {\n         config.mutable_coordinated_job_list()->Add();\n     job->set_name(\"agent\");\n     job->set_num_tasks(num_nodes);\n-    auto service = CoordinationService::Create(tsl::Env::Default(), config,\n-                                               /*cache=*/nullptr);\n+    auto service =\n+        std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n     return config;\n   }\n \n@@ -160,8 +160,8 @@ class ClientServerTest : public ::testing::Test {\n                              grpc::InsecureServerCredentials());\n     // Set up the actual coordination service (where all the real logic\n     // lives).\n-    coord_service_ = CoordinationService::Create(tsl::Env::Default(), config,\n-                                                 /*cache=*/nullptr);\n+    coord_service_ =\n+        std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n     // Set up threads and RPC service.\n     coord_compute_pool_ = std::make_unique<tsl::thread::ThreadPool>(\n         tsl::Env::Default(), \"CoordinationServiceRpcHandler\","
        },
        {
            "sha": "49313c4177e4bff52e33431090e88e3c4785f85f",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_client.h",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_client.h?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -154,21 +154,6 @@ class CoordinationClient {\n                                  tsl::StatusCallback done) = 0;\n };\n \n-// Simple wrapper class that can be used to retrieve CoordinationClients.\n-class CoordinationClientCache {\n- public:\n-  virtual ~CoordinationClientCache() = default;\n-\n-  // If the `target` names a remote task, returns a pointer of the\n-  // CoordinationClient object wrapping that channel to the remote task.\n-  virtual CoordinationClient* GetClient(const std::string& target) = 0;\n-\n-  // If the `target` names a remote task, returns an owned pointer of the\n-  // CoordinationClient object wrapping that channel to the remote task.\n-  virtual std::unique_ptr<CoordinationClient> GetOwnedClient(\n-      const std::string& target) = 0;\n-};\n-\n }  // namespace xla\n \n #endif  // XLA_PJRT_DISTRIBUTED_COORDINATION_COORDINATION_CLIENT_H_"
        },
        {
            "sha": "7df2ef53488c5fba0ef91bb3968946a4e33c2639",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 58,
            "changes": 61,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -201,10 +201,8 @@ bool CoordinationService::TaskState::IsDisconnectedBeyondGracePeriod() {\n }\n \n CoordinationService::CoordinationService(\n-    tsl::Env* env, const CoordinationServiceConfig& config,\n-    std::unique_ptr<CoordinationClientCache> client_cache)\n-    : client_cache_(std::move(client_cache)),\n-      env_(*env),\n+    tsl::Env* env, const CoordinationServiceConfig& config)\n+    : env_(*env),\n       heartbeat_timeout_ms_([&config]() -> uint64_t {\n         return config.heartbeat_timeout_in_ms() > 0\n                    ? config.heartbeat_timeout_in_ms()\n@@ -965,52 +963,7 @@ void CoordinationService::PropagateError(\n     VLOG(3) << \"All tasks are recoverable, skip propagating error.\";\n     return;\n   }\n-  // If there is no service-to-client connection, use error polling or stop\n-  // the service.\n-  if (client_cache_ == nullptr) {\n-    SendErrorPollingResponseOrFailAllTasks(error);\n-    return;\n-  }\n-\n-  ReportErrorToTaskRequest request;\n-  request.set_error_code(error.raw_code());\n-  request.set_error_message(std::string(error.message()));\n-  CoordinationServiceError* payload = request.mutable_error_payload();\n-  payload->set_is_reported_error(is_reported_by_task);\n-  tsl::CallOptions call_opts;\n-  call_opts.SetTimeout(kServiceToClientTimeoutMs);\n-  // TODO(b/369222279): This logic will be removed shortly, so we don't bother\n-  // adding the full list of source tasks.\n-  if (!source_tasks.empty()) {\n-    *payload->mutable_source_task() = source_tasks[0];\n-  }\n-\n-  std::vector<std::shared_ptr<absl::Notification>> notifications;\n-\n-  for (const auto& pair : cluster_state_) {\n-    // Propagate error only to tasks that are connected\n-    if (pair.second->GetState() != CoordinatedTaskState::TASKSTATE_CONNECTED) {\n-      continue;\n-    }\n-    std::string task = pair.first;\n-\n-    CoordinationClient* client = client_cache_->GetClient(task);\n-    auto response = std::make_shared<ReportErrorToTaskResponse>();\n-    auto n = std::make_shared<absl::Notification>();\n-    client->ReportErrorToTaskAsync(\n-        &call_opts, &request, response.get(),\n-        [response, n, task](const absl::Status& s) {\n-          if (!s.ok()) {\n-            LOG(ERROR) << \"Encountered another error while reporting to \"\n-                       << task << \": \" << s;\n-          }\n-          n->Notify();\n-        });\n-    notifications.push_back(n);\n-  }\n-  for (auto& n : notifications) {\n-    n->WaitForNotification();\n-  }\n+  SendErrorPollingResponseOrFailAllTasks(error);\n }\n \n // Utility for normalizing structured config key string.\n@@ -1125,13 +1078,6 @@ void CoordinationService::PollForErrorAsync(const CoordinatedTask& task,\n     return;\n   }\n \n-  if (client_cache_ != nullptr) {\n-    done(MakeCoordinationError(\n-        absl::InternalError(\"Should not use error polling from service when \"\n-                            \"there is service to client connection.\")));\n-    return;\n-  }\n-\n   client_polling_for_error_ = true;\n \n   if (!cluster_state_.contains(task_name)) {\n@@ -1891,7 +1837,6 @@ void CoordinationService::SendErrorPollingResponseOrFailAllTasks(\n   CHECK(!error.ok()) << \"SendErrorPollingResponseOrFailAllTasks called with OK \"\n                         \"status. Should always return an error.\";\n   // Should be called only when there is no service-to-client connection.\n-  assert(client_cache_ == nullptr);\n   if (IsClientPollingForError()) {\n     LOG(ERROR)\n         << \"Use error polling to propagate the following error to all tasks: \""
        },
        {
            "sha": "e95bd9c2adf23dc2673f5aa071381e2b5d3b63b3",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service.h",
            "status": "modified",
            "additions": 2,
            "deletions": 12,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.h?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -89,15 +89,8 @@ class CoordinationService {\n       absl::flat_hash_set<tensorflow::CoordinatedTask, CoordinatedTaskHash,\n                           CoordinatedTaskEqual>;\n \n-  static std::unique_ptr<CoordinationService> Create(\n-      tsl::Env* env, const tensorflow::CoordinationServiceConfig& config,\n-      std::unique_ptr<CoordinationClientCache> cache) {\n-    return std::make_unique<CoordinationService>(env, config, std::move(cache));\n-  }\n-\n   CoordinationService(tsl::Env* env,\n-                      const tensorflow::CoordinationServiceConfig& config,\n-                      std::unique_ptr<CoordinationClientCache> client_cache);\n+                      const tensorflow::CoordinationServiceConfig& config);\n \n   ~CoordinationService() {\n     absl::MutexLock lock(state_mu_);\n@@ -280,9 +273,7 @@ class CoordinationService {\n                           GetAliveTasksCallback done);\n \n   // Gets error from the coordination service. Block until the service\n-  // returns an error or the task/service is shutdown. This should never be used\n-  // when there is service to client connection (i.e. `CoordinationClientCache`\n-  // is passed in during construction).\n+  // returns an error or the task/service is shutdown.\n   //\n   // The first call to this function will trigger the error polling mode in the\n   // coordination service, so once an error occurs after the first call, the\n@@ -619,7 +610,6 @@ class CoordinationService {\n   // such that NotifyWatchJobStateCallbacks should be called.\n   void ClusterStateUpdated() ABSL_EXCLUSIVE_LOCKS_REQUIRED(state_mu_);\n \n-  std::unique_ptr<CoordinationClientCache> client_cache_;\n   tsl::Env& env_;\n   const IncarnationId service_incarnation_{tsl::random::New64()};\n   const uint64_t heartbeat_timeout_ms_;"
        },
        {
            "sha": "8f2dfb02ab135d98998becdec3c0b17f03aa05d9",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_recoverable_job_test.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 272,
            "changes": 272,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/17d6e98b76810250de1b626c16607f5189137a52/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_recoverable_job_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/17d6e98b76810250de1b626c16607f5189137a52/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_recoverable_job_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_recoverable_job_test.cc?ref=17d6e98b76810250de1b626c16607f5189137a52",
            "patch": "@@ -1,272 +0,0 @@\n-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-#include <memory>\n-#include <string>\n-#include <utility>\n-\n-#include \"absl/base/thread_annotations.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/log/log.h\"\n-#include \"absl/memory/memory.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/synchronization/mutex.h\"\n-#include \"grpcpp/server.h\"\n-#include \"grpcpp/server_builder.h\"\n-#include \"grpcpp/support/channel_arguments.h\"\n-#include \"xla/pjrt/distributed/coordination/coordination_client.h\"\n-#include \"xla/pjrt/distributed/coordination/coordination_service.h\"\n-#include \"xla/pjrt/distributed/coordination/coordination_service_agent.h\"\n-#include \"xla/pjrt/distributed/coordination/grpc_coordination_client.h\"\n-#include \"xla/pjrt/distributed/coordination/grpc_coordination_service_impl.h\"\n-#include \"xla/tsl/distributed_runtime/rpc/async_service_interface.h\"\n-#include \"xla/tsl/lib/core/status_test_util.h\"\n-#include \"xla/tsl/platform/env.h\"\n-#include \"xla/tsl/platform/status.h\"\n-#include \"xla/tsl/platform/test.h\"\n-#include \"xla/tsl/platform/threadpool.h\"\n-#include \"xla/tsl/protobuf/coordination_config.pb.h\"\n-\n-namespace xla {\n-namespace {\n-using tensorflow::CoordinatedJob;\n-using tensorflow::CoordinationServiceConfig;\n-\n-constexpr char kParameterServerJobName[] = \"parameter_server\";\n-constexpr char kWorkerJobName[] = \"worker\";\n-constexpr char kCoordinationServiceType[] = \"standalone\";\n-constexpr char kServiceLeader[] = \"/job:parameter_server/replica:0/task:0\";\n-\n-class TestCoordinationClientCache : public CoordinationClientCache {\n- public:\n-  void AddTask(const std::string& target, CoordinationClient* client) {\n-    absl::MutexLock l(clients_mu_);\n-    clients_.emplace(target, client);\n-  }\n-\n-  CoordinationClient* GetClient(const std::string& target) override {\n-    absl::MutexLock l(clients_mu_);\n-    if (auto it = clients_.find(target); it != clients_.end()) {\n-      return it->second;\n-    }\n-    return nullptr;\n-  }\n-\n-  std::unique_ptr<CoordinationClient> GetOwnedClient(\n-      const std::string& target) override {\n-    LOG(ERROR) << \"GetOwnedClient is not supported.\";\n-    return nullptr;\n-  }\n-\n- private:\n-  absl::Mutex clients_mu_;\n-  absl::flat_hash_map<std::string, CoordinationClient*> clients_\n-      ABSL_GUARDED_BY(clients_mu_);\n-};\n-\n-class TestCoordinationServiceTaskState {\n- public:\n-  TestCoordinationServiceTaskState() = default;\n-\n-  ~TestCoordinationServiceTaskState() = default;\n-\n-  void Shutdown() {\n-    coord_client_.reset();\n-    coord_agent_.reset();\n-    coord_compute_pool_.reset();\n-    static_cast<GrpcCoordinationServiceImpl*>(coord_rpc_service_.get())\n-        ->SetCoordinationServiceInstance(nullptr);\n-    grpc_server_->Shutdown();\n-    coord_rpc_service_->Shutdown();\n-  }\n-\n-  void StartGrpcServer() {\n-    ::grpc::ServerBuilder builder;\n-    coord_compute_pool_ = std::make_unique<tsl::thread::ThreadPool>(\n-        tsl::Env::Default(), /*name=*/\"CoordinationServiceRpcHandler\",\n-        /*num_threads=*/5);\n-    coord_rpc_service_ = std::make_unique<GrpcCoordinationServiceImpl>(\n-        coord_compute_pool_.get(), &builder);\n-    auto* grpc_coord_service =\n-        static_cast<GrpcCoordinationServiceImpl*>(coord_rpc_service_.get());\n-    grpc_coord_service->SetCoordinationServiceAgentInstance(coord_agent_.get());\n-    grpc_server_ = builder.BuildAndStart();\n-    coord_client_ = absl::WrapUnique(NewGrpcCoordinationClient(\n-        grpc_server_->InProcessChannel(::grpc::ChannelArguments())));\n-    coord_rpc_thread_ = absl::WrapUnique(tsl::Env::Default()->StartThread(\n-        /*thread_options=*/{}, /*name=*/\"CoordinationServiceHandleRPCsLoop\",\n-        [service = coord_rpc_service_.get()]() { service->HandleRPCsLoop(); }));\n-  }\n-\n-  void SetCoordinationService(CoordinationService* service) {\n-    auto* grpc_coord_service =\n-        static_cast<GrpcCoordinationServiceImpl*>(coord_rpc_service_.get());\n-    grpc_coord_service->SetCoordinationServiceInstance(service);\n-  }\n-\n-  void InitializeAndConnectCoordinationAgents(\n-      const std::string& job_name, int task_id,\n-      const CoordinationServiceConfig& coordination_config) {\n-    auto error_fn = [this, job_name](const absl::Status& status) {\n-      this->status_ = status;\n-      LOG(ERROR) << \"Coordination service agent of \" << job_name\n-                 << \" is in error status: \" << status;\n-    };\n-\n-    TF_CHECK_OK(coord_agent_->Initialize(tsl::Env::Default(), job_name, task_id,\n-                                         coordination_config,\n-                                         std::move(coord_client_), error_fn));\n-    TF_CHECK_OK(coord_agent_->Connect());\n-    TF_CHECK_OK(status_);\n-  }\n-\n-  CoordinationClient* GetCoordinationClient() { return coord_client_.get(); }\n-\n-  absl::Status ReportError(const absl::Status& status) {\n-    return coord_agent_->ReportError(status);\n-  }\n-\n-  absl::Status GetStatus() const { return status_; }\n-\n- private:\n-  std::unique_ptr<::grpc::Server> grpc_server_;\n-  std::unique_ptr<tsl::thread::ThreadPool> coord_compute_pool_;\n-  std::unique_ptr<tsl::AsyncServiceInterface> coord_rpc_service_;\n-  std::unique_ptr<tsl::Thread> coord_rpc_thread_;\n-  std::unique_ptr<CoordinationServiceAgent> coord_agent_ =\n-      CreateCoordinationServiceAgent();\n-  std::unique_ptr<CoordinationClient> coord_client_;\n-  absl::Status status_;\n-};\n-\n-class CoordinationServiceRecoverableJobTest : public ::testing::Test {\n- public:\n-  void SetUp() override {\n-    state_ps_0_.StartGrpcServer();\n-    state_ps_1_.StartGrpcServer();\n-    state_worker_0_.StartGrpcServer();\n-    state_worker_1_.StartGrpcServer();\n-  }\n-\n-  void TearDown() override {\n-    state_ps_0_.Shutdown();\n-    state_ps_1_.Shutdown();\n-    state_worker_0_.Shutdown();\n-    state_worker_1_.Shutdown();\n-    coord_service_.reset();\n-  }\n-\n-  void Initialize() {\n-    ConfigureCoordinationService();\n-    auto client_cache = std::make_unique<TestCoordinationClientCache>();\n-    client_cache->AddTask(\n-        /*target=*/kServiceLeader, state_ps_0_.GetCoordinationClient());\n-    client_cache->AddTask(\n-        /*target=*/\"/job:parameter_server/replica:0/task:1\",\n-        state_ps_1_.GetCoordinationClient());\n-    client_cache->AddTask(\n-        /*target=*/\"/job:worker/replica:0/task:0\",\n-        state_worker_0_.GetCoordinationClient());\n-    client_cache->AddTask(\n-        /*target=*/\"/job:worker/replica:0/task:1\",\n-        state_worker_1_.GetCoordinationClient());\n-    coord_service_ = CoordinationService::Create(\n-        tsl::Env::Default(), coordination_config_, std::move(client_cache));\n-    // Set the service pointer for all the tasks since it is needed for handling\n-    // error propagations. In reality, every task has its own service pointer.\n-    // To mimic that, we need multi-process tests.\n-    state_ps_0_.SetCoordinationService(coord_service_.get());\n-    state_ps_1_.SetCoordinationService(coord_service_.get());\n-    state_worker_0_.SetCoordinationService(coord_service_.get());\n-    state_worker_1_.SetCoordinationService(coord_service_.get());\n-    state_ps_0_.InitializeAndConnectCoordinationAgents(kParameterServerJobName,\n-                                                       /*task_id=*/0,\n-                                                       coordination_config_);\n-    state_ps_1_.InitializeAndConnectCoordinationAgents(kParameterServerJobName,\n-                                                       /*task_id=*/1,\n-                                                       coordination_config_);\n-    state_worker_0_.InitializeAndConnectCoordinationAgents(\n-        kWorkerJobName,\n-        /*task_id=*/0, coordination_config_);\n-    state_worker_1_.InitializeAndConnectCoordinationAgents(\n-        kWorkerJobName,\n-        /*task_id=*/1, coordination_config_);\n-  }\n-\n-  void ConfigureCoordinationService() {\n-    // Assume the coordination service is deployed in the parameter server.\n-    coordination_config_.set_service_type(kCoordinationServiceType);\n-    coordination_config_.set_service_leader(kServiceLeader);\n-    CoordinatedJob* ps =\n-        coordination_config_.mutable_coordinated_job_list()->Add();\n-    ps->set_name(kParameterServerJobName);\n-    ps->set_num_tasks(2);\n-    CoordinatedJob* worker =\n-        coordination_config_.mutable_coordinated_job_list()->Add();\n-    worker->set_name(kWorkerJobName);\n-    worker->set_num_tasks(2);\n-  }\n-\n-  void AddJobToRecoverableJobs(const std::string& job_name) {\n-    coordination_config_.add_recoverable_jobs(job_name);\n-  }\n-\n- protected:\n-  CoordinationServiceConfig coordination_config_;\n-  std::unique_ptr<CoordinationService> coord_service_;\n-  TestCoordinationServiceTaskState state_ps_0_;\n-  TestCoordinationServiceTaskState state_ps_1_;\n-  TestCoordinationServiceTaskState state_worker_0_;\n-  TestCoordinationServiceTaskState state_worker_1_;\n-};\n-\n-TEST_F(CoordinationServiceRecoverableJobTest,\n-       UnrecoverableWorkerFailurePropagated) {\n-  Initialize();\n-  TF_ASSERT_OK(state_worker_0_.ReportError(absl::InternalError(\"Test Error.\")));\n-\n-  // For unrecoverable task, error propagates to all connected tasks.\n-  EXPECT_TRUE(absl::IsInternal(state_ps_0_.GetStatus()));\n-  EXPECT_TRUE(absl::IsInternal(state_ps_1_.GetStatus()));\n-  EXPECT_TRUE(absl::IsInternal(state_worker_0_.GetStatus()));\n-  EXPECT_TRUE(absl::IsInternal(state_worker_1_.GetStatus()));\n-}\n-\n-TEST_F(CoordinationServiceRecoverableJobTest,\n-       UnrecoverablePSFailurePropagated) {\n-  Initialize();\n-  TF_ASSERT_OK(state_ps_0_.ReportError(absl::InternalError(\"Test Error.\")));\n-\n-  // For unrecoverable task, error propagates to all connected tasks.\n-  EXPECT_TRUE(absl::IsInternal(state_ps_0_.GetStatus()));\n-  EXPECT_TRUE(absl::IsInternal(state_ps_1_.GetStatus()));\n-  EXPECT_TRUE(absl::IsInternal(state_worker_0_.GetStatus()));\n-  EXPECT_TRUE(absl::IsInternal(state_worker_1_.GetStatus()));\n-}\n-\n-TEST_F(CoordinationServiceRecoverableJobTest,\n-       RecoverableWorkerFailureNotPropagated) {\n-  AddJobToRecoverableJobs(kWorkerJobName);\n-  Initialize();\n-  TF_ASSERT_OK(state_worker_0_.ReportError(absl::InternalError(\"Test Error.\")));\n-\n-  // For recoverable task, error does not propagate.\n-  EXPECT_TRUE(state_ps_0_.GetStatus().ok());\n-  EXPECT_TRUE(state_ps_1_.GetStatus().ok());\n-  EXPECT_TRUE(absl::IsInternal(state_worker_0_.GetStatus()));\n-  EXPECT_TRUE(state_worker_1_.GetStatus().ok());\n-}\n-\n-}  // namespace\n-}  // namespace xla"
        },
        {
            "sha": "b201c1100da1c52dafed1f2adcb544be551739d8",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_test.cc",
            "status": "modified",
            "additions": 79,
            "deletions": 177,
            "changes": 256,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_test.cc?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -19,7 +19,6 @@ limitations under the License.\n #include <memory>\n #include <optional>\n #include <string>\n-#include <unordered_map>\n #include <utility>\n #include <vector>\n \n@@ -43,7 +42,6 @@ limitations under the License.\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/platform/test.h\"\n-#include \"xla/tsl/platform/types.h\"\n #include \"xla/tsl/protobuf/coordination_config.pb.h\"\n #include \"xla/tsl/protobuf/coordination_service.pb.h\"\n #include \"xla/tsl/util/proto/proto_matchers.h\"\n@@ -68,7 +66,6 @@ using tensorflow::CoordinationServiceConfig;\n using tensorflow::DeviceInfo;\n using tensorflow::KeyValueEntry;\n using xla::TestDevice;\n-using xla::TestDeviceList;\n \n constexpr absl::Duration kHeartbeatTimeout = absl::Seconds(2);\n constexpr absl::Duration kShutdownBarrierTimeout = absl::Milliseconds(500);\n@@ -156,50 +153,25 @@ class TestCoordinationClient : public CoordinationClient {\n   absl::Status status_ ABSL_GUARDED_BY(mu_);\n };\n \n-class TestCoordinationClientCache : public CoordinationClientCache {\n- public:\n-  void AddTask(const std::string& target, CoordinationClient* client) {\n-    clients_.emplace(target, client);\n-  }\n-\n-  CoordinationClient* GetClient(const std::string& target) override {\n-    auto it = clients_.find(target);\n-    if (it == clients_.end()) return nullptr;\n-    return it->second;\n-  }\n-\n-  std::unique_ptr<CoordinationClient> GetOwnedClient(\n-      const std::string& target) override {\n-    LOG(ERROR) << \"GetOwnedClient is not supported.\";\n-    return nullptr;\n-  }\n-\n- private:\n-  std::unordered_map<std::string, CoordinationClient*> clients_;\n-};\n-\n class CoordinationBarrierTest : public ::testing::Test {\n  protected:\n-  CoordinationBarrierTest() {\n+  explicit CoordinationBarrierTest(bool recoverable = false) {\n     // Set up fake cluster with 3 tasks.\n     const int num_tasks = 3;\n-    auto client_cache = std::make_unique<TestCoordinationClientCache>();\n     for (int i = 0; i < num_tasks; ++i) {\n       CoordinatedTask task;\n       task.set_job_name(\"worker\");\n       task.set_task_id(i);\n+      task.set_recoverable(recoverable);\n \n       auto client = std::make_unique<TestCoordinationClient>();\n-      client_cache->AddTask(absl::StrCat(\"/job:worker/replica:0/task:\", i),\n-                            client.get());\n-\n       tasks_.push_back(task);\n       clients_.push_back(std::move(client));\n     }\n     CoordinationServiceConfig config = GetCoordinationServiceConfig(num_tasks);\n \n-    coord_service_ = CoordinationService::Create(tsl::Env::Default(), config,\n-                                                 std::move(client_cache));\n+    coord_service_ =\n+        std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n     // Register the tasks.\n     for (int i = 0; i < num_tasks; ++i) {\n       absl::Status s =\n@@ -256,20 +228,12 @@ class CoordinateTwoTasksTest : public ::testing::Test {\n \n   // Set up coordination service.\n   void EnableCoordinationService(\n-      bool has_service_to_client_connection = true,\n       bool enable_shutdown_barrier = false,\n       bool enable_register_barrier = false,\n       bool set_worker_job_recoverable = false,\n       bool allow_new_incarnation_to_reconnect = false) {\n     CoordinationServiceConfig config =\n         GetCoordinationServiceConfig(/*num_tasks=*/2);\n-    auto client_cache = std::make_unique<TestCoordinationClientCache>();\n-    if (has_service_to_client_connection) {\n-      client_cache->AddTask(\"/job:worker/replica:0/task:0\", &client_0_);\n-      client_cache->AddTask(\"/job:worker/replica:0/task:1\", &client_1_);\n-    } else {\n-      client_cache = nullptr;\n-    }\n     config.set_heartbeat_timeout_in_ms(kHeartbeatTimeout /\n                                        absl::Milliseconds(1));\n     if (set_worker_job_recoverable) {\n@@ -288,8 +252,8 @@ class CoordinateTwoTasksTest : public ::testing::Test {\n       config.set_allow_new_incarnation_to_reconnect(true);\n     }\n     // Init service.\n-    coord_service_ = CoordinationService::Create(tsl::Env::Default(), config,\n-                                                 std::move(client_cache));\n+    coord_service_ =\n+        std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   }\n \n   CoordinatedTask task_0_;\n@@ -342,8 +306,6 @@ TEST_F(CoordinateTwoTasksTest, TestStandaloneService) {\n               StatusIs(absl::StatusCode::kAborted));\n   EXPECT_THAT(coord_service_->RecordHeartbeat(task_1_, IncarnationId(0)),\n               StatusIs(absl::StatusCode::kAborted));\n-  // Error is propagated to other tasks.\n-  EXPECT_THAT(client_0_.GetStatus(), StatusIs(absl::StatusCode::kAborted));\n }\n \n TEST(CoordinationServiceTest, TestCoordinatedJobs) {\n@@ -369,18 +331,8 @@ TEST(CoordinationServiceTest, TestCoordinatedJobs) {\n   worker_job->set_name(\"worker\");\n   worker_job->set_num_tasks(2);\n \n-  auto client_cache = std::make_unique<TestCoordinationClientCache>();\n-  TestCoordinationClient ci;\n-  client_cache->AddTask(\"/job:chief/replica:0/task:0\", &ci);\n-  TestCoordinationClient wi0;\n-  client_cache->AddTask(\"/job:worker/replica:0/task:0\", &wi0);\n-  TestCoordinationClient wi1;\n-  client_cache->AddTask(\"/job:worker/replica:0/task:1\", &wi1);\n-  TestCoordinationClient ei;\n-  client_cache->AddTask(\"/job:evaluator/replica:0/task:0\", &ei);\n-  std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  std::move(client_cache));\n+  auto coord_service =\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n \n   // Each coordinated task registers and waits for other tasks.\n   absl::Notification register_chief;\n@@ -423,8 +375,7 @@ TEST(CoordinationServiceTest, RegisterTask_AlreadyConnected_Succeeds) {\n   task_0.set_job_name(\"worker\");\n   task_0.set_task_id(0);\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  /*cache=*/nullptr);\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   // Task connects to coordination service.\n   ASSERT_OK(coord_service->RegisterTask(task_0, IncarnationId(0)));\n \n@@ -443,8 +394,7 @@ TEST(CoordinationServiceTest,\n   task_0.set_job_name(\"worker\");\n   task_0.set_task_id(0);\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  /*cache=*/nullptr);\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   // Task connects to coordination service.\n   ASSERT_OK(coord_service->RegisterTask(task_0, IncarnationId(0)));\n \n@@ -464,8 +414,7 @@ TEST(CoordinationServiceTest, RegisterTask_AlreadyInError_Fails) {\n   task_0.set_job_name(\"worker\");\n   task_0.set_task_id(0);\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  /*cache=*/nullptr);\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   // Task connects to coordination service.\n   ASSERT_OK(coord_service->RegisterTask(task_0, IncarnationId(0)));\n   // Arbitrarily set task to be in error.\n@@ -495,7 +444,7 @@ TEST_F(CoordinateTwoTasksTest, TestTaskHeartbeatTimeout) {\n \n TEST_F(CoordinateTwoTasksTest,\n        ErrorPollingRequestsGotCancelledErrorUponServiceShutdown) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   std::vector<absl::Status> statuses;\n@@ -518,7 +467,7 @@ TEST_F(CoordinateTwoTasksTest,\n \n TEST_F(CoordinateTwoTasksTest,\n        HeartbeatTimeoutWithoutServerToClientConnection) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n \n@@ -534,7 +483,7 @@ TEST_F(CoordinateTwoTasksTest,\n \n TEST_F(CoordinateTwoTasksTest,\n        HeartbeatTimeoutErrorCanPropagateThroughErrorPolling) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   // Use notifications to guarantee the ordering of operations across threads.\n@@ -565,7 +514,7 @@ TEST_F(CoordinateTwoTasksTest,\n \n TEST_F(CoordinateTwoTasksTest,\n        HeartbeatTimeoutErrorFromOneTaskCanPropagateThroughErrorPolling) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   // Use notifications to guarantee the ordering of operations across threads.\n@@ -603,7 +552,7 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, ReportedErrorCanPropagateThroughErrorPolling) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   std::vector<absl::Status> statuses;\n@@ -630,8 +579,6 @@ TEST_F(CoordinateTwoTasksTest, TestTaskRestart) {\n       task_1_, IncarnationId(tsl::random::New64()));\n \n   EXPECT_THAT(s, StatusIs(absl::StatusCode::kAborted));\n-  // Aborted error is also propagated to other tasks in cluster.\n-  EXPECT_THAT(client_0_.GetStatus(), StatusIs(absl::StatusCode::kAborted));\n }\n \n tensorflow::CoordinatedTaskStateInfo info(\n@@ -909,10 +856,8 @@ TEST_F(CoordinateTwoTasksTest, TestSetGetValues) {\n TEST(CoordinationServiceTest, TryGetKeyValue) {\n   const CoordinationServiceConfig config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n-  auto client_cache = std::make_unique<TestCoordinationClientCache>();\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  std::move(client_cache));\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n \n   // Try to get nonexistent key.\n   absl::StatusOr<std::string> result =\n@@ -933,10 +878,8 @@ TEST(CoordinationServiceTest, TryGetKeyValue) {\n TEST(CoordinationServiceTest, IncrementKeyValue) {\n   const CoordinationServiceConfig config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n-  auto client_cache = std::make_unique<TestCoordinationClientCache>();\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  std::move(client_cache));\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   ASSERT_OK(coord_service->InsertKeyValue(\"test_key\", \"1\"));\n   ASSERT_OK(coord_service->IncrementKeyValue(\"test_key\", 3));\n   ASSERT_OK_AND_ASSIGN(std::string result_0,\n@@ -1044,10 +987,8 @@ TEST(CoordinationServiceTest, ListClusterDevices_TfDevice) {\n   task_2.set_job_name(\"worker\");\n   task_2.set_task_id(2);\n   absl::Status status = absl::OkStatus();\n-  auto client_cache = std::make_unique<TestCoordinationClientCache>();\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  std::move(client_cache));\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   absl::Notification n;\n   // Map fake devices to each task.\n   DeviceInfo local_devices_0;\n@@ -1101,10 +1042,8 @@ TEST(CoordinationServiceTest, ListClusterDevices_DevicesAreNotAddedTwice) {\n   task_1.set_task_id(1);\n   absl::Status status = absl::OkStatus();\n   absl::Status initial_wait_for_all_tasks_status;\n-  auto client_cache = std::make_unique<TestCoordinationClientCache>();\n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  std::move(client_cache));\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   absl::Notification n;\n   // Map fake devices to each task.\n   DeviceInfo local_devices_0;\n@@ -1866,8 +1805,8 @@ TEST_F(CoordinateTwoTasksTest, Reset_HeartbeatsAreAcceptedForAGracePeriod) {\n }\n \n TEST_F(CoordinateTwoTasksTest, Reset_FailsOngoingBarrier) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false);\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   absl::Status barrier_status;\n   absl::Notification barrier_n;\n@@ -1887,8 +1826,8 @@ TEST_F(CoordinateTwoTasksTest, Reset_FailsOngoingBarrier) {\n }\n \n TEST_F(CoordinateTwoTasksTest, Shutdown_HeartbeatsAreAcceptedForAGracePeriod) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false);\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n \n   absl::Notification n;\n@@ -1910,8 +1849,8 @@ TEST_F(CoordinateTwoTasksTest, Shutdown_HeartbeatsAreAcceptedForAGracePeriod) {\n }\n \n TEST_F(CoordinateTwoTasksTest, Shutdown_FailsOngoingBarrier) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false);\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   absl::Status barrier_status;\n   absl::Notification barrier_n;\n@@ -1936,8 +1875,8 @@ TEST_F(CoordinateTwoTasksTest, Shutdown_FailsOngoingBarrier) {\n }\n \n TEST_F(CoordinateTwoTasksTest, ShutdownWithBarrier_BarrierSucceeds) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/true);\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Status barrier_status;\n@@ -1960,8 +1899,8 @@ TEST_F(CoordinateTwoTasksTest, ShutdownWithBarrier_BarrierSucceeds) {\n \n TEST_F(CoordinateTwoTasksTest,\n        ShutdownWithBarrier_BarrierFails_TaskDisconnectsOtherTaskIsAlerted) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/true);\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Status barrier_status;\n@@ -1984,16 +1923,12 @@ TEST_F(CoordinateTwoTasksTest,\n               StatusIs(absl::StatusCode::kAborted));\n   EXPECT_THAT(coord_service_->RegisterTask(task_0_, incarnation_1_),\n               StatusIs(absl::StatusCode::kAborted));\n-\n-  // Other task is alerted that shutdown has been initiated without it.\n-  absl::Status other_task_status = client_1_.GetStatus();\n-  EXPECT_THAT(other_task_status, StatusIs(absl::StatusCode::kInternal));\n }\n \n TEST_F(CoordinateTwoTasksTest,\n        ShutdownWithBarrier_BarrierFailsWithoutClientConnection_SetTaskToError) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false,\n-                            /*enable_shutdown_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/true);\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Status barrier_status;\n@@ -2020,7 +1955,7 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, BarrierFailsIfTaskIsInError) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Notification n0;\n@@ -2043,7 +1978,7 @@ TEST_F(CoordinateTwoTasksTest, BarrierFailsIfTaskIsInError) {\n \n TEST_F(CoordinateTwoTasksTest,\n        BarrierWithParticipatingTasksFailsIfTaskIsStale) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Notification n0;\n@@ -2064,7 +1999,7 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, BarrierFailsAfterErrorPollingResponse) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   // Use notifications to guarantee the ordering of operations across threads.\n@@ -2107,7 +2042,7 @@ TEST_F(CoordinateTwoTasksTest, BarrierFailsAfterErrorPollingResponse) {\n }\n \n TEST_F(CoordinateTwoTasksTest, BarrierWithSubsetFailsIfTaskIsStale) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Notification n0;\n@@ -2130,27 +2065,11 @@ TEST_F(CoordinateTwoTasksTest, BarrierWithSubsetFailsIfTaskIsStale) {\n   EXPECT_THAT(barrier_status, StatusIs(absl::StatusCode::kInternal));\n }\n \n-TEST_F(CoordinateTwoTasksTest, UnrecoverableTaskPropagatesError) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/false,\n-                            /*set_worker_job_recoverable=*/false);\n-\n-  TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n-  TF_EXPECT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n-\n-  ASSERT_OK(coord_service_->ReportTaskError(task_0_,\n-                                            absl::InternalError(\"test_error\")));\n-\n-  // For unrecoverable task, error propagates to all connected tasks.\n-  EXPECT_THAT(client_1_.GetStatus(), StatusIs(absl::StatusCode::kInternal));\n-}\n-\n TEST_F(CoordinateTwoTasksTest, RecoverableTaskWillNotPropagateError) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/false,\n-                            /*set_worker_job_recoverable=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/false,\n+      /*set_worker_job_recoverable=*/true);\n \n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n@@ -2165,10 +2084,10 @@ TEST_F(CoordinateTwoTasksTest, RecoverableTaskWillNotPropagateError) {\n \n TEST_F(CoordinateTwoTasksTest,\n        RecoverableTaskWithErrorPollingWillNotPropagateError) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/false,\n-                            /*set_worker_job_recoverable=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/false,\n+      /*set_worker_job_recoverable=*/true);\n   // These callbacks may be invoked after this test (e.g. cancellations during\n   // coord service dtor), so we use shared pointers to extend their lifetimes\n   // beyond the test to avoid use-after-free errors.\n@@ -2212,8 +2131,7 @@ TEST(CoordinationServiceTest, RecoverableAndNonRecoverableTasks) {\n   worker_job->set_num_tasks(2);\n \n   std::unique_ptr<CoordinationService> coord_service =\n-      CoordinationService::Create(tsl::Env::Default(), config,\n-                                  /*cache=*/nullptr);\n+      std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n \n   // Each coordinated task registers and polls for errors.\n   ASSERT_OK(coord_service->RegisterTask(chief, IncarnationId(0)));\n@@ -2257,10 +2175,10 @@ TEST(CoordinationServiceTest, RecoverableAndNonRecoverableTasks) {\n \n TEST_F(CoordinateTwoTasksTest,\n        RecoverableTaskReportErrorResetAndRegisterAgain) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/false,\n-                            /*set_worker_job_recoverable=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/false,\n+      /*set_worker_job_recoverable=*/true);\n \n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n@@ -2282,11 +2200,11 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, UnavailableTaskCanReconnect) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/false,\n-                            /*set_worker_job_recoverable=*/false,\n-                            /*allow_new_incarnation_to_reconnect=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/false,\n+      /*set_worker_job_recoverable=*/false,\n+      /*allow_new_incarnation_to_reconnect=*/true);\n \n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n \n@@ -2296,27 +2214,8 @@ TEST_F(CoordinateTwoTasksTest, UnavailableTaskCanReconnect) {\n   TF_EXPECT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_new_));\n }\n \n-TEST_F(CoordinateTwoTasksTest,\n-       DoNotAllowPollForErrorIfHasServiceToClientConnection) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/true);\n-  ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n-  ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n-  std::vector<absl::Status> statuses;\n-  statuses.reserve(2);\n-\n-  for (const CoordinatedTask& task : {task_0_, task_1_}) {\n-    coord_service_->PollForErrorAsync(\n-        task, [&](const absl::Status& status) { statuses.push_back(status); });\n-  }\n-\n-  // The error polling requests will get immediate error because there is\n-  // service to client connection.\n-  EXPECT_EQ(statuses.size(), 2);\n-  EXPECT_THAT(statuses, Each(StatusIs(absl::StatusCode::kInternal)));\n-}\n-\n TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfNotInCluster) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   CoordinatedTask task_not_in_cluster;\n   absl::Status s;\n \n@@ -2328,7 +2227,7 @@ TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfNotInCluster) {\n }\n \n TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfTaskNotRegistered) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   absl::Status s;\n \n   coord_service_->PollForErrorAsync(\n@@ -2340,7 +2239,7 @@ TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfTaskNotRegistered) {\n \n TEST_F(CoordinateTwoTasksTest,\n        AllowPollForErrorWithinGracePeriodIfTaskHasShutDown) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   absl::Status s;\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n@@ -2359,7 +2258,7 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfTaskHasShutDown) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   absl::Status s;\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n@@ -2378,7 +2277,7 @@ TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfTaskHasShutDown) {\n }\n \n TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorAfterReset) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   absl::Status s;\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->ResetTask(task_0_));\n@@ -2393,7 +2292,7 @@ TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorAfterReset) {\n }\n \n TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorWhenInErrorState) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   absl::Status s;\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->ReportTaskError(task_0_,\n@@ -2405,7 +2304,7 @@ TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorWhenInErrorState) {\n }\n \n TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfTaskIsStale) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   // No heartbeat for a while, leader consider the task as stale.\n@@ -2422,7 +2321,7 @@ TEST_F(CoordinateTwoTasksTest, DoNotAllowPollForErrorIfTaskIsStale) {\n \n TEST_F(CoordinateTwoTasksTest,\n        CanPropagateTaskRegistrationErrorThroughErrorPolling) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   absl::Status s0;\n@@ -2440,7 +2339,7 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, LatePollingTaskCanGetError) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false);\n+  EnableCoordinationService();\n   ASSERT_OK(coord_service_->RegisterTask(task_0_, incarnation_0_));\n   ASSERT_OK(coord_service_->RegisterTask(task_1_, incarnation_1_));\n   std::vector<absl::Status> statuses;\n@@ -2465,9 +2364,9 @@ TEST_F(CoordinateTwoTasksTest, LatePollingTaskCanGetError) {\n \n TEST_F(CoordinateTwoTasksTest,\n        RegisterWithBarrier_OldHeartbeat_RestartedTasksCanReconnect) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/true);\n   // Service restarted.\n   // Old task 0 sends an unexpected heartbeat, which should fail.\n   ASSERT_THAT(coord_service_->RecordHeartbeat(task_0_, incarnation_0_ - 1),\n@@ -2488,9 +2387,9 @@ TEST_F(CoordinateTwoTasksTest,\n \n TEST_F(CoordinateTwoTasksTest,\n        RegisterWithBarrier_RestartBeforeBarrier_Succeeds) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/true);\n   absl::Status task0_status = absl::InternalError(\"uninitialized_status\");\n   absl::Status restarted_task0_status =\n       absl::InternalError(\"uninitialized_status\");\n@@ -2514,9 +2413,9 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST_F(CoordinateTwoTasksTest, RegisterWithBarrier_RestartAfterBarrier_Fails) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/true);\n   absl::Status task0_status = absl::InternalError(\"uninitialized_status\");\n   // Task 0 registers first.\n   coord_service_->RegisterTaskAsync(\n@@ -2544,16 +2443,19 @@ TEST_F(CoordinateTwoTasksTest, RegisterWithBarrier_RestartAfterBarrier_Fails) {\n }\n \n TEST_F(CoordinateTwoTasksTest, RegisterWithBarrier_Timeout) {\n-  EnableCoordinationService(/*has_service_to_client_connection=*/false,\n-                            /*enable_shutdown_barrier=*/false,\n-                            /*enable_register_barrier=*/true);\n+  EnableCoordinationService(\n+      /*enable_shutdown_barrier=*/false,\n+      /*enable_register_barrier=*/true);\n   // Task 0 joins without task 1. Times out eventually as this function is\n   // blocking.\n   EXPECT_THAT(coord_service_->RegisterTask(task_0_, incarnation_0_),\n               StatusIs(absl::StatusCode::kDeadlineExceeded));\n }\n \n-using GetAliveTasksTest = CoordinationBarrierTest;\n+class GetAliveTasksTest : public CoordinationBarrierTest {\n+ public:\n+  GetAliveTasksTest() : CoordinationBarrierTest(true) {}\n+};\n \n TEST_F(GetAliveTasksTest, SuccessfulGetAliveTasks) {\n   // This test has three tasks successfully call GetAliveTasks."
        },
        {
            "sha": "ee5f5ebafc27cc9ef6a1ea3df2051338edbf60b3",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/grpc_coordination_client.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fgrpc_coordination_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fgrpc_coordination_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fgrpc_coordination_client.cc?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -329,77 +329,8 @@ class GrpcCoordinationClient : public CoordinationClient {\n   std::unique_ptr<GrpcCoordinationClientThread> client_thread_;\n };\n \n-class GrpcCoordinationClientCache : public CoordinationClientCache {\n- public:\n-  explicit GrpcCoordinationClientCache(\n-      std::shared_ptr<tsl::GrpcChannelCache> channel_cache)\n-      : next_round_robin_assignment_(0),\n-        channel_cache_(channel_cache),\n-        threads_(4) {}\n-\n-  ~GrpcCoordinationClientCache() override = default;\n-\n-  CoordinationClient* GetClient(const std::string& target) override {\n-    absl::MutexLock l(clients_mu_);\n-    auto it = clients_.find(target);\n-    if (it == clients_.end()) {\n-      tsl::SharedGrpcChannelPtr channel =\n-          channel_cache_->FindWorkerChannel(target);\n-      if (channel == nullptr) {\n-        VLOG(2) << \"Coordination client for target \" << target << \" not found.\";\n-      }\n-      int assigned_index = AssignClientToThread(target);\n-      auto coord_client = std::make_unique<GrpcCoordinationClient>(\n-          channel, threads_[assigned_index].completion_queue(), target);\n-      it = clients_.emplace(target, std::move(coord_client)).first;\n-    }\n-    return it->second.get();\n-  }\n-\n-  std::unique_ptr<CoordinationClient> GetOwnedClient(\n-      const std::string& target) override {\n-    tsl::SharedGrpcChannelPtr channel =\n-        channel_cache_->FindWorkerChannel(target);\n-    if (channel == nullptr) {\n-      VLOG(2) << \"Coordination client for target \" << target << \" not found.\";\n-    }\n-    return std::make_unique<GrpcCoordinationClient>(channel, target);\n-  }\n-\n- private:\n-  absl::Mutex assignment_mu_;\n-  std::unordered_map<std::string, size_t> target_assignments_\n-      ABSL_GUARDED_BY(assignment_mu_);\n-  size_t next_round_robin_assignment_ ABSL_GUARDED_BY(assignment_mu_);\n-\n-  size_t AssignClientToThread(const std::string& target) {\n-    // Round-robin target assignment, but keeps the same target on the same\n-    // polling thread always, as this is important for gRPC performance\n-    absl::MutexLock l(assignment_mu_);\n-    auto it = target_assignments_.find(target);\n-    if (it == target_assignments_.end()) {\n-      it = target_assignments_\n-               .insert(std::make_pair(\n-                   target, (next_round_robin_assignment_++) % threads_.size()))\n-               .first;\n-    }\n-    return it->second;\n-  }\n-\n-  std::shared_ptr<tsl::GrpcChannelCache> channel_cache_;\n-  mutable absl::Mutex clients_mu_;\n-  std::unordered_map<std::string, std::unique_ptr<CoordinationClient>> clients_\n-      ABSL_GUARDED_BY(clients_mu_);\n-  std::vector<GrpcCoordinationClientThread> threads_;\n-};\n-\n }  // namespace\n \n-CoordinationClientCache* NewGrpcCoordinationClientCache(\n-    std::shared_ptr<tsl::GrpcChannelCache> channel_cache) {\n-  return new GrpcCoordinationClientCache(channel_cache);\n-}\n-\n CoordinationClient* NewGrpcCoordinationClient(\n     std::shared_ptr<::grpc::Channel> channel) {\n   return new GrpcCoordinationClient(channel, /*target=*/\"coordination_service\");"
        },
        {
            "sha": "a1c41ec4484e4e5c0f2fd9e202dfb4e22b8b33ba",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/grpc_coordination_client.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fgrpc_coordination_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fgrpc_coordination_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fgrpc_coordination_client.h?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -23,9 +23,6 @@ limitations under the License.\n \n namespace xla {\n \n-CoordinationClientCache* NewGrpcCoordinationClientCache(\n-    std::shared_ptr<tsl::GrpcChannelCache> channel);\n-\n CoordinationClient* NewGrpcCoordinationClient(\n     std::shared_ptr<::grpc::Channel> channel);\n "
        },
        {
            "sha": "c8edb09a60bcd0702c823f52fee2838b0fadc28f",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_sync_manager_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -149,8 +149,7 @@ class PreemptionSyncManagerTest : public ::testing::Test {\n     CoordinatedJob* job = config.mutable_coordinated_job_list()->Add();\n     job->set_name(kJobName);\n     job->set_num_tasks(2);\n-    return CoordinationService::Create(tsl::Env::Default(), config,\n-                                       /*cache=*/nullptr);\n+    return std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   }\n   void InitializeAndConnectCoordinationAgents() {\n     std::unique_ptr<CoordinationClient> coord_client ="
        },
        {
            "sha": "c5688fc14e8e37f66e16cd5ba83d5df462e68f9e",
            "filename": "third_party/xla/xla/pjrt/distributed/service.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fservice.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b650c8ec468c0a73e515e8bd334696d815ef1f36/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fservice.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fservice.cc?ref=b650c8ec468c0a73e515e8bd334696d815ef1f36",
            "patch": "@@ -52,7 +52,7 @@ std::unique_ptr<xla::CoordinationService> EnableCoordinationService(\n   job->set_name(job_name);\n   job->set_num_tasks(options.num_nodes);\n   auto service =\n-      xla::CoordinationService::Create(options.env, config, /*cache=*/nullptr);\n+      std::make_unique<xla::CoordinationService>(options.env, config);\n   return service;\n }\n }  // namespace"
        }
    ],
    "stats": {
        "total": 731,
        "additions": 92,
        "deletions": 639
    }
}