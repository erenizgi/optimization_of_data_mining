{
    "author": "nputikhin",
    "message": "Handle PyCUtensorMapObject in extractTmaDesc in the launcher\n\nReenables failing tests\n\nPiperOrigin-RevId: 825983235",
    "sha": "344930362279785fa27271e1087ddd220ae4c5f8",
    "files": [
        {
            "sha": "57d4c2121e37ea0bd56e368a543c23346b627948",
            "filename": "third_party/xla/third_party/triton/temporary/launcher_tma_desc_fix.patch",
            "status": "added",
            "additions": 144,
            "deletions": 0,
            "changes": 144,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/344930362279785fa27271e1087ddd220ae4c5f8/third_party%2Fxla%2Fthird_party%2Ftriton%2Ftemporary%2Flauncher_tma_desc_fix.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/344930362279785fa27271e1087ddd220ae4c5f8/third_party%2Fxla%2Fthird_party%2Ftriton%2Ftemporary%2Flauncher_tma_desc_fix.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftriton%2Ftemporary%2Flauncher_tma_desc_fix.patch?ref=344930362279785fa27271e1087ddd220ae4c5f8",
            "patch": "@@ -0,0 +1,144 @@\n+diff --git a/third_party/nvidia/backend/cuda_utils.cc b/third_party/nvidia/backend/cuda_utils.cc\n+--- a/third_party/nvidia/backend/cuda_utils.cc\n++++ b/third_party/nvidia/backend/cuda_utils.cc\n+@@ -270,51 +270,16 @@ bool extractPointer(PyObject* obj, void*\n+   return true;\n+ }\n+ \n++CUtensorMap* getTmaDesc(PyObject* obj);\n++\n+ // Extract a CUtensorMap descriptor from a python object, and store it to the\n+ // memory location pointed by ptr.\n+ bool extractTmaDesc(PyObject* obj, void* ptr) {\n+-  if (sizeof(CUtensorMap*) != 8) {\n+-    PyErr_SetString(PyExc_SystemError,\n+-                \"extractTmaDesc() requires 64-bit compilation\");\n+-    return false;\n+-  }\n+-\n+-  UniquePyObjectPtr method_ret(\n+-      PyObject_CallMethod(obj, \"tma_desc_cpu_ptr\", nullptr));\n+-  // Checking the error retains context if tma_desc_cpu_ptr raises an exception.\n+-  if (PyErr_Occurred()) {\n+-    return false;\n+-  }\n+-\n+-  if (!method_ret) {\n+-    PyErr_SetString(PyExc_SystemError, \"Call to tma_desc_cpu_ptr() failed\");\n++  CUtensorMap* tensor_map = getTmaDesc(obj);\n++  if (tensor_map == nullptr) {\n+     return false;\n+   }\n+-\n+-  if (!PyLong_Check(method_ret.get())) {\n+-    PyErr_SetString(PyExc_TypeError,\n+-                    \"tma_desc_cpu_ptr() must return 64-bit int\");\n+-    return false;\n+-  }\n+-\n+-  uint64_t ptr_as_uint = PyLong_AsUnsignedLongLong(method_ret.get());\n+-  if (PyErr_Occurred()) {\n+-    return false;\n+-  }\n+-\n+-  if (!ptr_as_uint) {\n+-    PyErr_SetString(PyExc_ValueError,\n+-                    \"received NULL ptr from tma_desc_cpu_ptr()\");\n+-    return false;\n+-  }\n+-  if (ptr_as_uint % 64 != 0) {\n+-    PyErr_SetString(PyExc_ValueError,\n+-                    \"tma_desc_cpu_ptr() must be 64-byte aligned\");\n+-    return false;\n+-  }\n+-\n+-  *static_cast<CUtensorMap*>(ptr) =\n+-      *reinterpret_cast<CUtensorMap*>(ptr_as_uint);\n++  *static_cast<CUtensorMap*>(ptr) = *tensor_map;\n+   return true;\n+ }\n+ \n+@@ -392,6 +357,7 @@ struct ExtractionInfo {\n+   // Prefixes of types reprs supported by the extractor.\n+   llvm::SmallVector<llvm::StringRef> supported_type_repr_prefixes;\n+   std::size_t size;         // Size required by the extracted value.\n++  std::size_t alignment;    // Alignment requirement for the extracted value.\n+   ExtractorType extractor;  // Function to call to extract the value.\n+ \n+   // Builds an ExtractionInfo for a given type T and a list of type reprs that\n+@@ -400,7 +366,7 @@ struct ExtractionInfo {\n+   static ExtractionInfo build(\n+       std::initializer_list<llvm::StringRef> supported_type_reprs,\n+       ExtractorType extractor = extractValue<T>) {\n+-    return {supported_type_reprs, sizeof(T), extractor};\n++    return {supported_type_reprs, sizeof(T), alignof(T), extractor};\n+   }\n+ \n+   // Checks if the extractor supports extracting a given type repr.\n+@@ -428,7 +394,7 @@ const ExtractionInfo kExtractionInfos[]{\n+     // Note: types are e.g. '*fp32', so no closing quote is intentional.\n+     ExtractionInfo::build<void*>({\"'*\"}, extractPointer),\n+     ExtractionInfo{\n+-        {\"None\", \"'none'\"}, 0, nullptr},  // Represent constexprs as None\n++        {\"None\", \"'none'\"}, 0, 0, nullptr},  // Represent constexprs as None\n+     ExtractionInfo::build<CUtensorMap>({\"'nvTmaDesc'\"}, extractTmaDesc),\n+ };\n+ \n+@@ -628,7 +594,19 @@ PyObject* launch(PyObject* self, PyObjec\n+     if (extraction_info.size == 0) {\n+       continue;  // skip adding constexpr parameters\n+     }\n+-    config.params[params_idx] = alloca(extraction_info.size);\n++    size_t alignment = std::max(1UL, extraction_info.alignment);\n++\n++    // Allocate enough space on the stack to guarantee an aligned block.\n++    size_t size_with_alignment = extraction_info.size + alignment - 1;\n++    void *param_storage_ptr = alloca(size_with_alignment);\n++\n++    void *aligned_ptr = std::align(alignment, extraction_info.size,\n++                                   param_storage_ptr, size_with_alignment);\n++    if (aligned_ptr == nullptr) {\n++      PyErr_SetString(PyExc_MemoryError, \"Failed to align parameter storage\");\n++      return nullptr;\n++    }\n++    config.params[params_idx] = aligned_ptr;\n+     if (!extraction_info.extractor(arg, config.params[params_idx])) {\n+       return nullptr;\n+     }\n+@@ -940,6 +918,36 @@ static PyTypeObject PyCUtensorMapType = \n+ };\n+ // clang-format on\n+ \n++namespace {\n++\n++// Extracts a pointer to `CUtensorMap` from a `PyCUtensorMapObject`.\n++CUtensorMap* getTmaDesc(PyObject* obj) {\n++  if (sizeof(CUtensorMap*) != 8) {\n++    PyErr_SetString(PyExc_SystemError,\n++                    \"getTmaDesc() requires 64-bit compilation\");\n++    return nullptr;\n++  }\n++  if (Py_TYPE(obj) != static_cast<PyTypeObject*>(&PyCUtensorMapType)) {\n++    PyErr_Format(PyExc_TypeError,\n++                 \"object must be of type PyCUtensorMap, got %s\",\n++                 Py_TYPE(obj)->tp_name);\n++    return nullptr;\n++  }\n++  CUtensorMap* map = &((PyCUtensorMapObject*)obj)->tensorMap;\n++  // PyCUtensorMapObject aligns tensorMap to 128.\n++  uintptr_t align_128 = (uintptr_t)map & (128 - 1);\n++  if (align_128 != 0) {\n++    PyErr_Format(\n++        PyExc_ValueError,\n++        \"CUtensorMap must be aligned to 128B, but got (&map) mod 128 = %ld\",\n++        align_128);\n++    return nullptr;\n++  }\n++  return map;\n++}\n++\n++}  // namespace\n++\n+ static PyObject *fillTMADescriptor(PyObject *self, PyObject *args) {\n+   unsigned long long global_address;\n+   int swizzle;"
        },
        {
            "sha": "21596b83c7ae9819181d9b4dd8e7a41bb8531155",
            "filename": "third_party/xla/third_party/triton/temporary/series.bzl",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/344930362279785fa27271e1087ddd220ae4c5f8/third_party%2Fxla%2Fthird_party%2Ftriton%2Ftemporary%2Fseries.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/344930362279785fa27271e1087ddd220ae4c5f8/third_party%2Fxla%2Fthird_party%2Ftriton%2Ftemporary%2Fseries.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftriton%2Ftemporary%2Fseries.bzl?ref=344930362279785fa27271e1087ddd220ae4c5f8",
            "patch": "@@ -15,5 +15,6 @@ those to this list.\n \n temporary_patch_list = [\n     \"//third_party/triton:temporary/utility-fix.patch\",\n+    \"//third_party/triton:temporary/launcher_tma_desc_fix.patch\",\n     # Add new patches just above this line\n ]"
        }
    ],
    "stats": {
        "total": 145,
        "additions": 145,
        "deletions": 0
    }
}