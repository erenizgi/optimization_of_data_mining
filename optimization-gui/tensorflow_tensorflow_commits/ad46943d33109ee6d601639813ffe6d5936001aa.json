{
    "author": "DottsGit",
    "message": "- Graph Mode RuntimeError: Dataset iteration not supported -> fixed by using get_single_element()\n- Eager Mode AssertionError: [2,2,3] != [None,None,3] -> fixed with Flexible assertions\n- .as_list() method now follows the convention by always stemming from the .get_shape() method\n- Made comments more consistent with the standard",
    "sha": "ad46943d33109ee6d601639813ffe6d5936001aa",
    "files": [
        {
            "sha": "05722c66cc154cd7805bc205a89783e069f19323",
            "filename": "tensorflow/python/ops/image_ops_test.py",
            "status": "modified",
            "additions": 26,
            "deletions": 20,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ad46943d33109ee6d601639813ffe6d5936001aa/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ad46943d33109ee6d601639813ffe6d5936001aa/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py?ref=ad46943d33109ee6d601639813ffe6d5936001aa",
            "patch": "@@ -6625,68 +6625,74 @@ def testDecodeImageShapeInferenceInDataPipeline(self):\n     [None, None, None] for unknown channel counts, enabling proper shape\n     inference for subsequent operations like resize.\n     \"\"\"\n-    # Create test JPEG image data\n+    # Create 2x2 RGB test image.\n     test_image = constant_op.constant([[[255, 0, 0], [0, 255, 0]], \n                                        [[0, 0, 255], [255, 255, 0]]], \n                                       dtype=dtypes.uint8)\n     jpeg_bytes = gen_image_ops.encode_jpeg(test_image)\n \n     def process_image_fixed(image_bytes):\n-      \"\"\"Process function using the fix: expand_animations=False.\"\"\"\n+      \"\"\"Process function using expand_animations=False for shape inference.\"\"\"\n       decoded = image_ops.decode_image(image_bytes, channels=3, \n                                        expand_animations=False)\n-      # This should work without ValueError due to proper shape inference\n       resized = image_ops.resize_images(decoded, [224, 224])\n       return resized\n \n-\n-\n     with self.cached_session():\n-      # Test the fixed version in a data pipeline\n+      # Test tf.data pipeline with decode_image + resize.\n       dataset_fixed = dataset_ops.Dataset.from_tensor_slices([jpeg_bytes])\n       dataset_fixed = dataset_fixed.map(process_image_fixed)\n       \n-      # Verify we can iterate through the dataset without errors\n-      for processed_image in dataset_fixed:\n-        processed_image_val = self.evaluate(processed_image)\n-        self.assertEqual(processed_image_val.shape, (224, 224, 3))\n+      # Use get_single_element for graph mode compatibility.\n+      processed_image = get_single_element.get_single_element(dataset_fixed)\n+      processed_image_val = self.evaluate(processed_image)\n+      self.assertEqual(processed_image_val.shape, (224, 224, 3))\n \n-      # Test that decode_image with expand_animations=False sets proper shape\n+      # Verify shape inference with expand_animations=False.\n       decoded_fixed = image_ops.decode_image(jpeg_bytes, channels=3,\n                                              expand_animations=False)\n       self.assertEqual(decoded_fixed.shape.rank, 3)\n-      self.assertEqual(decoded_fixed.shape.as_list(), [None, None, 3])\n+      \n+      # Check shape compatibility in both graph and eager modes.\n+      shape_list = decoded_fixed.get_shape().as_list()\n+      self.assertEqual(shape_list[2], 3)\n+      self.assertTrue(shape_list[0] is None or shape_list[0] == 2)\n+      self.assertTrue(shape_list[1] is None or shape_list[1] == 2)\n \n-      # Test with different channel counts\n+      # Test different channel configurations.\n       for channels in [1, 3, 4]:\n         if channels == 1:\n-          # Create grayscale test image\n+          # Create grayscale test image.\n           gray_image = constant_op.constant([[128, 64], [192, 32]], \n                                            dtype=dtypes.uint8)\n           gray_image = array_ops.expand_dims(gray_image, -1)\n           test_bytes = gen_image_ops.encode_png(gray_image)\n         else:\n-          # Use the RGB image for 3 and 4 channel tests\n+          # Use RGB JPEG for multi-channel tests.\n           test_bytes = jpeg_bytes\n \n         decoded = image_ops.decode_image(test_bytes, channels=channels,\n                                          expand_animations=False)\n         self.assertEqual(decoded.shape.rank, 3)\n         \n-        if channels <= 3:  # JPEG/PNG support up to 3 channels typically\n+        if channels <= 3:\n           expected_shape = [None, None, channels]\n         else:\n-          # For unsupported channel counts, we still get proper rank\n           expected_shape = [None, None, None]\n         \n-        # The key fix: shape is properly inferred for resize operations\n+        # Shape must be compatible for resize operations.\n         self.assertTrue(decoded.shape.is_compatible_with(expected_shape))\n \n-      # Test that unknown channel count still sets proper rank\n+      # Test automatic channel detection.\n       decoded_unknown = image_ops.decode_image(jpeg_bytes, \n                                                expand_animations=False)\n       self.assertEqual(decoded_unknown.shape.rank, 3)\n-      self.assertEqual(decoded_unknown.shape.as_list(), [None, None, None])\n+      \n+      # Check shape compatibility with automatic channel detection.\n+      shape_list_unknown = decoded_unknown.get_shape().as_list()\n+      self.assertTrue(shape_list_unknown[0] is None or shape_list_unknown[0] == 2)\n+      self.assertTrue(shape_list_unknown[1] is None or shape_list_unknown[1] == 2)\n+      self.assertTrue(shape_list_unknown[2] is None or shape_list_unknown[2] == 3)\n \n \n if __name__ == \"__main__\":"
        }
    ],
    "stats": {
        "total": 46,
        "additions": 26,
        "deletions": 20
    }
}