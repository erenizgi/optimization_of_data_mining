{
    "author": "zvikinoza",
    "message": "[XLA] UnflattenCallGraph: Filter computations before hashing\n\nfilter out computations that have a unique instruction count or a unique parameter count. Such computations cannot be duplicates of other computations, so we can avoid hashing them.\n\nPiperOrigin-RevId: 836837109",
    "sha": "cc620f349f11af49654ff155aff4be7c7e56084a",
    "files": [
        {
            "sha": "9dc7b880462f7494a2a134188345d444f1c3d923",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/unflatten_call_graph.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 8,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc620f349f11af49654ff155aff4be7c7e56084a/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Funflatten_call_graph.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc620f349f11af49654ff155aff4be7c7e56084a/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Funflatten_call_graph.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Funflatten_call_graph.cc?ref=cc620f349f11af49654ff155aff4be7c7e56084a",
            "patch": "@@ -55,30 +55,40 @@ struct HloCalls {\n // Iterates through all instructions in the module's computations\n // and collects all `HloInstruction`s with opcode `kCall` into 'call_sites'\n // and all unique computations targeted by these calls into 'targets'.\n+// It only retains call sites and targets that could potentially be duplicates\n+// by filtering out computations with unique properties (instruction count,\n+// parameter count).\n HloCalls CollectHloCalls(\n     HloModule* module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n-  std::unique_ptr<CallGraph> call_graph = CallGraph::Build(module);\n+  std::unique_ptr<CallGraph> call_graph =\n+      CallGraph::Build(module, execution_threads);\n   HloCalls calls;\n-  absl::flat_hash_map<uint64_t, uint64_t> count_num_instructions;\n+  absl::flat_hash_map<uint64_t, uint64_t> count_num_instructions,\n+      count_num_params;\n+\n   for (const CallGraphNode& node : call_graph->nodes()) {\n     for (const CallSite& callsite : node.callsites()) {\n       if (callsite.instruction()->opcode() == HloOpcode::kCall) {\n         calls.call_sites.insert(callsite.instruction());\n-        calls.targets.insert(callsite.instruction()->to_apply());\n-        ++count_num_instructions\n-            [callsite.instruction()->to_apply()->instruction_count()];\n+        HloComputation* target = callsite.instruction()->to_apply();\n+        calls.targets.insert(target);\n+        ++count_num_instructions[target->instruction_count()];\n+        ++count_num_params[target->num_parameters()];\n       }\n     }\n   }\n-  // Remove computations for which there is no other computation with matching\n-  // number of instructions (i.e. it cannot have duplicate)\n+\n+  // Remove computations that cannot be duplicates: if a computation is unique\n+  // in terms of instruction count or parameter count it implies it cannot be\n+  // identical to any other computation.\n   for (auto it = calls.call_sites.begin(), end = calls.call_sites.end();\n        it != end;) {\n     // `erase()` will invalidate `it`, so advance `it` first.\n     auto copy_it = it++;\n     HloComputation* computation = (*copy_it)->to_apply();\n-    if (count_num_instructions[computation->instruction_count()] == 1) {\n+    if (count_num_instructions[computation->instruction_count()] == 1 ||\n+        count_num_params[computation->num_parameters()] == 1) {\n       calls.targets.erase(computation);\n       calls.call_sites.erase(copy_it);\n     }"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 18,
        "deletions": 8
    }
}