{
    "author": "hawkinsp",
    "message": "Migrate IFRT IR Python extensions to nanobind.\n\nPybindAdaptors.h was deleted in upstream LLVM; MLIR extensions must use nanobind.\n\nPiperOrigin-RevId: 816470228",
    "sha": "b9ed811458d8da4c891e2632b00a343a828a3182",
    "files": [
        {
            "sha": "1a7232feeacb9db1cbc075654695018a2172fc2c",
            "filename": "third_party/xla/xla/python/ifrt/ir/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD?ref=b9ed811458d8da4c891e2632b00a343a828a3182",
            "patch": "@@ -456,8 +456,7 @@ tsl_pybind_extension(\n         \"@llvm-project//mlir:CAPIIRHeaders\",\n         \"@llvm-project//mlir:IR\",\n         \"@llvm-project//mlir:MLIRBindingsPythonHeaders\",\n-        \"@pybind11\",\n-        \"@pybind11_abseil//pybind11_abseil:absl_casters\",\n+        \"@nanobind\",\n     ],\n )\n "
        },
        {
            "sha": "b12c16f31f5c2e37163383371762820bfffdb526",
            "filename": "third_party/xla/xla/python/ifrt/ir/conversions/mpmd/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fconversions%2Fmpmd%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fconversions%2Fmpmd%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fconversions%2Fmpmd%2FBUILD?ref=b9ed811458d8da4c891e2632b00a343a828a3182",
            "patch": "@@ -112,15 +112,12 @@ tsl_pybind_extension(\n     deps = [\n         \":lower_to_ifrt\",\n         \"//xla/pjrt:status_casters\",\n-        \"//xla/tsl/platform:statusor\",\n+        \"//xla/python:nb_absl_flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings:string_view\",\n         \"@llvm-project//mlir:CAPIIRHeaders\",\n         \"@llvm-project//mlir:IR\",\n         \"@llvm-project//mlir:MLIRBindingsPythonNanobindHeaders\",\n         \"@nanobind\",\n-        \"@pybind11\",\n-        \"@pybind11_abseil//pybind11_abseil:absl_casters\",\n     ],\n )"
        },
        {
            "sha": "24a0ec94f029a6e719935957783d5609f4ba17bc",
            "filename": "third_party/xla/xla/python/ifrt/ir/conversions/mpmd/ifrt_mpmd_py.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 14,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fconversions%2Fmpmd%2Fifrt_mpmd_py.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fconversions%2Fmpmd%2Fifrt_mpmd_py.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fconversions%2Fmpmd%2Fifrt_mpmd_py.cc?ref=b9ed811458d8da4c891e2632b00a343a828a3182",
            "patch": "@@ -18,42 +18,43 @@ limitations under the License.\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/status/statusor.h\"\n #include \"mlir-c/IR.h\"\n-#include \"mlir/Bindings/Python/PybindAdaptors.h\"  // IWYU pragma: keep; Needed to allow MlirModule -> ModuleOp.\n+#include \"mlir/Bindings/Python/NanobindAdaptors.h\"  // IWYU pragma: keep; Needed to allow MlirModule -> ModuleOp.\n #include \"mlir/CAPI/IR.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/OperationSupport.h\"\n #include \"nanobind/nanobind.h\"\n-#include \"pybind11/detail/common.h\"\n-#include \"pybind11/pybind11.h\"\n-#include \"pybind11/pytypes.h\"\n-#include \"pybind11_abseil/absl_casters.h\"\n+#include \"nanobind/stl/pair.h\"  // IWYU pragma: keep\n+#include \"nanobind/stl/string.h\"  // IWYU pragma: keep\n+#include \"nanobind/stl/variant.h\"  // IWYU pragma: keep\n+#include \"nanobind/stl/vector.h\"  // IWYU pragma: keep\n #include \"xla/pjrt/status_casters.h\"  // IWYU pragma: keep; Needed for ValueOrThrow\n #include \"xla/python/ifrt/ir/conversions/mpmd/lower_to_ifrt.h\"\n-#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/python/nb_absl_flat_hash_map.h\"  // IWYU pragma: keep\n+\n+namespace nb = nanobind;\n \n namespace xla::ifrt::mpmd {\n \n-PYBIND11_MODULE(ifrt_mpmd_py, m) {\n+NB_MODULE(ifrt_mpmd_py, m) {\n   m.def(\n       \"lower_to_ifrt\",\n       [](MlirModule module) -> void {\n         return xla::ThrowIfError(LowerToIfrt(unwrap(module)));\n       },\n-      py::arg(\"module\"));\n+      nb::arg(\"module\"));\n \n   m.def(\"get_compile_options\",\n         [](MlirModule c_module,\n            const absl::flat_hash_map<std::string, const EnvOptionsOverride>&\n-               compile_options_overrides) -> absl::StatusOr<py::dict> {\n+               compile_options_overrides) -> absl::StatusOr<nb::dict> {\n           auto module = unwrap(c_module);\n-          TF_ASSIGN_OR_RETURN(\n-              auto compile_options_map,\n+          auto compile_options_map = ValueOrThrow(\n               GetCompileOptions(module, compile_options_overrides));\n-          py::dict out;\n+          nb::dict out;\n           for (const auto& [name, options] : compile_options_map) {\n-            out[py::cast(name)] = py::reinterpret_steal<py::object>(\n-                nanobind::cast(options).release().ptr());\n+            out[nb::cast(name)] =\n+                nb::steal<nb::object>(nanobind::cast(options).release().ptr());\n           }\n           return out;\n         });"
        },
        {
            "sha": "b414cf01847c0f5c620414b2d4e50ad4d0ba9267",
            "filename": "third_party/xla/xla/python/ifrt/ir/ir_py.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 26,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fir_py.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b9ed811458d8da4c891e2632b00a343a828a3182/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fir_py.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fir_py.cc?ref=b9ed811458d8da4c891e2632b00a343a828a3182",
            "patch": "@@ -20,43 +20,44 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"mlir-c/IR.h\"\n-#include \"mlir/Bindings/Python/PybindAdaptors.h\"  // IWYU pragma: keep; Needed to allow MlirModule -> ModuleOp.\n+#include \"mlir/Bindings/Python/NanobindAdaptors.h\"  // IWYU pragma: keep; Needed to allow MlirModule -> ModuleOp.\n #include \"mlir/CAPI/IR.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/OperationSupport.h\"\n-#include \"pybind11/detail/common.h\"\n-#include \"pybind11/pybind11.h\"\n-#include \"pybind11/pytypes.h\"\n-#include \"pybind11_abseil/absl_casters.h\"\n-#include \"xla/pjrt/status_casters.h\"  // IWYU pragma: keep; Needed for ValueOrThrow\n+#include \"nanobind/nanobind.h\"\n+#include \"nanobind/stl/string.h\"  // IWYU pragma: keep\n+#include \"nanobind/stl/string_view.h\"  // IWYU pragma: keep\n+#include \"xla/pjrt/status_casters.h\"\n #include \"xla/python/ifrt/ir/ifrt_ir_program.h\"\n #include \"xla/python/ifrt/ir/transforms/utils.h\"\n #include \"xla/python/ifrt/ir/version.h\"\n #include \"xla/python/ifrt/serdes.pb.h\"\n #include \"xla/python/ifrt/support/module_parsing.h\"\n #include \"xla/tsl/platform/statusor.h\"\n \n+namespace nb = nanobind;\n+\n namespace xla {\n namespace ifrt {\n \n namespace {\n \n-absl::StatusOr<py::bytes> SerializedVersionedProgram(\n+absl::StatusOr<nb::bytes> SerializedVersionedProgram(\n     MlirModule module, absl::string_view ifrt_ir_version,\n     absl::string_view atom_program_version, bool version_in_place) {\n   auto program = std::make_unique<IfrtIRProgram>(unwrap(module));\n   TF_ASSIGN_OR_RETURN(\n-      auto serialized,\n+      Serialized serialized,\n       Serialize(*program,\n                 std::make_unique<SerializeIfrtIRProgramOptions>(\n                     std::string(ifrt_ir_version),\n                     std::string(atom_program_version), version_in_place)));\n   // Return just the data, to avoid the dependency on the Serialized proto.\n-  return py::bytes(serialized.data());\n+  return nb::bytes(serialized.data().data(), serialized.data().size());\n }\n \n-absl::StatusOr<py::bytes> SerializedVersionedProgram(\n+absl::StatusOr<nb::bytes> SerializedVersionedProgram(\n     absl::string_view module_str, absl::string_view ifrt_ir_version,\n     absl::string_view atom_program_version, bool version_in_place) {\n   mlir::MLIRContext context;\n@@ -70,7 +71,7 @@ absl::StatusOr<py::bytes> SerializedVersionedProgram(\n                     std::string(ifrt_ir_version),\n                     std::string(atom_program_version), version_in_place)));\n   // Return just the data, to avoid the dependency on the Serialized proto.\n-  return py::bytes(serialized.data());\n+  return nb::bytes(serialized.data().data(), serialized.data().size());\n }\n \n absl::StatusOr<mlir::ModuleOp> DeserializeVersionedProgram(\n@@ -86,20 +87,21 @@ absl::StatusOr<mlir::ModuleOp> DeserializeVersionedProgram(\n   return std::move(program->mlir_module);\n }\n \n-absl::StatusOr<py::bytes> DeserializeVersionedProgram(\n+absl::StatusOr<nb::bytes> DeserializeVersionedProgram(\n     absl::string_view serialized_program) {\n   mlir::MLIRContext context;\n   support::RegisterMlirDialects(context);\n   TF_ASSIGN_OR_RETURN(\n       auto module, DeserializeVersionedProgram(&context, serialized_program));\n-  return py::bytes(\n-      OperationToString(module, mlir::OpPrintingFlags().enableDebugInfo(true)));\n+  std::string out =\n+      OperationToString(module, mlir::OpPrintingFlags().enableDebugInfo(true));\n+  return nb::bytes(out.data(), out.size());\n }\n \n }  // namespace\n \n-PYBIND11_MODULE(ir_py, m) {\n-  py::enum_<Version::CompatibilityRequirement>(m, \"CompatibilityRequirement\")\n+NB_MODULE(ir_py, m) {\n+  nb::enum_<Version::CompatibilityRequirement>(m, \"CompatibilityRequirement\")\n       .value(\"NONE\", Version::CompatibilityRequirement::NONE)\n       .value(\"WEEK_4\", Version::CompatibilityRequirement::WEEK_4)\n       .value(\"WEEK_12\", Version::CompatibilityRequirement::WEEK_12)\n@@ -110,7 +112,7 @@ PYBIND11_MODULE(ir_py, m) {\n       [](Version::CompatibilityRequirement requirement) {\n         return Version::fromCompatibilityRequirement(requirement).toString();\n       },\n-      py::arg(\"requirement\"));\n+      nb::arg(\"requirement\"));\n \n   m.def(\"get_current_version\",\n         []() { return Version::getCurrentVersion().toString(); });\n@@ -125,23 +127,23 @@ PYBIND11_MODULE(ir_py, m) {\n       \"serialize_versioned_program\",\n       [](MlirModule module, absl::string_view ifrt_ir_version,\n          absl::string_view atom_program_version,\n-         bool version_in_place) -> py::bytes {\n+         bool version_in_place) -> nb::bytes {\n         return xla::ValueOrThrow(SerializedVersionedProgram(\n             module, ifrt_ir_version, atom_program_version, version_in_place));\n       },\n-      py::arg(\"module\"), py::arg(\"ifrt_ir_version\"),\n-      py::arg(\"atom_program_version\"), py::arg(\"version_in_place\"));\n+      nb::arg(\"module\"), nb::arg(\"ifrt_ir_version\"),\n+      nb::arg(\"atom_program_version\"), nb::arg(\"version_in_place\"));\n   m.def(\n       \"serialize_versioned_program_str\",\n       [](absl::string_view module_str, absl::string_view ifrt_ir_version,\n          absl::string_view atom_program_version,\n-         bool version_in_place) -> py::bytes {\n+         bool version_in_place) -> nb::bytes {\n         return xla::ValueOrThrow(\n             SerializedVersionedProgram(module_str, ifrt_ir_version,\n                                        atom_program_version, version_in_place));\n       },\n-      py::arg(\"module_str\"), py::arg(\"ifrt_ir_version\"),\n-      py::arg(\"atom_program_version\"), py::arg(\"version_in_place\"));\n+      nb::arg(\"module_str\"), nb::arg(\"ifrt_ir_version\"),\n+      nb::arg(\"atom_program_version\"), nb::arg(\"version_in_place\"));\n \n   // Deserializes a versioned IFRT IR program to IFRT IR.\n   m.def(\n@@ -151,14 +153,14 @@ PYBIND11_MODULE(ir_py, m) {\n         return wrap(xla::ValueOrThrow(\n             DeserializeVersionedProgram(unwrap(context), serialized_program)));\n       },\n-      py::arg(\"context\"), py::arg(\"serialized_program\"));\n+      nb::arg(\"context\"), nb::arg(\"serialized_program\"));\n   m.def(\n       \"deserialize_versioned_program_str\",\n-      [](absl::string_view serialized_program) -> py::bytes {\n+      [](absl::string_view serialized_program) -> nb::bytes {\n         return xla::ValueOrThrow(\n             DeserializeVersionedProgram(serialized_program));\n       },\n-      py::arg(\"serialized_program\"));\n+      nb::arg(\"serialized_program\"));\n }\n \n }  // namespace ifrt"
        }
    ],
    "stats": {
        "total": 91,
        "additions": 45,
        "deletions": 46
    }
}