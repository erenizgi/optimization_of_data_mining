{
    "author": "d4n1elchen",
    "message": "[XLA:HLO Diff] Refactor HLO diff rendering to support multiple computations per side.\n\nNote that this will break the click-to-jump function. Will fix it in the next change.\n\nPiperOrigin-RevId: 805965283",
    "sha": "c7b82d06d68e4d8326da6a435452b3a5f963ab04",
    "files": [
        {
            "sha": "ac60db7ca82b6548c3d669d0f18565a8f465ce66",
            "filename": "third_party/xla/xla/hlo/tools/hlo_diff/render/hlo_gumgraph_html_renderer.cc",
            "status": "modified",
            "additions": 106,
            "deletions": 76,
            "changes": 182,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7b82d06d68e4d8326da6a435452b3a5f963ab04/third_party%2Fxla%2Fxla%2Fhlo%2Ftools%2Fhlo_diff%2Frender%2Fhlo_gumgraph_html_renderer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7b82d06d68e4d8326da6a435452b3a5f963ab04/third_party%2Fxla%2Fxla%2Fhlo%2Ftools%2Fhlo_diff%2Frender%2Fhlo_gumgraph_html_renderer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftools%2Fhlo_diff%2Frender%2Fhlo_gumgraph_html_renderer.cc?ref=c7b82d06d68e4d8326da6a435452b3a5f963ab04",
            "patch": "@@ -171,11 +171,20 @@ std::string PrintCss() {\n       width: 100%;\n       gap: 10px;\n     }\n-    .hlo-textbox {\n+    .hlo-textboxes {\n       flex: 1;\n+      display: flex;\n       min-width: 0;\n+      flex-direction: column;\n+      width: 100%;\n+      max-height: 1200px;\n+    }\n+    .hlo-textbox {\n+      flex: 1;\n       display: flex;\n       flex-direction: column;\n+      padding: 10px 0px;\n+      min-height: 0;\n     }\n     .hlo-textbox > .textbox {\n       position: relative;\n@@ -184,14 +193,15 @@ std::string PrintCss() {\n       border-radius: 5px;\n       height: 100%;\n       box-sizing: border-box;\n+      min-height: 0;\n     }\n     .hlo-textbox > .textbox > pre {\n       width: 100%;\n       margin: 0;\n-      padding: 0;\n+      padding: 2px;\n       overflow: auto;\n       white-space: pre-wrap;\n-      max-height: 800px;\n+      height: 100%;\n     }\n     .hlo-textbox > .textbox > .click-to-copy {\n       position: absolute;\n@@ -221,6 +231,7 @@ std::string PrintCss() {\n     span.hlo-instruction {\n       display: inline-block;\n       cursor: pointer;\n+      width: 100%;\n     }\n     span.hlo-instruction:hover {\n       border: 2px solid #4285F4;\n@@ -696,13 +707,13 @@ std::string PrintHloComputationToHtml(\n   StringPrinter printer;\n \n   // Mimic HloComputation::Print structure with default options.\n-  printer.Append(\"%\");\n+  printer.Append(\"<b>%\");\n   printer.Append(comp->name());\n   printer.Append(\" \");\n   ShapeUtil::PrintHumanString(&printer,\n                               comp->ComputeProgramShape(/*include_ids=*/true));\n   printer.Append(\" \");\n-  printer.Append(\"{\\n\");\n+  printer.Append(\"{</b>\\n\");\n \n   // Print instructions in this computation.\n   {\n@@ -792,7 +803,7 @@ std::string PrintHloComputationToHtml(\n     }\n   }\n \n-  printer.Append(\"}\");  // Closing brace for computation.\n+  printer.Append(\"<b>}</b>\");  // Closing brace for computation.\n \n   // Default print_ids is true, so execution thread is printed if not main.\n   if (!comp->IsMainThread()) {\n@@ -804,62 +815,64 @@ std::string PrintHloComputationToHtml(\n   return std::move(printer).ToString();\n }\n \n-// Prints a pair of instructions or computations in a text box.\n+// Prints a single HLO instruction in a text box.\n template <typename T>\n-std::string PrintHloTextboxPair(\n-    const T* left_node, const T* right_node,\n-    const absl::flat_hash_map<const HloInstruction*, Attributes>&\n-        span_attributes) {\n-  std::string left_title = \"None\", right_title = \"None\", left_text, right_text;\n-  if (left_node != nullptr) {\n-    left_title = left_node->name();\n-    if constexpr (std::is_same_v<T, HloComputation>) {\n-      left_text = PrintHloComputationToHtml(left_node, DiffSide::kLeft,\n-                                            span_attributes);\n-    } else {\n-      left_text = left_node->ToString();\n-    }\n-  }\n-  if (right_node != nullptr) {\n-    right_title = right_node->name();\n+std::string PrintHloTextbox(\n+    const T* node, const absl::flat_hash_map<const HloInstruction*, Attributes>&\n+                       span_attributes) {\n+  std::string title = \"None\", text;\n+  if (node != nullptr) {\n+    title = node->name();\n     if constexpr (std::is_same_v<T, HloComputation>) {\n-      right_text = PrintHloComputationToHtml(right_node, DiffSide::kRight,\n-                                             span_attributes);\n+      text = PrintHloComputationToHtml(node, DiffSide::kLeft, span_attributes);\n     } else {\n-      right_text = right_node->ToString();\n+      text = node->ToString();\n     }\n   }\n-\n-  uint64_t fingerprint =\n-      tsl::Fingerprint64(absl::StrCat(left_text, right_text));\n+  uint64_t fingerprint = tsl::Fingerprint64(text);\n   return PrintDiv(\n-      absl::StrCat(\n-          PrintDiv(PrintTextbox(left_title, left_text,\n-                                absl::StrFormat(\"%016x-left\", fingerprint)),\n-\n-                   {\"hlo-textbox\"}),\n-          PrintDiv(PrintTextbox(right_title, right_text,\n-                                absl::StrFormat(\"%016x-right\", fingerprint)),\n+      PrintTextbox(title, text, absl::StrFormat(\"%016x\", fingerprint)),\n+      {\"hlo-textbox\"});\n+}\n \n-                   {\"hlo-textbox\"})),\n-      {\"hlo-textbox-pair\"});\n+// Prints a pair of instructions or computations in a text box.\n+template <typename T>\n+std::string PrintHloTextboxPair(\n+    absl::Span<const T* const> left_nodes,\n+    absl::Span<const T* const> right_nodes,\n+    const absl::flat_hash_map<const HloInstruction*, Attributes>&\n+        span_attributes) {\n+  std::string left_textbox, right_textbox;\n+  for (const T* node : left_nodes) {\n+    absl::StrAppend(&left_textbox, PrintHloTextbox(node, span_attributes));\n+  }\n+  for (const T* node : right_nodes) {\n+    absl::StrAppend(&right_textbox, PrintHloTextbox(node, span_attributes));\n+  }\n+  return PrintDiv(absl::StrCat(PrintDiv(left_textbox, {\"hlo-textboxes\"}),\n+                               PrintDiv(right_textbox, {\"hlo-textboxes\"})),\n+                  {\"hlo-textbox-pair\"});\n }\n \n template <typename T>\n-using DecorationPrinter = std::string(const T*, const T*);\n+using DecorationPrinter = std::string(absl::Span<const T* const>,\n+                                      absl::Span<const T* const>);\n \n template <typename T>\n std::string PrintNodePairContent(\n-    const T* left_node, const T* right_node,\n+    absl::Span<const T* const> left_nodes,\n+    absl::Span<const T* const> right_nodes,\n     const absl::flat_hash_map<const HloInstruction*, Attributes>&\n         span_attributes,\n     GraphUrlGenerator* url_generator) {\n   std::string url;\n+  const T* left_node = left_nodes.empty() ? nullptr : left_nodes[0];\n+  const T* right_node = right_nodes.empty() ? nullptr : right_nodes[0];\n   if (url_generator != nullptr) {\n     url = url_generator->GenerateWithSelectedNodes(left_node, right_node);\n   }\n   return absl::StrCat(\n-      PrintHloTextboxPair(left_node, right_node, span_attributes),\n+      PrintHloTextboxPair(left_nodes, right_nodes, span_attributes),\n       url.empty()\n           ? \"\"\n           : PrintDiv(PrintLink(\"Model Explorer\", url), {\"model-explorer-url\"}));\n@@ -870,30 +883,57 @@ std::string PrintNodePairContent(\n // explorer will be printed.\n template <typename T>\n std::string PrintNodePair(\n-    const T* left_node, const T* right_node,\n+    absl::Span<const T* const> left_nodes,\n+    absl::Span<const T* const> right_nodes,\n     const absl::flat_hash_map<const HloInstruction*, Attributes>&\n         span_attributes,\n     GraphUrlGenerator* url_generator,\n     std::optional<absl::FunctionRef<DecorationPrinter<T>>> decoration_printer =\n         std::nullopt) {\n   std::vector<std::string> nodes;\n-  if (left_node != nullptr) {\n-    nodes.push_back(std::string(left_node->name()));\n+  if (!left_nodes.empty()) {\n+    nodes.push_back(\n+        absl::StrJoin(left_nodes, \", \", [](std::string* out, const T* node) {\n+          absl::StrAppend(out, node->name());\n+        }));\n   }\n-  if (right_node != nullptr) {\n-    nodes.push_back(std::string(right_node->name()));\n+  if (!right_nodes.empty()) {\n+    nodes.push_back(\n+        absl::StrJoin(right_nodes, \", \", [](std::string* out, const T* node) {\n+          absl::StrAppend(out, node->name());\n+        }));\n   }\n   std::string text = absl::StrJoin(nodes, \" â†” \");\n   std::string decoration;\n   if (decoration_printer.has_value()) {\n-    decoration =\n-        PrintSpan((*decoration_printer)(left_node, right_node), {\"decoration\"});\n+    decoration = PrintSpan((*decoration_printer)(left_nodes, right_nodes),\n+                           {\"decoration\"});\n   }\n   return PrintDetails(absl::StrCat(text, \" \", decoration),\n-                      PrintNodePairContent<T>(left_node, right_node,\n+                      PrintNodePairContent<T>(left_nodes, right_nodes,\n                                               span_attributes, url_generator));\n }\n \n+template <typename T>\n+std::string PrintNodePair(\n+    const T* left_node, const T* right_node,\n+    const absl::flat_hash_map<const HloInstruction*, Attributes>&\n+        span_attributes,\n+    GraphUrlGenerator* url_generator,\n+    std::optional<absl::FunctionRef<DecorationPrinter<T>>> decoration_printer =\n+        std::nullopt) {\n+  std::vector<const T*> left_nodes;\n+  if (left_node != nullptr) {\n+    left_nodes.push_back(left_node);\n+  }\n+  std::vector<const T*> right_nodes;\n+  if (right_node != nullptr) {\n+    right_nodes.push_back(right_node);\n+  }\n+  return PrintNodePair<T>(left_nodes, right_nodes, span_attributes,\n+                          url_generator, decoration_printer);\n+}\n+\n // The location of the instruction in the diff result.\n enum class InstructionLocation : std::uint8_t { kLeft, kRight };\n \n@@ -1040,8 +1080,12 @@ std::string PrintChangedInstructions(\n         instructions,\n     GraphUrlGenerator* url_generator) {\n   std::function<DecorationPrinter<HloInstruction>> decorated_printer =\n-      [](const HloInstruction* left_inst,\n-         const HloInstruction* right_inst) -> std::string {\n+      [](absl::Span<const HloInstruction* const> left_insts,\n+         absl::Span<const HloInstruction* const> right_insts) -> std::string {\n+    CHECK_EQ(left_insts.size(), 1);\n+    CHECK_EQ(right_insts.size(), 1);\n+    const HloInstruction* left_inst = left_insts[0];\n+    const HloInstruction* right_inst = right_insts[0];\n     std::vector<ChangedInstructionDiffType> diff_types =\n         GetChangedInstructionDiffTypes(*left_inst, *right_inst);\n     return absl::StrCat(\n@@ -1107,8 +1151,9 @@ std::string PrintUnmatchedMetricsDiff(\n     }\n     metrics_diff_list.push_back(PrintNodePair<HloInstruction>(\n         left_inst, right_inst, /*span_attributes=*/{}, url_generator,\n-        [&metrics_diff](const HloInstruction* inst,\n-                        const HloInstruction*) -> std::string {\n+        [&metrics_diff](absl::Span<const HloInstruction* const> left_insts,\n+                        absl::Span<const HloInstruction* const> right_insts)\n+            -> std::string {\n           return absl::StrFormat(\"%.2f (us)\", metrics_diff / 1e6);\n         }));\n   }\n@@ -1146,8 +1191,9 @@ std::string PrintMatchedMetricsDiff(\n     double metrics_diff = entry.second;\n     metrics_diff_list.push_back(PrintNodePair<HloInstruction>(\n         left_inst, right_inst, /*span_attributes=*/{}, url_generator,\n-        [&metrics_diff](const HloInstruction* left_inst,\n-                        const HloInstruction* right_inst) -> std::string {\n+        [&metrics_diff](absl::Span<const HloInstruction* const> left_insts,\n+                        absl::Span<const HloInstruction* const> right_insts)\n+            -> std::string {\n           return absl::StrFormat(\"%+.2f (us)\", metrics_diff / 1e6);\n         }));\n   }\n@@ -1219,35 +1265,19 @@ std::string PrintComputationSummary(\n         span_attributes,\n     GraphUrlGenerator* url_generator) {\n   const ComputationGroup& sample = diff_pattern.computation_groups[0];\n-  // We only support unmatched computation and one-to-one computation pairs.\n-  if (sample.left_computations.size() > 1 ||\n-      sample.right_computations.size() > 1) {\n-    return \"\";\n-  }\n   std::vector<std::string> computation_pair_list(\n       diff_pattern.computation_groups.size() - 1);\n   for (int i = 1; i < diff_pattern.computation_groups.size(); ++i) {\n     const ComputationGroup& computation_group =\n         diff_pattern.computation_groups[i];\n-    const HloComputation* left_computation =\n-        computation_group.left_computations.empty()\n-            ? nullptr\n-            : computation_group.left_computations[0];\n-    const HloComputation* right_computation =\n-        computation_group.right_computations.empty()\n-            ? nullptr\n-            : computation_group.right_computations[0];\n     computation_pair_list[i - 1] = PrintNodePair<HloComputation>(\n-        left_computation, right_computation, span_attributes, url_generator);\n+        computation_group.left_computations,\n+        computation_group.right_computations, span_attributes, url_generator);\n   }\n-  const HloComputation* left_computation =\n-      sample.left_computations.empty() ? nullptr : sample.left_computations[0];\n-  const HloComputation* right_computation = sample.right_computations.empty()\n-                                                ? nullptr\n-                                                : sample.right_computations[0];\n   std::vector<std::string> contents;\n-  contents.push_back(PrintNodePairContent(left_computation, right_computation,\n-                                          span_attributes, url_generator));\n+  contents.push_back(PrintNodePairContent<HloComputation>(\n+      sample.left_computations, sample.right_computations, span_attributes,\n+      url_generator));\n   if (!computation_pair_list.empty()) {\n     contents.push_back(\n         PrintDetails(absl::StrFormat(\"%d other similar computations\","
        }
    ],
    "stats": {
        "total": 182,
        "additions": 106,
        "deletions": 76
    }
}