{
    "author": "mkuperst",
    "message": "[XLA] Make sure inliner-assigned channel IDs are truly unique.\n1. Don't reuse IDs when inlining different computations.\n2. Make sure we don't collide with any IDs already present in the module.\n\nPiperOrigin-RevId: 801826554",
    "sha": "947af71e4e9381079ac1e01ec33b37e4d7cefc94",
    "files": [
        {
            "sha": "17f002342578937fba81038e8c52e2789f39773a",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=947af71e4e9381079ac1e01ec33b37e4d7cefc94",
            "patch": "@@ -1022,6 +1022,7 @@ xla_cc_test(\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings:string_view\","
        },
        {
            "sha": "d5441ed4bdce2511caf713643dc531bc1ce47dad",
            "filename": "third_party/xla/xla/service/call_inliner.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 2,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc?ref=947af71e4e9381079ac1e01ec33b37e4d7cefc94",
            "patch": "@@ -15,6 +15,7 @@ limitations under the License.\n \n #include \"xla/service/call_inliner.h\"\n \n+#include <algorithm>\n #include <memory>\n #include <optional>\n #include <string>\n@@ -395,7 +396,6 @@ absl::StatusOr<bool> CallInliner::InlineAndLegalize(\n         HloInstructionSequence(inlined_instructions);\n   }\n   if (did_node_mutate && uniquify_channel_ids_) {\n-    int unique_channel_id = 1;\n     for (HloInstruction* instruction : computation->instructions()) {\n       if (!dynamic_cast<HloChannelInstruction*>(instruction)) {\n         continue;\n@@ -407,7 +407,7 @@ absl::StatusOr<bool> CallInliner::InlineAndLegalize(\n       if (send_recv && send_recv->is_host_transfer()) {\n         continue;\n       }\n-      instruction->set_channel_id(unique_channel_id++);\n+      instruction->set_channel_id(next_unique_channel_id_++);\n     }\n   }\n   return did_node_mutate;\n@@ -417,6 +417,24 @@ absl::StatusOr<bool> CallInliner::RunWithInlineMap(\n     HloModule* module, std::optional<InlinedInstructionMap*> inline_map,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n   std::unique_ptr<CallGraph> call_graph = CallGraph::Build(module);\n+  if (uniquify_channel_ids_) {\n+    // If we're going to uniquify channel IDs, make sure the new IDs we assigned\n+    // are not already used in the module. The easiest way is to just start at\n+    // the top currently used ID.\n+    for (HloComputation* computation : module->computations()) {\n+      for (HloInstruction* instruction : computation->instructions()) {\n+        HloChannelInstruction* channel_instruction =\n+            dynamic_cast<HloChannelInstruction*>(instruction);\n+        if (channel_instruction &&\n+            channel_instruction->channel_id().has_value()) {\n+          next_unique_channel_id_ =\n+              std::max(next_unique_channel_id_,\n+                       channel_instruction->channel_id().value() + 1);\n+        }\n+      }\n+    }\n+  }\n+\n   // Because call graph nodes are visited in post-order (callees before callers)\n   // we'll always inline kCalls into their callers in the appropriate order.\n   TF_ASSIGN_OR_RETURN("
        },
        {
            "sha": "6607ee900aed4e076fde4a24003701b20bee43ba",
            "filename": "third_party/xla/xla/service/call_inliner.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.h?ref=947af71e4e9381079ac1e01ec33b37e4d7cefc94",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #ifndef XLA_SERVICE_CALL_INLINER_H_\n #define XLA_SERVICE_CALL_INLINER_H_\n \n+#include <cstdint>\n #include <functional>\n #include <optional>\n #include <string>\n@@ -99,6 +100,7 @@ class CallInliner : public HloModulePass {\n   std::optional<\n       std::function<bool(const CallGraph& call_graph, HloInstruction*)>>\n       should_inline_;\n+  int64_t next_unique_channel_id_ = 1;\n };\n \n // Returns true if the computation has instructions that are inlinable."
        },
        {
            "sha": "4839c60846a0bafff902ac3af1af1aae33b8f975",
            "filename": "third_party/xla/xla/service/call_inliner_test.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/947af71e4e9381079ac1e01ec33b37e4d7cefc94/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner_test.cc?ref=947af71e4e9381079ac1e01ec33b37e4d7cefc94",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/strings/string_view.h\"\n@@ -987,5 +988,52 @@ ENTRY main {\n   }\n }\n \n+TEST_F(CallInlinerTest, ChannelIdsAreGlovallyUniquified) {\n+  const char* hlo = R\"(\n+ag {\n+  input = f32[128,32] parameter(0)\n+  ROOT ag = f32[128,128] all-gather(input), replica_groups={}, dimensions={1}, channel_id=27\n+}\n+\n+branch_0 {\n+  input = f32[128,32] parameter(0)\n+  ROOT ag = f32[128,128] call(input), to_apply=ag\n+}\n+\n+branch_1 {\n+  input = f32[128,32] parameter(0)\n+  ROOT ag = f32[128,128] call(input), to_apply=ag\n+}\n+\n+ENTRY main {\n+  input.0 = f32[128,32] parameter(0)\n+  input.1 = f32[128,32] parameter(1)\n+  input.2 = f32[128,32] parameter(2)\n+  p = s32[] parameter(3)\n+  conditional = f32[128,128] conditional(p, input.0, input.1), branch_computations={branch_0, branch_1}\n+  ag = f32[128,128] all-gather(input.2), replica_groups={}, dimensions={1}, channel_id=42\n+  ROOT add = f32[128,128] add(conditional, ag)\n+})\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> m,\n+                          ParseAndReturnVerifiedModule(hlo));\n+  CallInliner call_inliner(\n+      /*single_call_site=*/false, /*update_domain=*/false,\n+      /*composites_to_preserve=*/{}, /*uniquify_channel_ids=*/true);\n+  ASSERT_THAT(call_inliner.Run(m.get()), absl_testing::IsOkAndHolds(true));\n+\n+  absl::flat_hash_set<int64_t> channel_ids;\n+  for (HloComputation* comp : m->computations()) {\n+    for (HloInstruction* inst : comp->instructions()) {\n+      HloChannelInstruction* channel =\n+          dynamic_cast<HloChannelInstruction*>(inst);\n+      if (channel && channel->channel_id().has_value()) {\n+        channel_ids.insert(channel->channel_id().value());\n+      }\n+    }\n+  }\n+  EXPECT_THAT(channel_ids, ::testing::UnorderedElementsAre(42, 43, 44));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 73,
        "additions": 71,
        "deletions": 2
    }
}