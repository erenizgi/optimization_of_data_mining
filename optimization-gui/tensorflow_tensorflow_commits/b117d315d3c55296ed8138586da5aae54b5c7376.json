{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832858636",
    "sha": "b117d315d3c55296ed8138586da5aae54b5c7376",
    "files": [
        {
            "sha": "6c840b9804617e22ac7cd5c6c9df40556bb2ea76",
            "filename": "third_party/xla/xla/tsl/platform/cloud/auth_provider.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fauth_provider.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fauth_provider.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fauth_provider.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -31,9 +31,9 @@ class AuthProvider {\n   /// \\brief Returns the short-term authentication bearer token.\n   ///\n   /// Safe for concurrent use by multiple threads.\n-  virtual absl::Status GetToken(string* t) = 0;\n+  virtual absl::Status GetToken(std::string* t) = 0;\n \n-  static absl::Status GetToken(AuthProvider* provider, string* token) {\n+  static absl::Status GetToken(AuthProvider* provider, std::string* token) {\n     if (!provider) {\n       return errors::Internal(\"Auth provider is required.\");\n     }\n@@ -44,7 +44,7 @@ class AuthProvider {\n /// No-op auth provider, which will only work for public objects.\n class EmptyAuthProvider : public AuthProvider {\n  public:\n-  absl::Status GetToken(string* token) override {\n+  absl::Status GetToken(std::string* token) override {\n     *token = \"\";\n     return absl::OkStatus();\n   }"
        },
        {
            "sha": "2590dcd743e0d6f7281537caccf40b510ac9359c",
            "filename": "third_party/xla/xla/tsl/platform/cloud/compute_engine_metadata_client.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -41,9 +41,9 @@ ComputeEngineMetadataClient::ComputeEngineMetadataClient(\n       retry_config_(config) {}\n \n absl::Status ComputeEngineMetadataClient::GetMetadata(\n-    const string& path, std::vector<char>* response_buffer) {\n+    const std::string& path, std::vector<char>* response_buffer) {\n   const auto get_metadata_from_gce = [path, response_buffer, this]() {\n-    string metadata_url;\n+    std::string metadata_url;\n     const char* metadata_url_override = std::getenv(kGceMetadataHost);\n     if (metadata_url_override) {\n       metadata_url = absl::StrCat(\"http://\", metadata_url_override,"
        },
        {
            "sha": "7fd20c0854c60e9cfb808d0bf40950e08fbd338e",
            "filename": "third_party/xla/xla/tsl/platform/cloud/compute_engine_metadata_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -51,7 +51,7 @@ class ComputeEngineMetadataClient {\n   /// To get the zone of an instance:\n   ///   compute_engine_metadata_client.GetMetadata(\n   ///       \"instance/zone\", response_buffer);\n-  virtual absl::Status GetMetadata(const string& path,\n+  virtual absl::Status GetMetadata(const std::string& path,\n                                    std::vector<char>* response_buffer);\n \n  private:"
        },
        {
            "sha": "5004842d8e1a8a2a19ecb47a9a87386ea165f556",
            "filename": "third_party/xla/xla/tsl/platform/cloud/compute_engine_metadata_client_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_metadata_client_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -31,7 +31,7 @@ class ComputeEngineMetadataClientTest : public ::testing::Test {\n };\n \n TEST_F(ComputeEngineMetadataClientTest, GetMetadata) {\n-  const string example_response = \"example response\";\n+  const std::string example_response = \"example response\";\n \n   std::vector<HttpRequest*> requests({new FakeHttpRequest(\n       \"Uri: http://metadata.google.internal/computeMetadata/v1/instance\"\n@@ -52,7 +52,7 @@ TEST_F(ComputeEngineMetadataClientTest, GetMetadata) {\n }\n \n TEST_F(ComputeEngineMetadataClientTest, GetCustomMetadataEndpoint) {\n-  const string example_response = \"example response\";\n+  const std::string example_response = \"example response\";\n   setenv(\"GCE_METADATA_HOST\", \"foo.bar\", 1);\n \n   std::vector<HttpRequest*> requests(\n@@ -74,7 +74,7 @@ TEST_F(ComputeEngineMetadataClientTest, GetCustomMetadataEndpoint) {\n }\n \n TEST_F(ComputeEngineMetadataClientTest, RetryOnFailure) {\n-  const string example_response = \"example response\";\n+  const std::string example_response = \"example response\";\n \n   std::vector<HttpRequest*> requests(\n       {new FakeHttpRequest("
        },
        {
            "sha": "2c1705802ebdb595046ddcad012f4d737a77faf2",
            "filename": "third_party/xla/xla/tsl/platform/cloud/compute_engine_zone_provider.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -28,7 +28,7 @@ ComputeEngineZoneProvider::ComputeEngineZoneProvider(\n     std::shared_ptr<ComputeEngineMetadataClient> google_metadata_client)\n     : google_metadata_client_(std::move(google_metadata_client)) {}\n \n-absl::Status ComputeEngineZoneProvider::GetZone(string* zone) {\n+absl::Status ComputeEngineZoneProvider::GetZone(std::string* zone) {\n   if (!cached_zone.empty()) {\n     *zone = cached_zone;\n     return absl::OkStatus();\n@@ -38,13 +38,12 @@ absl::Status ComputeEngineZoneProvider::GetZone(string* zone) {\n                                                           &response_buffer));\n   absl::string_view location(&response_buffer[0], response_buffer.size());\n \n-  std::vector<string> elems = str_util::Split(location, \"/\");\n+  std::vector<std::string> elems = str_util::Split(location, \"/\");\n   if (elems.size() == 4) {\n     cached_zone = elems.back();\n     *zone = cached_zone;\n   } else {\n-    LOG(ERROR) << \"Failed to parse the zone name from location: \"\n-               << string(location);\n+    LOG(ERROR) << \"Failed to parse the zone name from location: \" << location;\n   }\n \n   return absl::OkStatus();"
        },
        {
            "sha": "8366eb100e708dc228230833eddbe456ad6fe1b7",
            "filename": "third_party/xla/xla/tsl/platform/cloud/compute_engine_zone_provider.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -27,11 +27,11 @@ class ComputeEngineZoneProvider : public ZoneProvider {\n       std::shared_ptr<ComputeEngineMetadataClient> google_metadata_client);\n   virtual ~ComputeEngineZoneProvider();\n \n-  absl::Status GetZone(string* zone) override;\n+  absl::Status GetZone(std::string* zone) override;\n \n  private:\n   std::shared_ptr<ComputeEngineMetadataClient> google_metadata_client_;\n-  string cached_zone;\n+  std::string cached_zone;\n   ComputeEngineZoneProvider(const ComputeEngineZoneProvider&) = delete;\n   void operator=(const ComputeEngineZoneProvider&) = delete;\n };"
        },
        {
            "sha": "8c3f29d02f4cb089562de4191b60591d3aa55363",
            "filename": "third_party/xla/xla/tsl/platform/cloud/compute_engine_zone_provider_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fcompute_engine_zone_provider_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -40,7 +40,7 @@ TEST_F(ComputeEngineZoneProviderTest, GetZone) {\n \n   ComputeEngineZoneProvider provider(metadata_client);\n \n-  string zone;\n+  std::string zone;\n \n   TF_EXPECT_OK(provider.GetZone(&zone));\n   EXPECT_EQ(\"us-west1-b\", zone);\n@@ -61,7 +61,7 @@ TEST_F(ComputeEngineZoneProviderTest, InvalidZoneString) {\n \n   ComputeEngineZoneProvider provider(metadata_client);\n \n-  string zone;\n+  std::string zone;\n \n   TF_EXPECT_OK(provider.GetZone(&zone));\n   EXPECT_EQ(\"\", zone);"
        },
        {
            "sha": "49c2070e1a6c796691ada59cf1ba98fcac26f064",
            "filename": "third_party/xla/xla/tsl/platform/cloud/expiring_lru_cache.h",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -39,13 +39,13 @@ class ExpiringLRUCache {\n   /// A `max_age` of 0 means that nothing is cached. A `max_entries` of 0 means\n   /// that there is no limit on the number of entries in the cache (however, if\n   /// `max_age` is also 0, the cache will not be populated).\n-  ExpiringLRUCache(uint64 max_age, size_t max_entries,\n+  ExpiringLRUCache(uint64_t max_age, size_t max_entries,\n                    Env* env = Env::Default())\n       : max_age_(max_age), max_entries_(max_entries), env_(env) {}\n \n   /// Insert `value` with key `key`. This will replace any previous entry with\n   /// the same key.\n-  void Insert(const string& key, const T& value) {\n+  void Insert(const std::string& key, const T& value) {\n     if (max_age_ == 0) {\n       return;\n     }\n@@ -56,28 +56,28 @@ class ExpiringLRUCache {\n   // Delete the entry with key `key`. Return true if the entry was found for\n   // `key`, false if the entry was not found. In both cases, there is no entry\n   // with key `key` existed after the call.\n-  bool Delete(const string& key) {\n+  bool Delete(const std::string& key) {\n     absl::MutexLock lock(mu_);\n     return DeleteLocked(key);\n   }\n \n   /// Look up the entry with key `key` and copy it to `value` if found. Returns\n   /// true if an entry was found for `key`, and its timestamp is not more than\n   /// max_age_ seconds in the past.\n-  bool Lookup(const string& key, T* value) {\n+  bool Lookup(const std::string& key, T* value) {\n     if (max_age_ == 0) {\n       return false;\n     }\n     absl::MutexLock lock(mu_);\n     return LookupLocked(key, value);\n   }\n \n-  typedef std::function<absl::Status(const string&, T*)> ComputeFunc;\n+  typedef std::function<absl::Status(const std::string&, T*)> ComputeFunc;\n \n   /// Look up the entry with key `key` and copy it to `value` if found. If not\n   /// found, call `compute_func`. If `compute_func` returns successfully, store\n   /// a copy of the output parameter in the cache, and another copy in `value`.\n-  absl::Status LookupOrCompute(const string& key, T* value,\n+  absl::Status LookupOrCompute(const std::string& key, T* value,\n                                const ComputeFunc& compute_func) {\n     if (max_age_ == 0) {\n       return compute_func(key, value);\n@@ -105,22 +105,22 @@ class ExpiringLRUCache {\n   }\n \n   /// Accessors for cache parameters.\n-  uint64 max_age() const { return max_age_; }\n+  uint64_t max_age() const { return max_age_; }\n   size_t max_entries() const { return max_entries_; }\n \n  private:\n   struct Entry {\n     /// The timestamp (seconds) at which the entry was added to the cache.\n-    uint64 timestamp;\n+    uint64_t timestamp;\n \n     /// The entry's value.\n     T value;\n \n     /// A list iterator pointing to the entry's position in the LRU list.\n-    std::list<string>::iterator lru_iterator;\n+    std::list<std::string>::iterator lru_iterator;\n   };\n \n-  bool LookupLocked(const string& key, T* value)\n+  bool LookupLocked(const std::string& key, T* value)\n       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n     auto it = cache_.find(key);\n     if (it == cache_.end()) {\n@@ -137,7 +137,7 @@ class ExpiringLRUCache {\n     return true;\n   }\n \n-  void InsertLocked(const string& key, const T& value)\n+  void InsertLocked(const std::string& key, const T& value)\n       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n     lru_list_.push_front(key);\n     Entry entry{env_->NowSeconds(), value, lru_list_.begin()};\n@@ -151,7 +151,7 @@ class ExpiringLRUCache {\n     }\n   }\n \n-  bool DeleteLocked(const string& key) TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n+  bool DeleteLocked(const std::string& key) TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n     auto it = cache_.find(key);\n     if (it == cache_.end()) {\n       return false;\n@@ -163,7 +163,7 @@ class ExpiringLRUCache {\n \n   /// The maximum age of entries in the cache, in seconds. A value of 0 means\n   /// that no entry is ever placed in the cache.\n-  const uint64 max_age_;\n+  const uint64_t max_age_;\n \n   /// The maximum number of entries in the cache. A value of 0 means there is no\n   /// limit on entry count.\n@@ -176,11 +176,11 @@ class ExpiringLRUCache {\n   absl::Mutex mu_;\n \n   /// The cache (a map from string key to Entry).\n-  std::map<string, Entry> cache_ TF_GUARDED_BY(mu_);\n+  std::map<std::string, Entry> cache_ TF_GUARDED_BY(mu_);\n \n   /// The LRU list of entries. The front of the list identifies the most\n   /// recently accessed entry.\n-  std::list<string> lru_list_ TF_GUARDED_BY(mu_);\n+  std::list<std::string> lru_list_ TF_GUARDED_BY(mu_);\n };\n \n }  // namespace tsl"
        },
        {
            "sha": "8f69466b1404e0493aa03b5a3ec6470bd5dd87a2",
            "filename": "third_party/xla/xla/tsl/platform/cloud/expiring_lru_cache_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -25,7 +25,7 @@ namespace tsl {\n namespace {\n \n TEST(ExpiringLRUCacheTest, MaxAge) {\n-  const string key = \"a\";\n+  const std::string key = \"a\";\n   std::unique_ptr<NowSecondsEnv> env(new NowSecondsEnv);\n   ExpiringLRUCache<int> cache(1, 0, env.get());\n   env->SetNowSeconds(1);\n@@ -92,9 +92,9 @@ TEST(ExpiringLRUCacheTest, MaxEntries) {\n \n TEST(ExpiringLRUCacheTest, LookupOrCompute) {\n   // max_age of 0 means we should always compute.\n-  uint64 num_compute_calls = 0;\n+  uint64_t num_compute_calls = 0;\n   ExpiringLRUCache<int>::ComputeFunc compute_func =\n-      [&num_compute_calls](const string& key, int* value) {\n+      [&num_compute_calls](const std::string& key, int* value) {\n         *value = num_compute_calls;\n         num_compute_calls++;\n         return absl::OkStatus();"
        },
        {
            "sha": "bdab4dc8454f60adcc02094950e9f17d8ce41094",
            "filename": "third_party/xla/xla/tsl/platform/cloud/file_block_cache.h",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ffile_block_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ffile_block_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ffile_block_cache.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -69,7 +69,7 @@ class FileBlockCache {\n   /// cache is constructed. The returned Status should be OK as long as the\n   /// read from the remote filesystem succeeded (similar to the semantics of the\n   /// read(2) system call).\n-  typedef std::function<absl::Status(const string& filename, size_t offset,\n+  typedef std::function<absl::Status(const std::string& filename, size_t offset,\n                                      size_t buffer_size, char* buffer,\n                                      size_t* bytes_transferred)>\n       BlockFetcher;\n@@ -90,26 +90,27 @@ class FileBlockCache {\n   ///    placed in `out`.\n   /// 4) OK otherwise (i.e. the read succeeded, and at least one byte was placed\n   ///    in `out`).\n-  virtual absl::Status Read(const string& filename, size_t offset, size_t n,\n-                            char* buffer, size_t* bytes_transferred) = 0;\n+  virtual absl::Status Read(const std::string& filename, size_t offset,\n+                            size_t n, char* buffer,\n+                            size_t* bytes_transferred) = 0;\n \n   // Validate the given file signature with the existing file signature in the\n   // cache. Returns true if the signature doesn't change or the file did not\n   // exist before. If the signature changes, update the existing signature with\n   // the new one and remove the file from cache.\n-  virtual bool ValidateAndUpdateFileSignature(const string& filename,\n+  virtual bool ValidateAndUpdateFileSignature(const std::string& filename,\n                                               int64_t file_signature) = 0;\n \n   /// Remove all cached blocks for `filename`.\n-  virtual void RemoveFile(const string& filename) = 0;\n+  virtual void RemoveFile(const std::string& filename) = 0;\n \n   /// Remove all cached data.\n   virtual void Flush() = 0;\n \n   /// Accessors for cache parameters.\n   virtual size_t block_size() const = 0;\n   virtual size_t max_bytes() const = 0;\n-  virtual uint64 max_staleness() const = 0;\n+  virtual uint64_t max_staleness() const = 0;\n \n   /// The current size (in bytes) of the cache.\n   virtual size_t CacheSize() const = 0;"
        },
        {
            "sha": "73af26eed2f16b329dde6108867b9e37aeb447f3",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_dns_cache.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 12,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -40,10 +40,11 @@ namespace tsl {\n \n namespace {\n \n-const std::vector<string>& kCachedDomainNames =\n-    *new std::vector<string>{\"www.googleapis.com\", \"storage.googleapis.com\"};\n+const std::vector<std::string>& kCachedDomainNames =\n+    *new std::vector<std::string>{\"www.googleapis.com\",\n+                                  \"storage.googleapis.com\"};\n \n-inline void print_getaddrinfo_error(const string& name,\n+inline void print_getaddrinfo_error(const std::string& name,\n                                     absl::Status return_status) {\n   // Status doesn't map well to EAI type errors.\n   LOG(ERROR) << \"Error resolving \" << name << \": \" << return_status;\n@@ -81,10 +82,10 @@ void GcsDnsCache::AnnotateRequest(HttpRequest* request) {\n \n   CHECK_EQ(kCachedDomainNames.size(), addresses_.size());\n   for (size_t i = 0; i < kCachedDomainNames.size(); ++i) {\n-    const string& name = kCachedDomainNames[i];\n-    const std::vector<string>& addresses = addresses_[i];\n+    const std::string& name = kCachedDomainNames[i];\n+    const std::vector<std::string>& addresses = addresses_[i];\n     if (!addresses.empty()) {\n-      const string& chosen_address =\n+      const std::string& chosen_address =\n           SelectRandomItemUniform(&random_, addresses);\n       request->AddResolveOverride(name, 443, chosen_address);\n       VLOG(1) << \"Annotated DNS mapping: \" << name << \" --> \" << chosen_address;\n@@ -94,7 +95,8 @@ void GcsDnsCache::AnnotateRequest(HttpRequest* request) {\n   }\n }\n \n-/* static */ std::vector<string> GcsDnsCache::ResolveName(const string& name) {\n+/* static */ std::vector<std::string> GcsDnsCache::ResolveName(\n+    const std::string& name) {\n   VLOG(1) << \"Resolving DNS name: \" << name;\n \n   addrinfo hints;\n@@ -182,7 +184,7 @@ void GcsDnsCache::AnnotateRequest(HttpRequest* request) {\n       },\n       retryConfig);\n \n-  std::vector<string> output;\n+  std::vector<std::string> output;\n   if (getaddrinfo_status.ok()) {\n     for (const addrinfo* i = result; i != nullptr; i = i->ai_next) {\n       if (i->ai_family != AF_INET || i->ai_addr->sa_family != AF_INET) {\n@@ -221,11 +223,11 @@ void GcsDnsCache::AnnotateRequest(HttpRequest* request) {\n //\n // Ensures: names.size() == return_value.size()\n \n-std::vector<std::vector<string>> GcsDnsCache::ResolveNames(\n-    const std::vector<string>& names) {\n-  std::vector<std::vector<string>> all_addresses;\n+std::vector<std::vector<std::string>> GcsDnsCache::ResolveNames(\n+    const std::vector<std::string>& names) {\n+  std::vector<std::vector<std::string>> all_addresses;\n   all_addresses.reserve(names.size());\n-  for (const string& name : names) {\n+  for (const std::string& name : names) {\n     all_addresses.push_back(ResolveName(name));\n   }\n   return all_addresses;"
        },
        {
            "sha": "0a84728739441af8ef8dd8cf3cbfaf635618bb83",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_dns_cache.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -52,9 +52,9 @@ class GcsDnsCache {\n   void AnnotateRequest(HttpRequest* request);\n \n  private:\n-  static std::vector<string> ResolveName(const string& name);\n-  static std::vector<std::vector<string>> ResolveNames(\n-      const std::vector<string>& names);\n+  static std::vector<std::string> ResolveName(const std::string& name);\n+  static std::vector<std::vector<std::string>> ResolveNames(\n+      const std::vector<std::string>& names);\n   void WorkerThread();\n \n   // Define a friend class for testing.\n@@ -70,7 +70,7 @@ class GcsDnsCache {\n   const int64_t refresh_rate_secs_;\n \n   // Entries in this vector correspond to entries in kCachedDomainNames.\n-  std::vector<std::vector<string>> addresses_ TF_GUARDED_BY(mu_);\n+  std::vector<std::vector<std::string>> addresses_ TF_GUARDED_BY(mu_);\n };\n \n }  // namespace tsl"
        },
        {
            "sha": "6059ccba3ed056a87e48feb11776f929d045332e",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_dns_cache_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 14,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -23,25 +23,25 @@ namespace tsl {\n \n class TestHttpRequest : public HttpRequest {\n  public:\n-  void SetUri(const string& uri) override {}\n-  void SetRange(uint64 start, uint64 end) override {}\n-  void AddHeader(const string& name, const string& value) override {}\n-  void AddResolveOverride(const string& hostname, int64_t port,\n-                          const string& ip_addr) override {\n+  void SetUri(const std::string& uri) override {}\n+  void SetRange(uint64_t start, uint64_t end) override {}\n+  void AddHeader(const std::string& name, const std::string& value) override {}\n+  void AddResolveOverride(const std::string& hostname, int64_t port,\n+                          const std::string& ip_addr) override {\n     EXPECT_EQ(port, 443) << \"Unexpected port set for hostname: \" << hostname;\n     auto itr = resolve_overrides_.find(hostname);\n     EXPECT_EQ(itr, resolve_overrides_.end())\n         << \"Hostname \" << hostname << \"already in map: \" << itr->second;\n \n     resolve_overrides_.insert(\n-        std::map<string, string>::value_type(hostname, ip_addr));\n+        std::map<std::string, std::string>::value_type(hostname, ip_addr));\n   }\n \n-  void AddAuthBearerHeader(const string& auth_token) override {}\n+  void AddAuthBearerHeader(const std::string& auth_token) override {}\n   void SetRequestStats(HttpRequest::RequestStats* stats) override {}\n   void SetDeleteRequest() override {}\n \n-  absl::Status SetPutFromFile(const string& body_filepath,\n+  absl::Status SetPutFromFile(const std::string& body_filepath,\n                               size_t offset) override {\n     return absl::OkStatus();\n   }\n@@ -52,15 +52,17 @@ class TestHttpRequest : public HttpRequest {\n   void SetResultBufferDirect(char* buffer, size_t size) override {}\n   size_t GetResultBufferDirectBytesTransferred() override { return 0; }\n \n-  string GetResponseHeader(const string& name) const override { return \"\"; }\n-  uint64 GetResponseCode() const override { return 0; }\n+  std::string GetResponseHeader(const std::string& name) const override {\n+    return \"\";\n+  }\n+  uint64_t GetResponseCode() const override { return 0; }\n   absl::Status Send() override { return absl::OkStatus(); }\n-  string EscapeString(const string& str) override { return \"\"; }\n+  std::string EscapeString(const std::string& str) override { return \"\"; }\n \n-  void SetTimeouts(uint32 connection, uint32 inactivity,\n-                   uint32 total) override {}\n+  void SetTimeouts(uint32_t connection, uint32_t inactivity,\n+                   uint32_t total) override {}\n \n-  std::map<string, string> resolve_overrides_;\n+  std::map<std::string, std::string> resolve_overrides_;\n };\n \n // Friend class for testing."
        },
        {
            "sha": "4b23f3032ca06cbc71a9cf4002d23422072f67e8",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_throttle.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -60,7 +60,7 @@ void GcsThrottle::SetConfig(GcsThrottleConfig config) {\n void GcsThrottle::UpdateState() {\n   // TODO(b/72643279): Switch to a monotonic clock.\n   int64_t now = env_time_->GetOverridableNowSeconds();\n-  uint64 delta_secs =\n+  uint64_t delta_secs =\n       std::max(int64_t{0}, now - static_cast<int64_t>(last_updated_secs_));\n   available_tokens_ += delta_secs * config_.token_rate;\n   available_tokens_ = std::min(available_tokens_, config_.bucket_size);"
        },
        {
            "sha": "9fd44e794bac7422e10c484217297dd2b0971330",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_throttle.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -139,7 +139,7 @@ class GcsThrottle {\n    */\n   void UpdateState() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n \n-  inline uint64 request_bytes_to_tokens(size_t num_bytes) {\n+  inline uint64_t request_bytes_to_tokens(size_t num_bytes) {\n     return num_bytes >> 10;\n   }\n \n@@ -150,7 +150,7 @@ class GcsThrottle {\n    * the internal state of the GcsThrottle was updated. This is important when\n    * determining the number of tokens to add to the available_tokens_ pool.\n    */\n-  uint64 last_updated_secs_ TF_GUARDED_BY(mu_) = 0;\n+  uint64_t last_updated_secs_ TF_GUARDED_BY(mu_) = 0;\n \n   /**\n    * available_tokens_ records how many tokens are available to be consumed."
        },
        {
            "sha": "beb87685ef878fc218ceeda934ff89e2b46d41bf",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_throttle_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -25,16 +25,16 @@ namespace {\n \n class TestTime : public EnvTime {\n  public:\n-  uint64 GetOverridableNowNanos() const override {\n+  uint64_t GetOverridableNowNanos() const override {\n     return now_micros_ * kMicrosToNanos;\n   }\n \n-  void SetTime(uint64 now_micros) { now_micros_ = now_micros; }\n+  void SetTime(uint64_t now_micros) { now_micros_ = now_micros; }\n \n   void AdvanceSeconds(int64_t secs) { now_micros_ += secs * kSecondsToMicros; }\n \n  private:\n-  uint64 now_micros_ = 1234567890000000ULL;\n+  uint64_t now_micros_ = 1234567890000000ULL;\n };\n \n class GcsThrottleTest : public ::testing::Test {"
        },
        {
            "sha": "2a84c54dd06ddcce4c1355b19cf7cd807f65716f",
            "filename": "third_party/xla/xla/tsl/platform/cloud/google_auth_provider.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgoogle_auth_provider.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgoogle_auth_provider.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgoogle_auth_provider.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -40,7 +40,7 @@ class GoogleAuthProvider : public AuthProvider {\n   /// \\brief Returns the short-term authentication bearer token.\n   ///\n   /// Safe for concurrent use by multiple threads.\n-  absl::Status GetToken(string* token) override;\n+  absl::Status GetToken(std::string* token) override;\n \n  private:\n   /// \\brief Gets the bearer token from files.\n@@ -59,8 +59,8 @@ class GoogleAuthProvider : public AuthProvider {\n   std::shared_ptr<ComputeEngineMetadataClient> compute_engine_metadata_client_;\n   Env* env_;\n   absl::Mutex mu_;\n-  string current_token_ TF_GUARDED_BY(mu_);\n-  uint64 expiration_timestamp_sec_ TF_GUARDED_BY(mu_) = 0;\n+  std::string current_token_ TF_GUARDED_BY(mu_);\n+  uint64_t expiration_timestamp_sec_ TF_GUARDED_BY(mu_) = 0;\n   GoogleAuthProvider(const GoogleAuthProvider&) = delete;\n   void operator=(const GoogleAuthProvider&) = delete;\n };"
        },
        {
            "sha": "2657e58687d6f7453d24a7f93c3d1713361a853f",
            "filename": "third_party/xla/xla/tsl/platform/cloud/google_auth_provider_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgoogle_auth_provider_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgoogle_auth_provider_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgoogle_auth_provider_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -26,7 +26,7 @@ namespace tsl {\n \n namespace {\n \n-string TestData() {\n+std::string TestData() {\n   return io::JoinPath(testing::XlaSrcRoot(), \"tsl\", \"platform\", \"cloud\",\n                       \"testdata\");\n }\n@@ -35,16 +35,16 @@ class FakeEnv : public EnvWrapper {\n  public:\n   FakeEnv() : EnvWrapper(Env::Default()) {}\n \n-  uint64 NowSeconds() const override { return now; }\n-  uint64 now = 10000;\n+  uint64_t NowSeconds() const override { return now; }\n+  uint64_t now = 10000;\n };\n \n class FakeOAuthClient : public OAuthClient {\n  public:\n   absl::Status GetTokenFromServiceAccountJson(\n       Json::Value json, absl::string_view oauth_server_uri,\n-      absl::string_view scope, string* token,\n-      uint64* expiration_timestamp_sec) override {\n+      absl::string_view scope, std::string* token,\n+      uint64_t* expiration_timestamp_sec) override {\n     provided_credentials_json = json;\n     *token = return_token;\n     *expiration_timestamp_sec = return_expiration_timestamp;\n@@ -53,16 +53,16 @@ class FakeOAuthClient : public OAuthClient {\n \n   /// Retrieves a bearer token using a refresh token.\n   absl::Status GetTokenFromRefreshTokenJson(\n-      Json::Value json, absl::string_view oauth_server_uri, string* token,\n-      uint64* expiration_timestamp_sec) override {\n+      Json::Value json, absl::string_view oauth_server_uri, std::string* token,\n+      uint64_t* expiration_timestamp_sec) override {\n     provided_credentials_json = json;\n     *token = return_token;\n     *expiration_timestamp_sec = return_expiration_timestamp;\n     return absl::OkStatus();\n   }\n \n-  string return_token;\n-  uint64 return_expiration_timestamp;\n+  std::string return_token;\n+  uint64_t return_expiration_timestamp;\n   Json::Value provided_credentials_json;\n };\n \n@@ -103,7 +103,7 @@ TEST_F(GoogleAuthProviderTest, EnvironmentVariable_Caching) {\n   oauth_client->return_token = \"fake-token\";\n   oauth_client->return_expiration_timestamp = env.NowSeconds() + 3600;\n \n-  string token;\n+  std::string token;\n   TF_EXPECT_OK(provider.GetToken(&token));\n   EXPECT_EQ(\"fake-token\", token);\n   EXPECT_EQ(\"fake_key_id\",\n@@ -139,7 +139,7 @@ TEST_F(GoogleAuthProviderTest, GCloudRefreshToken) {\n   oauth_client->return_token = \"fake-token\";\n   oauth_client->return_expiration_timestamp = env.NowSeconds() + 3600;\n \n-  string token;\n+  std::string token;\n   TF_EXPECT_OK(provider.GetToken(&token));\n   EXPECT_EQ(\"fake-token\", token);\n   EXPECT_EQ(\"fake-refresh-token\",\n@@ -185,7 +185,7 @@ TEST_F(GoogleAuthProviderTest, RunningOnGCE) {\n   GoogleAuthProvider provider(std::unique_ptr<OAuthClient>(oauth_client),\n                               metadataClient, &env);\n \n-  string token;\n+  std::string token;\n   TF_EXPECT_OK(provider.GetToken(&token));\n   EXPECT_EQ(\"fake-gce-token\", token);\n \n@@ -213,7 +213,7 @@ TEST_F(GoogleAuthProviderTest, OverrideForTesting) {\n   GoogleAuthProvider provider(std::unique_ptr<OAuthClient>(oauth_client),\n                               metadataClient, &env);\n \n-  string token;\n+  std::string token;\n   TF_EXPECT_OK(provider.GetToken(&token));\n   EXPECT_EQ(\"tokenForTesting\", token);\n }\n@@ -235,7 +235,7 @@ TEST_F(GoogleAuthProviderTest, NothingAvailable) {\n   GoogleAuthProvider provider(std::unique_ptr<OAuthClient>(oauth_client),\n                               metadataClient, &env);\n \n-  string token;\n+  std::string token;\n   TF_EXPECT_OK(provider.GetToken(&token));\n   EXPECT_EQ(\"\", token);\n }\n@@ -250,7 +250,7 @@ TEST_F(GoogleAuthProviderTest, NoGceCheckEnvironmentVariable) {\n   GoogleAuthProvider provider(std::unique_ptr<OAuthClient>(oauth_client),\n                               nullptr, &env);\n \n-  string token;\n+  std::string token;\n   TF_EXPECT_OK(provider.GetToken(&token));\n   EXPECT_EQ(\"\", token);\n "
        },
        {
            "sha": "2a441fee630e32042a617986d7f6845418936732",
            "filename": "third_party/xla/xla/tsl/platform/cloud/http_request.h",
            "status": "modified",
            "additions": 16,
            "deletions": 15,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fhttp_request.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fhttp_request.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fhttp_request.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -80,40 +80,41 @@ class HttpRequest {\n     virtual ~RequestStats() = default;\n \n     /// RecordRequest is called right before a request is sent on the wire.\n-    virtual void RecordRequest(const HttpRequest* request, const string& uri,\n+    virtual void RecordRequest(const HttpRequest* request,\n+                               const std::string& uri,\n                                RequestMethod method) = 0;\n \n     /// RecordResponse is called after the response has been received.\n-    virtual void RecordResponse(const HttpRequest* request, const string& uri,\n-                                RequestMethod method,\n+    virtual void RecordResponse(const HttpRequest* request,\n+                                const std::string& uri, RequestMethod method,\n                                 const absl::Status& result) = 0;\n   };\n \n   HttpRequest() {}\n   virtual ~HttpRequest() {}\n \n   /// Sets the request URI.\n-  virtual void SetUri(const string& uri) = 0;\n+  virtual void SetUri(const std::string& uri) = 0;\n \n   /// \\brief Sets the Range header.\n   ///\n   /// Used for random seeks, for example \"0-999\" returns the first 1000 bytes\n   /// (note that the right border is included).\n-  virtual void SetRange(uint64 start, uint64 end) = 0;\n+  virtual void SetRange(uint64_t start, uint64_t end) = 0;\n \n   /// Sets a request header.\n-  virtual void AddHeader(const string& name, const string& value) = 0;\n+  virtual void AddHeader(const std::string& name, const std::string& value) = 0;\n \n   /// Sets a DNS resolve mapping (to skip DNS resolution).\n   ///\n   /// Note: because GCS is available over HTTPS, we cannot replace the hostname\n   /// in the URI with an IP address, as that will cause the certificate check\n   /// to fail.\n-  virtual void AddResolveOverride(const string& hostname, int64_t port,\n-                                  const string& ip_addr) = 0;\n+  virtual void AddResolveOverride(const std::string& hostname, int64_t port,\n+                                  const std::string& ip_addr) = 0;\n \n   /// Sets the 'Authorization' header to the value of 'Bearer ' + auth_token.\n-  virtual void AddAuthBearerHeader(const string& auth_token) = 0;\n+  virtual void AddAuthBearerHeader(const std::string& auth_token) = 0;\n \n   /// Sets the RequestStats object to use to record the request and response.\n   virtual void SetRequestStats(RequestStats* stats) = 0;\n@@ -125,7 +126,7 @@ class HttpRequest {\n   ///\n   /// The request body will be taken from the specified file starting from\n   /// the given offset.\n-  virtual absl::Status SetPutFromFile(const string& body_filepath,\n+  virtual absl::Status SetPutFromFile(const std::string& body_filepath,\n                                       size_t offset) = 0;\n \n   /// Makes the request a PUT request with an empty body.\n@@ -162,10 +163,10 @@ class HttpRequest {\n   /// \\brief Returns the response headers of a completed request.\n   ///\n   /// If the header is not found, returns an empty string.\n-  virtual string GetResponseHeader(const string& name) const = 0;\n+  virtual std::string GetResponseHeader(const std::string& name) const = 0;\n \n   /// Returns the response code of a completed request.\n-  virtual uint64 GetResponseCode() const = 0;\n+  virtual uint64_t GetResponseCode() const = 0;\n \n   /// \\brief Sends the formed request.\n   ///\n@@ -174,7 +175,7 @@ class HttpRequest {\n   virtual absl::Status Send() = 0;\n \n   // Url encodes str and returns a new string.\n-  virtual string EscapeString(const string& str) = 0;\n+  virtual std::string EscapeString(const std::string& str) = 0;\n \n   /// \\brief Set timeouts for this request.\n   ///\n@@ -183,8 +184,8 @@ class HttpRequest {\n   /// we should wait between additional responses from the server. Finally the\n   /// total parameter controls the maximum total connection time to prevent\n   /// hanging indefinitely.\n-  virtual void SetTimeouts(uint32 connection, uint32 inactivity,\n-                           uint32 total) = 0;\n+  virtual void SetTimeouts(uint32_t connection, uint32_t inactivity,\n+                           uint32_t total) = 0;\n \n   HttpRequest(const HttpRequest&) = delete;\n   void operator=(const HttpRequest&) = delete;"
        },
        {
            "sha": "06fd8fe8eef7c128a6ec87b1ef9b0668d970b560",
            "filename": "third_party/xla/xla/tsl/platform/cloud/now_seconds_env.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fnow_seconds_env.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fnow_seconds_env.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fnow_seconds_env.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -28,13 +28,13 @@ class NowSecondsEnv : public EnvWrapper {\n   NowSecondsEnv() : EnvWrapper(Env::Default()) {}\n \n   /// The current (fake) timestamp.\n-  uint64 NowSeconds() const override {\n+  uint64_t NowSeconds() const override {\n     absl::MutexLock lock(mu_);\n     return now_;\n   }\n \n   /// Set the current (fake) timestamp.\n-  void SetNowSeconds(uint64 now) {\n+  void SetNowSeconds(uint64_t now) {\n     absl::MutexLock lock(mu_);\n     now_ = now;\n   }\n@@ -43,7 +43,7 @@ class NowSecondsEnv : public EnvWrapper {\n   mutable absl::Mutex mu_;\n \n   /// The NowSeconds() value that this Env will return.\n-  uint64 now_ = 1;\n+  uint64_t now_ = 1;\n };\n \n }  // namespace tsl"
        },
        {
            "sha": "45a150efdfe74fd41a2e947d6e0085c0f45abe40",
            "filename": "third_party/xla/xla/tsl/platform/cloud/oauth_client.h",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Foauth_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Foauth_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Foauth_client.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -39,18 +39,19 @@ class OAuthClient {\n   /// with the client's private key.\n   virtual absl::Status GetTokenFromServiceAccountJson(\n       Json::Value json, absl::string_view oauth_server_uri,\n-      absl::string_view scope, string* token, uint64* expiration_timestamp_sec);\n+      absl::string_view scope, std::string* token,\n+      uint64_t* expiration_timestamp_sec);\n \n   /// Retrieves a bearer token using a refresh token.\n   virtual absl::Status GetTokenFromRefreshTokenJson(\n-      Json::Value json, absl::string_view oauth_server_uri, string* token,\n-      uint64* expiration_timestamp_sec);\n+      Json::Value json, absl::string_view oauth_server_uri, std::string* token,\n+      uint64_t* expiration_timestamp_sec);\n \n   /// Parses the JSON response with the token from an OAuth 2.0 server.\n   virtual absl::Status ParseOAuthResponse(absl::string_view response,\n-                                          uint64 request_timestamp_sec,\n-                                          string* token,\n-                                          uint64* expiration_timestamp_sec);\n+                                          uint64_t request_timestamp_sec,\n+                                          std::string* token,\n+                                          uint64_t* expiration_timestamp_sec);\n \n  private:\n   std::unique_ptr<HttpRequest::Factory> http_request_factory_;"
        },
        {
            "sha": "58113ce78d63d5ccba9777f555f4739784bb4f1f",
            "filename": "third_party/xla/xla/tsl/platform/cloud/oauth_client_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Foauth_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Foauth_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Foauth_client_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -31,7 +31,7 @@ limitations under the License.\n namespace tsl {\n namespace {\n \n-string TestData() {\n+std::string TestData() {\n   return io::JoinPath(testing::XlaSrcRoot(), \"tsl\", \"platform\", \"cloud\",\n                       \"testdata\");\n }\n@@ -47,24 +47,24 @@ class FakeEnv : public EnvWrapper {\n  public:\n   FakeEnv() : EnvWrapper(Env::Default()) {}\n \n-  uint64 NowSeconds() const override { return now; }\n-  uint64 now = 10000;\n+  uint64_t NowSeconds() const override { return now; }\n+  uint64_t now = 10000;\n };\n \n }  // namespace\n \n TEST(OAuthClientTest, ParseOAuthResponse) {\n-  const uint64 request_timestamp = 100;\n-  string token;\n-  uint64 expiration_timestamp;\n+  const uint64_t request_timestamp = 100;\n+  std::string token;\n+  uint64_t expiration_timestamp;\n   TF_EXPECT_OK(OAuthClient().ParseOAuthResponse(kTokenJson, request_timestamp,\n                                                 &token, &expiration_timestamp));\n   EXPECT_EQ(\"WITH_FAKE_ACCESS_TOKEN_TEST_SHOULD_BE_HAPPY\", token);\n   EXPECT_EQ(4020, expiration_timestamp);\n }\n \n TEST(OAuthClientTest, GetTokenFromRefreshTokenJson) {\n-  const string credentials_json = R\"(\n+  const std::string credentials_json = R\"(\n       {\n         \"client_id\": \"test_client_id\",\n         \"client_secret\": \"@@@test_client_secret@@@\",\n@@ -85,8 +85,8 @@ TEST(OAuthClientTest, GetTokenFromRefreshTokenJson) {\n   OAuthClient client(std::unique_ptr<HttpRequest::Factory>(\n                          new FakeHttpRequestFactory(&requests)),\n                      &env);\n-  string token;\n-  uint64 expiration_timestamp;\n+  std::string token;\n+  uint64_t expiration_timestamp;\n   TF_EXPECT_OK(client.GetTokenFromRefreshTokenJson(\n       json, \"https://www.googleapis.com/oauth2/v3/token\", &token,\n       &expiration_timestamp));\n@@ -102,16 +102,16 @@ TEST(OAuthClientTest, GetTokenFromServiceAccountJson) {\n   Json::Reader reader;\n   ASSERT_TRUE(reader.parse(credentials, json));\n \n-  string post_body;\n+  std::string post_body;\n   std::vector<HttpRequest*> requests(\n       {new FakeHttpRequest(\"Uri: https://www.googleapis.com/oauth2/v3/token\\n\",\n                            kTokenJson, &post_body)});\n   FakeEnv env;\n   OAuthClient client(std::unique_ptr<HttpRequest::Factory>(\n                          new FakeHttpRequestFactory(&requests)),\n                      &env);\n-  string token;\n-  uint64 expiration_timestamp;\n+  std::string token;\n+  uint64_t expiration_timestamp;\n   TF_EXPECT_OK(client.GetTokenFromServiceAccountJson(\n       json, \"https://www.googleapis.com/oauth2/v3/token\",\n       \"https://test-token-scope.com\", &token, &expiration_timestamp));\n@@ -131,15 +131,15 @@ TEST(OAuthClientTest, GetTokenFromServiceAccountJson) {\n             grant_type);\n \n   int last_dot = assertion.rfind('.');\n-  string header_dot_claim(assertion.substr(0, last_dot));\n-  string signature_encoded(assertion.substr(last_dot + 1));\n+  std::string header_dot_claim(assertion.substr(0, last_dot));\n+  std::string signature_encoded(assertion.substr(last_dot + 1));\n \n   // Check that 'signature' signs 'header_dot_claim'.\n \n   // Read the serialized public key.\n   std::ifstream public_key_stream(\n       io::JoinPath(TestData(), \"service_account_public_key.txt\"));\n-  string public_key_serialized(\n+  std::string public_key_serialized(\n       (std::istreambuf_iterator<char>(public_key_stream)),\n       (std::istreambuf_iterator<char>()));\n \n@@ -152,7 +152,7 @@ TEST(OAuthClientTest, GetTokenFromServiceAccountJson) {\n   EXPECT_TRUE(public_key) << \"Could not load the public key from testdata.\";\n \n   // Deserialize the signature.\n-  string signature;\n+  std::string signature;\n   TF_EXPECT_OK(Base64Decode(signature_encoded, &signature));\n \n   // Actually cryptographically verify the signature.\n@@ -178,10 +178,10 @@ TEST(OAuthClientTest, GetTokenFromServiceAccountJson) {\n \n   // Now check the content of the header and the claim.\n   int dot = header_dot_claim.find_last_of('.');\n-  string header_encoded = header_dot_claim.substr(0, dot);\n-  string claim_encoded = header_dot_claim.substr(dot + 1);\n+  std::string header_encoded = header_dot_claim.substr(0, dot);\n+  std::string claim_encoded = header_dot_claim.substr(dot + 1);\n \n-  string header, claim;\n+  std::string header, claim;\n   TF_EXPECT_OK(Base64Decode(header_encoded, &header));\n   TF_EXPECT_OK(Base64Decode(claim_encoded, &claim));\n "
        },
        {
            "sha": "fc4838af1d7aab300003e1f5b1856074f1bc4777",
            "filename": "third_party/xla/xla/tsl/platform/cloud/ram_file_block_cache.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -169,7 +169,7 @@ absl::Status RamFileBlockCache::MaybeFetch(\n       \"Control flow should never reach the end of RamFileBlockCache::Fetch.\");\n }\n \n-absl::Status RamFileBlockCache::Read(const string& filename, size_t offset,\n+absl::Status RamFileBlockCache::Read(const std::string& filename, size_t offset,\n                                      size_t n, char* buffer,\n                                      size_t* bytes_transferred) {\n   *bytes_transferred = 0;\n@@ -232,8 +232,8 @@ absl::Status RamFileBlockCache::Read(const string& filename, size_t offset,\n   return absl::OkStatus();\n }\n \n-bool RamFileBlockCache::ValidateAndUpdateFileSignature(const string& filename,\n-                                                       int64_t file_signature) {\n+bool RamFileBlockCache::ValidateAndUpdateFileSignature(\n+    const std::string& filename, int64_t file_signature) {\n   absl::MutexLock lock(mu_);\n   auto it = file_signature_map_.find(filename);\n   if (it != file_signature_map_.end()) {\n@@ -258,7 +258,7 @@ void RamFileBlockCache::Prune() {\n   while (\n       !stop_pruning_thread_.WaitForNotificationWithTimeout(absl::Seconds(1))) {\n     absl::MutexLock lock(mu_);\n-    uint64 now = env_->NowSeconds();\n+    uint64_t now = env_->NowSeconds();\n     while (!lra_list_.empty()) {\n       auto it = block_map_.find(lra_list_.back());\n       if (now - it->second->timestamp <= max_staleness_) {\n@@ -280,12 +280,12 @@ void RamFileBlockCache::Flush() {\n   cache_size_ = 0;\n }\n \n-void RamFileBlockCache::RemoveFile(const string& filename) {\n+void RamFileBlockCache::RemoveFile(const std::string& filename) {\n   absl::MutexLock lock(mu_);\n   RemoveFile_Locked(filename);\n }\n \n-void RamFileBlockCache::RemoveFile_Locked(const string& filename) {\n+void RamFileBlockCache::RemoveFile_Locked(const std::string& filename) {\n   Key begin = std::make_pair(filename, 0);\n   auto it = block_map_.lower_bound(begin);\n   while (it != block_map_.end() && it->first.first == filename) {"
        },
        {
            "sha": "6b1236d0bd6d6ced8929c56ea14d81a87b60c1fb",
            "filename": "third_party/xla/xla/tsl/platform/cloud/ram_file_block_cache.h",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -46,12 +46,12 @@ class RamFileBlockCache : public FileBlockCache {\n   /// cache is constructed. The returned Status should be OK as long as the\n   /// read from the remote filesystem succeeded (similar to the semantics of the\n   /// read(2) system call).\n-  typedef std::function<absl::Status(const string& filename, size_t offset,\n+  typedef std::function<absl::Status(const std::string& filename, size_t offset,\n                                      size_t buffer_size, char* buffer,\n                                      size_t* bytes_transferred)>\n       BlockFetcher;\n \n-  RamFileBlockCache(size_t block_size, size_t max_bytes, uint64 max_staleness,\n+  RamFileBlockCache(size_t block_size, size_t max_bytes, uint64_t max_staleness,\n                     BlockFetcher block_fetcher, Env* env = Env::Default())\n       : block_size_(block_size),\n         max_bytes_(max_bytes),\n@@ -89,27 +89,27 @@ class RamFileBlockCache : public FileBlockCache {\n   ///    placed in `out`.\n   /// 4) OK otherwise (i.e. the read succeeded, and at least one byte was placed\n   ///    in `out`).\n-  absl::Status Read(const string& filename, size_t offset, size_t n,\n+  absl::Status Read(const std::string& filename, size_t offset, size_t n,\n                     char* buffer, size_t* bytes_transferred) override;\n \n   // Validate the given file signature with the existing file signature in the\n   // cache. Returns true if the signature doesn't change or the file doesn't\n   // exist before. If the signature changes, update the existing signature with\n   // the new one and remove the file from cache.\n-  bool ValidateAndUpdateFileSignature(const string& filename,\n+  bool ValidateAndUpdateFileSignature(const std::string& filename,\n                                       int64_t file_signature) override\n       TF_LOCKS_EXCLUDED(mu_);\n \n   /// Remove all cached blocks for `filename`.\n-  void RemoveFile(const string& filename) override TF_LOCKS_EXCLUDED(mu_);\n+  void RemoveFile(const std::string& filename) override TF_LOCKS_EXCLUDED(mu_);\n \n   /// Remove all cached data.\n   void Flush() override TF_LOCKS_EXCLUDED(mu_);\n \n   /// Accessors for cache parameters.\n   size_t block_size() const override { return block_size_; }\n   size_t max_bytes() const override { return max_bytes_; }\n-  uint64 max_staleness() const override { return max_staleness_; }\n+  uint64_t max_staleness() const override { return max_staleness_; }\n \n   /// The current size (in bytes) of the cache.\n   size_t CacheSize() const override TF_LOCKS_EXCLUDED(mu_);\n@@ -127,7 +127,7 @@ class RamFileBlockCache : public FileBlockCache {\n   /// The maximum number of bytes (sum of block sizes) allowed in the LRU cache.\n   const size_t max_bytes_;\n   /// The maximum staleness of any block in the LRU cache, in seconds.\n-  const uint64 max_staleness_;\n+  const uint64_t max_staleness_;\n   /// The callback to read a block from the underlying filesystem.\n   const BlockFetcher block_fetcher_;\n   /// The Env from which we read timestamps.\n@@ -136,7 +136,7 @@ class RamFileBlockCache : public FileBlockCache {\n   /// \\brief The key type for the file block cache.\n   ///\n   /// The file block cache key is a {filename, offset} pair.\n-  typedef std::pair<string, size_t> Key;\n+  typedef std::pair<std::string, size_t> Key;\n \n   /// \\brief The state of a block.\n   ///\n@@ -175,7 +175,7 @@ class RamFileBlockCache : public FileBlockCache {\n     /// A list iterator pointing to the block's position in the LRA list.\n     std::list<Key>::iterator lra_iterator;\n     /// The timestamp (seconds since epoch) at which the block was cached.\n-    uint64 timestamp;\n+    uint64_t timestamp;\n     /// Mutex to guard state variable\n     absl::Mutex mu;\n     /// The state of the block.\n@@ -209,7 +209,7 @@ class RamFileBlockCache : public FileBlockCache {\n       TF_LOCKS_EXCLUDED(mu_);\n \n   /// Remove all blocks of a file, with mu_ already held.\n-  void RemoveFile_Locked(const string& filename)\n+  void RemoveFile_Locked(const std::string& filename)\n       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n \n   /// Remove the block `entry` from the block map and LRU list, and update the\n@@ -243,7 +243,7 @@ class RamFileBlockCache : public FileBlockCache {\n   size_t cache_size_ TF_GUARDED_BY(mu_) = 0;\n \n   // A filename->file_signature map.\n-  std::map<string, int64_t> file_signature_map_ TF_GUARDED_BY(mu_);\n+  std::map<std::string, int64_t> file_signature_map_ TF_GUARDED_BY(mu_);\n };\n \n }  // namespace tsl"
        },
        {
            "sha": "0148f01fcd2377aedb06577767949622269efb06",
            "filename": "third_party/xla/xla/tsl/platform/cloud/ram_file_block_cache_test.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 24,
            "changes": 49,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache_test.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -29,7 +29,7 @@ limitations under the License.\n namespace tsl {\n namespace {\n \n-absl::Status ReadCache(RamFileBlockCache* cache, const string& filename,\n+absl::Status ReadCache(RamFileBlockCache* cache, const std::string& filename,\n                        size_t offset, size_t n, std::vector<char>* out) {\n   out->clear();\n   out->resize(n, 0);\n@@ -42,7 +42,7 @@ absl::Status ReadCache(RamFileBlockCache* cache, const string& filename,\n }\n \n TEST(RamFileBlockCacheTest, IsCacheEnabled) {\n-  auto fetcher = [](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [](const std::string& filename, size_t offset, size_t n,\n                     char* buffer, size_t* bytes_transferred) {\n     // Do nothing.\n     return absl::OkStatus();\n@@ -60,14 +60,14 @@ TEST(RamFileBlockCacheTest, IsCacheEnabled) {\n \n TEST(RamFileBlockCacheTest, ValidateAndUpdateFileSignature) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, size_t* bytes_transferred) {\n     calls++;\n     memset(buffer, 'x', n);\n     *bytes_transferred = n;\n     return absl::OkStatus();\n   };\n-  string filename = \"file\";\n+  std::string filename = \"file\";\n   RamFileBlockCache cache(16, 32, 0, fetcher);\n   std::vector<char> out;\n \n@@ -88,12 +88,12 @@ TEST(RamFileBlockCacheTest, ValidateAndUpdateFileSignature) {\n }\n \n TEST(RamFileBlockCacheTest, PassThrough) {\n-  const string want_filename = \"foo/bar\";\n+  const std::string want_filename = \"foo/bar\";\n   const size_t want_offset = 42;\n   const size_t want_n = 1024;\n   int calls = 0;\n   auto fetcher = [&calls, want_filename, want_offset, want_n](\n-                     const string& got_filename, size_t got_offset,\n+                     const std::string& got_filename, size_t got_offset,\n                      size_t got_n, char* buffer, size_t* bytes_transferred) {\n     EXPECT_EQ(got_filename, want_filename);\n     EXPECT_EQ(got_offset, want_offset);\n@@ -129,7 +129,7 @@ TEST(RamFileBlockCacheTest, BlockAlignment) {\n     buf.push_back(i);\n   }\n   // The fetcher just fetches slices of the buffer.\n-  auto fetcher = [&buf](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&buf](const std::string& filename, size_t offset, size_t n,\n                         char* buffer, size_t* bytes_transferred) {\n     if (offset < buf.size()) {\n       size_t bytes_to_copy = std::min<size_t>(buf.size() - offset, n);\n@@ -174,8 +174,8 @@ TEST(RamFileBlockCacheTest, BlockAlignment) {\n TEST(RamFileBlockCacheTest, CacheHits) {\n   const size_t block_size = 16;\n   std::set<size_t> calls;\n-  auto fetcher = [&calls, block_size](const string& filename, size_t offset,\n-                                      size_t n, char* buffer,\n+  auto fetcher = [&calls, block_size](const std::string& filename,\n+                                      size_t offset, size_t n, char* buffer,\n                                       size_t* bytes_transferred) {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset % block_size, 0);\n@@ -185,7 +185,7 @@ TEST(RamFileBlockCacheTest, CacheHits) {\n     *bytes_transferred = n;\n     return absl::OkStatus();\n   };\n-  const uint32 block_count = 256;\n+  const uint32_t block_count = 256;\n   RamFileBlockCache cache(block_size, block_count * block_size, 0, fetcher);\n   std::vector<char> out;\n   out.resize(block_count, 0);\n@@ -207,7 +207,7 @@ TEST(RamFileBlockCacheTest, OutOfRange) {\n   bool first_block = false;\n   bool second_block = false;\n   auto fetcher = [block_size, file_size, &first_block, &second_block](\n-                     const string& filename, size_t offset, size_t n,\n+                     const std::string& filename, size_t offset, size_t n,\n                      char* buffer, size_t* bytes_transferred) {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset % block_size, 0);\n@@ -250,8 +250,9 @@ TEST(RamFileBlockCacheTest, Inconsistent) {\n   // where we expected complete blocks.\n   const size_t block_size = 16;\n   // This fetcher returns OK but only fills in one byte for any offset.\n-  auto fetcher = [block_size](const string& filename, size_t offset, size_t n,\n-                              char* buffer, size_t* bytes_transferred) {\n+  auto fetcher = [block_size](const std::string& filename, size_t offset,\n+                              size_t n, char* buffer,\n+                              size_t* bytes_transferred) {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset % block_size, 0);\n     EXPECT_GE(n, 1);\n@@ -273,8 +274,8 @@ TEST(RamFileBlockCacheTest, Inconsistent) {\n TEST(RamFileBlockCacheTest, LRU) {\n   const size_t block_size = 16;\n   std::list<size_t> calls;\n-  auto fetcher = [&calls, block_size](const string& filename, size_t offset,\n-                                      size_t n, char* buffer,\n+  auto fetcher = [&calls, block_size](const std::string& filename,\n+                                      size_t offset, size_t n, char* buffer,\n                                       size_t* bytes_transferred) {\n     EXPECT_EQ(n, block_size);\n     EXPECT_FALSE(calls.empty()) << \"at offset = \" << offset;\n@@ -286,7 +287,7 @@ TEST(RamFileBlockCacheTest, LRU) {\n     *bytes_transferred = n;\n     return absl::OkStatus();\n   };\n-  const uint32 block_count = 2;\n+  const uint32_t block_count = 2;\n   RamFileBlockCache cache(block_size, block_count * block_size, 0, fetcher);\n   std::vector<char> out;\n   // Read blocks from the cache, and verify the LRU behavior based on the\n@@ -321,7 +322,7 @@ TEST(RamFileBlockCacheTest, LRU) {\n \n TEST(RamFileBlockCacheTest, MaxStaleness) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, size_t* bytes_transferred) {\n     calls++;\n     memset(buffer, 'x', n);\n@@ -361,7 +362,7 @@ TEST(RamFileBlockCacheTest, MaxStaleness) {\n \n TEST(RamFileBlockCacheTest, RemoveFile) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, size_t* bytes_transferred) {\n     calls++;\n     char c = (filename == \"a\") ? 'a' : (filename == \"b\") ? 'b' : 'x';\n@@ -423,7 +424,7 @@ TEST(RamFileBlockCacheTest, RemoveFile) {\n \n TEST(RamFileBlockCacheTest, Prune) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, size_t* bytes_transferred) {\n     calls++;\n     memset(buffer, 'x', n);\n@@ -433,7 +434,7 @@ TEST(RamFileBlockCacheTest, Prune) {\n   std::vector<char> out;\n   // Our fake environment is initialized with the current timestamp.\n   std::unique_ptr<NowSecondsEnv> env(new NowSecondsEnv);\n-  uint64 now = Env::Default()->NowSeconds();\n+  uint64_t now = Env::Default()->NowSeconds();\n   env->SetNowSeconds(now);\n   RamFileBlockCache cache(8, 32, 1 /* max staleness */, fetcher, env.get());\n   // Read three blocks into the cache, and advance the timestamp by one second\n@@ -460,7 +461,7 @@ TEST(RamFileBlockCacheTest, Prune) {\n   // timestamp of `now` + 2, file \"a\" is stale because its first block is stale,\n   // but file \"b\" is not stale yet. Thus, once the pruning thread wakes up (in\n   // one second of wall time), it should remove \"a\" and leave \"b\" alone.\n-  uint64 start = Env::Default()->NowSeconds();\n+  uint64_t start = Env::Default()->NowSeconds();\n   do {\n     Env::Default()->SleepForMicroseconds(100000);\n   } while (cache.CacheSize() == 24 && Env::Default()->NowSeconds() - start < 3);\n@@ -488,7 +489,7 @@ TEST(RamFileBlockCacheTest, ParallelReads) {\n   absl::BlockingCounter counter(callers);\n   absl::Notification notification;\n   auto fetcher = [&counter, &notification](\n-                     const string& filename, size_t offset, size_t n,\n+                     const std::string& filename, size_t offset, size_t n,\n                      char* buffer, size_t* bytes_transferred) {\n     if (counter.DecrementCount()) {\n       notification.Notify();\n@@ -529,7 +530,7 @@ TEST(RamFileBlockCacheTest, CoalesceConcurrentReads) {\n   int num_requests = 0;\n   absl::Notification notification;\n   auto fetcher = [&num_requests, &notification, block_size](\n-                     const string& filename, size_t offset, size_t n,\n+                     const std::string& filename, size_t offset, size_t n,\n                      char* buffer, size_t* bytes_transferred) {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset, 0);\n@@ -559,7 +560,7 @@ TEST(RamFileBlockCacheTest, CoalesceConcurrentReads) {\n \n TEST(RamFileBlockCacheTest, Flush) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, size_t* bytes_transferred) {\n     calls++;\n     memset(buffer, 'x', n);"
        },
        {
            "sha": "9bb1fc8f77106d0bfc8b2ac9e8d7646af9aebf21",
            "filename": "third_party/xla/xla/tsl/platform/cloud/time_util.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ftime_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ftime_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ftime_util.cc?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -34,7 +34,7 @@ constexpr int64_t kNanosecondsPerSecond = 1000 * 1000 * 1000;\n \n // Only implements one special case of RFC 3339 which is returned by\n // GCS API, e.g 2016-04-29T23:15:24.896Z.\n-absl::Status ParseRfc3339Time(const string& time, int64_t* mtime_nsec) {\n+absl::Status ParseRfc3339Time(const std::string& time, int64_t* mtime_nsec) {\n   tm parsed{0};\n   float seconds;\n   if (sscanf(time.c_str(), \"%4d-%2d-%2dT%2d:%2d:%fZ\", &(parsed.tm_year),"
        },
        {
            "sha": "0d0ab557b6d7143c087f260671505ebddcac31f2",
            "filename": "third_party/xla/xla/tsl/platform/cloud/time_util.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ftime_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ftime_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Ftime_util.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -22,7 +22,7 @@ namespace tsl {\n \n /// Parses the timestamp in RFC 3339 format and returns it\n /// as nanoseconds since epoch.\n-absl::Status ParseRfc3339Time(const string& time, int64_t* mtime_nsec);\n+absl::Status ParseRfc3339Time(const std::string& time, int64_t* mtime_nsec);\n \n }  // namespace tsl\n "
        },
        {
            "sha": "5c61e2af0df6ed3f6036a99041136610b8b61fa0",
            "filename": "third_party/xla/xla/tsl/platform/cloud/zone_provider.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fzone_provider.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b117d315d3c55296ed8138586da5aae54b5c7376/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fzone_provider.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fzone_provider.h?ref=b117d315d3c55296ed8138586da5aae54b5c7376",
            "patch": "@@ -34,9 +34,9 @@ class ZoneProvider {\n   /// Returns an empty string in the case where the zone does not match the\n   /// expected format\n   /// Safe for concurrent use by multiple threads.\n-  virtual absl::Status GetZone(string* zone) = 0;\n+  virtual absl::Status GetZone(std::string* zone) = 0;\n \n-  static absl::Status GetZone(ZoneProvider* provider, string* zone) {\n+  static absl::Status GetZone(ZoneProvider* provider, std::string* zone) {\n     if (!provider) {\n       return errors::Internal(\"Zone provider is required.\");\n     }"
        }
    ],
    "stats": {
        "total": 373,
        "additions": 190,
        "deletions": 183
    }
}