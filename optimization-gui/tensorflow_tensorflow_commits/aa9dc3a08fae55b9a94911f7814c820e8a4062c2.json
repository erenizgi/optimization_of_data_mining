{
    "author": "allanrenucci",
    "message": "Clean up `StreamExecutor` plugin registration.\n\nThis also fixes a potential race condition. Not all accesses to the factory map were synchronised.\n\nPiperOrigin-RevId: 803536714",
    "sha": "aa9dc3a08fae55b9a94911f7814c820e8a4062c2",
    "files": [
        {
            "sha": "1edbe132a78d39271c6b705f604eabff7461a4a1",
            "filename": "third_party/xla/xla/stream_executor/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa9dc3a08fae55b9a94911f7814c820e8a4062c2/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa9dc3a08fae55b9a94911f7814c820e8a4062c2/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD?ref=aa9dc3a08fae55b9a94911f7814c820e8a4062c2",
            "patch": "@@ -652,10 +652,13 @@ cc_library(\n         \":dnn\",\n         \":fft\",\n         \":platform\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/synchronization\",\n     ],\n )"
        },
        {
            "sha": "f16a4f6707c35cfe29047e411112f77c843b0282",
            "filename": "third_party/xla/xla/stream_executor/plugin_registry.cc",
            "status": "modified",
            "additions": 65,
            "deletions": 78,
            "changes": 143,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa9dc3a08fae55b9a94911f7814c820e8a4062c2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fplugin_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa9dc3a08fae55b9a94911f7814c820e8a4062c2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fplugin_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fplugin_registry.cc?ref=aa9dc3a08fae55b9a94911f7814c820e8a4062c2",
            "patch": "@@ -15,112 +15,99 @@ limitations under the License.\n \n #include \"xla/stream_executor/plugin_registry.h\"\n \n-#include <optional>\n #include <string>\n \n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_format.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"xla/stream_executor/platform.h\"\n \n namespace stream_executor {\n \n-// Returns the string representation of the specified PluginKind.\n-std::string PluginKindString(PluginKind plugin_kind) {\n-  switch (plugin_kind) {\n-    case PluginKind::kBlas:\n-      return \"BLAS\";\n-    case PluginKind::kDnn:\n-      return \"DNN\";\n-    case PluginKind::kFft:\n-      return \"FFT\";\n-    case PluginKind::kInvalid:\n-    default:\n-      return \"kInvalid\";\n-  }\n-}\n-\n /* static */ PluginRegistry* PluginRegistry::Instance() {\n   static PluginRegistry* instance = new PluginRegistry();\n   return instance;\n }\n \n-template <typename FACTORY_TYPE>\n-absl::Status PluginRegistry::RegisterFactoryInternal(\n-    const std::string& plugin_name, FACTORY_TYPE factory,\n-    std::optional<FACTORY_TYPE>* factories) {\n-  absl::MutexLock lock(&registry_mutex_);\n+template <typename FactoryT>\n+PluginKind GetPluginKind() {\n+  if constexpr (std::is_same_v<FactoryT, PluginRegistry::BlasFactory>) {\n+    return PluginKind::kBlas;\n+  } else if constexpr (std::is_same_v<FactoryT, PluginRegistry::DnnFactory>) {\n+    return PluginKind::kDnn;\n+  } else if constexpr (std::is_same_v<FactoryT, PluginRegistry::FftFactory>) {\n+    return PluginKind::kFft;\n+  } else {\n+    static_assert(false, \"Unsupported factory type\");\n+  }\n+}\n+template <typename FactoryT>\n+absl::string_view GetPluginName() {\n+  if constexpr (std::is_same_v<FactoryT, PluginRegistry::BlasFactory>) {\n+    return \"BLAS\";\n+  } else if constexpr (std::is_same_v<FactoryT, PluginRegistry::DnnFactory>) {\n+    return \"DNN\";\n+  } else if constexpr (std::is_same_v<FactoryT, PluginRegistry::FftFactory>) {\n+    return \"FFT\";\n+  } else {\n+    static_assert(false, \"Unsupported factory type\");\n+  }\n+}\n \n-  if (factories->has_value()) {\n+template <typename FactoryT>\n+absl::Status PluginRegistry::RegisterFactory(Platform::Id platform_id,\n+                                             const std::string& name,\n+                                             FactoryT factory) {\n+  PluginKind plugin_kind = GetPluginKind<FactoryT>();\n+  absl::MutexLock lock(&registry_mutex_);\n+  auto [_, inserted] = factories_.insert({{platform_id, plugin_kind}, factory});\n+  if (!inserted) {\n     return absl::AlreadyExistsError(\n         absl::StrFormat(\"Attempting to register factory for plugin %s when \"\n                         \"one has already been registered\",\n-                        plugin_name));\n+                        name));\n   }\n-\n-  (*factories) = factory;\n   return absl::OkStatus();\n }\n \n-bool PluginRegistry::HasFactory(Platform::Id platform_id,\n-                                PluginKind plugin_kind) const {\n-  auto iter = factories_.find(platform_id);\n-  if (iter == factories_.end()) {\n-    return false;\n-  }\n-\n-  switch (plugin_kind) {\n-    case PluginKind::kBlas:\n-      return iter->second.blas.has_value();\n-    case PluginKind::kDnn:\n-      return iter->second.dnn.has_value();\n-    case PluginKind::kFft:\n-      return iter->second.fft.has_value();\n-    default:\n-      break;\n+template <typename FactoryT>\n+absl::StatusOr<FactoryT> PluginRegistry::GetFactory(\n+    Platform::Id platform_id) const {\n+  PluginKind plugin_kind = GetPluginKind<FactoryT>();\n+  absl::MutexLock lock(&registry_mutex_);\n+  auto it = factories_.find({platform_id, plugin_kind});\n+  if (it == factories_.end()) {\n+    absl::string_view name = GetPluginName<FactoryT>();\n+    return absl::FailedPreconditionError(\n+        absl::StrFormat(\"No suitable %s plugin registered. Have you linked in \"\n+                        \"a %s-providing plugin?\",\n+                        name, name));\n   }\n+  return std::get<FactoryT>(it->second);\n+}\n \n-  LOG(ERROR) << \"Invalid plugin kind specified: \"\n-             << PluginKindString(plugin_kind);\n-  return false;\n+bool PluginRegistry::HasFactory(Platform::Id platform_id,\n+                                PluginKind plugin_kind) const {\n+  absl::MutexLock lock(&registry_mutex_);\n+  return factories_.contains({platform_id, plugin_kind});\n }\n \n // Explicit instantiations to support types exposed in user/public API.\n-#define EMIT_PLUGIN_SPECIALIZATIONS(FACTORY_TYPE, FACTORY_VAR, PLUGIN_STRING) \\\n-                                                                              \\\n-  template absl::Status                                                       \\\n-  PluginRegistry::RegisterFactoryInternal<PluginRegistry::FACTORY_TYPE>(      \\\n-      const std::string& plugin_name, PluginRegistry::FACTORY_TYPE factory,   \\\n-      std::optional<PluginRegistry::FACTORY_TYPE>* factories);                \\\n-                                                                              \\\n-  template <>                                                                 \\\n-  absl::Status PluginRegistry::RegisterFactory<PluginRegistry::FACTORY_TYPE>( \\\n-      Platform::Id platform_id, const std::string& name,                      \\\n-      PluginRegistry::FACTORY_TYPE factory) {                                 \\\n-    return RegisterFactoryInternal(name, factory,                             \\\n-                                   &factories_[platform_id].FACTORY_VAR);     \\\n-  }                                                                           \\\n-                                                                              \\\n-  template <>                                                                 \\\n-  absl::StatusOr<PluginRegistry::FACTORY_TYPE> PluginRegistry::GetFactory(    \\\n-      Platform::Id platform_id) {                                             \\\n-    auto plugin_id = factories_[platform_id].FACTORY_VAR;                     \\\n-                                                                              \\\n-    if (!plugin_id.has_value()) {                                             \\\n-      return absl::FailedPreconditionError(                                   \\\n-          \"No suitable \" PLUGIN_STRING                                        \\\n-          \" plugin registered. Have you linked in a \" PLUGIN_STRING           \\\n-          \"-providing plugin?\");                                              \\\n-    } else {                                                                  \\\n-      VLOG(2) << \"Selecting default \" PLUGIN_STRING \" plugin\";                \\\n-    }                                                                         \\\n-    return factories_[platform_id].FACTORY_VAR.value();                       \\\n-  }\n-\n-EMIT_PLUGIN_SPECIALIZATIONS(BlasFactory, blas, \"BLAS\");\n-EMIT_PLUGIN_SPECIALIZATIONS(DnnFactory, dnn, \"DNN\");\n-EMIT_PLUGIN_SPECIALIZATIONS(FftFactory, fft, \"FFT\");\n+#define EMIT_PLUGIN_SPECIALIZATIONS(FACTORY_TYPE)                \\\n+                                                                 \\\n+  template absl::Status                                          \\\n+  PluginRegistry::RegisterFactory<PluginRegistry::FACTORY_TYPE>( \\\n+      Platform::Id platform_id, const std::string& name,         \\\n+      PluginRegistry::FACTORY_TYPE factory);                     \\\n+                                                                 \\\n+  template absl::StatusOr<PluginRegistry::FACTORY_TYPE>          \\\n+  PluginRegistry::GetFactory(Platform::Id platform_id) const;\n+\n+EMIT_PLUGIN_SPECIALIZATIONS(BlasFactory);\n+EMIT_PLUGIN_SPECIALIZATIONS(DnnFactory);\n+EMIT_PLUGIN_SPECIALIZATIONS(FftFactory);\n \n }  // namespace stream_executor"
        },
        {
            "sha": "084fcd7cffcb93ecd0c56d993ad411dbaca1751d",
            "filename": "third_party/xla/xla/stream_executor/plugin_registry.h",
            "status": "modified",
            "additions": 10,
            "deletions": 41,
            "changes": 51,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa9dc3a08fae55b9a94911f7814c820e8a4062c2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fplugin_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa9dc3a08fae55b9a94911f7814c820e8a4062c2/third_party%2Fxla%2Fxla%2Fstream_executor%2Fplugin_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fplugin_registry.h?ref=aa9dc3a08fae55b9a94911f7814c820e8a4062c2",
            "patch": "@@ -16,10 +16,12 @@ limitations under the License.\n #ifndef XLA_STREAM_EXECUTOR_PLUGIN_REGISTRY_H_\n #define XLA_STREAM_EXECUTOR_PLUGIN_REGISTRY_H_\n \n-#include <map>\n-#include <optional>\n #include <string>\n+#include <utility>\n+#include <variant>\n \n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_map.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/mutex.h\"\n@@ -34,7 +36,6 @@ class StreamExecutor;\n \n // Enumeration to list the supported types of plugins / support libraries.\n enum class PluginKind {\n-  kInvalid,\n   kBlas,\n   kDnn,\n   kFft,\n@@ -76,53 +77,21 @@ class PluginRegistry {\n   // Retrieves the factory registered for the specified kind,\n   // or a absl::Status on error.\n   template <typename FactoryT>\n-  absl::StatusOr<FactoryT> GetFactory(Platform::Id platform_id);\n+  absl::StatusOr<FactoryT> GetFactory(Platform::Id platform_id) const;\n \n  private:\n-  // Containers for the sets of registered factories, by plugin kind.\n-  struct Factories {\n-    std::optional<BlasFactory> blas;\n-    std::optional<DnnFactory> dnn;\n-    std::optional<FftFactory> fft;\n-  };\n+  using AnyFactory = std::variant<BlasFactory, DnnFactory, FftFactory>;\n \n   PluginRegistry() = default;\n-\n-  // Actually performs the work of registration.\n-  template <typename FactoryT>\n-  absl::Status RegisterFactoryInternal(const std::string& plugin_name,\n-                                       FactoryT factory,\n-                                       std::optional<FactoryT>* factories);\n-\n-  // Returns true if the specified plugin has been registered with the specified\n-  // platform factories. Unlike the other overload of this method, this does\n-  // not implicitly examine the default factory lists.\n-  bool HasFactory(const Factories& factories, PluginKind plugin_kind) const;\n-\n-  // The set of registered factories, keyed by platform ID.\n-  std::map<Platform::Id, Factories> factories_;\n-\n   PluginRegistry(const PluginRegistry&) = delete;\n   void operator=(const PluginRegistry&) = delete;\n \n-  absl::Mutex registry_mutex_;\n+  mutable absl::Mutex registry_mutex_;\n+  // The set of registered factories, keyed by platform ID and plugin kind.\n+  absl::flat_hash_map<std::pair<Platform::Id, PluginKind>, AnyFactory>\n+      factories_ ABSL_GUARDED_BY(registry_mutex_);\n };\n \n-// Explicit specializations are defined in plugin_registry.cc.\n-#define DECLARE_PLUGIN_SPECIALIZATIONS(FACTORY_TYPE)                          \\\n-  template <>                                                                 \\\n-  absl::Status PluginRegistry::RegisterFactory<PluginRegistry::FACTORY_TYPE>( \\\n-      Platform::Id platform_id, const std::string& name,                      \\\n-      PluginRegistry::FACTORY_TYPE factory);                                  \\\n-  template <>                                                                 \\\n-  absl::StatusOr<PluginRegistry::FACTORY_TYPE> PluginRegistry::GetFactory(    \\\n-      Platform::Id platform_id)\n-\n-DECLARE_PLUGIN_SPECIALIZATIONS(BlasFactory);\n-DECLARE_PLUGIN_SPECIALIZATIONS(DnnFactory);\n-DECLARE_PLUGIN_SPECIALIZATIONS(FftFactory);\n-#undef DECL_PLUGIN_SPECIALIZATIONS\n-\n }  // namespace stream_executor\n \n #endif  // XLA_STREAM_EXECUTOR_PLUGIN_REGISTRY_H_"
        }
    ],
    "stats": {
        "total": 197,
        "additions": 78,
        "deletions": 119
    }
}