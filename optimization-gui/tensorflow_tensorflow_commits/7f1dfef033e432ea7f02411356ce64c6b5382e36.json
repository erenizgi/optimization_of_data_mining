{
    "author": "ezhulenev",
    "message": "[xla:ffi] Remove internal context decoding code duplication\n\nPiperOrigin-RevId: 839755484",
    "sha": "7f1dfef033e432ea7f02411356ce64c6b5382e36",
    "files": [
        {
            "sha": "62929144eeb67759fe25c5d7dd3746b0295faf32",
            "filename": "third_party/xla/xla/backends/cpu/ffi.h",
            "status": "modified",
            "additions": 4,
            "deletions": 13,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fffi.h?ref=7f1dfef033e432ea7f02411356ce64c6b5382e36",
            "patch": "@@ -18,7 +18,6 @@ limitations under the License.\n \n #include <optional>\n \n-#include \"absl/base/optimization.h\"\n #include \"xla/ffi/api/c_api.h\"\n #include \"xla/ffi/api/c_api_internal.h\"  // IWYU pragma: keep\n #include \"xla/ffi/ffi.h\"  // IWYU pragma: export\n@@ -46,18 +45,10 @@ struct CtxDecoding<IntraOpThreadPool> {\n   static std::optional<Type> Decode(const XLA_FFI_Api* api,\n                                     XLA_FFI_ExecutionContext* ctx,\n                                     DiagnosticEngine& diagnostic) {\n-    void* thread_pool = nullptr;\n-    if (XLA_FFI_Error* error =\n-            api->internal_api->XLA_FFI_INTERNAL_IntraOpThreadPool_Get(\n-                ctx, &thread_pool);\n-        ABSL_PREDICT_FALSE(error)) {\n-      diagnostic.Emit(\"Failed to get intra op thread pool: \")\n-          << internal::GetErrorMessage(api, error);\n-      internal::DestroyError(api, error);\n-      return std::nullopt;\n-    }\n-\n-    return reinterpret_cast<Type>(thread_pool);\n+    return internal::DecodeInternalCtx<Type>(\n+        api, ctx, diagnostic,\n+        api->internal_api->XLA_FFI_INTERNAL_IntraOpThreadPool_Get,\n+        \"intra op thread pool\");\n   }\n };\n "
        },
        {
            "sha": "7546bed35c5d958a8c000ed9c85c9aada74c6933",
            "filename": "third_party/xla/xla/backends/gpu/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2FBUILD?ref=7f1dfef033e432ea7f02411356ce64c6b5382e36",
            "patch": "@@ -23,7 +23,7 @@ cc_library(\n         \"//xla/backends/gpu/runtime:collective_clique_requests\",\n         \"//xla/backends/gpu/runtime:collective_cliques\",\n         \"//xla/backends/gpu/runtime:collective_params\",\n-        \"//xla/ffi:api\",\n+        \"//xla/ffi\",\n         \"//xla/ffi/api:c_api\",\n         \"//xla/ffi/api:c_api_internal\",\n         \"//xla/stream_executor:device_memory_allocator\","
        },
        {
            "sha": "ccbb32842702c805a54e396b189fcc62ecaff5d8",
            "filename": "third_party/xla/xla/backends/gpu/ffi.h",
            "status": "modified",
            "additions": 35,
            "deletions": 70,
            "changes": 105,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fffi.h?ref=7f1dfef033e432ea7f02411356ce64c6b5382e36",
            "patch": "@@ -23,9 +23,9 @@ limitations under the License.\n #include \"xla/backends/gpu/runtime/collective_clique_requests.h\"\n #include \"xla/backends/gpu/runtime/collective_cliques.h\"\n #include \"xla/backends/gpu/runtime/collective_params.h\"\n-#include \"xla/ffi/api/api.h\"  // IWYU pragma: export\n #include \"xla/ffi/api/c_api.h\"\n #include \"xla/ffi/api/c_api_internal.h\"  // IWYU pragma: keep\n+#include \"xla/ffi/ffi.h\"  // IWYU pragma: export\n #include \"xla/stream_executor/device_memory_allocator.h\"\n #include \"xla/stream_executor/scratch_allocator.h\"\n #include \"xla/stream_executor/stream.h\"\n@@ -59,16 +59,25 @@ struct CtxDecoding<Stream> {\n   static std::optional<Type> Decode(const XLA_FFI_Api* api,\n                                     XLA_FFI_ExecutionContext* ctx,\n                                     DiagnosticEngine& diagnostic) {\n-    void* stream = nullptr;\n-    if (XLA_FFI_Error* error =\n-            api->internal_api->XLA_FFI_INTERNAL_Stream_Get(ctx, &stream);\n-        ABSL_PREDICT_FALSE(error)) {\n-      diagnostic.Emit(\"Failed to get stream: \")\n-          << internal::GetErrorMessage(api, error);\n-      internal::DestroyError(api, error);\n-      return std::nullopt;\n+    return internal::DecodeInternalCtx<Type>(\n+        api, ctx, diagnostic, api->internal_api->XLA_FFI_INTERNAL_Stream_Get,\n+        \"stream\");\n+  }\n+};\n+\n+template <typename T>\n+struct CtxDecoding<PlatformStream<T>> {\n+  using Type = T;\n+  static_assert(std::is_pointer_v<T>, \"platform stream type must be a pointer\");\n+\n+  static std::optional<Type> Decode(const XLA_FFI_Api* api,\n+                                    XLA_FFI_ExecutionContext* ctx,\n+                                    DiagnosticEngine& diagnostic) {\n+    if (auto stream = CtxDecoding<Stream>::Decode(api, ctx, diagnostic)) {\n+      return reinterpret_cast<Type>(\n+          stream.value()->platform_specific_handle().stream);\n     }\n-    return reinterpret_cast<Type>(stream);\n+    return std::nullopt;\n   }\n };\n \n@@ -79,17 +88,10 @@ struct CtxDecoding<Allocator> {\n   static std::optional<Type> Decode(const XLA_FFI_Api* api,\n                                     XLA_FFI_ExecutionContext* ctx,\n                                     DiagnosticEngine& diagnostic) {\n-    void* device_allocator = nullptr;\n-    if (XLA_FFI_Error* error =\n-            api->internal_api->XLA_FFI_INTERNAL_DeviceMemoryAllocator_Get(\n-                ctx, &device_allocator);\n-        ABSL_PREDICT_FALSE(error)) {\n-      diagnostic.Emit(\"Failed to get device memory allocator: \")\n-          << internal::GetErrorMessage(api, error);\n-      internal::DestroyError(api, error);\n-      return std::nullopt;\n-    }\n-    return reinterpret_cast<Type>(device_allocator);\n+    return internal::DecodeInternalCtx<Type>(\n+        api, ctx, diagnostic,\n+        api->internal_api->XLA_FFI_INTERNAL_DeviceMemoryAllocator_Get,\n+        \"device memory allocator\");\n   }\n };\n \n@@ -121,17 +123,10 @@ struct CtxDecoding<CollectiveParams> {\n   static std::optional<Type> Decode(const XLA_FFI_Api* api,\n                                     XLA_FFI_ExecutionContext* ctx,\n                                     DiagnosticEngine& diagnostic) {\n-    void* collective_params = nullptr;\n-    if (XLA_FFI_Error* error =\n-            api->internal_api->XLA_FFI_INTERNAL_CollectiveParams_Get(\n-                ctx, &collective_params);\n-        ABSL_PREDICT_FALSE(error)) {\n-      diagnostic.Emit(\"Failed to get collective params: \")\n-          << internal::GetErrorMessage(api, error);\n-      internal::DestroyError(api, error);\n-      return std::nullopt;\n-    }\n-    return reinterpret_cast<Type>(collective_params);\n+    return internal::DecodeInternalCtx<Type>(\n+        api, ctx, diagnostic,\n+        api->internal_api->XLA_FFI_INTERNAL_CollectiveParams_Get,\n+        \"collective params\");\n   }\n };\n \n@@ -142,17 +137,10 @@ struct CtxDecoding<CollectiveCliqueRequests> {\n   static std::optional<Type> Decode(const XLA_FFI_Api* api,\n                                     XLA_FFI_ExecutionContext* ctx,\n                                     DiagnosticEngine& diagnostic) {\n-    void* collective_clique_requests = nullptr;\n-    if (XLA_FFI_Error* error =\n-            api->internal_api->XLA_FFI_INTERNAL_CollectiveCliqueRequests_Get(\n-                ctx, &collective_clique_requests);\n-        ABSL_PREDICT_FALSE(error)) {\n-      diagnostic.Emit(\"Failed to get collective clique requests: \")\n-          << internal::GetErrorMessage(api, error);\n-      internal::DestroyError(api, error);\n-      return std::nullopt;\n-    }\n-    return reinterpret_cast<Type>(collective_clique_requests);\n+    return internal::DecodeInternalCtx<Type>(\n+        api, ctx, diagnostic,\n+        api->internal_api->XLA_FFI_INTERNAL_CollectiveCliqueRequests_Get,\n+        \"collective clique requests\");\n   }\n };\n \n@@ -163,33 +151,10 @@ struct CtxDecoding<CollectiveCliques> {\n   static std::optional<Type> Decode(const XLA_FFI_Api* api,\n                                     XLA_FFI_ExecutionContext* ctx,\n                                     DiagnosticEngine& diagnostic) {\n-    void* collective_cliques = nullptr;\n-    if (XLA_FFI_Error* error =\n-            api->internal_api->XLA_FFI_INTERNAL_CollectiveCliques_Get(\n-                ctx, &collective_cliques);\n-        ABSL_PREDICT_FALSE(error)) {\n-      diagnostic.Emit(\"Failed to get collective cliques: \")\n-          << internal::GetErrorMessage(api, error);\n-      internal::DestroyError(api, error);\n-      return std::nullopt;\n-    }\n-    return reinterpret_cast<Type>(collective_cliques);\n-  }\n-};\n-\n-template <typename T>\n-struct CtxDecoding<PlatformStream<T>> {\n-  using Type = T;\n-  static_assert(std::is_pointer_v<T>, \"platform stream type must be a pointer\");\n-\n-  static std::optional<Type> Decode(const XLA_FFI_Api* api,\n-                                    XLA_FFI_ExecutionContext* ctx,\n-                                    DiagnosticEngine& diagnostic) {\n-    if (auto stream = CtxDecoding<Stream>::Decode(api, ctx, diagnostic)) {\n-      return reinterpret_cast<Type>(\n-          stream.value()->platform_specific_handle().stream);\n-    }\n-    return std::nullopt;\n+    return internal::DecodeInternalCtx<Type>(\n+        api, ctx, diagnostic,\n+        api->internal_api->XLA_FFI_INTERNAL_CollectiveCliques_Get,\n+        \"collective cliques\");\n   }\n };\n "
        },
        {
            "sha": "da6303e14faef70dc8d17b6333851f3d5fb3289b",
            "filename": "third_party/xla/xla/ffi/ffi.h",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f1dfef033e432ea7f02411356ce64c6b5382e36/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h?ref=7f1dfef033e432ea7f02411356ce64c6b5382e36",
            "patch": "@@ -542,6 +542,27 @@ struct CtxDecoding<Context> {\n // Context decoding\n //===----------------------------------------------------------------------===//\n \n+namespace internal {\n+\n+// A helper function to decode context value of type `T` using provided\n+// `func` and name for error reporting.\n+template <typename T, typename F>\n+static std::optional<T> DecodeInternalCtx(const XLA_FFI_Api* api,\n+                                          XLA_FFI_ExecutionContext* ctx,\n+                                          DiagnosticEngine& diagnostic, F func,\n+                                          const char* name) {\n+  void* result = nullptr;\n+  if (XLA_FFI_Error* error = func(ctx, &result); ABSL_PREDICT_FALSE(error)) {\n+    diagnostic.Emit(\"Failed to get \")\n+        << name << \": \" << internal::GetErrorMessage(api, error);\n+    internal::DestroyError(api, error);\n+    return std::nullopt;\n+  }\n+  return reinterpret_cast<T>(result);\n+}\n+\n+}  // namespace internal\n+\n template <>\n struct CtxDecoding<DeviceOrdinal> {\n   using Type = int32_t;"
        }
    ],
    "stats": {
        "total": 145,
        "additions": 61,
        "deletions": 84
    }
}