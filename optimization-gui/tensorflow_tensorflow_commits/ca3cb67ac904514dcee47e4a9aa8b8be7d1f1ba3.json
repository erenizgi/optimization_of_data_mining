{
    "author": "hyeontaek",
    "message": "[PJRT:CPU] Delay the fulfillment of `returned_future` until (possibly async) all execution activities finish\n\n`returned_future` from `PjRtLoadedExecutable::Execute()` is frequently used as an indicator of whether the entire execution activity has finished and it is safe to destroy external resources used for prior execution dispatches (e.g., loaded callbacks, execute_context).\n\nIn the PJRT CPU client, with execution poisoning, `execute_event` may be set before an in-flight execution using the computation backend (e.g., eigen) finishes completely, and `execute_event`'s ready state was forwarded immediately `returned_future`, which has made `returned_future` become prematurely ready. If the user code releases the external resources, the inflight execution may attempt to access the external resources and causes a segfault or sigill.\n\nThis change makes `returned_future` to be fulfilled only if all execution activities are complete. This allows the user code to tear down of the execution environment and loaded executables safely.\n\nPiperOrigin-RevId: 842904201",
    "sha": "ca3cb67ac904514dcee47e4a9aa8b8be7d1f1ba3",
    "files": [
        {
            "sha": "98d5c48ef63655079fbe62396a9c3b2ace8e91c5",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 43,
            "deletions": 22,
            "changes": 65,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ca3cb67ac904514dcee47e4a9aa8b8be7d1f1ba3/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ca3cb67ac904514dcee47e4a9aa8b8be7d1f1ba3/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=ca3cb67ac904514dcee47e4a9aa8b8be7d1f1ba3",
            "patch": "@@ -1390,6 +1390,15 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n   auto execute_event = tsl::MakeConstructedAsyncValueRef<CpuEvent>();\n   MarkEventReadyOnExit ready_on_exit(execute_event);\n   auto execute_usage_event = tsl::MakeRef<CpuTrackedDeviceEvent>(execute_event);\n+  // `returned_future_can_be_set_event` indicates when `returned_future` can be\n+  // set using `execute_event`. This is necessary to delay setting the\n+  // `returned_future` until all (async) execution activities are complete even\n+  // if `execute_event` itself may be set early due to execution poisoning. This\n+  // lets the user rely on `returned_future` when there is no more in-flight\n+  // executions and destroy any external resources such as loaded callbacks and\n+  // execute contexts.\n+  auto returned_future_can_be_set_event =\n+      tsl::MakeConstructedAsyncValueRef<CpuEvent>();\n \n   absl::InlinedVector<CommonPjRtBuffer::ScopedHold, 4> donation_transactions;\n \n@@ -1689,6 +1698,8 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n       return thunks_execute_event.GetError();\n     }\n \n+    returned_future_can_be_set_event.SetStateConcrete();\n+\n   } else {\n     // Asynchronously call generated function.\n \n@@ -1718,20 +1729,21 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n         device->async_execution_tracker()->NewAsyncExecution(\n             run_id.ToInt(), std::move(ready_on_exit).Release());\n     client()->async_work_runner()->ScheduleWhenReady(\n-        input_deps,\n-        [cpu_executable, buffer_alloc = std::move(buffer_alloc),\n-         buffer_alloc_and_copy = std::move(buffer_alloc_and_copy),\n-         buffer_table = std::move(buffer_table),\n-         run_options = std::move(run_options),\n-         device_assignment = std::move(device_assignment),\n-         cpu_run_options = std::move(cpu_run_options),\n-         compute_reservation = std::move(compute_reservation),\n-         tuple_index_table = std::move(tuple_index_table),\n-         donation_transactions = std::move(donation_transactions),\n-         scoped_async_execution = std::move(scoped_async_execution),\n-         input_deps_avs = std::move(input_deps_avs_copy),\n-         allocator = client()->allocator(),\n-         eigen_device = client()->eigen_intraop_device()]() mutable {\n+        input_deps, [cpu_executable, buffer_alloc = std::move(buffer_alloc),\n+                     buffer_alloc_and_copy = std::move(buffer_alloc_and_copy),\n+                     buffer_table = std::move(buffer_table),\n+                     run_options = std::move(run_options),\n+                     device_assignment = std::move(device_assignment),\n+                     cpu_run_options = std::move(cpu_run_options),\n+                     compute_reservation = std::move(compute_reservation),\n+                     tuple_index_table = std::move(tuple_index_table),\n+                     donation_transactions = std::move(donation_transactions),\n+                     scoped_async_execution = std::move(scoped_async_execution),\n+                     input_deps_avs = std::move(input_deps_avs_copy),\n+                     allocator = client()->allocator(),\n+                     eigen_device = client()->eigen_intraop_device(),\n+                     returned_future_can_be_set_event =\n+                         returned_future_can_be_set_event.CopyRef()]() mutable {\n           // Because `input_deps` contains the definition events of all inputs,\n           // when it is ready, all input buffers must have been allocated. So,\n           // we are safe to allocate and copy memory here. Since `execute_event`\n@@ -1743,6 +1755,7 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n             if (auto* error = av->GetErrorIfPresent()) {\n               scoped_async_execution.SetError(Internal(\n                   \"Error dispatching computation: %s\", error->message()));\n+              returned_future_can_be_set_event.SetStateConcrete();\n               return;\n             }\n           }\n@@ -1758,6 +1771,7 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n               scoped_async_execution.SetError(\n                   Internal(\"Error preparing computation: %s\",\n                            buffer_info.buffer.GetError().message()));\n+              returned_future_can_be_set_event.SetStateConcrete();\n               return;\n             }\n           }\n@@ -1840,10 +1854,13 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n           if (!status.ok()) {\n             // CPU computation fails with an error.\n             scoped_async_execution.SetError(std::move(status));\n+            returned_future_can_be_set_event.SetStateConcrete();\n+            return;\n           }\n \n           // CPU computation completes.\n           scoped_async_execution.SetStateConcrete();\n+          returned_future_can_be_set_event.SetStateConcrete();\n         });\n   }\n \n@@ -1884,14 +1901,18 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n \n   if (fill_future) {\n     auto [promise, future] = Future<>::MakePromise();\n-    execute_event.AndThen([promise = std::move(promise),\n-                           event = execute_event.CopyRef()]() mutable {\n-      if (auto* error = event.GetErrorIfPresent()) {\n-        promise.Set(Internal(\"Compute error: %s\", error->message()));\n-      } else {\n-        promise.Set();\n-      }\n-    });\n+    returned_future_can_be_set_event.AndThen(\n+        [execute_event = std::move(execute_event),\n+         promise = std::move(promise)]() mutable {\n+          execute_event.AndThen([execute_event = execute_event.CopyRef(),\n+                                 promise = std::move(promise)]() mutable {\n+            if (auto* error = execute_event.GetErrorIfPresent()) {\n+              promise.Set(Internal(\"Compute error: %s\", error->message()));\n+            } else {\n+              promise.Set();\n+            }\n+          });\n+        });\n     return Result({std::move(future), /*buffers=*/std::move(res)});\n   }\n "
        }
    ],
    "stats": {
        "total": 65,
        "additions": 43,
        "deletions": 22
    }
}