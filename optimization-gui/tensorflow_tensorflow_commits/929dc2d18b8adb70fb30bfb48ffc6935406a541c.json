{
    "author": "chsigg",
    "message": "[xla:gpu] NFC: Hoist computation index map creation in Triton dot emitters.\n\nThis change moves the creation of the `computation_index_map` outside the loop body in `EmitDot` and `EmitScaledDot`, as it does not depend on the loop induction variable. It also simplifies how the tile size is retrieved in `GetDotLoopIterationCount` by using `TiledHloInstruction::tile_size`.\n\nPiperOrigin-RevId: 818718168",
    "sha": "929dc2d18b8adb70fb30bfb48ffc6935406a541c",
    "files": [
        {
            "sha": "74fb5d1e2d4c7b10e46d940c127467c766173d6b",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/fusion_emitter.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 38,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/929dc2d18b8adb70fb30bfb48ffc6935406a541c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/929dc2d18b8adb70fb30bfb48ffc6935406a541c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc?ref=929dc2d18b8adb70fb30bfb48ffc6935406a541c",
            "patch": "@@ -769,16 +769,10 @@ absl::StatusOr<int64_t> GetDotLoopIterationCount(\n         absl::StrCat(\"Only one contracting dimension is supported, got \",\n                      dims.lhs_contracting_dimensions_size()));\n   }\n-  auto contracting_dim_idx = dims.lhs_contracting_dimensions(0);\n-  int64_t k = dot.operand(0)->shape().dimensions(contracting_dim_idx);\n-\n-  const TiledHloFusionInstruction* tiled_hlo_fusion =\n-      static_cast<const TiledHloFusionInstruction*>(tiled_dot.operand(0));\n-  auto fusion_tile_sizes =\n-      tiled_hlo_fusion->called_computation()->GetRoots()[0]->tile_sizes();\n-  int64_t tile_k = fusion_tile_sizes[contracting_dim_idx];\n-\n-  return CeilOfRatio(k, tile_k);\n+  auto dim_idx = dims.lhs_contracting_dimensions(0);\n+  int64_t k_size = tiled_dot.hlo()->operand(0)->shape().dimensions(dim_idx);\n+  int64_t k_tile = tiled_dot.operand(0)->tile_size(dim_idx);\n+  return CeilOfRatio(k_size, k_tile);\n }\n \n // TODO(b/393299275): unify with the logic in `EmitReduce`.\n@@ -998,30 +992,28 @@ absl::StatusOr<ScalarOrTensor> EmitDot(\n \n   TF_ASSIGN_OR_RETURN(int64_t loop_iteration_count,\n                       GetDotLoopIterationCount(tiled_hlo_dot));\n+  auto pid_dim = b.getAffineDimExpr(0);\n+  auto ki_symbol = b.getAffineSymbolExpr(0);\n+  // Nested fusions are tiled with indexing map 'pid * loop_iter_count + ki'\n+  IndexingMap computation_index_map{\n+      AffineMap::get(1, 1, pid_dim * loop_iteration_count + ki_symbol),\n+      {IndexingMap::Variable{\n+          tiled_hlo_dot.tile_offsets_indexing()->GetDimensionBound(0), \"pid\"}},\n+      {IndexingMap::Variable{{0, loop_iteration_count - 1}, \"k\"}},\n+      /*rt_vars=*/{}};\n+\n   auto for_op = b.create<mlir::scf::ForOp>(\n       /*lowerBound=*/MakeIndex(b, 0),\n       /*upperBound=*/MakeIndex(b, loop_iteration_count),\n-      /*step=*/MakeIndex(b, 1), ValueRange{accumulator});\n+      /*step=*/MakeIndex(b, 1), accumulator);\n   {  // Loop body.\n     mlir::OpBuilder::InsertionGuard g(b);\n     b.setInsertionPointToStart(for_op.getBody());\n-    SmallVector<TensorValue> dot_args;\n     Value ki = for_op.getInductionVar();\n-    // Nested fusions are tiled with indexing map\n-    // (pid * loop_iteration_count_value + loop index) -> ....\n-    auto pid_dim = b.getAffineDimExpr(0);\n-    auto ki_symbol = b.getAffineSymbolExpr(0);\n-    IndexingMap computation_index_map{\n-        AffineMap::get(1, 1, {pid_dim * loop_iteration_count + ki_symbol}),\n-        {IndexingMap::Variable{\n-            tiled_hlo_dot.tile_offsets_indexing()->GetDimensionBound(0),\n-            \"pid\"}},\n-        {IndexingMap::Variable{{0, loop_iteration_count - 1}, \"k\"}},\n-        /*rt_vars=*/{}};\n-\n     Value computation_index = b.create<xla::ApplyIndexingOp>(\n                                    ValueRange{pid, ki}, computation_index_map)\n                                   .getResult(0);\n+    SmallVector<TensorValue> dot_args;\n     for (const TiledHloInstruction* operand : tiled_hlo_dot.operands()) {\n       VLOG(3) << \"Emitting dot operand: \" << operand->ToString();\n       const TiledHloFusionInstruction* tiled_fusion_operand =\n@@ -1131,30 +1123,28 @@ absl::StatusOr<ScalarOrTensor> EmitScaledDot(\n \n   TF_ASSIGN_OR_RETURN(int64_t loop_iteration_count,\n                       GetDotLoopIterationCount(tiled_hlo_dot));\n+  auto pid_dim = b.getAffineDimExpr(0);\n+  auto ki_symbol = b.getAffineSymbolExpr(0);\n+  // Nested fusions are tiled with indexing map 'pid * loop_iter_count + ki'\n+  IndexingMap computation_index_map{\n+      AffineMap::get(1, 1, pid_dim * loop_iteration_count + ki_symbol),\n+      {IndexingMap::Variable{\n+          tiled_hlo_dot.tile_offsets_indexing()->GetDimensionBound(0), \"pid\"}},\n+      {IndexingMap::Variable{{0, loop_iteration_count - 1}, \"k\"}},\n+      /*rt_vars=*/{}};\n+\n   auto for_op = b.create<mlir::scf::ForOp>(\n       /*lowerBound=*/MakeIndex(b, 0),\n       /*upperBound=*/MakeIndex(b, loop_iteration_count),\n-      /*step=*/MakeIndex(b, 1), SmallVector<Value>{accumulator});\n+      /*step=*/MakeIndex(b, 1), accumulator);\n   {  // Loop body.\n     mlir::OpBuilder::InsertionGuard g(b);\n     b.setInsertionPointToStart(for_op.getBody());\n-    SmallVector<TensorValue> dot_args;\n     Value ki = for_op.getInductionVar();\n-    // Nested fusions are tiled with indexing map\n-    // (pid * loop_iteration_count_value + loop index) -> ....\n-    auto pid_dim = b.getAffineDimExpr(0);\n-    auto ki_symbol = b.getAffineSymbolExpr(0);\n-    IndexingMap computation_index_map{\n-        AffineMap::get(1, 1, {pid_dim * loop_iteration_count + ki_symbol}),\n-        {IndexingMap::Variable{\n-            tiled_hlo_dot.tile_offsets_indexing()->GetDimensionBound(0),\n-            \"pid\"}},\n-        {IndexingMap::Variable{{0, loop_iteration_count - 1}, \"k\"}},\n-        /*rt_vars=*/{}};\n-\n     Value computation_index = b.create<xla::ApplyIndexingOp>(\n                                    ValueRange{pid, ki}, computation_index_map)\n                                   .getResult(0);\n+    SmallVector<TensorValue> dot_args;\n     for (const TiledHloInstruction* operand : tiled_hlo_dot.operands()) {\n       VLOG(3) << \"Emitting scaled dot operand: \" << operand->ToString();\n       const TiledHloFusionInstruction* tiled_fusion_operand ="
        }
    ],
    "stats": {
        "total": 66,
        "additions": 28,
        "deletions": 38
    }
}