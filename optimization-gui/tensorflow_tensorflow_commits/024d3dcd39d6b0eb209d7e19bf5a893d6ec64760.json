{
    "author": "akuegel",
    "message": "[XLA:GPU] Move helper function to indexing_analysis (NFC).\n\nPiperOrigin-RevId: 817057604",
    "sha": "024d3dcd39d6b0eb209d7e19bf5a893d6ec64760",
    "files": [
        {
            "sha": "b45125a9929e77523af3b99fc88e0fb4fc56bb6d",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_analysis.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 2,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/024d3dcd39d6b0eb209d7e19bf5a893d6ec64760/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/024d3dcd39d6b0eb209d7e19bf5a893d6ec64760/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.cc?ref=024d3dcd39d6b0eb209d7e19bf5a893d6ec64760",
            "patch": "@@ -1605,7 +1605,7 @@ void GetThreadIdToInputMemoryLayoutsMaps(\n                                             mlir_context);\n     // For every operand compute thread ID -> physical layout of operand\n     // indexing map.\n-    for (auto&& [operand, operand_linarized_physical_map] :\n+    for (auto&& [operand, operand_linearized_physical_map] :\n          llvm::zip(operands, operand_logical_to_linearized_physical_maps)) {\n       auto operand_indexing_maps_it =\n           instr_indexing_keyed_by_operands.find(operand);\n@@ -1623,7 +1623,7 @@ void GetThreadIdToInputMemoryLayoutsMaps(\n           break;\n         }\n         IndexingMap logical_output_to_linearized_physical_input_map =\n-            operand_indexing_map * operand_linarized_physical_map;\n+            operand_indexing_map * operand_linearized_physical_map;\n         IndexingMap thread_id_to_linearized_physical_input_map =\n             thread_id_to_hero_operand_map *\n             logical_output_to_linearized_physical_input_map;\n@@ -1634,6 +1634,36 @@ void GetThreadIdToInputMemoryLayoutsMaps(\n   }\n }\n \n+// Replaces RTVars with the midpoints of the feasible intervals.\n+void AssignValuesToRTVars(IndexingMap* indexing_map) {\n+  // If RTVars are present, replace them with constants.\n+  if (indexing_map->GetRTVarsCount() == 0) {\n+    return;\n+  }\n+  MLIRContext* mlir_context = indexing_map->GetMLIRContext();\n+  llvm::SmallVector<AffineExpr, 2> symbol_replacements;\n+  for (int64_t symbol_id = 0; symbol_id < indexing_map->GetRangeVarsCount();\n+       ++symbol_id) {\n+    symbol_replacements.push_back(\n+        mlir::getAffineSymbolExpr(symbol_id, mlir_context));\n+  }\n+  for (const IndexingMap::Variable& rt_var : indexing_map->GetRTVars()) {\n+    // Take midpoint of the feasible interval for the RT variable.\n+    symbol_replacements.push_back(getAffineConstantExpr(\n+        (rt_var.bounds.lower + rt_var.bounds.upper) / 2, mlir_context));\n+  }\n+  AffineMap thread_x_to_input_no_dim_symbols =\n+      indexing_map->GetAffineMap().replaceDimsAndSymbols(\n+          {}, symbol_replacements, indexing_map->GetDimVarsCount(),\n+          indexing_map->GetRangeVarsCount());\n+  *indexing_map = IndexingMap{thread_x_to_input_no_dim_symbols,\n+                              indexing_map->GetDimVars(),\n+                              indexing_map->GetRangeVars(),\n+                              {}};\n+  indexing_map->Simplify();\n+  indexing_map->RemoveUnusedSymbols();\n+}\n+\n HloInstructionIndexing ComputeOutputToInputAllGatherOpIndexing(\n     const HloAllGatherInstruction* instr, MLIRContext* ctx) {\n   // CHECK_EQ(instr->all_gather_dimension(), 0);"
        },
        {
            "sha": "4d24f8cd1f8f4e8ee01b4f2beb68043b0351e56c",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_analysis.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/024d3dcd39d6b0eb209d7e19bf5a893d6ec64760/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/024d3dcd39d6b0eb209d7e19bf5a893d6ec64760/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_analysis.h?ref=024d3dcd39d6b0eb209d7e19bf5a893d6ec64760",
            "patch": "@@ -226,6 +226,9 @@ void GetThreadIdToInputMemoryLayoutsMaps(\n     absl::Span<const IndexingMap> operand_logical_to_linearized_physical_maps,\n     mlir::MLIRContext* mlir_context, GroupedByOpIndexingMap& result);\n \n+// Replaces RTVars with the midpoints of the feasible intervals.\n+void AssignValuesToRTVars(IndexingMap* indexing_map);\n+\n // Groups indexing maps by instructions.\n GroupedByOpIndexing GroupIndexingMapsByProducers(\n     const HloInstructionIndexing& indexing, const HloInstruction* instr);"
        },
        {
            "sha": "7c2696f0967c4f0b668740521c7592283190639d",
            "filename": "third_party/xla/xla/service/gpu/model/coalescing_analysis.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/024d3dcd39d6b0eb209d7e19bf5a893d6ec64760/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fcoalescing_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/024d3dcd39d6b0eb209d7e19bf5a893d6ec64760/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fcoalescing_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fcoalescing_analysis.cc?ref=024d3dcd39d6b0eb209d7e19bf5a893d6ec64760",
            "patch": "@@ -218,36 +218,6 @@ bool EstimateCoalescingViaMemoryTransactionsCount(\n          memory_transactions * kIsCoalescedThreshold;\n }\n \n-// Replaces RTVars with the midpoints of the feasible intervals.\n-void AssignValuesToRTVars(IndexingMap* indexing_map) {\n-  // If RTVars are present, replace them with constants.\n-  if (indexing_map->GetRTVarsCount() == 0) {\n-    return;\n-  }\n-  MLIRContext* mlir_context = indexing_map->GetMLIRContext();\n-  llvm::SmallVector<AffineExpr, 2> symbol_replacements;\n-  for (int64_t symbol_id = 0; symbol_id < indexing_map->GetRangeVarsCount();\n-       ++symbol_id) {\n-    symbol_replacements.push_back(\n-        mlir::getAffineSymbolExpr(symbol_id, mlir_context));\n-  }\n-  for (const IndexingMap::Variable& rt_var : indexing_map->GetRTVars()) {\n-    // Take midpoint of the feasible interval for the RT variable.\n-    symbol_replacements.push_back(getAffineConstantExpr(\n-        (rt_var.bounds.lower + rt_var.bounds.upper) / 2, mlir_context));\n-  }\n-  AffineMap thread_x_to_input_no_dim_symbols =\n-      indexing_map->GetAffineMap().replaceDimsAndSymbols(\n-          {}, symbol_replacements, indexing_map->GetDimVarsCount(),\n-          indexing_map->GetRangeVarsCount());\n-  *indexing_map = IndexingMap{thread_x_to_input_no_dim_symbols,\n-                              indexing_map->GetDimVars(),\n-                              indexing_map->GetRangeVars(),\n-                              {}};\n-  indexing_map->Simplify();\n-  indexing_map->RemoveUnusedSymbols();\n-}\n-\n // Replaces all but one RangeVars with the first elements in the range.\n // At the moment, we assume that the last RangeVar symbol corresponds to the\n // innermost loop induction variable."
        }
    ],
    "stats": {
        "total": 67,
        "additions": 35,
        "deletions": 32
    }
}