{
    "author": "tensorflower-gardener",
    "message": "[SymbolicExpr] Implement canonicalization for FloorDiv, CeilDiv, and Mod\n\nPiperOrigin-RevId: 797696703",
    "sha": "97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2",
    "files": [
        {
            "sha": "c6d666f2d2068a2d06676650cef7f6a2a7f3eabb",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.cc",
            "status": "modified",
            "additions": 180,
            "deletions": 2,
            "changes": 182,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc?ref=97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <cmath>\n #include <cstddef>\n #include <cstdint>\n+#include <numeric>\n #include <optional>\n #include <string>\n #include <tuple>\n@@ -325,6 +326,178 @@ SymbolicExpr CanonicalizeMax(SymbolicExpr lhs, SymbolicExpr rhs) {\n   return ctx->CreateBinaryOp(SymbolicExprType::kMax, lhs, rhs);\n }\n \n+// Helper function to simplify (A * C1) op C2 using GCD.\n+SymbolicExpr TrySimplifyDivModByGCD(SymbolicExprType op_type, SymbolicExpr lhs,\n+                                    int64_t divisor) {\n+  if (lhs.GetType() != SymbolicExprType::kMul) {\n+    return SymbolicExpr();\n+  }\n+  SymbolicExpr mul_lhs = lhs.GetLHS();\n+  SymbolicExpr mul_rhs = lhs.GetRHS();\n+\n+  // mul_lhs can't be a constant because lhs is already canonicalized\n+  // and constants are on the RHS.\n+  if (mul_rhs.GetType() != SymbolicExprType::kConstant) {\n+    return SymbolicExpr();\n+  }\n+\n+  int64_t mul_rhs_val = mul_rhs.GetValue();\n+  int64_t gcd = std::gcd(std::abs(mul_rhs_val), std::abs(divisor));\n+\n+  if (gcd <= 1) {  // common is never 0 because divisor is non-zero\n+    return SymbolicExpr();\n+  }\n+\n+  SymbolicExpr new_lhs = mul_lhs * (mul_rhs_val / gcd);\n+  int64_t new_divisor = divisor / gcd;\n+\n+  switch (op_type) {\n+    case SymbolicExprType::kFloorDiv: {\n+      return (new_lhs / new_divisor).Canonicalize();\n+    }\n+    case SymbolicExprType::kCeilDiv: {\n+      return new_lhs.ceilDiv(new_divisor).Canonicalize();\n+    }\n+    case SymbolicExprType::kMod: {\n+      // (A * C1) mod C2 = ((A * (C1 / g)) mod (C2 / g)) * g\n+      return (((mul_lhs * (mul_rhs_val / gcd)) % (divisor / gcd)) * gcd)\n+          .Canonicalize();\n+    }\n+    default: {\n+      LOG(FATAL) << \"Unsupported op_type in TrySimplifyDivModByGCD\";\n+    }\n+  }\n+}\n+\n+// Helper function to simplify (A + B) floordiv div if A is multiple of div.\n+SymbolicExpr SimplifyFloorDivAddOperand(SymbolicExpr a, SymbolicExpr b,\n+                                        int64_t div) {\n+  if (a.GetType() == SymbolicExprType::kMul) {\n+    SymbolicExpr a_lhs = a.GetLHS();\n+    SymbolicExpr a_rhs = a.GetRHS();\n+\n+    // a_lhs can't be a constant because lhs is already canonicalized.\n+    if (a_rhs.GetType() != SymbolicExprType::kConstant) {\n+      return SymbolicExpr();\n+    }\n+\n+    int64_t a_rhs_val = a_rhs.GetValue();\n+    if (a_rhs_val != 0 && (a_rhs_val % div == 0)) {\n+      return ((a_lhs * (a_rhs_val / div)) + b.floorDiv(div)).Canonicalize();\n+    }\n+  } else if (a.GetType() == SymbolicExprType::kConstant) {\n+    if (a.GetValue() % div == 0) {\n+      return ((b.floorDiv(div)) + (a.GetValue() / div)).Canonicalize();\n+    }\n+  }\n+  return SymbolicExpr();  // Cannot simplify\n+}\n+\n+SymbolicExpr CanonicalizeFloorDiv(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n+    return lhs;  // 0 floordiv X => 0\n+  }\n+\n+  if (rhs.GetType() == SymbolicExprType::kConstant) {\n+    int64_t divisor = rhs.GetValue();\n+    CHECK_NE(divisor, 0) << \"Division by zero\";\n+    if (divisor == 1) {\n+      return lhs;\n+    }\n+    if (divisor == -1) {\n+      return -lhs;\n+    }\n+\n+    SymbolicExpr gcd_simplified =\n+        TrySimplifyDivModByGCD(SymbolicExprType::kFloorDiv, lhs, divisor);\n+    if (gcd_simplified) {\n+      return gcd_simplified;\n+    }\n+\n+    // Distributivity for (A + C1) floordiv C2 where C1 % C2 == 0\n+    if (lhs.GetType() == SymbolicExprType::kAdd) {\n+      SymbolicExpr add_lhs = lhs.GetLHS();\n+      SymbolicExpr add_rhs = lhs.GetRHS();\n+\n+      if (auto simplified =\n+              SimplifyFloorDivAddOperand(add_lhs, add_rhs, divisor)) {\n+        return simplified;\n+      }\n+      if (auto simplified =\n+              SimplifyFloorDivAddOperand(add_rhs, add_lhs, divisor)) {\n+        return simplified;\n+      }\n+    }\n+  }\n+\n+  return ctx->CreateBinaryOp(SymbolicExprType::kFloorDiv, lhs, rhs);\n+}\n+\n+SymbolicExpr CanonicalizeCeilDiv(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n+    return lhs;  // 0 ceildiv X => 0\n+  }\n+\n+  if (rhs.GetType() == SymbolicExprType::kConstant) {\n+    int64_t divisor = rhs.GetValue();\n+    CHECK_NE(divisor, 0) << \"Division by zero\";\n+    if (divisor == 1) {\n+      return lhs;\n+    }\n+    if (divisor == -1) {\n+      return -lhs;\n+    }\n+\n+    SymbolicExpr gcd_simplified =\n+        TrySimplifyDivModByGCD(SymbolicExprType::kCeilDiv, lhs, divisor);\n+    if (gcd_simplified) {\n+      return gcd_simplified;\n+    }\n+\n+    if (divisor > 0) {\n+      return ((lhs + divisor - 1).Canonicalize()).floorDiv(rhs).Canonicalize();\n+    }\n+    // TODO(b/433693793): Handle negative divisor for ceildiv.\n+  }\n+\n+  return ctx->CreateBinaryOp(SymbolicExprType::kCeilDiv, lhs, rhs);\n+}\n+\n+SymbolicExpr CanonicalizeMod(SymbolicExpr lhs, SymbolicExpr rhs) {\n+  SymbolicExprContext* ctx = lhs.GetContext();\n+\n+  if (lhs.GetType() == SymbolicExprType::kConstant && lhs.GetValue() == 0) {\n+    return lhs;  // 0 mod X => 0\n+  }\n+\n+  if (lhs == rhs) {\n+    return ctx->CreateConstant(0);  // X mod X => 0\n+  }\n+\n+  if (rhs.GetType() == SymbolicExprType::kConstant) {\n+    int64_t divisor = rhs.GetValue();\n+    CHECK_NE(divisor, 0) << \"Modulo by zero\";\n+\n+    if (SymbolicExpr gcd_simplified =\n+            TrySimplifyDivModByGCD(SymbolicExprType::kMod, lhs, divisor)) {\n+      return gcd_simplified;\n+    }\n+  }\n+\n+  // Fallback: A mod B = A - (A floordiv B) * B\n+  SymbolicExpr floor_div_expr = lhs.floorDiv(rhs).Canonicalize();\n+  if (floor_div_expr.GetType() == SymbolicExprType::kConstant &&\n+      floor_div_expr.GetValue() == 0) {\n+    return lhs;  // If A floordiv B is 0, then A mod B is A\n+  }\n+  SymbolicExpr product = (floor_div_expr * rhs).Canonicalize();\n+  return (lhs - product).Canonicalize();\n+}\n+\n }  // namespace\n \n class SymbolicExprStorage : public mlir::StorageUniquer::BaseStorage {\n@@ -555,9 +728,14 @@ SymbolicExpr SymbolicExpr::Canonicalize() const {\n       return CanonicalizeMin(lhs, rhs);\n     case SymbolicExprType::kMax:\n       return CanonicalizeMax(lhs, rhs);\n+    case SymbolicExprType::kFloorDiv:\n+      return CanonicalizeFloorDiv(lhs, rhs);\n+    case SymbolicExprType::kCeilDiv:\n+      return CanonicalizeCeilDiv(lhs, rhs);\n+    case SymbolicExprType::kMod:\n+      return CanonicalizeMod(lhs, rhs);\n     default:\n-      // TODO(b/433693793): Implement canonicalization for other types.\n-      return GetContext()->CreateBinaryOp(type, lhs, rhs);\n+      LOG(FATAL) << \"Canonicalize not implemented for this expression type.\";\n   }\n }\n "
        },
        {
            "sha": "33e9763daa7c73719aee47f1508029f910420721",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc?ref=97b6e7d078e82d81264d7eeeb9e5cc9d08856cc2",
            "patch": "@@ -182,7 +182,7 @@ TEST_F(SymbolicExprTest, Canonicalization_MinMax) {\n             \"(min(v0, v1) * 2)\");\n }\n \n-TEST_F(SymbolicExprTest, DISABLED_Canonicalization_DivMod) {\n+TEST_F(SymbolicExprTest, Canonicalization_DivMod) {\n   // FloorDiv, CeilDiv, and Mod simplifications.\n   EXPECT_EQ((v0.floorDiv(1)).Canonicalize().ToString(), \"v0\");\n   EXPECT_EQ((v0.ceilDiv(1)).Canonicalize().ToString(), \"v0\");"
        }
    ],
    "stats": {
        "total": 184,
        "additions": 181,
        "deletions": 3
    }
}