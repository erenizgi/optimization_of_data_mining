{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 820186224",
    "sha": "26d0e976a1183a87ed6b579a786ec95155acfc66",
    "files": [
        {
            "sha": "3c1e9cbdfece513472f97aa18d5006849e2426b1",
            "filename": "tensorflow/core/tfrt/runtime/stream.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/26d0e976a1183a87ed6b579a786ec95155acfc66/tensorflow%2Fcore%2Ftfrt%2Fruntime%2Fstream.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/26d0e976a1183a87ed6b579a786ec95155acfc66/tensorflow%2Fcore%2Ftfrt%2Fruntime%2Fstream.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fruntime%2Fstream.cc?ref=26d0e976a1183a87ed6b579a786ec95155acfc66",
            "patch": "@@ -83,7 +83,7 @@ absl::StatusOr<std::optional<StreamCallbackId>> CreateStreamCallbackId(\n absl::Status StreamCallbackRegistry::CallbackState::Invoke(\n     tsl::thread::ThreadPoolInterface* thread_pool, StreamedResult result) {\n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if (closed_) {\n       return absl::InternalError(\n           \"Failed to invole the callback that is closed.\");\n@@ -93,15 +93,15 @@ absl::Status StreamCallbackRegistry::CallbackState::Invoke(\n   thread_pool->Schedule([this, result = std::move(result)]() mutable {\n     InvokeCallback(std::move(result));\n \n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     --num_outstanding_;\n   });\n   return absl::OkStatus();\n }\n \n void StreamCallbackRegistry::CallbackState::Close() {\n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     closed_ = true;\n \n     auto not_running = [this]() ABSL_SHARED_LOCKS_REQUIRED(mu_) {\n@@ -134,7 +134,7 @@ absl::StatusOr<ScopedStreamCallback> StreamCallbackRegistry::Register(\n     absl::AnyInvocable<\n         void(absl::flat_hash_map<std::string, tensorflow::Tensor>)>\n         callback) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n \n   const auto [it, inserted] =\n       stream_callbacks_.insert({std::make_pair(callback_id, step_id), nullptr});\n@@ -151,7 +151,7 @@ absl::StatusOr<ScopedStreamCallback> StreamCallbackRegistry::Register(\n absl::Status StreamCallbackRegistry::Invoke(\n     tsl::thread::ThreadPoolInterface* thread_pool, StreamCallbackId callback_id,\n     StepId step_id, StreamedResult result) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto iter = stream_callbacks_.find({callback_id, step_id});\n   if (iter == stream_callbacks_.end()) {\n     return absl::NotFoundError(absl::StrCat(\n@@ -168,7 +168,7 @@ absl::Status StreamCallbackRegistry::Invoke(\n std::unique_ptr<StreamCallbackRegistry::CallbackState>\n StreamCallbackRegistry::Unregister(StreamCallbackId callback_id,\n                                    StepId step_id) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   const auto it = stream_callbacks_.find({callback_id, step_id});\n   if (it == stream_callbacks_.end()) {\n     return nullptr;"
        },
        {
            "sha": "e6f6eb235827974e84a62a57f6278571185c3a8c",
            "filename": "tensorflow/core/tfrt/runtime/stream.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/26d0e976a1183a87ed6b579a786ec95155acfc66/tensorflow%2Fcore%2Ftfrt%2Fruntime%2Fstream.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/26d0e976a1183a87ed6b579a786ec95155acfc66/tensorflow%2Fcore%2Ftfrt%2Fruntime%2Fstream.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fruntime%2Fstream.h?ref=26d0e976a1183a87ed6b579a786ec95155acfc66",
            "patch": "@@ -106,23 +106,23 @@ class StreamInterfaceFactory {\n       absl::AnyInvocable<\n           absl::StatusOr<std::unique_ptr<StreamControllerInterface>>() const>\n           interface_factory) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     controller_interface_factory_ = std::move(interface_factory);\n   }\n \n   absl::StatusOr<std::unique_ptr<StreamControllerInterface>>\n   CreateControllerStreamInterface() const {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return controller_interface_factory_();\n   }\n \n   void RegisterWorker(CreateWorkerStreamInterfaceFn interface_factory) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     worker_interface_factory_ = std::move(interface_factory);\n   }\n \n   CreateWorkerStreamInterfaceFn CreateWorkerStreamInterface() const {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return worker_interface_factory_;\n   }\n "
        }
    ],
    "stats": {
        "total": 20,
        "additions": 10,
        "deletions": 10
    }
}