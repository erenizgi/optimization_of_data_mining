{
    "author": "ezhulenev",
    "message": "[xla:ffi] Add support for returning TypeId for stateful handlers\n\nPiperOrigin-RevId: 819234816",
    "sha": "812c2012563505558e871b367f8d62608f80082c",
    "files": [
        {
            "sha": "2e3c8825e8427ee77b6599c7e259a837d63e18b1",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -124,6 +124,7 @@ cc_library(\n         \":api\",\n         \":execution_context\",\n         \":execution_state\",\n+        \":type_id_registry\",\n         \"//xla:executable_run_options\",\n         \"//xla:shape_util\",\n         \"//xla:types\",\n@@ -141,6 +142,7 @@ cc_library(\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/base:nullability\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/types:span\",\n         \"@local_tsl//tsl/platform:logging\",\n@@ -216,13 +218,18 @@ xla_cc_test(\n         \":execution_state\",\n         \":ffi\",\n         \":ffi_api\",\n+        \":type_id_registry\",\n         \"//xla:executable_run_options\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/ffi/api:c_api\",\n         \"//xla/stream_executor:device_memory\",\n         \"//xla/stream_executor:stream\",\n         \"//xla/tsl/concurrency:async_value\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/platform:test_benchmark\",\n         \"//xla/tsl/platform:test_main\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n@@ -232,11 +239,6 @@ xla_cc_test(\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest\",\n         \"@eigen_archive//:eigen3\",\n-        \"@local_tsl//tsl/platform:env\",\n-        \"@local_tsl//tsl/platform:status_matchers\",\n-        \"@local_tsl//tsl/platform:statusor\",\n-        \"@local_tsl//tsl/platform:test\",\n-        \"@local_tsl//tsl/platform:test_benchmark\",\n     ],\n )\n "
        },
        {
            "sha": "d28a39c9d15784ae25d1be22c1cdccde3b8c20aa",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 29,
            "deletions": 4,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -1411,6 +1411,24 @@ struct NumArgs<T, Ts...> {\n   static constexpr int64_t value = !IsTagged<T>::value + NumArgs<Ts...>::value;\n };\n \n+// A template to detect result encodings that are state constructors. We use\n+// this to report back the TypeId of the state as a part of the metadata.\n+template <typename ResultEnconding, typename = void>\n+struct IsStateConstructor : std::false_type {};\n+\n+// Check if the ResultEncoding has a static `state_type_id()` method returning\n+// the XLA_FFI_TypeId.\n+template <typename ResultEncoding>\n+struct IsStateConstructor<\n+    ResultEncoding,\n+    std::enable_if_t<std::is_same_v<XLA_FFI_TypeId,\n+                                    decltype(ResultEncoding::state_type_id())>>>\n+    : std::true_type {};\n+\n+template <typename ResultEncoding>\n+static constexpr bool is_state_constructor_v =  // NOLINT\n+    IsStateConstructor<ResultEncoding>::value;\n+\n }  // namespace internal\n \n //===----------------------------------------------------------------------===//\n@@ -1587,17 +1605,24 @@ class Handler : public Ffi {\n \n     extension->metadata->api_version = XLA_FFI_Api_Version{\n         XLA_FFI_Api_Version_STRUCT_SIZE,\n-        /*extension_start=*/nullptr,\n-        XLA_FFI_API_MAJOR,\n-        XLA_FFI_API_MINOR,\n-    };\n+        /*extension_start=*/nullptr, XLA_FFI_API_MAJOR, XLA_FFI_API_MINOR};\n \n+    // Collect all traits and store them in the metadata.\n     XLA_FFI_Handler_Traits traits = 0;\n     for (const auto& trait : traits_) {\n       traits |= static_cast<XLA_FFI_Handler_Traits>(trait);\n     }\n     extension->metadata->traits = traits;\n \n+    // Check if the handler creates a new state object and if so, record its\n+    // type id in the metadata.\n+    using ResultEncoding = ResultEncoding<stage, ResultType>;\n+    if constexpr (internal::is_state_constructor_v<ResultEncoding>) {\n+      extension->metadata->state_type_id = ResultEncoding::state_type_id();\n+    } else {\n+      extension->metadata->state_type_id = XLA_FFI_UNKNOWN_TYPE_ID;\n+    }\n+\n     return Sucess();\n   }\n "
        },
        {
            "sha": "287a9bd1b203515028a966862cd7671e3eadbb98",
            "filename": "third_party/xla/xla/ffi/api/c_api.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -694,10 +694,18 @@ typedef XLA_FFI_Error* XLA_FFI_DeviceOrdinal_Get(\n // Metadata extension\n //===----------------------------------------------------------------------===//\n \n+// XLA FFI handler metadata allows the XLA runtime to query handler properties\n+// during XLA compilation and execution. We use a metadata extension to verify\n+// that XLA is compatible with the FFI version used to compile the handler.\n struct XLA_FFI_Metadata {\n   size_t struct_size;\n+\n   XLA_FFI_Api_Version api_version;\n   XLA_FFI_Handler_Traits traits;\n+\n+  // For stateful handlers, the type id of the state type. Otherwise, the type\n+  // id is `XLA_FFI_UNKNOWN_TYPE_ID`.\n+  XLA_FFI_TypeId state_type_id;\n };\n \n XLA_FFI_DEFINE_STRUCT_TRAITS(XLA_FFI_Metadata, traits);"
        },
        {
            "sha": "80f28e29c30ee394d20b6cb12856f63dd0cb58d6",
            "filename": "third_party/xla/xla/ffi/api/ffi.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -1139,6 +1139,8 @@ struct ResultEncoding<ExecutionStage::kInstantiate,\n   static_assert(std::is_same_v<decltype(T::id), TypeId>,\n                 \"State type must have a static `TypeId id` field\");\n \n+  static XLA_FFI_TypeId state_type_id() { return T::id; }\n+\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n   static XLA_FFI_Error* Encode(const XLA_FFI_Api* api,\n                                XLA_FFI_ExecutionContext* ctx,"
        },
        {
            "sha": "c9cbea4f7ca93f05f10daf4a9466627cf7edd68a",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 8,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -1434,25 +1434,33 @@ TEST(FfiTest, AsyncHandler) {\n }\n \n TEST(FfiTest, Metadata) {\n-  auto api = GetXlaFfiApi();\n-  auto handler = Ffi::BindTo([]() { return Error::Success(); });\n-  auto maybe_metadata = GetMetadata(*handler);\n+  auto handler =\n+      Ffi::BindInstantiate().To([]() -> ErrorOr<std::unique_ptr<MyState>> {\n+        return std::make_unique<MyState>(42);\n+      });\n+\n+  absl::StatusOr<XLA_FFI_Metadata> maybe_metadata = GetMetadata(*handler);\n   EXPECT_TRUE(maybe_metadata.ok());\n-  auto metadata = maybe_metadata.value();\n-  EXPECT_EQ(metadata.api_version.major_version, api->api_version.major_version);\n-  EXPECT_EQ(metadata.api_version.minor_version, api->api_version.minor_version);\n+\n+  XLA_FFI_Metadata metadata = maybe_metadata.value();\n+  EXPECT_EQ(metadata.api_version.major_version, XLA_FFI_API_MAJOR);\n+  EXPECT_EQ(metadata.api_version.minor_version, XLA_FFI_API_MINOR);\n   EXPECT_EQ(metadata.traits, 0);\n+  EXPECT_EQ(metadata.state_type_id.type_id, MyState::id.type_id);\n }\n \n TEST(FfiTest, MetadataTraits) {\n   auto handler = Ffi::BindTo([]() { return Error::Success(); },\n                              {Traits::kCmdBufferCompatible});\n-  auto maybe_metadata = GetMetadata(*handler);\n+\n+  absl::StatusOr<XLA_FFI_Metadata> maybe_metadata = GetMetadata(*handler);\n   EXPECT_TRUE(maybe_metadata.ok());\n-  auto metadata = maybe_metadata.value();\n+\n+  XLA_FFI_Metadata metadata = maybe_metadata.value();\n   EXPECT_EQ(metadata.api_version.major_version, XLA_FFI_API_MAJOR);\n   EXPECT_EQ(metadata.api_version.minor_version, XLA_FFI_API_MINOR);\n   EXPECT_EQ(metadata.traits, XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n+  EXPECT_EQ(metadata.state_type_id.type_id, XLA_FFI_UNKNOWN_TYPE_ID.type_id);\n }\n \n //===----------------------------------------------------------------------===//"
        },
        {
            "sha": "7a61cd969903dc86defa11f2033a5eec8d7ad548",
            "filename": "third_party/xla/xla/ffi/ffi.h",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -38,13 +38,15 @@ limitations under the License.\n #include \"absl/base/nullability.h\"\n #include \"absl/base/optimization.h\"\n #include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/ffi/api/c_api.h\"\n #include \"xla/ffi/api/c_api_internal.h\"  // IWYU pragma: keep\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n+#include \"xla/ffi/type_id_registry.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/primitive_util.h\"\n #include \"xla/stream_executor/device_memory.h\"\n@@ -56,7 +58,6 @@ limitations under the License.\n #include \"xla/types.h\"  // IWYU pragma: keep\n #include \"xla/util.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/logging.h\"\n \n namespace xla::ffi {\n \n@@ -722,6 +723,10 @@ struct ResultEncoding<stage, absl::Status> {\n template <typename T>\n struct ResultEncoding<ExecutionStage::kInstantiate,\n                       absl::StatusOr<std::unique_ptr<T>>> {\n+  static XLA_FFI_TypeId state_type_id() {\n+    return XLA_FFI_TypeId{TypeIdRegistry::GetTypeId<T>().value()};\n+  }\n+\n   static XLA_FFI_Error* Encode(const XLA_FFI_Api* api,\n                                XLA_FFI_ExecutionContext* ctx,\n                                absl::StatusOr<std::unique_ptr<T>> state) {"
        },
        {
            "sha": "d064953a106769691d430d4e90cdadf4ea199d97",
            "filename": "third_party/xla/xla/ffi/ffi_api.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 17,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -136,7 +136,9 @@ static XLA_FFI_ExecutionContext CreateExecutionContext(\n //===----------------------------------------------------------------------===//\n \n absl::Status TakeStatus(XLA_FFI_Error* error) {\n-  if (ABSL_PREDICT_TRUE(error == nullptr)) return absl::OkStatus();\n+  if (ABSL_PREDICT_TRUE(error == nullptr)) {\n+    return absl::OkStatus();\n+  }\n   absl::Status status = std::move(error->status);\n   delete error;\n   return status;\n@@ -150,7 +152,9 @@ tsl::AsyncValueRef<tsl::Chain> TakeFuture(XLA_FFI_Future* future) {\n         tsl::MakeAvailableAsyncValueRef<tsl::Chain>(*storage));\n   }();\n \n-  if (ABSL_PREDICT_TRUE(future == nullptr)) return chain->AsRef();\n+  if (ABSL_PREDICT_TRUE(future == nullptr)) {\n+    return chain->AsRef();\n+  }\n \n   // If the future is already completed, immediately return the underlying async\n   // value and delete the XLA_FFI_Future.\n@@ -204,7 +208,9 @@ static absl::StatusOr<XLA_FFI_Future*> Call(Handler& handler,\n }\n \n static absl::Status BlockUntilReady(XLA_FFI_Future* future) {\n-  if (ABSL_PREDICT_TRUE(future == nullptr)) return absl::OkStatus();\n+  if (ABSL_PREDICT_TRUE(future == nullptr)) {\n+    return absl::OkStatus();\n+  }\n \n   tsl::AsyncValueRef<tsl::Chain> av = TakeFuture(future);\n   tsl::BlockUntilReady(av);\n@@ -246,20 +252,20 @@ tsl::AsyncValueRef<tsl::Chain> CallAsync(XLA_FFI_Handler* handler,\n   return TakeFuture(future);\n }\n \n-static XLA_FFI_Metadata BuildMetadata() {\n+static XLA_FFI_Metadata PrepareMetadata() {\n   return XLA_FFI_Metadata{XLA_FFI_Metadata_STRUCT_SIZE,\n                           XLA_FFI_Api_Version{XLA_FFI_Api_Version_STRUCT_SIZE}};\n }\n \n-static XLA_FFI_Metadata_Extension BuildMetadataExtension(\n+static XLA_FFI_Metadata_Extension PrepareMetadataExtension(\n     XLA_FFI_Metadata* metadata) {\n   return XLA_FFI_Metadata_Extension{\n       XLA_FFI_Extension_Base{XLA_FFI_Metadata_Extension_STRUCT_SIZE,\n                              XLA_FFI_Extension_Metadata},\n       metadata};\n }\n \n-static XLA_FFI_CallFrame BuildMetadataCallFrame(\n+static XLA_FFI_CallFrame PrepareMetadataCallFrame(\n     XLA_FFI_Metadata_Extension* extension) {\n   return XLA_FFI_CallFrame{\n       XLA_FFI_CallFrame_STRUCT_SIZE,\n@@ -274,9 +280,9 @@ static XLA_FFI_CallFrame BuildMetadataCallFrame(\n }\n \n absl::StatusOr<XLA_FFI_Metadata> GetMetadata(Ffi& handler) {\n-  XLA_FFI_Metadata metadata = BuildMetadata();\n-  XLA_FFI_Metadata_Extension extension = BuildMetadataExtension(&metadata);\n-  XLA_FFI_CallFrame call_frame = BuildMetadataCallFrame(&extension);\n+  XLA_FFI_Metadata metadata = PrepareMetadata();\n+  XLA_FFI_Metadata_Extension extension = PrepareMetadataExtension(&metadata);\n+  XLA_FFI_CallFrame call_frame = PrepareMetadataCallFrame(&extension);\n   XLA_FFI_Error* error = nullptr;\n   try {\n     error = handler.Call(&call_frame);\n@@ -290,9 +296,9 @@ absl::StatusOr<XLA_FFI_Metadata> GetMetadata(Ffi& handler) {\n }\n \n absl::StatusOr<XLA_FFI_Metadata> GetMetadata(XLA_FFI_Handler* handler) {\n-  XLA_FFI_Metadata metadata = BuildMetadata();\n-  XLA_FFI_Metadata_Extension extension = BuildMetadataExtension(&metadata);\n-  XLA_FFI_CallFrame call_frame = BuildMetadataCallFrame(&extension);\n+  XLA_FFI_Metadata metadata = PrepareMetadata();\n+  XLA_FFI_Metadata_Extension extension = PrepareMetadataExtension(&metadata);\n+  XLA_FFI_CallFrame call_frame = PrepareMetadataCallFrame(&extension);\n   XLA_FFI_Error* error = nullptr;\n   try {\n     error = (*handler)(&call_frame);\n@@ -346,10 +352,18 @@ static HandlerRegistry& GetHandlerRegistry() {\n static std::vector<std::string> GetHandlerStages(\n     const XLA_FFI_Handler_Bundle& bundle) {\n   std::vector<std::string> stages;\n-  if (bundle.instantiate != nullptr) stages.push_back(\"instantiate\");\n-  if (bundle.prepare != nullptr) stages.push_back(\"prepare\");\n-  if (bundle.initialize != nullptr) stages.push_back(\"initialize\");\n-  if (bundle.execute != nullptr) stages.push_back(\"execute\");\n+  if (bundle.instantiate != nullptr) {\n+    stages.push_back(\"instantiate\");\n+  }\n+  if (bundle.prepare != nullptr) {\n+    stages.push_back(\"prepare\");\n+  }\n+  if (bundle.initialize != nullptr) {\n+    stages.push_back(\"initialize\");\n+  }\n+  if (bundle.execute != nullptr) {\n+    stages.push_back(\"execute\");\n+  }\n   return stages;\n }\n \n@@ -368,7 +382,7 @@ static absl::Status RegisterHandler(absl::string_view name,\n   }\n \n   // Check the API versions.\n-  TF_ASSIGN_OR_RETURN(auto metadata, GetMetadata(bundle.execute));\n+  TF_ASSIGN_OR_RETURN(XLA_FFI_Metadata metadata, GetMetadata(bundle.execute));\n   const XLA_FFI_Api_Version& api_version = metadata.api_version;\n   if (api_version.major_version != XLA_FFI_API_MAJOR ||\n       api_version.minor_version != XLA_FFI_API_MINOR) {"
        },
        {
            "sha": "de2481dbad7a61d3335896b34b7e613f0e7d1f2e",
            "filename": "third_party/xla/xla/ffi/ffi_test.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 18,
            "changes": 55,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/812c2012563505558e871b367f8d62608f80082c/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc?ref=812c2012563505558e871b367f8d62608f80082c",
            "patch": "@@ -39,18 +39,17 @@ limitations under the License.\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n #include \"xla/ffi/ffi_api.h\"\n+#include \"xla/ffi/type_id_registry.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/stream.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/chain.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test_benchmark.h\"\n+#include \"xla/tsl/platform/threadpool.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/env.h\"\n-#include \"tsl/platform/status_matchers.h\"\n-#include \"tsl/platform/statusor.h\"\n-#include \"tsl/platform/test.h\"\n-#include \"tsl/platform/test_benchmark.h\"\n-#include \"tsl/platform/threadpool.h\"\n \n #define EIGEN_USE_THREADS\n #include \"unsupported/Eigen/CXX11/Tensor\"\n@@ -86,7 +85,6 @@ using ::testing::_;\n using ::testing::HasSubstr;\n using ::testing::Pair;\n using ::testing::UnorderedElementsAre;\n-using ::tsl::testing::StatusIs;\n \n TEST(FfiTest, StaticHandlerRegistration) {\n   static constexpr auto* noop = +[] { return absl::OkStatus(); };\n@@ -385,9 +383,15 @@ TEST(FfiTest, AttrsAsDictionary) {\n     EXPECT_TRUE(f32.ok());\n     EXPECT_TRUE(str.ok());\n \n-    if (i32.ok()) EXPECT_EQ(*i32, 42);\n-    if (f32.ok()) EXPECT_EQ(*f32, 42.0f);\n-    if (str.ok()) EXPECT_EQ(*str, \"foo\");\n+    if (i32.ok()) {\n+      EXPECT_EQ(*i32, 42);\n+    }\n+    if (f32.ok()) {\n+      EXPECT_EQ(*f32, 42.0f);\n+    }\n+    if (str.ok()) {\n+      EXPECT_EQ(*str, \"foo\");\n+    }\n \n     EXPECT_FALSE(dict.contains(\"i64\"));\n     EXPECT_FALSE(dict.get<int64_t>(\"i32\").ok());\n@@ -430,8 +434,12 @@ TEST(FfiTest, DictionaryAttr) {\n     EXPECT_TRUE(i32.ok());\n     EXPECT_TRUE(f32.ok());\n \n-    if (i32.ok()) EXPECT_EQ(*i32, 42);\n-    if (f32.ok()) EXPECT_EQ(*f32, 42.0f);\n+    if (i32.ok()) {\n+      EXPECT_EQ(*i32, 42);\n+    }\n+    if (f32.ok()) {\n+      EXPECT_EQ(*f32, 42.0f);\n+    }\n \n     return absl::OkStatus();\n   };\n@@ -1080,26 +1088,37 @@ TEST(FfiTest, AsyncHandler) {\n }\n \n TEST(FfiTest, Metadata) {\n-  static constexpr auto* noop = +[] { return absl::OkStatus(); };\n-  XLA_FFI_DEFINE_HANDLER(handler, noop, Ffi::Bind());\n-  auto maybe_metadata = GetMetadata(handler);\n+  static constexpr auto* instantiate =\n+      +[]() -> absl::StatusOr<std::unique_ptr<StrState>> {\n+    return std::make_unique<StrState>(\"\");\n+  };\n+  XLA_FFI_DEFINE_HANDLER(handler, instantiate, Ffi::BindInstantiate());\n+\n+  absl::StatusOr<XLA_FFI_Metadata> maybe_metadata = GetMetadata(handler);\n   EXPECT_TRUE(maybe_metadata.ok());\n-  auto metadata = maybe_metadata.value();\n+\n+  XLA_FFI_Metadata metadata = maybe_metadata.value();\n   EXPECT_EQ(metadata.traits, 0);\n   EXPECT_EQ(metadata.api_version.major_version, XLA_FFI_API_MAJOR);\n   EXPECT_EQ(metadata.api_version.minor_version, XLA_FFI_API_MINOR);\n+\n+  TypeIdRegistry::TypeId type_id = TypeIdRegistry::GetTypeId<StrState>();\n+  EXPECT_EQ(metadata.state_type_id.type_id, type_id);\n }\n \n TEST(FfiTest, MetadataTraits) {\n   static constexpr auto* noop = +[] { return absl::OkStatus(); };\n   XLA_FFI_DEFINE_HANDLER(handler, noop, Ffi::Bind(),\n                          {Traits::kCmdBufferCompatible});\n-  auto maybe_metadata = GetMetadata(handler);\n+\n+  absl::StatusOr<XLA_FFI_Metadata> maybe_metadata = GetMetadata(handler);\n   EXPECT_TRUE(maybe_metadata.ok());\n-  auto metadata = maybe_metadata.value();\n+\n+  XLA_FFI_Metadata metadata = maybe_metadata.value();\n   EXPECT_EQ(metadata.traits, XLA_FFI_HANDLER_TRAITS_COMMAND_BUFFER_COMPATIBLE);\n   EXPECT_EQ(metadata.api_version.major_version, XLA_FFI_API_MAJOR);\n   EXPECT_EQ(metadata.api_version.minor_version, XLA_FFI_API_MINOR);\n+  EXPECT_EQ(metadata.state_type_id.type_id, XLA_FFI_UNKNOWN_TYPE_ID.type_id);\n }\n \n // Use opaque struct to define a platform stream type just like platform"
        }
    ],
    "stats": {
        "total": 189,
        "additions": 136,
        "deletions": 53
    }
}