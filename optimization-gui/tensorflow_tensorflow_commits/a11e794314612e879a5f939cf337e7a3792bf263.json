{
    "author": "ezhulenev",
    "message": "[xla] Make PjRtFuture<T>::Promise move-only\n\nPiperOrigin-RevId: 810247251",
    "sha": "a11e794314612e879a5f939cf337e7a3792bf263",
    "files": [
        {
            "sha": "69b7e61f2fca20012a95a8b3ba109301a0a87b3b",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 11,
            "deletions": 20,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a11e794314612e879a5f939cf337e7a3792bf263/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a11e794314612e879a5f939cf337e7a3792bf263/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=a11e794314612e879a5f939cf337e7a3792bf263",
            "patch": "@@ -477,6 +477,9 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n  public:\n   class Promise : public Base::Promise {\n    public:\n+    Promise(Promise&&) = default;\n+    Promise& operator=(Promise&&) = default;\n+\n     using Base::Promise::Promise;\n \n     // Sets the value of the promise. Must be called at most once.\n@@ -487,35 +490,23 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n       Base::Promise::emplace(std::move(value));\n     }\n \n-   private:\n-    template <typename>\n-    friend class PjRtFuture;\n-  };\n-\n-  // This is a temporary class to support migration from CreatePromise() to\n-  // MakePromise() and an end goal of making Promise move-only type.\n-  class MoveOnlyPromise : public Promise {\n-   public:\n-    using Promise::Promise;\n-    using Promise::Set;\n-\n-    MoveOnlyPromise(MoveOnlyPromise&&) = default;\n-    MoveOnlyPromise& operator=(MoveOnlyPromise&&) = default;\n-\n     // A helper function to convert move-only Promise to shared_ptr, which is\n     // useful when the promise has to be captured by a std::function.\n-    std::shared_ptr<MoveOnlyPromise> ToShared() && {\n-      return std::make_shared<MoveOnlyPromise>(std::move(*this));\n+    std::shared_ptr<Promise> ToShared() && {\n+      return std::make_shared<Promise>(std::move(*this));\n     }\n+\n+   private:\n+    template <typename>\n+    friend class PjRtFuture;\n   };\n \n   // Returns a pair of connected Promise and PjRtFuture<T>. Setting the returned\n   // promise will fulfill the connected future.\n-  static std::pair<MoveOnlyPromise, PjRtFuture<T>> MakePromise(\n+  static std::pair<Promise, PjRtFuture<T>> MakePromise(\n       PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n       PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) {\n-    MoveOnlyPromise promise(\n-        tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n+    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n     PjRtFuture<T> future(promise, std::move(on_block_start),\n                          std::move(on_block_end));\n     return std::make_pair(std::move(promise), std::move(future));"
        },
        {
            "sha": "f4dcb953a352d82b83acfb913c1dee791eeb6729",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/basic_string_array_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a11e794314612e879a5f939cf337e7a3792bf263/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a11e794314612e879a5f939cf337e7a3792bf263/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array_test.cc?ref=a11e794314612e879a5f939cf337e7a3792bf263",
            "patch": "@@ -199,8 +199,8 @@ TEST(BasicStringArrayTest, InvalidBuffersAreHandledCorrectly) {\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto ret, CreateNonReadyTestArray(client.get(), devices[0],\n                                         std::move(on_done_with_buffer)));\n-  auto array = ret.first;\n-  auto promise = ret.second;\n+  auto& array = ret.first;\n+  auto& promise = ret.second;\n   auto basic_string_array = llvm::dyn_cast<BasicStringArray>(array.get());\n \n   // Buffers with two shards and a single-device array are inconsistent."
        }
    ],
    "stats": {
        "total": 35,
        "additions": 13,
        "deletions": 22
    }
}