{
    "author": "vsytch",
    "message": "[XLA] Don't eagerly delete side effecting custom calls\n\nAfter cloning such custom calls, we need to unmark it as side effecting in order for it to be removed from the computation, however we should only do this to instructions who have already been offloaded, otherwise we'll prevent the rest from being potentially offloaded too.\n\nPiperOrigin-RevId: 837225989",
    "sha": "34e899a6915d673314c6d308466ce69cf63d3ffb",
    "files": [
        {
            "sha": "e2bb673ea7af1e097211396ab3beadcc49592702",
            "filename": "third_party/xla/xla/hlo/transforms/offloaded_instruction_wrapper.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 7,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34e899a6915d673314c6d308466ce69cf63d3ffb/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Foffloaded_instruction_wrapper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34e899a6915d673314c6d308466ce69cf63d3ffb/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Foffloaded_instruction_wrapper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Foffloaded_instruction_wrapper.cc?ref=34e899a6915d673314c6d308466ce69cf63d3ffb",
            "patch": "@@ -47,6 +47,13 @@ absl::Status ClearComputeTypeFrontendAttribute(HloInstruction* instr) {\n   return absl::OkStatus();\n }\n \n+void ClearSideEffects(HloInstruction* instr) {\n+  if (instr->opcode() == HloOpcode::kCustomCall) {\n+    static_cast<HloCustomCallInstruction*>(instr)\n+        ->set_custom_call_has_side_effect(false);\n+  }\n+}\n+\n }  // namespace\n \n absl::Status RecursivelyClearComputeTypeFrontendAttribute(\n@@ -126,6 +133,7 @@ FindAndWrapOffloadedComputations(\n             clear_backend_config_device_type(offloaded_call_instr));\n         TF_RETURN_IF_ERROR(\n             ClearComputeTypeFrontendAttribute(offloaded_call_instr));\n+        ClearSideEffects(instr);\n         offloaded_instr = instr;\n         continue;\n       }\n@@ -161,6 +169,7 @@ FindAndWrapOffloadedComputations(\n \n           offloaded_call_instr->AppendInstructionIntoCalledComputation(\n               instr, /*add_output=*/instr_escapes_offloaded_computation);\n+          ClearSideEffects(instr);\n           offloaded_instr = instr;\n         } else {\n           unmerged_ancestors.insert(instr);\n@@ -176,6 +185,7 @@ FindAndWrapOffloadedComputations(\n         // computation, include it anyway.\n         offloaded_call_instr->AppendInstructionIntoCalledComputation(\n             instr, /*add_output=*/true);\n+        ClearSideEffects(instr);\n         offloaded_instr = instr;\n       } else {\n         unmerged_ancestors.insert(instr);\n@@ -191,13 +201,6 @@ FindAndWrapOffloadedComputations(\n         std::pair(offloaded_instr, offloaded_call_instr));\n \n     for (HloInstruction* instr : computation.instructions()) {\n-      // If an offloaded instruction is a custom call marked with side effects.\n-      // Remove the annotation so it can be properly removed from the\n-      // original computation during DCE.\n-      if (instr->opcode() == HloOpcode::kCustomCall && should_offload(instr)) {\n-        static_cast<HloCustomCallInstruction*>(instr)\n-            ->set_custom_call_has_side_effect(false);\n-      }\n       // If an offloaded instruction is a Sharding custom call or has control\n       // dependencies (such as those around elided copies), remove it\n       // explicitly since it won't be removed by HloDCE."
        }
    ],
    "stats": {
        "total": 17,
        "additions": 10,
        "deletions": 7
    }
}