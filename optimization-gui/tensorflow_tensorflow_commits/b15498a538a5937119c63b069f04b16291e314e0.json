{
    "author": "tensorflower-gardener",
    "message": "Add Symbolic/Affine convertor methods for IndexingMap\n\n- Renamed and make public SymbolicToAffine to SymbolicExprToAffineExpr (needed for IndexingMap::GetConstraints)\n- Renamed AffineToSymbolicExpr to AffineExprToSymbolicExpr\n- Added AffineExprsToSymbolicExprs to convert a list of mlir::AffineExpr to a vector of xla::gpu::SymbolicExpr (needed for IndexingMap::ConstraintsSatisfied)\n\nPiperOrigin-RevId: 824492246",
    "sha": "b15498a538a5937119c63b069f04b16291e314e0",
    "files": [
        {
            "sha": "49273b189976e7faf793071f006d390b2f2195f1",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 22,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b15498a538a5937119c63b069f04b16291e314e0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b15498a538a5937119c63b069f04b16291e314e0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc?ref=b15498a538a5937119c63b069f04b16291e314e0",
            "patch": "@@ -27,15 +27,15 @@ limitations under the License.\n \n namespace xla {\n namespace gpu {\n-namespace {\n \n // Helper function to convert xla::gpu::SymbolicExpr to mlir::AffineExpr.\n-mlir::AffineExpr SymbolicToAffine(SymbolicExpr symbolic_expr,\n-                                  mlir::MLIRContext* context, int num_dims) {\n+mlir::AffineExpr SymbolicExprToAffineExpr(SymbolicExpr symbolic_expr,\n+                                          mlir::MLIRContext* context,\n+                                          int num_dims) {\n   mlir::AffineExpr lhs, rhs;\n   if (symbolic_expr.GetLHS() && symbolic_expr.GetRHS()) {\n-    lhs = SymbolicToAffine(symbolic_expr.GetLHS(), context, num_dims);\n-    rhs = SymbolicToAffine(symbolic_expr.GetRHS(), context, num_dims);\n+    lhs = SymbolicExprToAffineExpr(symbolic_expr.GetLHS(), context, num_dims);\n+    rhs = SymbolicExprToAffineExpr(symbolic_expr.GetRHS(), context, num_dims);\n     if (!lhs || !rhs) {\n       return mlir::AffineExpr();\n     }\n@@ -69,11 +69,20 @@ mlir::AffineExpr SymbolicToAffine(SymbolicExpr symbolic_expr,\n   }\n }\n \n-}  // namespace\n+llvm::SmallVector<SymbolicExpr> AffineExprsToSymbolicExprs(\n+    llvm::ArrayRef<mlir::AffineExpr> affine_exprs, SymbolicExprContext* context,\n+    int num_dims) {\n+  llvm::SmallVector<SymbolicExpr> symbolic_exprs;\n+  symbolic_exprs.reserve(affine_exprs.size());\n+  for (mlir::AffineExpr expr : affine_exprs) {\n+    symbolic_exprs.push_back(AffineExprToSymbolicExpr(expr, context, num_dims));\n+  }\n+  return symbolic_exprs;\n+}\n \n-// Helper function to convert mlir::AffineExpr to xla::gpu::SymbolicExpr.\n-SymbolicExpr AffineToSymbolicExpr(mlir::AffineExpr affine_expr,\n-                                  SymbolicExprContext* context, int num_dims) {\n+SymbolicExpr AffineExprToSymbolicExpr(mlir::AffineExpr affine_expr,\n+                                      SymbolicExprContext* context,\n+                                      int num_dims) {\n   switch (affine_expr.getKind()) {\n     case mlir::AffineExprKind::Constant:\n       return context->CreateConstant(\n@@ -87,28 +96,30 @@ SymbolicExpr AffineToSymbolicExpr(mlir::AffineExpr affine_expr,\n           num_dims);\n     case mlir::AffineExprKind::Add: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims) +\n-             AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims) +\n+             AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n     }\n     case mlir::AffineExprKind::Mul: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims) *\n-             AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims) *\n+             AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n     }\n     case mlir::AffineExprKind::FloorDiv: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n-          .floorDiv(AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n+          .floorDiv(\n+              AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n     }\n     case mlir::AffineExprKind::CeilDiv: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n-          .ceilDiv(AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n+          .ceilDiv(\n+              AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n     }\n     case mlir::AffineExprKind::Mod: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims) %\n-             AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims) %\n+             AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n     }\n   }\n }\n@@ -119,7 +130,7 @@ SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n   results.reserve(affine_map.getNumResults());\n   int num_dims = affine_map.getNumDims();\n   for (mlir::AffineExpr expr : affine_map.getResults()) {\n-    results.push_back(AffineToSymbolicExpr(expr, context, num_dims));\n+    results.push_back(AffineExprToSymbolicExpr(expr, context, num_dims));\n   }\n   return SymbolicMap::Get(context, num_dims, affine_map.getNumSymbols(),\n                           results);\n@@ -133,7 +144,7 @@ mlir::AffineMap SymbolicMapToAffineMap(SymbolicMap symbolic_map,\n   results.reserve(symbolic_map.GetNumResults());\n   for (SymbolicExpr expr : symbolic_map.GetResults()) {\n     mlir::AffineExpr affine_expr =\n-        SymbolicToAffine(expr, context, symbolic_map.GetNumDims());\n+        SymbolicExprToAffineExpr(expr, context, symbolic_map.GetNumDims());\n     if (!affine_expr) {\n       // Conversion failed.\n       return mlir::AffineMap();\n@@ -150,7 +161,8 @@ ConvertAffineConstraintsToSymbolicConstraints(\n     SymbolicExprContext* context, int num_dims) {\n   llvm::MapVector<SymbolicExpr, Interval> symbolic_constraints;\n   for (const auto& [affine_expr, interval] : affine_constraints) {\n-    SymbolicExpr expr = AffineToSymbolicExpr(affine_expr, context, num_dims);\n+    SymbolicExpr expr =\n+        AffineExprToSymbolicExpr(affine_expr, context, num_dims);\n     symbolic_constraints[expr] = interval;\n   }\n   return symbolic_constraints;"
        },
        {
            "sha": "007a25d7da1c6363b17323de4d571054b442cb26",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter.h",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b15498a538a5937119c63b069f04b16291e314e0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b15498a538a5937119c63b069f04b16291e314e0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h?ref=b15498a538a5937119c63b069f04b16291e314e0",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n #define XLA_SERVICE_GPU_MODEL_EXPERIMENTAL_SYMBOLIC_MAP_CONVERTER_H_\n \n #include \"llvm/ADT/MapVector.h\"\n+#include \"llvm/ADT/SmallVector.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/AffineMap.h\"\n #include \"mlir/IR/MLIRContext.h\"\n@@ -27,9 +28,20 @@ limitations under the License.\n namespace xla {\n namespace gpu {\n \n-// Helper function to convert mlir::AffineExpr to xla::gpu::SymbolicExpr.\n-SymbolicExpr AffineToSymbolicExpr(::mlir::AffineExpr affine_expr,\n-                                  SymbolicExprContext* context, int num_dims);\n+// Converts an mlir::AffineExpr to xla::gpu::SymbolicExpr.\n+SymbolicExpr AffineExprToSymbolicExpr(::mlir::AffineExpr affine_expr,\n+                                      SymbolicExprContext* context,\n+                                      int num_dims);\n+\n+// Converts a list of mlir::AffineExpr to xla::gpu::SymbolicExpr.\n+llvm::SmallVector<SymbolicExpr> AffineExprsToSymbolicExprs(\n+    llvm::ArrayRef<mlir::AffineExpr> affine_exprs, SymbolicExprContext* context,\n+    int num_dims);\n+\n+// Converts an xla::gpu::SymbolicExpr to an mlir::AffineExpr.\n+mlir::AffineExpr SymbolicExprToAffineExpr(SymbolicExpr symbolic_expr,\n+                                          mlir::MLIRContext* context,\n+                                          int num_dims);\n \n // Converts an mlir::AffineMap to xla::gpu::SymbolicMap.\n SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,"
        },
        {
            "sha": "83b0bfb54fbacebe570d448698a74920b610b967",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter_test.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b15498a538a5937119c63b069f04b16291e314e0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b15498a538a5937119c63b069f04b16291e314e0/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc?ref=b15498a538a5937119c63b069f04b16291e314e0",
            "patch": "@@ -102,6 +102,21 @@ TEST_F(SymbolicMapConverterTest, SymbolicToAffineNestedFailure) {\n   EXPECT_FALSE(affine_map);\n }\n \n+TEST_F(SymbolicMapConverterTest, AffineExprsToSymbolicExprs) {\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n+  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &mlir_context_);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context_);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context_);\n+  llvm::SmallVector<mlir::AffineExpr> affine_exprs = {d0, d1, s0, c1};\n+  llvm::SmallVector<SymbolicExpr> symbolic_exprs = AffineExprsToSymbolicExprs(\n+      affine_exprs, &symbolic_expr_context_, /*num_dims=*/2);\n+  EXPECT_EQ(symbolic_exprs.size(), 4);\n+  EXPECT_EQ(symbolic_exprs[0], symbolic_expr_context_.CreateVariable(0));\n+  EXPECT_EQ(symbolic_exprs[1], symbolic_expr_context_.CreateVariable(1));\n+  EXPECT_EQ(symbolic_exprs[2], symbolic_expr_context_.CreateVariable(2));\n+  EXPECT_EQ(symbolic_exprs[3], symbolic_expr_context_.CreateConstant(1));\n+}\n+\n TEST_F(SymbolicMapConverterTest,\n        ConvertAffineConstraintsToSymbolicConstraints) {\n   mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n@@ -153,8 +168,8 @@ TEST_F(SymbolicMapConverterTest, ConvertAffineToSymbolicExpr) {\n   SymbolicExpr expected_symbolic_expr =\n       ((exp_d0 * exp_c2 + exp_s0 - exp_c1) / exp_c2) % exp_c3 + exp_d1;\n \n-  EXPECT_EQ(AffineToSymbolicExpr(affine_expr, &symbolic_expr_context_,\n-                                 /*num_dims=*/2),\n+  EXPECT_EQ(AffineExprToSymbolicExpr(affine_expr, &symbolic_expr_context_,\n+                                     /*num_dims=*/2),\n             expected_symbolic_expr);\n }\n "
        }
    ],
    "stats": {
        "total": 93,
        "additions": 66,
        "deletions": 27
    }
}