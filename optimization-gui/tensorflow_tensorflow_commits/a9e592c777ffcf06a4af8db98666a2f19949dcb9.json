{
    "author": "mwhittaker",
    "message": "Speeds up XLA CPU runtime by allocating buffers topologically.\n\n# Overview\n\nThe XLA CPU compiler takes an HLO graph as input. After various optimizations,\nit schedules the graph into a total order. It then performs buffer assignment\nassuming the program will run in this total order.\n\nLater, however, a conflict graph is extracted from the buffer assignment. Two\ncomputations conflict if they touch the same regions of memory. This graph is\nthen executed across multiple threads. Notably, the program is not actually\nexecuted in the scheduled order.\n\nThe buffer assigner can sometimes assign two buffers to the same region in\nmemory because the two values are not alive at the same time *when executed in\nscheduled order*. However, they may be alive at the same time in *some other\ntopological order*. This means that the buffer assigner is falsely limiting the\namount of parallelism the program can execute in.\n\nThis CL changes the buffer assigner to not overlap buffers that may be alive at\nthe same time in any topological order. This increases parallelism at the cost\nof increased memory usage.\n\nPiperOrigin-RevId: 840319508",
    "sha": "a9e592c777ffcf06a4af8db98666a2f19949dcb9",
    "files": [
        {
            "sha": "d7746c1c5b4146e0b08cf0d2861e4d8b4448227b",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=a9e592c777ffcf06a4af8db98666a2f19949dcb9",
            "patch": "@@ -1810,6 +1810,8 @@ cc_library(\n         \"@com_google_absl//absl/container:btree\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n+        \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/memory\","
        },
        {
            "sha": "2ef71009638b1e8f4d801392a6641f1b4e4a45ce",
            "filename": "third_party/xla/xla/service/buffer_assignment.cc",
            "status": "modified",
            "additions": 71,
            "deletions": 32,
            "changes": 103,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc?ref=a9e592c777ffcf06a4af8db98666a2f19949dcb9",
            "patch": "@@ -34,6 +34,8 @@ limitations under the License.\n #include \"absl/container/btree_map.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/functional/bind_front.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/memory/memory.h\"\n@@ -80,6 +82,45 @@ using absl::StrAppendFormat;\n using memory_space_assignment::PresetAssignments;\n using ::tsl::strings::HumanReadableNumBytes;\n \n+std::optional<bool> CompareSize(\n+    absl::AnyInvocable<int64_t(const HloBuffer&)> size_of, const HloBuffer* a,\n+    const HloBuffer* b) {\n+  const int64_t a_size = size_of(*a);\n+  const int64_t b_size = size_of(*b);\n+  if (a_size != b_size) {\n+    return a_size > b_size;  // use \">\" for decreasing size.\n+  }\n+  return std::nullopt;\n+};\n+\n+std::optional<bool> CompareLiveOut(const HloAliasAnalysis* alias_analysis,\n+                                   const HloBuffer* a, const HloBuffer* b) {\n+  const bool a_live_out = alias_analysis->BufferLivesOut(*a);\n+  const bool b_live_out = alias_analysis->BufferLivesOut(*b);\n+  if (a_live_out != b_live_out) {\n+    return a_live_out;\n+  }\n+  return std::nullopt;\n+};\n+\n+std::optional<bool> ComparePosition(\n+    const absl::flat_hash_map<const HloInstruction*, int>* post_order_position,\n+    const HloBuffer* a, const HloBuffer* b) {\n+  auto compare = [post_order_position](const HloValue* value1,\n+                                       const HloValue* value2) {\n+    return post_order_position->at(value1->instruction()) <\n+           post_order_position->at(value2->instruction());\n+  };\n+  const HloValue* a_min = *absl::c_min_element(a->values(), compare);\n+  const HloValue* b_min = *absl::c_min_element(b->values(), compare);\n+  int a_position = post_order_position->at(a_min->instruction());\n+  int b_position = post_order_position->at(b_min->instruction());\n+  if (a_position != b_position) {\n+    return a_position < b_position;\n+  }\n+  return std::nullopt;\n+}\n+\n absl::flat_hash_map<int64_t, const HloInstruction*> BuildIdToHloInstructionMap(\n     const HloModule* module) {\n   // Build a map from a unique_id to corresponding HloInstruction in the module.\n@@ -1764,39 +1805,37 @@ absl::Status BufferAssigner::AssignBuffersForComputations(\n     }\n   }\n \n-  absl::c_sort(\n-      sorted_buffers, [&post_order_position, &alias_analysis, assignment](\n-                          const HloBuffer* a, const HloBuffer* b) {\n-        // Primary sort is by decreasing buffer size.\n-        const int64_t a_size = assignment->HloBufferSize(*a);\n-        const int64_t b_size = assignment->HloBufferSize(*b);\n-        if (a_size != b_size) {\n-          return a_size > b_size;  // use \">\" for decreasing size.\n-        }\n-\n-        const bool a_live_out = alias_analysis.BufferLivesOut(*a);\n-        const bool b_live_out = alias_analysis.BufferLivesOut(*b);\n-        if (a_live_out != b_live_out) {\n-          return a_live_out;\n-        }\n-        auto compare = [&post_order_position](const HloValue* value1,\n-                                              const HloValue* value2) {\n-          return post_order_position.at(value1->instruction()) <\n-                 post_order_position.at(value2->instruction());\n-        };\n-        const HloValue* a_min = *absl::c_min_element(a->values(), compare);\n-        const HloValue* b_min = *absl::c_min_element(b->values(), compare);\n-        if (post_order_position.at(a_min->instruction()) <\n-            post_order_position.at(b_min->instruction())) {\n-          return true;\n-        } else if (post_order_position.at(a_min->instruction()) >\n-                   post_order_position.at(b_min->instruction())) {\n-          return false;\n-        }\n+  using Comparator = absl::AnyInvocable<std::optional<bool>(\n+      const HloBuffer* a, const HloBuffer* b)>;\n+  auto size_of = absl::bind_front(&BufferAssignment::HloBufferSize, assignment);\n+  Comparator compare_size = absl::bind_front(CompareSize, size_of);\n+  Comparator compare_live_out =\n+      absl::bind_front(CompareLiveOut, &alias_analysis);\n+  Comparator compare_position =\n+      absl::bind_front(ComparePosition, &post_order_position);\n+  std::vector<Comparator> comparators;\n+  switch (opts_.buffer_order) {\n+    case BufferOrder::kBiggestFirst:\n+      comparators.push_back(std::move(compare_size));\n+      comparators.push_back(std::move(compare_live_out));\n+      comparators.push_back(std::move(compare_position));\n+      break;\n+    case BufferOrder::kTopological:\n+      comparators.push_back(std::move(compare_position));\n+      comparators.push_back(std::move(compare_size));\n+      comparators.push_back(std::move(compare_live_out));\n+      break;\n+  }\n \n-        // Use buffer ids to break ties and ensure a stable ordering.\n-        return a->id() < b->id();\n-      });\n+  absl::c_sort(sorted_buffers,\n+               [&comparators](const HloBuffer* a, const HloBuffer* b) {\n+                 for (Comparator& c : comparators) {\n+                   if (std::optional<bool> lt = c(a, b); lt.has_value()) {\n+                     return *lt;\n+                   }\n+                 }\n+                 return a->id() < b->id();\n+               });\n \n   std::vector<BufferAllocation::Index> allocation_indices;\n "
        },
        {
            "sha": "4dc66ead8061b2123060418c312723f0c07362af",
            "filename": "third_party/xla/xla/service/buffer_assignment.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h?ref=a9e592c777ffcf06a4af8db98666a2f19949dcb9",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n+#include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n@@ -719,6 +720,12 @@ class BufferAssigner {\n   using PrivateStacks = absl::flat_hash_map<BufferValue::Color,\n                                             std::vector<const HloComputation*>>;\n \n+  // The order in which to process buffers during buffer assignment.\n+  enum class BufferOrder {\n+    kBiggestFirst,  // Process the biggest buffers first.\n+    kTopological,   // Process buffers in topological order.\n+  };\n+\n   // Options for BufferAssigner::Run.\n   struct Options {\n     // If true, allocate buffers for constant instructions.\n@@ -741,6 +748,7 @@ class BufferAssigner {\n         heap_buffer_interval_compare;\n     std::optional<BufferAssignment::BufferIsolationOptions> isolation_options;\n     std::optional<BufferValue::Color> temp_buffer_color;\n+    BufferOrder buffer_order = BufferOrder::kBiggestFirst;\n   };\n \n   static Colorer DefaultColorer() {"
        },
        {
            "sha": "c2e6591a02e0f9fb059a2db06dca36b3a0799275",
            "filename": "third_party/xla/xla/service/cpu/cpu_compiler.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a9e592c777ffcf06a4af8db98666a2f19949dcb9/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc?ref=a9e592c777ffcf06a4af8db98666a2f19949dcb9",
            "patch": "@@ -2354,10 +2354,13 @@ CpuCompiler::CreateBufferAssignment(const HloModule& module) const {\n   AliasInfo alias_info;\n   BufferAssigner::Options opts;\n   opts.allocate_buffers_for_constants = true;\n-  return BufferAssigner::Run(\n-      &module, std::make_unique<SequentialHloOrdering>(module.schedule()),\n-      BufferSizeBytesFunction(), &alias_info, memory_alignment,\n-      std::move(opts));\n+  opts.buffer_order = BufferAssigner::BufferOrder::kTopological;\n+  // We use a DependencyHloOrdering rather than a SequentialHloOrdering to\n+  // increase the amount of concurrency the program can execute with.\n+  return BufferAssigner::Run(&module,\n+                             std::make_unique<DependencyHloOrdering>(&module),\n+                             BufferSizeBytesFunction(), &alias_info,\n+                             memory_alignment, std::move(opts));\n }\n \n }  // namespace cpu"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 88,
        "deletions": 36
    }
}