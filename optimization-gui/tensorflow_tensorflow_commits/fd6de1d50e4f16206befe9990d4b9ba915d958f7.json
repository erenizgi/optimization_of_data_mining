{
    "author": "Varcho",
    "message": "[Cleanup][ReplicaGroupV3] specify struct members in `GetDefaultCollectiveOpsCreator` so it is easier to understand and modify.\n\nPiperOrigin-RevId: 840804521",
    "sha": "fd6de1d50e4f16206befe9990d4b9ba915d958f7",
    "files": [
        {
            "sha": "3efed6ad73375a5c612b1905cc416cdb67ee6895",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner.cc",
            "status": "modified",
            "additions": 123,
            "deletions": 111,
            "changes": 234,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fd6de1d50e4f16206befe9990d4b9ba915d958f7/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fd6de1d50e4f16206befe9990d4b9ba915d958f7/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc?ref=fd6de1d50e4f16206befe9990d4b9ba915d958f7",
            "patch": "@@ -5061,121 +5061,133 @@ SPMDCollectiveOpsCreator GetDefaultCollectiveOpsCreator(int64_t num_partitions,\n             /*constrain_layout=*/false, channel_id,\n             /*use_global_device_ids=*/true));\n       };\n-  return {\n-      [](SpmdBuilder* b) {\n-        return b->AddInstruction(HloInstruction::CreatePartitionId());\n-      },\n-      [create_all_reduce_lists_of_lists](\n-          SpmdBuilder* b, HloInstruction* operand, HloComputation* reduction,\n-          const std::vector<std::vector<int64_t>>& partition_subgroups,\n-          int64_t channel_id) {\n-        return create_all_reduce_lists_of_lists(\n-            b, operand, reduction, partition_subgroups, channel_id);\n-      },\n-      [create_all_reduce_lists_of_lists, uses_all_partitions, num_replicas,\n-       num_partitions](SpmdBuilder* b, HloInstruction* operand,\n-                       HloComputation* reduction,\n-                       const IotaReplicaGroupList& partition_group_list,\n-                       int64_t channel_id) {\n-        // Fallback to list of lists collective creation if the partition group\n-        // list does not utilize all the partitions.\n-        if (!uses_all_partitions(partition_group_list)) {\n-          return create_all_reduce_lists_of_lists(\n-              b, operand, reduction,\n-              partition_group_list.flattened_replica_groups(), channel_id);\n-        }\n-        HloComputation* reduction_clone =\n-            reduction->parent()->AddComputationAndUnifyNamesAndIds(\n-                reduction->Clone(), false);\n-        HloInstruction* all_reduce =\n-            b->AddInstruction(HloInstruction::CreateAllReduce(\n-                operand->shape(), {operand}, reduction_clone,\n+\n+  SPMDCollectiveOpsCreator result = {\n+      .create_partition_id =\n+          [](SpmdBuilder* b) {\n+            return b->AddInstruction(HloInstruction::CreatePartitionId());\n+          },\n+      .create_cross_partition_all_reduce =\n+          [create_all_reduce_lists_of_lists](\n+              SpmdBuilder* b, HloInstruction* operand,\n+              HloComputation* reduction,\n+              const std::vector<std::vector<int64_t>>& partition_subgroups,\n+              int64_t channel_id) {\n+            return create_all_reduce_lists_of_lists(\n+                b, operand, reduction, partition_subgroups, channel_id);\n+          },\n+      .create_cross_partition_all_reduce_with_iota_device_list =\n+          [create_all_reduce_lists_of_lists, uses_all_partitions, num_replicas,\n+           num_partitions](SpmdBuilder* b, HloInstruction* operand,\n+                           HloComputation* reduction,\n+                           const IotaReplicaGroupList& partition_group_list,\n+                           int64_t channel_id) {\n+            // Fallback to list of lists collective creation if the partition\n+            // group list does not utilize all the partitions.\n+            if (!uses_all_partitions(partition_group_list)) {\n+              return create_all_reduce_lists_of_lists(\n+                  b, operand, reduction,\n+                  partition_group_list.flattened_replica_groups(), channel_id);\n+            }\n+            HloComputation* reduction_clone =\n+                reduction->parent()->AddComputationAndUnifyNamesAndIds(\n+                    reduction->Clone(), false);\n+            HloInstruction* all_reduce =\n+                b->AddInstruction(HloInstruction::CreateAllReduce(\n+                    operand->shape(), {operand}, reduction_clone,\n+                    ExpandPartitionGroupListAcrossReplicas(\n+                        partition_group_list, num_replicas, num_partitions),\n+                    /*constrain_layout=*/false, channel_id,\n+                    /*use_global_device_ids=*/true));\n+            return all_reduce;\n+          },\n+      .create_cross_partition_collective_permute =\n+          [num_partitions](\n+              SpmdBuilder* b, HloInstruction* operand,\n+              std::vector<std::pair<int64_t, int64_t>>& src_dst_pairs,\n+              int64_t channel_id) {\n+            /* optimize trivial collective permute */\n+            if (src_dst_pairs.empty()) {\n+              // If the src/dst pairs are empty, then the collective permute\n+              // just initializes the output to zero.\n+              return CreateZero(operand->shape(), b);\n+            }\n+            // A collective-permute is a copy if all pairs are \"identity\" and\n+            // all partitions are listed.\n+            bool is_copy =\n+                src_dst_pairs.size() == num_partitions &&\n+                absl::c_all_of(src_dst_pairs,\n+                               [](const std::pair<int64_t, int64_t>& pair) {\n+                                 return pair.first == pair.second;\n+                               });\n+            if (is_copy) {\n+              return operand;\n+            }\n+            return b->AddInstruction(HloInstruction::CreateCollectivePermute(\n+                operand->shape(), operand, src_dst_pairs, channel_id));\n+          },\n+      .create_cross_partition_all_to_all =\n+          [create_all_to_all_list_of_lists](\n+              SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n+              const std::vector<std::vector<int64_t>>& partition_subgroups,\n+              int64_t channel_id, std::optional<int64_t> split_dimension) {\n+            return create_all_to_all_list_of_lists(\n+                b, operands, partition_subgroups, channel_id, split_dimension);\n+          },\n+      .create_cross_partition_all_to_all_with_iota_device_list =\n+          [create_all_to_all_list_of_lists, uses_all_partitions, num_replicas,\n+           num_partitions](\n+              SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n+              const IotaReplicaGroupList& partition_group_list,\n+              int64_t channel_id, std::optional<int64_t> split_dimension) {\n+            // Fallback back to list of lists collective creation if the\n+            // partition group list does not utilize all the partitions.\n+            if (!uses_all_partitions(partition_group_list)) {\n+              return create_all_to_all_list_of_lists(\n+                  b, operands, partition_group_list.flattened_replica_groups(),\n+                  channel_id, split_dimension);\n+            }\n+            std::vector<Shape> shapes(operands.size(), operands[0]->shape());\n+            const Shape output_shape = (shapes.size() == 1)\n+                                           ? shapes[0]\n+                                           : ShapeUtil::MakeTupleShape(shapes);\n+            return b->AddInstruction(HloInstruction::CreateAllToAll(\n+                output_shape, operands,\n+                ExpandPartitionGroupListAcrossReplicas(\n+                    partition_group_list, num_replicas, num_partitions),\n+                /*constrain_layout=*/false, channel_id, split_dimension));\n+          },\n+      .create_cross_partition_all_gather =\n+          [create_all_gather_list_of_lists](\n+              SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n+              const std::vector<std::vector<int64_t>>& partition_subgroups,\n+              int64_t channel_id, int64_t all_gather_dimension) {\n+            return create_all_gather_list_of_lists(\n+                b, operand, ag_shape, partition_subgroups, channel_id,\n+                all_gather_dimension);\n+          },\n+      .create_cross_partition_all_gather_with_iota_device_list =\n+          [create_all_gather_list_of_lists, uses_all_partitions, num_replicas,\n+           num_partitions](SpmdBuilder* b, HloInstruction* operand,\n+                           const Shape& ag_shape,\n+                           const IotaReplicaGroupList& partition_group_list,\n+                           int64_t channel_id, int64_t all_gather_dimension) {\n+            // Fallback to list of lists collective creation if the partition\n+            // group list does not utilize all the partitions.\n+            if (!uses_all_partitions(partition_group_list)) {\n+              return create_all_gather_list_of_lists(\n+                  b, operand, ag_shape,\n+                  partition_group_list.flattened_replica_groups(), channel_id,\n+                  all_gather_dimension);\n+            }\n+            return b->AddInstruction(HloInstruction::CreateAllGather(\n+                ag_shape, {operand}, all_gather_dimension,\n                 ExpandPartitionGroupListAcrossReplicas(\n                     partition_group_list, num_replicas, num_partitions),\n                 /*constrain_layout=*/false, channel_id,\n                 /*use_global_device_ids=*/true));\n-        return all_reduce;\n-      },\n-      [num_partitions](SpmdBuilder* b, HloInstruction* operand,\n-                       std::vector<std::pair<int64_t, int64_t>>& src_dst_pairs,\n-                       int64_t channel_id) {\n-        /* optimize trivial collective permute */\n-        if (src_dst_pairs.empty()) {\n-          // If the src/dst pairs are empty, then the collective permute\n-          // just initializes the output to zero.\n-          return CreateZero(operand->shape(), b);\n-        }\n-        // A collective-permute is a copy if all pairs are \"identity\" and\n-        // all partitions are listed.\n-        bool is_copy =\n-            src_dst_pairs.size() == num_partitions &&\n-            absl::c_all_of(src_dst_pairs,\n-                           [](const std::pair<int64_t, int64_t>& pair) {\n-                             return pair.first == pair.second;\n-                           });\n-        if (is_copy) {\n-          return operand;\n-        }\n-        return b->AddInstruction(HloInstruction::CreateCollectivePermute(\n-            operand->shape(), operand, src_dst_pairs, channel_id));\n-      },\n-      [create_all_to_all_list_of_lists](\n-          SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n-          const std::vector<std::vector<int64_t>>& partition_subgroups,\n-          int64_t channel_id, std::optional<int64_t> split_dimension) {\n-        return create_all_to_all_list_of_lists(b, operands, partition_subgroups,\n-                                               channel_id, split_dimension);\n-      },\n-      [create_all_to_all_list_of_lists, uses_all_partitions, num_replicas,\n-       num_partitions](\n-          SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n-          const IotaReplicaGroupList& partition_group_list, int64_t channel_id,\n-          std::optional<int64_t> split_dimension) {\n-        // Fallback back to list of lists collective creation if the partition\n-        // group list does not utilize all the partitions.\n-        if (!uses_all_partitions(partition_group_list)) {\n-          return create_all_to_all_list_of_lists(\n-              b, operands, partition_group_list.flattened_replica_groups(),\n-              channel_id, split_dimension);\n-        }\n-        std::vector<Shape> shapes(operands.size(), operands[0]->shape());\n-        const Shape output_shape = (shapes.size() == 1)\n-                                       ? shapes[0]\n-                                       : ShapeUtil::MakeTupleShape(shapes);\n-        return b->AddInstruction(HloInstruction::CreateAllToAll(\n-            output_shape, operands,\n-            ExpandPartitionGroupListAcrossReplicas(\n-                partition_group_list, num_replicas, num_partitions),\n-            /*constrain_layout=*/false, channel_id, split_dimension));\n-      },\n-      [create_all_gather_list_of_lists](\n-          SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n-          const std::vector<std::vector<int64_t>>& partition_subgroups,\n-          int64_t channel_id, int64_t all_gather_dimension) {\n-        return create_all_gather_list_of_lists(b, operand, ag_shape,\n-                                               partition_subgroups, channel_id,\n-                                               all_gather_dimension);\n-      },\n-      [create_all_gather_list_of_lists, uses_all_partitions, num_replicas,\n-       num_partitions](SpmdBuilder* b, HloInstruction* operand,\n-                       const Shape& ag_shape,\n-                       const IotaReplicaGroupList& partition_group_list,\n-                       int64_t channel_id, int64_t all_gather_dimension) {\n-        // Fallback to list of lists collective creation if the partition group\n-        // list does not utilize all the partitions.\n-        if (!uses_all_partitions(partition_group_list)) {\n-          return create_all_gather_list_of_lists(\n-              b, operand, ag_shape,\n-              partition_group_list.flattened_replica_groups(), channel_id,\n-              all_gather_dimension);\n-        }\n-        return b->AddInstruction(HloInstruction::CreateAllGather(\n-            ag_shape, {operand}, all_gather_dimension,\n-            ExpandPartitionGroupListAcrossReplicas(\n-                partition_group_list, num_replicas, num_partitions),\n-            /*constrain_layout=*/false, channel_id,\n-            /*use_global_device_ids=*/true));\n-      }};\n+          }};\n+  return result;\n }\n \n SpmdPartitioner::SpmdPartitioner(int64_t num_partitions, int64_t num_replicas,"
        }
    ],
    "stats": {
        "total": 234,
        "additions": 123,
        "deletions": 111
    }
}