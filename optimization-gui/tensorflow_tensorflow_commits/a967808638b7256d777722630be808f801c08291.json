{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845641559",
    "sha": "a967808638b7256d777722630be808f801c08291",
    "files": [
        {
            "sha": "f62268f3a40d3f226108a661878b94644d8b4da9",
            "filename": "tensorflow/core/distributed_runtime/eager/cluster_function_library_runtime.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fcluster_function_library_runtime.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fcluster_function_library_runtime.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fcluster_function_library_runtime.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -54,7 +54,7 @@ void StripDefaultAttributesInRegisterFunctionOp(\n }  // namespace\n \n void EagerClusterFunctionLibraryRuntime::Instantiate(\n-    const string& function_name, const FunctionLibraryDefinition& lib_def,\n+    const std::string& function_name, const FunctionLibraryDefinition& lib_def,\n     AttrSlice attrs, const FunctionLibraryRuntime::InstantiateOptions& options,\n     FunctionLibraryRuntime::LocalHandle* handle,\n     FunctionLibraryRuntime::DoneCallback done) {\n@@ -281,7 +281,7 @@ void EagerClusterFunctionLibraryRuntime::Run(\n }\n \n void EagerClusterFunctionLibraryRuntime::CleanUp(\n-    uint64 step_id, FunctionLibraryRuntime::LocalHandle handle,\n+    uint64_t step_id, FunctionLibraryRuntime::LocalHandle handle,\n     FunctionLibraryRuntime::DoneCallback done) {\n   FunctionData* function_data = nullptr;\n   {\n@@ -312,7 +312,8 @@ void EagerClusterFunctionLibraryRuntime::CleanUp(\n }\n \n DistributedFunctionLibraryRuntime* CreateClusterFLR(\n-    const uint64 context_id, EagerContext* ctx, WorkerSession* worker_session) {\n+    const uint64_t context_id, EagerContext* ctx,\n+    WorkerSession* worker_session) {\n   return new EagerClusterFunctionLibraryRuntime(\n       context_id, ctx, worker_session->remote_device_mgr());\n }"
        },
        {
            "sha": "6fb1fc280f0638b7943b0eaca9ee4212952ad1b1",
            "filename": "tensorflow/core/distributed_runtime/eager/cluster_function_library_runtime.h",
            "status": "modified",
            "additions": 9,
            "deletions": 7,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fcluster_function_library_runtime.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fcluster_function_library_runtime.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fcluster_function_library_runtime.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -37,7 +37,8 @@ namespace eager {\n class EagerClusterFunctionLibraryRuntime\n     : public DistributedFunctionLibraryRuntime {\n  public:\n-  EagerClusterFunctionLibraryRuntime(const uint64 context_id, EagerContext* ctx,\n+  EagerClusterFunctionLibraryRuntime(const uint64_t context_id,\n+                                     EagerContext* ctx,\n                                      DeviceMgr* remote_device_mgr)\n       : context_id_(context_id),\n         ctx_(ctx),\n@@ -49,7 +50,7 @@ class EagerClusterFunctionLibraryRuntime\n   // on the remote target specified in `options.target`. This should be\n   // triggered as part of instantiating a multi-device function in\n   // ProcessFunctionLibraryRuntime.\n-  void Instantiate(const string& function_name,\n+  void Instantiate(const std::string& function_name,\n                    const FunctionLibraryDefinition& lib_def, AttrSlice attrs,\n                    const FunctionLibraryRuntime::InstantiateOptions& options,\n                    FunctionLibraryRuntime::LocalHandle* handle,\n@@ -75,23 +76,23 @@ class EagerClusterFunctionLibraryRuntime\n            absl::Span<const FunctionArg> args, std::vector<FunctionRet>* rets,\n            FunctionLibraryRuntime::DoneCallback done) override;\n \n-  void CleanUp(uint64 step_id, FunctionLibraryRuntime::LocalHandle handle,\n+  void CleanUp(uint64_t step_id, FunctionLibraryRuntime::LocalHandle handle,\n                FunctionLibraryRuntime::DoneCallback done) override;\n \n   DeviceMgr* remote_device_mgr() const override { return remote_device_mgr_; }\n \n  private:\n-  const uint64 context_id_;\n+  const uint64_t context_id_;\n   EagerContext* ctx_;\n   DeviceMgr* remote_device_mgr_;  // not owned.\n \n   struct FunctionData {\n-    const string target;\n+    const std::string target;\n     const absl::optional<std::vector<int>> ret_indices;\n     core::RefCountPtr<EagerClient> eager_client;\n     std::unique_ptr<EagerOperation> op;\n \n-    FunctionData(const string& target,\n+    FunctionData(const std::string& target,\n                  const absl::optional<std::vector<int>>& ret_indices,\n                  EagerClient* eager_client, std::unique_ptr<EagerOperation> op)\n         : target(target),\n@@ -107,7 +108,8 @@ class EagerClusterFunctionLibraryRuntime\n };\n \n DistributedFunctionLibraryRuntime* CreateClusterFLR(\n-    const uint64 context_id, EagerContext* ctx, WorkerSession* worker_session);\n+    const uint64_t context_id, EagerContext* ctx,\n+    WorkerSession* worker_session);\n \n }  // namespace eager\n }  // namespace tensorflow"
        },
        {
            "sha": "a0991dc601be4e659dcb0e48e8cde2d64415f207",
            "filename": "tensorflow/core/distributed_runtime/eager/destroy_tensor_handle_node.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fdestroy_tensor_handle_node.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fdestroy_tensor_handle_node.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fdestroy_tensor_handle_node.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -71,16 +71,16 @@ class DestroyTensorHandleNode : public tensorflow::AsyncEagerNode {\n   // Remote node deletions are best effort\n   bool Fatal() const override { return false; }\n \n-  string DebugString() const override {\n-    string out = \"[DestroyTensorHandleNode]\";\n+  std::string DebugString() const override {\n+    std::string out = \"[DestroyTensorHandleNode]\";\n     absl::StrAppend(&out, \" request: \", request_->DebugString());\n     return out;\n   }\n \n  private:\n   std::unique_ptr<EnqueueRequest> request_;\n   core::RefCountPtr<EagerClient> eager_client_;\n-  const string remote_task_;\n+  const std::string remote_task_;\n   bool ready_;\n };\n "
        },
        {
            "sha": "a2a3d596bff10aec93e8de80184f631260e3b6cc",
            "filename": "tensorflow/core/distributed_runtime/eager/eager_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_client.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -92,7 +92,7 @@ class EagerClientCache {\n   // increment the refcount of the client. The reference ownership is\n   // transferred to the caller, and the unref should automatically happen when\n   // destructing the RefCountPtr object from the caller's side.\n-  virtual absl::Status GetClient(const string& target,\n+  virtual absl::Status GetClient(const std::string& target,\n                                  core::RefCountPtr<EagerClient>* client) = 0;\n };\n "
        },
        {
            "sha": "abae4bdce1d23a9cfbfee8cf2f1b69a6214a6919",
            "filename": "tensorflow/core/distributed_runtime/eager/eager_service_impl.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 15,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -59,8 +59,9 @@ namespace eager {\n \n namespace {\n absl::Status GetNumRetvals(\n-    FunctionLibraryDefinition* func_lib_def, const string& op_name,\n-    const google::protobuf::Map<string, tensorflow::AttrValue>& attrs, int* num_retvals) {\n+    FunctionLibraryDefinition* func_lib_def, const std::string& op_name,\n+    const google::protobuf::Map<std::string, tensorflow::AttrValue>& attrs,\n+    int* num_retvals) {\n   const tensorflow::OpRegistrationData* op_reg_data = nullptr;\n   auto status = tensorflow::OpRegistry::Global()->LookUp(op_name, &op_reg_data);\n   if (absl::IsNotFound(status)) {\n@@ -189,10 +190,10 @@ absl::Status TensorHandleShape(TensorHandle* handle, TensorShapeProto* proto) {\n \n absl::Status AddOpRetvalsToResponse(\n     EagerContext* eager_context, int op_id, int num_retvals,\n-    const std::vector<int32>& output_nums, TensorHandle** retvals,\n+    const std::vector<int32_t>& output_nums, TensorHandle** retvals,\n     std::function<TensorProto*()> add_tensor_proto_fn,\n     std::function<TensorShapeProto*()> add_shape_proto_fn,\n-    std::function<string*()> add_device_fn = nullptr) {\n+    std::function<std::string*()> add_device_fn = nullptr) {\n   // retvals hold references to the allocated output tensor handles. If errors\n   // happen with adding some results to the response, aggregate the status in sg\n   // instead of directly returning the error, to make sure unref or ownership\n@@ -291,7 +292,7 @@ absl::Status EagerServiceImpl::CreateContext(\n     TF_RETURN_IF_ERROR(env_->session_mgr->DeleteAllSessions());\n \n     // Cleanup existing contexts if any.\n-    std::unordered_map<uint64, ServerContext*> tmp_contexts;\n+    std::unordered_map<uint64_t, ServerContext*> tmp_contexts;\n     {\n       mutex_lock l(contexts_mu_);\n       if (!contexts_.empty()) {\n@@ -372,7 +373,7 @@ absl::Status EagerServiceImpl::CreateContext(\n   // case ctx will be deleted by this unref.\n   core::ScopedUnref unref_ctx(ctx);\n \n-  std::vector<string> remote_workers;\n+  std::vector<std::string> remote_workers;\n   worker_session->worker_cache()->ListWorkers(&remote_workers);\n   remote_workers.erase(std::remove(remote_workers.begin(), remote_workers.end(),\n                                    worker_session->worker_name()),\n@@ -500,15 +501,15 @@ absl::Status EagerServiceImpl::UpdateContext(\n \n   const tensorflow::DeviceMgr* device_mgr = worker_session->device_mgr();\n \n-  std::vector<string> remote_workers;\n+  std::vector<std::string> remote_workers;\n   worker_session->worker_cache()->ListWorkers(&remote_workers);\n   remote_workers.erase(std::remove(remote_workers.begin(), remote_workers.end(),\n                                    worker_session->worker_name()),\n                        remote_workers.end());\n   VLOG(1) << \"On existing server \" << worker_session->worker_name()\n           << \" updating remote workers\";\n   if (VLOG_IS_ON(2)) {\n-    for (const string& rw : remote_workers) {\n+    for (const std::string& rw : remote_workers) {\n       VLOG(2) << \"Remote worker \" << rw;\n     }\n   }\n@@ -546,8 +547,8 @@ absl::Status EagerServiceImpl::UpdateContext(\n   return absl::OkStatus();\n }\n \n-absl::Status EagerServiceImpl::CreateMasterContext(\n-    const tensorflow::uint64 context_id, EagerContext* context) {\n+absl::Status EagerServiceImpl::CreateMasterContext(const uint64_t context_id,\n+                                                   EagerContext* context) {\n   {\n     mutex_lock l(contexts_mu_);\n     auto iter = contexts_.find(context_id);\n@@ -616,7 +617,7 @@ void EagerServiceImpl::RunComponentFunction(\n   auto* retvals = new absl::FixedArray<TensorHandle*>(*num_retvals);\n   VLOG(3) << \"ServerContext: Calling EagerLocalExecuteAsync for op \"\n           << operation.id();\n-  std::vector<int32> output_nums;\n+  std::vector<int32_t> output_nums;\n   for (const int32_t output_num : request->output_num()) {\n     output_nums.push_back(output_num);\n   }\n@@ -676,7 +677,7 @@ absl::Status EagerServiceImpl::ExecuteOp(CallOptions* call_opts,\n           num_retvals),\n       &num_retvals));\n \n-  std::function<string*()> add_device_fn = nullptr;\n+  std::function<std::string*()> add_device_fn = nullptr;\n   // Send the output devices of a function back to let a client know where the\n   // outputs are. For a primitive op, an output devics is the op device which is\n   // known on a client.\n@@ -694,7 +695,7 @@ absl::Status EagerServiceImpl::ExecuteOp(CallOptions* call_opts,\n absl::Status EagerServiceImpl::Enqueue(CallOptions* call_opts,\n                                        const EnqueueRequest* request,\n                                        EnqueueResponse* response,\n-                                       uint64 stream_id) {\n+                                       uint64_t stream_id) {\n   tsl::profiler::TraceMe activity(\n       [&] {\n         return absl::StrCat(\n@@ -901,12 +902,12 @@ absl::Status EagerServiceImpl::SendPackedHandle(\n }\n \n absl::Status EagerServiceImpl::GetServerContext(\n-    uint64 context_id, ServerContext** server_context) {\n+    uint64_t context_id, ServerContext** server_context) {\n   tf_shared_lock l(contexts_mu_);\n   auto iter = contexts_.find(context_id);\n   if (iter == contexts_.end()) {\n     *server_context = nullptr;\n-    return errors::Aborted(strings::Printf(\n+    return errors::Aborted(absl::StrFormat(\n         \"Unable to find a context_id matching the specified one \"\n         \"(%llu). Perhaps the worker was restarted, or the context was GC'd?\",\n         static_cast<unsigned long long>(context_id)));"
        },
        {
            "sha": "90d49cc7a64e197640ca80eaa9eb6345415778e9",
            "filename": "tensorflow/core/distributed_runtime/eager/eager_service_impl.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -83,15 +83,15 @@ class EagerServiceImpl {\n                              UpdateContextResponse* response);\n \n   // Create a ServerContext for master eager context.\n-  absl::Status CreateMasterContext(const tensorflow::uint64 context_id,\n+  absl::Status CreateMasterContext(const uint64_t context_id,\n                                    EagerContext* context);\n \n-  static constexpr uint64 kInvalidStreamId = 0;\n+  static constexpr uint64_t kInvalidStreamId = 0;\n \n   // Used by both Enqueue and StreamingEnqueue RPCs.\n   absl::Status Enqueue(CallOptions* call_opts, const EnqueueRequest* request,\n                        EnqueueResponse* response,\n-                       uint64 stream_id = kInvalidStreamId);\n+                       uint64_t stream_id = kInvalidStreamId);\n \n   absl::Status WaitQueueDone(const WaitQueueDoneRequest* request,\n                              WaitQueueDoneResponse* response);\n@@ -166,7 +166,7 @@ class EagerServiceImpl {\n     const bool is_master_;\n   };\n   // The returned ServerContext will need to be Unrefed.\n-  absl::Status GetServerContext(uint64, ServerContext**);\n+  absl::Status GetServerContext(uint64_t, ServerContext**);\n \n   class ClientTensorHandleDeleteNode : public EagerNode {\n    public:\n@@ -194,8 +194,8 @@ class EagerServiceImpl {\n     // Remote node deletions are best effort\n     bool Fatal() const override { return false; }\n \n-    string DebugString() const override {\n-      string out = \"[ClientTensorHandleDeleteNode]\";\n+    std::string DebugString() const override {\n+      std::string out = \"[ClientTensorHandleDeleteNode]\";\n       absl::StrAppend(&out, \" op_id: \", handle_to_delete_->op_id);\n       absl::StrAppend(&out, \", output_num: \", handle_to_delete_->output_num);\n       return out;\n@@ -225,7 +225,7 @@ class EagerServiceImpl {\n   WorkerEnv* const env_;  // Not owned.\n \n   mutex contexts_mu_;\n-  std::unordered_map<uint64, ServerContext*> contexts_\n+  std::unordered_map<uint64_t, ServerContext*> contexts_\n       TF_GUARDED_BY(contexts_mu_);\n \n   std::unique_ptr<Thread> gc_thread_;"
        },
        {
            "sha": "e9be274d4fea19450eb8c9cf8b1d5ab6a7aeb692",
            "filename": "tensorflow/core/distributed_runtime/eager/eager_service_impl_test.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 49,
            "changes": 102,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Feager_service_impl_test.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -56,14 +56,14 @@ namespace {\n class TestEagerServiceImpl : public EagerServiceImpl {\n  public:\n   explicit TestEagerServiceImpl(WorkerEnv* env) : EagerServiceImpl(env) {}\n-  absl::Status GetEagerContext(const uint64 context_id, EagerContext** ctx) {\n+  absl::Status GetEagerContext(const uint64_t context_id, EagerContext** ctx) {\n     ServerContext* context = nullptr;\n     TF_RETURN_IF_ERROR(GetServerContext(context_id, &context));\n     core::ScopedUnref context_unref(context);\n     *ctx = context->Context();\n     return absl::OkStatus();\n   }\n-  absl::Status GetTensorHandle(const uint64 context_id,\n+  absl::Status GetTensorHandle(const uint64_t context_id,\n                                const RemoteTensorHandleInternal& remote_handle,\n                                tensorflow::TensorHandle** handle) {\n     ServerContext* context = nullptr;\n@@ -136,7 +136,7 @@ class FakeEagerClient : public EagerClient {\n class DummyEagerClientCache : public EagerClientCache {\n  public:\n   DummyEagerClientCache() : client_(new FakeEagerClient) {}\n-  absl::Status GetClient(const string& target,\n+  absl::Status GetClient(const std::string& target,\n                          core::RefCountPtr<EagerClient>* client) override {\n     client->reset(client_.get());\n     client_->Ref();\n@@ -154,7 +154,7 @@ class FakeCache : public TestWorkerCache {\n     return absl::OkStatus();\n   }\n \n-  void ListWorkers(std::vector<string>* workers) const override {\n+  void ListWorkers(std::vector<std::string>* workers) const override {\n     workers->push_back(\"/job:localhost/replica:0/task:0\");\n   }\n };\n@@ -202,10 +202,11 @@ void SetTensorProto(TensorProto* tensor_proto) {\n }\n \n void BuildOperation(\n-    Operation* operation, int64_t id, const string& name,\n-    const std::vector<std::variant<TensorProto, std::pair<int64_t, int32>>>&\n+    Operation* operation, int64_t id, const std::string& name,\n+    const std::vector<std::variant<TensorProto, std::pair<int64_t, int32_t>>>&\n         inputs,\n-    const std::unordered_map<string, AttrValue>& attrs, const string& device) {\n+    const std::unordered_map<std::string, AttrValue>& attrs,\n+    const std::string& device) {\n   operation->set_id(id);\n   operation->set_name(name);\n   operation->set_device(device);\n@@ -216,7 +217,7 @@ void BuildOperation(\n           std::get<TensorProto>(input);\n     } else {\n       const auto& tensor_handle_pair =\n-          std::get<std::pair<int64_t, int32>>(input);\n+          std::get<std::pair<int64_t, int32_t>>(input);\n       auto* input = operation->add_op_inputs()->mutable_remote_handle();\n       input->set_op_id(tensor_handle_pair.first);\n       input->set_output_num(tensor_handle_pair.second);\n@@ -231,21 +232,22 @@ void BuildOperation(\n }\n \n void AddOperationToEnqueueRequest(\n-    int64_t id, const string& name,\n-    const std::vector<std::variant<TensorProto, std::pair<int64_t, int32>>>&\n+    int64_t id, const std::string& name,\n+    const std::vector<std::variant<TensorProto, std::pair<int64_t, int32_t>>>&\n         inputs,\n-    const std::unordered_map<string, AttrValue>& attrs, const string& device,\n-    EnqueueRequest* request) {\n+    const std::unordered_map<std::string, AttrValue>& attrs,\n+    const std::string& device, EnqueueRequest* request) {\n   auto* operation = request->add_queue()->mutable_operation();\n   BuildOperation(operation, id, name, inputs, attrs, device);\n }\n \n void AddOperationToRunComponentFunctionRequest(\n-    int64_t id, const string& name,\n-    const std::vector<std::variant<TensorProto, std::pair<int64_t, int32>>>&\n+    int64_t id, const std::string& name,\n+    const std::vector<std::variant<TensorProto, std::pair<int64_t, int32_t>>>&\n         inputs,\n-    const std::unordered_map<string, AttrValue>& attrs, const string& device,\n-    const int output_num, RunComponentFunctionRequest* request) {\n+    const std::unordered_map<std::string, AttrValue>& attrs,\n+    const std::string& device, const int output_num,\n+    RunComponentFunctionRequest* request) {\n   auto* operation = request->mutable_operation();\n   operation->set_is_function(true);\n   operation->set_is_component_function(true);\n@@ -450,7 +452,7 @@ tensorflow::FunctionDef SingleRecvNodeFunction() {\n TEST_F(EagerServiceImplTest, BasicTest) {\n   TestEagerServiceImpl eager_service_impl(&worker_env_);\n \n-  uint64 context_id = random::New64();\n+  uint64_t context_id = random::New64();\n \n   CreateContextRequest request;\n   request.mutable_server_def()->set_job_name(\"localhost\");\n@@ -464,7 +466,7 @@ TEST_F(EagerServiceImplTest, BasicTest) {\n   remote_enqueue_request.set_context_id(context_id);\n   EnqueueResponse remote_enqueue_response;\n \n-  std::unordered_map<string, AttrValue> const_attrs;\n+  std::unordered_map<std::string, AttrValue> const_attrs;\n   AttrValue val;\n   val.set_type(tensorflow::DataType::DT_FLOAT);\n   const_attrs.insert({\"dtype\", val});\n@@ -476,7 +478,7 @@ TEST_F(EagerServiceImplTest, BasicTest) {\n                                \"/job:localhost/replica:0/task:0/device:CPU:0\",\n                                &remote_enqueue_request);\n \n-  std::unordered_map<string, AttrValue> attrs;\n+  std::unordered_map<std::string, AttrValue> attrs;\n   val.Clear();\n   val.set_type(tensorflow::DataType::DT_FLOAT);\n   attrs.insert({\"T\", val});\n@@ -529,12 +531,12 @@ class EagerServiceImplFunctionTest : public EagerServiceImplTest {\n \n   // Creates a context and attempts to execute a function.\n   void TestFunction(const RegisterFunctionOp& register_op,\n-                    const string& function_name,\n+                    const std::string& function_name,\n                     const bool local_inputs = false,\n                     const bool test_cancel = false) {\n     TestEagerServiceImpl eager_service_impl(&worker_env_);\n \n-    uint64 context_id = random::New64();\n+    uint64_t context_id = random::New64();\n \n     CreateContextRequest request;\n     request.mutable_server_def()->set_job_name(\"localhost\");\n@@ -561,12 +563,12 @@ class EagerServiceImplFunctionTest : public EagerServiceImplTest {\n       SetTensorProto(&tensor_proto);\n       AddOperationToEnqueueRequest(\n           2, function_name, {tensor_proto},\n-          std::unordered_map<string, AttrValue>(),\n+          std::unordered_map<std::string, AttrValue>(),\n           \"/job:localhost/replica:0/task:0/device:CPU:0\",\n           &remote_enqueue_request);\n \n     } else {\n-      std::unordered_map<string, AttrValue> const_attrs;\n+      std::unordered_map<std::string, AttrValue> const_attrs;\n       AttrValue val;\n       val.set_type(tensorflow::DataType::DT_FLOAT);\n       const_attrs.insert({\"dtype\", val});\n@@ -581,7 +583,7 @@ class EagerServiceImplFunctionTest : public EagerServiceImplTest {\n           &remote_enqueue_request);\n       AddOperationToEnqueueRequest(\n           2, function_name, {std::make_pair(1, 0)},\n-          std::unordered_map<string, AttrValue>(),\n+          std::unordered_map<std::string, AttrValue>(),\n           \"/job:localhost/replica:0/task:0/device:CPU:0\",\n           &remote_enqueue_request);\n     }\n@@ -629,10 +631,10 @@ class EagerServiceImplFunctionTest : public EagerServiceImplTest {\n \n   // Creates a context and attempts to execute a component function.\n   void TestComponentFunction(const RegisterFunctionOp& register_op,\n-                             const string& function_name,\n+                             const std::string& function_name,\n                              const bool test_cancel) {\n     TestEagerServiceImpl eager_service_impl(&worker_env_);\n-    uint64 context_id = random::New64();\n+    uint64_t context_id = random::New64();\n \n     // Create context.\n     CreateContextRequest request;\n@@ -655,7 +657,7 @@ class EagerServiceImplFunctionTest : public EagerServiceImplTest {\n     remote_enqueue_request.set_context_id(context_id);\n     EnqueueResponse remote_enqueue_response;\n \n-    std::unordered_map<string, AttrValue> const_attrs;\n+    std::unordered_map<std::string, AttrValue> const_attrs;\n     AttrValue val;\n     val.set_type(tensorflow::DataType::DT_FLOAT);\n     const_attrs.insert({\"dtype\", val});\n@@ -675,7 +677,7 @@ class EagerServiceImplFunctionTest : public EagerServiceImplTest {\n     const int output_num = 5;\n     AddOperationToRunComponentFunctionRequest(\n         2, function_name, {std::make_pair(1, 0)},\n-        std::unordered_map<string, AttrValue>(),\n+        std::unordered_map<std::string, AttrValue>(),\n         \"/job:localhost/replica:0/task:0/device:CPU:0\", output_num,\n         &run_comp_func_request);\n \n@@ -772,7 +774,7 @@ TEST_F(EagerServiceImplFunctionTest, ComponentNestedFunctionTest) {\n \n TEST_F(EagerServiceImplFunctionTest, ComponentNestedFunctionWithNameClashTest) {\n   TestEagerServiceImpl eager_service_impl(&worker_env_);\n-  uint64 context_id = random::New64();\n+  uint64_t context_id = random::New64();\n \n   // Create context.\n   CreateContextRequest request;\n@@ -820,7 +822,7 @@ TEST_F(EagerServiceImplFunctionTest, ComponentNestedFunctionWithNameClashTest) {\n   remote_enqueue_request.set_context_id(context_id);\n   EnqueueResponse remote_enqueue_response;\n \n-  std::unordered_map<string, AttrValue> const_attrs;\n+  std::unordered_map<std::string, AttrValue> const_attrs;\n   AttrValue val;\n   val.set_type(tensorflow::DataType::DT_FLOAT);\n   const_attrs.insert({\"dtype\", val});\n@@ -841,7 +843,7 @@ TEST_F(EagerServiceImplFunctionTest, ComponentNestedFunctionWithNameClashTest) {\n     const int output_num = 5;\n     AddOperationToRunComponentFunctionRequest(\n         2, \"MatMulNestedFunction\", {std::make_pair(1, 0)},\n-        std::unordered_map<string, AttrValue>(),\n+        std::unordered_map<std::string, AttrValue>(),\n         \"/job:localhost/replica:0/task:0/device:CPU:0\", output_num,\n         &run_comp_func_request);\n \n@@ -883,7 +885,7 @@ TEST_F(EagerServiceImplFunctionTest, ComponentNestedFunctionWithNameClashTest) {\n     const int output_num = 5;\n     AddOperationToRunComponentFunctionRequest(\n         3, \"MatMulNestedTransposeFunction\", {std::make_pair(1, 0)},\n-        std::unordered_map<string, AttrValue>(),\n+        std::unordered_map<std::string, AttrValue>(),\n         \"/job:localhost/replica:0/task:0/device:CPU:0\", output_num,\n         &run_comp_func_request);\n \n@@ -984,7 +986,7 @@ class FunctionWithRemoteInputsTest : public EagerServiceImplTest {\n     EnqueueRequest remote_enqueue_request;\n     remote_enqueue_request.set_context_id(context_id_);\n     EnqueueResponse remote_enqueue_response;\n-    std::unordered_map<string, AttrValue> const_attrs;\n+    std::unordered_map<std::string, AttrValue> const_attrs;\n     AttrValue val;\n     val.set_type(tensorflow::DataType::DT_FLOAT);\n     const_attrs.insert({\"dtype\", val});\n@@ -1045,11 +1047,13 @@ class FunctionWithRemoteInputsTest : public EagerServiceImplTest {\n   }\n \n  protected:\n-  const string local_device_ = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n-  const string remote_device_ = \"/job:localhost/replica:0/task:1/device:CPU:0\";\n+  const std::string local_device_ =\n+      \"/job:localhost/replica:0/task:0/device:CPU:0\";\n+  const std::string remote_device_ =\n+      \"/job:localhost/replica:0/task:1/device:CPU:0\";\n   TestEagerServiceImpl eager_service_impl_;\n   std::unique_ptr<DeviceMgr> remote_device_mgr_;\n-  uint64 context_id_;\n+  uint64_t context_id_;\n   tensorflow::FunctionDef fdef_;\n   std::unique_ptr<ProcessFunctionLibraryRuntime> eager_pflr_;\n   std::unique_ptr<EagerClusterFunctionLibraryRuntime> eager_cluster_flr_;\n@@ -1072,7 +1076,7 @@ TEST_F(FunctionWithRemoteInputsTest, EagerPFLRTest) {\n       fdef_.signature().name(), AttrSlice(&fdef_.attr()), options, &handle));\n   EagerContext* ctx = nullptr;\n   TF_ASSERT_OK(eager_service_impl_.GetEagerContext(context_id_, &ctx));\n-  for (const string& func_name : ctx->FuncLibDef()->ListFunctionNames()) {\n+  for (const std::string& func_name : ctx->FuncLibDef()->ListFunctionNames()) {\n     const FunctionDef* fdef = ctx->FuncLibDef()->Find(func_name);\n     EXPECT_TRUE(fdef != nullptr);\n     if (absl::StartsWith(func_name, \"MatMulFunction\")) {\n@@ -1085,7 +1089,7 @@ TEST_F(FunctionWithRemoteInputsTest, EagerPFLRTest) {\n \n   // Run MatMulFunction on remote_device.\n   FunctionLibraryRuntime::Options opts;\n-  const uint64 op_id = 2;\n+  const uint64_t op_id = 2;\n   opts.op_id = op_id;\n   absl::Notification done;\n   absl::Status status;\n@@ -1133,7 +1137,7 @@ TEST_F(FunctionWithRemoteInputsTest,\n   TF_ASSERT_OK(status);\n   EagerContext* ctx = nullptr;\n   TF_ASSERT_OK(eager_service_impl_.GetEagerContext(context_id_, &ctx));\n-  for (const string& func_name : ctx->FuncLibDef()->ListFunctionNames()) {\n+  for (const std::string& func_name : ctx->FuncLibDef()->ListFunctionNames()) {\n     const FunctionDef* fdef = ctx->FuncLibDef()->Find(func_name);\n     EXPECT_TRUE(fdef != nullptr);\n     if (absl::StartsWith(func_name, \"MatMulFunction\")) {\n@@ -1288,7 +1292,7 @@ TEST_F(FunctionWithRemoteInputsTest, KernelAndDeviceFuncAsyncTest) {\n TEST_F(EagerServiceImplTest, SendTensorTest) {\n   TestEagerServiceImpl eager_service_impl(&worker_env_);\n \n-  uint64 context_id = random::New64();\n+  uint64_t context_id = random::New64();\n \n   CreateContextRequest request;\n   request.mutable_server_def()->set_job_name(\"localhost\");\n@@ -1306,7 +1310,7 @@ TEST_F(EagerServiceImplTest, SendTensorTest) {\n   send_tensor->set_op_id(1);\n   SetTensorProto(send_tensor->add_tensors());\n \n-  std::unordered_map<string, AttrValue> attrs;\n+  std::unordered_map<std::string, AttrValue> attrs;\n   AttrValue val;\n   val.Clear();\n   val.set_type(tensorflow::DataType::DT_FLOAT);\n@@ -1351,13 +1355,13 @@ TEST_F(EagerServiceImplTest, SendTensorTest) {\n TEST_F(EagerServiceImplTest, SendPackedHandleTest) {\n   TestEagerServiceImpl eager_service_impl(&worker_env_);\n \n-  const string device0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n-  const string device1 = \"/job:localhost/replica:0/task:1/device:CPU:0\";\n-  const string device2 = \"/job:localhost/replica:0/task:2/device:CPU:0\";\n-  const string composite_device =\n+  const std::string device0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n+  const std::string device1 = \"/job:localhost/replica:0/task:1/device:CPU:0\";\n+  const std::string device2 = \"/job:localhost/replica:0/task:2/device:CPU:0\";\n+  const std::string composite_device =\n       \"/job:localhost/replica:0/task:0/device:COMPOSITE:0\";\n \n-  uint64 context_id = random::New64();\n+  uint64_t context_id = random::New64();\n   CreateContextRequest request;\n   auto* server_def = request.mutable_server_def();\n   server_def->set_job_name(\"localhost\");\n@@ -1465,7 +1469,7 @@ TEST_F(EagerServiceImplTest, RequestsToMasterTest) {\n       /*async=*/false, device_mgr_.get(), false, std::move(rendezvous), nullptr,\n       nullptr,\n       /*run_eager_op_as_function=*/true);\n-  const uint64 context_id = random::New64();\n+  const uint64_t context_id = random::New64();\n \n   // Set RemoteMgr to ctx.\n   auto remote_mgr =\n@@ -1506,7 +1510,7 @@ TEST_F(EagerServiceImplTest, RequestsToMasterTest) {\n TEST_F(EagerServiceImplTest, KeepAliveTest) {\n   TestEagerServiceImpl eager_service_impl(&worker_env_);\n \n-  uint64 context_id = random::New64();\n+  uint64_t context_id = random::New64();\n   CreateContextRequest request;\n   request.mutable_server_def()->set_job_name(\"localhost\");\n   request.mutable_server_def()->set_task_index(0);\n@@ -1531,7 +1535,7 @@ TEST_F(EagerServiceImplTest, KeepAliveTest) {\n   EXPECT_PRED_FORMAT2(::testing::IsSubstring, \"Unable to find a context_id\",\n                       std::string(status.message()));\n \n-  uint64 new_context_id = random::New64();\n+  uint64_t new_context_id = random::New64();\n   // Create a new context.\n   request.set_context_id(new_context_id);\n   TF_ASSERT_OK(eager_service_impl.CreateContext(&request, &response));"
        },
        {
            "sha": "e532bdff5e657a59571b9a491d061b38cbf10922",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_copy_node.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_copy_node.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_copy_node.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_copy_node.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -66,8 +66,8 @@ absl::Status CreateUncachedKernelAndDeviceOp(\n \n // This gets a unique wire ID. We add a random identifier so that if the\n // worker has other clients that it is servicing, we don't have any collision.\n-string GetUniqueWireID() {\n-  static tensorflow::uint64 random_seed = random::New64();\n+std::string GetUniqueWireID() {\n+  static uint64_t random_seed = random::New64();\n   static tensorflow::mutex wireid_mutex(tensorflow::LINKER_INITIALIZED);\n   static std::atomic<int64_t> wire_id;\n   return absl::StrCat(random_seed, \"_\", wire_id++);\n@@ -77,7 +77,7 @@ string GetUniqueWireID() {\n \n RemoteCopyNode::RemoteCopyNode(EagerContext* ctx, EagerExecutor* executor,\n                                TensorHandle* src, TensorHandle* dst,\n-                               Device* recv_device, uint64 recv_op_id)\n+                               Device* recv_device, uint64_t recv_op_id)\n     : AsyncEagerNode(),\n       src_(src),\n       ctx_(ctx),\n@@ -220,12 +220,12 @@ absl::Status RemoteCopyNode::RunLocalRecv(EagerOperation* op,\n \n void RemoteCopyNode::RunRemoteRecv(EagerOperation* op, StatusCallback done) {\n   EnqueueRequest request;\n-  uint64 context_id = ctx_->GetContextId();\n+  uint64_t context_id = ctx_->GetContextId();\n   request.set_context_id(context_id);\n   auto* remote_op = request.add_queue()->mutable_operation();\n   PrepareRemoteOp(remote_op, op);\n   remote_op->set_id(recv_op_id_);\n-  uint64 context_view_id = ctx_->GetContextViewId();\n+  uint64_t context_view_id = ctx_->GetContextViewId();\n \n   core::RefCountPtr<eager::EagerClient> eager_client;\n   absl::Status status = ctx_->GetClient(recv_device_, &eager_client);\n@@ -316,7 +316,7 @@ void RemoteCopyNode::StartRecv(StatusCallback done) {\n   }\n }\n \n-absl::Status SerializePackedHandle(const uint64 op_id,\n+absl::Status SerializePackedHandle(const uint64_t op_id,\n                                    TensorHandle* packed_handle,\n                                    const Device* target_device,\n                                    EagerContext* ctx, SendPackedHandleOp* op) {\n@@ -362,7 +362,7 @@ absl::Status SerializePackedHandle(const uint64 op_id,\n \n void RemoteCopyNode::StartSendPackedHandle(StatusCallback done) {\n   absl::Status s;\n-  const uint64 context_view_id = ctx_->GetContextViewId();\n+  const uint64_t context_view_id = ctx_->GetContextViewId();\n   if (!send_device_->IsLocal()) {\n     s = errors::InvalidArgument(\n         \"Copy a packed handle from a remote device is not supported\");\n@@ -372,7 +372,7 @@ void RemoteCopyNode::StartSendPackedHandle(StatusCallback done) {\n   }\n \n   EnqueueRequest request;\n-  uint64 context_id = ctx_->GetContextId();\n+  uint64_t context_id = ctx_->GetContextId();\n   request.set_context_id(context_id);\n   s = SerializePackedHandle(recv_op_id_, src_, recv_device_, ctx_,\n                             request.add_queue()->mutable_send_packed_handle());\n@@ -426,12 +426,12 @@ void RemoteCopyNode::StartSendPackedHandle(StatusCallback done) {\n void RemoteCopyNode::StartRemoteSendTensor(StatusCallback done) {\n   absl::Status s;\n   EnqueueRequest request;\n-  uint64 context_id = ctx_->GetContextId();\n+  uint64_t context_id = ctx_->GetContextId();\n   request.set_context_id(context_id);\n   auto* send_tensor = request.add_queue()->mutable_send_tensor();\n   send_tensor->set_op_id(recv_op_id_);\n   send_tensor->set_device_name(recv_device_->name());\n-  uint64 context_view_id = ctx_->GetContextViewId();\n+  uint64_t context_view_id = ctx_->GetContextViewId();\n \n   // AsProtoTensorContent doesn't work when the tensor is on the GPU, hence\n   // copy it to the CPU before copying it out.\n@@ -515,7 +515,7 @@ void RemoteCopyNode::RunAsync(StatusCallback done) {\n \n void RemoteCopyNode::Abort(absl::Status status) {\n   if (!started_) {\n-    uint64 context_view_id = ctx_->GetContextViewId();\n+    uint64_t context_view_id = ctx_->GetContextViewId();\n     captured_state_->dst()->PoisonRemote(status, recv_device_, context_view_id);\n   }\n }"
        },
        {
            "sha": "a8dc387d9a7dbf3128db8f13c945425e7a20d124",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_copy_node.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_copy_node.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_copy_node.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_copy_node.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -63,7 +63,7 @@ namespace eager {\n class RemoteCopyNode : public AsyncEagerNode {\n  public:\n   RemoteCopyNode(EagerContext* ctx, EagerExecutor* executor, TensorHandle* src,\n-                 TensorHandle* dst, Device* recv_device, uint64 recv_op_id);\n+                 TensorHandle* dst, Device* recv_device, uint64_t recv_op_id);\n \n   ~RemoteCopyNode() override;\n \n@@ -73,8 +73,8 @@ class RemoteCopyNode : public AsyncEagerNode {\n \n   void Abort(absl::Status status) override;\n \n-  string DebugString() const override {\n-    string out = \"[RemoteCopyNode]\";\n+  std::string DebugString() const override {\n+    std::string out = \"[RemoteCopyNode]\";\n     absl::StrAppend(&out, \" send_device: \", send_device_->name());\n     absl::StrAppend(&out, \", recv_device: \", recv_device_->name());\n     absl::StrAppend(&out, \", send_tensor: \", src_->DebugString());\n@@ -167,8 +167,8 @@ class RemoteCopyNode : public AsyncEagerNode {\n   EagerExecutor* const executor_;\n   Device* const send_device_;\n   Device* const recv_device_;\n-  const string wire_id_;\n-  const uint64 recv_op_id_;\n+  const std::string wire_id_;\n+  const uint64_t recv_op_id_;\n \n   std::shared_ptr<CapturedSharedState> captured_state_;\n   bool started_;"
        },
        {
            "sha": "3c526f2904d34c7d78f28eaeb5b7ab7bb575cdea",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_execute_node.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_execute_node.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_execute_node.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_execute_node.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -32,9 +32,9 @@ void RemoteExecuteNode::RunAsync(StatusCallback done) {\n   Device* device = device_;\n \n   // Filled and used only when VLOG(3) is on.\n-  string rpc_description;\n+  std::string rpc_description;\n   if (VLOG_IS_ON(3)) {\n-    std::vector<string> ops;\n+    std::vector<std::string> ops;\n     ops.reserve(request_->queue_size());\n     for (const QueueItem& item : request_->queue()) {\n       if (item.has_operation()) {\n@@ -96,7 +96,7 @@ void RemoteExecuteNode::RunAsync(StatusCallback done) {\n         }\n         for (size_t i = 0; i < retvals.size(); ++i) {\n           if (status.ok()) {\n-            const string output_device =\n+            const std::string output_device =\n                 response->queue_response(0).device().empty()\n                     ? \"\"\n                     : response->queue_response(0).device(i);"
        },
        {
            "sha": "8cc9501efb06d4ad3c77d7573df9545a93109f18",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_execute_node.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_execute_node.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_execute_node.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_execute_node.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -40,7 +40,7 @@ class RemoteExecuteNode : public AsyncRemoteExecuteNode {\n  public:\n   RemoteExecuteNode(EagerContext* eager_context,\n                     std::unique_ptr<EnqueueRequest> request, Device* device,\n-                    uint64 context_view_id, EagerClient* eager_client,\n+                    uint64_t context_view_id, EagerClient* eager_client,\n                     CancellationManager* cancellation_manager,\n                     const NodeDef& ndef,\n                     const FunctionLibraryDefinition* lib_def,\n@@ -118,8 +118,8 @@ class RemoteExecuteNode : public AsyncRemoteExecuteNode {\n     return eager_client_->allow_multiple_pending_requests();\n   }\n \n-  string DebugString() const override {\n-    string out = \"[RemoteExecuteNode]\";\n+  std::string DebugString() const override {\n+    std::string out = \"[RemoteExecuteNode]\";\n     absl::StrAppend(&out, \" request: \", request_->DebugString());\n     absl::StrAppend(&out, \", target_device: \", device_->name());\n     return out;\n@@ -129,7 +129,7 @@ class RemoteExecuteNode : public AsyncRemoteExecuteNode {\n   EagerContext* eager_context_;  // Not owned, and must outlive this node.\n   std::unique_ptr<EnqueueRequest> request_;\n   Device* device_;             // Not owned\n-  uint64 context_view_id_;\n+  uint64_t context_view_id_;\n   bool needs_remote_inputs_;\n   EagerClient* eager_client_;  // Not owned, and must outlive this node.\n   CancellationManager* cancellation_manager_;"
        },
        {
            "sha": "5cec8424c2e14da0298455107fba62b06d026485",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_mgr.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -127,7 +127,7 @@ absl::Status RemoteMgr::GetMirroredResourceShape(\n \n absl::Status RemoteMgr::GetRemoteTensorHandle(\n     const tensorflow::TensorHandle* handle, const bool wait_until_ready,\n-    int64_t* op_id, int32* output_num) {\n+    int64_t* op_id, int32_t* output_num) {\n   TF_RETURN_IF_ERROR(handle->RemoteAddress(handle->device(), wait_until_ready,\n                                            op_id, output_num));\n   tensorflow::TensorHandle* h;\n@@ -213,7 +213,7 @@ absl::Status RemoteMgr::DeserializeRemoteTensorHandle(\n   } else {\n     // Create a remote TensorHandle for remote tensors which have not been\n     // copied to the local worker yet (e.g. remote function inputs).\n-    const string& device_name =\n+    const std::string& device_name =\n         in.op_device().empty() ? in.device() : in.op_device();\n     TF_RETURN_IF_ERROR(\n         parent_->FindDeviceFromName(device_name.c_str(), &device));\n@@ -241,7 +241,7 @@ absl::Status RemoteMgr::DeserializeRemoteTensorHandle(\n   return absl::OkStatus();\n }\n \n-EagerExecutor& RemoteMgr::GetOrCreateExecutorForStream(uint64 stream_id) {\n+EagerExecutor& RemoteMgr::GetOrCreateExecutorForStream(uint64_t stream_id) {\n   mutex_lock l(executor_map_mu_);\n   auto it = executor_map_.find(stream_id);\n   if (it == executor_map_.end()) {\n@@ -254,7 +254,7 @@ EagerExecutor& RemoteMgr::GetOrCreateExecutorForStream(uint64 stream_id) {\n   return it->second;\n }\n \n-void RemoteMgr::DeleteExecutorForStream(uint64 stream_id) {\n+void RemoteMgr::DeleteExecutorForStream(uint64_t stream_id) {\n   mutex_lock l(executor_map_mu_);\n   auto it = executor_map_.find(stream_id);\n   if (it == executor_map_.end()) {"
        },
        {
            "sha": "975cfa13e45ef7eea9b30b24bda53647c36fb8bf",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_mgr.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -58,7 +58,7 @@ class RemoteMgr {\n \n   // Helper function to create monotonically increasing ids unique to this\n   // context.\n-  uint64 NextOpId() {\n+  uint64_t NextOpId() {\n     DCHECK(is_master_);\n     mutex_lock l(next_id_mutex_);\n     return next_op_id_++;\n@@ -77,20 +77,20 @@ class RemoteMgr {\n   absl::Status DeserializeRemoteTensorHandle(const RemoteTensorHandle& in,\n                                              TensorHandle** out);\n \n-  EagerExecutor& GetOrCreateExecutorForStream(uint64 stream_id);\n+  EagerExecutor& GetOrCreateExecutorForStream(uint64_t stream_id);\n \n-  void DeleteExecutorForStream(uint64 stream_id);\n+  void DeleteExecutorForStream(uint64_t stream_id);\n \n  protected:\n   mutex next_id_mutex_;\n-  uint64 next_op_id_ TF_GUARDED_BY(next_id_mutex_) = 1;\n+  uint64_t next_op_id_ TF_GUARDED_BY(next_id_mutex_) = 1;\n \n  private:\n   // Returns the op_id and output_num if the given local TensorHandle exists in\n   // remote_tensor_handle_map_.\n   absl::Status GetRemoteTensorHandle(const tensorflow::TensorHandle* handle,\n                                      const bool wait_until_ready,\n-                                     int64_t* op_id, int32* output_num)\n+                                     int64_t* op_id, int32_t* output_num)\n       TF_SHARED_LOCKS_REQUIRED(remote_tensor_handle_mu_);\n \n   absl::Status GetTensorHandleImpl(\n@@ -129,7 +129,7 @@ class RemoteMgr {\n   EagerContext* parent_;  // not owned.\n \n   mutex executor_map_mu_;\n-  std::unordered_map<uint64, EagerExecutor> executor_map_\n+  std::unordered_map<uint64_t, EagerExecutor> executor_map_\n       TF_GUARDED_BY(executor_map_mu_);\n };\n "
        },
        {
            "sha": "89901367b49b2dfbe2af8c483679bc8ba065d2c9",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_mgr_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_mgr_test.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -35,7 +35,7 @@ class TestRemoteMgr : public RemoteMgr {\n   TestRemoteMgr(bool is_master, EagerContext* ctx)\n       : RemoteMgr(is_master, ctx) {}\n \n-  uint64 OpId() {\n+  uint64_t OpId() {\n     tf_shared_lock l(next_id_mutex_);\n     return next_op_id_;\n   }\n@@ -75,7 +75,7 @@ TEST_F(RemoteMgrTest, SerializeLocalTensorHandleWithRemoteMirror) {\n \n   TensorHandle* handle = TensorHandle::CreateLocalHandle(\n       std::move(t), local_device_, local_device_, ctx_);\n-  const uint64 op_id = 2;\n+  const uint64_t op_id = 2;\n   const int output_num = 3;\n   TF_ASSERT_OK(handle->AddUnshapedRemoteMirror(remote_device_, op_id,\n                                                output_num, \"\", ctx_));\n@@ -94,7 +94,7 @@ TEST_F(RemoteMgrTest, SerializeLocalTensorHandleWithRemoteMirror) {\n TEST_F(RemoteMgrTest, SerializeRemoteTensorHandle) {\n   RemoteMgr remote_mgr(false, ctx_);\n \n-  const uint64 op_id = 3;\n+  const uint64_t op_id = 3;\n   const int output_num = 1;\n   TensorHandle* handle = TensorHandle::CreateLazyRemoteHandle(\n       op_id, output_num, DT_FLOAT, remote_device_, /*is_ready=*/true, ctx_);\n@@ -113,7 +113,7 @@ TEST_F(RemoteMgrTest, InvalidateRemoteMirrorWithClusterUpdate) {\n \n   TensorHandle* handle = TensorHandle::CreateLocalHandle(\n       std::move(t), local_device_, local_device_, ctx_);\n-  const uint64 op_id = 2;\n+  const uint64_t op_id = 2;\n   const int output_num = 3;\n   TF_ASSERT_OK(handle->AddUnshapedRemoteMirror(remote_device_, op_id,\n                                                output_num, \"\", ctx_));\n@@ -134,7 +134,7 @@ TEST_F(RemoteMgrTest, InvalidateRemoteMirrorWithClusterUpdate) {\n TEST_F(RemoteMgrTest, SetRemoteShapeWithClusterUpdate) {\n   RemoteMgr remote_mgr(false, ctx_);\n \n-  const uint64 op_id = 3;\n+  const uint64_t op_id = 3;\n   const int output_num = 1;\n   TensorHandle* handle = TensorHandle::CreateUnshapedRemoteHandle(\n       op_id, output_num,\n@@ -157,7 +157,7 @@ TEST_F(RemoteMgrTest, SetRemoteShapeWithClusterUpdate) {\n TEST_F(RemoteMgrTest, ErrorSourcesShouldExist) {\n   RemoteMgr remote_mgr(false, ctx_);\n \n-  const uint64 op_id = 3;\n+  const uint64_t op_id = 3;\n   const int output_num = 1;\n   TensorHandle* handle = TensorHandle::CreateLazyRemoteHandle(\n       op_id, output_num, DT_FLOAT, remote_device_, /*is_ready=*/true, ctx_);"
        },
        {
            "sha": "51f8d97e6ce6f8aae184b4be558a29c0346e972c",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_tensor_handle.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -28,7 +28,7 @@ struct RemoteTensorHandleInternal {\n   RemoteTensorHandleInternal(int64_t op_id, int32_t output_num)\n       : op_id(op_id), output_num(output_num) {}\n   int64_t op_id;\n-  int32 output_num;\n+  int32_t output_num;\n };\n \n struct RemoteTensorHandleInternalHash {"
        },
        {
            "sha": "32ec58774d99cb1bd44a120b424212773037baea",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_tensor_handle_data.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle_data.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle_data.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle_data.cc?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -29,9 +29,10 @@ namespace tensorflow {\n \n namespace {\n \n-void DestroyRemoteTensorHandle(EagerContext* ctx, const string& remote_task,\n-                               uint64 context_id, uint64 op_id, int output_num,\n-                               bool ready) {\n+void DestroyRemoteTensorHandle(EagerContext* ctx,\n+                               const std::string& remote_task,\n+                               uint64_t context_id, uint64_t op_id,\n+                               int output_num, bool ready) {\n   if (ctx->GetContextId() != context_id) {\n     // This means that this tensor was pointing to a remote device, which\n     // has been changed out from under us. Simply return since there is\n@@ -89,7 +90,7 @@ void DestroyRemoteTensorHandle(EagerContext* ctx, const string& remote_task,\n }  // namespace\n \n RemoteTensorHandleData::RemoteTensorHandleData(int64_t op_id, int output_num,\n-                                               uint64 context_view_id,\n+                                               uint64_t context_view_id,\n                                                bool is_ready)\n     : is_ready_(is_ready),\n       op_id_(op_id),\n@@ -102,7 +103,7 @@ RemoteTensorHandleData::RemoteTensorHandleData(int64_t op_id, int output_num,\n }\n \n RemoteTensorHandleData::RemoteTensorHandleData(int64_t op_id, int output_num,\n-                                               const string& remote_task,\n+                                               const std::string& remote_task,\n                                                EagerContext* ctx)\n     : is_ready_(false),\n       op_id_(op_id),\n@@ -182,7 +183,7 @@ absl::Status RemoteTensorHandleData::SetShape(const TensorShape& shape) {\n }\n \n absl::Status RemoteTensorHandleData::SetShapeAndRemoteTask(\n-    const TensorShape& shape, const string& remote_task) {\n+    const TensorShape& shape, const std::string& remote_task) {\n   // If `is_ready_` is set previously due to poisoning, return the original\n   // error that poisoned this tensor.\n   TF_RETURN_IF_ERROR(IsPoisoned());\n@@ -216,13 +217,13 @@ absl::Status RemoteTensorHandleData::SetShapeAndRemoteTask(\n   return absl::OkStatus();\n }\n \n-string RemoteTensorHandleData::DebugString() const {\n+std::string RemoteTensorHandleData::DebugString() const {\n   return absl::StrCat(\"RemoteTensorHandleData:\", \" op_id: \", op_id_,\n                       \" output_num: \", output_num_);\n }\n \n absl::Status RemoteTensorHandleData::OpIdAndOutputNum(\n-    const bool wait_until_ready, int64_t* op_id, int32* output_num) const {\n+    const bool wait_until_ready, int64_t* op_id, int32_t* output_num) const {\n   if (wait_until_ready) {\n     TF_RETURN_IF_ERROR(WaitReady(\"OpIdAndOutputNumUntilReady\"));\n   }"
        },
        {
            "sha": "1c7099cc66b1a492fc4b73885ed90929de2a8452",
            "filename": "tensorflow/core/distributed_runtime/eager/remote_tensor_handle_data.h",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle_data.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a967808638b7256d777722630be808f801c08291/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle_data.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdistributed_runtime%2Feager%2Fremote_tensor_handle_data.h?ref=a967808638b7256d777722630be808f801c08291",
            "patch": "@@ -31,12 +31,12 @@ class RemoteTensorHandleData {\n   // the corresponding remote tensor is ready. So the remote tensor should be\n   // ready when we create a lazy remote handle. If it refers to a remote output,\n   // it's not ready until the shape is set.\n-  RemoteTensorHandleData(int64_t op_id, int output_num, uint64 context_view_id,\n-                         bool is_ready);\n+  RemoteTensorHandleData(int64_t op_id, int output_num,\n+                         uint64_t context_view_id, bool is_ready);\n   // Constructor for unshaped remote handles. It controls the lifetime of a\n   // remote handle that it refers to.\n   RemoteTensorHandleData(int64_t op_id, int output_num,\n-                         const string& remote_task, EagerContext* ctx);\n+                         const std::string& remote_task, EagerContext* ctx);\n   ~RemoteTensorHandleData();\n \n   // A remote tensor handle does not have a Tensor object, hence it can only\n@@ -51,18 +51,18 @@ class RemoteTensorHandleData {\n   absl::Status WaitReady(const char* caller) const;\n   absl::Status SetShape(const TensorShape& shape);\n   absl::Status SetShapeAndRemoteTask(const TensorShape& shape,\n-                                     const string& remote_task);\n+                                     const std::string& remote_task);\n   void Poison(absl::Status status);\n   absl::Status IsPoisoned() const;\n \n-  string DebugString() const;\n+  std::string DebugString() const;\n \n   // Return the op id and output num. If wait_until_ready is true, block until\n   // the remote tensor is ready on a remote worker.\n   absl::Status OpIdAndOutputNum(bool wait_until_ready, int64_t* op_id,\n-                                int32* output_num) const;\n+                                int32_t* output_num) const;\n \n-  uint64 context_view_id() const { return context_view_id_; }\n+  uint64_t context_view_id() const { return context_view_id_; }\n \n  private:\n   mutable mutex mu_;\n@@ -72,10 +72,10 @@ class RemoteTensorHandleData {\n \n   // IDs required when this class is representing a remote tensor handle.\n   const int64_t op_id_;\n-  const int32 output_num_;\n-  string remote_task_ TF_GUARDED_BY(mu_);\n-  uint64 context_id_;\n-  uint64 context_view_id_;\n+  const int32_t output_num_;\n+  std::string remote_task_ TF_GUARDED_BY(mu_);\n+  uint64_t context_id_;\n+  uint64_t context_view_id_;\n   EagerContext* ctx_;\n };\n "
        }
    ],
    "stats": {
        "total": 297,
        "additions": 153,
        "deletions": 144
    }
}