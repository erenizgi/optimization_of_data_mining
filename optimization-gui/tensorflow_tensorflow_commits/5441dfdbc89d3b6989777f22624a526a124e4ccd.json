{
    "author": "chunnienc",
    "message": "Add extenral_buffer attribute to tfl.external_const\n\nPiperOrigin-RevId: 843109775",
    "sha": "5441dfdbc89d3b6989777f22624a526a124e4ccd",
    "files": [
        {
            "sha": "67eef87eb872ad90e522e4855d573c0a0669d2f2",
            "filename": "tensorflow/compiler/mlir/lite/flatbuffer_export.cc",
            "status": "modified",
            "additions": 91,
            "deletions": 17,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fflatbuffer_export.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fflatbuffer_export.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fflatbuffer_export.cc?ref=5441dfdbc89d3b6989777f22624a526a124e4ccd",
            "patch": "@@ -269,7 +269,7 @@ static StatusOr<tflite::TensorType> GetTFLiteType(Type type,\n static bool IsConst(Operation* op) {\n   return isa<mlir::func::ConstantOp, mlir::arith::ConstantOp, mlir::TF::ConstOp,\n              tfl::ConstOp, tfl::QConstOp, tfl::SparseConstOp,\n-             tfl::SparseQConstOp, mlir::TFL::NoValueOp,\n+             tfl::ExternalConstOp, tfl::SparseQConstOp, mlir::TFL::NoValueOp,\n              mlir::stablehlo::ConstantOp, mlir::vhlo::ConstantOpV1>(op);\n }\n \n@@ -632,6 +632,12 @@ class Translator {\n   std::optional<BufferOffset<tflite::Buffer>> BuildBuffer(\n       Value value, bool can_be_deduplicated, int& index);\n \n+  // Builds external buffer and external buffer group from the given value. If\n+  // the value is not defined by a constant op with external buffer attributes,\n+  // returns std::nullopt.\n+  std::optional<BufferOffset<tflite::ExternalBuffer>> BuildExternalBuffer(\n+      Value value, uint32_t external_buffer_id);\n+\n   // Build TFLite tensor from the given type. This function is for tfl.lstm\n   // intermediates, which should have UniformQuantizedType.\n   std::optional<BufferOffset<tflite::Tensor>> BuildTensorFromType(\n@@ -647,6 +653,7 @@ class Translator {\n   // corresponding buffer. Emits error and returns std::nullopt on failure.\n   std::optional<BufferOffset<tflite::Tensor>> BuildTensor(\n       Value value, const std::string& name, unsigned buffer_idx,\n+      unsigned external_buffer_id,\n       const std::optional<BufferOffset<tflite::QuantizationParameters>>&\n           quant_parameters);\n \n@@ -858,6 +865,13 @@ class Translator {\n   BufferOffset<tflite::Buffer> empty_buffer_;\n \n   std::vector<BufferOffset<tflite::Buffer>> buffers_;\n+\n+  // External buffers\n+  std::vector<BufferOffset<tflite::ExternalBuffer>> external_buffers_;\n+  std::vector<BufferOffset<tflite::ExternalBufferGroup>>\n+      external_buffer_groups_;\n+  absl::flat_hash_map<std::string, uint32_t> external_buffer_group_map_;\n+\n   // Maps subgraph index and tensor name in the graph to the tensor index.\n   absl::flat_hash_map<int, absl::flat_hash_map<std::string, int>>\n       tensor_index_map_;\n@@ -986,6 +1000,44 @@ std::string Translator::UniqueName(mlir::Value val) {\n   return std::string(name_mapper_.GetUniqueName(val));\n }\n \n+std::optional<BufferOffset<tflite::ExternalBuffer>>\n+Translator::BuildExternalBuffer(mlir::Value value,\n+                                uint32_t external_buffer_id) {\n+  if (value.getDefiningOp() == nullptr) {\n+    return std::nullopt;\n+  }\n+  auto inst = mlir::dyn_cast<tfl::ExternalConstOp>(value.getDefiningOp());\n+  if (!inst) {\n+    return std::nullopt;\n+  }\n+  auto meta = inst.getExternalBufferAttr();\n+  if (!meta) {\n+    return std::nullopt;\n+  }\n+\n+  std::string group_name = meta.getGroupName().str();\n+  uint64_t offset = meta.getOffset();\n+  uint64_t length = meta.getLength();\n+  std::string packing = meta.getPacking().str();\n+\n+  uint32_t group_index = 0;\n+  if (auto it = external_buffer_group_map_.find(group_name);\n+      it != external_buffer_group_map_.end()) {\n+    group_index = it->second;\n+  } else {\n+    int index = external_buffer_groups_.size();\n+    external_buffer_groups_.push_back(tflite::CreateExternalBufferGroup(\n+        builder_, builder_.CreateString(group_name)));\n+    external_buffer_group_map_[group_name] = index;\n+    group_index = index;\n+  }\n+\n+  auto external_buffer = tflite::CreateExternalBuffer(\n+      builder_, external_buffer_id, group_index, offset, length,\n+      builder_.CreateString(packing));\n+  return external_buffer;\n+}\n+\n std::optional<BufferOffset<tflite::Buffer>> Translator::BuildBuffer(\n     mlir::Value value, bool can_be_deduplicated, int& index) {\n   can_be_deduplicated = can_be_deduplicated && !disable_buffer_deduping_;\n@@ -1241,11 +1293,13 @@ std::optional<BufferOffset<tflite::Tensor>> Translator::BuildTensorFromType(\n       /*buffer=*/0, builder_.CreateString(name), q_params,\n       /*is_variable=*/false, /*sparsity=*/0, /*shape_signature=*/0,\n       /*has_rank=*/tensor_type.hasRank(),\n-      variant_params->empty() ? 0 : builder_.CreateVector(*variant_params));\n+      variant_params->empty() ? 0 : builder_.CreateVector(*variant_params),\n+      /*external_buffer=*/0);\n }\n \n std::optional<BufferOffset<tflite::Tensor>> Translator::BuildTensor(\n     Value value, const std::string& name, unsigned buffer_idx,\n+    unsigned external_buffer_id,\n     const std::optional<BufferOffset<tflite::QuantizationParameters>>&\n         quant_parameters) {\n   auto type = mlir::cast<TensorType>(value.getType());\n@@ -1371,15 +1425,17 @@ std::optional<BufferOffset<tflite::Tensor>> Translator::BuildTensor(\n         (is_variable ? 0 : buffer_idx), builder_.CreateString(name), q_params,\n         /*is_variable=*/is_variable, s_params, /*shape_signature=*/0,\n         /*has_rank=*/has_rank,\n-        variant_params->empty() ? 0 : builder_.CreateVector(*variant_params));\n+        variant_params->empty() ? 0 : builder_.CreateVector(*variant_params),\n+        external_buffer_id);\n   } else {\n     return tflite::CreateTensor(\n         builder_, builder_.CreateVector(shape), tflite_element_type,\n         (is_variable ? 0 : buffer_idx), builder_.CreateString(name), q_params,\n         /*is_variable=*/is_variable, s_params,\n         /*shape_signature=*/builder_.CreateVector(shape_signature),\n         /*has_rank=*/has_rank,\n-        variant_params->empty() ? 0 : builder_.CreateVector(*variant_params));\n+        variant_params->empty() ? 0 : builder_.CreateVector(*variant_params),\n+        external_buffer_id);\n   }\n }\n \n@@ -3292,27 +3348,41 @@ std::optional<BufferOffset<tflite::SubGraph>> Translator::BuildSubGraph(\n       }\n     }\n \n+    // External buffer id is enforced to have MSB set to 1 to distinguish from\n+    // buffer index/id, with the assumption that the number of external buffers\n+    // are less than 2^31.\n+    uint32_t external_buffer_id =\n+        (1 << 31) | static_cast<uint32_t>(external_buffers_.size());\n     int buffer_index = buffers_.size();\n-    // If a constant is returned as subgraph's output, this constant cannot be\n-    // deduplicated.\n-    const bool not_returned_by_subgraph = llvm::none_of(\n-        value.getUsers(),\n-        [](Operation* user) { return llvm::isa<mlir::func::ReturnOp>(user); });\n+\n     // TODO(ashwinm): Check if for stateful tensors, if it is also needed to\n     // make the Buffer empty apart from setting the buffer_idx=0 in the\n     // Tensor. This does not seem to affect runtime behavior for RNN/LSTM,\n     // but would be good for reducing memory footprint.\n-    if (value.getDefiningOp()) {\n+    if (auto external_buffer_or =\n+            BuildExternalBuffer(value, external_buffer_id);\n+        external_buffer_or.has_value()) {\n+      buffer_index = 0;\n+      external_buffers_.push_back(*external_buffer_or);\n+    } else if (value.getDefiningOp()) {\n+      // If a constant is returned as subgraph's output, this constant cannot be\n+      // deduplicated.\n+      const bool not_returned_by_subgraph =\n+          llvm::none_of(value.getUsers(), [](Operation* user) {\n+            return llvm::isa<mlir::func::ReturnOp>(user);\n+          });\n       auto buffer_or =\n           BuildBuffer(value, not_returned_by_subgraph, buffer_index);\n       if (!buffer_or) return false;\n+      external_buffer_id = 0;\n       buffers_.push_back(*buffer_or);\n     } else {\n+      external_buffer_id = 0;\n       buffers_.push_back(empty_buffer_);\n     }\n \n-    auto tensor_or =\n-        BuildTensor(value, tensor_name, buffer_index, quant_parameters);\n+    auto tensor_or = BuildTensor(value, tensor_name, buffer_index,\n+                                 external_buffer_id, quant_parameters);\n     if (!tensor_or) return false;\n     tensors.push_back(*tensor_or);\n \n@@ -4192,11 +4262,15 @@ std::optional<std::string> Translator::TranslateInternal() {\n   }\n   auto signature_defs = CreateSignatureDefs(signature_defs_vec);\n \n-  auto model = tflite::CreateModel(builder_, TFLITE_SCHEMA_VERSION,\n-                                   builder_.CreateVector(opcodes_),\n-                                   builder_.CreateVector(subgraphs_),\n-                                   description, builder_.CreateVector(buffers_),\n-                                   metadata_buffer, *metadata, *signature_defs);\n+  bool has_external_buffers = !external_buffers_.empty();\n+  auto model = tflite::CreateModel(\n+      builder_, TFLITE_SCHEMA_VERSION, builder_.CreateVector(opcodes_),\n+      builder_.CreateVector(subgraphs_), description,\n+      builder_.CreateVector(buffers_), metadata_buffer, *metadata,\n+      *signature_defs,\n+      has_external_buffers ? builder_.CreateVector(external_buffer_groups_) : 0,\n+      has_external_buffers ? builder_.CreateVector(external_buffers_) : 0);\n+\n   tflite::FinishModelBuffer(builder_, model);\n   // There is a limit of 2GB for a flatbuffer.\n   bool flatbuffer_limit_exceeded = builder_.GetSize() > flatbuffer_size_max;"
        },
        {
            "sha": "19aae278c33178604b41bd62096bbd267b2cfe1a",
            "filename": "tensorflow/compiler/mlir/lite/flatbuffer_import.cc",
            "status": "modified",
            "additions": 89,
            "deletions": 36,
            "changes": 125,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fflatbuffer_import.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fflatbuffer_import.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fflatbuffer_import.cc?ref=5441dfdbc89d3b6989777f22624a526a124e4ccd",
            "patch": "@@ -457,9 +457,9 @@ std::string GetMlirOpName(const tflite::OperatorT& op,\n   return mlir::GetMlirOpNameFromOpCode(op_code);\n }\n \n-StatusOr<Operation*> BuildExternalConstOp(const tflite::TensorT& tensor,\n-                                          int32_t buffer_index,\n-                                          OpBuilder builder, Location loc) {\n+StatusOr<Operation*> BuildExternalConstOpWithBufferIndex(\n+    const tflite::TensorT& tensor, int32_t buffer_index, OpBuilder builder,\n+    Location loc) {\n   TF_ASSIGN_OR_RETURN(mlir::TensorType type,\n                       tfl::GetTensorType(tensor, builder,\n                                          /*is_constant=*/true));\n@@ -468,7 +468,45 @@ StatusOr<Operation*> BuildExternalConstOp(const tflite::TensorT& tensor,\n     return errors::Internal(\"Constant doesn't have a shape\");\n   }\n   auto op = builder.create<tfl::ExternalConstOp>(\n-      loc, shaped_type, builder.getI32IntegerAttr(buffer_index));\n+      loc, shaped_type,\n+      /*buffer_index=*/builder.getI32IntegerAttr(buffer_index),\n+      /*external_buffer=*/nullptr);\n+  return op.getOperation();\n+}\n+\n+StatusOr<Operation*> BuildExternalConstOpWithExternalBuffer(\n+    const tflite::ModelT& model, const tflite::TensorT& tensor,\n+    OpBuilder builder, Location loc) {\n+  TF_ASSIGN_OR_RETURN(mlir::TensorType type,\n+                      tfl::GetTensorType(tensor, builder,\n+                                         /*is_constant=*/true));\n+  auto shaped_type = llvm::dyn_cast<mlir::RankedTensorType>(type);\n+  if (!shaped_type) {\n+    return errors::Internal(\"Constant doesn't have a shape\");\n+  }\n+\n+  tflite::ExternalBufferT* external_buffer = nullptr;\n+  for (const auto& extbuf : model.external_buffers) {\n+    if (extbuf->id == tensor.external_buffer) {\n+      external_buffer = extbuf.get();\n+      break;\n+    }\n+  }\n+  if (external_buffer == nullptr) {\n+    return errors::Internal(\"External buffer not found\");\n+  }\n+\n+  std::string group_name =\n+      model.external_buffer_groups[external_buffer->group]->name;\n+  auto op = builder.create<tfl::ExternalConstOp>(\n+      loc, shaped_type, /*buffer_index=*/nullptr,\n+      /*external_buffer=*/\n+      tfl::ExternalBufferAttr::get(\n+          builder.getContext(),\n+          /*group_name=*/builder.getStringAttr(group_name),\n+          /*offset=*/external_buffer->offset,\n+          /*length=*/external_buffer->length,\n+          /*packing=*/builder.getStringAttr(external_buffer->packing)));\n   return op.getOperation();\n }\n \n@@ -1347,7 +1385,8 @@ mlir::ResultRange MaybeWrapInControlNode(mlir::Operation* op,\n // ordered_output_arrays in the same order. If signature is not null, then the\n // inputs/outputs in signature will be attached to the FuncOp.\n StatusOr<FuncOp> ConvertSubgraph(\n-    const tflite::SubGraphT& subgraph, llvm::StringRef name,\n+    const tflite::ModelT& model, const tflite::SubGraphT& subgraph,\n+    llvm::StringRef name,\n     const std::vector<std::unique_ptr<tflite::OperatorCodeT>>& op_codes,\n     const std::vector<std::string>& func_names,\n     const std::vector<std::unique_ptr<tflite::BufferT>>& buffers,\n@@ -1511,22 +1550,30 @@ StatusOr<FuncOp> ConvertSubgraph(\n         StatusOr<Operation*> op_or_err;\n         std::vector<uint8_t> buffer;\n         // Check if constant tensor is stored outside of the flatbuffers.\n-        if (IsValidBufferOffset(buffers[const_tensor.buffer]->offset)) {\n-          const uint8_t* file_begin_ptr =\n-              reinterpret_cast<const uint8_t*>(model_ptr->allocation()->base());\n-          buffer = std::vector<uint8_t>(\n-              file_begin_ptr + buffers[const_tensor.buffer]->offset,\n-              file_begin_ptr + buffers[const_tensor.buffer]->offset +\n-                  buffers[const_tensor.buffer]->size);\n+        if (const_tensor.external_buffer != 0) {\n+          op_or_err = BuildExternalConstOpWithExternalBuffer(\n+              model, const_tensor, op_builder, const_loc);\n         } else {\n-          buffer = buffers[const_tensor.buffer]->data;\n+          if (IsValidBufferOffset(buffers[const_tensor.buffer]->offset)) {\n+            const uint8_t* file_begin_ptr = reinterpret_cast<const uint8_t*>(\n+                model_ptr->allocation()->base());\n+\n+            buffer = std::vector<uint8_t>(\n+                file_begin_ptr + buffers[const_tensor.buffer]->offset,\n+                file_begin_ptr + buffers[const_tensor.buffer]->offset +\n+                    buffers[const_tensor.buffer]->size);\n+          } else {\n+            buffer = buffers[const_tensor.buffer]->data;\n+          }\n+          op_or_err =\n+              use_external_constant\n+                  ? BuildExternalConstOpWithBufferIndex(const_tensor,\n+                                                        const_tensor.buffer,\n+                                                        op_builder, const_loc)\n+                  : BuildConstOp(const_tensor, buffer, const_tensor.is_variable,\n+                                 op_builder, const_loc, use_stablehlo_constant);\n         }\n-        op_or_err =\n-            use_external_constant\n-                ? BuildExternalConstOp(const_tensor, const_tensor.buffer,\n-                                       op_builder, const_loc)\n-                : BuildConstOp(const_tensor, buffer, const_tensor.is_variable,\n-                               op_builder, const_loc, use_stablehlo_constant);\n+\n         if (!op_or_err.ok()) {\n           return emitError(const_loc, op_or_err.status().ToString()),\n                  op_or_err.status();\n@@ -1584,23 +1631,29 @@ StatusOr<FuncOp> ConvertSubgraph(\n       StatusOr<Operation*> op_or_err;\n       std::vector<uint8_t> buffer;\n       // Check if constant tensor is stored outside of the flatbuffers.\n-      if (IsValidBufferOffset(buffers[const_tensor.buffer]->offset)) {\n-        const uint8_t* file_begin_ptr =\n-            reinterpret_cast<const uint8_t*>(model_ptr->allocation()->base());\n-\n-        buffer = std::vector<uint8_t>(\n-            file_begin_ptr + buffers[const_tensor.buffer]->offset,\n-            file_begin_ptr + buffers[const_tensor.buffer]->offset +\n-                buffers[const_tensor.buffer]->size);\n+      if (const_tensor.external_buffer != 0) {\n+        op_or_err = BuildExternalConstOpWithExternalBuffer(\n+            model, const_tensor, op_builder, const_loc);\n       } else {\n-        buffer = buffers[const_tensor.buffer]->data;\n+        if (IsValidBufferOffset(buffers[const_tensor.buffer]->offset)) {\n+          const uint8_t* file_begin_ptr =\n+              reinterpret_cast<const uint8_t*>(model_ptr->allocation()->base());\n+\n+          buffer = std::vector<uint8_t>(\n+              file_begin_ptr + buffers[const_tensor.buffer]->offset,\n+              file_begin_ptr + buffers[const_tensor.buffer]->offset +\n+                  buffers[const_tensor.buffer]->size);\n+        } else {\n+          buffer = buffers[const_tensor.buffer]->data;\n+        }\n+        op_or_err =\n+            use_external_constant\n+                ? BuildExternalConstOpWithBufferIndex(\n+                      const_tensor, const_tensor.buffer, op_builder, const_loc)\n+                : BuildConstOp(const_tensor, buffer, const_tensor.is_variable,\n+                               op_builder, const_loc, use_stablehlo_constant);\n       }\n-      op_or_err =\n-          use_external_constant\n-              ? BuildExternalConstOp(const_tensor, const_tensor.buffer,\n-                                     op_builder, const_loc)\n-              : BuildConstOp(const_tensor, buffer, const_tensor.is_variable,\n-                             op_builder, const_loc, use_stablehlo_constant);\n+\n       if (!op_or_err.ok()) {\n         return emitError(const_loc, op_or_err.status().ToString()),\n                op_or_err.status();\n@@ -1862,8 +1915,8 @@ OwningOpRef<mlir::ModuleOp> tflite::FlatBufferToMlir(\n         SubgraphName(set_implicit_main_func, e.index(), *subgraph);\n     uint32_t subgraph_index = static_cast<uint32_t>(e.index());\n     auto func_or_error = ConvertSubgraph(\n-        *subgraph, name, model->operator_codes, func_names, model->buffers,\n-        base_loc, builder,\n+        *model, *subgraph, name, model->operator_codes, func_names,\n+        model->buffers, base_loc, builder,\n         /*is_entry_point=*/\n         set_implicit_main_func\n             ? e.index() == 0"
        },
        {
            "sha": "6fa287a8c8b0137f7fd1418118cf631119b7d789",
            "filename": "tensorflow/compiler/mlir/lite/ir/tfl_op_enums.td",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fir%2Ftfl_op_enums.td",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fir%2Ftfl_op_enums.td",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fir%2Ftfl_op_enums.td?ref=5441dfdbc89d3b6989777f22624a526a124e4ccd",
            "patch": "@@ -166,4 +166,16 @@ def TFL_ConstBytesAttr : AttrDef<TFL_Dialect, \"ConstBytes\"> {\n   let hasCustomAssemblyFormat = 1;\n }\n \n+def TFL_ExternalBufferAttr : AttrDef<TFL_Dialect, \"ExternalBuffer\"> {\n+  let mnemonic = \"external_buffer\";\n+  let parameters = (ins\n+      \"::mlir::StringAttr\":$group_name,\n+      \"uint64_t\":$offset,\n+      \"uint64_t\":$length,\n+      \"::mlir::StringAttr\":$packing\n+  );\n+  let summary = \"Flatbuffer external buffer metadata.\";\n+  let assemblyFormat = \"`<` struct(params) `>`\";\n+}\n+\n #endif // TFL_OP_ENUMS"
        },
        {
            "sha": "4c7e784d5069fd4f2e97529a1a8071818110793a",
            "filename": "tensorflow/compiler/mlir/lite/ir/tfl_ops.td",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fir%2Ftfl_ops.td",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fir%2Ftfl_ops.td",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fir%2Ftfl_ops.td?ref=5441dfdbc89d3b6989777f22624a526a124e4ccd",
            "patch": "@@ -951,11 +951,15 @@ def TFL_ExternalConstOp : Op<TFL_Dialect, \"external_const\", [\n   let summary = \"External const op.\";\n \n   let description = [{\n-    External const op holds a `buffer_index` which points to a constant\n-    in the flatbuffer.\n+    External const op that can hold :\n+    - `buffer_index` which points to a constant in the flatbuffer.\n+    - `external_buffer` which contains metadata for external buffer outside flatbuffer.\n   }];\n \n-  let arguments = (ins I32Attr:$buffer_index);\n+  let arguments = (ins\n+    OptionalAttr<I32Attr>:$buffer_index,\n+    OptionalAttr<TFL_ExternalBufferAttr>:$external_buffer\n+  );\n \n   let results = (outs AnyTensor:$output);\n }"
        },
        {
            "sha": "987f5a90e374f559400ee17e23804e1c40703d87",
            "filename": "tensorflow/compiler/mlir/lite/tests/flatbuffer2mlir/external_buffer.mlir",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Ftests%2Fflatbuffer2mlir%2Fexternal_buffer.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Ftests%2Fflatbuffer2mlir%2Fexternal_buffer.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Ftests%2Fflatbuffer2mlir%2Fexternal_buffer.mlir?ref=5441dfdbc89d3b6989777f22624a526a124e4ccd",
            "patch": "@@ -0,0 +1,14 @@\n+// RUN: flatbuffer_translate -mlir-to-tflite-flatbuffer %s -o - | flatbuffer_translate --tflite-flatbuffer-to-mlir - -o - | FileCheck %s\n+\n+module {\n+  func.func public @main(%arg0: tensor<2x2xf32>) -> tensor<2x2xf32> {\n+    %0 = \"tfl.external_const\"() <{external_buffer = #tfl.external_buffer<group_name = \"test.bin\", offset = 0, length = 13, packing = \"unpacked\">}> : () -> tensor<2x2xf32>\n+    %1 = tfl.add %arg0, %0 {fused_activation_function = \"NONE\"} : tensor<2x2xf32>\n+    return %1 : tensor<2x2xf32>\n+  }\n+}\n+\n+// CHECK-LABEL: @main\n+// CHECK:      %0 = \"tfl.external_const\"() <{external_buffer = #tfl.external_buffer<group_name = \"test.bin\", offset = 0, length = 13, packing = \"unpacked\">}>\n+// CHECK-NEXT: %1 = tfl.add %arg0, %0 {fused_activation_function = \"NONE\"} : tensor<2x2xf32>\n+// CHECK-NEXT: return %1"
        },
        {
            "sha": "09d7e764b1f7a2f4bf533532f8cd792c7aebebc4",
            "filename": "tensorflow/compiler/mlir/lite/tests/mlir2flatbuffer/external_buffer.mlir",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Ftests%2Fmlir2flatbuffer%2Fexternal_buffer.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5441dfdbc89d3b6989777f22624a526a124e4ccd/tensorflow%2Fcompiler%2Fmlir%2Flite%2Ftests%2Fmlir2flatbuffer%2Fexternal_buffer.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Ftests%2Fmlir2flatbuffer%2Fexternal_buffer.mlir?ref=5441dfdbc89d3b6989777f22624a526a124e4ccd",
            "patch": "@@ -0,0 +1,34 @@\n+// RUN: flatbuffer_translate -mlir-to-tflite-flatbuffer %s -o - | flatbuffer_to_string - | FileCheck %s\n+\n+module {\n+  func.func public @main(%arg0: tensor<2x2xf32>) -> tensor<2x2xf32> {\n+    %0 = \"tfl.external_const\"() <{external_buffer = #tfl.external_buffer<group_name = \"test.bin\", offset = 0, length = 13, packing = \"unpacked\">}> : () -> tensor<2x2xf32>\n+    %1 = tfl.add %arg0, %0 {fused_activation_function = \"NONE\"} : tensor<2x2xf32>\n+    return %1 : tensor<2x2xf32>\n+  }\n+}\n+\n+// CHECK:  tensors: [ {\n+// CHECK:    shape: [ 2, 2 ],\n+// CHECK:    buffer: 1,\n+// CHECK:    name: \"arg0\",\n+// CHECK:    has_rank: true\n+// CHECK:  }, {\n+// CHECK:    shape: [ 2, 2 ],\n+// CHECK:    name: \"tfl.external_const\",\n+// CHECK:    has_rank: true,\n+// CHECK:    external_buffer: 2147483648\n+// CHECK:  }, {\n+// CHECK:    shape: [ 2, 2 ],\n+// CHECK:    buffer: 2,\n+// CHECK:    name: \"tfl.add\",\n+// CHECK:    has_rank: true\n+// CHECK:  } ],\n+// CHECK:  external_buffer_groups: [ {\n+// CHECK:    name: \"test.bin\"\n+// CHECK:  } ],\n+// CHECK:  external_buffers: [ {\n+// CHECK:    id: 2147483648,\n+// CHECK:    length: 13,\n+// CHECK:    packing: \"unpacked\"\n+// CHECK:  } ]"
        }
    ],
    "stats": {
        "total": 303,
        "additions": 247,
        "deletions": 56
    }
}