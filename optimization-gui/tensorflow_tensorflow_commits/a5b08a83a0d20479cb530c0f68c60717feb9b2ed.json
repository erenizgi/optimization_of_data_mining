{
    "author": "hawkinsp",
    "message": "Remove more code paths that can create >1 module module groups.\n\nMake HloModuleGroup::push_back() private.\n\nPiperOrigin-RevId: 815826722",
    "sha": "a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
    "files": [
        {
            "sha": "f452cf62028b26e5549eca28ab6d106b65d6b19c",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module_group.h",
            "status": "modified",
            "additions": 13,
            "deletions": 12,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_group.h?ref=a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
            "patch": "@@ -34,18 +34,9 @@ namespace xla {\n // concurrently across different devices.\n class HloModuleGroup {\n  public:\n-  // Construct an empty module group.\n-  explicit HloModuleGroup(absl::string_view name) : name_(name) {}\n-\n   // Construct a module group containing a single module.\n   explicit HloModuleGroup(std::unique_ptr<HloModule> module);\n \n-  // Construct a module group containing any number of modules.\n-  HloModuleGroup(absl::string_view name,\n-                 absl::Span<std::unique_ptr<HloModule>> modules);\n-  HloModuleGroup(absl::string_view name,\n-                 std::vector<std::unique_ptr<HloModule>>&& modules);\n-\n   HloModuleGroup(const HloModuleGroup& other) = delete;\n   HloModuleGroup(HloModuleGroup&& other) = default;\n   HloModuleGroup& operator=(const HloModuleGroup& other) = delete;\n@@ -57,9 +48,6 @@ class HloModuleGroup {\n   // Returns a module at a particular index.\n   HloModule& module(int index) const { return *module_ptrs_.at(index); }\n \n-  // Add a module to the back of vector of modules in the group.\n-  void push_back(std::unique_ptr<HloModule> module);\n-\n   // Replaces the existing module at the given index with the given module. The\n   // existing module is discarded.\n   void ReplaceModule(int index, std::unique_ptr<HloModule> module);\n@@ -105,6 +93,19 @@ class HloModuleGroup {\n   }\n \n  private:\n+  // Construct an empty module group.\n+  explicit HloModuleGroup(absl::string_view name) : name_(name) {}\n+\n+  // Construct a module group containing any number of modules.\n+  HloModuleGroup(absl::string_view name,\n+                 absl::Span<std::unique_ptr<HloModule>> modules);\n+  HloModuleGroup(absl::string_view name,\n+                 std::vector<std::unique_ptr<HloModule>>&& modules);\n+\n+  // Add a module to the back of vector of modules in the group. Private\n+  // because we no longer want to support > 1 module per group.\n+  void push_back(std::unique_ptr<HloModule> module);\n+\n   std::string name_;\n \n   // Vector of modules as std::unique_ptrs."
        },
        {
            "sha": "183a3b27da14fd7d870e1b30b806914bbae4f158",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_fix_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 80,
            "changes": 80,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_fix_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_fix_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_fix_test.cc?ref=a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
            "patch": "@@ -182,85 +182,5 @@ TEST_F(HloPassFixTest, RunModuleToNonDefaultEarlyExit) {\n   EXPECT_EQ(root->literal().GetFirstElement<int32_t>(), 20);\n }\n \n-TEST_F(HloPassFixTest, RunModuleGroupToFixedPoint) {\n-  constexpr absl::string_view kModule0 = R\"(\n-    HloModule First\n-\n-    ENTRY main {\n-      ROOT c = s32[] constant(5)\n-    }\n-  )\";\n-\n-  constexpr absl::string_view kModule1 = R\"(\n-    HloModule Second\n-\n-    ENTRY main {\n-      ROOT c = s32[] constant(3)\n-    }\n-  )\";\n-\n-  constexpr absl::string_view kModule2 = R\"(\n-    HloModule Second\n-\n-    ENTRY main {\n-      ROOT c = s32[] constant(0)\n-    }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module0,\n-                          ParseAndReturnVerifiedModule(kModule0));\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module1,\n-                          ParseAndReturnVerifiedModule(kModule1));\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module2,\n-                          ParseAndReturnVerifiedModule(kModule2));\n-  HloModuleGroup module_group(\"group\");\n-  module_group.push_back(std::move(module0));\n-  module_group.push_back(std::move(module1));\n-  module_group.push_back(std::move(module2));\n-\n-  HloPassFix<DecrementPositiveConstants> pass;\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed, pass.RunOnModuleGroup(&module_group));\n-  EXPECT_TRUE(changed);\n-  HloInstruction* root0 =\n-      module_group.module(0).entry_computation()->root_instruction();\n-  ASSERT_EQ(root0->opcode(), HloOpcode::kConstant);\n-  EXPECT_EQ(root0->literal().GetFirstElement<int32_t>(), 0);\n-  HloInstruction* root1 =\n-      module_group.module(1).entry_computation()->root_instruction();\n-  ASSERT_EQ(root1->opcode(), HloOpcode::kConstant);\n-  EXPECT_EQ(root1->literal().GetFirstElement<int32_t>(), 0);\n-  HloInstruction* root2 =\n-      module_group.module(2).entry_computation()->root_instruction();\n-  ASSERT_EQ(root2->opcode(), HloOpcode::kConstant);\n-  EXPECT_EQ(root2->literal().GetFirstElement<int32_t>(), 0);\n-}\n-\n-TEST_F(HloPassFixTest, OscillationsStillTerminate) {\n-  constexpr absl::string_view kModule = R\"(\n-    HloModule Oscillating\n-\n-    ENTRY main {\n-      a = f32[4] parameter(0)\n-      b = f32[4] parameter(1)\n-      ROOT c = f32[4] add(a, b)\n-    }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(kModule));\n-  HloPassFix<FlipAddSubtract> pass;\n-\n-  // We expect this to terminate and report that the module did not change.\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed, pass.Run(module.get()));\n-  EXPECT_FALSE(changed);\n-\n-  // But don't lie when crash_on_hlo_pass_silent_hlo_change is set.\n-  module->mutable_config()\n-      .mutable_debug_options()\n-      .set_xla_unsupported_crash_on_hlo_pass_silent_hlo_change(true);\n-  TF_ASSERT_OK_AND_ASSIGN(changed, pass.Run(module.get()));\n-  EXPECT_TRUE(changed);\n-}\n-\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "e783c425c21c9572dfb452bc12e7ebce9c10150e",
            "filename": "third_party/xla/xla/hlo/pass/hlo_pass_pipeline_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 31,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fpass%2Fhlo_pass_pipeline_test.cc?ref=a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
            "patch": "@@ -27,7 +27,6 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n-#include \"absl/types/span.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n@@ -50,15 +49,10 @@ using ::testing::StrEq;\n \n class HloPassPipelineTest : public HloHardwareIndependentTestBase {\n  protected:\n-  absl::StatusOr<HloModuleGroup> ParseModuleGroup(\n-      absl::Span<const std::string> hlo_strings) {\n-    HloModuleGroup group(TestName());\n-    for (const std::string& hlo_string : hlo_strings) {\n-      TF_ASSIGN_OR_RETURN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-      group.push_back(std::move(module));\n-    }\n-    return group;\n+  absl::StatusOr<HloModuleGroup> ParseModuleGroup(std::string hlo_string) {\n+    TF_ASSIGN_OR_RETURN(std::unique_ptr<VerifiedHloModule> module,\n+                        ParseAndReturnVerifiedModule(hlo_string));\n+    return HloModuleGroup(std::move(module));\n   }\n };\n \n@@ -276,36 +270,22 @@ ENTRY main {\n   ROOT baz = f32[] multiply(a, b)\n }\n )\";\n-  const std::string module_1_str = R\"(\n-HloModule MixedPipeline.0\n-\n-ENTRY main {\n-  a = f32[] parameter(0)\n-  b = f32[] parameter(1)\n-  ROOT foo = f32[] multiply(a, b)\n-}\n-)\";\n-\n   TF_ASSERT_OK_AND_ASSIGN(HloModuleGroup module_group,\n-                          ParseModuleGroup({module_0_str, module_1_str}));\n+                          ParseModuleGroup(module_0_str));\n \n   HloPassPipeline pipeline(TestName());\n   pipeline.AddPass<BazToQuxModuleGroupPass>();\n   pipeline.AddPass<FooToBarModulePass>();\n \n   HloInstruction* root0 =\n       module_group.module(0).entry_computation()->root_instruction();\n-  HloInstruction* root1 =\n-      module_group.module(1).entry_computation()->root_instruction();\n   EXPECT_EQ(root0->name(), \"baz\");\n-  EXPECT_EQ(root1->name(), \"foo\");\n \n   TF_ASSERT_OK_AND_ASSIGN(bool changed,\n                           pipeline.RunOnModuleGroup(&module_group));\n   EXPECT_TRUE(changed);\n \n   EXPECT_EQ(root0->name(), \"qux\");\n-  EXPECT_EQ(root1->name(), \"bar\");\n }\n \n TEST_F(HloPassPipelineTest, InvariantChecker) {\n@@ -383,15 +363,13 @@ ENTRY main {\n \n // Test that metadata is set when a module group goes through a pass pipeline.\n TEST_F(HloPassPipelineTest, SetHloModuleMetadata) {\n-  HloModuleGroup module_group(TestName());\n-  module_group.push_back(CreateNewVerifiedModule());\n-  module_group.push_back(CreateNewVerifiedModule());\n+  HloModuleGroup module_group(CreateNewVerifiedModule());\n \n   HloPassPipeline pipeline(TestName());\n   pipeline.AddPass<BazToQuxModuleGroupPass>();\n   pipeline.AddPass<FooToBarModulePass>();\n   TF_ASSERT_OK(pipeline.RunOnModuleGroup(&module_group).status());\n-  ASSERT_THAT(module_group.modules(), SizeIs(2));\n+  ASSERT_THAT(module_group.modules(), SizeIs(1));\n \n   std::vector<std::string> pass_names = {\"pipeline-start\", \"baz2qux\",\n                                          \"foo2bar\"};\n@@ -410,8 +388,7 @@ TEST_F(HloPassPipelineTest, SetHloModuleMetadata) {\n       EXPECT_FALSE(pass_metadata.module_changed());\n       EXPECT_EQ(pass_metadata.module_id(), module->unique_id());\n       EXPECT_THAT(pass_metadata.module_group_module_ids(),\n-                  ElementsAre(module_group.module(0).unique_id(),\n-                              module_group.module(1).unique_id()));\n+                  ElementsAre(module_group.module(0).unique_id()));\n       EXPECT_GT(pass_metadata.start_timestamp_usec(), 0);\n       EXPECT_LE(pass_metadata.start_timestamp_usec(),\n                 pass_metadata.end_timestamp_usec());"
        },
        {
            "sha": "2aa6581a911014f27c7c7db2e8703e7867ae8587",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
            "patch": "@@ -1837,10 +1837,7 @@ xla_cc_test(\n xla_cc_test(\n     name = \"hlo_module_group_test\",\n     srcs = [\"hlo_module_group_test.cc\"],\n-    # TODO(b/148211710) Test fails in OSS.\n-    tags = [\"no_oss\"],\n     deps = [\n-        \":hlo_module_group_metadata\",\n         \":hlo_proto_cc\",\n         \"//xla/hlo/ir:hlo_module_group\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\","
        },
        {
            "sha": "4e93664ee8b10fa74964c87ab21d51cfa13bb4fa",
            "filename": "third_party/xla/xla/service/hlo_module_group_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 140,
            "changes": 145,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_module_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_module_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_module_group_test.cc?ref=a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
            "patch": "@@ -15,11 +15,15 @@ limitations under the License.\n \n #include \"xla/hlo/ir/hlo_module_group.h\"\n \n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/test.h\"\n #include \"xla/hlo/utils/hlo_matchers.h\"\n #include \"xla/service/hlo.pb.h\"\n-#include \"xla/service/hlo_module_group_metadata.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n \n namespace xla {\n@@ -67,145 +71,6 @@ ENTRY %entry (x: f32[], y: f32[]) -> f32[] {\n   EXPECT_EQ(group.modules().size(), 0);\n }\n \n-TEST_F(HloModuleGroupTest, MultipleModules) {\n-  const std::string text_0 = R\"(\n-HloModule module0\n-\n-ENTRY %entry (x: f32[], y: f32[]) -> f32[] {\n-  %x = f32[] parameter(0)\n-  %y = f32[] parameter(1)\n-  ROOT %add = f32[] add(%x, %y)\n-}\n-)\";\n-  const std::string text_1 = R\"(\n-HloModule module1\n-\n-ENTRY %entry (a: f32[]) -> f32[] {\n-  ROOT %a = f32[] parameter(0)\n-}\n-)\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module_0,\n-                          ParseAndReturnVerifiedModule(text_0));\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module_1,\n-                          ParseAndReturnVerifiedModule(text_1));\n-  std::vector<std::unique_ptr<HloModule>> modules;\n-  modules.push_back(std::move(module_0));\n-  modules.push_back(std::move(module_1));\n-  HloModuleGroup group(TestName(), absl::MakeSpan(modules));\n-  EXPECT_EQ(group.modules().size(), 2);\n-  EXPECT_THAT(\n-      group.module(0).entry_computation()->instructions(),\n-      ::testing::ElementsAre(op::Parameter(), op::Parameter(), op::Add()));\n-  EXPECT_THAT(group.module(1).entry_computation()->instructions(),\n-              ::testing::ElementsAre(op::Parameter()));\n-\n-  TF_ASSERT_OK_AND_ASSIGN(HloModuleGroup group_copy,\n-                          HloModuleGroup::CreateFromProto(\n-                              group.ToProto(), {group.module(0).config(),\n-                                                group.module(1).config()}));\n-  EXPECT_EQ(group_copy.modules().size(), 2);\n-}\n-\n-TEST_F(HloModuleGroupTest, BuildModuleGroupByPushBack) {\n-  const std::string text_0 = R\"(\n-HloModule module0\n-\n-ENTRY %entry (x: f32[], y: f32[]) -> f32[] {\n-  %x = f32[] parameter(0)\n-  %y = f32[] parameter(1)\n-  ROOT %add = f32[] add(%x, %y)\n-}\n-)\";\n-  const std::string text_1 = R\"(\n-HloModule module1\n-\n-ENTRY %entry (a: f32[]) -> f32[] {\n-  ROOT %a = f32[] parameter(0)\n-}\n-)\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module_0,\n-                          ParseAndReturnVerifiedModule(text_0));\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module_1,\n-                          ParseAndReturnVerifiedModule(text_1));\n-  HloModuleGroup group(TestName());\n-  group.push_back(std::move(module_0));\n-  group.push_back(std::move(module_1));\n-\n-  EXPECT_EQ(group.modules().size(), 2);\n-  EXPECT_THAT(\n-      group.module(0).entry_computation()->instructions(),\n-      ::testing::ElementsAre(op::Parameter(), op::Parameter(), op::Add()));\n-  EXPECT_THAT(group.module(1).entry_computation()->instructions(),\n-              ::testing::ElementsAre(op::Parameter()));\n-}\n-\n-// Tests that the order of companion instructions in the companion set doesn't\n-// change across runs.\n-TEST_F(HloModuleGroupTest, ModuleGroupCompanionOrder) {\n-  // A simple while loop template for core i sending to core i+1.\n-  constexpr char text[] = R\"(\n-HloModule module_%d\n-\n-while_cond {\n-  param = s32[] parameter(0)\n-  ROOT p = pred[] constant(true)\n-}\n-\n-while_body {\n-  param = s32[] parameter(0)\n-  token.s = token[] after-all()\n-  token.r = token[] after-all()\n-  send = (s32[], u32[], token[]) send(param, token.s), channel_id=%d\n-  send-done = token[] send-done(send), channel_id=%d\n-  recv = (s32[], u32[], token[]) recv(token.r), channel_id=%d\n-  recv-done = (s32[], token[]) recv-done(recv), channel_id=%d\n-  ROOT data = s32[] get-tuple-element(recv-done), index=0\n-}\n-\n-ENTRY entry {\n-  while_init = s32[] constant(1)\n-  ROOT while = s32[] while(while_init), condition=while_cond, body=while_body\n-}\n-)\";\n-\n-  // Try creating the module and the metadata kTrialCount times and check the\n-  // companion instructions remain in the same order.\n-  const int64_t kTrialCount = 5;\n-  const int64_t kDeviceCount = 10;\n-  std::vector<int64_t> companion_order;\n-\n-  for (int64_t t = 0; t < kTrialCount; ++t) {\n-    HloModuleGroup group(TestName());\n-    for (int64_t i = 0; i < kDeviceCount; ++i) {\n-      const int64_t send_channel = i;\n-      const int64_t recv_channel = i == 0 ? kDeviceCount - 1 : i - 1;\n-      TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                              ParseAndReturnVerifiedModule(absl::StrFormat(\n-                                  text, i, send_channel, send_channel,\n-                                  recv_channel, recv_channel)));\n-      group.push_back(std::move(module));\n-    }\n-    ASSERT_EQ(group.modules().size(), kDeviceCount);\n-\n-    TF_ASSERT_OK_AND_ASSIGN(auto metadata,\n-                            HloModuleGroupMetadata::Build(group.modules()));\n-    ASSERT_EQ(metadata->companion_sets().size(), 1);\n-\n-    std::vector<int64_t> module_ids;\n-    const auto& companion_sets = *metadata->companion_sets()[0];\n-    module_ids.reserve(companion_sets.size());\n-    for (HloInstruction* companion : companion_sets) {\n-      module_ids.push_back(metadata->GetModuleId(companion->GetModule()));\n-    }\n-\n-    if (t == 0) {\n-      companion_order = module_ids;\n-    } else {\n-      EXPECT_TRUE(absl::c_equal(companion_order, module_ids));\n-    }\n-  }\n-}\n-\n // Test that metadata is transferred when a module is replaced.\n TEST_F(HloModuleGroupTest, ReplaceModuleMetadata) {\n   auto old_module = CreateNewVerifiedModule();"
        },
        {
            "sha": "1daf042fc2f931eb253cce2986d2ed8c2fe18bc6",
            "filename": "third_party/xla/xla/service/service.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 14,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fservice%2Fservice.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5b08a83a0d20479cb530c0f68c60717feb9b2ed/third_party%2Fxla%2Fxla%2Fservice%2Fservice.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fservice.cc?ref=a5b08a83a0d20479cb530c0f68c60717feb9b2ed",
            "patch": "@@ -270,21 +270,20 @@ Service::BuildExecutables(\n   }\n \n   CHECK_EQ(module_protos.size(), module_configs.size());\n-  auto module_group =\n-      std::make_unique<HloModuleGroup>(module_protos[0]->name());\n-  for (int64_t i = 0, end = module_protos.size(); i < end; ++i) {\n-    const HloModuleProto* proto = module_protos[i];\n-    const HloModuleConfig& config = *module_configs[i];\n-    TF_ASSIGN_OR_RETURN(\n-        auto module, CreateModuleFromProto(*proto, config, run_backend_only));\n-    module->set_layout_canonicalization_callback(\n-        options.layout_canonicalization_callback);\n-    UpdateEntryComputationLayout(\n-        module.get(), std::bind(&Compiler::DefaultDeviceShapeRepresentation,\n-                                backend->compiler(), std::placeholders::_1));\n-    DumpHloModuleIfEnabled(*module, kBeforeOptimizationsDumpName);\n-    module_group->push_back(std::move(module));\n+  if (module_protos.size() != 1) {\n+    return InvalidArgument(\"BuildExecutables only supports a single module.\");\n   }\n+  const HloModuleProto* proto = module_protos[0];\n+  const HloModuleConfig& config = *module_configs[0];\n+  TF_ASSIGN_OR_RETURN(auto module,\n+                      CreateModuleFromProto(*proto, config, run_backend_only));\n+  module->set_layout_canonicalization_callback(\n+      options.layout_canonicalization_callback);\n+  UpdateEntryComputationLayout(\n+      module.get(), std::bind(&Compiler::DefaultDeviceShapeRepresentation,\n+                              backend->compiler(), std::placeholders::_1));\n+  DumpHloModuleIfEnabled(*module, kBeforeOptimizationsDumpName);\n+  auto module_group = std::make_unique<HloModuleGroup>(std::move(module));\n \n   std::vector<std::unique_ptr<Executable>> executables;\n   if (!run_backend_only) {"
        }
    ],
    "stats": {
        "total": 319,
        "additions": 39,
        "deletions": 280
    }
}