{
    "author": "tensorflower-gardener",
    "message": "Add `buildMaxAndArgmaxBody` helper for StableHLO.\n\nThis helper function constructs a region for computing the maximum value and its index, suitable for use in `ReduceWindow` operations.\n\nPiperOrigin-RevId: 832491768",
    "sha": "67fc77e992104384e601c37bb5a09793d62fd515",
    "files": [
        {
            "sha": "915772f92413a9d4f3c487f2d80dc8c12a1c9935",
            "filename": "third_party/xla/third_party/stablehlo/temporary.patch",
            "status": "modified",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/67fc77e992104384e601c37bb5a09793d62fd515/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/67fc77e992104384e601c37bb5a09793d62fd515/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch?ref=67fc77e992104384e601c37bb5a09793d62fd515",
            "patch": "@@ -45,6 +45,68 @@ diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.cpp b/stablehlo/stablehlo/\n    (void)result;\n    assert(succeeded(result));\n  }\n+@@ -4024,6 +4024,61 @@\n+   ReturnOp::create(*builder, loc, compare);\n+ }\n+ \n++void buildMaxAndArgmaxBody(Type elementType, Type indices_type, Region& body,\n++                           OpBuilder& builder) {\n++  OpBuilder::InsertionGuard guard(builder);\n++  if (body.getBlocks().empty()) builder.createBlock(&body);\n++  Block* block = &body.getBlocks().front();\n++\n++  Type value_type = RankedTensorType::get(/*shape=*/{}, elementType);\n++  Type index_type = RankedTensorType::get(/*shape=*/{}, indices_type);\n++  Location loc = body.getLoc();\n++  block->addArguments({value_type, index_type}, {loc, loc});\n++  block->addArguments({value_type, index_type}, {loc, loc});\n++\n++  auto lhs_value = block->getArgument(0);\n++  auto lhs_index = block->getArgument(1);\n++  auto rhs_value = block->getArgument(2);\n++  auto rhs_index = block->getArgument(3);\n++\n++  auto gt_pred =\n++      builder\n++          .create<CompareOp>(loc, lhs_value, rhs_value, ComparisonDirection::GT)\n++          .getResult();\n++\n++  // Tie-Breaker Condition: (lhs == rhs) AND (lhs_index < rhs_index)\n++  auto eq_pred =\n++      builder\n++          .create<CompareOp>(loc, lhs_value, rhs_value, ComparisonDirection::EQ)\n++          .getResult();\n++  auto lt_index_pred =\n++      builder\n++          .create<CompareOp>(loc, lhs_index, rhs_index, ComparisonDirection::LT)\n++          .getResult();\n++  auto tie_breaker_condition =\n++      builder.create<AndOp>(loc, eq_pred, lt_index_pred).getResult();\n++\n++  // Final lhs Selection Condition: (gt_pred) OR (tie_breaker_condition)\n++  auto final_lhs_condition =\n++      builder.create<OrOp>(loc, gt_pred, tie_breaker_condition).getResult();\n++\n++  // Select Final Results:\n++  // if final_lhs_condition:\n++  //     return (lhs_value, lhs_index)\n++  // else:\n++  //     return (rhs_value, rhs_index)\n++  auto selected_value = builder\n++                            .create<stablehlo::SelectOp>(\n++                                loc, final_lhs_condition, lhs_value, rhs_value)\n++                            .getResult();\n++  auto selected_index = builder\n++                            .create<stablehlo::SelectOp>(\n++                                loc, final_lhs_condition, lhs_index, rhs_index)\n++                            .getResult();\n++  builder.create<stablehlo::ReturnOp>(\n++      loc, mlir::ValueRange{selected_value, selected_index});\n++}\n++\n+ SortOp createSortOp(PatternRewriter* rewriter, const Location& loc,\n+                     const llvm::ArrayRef<Value>& operands,\n+                     const llvm::ArrayRef<Type>& elementTypes, int64_t dimension,\n diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.h b/stablehlo/stablehlo/dialect/StablehloOps.h\n --- stablehlo/stablehlo/dialect/StablehloOps.h\n +++ stablehlo/stablehlo/dialect/StablehloOps.h\n@@ -65,6 +127,23 @@ diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.h b/stablehlo/stablehlo/di\n  \n    // Get the set dialect version.\n    std::optional<StablehloDialectVersion> getVersion() const;\n+@@ -203,6 +204,16 @@\n+   stablehlo::ReturnOp::create(builder, loc, reducer.getResult());\n+ }\n+ \n++// Builds the region `body` for a max-and-argmax computation, suitable for\n++// use in ReduceWindow operations with varidic value and index inputs.\n++// It creates four block arguments (val1, idx1, val2, idx2) of `elementType` and\n++// `indices_type`, and returns two results: result_val and result_idx.\n++// result_val is the maximum of val1 and val2, and result_idx is the index\n++// corresponding to result_val. If val1 >= val2, idx1 is returned, otherwise\n++// idx2 is returned.\n++void buildMaxAndArgmaxBody(Type elementType, Type indices_type, Region& body,\n++                           OpBuilder& builder);\n++\n+ // PrecisionConfigAttr is a constraint attribute on ArrayAttrs.\n+ // Create this class to allow for building this attr similar to other\n+ // attributes.\n diff --ruN a/stablehlo/stablehlo/integrations/cpp/builder/AttrTypeBuilderUtilTest.cpp b/stablehlo/stablehlo/integrations/cpp/builder/AttrTypeBuilderUtilTest.cpp\n --- stablehlo/stablehlo/integrations/cpp/builder/AttrTypeBuilderUtilTest.cpp\n +++ stablehlo/stablehlo/integrations/cpp/builder/AttrTypeBuilderUtilTest.cpp"
        }
    ],
    "stats": {
        "total": 79,
        "additions": 79,
        "deletions": 0
    }
}