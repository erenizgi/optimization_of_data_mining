{
    "author": "shawnwang18",
    "message": "PR #30809: [XLA:GPU] Move tests from command_buffer_thunk_test to command_buffer_test\n\nImported from GitHub PR https://github.com/openxla/xla/pull/30809\n\nüìù Summary of Changes\n Move several HLO based e2e tests from command_buffer_thunk_test to command_buffer_test\n\nüéØ Justification\ncode clean\n\nüöÄ Kind of Contribution\n‚ôªÔ∏è Cleanup\n\nCopybara import of the project:\n\n--\nc1b557660e5625260708e8ddd1ff9fce6bbaffb5 by Shawn Wang <shawnw@nvidia.com>:\n\nMove tests from command_buffer_thunk_test to command_buffer_test\n\n--\nc1dcd7db2afe5b34f249ff38ecd5cfec7f798ac5 by Shawn Wang <shawnw@nvidia.com>:\n\nfix\n\n--\nab2f2dc908232a16c0edeb08183963b406696694 by Shawn Wang <shawnw@nvidia.com>:\n\nclang format\n\nMerging this change closes #30809\n\nPiperOrigin-RevId: 802597809",
    "sha": "822a7678265bbfcc992ef0490a9efd06275c4061",
    "files": [
        {
            "sha": "17703c280d0135857fe54d402e43f0f6a911f1db",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_thunk_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 269,
            "changes": 269,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/822a7678265bbfcc992ef0490a9efd06275c4061/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_thunk_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/822a7678265bbfcc992ef0490a9efd06275c4061/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_thunk_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_thunk_test.cc?ref=822a7678265bbfcc992ef0490a9efd06275c4061",
            "patch": "@@ -1567,114 +1567,6 @@ TEST(CommandBufferThunkTest, WhileCmd) {\n   ASSERT_EQ(dst, std::vector<int32_t>(4, 15));\n }\n \n-class CmdBufferTest : public HloPjRtInterpreterReferenceMixin<HloPjRtTestBase> {\n- public:\n-  DebugOptions GetDebugOptionsForTest() const override {\n-    DebugOptions debug_options = HloPjRtTestBase::GetDebugOptionsForTest();\n-    debug_options.set_xla_gpu_autotune_level(0);\n-    debug_options.set_xla_gpu_enable_dynamic_slice_fusion(true);\n-    debug_options.set_xla_gpu_graph_min_graph_size(1);\n-    debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::FUSION);\n-    debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUBLAS);\n-    debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUBLASLT);\n-    debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUSTOM_CALL);\n-    debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUDNN);\n-    debug_options.add_xla_gpu_enable_command_buffer(\n-        DebugOptions::DYNAMIC_SLICE_FUSION);\n-    return debug_options;\n-  }\n-};\n-\n-TEST_F(CmdBufferTest, DynamicSliceFusionCmd) {\n-  // Hlo generated by below jax code\n-  // def scan_body(carry, x):\n-  //     sliced_x = lax.slice(x, (0, 0), (128, 128))\n-  //     result = jnp.dot(carry, sliced_x)\n-  //     new_carry = result\n-  //     return new_carry, result\n-  // @jax.jit\n-  // def run_scan(initial_carry, xs):\n-  //     final_carry, outputs = lax.scan(scan_body, initial_carry, xs, length=2)\n-  //     return final_carry, outputs\n-\n-  const char* module_str = R\"(\n-HloModule jit_run_scan\n-\n-None.7 {\n-  Arg_0.8 = f32[128,128]{1,0} parameter(0)\n-  Arg_1.9 = f32[128,128]{1,0} parameter(1)\n-  dot.10 = f32[128,128]{1,0} dot(Arg_0.8, Arg_1.9), lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-  ROOT tuple.11 = (f32[128,128]{1,0}, f32[128,128]{1,0}) tuple(dot.10, dot.10)\n-}\n-\n-region_0.12 {\n-  arg_tuple.13 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) parameter(0)\n-  get-tuple-element.14 = s32[] get-tuple-element(arg_tuple.13), index=0\n-  constant.18 = s32[] constant(1)\n-  add.34 = s32[] add(get-tuple-element.14, constant.18)\n-  get-tuple-element.15 = f32[128,128]{1,0} get-tuple-element(arg_tuple.13), index=1\n-  get-tuple-element.17 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.13), index=3\n-  constant.20 = s32[] constant(0)\n-  compare.21 = pred[] compare(get-tuple-element.14, constant.20), direction=LT\n-  constant.19 = s32[] constant(2)\n-  add.22 = s32[] add(get-tuple-element.14, constant.19)\n-  select.23 = s32[] select(compare.21, add.22, get-tuple-element.14)\n-  dynamic-slice.24 = f32[1,128,128]{2,1,0} dynamic-slice(get-tuple-element.17, select.23, constant.20, constant.20), dynamic_slice_sizes={1,128,128}\n-  reshape.25 = f32[128,128]{1,0} reshape(dynamic-slice.24)\n-  call.26 = (f32[128,128]{1,0}, f32[128,128]{1,0}) call(get-tuple-element.15, reshape.25), to_apply=None.7\n-  get-tuple-element.27 = f32[128,128]{1,0} get-tuple-element(call.26), index=0\n-  get-tuple-element.16 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.13), index=2\n-  get-tuple-element.28 = f32[128,128]{1,0} get-tuple-element(call.26), index=1\n-  reshape.29 = f32[1,128,128]{2,1,0} reshape(get-tuple-element.28)\n-  compare.30 = pred[] compare(get-tuple-element.14, constant.20), direction=LT\n-  add.31 = s32[] add(get-tuple-element.14, constant.19)\n-  select.32 = s32[] select(compare.30, add.31, get-tuple-element.14)\n-  dynamic-update-slice.33 = f32[2,128,128]{2,1,0} dynamic-update-slice(get-tuple-element.16, reshape.29, select.32, constant.20, constant.20)\n-  ROOT tuple.35 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) tuple(add.34, get-tuple-element.27, dynamic-update-slice.33, get-tuple-element.17)\n-} // region_0.12\n-\n-region_1.36 {\n-  arg_tuple.37 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) parameter(0)\n-  get-tuple-element.39 = f32[128,128]{1,0} get-tuple-element(arg_tuple.37), index=1\n-  get-tuple-element.40 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.37), index=2\n-  get-tuple-element.41 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.37), index=3\n-  get-tuple-element.38 = s32[] get-tuple-element(arg_tuple.37), index=0\n-  constant.42 = s32[] constant(2)\n-  ROOT compare.43 = pred[] compare(get-tuple-element.38, constant.42), direction=LT\n-} // region_1.36\n-\n-ENTRY main.49 {\n-  constant.3 = s32[] constant(0)\n-  Arg_0.1 = f32[128,128]{1,0} parameter(0)\n-  constant.4 = f32[] constant(0)\n-  broadcast.5 = f32[2,128,128]{2,1,0} broadcast(constant.4), dimensions={}\n-  Arg_1.2 = f32[2,128,128]{2,1,0} parameter(1)\n-  tuple.6 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) tuple(constant.3, Arg_0.1, broadcast.5, Arg_1.2)\n-  while.44 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) while(tuple.6), condition=region_1.36, body=region_0.12\n-  get-tuple-element.45 = s32[] get-tuple-element(while.44), index=0\n-  get-tuple-element.46 = f32[128,128]{1,0} get-tuple-element(while.44), index=1\n-  get-tuple-element.47 = f32[2,128,128]{2,1,0} get-tuple-element(while.44), index=2\n-  ROOT tuple.48 = (f32[128,128]{1,0}, f32[2,128,128]{2,1,0}) tuple(get-tuple-element.46, get-tuple-element.47)\n-}\n-)\";\n-\n-  // running with module without exclusive lock on GpuExecutable\n-  HloModuleConfig config;\n-  auto debug_options = GetDebugOptionsForTest();\n-  debug_options.set_xla_gpu_require_exclusive_lock(false);\n-  config.set_debug_options(debug_options);\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(module_str, config));\n-  EXPECT_TRUE(RunAndCompare(std::move(module), ErrorSpec{1e-3, 2e-3}));\n-\n-  // running with module with exclusive lock on GpuExecutable\n-  debug_options.set_xla_gpu_require_exclusive_lock(true);\n-  config.set_debug_options(debug_options);\n-  TF_ASSERT_OK_AND_ASSIGN(module,\n-                          ParseAndReturnVerifiedModule(module_str, config));\n-  EXPECT_TRUE(RunAndCompare(std::move(module), ErrorSpec{1e-3, 2e-3}));\n-}\n-\n TEST(CommandBufferThunkTest, ToStringPrintsNestedThunks) {\n   BufferAllocation alloc_a(/*index=*/0, /*size=*/4, /*color=*/0);\n   BufferAllocation::Slice slice_a(&alloc_a, /*offset=*/0, /*size=*/4);\n@@ -1693,165 +1585,4 @@ TEST(CommandBufferThunkTest, ToStringPrintsNestedThunks) {\n       absl::StrContains(thunk.ToString(/*indent=*/1), \"    kMemset32BitValue\"));\n }\n \n-TEST_F(CmdBufferTest, ControlDependencyTest) {\n-  const char* module_str = R\"(\n-HloModule m\n-\n-%x (a: f32[3200,6400]) -> f32[3200,6400] {\n-  %a = f32[3200,6400]{1,0} parameter(0)\n-  ROOT %b = f32[3200,6400]{1,0} negate(%a)\n-}\n-\n-%y (a.1: f32[3200,6400]) -> f32[3200,6400] {\n-  %a.1 = f32[3200,6400]{1,0} parameter(0)\n-  ROOT %b.1 = f32[3200,6400]{1,0} add(%a.1, %a.1)\n-}\n-\n-%command_buffer (p: f32[3200,6400], p.1: f32[3200,6400]) -> (f32[3200,6400], f32[3200,6400]) {\n-  %p = f32[3200,6400]{1,0} parameter(0)\n-  %p.1 = f32[3200,6400]{1,0} parameter(1)\n-  %b.2 = f32[3200,6400]{1,0} fusion(%p), kind=kLoop, calls=%x\n-  %c = f32[3200,6400]{1,0} fusion(%p.1), kind=kLoop, calls=%y, control-predecessors={%b.2}\n-  ROOT %tuple = (f32[3200,6400]{1,0}, f32[3200,6400]{1,0}) tuple(%b.2, %c)\n-}\n-\n-ENTRY %e (m: f32[3200,6400], n: f32[3200,6400]) -> (f32[3200,6400], f32[3200,6400]) {\n-  %m = f32[3200,6400]{1,0} parameter(0)\n-  %n = f32[3200,6400]{1,0} parameter(1)\n-  %call = (f32[3200,6400]{1,0}, f32[3200,6400]{1,0}) call(%m, %n), to_apply=%command_buffer\n-  %get-tuple-element = f32[3200,6400]{1,0} get-tuple-element(%call), index=0\n-  %get-tuple-element.1 = f32[3200,6400]{1,0} get-tuple-element(%call), index=1\n-  ROOT %t = (f32[3200,6400]{1,0}, f32[3200,6400]{1,0}) tuple(%get-tuple-element, %get-tuple-element.1)\n-}\n-)\";\n-\n-  // running with module without exclusive lock on GpuExecutable\n-  HloModuleConfig config;\n-  auto debug_options = GetDebugOptionsForTest();\n-  debug_options.set_xla_disable_all_hlo_passes(true);\n-  config.set_debug_options(debug_options);\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(module_str, config));\n-  EXPECT_TRUE(RunAndCompare(std::move(module), ErrorSpec{1e-3, 2e-3}));\n-}\n-\n-TEST_F(CmdBufferTest, DynamicSliceCopyFusionCmd) {\n-  const char* module_str = R\"(\n-    dynamic_slice {\n-      p0 = s32[4,8,8]{2,1,0} parameter(0)\n-      p1 = s32[] parameter(1)\n-      c1 = s32[] constant(1)\n-      p2 = s32[] parameter(2)\n-\n-      p1p1 = s32[] add(p1, c1)\n-\n-      // Test all supported kinds of offsets: derived from the while loop's\n-      // induction variable (p1p1), constant (c1) and always clamped to 0, so\n-      // the value is irrelevant (p2).\n-      ROOT slice = s32[1,1,8] dynamic-slice(p0, p1p1, c1, p2),\n-          dynamic_slice_sizes={1,1,8}\n-    }\n-\n-    remainder {\n-      p0 = s32[] parameter(0)\n-      c5 = s32[] constant(5)\n-      // We take the value modulo 5 to test for correct clamping (the offset 4\n-      // must get clamped to 3, since it's greater or equal than the dimension\n-      // size).\n-      ROOT remainder = s32[] remainder(p0, c5)\n-    }\n-\n-    add {\n-      p0 = s32[] parameter(0)\n-      c1 = s32[] constant(1)\n-      ROOT sum = s32[] add(p0, c1)\n-    }\n-\n-    add_slices {\n-      p0 = s32[1,1,8] parameter(0)\n-      p1 = s32[1,1,8] parameter(1)\n-      ROOT sum = s32[1,1,8] add(p0, p1)\n-    }\n-\n-    times_two {\n-      p0 = s32[] parameter(0)\n-      ROOT sum = s32[] add(p0, p0)\n-    }\n-\n-    body {\n-      p0 = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) parameter(0)\n-      ivar = s32[] get-tuple-element(p0), index=0\n-      input = s32[4,8,8]{2,1,0} get-tuple-element(p0), index=1\n-\n-      ivar_copy = s32[] copy(ivar)\n-      acc = s32[1,1,8] get-tuple-element(p0), index=2\n-      acc_copy = s32[1,1,8] copy(acc)\n-\n-      offset1 = s32[] fusion(ivar_copy), kind=kLoop, calls=remainder\n-      offset2 = s32[] get-tuple-element(p0), index=3\n-\n-      slice = s32[1,1,8] fusion(input, offset1, offset2), kind=kLoop, calls=dynamic_slice,\n-          backend_config={\"fusion_backend_config\":{\n-              \"kind\":\"__dynamic_memcpy\",\n-              \"dynamic_memcpy_config\":{\n-                  \"depends_on_loop\":true,\n-                  \"src_offset_bytes\":[\"288\",\"544\",\"800\",\"800\",\"800\",\"288\"],\n-                  \"dst_offset_bytes\":[\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"]}}}\n-      next_ivar = s32[] fusion(ivar_copy), kind=kLoop, calls=add\n-      next_offset_2 = s32[] fusion(offset2), kind=kLoop, calls=times_two\n-\n-      next_acc = s32[1,1,8] fusion(acc_copy, slice), kind=kLoop, calls=add_slices\n-      ROOT result = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[])\n-          tuple(next_ivar, input, next_acc, next_offset_2)\n-    }\n-\n-    compare {\n-      p0 = s32[] parameter(0)\n-      c6 = s32[] constant(6)\n-      ROOT cmp = pred[] compare(p0, c6), direction=LT\n-    }\n-\n-    condition {\n-      p0 = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) parameter(0)\n-      ivar = s32[] get-tuple-element(p0), index=0\n-      ROOT cmp = pred[] fusion(ivar), kind=kLoop, calls=compare\n-    }\n-\n-    zero {\n-      c0 = s32[] constant(0)\n-      ROOT bc = s32[1,1,8] broadcast(c0), dimensions={}\n-    }\n-\n-    input {\n-      iota = s32[256] iota(), iota_dimension=0\n-      ROOT bc = s32[4,8,8]{2,1,0} bitcast(iota)\n-    }\n-\n-    ENTRY main {\n-      input = s32[4,8,8]{2,1,0} fusion(), kind=kLoop, calls=input\n-      init_acc = s32[1,1,8] fusion(), kind=kLoop, calls=zero\n-      c0 = s32[] constant(0)\n-      c1 = s32[] constant(1)\n-      tuple = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) tuple(c0, input, init_acc, c1)\n-      ROOT while = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) while(tuple),\n-          condition=condition, body=body,\n-          backend_config={\"known_trip_count\":{\"n\":\"6\"},\n-                          \"known_init_step\":{\"init\":\"0\",\"step\":\"1\"},\n-                          \"known_induction_variable\":{\"tuple_index\":\"0\"}}\n-    }\n-)\";\n-\n-  // running with module without exclusive lock on GpuExecutable\n-  HloModuleConfig config;\n-  auto debug_options = GetDebugOptionsForTest();\n-  debug_options.set_xla_gpu_require_exclusive_lock(false);\n-  debug_options.add_xla_gpu_enable_command_buffer(\n-      DebugOptions::DYNAMIC_SLICE_COPY_FUSION);\n-  config.set_debug_options(debug_options);\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(module_str, config));\n-  EXPECT_TRUE(\n-      RunAndCompareNoHloPasses(std::move(module), ErrorSpec{1e-3, 2e-3}));\n-}\n-\n }  // namespace xla::gpu"
        },
        {
            "sha": "7e5f4f0f2add68d8176f042c677b268f96fb918e",
            "filename": "third_party/xla/xla/service/gpu/tests/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/822a7678265bbfcc992ef0490a9efd06275c4061/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/822a7678265bbfcc992ef0490a9efd06275c4061/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2FBUILD?ref=822a7678265bbfcc992ef0490a9efd06275c4061",
            "patch": "@@ -156,9 +156,12 @@ xla_test(\n     deps = [\n         \"//xla:literal\",\n         \"//xla:literal_util\",\n+        \"//xla/service:hlo_module_config\",\n+        \"//xla/tests:hlo_pjrt_interpreter_reference_mixin\",\n         \"//xla/tests:hlo_pjrt_test_base\",\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "853b21f6f8ecc41d82ed96a0eaf392451902ee61",
            "filename": "third_party/xla/xla/service/gpu/tests/command_buffer_test.cc",
            "status": "modified",
            "additions": 267,
            "deletions": 3,
            "changes": 270,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/822a7678265bbfcc992ef0490a9efd06275c4061/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fcommand_buffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/822a7678265bbfcc992ef0490a9efd06275c4061/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fcommand_buffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fcommand_buffer_test.cc?ref=822a7678265bbfcc992ef0490a9efd06275c4061",
            "patch": "@@ -20,16 +20,21 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n+#include \"xla/service/hlo_module_config.h\"\n+#include \"xla/tests/hlo_pjrt_interpreter_reference_mixin.h\"\n #include \"xla/tests/hlo_pjrt_test_base.h\"\n #include \"xla/tests/literal_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n \n namespace xla::gpu {\n namespace {\n \n-class CommandBufferTest : public HloPjRtTestBase,\n-                          public ::testing::WithParamInterface<\n-                              DebugOptions::CommandBufferSchedulingMode> {\n+class CommandBufferTest\n+    : public HloPjRtInterpreterReferenceMixin<HloPjRtTestBase>,\n+      public ::testing::WithParamInterface<\n+          DebugOptions::CommandBufferSchedulingMode> {\n+ protected:\n   DebugOptions GetDebugOptionsForTest() const override {\n     DebugOptions debug_options = HloPjRtTestBase::GetDebugOptionsForTest();\n     debug_options.set_xla_gpu_command_buffer_scheduling_mode(GetParam());\n@@ -274,6 +279,265 @@ TEST_P(CommandBufferTest, WhileLoop) {\n   EXPECT_TRUE(LiteralTestUtil::Equal(expected, result));\n }\n \n+TEST_P(CommandBufferTest, ControlDependencyTest) {\n+  constexpr absl::string_view module_str = R\"(\n+HloModule m\n+\n+%x (a: f32[3200,6400]) -> f32[3200,6400] {\n+  %a = f32[3200,6400]{1,0} parameter(0)\n+  ROOT %b = f32[3200,6400]{1,0} negate(%a)\n+}\n+\n+%y (a.1: f32[3200,6400]) -> f32[3200,6400] {\n+  %a.1 = f32[3200,6400]{1,0} parameter(0)\n+  ROOT %b.1 = f32[3200,6400]{1,0} add(%a.1, %a.1)\n+}\n+\n+%command_buffer (p: f32[3200,6400], p.1: f32[3200,6400]) -> (f32[3200,6400], f32[3200,6400]) {\n+  %p = f32[3200,6400]{1,0} parameter(0)\n+  %p.1 = f32[3200,6400]{1,0} parameter(1)\n+  %b.2 = f32[3200,6400]{1,0} fusion(%p), kind=kLoop, calls=%x\n+  %c = f32[3200,6400]{1,0} fusion(%p.1), kind=kLoop, calls=%y, control-predecessors={%b.2}\n+  ROOT %tuple = (f32[3200,6400]{1,0}, f32[3200,6400]{1,0}) tuple(%b.2, %c)\n+}\n+\n+ENTRY %e (m: f32[3200,6400], n: f32[3200,6400]) -> (f32[3200,6400], f32[3200,6400]) {\n+  %m = f32[3200,6400]{1,0} parameter(0)\n+  %n = f32[3200,6400]{1,0} parameter(1)\n+  %call = (f32[3200,6400]{1,0}, f32[3200,6400]{1,0}) call(%m, %n), to_apply=%command_buffer\n+  %get-tuple-element = f32[3200,6400]{1,0} get-tuple-element(%call), index=0\n+  %get-tuple-element.1 = f32[3200,6400]{1,0} get-tuple-element(%call), index=1\n+  ROOT %t = (f32[3200,6400]{1,0}, f32[3200,6400]{1,0}) tuple(%get-tuple-element, %get-tuple-element.1)\n+}\n+  )\";\n+\n+  HloModuleConfig config;\n+  DebugOptions debug_options = GetDebugOptionsForTest();\n+  debug_options.set_xla_disable_all_hlo_passes(true);\n+  debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::FUSION);\n+  config.set_debug_options(debug_options);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(module_str, config));\n+  EXPECT_TRUE(RunAndCompare(std::move(module), ErrorSpec{1e-3, 2e-3}));\n+}\n+\n+TEST_P(CommandBufferTest, DynamicSliceFusionCmd) {\n+  // Hlo generated by the following JAX program:\n+  // def scan_body(carry, x):\n+  //     sliced_x = lax.slice(x, (0, 0), (128, 128))\n+  //     result = jnp.dot(carry, sliced_x)\n+  //     new_carry = result\n+  //     return new_carry, result\n+  // @jax.jit\n+  // def run_scan(initial_carry, xs):\n+  //     final_carry, outputs = lax.scan(scan_body, initial_carry, xs, length=2)\n+  //     return final_carry, outputs\n+\n+  constexpr absl::string_view module_str = R\"(\n+HloModule jit_run_scan\n+\n+None.7 {\n+  Arg_0.8 = f32[128,128]{1,0} parameter(0)\n+  Arg_1.9 = f32[128,128]{1,0} parameter(1)\n+  dot.10 = f32[128,128]{1,0} dot(Arg_0.8, Arg_1.9), lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+  ROOT tuple.11 = (f32[128,128]{1,0}, f32[128,128]{1,0}) tuple(dot.10, dot.10)\n+}\n+\n+region_0.12 {\n+  arg_tuple.13 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) parameter(0)\n+  get-tuple-element.14 = s32[] get-tuple-element(arg_tuple.13), index=0\n+  constant.18 = s32[] constant(1)\n+  add.34 = s32[] add(get-tuple-element.14, constant.18)\n+  get-tuple-element.15 = f32[128,128]{1,0} get-tuple-element(arg_tuple.13), index=1\n+  get-tuple-element.17 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.13), index=3\n+  constant.20 = s32[] constant(0)\n+  compare.21 = pred[] compare(get-tuple-element.14, constant.20), direction=LT\n+  constant.19 = s32[] constant(2)\n+  add.22 = s32[] add(get-tuple-element.14, constant.19)\n+  select.23 = s32[] select(compare.21, add.22, get-tuple-element.14)\n+  dynamic-slice.24 = f32[1,128,128]{2,1,0} dynamic-slice(get-tuple-element.17, select.23, constant.20, constant.20), dynamic_slice_sizes={1,128,128}\n+  reshape.25 = f32[128,128]{1,0} reshape(dynamic-slice.24)\n+  call.26 = (f32[128,128]{1,0}, f32[128,128]{1,0}) call(get-tuple-element.15, reshape.25), to_apply=None.7\n+  get-tuple-element.27 = f32[128,128]{1,0} get-tuple-element(call.26), index=0\n+  get-tuple-element.16 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.13), index=2\n+  get-tuple-element.28 = f32[128,128]{1,0} get-tuple-element(call.26), index=1\n+  reshape.29 = f32[1,128,128]{2,1,0} reshape(get-tuple-element.28)\n+  compare.30 = pred[] compare(get-tuple-element.14, constant.20), direction=LT\n+  add.31 = s32[] add(get-tuple-element.14, constant.19)\n+  select.32 = s32[] select(compare.30, add.31, get-tuple-element.14)\n+  dynamic-update-slice.33 = f32[2,128,128]{2,1,0} dynamic-update-slice(get-tuple-element.16, reshape.29, select.32, constant.20, constant.20)\n+  ROOT tuple.35 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) tuple(add.34, get-tuple-element.27, dynamic-update-slice.33, get-tuple-element.17)\n+} // region_0.12\n+\n+region_1.36 {\n+  arg_tuple.37 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) parameter(0)\n+  get-tuple-element.39 = f32[128,128]{1,0} get-tuple-element(arg_tuple.37), index=1\n+  get-tuple-element.40 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.37), index=2\n+  get-tuple-element.41 = f32[2,128,128]{2,1,0} get-tuple-element(arg_tuple.37), index=3\n+  get-tuple-element.38 = s32[] get-tuple-element(arg_tuple.37), index=0\n+  constant.42 = s32[] constant(2)\n+  ROOT compare.43 = pred[] compare(get-tuple-element.38, constant.42), direction=LT\n+} // region_1.36\n+\n+ENTRY main.49 {\n+  constant.3 = s32[] constant(0)\n+  Arg_0.1 = f32[128,128]{1,0} parameter(0)\n+  constant.4 = f32[] constant(0)\n+  broadcast.5 = f32[2,128,128]{2,1,0} broadcast(constant.4), dimensions={}\n+  Arg_1.2 = f32[2,128,128]{2,1,0} parameter(1)\n+  tuple.6 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) tuple(constant.3, Arg_0.1, broadcast.5, Arg_1.2)\n+  while.44 = (s32[], f32[128,128]{1,0}, f32[2,128,128]{2,1,0}, f32[2,128,128]{2,1,0}) while(tuple.6), condition=region_1.36, body=region_0.12\n+  get-tuple-element.45 = s32[] get-tuple-element(while.44), index=0\n+  get-tuple-element.46 = f32[128,128]{1,0} get-tuple-element(while.44), index=1\n+  get-tuple-element.47 = f32[2,128,128]{2,1,0} get-tuple-element(while.44), index=2\n+  ROOT tuple.48 = (f32[128,128]{1,0}, f32[2,128,128]{2,1,0}) tuple(get-tuple-element.46, get-tuple-element.47)\n+}\n+  )\";\n+\n+  // Run twice toggling exclusive lock to match original test behavior.\n+  HloModuleConfig config;\n+  auto debug_options = GetDebugOptionsForTest();\n+  debug_options.set_xla_gpu_require_exclusive_lock(false);\n+  debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::FUSION);\n+  debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUBLAS);\n+  debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUBLASLT);\n+  debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUSTOM_CALL);\n+  debug_options.add_xla_gpu_enable_command_buffer(DebugOptions::CUDNN);\n+  debug_options.add_xla_gpu_enable_command_buffer(\n+      DebugOptions::DYNAMIC_SLICE_FUSION);\n+  config.set_debug_options(debug_options);\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(module_str, config));\n+  EXPECT_TRUE(RunAndCompare(std::move(module), ErrorSpec{1e-3, 2e-3}));\n+\n+  debug_options.set_xla_gpu_require_exclusive_lock(true);\n+  config.set_debug_options(debug_options);\n+  TF_ASSERT_OK_AND_ASSIGN(module,\n+                          ParseAndReturnVerifiedModule(module_str, config));\n+  EXPECT_TRUE(RunAndCompare(std::move(module), ErrorSpec{1e-3, 2e-3}));\n+}\n+\n+TEST_P(CommandBufferTest, DynamicSliceCopyFusionCmd) {\n+  constexpr absl::string_view hlo_text = R\"(\n+    dynamic_slice {\n+      p0 = s32[4,8,8]{2,1,0} parameter(0)\n+      p1 = s32[] parameter(1)\n+      c1 = s32[] constant(1)\n+      p2 = s32[] parameter(2)\n+\n+      p1p1 = s32[] add(p1, c1)\n+\n+      // Test all supported kinds of offsets: derived from the while loop's\n+      // induction variable (p1p1), constant (c1) and always clamped to 0, so\n+      // the value is irrelevant (p2).\n+      ROOT slice = s32[1,1,8] dynamic-slice(p0, p1p1, c1, p2),\n+          dynamic_slice_sizes={1,1,8}\n+    }\n+\n+    remainder {\n+      p0 = s32[] parameter(0)\n+      c5 = s32[] constant(5)\n+      // We take the value modulo 5 to test for correct clamping (the offset 4\n+      // must get clamped to 3, since it's greater or equal than the dimension\n+      // size).\n+      ROOT remainder = s32[] remainder(p0, c5)\n+    }\n+\n+    add {\n+      p0 = s32[] parameter(0)\n+      c1 = s32[] constant(1)\n+      ROOT sum = s32[] add(p0, c1)\n+    }\n+\n+    add_slices {\n+      p0 = s32[1,1,8] parameter(0)\n+      p1 = s32[1,1,8] parameter(1)\n+      ROOT sum = s32[1,1,8] add(p0, p1)\n+    }\n+\n+    times_two {\n+      p0 = s32[] parameter(0)\n+      ROOT sum = s32[] add(p0, p0)\n+    }\n+\n+    body {\n+      p0 = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) parameter(0)\n+      ivar = s32[] get-tuple-element(p0), index=0\n+      input = s32[4,8,8]{2,1,0} get-tuple-element(p0), index=1\n+\n+      ivar_copy = s32[] copy(ivar)\n+      acc = s32[1,1,8] get-tuple-element(p0), index=2\n+      acc_copy = s32[1,1,8] copy(acc)\n+\n+      offset1 = s32[] fusion(ivar_copy), kind=kLoop, calls=remainder\n+      offset2 = s32[] get-tuple-element(p0), index=3\n+\n+      slice = s32[1,1,8] fusion(input, offset1, offset2), kind=kLoop, calls=dynamic_slice,\n+          backend_config={\"fusion_backend_config\":{\n+              \"kind\":\"__dynamic_memcpy\",\n+              \"dynamic_memcpy_config\":{\n+                  \"depends_on_loop\":true,\n+                  \"src_offset_bytes\":[\"288\",\"544\",\"800\",\"800\",\"800\",\"288\"],\n+                  \"dst_offset_bytes\":[\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"]}}}\n+      next_ivar = s32[] fusion(ivar_copy), kind=kLoop, calls=add\n+      next_offset_2 = s32[] fusion(offset2), kind=kLoop, calls=times_two\n+\n+      next_acc = s32[1,1,8] fusion(acc_copy, slice), kind=kLoop, calls=add_slices\n+      ROOT result = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[])\n+          tuple(next_ivar, input, next_acc, next_offset_2)\n+    }\n+\n+    compare {\n+      p0 = s32[] parameter(0)\n+      c6 = s32[] constant(6)\n+      ROOT cmp = pred[] compare(p0, c6), direction=LT\n+    }\n+\n+    condition {\n+      p0 = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) parameter(0)\n+      ivar = s32[] get-tuple-element(p0), index=0\n+      ROOT cmp = pred[] fusion(ivar), kind=kLoop, calls=compare\n+    }\n+\n+    zero {\n+      c0 = s32[] constant(0)\n+      ROOT bc = s32[1,1,8] broadcast(c0), dimensions={}\n+    }\n+\n+    input {\n+      iota = s32[256] iota(), iota_dimension=0\n+      ROOT bc = s32[4,8,8]{2,1,0} bitcast(iota)\n+    }\n+\n+    ENTRY main {\n+      input = s32[4,8,8]{2,1,0} fusion(), kind=kLoop, calls=input\n+      init_acc = s32[1,1,8] fusion(), kind=kLoop, calls=zero\n+      c0 = s32[] constant(0)\n+      c1 = s32[] constant(1)\n+      tuple = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) tuple(c0, input, init_acc, c1)\n+      ROOT while = (s32[], s32[4,8,8]{2,1,0}, s32[1,1,8], s32[]) while(tuple),\n+          condition=condition, body=body,\n+          backend_config={\"known_trip_count\":{\"n\":\"6\"},\n+                          \"known_init_step\":{\"init\":\"0\",\"step\":\"1\"},\n+                          \"known_induction_variable\":{\"tuple_index\":\"0\"}}\n+    }\n+  )\";\n+\n+  HloModuleConfig config;\n+  DebugOptions debug_options = GetDebugOptionsForTest();\n+  debug_options.set_xla_gpu_require_exclusive_lock(false);\n+  debug_options.add_xla_gpu_enable_command_buffer(\n+      DebugOptions::DYNAMIC_SLICE_COPY_FUSION);\n+  config.set_debug_options(debug_options);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_text, config));\n+\n+  EXPECT_TRUE(\n+      RunAndCompareNoHloPasses(std::move(module), ErrorSpec{1e-3, 2e-3}));\n+}\n+\n INSTANTIATE_TEST_SUITE_P(CommandBufferTests, CommandBufferTest,\n                          ::testing::Values(DebugOptions::LHS,\n                                            DebugOptions::CONCURRENT));"
        }
    ],
    "stats": {
        "total": 542,
        "additions": 270,
        "deletions": 272
    }
}