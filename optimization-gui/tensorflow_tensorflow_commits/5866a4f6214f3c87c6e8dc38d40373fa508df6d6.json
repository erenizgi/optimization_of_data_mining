{
    "author": "liepieshov",
    "message": "fix relayout propagation for MPMD.\n\nIn the cases where the program argument with AUTO layout is used in more than one Fragment enforce the DEFAULT layout as we cannot allow different compiled layouts\n\nPiperOrigin-RevId: 821612799",
    "sha": "5866a4f6214f3c87c6e8dc38d40373fa508df6d6",
    "files": [
        {
            "sha": "c85997a33a039393dc055cda65a3fddf2c53d180",
            "filename": "third_party/xla/xla/python/ifrt/ir/compiled_ifrt_ir_program.cc",
            "status": "modified",
            "additions": 86,
            "deletions": 90,
            "changes": 176,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5866a4f6214f3c87c6e8dc38d40373fa508df6d6/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5866a4f6214f3c87c6e8dc38d40373fa508df6d6/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fcompiled_ifrt_ir_program.cc?ref=5866a4f6214f3c87c6e8dc38d40373fa508df6d6",
            "patch": "@@ -137,67 +137,37 @@ absl::StatusOr<std::vector<xla::ifrt::ArraySpec>> ExtractOutSpecs(\n   return out_specs;\n }\n \n+absl::StatusOr<std::shared_ptr<const xla::PjRtLayout>> BuildDefaultLayout(\n+    const xla::ifrt::ArraySpec& arg_spec, xla::ifrt::Client* client) {\n+  TF_ASSIGN_OR_RETURN(auto shard_shape,\n+                      arg_spec.sharding->GetShardShape(arg_spec.shape));\n+  return client->GetDefaultPjRtLayout(\n+      arg_spec.dtype, shard_shape.dims(),\n+      arg_spec.sharding->devices()->devices().front(),\n+      arg_spec.sharding->memory_kind());\n+}\n+\n absl::StatusOr<std::shared_ptr<const xla::PjRtLayout>>\n-GetParameterLayoutFromConsumer(\n+GetParameterLayoutFromLoadedExecutable(\n     xla::ifrt::Client* client,\n     const AtomExecutableMap& atom_program_executables,\n     absl::Span<const xla::ifrt::ArraySpec> in_specs,\n     absl::Span<const xla::ifrt::ArraySpec> out_specs,\n-    mlir::SymbolTableCollection& symbol_table, mlir::OpOperand& param_operand) {\n-  if (auto call_op = llvm::dyn_cast<xla::ifrt::CallLoadedExecutableOp>(\n-          param_operand.getOwner())) {\n-    // The parameter is used by a CallLoadedExecutableOp, return the layout\n-    // from the atom program executable.\n-    xla::ifrt::LoadedExecutableOp loaded_exec_op =\n-        call_op.getCalleeOp(symbol_table);\n-    auto atom_program_name = loaded_exec_op.getSymName().str();\n-    auto exec_it = atom_program_executables.find(atom_program_name);\n-    if (exec_it != atom_program_executables.end()) {\n-      TF_ASSIGN_OR_RETURN(auto exec_layouts,\n-                          exec_it->second->GetParameterLayouts());\n-      return std::move(exec_layouts[param_operand.getOperandNumber()]);\n-    } else {\n-      return absl::FailedPreconditionError(absl::StrFormat(\n-          \"Could not find SPMD executable %s\", atom_program_name));\n-    }\n-  } else if (auto return_op = llvm::dyn_cast<mlir::func::ReturnOp>(\n-                 param_operand.getOwner())) {\n-    // TODO(b/382761415): AUTO layouts should be handled during IFRT IR program\n-    // compilation so that by the time this method is called there should be no\n-    // AUTO layouts.\n-    // The parameter is not used by any atom program, return device default\n-    // layout.\n-    const auto& out_spec = out_specs[param_operand.getOperandNumber()];\n-    TF_ASSIGN_OR_RETURN(auto shard_shape,\n-                        out_spec.sharding->GetShardShape(out_spec.shape));\n-    return client->GetDefaultPjRtLayout(\n-        out_spec.dtype, shard_shape.dims(),\n-        out_spec.sharding->devices()->devices().front(),\n-        out_spec.sharding->memory_kind());\n-  } else if (auto copy_arrays =\n-                 llvm::dyn_cast<ifrt::CopyArraysOp>(param_operand.getOwner())) {\n-    // If the parameter is used by a CopyArraysOp, we assume a default layout.\n-    if (auto arg = llvm::dyn_cast<mlir::BlockArgument>(param_operand.get())) {\n-      const auto& arg_spec = in_specs[arg.getArgNumber()];\n-      TF_ASSIGN_OR_RETURN(auto shard_shape,\n-                          arg_spec.sharding->GetShardShape(arg_spec.shape));\n-      return client->GetDefaultPjRtLayout(\n-          arg_spec.dtype, shard_shape.dims(),\n-          arg_spec.sharding->devices()->devices().front(),\n-          arg_spec.sharding->memory_kind());\n-    } else {\n-      return absl::FailedPreconditionError(absl::StrFormat(\n-          \"Parameter used by CopyArraysOp does not originate from a block \"\n-          \"argument. Parameter used by %s\",\n-          xla::ifrt::OperationToString(param_operand.getOwner(),\n-                                       mlir::OpPrintingFlags())));\n-    }\n+    mlir::SymbolTableCollection& symbol_table,\n+    ifrt::CallLoadedExecutableOp& call_op, int param_operand_number) {\n+  // The parameter is used by a CallLoadedExecutableOp, return the layout\n+  // from the atom program executable.\n+  xla::ifrt::LoadedExecutableOp loaded_exec_op =\n+      call_op.getCalleeOp(symbol_table);\n+  auto atom_program_name = loaded_exec_op.getSymName().str();\n+  auto exec_it = atom_program_executables.find(atom_program_name);\n+  if (exec_it != atom_program_executables.end()) {\n+    TF_ASSIGN_OR_RETURN(auto exec_layouts,\n+                        exec_it->second->GetParameterLayouts());\n+    return std::move(exec_layouts[param_operand_number]);\n   } else {\n     return absl::FailedPreconditionError(absl::StrFormat(\n-        \"Layouts are supported only for programs that have parameters used \"\n-        \"only by CallLoadedExecutableOp ops. Used by %s\",\n-        xla::ifrt::OperationToString(param_operand.getOwner(),\n-                                     mlir::OpPrintingFlags())));\n+        \"Could not find SPMD executable %s\", atom_program_name));\n   }\n }\n \n@@ -213,36 +183,73 @@ absl::Status PopulateLayouts(mlir::ModuleOp mlir_module,\n     std::shared_ptr<const xla::PjRtLayout> parameter_layout;\n     if (arg.use_empty()) {\n       // The argument is not used. Return device default layout.\n-      const auto& arg_spec = in_specs[arg.getArgNumber()];\n-      TF_ASSIGN_OR_RETURN(auto shard_shape,\n-                          arg_spec.sharding->GetShardShape(arg_spec.shape));\n-      TF_ASSIGN_OR_RETURN(parameter_layout,\n-                          client->GetDefaultPjRtLayout(\n-                              arg_spec.dtype, shard_shape.dims(),\n-                              arg_spec.sharding->devices()->devices().front(),\n-                              arg_spec.sharding->memory_kind()));\n+      TF_ASSIGN_OR_RETURN(\n+          parameter_layout,\n+          BuildDefaultLayout(in_specs[arg.getArgNumber()], client));\n     } else {\n-      mlir::OpOperand& first_use = *arg.getUses().begin();\n-      TF_ASSIGN_OR_RETURN(parameter_layout,\n-                          GetParameterLayoutFromConsumer(\n-                              client, atom_program_executables, in_specs,\n-                              out_specs, symbol_table, first_use));\n-      for (mlir::OpOperand& use : llvm::drop_begin(arg.getUses())) {\n-        TF_ASSIGN_OR_RETURN(auto layout_from_executable,\n-                            GetParameterLayoutFromConsumer(\n-                                client, atom_program_executables, in_specs,\n-                                out_specs, symbol_table, use));\n-        // Verify that all uses of the parameter have the same layout.\n-        if (*parameter_layout != *layout_from_executable) {\n+      bool found_copy_arrays_user = false;\n+      // Find the layout from the first LoadedExecutableOp consumer or just\n+      // return any of the users otherwise. Possible users: CopyArraysOp,\n+      // ReturnOp, and other LoadedExecutableOp.\n+      for (mlir::OpOperand& use : arg.getUses()) {\n+        if (llvm::isa<mlir::func::ReturnOp>(use.getOwner())) {\n+          continue;\n+        }\n+        if (llvm::isa<ifrt::CopyArraysOp>(use.getOwner())) {\n+          found_copy_arrays_user = true;\n+          continue;\n+        }\n+\n+        if (!llvm::isa<ifrt::CallLoadedExecutableOp>(use.getOwner())) {\n+          return absl::FailedPreconditionError(absl::StrFormat(\n+              \"Layouts are supported only for programs that have parameters \"\n+              \"used only by CallLoadedExecutableOp ops. Parameter %d is used \"\n+              \"by %s\",\n+              arg.getArgNumber(),\n+              xla::ifrt::OperationToString(use.getOwner(),\n+                                           mlir::OpPrintingFlags())));\n+        }\n+        auto call_op = llvm::cast<ifrt::CallLoadedExecutableOp>(use.getOwner());\n+        TF_ASSIGN_OR_RETURN(\n+            std::shared_ptr<const xla::PjRtLayout> consumer_layout,\n+            GetParameterLayoutFromLoadedExecutable(\n+                client, atom_program_executables, in_specs, out_specs,\n+                symbol_table, call_op, use.getOperandNumber()));\n+        if (!parameter_layout) {\n+          parameter_layout = std::move(consumer_layout);\n+          continue;\n+        }\n+        if (*parameter_layout != *consumer_layout) {\n           return absl::InternalError(absl::StrFormat(\n               \"Parameter %d is used by atom programs with incompatible \"\n               \"layouts: %s vs. %s. This happens because support for layout \"\n               \"progation within MPMD programs is limited. Contact \"\n               \"ml-pathways-team@ for help\",\n               arg.getArgNumber(), parameter_layout->ToString(),\n-              layout_from_executable->ToString()));\n+              consumer_layout->ToString()));\n         }\n       }\n+      if (parameter_layout && found_copy_arrays_user) {\n+        // Need to check if the layout is compatible with the CopyArraysOp.\n+        TF_ASSIGN_OR_RETURN(\n+            std::shared_ptr<const xla::PjRtLayout> default_layout,\n+            BuildDefaultLayout(in_specs[arg.getArgNumber()], client));\n+        if (*parameter_layout != *default_layout) {\n+          return absl::InternalError(absl::StrFormat(\n+              \"Parameter %d is used by atom program with layout: %s and in \"\n+              \"transfer op with layout: %s. This happens because support for \"\n+              \"layout progation within MPMD programs is limited. Contact \"\n+              \"ml-pathways-team@ for help\",\n+              arg.getArgNumber(), parameter_layout->ToString(),\n+              default_layout->ToString()));\n+        }\n+      }\n+      if (!parameter_layout) {\n+        // The argument was skipped above, meaning only used by ReturnOp.\n+        TF_ASSIGN_OR_RETURN(\n+            parameter_layout,\n+            BuildDefaultLayout(in_specs[arg.getArgNumber()], client));\n+      }\n     }\n     in_specs[arg.getArgNumber()].layout = std::move(parameter_layout);\n   }\n@@ -252,15 +259,9 @@ absl::Status PopulateLayouts(mlir::ModuleOp mlir_module,\n     auto& out_spec = out_specs[return_operand.getOperandNumber()];\n     if (mlir::BlockArgument block_arg =\n             llvm::dyn_cast<mlir::BlockArgument>(return_operand.get())) {\n-      // The output is an argument of the IFRT IR program. Assume device\n-      // default layout.\n-      TF_ASSIGN_OR_RETURN(auto shard_shape,\n-                          out_spec.sharding->GetShardShape(out_spec.shape));\n-      TF_ASSIGN_OR_RETURN(out_spec.layout,\n-                          client->GetDefaultPjRtLayout(\n-                              out_spec.dtype, shard_shape.dims(),\n-                              out_spec.sharding->devices()->devices().front(),\n-                              out_spec.sharding->memory_kind()));\n+      // If result is a main func BlockArg, then it has already propagated the\n+      // layout above.\n+      out_spec.layout = in_specs[block_arg.getArgNumber()].layout;\n       continue;\n     }\n     auto op_result = llvm::cast<mlir::OpResult>(return_operand.get());\n@@ -286,13 +287,8 @@ absl::Status PopulateLayouts(mlir::ModuleOp mlir_module,\n     } else if (llvm::isa<ifrt::CopyArraysOp>(op_result.getOwner())) {\n       // The output is produced by a CopyArraysOp. Must be device\n       // default layout.\n-      TF_ASSIGN_OR_RETURN(auto shard_shape,\n-                          out_spec.sharding->GetShardShape(out_spec.shape));\n       TF_ASSIGN_OR_RETURN(out_spec.layout,\n-                          client->GetDefaultPjRtLayout(\n-                              out_spec.dtype, shard_shape.dims(),\n-                              out_spec.sharding->devices()->devices().front(),\n-                              out_spec.sharding->memory_kind()));\n+                          BuildDefaultLayout(out_spec, client));\n     } else {\n       return absl::FailedPreconditionError(absl::StrFormat(\n           \"Layouts are supported only for programs that have outputs produced \""
        }
    ],
    "stats": {
        "total": 176,
        "additions": 86,
        "deletions": 90
    }
}