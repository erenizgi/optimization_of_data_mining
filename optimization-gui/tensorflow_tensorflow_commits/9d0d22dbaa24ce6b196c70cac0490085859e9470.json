{
    "author": "hawkinsp",
    "message": "[PJRT] Change the two optimizations in Transpose to operate on Loop nests, rather than on the original dimensions.\n\nThese are simpler both to write and to think about.\n\nNo behavior changes are intended.\n\nPiperOrigin-RevId: 846253300",
    "sha": "9d0d22dbaa24ce6b196c70cac0490085859e9470",
    "files": [
        {
            "sha": "c7eb090396085c496f18eb8711c4f7e87e08fb7e",
            "filename": "third_party/xla/xla/pjrt/transpose.cc",
            "status": "modified",
            "additions": 87,
            "deletions": 123,
            "changes": 210,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9d0d22dbaa24ce6b196c70cac0490085859e9470/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9d0d22dbaa24ce6b196c70cac0490085859e9470/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose.cc?ref=9d0d22dbaa24ce6b196c70cac0490085859e9470",
            "patch": "@@ -548,124 +548,6 @@ static void ComputeStrides(\n   }\n }\n \n-void TransposePlan::RemoveTrivialDimensions(\n-    absl::InlinedVector<int64_t, 4>& a_dims,\n-    absl::InlinedVector<int64_t, 4>& permutation,\n-    absl::InlinedVector<int64_t, 4>& lda,\n-    absl::InlinedVector<int64_t, 4>& lda_tile,\n-    absl::InlinedVector<int64_t, 4>& a_tiling,\n-    absl::InlinedVector<int64_t, 4>& b_tiling) {\n-  int ndim = a_dims.size();\n-  // How many positions has the i-th dimension of 'a' been moved to the left?\n-  // -1 if the dimension is to be removed.\n-  std::vector<int> shift(ndim);\n-  absl::InlinedVector<int64_t, 4> updated_a_dims;\n-  absl::InlinedVector<int64_t, 4> updated_lda;\n-  absl::InlinedVector<int64_t, 4> updated_lda_tile;\n-  absl::InlinedVector<int64_t, 4> updated_a_tiling;\n-  updated_a_dims.reserve(ndim);\n-  updated_lda.reserve(ndim);\n-  updated_lda_tile.reserve(ndim);\n-  updated_a_tiling.reserve(ndim);\n-  std::vector<int64_t> inv_permutation = InversePermutation(permutation);\n-  for (int a_dim = 0; a_dim < ndim; ++a_dim) {\n-    int b_dim = inv_permutation[a_dim];\n-    // A dimension is trivial if it has size 1 and is not tiled.\n-    if (a_dims[a_dim] == 1 && a_tiling[a_dim] == 1 && b_tiling[b_dim] == 1) {\n-      shift[a_dim] = -1;\n-    } else {\n-      updated_a_dims.push_back(a_dims[a_dim]);\n-      updated_lda.push_back(lda[a_dim]);\n-      updated_lda_tile.push_back(lda_tile[a_dim]);\n-      updated_a_tiling.push_back(a_tiling[a_dim]);\n-      shift[a_dim] = a_dim + 1 - updated_a_dims.size();\n-    }\n-  }\n-\n-  // Updates the permutation and tiling of b.\n-  absl::InlinedVector<int64_t, 4> updated_permutation;\n-  absl::InlinedVector<int64_t, 4> updated_b_tiling;\n-  updated_permutation.reserve(updated_a_dims.size());\n-  updated_b_tiling.reserve(updated_a_dims.size());\n-  for (int b_dim = 0; b_dim < ndim; ++b_dim) {\n-    int a_dim = permutation[b_dim];\n-    if (shift[a_dim] >= 0) {\n-      updated_permutation.push_back(a_dim - shift[a_dim]);\n-      updated_b_tiling.push_back(b_tiling[b_dim]);\n-    }\n-  }\n-\n-  DCHECK(IsPermutation(updated_permutation));\n-  a_dims = std::move(updated_a_dims);\n-  permutation = std::move(updated_permutation);\n-  lda = std::move(updated_lda);\n-  lda_tile = std::move(updated_lda_tile);\n-  a_tiling = std::move(updated_a_tiling);\n-  b_tiling = std::move(updated_b_tiling);\n-}\n-\n-void TransposePlan::CoalesceDimensions(\n-    absl::InlinedVector<int64_t, 4>& a_dims,\n-    absl::InlinedVector<int64_t, 4>& permutation,\n-    absl::InlinedVector<int64_t, 4>& lda,\n-    absl::InlinedVector<int64_t, 4>& lda_tile,\n-    absl::InlinedVector<int64_t, 4>& a_tiling,\n-    absl::InlinedVector<int64_t, 4>& b_tiling) {\n-  int ndim = a_dims.size();\n-  // How many positions has the i-th dimension of 'a' been moved to the left?\n-  // -1 if the dimension is to be removed.\n-  std::vector<int> shift(ndim, 0);\n-  absl::InlinedVector<int64_t, 4> updated_a_dims;\n-  absl::InlinedVector<int64_t, 4> updated_lda;\n-  absl::InlinedVector<int64_t, 4> updated_lda_tile;\n-  absl::InlinedVector<int64_t, 4> updated_a_tiling;\n-  updated_a_dims.reserve(ndim);\n-  updated_lda.reserve(ndim);\n-  updated_lda_tile.reserve(ndim);\n-  updated_a_tiling.reserve(ndim);\n-  std::vector<int64_t> inv_permutation = InversePermutation(permutation);\n-  for (int a_dim = 0; a_dim < ndim; ++a_dim) {\n-    // We can coalesce two dimensions if they appear consecutively\n-    // in both the input dimensions and the output dimensions, and the stride\n-    // of the outer dimension is the usual multiple of the inner dimension.\n-    if (a_dim > 0 && inv_permutation[a_dim - 1] + 1 == inv_permutation[a_dim] &&\n-        lda[a_dim - 1] == lda[a_dim] * a_dims[a_dim] &&\n-        a_tiling[a_dim - 1] == 1 && a_tiling[a_dim] == 1 &&\n-        b_tiling[inv_permutation[a_dim]] == 1 &&\n-        b_tiling[inv_permutation[a_dim - 1]] == 1) {\n-      updated_a_dims.back() *= a_dims[a_dim];\n-      updated_lda.back() = lda[a_dim];\n-      shift[a_dim] = -1;\n-    } else {\n-      updated_a_dims.push_back(a_dims[a_dim]);\n-      updated_lda.push_back(lda[a_dim]);\n-      updated_lda_tile.push_back(lda_tile[a_dim]);\n-      updated_a_tiling.push_back(a_tiling[a_dim]);\n-      shift[a_dim] = a_dim + 1 - updated_a_dims.size();\n-    }\n-  }\n-\n-  // Updates the permutation.\n-  absl::InlinedVector<int64_t, 4> updated_permutation;\n-  absl::InlinedVector<int64_t, 4> updated_b_tiling;\n-  updated_permutation.reserve(updated_a_dims.size());\n-  updated_b_tiling.reserve(updated_a_dims.size());\n-  for (int b_dim = 0; b_dim < ndim; ++b_dim) {\n-    int a_dim = permutation[b_dim];\n-    if (shift[a_dim] >= 0) {\n-      updated_permutation.push_back(a_dim - shift[a_dim]);\n-      updated_b_tiling.push_back(b_tiling[b_dim]);\n-    }\n-  }\n-  DCHECK(IsPermutation(updated_permutation));\n-  a_dims = std::move(updated_a_dims);\n-  permutation = std::move(updated_permutation);\n-  lda = std::move(updated_lda);\n-  lda_tile = std::move(updated_lda_tile);\n-  a_tiling = std::move(updated_a_tiling);\n-  b_tiling = std::move(updated_b_tiling);\n-}\n-\n int64_t TransposePlan::InputNumElems() const {\n   int64_t size = 1;\n   for (size_t i = 0; i < a_dims_.size(); ++i) {\n@@ -712,6 +594,15 @@ static absl::Status ParseTilingSpecification(\n   return absl::OkStatus();\n }\n \n+bool TransposePlan::Loop::operator==(const Loop& other) const {\n+  return dim_in_a == other.dim_in_a && tile_interior == other.tile_interior &&\n+         dim_size == other.dim_size && tile_size == other.tile_size &&\n+         lda == other.lda && ldb == other.ldb &&\n+         is_inner_dim_in_a == other.is_inner_dim_in_a &&\n+         is_inner_dim_in_b == other.is_inner_dim_in_b &&\n+         parallelism == other.parallelism;\n+}\n+\n // Helper function that builds a plan.\n void TransposePlan::BuildPlanNodes(int thread_id,\n                                    std::vector<TransposePlan::Node>& nodes) {\n@@ -1063,11 +954,6 @@ void TransposePlan::Initialize() {\n   if (num_elems_ == 0) {\n     return;\n   }\n-  RemoveTrivialDimensions(a_dims_, permutation_, lda_, lda_tile_, a_tiling_,\n-                          b_tiling_);\n-  CoalesceDimensions(a_dims_, permutation_, lda_, lda_tile_, a_tiling_,\n-                     b_tiling_);\n-\n   // permutation maps dimensions of b to a\n   // inverse_permutation maps dimensions of a to b\n   std::vector<int64_t> inverse_permutation = InversePermutation(permutation_);\n@@ -1144,6 +1030,9 @@ void TransposePlan::Initialize() {\n     }\n   }\n \n+  RemoveTrivialLoops(loop_order_);\n+  CoalesceLoops(loop_order_);\n+\n   // Bound the block sizes so they are smaller than the stride-1 dimension\n   // size.\n   int64_t a_stride1_size = std::max(\n@@ -1425,4 +1314,79 @@ absl::StatusOr<std::shared_ptr<TransposePlan>> TransposePlanCache::GetOrCreate(\n       });\n }\n \n+/*static*/ void TransposePlan::RemoveTrivialLoops(std::vector<Loop>& loops) {\n+  auto it = std::remove_if(loops.begin(), loops.end(), [](const Loop& loop) {\n+    // We must preserve the loop if it corresponds to the innermost dimension\n+    // of the layout, because the kernels (especially TransposeConstStride1)\n+    // rely on finding a node with is_inner_dim_in_a/b set to true.\n+    if (loop.is_inner_dim_in_a || loop.is_inner_dim_in_b) {\n+      return false;\n+    }\n+    if (loop.tile_interior) {\n+      return loop.tile_size == 1;\n+    }\n+    // Exterior loop.\n+    // Trivial if dim_size == tile_size (1 complete tile, no partials). This\n+    // also accounts for the case where the dimension is of size 1, since in\n+    // that case the tile size is also 1.\n+    return loop.dim_size == loop.tile_size;\n+  });\n+  loops.erase(it, loops.end());\n+}\n+\n+/*static*/ void TransposePlan::CoalesceLoops(std::vector<Loop>& loops) {\n+  if (loops.empty()) {\n+    return;\n+  }\n+\n+  // Coalesce from slow-varying to fast-varying (outer to inner).\n+  // loop_order_[0] is slowest.\n+  int write_pos = 0;\n+  for (int read_pos = 1; read_pos < loops.size(); ++read_pos) {\n+    Loop& outer = loops[write_pos];\n+    const Loop& inner = loops[read_pos];\n+\n+    int64_t inner_iter_size = inner.tile_interior\n+                                  ? inner.tile_size\n+                                  : (inner.dim_size / inner.tile_size);\n+\n+    // Two loops can be coalesced if:\n+    // * they are both tile interiors or both tile exteriors\n+    // * neither has a partial tile\n+    // * the inner loop is a multiple of the outer loop.\n+    // TODO(phawkins): I suspect this condition can be simplified. In particular\n+    // the condition that we separate tile exteriors from interiors feels\n+    // arbitrary.\n+    bool coalescable = (outer.tile_interior == inner.tile_interior) &&\n+                       (outer.dim_size % outer.tile_size == 0) &&\n+                       (inner.dim_size % inner.tile_size == 0) &&\n+                       (outer.lda == inner.lda * inner_iter_size) &&\n+                       (outer.ldb == inner.ldb * inner_iter_size);\n+    if (coalescable) {\n+      if (outer.tile_interior) {\n+        outer.tile_size *= inner.tile_size;\n+        outer.dim_size *= inner.dim_size;\n+      } else {\n+        outer.dim_size *= inner_iter_size;\n+      }\n+\n+      outer.lda = inner.lda;\n+      outer.ldb = inner.ldb;\n+\n+      outer.is_inner_dim_in_a =\n+          inner.is_inner_dim_in_a || outer.is_inner_dim_in_a;\n+      outer.is_inner_dim_in_b =\n+          inner.is_inner_dim_in_b || outer.is_inner_dim_in_b;\n+\n+      // Don't advance write_pos, so we can merge more into 'outer'.\n+    } else {\n+      ++write_pos;\n+      if (write_pos != read_pos) {\n+        loops[write_pos] = inner;\n+      }\n+    }\n+  }\n+  loops.resize(write_pos + 1);\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "aef51be791a04bbb1a05b51d5f3a954b4139fd52",
            "filename": "third_party/xla/xla/pjrt/transpose.h",
            "status": "modified",
            "additions": 34,
            "deletions": 44,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9d0d22dbaa24ce6b196c70cac0490085859e9470/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9d0d22dbaa24ce6b196c70cac0490085859e9470/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose.h?ref=9d0d22dbaa24ce6b196c70cac0490085859e9470",
            "patch": "@@ -147,23 +147,40 @@ class TransposePlan {\n  protected:\n   // Methods protected so they can be accessed by tests.\n \n-  // Removes any size-1 dimensions.\n-  static void RemoveTrivialDimensions(\n-      absl::InlinedVector<int64_t, 4>& a_dims,\n-      absl::InlinedVector<int64_t, 4>& permutation,\n-      absl::InlinedVector<int64_t, 4>& lda,\n-      absl::InlinedVector<int64_t, 4>& lda_tile,\n-      absl::InlinedVector<int64_t, 4>& a_tiling,\n-      absl::InlinedVector<int64_t, 4>& b_tiling);\n-\n-  // Collapses together dimensions that are adjacent both in `dims` and\n-  // `permutation`.\n-  static void CoalesceDimensions(absl::InlinedVector<int64_t, 4>& a_dims,\n-                                 absl::InlinedVector<int64_t, 4>& permutation,\n-                                 absl::InlinedVector<int64_t, 4>& lda,\n-                                 absl::InlinedVector<int64_t, 4>& lda_tile,\n-                                 absl::InlinedVector<int64_t, 4>& a_tiling,\n-                                 absl::InlinedVector<int64_t, 4>& b_tiling);\n+  struct Loop {\n+    // Dimension number in A from which this loop originated. This is mostly\n+    // for debugging the plan.\n+    int dim_in_a;\n+\n+    // If true, the loop iterates over the interior of a tile.\n+    // For an untiled dimension, this is always false. For a tiled dimension,\n+    // we will have two loops: one over the tile exteriors and one over the tile\n+    // interiors.\n+    bool tile_interior;\n+\n+    // Size of the iteration space.\n+    int64_t dim_size;\n+\n+    // Size of the tiles, if this a tiled dimension.\n+    int64_t tile_size;\n+\n+    int64_t lda;  // Stride in A for this loop.\n+    int64_t ldb;  // Stride in B for this loop.\n+\n+    // Is this the innermost (stride 1) dimension in A or B? These dimensions\n+    // are special for the kernels.\n+    bool is_inner_dim_in_a;\n+    bool is_inner_dim_in_b;\n+\n+    // Number of parallel threads to use for this loop.\n+    int64_t parallelism;\n+\n+    bool operator==(const Loop& other) const;\n+  };\n+\n+  // Exposed for testing.\n+  static void RemoveTrivialLoops(std::vector<Loop>& loops);\n+  static void CoalesceLoops(std::vector<Loop>& loops);\n \n  private:\n   // Performs plan initialization that cannot fail.\n@@ -221,34 +238,7 @@ class TransposePlan {\n   bool b_is_tiled_;\n \n   // Order to traverse dimensions, from slowest-varying to fastest-varying.\n-  struct Loop {\n-    // Dimension number in A from which this loop originated. This is mostly\n-    // for debugging the plan.\n-    int dim_in_a;\n-\n-    // If true, the loop iterates over the interior of a tile.\n-    // For an untiled dimension, this is always false. For a tiled dimension,\n-    // we will have two loops: one over the tile exteriors and one over the tile\n-    // interiors.\n-    bool tile_interior;\n-\n-    // Size of the iteration space.\n-    int64_t dim_size;\n \n-    // Size of the tiles, if this a tiled dimension.\n-    int64_t tile_size;\n-\n-    int64_t lda;  // Stride in A for this loop.\n-    int64_t ldb;  // Stride in B for this loop.\n-\n-    // Is this the innermost (stride 1) dimension in A or B? These dimensions\n-    // are special for the kernels.\n-    bool is_inner_dim_in_a;\n-    bool is_inner_dim_in_b;\n-\n-    // Number of parallel threads to use for this loop.\n-    int64_t parallelism;\n-  };\n   std::vector<Loop> loop_order_;\n \n   // Root nodes of the plan, i.e., pointing to the outermost loops in the loop"
        },
        {
            "sha": "c136540eee1175f14dbf4cce5ce9a5fea4cd09ce",
            "filename": "third_party/xla/xla/pjrt/transpose_test.cc",
            "status": "modified",
            "additions": 93,
            "deletions": 72,
            "changes": 165,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9d0d22dbaa24ce6b196c70cac0490085859e9470/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9d0d22dbaa24ce6b196c70cac0490085859e9470/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftranspose_test.cc?ref=9d0d22dbaa24ce6b196c70cac0490085859e9470",
            "patch": "@@ -54,82 +54,103 @@ namespace xla {\n \n class TestTransposePlan : public TransposePlan {\n  public:\n-  using TransposePlan::CoalesceDimensions;\n-  using TransposePlan::RemoveTrivialDimensions;\n+  using Loop = TransposePlan::Loop;\n+  using TransposePlan::CoalesceLoops;\n+  using TransposePlan::RemoveTrivialLoops;\n };\n \n-TEST(TransposeTest, RemoveTrivialDimensions) {\n-  absl::InlinedVector<int64_t, 4> dims = {4, 5, 1, 3, 1, 2, 5};\n-  absl::InlinedVector<int64_t, 4> perm = {0, 2, 1, 4, 3, 6, 5};\n-  absl::InlinedVector<int64_t, 4> lda = {2, 5, 7, 100, 3, 0, 1};\n-  absl::InlinedVector<int64_t, 4> lda_tile = {1, 1, 1, 1, 1, 1, 1};\n-  absl::InlinedVector<int64_t, 4> input_tiling = {1, 1, 1, 1, 1, 1, 1};\n-  absl::InlinedVector<int64_t, 4> output_tiling = {1, 1, 1, 1, 1, 1, 1};\n-  TestTransposePlan::RemoveTrivialDimensions(dims, perm, lda, lda_tile,\n-                                             input_tiling, output_tiling);\n-  EXPECT_THAT(dims, testing::ElementsAre(4, 5, 3, 2, 5));\n-  EXPECT_THAT(perm, testing::ElementsAre(0, 1, 2, 4, 3));\n-\n-  dims = {4, 5, 3, 2, 5};\n-  perm = {4, 3, 2, 1, 0};\n-  lda = {2, 5, 100, 0, 1};\n-  lda_tile = {1, 1, 1, 1, 1};\n-  input_tiling = {1, 1, 1, 1, 1};\n-  output_tiling = {1, 1, 1, 1, 1};\n-  TestTransposePlan::RemoveTrivialDimensions(dims, perm, lda, lda_tile,\n-                                             input_tiling, output_tiling);\n-  EXPECT_THAT(dims, testing::ElementsAre(4, 5, 3, 2, 5));\n-  EXPECT_THAT(perm, testing::ElementsAre(4, 3, 2, 1, 0));\n+TEST(TransposeTest, RemoveTrivialLoops) {\n+  using Loop = TestTransposePlan::Loop;\n+  std::vector<Loop> loops;\n+  // Exterior loop, trivial (size 1)\n+  loops.push_back(Loop{/*dim_in_a=*/0, /*tile_interior=*/false, /*dim_size=*/1,\n+                       /*tile_size=*/1});\n+  // Exterior loop, trivial (dim_size == tile_size, 1 tile)\n+  loops.push_back(Loop{/*dim_in_a=*/1, /*tile_interior=*/false, /*dim_size=*/10,\n+                       /*tile_size=*/10});\n+  // Exterior loop, non-trivial\n+  loops.push_back(Loop{/*dim_in_a=*/2, /*tile_interior=*/false, /*dim_size=*/10,\n+                       /*tile_size=*/2});\n+  // Interior loop, trivial (size 1)\n+  loops.push_back(Loop{/*dim_in_a=*/3, /*tile_interior=*/true, /*dim_size=*/10,\n+                       /*tile_size=*/1});\n+  // Interior loop, non-trivial\n+  loops.push_back(Loop{/*dim_in_a=*/4, /*tile_interior=*/true, /*dim_size=*/10,\n+                       /*tile_size=*/10});\n+  // Trivial loop (size 1) but preserved because it is inner dim\n+  loops.push_back(Loop{/*dim_in_a=*/5, /*tile_interior=*/false, /*dim_size=*/1,\n+                       /*tile_size=*/1, /*lda=*/1, /*ldb=*/1,\n+                       /*is_inner_dim_in_a=*/true,\n+                       /*is_inner_dim_in_b=*/false});\n+\n+  TestTransposePlan::RemoveTrivialLoops(loops);\n+\n+  ASSERT_EQ(loops.size(), 3);\n+  // Expect loop 2 (Exterior non-trivial)\n+  EXPECT_EQ(loops[0].dim_in_a, 2);\n+  EXPECT_EQ(loops[0].tile_interior, false);\n+  // Expect loop 4 (Interior non-trivial)\n+  EXPECT_EQ(loops[1].dim_in_a, 4);\n+  EXPECT_EQ(loops[1].tile_interior, true);\n+  // Expect loop 5 (Trivial but preserved)\n+  EXPECT_EQ(loops[2].dim_in_a, 5);\n+  EXPECT_EQ(loops[2].is_inner_dim_in_a, true);\n }\n \n-TEST(TransposeTest, CoalesceDimensions) {\n-  absl::InlinedVector<int64_t, 4> dims = {4, 5, 1, 3, 1, 2, 5};\n-  absl::InlinedVector<int64_t, 4> perm = {0, 2, 1, 4, 3, 6, 5};\n-  absl::InlinedVector<int64_t, 4> lda = {50, 30, 30, 10, 10, 5, 1};\n-  absl::InlinedVector<int64_t, 4> lda_tile = {1, 1, 1, 1, 1, 1, 1};\n-  absl::InlinedVector<int64_t, 4> input_tiling = {1, 1, 1, 1, 1, 1, 1};\n-  absl::InlinedVector<int64_t, 4> output_tiling = {1, 1, 1, 1, 1, 1, 1};\n-  TestTransposePlan::CoalesceDimensions(dims, perm, lda, lda_tile, input_tiling,\n-                                        output_tiling);\n-  EXPECT_THAT(dims, testing::ElementsAre(4, 5, 1, 3, 1, 2, 5));\n-  EXPECT_THAT(perm, testing::ElementsAre(0, 2, 1, 4, 3, 6, 5));\n-  EXPECT_THAT(lda, testing::ElementsAre(50, 30, 30, 10, 10, 5, 1));\n-\n-  dims = {4, 5, 3, 2, 5};\n-  perm = {4, 1, 2, 3, 0};\n-  lda = {150, 30, 10, 5, 1};\n-  lda_tile = {1, 1, 1, 1, 1};\n-  input_tiling = {1, 1, 1, 1, 1};\n-  output_tiling = {1, 1, 1, 1, 1};\n-  TestTransposePlan::CoalesceDimensions(dims, perm, lda, lda_tile, input_tiling,\n-                                        output_tiling);\n-  EXPECT_THAT(dims, testing::ElementsAre(4, 30, 5));\n-  EXPECT_THAT(perm, testing::ElementsAre(2, 1, 0));\n-  EXPECT_THAT(lda, testing::ElementsAre(150, 5, 1));\n-\n-  dims = {4, 5, 3, 2, 5};\n-  perm = {0, 1, 2, 3, 4};\n-  lda = {150, 30, 10, 5, 1};\n-  lda_tile = {1, 1, 1, 1, 1};\n-  input_tiling = {1, 1, 1, 1, 1};\n-  output_tiling = {1, 1, 1, 1, 1};\n-  TestTransposePlan::CoalesceDimensions(dims, perm, lda, lda_tile, input_tiling,\n-                                        output_tiling);\n-  EXPECT_THAT(dims, testing::ElementsAre(600));\n-  EXPECT_THAT(perm, testing::ElementsAre(0));\n-  EXPECT_THAT(lda, testing::ElementsAre(1));\n-\n-  dims = {4, 5, 3, 2, 5};\n-  perm = {4, 1, 2, 3, 0};\n-  lda = {150, 30, 10, 7, 1};  // Non-standard stridings prevent coalescing.\n-  lda_tile = {1, 1, 1, 1, 1};\n-  input_tiling = {1, 1, 1, 1, 1};\n-  output_tiling = {1, 1, 1, 1, 1};\n-  TestTransposePlan::CoalesceDimensions(dims, perm, lda, lda_tile, input_tiling,\n-                                        output_tiling);\n-  EXPECT_THAT(dims, testing::ElementsAre(4, 15, 2, 5));\n-  EXPECT_THAT(perm, testing::ElementsAre(3, 1, 2, 0));\n-  EXPECT_THAT(lda, testing::ElementsAre(150, 10, 7, 1));\n+TEST(TransposeTest, CoalesceLoops) {\n+  using Loop = TestTransposePlan::Loop;\n+  std::vector<Loop> loops;\n+\n+  // Case 1: Compatible untiled loops\n+  // Outer: size 4, stride 20 (inner size 5 * inner stride 4)\n+  loops.push_back(Loop{/*dim_in_a=*/0, /*tile_interior=*/false, /*dim_size=*/4,\n+                       /*tile_size=*/1, /*lda=*/20, /*ldb=*/400});\n+  // Inner: size 5, stride 4\n+  loops.push_back(Loop{/*dim_in_a=*/1, /*tile_interior=*/false, /*dim_size=*/5,\n+                       /*tile_size=*/1, /*lda=*/4, /*ldb=*/80});\n+\n+  TestTransposePlan::CoalesceLoops(loops);\n+\n+  ASSERT_EQ(loops.size(), 1);\n+  EXPECT_EQ(loops[0].dim_size, 20);\n+  EXPECT_EQ(loops[0].tile_size, 1);\n+  EXPECT_EQ(loops[0].lda, 4);\n+  EXPECT_EQ(loops[0].ldb, 80);\n+\n+  // Case 2: Incompatible strides\n+  loops.clear();\n+  loops.push_back(Loop{/*dim_in_a=*/0, /*tile_interior=*/false, /*dim_size=*/4,\n+                       /*tile_size=*/1, /*lda=*/21,\n+                       /*ldb=*/400});  // lda mismatch\n+  loops.push_back(Loop{/*dim_in_a=*/1, /*tile_interior=*/false, /*dim_size=*/5,\n+                       /*tile_size=*/1, /*lda=*/4, /*ldb=*/80});\n+\n+  TestTransposePlan::CoalesceLoops(loops);\n+  EXPECT_EQ(loops.size(), 2);\n+\n+  // Case 3: Compatible tiled interior\n+  loops.clear();\n+  // Outer interior: tile_size 4, lda 16\n+  loops.push_back(Loop{/*dim_in_a=*/0, /*tile_interior=*/true, /*dim_size=*/100,\n+                       /*tile_size=*/4, /*lda=*/16, /*ldb=*/320});\n+  // Inner interior: tile_size 4, lda 4\n+  loops.push_back(Loop{/*dim_in_a=*/1, /*tile_interior=*/true, /*dim_size=*/100,\n+                       /*tile_size=*/4, /*lda=*/4, /*ldb=*/80});\n+\n+  TestTransposePlan::CoalesceLoops(loops);\n+  ASSERT_EQ(loops.size(), 1);\n+  EXPECT_EQ(loops[0].tile_size, 16);\n+  EXPECT_EQ(loops[0].tile_interior, true);\n+\n+  // Case 4: Mismatched tile_interior status (should not coalesce)\n+  loops.clear();\n+  loops.push_back(Loop{/*dim_in_a=*/0, /*tile_interior=*/false, /*dim_size=*/4,\n+                       /*tile_size=*/1, /*lda=*/20, /*ldb=*/400});\n+  loops.push_back(Loop{/*dim_in_a=*/1, /*tile_interior=*/true, /*dim_size=*/5,\n+                       /*tile_size=*/5, /*lda=*/4, /*ldb=*/80});\n+\n+  TestTransposePlan::CoalesceLoops(loops);\n+  EXPECT_EQ(loops.size(), 2);\n }\n \n TEST(TransposeTest, InvalidTilings) {"
        }
    ],
    "stats": {
        "total": 453,
        "additions": 214,
        "deletions": 239
    }
}