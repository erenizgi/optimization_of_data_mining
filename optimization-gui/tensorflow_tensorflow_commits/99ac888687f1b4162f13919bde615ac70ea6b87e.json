{
    "author": "sachinmuradi",
    "message": "PR #31003: [XLA::CPU][OneDnn]Async threadpool for onednn_fusion_thunk\n\nImported from GitHub PR https://github.com/openxla/xla/pull/31003\n\nThis PR updates the [OneDnnthreadpool ](https://github.com/openxla/xla/blob/09bb90bed5d0c036e1cdc67a6b4706016e7c8adc/xla/backends/cpu/runtime/onednn/onednn_fusion_thunk.cc#L68)used for creating OneDnnRuntime object inside onednn_fusion_thunk, to use threadpool with asynchronous execution.\nThis results in improved the performance for onednn_fusion_thunks .\n\nCopybara import of the project:\n\n--\nd12b257d267fa42fa139fac5accc253c8d55b40f by Sachin Muradi <sachin.muradi@intel.com>:\n\nasync threadpool for onednn_fusion_thunk\n\n--\nf40c2d92c2b659926aa9297260f6ebd7aa5d0782 by Sachin Muradi <sachin.muradi@intel.com>:\n\naddress review comments\n\nMerging this change closes #31003\n\nPiperOrigin-RevId: 807337748",
    "sha": "99ac888687f1b4162f13919bde615ac70ea6b87e",
    "files": [
        {
            "sha": "bfb6edad655847ee7886b157b60788ae667a0cc5",
            "filename": "third_party/xla/xla/backends/cpu/runtime/onednn/onednn_fusion_thunk.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/99ac888687f1b4162f13919bde615ac70ea6b87e/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fonednn%2Fonednn_fusion_thunk.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/99ac888687f1b4162f13919bde615ac70ea6b87e/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fonednn%2Fonednn_fusion_thunk.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fonednn%2Fonednn_fusion_thunk.cc?ref=99ac888687f1b4162f13919bde615ac70ea6b87e",
            "patch": "@@ -49,9 +49,10 @@ struct OneDnnFusionThunk::OneDnnRuntime {\n   OneDnnRuntime(OneDnnRuntime&&) = default;\n   OneDnnRuntime& operator=(OneDnnRuntime&&) = default;\n \n-  absl::Status Invoke(Eigen::ThreadPoolInterface* thread_pool,\n-                      absl::Span<se::DeviceMemoryBase> arguments,\n-                      absl::Span<se::DeviceMemoryBase> results);\n+  tsl::AsyncValueRef<OneDnnFusionThunk::ExecuteEvent> Invoke(\n+      Eigen::ThreadPoolInterface* thread_pool,\n+      absl::Span<se::DeviceMemoryBase> arguments,\n+      absl::Span<se::DeviceMemoryBase> results);\n \n   OneDnnFusion fusion;\n \n@@ -65,11 +66,13 @@ struct OneDnnFusionThunk::OneDnnRuntime {\n OneDnnFusionThunk::OneDnnRuntime::OneDnnRuntime(\n     OneDnnFusion fusion, Eigen::ThreadPoolInterface* thread_pool)\n     : fusion(std::move(fusion)),\n-      threadpool(std::make_unique<OneDnnThreadPool>(thread_pool)),\n+      threadpool(\n+          std::make_unique<OneDnnThreadPool>(thread_pool, /*is_async=*/true)),\n       engine(dnnl::engine::kind::cpu, 0),\n       stream(dnnl::threadpool_interop::make_stream(engine, threadpool.get())) {}\n \n-absl::Status OneDnnFusionThunk::OneDnnRuntime::Invoke(\n+tsl::AsyncValueRef<OneDnnFusionThunk::ExecuteEvent>\n+OneDnnFusionThunk::OneDnnRuntime::Invoke(\n     Eigen::ThreadPoolInterface* thread_pool,\n     absl::Span<se::DeviceMemoryBase> arguments,\n     absl::Span<se::DeviceMemoryBase> results) {\n@@ -103,7 +106,7 @@ absl::Status OneDnnFusionThunk::OneDnnRuntime::Invoke(\n     partition.execute(stream, argument_data, result_data);\n   }\n \n-  return absl::OkStatus();\n+  return threadpool->done_event();\n }\n \n absl::StatusOr<OneDnnFusionThunk::OneDnnRuntime>\n@@ -208,11 +211,13 @@ tsl::AsyncValueRef<OneDnnFusionThunk::ExecuteEvent> OneDnnFusionThunk::Execute(\n   // Borrow oneDNN runtime from the pool.\n   TF_ASSIGN_OR_RETURN(auto runtime,\n                       onednn_runtime_pool_.GetOrCreate(thread_pool));\n-  TF_RETURN_IF_ERROR(runtime->Invoke(thread_pool,\n-                                     absl::MakeSpan(arguments_buffers),\n-                                     absl::MakeSpan(results_buffers)));\n+  auto executed =\n+      runtime->Invoke(thread_pool, absl::MakeSpan(arguments_buffers),\n+                      absl::MakeSpan(results_buffers));\n+  // Destroy the runtime after the task is done.\n+  executed.AndThen([runtime = std::move(runtime)] {});\n \n-  return OkExecuteEvent();\n+  return executed;\n }\n \n }  // namespace xla::cpu"
        }
    ],
    "stats": {
        "total": 25,
        "additions": 15,
        "deletions": 10
    }
}