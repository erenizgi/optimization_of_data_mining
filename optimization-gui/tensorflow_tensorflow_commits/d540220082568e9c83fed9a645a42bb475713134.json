{
    "author": "tensorflower-gardener",
    "message": "[XLA:GPU] run the deadlocks verifier algorithm recursively\n\nPiperOrigin-RevId: 799871945",
    "sha": "d540220082568e9c83fed9a645a42bb475713134",
    "files": [
        {
            "sha": "327d19329c240586a526cd1e20628722145710fb",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -5286,6 +5286,7 @@ xla_cc_test(\n         \":computation_placer\",\n         \":global_device_id\",\n         \":hlo_module_config\",\n+        \":source_target_pairs\",\n         \"//xla:array2d\",\n         \"//xla:literal_util\",\n         \"//xla:shape_util\","
        },
        {
            "sha": "c43dfb019499b198e0bb24540eee295a360c6ff0",
            "filename": "third_party/xla/xla/service/collective_ops_utils.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.cc?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -42,6 +42,7 @@ limitations under the License.\n #include \"xla/service/computation_placer.h\"\n #include \"xla/service/global_device_id.h\"\n #include \"xla/service/pattern_matcher.h\"\n+#include \"xla/service/source_target_pairs.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/status_macros.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -872,4 +873,17 @@ bool IsExclusivelyCrossReplica(absl::Span<const ReplicaGroup> replica_groups,\n   }\n   return true;\n }\n+\n+bool HasDuplicateSourcesOrTargets(const SourceTargetPairs& pairs) {\n+  std::set<int> sources;\n+  std::set<int> targets;\n+  for (int i = 0; i < pairs.size(); ++i) {\n+    sources.insert(pairs[i].source);\n+    targets.insert(pairs[i].target);\n+  }\n+  if (sources.size() != pairs.size() || targets.size() != pairs.size()) {\n+    return true;\n+  }\n+  return false;\n+}\n }  // end namespace xla"
        },
        {
            "sha": "549d4159216db1210c1fccd8f3eecb0dd2145199",
            "filename": "third_party/xla/xla/service/collective_ops_utils.h",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.h?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -201,6 +201,8 @@ bool IsExclusivelyCrossReplica(absl::Span<const ReplicaGroup> replica_groups,\n                                bool use_global_ids, bool has_channel_id,\n                                const DeviceAssignment& device_assignment);\n \n+bool HasDuplicateSourcesOrTargets(const SourceTargetPairs& pairs);\n+\n // A custom call target that can be used to create a nop that can legally\n // replace a collective op.\n inline constexpr absl::string_view kNopCustomCallTarget = \"AllocateBuffer\";\n@@ -309,9 +311,6 @@ inline bool MayPipelineSendRecvChannel(int64_t channel_id) {\n   return channel_id > 0;\n }\n \n-constexpr char kSendRecvSourceTargetPairsAttr[] =\n-    \"_xla_send_recv_source_target_pairs\";\n-\n // When a Send or Recv is annotated with frontend attribute\n // _xla_send_recv_pipeline=\"1\", asynchronous stream kP2P1 is used to execute the\n // Send or Recv. For all other cases, asynchronous stream kP2P0 is used."
        },
        {
            "sha": "a081f724b214fb148b9eefa658722adf03889374",
            "filename": "third_party/xla/xla/service/collective_ops_utils_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils_test.cc?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -42,6 +42,7 @@ limitations under the License.\n #include \"xla/service/computation_placer.h\"\n #include \"xla/service/global_device_id.h\"\n #include \"xla/service/hlo_module_config.h\"\n+#include \"xla/service/source_target_pairs.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n@@ -511,6 +512,25 @@ TEST(IsExclusivelyCrossReplicaTest, CrossModuleWithGlobalIds) {\n       IsExclusivelyCrossReplica(replica_groups, /*use_global_ids=*/true,\n                                 /*has_channel_id=*/true, device_assignment));\n }\n+\n+TEST(HasDuplicateSourcesOrTargetsTest, NoDuplicates) {\n+  SourceTargetPairs pairs =\n+      SourceTargetPairs::FromString(\"{{0, 1}, {2, 3}, {4, 5}}\").value();\n+  EXPECT_FALSE(HasDuplicateSourcesOrTargets(pairs));\n+}\n+\n+TEST(HasDuplicateSourcesOrTargetsTest, DuplicateSources) {\n+  SourceTargetPairs pairs =\n+      SourceTargetPairs::FromString(\"{{0, 1}, {0, 3}, {4, 5}}\").value();\n+  EXPECT_TRUE(HasDuplicateSourcesOrTargets(pairs));\n+}\n+\n+TEST(HasDuplicateSourcesOrTargetsTest, DuplicateTargets) {\n+  SourceTargetPairs pairs =\n+      SourceTargetPairs::FromString(\"{{0, 1}, {2, 1}, {4, 5}}\").value();\n+  EXPECT_TRUE(HasDuplicateSourcesOrTargets(pairs));\n+}\n+\n }  // namespace\n \n // Tests for GetCollectOpGroupMode"
        },
        {
            "sha": "c4125d67deb57a72c2855f2095773e63a014b604",
            "filename": "third_party/xla/xla/service/hlo_verifier.cc",
            "status": "modified",
            "additions": 255,
            "deletions": 128,
            "changes": 383,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -24,7 +24,6 @@ limitations under the License.\n #include <memory>\n #include <numeric>\n #include <optional>\n-#include <set>\n #include <string>\n #include <utility>\n #include <vector>\n@@ -2538,174 +2537,302 @@ absl::Status VerifyAsynchronousInstructionPairs(const HloModule& module) {\n   return absl::OkStatus();\n }\n \n-// Helper function to match source-target pairs for a pair of send/recv\n-// instructions.\n-absl::Status VerifySourceTargetPairs(const HloInstruction* first,\n-                                     const HloInstruction* second) {\n-  if (first == nullptr || second == nullptr) {\n-    return Internal(\"Expected send or recv instruction to be non-null\");\n-  }\n-  auto send_source_target_pairs =\n-      first->frontend_attributes().map().find(kSendRecvSourceTargetPairsAttr);\n-  auto recv_source_target_pairs =\n-      second->frontend_attributes().map().find(kSendRecvSourceTargetPairsAttr);\n-  // Source-target pairs should be set or unset for both send and recv.\n-  if ((send_source_target_pairs == first->frontend_attributes().map().end()) !=\n-      (recv_source_target_pairs == second->frontend_attributes().map().end())) {\n-    return Internal(\n-        \"Expected both send and recv instruction to have source-target pairs \"\n-        \"set, but found %s and %s\",\n-        first->ToString(), second->ToString());\n-  }\n+enum class DfaState { kNoExpectation, kExpectSend, kExpectRecv };\n \n-  // Skip checks if source-target pairs are unset for both send and recv\n-  if (send_source_target_pairs == first->frontend_attributes().map().end()) {\n-    return absl::OkStatus();\n-  }\n-\n-  if (send_source_target_pairs->second != recv_source_target_pairs->second) {\n-    return Internal(\n-        \"Expected send and recv instructions to have the same source-target \"\n-        \"pairs, but found %s and %s\",\n-        first->ToString(), second->ToString());\n-  }\n-\n-  TF_ASSIGN_OR_RETURN(\n-      SourceTargetPairs send_source_target_pairs_array,\n-      SourceTargetPairs::FromString(send_source_target_pairs->second));\n-  if (collective_permute_cycle::HasCycles(send_source_target_pairs_array)) {\n+// Checks that the send/recv instructions in the module do not deadlock. This is\n+// only done on scheduled modules and is specific to device-to-device\n+// communications on GPU. At a high level, we want to check that:\n+// 1. no collectives are scheduled between a matching pair of send and recv\n+// 2. no two send instructions are scheduled in a row\n+// 3. no two recv instructions are scheduled in a row\n+// 4. the program does not terminate with a dangling send or recv\n+absl::Status VerifyNoConflictingSourceTargetPairs(\n+    const HloInstruction* instruction, SourceTargetPairs source_target_pairs) {\n+  // Check for cycles\n+  if (collective_permute_cycle::HasCycles(source_target_pairs)) {\n     return Internal(\n         \"Expected send and recv instructions to have non-cyclical \"\n         \"source-target pairs, but found %s\",\n-        first->ToString());\n-  }\n-  std::set<int> sources;\n-  std::set<int> targets;\n-  for (int i = 0; i < send_source_target_pairs_array.size(); ++i) {\n-    sources.insert(send_source_target_pairs_array[i].source);\n-    targets.insert(send_source_target_pairs_array[i].target);\n+        instruction->ToString());\n   }\n-  if (sources.size() != send_source_target_pairs_array.size() ||\n-      targets.size() != send_source_target_pairs_array.size()) {\n+  // Check for duplicate sources and targets\n+  if (HasDuplicateSourcesOrTargets(source_target_pairs)) {\n     return Internal(\n         \"Expected send and recv instructions to have unique source and target \"\n         \"pairs, but found %s\",\n-        first->ToString());\n+        instruction->ToString());\n   }\n-\n   return absl::OkStatus();\n }\n \n-enum class DfaState { kNoException, kExpectSend, kExpectRecv };\n+// Checks that the given instruction\n+// (1) does not contain a cycle\n+// (2) does not form a cycle with any of the instructions in the provided set\n+// (3) does not have duplicate sources or targets\n+// (4) does not contain duplicate sources or targets with any of the\n+//     instructions in the provided set\n+// If all 4 checks pass, insert the instruction into the provided set of\n+// instructions\n+template <typename T>\n+absl::Status VerifyNoConflictingSendOrRecv(\n+    const T* instruction, absl::flat_hash_set<const T*>& instructions) {\n+  TF_ASSIGN_OR_RETURN(SourceTargetPairs source_target_pairs_array,\n+                      SourceTargetPairs::FromInstruction(instruction));\n+  for (const T* existing_instruction : instructions) {\n+    TF_ASSIGN_OR_RETURN(\n+        SourceTargetPairs existing_source_target_pairs_array,\n+        SourceTargetPairs::FromInstruction(existing_instruction));\n+    TF_RETURN_IF_ERROR(VerifyNoConflictingSourceTargetPairs(\n+        existing_instruction,\n+        SourceTargetPairs::Join(source_target_pairs_array,\n+                                existing_source_target_pairs_array)));\n+  }\n+  instructions.insert(instruction);\n+  return absl::OkStatus();\n+}\n \n-// Helper function to handle the state transitions for a Send instruction.\n-absl::Status HandleSendInstruction(const HloInstruction* instruction,\n-                                   DfaState& current_state,\n-                                   const HloInstruction*& current_instruction) {\n-  if (DynCast<HloSendInstruction>(instruction)->is_host_transfer()) {\n+template <typename T>\n+absl::StatusOr<bool> ShouldSkipDeadlockCheck(const T* instruction) {\n+  if (instruction->is_host_transfer()) {\n+    return true;\n+  }\n+  // TODO: b/441038687 - Remove kSendRecvValidationAttr\n+  // TODO: b/441088186 - update static analyzer logic to also handle\n+  // instructions annotated with _xla_send_recv_pipeline\n+  // For now we will skip checks for instructions annotated with\n+  // _xla_send_recv_pipeline and _xla_send_recv_validation, since they introduce\n+  // extra constraints that have not been modeled by this function.\n+  if (instruction->frontend_attributes().map().contains(\n+          kSendRecvPipelineAttr) ||\n+      instruction->frontend_attributes().map().contains(\n+          kSendRecvValidationAttr)) {\n+    return true;\n+  }\n+  // Check that the instruction itself does not have conflicting\n+  // source-target pairs.\n+  TF_ASSIGN_OR_RETURN(SourceTargetPairs source_target_pairs_array,\n+                      SourceTargetPairs::FromInstruction(instruction));\n+  TF_RETURN_IF_ERROR(VerifyNoConflictingSourceTargetPairs(\n+      instruction, source_target_pairs_array));\n+  return false;\n+}\n+\n+// Finds a matching instruction (Send or Recv) for the given instruction in the\n+// provided set of candidates. Matching is based on the\n+// kSendRecvSourceTargetPairsAttr.\n+template <typename T, typename U>\n+const U* FindMatchingInstruction(\n+    const T* instruction, const absl::flat_hash_set<const U*>& candidates) {\n+  auto it = instruction->frontend_attributes().map().find(\n+      kSendRecvSourceTargetPairsAttr);\n+  if (it == instruction->frontend_attributes().map().end()) {\n+    return nullptr;  // Should not happen based on checks in caller\n+  }\n+  const std::string& source_target_pairs = it->second;\n+\n+  for (const U* candidate : candidates) {\n+    auto candidate_it = candidate->frontend_attributes().map().find(\n+        kSendRecvSourceTargetPairsAttr);\n+    if (candidate_it != candidate->frontend_attributes().map().end() &&\n+        candidate_it->second == source_target_pairs) {\n+      return candidate;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+absl::Status CheckDeadlocksForSend(\n+    const HloSendInstruction* send, DfaState& current_state,\n+    absl::flat_hash_set<const HloSendInstruction*>& pending_send_instructions,\n+    absl::flat_hash_set<const HloRecvInstruction*>& pending_recv_instructions) {\n+  TF_ASSIGN_OR_RETURN(bool skip, ShouldSkipDeadlockCheck(send));\n+  if (skip) {\n     return absl::OkStatus();\n   }\n   switch (current_state) {\n-    case DfaState::kNoException:\n-      current_instruction = instruction;\n+    case DfaState::kNoExpectation:\n+      pending_send_instructions.insert(send);\n       current_state = DfaState::kExpectRecv;\n       break;\n-    case DfaState::kExpectSend:\n-      TF_RETURN_IF_ERROR(\n-          VerifySourceTargetPairs(current_instruction, instruction));\n-      current_state = DfaState::kNoException;\n-      current_instruction = nullptr;\n-      break;\n     case DfaState::kExpectRecv:\n-      return Internal(\"Expected recv to match send, but found %s\",\n-                      instruction->ToString());\n-    default:\n+      if (!VerifyNoConflictingSendOrRecv(send, pending_send_instructions)\n+               .ok()) {\n+        return Internal(\"Expected recv, but found %s\", send->ToString());\n+      }\n+      break;\n+    case DfaState::kExpectSend:\n+      const HloRecvInstruction* recv =\n+          FindMatchingInstruction(send, pending_recv_instructions);\n+      if (recv != nullptr) {\n+        pending_recv_instructions.erase(recv);\n+        if (pending_recv_instructions.empty()) {\n+          current_state = DfaState::kNoExpectation;\n+        }\n+      } else {\n+        // We couldn't find a matching recv instruction, so we will put this\n+        // send in the set of unmatched send instructions.\n+        pending_send_instructions.insert(send);\n+      }\n       break;\n   }\n   return absl::OkStatus();\n }\n \n-// Helper function to handle the state transitions for a Recv instruction.\n-absl::Status HandleRecvInstruction(const HloInstruction* instruction,\n-                                   DfaState& current_state,\n-                                   const HloInstruction*& current_instruction) {\n-  if (DynCast<HloRecvInstruction>(instruction)->is_host_transfer()) {\n+absl::Status CheckDeadlocksForRecv(\n+    const HloRecvInstruction* recv, DfaState& current_state,\n+    absl::flat_hash_set<const HloSendInstruction*>& send_instructions,\n+    absl::flat_hash_set<const HloRecvInstruction*>& recv_instructions) {\n+  TF_ASSIGN_OR_RETURN(bool skip, ShouldSkipDeadlockCheck(recv));\n+  if (skip) {\n     return absl::OkStatus();\n   }\n   switch (current_state) {\n-    case DfaState::kNoException:\n-      current_instruction = instruction;\n+    case DfaState::kNoExpectation:\n+      recv_instructions.insert(recv);\n       current_state = DfaState::kExpectSend;\n       break;\n     case DfaState::kExpectSend:\n-      return Internal(\"Expected send to match recv, but found %s\",\n-                      instruction->ToString());\n+      if (!VerifyNoConflictingSendOrRecv(recv, recv_instructions).ok()) {\n+        return Internal(\"Expected send, but found %s\", recv->ToString());\n+      }\n+      break;\n     case DfaState::kExpectRecv:\n-      TF_RETURN_IF_ERROR(\n-          VerifySourceTargetPairs(current_instruction, instruction));\n-      current_state = DfaState::kNoException;\n-      current_instruction = nullptr;\n+      const HloSendInstruction* send =\n+          FindMatchingInstruction(recv, send_instructions);\n+      if (send != nullptr) {\n+        send_instructions.erase(send);\n+        if (send_instructions.empty()) {\n+          current_state = DfaState::kNoExpectation;\n+        }\n+      } else {\n+        // We couldn't find a matching send instruction, so we will put this\n+        // recv in the set of unmatched recv instructions.\n+        recv_instructions.insert(recv);\n+      }\n       break;\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status CheckDeadlocksForOtherCollectives(\n+    const HloInstruction* instruction, DfaState& current_state,\n+    absl::flat_hash_set<const HloSendInstruction*>& send_instructions,\n+    absl::flat_hash_set<const HloRecvInstruction*>& recv_instructions) {\n+  switch (current_state) {\n+    case DfaState::kExpectSend:\n+    case DfaState::kExpectRecv:\n+      // We have some left-over unmatched send or recv instructions.\n+      if (!send_instructions.empty() || !recv_instructions.empty()) {\n+        return Internal(\n+            \"Expected send and recv instructions to have the same \"\n+            \"source-target pairs, but could not match some \"\n+            \"instructions. Introducing the following instruction will \"\n+            \"cause a deadlock:\\n%s\",\n+            instruction->ToString());\n+      }\n+      return Internal(\"Expected send or recv, but found %s\",\n+                      instruction->ToString());\n     default:\n       break;\n   }\n   return absl::OkStatus();\n }\n \n-// Checks that the send/recv instructions in the module do not deadlock. This is\n-// only done on scheduled modules and is specific to device-to-device\n-// communications on GPU. At a high level, we want to check that:\n-// 1. no collectives are scheduled between a matching pair of send and recv\n-// 2. no two send instructions are scheduled in a row\n-// 3. no two recv instructions are scheduled in a row\n-// 4. the program does not terminate with a dangling send or recv\n-absl::Status VerifyNoCollectiveDeadlocks(const HloModule& module) {\n-  DfaState current_state = DfaState::kNoException;\n-  const HloInstruction* current_instruction = nullptr;\n-  // TODO: b/434020459 - start the static verification in ENTRY and run the\n-  // function recursively instead of iterating through all computations\n-  // serially\n-\n-  for (auto& [computation_id, sequence] : module.schedule().sequences()) {\n-    for (const HloInstruction* instruction : sequence.instructions()) {\n-      switch (instruction->opcode()) {\n-        case HloOpcode::kSend:\n-          TF_RETURN_IF_ERROR(HandleSendInstruction(instruction, current_state,\n-                                                   current_instruction));\n-          break;\n-        case HloOpcode::kRecv:\n-          TF_RETURN_IF_ERROR(HandleRecvInstruction(instruction, current_state,\n-                                                   current_instruction));\n-          break;\n-        case HloOpcode::kAllGather:\n-        case HloOpcode::kAllReduce:\n-        case HloOpcode::kAllToAll:\n-        case HloOpcode::kRaggedAllToAll:\n-        case HloOpcode::kCollectivePermute:\n-        case HloOpcode::kReduceScatter:\n-        case HloOpcode::kCollectiveBroadcast:\n-          switch (current_state) {\n-            case DfaState::kExpectSend:\n-            case DfaState::kExpectRecv:\n-              return Internal(\"Expected send or recv, but found %s\",\n-                              instruction->ToString());\n-            default:\n-              break;\n-          }\n-          break;\n-        default:\n-          break;\n+bool IsOtherCollective(const HloInstruction* instruction) {\n+  switch (instruction->opcode()) {\n+    case HloOpcode::kAllGather:\n+    case HloOpcode::kAllReduce:\n+    case HloOpcode::kAllToAll:\n+    case HloOpcode::kRaggedAllToAll:\n+    case HloOpcode::kCollectivePermute:\n+    case HloOpcode::kReduceScatter:\n+    case HloOpcode::kCollectiveBroadcast:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+absl::Status VerifyNoCollectiveDeadlocksRecursive(\n+    const HloComputation* computation, DfaState& current_state,\n+    absl::flat_hash_set<const HloSendInstruction*>& send_instructions,\n+    absl::flat_hash_set<const HloRecvInstruction*>& recv_instructions) {\n+  for (const HloInstruction* instruction : computation->instructions()) {\n+    if (instruction->called_computations().empty()) {\n+      if (instruction->opcode() == HloOpcode::kSend) {\n+        TF_RETURN_IF_ERROR(CheckDeadlocksForSend(\n+            DynCast<HloSendInstruction>(instruction), current_state,\n+            send_instructions, recv_instructions));\n+      } else if (instruction->opcode() == HloOpcode::kRecv) {\n+        TF_RETURN_IF_ERROR(CheckDeadlocksForRecv(\n+            DynCast<HloRecvInstruction>(instruction), current_state,\n+            send_instructions, recv_instructions));\n+      } else if (IsOtherCollective(instruction)) {\n+        TF_RETURN_IF_ERROR(CheckDeadlocksForOtherCollectives(\n+            instruction, current_state, send_instructions, recv_instructions));\n+      } else {\n+        continue;\n+      }\n+    } else {\n+      for (const HloComputation* computation :\n+           instruction->called_computations()) {\n+        TF_RETURN_IF_ERROR(VerifyNoCollectiveDeadlocksRecursive(\n+            computation, current_state, send_instructions, recv_instructions));\n       }\n     }\n   }\n-  return current_state == DfaState::kNoException\n-             ? absl::OkStatus()\n-             : Internal(\n-                   \"Program terminated with dangling send or recv. Last \"\n-                   \"checked instruction: %s\",\n-                   current_instruction == nullptr\n-                       ? \"\"\n-                       : current_instruction->ToString());\n+  return absl::OkStatus();\n+}\n+\n+absl::Status CheckPendingSendRecvDeadlocks(\n+    absl::flat_hash_set<const HloSendInstruction*>& send_instructions,\n+    absl::flat_hash_set<const HloRecvInstruction*>& recv_instructions) {\n+  if (recv_instructions.empty() && !send_instructions.empty()) {\n+    return Internal(\"Expected recv to match send\");\n+  }\n+  if (send_instructions.empty() && !recv_instructions.empty()) {\n+    return Internal(\"Expected send to match recv\");\n+  }\n+  std::string last_checked_instructions = \"\";\n+  for (const HloSendInstruction* send_instruction : send_instructions) {\n+    const HloRecvInstruction* recv_instruction =\n+        FindMatchingInstruction(send_instruction, recv_instructions);\n+    if (recv_instruction != nullptr) {\n+      recv_instructions.erase(recv_instruction);\n+    } else {\n+      absl::StrAppend(&last_checked_instructions, send_instruction->ToString(),\n+                      \",\");\n+    }\n+  }\n+  for (const HloRecvInstruction* recv_instruction : recv_instructions) {\n+    const HloSendInstruction* send_instruction =\n+        FindMatchingInstruction(recv_instruction, send_instructions);\n+    if (send_instruction != nullptr) {\n+      send_instructions.erase(send_instruction);\n+    } else {\n+      absl::StrAppend(&last_checked_instructions, recv_instruction->ToString(),\n+                      \",\");\n+    }\n+  }\n+  if (!last_checked_instructions.empty()) {\n+    return Internal(\"Deadlock detected. Last checked instructions: %s\",\n+                    last_checked_instructions);\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::Status VerifyNoCollectiveDeadlocks(const HloModule& module) {\n+  DfaState current_state = DfaState::kNoExpectation;\n+  absl::flat_hash_set<const HloSendInstruction*> send_instructions;\n+  absl::flat_hash_set<const HloRecvInstruction*> recv_instructions;\n+  TF_RETURN_IF_ERROR(VerifyNoCollectiveDeadlocksRecursive(\n+      module.entry_computation(), current_state, send_instructions,\n+      recv_instructions));\n+  if (current_state != DfaState::kNoExpectation) {\n+    TF_RETURN_IF_ERROR(\n+        CheckPendingSendRecvDeadlocks(send_instructions, recv_instructions));\n+  }\n+  return absl::OkStatus();\n }\n \n // Checks that the asynchronous computation only has a root and parameter"
        },
        {
            "sha": "4b6f3501b8d646c65776fe8f9ad4f613997ede8e",
            "filename": "third_party/xla/xla/service/hlo_verifier_test.cc",
            "status": "modified",
            "additions": 126,
            "deletions": 14,
            "changes": 140,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -4325,9 +4325,11 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks, VerifySendRecvDeadlockOnRecv) {\n \n   ENTRY test_computation {\n     after_all = token[] after-all()\n-    recv1 = (f32[], u32[], token[]) recv(after_all), channel_id=1\n+    recv1 = (f32[], u32[], token[]) recv(after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{3,0}}\"}\n     recv1-done = (f32[], token[]) recv-done(recv1), channel_id=1\n-    recv2 = (f32[], u32[], token[]) recv(after_all), channel_id=2\n+    recv2 = (f32[], u32[], token[]) recv(after_all), channel_id=2, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{0,1}}\"}\n     ROOT recv2-done = (f32[], token[]) recv-done(recv2), channel_id=2\n   })\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n@@ -4344,9 +4346,11 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks, VerifySendRecvDeadlockOnSend) {\n   ENTRY test_computation {\n     c0 = f32[] constant(0)\n     after_all = token[] after-all()\n-    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1\n+    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{3,0}}\"}\n     send1-done = token[] send-done(send1), channel_id=1\n-    send2 = (f32[], u32[], token[]) send(c0, after_all), channel_id=2\n+    send2 = (f32[], u32[], token[]) send(c0, after_all), channel_id=2, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{0,1}}\"}\n     ROOT send2-done = token[] send-done(send2), channel_id=2\n   })\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n@@ -4364,17 +4368,21 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks,\n   ENTRY test_computation {\n     c0 = f32[] constant(0)\n     after_all = token[] after-all()\n-    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1\n+    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{3,0}}\"}\n     send1-done = token[] send-done(send1), channel_id=1\n     p0 = f32[10] parameter(0)\n     p1 = bf16[10] parameter(1)\n     ROOT ag = (f32[20], bf16[20]) all-gather(p0, p1), dimensions={0}\n   })\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n                           ParseAndReturnUnverifiedModule(hlo));\n-  EXPECT_THAT(verifier().Run(module.get()),\n-              StatusIs(absl::StatusCode::kInternal,\n-                       HasSubstr(\"Expected send or recv\")));\n+  EXPECT_THAT(\n+      verifier().Run(module.get()),\n+      StatusIs(\n+          absl::StatusCode::kInternal,\n+          HasSubstr(\n+              \"Introducing the following instruction will cause a deadlock\")));\n }\n \n TEST_F(HloVerifierTestForCollectiveDeadlocks,\n@@ -4385,7 +4393,8 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks,\n   while_body {\n     c0 = f32[] constant(0)\n     after_all = token[] after-all()\n-    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1\n+    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{3,0}}\"}\n     send1-done = token[] send-done(send1), channel_id=1\n     params = (f32[10], bf16[10]) parameter(0)\n     p0 = f32[10] get-tuple-element(params), index=0\n@@ -4406,7 +4415,8 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks,\n \n   ENTRY test_computation {\n     after_all = token[] after-all()\n-    recv = (f32[], u32[], token[]) recv(after_all), channel_id=1\n+    recv = (f32[], u32[], token[]) recv(after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{0,1},{1,2},{2,3}}\"}\n     recv_done = (f32[], token[]) recv-done(recv), channel_id=1\n     p0 = f32[10] parameter(0)\n     p1 = bf16[10] parameter(1)\n@@ -4420,10 +4430,13 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks,\n \n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n                           ParseAndReturnUnverifiedModule(hlo));\n-  EXPECT_THAT(verifier().Run(module.get()),\n-              StatusIs(absl::StatusCode::kInternal,\n-                       AnyOf(HasSubstr(\"Expected send or recv\"),\n-                             HasSubstr(\"Expected send to match recv\"))));\n+  EXPECT_THAT(\n+      verifier().Run(module.get()),\n+      StatusIs(\n+          absl::StatusCode::kInternal,\n+          HasSubstr(\n+              \"Expected send and recv instructions to have the same \"\n+              \"source-target pairs, but could not match some instructions.\")));\n }\n \n TEST_F(HloVerifierTestForCollectiveDeadlocks,\n@@ -4563,6 +4576,105 @@ TEST_F(HloVerifierTestForCollectiveDeadlocks, VerifySendRecvNoDeadlocks) {\n                           ParseAndReturnUnverifiedModule(hlo));\n   EXPECT_THAT(verifier().Run(module.get()), IsOkAndHolds(false));\n }\n+TEST_F(HloVerifierTestForCollectiveDeadlocks,\n+       VerifySendRecvNoDeadlocksWithWhileLoop) {\n+  const char* const hlo = R\"(\n+  HloModule module, is_scheduled=true\n+\n+  while_body {\n+    c0 = f32[] parameter(0)\n+    after_all = token[] after-all()\n+    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{0,1}}\"}\n+    send1-done = token[] send-done(send1), channel_id=1\n+    recv1 = (f32[], u32[], token[]) recv(after_all), channel_id=1, frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{1,0}}\"}\n+    recv1-done = (f32[], token[]) recv-done(recv1), channel_id=1\n+    ROOT recv1_result = f32[] get-tuple-element(recv1-done), index=0\n+  }\n+\n+  while_condition {\n+    c0 = f32[] parameter(0)\n+    ROOT infinite_loop = pred[] constant(true)\n+  }\n+\n+  ENTRY test_computation {\n+    c0 = f32[] constant(0)\n+    after_all = token[] after-all()\n+    recv1 = (f32[], u32[], token[]) recv(after_all), channel_id=1,\n+          frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{0,1}}\"}\n+    recv1-done = (f32[], token[]) recv-done(recv1), channel_id=1\n+    ROOT while_res = f32[] while(c0), condition=while_condition, body=while_body\n+    send1 = (f32[], u32[], token[]) send(c0, after_all), channel_id=1,\n+          frontend_attributes={\n+            _xla_send_recv_source_target_pairs=\"{{1,0}}\"}\n+    send1-done = token[] send-done(send1), channel_id=1\n+  })\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                          ParseAndReturnUnverifiedModule(hlo));\n+  EXPECT_THAT(verifier().Run(module.get()), IsOkAndHolds(false));\n+}\n+\n+TEST_F(HloVerifierTestForCollectiveDeadlocks,\n+       VerifyAsyncComputationWithMultipleSendRecvs) {\n+  const char* const hlo = R\"(\n+HloModule nccl_group_send_recv_no_loop_x4, is_scheduled=true\n+\n+wrapped_send_recv {\n+  param0 = f32[] parameter(0)\n+  param1 = token[] parameter(1)\n+  send1 = (f32[], u32[], token[]) send(param0, param1), channel_id=0,\n+    frontend_attributes={_xla_send_recv_source_target_pairs={{0,1},{1,2}}}\n+  param2 = f32[] parameter(2)\n+  param3 = token[] parameter(3)\n+  send2 = (f32[], u32[], token[]) send(param2, param3), channel_id=0,\n+    frontend_attributes={_xla_send_recv_source_target_pairs={{2,3}}}\n+  param4 = token[] parameter(4)\n+  recv1 = (f32[], u32[], token[]) recv(param4), channel_id=0,\n+    frontend_attributes={_xla_send_recv_source_target_pairs={{0,1},{1,2}}}\n+  param5 = token[] parameter(5)\n+  recv2 = (f32[], u32[], token[]) recv(param5), channel_id=0,\n+    frontend_attributes={_xla_send_recv_source_target_pairs={{2,3}}}\n+  ROOT out = ((f32[], u32[], token[]), (f32[], u32[], token[]),\n+    (f32[], u32[], token[]), (f32[], u32[], token[]))\n+    tuple(send1, send2, recv1, recv2)\n+}\n+\n+ENTRY main {\n+  data1 = f32[] constant(10)\n+  after-all1 = token[] after-all()\n+  data2 = f32[] constant(20)\n+  after-all2 = token[] after-all()\n+  async-comp-start = ((f32[], token[], f32[], token[], token[], token[]),\n+    ((f32[], u32[], token[]), (f32[], u32[], token[]), (f32[], u32[], token[]),\n+    (f32[], u32[], token[])), s32[]) async-start(data1, after-all1,\n+    data2, after-all2, after-all1, after-all2), calls=wrapped_send_recv\n+  async-comp-done = ((f32[], u32[], token[]), (f32[], u32[], token[]),\n+    (f32[], u32[], token[]), (f32[], u32[], token[])) async-done(async-comp-start)\n+  unpack-recv-done1 = (f32[], u32[], token[]) get-tuple-element(async-comp-done), index=2\n+  recv-done-data1 = f32[] get-tuple-element(unpack-recv-done1), index=0\n+  recv-done-token1 = token[] get-tuple-element(unpack-recv-done1), index=2\n+  recv-done1 = (f32[], token[]) tuple(recv-done-data1, recv-done-token1),\n+    control-predecessors={async-comp-start}\n+  data-out1 = f32[] get-tuple-element(recv-done1), index=0\n+  unpack-recv-done2 = (f32[], u32[], token[]) get-tuple-element(async-comp-done), index=3\n+  recv-done-data2 = f32[] get-tuple-element(unpack-recv-done2), index=0\n+  recv-done-token2 = token[] get-tuple-element(unpack-recv-done2), index=2\n+  recv-done2 = (f32[], token[]) tuple(recv-done-data2, recv-done-token2),\n+    control-predecessors={async-comp-start}\n+  data-out2 = f32[] get-tuple-element(recv-done2), index=0\n+  ROOT out = (f32[], f32[]) tuple(data-out1, data-out2)\n+  unpack-send-done1 = (f32[], u32[], token[]) get-tuple-element(async-comp-done), index=0\n+  send-done1 = token[] get-tuple-element(unpack-send-done1), index=2\n+  unpack-send-done2 = (f32[], u32[], token[]) get-tuple-element(async-comp-done), index=1\n+  send-done2 = token[] get-tuple-element(unpack-send-done2), index=2\n+}\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                          ParseAndReturnUnverifiedModule(hlo));\n+  EXPECT_THAT(verifier().Run(module.get()), IsOkAndHolds(false));\n+}\n \n TEST_F(HloVerifierTest, VerifyMatchingSendSameChannel) {\n   const char* const hlo = R\"("
        },
        {
            "sha": "41bca805cc8ed5d1c28d4b17276330bcd76ae3cf",
            "filename": "third_party/xla/xla/service/source_target_pairs.h",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fsource_target_pairs.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d540220082568e9c83fed9a645a42bb475713134/third_party%2Fxla%2Fxla%2Fservice%2Fsource_target_pairs.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fsource_target_pairs.h?ref=d540220082568e9c83fed9a645a42bb475713134",
            "patch": "@@ -47,6 +47,9 @@ struct SourceTargetPair {\n   }\n };\n \n+constexpr char kSendRecvSourceTargetPairsAttr[] =\n+    \"_xla_send_recv_source_target_pairs\";\n+\n // SourceTargetPairs represents a list of (source, target)\n // pairs used in a collective permute instruction\n // e.g. {{0,1},{1,2},{2,3},{3,0}}.\n@@ -79,6 +82,27 @@ class SourceTargetPairs {\n     return res;\n   }\n \n+  static absl::StatusOr<SourceTargetPairs> FromInstruction(\n+      const HloInstruction* instruction) {\n+    auto source_target_pairs = instruction->frontend_attributes().map().find(\n+        kSendRecvSourceTargetPairsAttr);\n+    if (source_target_pairs != instruction->frontend_attributes().map().end()) {\n+      TF_ASSIGN_OR_RETURN(SourceTargetPairs res,\n+                          FromString(source_target_pairs->second));\n+      return res;\n+    }\n+    return Internal(\n+        \"Instruction %s does not have source-target pairs attribute\",\n+        instruction->ToString());\n+  }\n+\n+  static SourceTargetPairs Join(SourceTargetPairs a, SourceTargetPairs b) {\n+    SourceTargetPairs res;\n+    res.pairs_.insert(res.pairs_.end(), a.pairs_.begin(), a.pairs_.end());\n+    res.pairs_.insert(res.pairs_.end(), b.pairs_.begin(), b.pairs_.end());\n+    return res;\n+  }\n+\n   // Returns a cannoical string such as {{0,1},{1,2},{2,3},{3,0}}.\n   std::string ToString() const {\n     auto formatter = [](std::string* out, const SourceTargetPair& pair) {"
        }
    ],
    "stats": {
        "total": 587,
        "additions": 442,
        "deletions": 145
    }
}