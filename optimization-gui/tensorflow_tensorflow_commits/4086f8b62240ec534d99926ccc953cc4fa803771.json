{
    "author": "ezhulenev",
    "message": "[xla] Improve BufferAllocation memory footprint by packing bool flags\n\nPiperOrigin-RevId: 797890513",
    "sha": "4086f8b62240ec534d99926ccc953cc4fa803771",
    "files": [
        {
            "sha": "e6196d3ade26b4c54c157fa1cb6d9d1b13ac88ae",
            "filename": "third_party/xla/xla/service/buffer_assignment.h",
            "status": "modified",
            "additions": 37,
            "deletions": 23,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4086f8b62240ec534d99926ccc953cc4fa803771/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4086f8b62240ec534d99926ccc953cc4fa803771/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h?ref=4086f8b62240ec534d99926ccc953cc4fa803771",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/types/span.h\"\n@@ -51,7 +52,6 @@ limitations under the License.\n #include \"xla/service/logical_buffer.h\"\n #include \"xla/service/memory_space_assignment/memory_space_assignment.h\"\n #include \"xla/shape_util.h\"\n-#include \"tsl/platform/logging.h\"\n \n namespace xla {\n \n@@ -67,7 +67,7 @@ absl::Status GatherComputationsByAllocationType(\n     std::vector<const HloComputation*>* global_computations);\n \n // This class abstracts an allocation of contiguous memory which can hold the\n-// values described by LogicalBuffers. Each LogicalBuffer occupies a sub-range\n+// values described by LogicalBuffers. Each LogicalBuffer occupies a subrange\n // of the allocation, represented by a Slice. A single BufferAllocation may hold\n // LogicalBuffers with disjoint liveness, which may have overlapping Slices. A\n // single BufferAllocation may also hold LogicalBuffers with overlapping\n@@ -83,7 +83,15 @@ class BufferAllocation {\n   using Index = int64_t;\n \n   BufferAllocation(Index index, int64_t size, LogicalBuffer::Color color)\n-      : index_(index), size_(size), color_(color) {}\n+      : index_(index),\n+        size_(size),\n+        color_(color),\n+        is_thread_local_(false),\n+        is_tuple_(false),\n+        is_entry_computation_parameter_(false),\n+        is_parameter_aliased_with_output_(false),\n+        maybe_live_out_(false),\n+        is_constant_(false) {}\n \n   // Returns the index of this allocation.\n   Index index() const { return index_; }\n@@ -196,8 +204,12 @@ class BufferAllocation {\n     }\n     bool operator!=(const Slice& other) const { return !(*this == other); }\n     bool operator<(const Slice& other) const {\n-      if (index() != other.index()) return index() < other.index();\n-      if (offset_ != other.offset_) return offset_ < other.offset_;\n+      if (index() != other.index()) {\n+        return index() < other.index();\n+      }\n+      if (offset_ != other.offset_) {\n+        return offset_ < other.offset_;\n+      }\n       return size_ < other.size_;\n     }\n \n@@ -337,39 +349,39 @@ class BufferAllocation {\n   // Size of the allocation in bytes.\n   int64_t size_;\n \n+  // Color of the allocation.\n+  LogicalBuffer::Color color_;\n+\n+  // If this allocation holds an entry computation parameter, this field\n+  // indicates the index (starting from 0) of the parameter.\n+  int64_t parameter_number_ = 0;\n+\n   // Whether this buffer needs to be thread-local.\n-  bool is_thread_local_ = false;\n+  bool is_thread_local_ : 1;\n \n   // Whether this buffer holds a tuple.\n-  bool is_tuple_ = false;\n-\n-  // Color of the allocation.\n-  LogicalBuffer::Color color_;\n+  bool is_tuple_ : 1;\n \n   // Whether this allocation holds an entry computation parameter. Entry\n   // computation parameters are special because they have lifetimes which may\n   // outlast the computation.\n-  bool is_entry_computation_parameter_ = false;\n+  bool is_entry_computation_parameter_ : 1;\n \n   // Whether this entry computation parameter is aliased with output.\n-  bool is_parameter_aliased_with_output_ = false;\n-\n-  // If this allocation holds an entry computation parameter, this field\n-  // indicates the index (starting from 0) of the parameter.\n-  int64_t parameter_number_ = 0;\n-\n-  // If this buffer is for an entry computation parameter, which subshape of the\n-  // parameter is it for?\n-  ShapeIndex param_shape_index_;\n+  bool is_parameter_aliased_with_output_ : 1;\n \n   // Whether the allocation contains a LogicalBuffer which may be live-out of\n   // the entry computation. Note that this flag is conservatively computed by\n   // TuplePointsToAnalysis.  That is, an allocation marked `maybe_live_out_`\n   // might not actually escape.\n-  bool maybe_live_out_ = false;\n+  bool maybe_live_out_ : 1;\n \n   // See comment on the is_constant() accessor.\n-  bool is_constant_ = false;\n+  bool is_constant_ : 1;\n+\n+  // If this buffer is for an entry computation parameter, which subshape of the\n+  // parameter is it for?\n+  ShapeIndex param_shape_index_;\n \n   // Mapping from the set of buffers assigned to this allocation to their\n   // logical offsets and sizes.\n@@ -602,7 +614,9 @@ class BufferAssignment {\n \n   int64_t HloBufferSize(const HloBuffer& buffer) {\n     auto iter = cached_buffer_sizes_.find(buffer.id());\n-    if (iter != cached_buffer_sizes_.end()) return iter->second;\n+    if (iter != cached_buffer_sizes_.end()) {\n+      return iter->second;\n+    }\n     int64_t result = 0;\n     for (const HloValue* value : buffer.values()) {\n       result = std::max(result, buffer_size_(*value));"
        }
    ],
    "stats": {
        "total": 60,
        "additions": 37,
        "deletions": 23
    }
}