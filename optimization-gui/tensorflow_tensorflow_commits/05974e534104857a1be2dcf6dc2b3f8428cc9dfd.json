{
    "author": "jparkerh",
    "message": "Support AliasBuffers in PJRT\n\nThe previous CL adds the concept of an AliasBuffer to the PJRT C API. This CL implements this functionality on more plugins, and makes a minor refactor to the api structure on the CPU plugin.\n\nPiperOrigin-RevId: 811059076",
    "sha": "05974e534104857a1be2dcf6dc2b3f8428cc9dfd",
    "files": [
        {
            "sha": "66211e98152baec5907e7b7fd443a015917ad935",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=05974e534104857a1be2dcf6dc2b3f8428cc9dfd",
            "patch": "@@ -995,6 +995,8 @@ PJRT_Error* PJRT_Client_FulfillAliasBuffer(\n \n   absl::Status status = std::move(fulfill_alias_buffer_cb)(real_buffer_or);\n   if (!status.ok()) {\n+    LOG(ERROR) << \"PJRT_Client_FulfillAliasBuffer: Callback returned error: \"\n+               << status;\n     return new PJRT_Error{status};\n   }\n   return nullptr;"
        },
        {
            "sha": "e894064064850193d328b8ca16fbc5cef9e63856",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 59,
            "changes": 65,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=05974e534104857a1be2dcf6dc2b3f8428cc9dfd",
            "patch": "@@ -198,72 +198,19 @@ absl::StatusOr<\n     std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n CommonPjRtClient::CreateAliasBuffer(const Shape& shape,\n                                     PjRtMemorySpace* memory_space) {\n-  auto buffer_promise = tsl::MakeIndirectAsyncValue();\n-  auto raw_buffer_or = CreateRawBufferAsyncValue(memory_space, buffer_promise);\n-  if (!raw_buffer_or.ok()) {\n-    buffer_promise->SetError(raw_buffer_or.status());\n-    return raw_buffer_or.status();\n-  }\n-  auto raw_buffer = std::move(raw_buffer_or).value();\n+  tsl::RCReference<CommonPjRtRawBuffer> raw_buffer;\n+  tsl::RCReference<PjRtDeviceEvent> definition_event;\n+  PjRtFulfillAliasBufferCallback fulfill_cb;\n \n-  tsl::RCReference<xla::PjRtDeviceEventPromise> definition_event_promise;\n-  tsl::RCReference<xla::PjRtDeviceEvent> definition_event;\n-  TF_ASSIGN_OR_RETURN(\n-      std::tie(definition_event_promise, definition_event),\n-      CreateLinkedEventPromise(memory_space, \"MakePjRtBufferChannel\"));\n+  TF_ASSIGN_OR_RETURN(std::tie(raw_buffer, definition_event, fulfill_cb),\n+                      CreateRawBufferChannel(shape, memory_space));\n \n-  // Make a placeholder PjRtBuffer that will be fulfilled when the\n-  // buffer_promise is fulfilled.\n   TF_ASSIGN_OR_RETURN(\n       auto result_buffer,\n       DefineBuffer(shape, std::move(raw_buffer), {std::move(definition_event)},\n                    /*raw_buffer_is_mutable=*/true));\n \n-  xla::PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb =\n-      [buffer_promise = std::move(buffer_promise),\n-       definition_event_promise = std::move(definition_event_promise),\n-       memory_space,\n-       shape](absl::StatusOr<xla::PjRtBuffer*> buffer_or) -> absl::Status {\n-    tsl::RCReference<xla::PjRtDeviceEvent> device_event;\n-    if (!buffer_or.ok()) {\n-      definition_event_promise->SetError(buffer_or.status());\n-      buffer_promise->SetError(buffer_or.status());\n-      return buffer_or.status();\n-    }\n-    xla::PjRtBuffer* buffer = buffer_or.value();\n-    if (buffer->on_device_shape() != shape) {\n-      auto status = absl::InvalidArgumentError(absl::StrFormat(\n-          \"Shape mismatch in CreateAliasBuffer: expected %s, got %s\",\n-          shape.ToString(), buffer->on_device_shape().ToString()));\n-      definition_event_promise->SetError(status);\n-      buffer_promise->SetError(status);\n-      return status;\n-    }\n-    xla::CommonPjRtBuffer* common_buffer =\n-        dynamic_cast<xla::CommonPjRtBuffer*>(buffer);\n-    if (common_buffer == nullptr) {\n-      auto status = absl::InternalError(\"Failed to cast to CommonPjRtBuffer\");\n-      definition_event_promise->SetError(status);\n-      buffer_promise->SetError(status);\n-      return status;\n-    }\n-    xla::CommonPjRtBuffer::ScopedHold hold = common_buffer->GetBufferWithHold(\n-        xla::CommonPjRtBuffer::ScopedHold::kDonation);\n-    TF_ASSIGN_OR_RETURN(device_event,\n-                        hold.buffer()->GetDefinitionEvent(memory_space));\n-    // raw buffer. We forward it to the real buffer's raw buffer.\n-    tsl::RCReference<CommonPjRtRawBuffer> real_raw_buffer =\n-        hold.buffer()->GetRawBuffer(memory_space);\n-    TF_ASSIGN_OR_RETURN(tsl::RCReference<tsl::AsyncValue> underlying_av,\n-                        real_raw_buffer->GetRawBufferAsyncValue());\n-    buffer_promise->ForwardTo(std::move(underlying_av));\n-    definition_event_promise->Set(device_event);\n-    hold.ConfirmDonation();\n-    return absl::OkStatus();\n-  };\n-\n-  return std::make_pair(std::move(result_buffer),\n-                        std::move(fulfill_alias_buffer_cb));\n+  return std::make_pair(std::move(result_buffer), std::move(fulfill_cb));\n }\n \n absl::StatusOr<std::unique_ptr<PjRtBuffer>>"
        },
        {
            "sha": "b54daaddbf0eabe762f82bc8ef33e0e01d6687ea",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.h",
            "status": "modified",
            "additions": 15,
            "deletions": 8,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h?ref=05974e534104857a1be2dcf6dc2b3f8428cc9dfd",
            "patch": "@@ -121,14 +121,6 @@ class CommonPjRtClient : public PjRtClient {\n         \"CreateLinkedEventPromise is not supported\");\n   }\n \n-  virtual absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n-  CreateRawBufferAsyncValue(\n-      PjRtMemorySpace* memory_space,\n-      tsl::RCReference<tsl::IndirectAsyncValue> buffer_promise) {\n-    return absl::UnimplementedError(\n-        \"CreateRawBufferAsyncValue is not supported\");\n-  }\n-\n   // Track a user-provided future with attached debug_info (if\n   // event_tracking_enabled()).\n   virtual void TrackFuture(PjRtMemorySpace* memory_space,\n@@ -191,6 +183,21 @@ class CommonPjRtClient : public PjRtClient {\n       std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n   CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) override;\n \n+  // Creates a raw buffer channel. Returns a tuple containing:\n+  // 1.  A tsl::RCReference<CommonPjRtRawBuffer> which is an alias for a future\n+  //     raw buffer.\n+  // 2.  A tsl::RCReference<PjRtDeviceEvent> which is the definition event\n+  //     for the alias raw buffer.\n+  // 3.  A PjRtFulfillAliasBufferCallback to fulfill the alias.\n+  // TODO(b/447164755 jparkerh): Rework this API to share a bit more code\n+  // between children of this class.\n+  virtual absl::StatusOr<std::tuple<tsl::RCReference<CommonPjRtRawBuffer>,\n+                                    tsl::RCReference<PjRtDeviceEvent>,\n+                                    PjRtFulfillAliasBufferCallback>>\n+  CreateRawBufferChannel(const Shape& shape, PjRtMemorySpace* memory_space) {\n+    return absl::UnimplementedError(\"CreateRawBufferChannel is not supported\");\n+  }\n+\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n       const Shape& shape, PjRtMemorySpace* memory_space) override;\n "
        },
        {
            "sha": "81c2f7fb838b8dd0d9171df6752808057bde9ff5",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 65,
            "deletions": 7,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=05974e534104857a1be2dcf6dc2b3f8428cc9dfd",
            "patch": "@@ -1016,13 +1016,71 @@ PjRtCpuClient::AllocateRawBuffer(PjRtMemorySpace* memory_space,\n                                      *allocator_);\n }\n \n-absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n-PjRtCpuClient::CreateRawBufferAsyncValue(\n-    PjRtMemorySpace* memory_space,\n-    tsl::RCReference<tsl::IndirectAsyncValue> buffer_promise) {\n-  return tsl::MakeRef<CpuRawBuffer>(\n-      memory_space,\n-      tsl::AsyncValueRef<CpuDeviceMemory>(std::move(buffer_promise)));\n+absl::StatusOr<std::tuple<tsl::RCReference<CommonPjRtRawBuffer>,\n+                          tsl::RCReference<PjRtDeviceEvent>,\n+                          PjRtFulfillAliasBufferCallback>>\n+PjRtCpuClient::CreateRawBufferChannel(const Shape& shape,\n+                                      PjRtMemorySpace* memory_space) {\n+  auto buffer_promise = tsl::MakeIndirectAsyncValue();\n+  auto raw_buffer = tsl::MakeRef<CpuRawBuffer>(\n+      memory_space, tsl::AsyncValueRef<CpuDeviceMemory>(buffer_promise));\n+\n+  tsl::RCReference<xla::PjRtDeviceEventPromise> definition_event_promise;\n+  tsl::RCReference<xla::PjRtDeviceEvent> definition_event;\n+  TF_ASSIGN_OR_RETURN(\n+      std::tie(definition_event_promise, definition_event),\n+      CreateLinkedEventPromise(memory_space, \"CreateRawBufferChannel\"));\n+\n+  PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb =\n+      [buffer_promise = std::move(buffer_promise),\n+       definition_event_promise = std::move(definition_event_promise),\n+       memory_space,\n+       shape](absl::StatusOr<xla::PjRtBuffer*> buffer_or) mutable {\n+        tsl::RCReference<xla::PjRtDeviceEvent> device_event;\n+        if (!buffer_or.ok()) {\n+          definition_event_promise->SetError(buffer_or.status());\n+          buffer_promise->SetError(buffer_or.status());\n+          return buffer_or.status();\n+        }\n+        xla::PjRtBuffer* buffer = buffer_or.value();\n+        if (buffer->on_device_shape() != shape) {\n+          auto status = absl::InvalidArgumentError(absl::StrFormat(\n+              \"Shape mismatch in CreateRawBufferChannel fulfill: expected %s, \"\n+              \"got \"\n+              \"%s\",\n+              shape.ToString(), buffer->on_device_shape().ToString()));\n+          definition_event_promise->SetError(status);\n+          buffer_promise->SetError(status);\n+          return status;\n+        }\n+        xla::CommonPjRtBuffer* common_buffer =\n+            dynamic_cast<xla::CommonPjRtBuffer*>(buffer);\n+        if (common_buffer == nullptr) {\n+          auto status =\n+              absl::InternalError(\"Failed to cast to CommonPjRtBuffer\");\n+          definition_event_promise->SetError(status);\n+          buffer_promise->SetError(status);\n+          return status;\n+        }\n+        xla::CommonPjRtBuffer::ScopedHold hold =\n+            common_buffer->GetBufferWithHold(\n+                xla::CommonPjRtBuffer::ScopedHold::kDonation);\n+        TF_ASSIGN_OR_RETURN(device_event,\n+                            hold.buffer()->GetDefinitionEvent(memory_space));\n+\n+        auto* tracked_cpu_buffer =\n+            tensorflow::down_cast<TrackedCpuDeviceBuffer*>(hold.buffer());\n+        tsl::AsyncValueRef<CpuDeviceMemory> real_cpu_buffer =\n+            tracked_cpu_buffer->buffer();\n+\n+        buffer_promise->ForwardTo(real_cpu_buffer.CopyRCRef());\n+        definition_event_promise->Set(device_event);\n+        hold.ConfirmDonation();\n+        return absl::OkStatus();\n+      };\n+\n+  return std::make_tuple(std::move(raw_buffer), std::move(definition_event),\n+                         std::move(fulfill_alias_buffer_cb));\n }\n \n absl::StatusOr<int64_t> PjRtCpuClient::GetOnDeviceBytesCount("
        },
        {
            "sha": "f65a51c6d67dee147cff4f65303a79272efa1222",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.h",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/05974e534104857a1be2dcf6dc2b3f8428cc9dfd/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h?ref=05974e534104857a1be2dcf6dc2b3f8428cc9dfd",
            "patch": "@@ -200,10 +200,11 @@ class PjRtCpuClient final : public CommonPjRtClient {\n     return &topology_;\n   }\n \n-  absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n-  CreateRawBufferAsyncValue(\n-      PjRtMemorySpace* memory_space,\n-      tsl::RCReference<tsl::IndirectAsyncValue> buffer_promise) override;\n+  absl::StatusOr<std::tuple<tsl::RCReference<CommonPjRtRawBuffer>,\n+                            tsl::RCReference<PjRtDeviceEvent>,\n+                            PjRtFulfillAliasBufferCallback>>\n+  CreateRawBufferChannel(const Shape& shape,\n+                         PjRtMemorySpace* memory_space) override;\n \n   absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>> AllocateRawBuffer(\n       PjRtMemorySpace* memory_space, size_t on_device_bytes_count,"
        }
    ],
    "stats": {
        "total": 171,
        "additions": 93,
        "deletions": 78
    }
}