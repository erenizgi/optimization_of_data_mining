{
    "author": "hyeontaek",
    "message": "[IFRT] Define `UserContextRegistry` and `TrackedUserContextRef`\n\n`UserContextRegistry` provides a process-wide registry of live\n`UserContextRef`. As long as a returned `TrackedUserContextRef` is alive, the\nregistry allows looking up `UserContextRef` by its ID.\n\nThis is primarily used for making it possible for the IFRT user to retrieve\n`UserContextRef` when it is referenced in an `absl::Status`. As done in a\nsubsequent change, IFRT implementations can mention `UserContextRef` to provide\na more context on an async dispatch, where it would put its ID as the text,\nwith a hidden strong reference to `UserContextRef` (in fact\n`TrackedUserContextRef`). Then, the IFRT user can read the ID and obtain\n`UserContextRef` via the registry.\n\nThis feature can also be used for enumerating all live `UserContextRef` for\nasync dispatch operations. As `UserContextRegistry` is process-wide, this would\nlist `UserContextRef` from all IFRT implementation instances in the same\nprocess, but we do not expect this to be a problem because an ID identifying a\n`UserContext` is supposed to globally uniquely.\n\nBased on a design discussion with junwhan@.\n\nPiperOrigin-RevId: 804644395",
    "sha": "9132f8466759b75472979757b631515cb40bde42",
    "files": [
        {
            "sha": "7634256595525328a1b31e59d167581cbfa5e297",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=9132f8466759b75472979757b631515cb40bde42",
            "patch": "@@ -1130,6 +1130,37 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"user_context_registry\",\n+    srcs = [\"user_context_registry.cc\"],\n+    hdrs = [\"user_context_registry.h\"],\n+    visibility = internal_visibility([\n+        \":friends\",\n+        \":internal\",\n+    ]),\n+    deps = [\n+        \":user_context\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/synchronization\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"user_context_registry_test\",\n+    srcs = [\"user_context_registry_test.cc\"],\n+    deps = [\n+        \":user_context\",\n+        \":user_context_registry\",\n+        \"//xla/tsl/concurrency:ref_count\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//llvm:Support\",\n+    ],\n+)\n+\n xla_cc_test(\n     name = \"custom_call_program_serdes_test\",\n     srcs = [\"custom_call_program_serdes_test.cc\"],"
        },
        {
            "sha": "853888da2f0294744e8c74bc16b155b33da3277c",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry.cc",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.cc?ref=9132f8466759b75472979757b631515cb40bde42",
            "patch": "@@ -0,0 +1,88 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt/user_context_registry.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+UserContextRegistry& UserContextRegistry::Get() {\n+  static absl::NoDestructor<UserContextRegistry> registry;\n+  return *registry;\n+}\n+\n+TrackedUserContextRef UserContextRegistry::Register(\n+    UserContextRef user_context) {\n+  const uint64_t id = user_context->Fingerprint();\n+  absl::MutexLock lock(&mu_);\n+  auto it = registry_.find(id);\n+  if (it != registry_.end()) {\n+    // If the user context is already registered, return the existing\n+    // `TrackedUserContextRef`. This will avoid duplicate `Unregister()` calls\n+    // for the same user context ID.\n+    TrackedUserContextRef tracked_user_context = it->second.lock();\n+    CHECK(tracked_user_context != nullptr)\n+        << \"Unexpected dangling reference for user context ID: \" << id;\n+    return tracked_user_context;\n+  }\n+  auto tracked_user_context = std::shared_ptr<TrackedUserContext>(\n+      new TrackedUserContext(id, std::move(user_context)));\n+  registry_.insert(\n+      {id, std::weak_ptr<TrackedUserContext>(tracked_user_context)});\n+  return tracked_user_context;\n+}\n+\n+TrackedUserContextRef UserContextRegistry::Lookup(uint64_t id) const {\n+  absl::MutexLock lock(&mu_);\n+  auto it = registry_.find(id);\n+  if (it != registry_.end()) {\n+    TrackedUserContextRef tracked_user_context = it->second.lock();\n+    CHECK(tracked_user_context != nullptr)\n+        << \"Unexpected dangling reference for user context ID: \" << id;\n+    return tracked_user_context;\n+  }\n+  return nullptr;\n+}\n+\n+std::vector<TrackedUserContextRef> UserContextRegistry::LookupAll() const {\n+  absl::MutexLock lock(&mu_);\n+  std::vector<TrackedUserContextRef> tracked_user_contexts;\n+  tracked_user_contexts.reserve(registry_.size());\n+  for (auto it = registry_.begin(); it != registry_.end(); ++it) {\n+    TrackedUserContextRef tracked_user_context = it->second.lock();\n+    CHECK(tracked_user_context != nullptr)\n+        << \"Unexpected dangling reference for user context ID: \" << it->first;\n+    tracked_user_contexts.push_back(std::move(tracked_user_context));\n+  }\n+  return tracked_user_contexts;\n+}\n+\n+void UserContextRegistry::Unregister(uint64_t id) {\n+  absl::MutexLock lock(&mu_);\n+  CHECK_EQ(registry_.erase(id), 1);\n+}\n+\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "53fc66c921633b3d17f542336fdb9dbf7891012e",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry.h",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry.h?ref=9132f8466759b75472979757b631515cb40bde42",
            "patch": "@@ -0,0 +1,119 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PYTHON_IFRT_USER_CONTEXT_REGISTRY_H_\n+#define XLA_PYTHON_IFRT_USER_CONTEXT_REGISTRY_H_\n+\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+class TrackedUserContext;\n+using TrackedUserContextRef = std::shared_ptr<const TrackedUserContext>;\n+\n+// Global registry for tracking live `UserContextRef`.\n+//\n+// `UserContextRef` can be registered in the process-wide registry. As long as\n+// the returned `TrackedUserContextRef` is alive, the corresponding\n+// `UserContextRef` will be kept alive and can be looked up via the registry by\n+// using its ID. Once all `TrackedUserContextRef`s are destroyed, the\n+// corresponding `UserContextRef` will be removed from the registry (and\n+// destroyed if there is no other copy of `UserContextRef`).\n+//\n+// This registry serves two primary purposes:\n+//\n+// * Allow IFRT implementations to attach `UserContextRef` to an error status\n+// (e.g., `absl::Status`) and propagate it across the IFRT API boundary while\n+// keeping it alive until the IFRT user expands the error status with user\n+// context IDs. The reason why a registry is required even when we can keep\n+// `UserContextRef` alive with a status payload is that the IFRT user still\n+// needs a way to retrieve the original `UserContextRef`, and they will only\n+// have the ID to do so and cannot access `UserContextRef` embedded in the\n+// status payload directly.\n+//\n+// * Provide a way for IFRT implementations to enumerate all live\n+// `UserContextRef`s that may be referenced in an error status. To use this\n+// feature, IFRT implementations are expected to call `Register()` in the\n+// beginning of any operation that performs async dispatch, and hold the\n+// returned `TrackedUserContextRef` until the operation is complete.\n+//\n+// All methods are thread-safe.\n+class UserContextRegistry {\n+ public:\n+  // Returns the singleton registry.\n+  static UserContextRegistry& Get();\n+\n+  // Ensures that `user_context` is registered in the registry (if not) and\n+  // returns `TrackedUserContextRef` for `user_context`.\n+  TrackedUserContextRef Register(UserContextRef user_context);\n+\n+  // Returns `TrackedUserContextRef` for `id`.\n+  // If no such `id` is found, returns `nullptr`.\n+  TrackedUserContextRef Lookup(uint64_t id) const;\n+\n+  // Returns all `TrackedUserContextRef`s in the registry. Note that since the\n+  // registry is process-wide, the result will contain `TrackedUserContextRef`s\n+  // seen from all local IFRT client instances.\n+  std::vector<TrackedUserContextRef> LookupAll() const;\n+\n+ private:\n+  friend TrackedUserContext;\n+\n+  // Removes a `TrackedUserContext` entry identified by `id` from the\n+  // registry.\n+  void Unregister(uint64_t id);\n+\n+  mutable absl::Mutex mu_;\n+  // A map from `UserContext::Fingerprint()` to a weak reference of\n+  // `TrackedUserContext`.\n+  absl::flat_hash_map<uint64_t, std::weak_ptr<TrackedUserContext>> registry_\n+      ABSL_GUARDED_BY(mu_);\n+};\n+\n+// RAII wrapper around `UserContextRef` to allow querying them via the registry\n+// while the RAII wrapper is alive.\n+class TrackedUserContext {\n+ public:\n+  // Not copyable or movable. Use `TrackedUserContextRef`.\n+  TrackedUserContext(const TrackedUserContext&) = delete;\n+  TrackedUserContext(TrackedUserContext&&) = delete;\n+\n+  ~TrackedUserContext() { UserContextRegistry::Get().Unregister(id_); }\n+\n+  const UserContextRef& user_context() const { return user_context_; }\n+\n+ private:\n+  friend UserContextRegistry;\n+\n+  explicit TrackedUserContext(uint64_t id, UserContextRef user_context)\n+      : id_(id), user_context_(std::move(user_context)) {}\n+\n+  const uint64_t id_;\n+  const UserContextRef user_context_;\n+};\n+\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_IFRT_USER_CONTEXT_REGISTRY_H_"
        },
        {
            "sha": "243a3ff156cd0b1802c094761a3719e950ee040e",
            "filename": "third_party/xla/xla/python/ifrt/user_context_registry_test.cc",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9132f8466759b75472979757b631515cb40bde42/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context_registry_test.cc?ref=9132f8466759b75472979757b631515cb40bde42",
            "patch": "@@ -0,0 +1,93 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt/user_context_registry.h\"\n+\n+#include <cstdint>\n+#include <string>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/strings/str_cat.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+namespace {\n+\n+class TestUserContext : public llvm::RTTIExtends<TestUserContext, UserContext> {\n+ public:\n+  static UserContextRef Create(uint64_t id) {\n+    return tsl::TakeRef<TestUserContext>(new TestUserContext(id));\n+  }\n+\n+  uint64_t Fingerprint() const override { return id_; }\n+\n+  std::string DebugString() const override {\n+    return absl::StrCat(\"user context \", id_);\n+  }\n+\n+  // No new `ID` is not defined because tests below do not exercise RTTI.\n+\n+ private:\n+  explicit TestUserContext(uint64_t id) : id_(id) {}\n+\n+  uint64_t id_;\n+};\n+\n+TEST(UserContextRegistryTest, GetAndLookup) {\n+  UserContextRef user_context1 = TestUserContext::Create(100);\n+  TrackedUserContextRef tracked_user_context1 =\n+      UserContextRegistry::Get().Register(user_context1);\n+  ASSERT_EQ(UserContextRegistry::Get().Lookup(100), tracked_user_context1);\n+  EXPECT_EQ(UserContextRegistry::Get().Lookup(100)->user_context(),\n+            user_context1);\n+\n+  UserContextRef user_context2 = TestUserContext::Create(200);\n+  TrackedUserContextRef tracked_user_context2 =\n+      UserContextRegistry::Get().Register(user_context2);\n+  ASSERT_EQ(UserContextRegistry::Get().Lookup(200), tracked_user_context2);\n+  EXPECT_EQ(UserContextRegistry::Get().Lookup(200)->user_context(),\n+            user_context2);\n+}\n+\n+TEST(UserContextRegistryTest, LookupAll) {\n+  UserContextRef user_context1 = TestUserContext::Create(100);\n+  TrackedUserContextRef tracked_user_context1 =\n+      UserContextRegistry::Get().Register(user_context1);\n+  UserContextRef user_context2 = TestUserContext::Create(200);\n+  TrackedUserContextRef tracked_user_context2 =\n+      UserContextRegistry::Get().Register(user_context2);\n+\n+  EXPECT_THAT(UserContextRegistry::Get().LookupAll(),\n+              testing::UnorderedElementsAre(tracked_user_context1,\n+                                            tracked_user_context2));\n+}\n+\n+TEST(UserContextRegistryTest, Unregister) {\n+  EXPECT_EQ(UserContextRegistry::Get().Lookup(100), nullptr);\n+  {\n+    TrackedUserContextRef tracked_user_context =\n+        UserContextRegistry::Get().Register(TestUserContext::Create(100));\n+    EXPECT_NE(UserContextRegistry::Get().Lookup(100), nullptr);\n+  }\n+  EXPECT_EQ(UserContextRegistry::Get().Lookup(100), nullptr);\n+}\n+\n+}  // namespace\n+}  // namespace ifrt\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 331,
        "additions": 331,
        "deletions": 0
    }
}