{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Don't submit tasks to executor if Future::Map result is unused\n\nPiperOrigin-RevId: 818444632",
    "sha": "0c7c2289a95086ab4967e45b1bedcf85bfccb281",
    "files": [
        {
            "sha": "31d3946eb19138c1ef2303828b90b0ac0dc09d64",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 70,
            "deletions": 11,
            "changes": 81,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0c7c2289a95086ab4967e45b1bedcf85bfccb281/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0c7c2289a95086ab4967e45b1bedcf85bfccb281/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=0c7c2289a95086ab4967e45b1bedcf85bfccb281",
            "patch": "@@ -458,7 +458,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n \n   static constexpr bool is_move_only = Base::IsMoveOnly();  // NOLINT\n \n-  static_assert(!std::is_same_v<T, absl::Status>,\n+  static_assert(!internal::is_status_v<T>,\n                 \"Use Future<> specialization for stateless futures\");\n \n   static_assert(\n@@ -601,7 +601,23 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n             internal::Mappable<R, U>* = nullptr>\n   [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const& {\n     auto [promise, future] = Future<R>::MakePromise();\n-    OnReady(executor, SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n+\n+    OnReady([&executor, f = std::forward<F>(f), promise = std::move(promise),\n+             ptr = Base::promise()](const absl::StatusOr<T>& value) mutable {\n+      // Do not submit a task to the executor if the result is unused.\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n+\n+      // Extend the lifetime of the underlying async value storage by copying\n+      // the reference to it, to avoid use-after-free inside the `f` functor.\n+      executor.Execute([&value, ref = ptr.CopyRef(), f = std::move(f),\n+                        promise = std::move(promise)]() mutable {\n+        SetPromise<R, U>(std::move(promise), std::move(f))(value);\n+      });\n+    });\n+\n     return std::move(future);\n   }\n \n@@ -670,9 +686,38 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n             internal::Mappable<R, U>* = nullptr>\n   [[nodiscard]] Future<R> Map(Executor& executor, F&& f) && {\n     auto [promise, future] = Future<R>::MakePromise();\n-    std::move(*this).OnReady(\n-        executor, SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n-                                                    std::forward<F>(f)));\n+\n+    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n+                                     const absl::StatusOr<T>&>;\n+    std::move(*this).OnReady([&executor, f = std::forward<F>(f),\n+                              promise = std::move(promise),\n+                              ptr = Base::promise()](Value value) mutable {\n+      // Do not submit a task to the executor if the result is unused.\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n+\n+      // For move-only types pass by value to the executor callback, and for\n+      // copyable types pass by const reference to avoid accidental copies. For\n+      // values passed by reference extend the lifetime of the underlying async\n+      // value storage by copying the reference to it, to avoid use-after-free\n+      // inside the `f` functor.\n+      if constexpr (is_move_only) {\n+        executor.Execute([value = std::move(value), f = std::move(f),\n+                          promise = std::move(promise)]() mutable {\n+          SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n+                                            std::move(f))(std::move(value));\n+        });\n+      } else {\n+        executor.Execute([&value, ref = ptr.CopyRef(), f = std::move(f),\n+                          promise = std::move(promise)]() mutable {\n+          SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n+                                            std::move(f))(value);\n+        });\n+      }\n+    });\n+\n     return std::move(future);\n   }\n \n@@ -901,7 +946,21 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n             internal::Mappable<R, U>* = nullptr>\n   [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const {\n     auto [promise, future] = Future<R>::MakePromise();\n-    OnReady(executor, SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n+\n+    OnReady([&executor, f = std::forward<F>(f),\n+             promise = std::move(promise)](const absl::Status& status) mutable {\n+      // Do not submit a task to the executor if the result is unused.\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n+\n+      // Pass `status` by value because it's cheap to copy, instead of extending\n+      // the lifetime of the underlying async value storage.\n+      executor.Execute(std::bind(\n+          SetPromise<R, U>(std::move(promise), std::move(f)), status));\n+    });\n+\n     return std::move(future);\n   }\n \n@@ -948,7 +1007,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   template <typename R, typename U, typename F>\n   static auto SetPromise(typename Future<R>::Promise promise, F&& f) {\n     return [promise = std::move(promise),\n-            f = std::forward<F>(f)](absl::Status status) mutable {\n+            f = std::forward<F>(f)](const absl::Status& status) mutable {\n       // Do not compute `f` if the result is unused.\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n@@ -1003,11 +1062,11 @@ template <typename T, bool is_move_only>\n Future<> FutureBase<T, is_move_only>::GetReadyFuture() const {\n   auto [promise, future] = Future<>::MakePromise();\n   promise_.AndThen(\n-      [self = promise_.AsPtr(), promise = std::move(promise)]() mutable {\n-        if constexpr (std::is_same_v<T, absl::Status>) {\n-          promise.Set(*self);\n+      [ptr = promise_.AsPtr(), promise = std::move(promise)]() mutable {\n+        if constexpr (internal::is_status_v<T>) {\n+          promise.Set(*ptr);\n         } else {\n-          promise.Set(self->status());\n+          promise.Set(ptr->status());\n         }\n       });\n   return std::move(future);"
        },
        {
            "sha": "73b8e7b7662f72c08071de3cdb8c480ddf6e32b4",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 160,
            "deletions": 28,
            "changes": 188,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0c7c2289a95086ab4967e45b1bedcf85bfccb281/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0c7c2289a95086ab4967e45b1bedcf85bfccb281/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=0c7c2289a95086ab4967e45b1bedcf85bfccb281",
            "patch": "@@ -37,6 +37,16 @@ namespace tsl {\n using ::absl_testing::IsOk;\n using ::testing::Not;\n \n+// Inline executor that counts the number of tasks executed.\n+struct CountingExecutor : public Executor {\n+  void Execute(Task task) final {\n+    ++num_tasks;\n+    std::move(task)();\n+  }\n+\n+  int32_t num_tasks = 0;\n+};\n+\n TEST(FutureTest, StatusConstructedFuture) {\n   Future<> future = Future<>(absl::OkStatus());\n   EXPECT_TRUE(future.IsReady());\n@@ -298,32 +308,65 @@ TEST(FutureTest, MapMoveOnlyWithInplaceConstructor) {\n   EXPECT_EQ(mapped.Await()->v, 42);\n }\n \n-TEST(FutureTest, MapUnusedResult) {\n-  auto [promise, future] = Future<int>::MakePromise();\n+TEST(FutureTest, MapStatelessUnusedResult) {\n+  auto [promise, future] = Future<>::MakePromise();\n \n   bool called = false;\n   // We intentionally drop returned future to test that promise will not\n   // execute map functor.\n-  (void)future.Map([&](int) {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set(1);\n+  (void)future.Map([&]() { called = true; });\n+  promise.Set(absl::OkStatus());\n   EXPECT_FALSE(called);\n }\n \n-TEST(FutureTest, MapStatusUnusedResult) {\n+TEST(FutureTest, MapStatelessOnExecutorUnusedResult) {\n   auto [promise, future] = Future<>::MakePromise();\n \n+  CountingExecutor executor;\n   bool called = false;\n   // We intentionally drop returned future to test that promise will not\n   // execute map functor.\n-  (void)future.Map([&]() {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set();\n+  (void)future.Map(executor, [&]() { called = true; });\n+  promise.Set(absl::OkStatus());\n   EXPECT_FALSE(called);\n+  EXPECT_EQ(executor.num_tasks, 0);\n+}\n+\n+TEST(FutureTest, MapStatefulUnusedResult) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+  bool called = false;\n+  // We intentionally drop returned future to test that promise will not\n+  // execute map functor.\n+  (void)future.Map([&](int) { called = true; });\n+  promise.Set(1);\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(FutureTest, MapStatefulOnExecutorUnusedResult) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+  CountingExecutor executor;\n+  bool called = false;\n+  // We intentionally drop returned future to test that promise will not\n+  // execute map functor.\n+  (void)future.Map(executor, [&](int32_t) { called = true; });\n+  promise.Set(1);\n+  EXPECT_FALSE(called);\n+  EXPECT_EQ(executor.num_tasks, 0);\n+}\n+\n+TEST(FutureTest, MapStatefulRvalueOnExecutorUnusedResult) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  CountingExecutor executor;\n+  bool called = false;\n+  // We intentionally drop returned future to test that promise will not\n+  // execute map functor.\n+  (void)std::move(future).Map(executor, [&](auto) { called = true; });\n+  promise.Set(std::make_unique<int32_t>(1));\n+  EXPECT_FALSE(called);\n+  EXPECT_EQ(executor.num_tasks, 0);\n }\n \n TEST(FutureTest, TryMapCopyableFutureToStateless) {\n@@ -460,20 +503,6 @@ TEST(FutureTest, TryMapMoveOnlyFutureCreateError) {\n   EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n }\n \n-TEST(FutureTest, TryMapUnusedResult) {\n-  auto [promise, future] = Future<int>::MakePromise();\n-\n-  bool called = false;\n-  // We intentionally drop returned future to test that promise will not\n-  // execute map functor.\n-  (void)future.Map([&](int) -> absl::StatusOr<int> {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set(1);\n-  EXPECT_FALSE(called);\n-}\n-\n TEST(FutureTest, MapWithVoidFunctor) {\n   {\n     auto [promise, future] = Future<>::MakePromise();\n@@ -501,6 +530,67 @@ TEST(FutureTest, MapWithVoidFunctor) {\n   }\n }\n \n+TEST(FutureTest, MapDoesNotCopy) {\n+  static int32_t counter = 0;\n+\n+  // A trivial class that counts how many times the copy constructor is called.\n+  struct Data {\n+    Data() = default;\n+\n+    Data(const Data& other) { ++counter; }\n+    Data(Data&& other) {}\n+\n+    Data& operator=(Data& other) = delete;\n+    Data& operator=(Data&& other) = delete;\n+  };\n+\n+  auto [promise, future] = Future<Data>::MakePromise();\n+\n+  Future<> m0 = future.Map([](const Data& data) {});\n+  Future<> m1 = future.Map([](Data data) {});\n+  Future<> m2 = std::move(future).Map([](const Data& data) {});\n+\n+  promise.Set(Data{});\n+\n+  EXPECT_EQ(m0.Await(), absl::OkStatus());\n+  EXPECT_EQ(m1.Await(), absl::OkStatus());\n+  EXPECT_EQ(m2.Await(), absl::OkStatus());\n+\n+  EXPECT_EQ(counter, 1);\n+};\n+\n+TEST(FutureTest, MapOnExecutorDoesNotCopy) {\n+  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+  tsl::Executor* executor = thread_pool.AsExecutor();\n+\n+  static int32_t counter = 0;\n+\n+  // A trivial class that counts how many times the copy constructor is called.\n+  struct Data {\n+    Data() = default;\n+\n+    Data(const Data& other) { ++counter; }\n+    Data(Data&& other) {}\n+\n+    Data& operator=(Data& other) = delete;\n+    Data& operator=(Data&& other) = delete;\n+  };\n+\n+  auto [promise, future] = Future<Data>::MakePromise();\n+\n+  Future<> m0 = future.Map(*executor, [](const Data& data) {});\n+  Future<> m1 = future.Map(*executor, [](Data data) {});\n+  Future<> m2 = std::move(future).Map(*executor, [](const Data& data) {});\n+\n+  promise.Set(Data{});\n+\n+  EXPECT_EQ(m0.Await(), absl::OkStatus());\n+  EXPECT_EQ(m1.Await(), absl::OkStatus());\n+  EXPECT_EQ(m2.Await(), absl::OkStatus());\n+\n+  EXPECT_EQ(counter, 1);\n+};\n+\n TEST(FutureTest, StatelessError) {\n   auto [promise, future] = Future<>::MakePromise();\n \n@@ -877,7 +967,7 @@ TEST(FutureTest, MapStatelessOnThreadPoolExecutor) {\n   EXPECT_EQ(counter, 100);\n }\n \n-TEST(FutureTest, MapStatefullOnThreadPoolExecutor) {\n+TEST(FutureTest, MapStatefulOnThreadPoolExecutor) {\n   tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n \n   std::vector<Future<>> mapped;\n@@ -897,6 +987,48 @@ TEST(FutureTest, MapStatefullOnThreadPoolExecutor) {\n   EXPECT_EQ(counter, 100);\n }\n \n+TEST(FutureTest, MapMoveOnlyOnThreadPoolExecutor) {\n+  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+\n+  std::vector<Future<>> mapped;\n+  std::atomic<int32_t> counter = 0;\n+\n+  {  // Create mapped future in a nested scope to make sure that `promise` and\n+    // `future` are destroyed before the end of the test.\n+    auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+    for (size_t i = 0; i < 100; ++i) {\n+      mapped.push_back(future.Map(\n+          *thread_pool.AsExecutor(),\n+          [&](const std::unique_ptr<int32_t>& value) { counter += *value; }));\n+    }\n+    promise.Set(std::make_unique<int32_t>(1));\n+  }\n+\n+  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(counter, 100);\n+}\n+\n+TEST(FutureTest, MapMoveOnlyRvalueOnThreadPoolExecutor) {\n+  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+\n+  std::vector<Future<>> mapped;\n+  std::atomic<int32_t> counter = 0;\n+\n+  {  // Create mapped future in a nested scope to make sure that `promise` and\n+    // `future` are destroyed before the end of the test.\n+    for (size_t i = 0; i < 100; ++i) {\n+      auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+      mapped.push_back(std::move(future).Map(\n+          *thread_pool.AsExecutor(),\n+          [&](std::unique_ptr<int32_t> value) { counter += *value; }));\n+      promise.Set(std::make_unique<int32_t>(1));\n+    }\n+  }\n+\n+  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(counter, 100);\n+}\n+\n //===----------------------------------------------------------------------===//\n // Performance benchmarks.\n //===----------------------------------------------------------------------===//"
        }
    ],
    "stats": {
        "total": 269,
        "additions": 230,
        "deletions": 39
    }
}