{
    "author": "tensorflower-gardener",
    "message": "[XLA:GPU cleanup] Remove unused _xla_send_recv_validation frontend attribute.\n\nPiperOrigin-RevId: 842951517",
    "sha": "1c9d10e7967d37c36c499ea0c030b0a41632e790",
    "files": [
        {
            "sha": "52beaae671e8371aebf39cb93b8864f2a0f53493",
            "filename": "third_party/xla/xla/backends/gpu/runtime/p2p_thunk_common.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 31,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fp2p_thunk_common.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fp2p_thunk_common.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fp2p_thunk_common.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -127,30 +127,8 @@ P2PConfig GetP2PConfigForSendRecv(const HloSendRecvInstruction* instr,\n   }\n \n   std::vector<ReplicaGroup> replica_groups = statusor.value();\n-  auto validation_it =\n-      instr->frontend_attributes().map().find(kSendRecvValidationAttr);\n   P2PConfig::ValidationKind validation_kind = P2PConfig::ValidationKind::kValid;\n-  std::vector<ReplicaGroup> bounds;\n-  if (validation_it != instr->frontend_attributes().map().end()) {\n-    if (validation_it->second == \"invalid\") {\n-      validation_kind = P2PConfig::ValidationKind::kInvalid;\n-    } else {\n-      auto statusor_bounds = ParseReplicaGroupsOnly(validation_it->second);\n-      if (!statusor_bounds.ok() ||\n-          statusor_bounds.value().size() != replica_groups.size()) {\n-        // Ignore problems related to the source-target-pair string to avoid\n-        // using absl::StatusOr for the return type.\n-        return p2p_config;\n-      }\n-      validation_kind = P2PConfig::ValidationKind::kConditional;\n-      bounds = statusor_bounds.value();\n-    }\n-  }\n-\n-  int i = 0;\n   p2p_config.validation_kind = validation_kind;\n-  P2PConfig::SourceTargetToBounds& source_target_to_bounds =\n-      p2p_config.source_target_to_bounds;\n   for (const ReplicaGroup& replica_group : replica_groups) {\n     int64_t source = replica_group.replica_ids(0);\n     int64_t target = replica_group.replica_ids(1);\n@@ -159,15 +137,6 @@ P2PConfig GetP2PConfigForSendRecv(const HloSendRecvInstruction* instr,\n         source;\n     p2p_config.id_to_source_target.insert({source, {}}).first->second.target =\n         target;\n-\n-    if (validation_kind == P2PConfig::ValidationKind::kConditional) {\n-      const ReplicaGroup& bound = bounds[i];\n-      int64_t lower = bound.replica_ids(0);\n-      int64_t upper = bound.replica_ids(1);\n-      source_target_to_bounds[std::make_pair(source, target)] =\n-          std::make_pair(lower, upper);\n-      i++;\n-    }\n   }\n \n   return p2p_config;"
        },
        {
            "sha": "adaa3acc37ac49b054c5f1e45401739e9e4078c5",
            "filename": "third_party/xla/xla/service/collective_ops_utils.h",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_ops_utils.h?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -296,27 +296,6 @@ inline bool MayPipelineSendRecvChannel(int64_t channel_id) {\n // Send or Recv. For all other cases, asynchronous stream kP2P0 is used.\n constexpr char kSendRecvPipelineAttr[] = \"_xla_send_recv_pipeline\";\n \n-// This frontend attribute conveys the following information:\n-// (1) _xla_send_recv_validation=\"invalid\": the runtime should skip sending or\n-// receiving data when the instruction is executed.\n-// (2) the absent of the attribute: the runtime should faithfully perform the\n-// Send or Recv operation when the instruction is executed.\n-// (3) _xla_send_recv_validation={list-of-bounds}: the list-of-bounds\n-// corresponds to the value of _xla_send_recv_source_target_pairs, and specifies\n-// the execution instances for which the runtime should faithfully perform the\n-// Send or Recv operation. Here is an example:\n-//   _xla_send_recv_source_target_pairs={{0,1}, {1,2}}\n-//   _xla_send_recv_validation={{2,3}, {5,7}}\n-// The Send or Recv instruction with the above two attributes have the\n-// following semantics:\n-// The communication between device 0 and 1 will only send or receive data\n-// for execution instances 2 and 3 of the instruction on devices 0 and 1.\n-// For execution instances 0, 1, and beyond 3, the runtime should skip sending\n-// or receiving any data.\n-// Similarly, the communication between device 1 and 2 will only send or\n-// receive data on execution instances 5 and 7.\n-constexpr char kSendRecvValidationAttr[] = \"_xla_send_recv_validation\";\n-\n // Attribute to indicate that collective operations should be issued on a\n // dedicated p2p stream. This is a hint and there is no guarantee that this will\n // be honored."
        },
        {
            "sha": "85a04feae596334612690547e821ec0c676862b5",
            "filename": "third_party/xla/xla/service/collective_pipeliner.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 127,
            "changes": 127,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_pipeliner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_pipeliner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_pipeliner.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -1636,24 +1636,6 @@ HloInstruction* CreateZero(HloComputation* comp, const Shape& shape,\n \n }  // namespace\n \n-using Interval = std::pair<int64_t, int64_t>;\n-using Intervals = std::vector<Interval>;\n-// Parses a string \"{{a,b},{c,d},{e,f},...}\" to a vector of pairs.\n-absl::StatusOr<std::vector<Interval>> ParseVectorOfPairs(\n-    absl::string_view str) {\n-  TF_ASSIGN_OR_RETURN(std::vector<ReplicaGroup> replica_groups,\n-                      ParseReplicaGroupsOnly(str));\n-  std::vector<Interval> res;\n-  res.reserve(replica_groups.size());\n-  for (const ReplicaGroup& replica_group : replica_groups) {\n-    TF_RET_CHECK(replica_group.replica_ids_size() == 2);\n-    int64_t a = replica_group.replica_ids(0);\n-    int64_t b = replica_group.replica_ids(1);\n-    res.emplace_back(a, b);\n-  }\n-  return res;\n-}\n-\n // If there is a collective-permute instruction with _xla_send_recv_validation\n // attribute in the computation, then during pipelining the loop trip count\n // changes. This function fixes the attribute for the cloned instruction.\n@@ -1680,87 +1662,6 @@ absl::StatusOr<std::vector<Interval>> ParseVectorOfPairs(\n // attribute will become {{1,0},{1,0},{1,0},{0,0},{0,0}} and for the collective\n // inside while loop, this attribute will become\n // {{0,4},{0,4},{1,5},{1,5},{2,5}}.\n-absl::Status UpdateSendRecvValidation(\n-    HloInstruction* instruction, bool is_peeled,\n-    collective_pipeliner_utils::PipeliningDirection direction,\n-    const WhileLoopAnalysis& loop_analysis) {\n-  if (instruction->opcode() != HloOpcode::kCollectivePermute) {\n-    return absl::OkStatus();\n-  }\n-  const auto& frontend_attributes = instruction->frontend_attributes().map();\n-  if (!frontend_attributes.contains(kSendRecvValidationAttr)) {\n-    return absl::OkStatus();\n-  }\n-  VLOG(3) << \"Trip count = \"\n-          << loop_analysis.GetLoopIterationCount()->GetSignedValue();\n-  VLOG(3) << \"Collective permute with _xla_send_recv_validation: \"\n-          << instruction->ToString();\n-  TF_ASSIGN_OR_RETURN(\n-      Intervals old_intervals,\n-      ParseVectorOfPairs(frontend_attributes.at(kSendRecvValidationAttr)));\n-\n-  Intervals intervals;\n-\n-  if (direction == collective_pipeliner_utils::PipeliningDirection::kForward) {\n-    // It is a forward pipelining which means that the peeled collective permute\n-    // is before the loop. It should run once for the devices executing the\n-    // first iteration and the internal collective permute now sees each\n-    // original iteration decreased by one.\n-    //\n-    // peeled collective permute:\n-    //      {{0,0} if {a,b} in old and a<=0<=b, {1,0} otherwise}\n-    // internal collective permute: {{max(0, a-1), max(0, b-1)} | {a,b} in old}\n-    for (auto [a, b] : old_intervals) {\n-      if (is_peeled) {\n-        if (a <= 0 && 0 <= b) {\n-          intervals.push_back({0, 0});\n-        } else {\n-          intervals.push_back({1, 0});\n-        }\n-      } else {\n-        intervals.push_back(\n-            {std::max(int64_t{0}, a - 1), std::max(int64_t{0}, b - 1)});\n-      }\n-    }\n-  } else if (direction ==\n-             collective_pipeliner_utils::PipeliningDirection::kBackward) {\n-    // It is a backward pipelining which means that the peeled collective is\n-    // after the loop. It should run once for the devices executing the last\n-    // iteration and the internal collective permute doesn't see the last\n-    // iteration.\n-    //\n-    // peeled collective permute:\n-    //      {{0,0} if {a,b} in old and a<=n<=b where n=#last_iteration, {1,0}\n-    //      otherwise}\n-    // interval collective permute:\n-    //      {{a,min(n-1,b)} | {a,b} in old and n=#last_iteration}\n-    auto trip_count_value = loop_analysis.GetLoopIterationCount();\n-    if (!trip_count_value) {\n-      return absl::InternalError(\n-          \"Unable to deduce loop trip count in collective pipeliner. This is \"\n-          \"required for backward pipelining while fixing the \"\n-          \"_xla_send_recv_validation attribute\");\n-    }\n-    int64_t trip_count = trip_count_value->GetSignedValue();\n-    int64_t last_iteration = trip_count - 1;\n-    for (auto [a, b] : old_intervals) {\n-      if (is_peeled) {\n-        if (a <= last_iteration && last_iteration <= b) {\n-          intervals.push_back({0, 0});\n-        } else {\n-          intervals.push_back({1, 0});\n-        }\n-      } else {\n-        intervals.push_back({a, std::min(last_iteration - 1, b)});\n-      }\n-    }\n-  }\n-  hlo_instruction_utils::AddOrUpdateVectorOfPairsAsAttribute(\n-      instruction, kSendRecvValidationAttr, intervals);\n-  VLOG(3) << \"Updated collective_permute with _xla_send_recv_validation: \"\n-          << instruction->ToString();\n-  return absl::OkStatus();\n-}\n \n // Function that does the work of pushing forward instructions that have been\n // determined that can be pipelined. Rough transformation:\n@@ -1923,12 +1824,6 @@ absl::Status TransformLoopForward(\n       TF_RETURN_IF_ERROR(UpdateInstructionSchedulingAnnotation(\n           cloned_instr, next_scheduling_id, annotation_map));\n     }\n-    // TODO(b/398891001): Remove this once we have eliminated the need for\n-    // send/recv validation.\n-    TF_RETURN_IF_ERROR(UpdateSendRecvValidation(\n-        cloned_instr, true,\n-        collective_pipeliner_utils::PipeliningDirection::kForward,\n-        loop_analysis));\n     while_body_to_peeled[instr] = cloned_instr;\n     auto output_it = is_output_instruction.find(instr);\n     if (output_it != is_output_instruction.end()) {\n@@ -1992,14 +1887,6 @@ absl::Status TransformLoopForward(\n   HloComputation* new_while_body =\n       loop_computation->parent()->AddEmbeddedComputation(\n           while_body->CloneWithReplacements(&replacements));\n-  for (HloInstruction* instruction : new_while_body->instructions()) {\n-    // TODO(b/398891001): Remove this once we have eliminated the need for\n-    // send/recv validation.\n-    TF_RETURN_IF_ERROR(UpdateSendRecvValidation(\n-        instruction, false,\n-        collective_pipeliner_utils::PipeliningDirection::kForward,\n-        loop_analysis));\n-  }\n   HloInstruction* new_init = loop_computation->AddInstruction(\n       HloInstruction::CreateTuple(new_init_operands));\n   while_body_to_peeled[while_body->root_instruction()] = new_init;\n@@ -3150,14 +3037,6 @@ static absl::Status TransformLoopBackward(\n   TF_RETURN_IF_ERROR(UpdateControlDependencies(while_body->root_instruction(),\n                                                new_loop_root,\n                                                while_body_replacement_map));\n-  for (HloInstruction* instruction : new_while_body->instructions()) {\n-    // TODO(b/398891001): Remove this once we have eliminated the need for\n-    // send/recv validation.\n-    TF_RETURN_IF_ERROR(UpdateSendRecvValidation(\n-        instruction, false,\n-        collective_pipeliner_utils::PipeliningDirection::kBackward,\n-        loop_analysis));\n-  }\n   auto cond_builder =\n       HloComputation::Builder(while_loop->while_condition()->name());\n   HloInstruction* new_cond_param =\n@@ -3244,12 +3123,6 @@ static absl::Status TransformLoopBackward(\n                                update_collective_channel_id);\n     TF_RETURN_IF_ERROR(UpdateInstructionSchedulingAnnotation(\n         cloned_instr, next_scheduling_id, annotation_map));\n-    // TODO(b/398891001): Remove this once we have eliminated the need for\n-    // send/recv validation.\n-    TF_RETURN_IF_ERROR(UpdateSendRecvValidation(\n-        cloned_instr, true,\n-        collective_pipeliner_utils::PipeliningDirection::kBackward,\n-        loop_analysis));\n     while_body_replacement_map[instr] = cloned_instr;\n     if (instruction_is_output_it != is_output_instruction.end()) {\n       for (int64_t index : instruction_is_output_it->second) {"
        },
        {
            "sha": "7b01e0d9fdd61e7f3df4ac83046ad1dfa627c982",
            "filename": "third_party/xla/xla/service/collective_pipeliner_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 16,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_pipeliner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_pipeliner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcollective_pipeliner_test.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -352,8 +352,7 @@ while_body {\n   get-tuple-element.394 = s32[] get-tuple-element(param), index=0\n   get-tuple-element.395 = bf16[3,8,128] get-tuple-element(param), index=1\n   get-tuple-element.5 = bf16[3,8,128] get-tuple-element(param), index=2\n-  cp = bf16[3,8,128] collective-permute(get-tuple-element.5), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,0}},\n-                     frontend_attributes={_xla_send_recv_validation=\"{{0,6},{1,7},{2,8},{3,9},{4,10},{5,11},{6,12},{7,13}}\"}\n+  cp = bf16[3,8,128] collective-permute(get-tuple-element.5), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,0}}\n   constant.2557 = s32[] constant(1)\n   add.230 = s32[] add(get-tuple-element.394, constant.2557)\n   constant.2559 = s32[] constant(14)\n@@ -388,14 +387,14 @@ ENTRY entry {\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: HloModule\n     // CHECK: %while_body\n-    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}_xla_send_recv_validation={{[{]}}{0,5},{0,6},{1,7},{2,8},{3,9},{4,10},{5,11},{6,12}{{[}]}}\n+    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}})\n     // CHECK:   %[[dus:.+]] = {{.+}} dynamic-slice({{.*}}%[[cp]], {{.*}})\n     // CHECK:   %[[mul:.+]] = {{.+}} multiply({{.*}}%[[dus]], {{.*}}%[[dus]])\n     // CHECK:   %[[dus2:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[mul]], {{.*}})\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[dus2]], {{.*}})\n     // CHECK: }\n     // CHECK: ENTRY %entry\n-    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}{_xla_send_recv_validation={{[{]}}{0,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0}{{[}]}}\n+    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}})\n     // CHECK:   %[[ds:.+]] = {{.+}} dynamic-slice({{.*}}%[[cp]], {{.*}})\n     // CHECK:   %[[mul:.+]] = {{.+}} multiply({{.*}}%[[ds]], {{.*}}%[[ds]])\n     // CHECK:   %[[dus:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[mul]], {{.*}})\n@@ -428,8 +427,7 @@ while_body {\n   get-tuple-element.394 = s32[] get-tuple-element(param), index=0\n   get-tuple-element.395 = bf16[3,8,128] get-tuple-element(param), index=1\n   get-tuple-element.5 = bf16[3,8,128] get-tuple-element(param), index=2\n-  cp = bf16[3,8,128] collective-permute(get-tuple-element.5), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}},\n-                     frontend_attributes={_xla_send_recv_validation=\"{{7,13},{6,12},{5,11},{4,10},{3,9},{2,8},{1,7},{0,6}}\"}\n+  cp = bf16[3,8,128] collective-permute(get-tuple-element.5), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}}\n   constant.2557 = s32[] constant(1)\n   add.230 = s32[] add(get-tuple-element.394, constant.2557)\n   constant.2559 = s32[] constant(14)\n@@ -464,14 +462,14 @@ ENTRY entry {\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: HloModule\n     // CHECK: %while_body\n-    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}_xla_send_recv_validation={{[{]}}{6,12},{5,11},{4,10},{3,9},{2,8},{1,7},{0,6},{0,5}{{[}]}}\n+    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}})\n     // CHECK:   %[[dus:.+]] = {{.+}} dynamic-slice({{.*}}%[[cp]], {{.*}})\n     // CHECK:   %[[mul:.+]] = {{.+}} multiply({{.*}}%[[dus]], {{.*}}%[[dus]])\n     // CHECK:   %[[dus2:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[mul]], {{.*}})\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[dus2]], {{.*}})\n     // CHECK: }\n     // CHECK: ENTRY %entry\n-    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}{_xla_send_recv_validation={{[{]}}{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{0,0}{{[}]}}\n+    // CHECK:   %[[cp:.+]] = {{.+}} collective-permute({{.+}})\n     // CHECK:   %[[ds:.+]] = {{.+}} dynamic-slice({{.*}}%[[cp]], {{.*}})\n     // CHECK:   %[[mul:.+]] = {{.+}} multiply({{.*}}%[[ds]], {{.*}}%[[ds]])\n     // CHECK:   %[[dus:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[mul]], {{.*}})\n@@ -1995,8 +1993,7 @@ while_body {\n   get-tuple-element.394 = s32[] get-tuple-element(param), index=0\n   get-tuple-element.395 = bf16[3,8,128] get-tuple-element(param), index=1\n   get-tuple-element.k = bf16[3,1,2,128] get-tuple-element(param), index=2\n-  cp = bf16[3,8,128] collective-permute(get-tuple-element.395), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,0}},\n-                     frontend_attributes={_xla_send_recv_validation=\"{{0,6},{1,7},{2,8},{3,9},{4,10},{5,11},{6,12},{7,13}}\"}\n+  cp = bf16[3,8,128] collective-permute(get-tuple-element.395), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,0}}\n   constant.2561 = s32[] constant(0)\n   constant.2557 = s32[] constant(1)\n   add.230 = s32[] add(get-tuple-element.394, constant.2557)\n@@ -2041,13 +2038,13 @@ ENTRY entry {\n   XLA_VLOG_LINES(1, module->ToString());\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n   // CHECK: %while_body\n-  // CHECK: %[[cp:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}_xla_send_recv_validation={{[{]}}{0,6},{1,7},{2,8},{3,9},{4,10},{5,11},{6,12},{7,12}{{[}]}}}\n+  // CHECK: %[[cp:.+]] = {{.+}} collective-permute({{.+}})\n   // CHECK: %[[dus:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[cp]], {{.*}})\n   // CHECK: ROOT {{.+}} = {{.+}} tuple({{.*}}%[[dus]], {{.*}})\n   // CHECK: ENTRY %entry\n   // CHECK: %[[while:.+]] = {{.+}} while({{.*}})\n   // CHECK: %[[gte:.+]] = {{.+}} get-tuple-element({{.*}}%[[while]]), index=1\n-  // CHECK: %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[gte]]), {{.+}}_xla_send_recv_validation={{[{]}}{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{0,0}{{[}]}}\n+  // CHECK: %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[gte]])\n   // CHECK: %[[dus:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[cp2]], {{.*}})\n   // CHECK: %[[tuple:.+]] = {{.+}} tuple({{.*}}%[[dus]], {{.*}})\n   // CHECK: ROOT {{.+}} = {{.+}} get-tuple-element({{.*}}%[[tuple]]), index=1\n@@ -2074,8 +2071,7 @@ while_body {\n   get-tuple-element.394 = s32[] get-tuple-element(param), index=0\n   get-tuple-element.395 = bf16[3,8,128] get-tuple-element(param), index=1\n   get-tuple-element.k = bf16[3,1,2,128] get-tuple-element(param), index=2\n-  cp = bf16[3,8,128] collective-permute(get-tuple-element.395), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}},\n-                     frontend_attributes={_xla_send_recv_validation=\"{{7,13},{6,12},{5,11},{4,10},{3,9},{2,8},{1,7},{0,6}}\"}\n+  cp = bf16[3,8,128] collective-permute(get-tuple-element.395), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}}\n   constant.2561 = s32[] constant(0)\n   constant.2557 = s32[] constant(1)\n   add.230 = s32[] add(get-tuple-element.394, constant.2557)\n@@ -2120,13 +2116,13 @@ ENTRY entry {\n   XLA_VLOG_LINES(1, module->ToString());\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n   // CHECK: %while_body\n-  // CHECK: %[[cp:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}_xla_send_recv_validation={{[{]}}{7,12},{6,12},{5,11},{4,10},{3,9},{2,8},{1,7},{0,6}{{[}]}}}\n+  // CHECK: %[[cp:.+]] = {{.+}} collective-permute({{.+}})\n   // CHECK: %[[dus:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[cp]], {{.*}})\n   // CHECK: ROOT {{.+}} = {{.+}} tuple({{.*}}%[[dus]], {{.*}})\n   // CHECK: ENTRY %entry\n   // CHECK: %[[while:.+]] = {{.+}} while({{.+}})\n   // CHECK: %[[gte:.+]] = {{.+}} get-tuple-element({{.*}}%[[while]]), index=1\n-  // CHECK: %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[gte]]), {{.+}}_xla_send_recv_validation={{[{]}}{0,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0}{{[}]}}\n+  // CHECK: %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[gte]])\n   // CHECK: %[[dus:.+]] = {{.+}} dynamic-update-slice({{.*}}%[[cp2]], {{.*}})\n   // CHECK: %[[tuple:.+]] = {{.+}} tuple({{.*}}%[[dus]], {{.*}})\n   // CHECK: ROOT {{.+}} = {{.+}} get-tuple-element({{.*}}%[[tuple]]), index=1"
        },
        {
            "sha": "2bd05f3b369ee6c0c8d76e4b8d4936d50870c17e",
            "filename": "third_party/xla/xla/service/gpu/transforms/collectives/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2FBUILD?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -593,7 +593,6 @@ cc_library(\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/hlo/utils:hlo_query\",\n         \"//xla/service:collective_ops_utils\",\n-        \"//xla/service:source_target_pairs\",\n         \"//xla/service/gpu:backend_configs_cc\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\","
        },
        {
            "sha": "5c64c8a8d40c6649f248ed4d62c9b96c8ab155b4",
            "filename": "third_party/xla/xla/service/gpu/transforms/collectives/collective_permute_cycle_decomposer.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 20,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2Fcollective_permute_cycle_decomposer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2Fcollective_permute_cycle_decomposer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2Fcollective_permute_cycle_decomposer.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -38,7 +38,6 @@ limitations under the License.\n #include \"xla/literal_util.h\"\n #include \"xla/service/collective_ops_utils.h\"\n #include \"xla/service/gpu/backend_configs.pb.h\"\n-#include \"xla/service/source_target_pairs.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/platform/errors.h\"\n@@ -142,29 +141,11 @@ std::pair<CycleType, std::set<int>> GetCycleTypeAndIndicesArray(\n   return GetCycleTypeAndIndices(pairs);\n }\n \n-// Copies the frontend attributes from the original CP and splits the\n-// _xla_send_recv_validation attribute;\n+// Copies the frontend attributes from the original CP.\n absl::StatusOr<std::pair<FrontendAttributes, FrontendAttributes>>\n DecomposeFrontendAttributes(const FrontendAttributes& orig,\n                             const CycleType cycle_type) {\n   FrontendAttributes attr1 = orig, attr2 = orig;\n-  auto it = orig.map().find(kSendRecvValidationAttr);\n-  if (it == orig.map().end() || it->second == \"invalid\") {\n-    return std::make_pair(attr1, attr2);\n-  }\n-\n-  TF_ASSIGN_OR_RETURN(SourceTargetPairs bounds,\n-                      SourceTargetPairs::FromString(it->second));\n-  int64_t num_pairs = bounds.size();\n-  if (num_pairs < 2) {\n-    return Internal(\"Invalid number of replica groups\");\n-  }\n-\n-  // TODO: b/391377472 - this also need to be able to work with multiple cycles.\n-  auto [cp1_bounds, cp2_bounds] =\n-      collective_permute_cycle::SplitEdges(bounds, cycle_type);\n-  (*attr1.mutable_map())[kSendRecvValidationAttr] = cp1_bounds.ToString();\n-  (*attr2.mutable_map())[kSendRecvValidationAttr] = cp2_bounds.ToString();\n   return std::make_pair(attr1, attr2);\n }\n "
        },
        {
            "sha": "e05dcb487bb7245ea076b99db778c5951e75c9a4",
            "filename": "third_party/xla/xla/service/gpu/transforms/collectives/collective_permute_cycle_decomposer_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 16,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2Fcollective_permute_cycle_decomposer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2Fcollective_permute_cycle_decomposer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fcollectives%2Fcollective_permute_cycle_decomposer_test.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -112,7 +112,6 @@ TEST_F(CollectivePermuteCycleDecomposerTest, ForwardCycle) {\n       p = u32[8,8] parameter(0)\n       ROOT start = u32[8,8] collective-permute(p), channel_id=1,\n         source_target_pairs={{0,1},{1,2},{2,3},{3,0}},\n-        frontend_attributes={_xla_send_recv_validation=\"{{0,7},{1,8},{2,9},{3,10}}\"},\n         metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n     }\n   )\";\n@@ -126,10 +125,10 @@ TEST_F(CollectivePermuteCycleDecomposerTest, ForwardCycle) {\n     // CHECK-DAG:   %{{.+}} = u32[8,8] parameter(0)\n \n     // CHECK-DAG:   %[[cp1:.+]] = u32[8,8] collective-permute(%{{.+}}), channel_id=1,\n-    // CHECK-SAME{LITERAL}: source_target_pairs={{3,0}}, frontend_attributes={_xla_send_recv_validation={{3,10}}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n+    // CHECK-SAME{LITERAL}: source_target_pairs={{3,0}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n \n     // CHECK-DAG:   %[[cp2:.+]] = u32[8,8] collective-permute(%{{.+}}), channel_id=2,\n-    // CHECK-SAME{LITERAL}: source_target_pairs={{0,1},{1,2},{2,3}}, frontend_attributes={_xla_send_recv_validation={{0,7},{1,8},{2,9}}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n+    // CHECK-SAME{LITERAL}: source_target_pairs={{0,1},{1,2},{2,3}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n \n     // CHECK-DAG:   ROOT %{{.+}} = u32[8,8] select(%[[compare]], %[[cp1]], %[[cp2]])\n     // CHECK-DAG: }\n@@ -220,8 +219,7 @@ TEST_F(CollectivePermuteCycleDecomposerTest, ForwardCycleWithMatmul) {\n     weights = f32[2,2] get-tuple-element(param), index=2\n     cp = f32[2,2] collective-permute(data),\n       channel_id=1,\n-      source_target_pairs={{0,1}, {1,2}, {2,3}, {3,0}},\n-      frontend_attributes={_xla_send_recv_validation=\"{{0,7},{1,8},{2,9},{3,10}}\"}\n+      source_target_pairs={{0,1}, {1,2}, {2,3}, {3,0}}\n     matmul = f32[2,2] dot(weights, cp), lhs_contracting_dims={1}, rhs_contracting_dims={0}\n     iter_increment = u32[] constant(1)\n     next_iter = u32[] add(iter, iter_increment)\n@@ -241,12 +239,8 @@ TEST_F(CollectivePermuteCycleDecomposerTest, ForwardCycleWithMatmul) {\n   Decomposed deco = FindComponents(module.get(), \"cp\");\n   EXPECT_THAT(deco.cp_bwd->ToString(),\n               HasSubstr(\"source_target_pairs={{3,0}}\"));\n-  EXPECT_THAT(deco.cp_bwd->ToString(),\n-              HasSubstr(\"_xla_send_recv_validation={{3,10}}\"));\n   EXPECT_THAT(deco.cp_fwd->ToString(),\n               HasSubstr(\"source_target_pairs={{0,1},{1,2},{2,3}}\"));\n-  EXPECT_THAT(deco.cp_fwd->ToString(),\n-              HasSubstr(\"_xla_send_recv_validation={{0,7},{1,8},{2,9}}\"));\n }\n \n TEST_F(CollectivePermuteCycleDecomposerTest, BackwardCycle) {\n@@ -260,7 +254,6 @@ TEST_F(CollectivePermuteCycleDecomposerTest, BackwardCycle) {\n       p = u32[8,8] parameter(0)\n       ROOT start = u32[8,8] collective-permute(p), channel_id=1,\n         source_target_pairs={{0,3},{1,0},{2,1},{3,2}},\n-        frontend_attributes={_xla_send_recv_validation=\"{{0,7},{1,8},{2,9},{3,10}}\"},\n         metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n     })\";\n \n@@ -274,10 +267,10 @@ TEST_F(CollectivePermuteCycleDecomposerTest, BackwardCycle) {\n     // CHECK-DAG:   %{{.+}} = u32[8,8] parameter(0)\n \n     // CHECK-DAG:   %[[cp1:.+]] = u32[8,8] collective-permute(%{{.+}}), channel_id=1, source_target_pairs=\n-    // CHECK-SAME{LITERAL}: {{0,3}}, frontend_attributes={_xla_send_recv_validation={{0,7}}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n+    // CHECK-SAME{LITERAL}: {{0,3}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n \n     // CHECK-DAG:   %[[cp2:.+]] = u32[8,8] collective-permute(%{{.+}}), channel_id=2, source_target_pairs=\n-    // CHECK-SAME{LITERAL}: {{1,0},{2,1},{3,2}}, frontend_attributes={_xla_send_recv_validation={{1,8},{2,9},{3,10}}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n+    // CHECK-SAME{LITERAL}: {{1,0},{2,1},{3,2}}, metadata={op_name=\"op1/op2/add\" source_file=\"foo/bar/mysource.py\" source_line=35}\n \n     // CHECK-DAG:   ROOT %{{.+}} = u32[8,8] select(%[[compare]], %[[cp1]], %[[cp2]])\n     // CHECK-DAG: }\n@@ -293,8 +286,7 @@ TEST_F(CollectivePermuteCycleDecomposerTest, BackwardCycleNoChannel) {\n     ENTRY test_computation {\n       p = u32[8,8] parameter(0)\n       ROOT start = u32[8,8] collective-permute(p),\n-        source_target_pairs={{0,3},{1,0},{2,1},{3,2}},\n-        frontend_attributes={_xla_send_recv_validation=\"{{0,7},{1,8},{2,9},{3,10}}\"}\n+        source_target_pairs={{0,3},{1,0},{2,1},{3,2}}\n     })\";\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n@@ -307,10 +299,10 @@ TEST_F(CollectivePermuteCycleDecomposerTest, BackwardCycleNoChannel) {\n     // CHECK-DAG:   %{{.+}} = u32[8,8] parameter(0)\n \n     // CHECK-DAG:   %[[cp1:.+]] = u32[8,8] collective-permute(%{{.+}}), source_target_pairs=\n-    // CHECK-SAME{LITERAL}: {{0,3}}, frontend_attributes={_xla_send_recv_validation={{0,7}}}\n+    // CHECK-SAME{LITERAL}: {{0,3}}\n \n     // CHECK-DAG:   %[[cp2:.+]] = u32[8,8] collective-permute(%{{.+}}), source_target_pairs=\n-    // CHECK-SAME{LITERAL}: {{1,0},{2,1},{3,2}}, frontend_attributes={_xla_send_recv_validation={{1,8},{2,9},{3,10}}}\n+    // CHECK-SAME{LITERAL}: {{1,0},{2,1},{3,2}}\n \n     // CHECK-DAG:   ROOT %{{.+}} = u32[8,8] select(%[[compare]], %[[cp1]], %[[cp2]])\n     // CHECK-DAG: }"
        },
        {
            "sha": "589633cef66afd1b459275944535489d20273543",
            "filename": "third_party/xla/xla/service/gpu/transforms/double_buffer_loop_unrolling.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 120,
            "changes": 120,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fdouble_buffer_loop_unrolling.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fdouble_buffer_loop_unrolling.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fdouble_buffer_loop_unrolling.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -88,70 +88,12 @@ void SetChannelIdForNewCollective(HloInstruction* new_instr,\n \n using Interval = std::pair<int64_t, int64_t>;\n \n-// Parses a string of the format `{{a,b},{c,d},{e,f}...}` to a vector of pairs.\n-absl::StatusOr<std::vector<Interval>> ParseVectorOfPairs(\n-    absl::string_view str) {\n-  TF_ASSIGN_OR_RETURN(std::vector<ReplicaGroup> replica_groups,\n-                      ParseReplicaGroupsOnly(str));\n-  std::vector<Interval> res;\n-  res.reserve(replica_groups.size());\n-  for (const ReplicaGroup& replica_group : replica_groups) {\n-    TF_RET_CHECK(replica_group.replica_ids_size() == 2);\n-    int64_t a = replica_group.replica_ids(0);\n-    int64_t b = replica_group.replica_ids(1);\n-    res.emplace_back(a, b);\n-  }\n-  return res;\n-}\n-\n // This function fixes the `_xla_send_recv_validation` attribute for peeled\n // instructions. When the loop trip count is odd, the peeled instructions are\n // moved before the loop. The collectives in these instructions correspond to\n // the first iteration of the original loop. We have to run this peeled\n // collective for all those devices that had the 0-th iteration as a valid\n // iteration.\n-absl::Status SetSendRecvValidationForPeeledInstr(HloInstruction* new_instr,\n-                                                 HloInstruction* old_instr) {\n-  TF_RET_CHECK(\n-      new_instr->opcode() == old_instr->opcode() &&\n-      \"cloned instruction and original instruction have different opcodes\");\n-  if (HloPredicateIsNotOp<HloOpcode::kCollectivePermute,\n-                          HloOpcode::kCollectivePermuteStart, HloOpcode::kSend,\n-                          HloOpcode::kRecv>(old_instr)) {\n-    return absl::OkStatus();\n-  }\n-\n-  const auto& attribute_map = new_instr->frontend_attributes().map();\n-  if (!attribute_map.contains(kSendRecvValidationAttr)) {\n-    return absl::OkStatus();\n-  }\n-\n-  VLOG(3) << \"Original send-recv iterations: \"\n-          << attribute_map.at(kSendRecvValidationAttr);\n-\n-  TF_ASSIGN_OR_RETURN(\n-      auto send_recv_validation_attr,\n-      ParseVectorOfPairs(attribute_map.at(kSendRecvValidationAttr)));\n-\n-  uint64_t n_pairs = send_recv_validation_attr.size();\n-  if (n_pairs == 0) {\n-    return absl::OkStatus();\n-  }\n-  std::vector<Interval> send_recv_validation_attr_updated(n_pairs, {1, 0});\n-  // Check which of the attributes have iteration number zero as valid\n-  // iteration. For all those, set the peeled instruction to run.\n-  for (std::uint64_t i = 0; i < send_recv_validation_attr.size(); i++) {\n-    if (send_recv_validation_attr[i].first <= 0 &&\n-        send_recv_validation_attr[i].second >= 0) {\n-      send_recv_validation_attr_updated[i] = {0, 0};\n-    }\n-  }\n-\n-  hlo_instruction_utils::AddOrUpdateVectorOfPairsAsAttribute(\n-      /*instr=*/new_instr, /*attr_name=*/kSendRecvValidationAttr,\n-      /*intervals=*/send_recv_validation_attr_updated);\n-  return absl::OkStatus();\n-}\n \n // This function fixes the `_xla_send_recv_validation` attribute for the two new\n // collectives inside the loop. The calculation of the new valid iterations\n@@ -180,65 +122,6 @@ absl::Status SetSendRecvValidationForPeeledInstr(HloInstruction* new_instr,\n //\n // In a similar fashion we can generalize the computation of new values based on\n // the values of the old attribute as done in the logic below.\n-absl::Status SetSendRecvValidation(HloInstruction* cp1, HloInstruction* cp2,\n-                                   bool is_peeled) {\n-  TF_RET_CHECK(\n-      cp2->opcode() == cp1->opcode() &&\n-      \"cloned instruction and original instruction have different opcodes\");\n-  if (HloPredicateIsNotOp<HloOpcode::kCollectivePermute,\n-                          HloOpcode::kCollectivePermuteStart, HloOpcode::kSend,\n-                          HloOpcode::kRecv>(cp1)) {\n-    return absl::OkStatus();\n-  }\n-  const auto& attribute_map = cp2->frontend_attributes().map();\n-  if (!attribute_map.contains(kSendRecvValidationAttr)) {\n-    return absl::OkStatus();\n-  }\n-  VLOG(3) << \"Original send-recv iterations: \"\n-          << attribute_map.at(kSendRecvValidationAttr);\n-\n-  TF_ASSIGN_OR_RETURN(\n-      auto send_recv_validation_attr,\n-      ParseVectorOfPairs(attribute_map.at(kSendRecvValidationAttr)));\n-\n-  if (send_recv_validation_attr.size() == 0) {\n-    return absl::OkStatus();\n-  }\n-\n-  std::vector<Interval> send_recv_iterations_new_instr1,\n-      send_recv_iterations_new_instr2;\n-  send_recv_iterations_new_instr1.reserve(send_recv_validation_attr.size());\n-  send_recv_iterations_new_instr2.reserve(send_recv_validation_attr.size());\n-  for (const Interval& pair : send_recv_validation_attr) {\n-    int64_t a = pair.first;\n-    int64_t b = pair.second;\n-    if (is_peeled) {\n-      send_recv_iterations_new_instr1.emplace_back(\n-          std::floor(a / 2.0), std::max(0.0, std::floor((b - 1) / 2.0)));\n-      send_recv_iterations_new_instr2.emplace_back(\n-          std::max(0.0, std::floor((a - 1) / 2.0)),\n-          std::max(0.0, std::floor((b - 2) / 2.0)));\n-    } else {\n-      send_recv_iterations_new_instr1.emplace_back(std::floor((a + 1) / 2.0),\n-                                                   std::floor(b / 2.0));\n-      send_recv_iterations_new_instr2.emplace_back(\n-          std::floor(a / 2.0), std::max(0.0, std::floor((b - 1) / 2.0)));\n-    }\n-  }\n-\n-  hlo_instruction_utils::AddOrUpdateVectorOfPairsAsAttribute(\n-      /*instr=*/cp1, /*attr_name=*/kSendRecvValidationAttr,\n-      /*intervals=*/send_recv_iterations_new_instr1);\n-  hlo_instruction_utils::AddOrUpdateVectorOfPairsAsAttribute(\n-      /*instr=*/cp2, /*attr_name=*/kSendRecvValidationAttr,\n-      /*intervals=*/send_recv_iterations_new_instr2);\n-\n-  VLOG(3) << \"Updated send-recv iterations for \" << cp1->name() << \" : \"\n-          << cp1->frontend_attributes().map().at(kSendRecvValidationAttr);\n-  VLOG(3) << \"Updated send-recv iterations for \" << cp2->name() << \" : \"\n-          << cp2->frontend_attributes().map().at(kSendRecvValidationAttr);\n-  return absl::OkStatus();\n-}\n \n // Handle control predecessors/successors for every old-new instruction pair.\n // For every new instruction, we find the relevant predecessor/successor\n@@ -406,7 +289,6 @@ absl::Status PeelInstructionsForOddTripCount(HloModule* module,\n             old_instr->shape(), new_operands, suffix));\n \n     SetChannelIdForNewCollective(new_instr, module);\n-    CHECK_OK(SetSendRecvValidationForPeeledInstr(new_instr, old_instr));\n     old_to_new_map[old_instr] = new_instr;\n     VLOG(2) << \"Added instruction \" << new_instr->ToString()\n             << \" to parent computation.\";\n@@ -498,8 +380,6 @@ absl::StatusOr<bool> DoubleBufferingUnroll(HloInstruction* while_instr,\n       skip_control_dep_injection.insert(old_instr);\n     }\n     SetChannelIdForNewCollective(new_instr, module);\n-    CHECK_OK(SetSendRecvValidation(old_instr, new_instr,\n-                                   /*is_peeled=*/peel_one_iteration));\n     old_to_new_map[old_instr] = new_instr;\n     VLOG(2) << \"Added instruction \" << new_instr->ToString();\n   }"
        },
        {
            "sha": "3c643a3b83a110c61d6ea7d9d2d312be549502b6",
            "filename": "third_party/xla/xla/service/gpu/transforms/double_buffer_loop_unrolling_test.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 30,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fdouble_buffer_loop_unrolling_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fdouble_buffer_loop_unrolling_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fdouble_buffer_loop_unrolling_test.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -1003,8 +1003,7 @@ body {\n   input_tuple = (f32[], s32[]) parameter(0)\n   param_0 = f32[] get-tuple-element(input_tuple), index=0\n   cond = s32[] get-tuple-element(input_tuple), index=1\n-  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,0}},\n-                             frontend_attributes={_xla_send_recv_validation=\"{{0,6},{1,7},{2,8},{3,9}}\"}\n+  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,0}}\n   one = s32[] constant(1)\n   cond_plus_1 = s32[] add(cond, one)\n   ROOT output_tuple = (f32[], s32[]) tuple(collective-permute, cond_plus_1)\n@@ -1026,10 +1025,10 @@ ENTRY main {\n   VLOG(1) << module->ToString();\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body {{.+}} {\n-    // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,3},{1,3},{1,4},{2,4}{{[}]}}}\n+    // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}\n     // CHECK:   %[[out1:.+]] = {{.+}} tuple({{.*}}%[[cp1]], {{.*}})\n     // CHECK:   %[[param2:.+]] = {{.+}} get-tuple-element({{.*}}%[[out1]]), index=0\n-    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[param2]]), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,2},{0,3},{1,3},{1,4}{{[}]}}}\n+    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[param2]]), {{.+}}\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[cp2]], {{.*}})\n     // CHECK: }\n     // CHECK: ENTRY %main {{.+}} {\n@@ -1057,8 +1056,7 @@ body {\n   input_tuple = (f32[], s32[]) parameter(0)\n   param_0 = f32[] get-tuple-element(input_tuple), index=0\n   cond = s32[] get-tuple-element(input_tuple), index=1\n-  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,0}},\n-                             frontend_attributes={_xla_send_recv_validation=\"{{0,7},{1,8},{2,9},{3,10},{4,11},{5,12},{6,13},{7,14}}\"}\n+  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,0}}\n   one = s32[] constant(1)\n   cond_plus_1 = s32[] add(cond, one)\n   ROOT output_tuple = (f32[], s32[]) tuple(collective-permute, cond_plus_1)\n@@ -1080,13 +1078,13 @@ ENTRY main {\n   VLOG(1) << module->ToString();\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body\n-    // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute({{.*}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,3},{0,3},{1,4},{1,4},{2,5},{2,5},{3,6},{3,6}{{[}]}}}\n+    // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute({{.*}}), {{.+}}\n     // CHECK:   %[[out1:.+]] = {{.+}} tuple({{.*}}%[[cp1]], {{.*}})\n     // CHECK:   %[[param2:.+]] = {{.+}} get-tuple-element({{.*}}%[[out1]])\n-    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,2},{0,3},{0,3},{1,4},{1,4},{2,5},{2,5},{3,6}{{[}]}}}\n+    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}), {{.+}}\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[cp2]], {{.*}})\n     // CHECK: ENTRY %main {{.+}} {\n-    // CHECK:   %[[cp_peeled:.+]] = {{.+}} collective-permute({{.*}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0}{{[}]}}}\n+    // CHECK:   %[[cp_peeled:.+]] = {{.+}} collective-permute({{.*}}), {{.+}}\n     // CHECK:   %[[out_peeled:.+]] = {{.+}} tuple({{.*}}%[[cp_peeled]], {{.*}})\n     // CHECK:   %[[while:.+]] = {{.+}} while({{.*}}%[[out_peeled]])\n     // CHECK: }\n@@ -1112,8 +1110,7 @@ body {\n   input_tuple = (f32[], s32[]) parameter(0)\n   param_0 = f32[] get-tuple-element(input_tuple), index=0\n   cond = s32[] get-tuple-element(input_tuple), index=1\n-  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}},\n-                             frontend_attributes={_xla_send_recv_validation=\"{{7,13},{6,12},{5,11},{4,10},{3,9},{2,8},{1,7},{0,6}}\"}\n+  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}}\n   one = s32[] constant(1)\n   cond_plus_1 = s32[] add(cond, one)\n   ROOT output_tuple = (f32[], s32[]) tuple(collective-permute, cond_plus_1)\n@@ -1135,10 +1132,10 @@ ENTRY main {\n \n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body\n-    // CHECK:   %[[cp1:.+]] = f32[] collective-permute(%param_0), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{4,6},{3,6},{3,5},{2,5},{2,4},{1,4},{1,3},{0,3}{{[}]}}}\n+    // CHECK:   %[[cp1:.+]] = f32[] collective-permute(%param_0), {{.+}}\n     // CHECK:   %[[out1:.+]] = {{.+}} tuple({{.*}}%[[cp1]], {{.*}})\n     // CHECK:   %[[param2:.+]] = {{.+}} get-tuple-element({{.*}}%[[out1]]), index=0\n-    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[param2]]), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{3,6},{3,5},{2,5},{2,4},{1,4},{1,3},{0,3},{0,2}{{[}]}}}\n+    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[param2]]), {{.+}}\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[cp2]], {{.*}})\n     // CHECK: ENTRY %main\n     // CHECK-NOT: collective-permute\n@@ -1165,8 +1162,7 @@ body {\n   input_tuple = (f32[], s32[]) parameter(0)\n   param_0 = f32[] get-tuple-element(input_tuple), index=0\n   cond = s32[] get-tuple-element(input_tuple), index=1\n-  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}},\n-                             frontend_attributes={_xla_send_recv_validation=\"{{7,14},{6,13},{5,12},{4,11},{3,10},{2,9},{1,8},{0,7}}\"}\n+  collective-permute = f32[] collective-permute(param_0), channel_id=1, source_target_pairs={{0,7},{1,0},{2,1},{3,2},{4,3},{5,4},{6,5},{7,6}}\n   one = s32[] constant(1)\n   cond_plus_1 = s32[] add(cond, one)\n   ROOT output_tuple = (f32[], s32[]) tuple(collective-permute, cond_plus_1)\n@@ -1188,14 +1184,14 @@ ENTRY main {\n \n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body\n-    // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{3,6},{3,6},{2,5},{2,5},{1,4},{1,4},{0,3},{0,3}{{[}]}}}\n+    // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}\n     // CHECK:   %[[out1:.+]] = {{.+}} tuple({{.*}}%[[cp1]], {{.*}})\n     // CHECK:   %[[param2:.+]] = {{.+}} get-tuple-element({{.*}}%[[out1]]), index=0\n-    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[param2]]), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{3,6},{2,5},{2,5},{1,4},{1,4},{0,3},{0,3},{0,2}{{[}]}}}\n+    // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute({{.*}}%[[param2]]), {{.+}}\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[cp2]], {{.*}})\n     // CHECK: }\n     // CHECK: ENTRY %main\n-    // CHECK:   %[[cp_peeled:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{0,0}{{[}]}}}\n+    // CHECK:   %[[cp_peeled:.+]] = {{.+}} collective-permute({{.+}}), {{.+}}\n     // CHECK:   %[[out_peeled:.+]] = {{.+}} tuple({{.*}}%[[cp_peeled]], {{.*}})\n     // CHECK:   ROOT {{.+}} = {{.+}} while({{.*}}%[[out_peeled]])\n     // CHECK: }\n@@ -1221,8 +1217,7 @@ body {\n   input_tuple = (f32[], s32[]) parameter(0)\n   param_0 = f32[] get-tuple-element(input_tuple), index=0\n   cond = s32[] get-tuple-element(input_tuple), index=1\n-  collective-permute-start = (f32[], f32[], u32[], u32[]) collective-permute-start(param_0), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,0}},\n-                             frontend_attributes={_xla_send_recv_validation=\"{{0,6},{1,7},{2,8},{3,9}}\"}\n+  collective-permute-start = (f32[], f32[], u32[], u32[]) collective-permute-start(param_0), channel_id=1, source_target_pairs={{0,1},{1,2},{2,3},{3,0}}\n   collective-permute = f32[] collective-permute-done(collective-permute-start)\n   one = s32[] constant(1)\n   cond_plus_1 = s32[] add(cond, one)\n@@ -1245,11 +1240,11 @@ ENTRY main {\n \n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body\n-    // CHECK:   %[[cp_start1:.+]] = {{.+}} collective-permute-start({{.+}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,3},{1,3},{1,4},{2,4}{{[}]}}}\n+    // CHECK:   %[[cp_start1:.+]] = {{.+}} collective-permute-start({{.+}}), {{.+}}\n     // CHECK:   %[[cp1:.+]] = {{.+}} collective-permute-done({{.*}}%[[cp_start1]])\n     // CHECK:   %[[out1:.+]] = {{.+}} tuple({{.*}}%[[cp1]], {{.*}})\n     // CHECK:   %[[param2:.+]] = {{.+}} get-tuple-element({{.*}}%[[out1]]), index=0\n-    // CHECK:   %[[cp_start2:.+]] = {{.+}} collective-permute-start({{.*}}), {{.+}}, frontend_attributes={_xla_send_recv_validation={{[{]}}{0,2},{0,3},{1,3},{1,4}{{[}]}}}\n+    // CHECK:   %[[cp_start2:.+]] = {{.+}} collective-permute-start({{.*}}), {{.+}}\n     // CHECK:   %[[cp2:.+]] = {{.+}} collective-permute-done({{.*}}%[[cp_start2]])\n     // CHECK:   ROOT {{.+}} = {{.+}} tuple({{.*}}%[[cp2]], {{.*}})\n     // CHECK: }\n@@ -1281,8 +1276,7 @@ body {\n   recv.0 = (f32[], u32[], token[]) recv(after-all.0), channel_id=1,\n         frontend_attributes={\n           _xla_send_recv_source_target_pairs=\"{{0,1},{1,2},{2,3},{3,0}}\",\n-          _xla_send_recv_pipeline=\"0\",\n-          _xla_send_recv_validation=\"{{0,6},{1,7},{2,8},{3,9}}\"\n+          _xla_send_recv_pipeline=\"0\"\n         }\n   recv-done.0 = (f32[], token[]) recv-done(recv.0), channel_id=1,\n         frontend_attributes={\n@@ -1310,8 +1304,8 @@ ENTRY main {\n \n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body\n-    // CHECK:   %[[recv1:.+]] = {{.+}} recv({{.+}}), {{.+}},_xla_send_recv_validation={{[{]}}{0,3},{1,3},{1,4},{2,4}{{[}]}}\n-    // CHECK:   %[[recv2:.+]] = {{.+}} recv({{.+}}), {{.+}},_xla_send_recv_validation={{[{]}}{0,2},{0,3},{1,3},{1,4}{{[}]}}\n+    // CHECK:   %[[recv1:.+]] = {{.+}} recv({{.+}}), {{.+}}\n+    // CHECK:   %[[recv2:.+]] = {{.+}} recv({{.+}}), {{.+}}\n     // CHECK: ENTRY %main\n     // CHECK-NOT: recv\n     // CHECK: }\n@@ -1340,8 +1334,7 @@ body {\n   send.0 = (f32[], u32[], token[]) send(param_0, after-all.0), channel_id=1,\n         frontend_attributes={\n           _xla_send_recv_source_target_pairs=\"{{0,1},{1,2},{2,3},{3,0}}\",\n-          _xla_send_recv_pipeline=\"0\",\n-          _xla_send_recv_validation=\"{{0,6},{1,7},{2,8},{3,9}}\"\n+          _xla_send_recv_pipeline=\"0\"\n         }\n   send-done.0 = token[] send-done(send.0), channel_id=1,\n         frontend_attributes={\n@@ -1368,8 +1361,8 @@ ENTRY main {\n \n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n     // CHECK: %body\n-    // CHECK:   %[[send1:.+]] = {{.+}} send({{.+}}), {{.+}},_xla_send_recv_validation={{[{]}}{0,3},{1,3},{1,4},{2,4}{{[}]}}\n-    // CHECK:   %[[send2:.+]] = {{.+}} send({{.+}}), {{.+}},_xla_send_recv_validation={{[{]}}{0,2},{0,3},{1,3},{1,4}{{[}]}}\n+    // CHECK:   %[[send1:.+]] = {{.+}} send({{.+}}), {{.+}}\n+    // CHECK:   %[[send2:.+]] = {{.+}} send({{.+}}), {{.+}}\n     // CHECK: ENTRY %main\n     // CHECK-NOT: send\n     // CHECK: }"
        },
        {
            "sha": "e4443bf16350b9b57a276a7427a7601da341b83d",
            "filename": "third_party/xla/xla/service/hlo_verifier.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c9d10e7967d37c36c499ea0c030b0a41632e790/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc?ref=1c9d10e7967d37c36c499ea0c030b0a41632e790",
            "patch": "@@ -2562,16 +2562,13 @@ absl::StatusOr<bool> ShouldSkipDeadlockCheck(const T* instruction) {\n   if (instruction->is_host_transfer()) {\n     return true;\n   }\n-  // TODO: b/441038687 - Remove kSendRecvValidationAttr\n   // TODO: b/441088186 - update static analyzer logic to also handle\n   // instructions annotated with _xla_send_recv_pipeline\n   // For now we will skip checks for instructions annotated with\n-  // _xla_send_recv_pipeline and _xla_send_recv_validation, since they introduce\n-  // extra constraints that have not been modeled by this function.\n+  // _xla_send_recv_pipeline, since they introduce extra constraints that have\n+  // not been modeled by this function.\n   if (instruction->frontend_attributes().map().contains(\n-          kSendRecvPipelineAttr) ||\n-      instruction->frontend_attributes().map().contains(\n-          kSendRecvValidationAttr)) {\n+          kSendRecvPipelineAttr)) {\n     return true;\n   }\n   // Check that the instruction itself does not have conflicting"
        }
    ],
    "stats": {
        "total": 435,
        "additions": 47,
        "deletions": 388
    }
}