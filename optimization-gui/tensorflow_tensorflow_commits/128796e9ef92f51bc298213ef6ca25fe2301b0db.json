{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809685874",
    "sha": "128796e9ef92f51bc298213ef6ca25fe2301b0db",
    "files": [
        {
            "sha": "a7eb423d59ce8542e566bd555f93bc45d8a9626d",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/array.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Farray.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Farray.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Farray.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -442,7 +442,7 @@ Future<> Array::GetReadyFuture() const {\n     return Future<>(absl::InvalidArgumentError(\"Already deleted array.\"));\n   }\n \n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n \n   if (ready_future_.IsValid()) {\n     return ready_future_;\n@@ -462,7 +462,7 @@ Future<> Array::GetReadyFuture() const {\n \n Future<> Array::Delete() {\n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     deleted_ = DeletionState::kDeleted;\n   }\n   if (rpc_helper_->protocol_version() >= 5) {\n@@ -490,7 +490,7 @@ bool Array::IsDeleted() const {\n   tsl::profiler::TraceMe traceme_ifrt_entrypoint(\n       \"IfrtProxyEntrypointIsDeleted\");\n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if (deleted_ == DeletionState::kDeleted) {\n       return true;\n     }\n@@ -507,7 +507,7 @@ bool Array::IsDeleted() const {\n   absl::StatusOr<std::shared_ptr<IsArrayDeletedResponse>> response =\n       rpc_helper_->IsArrayDeleted(std::move(req)).Await();\n   if (response.ok()) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if ((*response)->deleted()) {\n       deleted_ = DeletionState::kDeleted;\n     } else {\n@@ -935,7 +935,7 @@ Future<> Array::CopyToHostBuffer(\n }\n \n absl::StatusOr<std::shared_ptr<const PjRtLayout>> Array::pjrt_layout() const {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   if (custom_layout_ != nullptr) {\n     return custom_layout_;\n   }\n@@ -951,7 +951,7 @@ xla::ifrt::Client* Array::client() const { return client_; }\n std::string Array::DebugString() const {\n   std::string is_deleted;\n   {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     switch (deleted_) {\n       case DeletionState::kUnknown:\n         is_deleted = \"unknown\";"
        },
        {
            "sha": "f1afa4dd6ed52062d208f2cd8965aacda9090ee0",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/array.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Farray.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Farray.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Farray.h?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -115,7 +115,7 @@ class Array final : public llvm::RTTIExtends<Array, xla::ifrt::Array> {\n   ~Array() override { Destruct(rpc_helper_.get(), handle_); }\n \n   absl::StatusOr<ArrayHandle> GetHandle(ArrayCopySemantics semantics) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (deleted_ == DeletionState::kDeleted) {\n       return absl::InvalidArgumentError(\"Array already deleted.\");\n     }\n@@ -132,7 +132,7 @@ class Array final : public llvm::RTTIExtends<Array, xla::ifrt::Array> {\n   // synchronous RPC to the proxy-server. To avoid such performance overhead,\n   // prefer using `GetHandle(semantics)` whenever the semantics are known.\n   absl::StatusOr<ArrayHandle> GetHandleUnknownIfBeingDonated() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (deleted_ == DeletionState::kDeleted) {\n       return absl::InvalidArgumentError(\"Array already deleted.\");\n     }"
        },
        {
            "sha": "74efe7ba6fba5ba8c3ef35b8f9aa739896d3121b",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/client.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fclient.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fclient.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fclient.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -454,7 +454,7 @@ Client::GetDefaultPjRtLayout(xla::ifrt::DType dtype,\n       /*device_summary=*/device_summary(llvm::dyn_cast<Device>(device))};\n \n   {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (auto it = layout_cache_.find(key); it != layout_cache_.end()) {\n       return it->second;\n     }\n@@ -476,7 +476,7 @@ Client::GetDefaultPjRtLayout(xla::ifrt::DType dtype,\n   TF_ASSIGN_OR_RETURN(auto layout, xla::PjRtLayout::Deserialize(\n                                        response->serialized_pjrt_layout()));\n   {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     layout_cache_.insert({key, layout});\n   }\n   return layout;"
        },
        {
            "sha": "dd83add02957686da098c56a1c2a02e46be031f0",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/executable.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -291,7 +291,7 @@ class LoadedExecutable::OutputSpecCache {\n \n   // Returns the cached output spec if already cached, and std::nullopt if not.\n   std::optional<absl::Span<const ArraySpec>> Retrieve() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (!data_.has_value()) {\n       return std::nullopt;\n     }\n@@ -304,7 +304,7 @@ class LoadedExecutable::OutputSpecCache {\n   absl::Status Cache(const tsl::protobuf::RepeatedPtrField<\n                      LoadedExecutableExecuteResponse_Output>& outputs) {\n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       if (data_.has_value()) {\n         return absl::OkStatus();\n       }\n@@ -320,7 +320,7 @@ class LoadedExecutable::OutputSpecCache {\n                                /*sharding=*/std::move(sharding)});\n     }\n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       if (!data_.has_value()) {\n         data_.emplace(std::move(data));\n       }"
        },
        {
            "sha": "d83e40be9f7f3bd28d01f649091f0b34b1f6ef02",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/grpc_client_session.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -59,7 +59,7 @@ namespace proxy {\n class GrpcClientSession::ResponseCallbackTable {\n  public:\n   absl::Status Add(OpId op_id, ResponseCallback callback) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     const bool inserted = table_.insert({op_id, std::move(callback)}).second;\n     if (!inserted) {\n       return absl::AlreadyExistsError(\n@@ -69,7 +69,7 @@ class GrpcClientSession::ResponseCallbackTable {\n   }\n \n   std::optional<ResponseCallback> Pop(OpId op_id) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     auto it = table_.find(op_id);\n     if (it == table_.end()) {\n       return std::nullopt;\n@@ -81,7 +81,7 @@ class GrpcClientSession::ResponseCallbackTable {\n \n   absl::flat_hash_map<OpId, ResponseCallback> PopAll() {\n     absl::flat_hash_map<OpId, ResponseCallback> result;\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     result = std::move(table_);\n     table_ = absl::flat_hash_map<OpId, ResponseCallback>();\n     return result;\n@@ -147,7 +147,7 @@ Future<std::shared_ptr<IfrtResponse>> GrpcClientSession::Enqueue(\n \n absl::Status GrpcClientSession::Enqueue(std::unique_ptr<IfrtRequest> req,\n                                         ResponseCallback callback) {\n-  absl::MutexLock l(&writer_mu_);\n+  absl::MutexLock l(writer_mu_);\n   const OpId op_id = writer_next_op_id_++;\n \n   if (writes_stopped_) {\n@@ -207,7 +207,7 @@ void GrpcClientSession::Finish(const absl::Status& client_status) {\n \n     auto finish_stream_and_get_server_status = [&]() -> absl::Status {\n       LOG(INFO) << \"GrpClientSession: Attempting to call stream->Finish()\";\n-      absl::MutexLock l(&writer_mu_);\n+      absl::MutexLock l(writer_mu_);\n       // Note: stream_->Finish() counts as a write, and needs to be serialized\n       // with stream->Write().\n       LOG(INFO) << \"GrpClientSession: Attempting to call stream->Finish(), \""
        },
        {
            "sha": "69dad0b92966714ab3f39b1c74e828dc0b934547",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/grpc_client_session_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fgrpc_client_session_test.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -132,7 +132,7 @@ class SimpleIfrtService : public grpc::GrpcIfrtService::Service {\n     }\n \n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       CHECK(contexts_.insert(context).second);\n     }\n \n@@ -154,7 +154,7 @@ class SimpleIfrtService : public grpc::GrpcIfrtService::Service {\n       }\n     }\n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       CHECK_EQ(contexts_.erase(context), 1);\n     }\n \n@@ -163,7 +163,7 @@ class SimpleIfrtService : public grpc::GrpcIfrtService::Service {\n   }\n \n   void CancelAllServerSessions() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     for (const auto& context : contexts_) {\n       context->TryCancel();\n     }"
        },
        {
            "sha": "c02d9c5baddbc145a8bc9a2e85230766adca224f",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/registry.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fregistry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fregistry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fregistry.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -56,7 +56,7 @@ Registry* registry() {\n \n void RegisterClientFactory(absl::string_view transport_name,\n                            FactoryFn factory) {\n-  absl::MutexLock l(&registry()->mu);\n+  absl::MutexLock l(registry()->mu);\n   const bool inserted =\n       registry()\n           ->factories.insert({std::string(transport_name), factory})\n@@ -85,7 +85,7 @@ absl::StatusOr<std::unique_ptr<xla::ifrt::Client>> CreateClient(\n \n   FactoryFn factory;\n   {\n-    absl::MutexLock l(&registry()->mu);\n+    absl::MutexLock l(registry()->mu);\n     const auto it = registry()->factories.find(transport_name);\n     if (it == registry()->factories.end()) {\n       return absl::NotFoundError("
        },
        {
            "sha": "f2789e31fb837c8094539d620b11d4bc6170c984",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -58,7 +58,7 @@ class BatchedOps {\n   using BatchOperation = RpcHelper::BatchOperation;\n \n   void Add(BatchOperation op, ArrayHandle handle) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     batched_[op].push_back(handle);\n   }\n \n@@ -69,7 +69,7 @@ class BatchedOps {\n \n   IfrtRequests Consume() {\n     IfrtRequests result;\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (!batched_[BatchOperation::kDeleteArray].empty()) {\n       result.delete_req = std::make_unique<IfrtRequest>();\n       for (const auto& arr_handle : batched_[BatchOperation::kDeleteArray]) {\n@@ -114,7 +114,7 @@ class RpcHelper::Batcher {\n   // that have been previously enqueued.\n   Future<ClientSession::Response> Immediate(\n       std::unique_ptr<IfrtRequest> request) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (finished_) {\n       LOG(WARNING) << \"After RpcHelper::Finish(): \" << request->DebugString();\n       return Future<ClientSession::Response>(\n@@ -134,7 +134,7 @@ class RpcHelper::Batcher {\n   void Finish(absl::Status s) {\n     LOG(INFO) << \"RpcHelper::Batcher::Finish() starting: \" << s;\n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       finished_ = true;\n       auto remaining = batched_.Consume();\n       if (remaining.delete_req != nullptr) {\n@@ -157,7 +157,7 @@ class RpcHelper::Batcher {\n   void PeriodicFlusher() {\n     while (true) {\n       absl::SleepFor(kPeriodicFlushInterval);\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       if (finished_) {\n         return;\n       }"
        },
        {
            "sha": "7dae28594034fd3fd8fd5df43a6a5ba5182d75c4",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/128796e9ef92f51bc298213ef6ca25fe2301b0db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper_test.cc?ref=128796e9ef92f51bc298213ef6ca25fe2301b0db",
            "patch": "@@ -57,13 +57,13 @@ void PausePeriodicFlushes() {\n   auto called_at_least_once = std::make_shared<AtomicBool>();\n   auto periodic_flusher_pause_hook = [called_at_least_once](bool* paused) {\n     *paused = true;\n-    absl::MutexLock l(&called_at_least_once->mu);\n+    absl::MutexLock l(called_at_least_once->mu);\n     called_at_least_once->b = true;\n   };\n   TestHookSet(TestHookName::kRpcBatcherPausePeriodicFlush,\n               std::move(periodic_flusher_pause_hook));\n \n-  absl::MutexLock l(&called_at_least_once->mu);\n+  absl::MutexLock l(called_at_least_once->mu);\n   CHECK(called_at_least_once->mu.AwaitWithTimeout(\n       absl::Condition(&called_at_least_once->b), kMaxFlushTimeout));\n }"
        }
    ],
    "stats": {
        "total": 60,
        "additions": 30,
        "deletions": 30
    }
}