{
    "author": "tensorflower-gardener",
    "message": "[Autotuner] Enable structured logging for debugging and benchmarking.\n\n- Add ConfigResult struct which holds a config and its associated profile result or failures.\n- This struct can be used to log on terminal using VLOG for debugging.\n- Add `dump_logs_to` in AutotuneConfig to support `xla_gpu_dump_autotune_logs_to` XLA_FLAG functionality, of dumping into AutotuneLogs proto format.\n\nPiperOrigin-RevId: 806356573",
    "sha": "e35d7442514859afbd66a4df1ef092e8f77feb18",
    "files": [
        {
            "sha": "060f34de43824a12ec318867292117afb5bbed97",
            "filename": "third_party/xla/xla/backends/autotuner/BUILD",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2FBUILD?ref=e35d7442514859afbd66a4df1ef092e8f77feb18",
            "patch": "@@ -37,23 +37,32 @@ cc_library(\n         \":autotuner_cache_interface\",\n         \":codegen_backend\",\n         \":profiler\",\n+        \"//xla:autotune_results_proto_cc\",\n+        \"//xla:autotuning_proto_cc\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/service:executable\",\n         \"//xla/service:shaped_buffer\",\n         \"//xla/stream_executor:device_description\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:status\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/util/proto:proto_utils\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/functional:function_ref\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/memory\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/time\",\n         \"@local_tsl//tsl/platform:blocking_counter\",\n         \"@local_tsl//tsl/platform:fingerprint\",\n+        \"@local_tsl//tsl/platform:path\",\n+        \"@local_tsl//tsl/platform:protobuf\",\n     ] + if_google([\"@com_google_protobuf//:any_cc_proto\"]),\n )\n \n@@ -74,8 +83,10 @@ xla_cc_test(\n         \"//xla/service/gpu:backend_configs_cc\",\n         \"//xla/stream_executor:device_description\",\n         \"//xla/tsl/platform:env\",\n-        \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/util/proto:proto_matchers\",\n+        \"//xla/tsl/util/proto:proto_utils\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/status:statusor\",\n@@ -84,6 +95,8 @@ xla_cc_test(\n         \"@com_google_absl//absl/types:optional\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@local_tsl//tsl/platform:path\",\n+        \"@local_tsl//tsl/platform:protobuf\",\n+        \"@local_tsl//tsl/platform:test\",\n     ] + if_google([\"@com_google_protobuf//:any_cc_proto\"]),\n )\n "
        },
        {
            "sha": "fce9ef510c0235d7db6c8821cbb6694f02d3bbf7",
            "filename": "third_party/xla/xla/backends/autotuner/autotuner.cc",
            "status": "modified",
            "additions": 193,
            "deletions": 73,
            "changes": 266,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.cc?ref=e35d7442514859afbd66a4df1ef092e8f77feb18",
            "patch": "@@ -15,30 +15,40 @@ limitations under the License.\n \n #include \"xla/backends/autotuner/autotuner.h\"\n \n+#include <cstdint>\n+#include <limits>\n #include <memory>\n #include <optional>\n+#include <string>\n #include <utility>\n #include <vector>\n \n #include \"google/protobuf/any.pb.h\"\n-#include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/memory/memory.h\"\n #include \"absl/status/status.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"absl/strings/str_replace.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/time/time.h\"\n+#include \"xla/autotuning.pb.h\"\n #include \"xla/backends/autotuner/autotuner_cache_interface.h\"\n #include \"xla/backends/autotuner/codegen_backend.h\"\n #include \"xla/backends/autotuner/profiler.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/service/executable.h\"\n #include \"xla/service/shaped_buffer.h\"\n+#include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n+#include \"xla/tsl/util/proto/proto_utils.h\"\n #include \"tsl/platform/blocking_counter.h\"\n #include \"tsl/platform/fingerprint.h\"\n+#include \"tsl/platform/protobuf.h\"\n \n namespace xla {\n \n@@ -52,6 +62,16 @@ tsl::Fprint128 GetFingerprint(const HloInstruction* instr) {\n \n   return tsl::Fingerprint128(instr->ToString(options));\n }\n+\n+// Returns ShortDebugString of contents of Any proto, without type URL.\n+std::string UnpackedAnyShortDebugString(const google::protobuf::Any& any) {\n+  std::string s = any.ShortDebugString();\n+  // Any is serialized as \"go/debugonly [type/url] {<serialized_proto>}\".\n+  std::string type_url = absl::StrCat(\" [\", any.type_url(), \"] \");\n+  absl::StrReplaceAll({{type_url, \"\"}}, &s);\n+  return s;\n+}\n+\n }  // namespace\n \n absl::StatusOr<std::unique_ptr<Autotuner>> Autotuner::Create(\n@@ -89,14 +109,16 @@ absl::Status Autotuner::Autotune(HloModule* module,\n           *instr, *best_config.backend_config));\n     }\n   }\n-  return absl::OkStatus();\n+  return DumpLogsToFile();\n }\n \n absl::Status Autotuner::Autotune(HloInstruction* instr) {\n   VLOG(1) << \"Autotuning HLO: \" << instr->ToString();\n   TF_ASSIGN_OR_RETURN(Config best_config, GetCachedOrTuneBestConfig(instr));\n   CodegenBackend* best_codegen_backend = best_config.codegen_backend;\n-  return best_codegen_backend->ApplyConfig(*instr, *best_config.backend_config);\n+  TF_RETURN_IF_ERROR(\n+      best_codegen_backend->ApplyConfig(*instr, *best_config.backend_config));\n+  return DumpLogsToFile();\n }\n \n absl::StatusOr<Autotuner::Config> Autotuner::GetCachedOrTuneBestConfig(\n@@ -130,18 +152,30 @@ absl::StatusOr<Autotuner::Config> Autotuner::TuneBestConfig(\n \n   std::vector<ExecutableCandidate> executable_candidates;\n   for (int i = 0; i < executables.size(); ++i) {\n-    if (!executables[i].ok()) {\n-      VLOG(2) << \"Failed to compile config \" << i << \": \"\n-              << executables[i].status();\n-      continue;\n+    if (executables[i].ok()) {\n+      executable_candidates.push_back(\n+          {std::move(supported_configs[i]), std::move(executables[i].value())});\n+    } else {\n+      VLOG(4) << \"Compilation failed for config \"\n+              << supported_configs[i].codegen_backend->name() << \" : \"\n+              << UnpackedAnyShortDebugString(\n+                     *supported_configs[i].backend_config)\n+              << \" with status: \" << executables[i].status();\n     }\n-    executable_candidates.push_back(\n-        {std::move(supported_configs[i]), std::move(executables[i].value())});\n+  }\n+\n+  if (executable_candidates.empty()) {\n+    return absl::InternalError(\"No executable candidates to profile!\");\n   }\n   VLOG(1) << \"Successfully compiled \" << executable_candidates.size()\n           << \" configs out of \" << supported_configs.size() << \" configs.\";\n \n-  return ProfileAndPickBest(executable_candidates);\n+  TF_ASSIGN_OR_RETURN(std::vector<ConfigResult> results,\n+                      ProfileAll(executable_candidates));\n+  LogConfigResults(*instr, results);\n+  TF_ASSIGN_OR_RETURN(auto best_result, PickBestConfig(results));\n+  VLOG(1) << \"Picked best config: \" << best_result.ToString();\n+  return std::move(best_result.config);\n }\n \n Autotuner::InstructionsByFingerprint Autotuner::GetAutotuningCandidates(\n@@ -228,19 +262,10 @@ std::vector<absl::StatusOr<std::unique_ptr<Executable>>> Autotuner::CompileAll(\n   return executables;\n }\n \n-absl::StatusOr<Autotuner::Config> Autotuner::ProfileAndPickBest(\n+absl::StatusOr<std::vector<Autotuner::ConfigResult>> Autotuner::ProfileAll(\n     std::vector<ExecutableCandidate>& candidates) {\n-  if (candidates.empty()) {\n-    return absl::InternalError(\"No executables to profile!\");\n-  }\n-  VLOG(1) << \"Profiling \" << candidates.size() << \" executable candidates.\";\n-  struct ConfigAndScratchBytes {\n-    Config* config;\n-    int scratch_bytes;\n-  };\n-  std::vector<ConfigAndScratchBytes> top_configs_and_scratch_bytes;\n-  Config* min_duration_config = nullptr;\n-  absl::Duration min_duration = absl::InfiniteDuration();\n+  std::vector<ConfigResult> results_vec;\n+  results_vec.reserve(candidates.size());\n \n   TF_ASSIGN_OR_RETURN(\n       std::unique_ptr<InputBuffers> input_buffers,\n@@ -255,62 +280,60 @@ absl::StatusOr<Autotuner::Config> Autotuner::ProfileAndPickBest(\n   for (int i = 0; i < candidates.size(); ++i) {\n     absl::StatusOr<ProfileResult> profile_result =\n         profiler_->Profile(candidates[i].executable.get(), *input_buffers);\n+\n+    std::optional<Failure> failure = std::nullopt;\n+    absl::Duration duration = absl::ZeroDuration();\n+    int scratch_bytes = 0;\n     if (!profile_result.ok()) {\n-      VLOG(4) << \"Failed to profile config \" << i << \": \"\n-              << profile_result.status();\n-      continue;\n-    }\n-    VLOG(3) << \"Config \" << i << \" (\"\n-            << candidates[i].config.backend_config->ShortDebugString()\n-            << \") duration: \" << profile_result.value().duration;\n-\n-    if (autotune_config_.check_buffers) {\n-      CHECK(reference_output.has_value());\n-      CHECK(profile_result.value().output_buffer.has_value());\n-      absl::Status status = CheckBuffers(\n-          *input_buffers, profile_result.value().output_buffer.value(),\n-          reference_output.value());\n-      if (!status.ok()) {\n-        continue;\n+      failure = Failure{FailureKind::kExecutionFailed,\n+                        profile_result.status().ToString()};\n+    } else {\n+      duration = profile_result->duration;\n+      scratch_bytes = profile_result->scratch_bytes;\n+      if (autotune_config_.check_buffers) {\n+        CHECK(reference_output.has_value());\n+        CHECK(profile_result->output_buffer.has_value());\n+        failure =\n+            CheckBuffers(*input_buffers, profile_result->output_buffer.value(),\n+                         reference_output.value());\n       }\n     }\n+    results_vec.push_back(\n+        {std::move(candidates[i].config), failure, duration, scratch_bytes});\n+  }\n+  return results_vec;\n+}\n \n-    absl::Duration duration = profile_result.value().duration;\n-    if (autotune_config_.optimize_scratch_bytes &&\n-        duration <\n-            min_duration + absl::Microseconds(\n-                               autotune_config_.scratch_bytes_window_size_us)) {\n-      top_configs_and_scratch_bytes.push_back(\n-          {&candidates[i].config, profile_result.value().scratch_bytes});\n-    }\n-    if (duration < min_duration) {\n-      min_duration = duration;\n-      min_duration_config = &candidates[i].config;\n+absl::StatusOr<Autotuner::ConfigResult> Autotuner::PickBestConfig(\n+    std::vector<ConfigResult>& results) {\n+  absl::Duration min_duration = absl::InfiniteDuration();\n+  ConfigResult* best_result = nullptr;\n+  for (ConfigResult& result : results) {\n+    if (!result.failure.has_value() && result.duration < min_duration) {\n+      min_duration = result.duration;\n+      best_result = &result;\n     }\n   }\n-  if (min_duration_config == nullptr) {\n-    return absl::InternalError(\"No valid config found!\");\n-  }\n \n-  Config* best_config = min_duration_config;\n   if (autotune_config_.optimize_scratch_bytes) {\n-    Config* best_scratch_bytes_config = nullptr;\n-    int min_scratch_bytes = -1;\n-    for (auto& config_and_scratch : top_configs_and_scratch_bytes) {\n-      if (best_scratch_bytes_config == nullptr ||\n-          config_and_scratch.scratch_bytes < min_scratch_bytes) {\n-        best_scratch_bytes_config = config_and_scratch.config;\n-        min_scratch_bytes = config_and_scratch.scratch_bytes;\n+    int64_t min_scratch_bytes = std::numeric_limits<int64_t>::max();\n+    absl::Duration duration_limit =\n+        min_duration +\n+        absl::Microseconds(autotune_config_.scratch_bytes_window_size_us);\n+    for (ConfigResult& result : results) {\n+      if (!result.failure.has_value() && result.duration <= duration_limit &&\n+          result.scratch_bytes < min_scratch_bytes) {\n+        best_result = &result;\n+        min_scratch_bytes = result.scratch_bytes;\n       }\n     }\n-    if (best_scratch_bytes_config != nullptr) {\n-      best_config = best_scratch_bytes_config;\n-    }\n   }\n \n-  VLOG(1) << \"Picked config: \" << best_config->codegen_backend->name() << \" \"\n-          << best_config->backend_config->ShortDebugString();\n-  return std::move(*best_config);\n+  if (best_result == nullptr) {\n+    return absl::InternalError(\"No valid config found!\");\n+  }\n+\n+  return std::move(*best_result);\n }\n \n absl::StatusOr<ScopedShapedBuffer> Autotuner::GetReferenceOutput(\n@@ -322,6 +345,7 @@ absl::StatusOr<ScopedShapedBuffer> Autotuner::GetReferenceOutput(\n     absl::StatusOr<ProfileResult> profile_result =\n         profiler_->Profile(candidate.executable.get(), input_buffers);\n     if (!profile_result.ok()) {\n+      VLOG(2) << \"Failed to profile executable: \" << profile_result.status();\n       continue;\n     }\n     if (profile_result.value().output_buffer.has_value()) {\n@@ -331,22 +355,118 @@ absl::StatusOr<ScopedShapedBuffer> Autotuner::GetReferenceOutput(\n   return absl::InternalError(\"No reference output found!\");\n }\n \n-absl::Status Autotuner::CheckBuffers(InputBuffers& input_buffers,\n-                                     ScopedShapedBuffer& output_buffer,\n-                                     ScopedShapedBuffer& reference_output) {\n+std::optional<Autotuner::Failure> Autotuner::CheckBuffers(\n+    InputBuffers& input_buffers, ScopedShapedBuffer& output_buffer,\n+    ScopedShapedBuffer& reference_output) {\n   absl::Status status = profiler_->CheckInputBuffers(input_buffers);\n   if (!status.ok()) {\n-    VLOG(2) << \"Input buffers check failed: \" << status;\n     CHECK(!autotune_config_.crash_on_check_failure);\n-    return status;\n+    return Failure{FailureKind::kRedzoneCheckFailed, status.ToString()};\n   }\n   status = profiler_->CheckOutputBuffer(output_buffer, reference_output,\n                                         autotune_config_.relative_tolerance);\n   if (!status.ok()) {\n-    VLOG(2) << \"Output buffers check failed: \" << status;\n-    return status;\n+    return Failure{FailureKind::kWrongResults, status.ToString()};\n   }\n+  return std::nullopt;\n+}\n+\n+void Autotuner::LogConfigResults(const HloInstruction& instr,\n+                                 const std::vector<ConfigResult>& results) {\n+  for (const auto& result : results) {\n+    VLOG(2) << result.ToString(/*verbose=*/VLOG_IS_ON(3));\n+  }\n+  if (!autotune_config_.dump_logs_to.empty()) {\n+    AutotuningLog log;\n+    log.mutable_instr()->PackFrom(instr.ToProto());\n+    for (const auto& result : results) {\n+      *log.add_results() = result.ToProto();\n+    }\n+    *logs_.add_logs() = log;\n+  }\n+}\n+\n+absl::Status Autotuner::DumpLogsToFile() {\n+  if (autotune_config_.dump_logs_to.empty()) {\n+    return absl::OkStatus();\n+  }\n+\n+  std::string textproto;\n+  tsl::protobuf::TextFormat::PrintToString(logs_, &textproto);\n+\n+  TF_RETURN_IF_ERROR(tsl::WriteStringToFile(\n+      tsl::Env::Default(), autotune_config_.dump_logs_to, textproto));\n+  VLOG(1) << \"Autotune logs serialized to file: \"\n+          << autotune_config_.dump_logs_to;\n   return absl::OkStatus();\n }\n \n+std::string Autotuner::Failure::ToString() const {\n+  absl::string_view kind_str;\n+  switch (kind) {\n+    case FailureKind::kCompilationFailed:\n+      kind_str = \"COMPILATION FAILED\";\n+      break;\n+    case FailureKind::kExecutionFailed:\n+      kind_str = \"EXECUTION FAILED\";\n+      break;\n+    case FailureKind::kRedzoneCheckFailed:\n+      kind_str = \"REDZONE CHECK FAILED\";\n+      break;\n+    case FailureKind::kWrongResults:\n+      kind_str = \"WRONG RESULTS\";\n+      break;\n+  }\n+  return absl::StrFormat(\"%s: %s\", kind_str, message);\n+}\n+\n+std::string Autotuner::ConfigResult::ToString(bool verbose) const {\n+  std::string config_str = absl::StrFormat(\n+      \"%s : %s\", config.codegen_backend->name(),\n+      verbose ? UnpackedAnyShortDebugString(*config.backend_config) : \"\");\n+  if (failure.has_value()) {\n+    absl::StrAppend(&config_str, \" \", failure->ToString());\n+  }\n+  return absl::StrFormat(\"{%s duration: %s, scratch_bytes: %d}\", config_str,\n+                         absl::FormatDuration(duration), scratch_bytes);\n+}\n+\n+AutotuneResult::FailureResult Autotuner::Failure::ToProto() const {\n+  AutotuneResult::FailureResult failure_proto;\n+  switch (kind) {\n+    case FailureKind::kCompilationFailed:\n+      failure_proto.set_kind(AutotuneResult::UNKNOWN);\n+      break;\n+    case FailureKind::kExecutionFailed:\n+      failure_proto.set_kind(AutotuneResult::DISQUALIFIED);\n+      break;\n+    case FailureKind::kRedzoneCheckFailed:\n+      failure_proto.set_kind(AutotuneResult::REDZONE_MODIFIED);\n+      break;\n+    case FailureKind::kWrongResults:\n+      failure_proto.set_kind(AutotuneResult::WRONG_RESULT);\n+      break;\n+  }\n+  failure_proto.set_msg(message);\n+  return failure_proto;\n+}\n+\n+AutotuneResult Autotuner::ConfigResult::ToProto() const {\n+  AutotuneResult result;\n+  if (config.backend_config->Is<AutotuneResult::GemmKey>()) {\n+    config.backend_config->UnpackTo(result.mutable_gemm());\n+  } else if (config.backend_config->Is<AutotuneResult::TritonGemmKey>()) {\n+    config.backend_config->UnpackTo(result.mutable_triton());\n+  } else if (config.backend_config\n+                 ->Is<stream_executor::dnn::AlgorithmProto>()) {\n+    config.backend_config->UnpackTo(result.mutable_algorithm());\n+  }\n+  if (failure.has_value()) {\n+    *result.mutable_failure() = failure->ToProto();\n+  }\n+  *result.mutable_run_time() = tsl::proto_utils::ToDurationProto(duration);\n+  result.set_scratch_bytes(scratch_bytes);\n+  return result;\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "64a26bc78f8b590f342afefdfb026dc611640883",
            "filename": "third_party/xla/xla/backends/autotuner/autotuner.h",
            "status": "modified",
            "additions": 45,
            "deletions": 5,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.h?ref=e35d7442514859afbd66a4df1ef092e8f77feb18",
            "patch": "@@ -18,13 +18,17 @@ limitations under the License.\n \n #include <memory>\n #include <optional>\n+#include <string>\n #include <utility>\n #include <vector>\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/functional/function_ref.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/autotune_results.pb.h\"\n+#include \"xla/autotuning.pb.h\"\n #include \"xla/backends/autotuner/autotuner_cache_interface.h\"\n #include \"xla/backends/autotuner/codegen_backend.h\"\n #include \"xla/backends/autotuner/profiler.h\"\n@@ -59,6 +63,9 @@ struct AutotuneConfig {\n   // If true, the autotuner will return an error if the best config for a\n   // certain instruction is not in the cache.\n   bool expect_all_instructions_in_cache = false;\n+  // If not empty, detailed logs will be written to the specified file path\n+  // as a textproto representation of an `AutotuningLogs` proto message.\n+  std::string dump_logs_to = \"\";\n };\n \n class Autotuner {\n@@ -94,6 +101,33 @@ class Autotuner {\n     Config config;\n     std::unique_ptr<Executable> executable;\n   };\n+  enum class FailureKind {\n+    kCompilationFailed,\n+    kExecutionFailed,\n+    kRedzoneCheckFailed,\n+    kWrongResults,\n+  };\n+\n+  struct Failure {\n+    FailureKind kind;\n+    std::string message;\n+\n+    std::string ToString() const;\n+    AutotuneResult::FailureResult ToProto() const;\n+  };\n+  // The result of profiling a single config for a given instruction. If the\n+  // profiling failed, as indicated by the failures of kind kCompilationFailed\n+  // or kExecutionFailed, the duration and scratch_bytes fields won't be set,\n+  // retaining the default values of 0.\n+  struct ConfigResult {\n+    Config config;\n+    std::optional<Failure> failure;\n+    absl::Duration duration = absl::ZeroDuration();\n+    int scratch_bytes = 0;\n+\n+    std::string ToString(bool verbose = false) const;\n+    AutotuneResult ToProto() const;\n+  };\n \n   Autotuner(std::vector<std::unique_ptr<CodegenBackend>> codegen_backends,\n             std::unique_ptr<Profiler> profiler, AutotuneConfig autotune_config,\n@@ -125,23 +159,29 @@ class Autotuner {\n       HloInstruction* instr);\n   std::vector<absl::StatusOr<std::unique_ptr<Executable>>> CompileAll(\n       HloInstruction* instr, std::vector<Config>& configs);\n-\n-  absl::StatusOr<Config> ProfileAndPickBest(\n+  absl::StatusOr<std::vector<ConfigResult>> ProfileAll(\n       std::vector<ExecutableCandidate>& candidates);\n+  absl::StatusOr<ConfigResult> PickBestConfig(\n+      std::vector<ConfigResult>& results);\n \n   absl::StatusOr<ScopedShapedBuffer> GetReferenceOutput(\n       std::vector<ExecutableCandidate>& candidates,\n       InputBuffers& input_buffers);\n \n-  absl::Status CheckBuffers(InputBuffers& input_buffers,\n-                            ScopedShapedBuffer& output,\n-                            ScopedShapedBuffer& reference);\n+  std::optional<Failure> CheckBuffers(InputBuffers& input_buffers,\n+                                      ScopedShapedBuffer& output,\n+                                      ScopedShapedBuffer& reference);\n+\n+  void LogConfigResults(const HloInstruction& instr,\n+                        const std::vector<ConfigResult>& results);\n+  absl::Status DumpLogsToFile();\n \n   std::vector<std::unique_ptr<CodegenBackend>> codegen_backends_;\n   std::unique_ptr<Profiler> profiler_;\n   AutotuneConfig autotune_config_;\n   std::unique_ptr<AutotunerCacheInterface> cache_;\n   tsl::thread::ThreadPool* thread_pool_;\n+  AutotuningLogs logs_;\n };\n }  // namespace xla\n "
        },
        {
            "sha": "697c21f56913dab673bdf8511d3b0fbde24dbd4d",
            "filename": "third_party/xla/xla/backends/autotuner/autotuner_test.cc",
            "status": "modified",
            "additions": 61,
            "deletions": 1,
            "changes": 62,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc?ref=e35d7442514859afbd66a4df1ef092e8f77feb18",
            "patch": "@@ -42,9 +42,13 @@ limitations under the License.\n #include \"xla/shape.h\"\n #include \"xla/stream_executor/device_description.h\"\n #include \"xla/tsl/platform/env.h\"\n-#include \"xla/tsl/platform/status_matchers.h\"\n #include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n+#include \"xla/tsl/util/proto/proto_matchers.h\"\n+#include \"xla/tsl/util/proto/proto_utils.h\"\n+#include \"tsl/platform/path.h\"\n+#include \"tsl/platform/protobuf.h\"\n \n namespace xla {\n namespace {\n@@ -124,6 +128,7 @@ using absl_testing::IsOk;\n using absl_testing::StatusIs;\n using ::testing::_;\n using ::testing::Return;\n+using tsl::proto_utils::ToDurationProto;\n \n se::DeviceDescription CreateDummyDeviceDescription() {\n   se::DeviceDescription desc;\n@@ -522,5 +527,60 @@ TEST_F(AutotunerTest, ExpectAllInstructionsInCache) {\n               StatusIs(absl::StatusCode::kNotFound));\n }\n \n+TEST_F(AutotunerTest, DumpLogsToFile) {\n+  config_.dump_logs_to = tsl::io::JoinPath(tsl::testing::TmpDir(), \"dump.log\");\n+\n+  std::vector<std::unique_ptr<BackendConfig>> configs;\n+  configs.push_back(GetTestConfig(\"test_config_1\"));\n+  configs.push_back(GetTestConfig(\"test_config_2\"));\n+\n+  auto backend = std::make_unique<MockCodegenBackend>();\n+  EXPECT_CALL(*backend, name()).WillRepeatedly(Return(\"mock_backend\"));\n+  EXPECT_CALL(*backend, GetSupportedConfigs)\n+      .WillOnce(Return(std::move(configs)));\n+  EXPECT_CALL(*backend, Compile(_, _))\n+      .WillOnce(Return(std::unique_ptr<Executable>()))\n+      .WillOnce(Return(std::unique_ptr<Executable>()));\n+  EXPECT_CALL(*backend, ApplyConfig(_, ConfigMatcher(\"test_config_2\")))\n+      .Times(1)\n+      .WillRepeatedly(Return(absl::OkStatus()));\n+\n+  auto profiler = std::make_unique<MockProfiler>();\n+  EXPECT_CALL(*profiler, CreateInputBuffers(_))\n+      .WillOnce(Return(std::make_unique<InputBuffers>()));\n+  EXPECT_CALL(*profiler, Profile(_, _))\n+      .WillOnce(Return(ProfileResult({absl::Seconds(2),\n+                                      /*output_buffer=*/std::nullopt,\n+                                      /*scratch_bytes=*/100})))\n+      .WillOnce(Return(ProfileResult({absl::Seconds(1)})));\n+  std::vector<std::unique_ptr<CodegenBackend>> backends;\n+  backends.push_back(std::move(backend));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto autotuner, Autotuner::Create(std::move(backends),\n+                                        std::move(profiler), config_, nullptr));\n+  auto module = ParseAndReturnVerifiedModule(kHlo).value();\n+  auto dummy_instr = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(autotuner->Autotune(dummy_instr), absl_testing::IsOk());\n+\n+  std::string content;\n+  EXPECT_THAT(tsl::ReadFileToString(tsl::Env::Default(), config_.dump_logs_to,\n+                                    &content),\n+              absl_testing::IsOk());\n+  AutotuningLogs actual_logs;\n+  EXPECT_TRUE(\n+      tsl::protobuf::TextFormat::ParseFromString(content, &actual_logs));\n+\n+  AutotuningLogs expected_logs;\n+  AutotuningLog* log = expected_logs.add_logs();\n+  log->mutable_instr()->PackFrom(dummy_instr->ToProto());\n+  AutotuneResult* result_1 = log->add_results();\n+  *result_1->mutable_run_time() = ToDurationProto(absl::Seconds(2));\n+  result_1->set_scratch_bytes(100);\n+  AutotuneResult* result_2 = log->add_results();\n+  *result_2->mutable_run_time() = ToDurationProto(absl::Seconds(1));\n+\n+  EXPECT_THAT(actual_logs, tsl::proto_testing::EqualsProto(expected_logs));\n+}\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "a9b365808eb4af0eb3b1d4dca047ea013388af33",
            "filename": "third_party/xla/xla/service/gpu/autotuning/autotuner_pass.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fautotuner_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e35d7442514859afbd66a4df1ef092e8f77feb18/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fautotuner_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fautotuner_pass.cc?ref=e35d7442514859afbd66a4df1ef092e8f77feb18",
            "patch": "@@ -55,6 +55,7 @@ AutotuneConfig GetAutotuneConfig(const DebugOptions& debug_options) {\n       debug_options.xla_gpu_crash_on_verification_failures();\n   autotune_config.expect_all_instructions_in_cache =\n       debug_options.xla_gpu_require_complete_aot_autotune_results();\n+  autotune_config.dump_logs_to = debug_options.xla_gpu_dump_autotune_logs_to();\n   return autotune_config;\n }\n "
        }
    ],
    "stats": {
        "total": 394,
        "additions": 314,
        "deletions": 80
    }
}