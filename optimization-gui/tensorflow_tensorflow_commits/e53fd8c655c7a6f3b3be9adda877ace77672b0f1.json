{
    "author": "junwhanahn",
    "message": "Introduce `tsl::MakePromise<T>` and deprecate `tsl::Future<T>::MakePromise()`\n\nThe new API allows for more natural usage that is consistent with other TSL APIs, e.g., `tsl::MakeRef<T>()`. The old spelling will be removed after all existing usage is migrated.\n\nThere is a fair amount of code move in this CL because `MakePromise` is referenced by `Map` implementations and they now have to be defined outside the class.\n\nPiperOrigin-RevId: 850618096",
    "sha": "e53fd8c655c7a6f3b3be9adda877ace77672b0f1",
    "files": [
        {
            "sha": "3736e581d5a277104debfc5d3f346516efae6c6f",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 375,
            "deletions": 279,
            "changes": 654,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e53fd8c655c7a6f3b3be9adda877ace77672b0f1/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e53fd8c655c7a6f3b3be9adda877ace77672b0f1/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=e53fd8c655c7a6f3b3be9adda877ace77672b0f1",
            "patch": "@@ -172,6 +172,8 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n                    /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n \n  public:\n+  using type = T;\n+\n   bool IsValid() const { return promise_ != nullptr; }\n \n   // Two functions exist to know whether the future is ready, to accommodate\n@@ -484,6 +486,9 @@ template <typename R> struct MapResult<absl::StatusOr<R>> { using T = R; };\n template <typename R>\n using map_result_t = typename MapResult<R>::T;  // NOLINT\n \n+template <typename T>\n+class PromiseMaker;\n+\n }  // namespace internal\n \n // Future<T> is a simple future that is returned by  APIs that enqueue\n@@ -563,56 +568,25 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     }\n \n    private:\n-    template <typename>\n-    friend class Future;\n+    friend class Future<T>;\n+    friend class internal::PromiseMaker<T>;\n   };\n \n-  // Returns a pair of connected Promise and Future<>. Setting the returned\n-  // promise will fulfill the connected future and will run pending callbacks in\n-  // the caller thread.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n+  ABSL_DEPRECATED(\"Use `tsl::MakePromise<T>` instead\")\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<T>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n-      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n-    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n-    Future<T> future(promise, std::move(on_block_start),\n-                     std::move(on_block_end));\n-    return std::make_pair(std::move(promise), std::move(future));\n-  }\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr);\n \n-  // Returns a pair of connected Promise and Future<T>. Setting the returned\n-  // promise will fulfill the connected future and will run all pending\n-  // callbacks on the given `executor`. If the future is ready when `OnReady` or\n-  // `Map` is called, then the callback will be executed immediately in the\n-  // caller thread. Users can explicitly override executor by using `OnReady`\n-  // and `Map` overloads that accept another executor instance.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n+  ABSL_DEPRECATED(\"Use `tsl::MakePromise<T>` instead\")\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<T>> MakePromise(\n       Executor& executor, FutureHelpers::OnBlockStart on_block_start = nullptr,\n-      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n-    auto [promise, future] =\n-        MakePromise(std::move(on_block_start), std::move(on_block_end));\n-    return std::make_pair(std::move(promise),\n-                          std::move(future).Detach(executor));\n-  }\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr);\n \n-  // Returns a future that is constructed from the result of invoking functor\n-  // `f` on the given `executor`.\n   template <typename F, typename R = std::invoke_result_t<F>,\n             std::enable_if_t<std::is_constructible_v<absl::StatusOr<T>, R>>* =\n                 nullptr>\n-  [[nodiscard]] static Future<T> MakeOn(Executor& executor, F&& f) {\n-    auto [promise, future] = MakePromise();\n-    executor.Execute(\n-        [promise = std::move(promise), f = std::forward<F>(f)]() mutable {\n-          promise.Set(std::move(f)());\n-        });\n-    return std::move(future);\n-  }\n+  ABSL_DEPRECATED(\"Use `tsl::MakeFutureOn<T>` instead\")\n+  static Future<T> MakeOn(Executor& executor, F&& f);\n \n   using Base::Await;\n   using Base::Detach;\n@@ -644,56 +618,13 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<F, const T&>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const& {\n-    // If `*this` is ready, construct the mapped future immediately.\n-    if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n-      const absl::StatusOr<T>& value = *Base::promise();\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!value.ok())) {\n-        return Future<R>(value.status());\n-      }\n-\n-      // Construct the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        return Future<R>((f(*value), absl::OkStatus()));\n-      } else {\n-        return Future<R>(f(*value));\n-      }\n-    }\n-\n-    // If `*this` is not ready yet, we need to create a new promise and fulfill\n-    // it with a result of `f` when `*this` becomes ready.\n-    auto [promise, future] = Future<R>::MakePromise();\n-    OnReady(SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n-    return std::move(future);\n-  }\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const&;\n \n   // A `Map` overload that invokes `f` on the given `executor`.\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<F, const T&>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const& {\n-    auto [promise, future] = Future<R>::MakePromise();\n-\n-    OnReady([&executor, f = std::forward<F>(f), promise = std::move(promise),\n-             ptr = Base::promise()](const absl::StatusOr<T>& value) mutable {\n-      // Do not submit a task to the executor if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Extend the lifetime of the underlying async value storage by copying\n-      // the reference to it, to avoid use-after-free inside the `f` functor.\n-      executor.Execute([&value, ref = ptr.CopyRef(), f = std::move(f),\n-                        promise = std::move(promise)]() mutable {\n-        SetPromise<R, U>(std::move(promise), std::move(f))(value);\n-      });\n-    });\n-\n-    return std::move(future);\n-  }\n+  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const&;\n \n   // Returns an Future<R> that is constructed from the result of invoking\n   // functor `f` with *this value. If *this completes with an error, returned\n@@ -723,77 +654,14 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n             typename U = std::invoke_result_t<\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) && {\n-    // If `*this` is ready, construct the mapped future immediately.\n-    if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n-      // For copyable types bind to const reference, so that we don't\n-      // accidentally move the value from the underlying async value storage.\n-      using Value = std::conditional_t<is_move_only, absl::StatusOr<T>&,\n-                                       const absl::StatusOr<T>&>;\n-      Value value = *Base::promise();\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!value.ok())) {\n-        return Future<R>(value.status());\n-      }\n-\n-      // Construct the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        return Future<R>((f(std::move(*value)), absl::OkStatus()));\n-      } else {\n-        return Future<R>(f(std::move(*value)));\n-      }\n-    }\n-\n-    // If `*this` is not ready yet, we need to create a new promise and fulfill\n-    // it with a result of `f` when `*this` becomes ready.\n-    auto [promise, future] = Future<R>::MakePromise();\n-    std::move(*this).OnReady(SetPromise<R, U, /*rvalue=*/true>(\n-        std::move(promise), std::forward<F>(f)));\n-    return std::move(future);\n-  }\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) &&;\n \n   // A `Map` overload that invokes `f` on the given `executor`.\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) && {\n-    auto [promise, future] = Future<R>::MakePromise();\n-\n-    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n-                                     const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady([&executor, f = std::forward<F>(f),\n-                              promise = std::move(promise),\n-                              ptr = Base::promise()](Value value) mutable {\n-      // Do not submit a task to the executor if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // For move-only types pass by value to the executor callback, and for\n-      // copyable types pass by const reference to avoid accidental copies. For\n-      // values passed by reference extend the lifetime of the underlying async\n-      // value storage by copying the reference to it, to avoid use-after-free\n-      // inside the `f` functor.\n-      if constexpr (is_move_only) {\n-        executor.Execute([value = std::move(value), f = std::move(f),\n-                          promise = std::move(promise)]() mutable {\n-          SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n-                                            std::move(f))(std::move(value));\n-        });\n-      } else {\n-        executor.Execute([&value, ref = ptr.CopyRef(), f = std::move(f),\n-                          promise = std::move(promise)]() mutable {\n-          SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n-                                            std::move(f))(value);\n-        });\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n+  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) &&;\n \n   // A `Map` overload that automatically infers the type of result from `f`:\n   //\n@@ -835,37 +703,11 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n \n  private:\n   friend class FutureHelpers;\n+  friend class internal::PromiseMaker<T>;\n \n   // Wraps a map functor into a callback compatible with Future<>::OnReady.\n   template <typename R, typename U, bool rvalue = false, typename F>\n-  static auto SetPromise(typename Future<R>::Promise promise, F&& f) {\n-    // For copyable types bind to const reference, so that we don't\n-    // accidentally move the value from the underlying async value storage.\n-    // Move-only types are passed by value into the `OnReady` callback.\n-    using Value = std::conditional_t<rvalue && is_move_only, absl::StatusOr<T>,\n-                                     const absl::StatusOr<T>&>;\n-    return [promise = std::move(promise),\n-            f = std::forward<F>(f)](Value value) mutable {\n-      // Do not compute `f` if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!value.ok())) {\n-        promise.Set(value.status());\n-        return;\n-      }\n-\n-      // Set the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        promise.Set((f(std::move(*value)), absl::OkStatus()));\n-      } else {\n-        promise.Set(f(std::move(*value)));\n-      }\n-    };\n-  }\n+  static auto SetPromise(typename Future<R>::Promise promise, F&& f);\n \n   // Bring FutureBase constructors in scope.\n   using Base::Base;\n@@ -938,53 +780,23 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n \n    private:\n     friend class Future<void>;\n+    friend class internal::PromiseMaker<void>;\n   };\n \n-  // Returns a pair of connected Promise and Future<>. Setting the returned\n-  // promise will fulfill the connected future and will run all pending\n-  // callbacks in the caller thread.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n+  ABSL_DEPRECATED(\"Use `tsl::MakePromise<>` instead\")\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<>> MakePromise(\n       FutureHelpers::OnBlockStart on_block_start = nullptr,\n-      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n-    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n-    Future<> future(promise, std::move(on_block_start),\n-                    std::move(on_block_end));\n-    return std::make_pair(std::move(promise), std::move(future));\n-  }\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr);\n \n-  // Returns a pair of connected Promise and Future<>. Setting the returned\n-  // promise will fulfill the connected future and will run all pending\n-  // callbacks on the given `executor`. If the future is ready when `OnReady` or\n-  // `Map` is called, then the callback will be executed immediately in the\n-  // caller thread. Users can explicitly override executor by using `OnReady`\n-  // and `Map` overloads that accept another executor instance.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n+  ABSL_DEPRECATED(\"Use `tsl::MakePromise<>` instead\")\n   static ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise, Future<>> MakePromise(\n       Executor& executor, FutureHelpers::OnBlockStart on_block_start = nullptr,\n-      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n-    auto [promise, future] =\n-        MakePromise(std::move(on_block_start), std::move(on_block_end));\n-    return std::make_pair(std::move(promise),\n-                          std::move(future).Detach(executor));\n-  }\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr);\n \n-  // Returns a future that is constructed from the result of invoking\n-  // functor `f` on the given `executor`.\n   template <typename F, typename R = std::invoke_result_t<F>,\n             std::enable_if_t<internal::is_status_v<R>>* = nullptr>\n-  [[nodiscard]] static Future<> MakeOn(Executor& executor, F&& f) {\n-    auto [promise, future] = MakePromise();\n-    executor.Execute(\n-        [promise = std::move(promise), f = std::forward<F>(f)]() mutable {\n-          promise.Set(std::move(f)());\n-        });\n-    return std::move(future);\n-  }\n+  ABSL_DEPRECATED(\"Use `tsl::MakeFutureOn<void>` instead\")\n+  static Future<> MakeOn(Executor& executor, F&& f);\n \n   using Base::Await;\n   using Base::BlockUntilReady;\n@@ -1015,51 +827,12 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // See `Map` functor type inference defined below for more details.\n   template <typename R, typename F, typename U = std::invoke_result_t<F>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const {\n-    // If `*this` is ready, construct the mapped future immediately.\n-    if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!Base::promise()->ok())) {\n-        return Future<R>(*Base::promise());\n-      }\n-\n-      // Construct the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        return Future<R>((f(), absl::OkStatus()));\n-      } else {\n-        return Future<R>(f());\n-      }\n-    }\n-\n-    // If `*this` is not ready yet, we need to create a new promise and fulfill\n-    // it with a result of `f` when `*this` becomes ready.\n-    auto [promise, future] = Future<R>::MakePromise();\n-    OnReady(SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n-    return std::move(future);\n-  }\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const;\n \n   // A `Map` overload that invokes `f` on the given `executor`.\n   template <typename R, typename F, typename U = std::invoke_result_t<F>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const {\n-    auto [promise, future] = Future<R>::MakePromise();\n-\n-    OnReady([&executor, f = std::forward<F>(f),\n-             promise = std::move(promise)](const absl::Status& status) mutable {\n-      // Do not submit a task to the executor if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Pass `status` by value because it's cheap to copy, instead of extending\n-      // the lifetime of the underlying async value storage.\n-      executor.Execute(std::bind(\n-          SetPromise<R, U>(std::move(promise), std::move(f)), status));\n-    });\n-\n-    return std::move(future);\n-  }\n+  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const;\n \n   // A `Map` overload that automatically infers the type of result from `f`:\n   //\n@@ -1099,32 +872,11 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n \n  private:\n   friend class FutureHelpers;\n+  friend class internal::PromiseMaker<void>;\n \n   // Wraps a map functor into a callback compatible with Future<>::OnReady.\n   template <typename R, typename U, typename F>\n-  static auto SetPromise(typename Future<R>::Promise promise, F&& f) {\n-    return [promise = std::move(promise),\n-            f = std::forward<F>(f)](const absl::Status& status) mutable {\n-      // Do not compute `f` if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!status.ok())) {\n-        promise.Set(std::move(status));\n-        return;\n-      }\n-\n-      // Set the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        promise.Set((f(), absl::OkStatus()));\n-      } else {\n-        promise.Set(f());\n-      }\n-    };\n-  }\n+  static auto SetPromise(typename Future<R>::Promise promise, F&& f);\n \n   // A promise that is immediately ready with OK status. Async value allocated\n   // in the static storage and is not reference-counted.\n@@ -1149,6 +901,71 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n template <typename T = void>\n using Promise = typename Future<T>::Promise;  // NOLINT\n \n+namespace internal {\n+\n+// Helper class to access private future/promise constructors.\n+template <typename T>\n+class PromiseMaker {\n+ public:\n+  static std::pair<Promise<T>, Future<T>> Make(\n+      FutureHelpers::OnBlockStart on_block_start,\n+      FutureHelpers::OnBlockEnd on_block_end) {\n+    Promise<T> promise(\n+        tsl::MakeUnconstructedAsyncValueRef<typename tsl::Future<T>::type>());\n+    Future<T> future(promise, std::move(on_block_start),\n+                     std::move(on_block_end));\n+    return std::make_pair(std::move(promise), std::move(future));\n+  }\n+};\n+\n+}  // namespace internal\n+\n+// Returns a pair of connected Promise and Future<>. Setting the returned\n+// promise will fulfill the connected future and will run pending callbacks in\n+// the caller thread.\n+//\n+// - on_block_start is called before Await starts to block.\n+// - on_block_end is called after Await finishes blocking.\n+template <typename T = void>\n+ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise<T>, Future<T>> MakePromise(\n+    FutureHelpers::OnBlockStart on_block_start = nullptr,\n+    FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n+  return ::tsl::internal::PromiseMaker<T>::Make(std::move(on_block_start),\n+                                                std::move(on_block_end));\n+}\n+\n+// Returns a pair of connected Promise and Future<T>. Setting the returned\n+// promise will fulfill the connected future and will run all pending\n+// callbacks on the given `executor`. If the future is ready when `OnReady` or\n+// `Map` is called, then the callback will be executed immediately in the\n+// caller thread. Users can explicitly override executor by using `OnReady`\n+// and `Map` overloads that accept another executor instance.\n+//\n+// - on_block_start is called before Await starts to block.\n+// - on_block_end is called after Await finishes blocking.\n+template <typename T = void>\n+ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise<T>, Future<T>> MakePromise(\n+    Executor& executor, FutureHelpers::OnBlockStart on_block_start = nullptr,\n+    FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n+  auto [promise, future] =\n+      MakePromise<T>(std::move(on_block_start), std::move(on_block_end));\n+  return std::make_pair(std::move(promise), std::move(future).Detach(executor));\n+}\n+\n+// Returns a future that is constructed from the result of invoking functor\n+// `f` on the given `executor`.\n+template <typename T, typename F, typename R = std::invoke_result_t<F>,\n+          std::enable_if_t<std::is_constructible_v<\n+              typename tsl::Future<T>::type, R>>* = nullptr>\n+[[nodiscard]] Future<T> MakeFutureOn(Executor& executor, F&& f) {\n+  auto [promise, future] = MakePromise<T>();\n+  executor.Execute(\n+      [promise = std::move(promise), f = std::forward<F>(f)]() mutable {\n+        promise.Set(std::move(f)());\n+      });\n+  return std::move(future);\n+}\n+\n //===----------------------------------------------------------------------===//\n // internal::FutureBase<T> implementation.\n //===----------------------------------------------------------------------===//\n@@ -1208,7 +1025,7 @@ Future<future_type_t<T>> FutureBase<T, is_move_only>::Detach(\n \n template <typename T, bool is_move_only>\n Future<> FutureBase<T, is_move_only>::GetReadyFuture() const {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise<>();\n   promise_.AndThen(\n       [ptr = promise_.AsPtr(), promise = std::move(promise)]() mutable {\n         if constexpr (internal::is_status_v<T>) {\n@@ -1221,6 +1038,285 @@ Future<> FutureBase<T, is_move_only>::GetReadyFuture() const {\n }\n \n }  // namespace internal\n+\n+//===----------------------------------------------------------------------===//\n+// Future<T> implementation.\n+//===----------------------------------------------------------------------===//\n+\n+template <typename T>\n+ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise<T>, Future<T>>\n+Future<T>::MakePromise(FutureHelpers::OnBlockStart on_block_start,\n+                       FutureHelpers::OnBlockEnd on_block_end) {\n+  return ::tsl::MakePromise<T>(std::move(on_block_start),\n+                               std::move(on_block_end));\n+}\n+\n+template <typename T>\n+ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise<T>, Future<T>>\n+Future<T>::MakePromise(Executor& executor,\n+                       FutureHelpers::OnBlockStart on_block_start,\n+                       FutureHelpers::OnBlockEnd on_block_end) {\n+  return ::tsl::MakePromise<T>(executor, std::move(on_block_start),\n+                               std::move(on_block_end));\n+}\n+\n+template <typename T>\n+template <typename F, typename R,\n+          std::enable_if_t<std::is_constructible_v<absl::StatusOr<T>, R>>*>\n+[[nodiscard]] Future<T> Future<T>::MakeOn(Executor& executor, F&& f) {\n+  return ::tsl::MakeFutureOn<T>(executor, std::forward<F>(f));\n+}\n+\n+template <typename T>\n+template <typename R, typename F, typename U, internal::Mappable<R, U>*>\n+[[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Future<T>::Map(\n+    F&& f) const& {\n+  // If `*this` is ready, construct the mapped future immediately.\n+  if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n+    const absl::StatusOr<T>& value = *Base::promise();\n+\n+    // Short-circuit and forward existing error to the mapped future.\n+    if (ABSL_PREDICT_FALSE(!value.ok())) {\n+      return Future<R>(value.status());\n+    }\n+\n+    // Construct the result future available with a result of invoking `f`.\n+    if constexpr (std::is_void_v<U>) {\n+      return Future<R>((f(*value), absl::OkStatus()));\n+    } else {\n+      return Future<R>(f(*value));\n+    }\n+  }\n+\n+  // If `*this` is not ready yet, we need to create a new promise and fulfill\n+  // it with a result of `f` when `*this` becomes ready.\n+  auto [promise, future] = ::tsl::MakePromise<R>();\n+  OnReady(SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n+  return std::move(future);\n+}\n+\n+template <typename T>\n+template <typename R, typename F, typename U, internal::Mappable<R, U>*>\n+[[nodiscard]] Future<R> Future<T>::Map(Executor& executor, F&& f) const& {\n+  auto [promise, future] = ::tsl::MakePromise<R>();\n+\n+  OnReady([&executor, f = std::forward<F>(f), promise = std::move(promise),\n+           ptr = Base::promise()](const absl::StatusOr<T>& value) mutable {\n+    // Do not submit a task to the executor if the result is unused.\n+    if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+      promise.Set(Base::AbortedError());\n+      return;\n+    }\n+\n+    // Extend the lifetime of the underlying async value storage by copying\n+    // the reference to it, to avoid use-after-free inside the `f` functor.\n+    executor.Execute([&value, ref = ptr.CopyRef(), f = std::move(f),\n+                      promise = std::move(promise)]() mutable {\n+      SetPromise<R, U>(std::move(promise), std::move(f))(value);\n+    });\n+  });\n+\n+  return std::move(future);\n+}\n+\n+template <typename T>\n+template <typename R, typename F, typename U, internal::Mappable<R, U>*>\n+[[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Future<T>::Map(F&& f) && {\n+  // If `*this` is ready, construct the mapped future immediately.\n+  if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n+    // For copyable types bind to const reference, so that we don't\n+    // accidentally move the value from the underlying async value storage.\n+    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>&,\n+                                     const absl::StatusOr<T>&>;\n+    Value value = *Base::promise();\n+\n+    // Short-circuit and forward existing error to the mapped future.\n+    if (ABSL_PREDICT_FALSE(!value.ok())) {\n+      return Future<R>(value.status());\n+    }\n+\n+    // Construct the result future available with a result of invoking `f`.\n+    if constexpr (std::is_void_v<U>) {\n+      return Future<R>((f(std::move(*value)), absl::OkStatus()));\n+    } else {\n+      return Future<R>(f(std::move(*value)));\n+    }\n+  }\n+\n+  // If `*this` is not ready yet, we need to create a new promise and fulfill\n+  // it with a result of `f` when `*this` becomes ready.\n+  auto [promise, future] = ::tsl::MakePromise<R>();\n+  std::move(*this).OnReady(SetPromise<R, U, /*rvalue=*/true>(\n+      std::move(promise), std::forward<F>(f)));\n+  return std::move(future);\n+}\n+\n+template <typename T>\n+template <typename R, typename F, typename U, internal::Mappable<R, U>*>\n+[[nodiscard]] Future<R> Future<T>::Map(Executor& executor, F&& f) && {\n+  auto [promise, future] = ::tsl::MakePromise<R>();\n+\n+  using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n+                                   const absl::StatusOr<T>&>;\n+  std::move(*this).OnReady([&executor, f = std::forward<F>(f),\n+                            promise = std::move(promise),\n+                            ptr = Base::promise()](Value value) mutable {\n+    // Do not submit a task to the executor if the result is unused.\n+    if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+      promise.Set(Base::AbortedError());\n+      return;\n+    }\n+\n+    // For move-only types pass by value to the executor callback, and for\n+    // copyable types pass by const reference to avoid accidental copies. For\n+    // values passed by reference extend the lifetime of the underlying async\n+    // value storage by copying the reference to it, to avoid use-after-free\n+    // inside the `f` functor.\n+    if constexpr (is_move_only) {\n+      executor.Execute([value = std::move(value), f = std::move(f),\n+                        promise = std::move(promise)]() mutable {\n+        SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n+                                          std::move(f))(std::move(value));\n+      });\n+    } else {\n+      executor.Execute([&value, ref = ptr.CopyRef(), f = std::move(f),\n+                        promise = std::move(promise)]() mutable {\n+        SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n+                                          std::move(f))(value);\n+      });\n+    }\n+  });\n+\n+  return std::move(future);\n+}\n+\n+template <typename T>\n+template <typename R, typename U, bool rvalue, typename F>\n+auto Future<T>::SetPromise(typename Future<R>::Promise promise, F&& f) {\n+  // For copyable types bind to const reference, so that we don't\n+  // accidentally move the value from the underlying async value storage.\n+  // Move-only types are passed by value into the `OnReady` callback.\n+  using Value = std::conditional_t<rvalue && is_move_only, absl::StatusOr<T>,\n+                                   const absl::StatusOr<T>&>;\n+  return [promise = std::move(promise),\n+          f = std::forward<F>(f)](Value value) mutable {\n+    // Do not compute `f` if the result is unused.\n+    if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+      promise.Set(Base::AbortedError());\n+      return;\n+    }\n+\n+    // Short-circuit and forward existing error to the mapped future.\n+    if (ABSL_PREDICT_FALSE(!value.ok())) {\n+      promise.Set(value.status());\n+      return;\n+    }\n+\n+    // Set the result future available with a result of invoking `f`.\n+    if constexpr (std::is_void_v<U>) {\n+      promise.Set((f(std::move(*value)), absl::OkStatus()));\n+    } else {\n+      promise.Set(f(std::move(*value)));\n+    }\n+  };\n+}\n+\n+//===----------------------------------------------------------------------===//\n+// Future<void> implementation.\n+//===----------------------------------------------------------------------===//\n+\n+ABSL_ATTRIBUTE_ALWAYS_INLINE\n+inline std::pair<Promise<>, Future<>> Future<void>::MakePromise(\n+    FutureHelpers::OnBlockStart on_block_start,\n+    FutureHelpers::OnBlockEnd on_block_end) {\n+  return ::tsl::MakePromise<>(std::move(on_block_start),\n+                              std::move(on_block_end));\n+}\n+\n+ABSL_ATTRIBUTE_ALWAYS_INLINE inline std::pair<Promise<>, Future<>>\n+Future<void>::MakePromise(Executor& executor,\n+                          FutureHelpers::OnBlockStart on_block_start,\n+                          FutureHelpers::OnBlockEnd on_block_end) {\n+  return ::tsl::MakePromise<>(executor, std::move(on_block_start),\n+                              std::move(on_block_end));\n+}\n+\n+template <typename F, typename R, std::enable_if_t<internal::is_status_v<R>>*>\n+[[nodiscard]] inline Future<> Future<void>::MakeOn(Executor& executor, F&& f) {\n+  return ::tsl::MakeFutureOn<void>(executor, std::forward<F>(f));\n+}\n+\n+template <typename R, typename F, typename U, internal::Mappable<R, U>*>\n+[[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Future<void>::Map(\n+    F&& f) const {\n+  // If `*this` is ready, construct the mapped future immediately.\n+  if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n+    // Short-circuit and forward existing error to the mapped future.\n+    if (ABSL_PREDICT_FALSE(!Base::promise()->ok())) {\n+      return Future<R>(*Base::promise());\n+    }\n+\n+    // Construct the result future available with a result of invoking `f`.\n+    if constexpr (std::is_void_v<U>) {\n+      return Future<R>((f(), absl::OkStatus()));\n+    } else {\n+      return Future<R>(f());\n+    }\n+  }\n+\n+  // If `*this` is not ready yet, we need to create a new promise and fulfill\n+  // it with a result of `f` when `*this` becomes ready.\n+  auto [promise, future] = ::tsl::MakePromise<R>();\n+  OnReady(SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n+  return std::move(future);\n+}\n+\n+template <typename R, typename F, typename U, internal::Mappable<R, U>*>\n+[[nodiscard]] Future<R> Future<void>::Map(Executor& executor, F&& f) const {\n+  auto [promise, future] = ::tsl::MakePromise<R>();\n+\n+  OnReady([&executor, f = std::forward<F>(f),\n+           promise = std::move(promise)](const absl::Status& status) mutable {\n+    // Do not submit a task to the executor if the result is unused.\n+    if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+      promise.Set(Base::AbortedError());\n+      return;\n+    }\n+\n+    // Pass `status` by value because it's cheap to copy, instead of extending\n+    // the lifetime of the underlying async value storage.\n+    executor.Execute(\n+        std::bind(SetPromise<R, U>(std::move(promise), std::move(f)), status));\n+  });\n+\n+  return std::move(future);\n+}\n+\n+template <typename R, typename U, typename F>\n+auto Future<void>::SetPromise(typename Future<R>::Promise promise, F&& f) {\n+  return [promise = std::move(promise),\n+          f = std::forward<F>(f)](const absl::Status& status) mutable {\n+    // Do not compute `f` if the result is unused.\n+    if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+      promise.Set(Base::AbortedError());\n+      return;\n+    }\n+\n+    // Short-circuit and forward existing error to the mapped future.\n+    if (ABSL_PREDICT_FALSE(!status.ok())) {\n+      promise.Set(std::move(status));\n+      return;\n+    }\n+\n+    // Set the result future available with a result of invoking `f`.\n+    if constexpr (std::is_void_v<U>) {\n+      promise.Set((f(), absl::OkStatus()));\n+    } else {\n+      promise.Set(f());\n+    }\n+  };\n+}\n+\n }  // namespace tsl\n \n #endif  // XLA_TSL_CONCURRENCY_FUTURE_H_"
        },
        {
            "sha": "0177b9ed17a0893973a6f09542e8bf6569294747",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 84,
            "deletions": 84,
            "changes": 168,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e53fd8c655c7a6f3b3be9adda877ace77672b0f1/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e53fd8c655c7a6f3b3be9adda877ace77672b0f1/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=e53fd8c655c7a6f3b3be9adda877ace77672b0f1",
            "patch": "@@ -63,7 +63,7 @@ TEST(FutureTest, ValueConstructedFuture) {\n }\n \n TEST(FutureTest, StatelessFuture) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set();\n@@ -76,7 +76,7 @@ TEST(FutureTest, StatelessFuture) {\n }\n \n TEST(FutureTest, CreateFutureFromPromise) {\n-  auto [promise, _] = Future<int32_t>::MakePromise();\n+  auto [promise, _] = MakePromise<int32_t>();\n   Future<int32_t> future = promise.future();\n \n   EXPECT_FALSE(future.IsReady());\n@@ -85,7 +85,7 @@ TEST(FutureTest, CreateFutureFromPromise) {\n }\n \n TEST(FutureTest, StatefulFutureToStateless) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<> ready_future = future.GetReadyFuture();\n \n   EXPECT_FALSE(ready_future.IsReady());\n@@ -94,7 +94,7 @@ TEST(FutureTest, StatefulFutureToStateless) {\n }\n \n TEST(FutureTest, StatefulFutureToStatelessError) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<> ready_future = future.GetReadyFuture();\n \n   EXPECT_FALSE(ready_future.IsReady());\n@@ -103,7 +103,7 @@ TEST(FutureTest, StatefulFutureToStatelessError) {\n }\n \n TEST(FutureTest, MoveOnlyFutureToStateless) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n   Future<> ready_future = future.GetReadyFuture();\n \n   EXPECT_FALSE(future.IsReady());\n@@ -114,7 +114,7 @@ TEST(FutureTest, MoveOnlyFutureToStateless) {\n }\n \n TEST(FutureTest, MoveOnlyFutureToStatelessError) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n   Future<> ready_future = future.GetReadyFuture();\n \n   EXPECT_FALSE(future.IsReady());\n@@ -125,7 +125,7 @@ TEST(FutureTest, MoveOnlyFutureToStatelessError) {\n }\n \n TEST(FutureTest, CopyableFuture) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n \n   Future<int32_t> copy_constructed(future);\n   Future<int32_t> copy_assigned = future;\n@@ -138,7 +138,7 @@ TEST(FutureTest, CopyableFuture) {\n }\n \n TEST(FutureTest, MoveConstructedFuture) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   Future<std::unique_ptr<int32_t>> move_constructed(std::move(future));\n \n@@ -148,7 +148,7 @@ TEST(FutureTest, MoveConstructedFuture) {\n }\n \n TEST(FutureTest, MoveAssignedFuture) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   Future<std::unique_ptr<int32_t>> move_assigned = std::move(future);\n \n@@ -185,7 +185,7 @@ TEST(FutureTest, StatusMacro) {\n }\n \n TEST(FutureTest, AwaitMoveOnlyFuture) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   promise.Set(std::make_unique<int32_t>(42));\n \n@@ -194,7 +194,7 @@ TEST(FutureTest, AwaitMoveOnlyFuture) {\n }\n \n TEST(FutureTest, OnReadyRvalueFuture) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n \n   promise.Set(42);\n \n@@ -203,7 +203,7 @@ TEST(FutureTest, OnReadyRvalueFuture) {\n }\n \n TEST(FutureTest, OnReadyMoveOnlyFuture) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   promise.Set(std::make_unique<int32_t>(42));\n \n@@ -216,27 +216,27 @@ TEST(FutureTest, PromiseNotSet) {\n   Future<> future;\n   {\n     Promise<> promise;\n-    std::tie(promise, future) = Future<>::MakePromise();\n+    std::tie(promise, future) = MakePromise();\n   }\n   ASSERT_TRUE(future.IsReady());\n   EXPECT_THAT(future.Await(), Not(IsOk()));\n }\n \n TEST(FutureTest, PromiseSetTwice) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   promise.Set();\n   EXPECT_DEATH(promise.Set(), \"Promise must not be fulfilled more than once\");\n }\n \n TEST(FutureTest, UnlinkedPromiseIsUnique) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   EXPECT_FALSE(promise.IsUniqueReference());\n   future = {};\n   EXPECT_TRUE(promise.IsUniqueReference());\n }\n \n TEST(FutureTest, PromiseIsUnique) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   // Future is linked to the promise object.\n   EXPECT_FALSE(promise.IsUniqueReference());\n@@ -254,7 +254,7 @@ TEST(FutureTest, PromiseIsUnique) {\n }\n \n TEST(FutureTest, MapCopyableFuture) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n@@ -273,7 +273,7 @@ TEST(FutureTest, MapCopyableFuture) {\n }\n \n TEST(FutureTest, MapCopyableFutureError) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n \n   promise.Set(absl::InternalError(\"test\"));\n@@ -282,7 +282,7 @@ TEST(FutureTest, MapCopyableFutureError) {\n }\n \n TEST(FutureTest, MapMoveOnlyFuture) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   Future<std::unique_ptr<float>> mapped =\n       std::move(future).Map([](std::unique_ptr<int32_t> v) {\n@@ -298,7 +298,7 @@ TEST(FutureTest, MapMoveOnlyFuture) {\n }\n \n TEST(FutureTest, MapMoveOnlyFutureError) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n   Future<std::unique_ptr<float>> mapped =\n       std::move(future).Map([](std::unique_ptr<int32_t> v) {\n         return std::make_unique<float>(*v * 2.0f);\n@@ -315,7 +315,7 @@ TEST(FutureTest, MapCopyableWithInplaceConstructor) {\n     int32_t v;\n   };\n \n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<Struct> mapped = future.Map<Struct>([](int32_t v) { return v; });\n \n   promise.Set(42);\n@@ -329,7 +329,7 @@ TEST(FutureTest, MapMoveOnlyWithInplaceConstructor) {\n     int32_t v;\n   };\n \n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n   Future<Struct> mapped = std::move(future).Map<Struct>(\n       [](std::unique_ptr<int32_t> v) { return *v; });\n \n@@ -339,7 +339,7 @@ TEST(FutureTest, MapMoveOnlyWithInplaceConstructor) {\n }\n \n TEST(FutureTest, MapStatelessUnusedResult) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   bool called = false;\n   // We intentionally drop returned future to test that promise will not\n@@ -350,7 +350,7 @@ TEST(FutureTest, MapStatelessUnusedResult) {\n }\n \n TEST(FutureTest, MapStatelessOnExecutorUnusedResult) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   CountingExecutor executor;\n   bool called = false;\n@@ -363,7 +363,7 @@ TEST(FutureTest, MapStatelessOnExecutorUnusedResult) {\n }\n \n TEST(FutureTest, MapStatefulUnusedResult) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n \n   bool called = false;\n   // We intentionally drop returned future to test that promise will not\n@@ -374,7 +374,7 @@ TEST(FutureTest, MapStatefulUnusedResult) {\n }\n \n TEST(FutureTest, MapStatefulOnExecutorUnusedResult) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n \n   CountingExecutor executor;\n   bool called = false;\n@@ -387,7 +387,7 @@ TEST(FutureTest, MapStatefulOnExecutorUnusedResult) {\n }\n \n TEST(FutureTest, MapStatefulRvalueOnExecutorUnusedResult) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   CountingExecutor executor;\n   bool called = false;\n@@ -400,7 +400,7 @@ TEST(FutureTest, MapStatefulRvalueOnExecutorUnusedResult) {\n }\n \n TEST(FutureTest, TryMapCopyableFutureToStateless) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   promise.Set(42);\n \n   {\n@@ -416,7 +416,7 @@ TEST(FutureTest, TryMapCopyableFutureToStateless) {\n }\n \n TEST(FutureTest, TryMapCopyableFuture) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<float> mapped =\n       future.Map([](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n \n@@ -436,7 +436,7 @@ TEST(FutureTest, TryMapCopyableFuture) {\n }\n \n TEST(FutureTest, TryMapCopyableFutureForwardError) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<float> mapped =\n       future.Map([](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n \n@@ -446,7 +446,7 @@ TEST(FutureTest, TryMapCopyableFutureForwardError) {\n }\n \n TEST(FutureTest, TryMapCopyableFutureCreateError) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n   Future<float> mapped = future.Map([](int32_t v) -> absl::StatusOr<float> {\n     return absl::InternalError(\"test\");\n   });\n@@ -457,7 +457,7 @@ TEST(FutureTest, TryMapCopyableFutureCreateError) {\n }\n \n TEST(FutureTest, TryMapMoveOnlyFutureToStateless) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n   promise.Set(std::make_unique<int32_t>(42));\n \n   Future<> mapped = std::move(future).Map(\n@@ -466,7 +466,7 @@ TEST(FutureTest, TryMapMoveOnlyFutureToStateless) {\n }\n \n TEST(FutureTest, TryMapMoveOnlyFuture) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   Future<std::unique_ptr<float>> mapped = std::move(future).Map(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n@@ -482,7 +482,7 @@ TEST(FutureTest, TryMapMoveOnlyFuture) {\n }\n \n TEST(FutureTest, TryMapMoveOnlyFutureForwardError) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   Future<std::unique_ptr<float>> mapped = std::move(future).Map(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n@@ -498,7 +498,7 @@ TEST(FutureTest, TryMapMoveOnlyFutureForwardError) {\n }\n \n TEST(FutureTest, MapFutureCopies) {\n-  auto [promise, future] = Future<std::shared_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::shared_ptr<int32_t>>();\n   promise.Set(std::make_shared<int32_t>(42));\n \n   Future<std::shared_ptr<int32_t>> future0 = future;\n@@ -518,7 +518,7 @@ TEST(FutureTest, MapFutureCopies) {\n }\n \n TEST(FutureTest, TryMapMoveOnlyFutureCreateError) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   Future<std::unique_ptr<float>> mapped = std::move(future).Map(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n@@ -535,23 +535,23 @@ TEST(FutureTest, TryMapMoveOnlyFutureCreateError) {\n \n TEST(FutureTest, MapWithVoidFunctor) {\n   {\n-    auto [promise, future] = Future<>::MakePromise();\n+    auto [promise, future] = MakePromise();\n     promise.Set(absl::OkStatus());\n \n     Future<> mapped = future.Map([] {});\n     EXPECT_EQ(mapped.Await(), absl::OkStatus());\n   }\n \n   {\n-    auto [promise, future] = Future<int32_t>::MakePromise();\n+    auto [promise, future] = MakePromise<int32_t>();\n     promise.Set(42);\n \n     Future<> mapped = future.Map([](int32_t value) { EXPECT_EQ(value, 42); });\n     EXPECT_EQ(mapped.Await(), absl::OkStatus());\n   }\n \n   {\n-    auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+    auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n     promise.Set(std::make_unique<int32_t>(42));\n \n     Future<> mapped = std::move(future).Map(\n@@ -574,7 +574,7 @@ TEST(FutureTest, MapDoesNotCopy) {\n     Data& operator=(Data&& other) = delete;\n   };\n \n-  auto [promise, future] = Future<Data>::MakePromise();\n+  auto [promise, future] = MakePromise<Data>();\n \n   Future<> m0 = future.Map([](const Data& data) {});\n   Future<> m1 = future.Map([](Data data) {});\n@@ -604,7 +604,7 @@ TEST(FutureTest, DetachDoesnNotCopy) {\n     Data& operator=(Data&& other) = delete;\n   };\n \n-  auto [promise, future] = Future<Data>::MakePromise();\n+  auto [promise, future] = MakePromise<Data>();\n   auto detached = future.Detach(executor);\n \n   Future<> m0 = future.Map([](const Data& data) {});\n@@ -622,7 +622,7 @@ TEST(FutureTest, DetachDoesnNotCopy) {\n TEST(FutureTest, DetachAndMap) {\n   CountingExecutor executor;\n \n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   Future<> mapped = future.Detach(executor).Map([] {});\n   promise.Set(absl::OkStatus());\n@@ -635,7 +635,7 @@ TEST(FutureTest, MakeDetachedFuture) {\n   CountingExecutor executor;\n \n   {  // Stateless future.\n-    auto [promise, future] = Future<>::MakePromise(executor);\n+    auto [promise, future] = MakePromise(executor);\n     Future<> mapped = future.Map([] {});\n     promise.Set(absl::OkStatus());\n \n@@ -644,7 +644,7 @@ TEST(FutureTest, MakeDetachedFuture) {\n   }\n \n   {  // Stateful future.\n-    auto [promise, future] = Future<int32_t>::MakePromise(executor);\n+    auto [promise, future] = MakePromise<int32_t>(executor);\n     Future<> mapped = future.Map([](int32_t value) { EXPECT_EQ(value, 42); });\n     promise.Set(42);\n \n@@ -657,7 +657,7 @@ TEST(FutureTest, DetachMoveOnly) {\n   CountingExecutor executor;\n   static int32_t counter = 0;\n \n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n   auto detached = std::move(future).Detach(executor);\n \n   Future<> m0 = std::move(detached).Map([](std::unique_ptr<int32_t> value) {\n@@ -681,23 +681,23 @@ TEST(FutureTest, DetachOnThreadPool) {\n   Executor* executor = thread_pool.AsExecutor();\n \n   {  // Test both lvalue and rvalue stateless detached futures.\n-    auto [promise, future] = Future<>::MakePromise();\n+    auto [promise, future] = MakePromise();\n     Future<> detached = future.Detach(*executor);\n     detached.OnReady([](auto) { counter++; });\n     future.Detach(*executor).OnReady([](auto) { counter++; });\n     promise.Set(absl::OkStatus());\n   }\n \n   {  // Test both lvalue and rvalue stateful detached futures.\n-    auto [promise, future] = Future<int32_t>::MakePromise();\n+    auto [promise, future] = MakePromise<int32_t>();\n     Future<int32_t> detached = future.Detach(*executor);\n     detached.OnReady([](auto) { counter++; });\n     future.Detach(*executor).OnReady([](auto) { counter++; });\n     promise.Set(42);\n   }\n \n   {  // Test detached future with move-only payload.\n-    auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+    auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n     std::move(future).Detach(*executor).OnReady([](auto) { counter++; });\n     promise.Set(std::make_unique<int32_t>(42));\n   }\n@@ -707,7 +707,7 @@ TEST(FutureTest, DetachOnThreadPool) {\n }\n \n TEST(FutureTest, NoOpDetachDoesNotExecute) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   CountingExecutor executor;\n   (void)future.Detach(executor);\n@@ -716,7 +716,7 @@ TEST(FutureTest, NoOpDetachDoesNotExecute) {\n }\n \n TEST(FutureTest, NoOpMoveOnlyDetachDoesNotExecute) {\n-  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n \n   CountingExecutor executor;\n   (void)std::move(future).Detach(executor);\n@@ -741,7 +741,7 @@ TEST(FutureTest, MapOnExecutorDoesNotCopy) {\n     Data& operator=(Data&& other) = delete;\n   };\n \n-  auto [promise, future] = Future<Data>::MakePromise();\n+  auto [promise, future] = MakePromise<Data>();\n \n   Future<> m0 = future.Map(*executor, [](const Data& data) {});\n   Future<> m1 = future.Map(*executor, [](Data data) {});\n@@ -757,7 +757,7 @@ TEST(FutureTest, MapOnExecutorDoesNotCopy) {\n };\n \n TEST(FutureTest, StatelessError) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(absl::InternalError(\"test\"));\n@@ -790,7 +790,7 @@ TEST(FutureTest, StatelessImmediate) {\n }\n \n TEST(FutureTest, MapStatelessFuture) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   Future<float> mapped = future.Map([]() { return 42.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n@@ -805,7 +805,7 @@ TEST(FutureTest, MapStatelessFuture) {\n }\n \n TEST(FutureTest, MapStatelessToStatus) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   promise.Set(absl::OkStatus());\n \n   {\n@@ -822,7 +822,7 @@ TEST(FutureTest, MapStatelessToStatus) {\n }\n \n TEST(FutureTest, MapStatelessErrorToStatus) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   promise.Set(absl::InternalError(\"test\"));\n \n   Future<> mapped = future.Map([] { return absl::OkStatus(); });\n@@ -831,7 +831,7 @@ TEST(FutureTest, MapStatelessErrorToStatus) {\n }\n \n TEST(FutureTest, MapStatelessFutureError) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   Future<float> mapped = future.Map([]() { return 42.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n@@ -846,7 +846,7 @@ TEST(FutureTest, MapStatelessFutureError) {\n }\n \n TEST(FutureTest, MapStatelessFutureToStatusOr) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   Future<float> mapped =\n       future.Map([]() -> absl::StatusOr<float> { return 42.0f; });\n \n@@ -862,7 +862,7 @@ TEST(FutureTest, MapStatelessFutureToStatusOr) {\n }\n \n TEST(FutureTest, MapStatelessFutureForwardError) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   Future<float> mapped =\n       future.Map([]() -> absl::StatusOr<float> { return 42.0f; });\n \n@@ -872,7 +872,7 @@ TEST(FutureTest, MapStatelessFutureForwardError) {\n }\n \n TEST(FutureTest, MapStatelessFutureCreateError) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   Future<float> mapped = future.Map(\n       []() -> absl::StatusOr<float> { return absl::InternalError(\"test\"); });\n \n@@ -882,7 +882,7 @@ TEST(FutureTest, MapStatelessFutureCreateError) {\n }\n \n TEST(FutureTest, MapToStatelessFuture) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n   Future<float> mapped = future.MapTo(42.0f);\n \n   EXPECT_FALSE(future.IsReady());\n@@ -897,7 +897,7 @@ TEST(FutureTest, MapToStatelessFuture) {\n }\n \n TEST(FutureTest, StatefulFuture) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(42);\n@@ -907,7 +907,7 @@ TEST(FutureTest, StatefulFuture) {\n }\n \n TEST(FutureTest, StatusFuture) {\n-  auto [promise, future] = Future<>::MakePromise();\n+  auto [promise, future] = MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(absl::OkStatus());\n@@ -918,7 +918,7 @@ TEST(FutureTest, StatusFuture) {\n }\n \n TEST(FutureTest, StatusOrFuture) {\n-  auto [promise, future] = Future<int32_t>::MakePromise();\n+  auto [promise, future] = MakePromise<int32_t>();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(42);\n@@ -932,8 +932,8 @@ TEST(FutureTest, JoinFutures) {\n   EXPECT_TRUE(empty_join.IsReady());\n   EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n \n-  auto [promise0, future0] = Future<>::MakePromise();\n-  auto [promise1, future1] = Future<>::MakePromise();\n+  auto [promise0, future0] = MakePromise();\n+  auto [promise1, future1] = MakePromise();\n \n   std::vector<Future<>> futures0 = {future0};\n   std::vector<Future<>> futures1 = {future0, future1};\n@@ -959,8 +959,8 @@ TEST(FutureTest, JoinErrors) {\n   EXPECT_TRUE(empty_join.IsReady());\n   EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n \n-  auto [promise0, future0] = Future<>::MakePromise();\n-  auto [promise1, future1] = Future<>::MakePromise();\n+  auto [promise0, future0] = MakePromise();\n+  auto [promise1, future1] = MakePromise();\n \n   std::vector<Future<>> futures0 = {future0};\n   std::vector<Future<>> futures1 = {future0, future1};\n@@ -982,9 +982,9 @@ TEST(FutureTest, JoinErrors) {\n }\n \n TEST(FutureTest, WithProfiling) {\n-  auto [promise, future] = Future<int32_t>::MakePromise(\n-      [&] { return FutureHelpers::ProfilingKeys{}; },\n-      [&](FutureHelpers::ProfilingKeys) {});\n+  auto [promise, future] =\n+      MakePromise<int32_t>([&] { return FutureHelpers::ProfilingKeys{}; },\n+                           [&](FutureHelpers::ProfilingKeys) {});\n \n   auto update_profiling = FutureHelpers::WithProfiling(\n       std::move(future), [&] { return FutureHelpers::ProfilingKeys{}; },\n@@ -1000,7 +1000,7 @@ TEST(FutureTest, WithProfiling) {\n \n TEST(FutureTest, MakeSharedPromise) {\n   {  // Stateless future.\n-    auto [promise, future] = Future<>::MakePromise();\n+    auto [promise, future] = MakePromise();\n \n     auto shared_promise = std::move(promise).ToShared();\n     shared_promise->Set();\n@@ -1013,7 +1013,7 @@ TEST(FutureTest, MakeSharedPromise) {\n   }\n \n   {  // Stateful future.\n-    auto [promise, future] = Future<int32_t>::MakePromise();\n+    auto [promise, future] = MakePromise<int32_t>();\n \n     auto shared_promise = std::move(promise).ToShared();\n     shared_promise->Set(42);\n@@ -1030,14 +1030,14 @@ TEST(FutureTest, MakeOnStateless) {\n   InlineExecutor e;\n \n   {\n-    auto future = Future<>::MakeOn(e, [] { return absl::OkStatus(); });\n+    auto future = MakeFutureOn<void>(e, [] { return absl::OkStatus(); });\n     EXPECT_TRUE(future.IsReady());\n     EXPECT_EQ(future.Await(), absl::OkStatus());\n   }\n \n   {\n     auto future =\n-        Future<>::MakeOn(e, [] { return absl::InternalError(\"test\"); });\n+        MakeFutureOn<void>(e, [] { return absl::InternalError(\"test\"); });\n     EXPECT_TRUE(future.IsReady());\n     EXPECT_EQ(future.Await(), absl::InternalError(\"test\"));\n   }\n@@ -1052,26 +1052,26 @@ TEST(FutureTest, MakeOnStateful) {\n   };\n \n   {\n-    auto future = Future<int32_t>::MakeOn(executor, [] { return 42; });\n+    auto future = MakeFutureOn<int32_t>(executor, [] { return 42; });\n     EXPECT_TRUE(future.IsReady());\n     EXPECT_EQ(*future.Await(), 42);\n   }\n \n   {\n-    auto future = Future<Foo>::MakeOn(executor, [] { return 42; });\n+    auto future = MakeFutureOn<Foo>(executor, [] { return 42; });\n     EXPECT_TRUE(future.IsReady());\n     EXPECT_EQ(future.Await()->value, 42);\n   }\n \n   {\n-    auto future = Future<std::unique_ptr<int32_t>>::MakeOn(\n+    auto future = MakeFutureOn<std::unique_ptr<int32_t>>(\n         executor, [] { return std::make_unique<int32_t>(42); });\n     EXPECT_TRUE(future.IsReady());\n     EXPECT_EQ(**future.Await(), 42);\n   }\n \n   {\n-    auto future = Future<int32_t>::MakeOn(\n+    auto future = MakeFutureOn<int32_t>(\n         executor, [] { return absl::InternalError(\"test\"); });\n     EXPECT_TRUE(future.IsReady());\n     EXPECT_EQ(future.Await().status(), absl::InternalError(\"test\"));\n@@ -1120,7 +1120,7 @@ TEST(FutureTest, MapStatelessOnThreadPoolExecutor) {\n \n   {  // Create mapped future in a nested scope to make sure that `promise` and\n     // `future` are destroyed before the end of the test.\n-    auto [promise, future] = Future<>::MakePromise();\n+    auto [promise, future] = MakePromise();\n     for (size_t i = 0; i < 100; ++i) {\n       mapped.push_back(\n           future.Map(*thread_pool.AsExecutor(), [&] { ++counter; }));\n@@ -1140,7 +1140,7 @@ TEST(FutureTest, MapStatefulOnThreadPoolExecutor) {\n \n   {  // Create mapped future in a nested scope to make sure that `promise` and\n     // `future` are destroyed before the end of the test.\n-    auto [promise, future] = Future<int32_t>::MakePromise();\n+    auto [promise, future] = MakePromise<int32_t>();\n     for (size_t i = 0; i < 100; ++i) {\n       mapped.push_back(future.Map(*thread_pool.AsExecutor(),\n                                   [&](int32_t value) { counter += value; }));\n@@ -1160,7 +1160,7 @@ TEST(FutureTest, MapMoveOnlyOnThreadPoolExecutor) {\n \n   {  // Create mapped future in a nested scope to make sure that `promise` and\n     // `future` are destroyed before the end of the test.\n-    auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+    auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n     for (size_t i = 0; i < 100; ++i) {\n       mapped.push_back(future.Map(\n           *thread_pool.AsExecutor(),\n@@ -1182,7 +1182,7 @@ TEST(FutureTest, MapMoveOnlyRvalueOnThreadPoolExecutor) {\n   {  // Create mapped future in a nested scope to make sure that `promise` and\n     // `future` are destroyed before the end of the test.\n     for (size_t i = 0; i < 100; ++i) {\n-      auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+      auto [promise, future] = MakePromise<std::unique_ptr<int32_t>>();\n       mapped.push_back(std::move(future).Map(\n           *thread_pool.AsExecutor(),\n           [&](std::unique_ptr<int32_t> value) { counter += *value; }));\n@@ -1203,7 +1203,7 @@ TEST(FutureTest, DetachStatefulOnThreadPoolExecutor) {\n \n   {  // Create mapped future in a nested scope to make sure that `promise` and\n     // `future` are destroyed before the end of the test.\n-    auto [promise, future] = Future<int32_t>::MakePromise();\n+    auto [promise, future] = MakePromise<int32_t>();\n     for (size_t i = 0; i < 100; ++i) {\n       mapped.push_back(future.Detach(*executor).Map(\n           [&](int32_t value) { counter += value; }));\n@@ -1286,7 +1286,7 @@ static void BM_CreateAndMapStatelessFuture(benchmark::State& state) {\n   Future<> future(absl::OkStatus());\n \n   for (auto _ : state) {\n-    auto [promise, future] = Future<>::MakePromise();\n+    auto [promise, future] = MakePromise();\n     Future<int32_t> mapped = future.Map([] { return 42; });\n     promise.Set(absl::OkStatus());\n     benchmark::DoNotOptimize(mapped);"
        }
    ],
    "stats": {
        "total": 822,
        "additions": 459,
        "deletions": 363
    }
}