{
    "author": "ezhulenev",
    "message": "[xla] Add PjRtFuture<T>::MakePromise()\n\nMigrate PjRtFuture test and implementation to new API and deprecate CreatePromise().\n\nPiperOrigin-RevId: 803273778",
    "sha": "0f72faa176ba8f9747098e71806a3ceb8b0cba8b",
    "files": [
        {
            "sha": "15c72fed708e51ddf1f28d13bbe979cffc6adcac",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 68,
            "deletions": 68,
            "changes": 136,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0f72faa176ba8f9747098e71806a3ceb8b0cba8b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0f72faa176ba8f9747098e71806a3ceb8b0cba8b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=0f72faa176ba8f9747098e71806a3ceb8b0cba8b",
            "patch": "@@ -476,6 +476,14 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n     return Promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n   }\n \n+  // Returns a pair of connected Promise and PjRtFuture<T>. Setting the returned\n+  // promise will fulfill the connected future.\n+  static std::pair<Promise, PjRtFuture<T>> MakePromise() {\n+    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n+    PjRtFuture<T> future(promise);\n+    return std::make_pair(std::move(promise), std::move(future));\n+  }\n+\n   // Bring PjRtFutureBase constructors in scope.\n   using Base::Base;\n \n@@ -517,22 +525,21 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n             std::enable_if_t<!is_move_only && std::is_constructible_v<R, U>>* =\n                 nullptr>\n   PjRtFuture<R> Map(F&& f) const& {\n-    auto promise = PjRtFuture<R>::CreatePromise();\n+    auto [promise, future] = PjRtFuture<R>::MakePromise();\n \n     using Value = const absl::StatusOr<T>&;\n-    OnReady([promise, f = std::forward<F>(f)](Value value) mutable {\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](Value value) mutable {\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-        return;\n-      }\n-      if (ABSL_PREDICT_TRUE(value.ok())) {\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n         promise.emplace(absl::in_place_t{}, f(*value));\n       } else {\n         promise.Set(value.status());\n       }\n     });\n \n-    return PjRtFuture<R>(promise);\n+    return std::move(future);\n   }\n \n   // Returns an PjRtFuture<R> that is constructed from the result of invoking\n@@ -550,28 +557,26 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n             std::enable_if_t<std::is_constructible_v<R, U>>* = nullptr>\n   PjRtFuture<R> Map(F&& f) && {\n-    auto promise = PjRtFuture<R>::CreatePromise();\n+    auto [promise, future] = PjRtFuture<R>::MakePromise();\n \n     using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n                                      const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady(\n-        [promise, f = std::forward<F>(f)](Value value) mutable {\n-          if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-            promise.Set(Base::AbortedError());\n-            return;\n-          }\n-          if (ABSL_PREDICT_TRUE(value.ok())) {\n-            if constexpr (is_move_only) {\n-              promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n-            } else {\n-              promise.emplace(absl::in_place_t{}, f(*value));\n-            }\n-          } else {\n-            promise.Set(value.status());\n-          }\n-        });\n+    std::move(*this).OnReady([promise = std::move(promise),\n+                              f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n+        if constexpr (is_move_only) {\n+          promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n+        } else {\n+          promise.emplace(absl::in_place_t{}, f(*value));\n+        }\n+      } else {\n+        promise.Set(value.status());\n+      }\n+    });\n \n-    return PjRtFuture<R>(promise);\n+    return std::move(future);\n   }\n \n   // Returns an PjRtFuture<R> that is constructed from the result of invoking\n@@ -592,15 +597,14 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n                        std::is_constructible_v<R, typename U::value_type>>* =\n           nullptr>\n   PjRtFuture<R> TryMap(F&& f) const& {\n-    auto promise = PjRtFuture<R>::CreatePromise();\n+    auto [promise, future] = PjRtFuture<R>::MakePromise();\n \n     using Value = const absl::StatusOr<T>&;\n-    OnReady([promise, f = std::forward<F>(f)](Value value) mutable {\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](Value value) mutable {\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-        return;\n-      }\n-      if (ABSL_PREDICT_TRUE(value.ok())) {\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n         auto result = f(*value);\n         if (ABSL_PREDICT_TRUE(result.ok())) {\n           promise.emplace(absl::in_place_t{}, *std::move(result));\n@@ -612,7 +616,7 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n       }\n     });\n \n-    return PjRtFuture<R>(promise);\n+    return std::move(future);\n   }\n \n   // Returns an PjRtFuture<R> that is constructed from the result of invoking\n@@ -634,35 +638,33 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n                 is_status_or<U> &&\n                 std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n   PjRtFuture<R> TryMap(F&& f) && {\n-    auto promise = PjRtFuture<R>::CreatePromise();\n+    auto [promise, future] = PjRtFuture<R>::MakePromise();\n \n     using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n                                      const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady(\n-        [promise, f = std::forward<F>(f)](Value value) mutable {\n-          if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-            promise.Set(Base::AbortedError());\n-            return;\n-          }\n-          if (ABSL_PREDICT_TRUE(value.ok())) {\n-            auto result = [&] {\n-              if constexpr (is_move_only) {\n-                return f(std::move(*value));\n-              } else {\n-                return f(*value);\n-              }\n-            }();\n-            if (ABSL_PREDICT_TRUE(result.ok())) {\n-              promise.emplace(absl::in_place_t{}, *std::move(result));\n-            } else {\n-              promise.Set(std::move(result).status());\n-            }\n+    std::move(*this).OnReady([promise = std::move(promise),\n+                              f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n+        auto result = [&] {\n+          if constexpr (is_move_only) {\n+            return f(std::move(*value));\n           } else {\n-            promise.Set(value.status());\n+            return f(*value);\n           }\n-        });\n+        }();\n+        if (ABSL_PREDICT_TRUE(result.ok())) {\n+          promise.emplace(absl::in_place_t{}, *std::move(result));\n+        } else {\n+          promise.Set(std::move(result).status());\n+        }\n+      } else {\n+        promise.Set(value.status());\n+      }\n+    });\n \n-    return PjRtFuture<R>(promise);\n+    return std::move(future);\n   }\n \n   // A `Map` overload that automatically infers the type of result from `f`.\n@@ -735,8 +737,8 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   // Returns a pair of connected Promise and PjRtFuture<>. Setting the returned\n   // promise will fulfill the connected future.\n   static std::pair<Promise, PjRtFuture<>> MakePromise() {\n-    auto promise = Promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n-    auto future = PjRtFuture<void>(promise);\n+    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n+    PjRtFuture<> future(promise);\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n@@ -782,21 +784,20 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n   //\n   template <typename R, typename F, typename U = std::invoke_result_t<F>>\n   PjRtFuture<R> Map(F&& f) {\n-    auto promise = PjRtFuture<R>::CreatePromise();\n+    auto [promise, future] = PjRtFuture<R>::MakePromise();\n \n-    OnReady([promise, f = std::forward<F>(f)](absl::Status status) mutable {\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](absl::Status status) mutable {\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-        return;\n-      }\n-      if (ABSL_PREDICT_TRUE(status.ok())) {\n+      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n         promise.emplace(absl::in_place_t{}, f());\n       } else {\n         promise.Set(std::move(status));\n       }\n     });\n \n-    return PjRtFuture<R>(promise);\n+    return std::move(future);\n   }\n \n   // Returns an PjRtFuture<R> that is constructed from the result of invoking\n@@ -816,14 +817,13 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n                 is_status_or<U> &&\n                 std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n   PjRtFuture<R> TryMap(F&& f) {\n-    auto promise = PjRtFuture<R>::CreatePromise();\n+    auto [promise, future] = PjRtFuture<R>::MakePromise();\n \n-    OnReady([promise, f = std::forward<F>(f)](absl::Status status) mutable {\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](absl::Status status) mutable {\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n-        return;\n-      }\n-      if (ABSL_PREDICT_TRUE(status.ok())) {\n+      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n         auto result = f();\n         if (ABSL_PREDICT_TRUE(result.ok())) {\n           promise.emplace(absl::in_place_t{}, *std::move(result));\n@@ -835,7 +835,7 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n       }\n     });\n \n-    return PjRtFuture<R>(promise);\n+    return std::move(future);\n   }\n \n   // A `Map` overload that automatically infers the type of result from `f`.\n@@ -890,7 +890,7 @@ PjRtFuture<> PjRtFutureBase<T, is_move_only>::GetReadyFuture() const {\n           promise.Set(self->status());\n         }\n       });\n-  return future;\n+  return std::move(future);\n }\n \n }  // namespace internal"
        },
        {
            "sha": "d463d2438976c5829018cb43b409e4e46247f850",
            "filename": "third_party/xla/xla/pjrt/pjrt_future_test.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 69,
            "changes": 125,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0f72faa176ba8f9747098e71806a3ceb8b0cba8b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0f72faa176ba8f9747098e71806a3ceb8b0cba8b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc?ref=0f72faa176ba8f9747098e71806a3ceb8b0cba8b",
            "patch": "@@ -53,52 +53,47 @@ TEST(PjRtFutureTest, StatelessFuture) {\n }\n \n TEST(PjRtFutureTest, StatefulFutureToStateless) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n-  PjRtFuture<> on_ready_future = future.GetReadyFuture();\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n+  PjRtFuture<> ready_future = future.GetReadyFuture();\n \n-  EXPECT_FALSE(on_ready_future.IsReady());\n+  EXPECT_FALSE(ready_future.IsReady());\n   promise.Set(42);\n-  EXPECT_EQ(on_ready_future.Await(), absl::OkStatus());\n+  EXPECT_EQ(ready_future.Await(), absl::OkStatus());\n }\n \n TEST(PjRtFutureTest, StatefulFutureToStatelessError) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n-  PjRtFuture<> on_ready_future = future.GetReadyFuture();\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n+  PjRtFuture<> ready_future = future.GetReadyFuture();\n \n-  EXPECT_FALSE(on_ready_future.IsReady());\n+  EXPECT_FALSE(ready_future.IsReady());\n   promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_EQ(on_ready_future.Await(), absl::InternalError(\"test\"));\n+  EXPECT_EQ(ready_future.Await(), absl::InternalError(\"test\"));\n }\n \n TEST(PjRtFutureTest, MoveOnlyFutureToStateless) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n-  PjRtFuture<> on_ready_future = future.GetReadyFuture();\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n+  PjRtFuture<> ready_future = future.GetReadyFuture();\n \n   EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(on_ready_future.IsReady());\n+  EXPECT_FALSE(ready_future.IsReady());\n \n   promise.Set(std::make_unique<int32_t>(42));\n-  EXPECT_EQ(on_ready_future.Await(), absl::OkStatus());\n+  EXPECT_EQ(ready_future.Await(), absl::OkStatus());\n }\n \n TEST(PjRtFutureTest, MoveOnlyFutureToStatelessError) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n-  PjRtFuture<> on_ready_future = future.GetReadyFuture();\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n+  PjRtFuture<> ready_future = future.GetReadyFuture();\n \n   EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(on_ready_future.IsReady());\n+  EXPECT_FALSE(ready_future.IsReady());\n \n   promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_EQ(on_ready_future.Await(), absl::InternalError(\"test\"));\n+  EXPECT_EQ(ready_future.Await(), absl::InternalError(\"test\"));\n }\n \n TEST(PjRtFutureTest, CopyableFuture) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n \n   PjRtFuture<int32_t> copy_constructed(future);\n   PjRtFuture<int32_t> copy_assigned = future;\n@@ -111,8 +106,7 @@ TEST(PjRtFutureTest, CopyableFuture) {\n }\n \n TEST(PjRtFutureTest, MoveConstructedFuture) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n   PjRtFuture<std::unique_ptr<int32_t>> move_constructed(std::move(future));\n \n@@ -122,8 +116,7 @@ TEST(PjRtFutureTest, MoveConstructedFuture) {\n }\n \n TEST(PjRtFutureTest, MoveAssignedFuture) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n   PjRtFuture<std::unique_ptr<int32_t>> move_assigned = std::move(future);\n \n@@ -133,8 +126,7 @@ TEST(PjRtFutureTest, MoveAssignedFuture) {\n }\n \n TEST(PjRtFutureTest, AwaitMoveOnlyFuture) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n   promise.Set(std::make_unique<int32_t>(42));\n \n@@ -143,8 +135,7 @@ TEST(PjRtFutureTest, AwaitMoveOnlyFuture) {\n }\n \n TEST(PjRtFutureTest, OnReadyRvalueFuture) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n \n   promise.Set(42);\n \n@@ -153,8 +144,7 @@ TEST(PjRtFutureTest, OnReadyRvalueFuture) {\n }\n \n TEST(PjRtFutureTest, OnReadyMoveOnlyFuture) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n   promise.Set(std::make_unique<int32_t>(42));\n \n@@ -163,30 +153,40 @@ TEST(PjRtFutureTest, OnReadyMoveOnlyFuture) {\n   });\n }\n \n-TEST(PjRtFutureTest, PromiseIsUnique) {\n-  auto promise = PjRtFuture<>::CreatePromise();\n+TEST(PjRtFutureTest, UnlinkedPromiseIsUnique) {\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n+  EXPECT_FALSE(promise.IsUniqueReference());\n+  future = {};\n   EXPECT_TRUE(promise.IsUniqueReference());\n+}\n \n-  {\n-    auto copy = promise;\n-    EXPECT_FALSE(promise.IsUniqueReference());\n-    EXPECT_FALSE(copy.IsUniqueReference());\n-  }\n-  EXPECT_TRUE(promise.IsUniqueReference());\n+TEST(PjRtFutureTest, PromiseIsUnique) {\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n \n-  PjRtFuture<> future(promise);\n+  // Future is linked to the promise object.\n   EXPECT_FALSE(promise.IsUniqueReference());\n+\n+  // Future is destroyed, but we added a callback to underlying value.\n   future.OnReady([](const absl::Status&) {});\n   future = {};\n   EXPECT_FALSE(promise.IsUniqueReference());\n \n+  // Once promise is fulfilled, the callback is executed, and because we\n+  // destroyed the future, the underlying value is not referenced by anyone\n+  // else, and the promise becomes unique.\n   promise.Set();\n   EXPECT_TRUE(promise.IsUniqueReference());\n+\n+  {  // Making a copy of the promise makes it not unique.\n+    auto copy = promise;\n+    EXPECT_FALSE(promise.IsUniqueReference());\n+    EXPECT_FALSE(copy.IsUniqueReference());\n+  }\n+  EXPECT_TRUE(promise.IsUniqueReference());\n }\n \n TEST(PjRtFutureTest, MapCopyableFuture) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n   PjRtFuture<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n \n   EXPECT_FALSE(future.IsReady());\n@@ -205,8 +205,7 @@ TEST(PjRtFutureTest, MapCopyableFuture) {\n }\n \n TEST(PjRtFutureTest, MapCopyableFutureError) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n   PjRtFuture<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n \n   promise.Set(absl::InternalError(\"test\"));\n@@ -215,9 +214,8 @@ TEST(PjRtFutureTest, MapCopyableFutureError) {\n }\n \n TEST(PjRtFutureTest, MapMoveOnlyFuture) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n   PjRtFuture<std::unique_ptr<float>> mapped =\n       std::move(future).Map([](std::unique_ptr<int32_t> v) {\n         return std::make_unique<float>(*v * 2.0f);\n@@ -232,8 +230,7 @@ TEST(PjRtFutureTest, MapMoveOnlyFuture) {\n }\n \n TEST(PjRtFutureTest, MapMoveOnlyFutureError) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n   PjRtFuture<std::unique_ptr<float>> mapped =\n       std::move(future).Map([](std::unique_ptr<int32_t> v) {\n         return std::make_unique<float>(*v * 2.0f);\n@@ -250,8 +247,7 @@ TEST(PjRtFutureTest, MapCopyableWithInplaceConstructor) {\n     int32_t v;\n   };\n \n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n   PjRtFuture<Struct> mapped = future.Map<Struct>([](int32_t v) { return v; });\n \n   promise.Set(42);\n@@ -265,8 +261,7 @@ TEST(PjRtFutureTest, MapMoveOnlyWithInplaceConstructor) {\n     int32_t v;\n   };\n \n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n   PjRtFuture<Struct> mapped = std::move(future).Map<Struct>(\n       [](std::unique_ptr<int32_t> v) { return *v; });\n \n@@ -302,8 +297,7 @@ TEST(PjRtFutureTest, MapStatusUnusedResult) {\n }\n \n TEST(PjRtFutureTest, TryMapCopyableFuture) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n   PjRtFuture<float> mapped = future.TryMap(\n       [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n \n@@ -323,8 +317,7 @@ TEST(PjRtFutureTest, TryMapCopyableFuture) {\n }\n \n TEST(PjRtFutureTest, TryMapCopyableFutureForwardError) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n   PjRtFuture<float> mapped = future.TryMap(\n       [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n \n@@ -334,8 +327,7 @@ TEST(PjRtFutureTest, TryMapCopyableFutureForwardError) {\n }\n \n TEST(PjRtFutureTest, TryMapCopyableFutureCreateError) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n   PjRtFuture<float> mapped =\n       future.TryMap([](int32_t v) -> absl::StatusOr<float> {\n         return absl::InternalError(\"test\");\n@@ -347,9 +339,8 @@ TEST(PjRtFutureTest, TryMapCopyableFutureCreateError) {\n }\n \n TEST(PjRtFutureTest, TryMapMoveOnlyFuture) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n   PjRtFuture<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n         return std::make_unique<float>(*v * 2.0f);\n@@ -364,9 +355,8 @@ TEST(PjRtFutureTest, TryMapMoveOnlyFuture) {\n }\n \n TEST(PjRtFutureTest, TryMapMoveOnlyFutureForwardError) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n   PjRtFuture<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n         return std::make_unique<float>(*v * 2.0f);\n@@ -381,9 +371,8 @@ TEST(PjRtFutureTest, TryMapMoveOnlyFutureForwardError) {\n }\n \n TEST(PjRtFutureTest, TryMapMoveOnlyFutureCreateError) {\n-  auto promise = PjRtFuture<std::unique_ptr<int32_t>>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n \n-  PjRtFuture<std::unique_ptr<int32_t>> future(promise);\n   PjRtFuture<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n       [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n         return absl::InternalError(\"test\");\n@@ -538,8 +527,7 @@ TEST(PjRtFutureTest, MapToStatelessFuture) {\n }\n \n TEST(PjRtFutureTest, StatefulFuture) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(42);\n@@ -560,8 +548,7 @@ TEST(PjRtFutureTest, StatusFuture) {\n }\n \n TEST(PjRtFutureTest, StatusOrFuture) {\n-  auto promise = PjRtFuture<int32_t>::CreatePromise();\n-  PjRtFuture<int32_t> future(promise);\n+  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n \n   EXPECT_FALSE(future.IsReady());\n   promise.Set(42);"
        }
    ],
    "stats": {
        "total": 261,
        "additions": 124,
        "deletions": 137
    }
}