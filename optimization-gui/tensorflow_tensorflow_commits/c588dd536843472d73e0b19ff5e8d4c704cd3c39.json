{
    "author": "majiddadashi",
    "message": "Use signless i4 for the TF_Int4 type to align with other TF integer types.\n\nThe other TensorFlow integer types in MLIR (TF_Int8, TF_Int16, etc.) are represented by signless MLIR integer types (i8, i16). However, TF_Int4 was inconsistently defined to use a signed type (si4).\n\nThis CL changes TF_Int4 to use a signless i4 for consistency. This involves updating:\n- The TableGen definition in `tf_op_base.td`.\n- The type conversion logic for `DT_INT4` in `convert_type.cc`.\n\nAdditionally, the conversion for `DT_UINT4` is updated to use the more explicit `mlir::IntegerType::SignednessSemantics::Unsigned` enum for clarity.\n\nPiperOrigin-RevId: 815873083",
    "sha": "c588dd536843472d73e0b19ff5e8d4c704cd3c39",
    "files": [
        {
            "sha": "4072798c2846502f80609e836a714c8e22694a50",
            "filename": "tensorflow/compiler/mlir/tensorflow/ir/tf_op_base.td",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c588dd536843472d73e0b19ff5e8d4c704cd3c39/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Fir%2Ftf_op_base.td",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c588dd536843472d73e0b19ff5e8d4c704cd3c39/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Fir%2Ftf_op_base.td",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Fir%2Ftf_op_base.td?ref=c588dd536843472d73e0b19ff5e8d4c704cd3c39",
            "patch": "@@ -366,7 +366,7 @@ def TF_VariantRef : TF_TensorFlowType<\"VariantRef\", \"variantref\">;\n \n def TF_Bool : AnyTypeOf<[I<1>, TF_BoolRef], \"bool\">;\n \n-def TF_Int4 : AnyTypeOf<[SI<4>, TF_Int4Ref], \"4-bit integer\">;\n+def TF_Int4 : AnyTypeOf<[I<4>, TF_Int4Ref], \"4-bit integer\">;\n def TF_Int8 : AnyTypeOf<[I8, TF_Int8Ref], \"8-bit integer\">;\n def TF_Int16 : AnyTypeOf<[I16, TF_Int16Ref], \"16-bit integer\">;\n def TF_Int32 : AnyTypeOf<[I32, TF_Int32Ref], \"32-bit integer\">;"
        },
        {
            "sha": "a34553623408d8a91430de5049c8bad3cbdd7a9a",
            "filename": "tensorflow/compiler/mlir/tensorflow/utils/convert_tensor_test.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 14,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c588dd536843472d73e0b19ff5e8d4c704cd3c39/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Futils%2Fconvert_tensor_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c588dd536843472d73e0b19ff5e8d4c704cd3c39/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Futils%2Fconvert_tensor_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Futils%2Fconvert_tensor_test.cc?ref=c588dd536843472d73e0b19ff5e8d4c704cd3c39",
            "patch": "@@ -42,7 +42,7 @@ using ::testing::Eq;\n using ::testing::IsFalse;\n using ::testing::IsTrue;\n \n-static void RegisterDialects(mlir::MLIRContext &context) {\n+static void RegisterDialects(mlir::MLIRContext& context) {\n   context.loadDialect<mlir::TF::TensorFlowDialect>();\n }\n \n@@ -159,10 +159,9 @@ TEST_F(ConvertTensorTest, Simple) {\n       {tsl::float8_e5m2fnuz{1.0}, tsl::float8_e5m2fnuz{-1.0}},\n       DT_FLOAT8_E5M2FNUZ, mlir::Float8E5M2FNUZType::get(&context)));\n \n-  ASSERT_NO_FATAL_FAILURE(VerifyConversion<int4>(\n-      {static_cast<int4>(1), static_cast<int4>(-1)}, DT_INT4,\n-      mlir::IntegerType::get(&context, 4,\n-                             mlir::IntegerType::SignednessSemantics::Signed)));\n+  ASSERT_NO_FATAL_FAILURE(VerifyConversion<tsl::int4>(\n+      {static_cast<tsl::int4>(1), static_cast<tsl::int4>(-1)}, DT_INT4,\n+      mlir::IntegerType::get(&context, 4)));\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<int8>(\n       {1, -1}, DT_INT8, mlir::IntegerType::get(&context, 8)));\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<int16>(\n@@ -172,8 +171,8 @@ TEST_F(ConvertTensorTest, Simple) {\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<int64_t>(\n       {1, -1}, DT_INT64, mlir::IntegerType::get(&context, 64)));\n \n-  ASSERT_NO_FATAL_FAILURE(VerifyConversion<uint4>(\n-      {static_cast<uint4>(1), static_cast<uint4>(2)}, DT_UINT4,\n+  ASSERT_NO_FATAL_FAILURE(VerifyConversion<tsl::uint4>(\n+      {static_cast<tsl::uint4>(1), static_cast<tsl::uint4>(2)}, DT_UINT4,\n       mlir::IntegerType::get(\n           &context, 4, mlir::IntegerType::SignednessSemantics::Unsigned)));\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<uint8>(\n@@ -220,11 +219,9 @@ TEST_F(ConvertTensorTest, SimpleDenseResourceElements) {\n       {tsl::float8_e4m3fn{1.0}, tsl::float8_e4m3fn{-1.0}}, DT_FLOAT8_E4M3FN,\n       mlir::Float8E4M3FNType::get(&context), true));\n \n-  ASSERT_NO_FATAL_FAILURE(VerifyConversion<int4>(\n-      {static_cast<int4>(1), static_cast<int4>(-1)}, DT_INT4,\n-      mlir::IntegerType::get(&context, 4,\n-                             mlir::IntegerType::SignednessSemantics::Signed),\n-      true));\n+  ASSERT_NO_FATAL_FAILURE(VerifyConversion<tsl::int4>(\n+      {static_cast<tsl::int4>(1), static_cast<tsl::int4>(-1)}, DT_INT4,\n+      mlir::IntegerType::get(&context, 4), true));\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<int8>(\n       {1, -1}, DT_INT8, mlir::IntegerType::get(&context, 8), true));\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<int16>(\n@@ -234,8 +231,8 @@ TEST_F(ConvertTensorTest, SimpleDenseResourceElements) {\n   ASSERT_NO_FATAL_FAILURE(VerifyConversion<int64_t>(\n       {1, -1}, DT_INT64, mlir::IntegerType::get(&context, 64), true));\n \n-  ASSERT_NO_FATAL_FAILURE(VerifyConversion<uint4>(\n-      {static_cast<uint4>(1), static_cast<uint4>(2)}, DT_UINT4,\n+  ASSERT_NO_FATAL_FAILURE(VerifyConversion<tsl::uint4>(\n+      {static_cast<tsl::uint4>(1), static_cast<tsl::uint4>(2)}, DT_UINT4,\n       mlir::IntegerType::get(&context, 4,\n                              mlir::IntegerType::SignednessSemantics::Unsigned),\n       true));"
        },
        {
            "sha": "3ee10daba1a4663fddd50c50536c7c5495655940",
            "filename": "tensorflow/compiler/mlir/tensorflow/utils/convert_type.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c588dd536843472d73e0b19ff5e8d4c704cd3c39/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Futils%2Fconvert_type.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c588dd536843472d73e0b19ff5e8d4c704cd3c39/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Futils%2Fconvert_type.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftensorflow%2Futils%2Fconvert_type.cc?ref=c588dd536843472d73e0b19ff5e8d4c704cd3c39",
            "patch": "@@ -98,7 +98,8 @@ absl::Status ConvertDataType(DataType dtype, Builder builder, Type* type) {\n       *type = builder.getType<mlir::Float8E5M2FNUZType>();\n       return absl::OkStatus();\n     case DT_INT4:\n-      *type = builder.getIntegerType(4, /*isSigned=*/true);\n+      // build a **signless** integer type.\n+      *type = builder.getIntegerType(4);\n       return absl::OkStatus();\n     case DT_UINT4:\n       *type = builder.getIntegerType(4, /*isSigned=*/false);"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 14,
        "deletions": 16
    }
}