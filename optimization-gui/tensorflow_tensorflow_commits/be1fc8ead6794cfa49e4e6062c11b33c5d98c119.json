{
    "author": "bchetioui",
    "message": "[XLA:GPU] Rewrite `fusion_emitter_int4_device_test` to properly call into the generic Triton emitter.\n\nThe previous port was only approximate, and did not reliably lower through the\ngeneric Triton emitter, leading to failures as I attempted to delete the legacy\npath.\n\nDeleted tests:\n\n* `ConvertPlusNegate`, was introduced in [1] and seems to not be a\ngreat test since it's just testing that having an additional elementwise after\nan upcast works (should be tested by composition);\n* `NegatePlusConvertHLO`, for the same reasons as above [2]. (That\ntest was not even verifying that it is running through Triton.);\n* `LHSNonMinorContractingDimWithBatchDim0`, which is just a batched version of\n`LHSNonMinorContractingDim`. In the generic Triton emitter, adding a batch\ndimension is completely tangential to testing `int4`;\n* `LHSMinorContractingDimWithBatchDim0`, for the same reasons as above with\nregards to `LHSMinorContractingDim`;\n* `RHSTestWithMinorContractingDimWithBatchDim`, for the same reasons as above\nwith regards to `RHSTestWithMinorContractingDim`;\n* `RHSTestWithNotMinorContractingDimWithBatchDim0`, for the same reasons as\nabove with regards to `RHSTestWithNotMinorContractingDim`;\n* `FusedBroadcastAddBroadcastMultiplyDotGeneratesValidTriton`, which is a\nregression test purely pertaining to the legacy matmul emitter [3];\n* `DotWithI4WeightsOnLhsWithNonStandardLayoutAndMultplyInEpilogue`, which\ncombines having a non-standard layout with having a multiplication in the\nepilogue. However, `TritonTest.NonstandardLayoutInt4` already tests a\nnon-standard layout, and there is no reason for an epilogue multiplication to\nnot be purely orthogonal to this;\n* `DotWithI4WeightsOnLhsWithBitcastTo3dTensor`, because the bitcast is just\nhoisted and therefore doesn't bring any useful coverage;\n* `FuseBroadcastInPrologue`, because it is entirely covered by\n`FuseBroadcastBitcastMultiplyInPrologue` (which, while it may look overkill,\ndoes check a proper subchannel dequantization pattern---and seems therefore to\nbe a reasonable test to keep);\n* `FuseBroadcastBitcastInPrologue`, for the same reason as above;\n* `FuseSubchannelDequantizationFusedWithSmallBlockKSize`, and I lowered the\nvalue associated with `block_k` in `FuseSubchannelDequantizationFused` to\ncover this use case. Once we test the smaller value, there doesn't seem to\nbe much value in testing the larger one.\n\nPiperOrigin-RevId: 833481384",
    "sha": "be1fc8ead6794cfa49e4e6062c11b33c5d98c119",
    "files": [
        {
            "sha": "27ecbd0cfea4326cb45e2a7b78573c3d3130ea20",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/fusion_emitter_int4_device_test.cc",
            "status": "modified",
            "additions": 506,
            "deletions": 805,
            "changes": 1311,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/be1fc8ead6794cfa49e4e6062c11b33c5d98c119/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter_int4_device_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/be1fc8ead6794cfa49e4e6062c11b33c5d98c119/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter_int4_device_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter_int4_device_test.cc?ref=be1fc8ead6794cfa49e4e6062c11b33c5d98c119",
            "patch": "@@ -19,9 +19,6 @@ limitations under the License.\n #include <vector>\n \n #include <gtest/gtest.h>\n-#include \"absl/algorithm/container.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_replace.h\"\n #include \"absl/strings/str_split.h\"\n@@ -32,11 +29,9 @@ limitations under the License.\n #include \"xla/hlo/analysis/symbolic_expr.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n-#include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/testlib/filecheck.h\"\n #include \"xla/service/gpu/backend_configs.pb.h\"\n #include \"xla/service/gpu/tests/gpu_codegen_test.h\"\n-#include \"xla/service/gpu/transforms/nest_gemm_fusion.h\"\n #include \"xla/stream_executor/device_description.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla.pb.h\"\n@@ -58,98 +53,9 @@ class TritonTest : public GpuCodegenTest {\n     debug_options.set_xla_gpu_gemm_rewrite_size_threshold(0);\n     debug_options\n         .set_xla_gpu_experimental_enable_subchannel_dequantisation_fusion(true);\n-    // TODO(b/393299275): remove this once flag is on by default and test is\n-    // updated.\n-    // Note that we clear\n-    // xla_gpu_unsupported_generic_triton_emitter_opts here to disable\n-    // nest gemm fusion pass as test will run the pass manually.\n-    debug_options.clear_xla_gpu_unsupported_generic_triton_emitter_features();\n     return debug_options;\n   }\n \n-  ::testing::AssertionResult RunAndCompare(absl::string_view hlo_text,\n-                                           ErrorSpec error_spec) {\n-    auto module_or = GetOptimizedModule(hlo_text);\n-    if (!module_or.ok()) {\n-      return ::testing::AssertionFailure() << module_or.status().message();\n-    }\n-    return NestFusionsRunAndCompare(std::move(*module_or), error_spec);\n-  }\n-\n-  ::testing::AssertionResult RunAndCompare(std::unique_ptr<HloModule> module,\n-                                           ErrorSpec error_spec) {\n-    auto module_or = GetOptimizedModule(std::move(module));\n-    if (!module_or.ok()) {\n-      return ::testing::AssertionFailure() << module_or.status().message();\n-    }\n-    return NestFusionsRunAndCompare(std::move(*module_or), error_spec);\n-  }\n-\n-  ::testing::AssertionResult RunAndCompareNoHloPasses(\n-      absl::string_view hlo_text, ErrorSpec error_spec) {\n-    auto module_or = ParseAndReturnVerifiedModule(hlo_text);\n-    if (!module_or.ok()) {\n-      return ::testing::AssertionFailure() << module_or.status().message();\n-    }\n-    return NestFusionsRunAndCompare(std::move(*module_or), error_spec);\n-  }\n-\n-  ::testing::AssertionResult NestFusionsRunAndCompare(\n-      std::unique_ptr<HloModule> module, ErrorSpec error_spec) {\n-    if (absl::Status status = MaybeAddTritonGemmConfig(module.get());\n-        !status.ok()) {\n-      return ::testing::AssertionFailure() << status.message();\n-    }\n-    // NestGemmFusion pass is controlled by\n-    // xla_gpu_unsupported_generic_triton_emitter_opts flag, set it now.\n-    auto* emitter_opts =\n-        module->mutable_config()\n-            .mutable_debug_options()\n-            .mutable_xla_gpu_unsupported_generic_triton_emitter_features();\n-    emitter_opts->Add(DebugOptions::GENERIC_TRITON_EMITTER_ENABLE_NESTED_GEMM);\n-    emitter_opts->Add(DebugOptions::GENERIC_TRITON_EMITTER_DISABLE_LEGACY_GEMM);\n-    emitter_opts->Add(\n-        DebugOptions::GENERIC_TRITON_EMITTER_ALLOW_ALL_OPS_IN_GEMM_FUSION);\n-    emitter_opts->Add(\n-        DebugOptions::GENERIC_TRITON_EMITTER_ALLOW_ALL_GEMM_SHAPES);\n-    absl::StatusOr<bool> nested_or =\n-        NestGemmFusion(device_desc(), &symbolic_expr_context_)\n-            .Run(module.get());\n-    if (!nested_or.ok()) {\n-      return ::testing::AssertionFailure() << nested_or.status().message();\n-    }\n-    EXPECT_TRUE(nested_or.value());\n-    return GpuCodegenTest::RunAndCompareNoHloPasses(std::move(module),\n-                                                    error_spec);\n-  }\n-\n-  absl::Status MaybeAddTritonGemmConfig(HloModule* module) {\n-    auto instructions = module->entry_computation()->instructions();\n-    auto it = absl::c_find_if(instructions, [](auto instruction) {\n-      return instruction->opcode() == HloOpcode::kFusion;\n-    });\n-    if (it == instructions.end()) {\n-      return absl::InternalError(\"No fusion in entry computation.\");\n-    }\n-    HloInstruction* fusion = *it;\n-    TF_ASSIGN_OR_RETURN(auto gpu_config,\n-                        fusion->backend_config<GpuBackendConfig>());\n-    FusionBackendConfig* backend_config =\n-        gpu_config.mutable_fusion_backend_config();\n-    if (backend_config->has_triton_gemm_config()) {\n-      return absl::OkStatus();\n-    }\n-    auto* triton_gemm_key = backend_config->mutable_triton_gemm_config();\n-    triton_gemm_key->set_block_m(64);\n-    triton_gemm_key->set_block_k(64);\n-    triton_gemm_key->set_block_n(64);\n-    triton_gemm_key->set_split_k(1);\n-    triton_gemm_key->set_num_stages(1);\n-    triton_gemm_key->set_num_warps(2);\n-    triton_gemm_key->set_num_ctas(1);\n-    return fusion->set_backend_config(gpu_config);\n-  }\n-\n  protected:\n   const stream_executor::DeviceDescription& device_desc() {\n     return backend().default_stream_executor()->GetDeviceDescription();\n@@ -159,70 +65,63 @@ class TritonTest : public GpuCodegenTest {\n };\n \n // The following tests are for the channel and subchannel dequantization\n-// fusions. We run the fused version to avoid the hlo passes and prove that\n-// emitters work correctly and unfused version with the goal to fail if an hlo\n+// fusions. We run the fused version to avoid the HLO passes and prove that\n+// emitters work correctly and unfused version with the goal to fail if an HLO\n // rewrite broke the dequantization logic.\n // For the subchannel dequantization there are two cases:\n // 1. The case where we do:\n //   broadcast -> multiply -> bitcast -> dot.\n // 2. The case where we do:\n //   broadcast -> reshape -> multiply -> dot.\n-// On top of that there could be an additional bitcast between the parameter and\n-// the broadcast.\n TEST_F(TritonTest, FuseChannelDequantizationFused) {\n-  // This test is a Channel Dequantization fusion.\n-  // We run the fused version to avoid the hlo passes.\n-  // The case where we do:\n-  // param(1) -> bitcast -> broadcast -> multiply -> bitcast -> dot.\n+  // This test is a channel dequantization fusion of the form:\n+  //   param(1) -> bitcast -> broadcast -> multiply -> bitcast -> dot.\n+  // In a nested fusion, the parameter bitcast can be hoisted out of the fusion,\n+  // and is therefore not materialized in the HLO.\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule FuseChannelDequantizationFused\n-\n-    fusion {\n-      w.s4 = s4[32,128,256]{2,1,0:E(4)} parameter(0)\n-      w.s8 = s8[32,128,256] convert(w.s4)\n-      w.b16 = bf16[32,128,256] convert(w.s8)\n-\n-      s = bf16[32,1,256] parameter(1)\n-      s.bitcast = bf16[32,256] bitcast(s)\n-      s.broadcast = bf16[32,128,256] broadcast(s.bitcast), dimensions={0,2}\n-      w.scaled = bf16[32,128,256] multiply(w.b16, s.broadcast)\n-      w.scaled.bitcast = bf16[32,2,64,256] bitcast(w.scaled)\n-\n-      a = bf16[1,32,128,2,128] parameter(2)\n-      a.bitcast = bf16[32,128,256] bitcast(bf16[1,32,128,2,128] a)\n-      a.bitcast.2 = bf16[32,2,64,256] bitcast(a.bitcast)\n-      dot = f32[2,32,256,256] dot(w.scaled.bitcast, a.bitcast.2),\n-        lhs_batch_dims={1,0}, lhs_contracting_dims={2},\n-        rhs_batch_dims={1,0}, rhs_contracting_dims={2}\n-      ROOT bitcast = f32[2,32,256,2,1,128] bitcast(f32[2,32,256,256] dot)\n-    }\n+HloModule FuseChannelDequantizationFused\n+\n+lhs {\n+  parameter_0 = s4[32,2,64,256]{3,2,1,0:E(4)} parameter(0)\n+  w.s8 = s8[32,2,64,256]{3,2,1,0} convert(parameter_0)\n+  w.b16 = bf16[32,2,64,256]{3,2,1,0} convert(w.s8)\n+  parameter_1 = bf16[32,256]{1,0} parameter(1)\n+  s.broadcast = bf16[32,2,64,256]{3,2,1,0} broadcast(parameter_1), dimensions={0,3}\n+  ROOT w.scaled = bf16[32,2,64,256]{3,2,1,0} multiply(w.b16, s.broadcast)\n+}\n+\n+rhs {\n+  ROOT parameter_0 = bf16[32,2,64,256]{3,2,1,0} parameter(0)\n+}\n+\n+fusion {\n+  w.s4 = s4[32,2,64,256]{3,2,1,0:E(4)} parameter(0)\n+  s = bf16[32,256]{1,0} parameter(1)\n+  lhs = bf16[32,2,64,256]{3,2,1,0} fusion(w.s4, s), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\",\"1\",\"64\",\"128\"]}]}}}\n+  a = bf16[32,2,64,256]{3,2,1,0} parameter(2)\n+  rhs = bf16[32,2,64,256]{3,2,1,0} fusion(a), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\",\"1\",\"64\",\"128\"]}]}}}\n+  ROOT dot = f32[2,32,256,256]{3,2,1,0} dot(lhs, rhs),\n+    lhs_batch_dims={1,0}, lhs_contracting_dims={2},\n+    rhs_batch_dims={1,0}, rhs_contracting_dims={2}\n+}\n+\n+ENTRY entry_computation {\n+  w.s4 = s4[32,2,64,256]{3,2,1,0:E(4)} parameter(0)\n+  s.bf16 = bf16[32,256]{1,0} parameter(1)\n+  a.bf16 = bf16[32,2,64,256]{3,2,1,0} parameter(2)                                                                                                                                                                                              bitcast = bf16[32,2,64,256]{3,2,1,0} bitcast(a.bf16)\n+  ROOT fusion = f32[2,32,256,256]{3,2,1,0} fusion(w.s4, s.bf16, a.bf16),\n+    kind=kCustom, calls=fusion, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"8\",\"output_tiles\":[{\"sizes\":[\"1\",\"1\",\"128\",\"128\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n \n-    ENTRY entry_computation {\n-      w.s4 = s4[32,128,256]{2,1,0:E(4)} parameter(0)\n-      s.bf16 = bf16[32,1,256] parameter(1)\n-      a.bf16 = bf16[1,32,128,2,128] parameter(2)\n-      ROOT fusion = f32[2,32,256,2,1,128] fusion(w.s4, s.bf16, a.bf16),\n-          kind=kCustom,\n-          calls=fusion,\n-          backend_config={\n-            \"operation_queue_id\":\"0\",\n-            \"wait_on_operation_queues\":[],\n-            \"fusion_backend_config\":{\n-              \"kind\":\"__triton_gemm\",\n-              \"triton_gemm_config\":{\n-                \"block_m\":\"128\",\n-                \"block_n\":\"128\",\n-                \"block_k\":\"64\",\n-                \"split_k\":\"2\",\n-                \"num_stages\":\"1\",\n-                \"num_warps\":\"8\",\n-                \"num_ctas\":\"1\"\n-              }\n-            },\n-            \"force_earliest_schedule\":false\n-          }\n-    }\n-  )\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n@@ -256,14 +155,14 @@ TEST_F(TritonTest, FuseSubchannelDequantizationWithTranspose) {\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n-    CHECK:    %[[bitcast:.*]] = bf16[2,8,64]{2,1,0} bitcast({{.*}})\n-    CHECK:    %[[transpose:.*]] = bf16[2,64,8]{2,1,0} transpose(%[[bitcast]]), dimensions={0,2,1}\n-    CHECK:    %[[broadcast:.*]] = bf16[2,64,8,256]{3,2,1,0} broadcast(%[[transpose]]), dimensions={0,1,2}\n-    CHECK:    %[[multiply:.*]] = bf16[2,64,8,256]{3,2,1,0} multiply({{.*}}, %[[broadcast]])\n+    CHECK:    %[[transpose:.*]] = bf16[2,64,8]{2,1,0} transpose(\n+    CHECK:    %[[broadcast:.*]] = {{.*}} broadcast(%[[transpose]])\n+    CHECK:    multiply({{.*}}, %[[broadcast]])\n+    CHECK:    ENTRY\n+    CHECK:    __triton_nested_gemm_fusion\n   )\"));\n-  EXPECT_TRUE(*RunFileCheck(module->ToString(), \"CHECK: __triton_gemm\"));\n \n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n+  EXPECT_TRUE(RunAndCompareNoHloPasses(\n       std::move(module), ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n }\n \n@@ -296,11 +195,18 @@ TEST_F(TritonTest, FuseSubchannelDequantization) {\n     }\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(*RunFileCheck(module->ToString(), \"CHECK: __triton_gemm\"));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n+  EXPECT_TRUE(\n+      *RunFileCheck(module->ToString(), \"CHECK: __triton_nested_gemm_fusion\"));\n+  EXPECT_TRUE(RunAndCompareNoHloPasses(\n       std::move(module), ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n+// Dump trick:\n+// TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(kHloText));\n+// HloPrintOptions options = HloPrintOptions::ShortParsable();\n+// options.set_print_backend_config(true);\n+// std::cout << \"Dumping module: \" << module->ToString(options) << std::endl;\n+\n TEST_F(TritonTest, FuseChannelDequantization) {\n   // This test is a Channel Dequantization fusion.\n   // We run the non-fused version with the goal to fail if an hlo rewrite broke\n@@ -329,8 +235,9 @@ TEST_F(TritonTest, FuseChannelDequantization) {\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n                           GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(*RunFileCheck(module->ToString(), \"CHECK: __triton_gemm\"));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n+  EXPECT_TRUE(\n+      *RunFileCheck(module->ToString(), \"CHECK: __triton_nested_gemm_fusion\"));\n+  EXPECT_TRUE(RunAndCompareNoHloPasses(\n       std::move(module), ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n@@ -340,166 +247,57 @@ TEST_F(TritonTest, FuseSubchannelDequantizationFused) {\n   // The case where we do:\n   // param -> bitcast -> broadcast -> multiply -> bitcast -> dot.\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule FuseSubchannelDequantizationFused\n-\n-    fusion {\n-      w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n-      w.s8 = s8[2,2048,32] convert(w.s4)\n-      w.s8.bitcast = s8[2,8,256,32] bitcast(w.s8)\n-      w.bf16 = bf16[2,8,256,32] convert(w.s8.bitcast)\n-\n-      s.bf16 = bf16[2,8,1,32] parameter(1)\n-      s.bf16.bitcast = bf16[2,8,32] bitcast(s.bf16)\n-      s.bf16.broadcast = bf16[2,8,256,32] broadcast(s.bf16.bitcast), dimensions={0,1,3}\n-      w = bf16[2,8,256,32] multiply(w.bf16, s.bf16.broadcast)\n-      w.bitcast = bf16[2,2048,32] bitcast(w)\n-\n-      a = bf16[2,2,1,2048] parameter(2)\n-      a.bitcast = bf16[2,2,2048] bitcast(a)\n-      ROOT dot = f32[2,32,2] dot(w.bitcast, a.bitcast),\n-          lhs_batch_dims={0}, lhs_contracting_dims={1},\n-          rhs_batch_dims={1}, rhs_contracting_dims={2}\n-    } // fusion\n-\n-    ENTRY main {\n-      w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n-      s.bf16 = bf16[2,8,1,32] parameter(1)\n-      a.bf16 = bf16[2,2,1,2048] parameter(2)\n-      ROOT fusion = f32[2,32,2] fusion(w.s4, s.bf16, a.bf16),\n-        kind=kCustom,\n-        calls=fusion,\n-        backend_config={\n-          \"operation_queue_id\":\"0\",\n-          \"wait_on_operation_queues\":[],\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\",\n-            \"triton_gemm_config\":{\n-              \"block_m\":16,\n-              \"block_n\":16,\n-              \"block_k\":256,\n-              \"split_k\":1,\n-              \"num_stages\":1,\n-              \"num_warps\":2,\n-              \"num_ctas\":1\n-            }\n-          },\n-          \"force_earliest_schedule\":false\n-        }\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n-}\n-\n-TEST_F(TritonTest, FuseSubchannelDequantizationFusedWithSmallBlockKSize) {\n-  // This test is a Subchannel Dequantization fusion.\n-  // We run the fused version to avoid the hlo passes.\n-  // The case where we do:\n-  // param -> bitcast -> broadcast -> multiply -> bitcast -> dot.\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule FuseSubchannelDequantizationFusedWithSmallBlockKSize\n-\n-    fusion {\n-      w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n-      w.s8 = s8[2,2048,32] convert(w.s4)\n-      w.s8.bitcast = s8[2,8,256,32] bitcast(w.s8)\n-      w.bf16 = bf16[2,8,256,32] convert(w.s8.bitcast)\n-\n-      s.bf16 = bf16[2,8,1,32] parameter(1)\n-      s.bf16.bitcast = bf16[2,8,32] bitcast(s.bf16)\n-      s.bf16.broadcast = bf16[2,8,256,32] broadcast(s.bf16.bitcast), dimensions={0,1,3}\n-      w = bf16[2,8,256,32] multiply(w.bf16, s.bf16.broadcast)\n-      w.bitcast = bf16[2,2048,32] bitcast(w)\n-\n-      a = bf16[2,2,1,2048] parameter(2)\n-      a.bitcast = bf16[2,2,2048] bitcast(a)\n-      ROOT dot = f32[2,32,2] dot(w.bitcast, a.bitcast),\n-          lhs_batch_dims={0}, lhs_contracting_dims={1},\n-          rhs_batch_dims={1}, rhs_contracting_dims={2}\n-    } // fusion\n-\n-    ENTRY main {\n-      w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n-      s.bf16 = bf16[2,8,1,32] parameter(1)\n-      a.bf16 = bf16[2,2,1,2048] parameter(2)\n-      ROOT fusion = f32[2,32,2] fusion(w.s4, s.bf16, a.bf16),\n-        kind=kCustom,\n-        calls=fusion,\n-        backend_config={\n-          \"operation_queue_id\":\"0\",\n-          \"wait_on_operation_queues\":[],\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\",\n-            \"triton_gemm_config\":{\n-              \"block_m\":16,\n-              \"block_n\":16,\n-              \"block_k\":128,\n-              \"split_k\":1,\n-              \"num_stages\":1,\n-              \"num_warps\":2,\n-              \"num_ctas\":1\n-            }\n-          },\n-          \"force_earliest_schedule\":false\n-        }\n-    }\n-  )\";\n+HloModule FuseSubchannelDequantizationFused\n+\n+lhs {\n+  w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n+  w.s8 = s8[2,2048,32] convert(w.s4)\n+  w.s8.bitcast = s8[2,8,256,32] bitcast(w.s8)\n+  w.bf16 = bf16[2,8,256,32] convert(w.s8.bitcast)\n+\n+  s.bf16 = bf16[2,8,1,32] parameter(1)\n+  s.bf16.bitcast = bf16[2,8,32] bitcast(s.bf16)\n+  s.bf16.broadcast = bf16[2,8,256,32] broadcast(s.bf16.bitcast), dimensions={0,1,3}\n+  w = bf16[2,8,256,32] multiply(w.bf16, s.bf16.broadcast)\n+  ROOT w.bitcast = bf16[2,2048,32] bitcast(w)\n+}\n+\n+rhs {\n+  a.bf16 = bf16[2,2,1,2048] parameter(0)\n+  ROOT a.bitcast = bf16[2,2,2048] bitcast(a.bf16)\n+}\n+\n+fusion {\n+  w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n+  s.bf16 = bf16[2,8,1,32] parameter(1)\n+  w.bitcast = bf16[2,2048,32] fusion(w.s4, s.bf16), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"128\", \"16\"]}]}}}\n+  a = bf16[2,2,1,2048] parameter(2)\n+  a.bitcast = bf16[2,2,2048] fusion(a), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"16\", \"1\", \"128\"]}]}}}\n+  ROOT dot = f32[2,32,2] dot(w.bitcast, a.bitcast),\n+      lhs_batch_dims={0}, lhs_contracting_dims={1},\n+      rhs_batch_dims={1}, rhs_contracting_dims={2}\n+}\n+\n+ENTRY main {\n+  w.s4 = s4[2,2048,32]{2,1,0:E(4)} parameter(0)\n+  s.bf16 = bf16[2,8,1,32] parameter(1)\n+  a.bf16 = bf16[2,2,1,2048] parameter(2)\n+  ROOT fusion = f32[2,32,2] fusion(w.s4, s.bf16, a.bf16), kind=kCustom,\n+    calls=fusion, backend_config={\n+      \"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"1\", \"16\", \"16\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n-TEST_F(TritonTest, FuseBroadcastInPrologue) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule FuseBroadcastInPrologue\n-\n-    ENTRY main {\n-      lhs = bf16[2,1024] parameter(0)\n-      lhs.broadcast = bf16[2,256,1024] broadcast(lhs), dimensions={0,2}\n-\n-      rhs = bf16[2,256,512] parameter(1)\n-\n-      ROOT dot = f32[2,1024,512] dot(lhs.broadcast, rhs),\n-        lhs_batch_dims={0}, lhs_contracting_dims={1},\n-        rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n-    CHECK:    %[[broadcast:.*]] = bf16[2,256,1024]{2,1,0} broadcast\n-    CHECK:    %[[dot:.*]] = f32[2,1024,512]{2,1,0} dot\n-    CHECK:    ENTRY %main\n-  )\"));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n-      std::move(module), ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n-}\n-\n-TEST_F(TritonTest, FuseBroadcastBitcastInPrologue) {\n-  // This test is a Subchannel Dequantization fusion.\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule FuseBroadcastBitcastInPrologue\n-\n-    ENTRY main {\n-      lhs = bf16[2,1024] parameter(0)\n-      lhs.broadcast = bf16[2,128,1024] broadcast(lhs), dimensions={0,2}\n-      lhs.bitcast = bf16[256,1024] reshape(lhs.broadcast)\n-\n-      rhs = bf16[256,512] parameter(1)\n-\n-      ROOT dot = f32[1024,512] dot(lhs.bitcast, rhs),\n-        lhs_contracting_dims={0}, rhs_contracting_dims={0}\n-    }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n-    CHECK:    %[[broadcast:.*]] = bf16[{{.*}}]{2,1,0} broadcast\n-    CHECK:    %[[bitcast:.*]] = bf16[{{.*}}]{1,0} bitcast\n-    CHECK:    ROOT %[[dot:.*]] = f32[{{.*}}]{1,0} dot\n-    CHECK:    ENTRY %main\n-  )\"));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n-      std::move(module), ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}));\n-}\n-\n TEST_F(TritonTest, FuseBroadcastBitcastMultiplyInPrologue) {\n   // This test is a Subchannel Dequantization fusion.\n   constexpr absl::string_view kHloText = R\"(\n@@ -523,117 +321,62 @@ TEST_F(TritonTest, FuseBroadcastBitcastMultiplyInPrologue) {\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n   EXPECT_TRUE(*RunFileCheck(module->ToString(), R\"(\n-    CHECK:    %[[broadcast:.*]] = bf16[{{.*}}]{2,1,0} broadcast\n-    CHECK:    %[[bitcast:.*]] = bf16[{{.*}}]{1,0} bitcast\n-    CHECK:    %[[multiply:.*]] = [[type:.*]][{{.*}}]{1,0} multiply\n-    CHECK:    %[[dot:.*]] = f32[1024,512]{1,0} dot\n-    CHECK:    ENTRY %main\n+    // We don't need to check the bitcast, because it is hoisted.\n+    CHECK:    %[[broadcast:.*]] = {{.*}} broadcast\n+    CHECK:    %[[multiply:.*]] = {{.*}} multiply\n+    CHECK:    f32[1024,512]{1,0} dot\n+    CHECK:    ENTRY\n+    CHECK:    __triton_nested_gemm_fusion\n   )\"));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n-      std::move(module), ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}));\n-}\n-\n-TEST_F(TritonTest, DotWithI4WeightsOnLhsWithBitcastTo3dTensor) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule DotWithI4WeightsOnLhsWithBitcastTo3dTensor\n-\n-    fusion {\n-      p0 = s4[256,16]{1,0:E(4)} parameter(0)\n-      p0.2 = bf16[256,16] convert(p0)\n-      p0.3 = bf16[4,64,16] bitcast(p0.2)\n-      p1 = bf16[4,32,64] parameter(1)\n-      ROOT dot = bf16[4,16,32] dot(p0.3, p1),\n-        lhs_batch_dims={0}, lhs_contracting_dims={1},\n-        rhs_batch_dims={0}, rhs_contracting_dims={2}\n-    }\n-\n-    ENTRY entry_computation {\n-      p0 = s4[256,16]{1,0:E(4)} parameter(0)\n-      p1 = bf16[4,32,64] parameter(1)\n-      ROOT dot = bf16[4,16,32] fusion(p0, p1),\n-        kind=kCustom,\n-        calls=fusion,\n-        backend_config={\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\"\n-          }\n-        }\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}));\n-}\n-\n-TEST_F(TritonTest,\n-       DotWithI4WeightsOnLhsWithNonStandardLayoutAndMultplyInEpilogue) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule DotWithI4WeightsOnLhsWithNonStandardLayoutAndMultplyInEpilogue\n-\n-    fusion {\n-      p0 = s4[1,128,32]{1,2,0:E(4)} parameter(0)\n-      p0.1 = s4[1,32,128]{2,1,0:E(4)} bitcast(p0)\n-      p0.2 = bf16[1,32,128] convert(p0.1)\n-      p0.3 = bf16[1,128,32]{1,2,0} bitcast(p0.2)\n-      p1 = bf16[128,1,64] parameter(1)\n-      dot = bf16[1,32,64] dot(p0.3, p1),\n-        lhs_batch_dims={0}, lhs_contracting_dims={1},\n-        rhs_batch_dims={1}, rhs_contracting_dims={0}\n-      p2 = bf16[1,1,32]{2,0,1} parameter(2)\n-      p2.1 = bf16[1,32] bitcast(p2)\n-      p2.2 = bf16[1,32,64] broadcast(p2.1), dimensions={0,1}\n-      m = bf16[1,32,64] multiply(dot, p2.2)\n-      ROOT m.1 = bf16[1,1,32,64] bitcast(m)\n-    }\n-\n-    ENTRY entry_computation {\n-      p0 = s4[1,128,32]{1,2,0:E(4)} parameter(0)\n-      p1 = bf16[128,1,64] parameter(1)\n-      p2 = bf16[1,1,32]{2,0,1} parameter(2)\n-      ROOT gemm_fusion_dot.2 = bf16[1,1,32,64] fusion(p0, p1, p2),\n-        kind=kCustom,\n-        calls=fusion,\n-        backend_config={\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\"\n-          }\n-        }\n-    }\n-  )\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}));\n+      std::move(module), ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}));\n }\n \n TEST_F(TritonTest, DotWithInt4WeightsOnLhsFusedWithMultiplyByChannelScales) {\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule DotWithI4WeightsOnLhsFusedWithMultiplyByChannelScales\n-\n-    DotWithI4WeightsOnLhsFusedWithMultiplyByChannelScales {\n-      w = s4[32,64,128] parameter(0)\n-      w.i8 = s8[32,64,128] convert(w)\n-      w.bf16 = bf16[32,64,128] convert(w.i8)\n-      scales = bf16[32,128] parameter(1)\n-      scales.broadcast = bf16[32,64,128] broadcast(scales), dimensions={0,2}\n-      weights.scaled = bf16[32,64,128] multiply(w.bf16, scales.broadcast)\n-      activations = bf16[32,64,256] parameter(2)\n-      ROOT dot = f32[32,128,256] dot(weights.scaled, activations),\n-        lhs_batch_dims={0}, lhs_contracting_dims={1},\n-        rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY main {\n-      w = s4[32,64,128] parameter(0)\n-      scales = bf16[32,128] parameter(1)\n-      p2 = bf16[32,64,256] parameter(2)\n-      ROOT dot = f32[32,128,256] fusion(w, scales, p2),\n-        kind=kCustom,\n-        calls=DotWithI4WeightsOnLhsFusedWithMultiplyByChannelScales,\n-        backend_config={\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\"\n-          }\n-        }\n-    }\n-  )\";\n+HloModule DotWithI4WeightsOnLhsFusedWithMultiplyByChannelScales\n+\n+lhs {\n+  parameter_0 = s4[32,64,128] parameter(0)\n+  parameter_1 = bf16[32,128] parameter(1)\n+  w.s8 = s8[32,64,128] convert(parameter_0)\n+  w.bf16 = bf16[32,64,128] convert(w.s8)\n+  scales.broadcast = bf16[32,64,128] broadcast(parameter_1), dimensions={0,2}\n+  ROOT weights.scaled = bf16[32,64,128] multiply(w.bf16, scales.broadcast)\n+}\n+\n+rhs {\n+  ROOT activations = bf16[32,64,256] parameter(0)\n+}\n+\n+DotWithI4WeightsOnLhsFusedWithMultiplyByChannelScales {\n+  w = s4[32,64,128] parameter(0)\n+  scales = bf16[32,128] parameter(1)\n+  lhs = bf16[32,64,128] fusion(w, scales), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  activations = bf16[32,64,256] parameter(2)\n+  rhs = bf16[32,64,256] fusion(activations), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  ROOT dot = f32[32,128,256] dot(lhs, rhs),\n+    lhs_batch_dims={0}, lhs_contracting_dims={1},\n+    rhs_batch_dims={0}, rhs_contracting_dims={1}\n+}\n+\n+ENTRY main {\n+  w = s4[32,64,128] parameter(0)\n+  scales = bf16[32,128] parameter(1)\n+  p2 = bf16[32,64,256] parameter(2)\n+  ROOT dot = f32[32,128,256] fusion(w, scales, p2),\n+    kind=kCustom,\n+    calls=DotWithI4WeightsOnLhsFusedWithMultiplyByChannelScales,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}));\n }\n@@ -662,6 +405,7 @@ TEST_F(TritonTest, FuseMultiplyInPrologue) {\n     CHECK:    %[[multiply:.*]] = [[type:.*]]{{.*}} multiply({{.*}}, {{.*}})\n     CHECK:    %[[dot:.*]] = f32[32,128,256]{2,1,0} dot\n     CHECK:    ENTRY %main\n+    CHECK:    __triton_nested_gemm_fusion\n   )\"));\n }\n \n@@ -687,6 +431,7 @@ TEST_F(TritonTest, DISABLED_FuseMultiplyInEpilogue) {\n       CHECK:  %[[dot:.*]] = bf16[4,64,32]{1,2,0} dot\n       CHECK:  %[[multiply:.*]] = [[type:.*]][4,32,64]{2,1,0} multiply\n       CHECK:  ENTRY %main\n+      CHECK:  __triton_nested_gemm_fusion\n     )\"));\n }\n \n@@ -703,8 +448,10 @@ TEST_F(TritonTest, NonstandardLayoutInt4) {\n   )\";\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n-      std::move(module), ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n+  EXPECT_TRUE(\n+      *RunFileCheck(module->ToString(), \"CHECK: __triton_nested_gemm_fusion\"));\n+  EXPECT_TRUE(RunAndCompare(std::move(module),\n+                            ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n using ::testing::TestParamInfo;\n@@ -744,31 +491,46 @@ TEST_P(ParametrizedTritonTest, Int4WeightsOnTheLhs) {\n     GTEST_SKIP() << \"2d test ignores batch dim case.\";\n   }\n   constexpr absl::string_view kHloTextTemplate = R\"(\n-    HloModule lhs_${name}\n-\n-    lhs_${name} {\n-      w.s4 = s4[${lhs}] parameter(0)\n-      w.s8 = s8[${lhs}] convert(w.s4)\n-      w.bf16 = bf16[${lhs}] convert(w.s8)\n-      a = bf16[${rhs}] parameter(1)\n-      ROOT lhs_${name} = f32[${out}] dot(w.bf16, a),\n-        lhs_contracting_dims={${lhs_contracting_dim}},\n-        rhs_contracting_dims={${rhs_contracting_dim}}\n-    }\n+HloModule lhs_${name}\n+\n+lhs {\n+  parameter_0 = s4[${lhs}] parameter(0)\n+  w.s8 = s8[${lhs}] convert(parameter_0)\n+  ROOT w.b16 = bf16[${lhs}] convert(w.s8)\n+}\n+\n+rhs {\n+  ROOT parameter_0 = bf16[${rhs}] parameter(0)\n+}\n+\n+fusion {\n+  parameter_0 = s4[${lhs}] parameter(0)\n+\n+  lhs = bf16[${lhs}] fusion(parameter_0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  parameter_1 = bf16[${rhs}] parameter(1)\n+  rhs = bf16[${rhs}] fusion(parameter_1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  ROOT dot = f32[${out}] dot(lhs, rhs),\n+    lhs_contracting_dims={${lhs_contracting_dim}},\n+    rhs_contracting_dims={${rhs_contracting_dim}}\n+}\n+\n+ENTRY entry_computation {\n+  w = s4[${lhs}] parameter(0)\n+  a = bf16[${rhs}] parameter(1)\n+  ROOT fusion = f32[${out}] fusion(w, a),\n+    kind=kCustom, calls=fusion, backend_config={\n+      \"fusion_backend_config\":{\n+        \"kind\":\"__triton_nested_gemm_fusion\",\n+        \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n \n-    ENTRY main {\n-      w = s4[${lhs}] parameter(0)\n-      a = bf16[${rhs}] parameter(1)\n-      ROOT gemm_fusion_dot.2 = f32[${out}] fusion(w, a),\n-        kind=kCustom,\n-        calls=lhs_${name},\n-        backend_config={\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\"\n-          }\n-        }\n-    }\n-  )\";\n   std::string hlo_text = GetParam().Format(kHloTextTemplate);\n   EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text,\n                                        ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}))\n@@ -780,31 +542,45 @@ TEST_P(ParametrizedTritonTest, Int4WeightsOnTheLhsWithBatchDim) {\n     GTEST_SKIP() << \"3d test ignores 2d case.\";\n   }\n   constexpr absl::string_view kHloTextTemplate = R\"(\n-    HloModule ${name}\n-\n-    fusion {\n-      w.s4 = s4[${lhs}] parameter(0)\n-      w.s8 = s8[${lhs}] convert(w.s4)\n-      w.bf16 = bf16[${lhs}] convert(w.s8)\n-      a = bf16[${rhs}] parameter(1)\n-      ROOT dot.0 = f32[${out}] dot(w.bf16, a),\n-        lhs_batch_dims={0}, lhs_contracting_dims={${lhs_contracting_dim}},\n-        rhs_batch_dims={0}, rhs_contracting_dims={${rhs_contracting_dim}}\n-    }\n-\n-    ENTRY gemm_fusion_dot_computation {\n-      w = s4[${lhs}] parameter(0)\n-      a = bf16[${rhs}] parameter(1)\n-      ROOT gemm_fusion_dot.2 = f32[${out}] fusion(w, a),\n-        kind=kCustom,\n-        calls=fusion,\n-        backend_config={\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\"\n-          }\n-        }\n-    }\n-  )\";\n+HloModule lhs_${name}\n+\n+lhs {\n+  parameter_0 = s4[${lhs}] parameter(0)\n+  w.s8 = s8[${lhs}] convert(parameter_0)\n+  ROOT w.b16 = bf16[${lhs}] convert(w.s8)\n+}\n+\n+rhs {\n+  ROOT parameter_0 = bf16[${rhs}] parameter(0)\n+}\n+\n+fusion {\n+  parameter_0 = s4[${lhs}] parameter(0)\n+\n+  lhs = bf16[${lhs}] fusion(parameter_0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  parameter_1 = bf16[${rhs}] parameter(1)\n+  rhs = bf16[${rhs}] fusion(parameter_1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  ROOT dot = f32[${out}] dot(lhs, rhs),\n+    lhs_batch_dims={0}, lhs_contracting_dims={${lhs_contracting_dim}},\n+    rhs_batch_dims={0}, rhs_contracting_dims={${rhs_contracting_dim}}\n+}\n+\n+ENTRY entry_computation {\n+  w = s4[${lhs}] parameter(0)\n+  a = bf16[${rhs}] parameter(1)\n+  ROOT fusion = f32[${out}] fusion(w, a),\n+    kind=kCustom, calls=fusion, backend_config={\n+      \"fusion_backend_config\":{\n+        \"kind\":\"__triton_nested_gemm_fusion\",\n+        \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   std::string hlo_text = GetParam().Format(kHloTextTemplate);\n   EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text,\n                                        ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}))\n@@ -817,31 +593,46 @@ TEST_P(ParametrizedTritonTest, Int4WeightsOnTheRhs) {\n   }\n \n   constexpr absl::string_view kHloTextTemplate = R\"(\n-    HloModule rhs_${name}\n-\n-    rhs_${name} {\n-      a = bf16[${lhs}] parameter(0)\n-      w.s4 = s4[${rhs}] parameter(1)\n-      w.s8 = s8[${rhs}] convert(w.s4)\n-      w.bf16 = bf16[${rhs}] convert(w.s8)\n-      ROOT rhs_${name} = f32[${out}] dot(a, w.bf16),\n-        lhs_contracting_dims={${lhs_contracting_dim}},\n-        rhs_contracting_dims={${rhs_contracting_dim}}\n-    }\n+HloModule rhs_${name}\n+\n+lhs {\n+  ROOT parameter_0 = bf16[${lhs}] parameter(0)\n+}\n+\n+rhs {\n+  parameter_0 = s4[${rhs}] parameter(0)\n+  w.s8 = s8[${rhs}] convert(parameter_0)\n+  ROOT w.b16 = bf16[${rhs}] convert(w.s8)\n+}\n+\n+fusion {\n+  parameter_0 = bf16[${lhs}] parameter(0)\n+\n+  lhs = bf16[${lhs}] fusion(parameter_0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  parameter_1 = s4[${rhs}] parameter(1)\n+  rhs = bf16[${rhs}] fusion(parameter_1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  ROOT dot = f32[${out}] dot(lhs, rhs),\n+    lhs_contracting_dims={${lhs_contracting_dim}},\n+    rhs_contracting_dims={${rhs_contracting_dim}}\n+}\n+\n+ENTRY entry_computation {\n+  a = bf16[${lhs}] parameter(0)\n+  w = s4[${rhs}] parameter(1)\n+  ROOT fusion = f32[${out}] fusion(a, w),\n+    kind=kCustom, calls=fusion, backend_config={\n+      \"fusion_backend_config\":{\n+        \"kind\":\"__triton_nested_gemm_fusion\",\n+        \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n \n-    ENTRY main {\n-      a = bf16[${lhs}] parameter(0)\n-      w = s4[${rhs}] parameter(1)\n-      ROOT rhs_${name} = f32[${out}] fusion(a, w),\n-        kind=kCustom,\n-        calls=rhs_${name},\n-        backend_config={\n-          \"fusion_backend_config\":{\n-            \"kind\":\"__triton_gemm\"\n-          }\n-        }\n-    }\n-  )\";\n   std::string hlo_text = GetParam().Format(kHloTextTemplate);\n   EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text,\n                                        ErrorSpec{/*aabs=*/1e-5, /*arel=*/1e-5}))\n@@ -887,7 +678,9 @@ TEST_F(TritonTest, NonstandardLayoutWithManyNonContractingDims) {\n   )\";\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n+  EXPECT_TRUE(\n+      *RunFileCheck(module->ToString(), \"CHECK: __triton_nested_gemm_fusion\"));\n+  EXPECT_TRUE(RunAndCompareNoHloPasses(\n       std::move(module), ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-2}));\n }\n \n@@ -905,27 +698,12 @@ TEST_F(TritonTest, NonstandardLayoutWithManyNonContractingDimsReversedLayout) {\n   )\";\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(NestFusionsRunAndCompare(\n+  EXPECT_TRUE(\n+      *RunFileCheck(module->ToString(), \"CHECK: __triton_nested_gemm_fusion\"));\n+  EXPECT_TRUE(RunAndCompareNoHloPasses(\n       std::move(module), ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n-TEST_F(TritonTest, NegatePlusConvertHLO) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule NegatePlusConvertHLO\n-\n-    ENTRY main {\n-      lhs = s4[2,32,64] parameter(0)\n-      lhs_negated = s4[2,32,64] negate(lhs)\n-      lhs_converted = bf16[2,32,64] convert(lhs_negated)\n-      rhs = bf16[2,64,16] parameter(1)\n-      ROOT dot = bf16[2,32,16] dot(lhs_converted, rhs),\n-          lhs_batch_dims={0}, lhs_contracting_dims={2},\n-          rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompare(kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n-}\n-\n TEST_F(TritonTest, RejectTritonFusionForWithMinorBatchDim) {\n   constexpr absl::string_view kHloText = R\"(\n     HloModule RejectTritonFusionForWithMinorBatchDim\n@@ -940,63 +718,95 @@ TEST_F(TritonTest, RejectTritonFusionForWithMinorBatchDim) {\n     }\n   )\";\n \n-  const std::string pattern =\n-      R\"(CHECK-NOT: \"kind\":\"__triton_gemm\",\"triton_gemm_config\")\";\n   TF_ASSERT_OK_AND_ASSIGN(auto module, GetOptimizedModule(kHloText));\n-  EXPECT_TRUE(*RunFileCheck(module->ToString(), pattern));\n+  EXPECT_TRUE(*RunFileCheck(module->ToString(),\n+                            \"CHECK-NOT: __triton_nested_gemm_fusion\"));\n }\n \n TEST_F(TritonTest, LHSWithMinorDimEqualTo1) {\n   // We prove that triton can handle int4 dot with non contracting dim size\n-  // equal to 1.\n+  // equal to 1 on the left-hand side.\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule LHSWithMinorDimEqualTo1\n-\n-    triton_computation {\n-      lhs = s4[2,1024,1] parameter(0)\n-      lhs_converted = bf16[2,1024,1] convert(lhs)\n-      rhs = bf16[2,64,1024] parameter(1)\n-      ROOT dot = bf16[2,1,64] dot(lhs_converted, rhs),\n-          lhs_batch_dims={0}, lhs_contracting_dims={1},\n-          rhs_batch_dims={0}, rhs_contracting_dims={2}\n-    }\n-\n-    ENTRY main {\n-      lhs = s4[2,1024,1] parameter(0)\n-      rhs = bf16[2,64,1024] parameter(1)\n-      ROOT dot = bf16[2,1,64] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n+HloModule LHSWithMinorDimEqualTo1\n+\n+lhs {\n+  lhs = s4[2,1024,1] parameter(0)\n+  ROOT lhs_converted = bf16[2,1024,1] convert(lhs)\n+}\n+\n+rhs {\n+  ROOT rhs = bf16[2,64,1024] parameter(0)\n+}\n+\n+triton_computation {\n+  p0 = s4[2,1024,1] parameter(0)\n+  p1 = bf16[2,64,1024] parameter(1)\n+  lhs = bf16[2,1024,1] fusion(p0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  rhs = bf16[2,64,1024] fusion(p1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  ROOT dot = bf16[2,1,64] dot(lhs, rhs),\n+      lhs_batch_dims={0}, lhs_contracting_dims={1},\n+      rhs_batch_dims={0}, rhs_contracting_dims={2}\n+}\n+\n+ENTRY main {\n+  lhs = s4[2,1024,1] parameter(0)\n+  rhs = bf16[2,64,1024] parameter(1)\n+  ROOT dot = bf16[2,1,64] fusion(lhs, rhs), kind=kCustom,\n+    calls=triton_computation, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"1\", \"64\",\"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n TEST_F(TritonTest, RHSWithMinorDimEqualTo1) {\n   // We prove that triton can handle int4 dot with non contracting dim size\n-  // equal to 1.\n+  // equal to 1 on the right-hand side.\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule RHSWithMinorDimEqualTo1\n-\n-    triton_computation {\n-      lhs = bf16[2,1024,64] parameter(0)\n-      rhs = s4[2,1024,1] parameter(1)\n-      rhs_converted = bf16[2,1024,1] convert(rhs)\n-      ROOT dot = bf16[2,64,1] dot(lhs, rhs_converted),\n-          lhs_batch_dims={0}, lhs_contracting_dims={1},\n-          rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY main {\n-      lhs = bf16[2,1024,64] parameter(0)\n-      rhs = s4[2,1024,1] parameter(1)\n-      ROOT dot = bf16[2,64,1] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-\n+HloModule RHSWithMinorDimEqualTo1\n+\n+lhs {\n+  ROOT lhs = bf16[2,1024,64] parameter(0)\n+}\n+\n+rhs {\n+  rhs = s4[2,1024,1] parameter(0)\n+  ROOT rhs_converted = bf16[2,1024,1] convert(rhs)\n+}\n+\n+triton_computation {\n+  p0 = bf16[2,1024,64] parameter(0)\n+  p1 = s4[2,1024,1] parameter(1)\n+  lhs = bf16[2,1024,64] fusion(p0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  rhs = bf16[2,1024,1] fusion(p1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"1\", \"64\", \"64\"]}]}}}\n+  ROOT dot = bf16[2,64,1] dot(lhs, rhs),\n+      lhs_batch_dims={0}, lhs_contracting_dims={1},\n+      rhs_batch_dims={0}, rhs_contracting_dims={1}\n+}\n+\n+ENTRY main {\n+  lhs = bf16[2,1024,64] parameter(0)\n+  rhs = s4[2,1024,1] parameter(1)\n+  ROOT dot = bf16[2,64,1] fusion(lhs, rhs), kind=kCustom,\n+    calls=triton_computation, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"1\", \"64\",\"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n@@ -1005,272 +815,163 @@ TEST_F(TritonTest, LHSNonMinorContractingDim) {\n   // We prove that triton can handle int4 dot with non minor\n   // lhs_contracting_dim.\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule LHSNonMinorContractingDim\n-\n-    triton_computation {\n-      lhs = s4[1024,8] parameter(0)\n-      lhs_converted = bf16[1024,8] convert(lhs)\n-      rhs = bf16[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] dot(lhs_converted, rhs),\n-          lhs_contracting_dims={0}, rhs_contracting_dims={0}\n-    }\n-\n-    ENTRY main {\n-      lhs = s4[1024,8] parameter(0)\n-      rhs = bf16[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n-}\n-\n-TEST_F(TritonTest, LHSNonMinorContractingDimWithBatchDim0) {\n-  // We prove that triton can handle int4 dot with non minor\n-  // lhs_contracting_dim.\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule LHSNonMinorContractingDimWithBatchDim0\n-\n-    triton_computation {\n-      lhs = s4[2,1024,8] parameter(0)\n-      lhs_converted = bf16[2,1024,8] convert(lhs)\n-      rhs = bf16[2,1024,4] parameter(1)\n-      ROOT dot = bf16[2,8,4] dot(lhs_converted, rhs),\n-        lhs_batch_dims={0}, lhs_contracting_dims={1},\n-        rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY main {\n-      lhs = s4[2,1024,8] parameter(0)\n-      rhs = bf16[2,1024,4] parameter(1)\n-      ROOT dot = bf16[2,8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n+HloModule LHSNonMinorContractingDim\n+\n+lhs {\n+  lhs = s4[1024,8] parameter(0)\n+  ROOT lhs_converted = bf16[1024,8] convert(lhs)\n+}\n+\n+rhs {\n+  ROOT rhs = bf16[1024,4] parameter(0)\n+}\n+\n+triton_computation {\n+  p0 = s4[1024,8] parameter(0)\n+  p1 = bf16[1024,4] parameter(1)\n+  lhs = bf16[1024,8] fusion(p0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  rhs = bf16[1024,4] fusion(p1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  ROOT dot = bf16[8,4] dot(lhs, rhs),\n+    lhs_contracting_dims={0}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = s4[1024,8] parameter(0)\n+  p1 = bf16[1024,4] parameter(1)\n+  ROOT dot = bf16[8,4] fusion(p0, p1), kind=kCustom,\n+    calls=triton_computation, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"64\",\"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-3, /*arel=*/1e-3}));\n }\n \n TEST_F(TritonTest, LHSMinorContractingDim) {\n   // We prove that triton can handle int4 dot with minor lhs_contracting_dim.\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule LHSMinorContractingDim\n-\n-    triton_computation {\n-      lhs = s4[8,1024] parameter(0)\n-      lhs_converted = bf16[8,1024] convert(lhs)\n-      rhs = bf16[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] dot(lhs_converted, rhs),\n-        lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-    }\n-\n-    ENTRY main {\n-      lhs = s4[8,1024] parameter(0)\n-      rhs = bf16[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n-}\n-\n-TEST_F(TritonTest, ConvertPlusNegate) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule ConvertPlusNegate\n-\n-    triton_computation {\n-      lhs = s4[8,1024] parameter(0)\n-      lhs_converted = bf16[8,1024] convert(lhs)\n-      lhs_negated = bf16[8,1024] negate(lhs_converted)\n-      rhs = bf16[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] dot(lhs_negated, rhs),\n-        lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-    }\n-\n-    ENTRY main {\n-      lhs = s4[8,1024] parameter(0)\n-      rhs = bf16[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n-}\n-\n-TEST_F(TritonTest, LHSMinorContractingDimWithBatchDim0) {\n-  // We prove that triton can handle int4 dot with minor lhs_contracting_dim.\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule LHSMinorContractingDimWithBatchDim0\n-\n-    triton_computation {\n-      lhs = s4[2,8,1024] parameter(0)\n-      lhs_converted = bf16[2,8,1024] convert(lhs)\n-      rhs = bf16[2,1024,4] parameter(1)\n-      ROOT dot = bf16[2,8,4] dot(lhs_converted, rhs),\n-        lhs_batch_dims={0}, lhs_contracting_dims={2},\n-        rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY main {\n-      lhs = s4[2,8,1024] parameter(0)\n-      rhs = bf16[2,1024,4] parameter(1)\n-      ROOT dot = bf16[2,8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n+HloModule LHSMinorContractingDim\n+\n+lhs {\n+  lhs = s4[8,1024] parameter(0)\n+  ROOT lhs_converted = bf16[8,1024] convert(lhs)\n+}\n+\n+rhs {\n+  ROOT rhs = bf16[1024,4] parameter(0)\n+}\n+\n+triton_computation {\n+  p0 = s4[8,1024] parameter(0)\n+  p1 = bf16[1024,4] parameter(1)\n+  lhs = bf16[8,1024] fusion(p0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  rhs = bf16[1024,4] fusion(p1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  ROOT dot = bf16[8,4] dot(lhs, rhs),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = s4[8,1024] parameter(0)\n+  p1 = bf16[1024,4] parameter(1)\n+  ROOT dot = bf16[8,4] fusion(p0, p1), kind=kCustom,\n+    calls=triton_computation, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"64\",\"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n }\n \n TEST_F(TritonTest, RHSTestWithNotMinorContractingDim) {\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule RHSTestWithNotMinorContractingDim\n-\n-    triton_computation {\n-      lhs = bf16[8,1024] parameter(0)\n-      rhs = s4[1024,4] parameter(1)\n-      rhs_converted = bf16[1024,4] convert(rhs)\n-      ROOT dot = bf16[8,4] dot(lhs, rhs_converted),\n-          lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-    }\n-\n-    ENTRY main {\n-      lhs = bf16[8,1024] parameter(0)\n-      rhs = s4[1024,4] parameter(1)\n-      ROOT dot = bf16[8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n+HloModule RHSTestWithNotMinorContractingDim\n+\n+lhs {\n+  ROOT lhs = bf16[8,1024] parameter(0)\n+}\n+\n+rhs {\n+  rhs = s4[1024,4] parameter(0)\n+  ROOT rhs_converted = bf16[1024,4] convert(rhs)\n+}\n+\n+triton_computation {\n+  p0 = bf16[8,1024] parameter(0)\n+  p1 = s4[1024,4] parameter(1)\n+  lhs = bf16[8,1024] fusion(p0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  rhs = bf16[1024,4] fusion(p1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  ROOT dot = bf16[8,4] dot(lhs, rhs),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = bf16[8,1024] parameter(0)\n+  p1 = s4[1024,4] parameter(1)\n+  ROOT dot = bf16[8,4] fusion(p0, p1), kind=kCustom,\n+    calls=triton_computation, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"64\",\"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n }\n \n TEST_F(TritonTest, RHSTestWithMinorContractingDim) {\n   constexpr absl::string_view kHloText = R\"(\n-    HloModule RHSTestWithMinorContractingDim\n-\n-    triton_computation {\n-      lhs = bf16[8,1024] parameter(0)\n-      rhs = s4[4,1024] parameter(1)\n-      rhs_converted = bf16[4,1024] convert(rhs)\n-      ROOT dot = bf16[8,4] dot(lhs, rhs_converted),\n-          lhs_contracting_dims={1}, rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY main {\n-      lhs = bf16[8,1024] parameter(0)\n-      rhs = s4[4,1024] parameter(1)\n-      ROOT dot = bf16[8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n-}\n-\n-TEST_F(TritonTest, RHSTestWithMinorContractingDimWithBatchDim) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule RHSTestWithMinorContractingDimWithBatchDim\n-\n-    triton_computation {\n-      lhs = bf16[2,8,1024] parameter(0)\n-      rhs = s4[2,1024,4] parameter(1)\n-      rhs_converted = bf16[2,1024,4] convert(rhs)\n-      ROOT dot = bf16[2,8,4] dot(lhs, rhs_converted),\n-          lhs_batch_dims={0}, lhs_contracting_dims={2},\n-          rhs_batch_dims={0}, rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY main {\n-      lhs = bf16[2,8,1024] parameter(0)\n-      rhs = s4[2,1024,4] parameter(1)\n-      ROOT dot = bf16[2,8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n-}\n-\n-TEST_F(TritonTest, RHSTestWithNotMinorContractingDimWithBatchDim0) {\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule RHSTestWithNotMinorContractingDimWithBatchDim0\n-\n-    triton_computation {\n-      lhs = bf16[2,8,1024] parameter(0)\n-      rhs = s4[2,4,1024] parameter(1)\n-      rhs_converted = bf16[2,4,1024] convert(rhs)\n-      ROOT dot = bf16[2,8,4] dot(lhs, rhs_converted),\n-          lhs_batch_dims={0}, lhs_contracting_dims={2},\n-          rhs_batch_dims={0}, rhs_contracting_dims={2}\n-    }\n-\n-    ENTRY main {\n-      lhs = bf16[2,8,1024] parameter(0)\n-      rhs = s4[2,4,1024] parameter(1)\n-      ROOT dot = bf16[2,8,4] fusion(lhs, rhs), kind=kCustom,\n-        calls=triton_computation,\n-        backend_config={\"fusion_backend_config\": {\"kind\":\"__triton_gemm\"}}\n-    }\n-  )\";\n-  EXPECT_TRUE(RunAndCompareNoHloPasses(\n-      kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n-}\n-\n-TEST_F(TritonTest, FusedBroadcastAddBroadcastMultiplyDotGeneratesValidTriton) {\n-  // Here we test that the Triton codegen can handle a fusion with the chain of\n-  // a broadcast, add, broadcast, multiply, and dot. First broadcast was causing\n-  // a problem in the past because it was not using a 1d tile shape. That was\n-  // necessary for the Triton kernel to be valid.\n-  constexpr absl::string_view kHloText = R\"(\n-    HloModule gemm_fusion_dot\n-\n-    %fusion  {\n-      p0 = bf16[1024,1,512]{2,1,0} parameter(0)\n-      p0_b = bf16[1,128,8,8,64]{4,3,2,1,0} bitcast(p0)\n-      p1 = bf16[1,128,8,8]{3,2,1,0} parameter(1)\n-      c0 = bf16[] constant(3.e-02)\n-      c0_b = bf16[1,128,8,8]{3,2,1,0} broadcast(c0), dimensions={}\n-      add_0 = bf16[1,128,8,8]{3,2,1,0} add(p1, c0_b)\n-      add_bitcast = bf16[128,8,8]{2,1,0} bitcast(add_0)\n-      add_broadcast = bf16[1,128,8,8,64]{4,3,2,1,0} broadcast(add_bitcast), dimensions={1,2,3}\n-      m_p0 = bf16[1,128,8,8,64]{4,3,2,1,0} multiply(p0_b, add_broadcast)\n-      p2 = bf16[8,64]{1,0} parameter(2)\n-      c1 = bf16[] constant(1)\n-      c1_broadcast = bf16[8,64]{1,0} broadcast(c1), dimensions={}\n-      add_p2 = bf16[8,64]{1,0} add(p2, c1_broadcast)\n-      add_p2_broadcast = bf16[1,128,8,8,64]{4,3,2,1,0} broadcast(add_p2),\n-          dimensions={3,4}\n-      m_m_p0 = bf16[1,128,8,8,64]{4,3,2,1,0} multiply(m_p0, add_p2_broadcast)\n-      m_m_p0_bitcast = bf16[1024,512]{1,0} bitcast(m_m_p0)\n-      p3 = bf16[64,512]{1,0} parameter(3)\n-      ROOT dot = bf16[1024,64]{1,0} dot(m_m_p0_bitcast, p3),\n-          lhs_contracting_dims={1},\n-          rhs_contracting_dims={1}\n-    }\n-\n-    ENTRY entry_computation {\n-      p0 = bf16[1024,1,512]{2,1,0} parameter(0)\n-      p1 = bf16[1,128,8,8]{3,2,1,0} parameter(1)\n-      p2 = bf16[8,64]{1,0} parameter(2)\n-      p3 = bf16[64,512]{1,0} parameter(3)\n-      ROOT gemm_fusion_dot.1642 = bf16[1024,64]{1,0} fusion(p0, p1, p2, p3),\n-          kind=kCustom,\n-          calls=fusion\n-    }\n-  )\";\n+lhs {\n+  ROOT lhs = bf16[8,1024] parameter(0)\n+}\n+\n+rhs {\n+  rhs = s4[4,1024] parameter(0)\n+  ROOT rhs_converted = bf16[4,1024] convert(rhs)\n+}\n+\n+triton_computation {\n+  p0 = bf16[8,1024] parameter(0)\n+  p1 = s4[4,1024] parameter(1)\n+  lhs = bf16[8,1024] fusion(p0), kind=kCustom, calls=lhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  rhs = bf16[4,1024] fusion(p1), kind=kCustom, calls=rhs,\n+    backend_config={\"fusion_backend_config\":{\"kind\":\"__triton_nested_gemm_fusion\",\n+      \"block_level_fusion_config\":{\"output_tiles\":[{\"sizes\":[\"64\", \"64\"]}]}}}\n+  ROOT dot = bf16[8,4] dot(lhs, rhs),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={1}\n+}\n+\n+ENTRY main {\n+  p0 = bf16[8,1024] parameter(0)\n+  p1 = s4[4,1024] parameter(1)\n+  ROOT dot = bf16[8,4] fusion(p0, p1), kind=kCustom,\n+    calls=triton_computation, backend_config={\"fusion_backend_config\":\n+      {\"kind\":\"__triton_nested_gemm_fusion\",\n+       \"block_level_fusion_config\":{\n+        \"num_warps\":\"2\",\"output_tiles\":[{\"sizes\":[\"64\",\"64\"]}],\n+        \"num_ctas\":1,\"num_stages\":1,\"is_tma_allowed\":false,\n+        \"is_warp_specialization_allowed\":false}}}\n+})\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(\n       kHloText, ErrorSpec{/*aabs=*/1e-2, /*arel=*/1e-2}));\n }"
        }
    ],
    "stats": {
        "total": 1311,
        "additions": 506,
        "deletions": 805
    }
}