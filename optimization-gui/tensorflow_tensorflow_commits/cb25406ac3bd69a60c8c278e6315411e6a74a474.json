{
    "author": "yueshengys",
    "message": "[Mosaic TPU] Support scalar input-output-alias. Relax the condition in `ShapeVerifier::HandleCustomCall` to allow scalar operand live on S(6) while the result has no memory space assigned.\n\nPiperOrigin-RevId: 814526870",
    "sha": "cb25406ac3bd69a60c8c278e6315411e6a74a474",
    "files": [
        {
            "sha": "d3caeb1698e96820670b4d579e217e488be0a438",
            "filename": "third_party/xla/xla/service/hlo_verifier.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cb25406ac3bd69a60c8c278e6315411e6a74a474/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cb25406ac3bd69a60c8c278e6315411e6a74a474/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier.cc?ref=cb25406ac3bd69a60c8c278e6315411e6a74a474",
            "patch": "@@ -42,6 +42,7 @@ limitations under the License.\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/strings/substitute.h\"\n #include \"absl/types/span.h\"\n #include \"xla/comparison_util.h\"\n #include \"xla/hlo/ir/collective_op_group_mode.h\"\n@@ -1516,11 +1517,16 @@ absl::Status ShapeVerifier::HandleCustomCall(HloInstruction* instruction) {\n     const Shape& operand_subshape = ShapeUtil::GetSubshape(\n         custom_call->operand(pair.second.first)->shape(), pair.second.second);\n     if (opts_.layout_sensitive) {\n-      TF_RET_CHECK(Shape::Equal().IgnoreBuffer(ignore_buffer)(operand_subshape,\n-                                                              output_subshape))\n-          << \"Different aliasing shapes: \"\n-          << operand_subshape.ToString(/*print_layout=*/true) << \" vs \"\n-          << output_subshape.ToString(/*print_layout=*/true);\n+      bool operand_is_scalar = operand_subshape.IsArray() &&\n+                               ShapeUtil::ElementsIn(operand_subshape) == 1;\n+      auto shape_equal_checker = Shape::Equal().IgnoreBuffer(ignore_buffer);\n+      if (operand_is_scalar) {\n+        shape_equal_checker.IgnoreMemorySpaceInLayout();\n+      }\n+      TF_RET_CHECK(shape_equal_checker(operand_subshape, output_subshape))\n+          << absl::Substitute(\"Different aliasing shapes: $0 vs $1\",\n+                              operand_subshape.ToString(/*print_layout=*/true),\n+                              output_subshape.ToString(/*print_layout=*/true));\n     } else {\n       TF_RET_CHECK(\n           Shape::Equal().IgnoreDynamicDimension().IgnoreLayout().IgnoreBuffer("
        },
        {
            "sha": "49e21a819374a01a6274d85539ceca3143d5505b",
            "filename": "third_party/xla/xla/service/hlo_verifier_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cb25406ac3bd69a60c8c278e6315411e6a74a474/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cb25406ac3bd69a60c8c278e6315411e6a74a474/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_verifier_test.cc?ref=cb25406ac3bd69a60c8c278e6315411e6a74a474",
            "patch": "@@ -3429,6 +3429,26 @@ ENTRY entry {\n               HasSubstr(\"Shape and memory space of the result\"));\n }\n \n+TEST_F(HloVerifierTestLayoutSensitive,\n+       CustomCallOperandOutputScalarAliasingSuccessWithMemorySpaceMismatch) {\n+  constexpr absl::string_view hlo = R\"(\n+    HloModule module, input_output_alias={ {}: (0, {}, may-alias) },\n+    entry_computation_layout={(f32[1]{0:T(128)})->f32[1]{0:T(128)}}\n+\n+    ENTRY entry {\n+      x = f32[1]{0:T(128)} parameter(0)\n+      copy.1 = f32[1]{0:T(128)} copy(x)\n+      copy.2 = f32[1]{0:T(128)S(6)} copy(copy.1)\n+      copy.3 = f32[1]{0:T(128)S(6)} copy(copy.2)\n+      ROOT output = f32[1]{0:T(128)} custom-call(copy.3),\n+        custom_call_target=\"tpu_custom_call\",\n+        output_to_operand_aliasing={{}: (0, {})}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo));\n+  TF_EXPECT_OK(verifier().Run(module.get()).status());\n+}\n+\n TEST_F(HloVerifierTestLayoutSensitive, LayoutOK) {\n   constexpr absl::string_view kHlo = R\"(\n HloModule module, entry_computation_layout={(f32[10,10]{1,0},f32[10,10]{1,0})->f32[10,10]{1,0}}"
        }
    ],
    "stats": {
        "total": 36,
        "additions": 31,
        "deletions": 5
    }
}