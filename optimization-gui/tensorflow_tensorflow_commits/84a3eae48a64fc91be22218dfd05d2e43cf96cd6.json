{
    "author": "tensorflower-gardener",
    "message": "Add `EquivToProto` matchers to `tsl/util/proto/proto_matchers.h`.\n\nPiperOrigin-RevId: 797474706",
    "sha": "84a3eae48a64fc91be22218dfd05d2e43cf96cd6",
    "files": [
        {
            "sha": "b4f25adc8d94d5e6d9fe53d261c456a8403e4197",
            "filename": "third_party/xla/xla/tsl/util/proto/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2FBUILD?ref=84a3eae48a64fc91be22218dfd05d2e43cf96cd6",
            "patch": "@@ -53,6 +53,7 @@ tsl_cc_test(\n     deps = [\n         \":proto_matchers\",\n         \":proto_matchers_test_protos_cc\",\n+        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@local_tsl//tsl/platform:protobuf\","
        },
        {
            "sha": "80f55d3f4420dfd9b59467abdce9d9f225f43c52",
            "filename": "third_party/xla/xla/tsl/util/proto/proto_matchers.h",
            "status": "modified",
            "additions": 66,
            "deletions": 16,
            "changes": 82,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers.h?ref=84a3eae48a64fc91be22218dfd05d2e43cf96cd6",
            "patch": "@@ -20,11 +20,21 @@ limitations under the License.\n //\n //   EqualsProto(Proto)\n //   EqualsProto(string)\n+//   EquivToProto(Proto)\n+//   EquivToProto(string)\n //\n // The EqualsProto(Proto) matcher matches a proto that equals the given proto.\n // The EqualsProto(string) matcher matches a proto that equals the given proto\n // (represented as a text string).\n //\n+// The EquivToProto(Proto) matcher matches a proto that is equivalent to the\n+// given proto. The EquivToProto(string) matcher matches a proto that is\n+// equivalent to the given proto (represented as a text string).\n+//\n+// The difference between EqualsProto and EquivToProto can be found in\n+// `::tsl::protobuf::util::MessageDifferencer::MessageFieldComparison` (see\n+// `EQUAL` vs. `EQUIVALENT`).\n+//\n // It also defines a few transformers for proto matchers:\n //\n //   Partially(m)\n@@ -141,16 +151,18 @@ class PartialIgnore final\n // and IgnoreRepeatedFieldOrdering to adjust the values. ExpectedProto can be\n // either a proto or string.\n template <typename ExpectedProto>\n-class EqualsProtoMatcher {\n+class ProtoMatcher {\n  public:\n   static_assert(std::is_base_of_v<::tsl::protobuf::Message, ExpectedProto> ||\n                     std::is_same_v<ExpectedProto, std::string>,\n                 \"EqualsProto(p) requires p to be a proto or a string.\");\n   using is_gtest_matcher = void;\n   using is_proto_matcher = void;\n \n-  explicit EqualsProtoMatcher(ExpectedProto expected_proto)\n-      : expected_proto_(std::move(expected_proto)) {}\n+  explicit ProtoMatcher(\n+      ExpectedProto expected_proto,\n+      ::tsl::protobuf::util::MessageDifferencer::MessageFieldComparison cmp)\n+      : expected_proto_(std::move(expected_proto)), cmp_(cmp) {}\n \n   // Matches a proto against the expected proto.\n   template <typename ActualProto>\n@@ -172,6 +184,7 @@ class EqualsProtoMatcher {\n     }\n \n     ::tsl::protobuf::util::MessageDifferencer diff;\n+    diff.set_message_field_comparison(cmp_);\n     diff.set_report_ignores(false);\n     if (partial_) {\n       diff.AddIgnoreCriteria(std::make_unique<PartialIgnore>());\n@@ -192,32 +205,51 @@ class EqualsProtoMatcher {\n \n   // Describes this matcher to an ostream.\n   void DescribeTo(std::ostream* os) const {\n-    *os << absl::StreamFormat(\n-        \"equals%s%s \", partial_ ? \" (ignoring extra fields)\" : \"\",\n-        unordered_repeated_fields_ ? \" (ignoring repeated field order)\" : \"\");\n-    // StreamFormat() doesn't work with some versions of protobuf, so we need\n-    // to convert expected_proto_ to a string manually.\n-    std::string expected_proto_str;\n-    if constexpr (std::is_same_v<ExpectedProto, std::string>) {\n-      *os << expected_proto_;\n+    if (cmp_ == ::tsl::protobuf::util::MessageDifferencer::\n+                    MessageFieldComparison::EQUAL) {\n+      *os << \"equals \";\n     } else {\n-      *os << expected_proto_.DebugString();\n+      *os << \"is equivalent to \";\n     }\n+    DescribeRelationToExpectedProto(os);\n   }\n \n   // Describes the negation of this matcher to an ostream.\n   void DescribeNegationTo(std::ostream* os) const {\n-    *os << \"not \";\n-    DescribeTo(os);\n+    if (cmp_ == ::tsl::protobuf::util::MessageDifferencer::\n+                    MessageFieldComparison::EQUAL) {\n+      *os << \"not equals \";\n+    } else {\n+      *os << \"is not equivalent to \";\n+    }\n+    DescribeRelationToExpectedProto(os);\n   }\n \n   void SetPartial() { partial_ = true; }\n   void SetUnorderedRepeatedFields() { unordered_repeated_fields_ = true; }\n \n  private:\n+  void DescribeRelationToExpectedProto(::std::ostream* os) const {\n+    if (partial_) {\n+      *os << \"(ignoring extra fields) \";\n+    }\n+    if (unordered_repeated_fields_) {\n+      *os << \"(ignoring repeated field order) \";\n+    }\n+    // StreamFormat() doesn't work with some versions of protobuf, so we need\n+    // to convert expected_proto_ to a string manually.\n+    std::string expected_proto_str;\n+    if constexpr (std::is_same_v<ExpectedProto, std::string>) {\n+      *os << expected_proto_;\n+    } else {\n+      *os << expected_proto_.DebugString();\n+    }\n+  }\n+\n   ExpectedProto expected_proto_;\n   bool partial_ = false;\n   bool unordered_repeated_fields_ = false;\n+  const ::tsl::protobuf::util::MessageDifferencer::MessageFieldComparison cmp_;\n };\n \n }  // namespace internal\n@@ -226,13 +258,31 @@ class EqualsProtoMatcher {\n template <typename Proto, typename = std::enable_if_t<std::is_base_of_v<\n                               ::tsl::protobuf::Message, Proto>>>\n inline auto EqualsProto(Proto proto) {\n-  return internal::EqualsProtoMatcher<Proto>(std::move(proto));\n+  return internal::ProtoMatcher<Proto>(\n+      std::move(proto), ::tsl::protobuf::util::MessageDifferencer::EQUAL);\n }\n \n // Returns a matcher that matches a proto that equals the given proto\n // (represented as a text string).\n inline auto EqualsProto(absl::string_view proto) {\n-  return internal::EqualsProtoMatcher<std::string>(std::string(proto));\n+  return internal::ProtoMatcher<std::string>(\n+      std::string(proto), ::tsl::protobuf::util::MessageDifferencer::EQUAL);\n+}\n+\n+// Returns a matcher that matches a proto that is equivalent to the given proto.\n+template <typename Proto, typename = std::enable_if_t<std::is_base_of_v<\n+                              ::tsl::protobuf::Message, Proto>>>\n+inline auto EquivToProto(Proto proto) {\n+  return internal::ProtoMatcher<Proto>(\n+      std::move(proto), ::tsl::protobuf::util::MessageDifferencer::EQUIVALENT);\n+}\n+\n+// Returns a matcher that matches a proto that is equivalent to the given proto\n+// (represented as a text string).\n+inline auto EquivToProto(absl::string_view proto) {\n+  return internal::ProtoMatcher<std::string>(\n+      std::string(proto),\n+      ::tsl::protobuf::util::MessageDifferencer::EQUIVALENT);\n }\n \n }  // namespace proto_testing"
        },
        {
            "sha": "5af685b36c316dd5c7d7980905266f7921b55c3a",
            "filename": "third_party/xla/xla/tsl/util/proto/proto_matchers_test.cc",
            "status": "modified",
            "additions": 296,
            "deletions": 30,
            "changes": 326,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers_test.cc?ref=84a3eae48a64fc91be22218dfd05d2e43cf96cd6",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/util/proto/proto_matchers_test_protos.pb.h\"\n #include \"tsl/platform/protobuf.h\"\n@@ -49,25 +50,25 @@ std::string Describe(const Matcher<const Foo&>& matcher) {\n TEST(EqualsProto, DescribesSelfWhenGivenProto) {\n   const Matcher<const Foo&> matcher =\n       EqualsProto(MakeFoo(R\"pb(\n-        s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n+        s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n       )pb\"));\n \n   EXPECT_THAT(Describe(matcher),\n               MatchesRegex(\"equals (.|\\n)*s1: \\\"foo\\\"(.|\\n)*r3: \\\"a\\\"(.|\\n)r3: \"\n-                           \"\\\"b\\\"(.|\\n)r3: \\\"c\\\"(.|\\n)\"));\n-  EXPECT_THAT(Describe(Not(matcher)),\n-              MatchesRegex(\"not equals (.|\\n)*s1: \\\"foo\\\"(.|\\n)*r3: \"\n-                           \"\\\"a\\\"(.|\\n)r3: \\\"b\\\"(.|\\n)r3: \\\"c\\\"(.|\\n)\"));\n+                           \"\\\"b\\\"(.|\\n)r3: \\\"c\\\"(.|\\n)s4: \\\"t\\\"(.|\\n)\"));\n+  EXPECT_THAT(\n+      Describe(Not(matcher)),\n+      MatchesRegex(\"not equals (.|\\n)*s1: \\\"foo\\\"(.|\\n)*r3: \"\n+                   \"\\\"a\\\"(.|\\n)r3: \\\"b\\\"(.|\\n)r3: \\\"c\\\"(.|\\n)s4: \\\"t\\\"(.|\\n)\"));\n }\n \n TEST(EqualsProto, DescribesSelfWhenGivenString) {\n+  const std::string s = R\"pb(s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\")pb\";\n   const Matcher<const Foo&> matcher =\n-      EqualsProto(R\"pb(s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\")pb\");\n+      EqualsProto(R\"pb(s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\")pb\");\n \n-  EXPECT_EQ(Describe(matcher),\n-            R\"pb(equals s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\")pb\");\n-  EXPECT_EQ(Describe(Not(matcher)),\n-            R\"pb(not equals s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\")pb\");\n+  EXPECT_EQ(Describe(matcher), absl::StrCat(\"equals \", s));\n+  EXPECT_EQ(Describe(Not(matcher)), absl::StrCat(\"not equals \", s));\n }\n \n TEST(EqualsProto, WorksWithProtoArgument) {\n@@ -76,13 +77,18 @@ TEST(EqualsProto, WorksWithProtoArgument) {\n       r3: \"a\"\n       r3: \"b\"\n       r3: \"c\"\n+      s4: \"t\"\n     )\");\n-  EXPECT_THAT(foo, EqualsProto(MakeFoo(R\"pb(\n-                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n-              )pb\")));\n   EXPECT_THAT(foo,\n-              Not(EqualsProto(MakeFoo(R\"pb(\n-                s1: \"bar\" r3: \"a\" r3: \"b\" r3: \"c\"\n+              EqualsProto(MakeFoo(R\"pb(\n+                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+              )pb\")));\n+  EXPECT_THAT(foo, Not(EqualsProto(MakeFoo(R\"pb(\n+                s1: \"bar\"\n+                r3: \"a\"\n+                r3: \"b\"\n+                r3: \"c\"\n+                s4: \"t\"\n               )pb\"))));\n }\n \n@@ -92,29 +98,34 @@ TEST(EqualsProto, WorksWithStringArgument) {\n       r3: \"a\"\n       r3: \"b\"\n       r3: \"c\"\n+      s4: \"t\"\n     )\");\n   EXPECT_THAT(foo, EqualsProto(R\"pb(\n-                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n+                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n               )pb\"));\n   EXPECT_THAT(foo, EqualsProto(R\"pb(\n-                r3: \"a\" r3: \"b\" s1: \"foo\" r3: \"c\"\n+                r3: \"a\" r3: \"b\" s1: \"foo\" r3: \"c\" s4: \"t\"\n               )pb\"));\n-  EXPECT_THAT(foo, Not(EqualsProto(R\"pb(\n-                s1: \"foobar\" r3: \"a\" r3: \"b\" r3: \"c\"\n+  EXPECT_THAT(foo,\n+              Not(EqualsProto(R\"pb(\n+                s1: \"foobar\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n               )pb\")));\n   EXPECT_THAT(foo, Not(EqualsProto(R\"pb(\n                 !garbage ^ &*\n               )pb\")));\n+  EXPECT_THAT(\n+      foo,\n+      Not(EqualsProto(R\"pb(\n+        r3: \"a\" r3: \"b\" s1: \"foo\" r3: \"c\" r3: \"d\" s4: \"t\"\n+      )pb\")));\n   EXPECT_THAT(foo,\n               Not(EqualsProto(R\"pb(\n-                r3: \"a\" r3: \"b\" s1: \"foo\" r3: \"c\" r3: \"d\"\n-              )pb\")));\n-  EXPECT_THAT(foo, Not(EqualsProto(R\"pb(\n-                s1: \"foo\" r3: \"b\" r3: \"c\" r3: \"a\"\n-              )pb\")));\n-  EXPECT_THAT(foo, Not(EqualsProto(R\"pb(\n-                s1: \"foo\" i2: 32 r3: \"a\" r3: \"b\" r3: \"c\"\n+                s1: \"foo\" r3: \"b\" r3: \"c\" r3: \"a\" s4: \"t\"\n               )pb\")));\n+  EXPECT_THAT(\n+      foo, Not(EqualsProto(R\"pb(\n+        s1: \"foo\" i2: 32 r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+      )pb\")));\n }\n \n TEST(EqualsProto, WorksWithPartially) {\n@@ -124,12 +135,14 @@ TEST(EqualsProto, WorksWithPartially) {\n       r3: \"a\"\n       r3: \"b\"\n       r3: \"c\"\n+      s4: \"t\"\n     )\");\n+  EXPECT_THAT(\n+      foo, Partially(EqualsProto(R\"pb(\n+        s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+      )pb\")));\n   EXPECT_THAT(foo, Partially(EqualsProto(R\"pb(\n-                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n-              )pb\")));\n-  EXPECT_THAT(foo, Partially(EqualsProto(R\"pb(\n-                r3: \"a\" r3: \"b\" r3: \"c\"\n+                r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n               )pb\")));\n   EXPECT_THAT(foo, Partially(EqualsProto(R\"pb(\n                 s1: \"foo\"\n@@ -158,38 +171,44 @@ TEST(EqualsProto, WorksWithIgnoringRepeatedFieldOrdering) {\n       r3: \"a\"\n       r3: \"b\"\n       r3: \"c\"\n+      s4: \"t\"\n     )\");\n   EXPECT_THAT(foo, IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 s1: \"foo\"\n                 r3: \"a\"\n                 r3: \"c\"\n                 r3: \"b\"\n+                s4: \"t\"\n               )pb\")));\n   EXPECT_THAT(foo, IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 r3: \"a\"\n                 r3: \"c\"\n                 s1: \"foo\"\n                 r3: \"b\"\n+                s4: \"t\"\n               )pb\")));\n   EXPECT_THAT(foo, Not(IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 s1: \"foobar\"\n                 r3: \"b\"\n                 r3: \"a\"\n                 r3: \"c\"\n+                s4: \"t\"\n               )pb\"))));\n   EXPECT_THAT(foo, Not(IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 r3: \"b\"\n                 r3: \"a\"\n                 s1: \"foo\"\n                 r3: \"c\"\n                 r3: \"d\"\n+                s4: \"t\"\n               )pb\"))));\n   EXPECT_THAT(foo, Not(IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 s1: \"foo\"\n                 i2: 32\n                 r3: \"a\"\n                 r3: \"b\"\n                 r3: \"c\"\n+                s4: \"t\"\n               )pb\"))));\n }\n \n@@ -200,17 +219,20 @@ TEST(EqualsProto, WorksWithPartiallyAndIgnoringOrder) {\n       r3: \"a\"\n       r3: \"b\"\n       r3: \"c\"\n+      s4: \"t\"\n     )\");\n   EXPECT_THAT(foo, Partially(IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 s1: \"foo\"\n                 r3: \"a\"\n                 r3: \"b\"\n                 r3: \"c\"\n+                s4: \"t\"\n               )pb\"))));\n   EXPECT_THAT(foo, Partially(IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 r3: \"b\"\n                 r3: \"a\"\n                 r3: \"c\"\n+                s4: \"t\"\n               )pb\"))));\n   EXPECT_THAT(foo, Partially(IgnoringRepeatedFieldOrdering(EqualsProto(R\"pb(\n                 s1: \"foo\"\n@@ -232,6 +254,250 @@ TEST(EqualsProto, WorksWithPartiallyAndIgnoringOrder) {\n               )pb\")))));\n }\n \n+TEST(EqualsProto, DoesNotMatchWhenGivenSameValueAsDefault) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+      s4: \"s\"\n+    )\");\n+  EXPECT_THAT(foo, Not(EqualsProto(R\"pb(\n+                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n+              )pb\")));\n+}\n+\n+TEST(EquivToProto, DescribesSelfWhenGivenProto) {\n+  const Matcher<const Foo&> matcher =\n+      EquivToProto(MakeFoo(R\"pb(\n+        s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+      )pb\"));\n+\n+  EXPECT_THAT(\n+      Describe(matcher),\n+      MatchesRegex(\n+          \"is equivalent to (.|\\n)*s1: \\\"foo\\\"(.|\\n)*r3: \\\"a\\\"(.|\\n)r3: \"\n+          \"\\\"b\\\"(.|\\n)r3: \\\"c\\\"(.|\\n)s4: \\\"t\\\"(.|\\n)\"));\n+  EXPECT_THAT(\n+      Describe(Not(matcher)),\n+      MatchesRegex(\"is not equivalent to (.|\\n)*s1: \\\"foo\\\"(.|\\n)*r3: \"\n+                   \"\\\"a\\\"(.|\\n)r3: \\\"b\\\"(.|\\n)r3: \\\"c\\\"(.|\\n)s4: \\\"t\\\"(.|\\n)\"));\n+}\n+\n+TEST(EquivToProto, DescribesSelfWhenGivenString) {\n+  const std::string s = R\"pb(s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\")pb\";\n+  const Matcher<const Foo&> matcher = EquivToProto(s);\n+\n+  EXPECT_EQ(Describe(matcher), absl::StrCat(\"is equivalent to \", s));\n+  EXPECT_EQ(Describe(Not(matcher)), absl::StrCat(\"is not equivalent to \", s));\n+}\n+\n+TEST(EquivToProto, WorksWithProtoArgument) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+      s4: \"t\"\n+    )\");\n+  EXPECT_THAT(\n+      foo, EquivToProto(MakeFoo(R\"pb(\n+        s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+      )pb\")));\n+  EXPECT_THAT(foo, Not(EquivToProto(MakeFoo(R\"pb(\n+                s1: \"bar\"\n+                r3: \"a\"\n+                r3: \"b\"\n+                r3: \"c\"\n+                s4: \"t\"\n+              )pb\"))));\n+}\n+\n+TEST(EquivToProto, WorksWithStringArgument) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+      s4: \"t\"\n+    )\");\n+  EXPECT_THAT(foo, EquivToProto(R\"pb(\n+                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+              )pb\"));\n+  EXPECT_THAT(foo, EquivToProto(R\"pb(\n+                r3: \"a\" r3: \"b\" s1: \"foo\" r3: \"c\" s4: \"t\"\n+              )pb\"));\n+  EXPECT_THAT(foo,\n+              Not(EquivToProto(R\"pb(\n+                s1: \"foobar\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+              )pb\")));\n+  EXPECT_THAT(foo, Not(EquivToProto(R\"pb(\n+                !garbage ^ &*\n+              )pb\")));\n+  EXPECT_THAT(\n+      foo,\n+      Not(EquivToProto(R\"pb(\n+        r3: \"a\" r3: \"b\" s1: \"foo\" r3: \"c\" r3: \"d\" s4: \"t\"\n+      )pb\")));\n+  EXPECT_THAT(foo,\n+              Not(EquivToProto(R\"pb(\n+                s1: \"foo\" r3: \"b\" r3: \"c\" r3: \"a\" s4: \"t\"\n+              )pb\")));\n+  EXPECT_THAT(\n+      foo,\n+      Not(EquivToProto(R\"pb(\n+        s1: \"foo\" i2: 32 r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\"\n+      )pb\")));\n+}\n+\n+TEST(EquivToProto, MatchesWhenGivenSameValueAsDefault) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+      s4: \"s\"\n+    )\");\n+  EXPECT_THAT(foo, EquivToProto(R\"pb(\n+                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n+              )pb\"));\n+}\n+\n+TEST(EquivToProto, WorksWithPartially) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      i2: 32\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+      s4: \"s\"\n+    )\");\n+  EXPECT_THAT(foo, Partially(EquivToProto(R\"pb(\n+                s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\"\n+              )pb\")));\n+  EXPECT_THAT(foo, Partially(EquivToProto(R\"pb(\n+                r3: \"a\" r3: \"b\" r3: \"c\"\n+              )pb\")));\n+  EXPECT_THAT(foo, Partially(EquivToProto(R\"pb(\n+                s1: \"foo\"\n+              )pb\")));\n+  EXPECT_THAT(foo, Partially(EquivToProto(R\"pb(\n+                r3: \"a\" r3: \"b\" r3: \"c\"\n+              )pb\")));\n+  // bad order\n+  EXPECT_THAT(foo,\n+              Not(Partially(EquivToProto(R\"pb(\n+                s1: \"foo\" r3: \"b\" r3: \"c\" r3: \"a\"\n+              )pb\"))));\n+  // new value\n+  EXPECT_THAT(foo, Not(Partially(EquivToProto(R\"pb(\n+                s1: \"foo\"\n+                i2: 10\n+                r3: \"a\"\n+                r3: \"b\"\n+                r3: \"c\"\n+              )pb\"))));\n+}\n+\n+TEST(EquivToProto, WorksWithIgnoringRepeatedFieldOrdering) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+    )\");\n+  EXPECT_THAT(foo, IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                s1: \"foo\"\n+                r3: \"a\"\n+                r3: \"c\"\n+                r3: \"b\"\n+                s4: \"s\"\n+              )pb\")));\n+  EXPECT_THAT(foo, IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                r3: \"a\"\n+                r3: \"c\"\n+                s1: \"foo\"\n+                r3: \"b\"\n+                s4: \"s\"\n+              )pb\")));\n+  EXPECT_THAT(foo, Not(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                s1: \"foobar\"\n+                r3: \"b\"\n+                r3: \"a\"\n+                r3: \"c\"\n+                s4: \"s\"\n+              )pb\"))));\n+  EXPECT_THAT(foo, Not(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                r3: \"b\"\n+                r3: \"a\"\n+                s1: \"foo\"\n+                r3: \"c\"\n+                r3: \"d\"\n+                s4: \"s\"\n+              )pb\"))));\n+  EXPECT_THAT(foo, Not(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                s1: \"foo\"\n+                i2: 32\n+                r3: \"a\"\n+                r3: \"b\"\n+                r3: \"c\"\n+                s4: \"s\"\n+              )pb\"))));\n+}\n+\n+TEST(EquivToProto, WorksWithPartiallyAndIgnoringOrder) {\n+  const Foo foo = MakeFoo(R\"(\n+      s1: \"foo\"\n+      i2: 32\n+      r3: \"a\"\n+      r3: \"b\"\n+      r3: \"c\"\n+      s4: \"s\"\n+    )\");\n+  EXPECT_THAT(foo, Partially(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                s1: \"foo\"\n+                r3: \"a\"\n+                r3: \"b\"\n+                r3: \"c\"\n+              )pb\"))));\n+  EXPECT_THAT(foo, Partially(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                r3: \"b\"\n+                r3: \"a\"\n+                r3: \"c\"\n+              )pb\"))));\n+  EXPECT_THAT(foo, Partially(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                s1: \"foo\"\n+              )pb\"))));\n+  // bad order\n+  EXPECT_THAT(foo,\n+              Not(Partially(IgnoringRepeatedFieldOrdering(EquivToProto(R\"pb(\n+                s1: \"bar\"\n+                r3: \"b\"\n+                r3: \"c\"\n+                r3: \"a\"\n+              )pb\")))));\n+  // new value\n+  EXPECT_THAT(foo, Not(Partially(IgnoringRepeatedFieldOrdering(EquivToProto(\n+                       R\"pb(\n+                         s1: \"foo\" i2: 10 r3: \"b\" r3: \"a\" r3: \"c\"\n+                       )pb\")))));\n+}\n+\n+TEST(EquivToProto, DescribesSelfWithPartiallyAndIgnoringOrder) {\n+  const std::string s = R\"pb(s1: \"foo\" r3: \"a\" r3: \"b\" r3: \"c\" s4: \"t\")pb\";\n+  const Matcher<const Foo&> matcher =\n+      Partially(IgnoringRepeatedFieldOrdering(EquivToProto(s)));\n+\n+  EXPECT_EQ(Describe(matcher),\n+            absl::StrCat(\"is equivalent to (ignoring extra fields) (ignoring \"\n+                         \"repeated field order) \",\n+                         s));\n+  EXPECT_EQ(Describe(Not(matcher)),\n+            absl::StrCat(\"is not equivalent to (ignoring extra fields) \"\n+                         \"(ignoring repeated field order) \",\n+                         s));\n+}\n+\n }  // namespace\n }  // namespace proto_testing\n }  // namespace tsl"
        },
        {
            "sha": "686030380583188789aadd459243dd7e445503c5",
            "filename": "third_party/xla/xla/tsl/util/proto/proto_matchers_test_protos.proto",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers_test_protos.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84a3eae48a64fc91be22218dfd05d2e43cf96cd6/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers_test_protos.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Futil%2Fproto%2Fproto_matchers_test_protos.proto?ref=84a3eae48a64fc91be22218dfd05d2e43cf96cd6",
            "patch": "@@ -20,4 +20,5 @@ message Foo {\n   optional string s1 = 1;\n   optional int32 i2 = 2;\n   repeated string r3 = 3;\n+  optional string s4 = 4 [default = \"s\"];\n }"
        }
    ],
    "stats": {
        "total": 410,
        "additions": 364,
        "deletions": 46
    }
}