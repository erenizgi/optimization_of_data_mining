{
    "author": "junwhanahn",
    "message": "Replace IFRT futures/promises with TSL futures/promises\n\nIFRT futures/promises have been deprecated in favor of TSL futures/promises.\n\nPiperOrigin-RevId: 812523966",
    "sha": "124996c7f5b8ff168cf634454d367bf80d4e1639",
    "files": [
        {
            "sha": "14efb3cc2715fc0795363ada8cf8d37ce5398533",
            "filename": "third_party/xla/xla/python/ifrt_proxy/integration_tests/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2FBUILD?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -135,6 +135,7 @@ ifrt_proxy_cc_test(\n         \"//xla/python/ifrt_proxy/client:registry\",\n         \"//xla/python/ifrt_proxy/server:grpc_server\",\n         \"//xla/python/pjrt_ifrt\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\","
        },
        {
            "sha": "6fc395570cf86cae0958df88f9baf9604d342686",
            "filename": "third_party/xla/xla/python/ifrt_proxy/integration_tests/mock_array_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fmock_array_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fmock_array_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fmock_array_test.cc?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -41,7 +41,6 @@\n #include \"xla/python/ifrt/client.h\"\n #include \"xla/python/ifrt/device.h\"\n #include \"xla/python/ifrt/dtype.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/memory.h\"\n #include \"xla/python/ifrt/mock.h\"\n #include \"xla/python/ifrt/shape.h\"\n@@ -51,6 +50,7 @@\n #include \"xla/python/ifrt_proxy/client/registry.h\"\n #include \"xla/python/ifrt_proxy/server/grpc_server.h\"\n #include \"xla/python/pjrt_ifrt/pjrt_client.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/status_matchers.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -134,7 +134,7 @@ class MockArrayTest : public testing::Test {\n                     absl::MutexLock l(mu_);\n                     if (get_ready_hook_) {\n                       absl::Status s = get_ready_hook_();\n-                      if (!s.ok()) return Future<>(s);\n+                      if (!s.ok()) return tsl::Future<>(s);\n                     }\n                     return delegated->GetReadyFuture();\n                   });\n@@ -144,7 +144,7 @@ class MockArrayTest : public testing::Test {\n                     absl::MutexLock l(mu_);\n                     if (copy_host_hook_) {\n                       absl::Status s = copy_host_hook_();\n-                      if (!s.ok()) return Future<>(s);\n+                      if (!s.ok()) return tsl::Future<>(s);\n                     }\n                     return delegated->CopyToHostBuffer(data, byte_strides,\n                                                        semantics);\n@@ -154,7 +154,7 @@ class MockArrayTest : public testing::Test {\n \n     ON_CALL(*mock_backend, GetReadyFuture)\n         .WillByDefault([](absl::Span<const ValueRef> values) {\n-          std::vector<Future<>> futures;\n+          std::vector<tsl::Future<>> futures;\n           futures.reserve(values.size());\n           for (const auto& value : values) {\n             futures.push_back(value->GetReadyFuture());"
        },
        {
            "sha": "44d0087641dd5d5be7770b5f8d584130b5e28e4f",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/BUILD",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -151,6 +151,7 @@ cc_library(\n         \"//xla/python/ifrt_proxy/common:types_proto_cc\",\n         \"//xla/python/ifrt_proxy/common:versions\",\n         \"//xla/python/pjrt_ifrt:xla_ifrt\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n@@ -205,6 +206,7 @@ ifrt_proxy_cc_test(\n         \"//xla/python/ifrt_proxy/common:versions\",\n         \"//xla/python/pjrt_ifrt:xla_ifrt\",\n         \"//xla/service:computation_placer_hdr\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:env\",\n@@ -240,8 +242,8 @@ cc_library(\n     hdrs = [\"mock_ifrt_backend.h\"],\n     deps = [\n         \":ifrt_backend\",\n-        \"//xla/python/ifrt\",\n         \"//xla/python/ifrt_proxy/common:ifrt_service_proto_cc\",\n+        \"//xla/tsl/concurrency:future\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_googletest//:gtest_for_library\",\n     ],\n@@ -279,6 +281,7 @@ cc_library(\n         \"//xla/python/ifrt_proxy/common:proto_util\",\n         \"//xla/python/pjrt_ifrt\",\n         \"//xla/python/pjrt_ifrt:xla_host_callback_proto_cc\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n@@ -326,7 +329,7 @@ ifrt_proxy_cc_test(\n     srcs = [\"host_buffer_test.cc\"],\n     deps = [\n         \":host_buffer\",\n-        \"//xla/python/ifrt\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"@com_google_absl//absl/status\","
        },
        {
            "sha": "185facc7ff3a3ed4fdf58d578c4b432d07068f42",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/host_buffer_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer_test.cc?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -25,7 +25,7 @@\n #include \"absl/synchronization/notification.h\"\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n-#include \"xla/python/ifrt/future.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/status_matchers.h\"\n \n@@ -58,7 +58,7 @@ TEST(HostBufferStoreTest, WriteAfterReadStarted) {\n   const uint64_t kHandle = 1;\n \n   auto [lookup_promise, lookup_fut] =\n-      Future<HostBufferStore::MemRegion>::MakePromise();\n+      tsl::Future<HostBufferStore::MemRegion>::MakePromise();\n \n   absl::Notification closure_started;\n   tsl::Env::Default()->SchedClosure(\n@@ -80,7 +80,7 @@ TEST(HostBufferStoreTest, ShutdownAfterReadStarted) {\n   const uint64_t kHandle = 1;\n \n   auto [lookup_promise, lookup_fut] =\n-      Future<HostBufferStore::MemRegion>::MakePromise();\n+      tsl::Future<HostBufferStore::MemRegion>::MakePromise();\n \n   absl::Notification closure_started;\n   tsl::Env::Default()->SchedClosure([&, promise = std::move("
        },
        {
            "sha": "7af4bfcf219fde01b3bfaed2b430a5001e2d2bee",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/host_callback.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.cc?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -33,13 +33,13 @@\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/pjrt/host_callback.h\"\n #include \"xla/python/ifrt/client.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt_proxy/common/proto_util.h\"\n #include \"xla/python/pjrt_ifrt/pjrt_host_callback.h\"\n #include \"xla/python/pjrt_ifrt/xla_host_callback.pb.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -164,8 +164,8 @@ absl::Status RemoteLoadedHostCallback::Execute(void** result_ptrs,\n   to_buffer(host_callback().operands, operand_ptrs, request.operands);\n   to_buffer(host_callback().results, result_ptrs, request.results);\n \n-  Future<> status;\n-  std::tie(request.status, status) = Future<>::MakePromise();\n+  tsl::Future<> status;\n+  std::tie(request.status, status) = tsl::Future<>::MakePromise();\n \n   // Enqueue the execution request. `IfrtBackend` retrieves this by calling\n   // `PopExecutionRequest` and fulfills the `results` promise."
        },
        {
            "sha": "bcdca71a25b4705b5f9f0aebbf670da48a8670d1",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/host_callback.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.h?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -32,8 +32,8 @@\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/pjrt/host_callback.h\"\n #include \"xla/python/ifrt/client.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/pjrt_ifrt/pjrt_host_callback.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n@@ -55,7 +55,7 @@ class RemoteLoadedHostCallbackQueue {\n   struct ExecutionRequest {\n     std::vector<Buffer> operands;\n     std::vector<Buffer> results;\n-    Future<>::Promise status;\n+    tsl::Promise<> status;\n   };\n \n   ~RemoteLoadedHostCallbackQueue();"
        },
        {
            "sha": "69b22daa93fd46e3809055895a813c8497d3c1da",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 62,
            "deletions": 56,
            "changes": 118,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -54,7 +54,6 @@\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n #include \"xla/python/ifrt/executable.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt/memory.h\"\n #include \"xla/python/ifrt/program.h\"\n@@ -79,6 +78,7 @@\n #include \"xla/python/ifrt_proxy/server/version.h\"\n #include \"xla/python/pjrt_ifrt/xla_compiler.h\"\n #include \"xla/status_macros.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n@@ -319,7 +319,7 @@ struct IfrtBackend::LoadedExecutableWithInfo {\n class IfrtBackend::InOrderRequestsProcessor {\n   struct Entry {\n     std::unique_ptr<IfrtRequest> req;\n-    Future<Response>::Promise promise;\n+    tsl::Promise<Response> promise;\n     XFlowHelper xflow;\n   };\n \n@@ -357,9 +357,9 @@ class IfrtBackend::InOrderRequestsProcessor {\n     LOG(INFO) << \"IfrtBackend::InOrderRequestsProcessor has been destroyed.\";\n   }\n \n-  Future<Response> Push(std::unique_ptr<IfrtRequest> request) {\n+  tsl::Future<Response> Push(std::unique_ptr<IfrtRequest> request) {\n     VLOG(3) << \"Enqueuing \" << request->ShortDebugString();\n-    auto [promise, future] = Future<Response>::MakePromise();\n+    auto [promise, future] = tsl::Future<Response>::MakePromise();\n     absl::MutexLock l(mu_);\n     if (shutdown_msg_.has_value()) {\n       promise.Set(absl::InternalError(absl::StrCat(\n@@ -517,77 +517,81 @@ IfrtBackend::~IfrtBackend() {\n   }\n }\n \n-Future<BackendInterface::Response> IfrtBackend::Process(\n+tsl::Future<BackendInterface::Response> IfrtBackend::Process(\n     std::unique_ptr<IfrtRequest> request) {\n   return in_order_requests_processor_->Push(std::move(request));\n }\n \n-Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n+tsl::Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n     std::unique_ptr<IfrtRequest> request) {\n   std::optional<ArrayStore::Reservation> asr;\n   switch (request->request_case()) {\n     case IfrtRequest::RequestCase::kInitRequest:\n-      return Future<Response>(HandleInit(std::move(request)));\n+      return tsl::Future<Response>(HandleInit(std::move(request)));\n     case IfrtRequest::RequestCase::kCheckFutureRequest:\n       return HandleCheckFutureRequest(std::move(request));\n     case IfrtRequest::RequestCase::kMakeArrayFromHostBufferRequest:\n       asr.emplace(request->make_array_from_host_buffer_request().array_handle(),\n                   &array_store_);\n-      return Future<Response>(asr->ProcessResponse(\n+      return tsl::Future<Response>(asr->ProcessResponse(\n           HandleMakeArrayFromHostBufferRequest(*asr, std::move(request))));\n     case IfrtRequest::RequestCase::kMakeArraysFromHostBufferShardsRequest:\n       asr.emplace(request->make_arrays_from_host_buffer_shards_request()\n                       .array_handles(),\n                   &array_store_);\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           asr->ProcessResponse(HandleMakeArraysFromHostBufferShardsRequest(\n               *asr, std::move(request))));\n     case IfrtRequest::RequestCase::kMakeErrorArraysRequest:\n       asr.emplace(request->make_error_arrays_request().array_handles(),\n                   &array_store_);\n-      return Future<Response>(asr->ProcessResponse(\n+      return tsl::Future<Response>(asr->ProcessResponse(\n           HandleMakeErrorArraysRequest(*asr, std::move(request))));\n     case IfrtRequest::RequestCase::kAssembleArrayFromSingleDeviceArraysRequest:\n       asr.emplace(request->assemble_array_from_single_device_arrays_request()\n                       .result_handle(),\n                   &array_store_);\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           asr->ProcessResponse(HandleAssembleArrayFromSingleDeviceArraysRequest(\n               *asr, std::move(request))));\n     case IfrtRequest::RequestCase::kRemapArraysRequest:\n       asr.emplace(request->remap_arrays_request().result_handles(),\n                   &array_store_);\n-      return Future<Response>(asr->ProcessResponse(\n+      return tsl::Future<Response>(asr->ProcessResponse(\n           HandleRemapArraysRequest(*asr, std::move(request))));\n     case IfrtRequest::RequestCase::kCopyToHostBufferRequest:\n       return HandleCopyToHostBufferRequest(std::move(request));\n     case IfrtRequest::RequestCase::kDisassembleIntoSingleDeviceArraysRequest:\n       asr.emplace(request->disassemble_into_single_device_arrays_request()\n                       .result_handles(),\n                   &array_store_);\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           asr->ProcessResponse(HandleDisassembleIntoSingleDeviceArraysRequest(\n               *asr, std::move(request))));\n     case IfrtRequest::RequestCase::kCheckValueReadyRequest:\n-      return Future<Response>(HandleCheckValueReadyRequest(std::move(request)));\n+      return tsl::Future<Response>(\n+          HandleCheckValueReadyRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kCopyArraysRequest:\n       asr.emplace(request->copy_arrays_request().result_handles(),\n                   &array_store_);\n-      return Future<Response>(asr->ProcessResponse(\n+      return tsl::Future<Response>(asr->ProcessResponse(\n           HandleCopyArraysRequest(*asr, std::move(request))));\n     case IfrtRequest::RequestCase::kFullyReplicatedShardRequest:\n       asr.emplace(request->fully_replicated_shard_request().result_handle(),\n                   &array_store_);\n-      return Future<Response>(asr->ProcessResponse(\n+      return tsl::Future<Response>(asr->ProcessResponse(\n           HandleFullyReplicatedShardRequest(*asr, std::move(request))));\n     case IfrtRequest::RequestCase::kDeleteArrayRequest:\n-      return Future<Response>(HandleDeleteArrayRequest(std::move(request)));\n+      return tsl::Future<Response>(\n+          HandleDeleteArrayRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kIsArrayDeletedRequest:\n-      return Future<Response>(HandleIsArrayDeletedRequest(std::move(request)));\n+      return tsl::Future<Response>(\n+          HandleIsArrayDeletedRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kDestructArrayRequest:\n-      return Future<Response>(HandleDestructArrayRequest(std::move(request)));\n+      return tsl::Future<Response>(\n+          HandleDestructArrayRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kCompileRequest:\n-      return Future<Response>(HandleCompileRequest(std::move(request)));\n+      return tsl::Future<Response>(HandleCompileRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kLoadedExecutableMetadataRequest:\n       return HandleLoadedExecutableMetadataRequest(std::move(request));\n     case IfrtRequest::RequestCase::kLoadedExecutableExecuteRequest: {\n@@ -603,40 +607,40 @@ Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n         absl::MutexLock l(futures_mutex_);\n         const bool inserted = futures_\n                                   .insert({client_generated_status_handle,\n-                                           Future<>(result.status())})\n+                                           tsl::Future<>(result.status())})\n                                   .second;\n         // If `HandleLoadedExecutableExecuteRequest` returned OK, verify that\n         // it already has populated status_handle.\n         if (result.ok()) {\n           CHECK(!inserted);\n         }\n       }\n-      return Future<Response>(asr->ProcessResponse(std::move(result)));\n+      return tsl::Future<Response>(asr->ProcessResponse(std::move(result)));\n     }\n     case IfrtRequest::RequestCase::kLoadedExecutableDeleteRequest:\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           HandleLoadedExecutableDeleteRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kLoadedExecutableIsDeletedRequest:\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           HandleLoadedExecutableIsDeletedRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kLoadedExecutableDestructRequest:\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           HandleLoadedExecutableDestructRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kLoadedHostCallbackPollRequest:\n       return HandleLoadedHostCallbackPollRequest(std::move(request));\n     case IfrtRequest::RequestCase::kLoadedHostCallbackReturnRequest:\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           HandleLoadedHostCallbackReturnRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kGetDefaultDeviceAssignmentRequest:\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           HandleGetDefaultDeviceAssignmentRequest(std::move(request)));\n     case IfrtRequest::RequestCase::kGetDefaultLayoutRequest:\n-      return Future<Response>(\n+      return tsl::Future<Response>(\n           HandleGetDefaultLayoutRequest(std::move(request)));\n     default:\n       LOG(ERROR) << \"Got unimplemented request type: \"\n                  << request->DebugString();\n-      return Future<Response>(absl::UnimplementedError(absl::StrCat(\n+      return tsl::Future<Response>(absl::UnimplementedError(absl::StrCat(\n           \"Got unimplemented request type: \", request->request_case())));\n   }\n }\n@@ -659,14 +663,14 @@ void IfrtBackend::HandleGenerator::GenerateAtServerBulk(\n   CHECK_GE(current_, kServerGeneratedHandlesMinValue);\n }\n \n-Future<BackendInterface::Response> IfrtBackend::AsyncExecute(\n+tsl::Future<BackendInterface::Response> IfrtBackend::AsyncExecute(\n     std::function<absl::StatusOr<Response>()> handle_fn,\n     tsl::thread::ThreadPool* thread_pool) {\n   {\n     absl::MutexLock lock(in_flight_count_mutex_);\n     ++in_flight_count_;\n   }\n-  auto [promise, future] = Future<Response>::MakePromise();\n+  auto [promise, future] = tsl::Future<Response>::MakePromise();\n   auto f = [this, promise = std::move(promise).ToShared(),\n             handle_fn = std::move(handle_fn)]() mutable {\n     promise->Set(handle_fn());\n@@ -768,24 +772,24 @@ absl::StatusOr<BackendInterface::Response> IfrtBackend::HandleInit(\n   return response;\n }\n \n-Future<BackendInterface::Response> IfrtBackend::HandleCheckFutureRequest(\n+tsl::Future<BackendInterface::Response> IfrtBackend::HandleCheckFutureRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   const CheckFutureRequest& check_request = request->check_future_request();\n \n-  Future<> future;\n+  tsl::Future<> future;\n   {\n     absl::MutexLock lock(futures_mutex_);\n     const auto it = futures_.find(check_request.future_handle());\n     if (it == futures_.end()) {\n-      return Future<Response>(absl::NotFoundError(absl::StrCat(\n+      return tsl::Future<Response>(absl::NotFoundError(absl::StrCat(\n           \"Unknown future handle: \", check_request.future_handle())));\n     }\n     future = std::move(it->second);\n     futures_.erase(it);\n   }\n \n   auto [promise, resp_future] =\n-      Future<BackendInterface::Response>::MakePromise();\n+      tsl::Future<BackendInterface::Response>::MakePromise();\n   // With PjRtFuture, the `Future` needs to be owned by one or more owners until\n   // `OnReady()`'s lambda gets executed. So, capture a copy of `future` in the\n   // lambda, making the lambda itself an owner of `future`.\n@@ -804,7 +808,8 @@ Future<BackendInterface::Response> IfrtBackend::HandleCheckFutureRequest(\n   return std::move(resp_future);\n }\n \n-Future<BackendInterface::Response> IfrtBackend::HandleCheckValueReadyRequest(\n+tsl::Future<BackendInterface::Response>\n+IfrtBackend::HandleCheckValueReadyRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   std::vector<xla::ifrt::ValueRef> values;\n   values.reserve(request->check_value_ready_request().value_handles_size());\n@@ -814,13 +819,13 @@ Future<BackendInterface::Response> IfrtBackend::HandleCheckValueReadyRequest(\n     // type, but this may be extended later to other types such as Tuples.\n     absl::StatusOr<IfrtArrayRef> array = array_store_.Find(value_handle);\n     if (!array.ok()) {\n-      return Future<Response>(array.status());\n+      return tsl::Future<Response>(array.status());\n     }\n     values.push_back(*std::move(array));\n   }\n \n   auto [ifrt_response_promise, ifrt_response_future] =\n-      Future<BackendInterface::Response>::MakePromise();\n+      tsl::Future<BackendInterface::Response>::MakePromise();\n \n   client_->GetReadyFuture(values).OnReady(\n       [op_id = request->request_metadata().op_id(),\n@@ -1079,7 +1084,7 @@ IfrtBackend::HandleRemapArraysRequest(ArrayStore::Reservation& asr,\n   return response;\n }\n \n-Future<BackendInterface::Response>\n+tsl::Future<BackendInterface::Response>\n IfrtBackend::HandleCopyToStringHostBufferRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   const CopyToHostBufferRequest& copy_to_host =\n@@ -1088,23 +1093,23 @@ IfrtBackend::HandleCopyToStringHostBufferRequest(\n   absl::StatusOr<IfrtArrayRef> array =\n       array_store_.Find(copy_to_host.array_handle());\n   if (!array.ok()) {\n-    return Future<Response>(array.status());\n+    return tsl::Future<Response>(array.status());\n   }\n \n   if (copy_to_host.has_byte_strides()) {\n-    return Future<Response>(absl::InvalidArgumentError(\n+    return tsl::Future<Response>(absl::InvalidArgumentError(\n         \"Byte strides are not supported for string arrays.\"));\n   }\n \n   // Allocate the host buffer and start the copy.\n   auto host_buffer = std::make_unique<std::vector<absl::Cord>>(\n       (*array)->shape().num_elements());\n-  Future<> copy_status = (*array)->CopyToHostBuffer(\n+  tsl::Future<> copy_status = (*array)->CopyToHostBuffer(\n       host_buffer->data(), /*byte_strides=*/std::nullopt,\n       ArrayCopySemantics::kAlwaysCopy);\n \n   auto [resp_promise, resp_future] =\n-      Future<BackendInterface::Response>::MakePromise();\n+      tsl::Future<BackendInterface::Response>::MakePromise();\n \n   // Make the response proto when the copy is done.\n   auto response_maker =\n@@ -1133,15 +1138,16 @@ IfrtBackend::HandleCopyToStringHostBufferRequest(\n   return std::move(resp_future);\n }\n \n-Future<BackendInterface::Response> IfrtBackend::HandleCopyToHostBufferRequest(\n+tsl::Future<BackendInterface::Response>\n+IfrtBackend::HandleCopyToHostBufferRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   const CopyToHostBufferRequest& copy_to_host =\n       request->copy_to_host_buffer_request();\n \n   absl::StatusOr<IfrtArrayRef> array =\n       array_store_.Find(copy_to_host.array_handle());\n   if (!array.ok()) {\n-    return Future<Response>(array.status());\n+    return tsl::Future<Response>(array.status());\n   }\n \n   if ((*array)->dtype().kind() == DType::kString) {\n@@ -1161,7 +1167,7 @@ Future<BackendInterface::Response> IfrtBackend::HandleCopyToHostBufferRequest(\n       /*zeroth_element=*/nullptr, (*array)->dtype(), (*array)->shape(),\n       byte_strides);\n   if (!pseudo_mem_region.ok()) {\n-    return Future<Response>(pseudo_mem_region.status());\n+    return tsl::Future<Response>(pseudo_mem_region.status());\n   }\n \n   // Use `std::unique_ptr<std::string>` for pointer stability.\n@@ -1172,16 +1178,16 @@ Future<BackendInterface::Response> IfrtBackend::HandleCopyToHostBufferRequest(\n       absl::string_view(*host_buffer), (*array)->dtype(), (*array)->shape(),\n       byte_strides);\n   if (!mem_region.ok()) {\n-    return Future<Response>(mem_region.status());\n+    return tsl::Future<Response>(mem_region.status());\n   }\n \n   // TODO(b/282757875): Consider other ArrayCopySemantics.\n-  Future<> copy_status =\n+  tsl::Future<> copy_status =\n       (*array)->CopyToHostBuffer(mem_region->zeroth_element(), byte_strides,\n                                  ArrayCopySemantics::kAlwaysCopy);\n \n   auto [resp_promise, resp_future] =\n-      Future<BackendInterface::Response>::MakePromise();\n+      tsl::Future<BackendInterface::Response>::MakePromise();\n   auto on_ready = [this, op_id = request->request_metadata().op_id(),\n                    host_buffer = std::move(host_buffer),\n                    host_buffer_handle = copy_to_host.host_buffer_handle()](\n@@ -1309,14 +1315,14 @@ IfrtBackend::HandleFullyReplicatedShardRequest(\n absl::StatusOr<BackendInterface::Response>\n IfrtBackend::HandleDeleteArrayRequest(std::unique_ptr<IfrtRequest> request) {\n   std::vector<uint64_t> bad_handles;\n-  std::vector<Future<>> deletion_futures;\n+  std::vector<tsl::Future<>> deletion_futures;\n \n   auto delete_handle = [&](uint64_t handle) {\n     absl::StatusOr<IfrtArrayRef> array = array_store_.Find(handle);\n     if (array.ok()) {\n       deletion_futures.push_back(array.value()->Delete());\n     } else {\n-      deletion_futures.push_back(Future<>(array.status()));\n+      deletion_futures.push_back(tsl::Future<>(array.status()));\n     }\n   };\n \n@@ -1381,7 +1387,7 @@ IfrtBackend::HandleDestructArrayRequest(std::unique_ptr<IfrtRequest> request) {\n   return ifrt_resp;\n }\n \n-Future<BackendInterface::Response> IfrtBackend::HandleCompileRequest(\n+tsl::Future<BackendInterface::Response> IfrtBackend::HandleCompileRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   // Perform compilation on a thread pool in order to (1) avoid blocking the RPC\n   // thread during compilation and (2) run compilation with bigger stacks (often\n@@ -1507,7 +1513,7 @@ Future<BackendInterface::Response> IfrtBackend::HandleCompileRequest(\n   return AsyncExecute(std::move(f), &compile_thread_pool_);\n }\n \n-Future<BackendInterface::Response>\n+tsl::Future<BackendInterface::Response>\n IfrtBackend::HandleLoadedExecutableMetadataRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   // Call `GetParameterShardings` and `GetOutputShardings` in the background\n@@ -1520,7 +1526,7 @@ IfrtBackend::HandleLoadedExecutableMetadataRequest(\n                               .loaded_executable_handle());\n \n   if (!executable_info.ok()) {\n-    return Future<BackendInterface::Response>(executable_info.status());\n+    return tsl::Future<BackendInterface::Response>(executable_info.status());\n   }\n \n   return AsyncExecute([executable_info = *std::move(executable_info),\n@@ -1771,7 +1777,7 @@ IfrtBackend::HandleLoadedExecutableExecuteRequest(\n absl::StatusOr<BackendInterface::Response>\n IfrtBackend::HandleLoadedExecutableDeleteRequest(\n     std::unique_ptr<IfrtRequest> request) {\n-  Future<> future(absl::UnimplementedError(\n+  tsl::Future<> future(absl::UnimplementedError(\n       \"LoadedExecutable::Delete is no longer supported\"));\n \n   auto ifrt_resp = NewIfrtResponse(request->request_metadata().op_id());\n@@ -1827,7 +1833,7 @@ IfrtBackend::HandleLoadedExecutableDestructRequest(\n   return ifrt_resp;\n }\n \n-Future<BackendInterface::Response>\n+tsl::Future<BackendInterface::Response>\n IfrtBackend::HandleLoadedHostCallbackPollRequest(\n     std::unique_ptr<IfrtRequest> request) {\n   return AsyncExecute([this, request = std::shared_ptr<IfrtRequest>(std::move("
        },
        {
            "sha": "366ec8a7768f3da4255ee6becd14c887bd5c1cbe",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.h",
            "status": "modified",
            "additions": 15,
            "deletions": 13,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -32,13 +32,13 @@\n #include \"xla/python/ifrt/array_spec.h\"\n #include \"xla/python/ifrt/client.h\"\n #include \"xla/python/ifrt/executable.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt/serdes_any_version_accessor.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n #include \"xla/python/ifrt_proxy/server/host_buffer.h\"\n #include \"xla/python/ifrt_proxy/server/host_callback.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n \n namespace xla {\n@@ -59,7 +59,8 @@ class BackendInterface {\n   using Response = std::shared_ptr<IfrtResponse>;\n \n   // Processes a given IFRT Request and returns a Future of an IfrtResponse.\n-  virtual Future<Response> Process(std::unique_ptr<IfrtRequest> request) = 0;\n+  virtual tsl::Future<Response> Process(\n+      std::unique_ptr<IfrtRequest> request) = 0;\n };\n \n // IfrtBackend implements a backend that already has a linkable C++ client that\n@@ -85,7 +86,7 @@ class IfrtBackend final : public BackendInterface {\n         SerDesVersionNumber(version_.ifrt_serdes_version_number()));\n   }\n \n-  Future<Response> Process(std::unique_ptr<IfrtRequest> request) override;\n+  tsl::Future<Response> Process(std::unique_ptr<IfrtRequest> request) override;\n \n  private:\n   // Generates unique handles for returning to the client. Guaranteed to return\n@@ -163,22 +164,22 @@ class IfrtBackend final : public BackendInterface {\n   // that becomes ready when the function returns. If the thread pool is not\n   // given, uses a default thread pool implementation that does not limit the\n   // maximum number of threads.\n-  Future<Response> AsyncExecute(\n+  tsl::Future<Response> AsyncExecute(\n       std::function<absl::StatusOr<Response>()> handle_fn,\n       tsl::thread::ThreadPool* thread_pool = nullptr);\n \n-  Future<Response> ProcessInternal(std::unique_ptr<IfrtRequest> request);\n+  tsl::Future<Response> ProcessInternal(std::unique_ptr<IfrtRequest> request);\n \n   //////////////////////////////////////////////////////////////////////\n   // Handlers for individual requests\n   //\n \n   absl::StatusOr<Response> HandleInit(std::unique_ptr<IfrtRequest> request);\n \n-  Future<Response> HandleCheckFutureRequest(\n+  tsl::Future<Response> HandleCheckFutureRequest(\n       std::unique_ptr<IfrtRequest> request);\n \n-  Future<Response> HandleCheckValueReadyRequest(\n+  tsl::Future<Response> HandleCheckValueReadyRequest(\n       std::unique_ptr<IfrtRequest> request);\n \n   absl::StatusOr<Response> HandleMakeArrayFromHostBufferRequest(\n@@ -191,7 +192,7 @@ class IfrtBackend final : public BackendInterface {\n       ArrayStore::Reservation& asr, std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleRemapArraysRequest(\n       ArrayStore::Reservation& asr, std::unique_ptr<IfrtRequest> request);\n-  Future<Response> HandleCopyToHostBufferRequest(\n+  tsl::Future<Response> HandleCopyToHostBufferRequest(\n       std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleDisassembleIntoSingleDeviceArraysRequest(\n       ArrayStore::Reservation& asr, std::unique_ptr<IfrtRequest> request);\n@@ -206,9 +207,10 @@ class IfrtBackend final : public BackendInterface {\n   absl::StatusOr<Response> HandleDestructArrayRequest(\n       std::unique_ptr<IfrtRequest> request);\n \n-  Future<Response> HandleCompileRequest(std::unique_ptr<IfrtRequest> request);\n+  tsl::Future<Response> HandleCompileRequest(\n+      std::unique_ptr<IfrtRequest> request);\n \n-  Future<Response> HandleLoadedExecutableMetadataRequest(\n+  tsl::Future<Response> HandleLoadedExecutableMetadataRequest(\n       std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleLoadedExecutableExecuteRequest(\n       ArrayStore::Reservation& asr, std::unique_ptr<IfrtRequest> request);\n@@ -219,7 +221,7 @@ class IfrtBackend final : public BackendInterface {\n   absl::StatusOr<Response> HandleLoadedExecutableDestructRequest(\n       std::unique_ptr<IfrtRequest> request);\n \n-  Future<Response> HandleLoadedHostCallbackPollRequest(\n+  tsl::Future<Response> HandleLoadedHostCallbackPollRequest(\n       std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleLoadedHostCallbackReturnRequest(\n       std::unique_ptr<IfrtRequest> request);\n@@ -233,7 +235,7 @@ class IfrtBackend final : public BackendInterface {\n   // Auxiliary/Helper methods for the handler methods above\n   //\n \n-  Future<BackendInterface::Response> HandleCopyToStringHostBufferRequest(\n+  tsl::Future<BackendInterface::Response> HandleCopyToStringHostBufferRequest(\n       std::unique_ptr<IfrtRequest> request);\n \n   //////////////////////////////////////////////////////////////////////\n@@ -253,7 +255,7 @@ class IfrtBackend final : public BackendInterface {\n   const std::shared_ptr<HostBufferStore> host_buffer_store_;\n \n   absl::Mutex futures_mutex_;\n-  absl::flat_hash_map<uint64_t, Future<>> futures_\n+  absl::flat_hash_map<uint64_t, tsl::Future<>> futures_\n       ABSL_GUARDED_BY(futures_mutex_);\n \n   ArrayStore array_store_;"
        },
        {
            "sha": "37e25cf5794b68258dfd6bc4b0d6b294aa99398b",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend_test.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -54,7 +54,6 @@\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n #include \"xla/python/ifrt/executable.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt/memory.h\"\n #include \"xla/python/ifrt/mock.h\"\n@@ -75,6 +74,7 @@\n #include \"xla/service/computation_placer.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/status_macros.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n@@ -759,7 +759,7 @@ TEST_P(IfrtBackendHandlerTest, CopyToHostSuccess) {\n   const std::optional<absl::Span<const int64_t>> expected_byte_strides =\n       absl::Span<const int64_t>(expected_byte_strides_vec);\n   EXPECT_CALL(*array, CopyToHostBuffer(_, expected_byte_strides, _))\n-      .WillOnce(Return(Future<>(absl::OkStatus())));\n+      .WillOnce(Return(tsl::Future<>(absl::OkStatus())));\n \n   TF_ASSERT_OK_AND_ASSIGN(auto response, CallBackend(std::move(ifrt_request)));\n   // Given the above shape, dtype, and compact byte_strides, the size of the\n@@ -814,7 +814,7 @@ TEST_P(IfrtBackendHandlerTest, CopyToHostSuccessWithStringArray) {\n         for (int i = 0; i < input_strings.size(); ++i) {\n           dst[i] = input_strings[i];\n         }\n-        return Future<>(absl::OkStatus());\n+        return tsl::Future<>(absl::OkStatus());\n       });\n \n   EXPECT_CALL(*mock_client_,\n@@ -1004,8 +1004,8 @@ TEST_P(IfrtBackendHandlerTest,\n   TF_ASSERT_OK_AND_ASSIGN(auto array_handle,\n                           MakeTestArray(std::move(mock_array)));\n   EXPECT_CALL(*mock_client_, GetReadyFuture(_))\n-      .WillOnce(Return(Future<>(absl::OkStatus())))\n-      .WillOnce(Return(Future<>(absl::UnknownError(\"injected error\"))));\n+      .WillOnce(Return(tsl::Future<>(absl::OkStatus())))\n+      .WillOnce(Return(tsl::Future<>(absl::UnknownError(\"injected error\"))));\n \n   {\n     auto ifrt_request = NewIfrtRequest(NewOpId());\n@@ -1040,10 +1040,10 @@ TEST_P(IfrtBackendHandlerTest,\n TEST_P(IfrtBackendHandlerTest, DeleteArraySuccess) {\n   auto mock_array1 = tsl::MakeRef<xla::ifrt::MockArray>();\n   EXPECT_CALL(*mock_array1, Delete())\n-      .WillOnce(Return(Future<>(absl::OkStatus())));\n+      .WillOnce(Return(tsl::Future<>(absl::OkStatus())));\n   auto mock_array2 = tsl::MakeRef<xla::ifrt::MockArray>();\n   EXPECT_CALL(*mock_array2, Delete())\n-      .WillOnce(Return(Future<>(absl::OkStatus())));\n+      .WillOnce(Return(tsl::Future<>(absl::OkStatus())));\n \n   TF_ASSERT_OK_AND_ASSIGN(auto array_handle1,\n                           MakeTestArray(std::move(mock_array1)));\n@@ -1066,7 +1066,7 @@ TEST_P(IfrtBackendHandlerTest,\n   // Create one existing array.\n   auto mock_array1 = tsl::MakeRef<xla::ifrt::MockArray>();\n   EXPECT_CALL(*mock_array1, Delete())\n-      .WillOnce(Return(Future<>(absl::OkStatus())));\n+      .WillOnce(Return(tsl::Future<>(absl::OkStatus())));\n   TF_ASSERT_OK_AND_ASSIGN(auto real_handle,\n                           MakeTestArray(std::move(mock_array1)));\n \n@@ -1162,7 +1162,7 @@ TEST_P(IfrtBackendHandlerTest, CompileSuccess) {\n       .WillOnce(Return(absl::MakeSpan(addressable_devices)));\n   EXPECT_CALL(*executable, Fingerprint()).WillOnce(Return(\"fingerprint\"));\n   EXPECT_CALL(*executable, GetReadyFuture())\n-      .WillOnce(Return(Future<>(absl::OkStatus())));\n+      .WillOnce(Return(tsl::Future<>(absl::OkStatus())));\n \n   TF_ASSERT_OK_AND_ASSIGN(CompileResponse response,\n                           CompileTestLoadedExecutable(std::move(executable)));\n@@ -1331,7 +1331,7 @@ TEST_P(IfrtBackendHandlerTest, LoadedExecutableExecute) {\n                     std::optional<DeviceListRef> devices)\n                     -> absl::StatusOr<LoadedExecutable::ExecuteResult> {\n         return LoadedExecutable::ExecuteResult{\n-            .status = Future<>(absl::InternalError(\"injected error\")),\n+            .status = tsl::Future<>(absl::InternalError(\"injected error\")),\n             .outputs = outputs,\n         };\n       });"
        },
        {
            "sha": "cc9c84ec91d7bcffef9768d8b9d24c7a013f59a9",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/mock_ifrt_backend.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fmock_ifrt_backend.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/124996c7f5b8ff168cf634454d367bf80d4e1639/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fmock_ifrt_backend.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fmock_ifrt_backend.h?ref=124996c7f5b8ff168cf634454d367bf80d4e1639",
            "patch": "@@ -21,18 +21,18 @@\n \n #include <gmock/gmock.h>\n #include \"absl/status/status.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt_proxy/common/ifrt_service.pb.h\"\n #include \"xla/python/ifrt_proxy/server/ifrt_backend.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n \n namespace xla {\n namespace ifrt {\n namespace proxy {\n \n class MockIfrtBackend final : public BackendInterface {\n  public:\n-  MOCK_METHOD(Future<Response>, Process, (std::unique_ptr<IfrtRequest> request),\n-              (final));\n+  MOCK_METHOD(tsl::Future<Response>, Process,\n+              (std::unique_ptr<IfrtRequest> request), (final));\n };\n \n }  // namespace proxy"
        }
    ],
    "stats": {
        "total": 204,
        "additions": 108,
        "deletions": 96
    }
}