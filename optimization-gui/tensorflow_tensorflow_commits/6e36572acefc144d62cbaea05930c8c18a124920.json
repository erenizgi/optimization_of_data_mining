{
    "author": "tensorflower-gardener",
    "message": "[Autotuner] Remove unused `ProfileWithSharedBuffers` method from profiler.\n\n_ It was replaced by a combination of CreateBuffer and a Profile call which accept buffers.\n\nPiperOrigin-RevId: 803046168",
    "sha": "6e36572acefc144d62cbaea05930c8c18a124920",
    "files": [
        {
            "sha": "07b7bf37969f271b4366b9ead045699729597d9c",
            "filename": "third_party/xla/xla/backends/autotuner/autotuner_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e36572acefc144d62cbaea05930c8c18a124920/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e36572acefc144d62cbaea05930c8c18a124920/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc?ref=6e36572acefc144d62cbaea05930c8c18a124920",
            "patch": "@@ -97,10 +97,6 @@ class MockCodegenBackendWithWrongResults : public MockCodegenBackend {\n \n class MockProfiler : public Profiler {\n  public:\n-  MOCK_METHOD(absl::StatusOr<std::vector<absl::StatusOr<ProfileResult>>>,\n-              ProfileWithSharedBuffers,\n-              (std::vector<std::unique_ptr<Executable>> executables),\n-              (override));\n   MOCK_METHOD(absl::StatusOr<ProfileResult>, Profile,\n               (Executable * executable, const InputBuffers& buffers),\n               (override));\n@@ -404,7 +400,6 @@ TEST_F(AutotunerTest, CacheHit) {\n   EXPECT_CALL(*backend, name()).WillRepeatedly(Return(\"mock_backend\"));\n \n   auto profiler = std::make_unique<MockProfiler>();\n-  EXPECT_CALL(*profiler, ProfileWithSharedBuffers).Times(0);\n \n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));"
        },
        {
            "sha": "4944c296ac82e0f02e9266a8010c01c078ce110d",
            "filename": "third_party/xla/xla/backends/autotuner/profiler.h",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e36572acefc144d62cbaea05930c8c18a124920/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fprofiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e36572acefc144d62cbaea05930c8c18a124920/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fprofiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fprofiler.h?ref=6e36572acefc144d62cbaea05930c8c18a124920",
            "patch": "@@ -18,7 +18,6 @@ limitations under the License.\n \n #include <memory>\n #include <optional>\n-#include <vector>\n \n #include \"absl/log/check.h\"\n #include \"absl/status/statusor.h\"\n@@ -65,26 +64,6 @@ class Profiler {\n     return Profile(executable.get(), *buffers);\n   }\n \n-  // Profiles multiple executables with shared buffers. This guarantees that\n-  // the provided executables have same arguments. This is important for\n-  // autotuning as we run same instruction with different configs.\n-  // Note that an executable can still fail during runtime even if it compiled\n-  // successfully, which is why the return type is a vector of StatusOr.\n-  virtual absl::StatusOr<std::vector<absl::StatusOr<ProfileResult>>>\n-  ProfileWithSharedBuffers(\n-      std::vector<std::unique_ptr<Executable>> executables) {\n-    std::vector<absl::StatusOr<ProfileResult>> results;\n-    if (executables.empty()) {\n-      return results;\n-    }\n-    TF_ASSIGN_OR_RETURN(std::unique_ptr<InputBuffers> buffers,\n-                        CreateInputBuffers(executables[0].get()));\n-    for (auto& executable : executables) {\n-      results.push_back(Profile(executable.get(), *buffers));\n-    }\n-    return results;\n-  }\n-\n   // Creates Input buffers for a given executable on the device. The buffers\n   // are created with the same shape as the input parameters of the executable.\n   virtual absl::StatusOr<std::unique_ptr<InputBuffers>> CreateInputBuffers("
        },
        {
            "sha": "21b9158558a1ef470e4505d79783caf2d349310e",
            "filename": "third_party/xla/xla/backends/cpu/autotuner/cpu_profiler_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6e36572acefc144d62cbaea05930c8c18a124920/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fautotuner%2Fcpu_profiler_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6e36572acefc144d62cbaea05930c8c18a124920/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fautotuner%2Fcpu_profiler_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fautotuner%2Fcpu_profiler_test.cc?ref=6e36572acefc144d62cbaea05930c8c18a124920",
            "patch": "@@ -54,39 +54,6 @@ class CpuProfilerTest : public HloHardwareIndependentTestBase {\n   ProfileOptions profile_options_;\n };\n \n-TEST_F(CpuProfilerTest, ProfileWithSharedBuffers) {\n-  constexpr absl::string_view kHloModule = R\"(\n-        HloModule module\n-        ENTRY main {\n-          ROOT c = s32[] constant(1)\n-        }\n-      )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> hlo_module,\n-                          ParseAndReturnVerifiedModule(kHloModule));\n-\n-  std::vector<std::unique_ptr<Executable>> executables;\n-\n-  TF_ASSERT_OK_AND_ASSIGN(executables.emplace_back(),\n-                          CompileHloModule(std::move(hlo_module)));\n-\n-  auto profiler = CpuProfiler::Create(profile_options_);\n-  TF_ASSERT_OK_AND_ASSIGN(auto profiles, profiler->ProfileWithSharedBuffers(\n-                                             std::move(executables)));\n-\n-  // We expect only one profile because we only have one executable.\n-  EXPECT_EQ(profiles.size(), 1);\n-  TF_EXPECT_OK(profiles[0].status());\n-}\n-\n-TEST_F(CpuProfilerTest, ProfileWithSharedBuffersWithoutExecutable) {\n-  auto profiler = CpuProfiler::Create(profile_options_);\n-  TF_ASSERT_OK_AND_ASSIGN(auto profiles,\n-                          profiler->ProfileWithSharedBuffers({}));\n-\n-  // No executable means no profiles.\n-  EXPECT_EQ(profiles.size(), 0);\n-}\n-\n TEST_F(CpuProfilerTest, CreateInputBuffersAndProfile) {\n   constexpr absl::string_view kHloModule = R\"(\n         HloModule module"
        }
    ],
    "stats": {
        "total": 59,
        "additions": 0,
        "deletions": 59
    }
}