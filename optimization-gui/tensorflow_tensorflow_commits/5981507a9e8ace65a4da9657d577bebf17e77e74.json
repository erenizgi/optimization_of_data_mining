{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Validation] Add validation for `Mesh` and `AxisRef` constructors.\n\nPiperOrigin-RevId: 827808014",
    "sha": "5981507a9e8ace65a4da9657d577bebf17e77e74",
    "files": [
        {
            "sha": "b8a6aa762ea93f1843be07580ae6a3728b0a49d9",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=5981507a9e8ace65a4da9657d577bebf17e77e74",
            "patch": "@@ -189,7 +189,9 @@ cc_library(\n         \"//xla:array\",\n         \"//xla:xla_data_proto_cc\",\n         \"@com_google_absl//absl/algorithm:container\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n@@ -439,6 +441,8 @@ xla_cc_test(\n         \"//xla:array\",\n         \"//xla:array2d\",\n         \"//xla/tsl/util/proto:proto_matchers\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "a78b335e078d6b8ee8edfb4d5d7b289f8ccbb909",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.cc",
            "status": "modified",
            "additions": 96,
            "deletions": 4,
            "changes": 100,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc?ref=5981507a9e8ace65a4da9657d577bebf17e77e74",
            "patch": "@@ -18,12 +18,17 @@ limitations under the License.\n #include <algorithm>\n #include <cstdint>\n #include <memory>\n+#include <numeric>\n #include <optional>\n #include <string>\n #include <utility>\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/ADT/STLExtras.h\"\n #include \"xla/array.h\"\n@@ -32,6 +37,62 @@ limitations under the License.\n \n namespace xla {\n \n+absl::Status Mesh::ValidateMesh() {\n+  // TODO(varcho): An empty mesh is valid in Shardy. If support for such meshes\n+  // is required, update this validation.\n+  if (device_assignment_.dimensions().empty() || axes_names_.empty()) {\n+    return absl::InvalidArgumentError(\"Mesh must have at least one axis.\");\n+  }\n+\n+  if (device_assignment_.dimensions().size() != axes_names_.size()) {\n+    return absl::InvalidArgumentError(\n+        \"Number of axes names must match number of dimensions in the device \"\n+        \"assignment.\");\n+  }\n+\n+  absl::flat_hash_set<std::string> seen_axis_names;\n+  for (const std::string& axis_name : axes_names_) {\n+    if (!seen_axis_names.insert(axis_name).second) {\n+      return absl::InvalidArgumentError(\"Mesh has duplicate axis names.\");\n+    }\n+  }\n+\n+  // Validate device ids are permutation of iota in non-iota cases.\n+  if (device_assignment_.iota().has_value()) {\n+    return absl::OkStatus();\n+  }\n+  std::vector<int64_t> device_ids(device_assignment_.array().begin(),\n+                                  device_assignment_.array().end());\n+  for (int64_t device_id : device_ids) {\n+    if (device_id < 0) {\n+      return absl::InvalidArgumentError(\n+          \"Mesh device ids must be non-negative.\");\n+    }\n+  }\n+  std::vector<int64_t> iota(device_ids.size());\n+  std::iota(iota.begin(), iota.end(), 0);\n+\n+  // For non-iota cases the device ids should be a non-identity permutation\n+  // of iota.\n+  if (device_ids == iota) {\n+    return absl::InvalidArgumentError(\n+        \"Non-iota device assignment has iota device id list [0,1,2,3...].\");\n+  }\n+  absl::c_sort(device_ids);\n+  if (device_ids != iota) {\n+    return absl::InvalidArgumentError(\n+        \"Device ids must be a permutation of [0,1,2,3...].\");\n+  }\n+  return absl::OkStatus();\n+}\n+\n+Mesh::Mesh(TileAssignment device_assignment,\n+           absl::Span<const absl::string_view> axes_names)\n+    : device_assignment_(std::move(device_assignment)),\n+      axes_names_(axes_names.begin(), axes_names.end()) {\n+  CHECK_OK(ValidateMesh());\n+}\n+\n MeshProto Mesh::ToProto() const {\n   MeshProto proto;\n   std::vector<MeshProto::MeshAxis> axes;\n@@ -56,21 +117,22 @@ MeshProto Mesh::ToProto() const {\n }\n \n Mesh Mesh::FromProto(const MeshProto& proto) {\n-  // TODO(b/454008727): Add validators for Mesh and AxisRef FromProto methods.\n   std::vector<int64_t> mesh_axis_sizes;\n-  std::vector<std::string> mesh_axis_names;\n+  std::vector<absl::string_view> mesh_axis_names;\n   mesh_axis_sizes.reserve(proto.axes_size());\n   mesh_axis_names.reserve(proto.axes_size());\n   for (const auto& axis : proto.axes()) {\n     mesh_axis_sizes.push_back(axis.size());\n     mesh_axis_names.push_back(axis.name());\n   }\n+  absl::Span<const absl::string_view> mesh_axis_names_span =\n+      absl::MakeSpan(mesh_axis_names);\n \n   // If device ids are not specified, create a mesh with iota tiling.\n   if (proto.device_ids_size() == 0) {\n     TileAssignment device_assignment =\n         TileAssignment(IotaTileAssignment::Create(mesh_axis_sizes));\n-    return Mesh(device_assignment, mesh_axis_names);\n+    return Mesh(device_assignment, mesh_axis_names_span);\n   }\n   // Otherwise, create a mesh with the specific device id ordering.\n   std::vector<int64_t> device_ids(proto.device_ids().begin(),\n@@ -80,7 +142,29 @@ Mesh Mesh::FromProto(const MeshProto& proto) {\n \n   TileAssignment tile_assignment =\n       TileAssignment(std::make_shared<Array<int64_t>>(device_ids_array));\n-  return Mesh(tile_assignment, absl::MakeSpan(mesh_axis_names));\n+  return Mesh(tile_assignment, mesh_axis_names_span);\n+}\n+\n+absl::Status AxisRef::Validate(const Mesh& mesh) const {\n+  if (mesh_axis_index_ >= mesh.axis_names().size()) {\n+    return absl::InvalidArgumentError(\n+        \"Axis index must be less than number of axes.\");\n+  }\n+  if (!sub_axis_info_.has_value()) {\n+    return absl::OkStatus();\n+  }\n+\n+  int64_t axis_size = mesh.axis_size(mesh_axis_index_);\n+  if (axis_size % sub_axis_info_->pre_size != 0 ||\n+      axis_size % sub_axis_info_->size != 0) {\n+    return absl::InvalidArgumentError(\n+        \"Pre-size and size must divide the full axis size.\");\n+  }\n+  if (sub_axis_info_->size >= axis_size) {\n+    return absl::InvalidArgumentError(\n+        \"Sub-axis size must be strictly less than the full axis size.\");\n+  }\n+  return absl::OkStatus();\n }\n \n AxisRefProto AxisRef::ToProto() const {\n@@ -102,6 +186,14 @@ AxisRef AxisRef::FromProto(const AxisRefProto& proto) {\n   return axis_ref;\n }\n \n+AxisRef::AxisRef(int64_t mesh_axis_index) : mesh_axis_index_(mesh_axis_index) {}\n+\n+AxisRef::AxisRef(int64_t mesh_axis_index, SubAxis sub_axis_info)\n+    : mesh_axis_index_(mesh_axis_index), sub_axis_info_(sub_axis_info) {\n+  CHECK_GT(sub_axis_info_->pre_size, 0) << \"sub-axis pre-size must be >= 1\";\n+  CHECK_GT(sub_axis_info_->size, 1) << \"sub-axis size must be > 1\";\n+}\n+\n bool canSubAxesCoexist(int64_t minPreSize, int64_t maxPreSize,\n                        int64_t minNextPreSize, int64_t maxNextPreSize) {\n   if (minNextPreSize > maxPreSize) {"
        },
        {
            "sha": "36f2fc71a542b4a7d6c9ba958fdf401c31142bfb",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 14,
            "deletions": 18,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=5981507a9e8ace65a4da9657d577bebf17e77e74",
            "patch": "@@ -26,13 +26,16 @@ limitations under the License.\n #include \"absl/log/check.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla {\n \n+class AxisRef;\n+\n // C++ representation for corresponding `OpSharding::Mesh` proto so same\n // documentation applies, except device assignment is represented in the array\n // format instead of list of device ids to align with various array specific\n@@ -50,25 +53,19 @@ class Mesh {\n   // mesh [\"data\"=2, \"model\"=3] with iota device list. We use `TileAssignment`\n   // optimized for iota based cases which will not store the entire array.\n   explicit Mesh(absl::Span<const int64_t> axes_sizes,\n-                absl::Span<const std::string> axes_names)\n+                absl::Span<const absl::string_view> axes_names)\n       : Mesh(TileAssignment(axes_sizes), axes_names) {}\n \n   // Constructs a mesh with given device assignment and axes names. This ctor\n   // should **ONLY** be used for non-iota based device assignments.\n   explicit Mesh(Array<int64_t> device_assignment,\n-                absl::Span<const std::string> axes_names)\n+                absl::Span<const absl::string_view> axes_names)\n       : Mesh(TileAssignment(std::make_shared<Array<int64_t>>(\n                  std::move(device_assignment))),\n              axes_names) {}\n \n   explicit Mesh(TileAssignment device_assignment,\n-                absl::Span<const std::string> axes_names)\n-      : device_assignment_(std::move(device_assignment)),\n-        axes_names_(axes_names.begin(), axes_names.end()) {\n-    CHECK_EQ(device_assignment_.dimensions().size(), axes_names_.size())\n-        << \"Number of axes names must match number of dimensions in the \"\n-           \"device assignment.\";\n-  }\n+                absl::Span<const absl::string_view> axes_names);\n \n   bool operator==(const Mesh& other) const {\n     return device_assignment_ == other.device_assignment_ &&\n@@ -117,6 +114,7 @@ class Mesh {\n   }\n \n  private:\n+  absl::Status ValidateMesh();\n   // Dimensions of the `device_assignment_` array correspond to the axes of the\n   // mesh.\n   TileAssignment device_assignment_;\n@@ -142,16 +140,9 @@ class AxisRef {\n   std::optional<SubAxis> sub_axis_info_;\n \n  public:\n-  explicit AxisRef(int64_t mesh_axis_index)\n-      : mesh_axis_index_(mesh_axis_index) {}\n-\n-  explicit AxisRef(int64_t mesh_axis_index, SubAxis sub_axis_info)\n-      : mesh_axis_index_(mesh_axis_index), sub_axis_info_(sub_axis_info) {}\n+  explicit AxisRef(int64_t mesh_axis_index);\n \n-  explicit AxisRef(int64_t mesh_axis_index, int64_t sub_axis_pre_size,\n-                   int64_t sub_axis_size)\n-      : mesh_axis_index_(mesh_axis_index),\n-        sub_axis_info_({sub_axis_pre_size, sub_axis_size}) {}\n+  explicit AxisRef(int64_t mesh_axis_index, SubAxis sub_axis_info);\n \n   bool operator==(const xla::AxisRef& other) const {\n     if (mesh_axis_index_ != other.mesh_axis_index_) {\n@@ -186,8 +177,13 @@ class AxisRef {\n \n   bool CanCoexist(const AxisRef& other) const;\n \n+  // Validates that the given mesh is compatible for this axis ref.\n+  absl::Status Validate(const Mesh& mesh) const;\n   int64_t mesh_axis_index() const { return mesh_axis_index_; }\n   std::optional<SubAxis> sub_axis_info() const { return sub_axis_info_; }\n+\n+ private:\n+  absl::Status ValidateAxisRef();\n };\n \n }  // namespace xla"
        },
        {
            "sha": "f522c32ad7bb4e319572b560dcd089a4a69740aa",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis_test.cc",
            "status": "modified",
            "additions": 67,
            "deletions": 11,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc?ref=5981507a9e8ace65a4da9657d577bebf17e77e74",
            "patch": "@@ -21,6 +21,8 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/log/check.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n #include \"xla/array2d.h\"\n@@ -42,17 +44,17 @@ TEST(MeshAndAxisTest, AxisRefEquality) {\n }\n \n TEST(MeshAndAxisTest, MeshEquality) {\n-  std::vector<std::string> axes_abc = {\"a\", \"b\", \"c\"};\n-  std::vector<std::string> axes_abcd = {\"a\", \"b\", \"c\", \"d\"};\n-  std::vector<std::string> axes_efgh = {\"e\", \"f\", \"g\", \"h\"};\n+  std::vector<absl::string_view> axes_abc = {\"a\", \"b\", \"c\"};\n+  std::vector<absl::string_view> axes_abcd = {\"a\", \"b\", \"c\", \"d\"};\n+  std::vector<absl::string_view> axes_efgh = {\"e\", \"f\", \"g\", \"h\"};\n   EXPECT_EQ(Mesh({1, 2, 3}, axes_abc), Mesh({1, 2, 3}, axes_abc));\n   EXPECT_NE(Mesh({1, 2, 3, 4}, axes_abcd), Mesh({1, 2, 3, 4}, axes_efgh));\n   EXPECT_NE(Mesh({1, 2, 3}, axes_abc), Mesh({1, 2, 3, 4}, axes_abcd));\n }\n \n TEST(MeshAndAxisTest, DeviceAssignmentEquality) {\n-  std::vector<std::string> axes_abcd = {\"a\", \"b\", \"c\", \"d\"};\n-  std::vector<std::string> axes_efgh = {\"e\", \"f\", \"g\", \"h\"};\n+  std::vector<absl::string_view> axes_abcd = {\"a\", \"b\", \"c\", \"d\"};\n+  std::vector<absl::string_view> axes_efgh = {\"e\", \"f\", \"g\", \"h\"};\n   Mesh mesh({1, 2, 3, 4}, axes_abcd);\n   Mesh mesh_diff_axis_names({1, 2, 3, 4}, axes_efgh);\n   EXPECT_TRUE(mesh.DeviceAssignmentEquals(mesh_diff_axis_names));\n@@ -120,7 +122,7 @@ TEST(MeshAndAxisTest, MeshToProtoIotaTilingWithReshapeDims) {\n     expected.add_device_ids(expected_device_ids[i]);\n   }\n \n-  std::vector<std::string> axes_names = {\"axis1\", \"axis2\", \"axis3\"};\n+  std::vector<absl::string_view> axes_names = {\"axis1\", \"axis2\", \"axis3\"};\n   EXPECT_THAT(\n       Mesh(TileAssignment(/*dims=*/{4, 4, 1}, /*reshape_dims=*/{4, 2, 2},\n                           /*transpose_perm=*/{1, 0, 2}),\n@@ -141,7 +143,7 @@ TEST(MeshAndAxisTest, MeshToProtoNonIotaTiling) {\n   }\n \n   Array2D<int64_t> array({{6, 3}, {0, 1}, {5, 2}, {7, 4}});\n-  std::vector<std::string> axes_xy = {\"x\", \"y\"};\n+  std::vector<absl::string_view> axes_xy = {\"x\", \"y\"};\n   EXPECT_THAT(Mesh(array, axes_xy).ToProto(), EqualsProto(expected));\n }\n \n@@ -157,24 +159,59 @@ TEST(MeshAndAxisTest, MeshFromProtoNonIotaTiling) {\n   }\n \n   Array2D<int64_t> array({{0, 1}, {6, 3}, {7, 4}, {5, 2}});\n-  std::vector<std::string> axes_xy = {\"x\", \"y\"};\n+  std::vector<absl::string_view> axes_xy = {\"x\", \"y\"};\n   EXPECT_EQ(Mesh(array, axes_xy), Mesh::FromProto(expected));\n }\n \n TEST(MeshAndAxisTest, MeshRoundtripProto) {\n   // Iota tiling.\n-  std::vector<std::string> axes_xy = {\"data\", \"model\"};\n+  std::vector<absl::string_view> axes_xy = {\"data\", \"model\"};\n   Mesh mesh_iota({5, 3}, axes_xy);\n   EXPECT_THAT(mesh_iota, Mesh::FromProto(mesh_iota.ToProto()));\n \n   // Non-iota tiling.\n   Array2D<int64_t> array(\n-      {{14, 7, 6}, {12, 0, 8}, {11, 10, 5}, {11, 9, 3}, {2, 13, 4}});\n+      {{14, 7, 6}, {12, 0, 8}, {11, 10, 5}, {1, 9, 3}, {2, 13, 4}});\n   Mesh mesh_non_iota(array, axes_xy);\n   EXPECT_THAT(mesh_non_iota, Mesh::FromProto(mesh_non_iota.ToProto()));\n }\n \n-TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n+TEST(MeshAndAxisTest, ValidatesAxisRef) {\n+  EXPECT_DEATH(\n+      { AxisRef axis_ref_invalid_pre_size(3, {0, 2}); },\n+      \"sub-axis pre-size must be \");\n+  EXPECT_DEATH(\n+      { AxisRef axis_ref_invalid_subaxis_size(0, {1, 1}); },\n+      \"sub-axis size must be\");\n+}\n+\n+TEST(MeshAndAxisTest, ValidatesMesh) {\n+  EXPECT_DEATH(\n+      { Mesh mesh_dims_axes_mismatch({2, 3, 4}, {\"x\", \"y\"}); },\n+      \"Number of axes names must match number of dimensions\");\n+\n+  Array2D<int64_t> negative_device_ids({{0, 1, 2}, {3, -4, 5}});\n+  EXPECT_DEATH(\n+      { Mesh mesh_invalid_non_iota(negative_device_ids, {\"x\", \"y\"}); },\n+      \"Mesh device ids must be non-negative\");\n+\n+  Array2D<int64_t> invalid_non_iota_device_ids({{10, 11, 12}, {13, 14, 15}});\n+  EXPECT_DEATH(\n+      { Mesh mesh_invalid_non_iota(invalid_non_iota_device_ids, {\"x\", \"y\"}); },\n+      \"Device ids must be a permutation of\");\n+\n+  EXPECT_DEATH(\n+      {\n+        Mesh mesh_with_duplicate_axis_names({1, 2, 3, 4}, {\"x\", \"y\", \"z\", \"x\"});\n+      },\n+      \"Mesh has duplicate axis names\");\n+\n+  EXPECT_DEATH(\n+      { Mesh mesh_with_empty_dims(TileAssignment({}), {}); },\n+      \"Mesh must have at least one axis\");\n+}\n+\n+TEST(MeshAndAxisTest, MeshAxesToString) {\n   Mesh mesh_uvw({10, 12, 15}, {\"u\", \"v\", \"w\"});\n   EXPECT_EQ(mesh_uvw.ToString(), \"@mesh<u=10,v=12,w=15>\");\n \n@@ -190,4 +227,23 @@ TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n   EXPECT_EQ(mesh_ooo.ToString(), \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9)\");\n }\n \n+TEST(MeshAndAxisTest, ValidateAxisForMesh) {\n+  Mesh mesh({2 * 7, 3 * 11, 5 * 13}, {\"fdr\", \"jfk\", \"lbj\"});\n+\n+  EXPECT_DEATH(\n+      { CHECK_OK(AxisRef(3, {1, 2}).Validate(mesh)); },\n+      \"Axis index must be less than number of axes\");\n+\n+  EXPECT_DEATH(\n+      { CHECK_OK(AxisRef(0, {5, 19}).Validate(mesh)); },\n+      \"Pre-size and size must divide the full axis size\");\n+  EXPECT_DEATH(\n+      { CHECK_OK(AxisRef(0, {2, 5}).Validate(mesh)); },\n+      \"Pre-size and size must divide the full axis size\");\n+\n+  EXPECT_DEATH(\n+      { CHECK_OK(AxisRef(1, {1, 3 * 11}).Validate(mesh)); },\n+      \"Sub-axis size must be strictly less than the full axis size\");\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "067aea60c221a8faf9fb92d7e73ba0dd15336898",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=5981507a9e8ace65a4da9657d577bebf17e77e74",
            "patch": "@@ -176,14 +176,9 @@ MeshAxesReplicaGroupList::MeshAxesReplicaGroupList(Mesh mesh,\n   absl::flat_hash_set<int64_t> dimensions;\n   absl::flat_hash_map<int64_t, std::vector<AxisRef>> dim_to_axes;\n   for (const AxisRef& axis : axes_) {\n+    CHECK_OK(axis.Validate(mesh_));\n     dim_to_axes[axis.mesh_axis_index()].push_back(axis);\n     dimensions.insert(axis.mesh_axis_index());\n-    if (axis.sub_axis_info().has_value()) {\n-      CHECK(mesh_.axis_size(axis.mesh_axis_index()) %\n-                axis.sub_axis_info()->next_pre_size() ==\n-            0)\n-          << \"Next pre-size must divide the full axis size.\";\n-    }\n   }\n \n   // Validate input AxisRefs."
        },
        {
            "sha": "f851cffd92bc30f6d833da0d908a9695106deeab",
            "filename": "third_party/xla/xla/hlo/ir/replica_group_test.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 4,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5981507a9e8ace65a4da9657d577bebf17e77e74/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc?ref=5981507a9e8ace65a4da9657d577bebf17e77e74",
            "patch": "@@ -289,14 +289,14 @@ TEST(MeshAxesReplicaGroupListTest, ValidateSubAxesCoexistenceCheck) {\n \n TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n   Mesh mesh_one_subaxis({2, 6, 10}, {\"axis1\", \"axis2\", \"axis3\"});\n-  MeshAxesReplicaGroupList replica_group_across_axis1_subaxis(\n-      mesh_one_subaxis, {AxisRef(0, {1, 2})});\n   MeshAxesReplicaGroupList replica_group_across_axis2_subaxis(\n       mesh_one_subaxis, {AxisRef(1, {2, 3})});\n-  EXPECT_EQ(replica_group_across_axis1_subaxis.num_replica_groups(), 60);\n-  EXPECT_EQ(replica_group_across_axis1_subaxis.num_devices_per_group(), 2);\n+  MeshAxesReplicaGroupList replica_group_across_axis3_subaxis(\n+      mesh_one_subaxis, {AxisRef(2, {1, 2})});\n   EXPECT_EQ(replica_group_across_axis2_subaxis.num_replica_groups(), 40);\n   EXPECT_EQ(replica_group_across_axis2_subaxis.num_devices_per_group(), 3);\n+  EXPECT_EQ(replica_group_across_axis3_subaxis.num_replica_groups(), 60);\n+  EXPECT_EQ(replica_group_across_axis3_subaxis.num_devices_per_group(), 2);\n \n   Mesh mesh_multiple_subaxis({2 * 3, 5 * 7, 11 * 13},\n                              {\"alpha\", \"beta\", \"gamma\"});\n@@ -352,6 +352,34 @@ TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n             \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {ooo:(5)2}\");\n }\n \n+TEST(MeshAxesReplicaGroupListTest, ValidatesIncompatibleAxes) {\n+  Mesh mesh({10}, {\"u\"});\n+  EXPECT_DEATH(\n+      {\n+        MeshAxesReplicaGroupList index_out_of_bounds(\n+            mesh, /*axes=*/{AxisRef(1, {1, 2})});\n+      },\n+      \"Axis index must be less than number of axes\");\n+  EXPECT_DEATH(\n+      {\n+        MeshAxesReplicaGroupList index_out_of_bounds(\n+            mesh, /*axes=*/{AxisRef(0, {8, 2})});\n+      },\n+      \"Pre-size and size must divide the full axis size\");\n+  EXPECT_DEATH(\n+      {\n+        MeshAxesReplicaGroupList index_out_of_bounds(\n+            mesh, /*axes=*/{AxisRef(0, {2, 8})});\n+      },\n+      \"Pre-size and size must divide the full axis size\");\n+  EXPECT_DEATH(\n+      {\n+        MeshAxesReplicaGroupList index_out_of_bounds(\n+            mesh, /*axes=*/{AxisRef(0, {1, 10})});\n+      },\n+      \"Sub-axis size must be strictly less than the full axis size\");\n+}\n+\n TEST(CollectiveDeviceListTest, DefaultListToString) {\n   EXPECT_EQ(CollectiveDeviceList().ToString(true), \"{}\");\n   EXPECT_EQ(CollectiveDeviceList().ToString(false), \"{}\");"
        }
    ],
    "stats": {
        "total": 257,
        "additions": 214,
        "deletions": 43
    }
}