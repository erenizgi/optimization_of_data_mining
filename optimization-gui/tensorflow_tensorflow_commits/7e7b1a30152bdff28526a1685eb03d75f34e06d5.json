{
    "author": "tensorflower-gardener",
    "message": "Allow empty dimension list in SymbolicMap::ReplaceDimsAndSymbols\n\nI originally assumed the caller was always providing a full list of replacements but IndexingMap have some uses where the dim_replacement list is empty, resulting in a CHECK-fail.\n\nSo, I'm allowing the user to provide either dim or symbol empty lists to ReplaceDimsAndSymbols. In that case, the dims/symbols won't be replaced.\n\nPiperOrigin-RevId: 826138814",
    "sha": "7e7b1a30152bdff28526a1685eb03d75f34e06d5",
    "files": [
        {
            "sha": "d62b4301a34ae291763cce0659d00fad8b4b3244",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 4,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7e7b1a30152bdff28526a1685eb03d75f34e06d5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7e7b1a30152bdff28526a1685eb03d75f34e06d5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc?ref=7e7b1a30152bdff28526a1685eb03d75f34e06d5",
            "patch": "@@ -127,13 +127,27 @@ SymbolicMap SymbolicMap::ReplaceDimsAndSymbols(\n     absl::Span<const SymbolicExpr> dim_replacements,\n     absl::Span<const SymbolicExpr> sym_replacements, int64_t num_result_dims,\n     int64_t num_result_symbols) const {\n-  CHECK_EQ(dim_replacements.size(), num_dimensions_);\n-  CHECK_EQ(sym_replacements.size(), num_symbols_);\n+  CHECK(dim_replacements.empty() || dim_replacements.size() == num_dimensions_);\n+  CHECK(sym_replacements.empty() || sym_replacements.size() == num_symbols_);\n \n   llvm::SmallVector<SymbolicExpr> all_replacements;\n   all_replacements.reserve(num_dimensions_ + num_symbols_);\n-  absl::c_copy(dim_replacements, std::back_inserter(all_replacements));\n-  absl::c_copy(sym_replacements, std::back_inserter(all_replacements));\n+\n+  if (!dim_replacements.empty()) {\n+    absl::c_copy(dim_replacements, std::back_inserter(all_replacements));\n+  } else {\n+    for (int i = 0; i < num_dimensions_; ++i) {\n+      all_replacements.push_back(ctx_->CreateVariable(i));\n+    }\n+  }\n+\n+  if (!sym_replacements.empty()) {\n+    absl::c_copy(sym_replacements, std::back_inserter(all_replacements));\n+  } else {\n+    for (int i = 0; i < num_symbols_; ++i) {\n+      all_replacements.push_back(ctx_->CreateVariable(num_dimensions_ + i));\n+    }\n+  }\n \n   llvm::SmallVector<SymbolicExpr> new_exprs;\n   new_exprs.reserve(exprs_.size());"
        },
        {
            "sha": "a231a53954a69c7055bc9eabd3269f9468554fa4",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_test.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 2,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7e7b1a30152bdff28526a1685eb03d75f34e06d5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7e7b1a30152bdff28526a1685eb03d75f34e06d5/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc?ref=7e7b1a30152bdff28526a1685eb03d75f34e06d5",
            "patch": "@@ -150,6 +150,42 @@ TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n               ElementsAre((new_d0 * c1 + new_d1) + new_s0 * c2));\n }\n \n+TEST_F(SymbolicMapTest, ReplaceDimsAndSymbolsOnlyDims) {\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  int num_dims = 2;\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, 0, num_dims);\n+  SymbolicExpr s1 = CreateSymbolExpr(&ctx, 1, num_dims);\n+  int num_symbols = 2;\n+  SymbolicExpr c1 = ctx.CreateConstant(10);\n+  SymbolicExpr c2 = ctx.CreateConstant(20);\n+\n+  SymbolicMap map =\n+      SymbolicMap::Get(&ctx, num_dims, num_symbols, {d0 + s0, d1 * s1});\n+  SymbolicMap replaced = map.ReplaceDimsAndSymbols(\n+      /*dim_replacements=*/{c1, c2}, /*sym_replacements=*/{}, num_dims,\n+      num_symbols);\n+  EXPECT_THAT(replaced.GetResults(), ElementsAre(c1 + s0, c2 * s1));\n+}\n+\n+TEST_F(SymbolicMapTest, ReplaceDimsAndSymbolsOnlySymbols) {\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  int num_dims = 2;\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, 0, num_dims);\n+  SymbolicExpr s1 = CreateSymbolExpr(&ctx, 1, num_dims);\n+  int num_symbols = 2;\n+  SymbolicExpr c1 = ctx.CreateConstant(10);\n+  SymbolicExpr c2 = ctx.CreateConstant(20);\n+\n+  SymbolicMap map =\n+      SymbolicMap::Get(&ctx, num_dims, num_symbols, {d0 + s0, d1 * s1});\n+  SymbolicMap replaced = map.ReplaceDimsAndSymbols(\n+      /*dim_replacements=*/{}, /*sym_replacements=*/{c1, c2}, num_dims,\n+      num_symbols);\n+  EXPECT_THAT(replaced.GetResults(), ElementsAre(d0 + c1, d1 * c2));\n+}\n+\n TEST_F(SymbolicMapTest, Compose) {\n   SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n   SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n@@ -207,8 +243,8 @@ TEST_F(SymbolicMapTest, Compose) {\n }\n \n TEST_F(SymbolicMapTest, Replace) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n   SymbolicExpr c2 = ctx.CreateConstant(2);\n   SymbolicExpr c5 = ctx.CreateConstant(5);\n "
        }
    ],
    "stats": {
        "total": 62,
        "additions": 56,
        "deletions": 6
    }
}