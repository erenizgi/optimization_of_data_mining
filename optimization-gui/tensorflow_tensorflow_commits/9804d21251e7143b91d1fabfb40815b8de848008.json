{
    "author": "cota",
    "message": "[xla:cpu] hlo_benchmark_runner: NFC: drop TF_ prefix from RETURN_IF_ERROR/ASSIGN_OR_RETURN\n\nPiperOrigin-RevId: 845604102",
    "sha": "9804d21251e7143b91d1fabfb40815b8de848008",
    "files": [
        {
            "sha": "8ad37162b2c78f570c0e7a6f450900b63899a4cb",
            "filename": "third_party/xla/xla/backends/cpu/benchmarks/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9804d21251e7143b91d1fabfb40815b8de848008/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbenchmarks%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9804d21251e7143b91d1fabfb40815b8de848008/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbenchmarks%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbenchmarks%2FBUILD?ref=9804d21251e7143b91d1fabfb40815b8de848008",
            "patch": "@@ -68,6 +68,7 @@ cc_library(\n         \"//xla/tools:run_hlo_module_proto_cc\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:status_macros\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test_benchmark\",\n         \"@com_google_absl//absl/base:nullability\","
        },
        {
            "sha": "4d5d25d78d5fdcf51bcd52064267e6cdd5676a42",
            "filename": "third_party/xla/xla/backends/cpu/benchmarks/hlo_benchmark_runner.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 39,
            "changes": 79,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9804d21251e7143b91d1fabfb40815b8de848008/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbenchmarks%2Fhlo_benchmark_runner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9804d21251e7143b91d1fabfb40815b8de848008/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbenchmarks%2Fhlo_benchmark_runner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbenchmarks%2Fhlo_benchmark_runner.cc?ref=9804d21251e7143b91d1fabfb40815b8de848008",
            "patch": "@@ -57,6 +57,7 @@ limitations under the License.\n #include \"xla/util.h\"\n #include \"tsl/platform/casts.h\"\n #include \"tsl/platform/path.h\"\n+#include \"xla/tsl/platform/status_macros.h\"\n \n namespace xla::cpu {\n \n@@ -131,10 +132,10 @@ absl::Status RunHloBenchmark(benchmark::State& state,\n                              absl::Span<const Literal* const> args,\n                              StrToStrMapping replacements,\n                              const HloBenchmarkOptions& benchmark_options) {\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloModule> module,\n-                      ParseAndReturnUnverifiedModule(\n-                          absl::StrReplaceAll(hlo_module, replacements),\n-                          HloModuleConfig() /* unused */));\n+  ASSIGN_OR_RETURN(std::unique_ptr<HloModule> module,\n+                   ParseAndReturnUnverifiedModule(\n+                       absl::StrReplaceAll(hlo_module, replacements),\n+                       HloModuleConfig() /* unused */));\n   return RunHloBenchmark(state, std::move(module), args, benchmark_options);\n }\n \n@@ -158,11 +159,11 @@ absl::Status RunHloBenchmarkImpl(benchmark::State* absl_nullable state,\n                                  absl::Span<const Literal* const> args,\n                                  const HloBenchmarkOptions& benchmark_options) {\n   xla::CpuClientOptions client_options;\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<PjRtClient> client,\n-                      xla::GetXlaPjrtCpuClient(client_options));\n+  ASSIGN_OR_RETURN(std::unique_ptr<PjRtClient> client,\n+                   xla::GetXlaPjrtCpuClient(client_options));\n   PjRtDevice* device = client->devices().front();\n-  TF_ASSIGN_OR_RETURN(PjRtMemorySpace * memory_space,\n-                      device->default_memory_space());\n+  ASSIGN_OR_RETURN(PjRtMemorySpace * memory_space,\n+                   device->default_memory_space());\n \n   XlaComputation computation(module->ToProto());\n \n@@ -176,12 +177,12 @@ absl::Status RunHloBenchmarkImpl(benchmark::State* absl_nullable state,\n   std::unique_ptr<PjRtLoadedExecutable> executable;\n   if (benchmark_options.aot_options) {\n     auto* cpu_client = tsl::down_cast<PjRtCpuClient*>(client.get());\n-    TF_ASSIGN_OR_RETURN(executable, cpu_client->CompileAheadOfTimeAndLoad(\n-                                        computation, compile_options,\n-                                        *benchmark_options.aot_options));\n+    ASSIGN_OR_RETURN(executable, cpu_client->CompileAheadOfTimeAndLoad(\n+                                     computation, compile_options,\n+                                     *benchmark_options.aot_options));\n   } else {\n-    TF_ASSIGN_OR_RETURN(executable,\n-                        client->CompileAndLoad(computation, compile_options));\n+    ASSIGN_OR_RETURN(executable,\n+                     client->CompileAndLoad(computation, compile_options));\n   }\n \n   CHECK_GE(benchmark_options.num_executions, 1);\n@@ -198,14 +199,14 @@ absl::Status RunHloBenchmarkImpl(benchmark::State* absl_nullable state,\n   // If the user has not passed any arguments we need to generate\n   // fake arguments based on the number of inputs to the hlo module.\n   if (args.empty()) {\n-    TF_ASSIGN_OR_RETURN(std::vector<Literal> fake_args,\n-                        MakeFakeArguments(module.get()));\n+    ASSIGN_OR_RETURN(std::vector<Literal> fake_args,\n+                     MakeFakeArguments(module.get()));\n     for (auto& args_buffers : execution_args_buffers) {\n       args_buffers.reserve(fake_args.size());\n       for (const Literal& arg : fake_args) {\n-        TF_ASSIGN_OR_RETURN(args_buffers.emplace_back(),\n-                            client->BufferFromHostLiteral(arg, memory_space));\n-        TF_RETURN_IF_ERROR(args_buffers.back()->GetReadyFuture().Await());\n+        ASSIGN_OR_RETURN(args_buffers.emplace_back(),\n+                         client->BufferFromHostLiteral(arg, memory_space));\n+        RETURN_IF_ERROR(args_buffers.back()->GetReadyFuture().Await());\n       }\n     }\n   } else {\n@@ -218,9 +219,9 @@ absl::Status RunHloBenchmarkImpl(benchmark::State* absl_nullable state,\n     for (auto& args_buffers : execution_args_buffers) {\n       args_buffers.reserve(args.size());\n       for (const Literal* arg : args) {\n-        TF_ASSIGN_OR_RETURN(args_buffers.emplace_back(),\n-                            client->BufferFromHostLiteral(*arg, memory_space));\n-        TF_RETURN_IF_ERROR(args_buffers.back()->GetReadyFuture().Await());\n+        ASSIGN_OR_RETURN(args_buffers.emplace_back(),\n+                         client->BufferFromHostLiteral(*arg, memory_space));\n+        RETURN_IF_ERROR(args_buffers.back()->GetReadyFuture().Await());\n       }\n     }\n   }\n@@ -284,7 +285,7 @@ absl::Status RunHloBenchmarkImpl(benchmark::State* absl_nullable state,\n       std::vector<std::unique_ptr<PjRtBuffer>>& args_buffers =\n           execution_args_buffers[i];\n       std::vector<PjRtBuffer*>& args_ptrs = execution_args_ptrs[i];\n-      TF_RETURN_IF_ERROR(alias_helper.SwapOutputAliasedBuffersToArgumentBuffers(\n+      RETURN_IF_ERROR(alias_helper.SwapOutputAliasedBuffersToArgumentBuffers(\n           execution_results[i], args_buffers, args_ptrs));\n     }\n \n@@ -293,12 +294,12 @@ absl::Status RunHloBenchmarkImpl(benchmark::State* absl_nullable state,\n \n   // Run once. For a regular benchmark this will serve as a warm-up;\n   // for RunHloBenchmarkOnce this will be the only run.\n-  TF_RETURN_IF_ERROR(run_benchmark_once());\n+  RETURN_IF_ERROR(run_benchmark_once());\n \n   // Benchmark executable.\n   if (state) {\n     for (auto _ : *state) {\n-      TF_RETURN_IF_ERROR(run_benchmark_once());\n+      RETURN_IF_ERROR(run_benchmark_once());\n     }\n   }\n \n@@ -324,10 +325,10 @@ absl::Status CompileHloBenchmark(benchmark::State& state,\n                                  absl::string_view hlo_module,\n                                  StrToStrMapping replacements,\n                                  const HloBenchmarkOptions& benchmark_options) {\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloModule> module,\n-                      ParseAndReturnUnverifiedModule(\n-                          absl::StrReplaceAll(hlo_module, replacements),\n-                          HloModuleConfig() /* unused */));\n+  ASSIGN_OR_RETURN(std::unique_ptr<HloModule> module,\n+                   ParseAndReturnUnverifiedModule(\n+                       absl::StrReplaceAll(hlo_module, replacements),\n+                       HloModuleConfig() /* unused */));\n \n   return CompileHloBenchmark(state, std::move(module), benchmark_options);\n }\n@@ -336,8 +337,8 @@ absl::Status CompileHloBenchmark(benchmark::State& state,\n                                  std::unique_ptr<HloModule> module,\n                                  const HloBenchmarkOptions& benchmark_options) {\n   xla::CpuClientOptions client_options;\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<PjRtClient> client,\n-                      xla::GetXlaPjrtCpuClient(client_options));\n+  ASSIGN_OR_RETURN(std::unique_ptr<PjRtClient> client,\n+                   xla::GetXlaPjrtCpuClient(client_options));\n \n   XlaComputation computation(module->ToProto());\n \n@@ -348,8 +349,8 @@ absl::Status CompileHloBenchmark(benchmark::State& state,\n   }\n \n   for (auto _ : state) {\n-    TF_ASSIGN_OR_RETURN(std::unique_ptr<PjRtLoadedExecutable> executable,\n-                        client->CompileAndLoad(computation, compile_options));\n+    ASSIGN_OR_RETURN(std::unique_ptr<PjRtLoadedExecutable> executable,\n+                     client->CompileAndLoad(computation, compile_options));\n     tsl::testing::DoNotOptimize(executable);\n   }\n \n@@ -365,11 +366,11 @@ LoadFromHloSnapshotOrHloModuleProto(absl::string_view hlo_data,\n   auto iteration_literals_proto =\n       std::make_unique<RunHloModuleIterationLiterals>();\n   if (extension == \"pb\" || extension == \"pbtxt\") {\n-    TF_ASSIGN_OR_RETURN(iteration_literals_proto,\n-                        LoadInputFromData(hlo_data, extension));\n+    ASSIGN_OR_RETURN(iteration_literals_proto,\n+                     LoadInputFromData(hlo_data, extension));\n   }\n \n-  TF_ASSIGN_OR_RETURN(auto hlo_module, LoadModuleFromData(hlo_data, extension));\n+  ASSIGN_OR_RETURN(auto hlo_module, LoadModuleFromData(hlo_data, extension));\n \n   return std::make_pair(std::move(hlo_module),\n                         std::move(iteration_literals_proto));\n@@ -379,12 +380,12 @@ absl::StatusOr<std::pair<std::unique_ptr<HloModule>,\n                          std::unique_ptr<RunHloModuleIterationLiterals>>>\n LoadFromHloUnoptimizedSnapshot(\n     const HloUnoptimizedSnapshot& unoptimized_snapshot) {\n-  TF_ASSIGN_OR_RETURN(\n+  ASSIGN_OR_RETURN(\n       HloModuleConfig config,\n       HloModule::CreateModuleConfigFromProto(unoptimized_snapshot.hlo_module(),\n                                              xla::GetDebugOptionsFromFlags()));\n \n-  TF_ASSIGN_OR_RETURN(\n+  ASSIGN_OR_RETURN(\n       std::unique_ptr<HloModule> hlo_module,\n       HloModule::CreateFromProto(unoptimized_snapshot.hlo_module(), config));\n \n@@ -410,8 +411,8 @@ absl::StatusOr<std::pair<std::unique_ptr<HloModule>,\n                          std::unique_ptr<RunHloModuleIterationLiterals>>>\n LoadHloModuleAndMaybeIterationLiterals(absl::string_view hlo_path) {\n   std::string hlo_data;\n-  TF_RETURN_IF_ERROR(tsl::ReadFileToString(tsl::Env::Default(),\n-                                           std::string(hlo_path), &hlo_data));\n+  RETURN_IF_ERROR(tsl::ReadFileToString(tsl::Env::Default(),\n+                                        std::string(hlo_path), &hlo_data));\n \n   HloUnoptimizedSnapshot unoptimized_snapshot;\n   if (unoptimized_snapshot.ParseFromString(hlo_data)) {"
        }
    ],
    "stats": {
        "total": 80,
        "additions": 41,
        "deletions": 39
    }
}