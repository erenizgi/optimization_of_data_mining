{
    "author": "junwhanahn",
    "message": "Add an API for promise owners to tell if there are any other references to the underlying value\n\n`Promise::IsUniqueReference()` returns true if and only if there are no other promises/futures sharing the same AVR and no OnReady callbacks registered. This may be used by promise owners to tell if they can short-circuit expensive work needed to fulfill the future when they know there's no one interested in the value.\n\nPiperOrigin-RevId: 802826698",
    "sha": "7dc449107fbd9f7e17a9c58bf5170a97ec72131b",
    "files": [
        {
            "sha": "ac12d2993e9a221aa806c4da56184e57cd9f397b",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=7dc449107fbd9f7e17a9c58bf5170a97ec72131b",
            "patch": "@@ -223,6 +223,24 @@ class PjRtFutureBase : public PjRtFutureMoveControl<is_move_only> {\n \n     explicit operator bool() const { return static_cast<bool>(promise_); }\n \n+    // Returns if this promise is the unique reference to the underlying value.\n+    // That is, this method returns true only if all of the following conditions\n+    // are satisfied:\n+    //\n+    // - The promise is the only reference to the underlying value, i.e., there\n+    //   are no other promises or futures associated with this value.\n+    // - There are no OnReady callbacks registered to this promise.\n+    //\n+    // This may be used by the caller of `Set()` to short-circuit the work to\n+    // fulfill the promise if no one will ever consume the value. Even in that\n+    // case, consider fulfilling the promise with an error (e.g., `CANCELLED`)\n+    // instead of dropping the promise without fulfilling it in order to make\n+    // debugging easier. Also, be aware that the current promise may still be\n+    // used to mint a future.\n+    bool IsUniqueReference() const {\n+      return async_value()->IsUnique() && !async_value()->HasWaiter();\n+    }\n+\n    protected:\n     explicit Promise(tsl::AsyncValueRef<T> promise)\n         : promise_(std::move(promise)) {}"
        },
        {
            "sha": "72f72089d0dd301c67c084c61ec036cef2e3bc4f",
            "filename": "third_party/xla/xla/pjrt/pjrt_future_test.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc?ref=7dc449107fbd9f7e17a9c58bf5170a97ec72131b",
            "patch": "@@ -163,6 +163,27 @@ TEST(PjRtFutureTest, OnReadyMoveOnlyFuture) {\n   });\n }\n \n+TEST(PjRtFutureTest, PromiseIsUnique) {\n+  auto promise = PjRtFuture<>::CreatePromise();\n+  EXPECT_TRUE(promise.IsUniqueReference());\n+\n+  {\n+    auto copy = promise;\n+    EXPECT_FALSE(promise.IsUniqueReference());\n+    EXPECT_FALSE(copy.IsUniqueReference());\n+  }\n+  EXPECT_TRUE(promise.IsUniqueReference());\n+\n+  PjRtFuture<> future(promise);\n+  EXPECT_FALSE(promise.IsUniqueReference());\n+  future.OnReady([](const absl::Status&) {});\n+  future = {};\n+  EXPECT_FALSE(promise.IsUniqueReference());\n+\n+  promise.Set();\n+  EXPECT_TRUE(promise.IsUniqueReference());\n+}\n+\n TEST(PjRtFutureTest, MapCopyableFuture) {\n   auto promise = PjRtFuture<int32_t>::CreatePromise();\n   PjRtFuture<int32_t> future(promise);"
        },
        {
            "sha": "00d473583024e2ba013952a22ddfdad649289c7c",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h?ref=7dc449107fbd9f7e17a9c58bf5170a97ec72131b",
            "patch": "@@ -146,6 +146,10 @@ class AsyncValue {\n \n   void SetError(absl::Status status);\n \n+  // Returns true if and only if there are any waiters waiting for this value to\n+  // become available.\n+  bool HasWaiter() const;\n+\n   // If the value is available or becomes available, this invokes the waiter\n   // immediately. Otherwise, adds the waiter to the waiter list and calls it\n   // when the value becomes available.\n@@ -1035,6 +1039,10 @@ inline const absl::Status& AsyncValue::GetError() const {\n   return *result;\n }\n \n+inline bool AsyncValue::HasWaiter() const {\n+  return waiters_and_state_.load(std::memory_order_acquire).waiter() != nullptr;\n+}\n+\n template <typename Waiter>\n void AsyncValue::AndThen(Waiter&& waiter) {\n   // Clients generally want to use AndThen without them each having to check"
        },
        {
            "sha": "1e12d58e9e0dd745a1c5e8e2d789f7a5f2dc0c0b",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h?ref=7dc449107fbd9f7e17a9c58bf5170a97ec72131b",
            "patch": "@@ -252,6 +252,8 @@ class AsyncValueRef {\n \n   T& operator*() const { return get(); }\n \n+  bool HasWaiter() const { return AsPtr().HasWaiter(); }\n+\n   template <typename Waiter>\n   void AndThen(Waiter&& waiter) const {\n     AsPtr().AndThen(std::forward<Waiter>(waiter));\n@@ -511,6 +513,10 @@ class AsyncValuePtr {\n     return value_->SetError(std::move(status));\n   }\n \n+  // Returns true if and only if there are any waiters waiting for this value to\n+  // become available.\n+  bool HasWaiter() const { return value_->HasWaiter(); }\n+\n   // If the AsyncValueRef is available, invokes the `waiter` immediately.\n   // Otherwise, invokes the `waiter` when the AsyncValueRef becomes available.\n   //"
        },
        {
            "sha": "219b39cd856c1a504c5861f318c55498ef35da82",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dc449107fbd9f7e17a9c58bf5170a97ec72131b/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref_test.cc?ref=7dc449107fbd9f7e17a9c58bf5170a97ec72131b",
            "patch": "@@ -181,12 +181,15 @@ TEST(AsyncValueRefTest, AndThen) {\n \n   EXPECT_FALSE(ref.IsConcrete());\n   EXPECT_FALSE(ref.IsAvailable());\n+  EXPECT_FALSE(ref.HasWaiter());\n \n   bool executed = false;\n   ref.AndThen([&]() { executed = true; });\n+  EXPECT_TRUE(ref.HasWaiter());\n \n   ref.emplace(42);\n   EXPECT_TRUE(executed);\n+  EXPECT_FALSE(ref.HasWaiter());\n }\n \n TEST(AsyncValueRefTest, AndThenError) {"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 56,
        "deletions": 0
    }
}