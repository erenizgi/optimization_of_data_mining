{
    "author": "apivovarov",
    "message": "Move helper functions to an anonymous namespace.\n\nThis change moves `getScalarLimitOfFloatType` and `getScalarLimitOfIntegerType` into an anonymous namespace to limit their visibility to the current translation unit.\n\nPiperOrigin-RevId: 841912322",
    "sha": "c78a6691190e8a5428f54515888123fc2e63c50b",
    "files": [
        {
            "sha": "4e2a8c6358a16f222771685a3a8cc117996a487e",
            "filename": "third_party/xla/xla/mlir_hlo/utils/hlo_utils.cc",
            "status": "modified",
            "additions": 50,
            "deletions": 44,
            "changes": 94,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c78a6691190e8a5428f54515888123fc2e63c50b/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Futils%2Fhlo_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c78a6691190e8a5428f54515888123fc2e63c50b/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Futils%2Fhlo_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Futils%2Fhlo_utils.cc?ref=c78a6691190e8a5428f54515888123fc2e63c50b",
            "patch": "@@ -17,21 +17,71 @@ limitations under the License.\n \n #include <algorithm>\n #include <cassert>\n+#include <complex>\n+#include <cstddef>\n+#include <cstdint>\n #include <numeric>\n #include <string>\n #include <utility>\n #include <vector>\n \n+#include \"llvm/Support/ErrorHandling.h\"\n #include \"mlir/Dialect/Func/IR/FuncOps.h\"\n #include \"mlir/IR/Attributes.h\"\n #include \"mlir/IR/Builders.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n #include \"mlir/IR/BuiltinTypes.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"mlir/IR/TypeUtilities.h\"\n #include \"mlir/IR/Value.h\"\n #include \"mlir/Support/LLVM.h\"\n \n namespace mlir {\n namespace hlo {\n+namespace {\n+APFloat getScalarLimitOfFloatType(FloatType floatTy, ScalarLimit limit) {\n+  auto& semantics = floatTy.getFloatSemantics();\n+  switch (limit) {\n+    case kLowest:\n+      return APFloat::getLargest(semantics, /*negative=*/true);\n+    case kInfinityLowest:\n+      return APFloat::getInf(semantics, /*negative=*/true);\n+    case kMax:\n+      return APFloat::getLargest(semantics, /*negative=*/false);\n+    case kInfinityMax:\n+      return APFloat::getInf(semantics, /*negative=*/false);\n+  }\n+  llvm_unreachable(\"invalid limit\");\n+}\n+\n+// Returns a scalar value for the given integer type.\n+//\n+// The argument 'scalar' describes which scalar value to return. `integer_value`\n+// is used to specify the integer value for kInteger. For any other scalar,\n+// integer_value is ignored.\n+APInt getScalarLimitOfIntegerType(IntegerType integerTy, ScalarLimit limit) {\n+  unsigned width = integerTy.getWidth();\n+  bool isBool = (width == 1);\n+  switch (limit) {\n+    case kLowest:\n+    case kInfinityLowest:\n+      if (integerTy.isUnsigned() || isBool) {\n+        return APInt::getMinValue(width);\n+      } else {\n+        return APInt::getSignedMinValue(width);\n+      }\n+\n+    case kMax:\n+    case kInfinityMax:\n+      if (integerTy.isUnsigned() || isBool) {\n+        return APInt::getMaxValue(width);\n+      } else {\n+        return APInt::getSignedMaxValue(width);\n+      }\n+  }\n+  llvm_unreachable(\"invalid limit\");\n+}\n+}  // namespace\n \n static constexpr size_t kPaddingSize = 64;\n \n@@ -110,50 +160,6 @@ DenseElementsAttr getScalarNegZeroOfType(Type ty) {\n   llvm_unreachable(\"unsupported type\");\n }\n \n-static APFloat getScalarLimitOfFloatType(FloatType floatTy, ScalarLimit limit) {\n-  auto& semantics = floatTy.getFloatSemantics();\n-  switch (limit) {\n-    case kLowest:\n-      return APFloat::getLargest(semantics, /*negative=*/true);\n-    case kInfinityLowest:\n-      return APFloat::getInf(semantics, /*negative=*/true);\n-    case kMax:\n-      return APFloat::getLargest(semantics, /*negative=*/false);\n-    case kInfinityMax:\n-      return APFloat::getInf(semantics, /*negative=*/false);\n-  }\n-  llvm_unreachable(\"invalid limit\");\n-}\n-\n-// Returns a scalar value for the given integer type.\n-//\n-// The argument 'scalar' describes which scalar value to return. `integer_value`\n-// is used to specify the integer value for kInteger. For any other scalar,\n-// integer_value is ignored.\n-static APInt getScalarLimitOfIntegerType(IntegerType integerTy,\n-                                         ScalarLimit limit) {\n-  unsigned width = integerTy.getWidth();\n-  bool isBool = (width == 1);\n-  switch (limit) {\n-    case kLowest:\n-    case kInfinityLowest:\n-      if (integerTy.isUnsigned() || isBool) {\n-        return APInt::getMinValue(width);\n-      } else {\n-        return APInt::getSignedMinValue(width);\n-      }\n-\n-    case kMax:\n-    case kInfinityMax:\n-      if (integerTy.isUnsigned() || isBool) {\n-        return APInt::getMaxValue(width);\n-      } else {\n-        return APInt::getSignedMaxValue(width);\n-      }\n-  }\n-  llvm_unreachable(\"invalid limit\");\n-}\n-\n DenseElementsAttr getScalarLimitOfType(Type ty, ScalarLimit limit) {\n   RankedTensorType scalarTy = RankedTensorType::get({}, ty);\n   if (auto floatTy = mlir::dyn_cast<FloatType>(ty)) {"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 50,
        "deletions": 44
    }
}