{
    "author": "junwhanahn",
    "message": "Rename `Future<T>::type` to `Future<T>::value_type` to match the STL's naming style\n\nPiperOrigin-RevId: 850741539",
    "sha": "6fc67e9a8bd2c886dcd395758b911f0ebf736947",
    "files": [
        {
            "sha": "b55a9ce30e742d01f7e1b48cacfb00a44b42f39f",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6fc67e9a8bd2c886dcd395758b911f0ebf736947/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6fc67e9a8bd2c886dcd395758b911f0ebf736947/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=6fc67e9a8bd2c886dcd395758b911f0ebf736947",
            "patch": "@@ -179,7 +179,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n                    /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n \n  public:\n-  using type = T;\n+  using value_type = T;\n \n   bool IsValid() const { return promise_ != nullptr; }\n \n@@ -931,8 +931,8 @@ class PromiseMaker {\n   static std::pair<Promise<T>, Future<T>> Make(\n       FutureHelpers::OnBlockStart on_block_start,\n       FutureHelpers::OnBlockEnd on_block_end) {\n-    Promise<T> promise(\n-        tsl::MakeUnconstructedAsyncValueRef<typename tsl::Future<T>::type>());\n+    Promise<T> promise(tsl::MakeUnconstructedAsyncValueRef<\n+                       typename tsl::Future<T>::value_type>());\n     Future<T> future(promise, std::move(on_block_start),\n                      std::move(on_block_end));\n     return std::make_pair(std::move(promise), std::move(future));\n@@ -977,7 +977,7 @@ ABSL_ATTRIBUTE_ALWAYS_INLINE std::pair<Promise<T>, Future<T>> MakePromise(\n // `f` on the given `executor`.\n template <typename T, typename F, typename R = std::invoke_result_t<F>,\n           std::enable_if_t<std::is_constructible_v<\n-              typename tsl::Future<T>::type, R>>* = nullptr>\n+              typename tsl::Future<T>::value_type, R>>* = nullptr>\n [[nodiscard]] Future<T> MakeFutureOn(Executor& executor, F&& f) {\n   auto [promise, future] = MakePromise<T>();\n   executor.Execute("
        }
    ],
    "stats": {
        "total": 8,
        "additions": 4,
        "deletions": 4
    }
}