{
    "author": "ezhulenev",
    "message": "[xla] Optimize TupleTree construction\n\n```\nname                       cpu/op         cpu/op      vs base\nBM_Construct/0/0            304.7n ± 0%    271.0n ± 1%  -11.03% (p=0.000 n=20)\nBM_Construct/2/8            8.103µ ± 1%    5.385µ ± 1%  -33.54% (p=0.000 n=20)\nBM_Construct/1/1000         52.60µ ± 1%    40.34µ ± 1%  -23.31% (p=0.000 n=20)\nBM_ConstructUnowned/0/0     41.25n ± 0%    14.97n ± 1%  -63.71% (p=0.000 n=20)\nBM_ConstructUnowned/2/8     4.387µ ± 1%    1.701µ ± 1%  -61.22% (p=0.000 n=20)\nBM_ConstructUnowned/1/1000  28.87µ ± 0%    16.65µ ± 1%  -42.31% (p=0.000 n=20)\nBM_Copy/0/0                 19.36n ± 0%    18.43n ± 1%   -4.81% (p=0.000 n=20)\nBM_Copy/2/8                 614.4n ± 1%    618.7n ± 1%        ~ (p=0.086 n=20)\nBM_Copy/1/1000              3.141µ ± 1%    3.163µ ± 1%        ~ (p=0.072 n=20)\nBM_Move/0/0                 21.74n ± 0%    18.93n ± 1%  -12.90% (p=0.000 n=20)\nBM_Move/2/8                 14.90n ± 0%    12.67n ± 1%  -15.01% (p=0.000 n=20)\nBM_Move/1/1000              14.91n ± 0%    12.71n ± 1%  -14.75% (p=0.000 n=20)\nBM_ForEach/0/0             0.9730n ± 0%   1.3005n ± 1%  +33.66% (p=0.000 n=20)\nBM_ForEach/2/8              25.28n ± 0%    25.36n ± 1%        ~ (p=0.126 n=20)\nBM_ForEach/1/1000           332.5n ± 0%    333.6n ± 1%        ~ (p=0.174 n=20)\nBM_Iterate/0/0             0.9725n ± 1%   1.2995n ± 1%  +33.62% (p=0.000 n=20)\nBM_Iterate/2/8              25.29n ± 0%    25.35n ± 1%        ~ (p=0.167 n=20)\nBM_Iterate/1/1000           334.1n ± 0%    335.2n ± 1%        ~ (p=0.060 n=20)\ngeomean                    165.0n         138.1n       -16.31%\n\nname                       time/op        time/op     vs base\nBM_Construct/0/0            305.4n ± 0%    271.7n ± 1%  -11.03% (p=0.000 n=20)\nBM_Construct/2/8            8.124µ ± 1%    5.399µ ± 1%  -33.55% (p=0.000 n=20)\nBM_Construct/1/1000         52.77µ ± 1%    40.46µ ± 1%  -23.32% (p=0.000 n=20)\nBM_ConstructUnowned/0/0     41.35n ± 0%    15.00n ± 1%  -63.71% (p=0.000 n=20)\nBM_ConstructUnowned/2/8     4.397µ ± 1%    1.706µ ± 1%  -61.21% (p=0.000 n=20)\nBM_ConstructUnowned/1/1000  28.93µ ± 0%    16.69µ ± 1%  -42.31% (p=0.000 n=20)\nBM_Copy/0/0                 19.40n ± 0%    18.47n ± 1%   -4.81% (p=0.000 n=20)\nBM_Copy/2/8                 615.9n ± 1%    620.2n ± 1%        ~ (p=0.072 n=20)\nBM_Copy/1/1000              3.148µ ± 2%    3.171µ ± 1%        ~ (p=0.072 n=20)\nBM_Move/0/0                 21.79n ± 0%    18.98n ± 1%  -12.88% (p=0.000 n=20)\nBM_Move/2/8                 14.94n ± 0%    12.70n ± 1%  -15.00% (p=0.000 n=20)\nBM_Move/1/1000              14.94n ± 0%    12.74n ± 1%  -14.75% (p=0.000 n=20)\nBM_ForEach/0/0             0.9750n ± 0%   1.3035n ± 1%  +33.69% (p=0.000 n=20)\nBM_ForEach/2/8              25.34n ± 0%    25.43n ± 1%        ~ (p=0.098 n=20)\nBM_ForEach/1/1000           333.3n ± 0%    334.3n ± 1%        ~ (p=0.142 n=20)\nBM_Iterate/0/0             0.9750n ± 1%   1.3025n ± 1%  +33.59% (p=0.000 n=20)\nBM_Iterate/2/8              25.35n ± 0%    25.41n ± 1%        ~ (p=0.172 n=20)\nBM_Iterate/1/1000           334.8n ± 0%    336.0n ± 1%        ~ (p=0.063 n=20)\ngeomean                    165.4n         138.4n       -16.31%\n```\n\nPiperOrigin-RevId: 802180448",
    "sha": "5fdfdae8ec7e23fcd616e431136c14147d709fd2",
    "files": [
        {
            "sha": "89f3f036bc8b758130b6c97a94b3949333f8a1b6",
            "filename": "third_party/xla/xla/shape_tree.h",
            "status": "modified",
            "additions": 8,
            "deletions": 11,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fdfdae8ec7e23fcd616e431136c14147d709fd2/third_party%2Fxla%2Fxla%2Fshape_tree.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fdfdae8ec7e23fcd616e431136c14147d709fd2/third_party%2Fxla%2Fxla%2Fshape_tree.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fshape_tree.h?ref=5fdfdae8ec7e23fcd616e431136c14147d709fd2",
            "patch": "@@ -302,24 +302,21 @@ class ShapeTree {\n     shape_storage_.swap(shape);\n   }\n \n-  ShapeTree(std::shared_ptr<Shape> shape, const T& init_value)\n-      : ShapeTree(shape.get(), init_value) {\n-    shape_storage_.swap(shape);\n-  }\n-\n   ShapeTree(const Shape* shape, TupleTree<T>&& tuple_tree,\n             std::shared_ptr<Shape> shape_storage)\n       : tuple_tree_(std::move(tuple_tree)),\n         shape_storage_(shape_storage),\n         shape_(shape) {}\n \n-  // This constructor now always takes an init_value.\n-  ShapeTree(absl::in_place_t, const Shape* shape, const T& init_value)\n-      : tuple_tree_(*shape, init_value), shape_(shape) {}\n+  template <typename... Args>\n+  explicit ShapeTree(std::shared_ptr<Shape> shape, Args&&... args)\n+      : ShapeTree(shape.get(), args...) {\n+    shape_storage_.swap(shape);\n+  }\n \n-  template <typename... Ts>\n-  ShapeTree(absl::in_place_t, const Shape* shape)\n-      : tuple_tree_(TupleTree<T>::Node::FromShape(*shape)), shape_(shape) {}\n+  template <typename... Args>\n+  ShapeTree(absl::in_place_t, const Shape* shape, Args&&... args)\n+      : tuple_tree_(*shape, args...), shape_(shape) {}\n \n   TupleTree<T> tuple_tree_;\n "
        },
        {
            "sha": "81dceca3f1ba0826c51ae033fb81ecef85bfe06d",
            "filename": "third_party/xla/xla/tuple_tree.h",
            "status": "modified",
            "additions": 33,
            "deletions": 84,
            "changes": 117,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fdfdae8ec7e23fcd616e431136c14147d709fd2/third_party%2Fxla%2Fxla%2Ftuple_tree.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fdfdae8ec7e23fcd616e431136c14147d709fd2/third_party%2Fxla%2Fxla%2Ftuple_tree.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftuple_tree.h?ref=5fdfdae8ec7e23fcd616e431136c14147d709fd2",
            "patch": "@@ -170,7 +170,8 @@ class IndexTable {\n // - Constructor from Span of Pairs: When constructing from a span of\n //   {ShapeIndex, T} pairs, only the nodes at the specified indices are\n //   initialized with the given values. Any necessary ancestor tuple nodes are\n-//   implicitly created and their values are default-initialized (e.g., T()).\n+//   implicitly created and their values are constructed from the provided\n+//   arguments.\n // - `element()` and `mutable_element()`: These methods can access the value\n //   of *any* node in the tree, not just leaves, using its ShapeIndex.\n // - `Map` and `MapWithStatus`: These functions apply the given function to the\n@@ -212,30 +213,6 @@ class TupleTree {\n                   std::vector<Node>(children.begin(), children.end()));\n     }\n \n-    static Node FromShape(const Shape& shape, const T& init_value) {\n-      if (!shape.IsTuple()) {\n-        return Node::Leaf(init_value);\n-      }\n-      std::vector<Node> children;\n-      children.reserve(shape.tuple_shapes().size());\n-      for (const auto& subshape : shape.tuple_shapes()) {\n-        children.push_back(FromShape(subshape, init_value));\n-      }\n-      return Node(init_value, std::move(children));\n-    }\n-\n-    static Node FromShape(const Shape& shape) {\n-      if (!shape.IsTuple()) {\n-        return Node::Leaf(T());\n-      }\n-      std::vector<Node> children;\n-      children.reserve(shape.tuple_shapes().size());\n-      for (const auto& subshape : shape.tuple_shapes()) {\n-        children.push_back(FromShape(subshape));\n-      }\n-      return Node(T(), std::move(children));\n-    }\n-\n     // Default constructor creates an empty tuple.\n     Node() : children_({}) {}\n \n@@ -279,22 +256,19 @@ class TupleTree {\n   using NodePairs = absl::InlinedVector<NodePair, 1>;\n   using IndexTable = internal::IndexTable;\n \n+  // Constructor for an empty tuple.\n+  TupleTree() { Initialize(Node::Tuple()); }\n+\n   // Constructor for a single leaf node.\n-  explicit TupleTree(const T& leaf_value, T default_value = T())\n-      : default_value_(std::move(default_value)) {\n+  explicit TupleTree(const T& leaf_value) {\n     Initialize(Node::Leaf(leaf_value));\n   }\n-  explicit TupleTree(T&& leaf_value, T default_value = T())\n-      : default_value_(std::move(default_value)) {\n+  explicit TupleTree(T&& leaf_value) {\n     Initialize(Node::Leaf(std::move(leaf_value)));\n   }\n \n-  // Constructor for an empty tuple.\n-  TupleTree() { Initialize(Node::Tuple()); }\n-\n   // Constructor from an initializer list, creating a flat tuple of leaves.\n-  TupleTree(std::initializer_list<T> items, T default_value = T())\n-      : default_value_(std::move(default_value)) {\n+  TupleTree(std::initializer_list<T> items) {\n     std::vector<Node> children;\n     children.reserve(items.size());\n     for (const auto& item : items) {\n@@ -304,53 +278,47 @@ class TupleTree {\n   }\n \n   // Constructor from an initializer list of Nodes for nested structures.\n-  TupleTree(std::initializer_list<Node> items, T default_value = T())\n-      : default_value_(std::move(default_value)) {\n+  TupleTree(std::initializer_list<Node> items) {\n     Initialize(Node::Tuple(items));\n   }\n \n   // Basic constructor taking the root node.\n-  explicit TupleTree(Node&& root, T default_value = T())\n-      : default_value_(std::move(default_value)) {\n-    Initialize(std::move(root));\n-  }\n+  explicit TupleTree(Node&& root) { Initialize(std::move(root)); }\n \n   // Constructor from a list of shape indices and values.\n   // U must be std::pair<ShapeIndex, T> or const std::pair<ShapeIndex, T>.\n   // The tree structure is created based on the provided indices. Nodes at these\n   // indices are initialized with the given values. Any implicitly created\n-  // parent nodes are value-initialized (e.g., T()).\n-  template <typename U>\n-  explicit TupleTree(absl::Span<U> node_pairs, T default_value = T())\n-      : default_value_(default_value) {\n+  // parent nodes are constructed from the provided arguments.\n+  template <typename U, typename... Args>\n+  explicit TupleTree(absl::Span<U> node_pairs, Args&&... args) {\n     static_assert(\n-        std::is_same_v<U, std::pair<ShapeIndex, T>> ||\n-            std::is_same_v<U, const std::pair<ShapeIndex, T>>,\n+        std::is_same_v<std::remove_const_t<U>, std::pair<ShapeIndex, T>>,\n         \"TupleTree constructor requires absl::Span of std::pair<ShapeIndex, T> \"\n         \"or const std::pair<ShapeIndex, T>\");\n \n-    Node root_node(Node::Tuple(default_value));\n-    for (U& pair : node_pairs) {\n-      const ShapeIndex& index = pair.first;\n+    Node root_node(Node::Tuple(T(args...)));\n+    for (auto& [index, value] : node_pairs) {\n       Node* node = GetOrCreateNode(root_node, index,\n-                                   /*preserve_leaf_value=*/false);\n+                                   /*preserve_leaf_value=*/false, args...);\n       // Forward the second element to enable move semantics if U is non-const.\n-      *node = Node::Leaf(std::forward<decltype(pair.second)>(pair.second));\n+      *node = Node::Leaf(std::forward<decltype(value)>(value));\n     }\n     Initialize(std::move(root_node));\n   }\n \n-  // Constructor from a Shape and an initial value for all nodes.\n-  explicit TupleTree(const Shape& shape, const T& init_value = T())\n-      : default_value_(init_value) {\n+  // Constructor from a Shape and an initial value for all nodes constructed\n+  // from the given arguments.\n+  template <typename... Args>\n+  explicit TupleTree(const Shape& shape, Args&&... args) {\n     index_table_ = IndexTable(shape);\n     if (!shape.IsTuple()) {\n-      nodes_.emplace_back(ShapeIndex(), init_value);\n+      nodes_.emplace_back(ShapeIndex(), T(args...));\n     } else {\n       nodes_.reserve(ShapeUtil::SubshapeCount(shape));\n       ShapeUtil::ForEachSubshape(shape,\n                                  [&](const Shape&, const ShapeIndex& index) {\n-                                   nodes_.emplace_back(index, init_value);\n+                                   nodes_.emplace_back(index, T(args...));\n                                  });\n     }\n   }\n@@ -459,7 +427,7 @@ class TupleTree {\n     }\n \n     return TupleTree<T>(std::move(subtree_index_table),\n-                        std::move(subtree_nodes), default_value_);\n+                        std::move(subtree_nodes));\n   }\n \n   using iterator = typename NodePairs::iterator;\n@@ -616,7 +584,7 @@ class TupleTree {\n \n   absl::StatusOr<Node> ToNode(ShapeIndexView index_view = {}) const {\n     if (!index_table_.entries().has_value()) {\n-      return Node::Tuple(default_value_);\n+      return Node::Tuple(T());\n     }\n     ShapeIndex index(index_view.begin(), index_view.end());\n     return ToNodeImpl(index);\n@@ -631,11 +599,8 @@ class TupleTree {\n       : nodes_(std::move(nodes)), index_table_(index_table) {}\n \n   // Private constructor for SubTree.\n-  TupleTree(internal::IndexTable&& index_table, NodePairs&& nodes,\n-            T default_value)\n-      : default_value_(std::move(default_value)),\n-        nodes_(std::move(nodes)),\n-        index_table_(std::move(index_table)) {}\n+  TupleTree(internal::IndexTable&& index_table, NodePairs&& nodes)\n+      : nodes_(std::move(nodes)), index_table_(std::move(index_table)) {}\n \n   void Initialize(Node root) {\n     // First, build the IndexTable from the structure.\n@@ -662,24 +627,9 @@ class TupleTree {\n     }\n   }\n \n-  size_t BuildNodesVectorFromShape(const Shape& shape, const T& init_value,\n-                                   ShapeIndex& current_index, size_t node_idx) {\n-    nodes_[node_idx] = {current_index, init_value};\n-    if (!shape.IsTuple()) {\n-      return node_idx + 1;\n-    }\n-    size_t current_node_idx = node_idx + 1;\n-    for (size_t i = 0; i < shape.tuple_shapes().size(); ++i) {\n-      current_index.push_back(i);\n-      current_node_idx = BuildNodesVectorFromShape(\n-          shape.tuple_shapes(i), init_value, current_index, current_node_idx);\n-      current_index.pop_back();\n-    }\n-    return current_node_idx;\n-  }\n-\n+  template <typename... Args>\n   Node* GetOrCreateNode(Node& root, const ShapeIndex& index,\n-                        bool preserve_leaf_value) {\n+                        bool preserve_leaf_value, Args&&... args) {\n     Node* node = &root;\n     if (index.empty()) {\n       return node;\n@@ -692,18 +642,18 @@ class TupleTree {\n         // Transition from leaf to tuple.\n         if (preserve_leaf_value) {\n           T original_value = std::move(*node->mutable_value());\n-          *node = Node::Tuple(default_value_);\n+          *node = Node::Tuple(T(args...));\n           // The original leaf value is placed at index 0.\n           node->mutable_children()->push_back(\n               Node::Leaf(std::move(original_value)));\n         } else {\n-          *node = Node::Tuple(default_value_);\n+          *node = Node::Tuple(T(args...));\n         }\n       }\n \n       std::vector<Node>* children = node->mutable_children();\n       while (idx >= children->size()) {\n-        children->push_back(Node::Tuple(default_value_));\n+        children->push_back(Node::Tuple(T(args...)));\n       }\n       node = &children->at(idx);\n     }\n@@ -733,7 +683,6 @@ class TupleTree {\n     return Node::Tuple(value, std::move(children));\n   }\n \n-  T default_value_;\n   // Leaves sorted in pre-order.\n   NodePairs nodes_;\n   IndexTable index_table_;"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 41,
        "deletions": 95
    }
}