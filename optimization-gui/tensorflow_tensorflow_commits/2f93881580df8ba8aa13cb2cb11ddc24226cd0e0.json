{
    "author": "pifon2a",
    "message": "[XLA] Skip printing StackFrameIndex if print_metadata is false.\n\nPiperOrigin-RevId: 845184915",
    "sha": "2f93881580df8ba8aa13cb2cb11ddc24226cd0e0",
    "files": [
        {
            "sha": "aa64124e7d6bdbf93395434cb65c68a1ad8144cd",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f93881580df8ba8aa13cb2cb11ddc24226cd0e0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f93881580df8ba8aa13cb2cb11ddc24226cd0e0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc?ref=2f93881580df8ba8aa13cb2cb11ddc24226cd0e0",
            "patch": "@@ -406,7 +406,7 @@ void HloModule::Print(\n         },\n         value);\n   }\n-  PrintStackFrameIndex(printer);\n+  PrintStackFrameIndex(printer, options);\n   printer->Append(\"\\n\\n\");\n   PrintComputations(printer, options);\n }\n@@ -479,8 +479,10 @@ void HloModule::PrintComputations(Printer* printer,\n   }\n }\n \n-void HloModule::PrintStackFrameIndex(Printer* printer) const {\n-  if (!stack_frame_index_.has_value()) {\n+void HloModule::PrintStackFrameIndex(Printer* printer,\n+                                     const HloPrintOptions& options) const {\n+  if (!stack_frame_index_.has_value() ||\n+      stack_frame_index_->file_names().empty() || !options.print_metadata()) {\n     return;\n   }\n   printer->Append(\"\\n\\nFileNames\\n\");"
        },
        {
            "sha": "584fd38d1e89798cb3108de5f994a9cb49a270f4",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f93881580df8ba8aa13cb2cb11ddc24226cd0e0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f93881580df8ba8aa13cb2cb11ddc24226cd0e0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h?ref=2f93881580df8ba8aa13cb2cb11ddc24226cd0e0",
            "patch": "@@ -448,7 +448,8 @@ class HloModule {\n   void PrintComputations(Printer* printer,\n                          const HloPrintOptions& options) const;\n   void PrintConfig(Printer* printer, const HloModuleConfig& config) const;\n-  void PrintStackFrameIndex(Printer* printer) const;\n+  void PrintStackFrameIndex(Printer* printer,\n+                            const HloPrintOptions& options) const;\n \n  public:\n   // Prints a string representation of the module."
        },
        {
            "sha": "3edde58537a8fdb464595ca9179f63896929f5fc",
            "filename": "third_party/xla/xla/hlo/parser/hlo_parser_test.cc",
            "status": "modified",
            "additions": 148,
            "deletions": 124,
            "changes": 272,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2f93881580df8ba8aa13cb2cb11ddc24226cd0e0/third_party%2Fxla%2Fxla%2Fhlo%2Fparser%2Fhlo_parser_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2f93881580df8ba8aa13cb2cb11ddc24226cd0e0/third_party%2Fxla%2Fxla%2Fhlo%2Fparser%2Fhlo_parser_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fparser%2Fhlo_parser_test.cc?ref=2f93881580df8ba8aa13cb2cb11ddc24226cd0e0",
            "patch": "@@ -2820,15 +2820,14 @@ class HloParameterizedParserTest\n     VLOG(3) << \"Running HloParameterizedParserTest with short_form = \"\n             << short_form << \", proto_round_trip = \" << proto_round_trip;\n     const std::string& original = GetParam().module_string;\n-    TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                            ParseAndReturnVerifiedModule(original));\n-    TF_ASSERT_OK_AND_ASSIGN(\n+    ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(original));\n+    ASSERT_OK_AND_ASSIGN(\n         module, ParseAndReturnVerifiedModule(module->ToString(\n                     HloPrintOptions().set_print_large_constants(true))));\n \n     if (proto_round_trip) {\n-      TF_ASSERT_OK_AND_ASSIGN(module, HloModule::CreateFromProto(\n-                                          module->ToProto(), module->config()));\n+      ASSERT_OK_AND_ASSIGN(module, HloModule::CreateFromProto(\n+                                       module->ToProto(), module->config()));\n     }\n     if (short_form) {\n       EXPECT_EQ(original, module->ToString(HloPrintOptions::ShortParsable()));\n@@ -2879,7 +2878,7 @@ INSTANTIATE_TEST_SUITE_P(HloParserTestSuccessInstantiation,\n class HloNonRoundtripParserTest\n     : public ::testing::TestWithParam<NonRoundtripTestData> {};\n TEST_P(HloNonRoundtripParserTest, Run) {\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto module, ParseAndReturnVerifiedModule(GetParam().test_name,\n                                                 GetParam().input_module_string,\n                                                 HloModuleConfig()));\n@@ -3020,7 +3019,7 @@ ENTRY %configuration_test() -> s32[] {\n   %constant = s32[] constant(42), backend_config=\"foo bar\"\n })\";\n   auto result = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(result.status());\n+  ASSERT_OK(result.status());\n   EXPECT_EQ(\"foo bar\", result.value()\n                            ->entry_computation()\n                            ->root_instruction()\n@@ -3481,7 +3480,7 @@ ENTRY %Reduce (input: f32[8,16,256]) -> f32[8,16] {\n })\";\n \n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   auto program_layout = module.value()->entry_computation_layout();\n   ASSERT_EQ(program_layout.parameter_count(), 1);\n   auto param_layout = program_layout.parameter_layout(0).layout();\n@@ -3516,7 +3515,7 @@ ENTRY %Reduce (input: f32[8,16,256]) -> f32[8,16] {\n                                      HloParserOptions()\n                                          .set_fill_missing_layouts(false)\n                                          .set_keep_module_auto_layouts(false));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   // Do not set the default layout.\n   EXPECT_FALSE(module.value()->entry_computation_layout().AnyLayoutSet());\n }\n@@ -3542,7 +3541,7 @@ ENTRY %Reduce (input: f32[8,16,256]) -> f32[8,16] {\n                                      HloParserOptions()\n                                          .set_fill_missing_layouts(true)\n                                          .set_keep_module_auto_layouts(true));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   // Do not set the default layout.\n   EXPECT_FALSE(module.value()->entry_computation_layout().AnyLayoutSet());\n }\n@@ -3568,7 +3567,7 @@ ENTRY %Reduce (input: f32[8,16,256]) -> f32[8,16] {\n                                      HloParserOptions()\n                                          .set_fill_missing_layouts(true)\n                                          .set_keep_module_auto_layouts(false));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_THAT(module.value()\n                   ->entry_computation_layout()\n                   .parameter_layout(0)\n@@ -3598,7 +3597,7 @@ ENTRY %Reduce (input: f32[8,16,256]) -> f32[8,16] {\n                                      HloParserOptions()\n                                          .set_fill_missing_layouts(true)\n                                          .set_keep_module_auto_layouts(false));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_THAT(module.value()\n                   ->entry_computation_layout()\n                   .parameter_layout(0)\n@@ -3620,7 +3619,7 @@ ENTRY main {\n   absl::StatusOr<std::unique_ptr<HloModule>> module =\n       ParseAndReturnUnverifiedModule(\n           original, {}, HloParserOptions().set_fill_missing_layouts(false));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_FALSE(module.value()\n                    ->entry_computation()\n                    ->root_instruction()\n@@ -3641,7 +3640,7 @@ ENTRY main {\n   absl::StatusOr<std::unique_ptr<HloModule>> module =\n       ParseAndReturnUnverifiedModule(\n           original, {}, HloParserOptions().set_fill_missing_layouts(true));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_THAT(module.value()\n                   ->entry_computation()\n                   ->root_instruction()\n@@ -3664,7 +3663,7 @@ ENTRY main {\n   absl::StatusOr<std::unique_ptr<HloModule>> module =\n       ParseAndReturnUnverifiedModule(\n           original, {}, HloParserOptions().set_fill_missing_layouts(true));\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_THAT(module.value()\n                   ->entry_computation()\n                   ->root_instruction()\n@@ -3683,7 +3682,7 @@ c2 {\n   const2 = f32[1]{0} constant({67890})\n })\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_EQ(module.value()->entry_computation()->name(), \"c2\");\n }\n \n@@ -3694,7 +3693,7 @@ ENTRY consts {\n   last = f32[1]{0} constant({67890})\n })\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   EXPECT_EQ(module.value()->entry_computation()->root_instruction()->name(),\n             \"last\");\n }\n@@ -3713,7 +3712,7 @@ ENTRY /*comment*/ c1 {\n \n )\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n }\n \n TEST_F(HloParserTest, MultilineComments) {\n@@ -3732,7 +3731,7 @@ d\n */\n })\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n }\n \n TEST_F(HloParserTest, UnterminatedComment) {\n@@ -3755,23 +3754,23 @@ ENTRY c1 {\n   ROOT const1 = f32[1]{0} constant({12345}) // Something else\n })\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n }\n \n TEST_F(HloParserTest, SlashSlashCommentMsDosEolFormat) {\n   const std::string original =\n       \"HloModule slash_slash_comment:\\r\\n// Garbage\\r\\nENTRY c1 {\\r\\n// Foo \"\n       \"bar\\r\\nROOT const1 = f32[1]{0} constant({12345}) // Something else\\r\\n}\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n }\n \n TEST_F(HloParserTest, SlashSlashCommentMacEolFormat) {\n   const std::string original =\n       \"HloModule slash_slash_comment:\\r// Garbage\\rENTRY c1 {\\r// Foo \"\n       \"bar\\rROOT const1 = f32[1]{0} constant({12345}) // Something else\\r}\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n }\n \n TEST_F(HloParserTest, MultipleEntries) {\n@@ -3798,7 +3797,7 @@ ENTRY entry {\n }\n   )\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   std::unique_ptr<HloModule> parsed_module = std::move(module).value();\n   EXPECT_EQ(parsed_module->input_output_alias_config().GetAliasedOutput(0, {0}),\n             ShapeIndex{0});\n@@ -3825,7 +3824,7 @@ ENTRY entry {\n }\n   )\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   std::unique_ptr<HloModule> parsed_module = std::move(module).value();\n   EXPECT_EQ(parsed_module->input_output_alias_config().GetAliasedOutput(0, {0}),\n             ShapeIndex({0, 0}));\n@@ -3920,7 +3919,7 @@ ENTRY entry {\n }\n   )\";\n   auto module = ParseAndReturnVerifiedModule(original);\n-  TF_ASSERT_OK(module.status());\n+  ASSERT_OK(module.status());\n   std::unique_ptr<HloModule> parsed_module = std::move(module).value();\n   EXPECT_TRUE(\n       parsed_module->buffer_donor_config().ParameterIsBufferDonor(0, {0}));\n@@ -4019,21 +4018,21 @@ ENTRY ReduceR3ToR2 {\n   ROOT result = f32[8,16]{1,0} reduce(p0, p1), dimensions={2}, to_apply=add\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(original));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(original));\n   ASSERT_NE(module->entry_computation(), nullptr);\n   EXPECT_THAT(module->entry_computation()->root_instruction(),\n               GmockMatch(m::Reduce()));\n }\n \n TEST_F(HloParserTest, ParseSharding) {\n   const std::string original = \"{maximal device=42}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n }\n \n TEST_F(HloParserTest, ParseShardingPartialReplication) {\n   const std::string original = \"{devices=[2,2]0,1,2,3 last_tile_dim_replicate}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   Array<int64_t> tiling_last_dim_replicated({{0, 1}, {2, 3}});\n   EXPECT_EQ(HloSharding::PartialTile(tiling_last_dim_replicated).ToString(),\n@@ -4044,7 +4043,7 @@ TEST_F(HloParserTest, ParseShardingSubGroup) {\n   const std::string original =\n       \"{devices=[2,2,2,2]0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 \"\n       \"last_tile_dims={manual, replicated}}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   Array<int64_t> tile_assignment({2, 2, 2, 2});\n   tile_assignment.FillIota(0);\n@@ -4056,7 +4055,7 @@ TEST_F(HloParserTest, ParseShardingSubGroup) {\n \n TEST_F(HloParserTest, ParseTrivialIotaShardingPartialReplication) {\n   const std::string original = \"{devices=[2,2]<=[4] last_tile_dim_replicate}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   TileAssignment tiling_last_dim_replicated((absl::Span<const int64_t>){2, 2});\n   EXPECT_EQ(HloSharding::PartialTile(tiling_last_dim_replicated).ToString(),\n@@ -4066,7 +4065,7 @@ TEST_F(HloParserTest, ParseTrivialIotaShardingPartialReplication) {\n TEST_F(HloParserTest, ParseTrivialIotaShardingSubGroup) {\n   const std::string original =\n       \"{devices=[2,2,2,2]<=[16] last_tile_dims={manual, replicated}}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   TileAssignment tile_assignment({2, 2, 2, 2});\n   std::vector<OpSharding::Type> subgroup_types = {OpSharding::MANUAL,\n@@ -4078,7 +4077,7 @@ TEST_F(HloParserTest, ParseTrivialIotaShardingSubGroup) {\n TEST_F(HloParserTest, ParseTransposedIotaShardingPartialReplication) {\n   const std::string original =\n       \"{devices=[2,2]<=[2,2]T(1,0) last_tile_dim_replicate}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   TileAssignment tiling_last_dim_replicated({2, 2}, {2, 2}, {1, 0});\n   EXPECT_EQ(HloSharding::PartialTile(tiling_last_dim_replicated).ToString(),\n@@ -4089,7 +4088,7 @@ TEST_F(HloParserTest, ParseTransposedIotaShardingSubGroup) {\n   const std::string original =\n       \"{devices=[2,2,2,2]<=[2,2,4]T(2,1,0) last_tile_dims={manual, \"\n       \"replicated}}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   TileAssignment tile_assignment({2, 2, 2, 2}, {2, 2, 4}, {2, 1, 0});\n   std::vector<OpSharding::Type> subgroup_types = {OpSharding::MANUAL,\n@@ -4100,7 +4099,7 @@ TEST_F(HloParserTest, ParseTransposedIotaShardingSubGroup) {\n \n TEST_F(HloParserTest, ParseShardAs) {\n   const std::string original = \"{manual shard_as 1}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   EXPECT_EQ(\n       HloSharding::Manual().SetShardGroup(HloSharding::ShardAs(1)).ToString(),\n@@ -4111,7 +4110,7 @@ TEST_F(HloParserTest, ParseShardLike) {\n   const std::string original =\n       \"{devices=[2,2,2,2]<=[16] last_tile_dims={manual, replicated} shard_like \"\n       \"1}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   TileAssignment tile_assignment({2, 2, 2, 2});\n   std::vector<OpSharding::Type> subgroup_types = {OpSharding::MANUAL,\n@@ -4124,61 +4123,61 @@ TEST_F(HloParserTest, ParseShardLike) {\n \n TEST_F(HloParserTest, ParseUnknownSharding) {\n   const std::string original = \"{unknown}\";\n-  TF_ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n+  ASSERT_OK_AND_ASSIGN(HloSharding sharding, ParseSharding(original));\n   EXPECT_EQ(sharding.ToString(), original);\n   EXPECT_EQ(HloSharding::Unknown().ToString(), original);\n }\n \n TEST_F(HloParserTest, ParseFrontendAttributes) {\n   const std::string original =\n       R\"({attr_a=\"test_a\",attr_b=\"b\",attr_c={type=\"s64\"},attr_d=\"a=\\\"b/c\\\"\"})\";\n-  TF_ASSERT_OK_AND_ASSIGN(FrontendAttributes frontend_attributes,\n-                          ParseFrontendAttributes(original));\n+  ASSERT_OK_AND_ASSIGN(FrontendAttributes frontend_attributes,\n+                       ParseFrontendAttributes(original));\n   EXPECT_EQ(FrontendAttributesToString(frontend_attributes), original);\n }\n \n TEST_F(HloParserTest, ParseWindow) {\n   Window original = window_util::MakeWindow({1, 2, 3});\n-  TF_ASSERT_OK_AND_ASSIGN(Window parsed,\n-                          ParseWindow(window_util::ToString(original)));\n+  ASSERT_OK_AND_ASSIGN(Window parsed,\n+                       ParseWindow(window_util::ToString(original)));\n   EXPECT_EQ(window_util::ToString(original), window_util::ToString(parsed));\n }\n \n TEST_F(HloParserTest, ParseConvolutionDimensionNumbers) {\n   const std::string original = \"b0f_0io->b0f\";\n-  TF_ASSERT_OK_AND_ASSIGN(ConvolutionDimensionNumbers dnums,\n-                          ParseConvolutionDimensionNumbers(original));\n+  ASSERT_OK_AND_ASSIGN(ConvolutionDimensionNumbers dnums,\n+                       ParseConvolutionDimensionNumbers(original));\n   EXPECT_EQ(original, ConvolutionDimensionNumbersToString(dnums));\n }\n \n TEST_F(HloParserTest, ParseConvolutionDimensionNumbersWithUnknownDims) {\n   const std::string original = \"b0?f_?0?io->?b?0?f\";\n-  TF_ASSERT_OK_AND_ASSIGN(ConvolutionDimensionNumbers dnums,\n-                          ParseConvolutionDimensionNumbers(original));\n+  ASSERT_OK_AND_ASSIGN(ConvolutionDimensionNumbers dnums,\n+                       ParseConvolutionDimensionNumbers(original));\n   EXPECT_EQ(original, ConvolutionDimensionNumbersToString(dnums));\n }\n \n TEST_F(HloParserTest, ParseReplicaGroups) {\n   const std::string original = \"{{0,1},{2,3}}\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::vector<ReplicaGroup> replica_groups,\n-                          ParseReplicaGroupsOnly(original));\n+  ASSERT_OK_AND_ASSIGN(std::vector<ReplicaGroup> replica_groups,\n+                       ParseReplicaGroupsOnly(original));\n   EXPECT_EQ(original, ReplicaGroupsToString(replica_groups));\n }\n \n TEST_F(HloParserTest, ParsePaddingConfigNoInteriorPadding) {\n   const std::string original = \"0_1x2_3\";\n-  TF_ASSERT_OK_AND_ASSIGN(PaddingConfig dnums, ParsePaddingConfig(original));\n+  ASSERT_OK_AND_ASSIGN(PaddingConfig dnums, ParsePaddingConfig(original));\n   EXPECT_EQ(original, PaddingConfigToString(dnums));\n }\n \n TEST_F(HloParserTest, ParsePaddingConfigInteriorPadding) {\n   const std::string original = \"0_1_0x2_3_4\";\n-  TF_ASSERT_OK_AND_ASSIGN(PaddingConfig dnums, ParsePaddingConfig(original));\n+  ASSERT_OK_AND_ASSIGN(PaddingConfig dnums, ParsePaddingConfig(original));\n   EXPECT_EQ(original, PaddingConfigToString(dnums));\n }\n \n TEST_F(HloParserTest, ParsePaddingConfigInteriorPaddingImplicitZeroDim) {\n-  TF_ASSERT_OK_AND_ASSIGN(PaddingConfig dnums, ParsePaddingConfig(\"0_1x2_3_4\"));\n+  ASSERT_OK_AND_ASSIGN(PaddingConfig dnums, ParsePaddingConfig(\"0_1x2_3_4\"));\n   // The extra \"_0\" gets added to the canonical string because the other dim has\n   // interior padding.\n   EXPECT_EQ(\"0_1_0x2_3_4\", PaddingConfigToString(dnums));\n@@ -4198,7 +4197,7 @@ TEST(HloParserSingleOpTest, SingleOp) {\n   const std::string text =\n       \"%multiply = f32[2,4]{1,0} multiply(f32[2,4]{1,0} %broadcast, \"\n       \"f32[2,4]{1,0} %x)\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_THAT(computation->root_instruction(),\n@@ -4229,17 +4228,55 @@ TEST(HloParserSingleOpTest, SingleOpNoOperandShapesProducesError) {\n TEST(HloParserSingleOpTest, SingleOpNoNames) {\n   const std::string text =\n       \"%multiply = f32[2,4]{1,0} multiply(f32[2,4]{1,0}, f32[2,4]{1,0})\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_THAT(computation->root_instruction(),\n               GmockMatch(m::Multiply(m::Parameter(0), m::Parameter(1))));\n }\n \n+TEST(HloParserSingleOpTest, SkipStackFrameIndex) {\n+  const std::string text = R\"(HloModule m, entry_computation_layout={()->pred[]}\n+\n+FileNames\n+1 \"<embedded module>\"\n+2 \"experimental/module.py\"\n+3 \"yet/another/test.py\"\n+\n+FunctionNames\n+1 \"main\"\n+2 \"method\"\n+\n+FileLocations\n+1 {file_name_id=1 function_name_id=1 line=153 end_line=153 column=2 end_column=31}\n+2 {file_name_id=3 function_name_id=2 line=35 end_line=35 column=2 end_column=24}\n+3 {file_name_id=2 function_name_id=2 line=83 end_line=83 column=2 end_column=15}\n+\n+StackFrames\n+1 {file_location_id=1 parent_frame_id=1}\n+2 {file_location_id=2 parent_frame_id=2}\n+\n+\n+ENTRY %constant_pred () -> pred[] {\n+  ROOT %constant = pred[] constant(true), metadata={op_type=\"const\" op_name=\"opname\" stack_frame_id=1}\n+})\";\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  HloPrintOptions options = HloPrintOptions::Canonical();\n+  options.set_print_metadata(false);\n+  EXPECT_EQ(module->ToString(options),\n+            R\"(HloModule m, entry_computation_layout={()->pred[]}\n+\n+ENTRY constant_pred {\n+  ROOT tmp_0 = pred[] constant(true)\n+}\n+\n+)\");\n+}\n+\n TEST(HloParserSingleOpTest, CanonicalOp) {\n   const std::string text =\n       \"f32[2,4]{1,0} multiply(f32[2,4]{1,0}, f32[2,4]{1,0})\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_THAT(computation->root_instruction(),\n@@ -4275,7 +4312,7 @@ TEST(HloParserSingleOpTest, CanonicalOpWithNested) {\n   }\n })\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_EQ(\n@@ -4300,7 +4337,7 @@ TEST(HloParserSingleOpTest, CanonicalOpIndexedConditionalInlinedBranches) {\n }\n })\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_EQ(\n@@ -4318,7 +4355,7 @@ TEST(HloParserSingleOpTest, SingleOpWithNested) {\n   ROOT %subtract = f32[3,2,1,1]{3,2,1,0} subtract(f32[3,2,1,1]{3,2,1,0} %param_0, f32[3,2,1,1]{3,2,1,0} %broadcast)\n })\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_THAT(computation->root_instruction(),\n@@ -4365,7 +4402,7 @@ TEST(HloParserSingleOpTest, SingleOpWithNested_NoOperandName) {\n TEST(HloParserSingleOpTest, ConvolutionTrivialFeatureGroupCount) {\n   const std::string text =\n       R\"(%convolution = f32[1,2,1]{2,0,1} convolution(f32[1,2,1]{2,0,1} %copy, f32[1,1,1]{2,1,0} %filter), window={size=1}, dim_labels=b0f_0io->b0f)\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(text));\n   const HloComputation* computation = module->entry_computation();\n   ASSERT_NE(computation, nullptr);\n   EXPECT_THAT(computation->root_instruction(),\n@@ -4398,7 +4435,7 @@ ENTRY %axpy.v5 (alpha: f32[], x: f32[2,4], y: f32[2,4]) -> f32[2,4] {\n   ROOT %add = f32[2,4]{1,0} add(f32[2,4]{1,0} %multiply, f32[2,4]{1,0} %y)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   ASSERT_FALSE(module->has_schedule());\n }\n \n@@ -4415,7 +4452,7 @@ ENTRY %axpy.v5 (alpha: f32[], x: f32[2,4], y: f32[2,4]) -> f32[2,4] {\n   ROOT %add = f32[2,4]{1,0} add(f32[2,4]{1,0} %multiply, f32[2,4]{1,0} %y)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   ASSERT_FALSE(module->has_schedule());\n }\n \n@@ -4432,9 +4469,9 @@ ENTRY %axpy.v5 (alpha: f32[], x: f32[2,4], y: f32[2,4]) -> f32[2,4] {\n   ROOT %add = f32[2,4]{1,0} add(f32[2,4]{1,0} %multiply, f32[2,4]{1,0} %y)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   ASSERT_TRUE(module->has_schedule());\n-  TF_ASSERT_OK(module->schedule().Verify());\n+  ASSERT_OK(module->schedule().Verify());\n   EXPECT_EQ(module->schedule().sequences().size(), 1);\n   ASSERT_TRUE(\n       module->schedule().is_computation_scheduled(module->entry_computation()));\n@@ -4459,9 +4496,9 @@ ENTRY %axpy.v5 (alpha: f32[], x: f32[2,4], y: f32[2,4]) -> f32[2,4] {\n   ROOT %add = f32[2,4]{1,0} add(f32[2,4]{1,0} %multiply, f32[2,4]{1,0} %y)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   ASSERT_TRUE(module->has_schedule());\n-  TF_ASSERT_OK(module->schedule().Verify());\n+  ASSERT_OK(module->schedule().Verify());\n   EXPECT_EQ(module->schedule().sequences().size(), 1);\n   ASSERT_TRUE(\n       module->schedule().is_computation_scheduled(module->entry_computation()));\n@@ -4536,7 +4573,7 @@ ENTRY entry {\n   ROOT root = f32[ 1, 2,3, 4, 5]{0, 1, 2,3, 4 } parameter(0)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n }\n \n TEST_F(HloParserTest, ShapeMismatchInOperand) {\n@@ -4557,7 +4594,7 @@ ENTRY %entrycomp (p: f32[2,2]) -> f32[2,2] {\n \n TEST_F(HloParserTest, ParseShapeStringR2F32) {\n   std::string shape_string = \"f32[123,456]\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShape(F32, {123, 456});\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n@@ -4566,7 +4603,7 @@ TEST_F(HloParserTest, ParseShapeStringR2F32) {\n \n TEST_F(HloParserTest, ParseShapeStringUnbounded) {\n   std::string shape_string = \"f32[?,784]\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected =\n       ShapeUtil::MakeShape(F32, {Shape::kUnboundedSize, 784}, {true, false});\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n@@ -4576,7 +4613,7 @@ TEST_F(HloParserTest, ParseShapeStringUnbounded) {\n \n TEST_F(HloParserTest, ParseShapeStringTupleOfArrays) {\n   std::string shape_string = \"(f32[1572864],s8[5120,1024])\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected =\n       ShapeUtil::MakeTupleShape({ShapeUtil::MakeShape(F32, {1572864}),\n                                  ShapeUtil::MakeShape(S8, {5120, 1024})});\n@@ -4587,7 +4624,7 @@ TEST_F(HloParserTest, ParseShapeStringTupleOfArrays) {\n \n TEST_F(HloParserTest, ParseShapeStringNestedTuple) {\n   std::string shape_string = \"(f32[1],(f32[2], token[]), opaque[], f32[3])\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeTupleShape({\n       ShapeUtil::MakeShape(F32, {1}),\n       ShapeUtil::MakeTupleShape(\n@@ -4602,7 +4639,7 @@ TEST_F(HloParserTest, ParseShapeStringNestedTuple) {\n \n TEST_F(HloParserTest, ParseShapeStringWithLayout) {\n   std::string shape_string = \"f32[123,456]{0,1}\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShapeWithDenseLayout(F32, {123, 456}, {0, 1});\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n@@ -4612,7 +4649,7 @@ TEST_F(HloParserTest, ParseShapeStringWithLayout) {\n TEST_F(HloParserTest, ParseShapeStringWithTilingLayout) {\n   // One tile.\n   std::string shape_string = \"f32[123,456]{0,1:T(2,128)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShapeWithDenseLayout(F32, {123, 456}, {0, 1},\n                                                        {Tile({2, 128})});\n   EXPECT_EQ(expected, actual)\n@@ -4621,7 +4658,7 @@ TEST_F(HloParserTest, ParseShapeStringWithTilingLayout) {\n \n   // Tile with negative dimension size for combining dimensions.\n   shape_string = \"f32[123,456,789]{0,1,2:T(2, * , 128)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n   expected = ShapeUtil::MakeShapeWithDenseLayout(\n       F32, {123, 456, 789}, {0, 1, 2},\n       {Tile({2, Tile::kCombineDimension, 128})});\n@@ -4631,7 +4668,7 @@ TEST_F(HloParserTest, ParseShapeStringWithTilingLayout) {\n \n   // Two tiles.\n   shape_string = \"bf16[123,456,789]{2,1,0:T(2,*,128)(2,1)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n   expected = ShapeUtil::MakeShapeWithDenseLayout(\n       BF16, {123, 456, 789}, {2, 1, 0},\n       {Tile({2, Tile::kCombineDimension, 128}), Tile({2, 1})});\n@@ -4649,7 +4686,7 @@ TEST_F(HloParserTest, ParseShapeStringWithTilingLayout) {\n TEST_F(HloParserTest, ParseShapeStringWithElementSizeInBits) {\n   // Tile, element size, and memory space.\n   std::string shape_string = \"s4[123,456]{1,0:T(2,128)E(4)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShapeWithDenseLayout(S4, {123, 456}, {1, 0},\n                                                        {Tile({2, 128})}, 1, 4);\n   EXPECT_EQ(expected, actual)\n@@ -4660,7 +4697,7 @@ TEST_F(HloParserTest, ParseShapeStringWithElementSizeInBits) {\n TEST_F(HloParserTest, ParseShapeStringWithMemorySpaceLayout) {\n   // Tile, element size, and memory space.\n   std::string shape_string = \"pred[123,456]{1,0:T(2,128)S(3)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShapeWithDenseLayout(\n       PRED, {123, 456}, {1, 0}, {Tile({2, 128})}, 1, 0, 3);\n   EXPECT_EQ(expected, actual)\n@@ -4669,7 +4706,7 @@ TEST_F(HloParserTest, ParseShapeStringWithMemorySpaceLayout) {\n \n   // Element size and memory space.\n   shape_string = \"pred[123,456]{1,0:S(3)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n   expected = ShapeUtil::MakeShapeWithDenseLayout(PRED, {123, 456}, {1, 0}, {},\n                                                  1, 0, 3);\n   EXPECT_EQ(expected, actual)\n@@ -4678,7 +4715,7 @@ TEST_F(HloParserTest, ParseShapeStringWithMemorySpaceLayout) {\n \n   // Memory space only.\n   shape_string = \"pred[123,456]{1,0:S(3)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n   expected = ShapeUtil::MakeShapeWithDenseLayout(PRED, {123, 456}, {1, 0}, {},\n                                                  1, 0, 3);\n   EXPECT_EQ(expected, actual)\n@@ -4689,7 +4726,7 @@ TEST_F(HloParserTest, ParseShapeStringWithMemorySpaceLayout) {\n TEST_F(HloParserTest, ParseShapeStringWithDynamicShapeMetadataPrefix) {\n   // Tile, element size, and memory space.\n   std::string shape_string = \"f32[123,456]{1,0:T(16,128)M(1024)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShapeWithDenseLayout(F32, {123, 456}, {1, 0},\n                                                        {Tile({16, 128})});\n   expected.mutable_layout()->set_dynamic_shape_metadata_prefix_bytes(1024);\n@@ -4701,7 +4738,7 @@ TEST_F(HloParserTest, ParseShapeStringWithDynamicShapeMetadataPrefix) {\n TEST_F(HloParserTest, ParseShapeStringWithSplitConfigLayout) {\n   // Tile, memory space, and split config.\n   std::string shape_string = \"pred[123,456]{1,0:T(2,128)S(3)SC(1:200)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShapeWithDenseLayout(\n       PRED, {123, 456}, {1, 0}, {Tile({2, 128})}, 1, 0, 3,\n       {SplitConfig(1, {200})});\n@@ -4711,7 +4748,7 @@ TEST_F(HloParserTest, ParseShapeStringWithSplitConfigLayout) {\n \n   // Memory space and split config.\n   shape_string = \"pred[123,456]{1,0:S(3)SC(0:10)(1:4,5)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n   expected = ShapeUtil::MakeShapeWithDenseLayout(\n       PRED, {123, 456}, {1, 0}, {}, 1, 0, 3,\n       {SplitConfig(0, {10}), SplitConfig(1, {4, 5})});\n@@ -4721,7 +4758,7 @@ TEST_F(HloParserTest, ParseShapeStringWithSplitConfigLayout) {\n \n   // Split config only.\n   shape_string = \"pred[123,456]{1,0:SC(1:50,200)}\";\n-  TF_ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(actual, ParseShape(shape_string));\n   expected = ShapeUtil::MakeShapeWithDenseLayout(\n       PRED, {123, 456}, {1, 0}, {}, 1, 0, 0, {SplitConfig(1, {50, 200})});\n   EXPECT_EQ(expected, actual)\n@@ -4730,15 +4767,15 @@ TEST_F(HloParserTest, ParseShapeStringWithSplitConfigLayout) {\n }\n \n TEST_F(HloParserTest, ParseOpaqueType) {\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(\"opaque[]\"));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(\"opaque[]\"));\n   Shape expected = ShapeUtil::MakeOpaqueShape();\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n       << \"actual:   \" << ShapeUtil::HumanString(actual);\n }\n \n TEST_F(HloParserTest, ParseTokenType) {\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(\"token[]\"));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(\"token[]\"));\n   Shape expected = ShapeUtil::MakeTokenShape();\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n@@ -4756,7 +4793,7 @@ TEST_F(HloParserTest, ParseInvalidShapeString) {\n \n TEST_F(HloParserTest, ParseDynamicArray) {\n   std::string shape_string = \"f32[123,<=456]\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeShape(F32, {123, 456}, {false, true});\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n@@ -4765,7 +4802,7 @@ TEST_F(HloParserTest, ParseDynamicArray) {\n \n TEST_F(HloParserTest, ParseDynamicTuple) {\n   std::string shape_string = \"(f32[42], u32[<=123,<=456])\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeTupleShape(\n       {ShapeUtil::MakeShape(F32, {42}),\n        ShapeUtil::MakeShape(U32, {123, 456}, {true, true})});\n@@ -4897,7 +4934,7 @@ ENTRY InferUnaryShape {\n   ROOT v = abs(a)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n }\n \n TEST_F(HloParserTest, InferBinaryShape) {\n@@ -4908,7 +4945,7 @@ ENTRY InferBinaryShape {\n   ROOT sum = add(a, b)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   EXPECT_TRUE(ShapeUtil::Equal(\n       module->entry_computation()->ComputeProgramShape().result(),\n       ShapeUtil::MakeShapeWithDenseLayout(F32, {2, 10}, {1, 0})));\n@@ -4923,7 +4960,7 @@ ENTRY InferTernaryShape {\n   ROOT select = select(p, f, t)\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   EXPECT_TRUE(ShapeUtil::Equal(\n       module->entry_computation()->ComputeProgramShape().result(),\n       ShapeUtil::MakeScalarShape(S32)));\n@@ -4950,7 +4987,7 @@ ENTRY InferDotShape {\n   ROOT dot = dot(a, b), lhs_batch_dims={0}, lhs_contracting_dims={1}, rhs_batch_dims={1}, rhs_contracting_dims={0}\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   EXPECT_TRUE(ShapeUtil::Equal(\n       module->entry_computation()->ComputeProgramShape().result(),\n       ShapeUtil::MakeShape(F32, {2}, {0})));\n@@ -4965,7 +5002,7 @@ ENTRY InferTupleShape () -> s32[2,3] {\n   ROOT get = get-tuple-element(tuple), index=1, sharding={maximal device=0}\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   EXPECT_TRUE(ShapeUtil::Equal(\n       module->entry_computation()->ComputeProgramShape().result(),\n       ShapeUtil::MakeShapeWithDenseLayout(S32, {2, 3}, {1, 0})));\n@@ -4991,7 +5028,7 @@ ENTRY InferUnaryShape {\n   ROOT conditional = conditional(p, a, c), true_computation=Negate, false_computation=Identity\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnVerifiedModule(text));\n   EXPECT_TRUE(ShapeUtil::Equal(\n       module->entry_computation()->ComputeProgramShape().result(),\n       ShapeUtil::MakeScalarShape(F32)));\n@@ -5189,8 +5226,7 @@ TEST_F(HloParserTest, ParseSingleComputation) {\n test {\n   ROOT root =  f32[1,64,10,128]{1,0,2,3} parameter(0)\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(original));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(original));\n   EXPECT_TRUE(module->entry_computation()\n                   ->ComputeProgramShape()\n                   .parameters()[0]\n@@ -5221,8 +5257,7 @@ TEST_F(HloParserTest, ParseSingleEntryComputation) {\n ENTRY test {\n   ROOT root =  f32[1,64,10,128]{1,0,2,3} parameter(0)\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(original));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(original));\n   EXPECT_TRUE(module->entry_computation()\n                   ->ComputeProgramShape()\n                   .parameters()[0]\n@@ -5247,8 +5282,7 @@ comp1 {\n comp2 {\n   ROOT root =  f32[1,64,10,128]{1,0,2,3} parameter(0)\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(original));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(original));\n   EXPECT_TRUE(module->entry_computation()\n                   ->ComputeProgramShape()\n                   .parameters()[0]\n@@ -5273,8 +5307,7 @@ ENTRY comp1 {\n comp2 {\n   ROOT root =  f32[1,64,10,128]{3,2,1,0} parameter(0)\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(original));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(original));\n   EXPECT_TRUE(module->entry_computation()\n                   ->ComputeProgramShape()\n                   .parameters()[0]\n@@ -5314,9 +5347,8 @@ ENTRY %main {\n   ROOT %async-done = s32[1024]{0} async-done(((s32[1024]{0}, s32[256]{0}, s32[]), s32[1024]{0}, u32[]) %async-start), calls=%async_wrapped\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(original));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(original));\n+  ASSERT_OK_AND_ASSIGN(\n       auto roundtrip_module,\n       ParseAndReturnUnverifiedModule(module->ToString(\n           HloPrintOptions().set_syntax_sugar_async_ops(true))));\n@@ -5698,8 +5730,7 @@ TEST_F(HloParserTest, ReplicaIdWithLayout) {\n     ROOT replica-id.18600 = u32[]{:T(128)} replica-id()\n   }\n   )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n   EXPECT_TRUE(\n       module->entry_computation()->root_instruction()->shape().has_layout());\n   EXPECT_FALSE(module->entry_computation()\n@@ -5720,8 +5751,7 @@ ENTRY %test {\n \n \n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n \n   ExpectHasSubstr(module->ToString(HloPrintOptions::ShortParsable()),\n                   \"origin={{\\\"v\\\"}}\");\n@@ -5734,8 +5764,7 @@ ENTRY %test {\n   ROOT op = ((f32[], f32[3]{0}), f32[2,3]) parameter(0),  origin={(({}, {\"v2\"}), {\"v3\"})}\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n \n   ExpectHasSubstr(module->ToString(HloPrintOptions::ShortParsable()),\n                   \"origin={(({}, {\\\"v2\\\"}), {\\\"v3\\\"})}\");\n@@ -5755,8 +5784,7 @@ ENTRY %test (Arg_0: s32[]) -> s32[] {\n   %Arg_0 = s32[] parameter(0), origin={{\"Arg_0\"}}\n   ROOT %pad_add_fusion = s32[] fusion(%Arg_0), kind=kLoop, calls=%fused_computation, origin={{\"concatenate\"}}\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n \n   auto fusion_inst = static_cast<HloFusionInstruction*>(\n       module->entry_computation()->root_instruction());\n@@ -5777,8 +5805,7 @@ TEST_F(HloParserTest, TranscendentalAccuracyMode) {\n   )\";\n   ResultAccuracy expected_result_accuracy = ResultAccuracy();\n   expected_result_accuracy.set_mode(ResultAccuracy::HIGHEST);\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n   auto* unary = module->entry_computation()->root_instruction();\n   EXPECT_THAT(unary->result_accuracy(), EqualsProto(expected_result_accuracy));\n }\n@@ -5813,8 +5840,7 @@ TEST_F(HloParserTest, TranscendentalAccuracyRtol) {\n   tolerance.set_atol(1.0);  // NOLINT\n   tolerance.set_ulps(2);\n   *expected_result_accuracy.mutable_tolerance() = tolerance;\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n   auto* unary = module->entry_computation()->root_instruction();\n   EXPECT_THAT(unary->result_accuracy(), EqualsProto(expected_result_accuracy));\n }\n@@ -5856,8 +5882,7 @@ TEST_F(HloParserTest, TranscendentalAccuracyNoConfig) {\n     ROOT %exponential = f32[] exponential(f32[] %exponent)\n   }\n   )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n   ResultAccuracy default_result_accuracy;\n   default_result_accuracy.set_mode(ResultAccuracy::DEFAULT);\n   EXPECT_THAT(\n@@ -5894,8 +5919,8 @@ TEST_F(HloParserTest,\n                 statistics={visualizing_index=1,stat-1=33,stat-2=44}\n     ROOT add-done = s32[] add-done(add-start), origin={{\"v3\"}}\n   })\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> m,\n-                          ParseAndReturnVerifiedModule(hlo));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> m,\n+                       ParseAndReturnVerifiedModule(hlo));\n   // Check the wrapped instruction.\n   HloInstruction* wrapped_instr =\n       m->entry_computation()->root_instruction()->async_wrapped_instruction();\n@@ -5942,8 +5967,7 @@ TEST_F(HloParserTest, ResultAccuracyToProto) {\n     ROOT %exponential = f32[] exponential(f32[] %exponent), result_accuracy={tolerance={rtol=0.5, atol=1.0, ulps=2}}\n   }\n   )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto module,\n-                          ParseAndReturnUnverifiedModule(hlo_string));\n+  ASSERT_OK_AND_ASSIGN(auto module, ParseAndReturnUnverifiedModule(hlo_string));\n   HloInstruction* exp_hlo_instruction =\n       module->entry_computation()->root_instruction();\n   HloInstructionProto exp_hlo_inst_proto = exp_hlo_instruction->ToProto();\n@@ -5969,7 +5993,7 @@ TEST_F(HloParserTest, ParseBufferMoreThanOneElement) {\n \n TEST_F(HloParserTest, ParseBufferScalar) {\n   std::string shape_string = \"b(s32[])\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeValidatedBufferShape(S32, {}).value();\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n@@ -5978,7 +6002,7 @@ TEST_F(HloParserTest, ParseBufferScalar) {\n \n TEST_F(HloParserTest, ParseBufferArray) {\n   std::string shape_string = \"b(f32[8,16]{1,0})\";\n-  TF_ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n+  ASSERT_OK_AND_ASSIGN(Shape actual, ParseShape(shape_string));\n   Shape expected = ShapeUtil::MakeValidatedBufferShape(F32, {8, 16}).value();\n   ASSERT_TRUE(ShapeUtil::Equal(expected, actual))\n       << \"expected: \" << ShapeUtil::HumanString(expected)\n@@ -6006,10 +6030,10 @@ ENTRY entry {\n       absl::StrFormat(hlo_template, \"mode=cross_replica,\");\n   const std::string hlo_without_mode = absl::StrFormat(hlo_template, \"\");\n \n-  TF_ASSERT_OK_AND_ASSIGN(auto module_with_mode,\n-                          ParseAndReturnVerifiedModule(hlo_with_mode));\n-  TF_ASSERT_OK_AND_ASSIGN(auto module_without_mode,\n-                          ParseAndReturnVerifiedModule(hlo_without_mode));\n+  ASSERT_OK_AND_ASSIGN(auto module_with_mode,\n+                       ParseAndReturnVerifiedModule(hlo_with_mode));\n+  ASSERT_OK_AND_ASSIGN(auto module_without_mode,\n+                       ParseAndReturnVerifiedModule(hlo_without_mode));\n   EXPECT_EQ(*module_with_mode->entry_computation(),\n             *module_without_mode->entry_computation());\n }"
        }
    ],
    "stats": {
        "total": 283,
        "additions": 155,
        "deletions": 128
    }
}