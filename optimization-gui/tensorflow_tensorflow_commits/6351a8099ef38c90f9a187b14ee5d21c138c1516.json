{
    "author": "loislo",
    "message": "[XLA:GPU] Add support for detecting infinite values in XLA GPU.\n\nThis change introduces a new debug option `xla_gpu_detect_inf` to enable checking for infinite values in kernel outputs. Similar to NaN detection, users can choose between \"none\", \"warning\", and \"fail\" modes. When enabled, additional thunks are added to the execution graph to detect and report or fail on the presence of Inf values.\n\nPiperOrigin-RevId: 831300998",
    "sha": "6351a8099ef38c90f9a187b14ee5d21c138c1516",
    "files": [
        {
            "sha": "7437dd681c89c2a1b145143f739680f8b52760ed",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_checksum.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_checksum.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -157,25 +157,6 @@ absl::Status DumpBufferDebugChecksumLog(\n   VLOG(1) << \"read \" << buffer_debug_log_proto.entries_size() << \" entries\";\n   DumpPerExecutionProtobufToFile(*hlo_module, buffer_debug_log_proto,\n                                  debug_options, \"buffer_debug_log\", nullptr);\n-  int non_zero_float_check_modules_count = 0;\n-  for (const auto& entry : buffer_debug_log_proto.entries()) {\n-    if (entry.check_type() ==\n-            BufferDebugLogEntryProto::CHECK_TYPE_FLOAT_CHECKS &&\n-        entry.checksum() > 0) {\n-      LOG(ERROR) << \"Found entry with non zero float check count \"\n-                 << entry.checksum() << \" for thunk \" << entry.thunk_id()\n-                 << \" and execution \" << entry.execution_id()\n-                 << \" for module: \\n\"\n-                 << hlo_module->ToString();\n-      non_zero_float_check_modules_count++;\n-    }\n-  }\n-  if (non_zero_float_check_modules_count > 0 &&\n-      hlo_module->config().debug_options().xla_gpu_detect_nan() ==\n-          DebugOptions::NAN_CHECK_DETECTION_MODE_FAIL) {\n-    LOG(FATAL) << \"Found \" << non_zero_float_check_modules_count\n-               << \" modules with non zero float check count\";\n-  }\n   return absl::OkStatus();\n }\n "
        },
        {
            "sha": "8149ec5c45d5fb182a98cdc4160b66f363c83f12",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_float_check.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 9,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_float_check.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -145,6 +145,12 @@ absl::Status BufferDebugFloatCheck(\n   VLOG(1) << \"HLO module ptr: \" << hlo_module;\n   VLOG(1) << \"HLO module name: \" << hlo_module->name();\n   CHECK(hlo_module != nullptr);\n+  bool nan_check_enabled =\n+      hlo_module->config().debug_options().xla_gpu_detect_nan() !=\n+      DebugOptions::DETECTION_MODE_NONE;\n+  bool inf_check_enabled =\n+      hlo_module->config().debug_options().xla_gpu_detect_inf() !=\n+      DebugOptions::DETECTION_MODE_NONE;\n \n   auto buffer_debug_log = se::gpu::BufferDebugLog<BufferDebugFloatCheckEntry>::\n       FromDeviceMemoryUnchecked(log_buffer.device_memory());\n@@ -160,6 +166,7 @@ absl::Status BufferDebugFloatCheck(\n   VLOG(1) << \"read \" << entries.size() << \" entries\";\n   auto entries_metadata = metadata_store->GetEntryMetadataBatch(entry_ids);\n   int non_zero_float_check_modules_count = 0;\n+  int non_zero_inf_check_modules_count = 0;\n   CHECK_EQ(entries.size(), entries_metadata.size());\n \n   for (int i = 0; i < entries.size(); ++i) {\n@@ -171,22 +178,37 @@ absl::Status BufferDebugFloatCheck(\n       continue;\n     }\n     if (metadata->check_type ==\n-            BufferDebugLogEntryProto::CHECK_TYPE_FLOAT_CHECKS &&\n-        entry.nan_count > 0) {\n-      LOG(ERROR) << \"Found entry with non zero float check count \"\n-                 << entry.nan_count << \" for thunk \" << entry.entry_id\n-                 << \" and execution \" << metadata->execution_id\n-                 << \" for module: \\n\"\n-                 << hlo_module->ToString();\n-      non_zero_float_check_modules_count++;\n+        BufferDebugLogEntryProto::CHECK_TYPE_FLOAT_CHECKS) {\n+      if (nan_check_enabled && entry.nan_count > 0) {\n+        LOG(ERROR) << \"Found entry with non zero float check count \"\n+                   << entry.nan_count << \" for thunk \" << entry.entry_id\n+                   << \" and execution \" << metadata->execution_id\n+                   << \" for module: \\n\"\n+                   << hlo_module->ToString();\n+        non_zero_float_check_modules_count++;\n+      }\n+      if (inf_check_enabled && entry.inf_count > 0) {\n+        LOG(ERROR) << \"Found entry with non zero inf check count \"\n+                   << entry.inf_count << \" for thunk \" << entry.entry_id\n+                   << \" and execution \" << metadata->execution_id\n+                   << \" for module: \\n\"\n+                   << hlo_module->ToString();\n+        non_zero_inf_check_modules_count++;\n+      }\n     }\n   }\n   if (non_zero_float_check_modules_count > 0 &&\n       hlo_module->config().debug_options().xla_gpu_detect_nan() ==\n-          DebugOptions::NAN_CHECK_DETECTION_MODE_FAIL) {\n+          DebugOptions::DETECTION_MODE_FAIL) {\n     LOG(FATAL) << \"Found \" << non_zero_float_check_modules_count\n                << \" modules with non zero float check count\";\n   }\n+  if (non_zero_inf_check_modules_count > 0 &&\n+      hlo_module->config().debug_options().xla_gpu_detect_inf() ==\n+          DebugOptions::DETECTION_MODE_FAIL) {\n+    LOG(FATAL) << \"Found \" << non_zero_float_check_modules_count\n+               << \" modules with non zero inf check count\";\n+  }\n   return absl::OkStatus();\n }\n "
        },
        {
            "sha": "71139279e24212f18c74fbf27c93bf0f4bb81767",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -440,8 +440,7 @@ TEST_F(ThunkBufferDebugPassTest, RecursivelyInsertsBuffersDebugChecksumThunks) {\n TEST_F(ThunkBufferDebugPassTest, InsertsBuffersDebugFloatCheckThunks) {\n   static constexpr ThunkId kTestThunkId = ThunkId(123);\n   DebugOptions debug_options;\n-  debug_options.set_xla_gpu_detect_nan(\n-      DebugOptions::NAN_CHECK_DETECTION_MODE_WARNING);\n+  debug_options.set_xla_gpu_detect_nan(DebugOptions::DETECTION_MODE_WARNING);\n   se::DeviceDescription device_info;\n   FakeThunkPassBufferAllocator allocator;\n   // The callbacks created by ThunkBufferDebugPass require a HloModule with"
        },
        {
            "sha": "1c809e39944f2b2b52da38141ff28abd2c5d1980",
            "filename": "third_party/xla/xla/debug_options_flags.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 31,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fdebug_options_flags.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fdebug_options_flags.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fdebug_options_flags.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <fstream>\n #include <limits>\n #include <memory>\n+#include <optional>\n #include <sstream>\n #include <string>\n #include <vector>\n@@ -467,8 +468,7 @@ DebugOptions DefaultDebugOptionsIgnoringFlags() {\n   opts.set_xla_gpu_experimental_enable_triton_tma(false);\n   opts.set_xla_gpu_experimental_enable_triton_warp_specialization(false);\n   opts.set_xla_gpu_experimental_enable_command_buffer_on_thunks(true);\n-  opts.set_xla_detect_unstable_reductions(\n-      DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_NONE);\n+  opts.set_xla_detect_unstable_reductions(DebugOptions::DETECTION_MODE_NONE);\n   opts.set_xla_gpu_experimental_scaled_dot_with_triton(false);\n   opts.set_xla_gpu_experimental_use_raft_select_k(false);\n \n@@ -477,7 +477,8 @@ DebugOptions DefaultDebugOptionsIgnoringFlags() {\n \n   opts.set_xla_keep_shardings_after_spmd(false);\n   opts.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(false);\n-  opts.set_xla_gpu_detect_nan(DebugOptions::NAN_CHECK_DETECTION_MODE_NONE);\n+  opts.set_xla_gpu_detect_nan(DebugOptions::DETECTION_MODE_NONE);\n+  opts.set_xla_gpu_detect_inf(DebugOptions::DETECTION_MODE_NONE);\n   return opts;\n }\n \n@@ -878,21 +879,27 @@ void MakeDebugOptionsFlags(std::vector<tsl::Flag>* flag_list,\n   };\n \n   // Custom \"sub-parser\" for xla_gpu_experimental_autotune_cache_mode.\n+  auto detection_mode = [](DebugOptions* debug_options,\n+                           const std::string& value)\n+      -> std::optional<DebugOptions::DetectionMode> {\n+    if (value == \"none\") {\n+      return DebugOptions::DETECTION_MODE_NONE;\n+    }\n+    if (value == \"warning\") {\n+      return DebugOptions::DETECTION_MODE_WARNING;\n+    }\n+    if (value == \"fail\") {\n+      return DebugOptions::DETECTION_MODE_FAIL;\n+    }\n+    return std::nullopt;\n+  };\n   auto setter_for_xla_detect_unstable_reductions =\n-      [debug_options](const std::string& value) {\n-        DebugOptions::UnstableReductionDetectionMode detection_mode;\n-        if (value == \"none\") {\n-          detection_mode = DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_NONE;\n-        } else if (value == \"warning\") {\n-          detection_mode =\n-              DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_WARNING;\n-        } else if (value == \"fail\") {\n-          detection_mode = DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_FAIL;\n-        } else {\n-          return false;\n+      [debug_options, detection_mode](const std::string& value) {\n+        if (auto mode = detection_mode(debug_options, value)) {\n+          debug_options->set_xla_detect_unstable_reductions(mode.value());\n+          return true;\n         }\n-        debug_options->set_xla_detect_unstable_reductions(detection_mode);\n-        return true;\n+        return false;\n       };\n \n   // Custom \"sub-parser\" for\n@@ -2638,7 +2645,7 @@ void MakeDebugOptionsFlags(std::vector<tsl::Flag>* flag_list,\n   flag_list->push_back(\n       tsl::Flag(\"xla_detect_unstable_reductions\",\n                 setter_for_xla_detect_unstable_reductions,\n-                DebugOptions::UnstableReductionDetectionMode_Name(\n+                DebugOptions::DetectionMode_Name(\n                     debug_options->xla_detect_unstable_reductions()),\n                 \"Controls the behavior of the unstable reduction detector pass \"\n                 \"that checks for unstable reductions in HLO computations. \"\n@@ -2702,29 +2709,38 @@ void MakeDebugOptionsFlags(std::vector<tsl::Flag>* flag_list,\n       \"Enable autotuning between the native & triton fusion emitters.\"));\n \n   auto setter_for_xla_gpu_detect_nan =\n-      [debug_options](const std::string& value) {\n-        DebugOptions::NaNCheckDetectionMode detection_mode;\n-        if (value == \"none\") {\n-          detection_mode = DebugOptions::NAN_CHECK_DETECTION_MODE_NONE;\n-        } else if (value == \"warning\") {\n-          detection_mode = DebugOptions::NAN_CHECK_DETECTION_MODE_WARNING;\n-        } else if (value == \"fail\") {\n-          detection_mode = DebugOptions::NAN_CHECK_DETECTION_MODE_FAIL;\n-        } else {\n-          return false;\n+      [debug_options, detection_mode](const std::string& value) {\n+        if (auto mode = detection_mode(debug_options, value)) {\n+          debug_options->set_xla_gpu_detect_nan(mode.value());\n+          return true;\n         }\n-        debug_options->set_xla_gpu_detect_nan(detection_mode);\n-        return true;\n+        return false;\n       };\n+\n   flag_list->push_back(tsl::Flag(\n       \"xla_gpu_detect_nan\", setter_for_xla_gpu_detect_nan,\n-      DebugOptions::NaNCheckDetectionMode_Name(\n-          debug_options->xla_gpu_detect_nan()),\n+      DebugOptions::DetectionMode_Name(debug_options->xla_gpu_detect_nan()),\n       \"Controls the behavior of the NaN detector pass that checks for presence \"\n       \"of NaN values in kernel outputs. Acceptable values are: 'none', \"\n       \"'warning', and 'fail'. 'none' is the default. If other than 'none' \"\n       \"value is provided, additional thunks will be added to detect and \"\n       \"warn or fail the execution if NaNs are detected.\"));\n+  auto setter_for_xla_gpu_detect_inf =\n+      [debug_options, detection_mode](const std::string& value) {\n+        if (auto mode = detection_mode(debug_options, value)) {\n+          debug_options->set_xla_gpu_detect_inf(mode.value());\n+          return true;\n+        }\n+        return false;\n+      };\n+  flag_list->push_back(tsl::Flag(\n+      \"xla_gpu_detect_inf\", setter_for_xla_gpu_detect_inf,\n+      DebugOptions::DetectionMode_Name(debug_options->xla_gpu_detect_inf()),\n+      \"Controls the behavior of the Inf detector pass that checks for presence \"\n+      \"of Inf values in kernel outputs. Acceptable values are: 'none', \"\n+      \"'warning', and 'fail'. 'none' is the default. If other than 'none' \"\n+      \"value is provided, additional thunks will be added to detect and \"\n+      \"warn or fail the execution if Infs are detected.\"));\n }  // NOLINT(readability/fn_size)\n \n // Allocates flag_values and flag_objects; this function must not be called more"
        },
        {
            "sha": "a7c60d54d1d9ecb46dde17fc2f7bc8d125c58f7e",
            "filename": "third_party/xla/xla/service/debug/unstable_reduction_detector.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -78,7 +78,7 @@ absl::StatusOr<bool> UnstableReductionDetector::RunImpl(\n     HloModule* module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n   if (module->config().debug_options().xla_detect_unstable_reductions() ==\n-      DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_NONE) {\n+      DebugOptions::DETECTION_MODE_NONE) {\n     return false;\n   }\n   std::vector<const HloInstruction*> unstable_reductions =\n@@ -94,7 +94,7 @@ absl::StatusOr<bool> UnstableReductionDetector::RunImpl(\n     LOG(WARNING) << \"Unstable reduction: \" << reduction->ToString();\n   }\n   if (module->config().debug_options().xla_detect_unstable_reductions() ==\n-      DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_FAIL) {\n+      DebugOptions::DETECTION_MODE_FAIL) {\n     std::string reduction_ops_string =\n         UniqueReductionOpsAsString(unstable_reductions);\n     return absl::FailedPreconditionError(absl::StrFormat("
        },
        {
            "sha": "f0a6454e2f8639bae542117e132d17e1ec54e94f",
            "filename": "third_party/xla/xla/service/debug/unstable_reduction_detector_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector_test.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -89,8 +89,7 @@ TEST(UnstableReductionDetectorTest, FailOnUnstableReductions) {\n       auto module, ParseAndReturnUnverifiedModule(kUnstableReductionHloModule));\n   module->mutable_config()\n       .mutable_debug_options()\n-      .set_xla_detect_unstable_reductions(\n-          DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_FAIL);\n+      .set_xla_detect_unstable_reductions(DebugOptions::DETECTION_MODE_FAIL);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n   EXPECT_CALL(\n@@ -117,8 +116,7 @@ TEST(UnstableReductionDetectorTest, WarningOnUnstableReduction) {\n       auto module, ParseAndReturnUnverifiedModule(kUnstableReductionHloModule));\n   module->mutable_config()\n       .mutable_debug_options()\n-      .set_xla_detect_unstable_reductions(\n-          DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_WARNING);\n+      .set_xla_detect_unstable_reductions(DebugOptions::DETECTION_MODE_WARNING);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n   EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n@@ -139,8 +137,7 @@ TEST(UnstableReductionDetectorTest, FailOnUnstableReductionNoMetadata) {\n       ParseAndReturnUnverifiedModule(kUnstableReductionNoMetadataHloModule));\n   module->mutable_config()\n       .mutable_debug_options()\n-      .set_xla_detect_unstable_reductions(\n-          DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_FAIL);\n+      .set_xla_detect_unstable_reductions(DebugOptions::DETECTION_MODE_FAIL);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n   EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n@@ -159,8 +156,7 @@ TEST(UnstableReductionDetectorTest, DoNothingOnUnstableReduction) {\n       auto module, ParseAndReturnUnverifiedModule(kUnstableReductionHloModule));\n   module->mutable_config()\n       .mutable_debug_options()\n-      .set_xla_detect_unstable_reductions(\n-          DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_NONE);\n+      .set_xla_detect_unstable_reductions(DebugOptions::DETECTION_MODE_NONE);\n   ::absl::ScopedMockLog log;\n   EXPECT_CALL(log, Log(LogSeverity::kWarning, _, _)).Times(0);\n   UnstableReductionDetector detector;\n@@ -174,8 +170,7 @@ TEST(UnstableReductionDetectorTest, NoOpUnstableReduction) {\n                                            kNoOpUnstableReductionHloModule));\n   module->mutable_config()\n       .mutable_debug_options()\n-      .set_xla_detect_unstable_reductions(\n-          DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_WARNING);\n+      .set_xla_detect_unstable_reductions(DebugOptions::DETECTION_MODE_WARNING);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n   EXPECT_CALL(log, Log(LogSeverity::kWarning, _, _)).Times(0);"
        },
        {
            "sha": "7c0c99f6464401442d13b4c0dc09159daac4ba6f",
            "filename": "third_party/xla/xla/service/gpu/gpu_compiler.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -556,7 +556,7 @@ absl::Status RunOptimizationPasses(\n   HloPassPipeline pipeline(\"optimization\");\n   AddHloVerifier(&pipeline);\n   if (debug_options.xla_detect_unstable_reductions() !=\n-      DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_NONE) {\n+      DebugOptions::DETECTION_MODE_NONE) {\n     pipeline.AddPass<UnstableReductionDetector>();\n   }\n   pipeline.AddPass<RaggedDotRewriter>();"
        },
        {
            "sha": "7023f6c7c561fa77cc1b366b6ec4dc1560d9629d",
            "filename": "third_party/xla/xla/service/gpu/gpu_executable.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_executable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_executable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_executable.cc?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -182,8 +182,10 @@ static absl::Status RunThunkPasses(const DebugOptions& debug_options,\n     pipeline.AddPass(std::make_unique<ThunkBufferDebugPass>(\n         ThunkBufferDebugPass::Mode::kChecksum));\n   }\n-  if (debug_options.xla_gpu_detect_nan() !=\n-      DebugOptions::NAN_CHECK_DETECTION_MODE_NONE) {\n+  if ((debug_options.xla_gpu_detect_nan() !=\n+       DebugOptions::DETECTION_MODE_NONE) ||\n+      (debug_options.xla_gpu_detect_inf() !=\n+       DebugOptions::DETECTION_MODE_NONE)) {\n     pipeline.AddPass(std::make_unique<ThunkBufferDebugPass>(\n         ThunkBufferDebugPass::Mode::kFloatChecker));\n   }"
        },
        {
            "sha": "42e9863e5b217cff1fc7fe3210fa666a1c684b36",
            "filename": "third_party/xla/xla/xla.proto",
            "status": "modified",
            "additions": 10,
            "deletions": 12,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fxla.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6351a8099ef38c90f9a187b14ee5d21c138c1516/third_party%2Fxla%2Fxla%2Fxla.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fxla.proto?ref=6351a8099ef38c90f9a187b14ee5d21c138c1516",
            "patch": "@@ -1308,21 +1308,19 @@ message DebugOptions {\n   // Maximum number of buffers to print when debugging buffer assignment.\n   optional int64 xla_debug_buffer_assignment_show_max = 251;\n \n-  enum UnstableReductionDetectionMode {\n-    UNSTABLE_REDUCTION_DETECTION_MODE_NONE = 0;\n-    UNSTABLE_REDUCTION_DETECTION_MODE_WARNING = 1;\n-    UNSTABLE_REDUCTION_DETECTION_MODE_FAIL = 2;\n+  enum DetectionMode {\n+    DETECTION_MODE_NONE = 0;\n+    DETECTION_MODE_WARNING = 1;\n+    DETECTION_MODE_FAIL = 2;\n   }\n   // Whether to enable checks for unstable reductions in computations.\n-  optional UnstableReductionDetectionMode xla_detect_unstable_reductions = 403;\n+  optional DetectionMode xla_detect_unstable_reductions = 403;\n \n-  enum NaNCheckDetectionMode {\n-    NAN_CHECK_DETECTION_MODE_NONE = 0;\n-    NAN_CHECK_DETECTION_MODE_WARNING = 1;\n-    NAN_CHECK_DETECTION_MODE_FAIL = 2;\n-  }\n   // Whether to enable checks for NaN values in computations.\n-  optional NaNCheckDetectionMode xla_gpu_detect_nan = 426;\n+  optional DetectionMode xla_gpu_detect_nan = 426;\n+\n+  // Whether to enable checks for Inf values in computations.\n+  optional DetectionMode xla_gpu_detect_inf = 428;\n \n   reserved 275;  // was xla_gpu_enable_mlir_emitters\n   reserved 281;  // was xla_gpu_max_mlir_kernels\n@@ -1417,7 +1415,7 @@ message DebugOptions {\n   // Note: when adding a new flag, please add it to one of the hardware-specific\n   // or hardware-agnostic sections at the top of this proto message.\n \n-  // Next id: 428\n+  // Next id: 429\n \n   // Extra options to pass to the compilation backend (e.g. LLVM); specific\n   // interpretation of these values is left to the backend."
        }
    ],
    "stats": {
        "total": 189,
        "additions": 101,
        "deletions": 88
    }
}