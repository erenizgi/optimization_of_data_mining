{
    "author": "tensorflower-gardener",
    "message": "Add helper functions for creating and inspecting symbolic dimensions and symbols\n\nSymbolic dimensions and symbols are both implemented as SymbolicExpr variables, with symbols being offset by the number of dimensions. This implementation detail was previously exposed to users of SymbolicExprContext, who had to manually calculate variable IDs. I ended having a hidden bug in the implementation of IndexingMap, so I included these free functions to make the translation less bug-prone.\n\nThe SymbolicMap tests have been updated to use these new helper functions\n\nPiperOrigin-RevId: 826053249",
    "sha": "a28d4bf9f835735a458f31811edc1261d0cb6ec7",
    "files": [
        {
            "sha": "133f869d1a85c75c80d78f16987433cb160ac11d",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map.h",
            "status": "modified",
            "additions": 36,
            "deletions": 2,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a28d4bf9f835735a458f31811edc1261d0cb6ec7/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a28d4bf9f835735a458f31811edc1261d0cb6ec7/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.h?ref=a28d4bf9f835735a458f31811edc1261d0cb6ec7",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include <cstdint>\n #include <string>\n \n+#include \"absl/log/check.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/ADT/Hashing.h\"\n #include \"llvm/ADT/SmallBitVector.h\"\n@@ -28,6 +29,39 @@ limitations under the License.\n \n namespace xla {\n \n+// SymbolicMap abstracts away the fact that dimensions and symbols are both\n+// implemented as SymbolicExpr variables. These free functions provide a way to\n+// work with them without a SymbolicMap instance.\n+inline SymbolicExpr CreateDimExpr(SymbolicExprContext* context,\n+                                  unsigned dim_id) {\n+  return context->CreateVariable(dim_id);\n+}\n+\n+inline SymbolicExpr CreateSymbolExpr(SymbolicExprContext* context,\n+                                     unsigned symbol_id, int64_t num_dims) {\n+  return context->CreateVariable(symbol_id + num_dims);\n+}\n+\n+inline bool IsDimension(SymbolicExpr expr, int64_t num_dims) {\n+  return expr.GetType() == SymbolicExprType::kVariable &&\n+         expr.GetValue() < num_dims;\n+}\n+\n+inline bool IsSymbol(SymbolicExpr expr, int64_t num_dims) {\n+  return expr.GetType() == SymbolicExprType::kVariable &&\n+         expr.GetValue() >= num_dims;\n+}\n+\n+inline int64_t GetDimensionIndex(SymbolicExpr expr, int64_t num_dims) {\n+  CHECK(IsDimension(expr, num_dims));\n+  return expr.GetValue();\n+}\n+\n+inline int64_t GetSymbolIndex(SymbolicExpr expr, int64_t num_dims) {\n+  CHECK(IsSymbol(expr, num_dims));\n+  return expr.GetValue() - num_dims;\n+}\n+\n // Maps a set of input variables to a set of output SymbolicExpr trees.\n class SymbolicMap {\n  public:\n@@ -40,10 +74,10 @@ class SymbolicMap {\n   int64_t GetNumDims() const { return num_dimensions_; }\n   int64_t GetNumSymbols() const { return num_symbols_; }\n   SymbolicExpr GetDimExpression(unsigned idx) const {\n-    return ctx_->CreateVariable(idx);\n+    return CreateDimExpr(ctx_, idx);\n   }\n   SymbolicExpr GetSymbolExpression(unsigned idx) const {\n-    return ctx_->CreateVariable(num_dimensions_ + idx);\n+    return CreateSymbolExpr(ctx_, idx, num_dimensions_);\n   }\n   int64_t GetNumResults() const { return exprs_.size(); }\n   const llvm::SmallVector<SymbolicExpr>& GetResults() const { return exprs_; }"
        },
        {
            "sha": "3f72070ddde3a7f8a5426a65b6c58b8a0c7f97b4",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_test.cc",
            "status": "modified",
            "additions": 67,
            "deletions": 55,
            "changes": 122,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a28d4bf9f835735a458f31811edc1261d0cb6ec7/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a28d4bf9f835735a458f31811edc1261d0cb6ec7/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc?ref=a28d4bf9f835735a458f31811edc1261d0cb6ec7",
            "patch": "@@ -34,10 +34,10 @@ struct SymbolicMapTest : public ::testing::Test {\n };\n \n TEST_F(SymbolicMapTest, GetSymbolAndDimExpressions) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n-  SymbolicExpr s0 = ctx.CreateVariable(2);\n-  SymbolicExpr s1 = ctx.CreateVariable(3);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n   SymbolicMap map = SymbolicMap::Get(&ctx, 2, 2, {d0 + s0, d1 * s1});\n   EXPECT_EQ(map.GetSymbolExpression(0), s0);\n   EXPECT_EQ(map.GetSymbolExpression(1), s1);\n@@ -46,10 +46,10 @@ TEST_F(SymbolicMapTest, GetSymbolAndDimExpressions) {\n }\n \n TEST_F(SymbolicMapTest, ToString) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n-  SymbolicExpr s0 = ctx.CreateVariable(2);\n-  SymbolicExpr s1 = ctx.CreateVariable(3);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n \n   SymbolicMap map = SymbolicMap::Get(&ctx, 2, 2, {d0 + s0, d1 * s1});\n   EXPECT_EQ(map.ToString(), \"(d0, d1)[s0, s1] -> ((d0 + s0), (d1 * s1))\");\n@@ -60,8 +60,10 @@ TEST_F(SymbolicMapTest, ToString) {\n   SymbolicMap dims_only = SymbolicMap::Get(&ctx, 2, 0, {d0, d1});\n   EXPECT_EQ(dims_only.ToString(), \"(d0, d1)[] -> (d0, d1)\");\n \n-  SymbolicExpr s0_no_dims = ctx.CreateVariable(0);\n-  SymbolicExpr s1_no_dims = ctx.CreateVariable(1);\n+  SymbolicExpr s0_no_dims =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/0);\n+  SymbolicExpr s1_no_dims =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/0);\n   SymbolicMap symbols_only =\n       SymbolicMap::Get(&ctx, 0, 2, {s0_no_dims, s1_no_dims});\n   EXPECT_EQ(symbols_only.ToString(), \"()[s0, s1] -> (s0, s1)\");\n@@ -70,32 +72,33 @@ TEST_F(SymbolicMapTest, ToString) {\n TEST_F(SymbolicMapTest, IsEmpty) {\n   EXPECT_TRUE(SymbolicMap::Get(&ctx, 0, 0, {}).IsEmpty());\n   EXPECT_TRUE(SymbolicMap::Get(&ctx, 2, 1, {}).IsEmpty());\n-  EXPECT_FALSE(SymbolicMap::Get(&ctx, 1, 0, {ctx.CreateVariable(0)}).IsEmpty());\n+  EXPECT_FALSE(\n+      SymbolicMap::Get(&ctx, 1, 0, {CreateDimExpr(&ctx, 0)}).IsEmpty());\n }\n \n TEST_F(SymbolicMapTest, IsIdentity) {\n   SymbolicMap true_identity = SymbolicMap::Get(\n-      &ctx, 2, 0, {ctx.CreateVariable(0), ctx.CreateVariable(1)});\n+      &ctx, 2, 0, {CreateDimExpr(&ctx, 0), CreateDimExpr(&ctx, 1)});\n   EXPECT_TRUE(true_identity.IsIdentity());\n \n   SymbolicMap true_identity_with_symbols = SymbolicMap::Get(\n-      &ctx, 2, 1, {ctx.CreateVariable(0), ctx.CreateVariable(1)});\n+      &ctx, 2, 1, {CreateDimExpr(&ctx, 0), CreateDimExpr(&ctx, 1)});\n   EXPECT_TRUE(true_identity_with_symbols.IsIdentity());\n \n   SymbolicMap few_results =\n-      SymbolicMap::Get(&ctx, 2, 0, {ctx.CreateVariable(0)});\n+      SymbolicMap::Get(&ctx, 2, 0, {CreateDimExpr(&ctx, 0)});\n   EXPECT_FALSE(few_results.IsIdentity());\n \n   SymbolicMap too_many_results = SymbolicMap::Get(\n-      &ctx, 1, 0, {ctx.CreateVariable(0), ctx.CreateVariable(1)});\n+      &ctx, 1, 0, {CreateDimExpr(&ctx, 0), CreateDimExpr(&ctx, 1)});\n   EXPECT_FALSE(too_many_results.IsIdentity());\n \n   SymbolicMap wrong_expr_type = SymbolicMap::Get(\n-      &ctx, 2, 0, {ctx.CreateVariable(0), ctx.CreateConstant(1)});\n+      &ctx, 2, 0, {CreateDimExpr(&ctx, 0), ctx.CreateConstant(1)});\n   EXPECT_FALSE(wrong_expr_type.IsIdentity());\n \n   SymbolicMap unordered_variable_id = SymbolicMap::Get(\n-      &ctx, 2, 0, {ctx.CreateVariable(1), ctx.CreateVariable(0)});\n+      &ctx, 2, 0, {CreateDimExpr(&ctx, 1), CreateDimExpr(&ctx, 0)});\n   EXPECT_FALSE(unordered_variable_id.IsIdentity());\n }\n \n@@ -117,10 +120,10 @@ TEST_F(SymbolicMapTest, GetConstantResults) {\n }\n \n TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n-  SymbolicExpr s0 = ctx.CreateVariable(2);\n-  SymbolicExpr s1 = ctx.CreateVariable(3);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n   SymbolicExpr c1 = ctx.CreateConstant(10);\n   SymbolicExpr c2 = ctx.CreateConstant(20);\n   SymbolicExpr c3 = ctx.CreateConstant(30);\n@@ -136,9 +139,9 @@ TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n \n   SymbolicMap map_change_dims = SymbolicMap::Get(&ctx, 1, 1, {d0 + s0 * c2});\n   // Replacements in the context of the NEW map (2 dims, 1 symbol)\n-  SymbolicExpr new_d0 = ctx.CreateVariable(0);\n-  SymbolicExpr new_d1 = ctx.CreateVariable(1);\n-  SymbolicExpr new_s0 = ctx.CreateVariable(2);\n+  SymbolicExpr new_d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr new_d1 = CreateDimExpr(&ctx, 1);\n+  SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n   SymbolicMap replaced_change_dims = map_change_dims.ReplaceDimsAndSymbols(\n       {new_d0 * c1 + new_d1}, {new_s0}, 2, 1);\n   EXPECT_EQ(replaced_change_dims.GetNumDims(), 2);\n@@ -148,8 +151,8 @@ TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n }\n \n TEST_F(SymbolicMapTest, Compose) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n \n   // Composition without Symbols\n   SymbolicMap map1_no_symbols = SymbolicMap::Get(&ctx, 1, 0, {d0 * 2});\n@@ -158,8 +161,10 @@ TEST_F(SymbolicMapTest, Compose) {\n   EXPECT_THAT(composed_no_symbols.GetResults(), ElementsAre((d0 + 5) * 2));\n \n   // Composition with Symbols\n-  SymbolicExpr s0_map1 = ctx.CreateVariable(/*map1_dims*/ 2);\n-  SymbolicExpr s0_map2 = ctx.CreateVariable(/*map2_dims*/ 1);\n+  SymbolicExpr s0_map1 =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+  SymbolicExpr s0_map2 =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n   SymbolicMap map1_symbols =\n       SymbolicMap::Get(&ctx, 2, 1, {d0 + s0_map1, d1 * 2});\n   SymbolicMap map2_symbols =\n@@ -168,9 +173,10 @@ TEST_F(SymbolicMapTest, Compose) {\n   EXPECT_EQ(compose_with_symbols.GetNumDims(), 1);\n   EXPECT_EQ(compose_with_symbols.GetNumSymbols(), 2);\n   SymbolicExpr new_d0 = d0;\n-  SymbolicExpr new_s0_map1 = ctx.CreateVariable(/*compose_dims*/ 1);\n+  SymbolicExpr new_s0_map1 =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n   SymbolicExpr new_s0_map2 =\n-      ctx.CreateVariable(/*compose_dims + map1_symbols.GetNumSymbols()*/ 2);\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/1);\n   EXPECT_THAT(\n       compose_with_symbols.GetResults(),\n       ElementsAre((new_d0 - 10) + new_s0_map1, (new_d0 + new_s0_map2) * 2));\n@@ -189,9 +195,13 @@ TEST_F(SymbolicMapTest, Compose) {\n       id_2dim_1sym.Compose(map1_symbols);\n   EXPECT_EQ(compose_left_with_id2dim_1sym.GetNumDims(), 2);\n   EXPECT_EQ(compose_left_with_id2dim_1sym.GetNumSymbols(), 2);\n+  // The composed map has 2 dims and 2 symbols:\n+  //    d0 and d1 (from map1_symbols)\n+  //    s0 (from id_2dim_1sym) and s0 (from map1_symbols)\n+  // The reindexed symbol from map1_symbols is the second symbol in the composed\n+  // map.\n   SymbolicExpr reindexed_map1_s0 =\n-      ctx.CreateVariable(compose_left_with_id2dim_1sym.GetNumDims() +\n-                         id_2dim_1sym.GetNumSymbols());\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n   EXPECT_THAT(compose_left_with_id2dim_1sym.GetResults(),\n               ElementsAre(d0 + reindexed_map1_s0, d1 * 2));\n }\n@@ -218,11 +228,11 @@ TEST_F(SymbolicMapTest, Replace) {\n }\n \n TEST_F(SymbolicMapTest, GetUnusedVariables) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n   // d2 is unused.\n-  SymbolicExpr s0 = ctx.CreateVariable(3);\n-  SymbolicExpr s1 = ctx.CreateVariable(4);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/3);\n+  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/3);\n   SymbolicExpr c2 = ctx.CreateConstant(2);\n \n   // Map with used and unused dims and symbols.\n@@ -260,8 +270,8 @@ TEST_F(SymbolicMapTest, GetUnusedVariables) {\n   EXPECT_EQ(no_sym_symbols.size(), 0);\n \n   // Map with only symbols\n-  s0 = ctx.CreateVariable(0);\n-  s1 = ctx.CreateVariable(1);\n+  s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/0);\n+  s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/0);\n   SymbolicMap no_dims_map = SymbolicMap::Get(&ctx, 0, 2, {s0 * s1});\n   llvm::SmallBitVector no_dim_dims = GetUnusedDimensionsBitVector(no_dims_map);\n   EXPECT_EQ(no_dim_dims.size(), 0);\n@@ -272,10 +282,10 @@ TEST_F(SymbolicMapTest, GetUnusedVariables) {\n }\n \n TEST_F(SymbolicMapTest, CompressDims) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  [[maybe_unused]] SymbolicExpr d1 = ctx.CreateVariable(1);  // Unused\n-  SymbolicExpr d2 = ctx.CreateVariable(2);\n-  SymbolicExpr s0 = ctx.CreateVariable(3);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  [[maybe_unused]] SymbolicExpr d1 = CreateDimExpr(&ctx, 1);  // Unused\n+  SymbolicExpr d2 = CreateDimExpr(&ctx, 2);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/3);\n \n   // Map: (d0, d1, d2)[s0] -> {d0 + d2, s0 * 5}\n   SymbolicMap map = SymbolicMap::Get(&ctx, 3, 1, {d0 + d2, s0 * 5});\n@@ -287,9 +297,9 @@ TEST_F(SymbolicMapTest, CompressDims) {\n   EXPECT_EQ(compressed.GetNumDims(), 2);\n   EXPECT_EQ(compressed.GetNumSymbols(), 1);\n \n-  SymbolicExpr new_d0 = ctx.CreateVariable(0);\n-  SymbolicExpr new_d1 = ctx.CreateVariable(1);\n-  SymbolicExpr new_s0 = ctx.CreateVariable(2);\n+  SymbolicExpr new_d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr new_d1 = CreateDimExpr(&ctx, 1);\n+  SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n   EXPECT_THAT(compressed.GetResults(),\n               ElementsAre(new_d0 + new_d1, new_s0 * 5));\n \n@@ -301,10 +311,11 @@ TEST_F(SymbolicMapTest, CompressDims) {\n }\n \n TEST_F(SymbolicMapTest, CompressSymbols) {\n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr s0 = ctx.CreateVariable(1);\n-  [[maybe_unused]] SymbolicExpr s1 = ctx.CreateVariable(2);  // Unused\n-  SymbolicExpr s2 = ctx.CreateVariable(3);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n+  [[maybe_unused]] SymbolicExpr s1 =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/1);  // Unused\n+  SymbolicExpr s2 = CreateSymbolExpr(&ctx, /*symbol_id=*/2, /*num_dims=*/1);\n \n   // Map: (d0)[s0, s1, s2] -> {d0 + s2, s0 * 5}\n   SymbolicMap map = SymbolicMap::Get(&ctx, 1, 3, {d0 + s2, s0 * 5});\n@@ -316,9 +327,10 @@ TEST_F(SymbolicMapTest, CompressSymbols) {\n   EXPECT_EQ(compressed.GetNumDims(), 1);\n   EXPECT_EQ(compressed.GetNumSymbols(), 2);\n \n-  SymbolicExpr new_d0 = ctx.CreateVariable(0);\n-  SymbolicExpr new_s0 = ctx.CreateVariable(1);\n-  SymbolicExpr new_s1 = ctx.CreateVariable(2);  // Original s2\n+  SymbolicExpr new_d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n+  SymbolicExpr new_s1 =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/1);  // Original s2\n   EXPECT_THAT(compressed.GetResults(),\n               ElementsAre(new_d0 + new_s1, new_s0 * 5));\n \n@@ -332,9 +344,9 @@ TEST_F(SymbolicMapTest, CompressSymbols) {\n TEST_F(SymbolicMapTest, Hashing) {\n   absl::flat_hash_set<SymbolicMap> set;\n \n-  SymbolicExpr d0 = ctx.CreateVariable(0);\n-  SymbolicExpr d1 = ctx.CreateVariable(1);\n-  SymbolicExpr s0 = ctx.CreateVariable(2);\n+  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n+  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n   SymbolicExpr c42 = ctx.CreateConstant(42);\n   SymbolicExpr c99 = ctx.CreateConstant(99);\n "
        }
    ],
    "stats": {
        "total": 160,
        "additions": 103,
        "deletions": 57
    }
}