{
    "author": "junwhanahn",
    "message": "Add more XLA executable tests\n\nPiperOrigin-RevId: 800163323",
    "sha": "6232108a43903cef73ac5c644afe8d98f5dd2047",
    "files": [
        {
            "sha": "37542b73d27e3e095454b5409cd35fcfeea6322d",
            "filename": "third_party/xla/xla/backends/cpu/nanort/ifrt_client_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc?ref=6232108a43903cef73ac5c644afe8d98f5dd2047",
            "patch": "@@ -320,7 +320,13 @@ int main(int argc, char** argv) {\n       \"ArrayImplTest.\"\n       \"MakeArraysFromHostBufferShardsAndCopyToHostBufferWithString:\"\n       // `MakeErrorArrays` is not supported in NanoIfrtClient.\n-      \"ArrayImplTest.MakeErrorArrays\";\n+      \"ArrayImplTest.MakeErrorArrays:\"\n+      // Executable returns a wrong number of devices.\n+      \"LoadedExecutableImplTest.Properties:\"\n+      // Incorrect deleted state of donated inputs.\n+      \"LoadedExecutableImplTest.Donation:\"\n+      // Analysis methods are not implemented.\n+      \"LoadedExecutableImplTest.Analysis\";\n   xla::ifrt::test_util::SetTestFilterIfNotUserSpecified(kFilter);\n \n   for (int i = 1; i < argc; i++) {"
        },
        {
            "sha": "05dc623cb3df9b139d54ec96826d34fed0fb9b7a",
            "filename": "third_party/xla/xla/python/ifrt_proxy/integration_tests/executable_impl_test_tfrt_cpu.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fexecutable_impl_test_tfrt_cpu.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fexecutable_impl_test_tfrt_cpu.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fexecutable_impl_test_tfrt_cpu.cc?ref=6232108a43903cef73ac5c644afe8d98f5dd2047",
            "patch": "@@ -24,6 +24,8 @@ int main(int argc, char** argv) {\n   const std::string disabled[] = {\n       // Executable::IsDeleted always returns false with TFRT CPU backend.\n       \"LoadedExecutableImplTest.IsDeleted\",\n+      // IFRT Proxy does not support `GetHloModules`.\n+      \"LoadedExecutableImplTest.Analysis\",\n   };\n \n   const std::string filter = absl::StrCat(\"-\", absl::StrJoin(disabled, \":\"));"
        },
        {
            "sha": "1c8a141864aeaccb078e029efb458b9e0bf09b87",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD?ref=6232108a43903cef73ac5c644afe8d98f5dd2047",
            "patch": "@@ -156,7 +156,9 @@ cc_library(\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/util/proto:proto_matchers\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\","
        },
        {
            "sha": "923cb3c949deb6ef697367237594bd49f13c48d5",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/xla_executable_impl_test_lib.cc",
            "status": "modified",
            "additions": 226,
            "deletions": 3,
            "changes": 229,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6232108a43903cef73ac5c644afe8d98f5dd2047/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc?ref=6232108a43903cef73ac5c644afe8d98f5dd2047",
            "patch": "@@ -13,13 +13,15 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n+#include <cstdint>\n #include <memory>\n #include <numeric>\n #include <optional>\n #include <utility>\n #include <vector>\n \n #include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n@@ -36,6 +38,7 @@ limitations under the License.\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n #include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/hlo/hlo_program.h\"\n #include \"xla/python/ifrt/memory.h\"\n #include \"xla/python/ifrt/shape.h\"\n@@ -46,15 +49,24 @@ limitations under the License.\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n+#include \"xla/tsl/util/proto/proto_matchers.h\"\n \n namespace xla {\n namespace ifrt {\n namespace {\n \n+using ::absl_testing::IsOk;\n+using ::absl_testing::IsOkAndHolds;\n+using ::absl_testing::StatusIs;\n+using ::testing::AnyOf;\n+using ::testing::ElementsAre;\n using ::testing::ElementsAreArray;\n+using ::testing::IsEmpty;\n+using ::testing::Not;\n+using ::testing::Optional;\n using ::testing::SizeIs;\n using ::testing::UnorderedElementsAre;\n-using ::tsl::testing::IsOkAndHolds;\n+using ::tsl::proto_testing::EquivToProto;\n \n // Serialized `ModuleOp` that does add 1.\n static const char* const module_add_one =\n@@ -86,7 +98,9 @@ absl::StatusOr<LoadedExecutableRef> CompileOnDevices(\n         device_list,\n         client->MakeDeviceList({client->addressable_devices().front()}));\n   } else {\n-    build_options.set_device_ordinal(devices.front()->Id().value());\n+    if (devices.size() == 1) {\n+      build_options.set_device_ordinal(devices.front()->Id().value());\n+    }\n     if (replicated) {\n       build_options.set_num_replicas(devices.size());\n       build_options.set_num_partitions(1);\n@@ -117,6 +131,99 @@ absl::StatusOr<LoadedExecutableRef> CompileOnDevices(\n                                   std::move(xla_compile_options));\n }\n \n+TEST(LoadedExecutableImplTest, Properties) {\n+  static constexpr absl::string_view kModule = R\"(\n+module @add_sub attributes {\n+  mhlo.num_replicas = 1 : i32,\n+  mhlo.num_partitions = 2 : i32\n+} {\n+  func.func @main(\n+    %arg0: tensor<2x3xi32> {mhlo.sharding = \"{devices=[2,1]<=[2]}\"},\n+    %arg1: tensor<2x3xi32> {mhlo.sharding = \"{replicated}\"}\n+  ) -> (\n+    tensor<2x3xi32> {mhlo.sharding = \"{replicated}\"},\n+    tensor<2x3xi32> {mhlo.sharding = \"{devices=[2,1]<=[2]}\"}\n+  ) {\n+    %0 = stablehlo.add %arg0, %arg1 : tensor<2x3xi32>\n+    %1 = stablehlo.subtract %arg0, %arg1 : tensor<2x3xi32>\n+    return %0, %1 : tensor<2x3xi32>, tensor<2x3xi32>\n+  }\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Compiler* compiler = client->GetDefaultCompiler();\n+\n+  absl::Span<Device* const> devices =\n+      client->addressable_devices().subspan(0, 2);\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      const LoadedExecutableRef executable,\n+      CompileOnDevices(client.get(), compiler, kModule, devices,\n+                       /*replicated=*/false));\n+\n+  EXPECT_EQ(executable->name(), \"add_sub\");\n+  EXPECT_EQ(executable->num_devices(), devices.size());\n+\n+  EXPECT_THAT(executable->GetParameterShardings(),\n+              Optional(ElementsAre(EquivToProto(R\"pb(\n+                                     type: OTHER\n+                                     tile_assignment_dimensions: 2\n+                                     tile_assignment_dimensions: 1\n+                                     iota_reshape_dims: 2\n+                                     iota_transpose_perm: 0\n+                                   )pb\"),\n+                                   EquivToProto(R\"pb(type: REPLICATED)pb\"))));\n+\n+  EXPECT_THAT(executable->GetOutputShardings(),\n+              Optional(ElementsAre(EquivToProto(R\"pb(type: REPLICATED)pb\"),\n+                                   EquivToProto(R\"pb(\n+                                     type: OTHER\n+                                     tile_assignment_dimensions: 2\n+                                     tile_assignment_dimensions: 1\n+                                     iota_reshape_dims: 2\n+                                     iota_transpose_perm: 0\n+                                   )pb\"))));\n+\n+  EXPECT_THAT(executable->GetOutputMemoryKinds(),\n+              AnyOf(IsOkAndHolds(ElementsAre(ElementsAre(\"device\", \"device\"))),\n+                    StatusIs(absl::StatusCode::kUnimplemented)));\n+}\n+\n+TEST(LoadedExecutableImplTest, Analysis) {\n+  static constexpr absl::string_view kModule = R\"(\n+module @add attributes {\n+  mhlo.num_replicas = 1 : i32,\n+  mhlo.num_partitions = 2 : i32\n+} {\n+  func.func @main(\n+    %arg0: tensor<2x3xi32> {mhlo.sharding = \"{devices=[2,1]<=[2]}\"}\n+  ) -> (tensor<2x3xi32> {mhlo.sharding = \"{devices=[2,1]<=[2]}\"}) {\n+    %0 = stablehlo.add %arg0, %arg0 : tensor<2x3xi32>\n+    return %0 : tensor<2x3xi32>\n+  }\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Compiler* compiler = client->GetDefaultCompiler();\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      const LoadedExecutableRef executable,\n+      CompileOnDevices(client.get(), compiler, kModule,\n+                       {client->addressable_devices().front()},\n+                       /*replicated=*/false));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(const xla::CompiledMemoryStats compiled_memory_stats,\n+                          executable->GetCompiledMemoryStats());\n+  EXPECT_GT(compiled_memory_stats.argument_size_in_bytes, 0);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      const std::vector<std::shared_ptr<xla::HloModule>> hlo_modules,\n+      executable->GetHloModules());\n+  ASSERT_EQ(hlo_modules.size(), 1);\n+  EXPECT_EQ(hlo_modules.front()->name(), \"add\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(const auto cost_analysis,\n+                          executable->GetCostAnalysis());\n+  EXPECT_THAT(cost_analysis.map(), Not(IsEmpty()));\n+}\n+\n TEST(LoadedExecutableImplTest, GetDonatableInputIndices) {\n   static const char* const multi_arg_add_all = R\"(module {\n     func.func @main(\n@@ -149,7 +256,7 @@ TEST(LoadedExecutableImplTest, GetDonatableInputIndices) {\n   }\n \n   EXPECT_THAT(donatable_input_indices,\n-              absl_testing::IsOkAndHolds(UnorderedElementsAre(0, 2)));\n+              IsOkAndHolds(UnorderedElementsAre(0, 2)));\n }\n \n TEST(LoadedExecutableImplTest, CompileAndExecute) {\n@@ -308,6 +415,122 @@ TEST(LoadedExecutableImplTest, DoNotFillStatus) {\n   EXPECT_THAT(out_data, ElementsAreArray(expected_out_data));\n }\n \n+TEST(LoadedExecutableImplTest, NoInputOutput) {\n+  static constexpr absl::string_view kModule = R\"(\n+module @nop attributes {\n+  mhlo.num_replicas = 1 : i32,\n+  mhlo.num_partitions = 2 : i32\n+} {\n+  func.func @main() {\n+    return\n+  }\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Compiler* compiler = client->GetDefaultCompiler();\n+\n+  Device* const device = client->addressable_devices().front();\n+  TF_ASSERT_OK_AND_ASSIGN(const LoadedExecutableRef executable,\n+                          CompileOnDevices(client.get(), compiler, kModule,\n+                                           {device}, /*replicated=*/false));\n+\n+  ExecuteOptions options;\n+  options.fill_status = true;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      LoadedExecutable::ExecuteResult result,\n+      executable->Execute({}, options, /*devices=*/std::nullopt));\n+\n+  TF_ASSERT_OK(result.status.Await());\n+}\n+\n+TEST(LoadedExecutableImplTest, Donation) {\n+  static constexpr absl::string_view kModule = R\"(\n+module @add_sub {\n+  func.func @main(\n+    %arg0: tensor<2x3xi32> {jax.buffer_donor = true},\n+    %arg1: tensor<2x3xi32> {jax.buffer_donor = true}\n+  ) -> (tensor<2x3xi32>, tensor<2x3xi32>) {\n+    %0 = stablehlo.add %arg0, %arg1 : tensor<2x3xi32>\n+    %1 = stablehlo.subtract %arg0, %arg1 : tensor<2x3xi32>\n+    return %0, %1 : tensor<2x3xi32>, tensor<2x3xi32>\n+  }\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Compiler* compiler = client->GetDefaultCompiler();\n+\n+  Device* const device = client->addressable_devices().front();\n+  TF_ASSERT_OK_AND_ASSIGN(const LoadedExecutableRef executable,\n+                          CompileOnDevices(client.get(), compiler, kModule,\n+                                           {device}, /*replicated=*/false));\n+\n+  // Create an input array.\n+  std::vector<ArrayRef> arrays;\n+  {\n+    ShardingRef sharding = SingleDeviceSharding::Create(device, MemoryKind());\n+    for (int i = 0; i < 2; ++i) {\n+      std::vector<int32_t> data(6);\n+      std::iota(data.begin(), data.end(), 0);\n+      TF_ASSERT_OK_AND_ASSIGN(\n+          arrays.emplace_back(),\n+          client->MakeArrayFromHostBuffer(\n+              data.data(), DType(DType::kS32), Shape({2, 3}),\n+              /*byte_strides=*/std::nullopt, sharding,\n+              Client::HostBufferSemantics::kImmutableOnlyDuringCall,\n+              /*on_done_with_host_buffer=*/{}));\n+    }\n+  }\n+\n+  // Enqueue a read operation just before donation. The scheduler must not\n+  // reorder read and donation.\n+  std::vector<int32_t> data(6);\n+  Future<> copy_future =\n+      arrays[0]->CopyToHostBuffer(data.data(), /*byte_strides=*/std::nullopt,\n+                                  ArrayCopySemantics::kAlwaysCopy);\n+\n+  LoadedExecutable::ExecuteOptions execute_options;\n+  execute_options.non_donatable_input_indices.insert(1);\n+  execute_options.fill_status = true;\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      LoadedExecutable::ExecuteResult result,\n+      executable->Execute(absl::MakeSpan(arrays), execute_options,\n+                          /*devices=*/std::nullopt));\n+\n+  // The first input array is donated to the computation, so it should have been\n+  // marked as deleted after the execution is dispatched.\n+  EXPECT_TRUE(arrays[0]->IsDeleted());\n+  EXPECT_THAT(arrays[0]->GetReadyFuture().Await(), Not(IsOk()));\n+\n+  // The second input array is marked as non-donatable in the execute option,\n+  // which should be respected by the execution.\n+  EXPECT_FALSE(arrays[1]->IsDeleted());\n+  TF_EXPECT_OK(arrays[1]->GetReadyFuture().Await());\n+\n+  // Copy will succeed as long as the ordering is preserved.\n+  TF_ASSERT_OK(copy_future.Await());\n+  EXPECT_THAT(data, ElementsAre(0, 1, 2, 3, 4, 5));\n+\n+  TF_ASSERT_OK(result.status.Await());\n+  EXPECT_THAT(result.outputs, SizeIs(2));\n+\n+  {\n+    std::vector<int32_t> output(6);\n+    TF_ASSERT_OK(result.outputs[0]\n+                     ->CopyToHostBuffer(output.data(),\n+                                        /*byte_strides=*/std::nullopt,\n+                                        ArrayCopySemantics::kAlwaysCopy)\n+                     .Await());\n+    EXPECT_THAT(output, ElementsAre(0, 2, 4, 6, 8, 10));\n+  }\n+  {\n+    std::vector<int32_t> output(6);\n+    TF_ASSERT_OK(result.outputs[1]\n+                     ->CopyToHostBuffer(output.data(),\n+                                        /*byte_strides=*/std::nullopt,\n+                                        ArrayCopySemantics::kAlwaysCopy)\n+                     .Await());\n+    EXPECT_THAT(output, ElementsAre(0, 0, 0, 0, 0, 0));\n+  }\n+}\n+\n }  // namespace\n }  // namespace ifrt\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 241,
        "additions": 237,
        "deletions": 4
    }
}