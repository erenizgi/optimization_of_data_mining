{
    "author": "pschuh",
    "message": "Implement PjRtStreamExecutorRawBuffer::CopyTo in terms of raw buffers.\n\nPiperOrigin-RevId: 822345080",
    "sha": "68ad2b30fada51479ae19d65eea9a69eeae17f0e",
    "files": [
        {
            "sha": "d20874b54ea82566bdfeef8b7273e2db6863f44e",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 10,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=68ad2b30fada51479ae19d65eea9a69eeae17f0e",
            "patch": "@@ -424,16 +424,16 @@ CommonPjRtBufferImpl::CopyToCpuMemorySpace(const xla::Shape& dst_shape,\n             *literal, dst_shape,\n             PjRtClient::HostBufferSemantics::kImmutableUntilTransferCompletes,\n             dst_raw_buffer);\n+        if (!status_or_h2d_transfer_event.ok()) {\n+          definition_event_promise->SetError(status);\n+        } else {\n+          status_or_h2d_transfer_event.value()->AndThen(\n+              [literal = std::move(literal)] {});\n+          definition_event_promise->Set(\n+              *std::move(status_or_h2d_transfer_event));\n+        }\n       } else {\n-        status_or_h2d_transfer_event =\n-            dst_raw_buffer->MakeAllocationReadyEvent();\n-      }\n-      if (!status_or_h2d_transfer_event.ok()) {\n-        definition_event_promise->SetError(status);\n-      } else {\n-        status_or_h2d_transfer_event.value()->AndThen(\n-            [literal = std::move(literal)] {});\n-        definition_event_promise->Set(*std::move(status_or_h2d_transfer_event));\n+        definition_event_promise->SetReady();\n       }\n     }\n   });\n@@ -663,7 +663,8 @@ CommonPjRtBufferImpl::CopyToMemorySpace(PjRtMemorySpace* dst_memory_space) {\n     TF_ASSIGN_OR_RETURN(auto dest_shape, client()->GetCopyDestinationShape(\n                                              on_device_shape(), memory_space(),\n                                              dst_memory_space));\n-    if (dest_shape == on_device_shape()) {\n+    if (xla::Shape::Equal().IgnoreMemorySpaceInLayout()(dest_shape,\n+                                                        on_device_shape())) {\n       return DirectCopyToMemorySpace(dst_memory_space);\n     }\n     if (!primitive_util::IsSubByteNonPredType(dest_shape.element_type())) {"
        },
        {
            "sha": "75cf106c093bdc430d8f75b7ea7c9e44696c949e",
            "filename": "third_party/xla/xla/pjrt/gpu/se_gpu_pjrt_client_test.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client_test.cc?ref=68ad2b30fada51479ae19d65eea9a69eeae17f0e",
            "patch": "@@ -1589,6 +1589,37 @@ TEST(StreamExecutorGpuClientTest, CopyToPinnedHostMemorySpace) {\n                                      *literal));\n }\n \n+TEST(StreamExecutorGpuClientTest, CopyFromPinnedHostMemorySpace) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client,\n+                          GetStreamExecutorGpuClient(DefaultOptions()));\n+  std::vector<int32_t> data{1, 2, 3, 4};\n+  Shape shape = ShapeUtil::MakeShape(S32, {4});\n+  auto device = client->addressable_devices()[0];\n+  auto* device_memory_space = *device->default_memory_space();\n+  auto* pinned_memory_space = device->memory_spaces()[1];\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto buffer,\n+      client->BufferFromHostBuffer(\n+          data.data(), shape.element_type(), shape.dimensions(),\n+          /*byte_strides=*/std::nullopt,\n+          PjRtClient::HostBufferSemantics::kImmutableOnlyDuringCall, nullptr,\n+          pinned_memory_space, /*device_layout=*/nullptr));\n+\n+  EXPECT_EQ(buffer->memory_space()->kind(), \"pinned_host\");\n+  EXPECT_TRUE(buffer->IsOnCpu());\n+\n+  EXPECT_EQ(pinned_memory_space->kind_id(), PinnedHostMemorySpace::kKindId);\n+  TF_ASSERT_OK_AND_ASSIGN(auto result,\n+                          buffer->CopyToMemorySpace(device_memory_space));\n+\n+  EXPECT_EQ(result->memory_space()->kind(), \"device\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto literal, result->ToLiteralSync());\n+  std::vector<int32_t> expected{1, 2, 3, 4};\n+  EXPECT_TRUE(LiteralTestUtil::Equal(LiteralUtil::CreateR1<int32_t>(expected),\n+                                     *literal));\n+}\n+\n TEST(StreamExecutorGpuClientTest, CopyToPinnedHostMemorySpaceInt4) {\n   TF_ASSERT_OK_AND_ASSIGN(auto client,\n                           GetStreamExecutorGpuClient(DefaultOptions()));"
        },
        {
            "sha": "b9eaa3949f77120673996f18adece5ee23f51524",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 172,
            "changes": 172,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=68ad2b30fada51479ae19d65eea9a69eeae17f0e",
            "patch": "@@ -1409,178 +1409,6 @@ PjRtStreamExecutorBuffer::GetBufferWithHold(ScopedHold::Type type) {\n   return hold;\n }\n \n-absl::StatusOr<std::pair<std::unique_ptr<PjRtBuffer>, BufferSequencingEventRef>>\n-PjRtStreamExecutorBuffer::CopyToDeviceHelper(\n-    PjRtDevice* dst_device, LocalDeviceState* dst_local_device,\n-    PjRtMemorySpace* dst_memory_space, LocalDeviceState* transfer_local_device,\n-    LocalDeviceState* src_local_device, se::Stream* transfer_stream,\n-    const TrackedDeviceBuffer& src_device_buffer) {\n-  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<PjRtStreamExecutorBuffer> py_buffer,\n-                      AllocateDestinationBuffer(\n-                          ShapeUtil::DeviceShapeToHostShape(on_device_shape()),\n-                          dst_device, dst_local_device, transfer_stream,\n-                          /*is_uninitialized_create=*/false, se_client,\n-                          /*definition_event=*/nullptr, dst_memory_space));\n-\n-  ScopedHold dst_device_buffer(py_buffer->GetBufferWithUsageHold());\n-  CHECK(dst_device_buffer.ok());\n-\n-  BufferSequencingEventRef copy_event =\n-      dst_device_buffer->definition_events()[0];\n-\n-  // Copy the leaf buffers.\n-  auto async_copy_to_device = [src_memory = src_device_buffer.device_memory(),\n-                               src_definition_events =\n-                                   src_device_buffer.definition_events(),\n-                               dst_memory = dst_device_buffer->device_memory(),\n-                               transfer_stream = std::move(transfer_stream),\n-                               copy_event,\n-                               on_device_shape{py_buffer->on_device_shape()},\n-                               src_local_device = std::move(src_local_device),\n-                               transfer_local_device =\n-                                   std::move(transfer_local_device),\n-                               dst_local_device = std::move(dst_local_device),\n-                               client = se_client]() mutable {\n-    tsl::profiler::TraceMe traceme(\n-        \"PjRtStreamExecutorBuffer::CopyToDeviceHelper::async_copy_to_\"\n-        \"device\");\n-    VLOG(3)\n-        << \"PjRtStreamExecutorBuffer::CopyToDeviceHelper::async_copy_to_device\";\n-\n-    absl::Status defined_status = src_definition_events[0]->GetDefinedStatus();\n-    // Only proceeds to transfer when the buffer doesn't hold an error.\n-    if (defined_status.ok()) {\n-      WaitForBufferDefinitionEventsOnStream(src_definition_events,\n-                                            transfer_stream);\n-\n-      const se::DeviceMemoryBase& input_buffer = src_memory->mem();\n-      const se::DeviceMemoryBase& output_buffer = dst_memory->mem();\n-      CHECK_EQ(input_buffer.size(), output_buffer.size());\n-      if (input_buffer.size() != 0) {\n-        auto status = transfer_local_device->ThenMemcpyDeviceToDevice(\n-            transfer_stream, dst_local_device->compute_stream(), input_buffer,\n-            output_buffer);\n-        if (!status.ok()) {\n-          LOG(ERROR) << \"D2D memory copy failed due to: \" << status;\n-          StallStreamOnError(transfer_local_device, transfer_stream);\n-          if (transfer_local_device == dst_local_device) {\n-            // Some copies may have been enqueued before the error was\n-            // returned, and StallStreamOnError only makes sure the\n-            // destination device is ok, so make sure that the src buffer\n-            // remains valid until after any transfers have completed.\n-            auto status =\n-                src_local_device->ThenRelease(transfer_stream, src_memory);\n-            if (!status.ok()) {\n-              LOG(ERROR) << \"ThenRelease failed due to: \" << status;\n-            }\n-          }\n-          return;\n-        }\n-      }\n-\n-      absl::Status status = client->AllocateAndRecordEvent(\n-          copy_event, transfer_local_device, transfer_stream);\n-      if (!status.ok()) {\n-        StallStreamOnError(transfer_local_device, transfer_stream);\n-        LOG(ERROR) << status;\n-        return;\n-      }\n-    } else {\n-      client->SetEventAsError(copy_event, defined_status);\n-    }\n-\n-    auto status =\n-        src_local_device->ThenRelease(transfer_stream, std::move(src_memory));\n-    if (!status.ok()) {\n-      LOG(ERROR) << \"ThenRelease failed due to: \" << status;\n-    }\n-  };\n-\n-  src_device_buffer.definition_events()[0]->ExecuteOrAddToFutureTasks(\n-      absl::StrFormat(\"async_copy_to_device_%p\", dst_device_buffer.buffer()),\n-      std::move(async_copy_to_device));\n-\n-  RecordUsage(std::move(dst_device_buffer), transfer_local_device,\n-              transfer_local_device, copy_event, transfer_stream);\n-\n-  return std::pair<std::unique_ptr<PjRtBuffer>, BufferSequencingEventRef>(\n-      std::unique_ptr<PjRtStreamExecutorBuffer>(std::move(py_buffer)),\n-      std::move(copy_event));\n-}\n-\n-absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-PjRtStreamExecutorBuffer::CopyToDeviceMemorySpace(\n-    PjRtDevice* dst_device, PjRtMemorySpace* dst_memory_space) {\n-  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n-  auto* se_device = tensorflow::down_cast<PjRtStreamExecutorDevice*>(device());\n-  // Copying across PjRtClients involves a copy through the host.\n-  if (dst_device->client() != se_client) {\n-    TF_ASSIGN_OR_RETURN(std::shared_ptr<Literal> literal, ToLiteralSync());\n-    // Avoid use-after-free on `literal` due to unsequenced move and use.\n-    Literal* literal_pointer = literal.get();\n-    absl::InlinedVector<int64_t, 4> byte_strides(\n-        literal->shape().dimensions().size());\n-    TF_RETURN_IF_ERROR(\n-        ShapeUtil::ByteStrides(literal->shape(), absl::MakeSpan(byte_strides)));\n-    return dst_device->client()->BufferFromHostBuffer(\n-        literal_pointer->untyped_data(),\n-        literal_pointer->shape().element_type(),\n-        literal_pointer->shape().dimensions(), byte_strides,\n-        PjRtStreamExecutorClient::HostBufferSemantics::kImmutableZeroCopy,\n-        [literal{std::move(literal)}]() { /* frees literal */ },\n-        dst_memory_space, /*device_layout=*/nullptr);\n-  }\n-\n-  TF_ASSIGN_OR_RETURN(\n-      LocalDeviceState * dst_local_device,\n-      tensorflow::down_cast<PjRtStreamExecutorDevice*>(dst_device)\n-          ->GetLocalDeviceState());\n-  LocalDeviceState* transfer_local_device =\n-      se_client->EnqueueD2DTransfersOnSrcStream()\n-          ? se_device->local_device_state()\n-          : dst_local_device;\n-  CHECK_EQ(dst_local_device->allocation_model(),\n-           transfer_local_device->allocation_model());\n-\n-  se::Stream* transfer_stream =\n-      transfer_local_device->GetDeviceToDeviceStream();\n-\n-  auto src_device_buffer = GetBufferWithUsageHold();\n-  if (!src_device_buffer.ok()) {\n-    return InvalidArgument(\n-        \"CopyToDevice() called on deleted or donated buffer: %s\",\n-        src_device_buffer.status().ToString());\n-  }\n-\n-  absl::StatusOr<\n-      std::pair<std::unique_ptr<PjRtBuffer>, BufferSequencingEventRef>>\n-      buffer_and_event_or = CopyToDeviceHelper(\n-          dst_device, dst_local_device, dst_memory_space, transfer_local_device,\n-          se_device->local_device_state(), transfer_stream, *src_device_buffer);\n-  if (!buffer_and_event_or.ok()) {\n-    return buffer_and_event_or.status();\n-  }\n-\n-  auto& buffer_and_event = buffer_and_event_or.value();\n-  std::unique_ptr<PjRtBuffer>& buffer = buffer_and_event.first;\n-  BufferSequencingEventRef& event = buffer_and_event.second;\n-\n-  src_device_buffer.ConvertUsageHold(transfer_stream, event,\n-                                     /*reference_held=*/true);\n-\n-  return std::move(buffer);\n-}\n-\n-absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-PjRtStreamExecutorBuffer::CopyToMemorySpace(PjRtMemorySpace* dst_memory_space) {\n-  if (dst_memory_space->devices().size() == 1) {\n-    return CopyToDeviceMemorySpace(dst_memory_space->devices()[0],\n-                                   dst_memory_space);\n-  }\n-  return Unimplemented(\"CopyToMemorySpace is not supported\");\n-}\n-\n Future<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n   absl::InlinedVector<BufferSequencingEventRef, 2> definition_events;\n   Promise<> definition_promise;"
        },
        {
            "sha": "0a70033e76446d049861cb7abae91b79a3bf60be",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=68ad2b30fada51479ae19d65eea9a69eeae17f0e",
            "patch": "@@ -621,9 +621,6 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n     return GetBufferWithHold(ScopedHold::kExternalReference);\n   }\n \n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n-      PjRtMemorySpace* dst_memory_space) override;\n-\n   Future<> GetReadyFuture() override;\n \n   // Similar to Delete, drops the buffer's reference to its associated device\n@@ -660,17 +657,6 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n   // device_buffer_ was successfully enqueued on a stream.\n   void ConvertUsageHold(TrackedDeviceBuffer* buffer, se::Stream* usage_stream,\n                         BufferSequencingEventRef event, bool reference_held);\n-\n-  absl::StatusOr<\n-      std::pair<std::unique_ptr<PjRtBuffer>, BufferSequencingEventRef>>\n-  CopyToDeviceHelper(PjRtDevice* dst_device, LocalDeviceState* dst_local_device,\n-                     PjRtMemorySpace* dst_memory_space,\n-                     LocalDeviceState* transfer_local_device,\n-                     LocalDeviceState* src_local_device,\n-                     se::Stream* transfer_stream,\n-                     const TrackedDeviceBuffer& src_device_buffer);\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToDeviceMemorySpace(\n-      PjRtDevice* dst_device, PjRtMemorySpace* dst_memory_space = nullptr);\n };\n \n // Allocates the device buffers for a buffer that will be used as the"
        },
        {
            "sha": "486100014329a6287b5a13e34349bd266c5f4bb9",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 117,
            "deletions": 6,
            "changes": 123,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68ad2b30fada51479ae19d65eea9a69eeae17f0e/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=68ad2b30fada51479ae19d65eea9a69eeae17f0e",
            "patch": "@@ -362,13 +362,17 @@ void PjRtStreamExecutorRawBuffer::CopyToLiteralAsync(\n           transfer_manager->TransferLiteralFromDevice(\n               stream, shaped_buffer, staged.get(),\n               [transpose = std::move(transpose),\n-               promise = std::move(promise).ToShared(), staged,\n+               promise = std::move(promise).ToShared(), staged, client,\n                literal = std::move(literal)](absl::Status status) mutable {\n                 if (status.ok()) {\n                   transpose->Execute(staged->untyped_data(),\n                                      literal->untyped_data());\n                 }\n-                promise->Set(std::move(status));\n+                client->async_work_runner()->Schedule(\n+                    [promise = std::move(promise),\n+                     status = std::move(status)]() {\n+                      promise->Set(std::move(status));\n+                    });\n               },\n               transfer_metadata_ptr);\n         } else {\n@@ -412,12 +416,119 @@ void PjRtStreamExecutorRawBuffer::CopyTo(\n     tsl::RCReference<PjRtDeviceEventPromise> definition_event_promise,\n     tsl::RCReference<PjRtDeviceEventPromise> src_usage_event_promise,\n     ::tsl::AsyncValueRef<bool> allocation_event) {\n-  auto status = absl::UnimplementedError(\"CopyTo not implemented\");\n-  src_usage_event_promise->SetError(status);\n   if (allocation_event) {\n-    allocation_event.SetError(status);\n+    allocation_event.SetStateConcrete();\n+  }\n+  if (dst_raw_buffer->memory_space()->client() == memory_space()->client()) {\n+    auto usage_event = BufferSequencingEvent::Create(client_->thread_pool());\n+    client_->thread_pool()->Schedule(\n+        [client = client_, local_device = local_device_,\n+         src_buffer = device_buffer_,\n+         dst_raw_buffer = std::move(dst_raw_buffer),\n+         src_raw_buffer = tsl::FormRef(this), usage_event]() {\n+          se::Stream* stream = local_device->GetDeviceToDeviceStream();\n+\n+          absl::StatusOr<EventPool::Handle> event_or =\n+              local_device->event_pool().AllocateEvent(stream->parent());\n+          if (!event_or.ok()) {\n+            client->SetEventAsError(usage_event, event_or.status());\n+            return;\n+          }\n+\n+          auto dst_buffer =\n+              tensorflow::down_cast<const PjRtStreamExecutorRawBuffer*>(\n+                  dst_raw_buffer.get())\n+                  ->device_buffer();\n+          auto dst_buffer_mem = dst_buffer->mem();\n+          client->WaitForAllocation(stream, *src_raw_buffer);\n+          client->WaitForAllocation(stream, *dst_raw_buffer);\n+          auto status = stream->MemcpyD2D(&dst_buffer_mem, src_buffer->mem(),\n+                                          dst_buffer_mem.size());\n+          if (!status.ok()) {\n+            client->SetEventAsError(usage_event, status);\n+            return;\n+          }\n+\n+          client->ThenRecordEvent(usage_event, local_device,\n+                                  std::move(event_or).value(), stream);\n+          usage_event.AndThen([src_buffer, dst_buffer]() {});\n+        });\n+\n+    definition_event_promise->Set(\n+        tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(usage_event));\n+    src_usage_event_promise->Set(\n+        tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(std::move(usage_event)));\n+  } else if (auto* src_ptr = GetHostPointer()) {\n+    auto h2d_event = dst_raw_buffer->CopyRawHostToDeviceAndReturnEvent(\n+        src_ptr, 0, GetOnDeviceSizeInBytes());\n+    if (!h2d_event.ok()) {\n+      definition_event_promise->SetError(h2d_event.status());\n+      src_usage_event_promise->SetError(h2d_event.status());\n+      return;\n+    }\n+    (*h2d_event)\n+        ->AndThen([src_usage_event_promise = std::move(src_usage_event_promise),\n+                   src_buffer = tsl::FormRef(this)]() {\n+          src_usage_event_promise->SetReady();\n+        });\n+    definition_event_promise->Set(*std::move(h2d_event));\n+    return;\n+  } else if (auto* dst_ptr = dst_raw_buffer->GetHostPointer()) {\n+    auto d2h_event =\n+        CopyRawDeviceToHostAndReturnEvent(dst_ptr, 0, GetOnDeviceSizeInBytes());\n+    if (!d2h_event.ok()) {\n+      definition_event_promise->SetError(d2h_event.status());\n+      src_usage_event_promise->SetError(d2h_event.status());\n+      return;\n+    }\n+    (*d2h_event)\n+        ->AndThen(\n+            [definition_event_promise = std::move(definition_event_promise),\n+             d2h_event = *d2h_event, dst_buffer = dst_raw_buffer]() {\n+              if (const absl::Status* error =\n+                      d2h_event->async_value()->GetErrorIfPresent()) {\n+                definition_event_promise->SetError(*error);\n+              } else {\n+                definition_event_promise->SetReady();\n+              }\n+            });\n+    src_usage_event_promise->Set(*std::move(d2h_event));\n+    return;\n+  } else {\n+    void* ptr = client_->host_memory_allocator()->AllocateRaw(\n+        tsl::Allocator::kAllocatorAlignment, GetOnDeviceSizeInBytes());\n+    std::shared_ptr<void> staging_buffer = std::shared_ptr<void>(\n+        ptr, [host_memory_allocator = client_->host_memory_allocator()](\n+                 void* ptr) { host_memory_allocator->DeallocateRaw(ptr); });\n+    auto d2h_event =\n+        CopyRawDeviceToHostAndReturnEvent(ptr, 0, GetOnDeviceSizeInBytes());\n+    if (!d2h_event.ok()) {\n+      definition_event_promise->SetError(d2h_event.status());\n+      src_usage_event_promise->SetError(d2h_event.status());\n+      return;\n+    }\n+    (*d2h_event)\n+        ->AndThen([staging_buffer, dst_raw_buffer,\n+                   definition_event_promise =\n+                       std::move(definition_event_promise),\n+                   d2h_event = *d2h_event]() {\n+          if (const absl::Status* error =\n+                  d2h_event->async_value()->GetErrorIfPresent()) {\n+            definition_event_promise->SetError(*error);\n+          } else {\n+            auto h2d_event = dst_raw_buffer->CopyRawHostToDeviceAndReturnEvent(\n+                staging_buffer.get(), 0,\n+                dst_raw_buffer->GetOnDeviceSizeInBytes());\n+            if (!h2d_event.ok()) {\n+              definition_event_promise->SetError(*error);\n+            } else {\n+              (*h2d_event)->AndThen([staging_buffer]() {});\n+              definition_event_promise->Set(*std::move(h2d_event));\n+            }\n+          }\n+        });\n+    src_usage_event_promise->Set(*std::move(d2h_event));\n   }\n-  definition_event_promise->SetError(status);\n }\n \n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 361,
        "additions": 159,
        "deletions": 202
    }
}