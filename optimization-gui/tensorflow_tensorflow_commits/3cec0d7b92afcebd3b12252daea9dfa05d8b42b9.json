{
    "author": "olegshyshkov",
    "message": "[XLA:GPU] Clean up RaggedAllToAllStartThunk rendezvous helpers.\n\nPiperOrigin-RevId: 847783200",
    "sha": "3cec0d7b92afcebd3b12252daea9dfa05d8b42b9",
    "files": [
        {
            "sha": "75e3ca5dc0eb8111bd67d9f91f9cb024462326b5",
            "filename": "third_party/xla/xla/backends/gpu/runtime/ragged_all_to_all_thunk.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 47,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3cec0d7b92afcebd3b12252daea9dfa05d8b42b9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fragged_all_to_all_thunk.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3cec0d7b92afcebd3b12252daea9dfa05d8b42b9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fragged_all_to_all_thunk.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fragged_all_to_all_thunk.cc?ref=3cec0d7b92afcebd3b12252daea9dfa05d8b42b9",
            "patch": "@@ -216,38 +216,29 @@ absl::Status RunRaggedAllToAll(\n   return future.Await();\n }\n \n-// Contains the values that are passed between host threads with rendezvous.\n-struct RendezvousValue {\n-  RankId rank;\n-  se::DeviceAddressBase output_buffer;\n-  se::Event* start_event;\n-  se::Event* end_event;\n-\n-  bool operator<(const RendezvousValue& other) const {\n-    return rank < other.rank;\n-  }\n-};\n+}  // namespace\n \n // Executes the rendezvous before the kernel start.\n // Inserts CUDA events into the stream to ensure that all devices have reached\n // the start event before the kernel starts.\n-absl::StatusOr<std::shared_ptr<std::vector<RendezvousValue>>>\n-RendezvousBeforeKernelStart(absl::string_view name,\n-                            const GpuCliqueKey& clique_key, RankId rank,\n-                            int64_t num_ranks,\n-                            const se::DeviceAddressBase& output_buffer,\n-                            se::Stream& stream, se::Event* start_event,\n-                            se::Event* end_event) {\n+absl::StatusOr<\n+    std::shared_ptr<std::vector<RaggedAllToAllStartThunk::RendezvousValue>>>\n+RaggedAllToAllStartThunk::RendezvousBeforeKernelStart(\n+    const GpuCliqueKey& clique_key, se::Stream& stream,\n+    const StreamState& state, const se::DeviceAddressBase& output_buffer) {\n+  int64_t num_ranks = clique_key.num_local_participants();\n+  const RankId& rank = state.rank;\n+\n   RendezvousValue rendezvous_value;\n   rendezvous_value.rank = rank;\n   rendezvous_value.output_buffer = output_buffer;\n-  rendezvous_value.start_event = start_event;\n-  rendezvous_value.end_event = end_event;\n+  rendezvous_value.start_event = state.start_event.get();\n+  rendezvous_value.end_event = state.end_event.get();\n \n   // Record that this device has started the memcpy ragged-all-to-all. We do\n   // this before the rendezvous to make sure that RecordEvent is called before\n   // WaitFor on another stream.\n-  RETURN_IF_ERROR(stream.RecordEvent(start_event));\n+  RETURN_IF_ERROR(stream.RecordEvent(state.start_event.get()));\n \n   auto rendezvous_fn = [](absl::Span<const RendezvousValue* const> values) {\n     std::vector<RendezvousValue> values_copy;\n@@ -260,16 +251,13 @@ RendezvousBeforeKernelStart(absl::string_view name,\n     return values_copy;\n   };\n \n-  std::string start_rendezvous_key =\n-      absl::StrFormat(\"start %s ragged-all-to-all for rank %d, clique %s\", name,\n+  std::string name =\n+      absl::StrFormat(\"start one-shot ragged-all-to-all for rank %d, clique %s\",\n                       rank.value(), clique_key.ToString());\n   ASSIGN_OR_RETURN(\n       std::shared_ptr<std::vector<RendezvousValue>> rendezvous_values,\n       Rendezvous<std::vector<RendezvousValue>>(\n-          /*name=*/\n-          start_rendezvous_key, /*key=*/clique_key,\n-          /*value=*/rendezvous_value, /*num_threads=*/num_ranks,\n-          rendezvous_fn));\n+          name, clique_key, rendezvous_value, num_ranks, rendezvous_fn));\n \n   // Wait for all devices to reach the start event. This indicates that all\n   // output buffers are ready for transfer.\n@@ -282,33 +270,32 @@ RendezvousBeforeKernelStart(absl::string_view name,\n \n // Executes the rendezvous after the kernel finish. Waits for all devices to\n // reach the end event.\n-absl::Status RendezvousAfterKernelFinish(\n-    absl::string_view name, const GpuCliqueKey& clique_key, RankId rank,\n-    int64_t num_ranks, se::Stream& stream, se::Event* end_event,\n-    const std::shared_ptr<std::vector<RendezvousValue>>& rendezvous_values) {\n+absl::Status RaggedAllToAllStartThunk::RendezvousAfterKernelFinish(\n+    const GpuCliqueKey& clique_key, se::Stream& stream,\n+    const StreamState& state,\n+    const std::vector<RendezvousValue>& rendezvous_values) {\n+  int64_t num_ranks = clique_key.num_local_participants();\n+  const RankId& rank = state.rank;\n+\n   // Record that this device has finished the memcpy ragged-all-to-all.\n-  RETURN_IF_ERROR(stream.RecordEvent(end_event));\n+  RETURN_IF_ERROR(stream.RecordEvent(state.end_event.get()));\n \n   // Do another rendezvous to make sure that we call RecordEvent for end_event\n   // before WaitFor on another stream.\n-  std::string finish_rendezvous_key =\n-      absl::StrFormat(\"finish %s ragged-all-to-all for rank %d, clique %s\",\n-                      name, rank.value(), clique_key.ToString());\n-  RETURN_IF_ERROR(Rendezvous(/*name=*/finish_rendezvous_key,\n-                             /*key=*/clique_key,\n-                             /*num_threads=*/num_ranks));\n+  std::string name = absl::StrFormat(\n+      \"finish one-shot ragged-all-to-all for rank %d, clique %s\", rank.value(),\n+      clique_key.ToString());\n+  RETURN_IF_ERROR(Rendezvous(name, clique_key, num_ranks));\n \n   // Wait for all devices to reach the end event. This indicates that all\n   // updates from other devices have arrived.\n-  for (auto& value : *rendezvous_values) {\n+  for (auto& value : rendezvous_values) {\n     RETURN_IF_ERROR(stream.WaitFor(value.end_event));\n   }\n \n   return absl::OkStatus();\n }\n \n-}  // namespace\n-\n absl::Status RaggedAllToAllStartThunk::RunOneShotRaggedAllToAll(\n     const GpuCliqueKey& clique_key, se::Stream& stream,\n     const StreamState& state, absl::Span<DeviceBufferPair const> buffers) {\n@@ -327,9 +314,7 @@ absl::Status RaggedAllToAllStartThunk::RunOneShotRaggedAllToAll(\n \n   ASSIGN_OR_RETURN(\n       std::shared_ptr<std::vector<RendezvousValue>> rendezvous_values,\n-      RendezvousBeforeKernelStart(\n-          /*name=*/\"one-shot\", clique_key, rank, num_ranks, output_buffer,\n-          stream, state.start_event.get(), state.end_event.get()));\n+      RendezvousBeforeKernelStart(clique_key, stream, state, output_buffer));\n \n   const int64_t num_updates_per_replica = config_.num_total_updates / num_ranks;\n \n@@ -344,9 +329,8 @@ absl::Status RaggedAllToAllStartThunk::RunOneShotRaggedAllToAll(\n       buffers[4].source_buffer, num_ranks, num_updates_per_replica,\n       config_.num_input_rows, config_.num_row_elements));\n \n-  return RendezvousAfterKernelFinish(\n-      /*name=*/\"one-shot\", clique_key, rank, num_ranks, stream,\n-      state.end_event.get(), rendezvous_values);\n+  return RendezvousAfterKernelFinish(clique_key, stream, state,\n+                                     *rendezvous_values);\n }\n \n RaggedAllToAllStartThunk::RaggedAllToAllStartThunk("
        },
        {
            "sha": "eb46ba6ef3b12d1822fe2950e98edd3467c14406",
            "filename": "third_party/xla/xla/backends/gpu/runtime/ragged_all_to_all_thunk.h",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3cec0d7b92afcebd3b12252daea9dfa05d8b42b9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fragged_all_to_all_thunk.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3cec0d7b92afcebd3b12252daea9dfa05d8b42b9/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fragged_all_to_all_thunk.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fragged_all_to_all_thunk.h?ref=3cec0d7b92afcebd3b12252daea9dfa05d8b42b9",
            "patch": "@@ -32,6 +32,7 @@ limitations under the License.\n #include \"xla/core/collectives/communicator.h\"\n #include \"xla/core/collectives/rank_id.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n+#include \"xla/stream_executor/device_address.h\"\n #include \"xla/stream_executor/device_address_handle.h\"\n #include \"xla/stream_executor/event.h\"\n #include \"xla/stream_executor/memory_allocation.h\"\n@@ -80,6 +81,18 @@ class RaggedAllToAllStartThunk : public CollectiveThunk {\n                                      Communicator& comm) override;\n \n  private:\n+  // Contains the values that are passed between host threads with rendezvous.\n+  struct RendezvousValue {\n+    RankId rank;\n+    se::DeviceAddressBase output_buffer;\n+    se::Event* start_event = nullptr;\n+    se::Event* end_event = nullptr;\n+\n+    bool operator<(const RendezvousValue& other) const {\n+      return rank < other.rank;\n+    }\n+  };\n+\n   struct StreamState {\n     int device_ordinal;\n     RankId rank;\n@@ -103,6 +116,21 @@ class RaggedAllToAllStartThunk : public CollectiveThunk {\n         : device_ordinal(device_ordinal), rank(rank) {}\n   };\n \n+  // Executes the rendezvous before the kernel start.\n+  // Inserts CUDA events into the stream to ensure that all devices have reached\n+  // the start event before the kernel starts.\n+  absl::StatusOr<std::shared_ptr<std::vector<RendezvousValue>>>\n+  RendezvousBeforeKernelStart(const GpuCliqueKey& clique_key,\n+                              se::Stream& stream, const StreamState& state,\n+                              const se::DeviceAddressBase& output_buffer);\n+\n+  // Executes the rendezvous after the kernel finish. Waits for all devices to\n+  // reach the end event.\n+  absl::Status RendezvousAfterKernelFinish(\n+      const GpuCliqueKey& clique_key, se::Stream& stream,\n+      const StreamState& state,\n+      const std::vector<RendezvousValue>& rendezvous_values);\n+\n   absl::Status RunOneShotRaggedAllToAll(\n       const GpuCliqueKey& clique_key, se::Stream& stream,\n       const StreamState& state, absl::Span<DeviceBufferPair const> buffers);"
        }
    ],
    "stats": {
        "total": 106,
        "additions": 59,
        "deletions": 47
    }
}