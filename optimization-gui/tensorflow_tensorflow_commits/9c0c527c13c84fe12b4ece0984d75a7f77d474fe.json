{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 812274359",
    "sha": "9c0c527c13c84fe12b4ece0984d75a7f77d474fe",
    "files": [
        {
            "sha": "e92e92105585c8cb979fa31ef24aad4634f9c869",
            "filename": "third_party/xla/xla/pjrt/abstract_tracked_device_buffer.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9c0c527c13c84fe12b4ece0984d75a7f77d474fe/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9c0c527c13c84fe12b4ece0984d75a7f77d474fe/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.cc?ref=9c0c527c13c84fe12b4ece0984d75a7f77d474fe",
            "patch": "@@ -112,15 +112,15 @@ void CommonPjRtBuffer::AcquireHoldLocked(ScopedHold* hold) {\n \n void CommonPjRtBuffer::DropUsageOrExternalHold(\n     ScopedHold::Type type, AbstractTrackedDeviceBuffer* buffer) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   CHECK(device_buffer_.get() == buffer || device_buffer_ == nullptr);\n   CHECK_GT(holds_[type], 0);\n   --holds_[type];\n }\n \n void CommonPjRtBuffer::DropDonationHold(\n     std::unique_ptr<AbstractTrackedDeviceBuffer> buffer) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   CHECK_EQ(device_buffer_.get(), nullptr);\n   device_buffer_ = std::move(buffer);\n   CHECK_GT(holds_[ScopedHold::kDonation], 0);\n@@ -218,7 +218,7 @@ void CommonPjRtBuffer::ScopedHold::ConfirmDonation() {\n \n void CommonPjRtBuffer::ConfirmDonation(\n     AbstractTrackedDeviceBuffer* device_buffer) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   CHECK_EQ(holds_[ScopedHold::kUsage], 0);\n   CHECK_EQ(holds_[ScopedHold::kExternalReference], 0);\n   CHECK_EQ(holds_[ScopedHold::kDonation], 1);\n@@ -231,7 +231,7 @@ void CommonPjRtBuffer::ScopedHold::ConvertUsageHold(\n   CHECK(ok());\n   CHECK_EQ(type(), kUsage);\n   {\n-    absl::MutexLock lock(&parent()->mu_);\n+    absl::MutexLock lock(parent()->mu_);\n     CHECK(parent()->device_buffer() == buffer() ||\n           parent()->device_buffer() == nullptr);\n     buffer()->AddUsageEvent(std::move(event));\n@@ -241,7 +241,7 @@ void CommonPjRtBuffer::ScopedHold::ConvertUsageHold(\n }\n \n std::unique_ptr<AbstractTrackedDeviceBuffer> CommonPjRtBuffer::ReleaseBuffer() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   {\n     tsl::profiler::TraceMe t1(\"Wait for donation holds\");\n     // We first wait for a donation hold to complete if there is one in\n@@ -264,7 +264,7 @@ std::unique_ptr<AbstractTrackedDeviceBuffer> CommonPjRtBuffer::ReleaseBuffer() {\n }\n \n bool CommonPjRtBuffer::IsDeleted() const {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   return device_buffer_ == nullptr;\n }\n \n@@ -277,7 +277,7 @@ absl::Status CommonPjRtBuffer::AcquireScopedRawBuffer(\n     const char* caller_name) {\n   ScopedHold device_buffer(this, ScopedHold::kUsage);\n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     // Ensure that at most one donation hold can be in progress at a time.\n     WaitForOutstandingDonationHold();\n     AcquireHoldLocked(&device_buffer);\n@@ -297,7 +297,7 @@ absl::Status CommonPjRtBuffer::AcquireScopedRawBuffer(\n \n CommonPjRtBuffer::ScopedHold CommonPjRtBuffer::GetBufferWithHold(\n     ScopedHold::Type type) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   // Ensure that at most one donation hold can be in progress at a time.\n   WaitForOutstandingDonationHold();\n   ScopedHold hold(this, type);"
        }
    ],
    "stats": {
        "total": 16,
        "additions": 8,
        "deletions": 8
    }
}