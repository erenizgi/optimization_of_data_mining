{
    "author": "tensorflower-gardener",
    "message": "Avoid copying BufferAllocations in BufferAssignment::CombineTempAllocations\n\nPiperOrigin-RevId: 812074858",
    "sha": "eaa6b35a60dea4a50e259e28a3ae322e17ea95ba",
    "files": [
        {
            "sha": "1d86a11c2fcd82af6bd7ee271319f610dc9684b1",
            "filename": "third_party/xla/xla/service/buffer_assignment.cc",
            "status": "modified",
            "additions": 82,
            "deletions": 80,
            "changes": 162,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eaa6b35a60dea4a50e259e28a3ae322e17ea95ba/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eaa6b35a60dea4a50e259e28a3ae322e17ea95ba/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc?ref=eaa6b35a60dea4a50e259e28a3ae322e17ea95ba",
            "patch": "@@ -688,10 +688,6 @@ absl::Status BufferAssignment::CombineTempAllocations(\n     const absl::flat_hash_set<BufferValue::Color>& private_stack_colors,\n     std::optional<BufferValue::Color> temp_buffer_color) {\n   VLOG(1) << \"CombineTempAllocations()\";\n-  // Stores the combined allocations.\n-  std::deque<BufferAllocation> combined_allocations;\n-  // Holds the pointer to a combined allocation of each color, if any.\n-  flat_hash_map<BufferValue::Color, BufferAllocation*> combined_allocation_map;\n \n   // Move all temp allocations into a single run at the end of the allocations\n   // vector.\n@@ -700,91 +696,97 @@ absl::Status BufferAssignment::CombineTempAllocations(\n                      [](const BufferAllocation& allocation) {\n                        return !allocation.IsPreallocatedTempBuffer();\n                      });\n+  // Stores the combined allocations.\n+  std::vector<BufferAllocation> combined_allocations;\n+  // Reserve the max possible size we'd need to ensure pointer stability.\n+  combined_allocations.reserve(allocations_.end() - first_temp_it);\n+  // Holds the pointer to a combined allocation of each color, if any.\n+  flat_hash_map<BufferValue::Color, BufferAllocation*> combined_allocation_map;\n \n   // Walk over the run of temp allocations, collecting the allocations belonging\n   // to the same color.\n-  if (first_temp_it != allocations_.end()) {\n-    for (auto it = first_temp_it; it != allocations_.end(); ++it) {\n-      BufferAllocation& temp_allocation = *it;\n-      BufferValue::Color color = temp_allocation.color();\n-      auto combined_it = combined_allocation_map.find(color);\n-      if (combined_it == combined_allocation_map.end()) {\n-        // We have found the first temp allocation of this color. Collect\n-        // the other temp allocations of the same color into it subject to the\n-        // size constraint.\n-        VLOG(1) << \"Combined temp allocation for color \" << color\n-                << \" is: \" << temp_allocation;\n-        combined_allocations.push_back(temp_allocation);\n-        combined_allocation_map.emplace(color, &combined_allocations.back());\n-        continue;\n-      }\n-      if (combined_it->second->size() + it->size() >=\n-          multiheap_size_constraint_per_heap_) {\n-        // We cannot put more into the current combined_it. So, appoint a new\n-        // combined_it.\n-        VLOG(1) << \"Due to size constraint, reset temp allocation for color \"\n-                << color << \" to: \" << temp_allocation;\n-        combined_allocations.push_back(temp_allocation);\n-        combined_allocation_map.emplace(color, &combined_allocations.back());\n-        continue;\n-      }\n+  for (auto it = first_temp_it; it != allocations_.end(); ++it) {\n+    BufferAllocation& temp_allocation = *it;\n+    BufferValue::Color color = temp_allocation.color();\n+    auto combined_it = combined_allocation_map.find(color);\n+    if (combined_it == combined_allocation_map.end()) {\n+      // We have found the first temp allocation of this color. Collect\n+      // the other temp allocations of the same color into it subject to the\n+      // size constraint.\n+      VLOG(1) << \"Combined temp allocation for color \" << color\n+              << \" is: \" << temp_allocation;\n+      combined_allocations.push_back(std::move(temp_allocation));\n+      combined_allocation_map.emplace(color, &combined_allocations.back());\n+      continue;\n+    }\n+    if (combined_it->second->size() + temp_allocation.size() >=\n+        multiheap_size_constraint_per_heap_) {\n+      // We cannot put more into the current combined_it. So, appoint a new\n+      // combined_it.\n+      VLOG(1) << \"Due to size constraint, reset temp allocation for color \"\n+              << color << \" to: \" << temp_allocation;\n+      combined_allocations.push_back(std::move(temp_allocation));\n+      combined_allocation_map.emplace(color, &combined_allocations.back());\n+      continue;\n+    }\n \n-      BufferAllocation* combined_allocation = combined_it->second;\n-      VLOG(1) << \"Combined allocation absorbing temp allocation: \"\n-              << temp_allocation;\n-\n-      // Each temp allocation is placed end-to-end, accounting for alignment.\n-      // The offset of each buffer in the combined allocation is computed from\n-      // the base offset of the allocation. For private stack color, we assume\n-      // each allocation object corresponds to one of the independent executions\n-      // of the private stack computations, so it is safe to reuse offsets in\n-      // that case.\n-      int64_t alignment = color_alignment_(color);\n-      int64_t base;\n-      bool is_private_stack = private_stack_colors.contains(color);\n-      if (is_private_stack) {\n-        base = 0;\n-        combined_allocation->set_size(std::max(base, temp_allocation.size()));\n-      } else {\n-        base = RoundUpTo(combined_allocation->size(), alignment);\n-        combined_allocation->set_size(base + temp_allocation.size());\n-      }\n-      for (const auto& buffer_offset_size : temp_allocation.assigned_buffers_) {\n-        const HloValue* value = buffer_offset_size.first;\n-        const int64_t offset = buffer_offset_size.second.offset;\n-        const int64_t size = buffer_offset_size.second.size;\n-        TF_RETURN_IF_ERROR(\n-            combined_allocation->AddAssignment(*value, base + offset, size));\n-      }\n-      if (!temp_allocation.HeapTraces().empty()) {\n-        CHECK_EQ(temp_allocation.HeapTraces().size(), 1);\n-        combined_allocation->AddHeapTrace(temp_allocation.HeapTraces().front());\n-      }\n+    // If we got here, temp_allocation is still valid, since all the paths\n+    // that `std::move` it continue.\n+    BufferAllocation* combined_allocation = combined_it->second;\n+    VLOG(1) << \"Combined allocation absorbing temp allocation: \"\n+            << temp_allocation;\n+\n+    // Each temp allocation is placed end-to-end, accounting for alignment.\n+    // The offset of each buffer in the combined allocation is computed from\n+    // the base offset of the allocation. For private stack color, we assume\n+    // each allocation object corresponds to one of the independent executions\n+    // of the private stack computations, so it is safe to reuse offsets in\n+    // that case.\n+    int64_t alignment = color_alignment_(color);\n+    int64_t base;\n+    bool is_private_stack = private_stack_colors.contains(color);\n+    if (is_private_stack) {\n+      base = 0;\n+      combined_allocation->set_size(std::max(base, temp_allocation.size()));\n+    } else {\n+      base = RoundUpTo(combined_allocation->size(), alignment);\n+      combined_allocation->set_size(base + temp_allocation.size());\n+    }\n+    for (const auto& buffer_offset_size : temp_allocation.assigned_buffers_) {\n+      const HloValue* value = buffer_offset_size.first;\n+      const int64_t offset = buffer_offset_size.second.offset;\n+      const int64_t size = buffer_offset_size.second.size;\n+      TF_RETURN_IF_ERROR(\n+          combined_allocation->AddAssignment(*value, base + offset, size));\n+    }\n+    if (!temp_allocation.HeapTraces().empty()) {\n+      CHECK_EQ(temp_allocation.HeapTraces().size(), 1);\n+      combined_allocation->AddHeapTrace(temp_allocation.HeapTraces().front());\n+    }\n \n-      if (is_private_stack) {\n-        if (temp_allocation.size() == combined_allocation->size()) {\n-          combined_allocation->peak_buffers_ = temp_allocation.peak_buffers_;\n-        }\n-      } else {\n-        combined_allocation->peak_buffers_.insert(\n-            combined_allocation->peak_buffers_.end(),\n-            temp_allocation.peak_buffers_.begin(),\n-            temp_allocation.peak_buffers_.end());\n+    if (is_private_stack) {\n+      if (temp_allocation.size() == combined_allocation->size()) {\n+        combined_allocation->peak_buffers_ = temp_allocation.peak_buffers_;\n       }\n+    } else {\n+      combined_allocation->peak_buffers_.insert(\n+          combined_allocation->peak_buffers_.end(),\n+          temp_allocation.peak_buffers_.begin(),\n+          temp_allocation.peak_buffers_.end());\n+    }\n \n-      if (temp_buffer_color.has_value()) {\n-        if (combined_allocation->color() == 0) {\n-          combined_allocation->set_color(temp_buffer_color.value());\n-        }\n+    if (temp_buffer_color.has_value()) {\n+      if (combined_allocation->color() == 0) {\n+        combined_allocation->set_color(temp_buffer_color.value());\n       }\n     }\n-    // Replace all existing temporary allocations with the new combined\n-    // allocations.\n-    allocations_.erase(first_temp_it, allocations_.end());\n-    for (BufferAllocation& combined : combined_allocations) {\n-      temp_allocation_total_size_ += combined.size();\n-      allocations_.push_back(std::move(combined));\n-    }\n+  }\n+  // Replace all existing temporary allocations with the new combined\n+  // allocations.\n+  allocations_.erase(first_temp_it, allocations_.end());\n+  for (BufferAllocation& combined : combined_allocations) {\n+    temp_allocation_total_size_ += combined.size();\n+    allocations_.push_back(std::move(combined));\n   }\n \n   // Update allocation indices to their new positions."
        }
    ],
    "stats": {
        "total": 162,
        "additions": 82,
        "deletions": 80
    }
}