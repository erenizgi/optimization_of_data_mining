{
    "author": "hhb",
    "message": "Add `PJRT_Buffer_CopyRawToHostFuture` to the PJRT C API.\n\nPiperOrigin-RevId: 845471805",
    "sha": "eca48b1b6fb331fc48f5e056f76c6b061a410733",
    "files": [
        {
            "sha": "c47d05a264835bd26dbf8d8cbe50a9ffd1a0d58c",
            "filename": "third_party/xla/xla/pjrt/c/CHANGELOG.md",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -1,5 +1,9 @@\n # PJRT C API changelog\n \n+## 0.84\n+\n+* Add `PJRT_Buffer_CopyRawToHostFuture`.\n+\n ## 0.83\n \n * Add `PJRT_AsyncHostToDeviceTransferManager_TransferLiteral`."
        },
        {
            "sha": "7dd3139bd7658c0eebc038d951b8799bea730788",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 41,
            "deletions": 3,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -104,7 +104,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Extension_Base, next);\n // Changes include:\n // * Adding a new field to the PJRT_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define PJRT_API_MINOR 83\n+#define PJRT_API_MINOR 84\n \n // The plugin should set the major_version and minor_version of\n // PJRT_Api.pjrt_api_version to be the `PJRT_API_MAJOR` and `PJRT_API_MINOR` in\n@@ -2210,6 +2210,43 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Buffer_CopyRawToHost_Args, event);\n typedef PJRT_Error* PJRT_Buffer_CopyRawToHost(\n     PJRT_Buffer_CopyRawToHost_Args* args);\n \n+struct PJRT_Buffer_CopyRawToHostFuture_Callback_Args {\n+  size_t struct_size;\n+\n+  // callback_data should be set to the one returned by\n+  // PJRT_Buffer_CopyRawToHostFuture.\n+  void* callback_data;\n+\n+  PJRT_Error_Code error_code;\n+  // error_message and error_message_size are only valid if error_code is not\n+  // PJRT_ERROR_CODE_OK.\n+  const char* error_message;\n+  size_t error_message_size;\n+  // dst is only valid if error_code is PJRT_ERROR_CODE_OK.\n+  void* dst;\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_Buffer_CopyRawToHostFuture_Callback_Args, dst);\n+\n+struct PJRT_Buffer_CopyRawToHostFuture_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+  PJRT_Buffer* buffer;\n+  int64_t offset;\n+  int64_t transfer_size;\n+  PJRT_Event* event;  // out\n+  // callback_data should be sent to the future_ready, when dst is ready.\n+  void* callback_data;  // out\n+  void (*future_ready_callback)(\n+      PJRT_Buffer_CopyRawToHostFuture_Callback_Args* args);  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_Buffer_CopyRawToHostFuture_Args,\n+                          future_ready_callback);\n+\n+// Similar to PJRT_Buffer_CopyRawToHost, but the transfer will not happen until\n+// `future_ready_callback` is invoked.\n+typedef PJRT_Error* PJRT_Buffer_CopyRawToHostFuture(\n+    PJRT_Buffer_CopyRawToHostFuture_Args* args);\n+\n struct PJRT_Buffer_CopyToDevice_Args {\n   size_t struct_size;\n   PJRT_Extension_Base* extension_start;\n@@ -2734,11 +2771,12 @@ typedef struct PJRT_Api {\n   _PJRT_API_STRUCT_FIELD(PJRT_LoadedExecutable_GetDeviceAssignment);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateErrorBuffer);\n   _PJRT_API_STRUCT_FIELD(PJRT_AsyncHostToDeviceTransferManager_TransferLiteral);\n+  _PJRT_API_STRUCT_FIELD(PJRT_Buffer_CopyRawToHostFuture);\n } PJRT_Api;\n \n enum {\n-  PJRT_Api_STRUCT_SIZE = PJRT_STRUCT_SIZE(\n-      PJRT_Api, PJRT_AsyncHostToDeviceTransferManager_TransferLiteral)\n+  PJRT_Api_STRUCT_SIZE =\n+      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Buffer_CopyRawToHostFuture)\n };\n \n #undef _PJRT_API_STRUCT_FIELD"
        },
        {
            "sha": "ce115dd3958adb15d3d80c356e7559ca8d1e5ede",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -950,6 +950,9 @@ FieldOffsetsAndSizesForVersion(int major_version, int minor_version) {\n       add_field(\"PJRT_AsyncHostToDeviceTransferManager_TransferLiteral\",\n                 kFnPtrSize);\n     }\n+    if (minor_version >= 84) {\n+      add_field(\"PJRT_Buffer_CopyRawToHostFuture\", kFnPtrSize);\n+    }\n     return version_offsets_and_sizes;\n   }\n   LOG(FATAL) << \"Unsupported API version: \" << major_version << \".\"\n@@ -1349,6 +1352,9 @@ TEST_F(PjrtCAbiTestBase, FieldOffsetsAndSizes) {\n                      PJRT_AsyncHostToDeviceTransferManager_TransferLiteral),\n             sizeof(PJRT_Api::\n                        PJRT_AsyncHostToDeviceTransferManager_TransferLiteral)}},\n+          {\"PJRT_Buffer_CopyRawToHostFuture\",\n+           {offsetof(PJRT_Api, PJRT_Buffer_CopyRawToHostFuture),\n+            sizeof(PJRT_Api::PJRT_Buffer_CopyRawToHostFuture)}},\n       };\n   ASSERT_EQ(api_->pjrt_api_version.major_version, PJRT_API_MAJOR);\n   ASSERT_EQ(api_->pjrt_api_version.minor_version, PJRT_API_MINOR);"
        },
        {
            "sha": "801328d8288165f3ef9ed2b167cd2dd2117a7dee",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -2248,6 +2248,50 @@ PJRT_Error* PJRT_Buffer_CopyRawToHost(PJRT_Buffer_CopyRawToHost_Args* args) {\n   return nullptr;\n }\n \n+PJRT_Error* PJRT_Buffer_CopyRawToHostFuture(\n+    PJRT_Buffer_CopyRawToHostFuture_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_Buffer_CopyRawToHostFuture_Args\",\n+      PJRT_Buffer_CopyRawToHostFuture_Args_STRUCT_SIZE, args->struct_size));\n+\n+  auto [promise, future] = xla::Future<void*>::MakePromise();\n+  xla::Future<> wrapped_promise = args->buffer->buffer->CopyRawToHostFuture(\n+      future, args->offset, args->transfer_size);\n+  args->event = new PJRT_Event{std::move(wrapped_promise)};\n+\n+  typedef absl::AnyInvocable<void(\n+      PJRT_Buffer_CopyRawToHostFuture_Callback_Args*) &&>\n+      Callback;\n+  auto callback = new Callback(\n+      [promise = std::move(promise)](\n+          PJRT_Buffer_CopyRawToHostFuture_Callback_Args* args) mutable {\n+        absl::Status status = ActualStructSizeIsGreaterOrEqual(\n+            \"PJRT_Buffer_CopyRawToHostFuture_Callback_Args\",\n+            PJRT_Buffer_CopyRawToHostFuture_Callback_Args_STRUCT_SIZE,\n+            args->struct_size);\n+        if (!status.ok()) {\n+          promise.Set(status);\n+          return;\n+        }\n+        if (args->error_code != PJRT_Error_Code_OK) {\n+          absl::Status error = absl::Status(\n+              pjrt::PjrtErrorCodeToStatusCode(args->error_code),\n+              absl::string_view(args->error_message, args->error_message_size));\n+          promise.Set(std::move(error));\n+          return;\n+        }\n+        promise.Set(args->dst);\n+      });\n+  args->callback_data = callback;\n+  args->future_ready_callback =\n+      +[](PJRT_Buffer_CopyRawToHostFuture_Callback_Args* args) {\n+        auto* callback = reinterpret_cast<Callback*>(args->callback_data);\n+        std::move (*callback)(args);\n+        delete callback;\n+      };\n+  return nullptr;\n+}\n+\n PJRT_Error* PJRT_Buffer_CopyToDevice(PJRT_Buffer_CopyToDevice_Args* args) {\n   PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n       \"PJRT_Buffer_CopyToDevice_Args\",\n@@ -3181,6 +3225,8 @@ PJRT_Api CreatePjrtApi(PJRT_Client_Create* create_fn,\n       pjrt::PJRT_Client_CreateErrorBuffer,\n       /*PJRT_AsyncHostToDeviceTransferManager_TransferLiteral=*/\n       pjrt::PJRT_AsyncHostToDeviceTransferManager_TransferLiteral,\n+      /*PJRT_Buffer_CopyRawToHostFuture=*/\n+      pjrt::PJRT_Buffer_CopyRawToHostFuture,\n   };\n }\n "
        },
        {
            "sha": "8fc556ae3c715092302f9ea65c3a9f0ccbd73051",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -3096,6 +3096,48 @@ Future<> PjRtCApiBuffer::CopyRawToHost(void* dst, int64_t offset,\n   return pjrt::ConvertCEventToCppFuture(args.event, api);\n }\n \n+Future<> PjRtCApiBuffer::CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                                             int64_t transfer_size) {\n+  if (pjrt_c_api()->pjrt_api_version.major_version == 0 &&\n+      pjrt_c_api()->pjrt_api_version.minor_version < 84) {\n+    return Future<>(absl::UnimplementedError(\n+        \"PJRT_Buffer_CopyRawToHostFuture requires PJRT C API version 0.84 or \"\n+        \"higher.\"));\n+  }\n+\n+  PJRT_Buffer_CopyRawToHostFuture_Args args;\n+  args.struct_size = PJRT_Buffer_CopyRawToHostFuture_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.buffer = buffer_.get();\n+  args.offset = offset;\n+  args.transfer_size = transfer_size;\n+  const PJRT_Api* api = pjrt_c_api();\n+  RETURN_FUTURE_IF_ERROR(api->PJRT_Buffer_CopyRawToHostFuture(&args), api);\n+  dst.OnReady(\n+      [callback_data = args.callback_data,\n+       callback = args.future_ready_callback](absl::StatusOr<void*> dst) {\n+        PJRT_Buffer_CopyRawToHostFuture_Callback_Args callback_args;\n+        callback_args.struct_size =\n+            PJRT_Buffer_CopyRawToHostFuture_Callback_Args_STRUCT_SIZE;\n+        if (dst.ok()) {\n+          callback_args.dst = *dst;\n+          callback_args.error_code = PJRT_Error_Code_OK;\n+          callback_args.error_message = nullptr;\n+          callback_args.error_message_size = 0;\n+        } else {\n+          callback_args.dst = nullptr;\n+          callback_args.error_code =\n+              pjrt::StatusCodeToPjrtErrorCode(dst.status().code());\n+          callback_args.error_message = dst.status().message().data();\n+          callback_args.error_message_size = dst.status().message().size();\n+        }\n+        callback_args.callback_data = callback_data;\n+        callback(&callback_args);\n+      });\n+  CHECK(args.event != nullptr);\n+  return pjrt::ConvertCEventToCppFuture(args.event, api);\n+}\n+\n absl::StatusOr<std::unique_ptr<PjRtBuffer>> PjRtCApiBuffer::CopyToMemorySpace(\n     PjRtMemorySpace* dst_memory) {\n   const PJRT_Api* api = pjrt_c_api();"
        },
        {
            "sha": "42291bc32e0e7cbb8bf0af87923ef1f1b011a24a",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -549,6 +549,9 @@ class PjRtCApiBuffer : public PjRtBuffer {\n   Future<> CopyRawToHost(void* dst, int64_t offset,\n                          int64_t transfer_size) override;\n \n+  Future<> CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n+                               int64_t transfer_size) override;\n+\n   void Delete() override;\n \n   absl::StatusOr<std::unique_ptr<ExternalReference>>"
        },
        {
            "sha": "cfe59018a804138d2c686c11c88668ed5fda84c9",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client_test.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eca48b1b6fb331fc48f5e056f76c6b061a410733/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc?ref=eca48b1b6fb331fc48f5e056f76c6b061a410733",
            "patch": "@@ -639,5 +639,38 @@ TEST(PjRtCApiClientTest, AsyncHostToDeviceTransferManagerTransferLiteral) {\n   EXPECT_TRUE(LiteralTestUtil::Equal(literal, *result_literal));\n }\n \n+TEST(PjRtCApiClientTest, CopyRawToHostFuture) {\n+  SetUpCpuPjRtApi();\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,\n+                       GetCApiClient(\"cpu\"));\n+  std::vector<float> data = {1.0f, 2.0f, 3.0f, 4.0f};\n+  std::vector<float> recv_data(4);\n+  Shape shape = ShapeUtil::MakeShape(F32, {4});\n+  ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<PjRtBuffer> buffer,\n+      client->BufferFromHostBuffer(\n+          data.data(), shape.element_type(), shape.dimensions(),\n+          /*byte_strides=*/std::nullopt,\n+          PjRtClient::HostBufferSemantics::kImmutableOnlyDuringCall, nullptr,\n+          client->memory_spaces()[0], /*device_layout=*/nullptr));\n+  auto [dst_promise, dst_future] = Future<void*>::MakePromise();\n+  ASSERT_OK_AND_ASSIGN(int64_t size, buffer->GetOnDeviceSizeInBytes());\n+  auto result = buffer->CopyRawToHostFuture(dst_future, 0, size);\n+\n+  // Fulfill the promise with a valid host buffer.\n+  dst_promise.Set(recv_data.data());\n+  EXPECT_OK(result.Await());\n+  ASSERT_EQ(recv_data.size(), data.size());\n+  EXPECT_THAT(recv_data, ElementsAreArray(data));\n+\n+  // Test error case.\n+  auto [error_dst_promise, error_dst_future] = Future<void*>::MakePromise();\n+  result = buffer->CopyRawToHostFuture(error_dst_future, 0, size);\n+  error_dst_promise.Set(absl::InternalError(\"Future error\"));\n+  absl::Status status = result.Await();\n+  EXPECT_EQ(status.code(), absl::StatusCode::kInternal);\n+  EXPECT_EQ(status.message(), \"Future error\");\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 178,
        "additions": 175,
        "deletions": 3
    }
}