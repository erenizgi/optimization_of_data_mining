{
    "author": "toli-y",
    "message": "Eliminate using of const_cast\n\nPiperOrigin-RevId: 802709280",
    "sha": "e994de383eda709fef9733b11906b2c2dc61df91",
    "files": [
        {
            "sha": "33ddc2e1ebada9f618740b160614c74466ec17c2",
            "filename": "third_party/xla/xla/hlo/ir/hlo_casting_utils.h",
            "status": "modified",
            "additions": 17,
            "deletions": 7,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e994de383eda709fef9733b11906b2c2dc61df91/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_casting_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e994de383eda709fef9733b11906b2c2dc61df91/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_casting_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_casting_utils.h?ref=e994de383eda709fef9733b11906b2c2dc61df91",
            "patch": "@@ -48,39 +48,49 @@ inline std::string WrongCastError(const HloInstruction* instr) {\n       \"HloInstruction '%s' is of type '%s' and cannot be downcasted to '%s.'\",\n       instr->name(), TypeName(instr), TypeName<T>());\n }\n+\n+template <typename T, typename I>\n+inline T* CastImpl(I* instr) {\n+  CHECK(instr != nullptr);\n+  CHECK(T::ClassOf(instr)) << cast_internal::WrongCastError<T>(instr);\n+  return tsl::down_cast<T*>(instr);\n+}\n+\n+template <typename T, typename I>\n+inline T* DynCastImpl(I* instr) {\n+  CHECK(instr != nullptr);\n+  return !T::ClassOf(instr) ? nullptr : tsl::down_cast<T*>(instr);\n+}\n }  // namespace cast_internal\n \n // Downcasts a const HloInstruction pointer. Dies if argument is nullptr or\n // TargetClass::ClassOf() does not match. Similar to LLVM's cast.\n template <typename T>\n const T* Cast(const HloInstruction* instr) {\n-  CHECK(instr != nullptr);\n-  CHECK(T::ClassOf(instr)) << cast_internal::WrongCastError<T>(instr);\n-  return tsl::down_cast<const T*>(instr);\n+  return cast_internal::CastImpl<const T>(instr);\n }\n \n // Downcasts a non-const HloInstruction pointer. Dies if argument is nullptr or\n // TargetClass::ClassOf() does not match. Similar to LLVM's cast.\n template <typename T>\n T* Cast(HloInstruction* instr) {\n-  return const_cast<T*>(Cast<T>(const_cast<const HloInstruction*>(instr)));\n+  return cast_internal::CastImpl<T>(instr);\n }\n \n // Downcasts a const HloInstruction pointer or returns nullptr if\n // TargetClass::ClassOf() does not match. Dies if argument is nullptr. Similar\n // to LLVM's dyn_cast.\n template <typename T>\n const T* DynCast(const HloInstruction* i) {\n-  CHECK(i != nullptr);\n-  return !T::ClassOf(i) ? nullptr : tsl::down_cast<const T*>(i);\n+  return cast_internal::DynCastImpl<const T>(i);\n }\n \n // Downcasts a non-const HloInstruction pointer or returns nullptr if\n // TargetClass::ClassOf() does not match. Dies if argument is nullptr. Similar\n // to LLVM's dyn_cast.\n template <typename T>\n T* DynCast(HloInstruction* i) {\n-  return const_cast<T*>(DynCast<T>(const_cast<const HloInstruction*>(i)));\n+  return cast_internal::DynCastImpl<T>(i);\n }\n \n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 24,
        "additions": 17,
        "deletions": 7
    }
}