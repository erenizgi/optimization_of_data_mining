{
    "author": "bartchr808",
    "message": "Delete old Shard Map import code path that isn't needed anymore.\n\nPiperOrigin-RevId: 827665914",
    "sha": "ed6e3fa1fadbb39c5e36e15dcc3c328f9e3d3ee8",
    "files": [
        {
            "sha": "c0edc9df9ddd77255d358c67750770e76122320f",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/shard_map_import.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 15,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ed6e3fa1fadbb39c5e36e15dcc3c328f9e3d3ee8/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fshard_map_import.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ed6e3fa1fadbb39c5e36e15dcc3c328f9e3d3ee8/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fshard_map_import.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fshard_map_import.cc?ref=ed6e3fa1fadbb39c5e36e15dcc3c328f9e3d3ee8",
            "patch": "@@ -133,17 +133,15 @@ mlir::LogicalResult rewriteManualComputation(\n   sdy::TensorShardingPerValueAttr outShardings =\n       sdy::TensorShardingPerValueAttr::get(context, {});\n   sdy::ManualAxesAttr manualAxes = sdy::ManualAxesAttr::get(context, {});\n-  bool newCodePath = false;\n \n-  auto setShardingAttrs = [&newCodePath, &manualAxes](\n+  auto setShardingAttrs = [&manualAxes](\n                               CustomCallOp customCallOp,\n                               sdy::TensorShardingPerValueAttr& shardings,\n                               llvm::StringRef shardingAttrName) {\n     if (!customCallOp) {\n       return;\n     }\n     if (mlir::DictionaryAttr frontendAttrs = getFrontendAttrs(customCallOp)) {\n-      newCodePath = true;\n       shardings = parseStringAttr<sdy::TensorShardingPerValueAttr>(\n           frontendAttrs, shardingAttrName);\n       if (manualAxes.empty()) {\n@@ -155,18 +153,6 @@ mlir::LogicalResult rewriteManualComputation(\n \n   setShardingAttrs(globalToLocalShape, inShardings, kInShardings);\n   setShardingAttrs(localToGlobalShape, outShardings, kOutShardings);\n-  // TODO(b/410499196): Code to handle loading an old checkpoint. Remove after\n-  // 6 months of cl/745735176 being submitted.\n-  mlir::DictionaryAttr callOpFrontendAttrs = getFrontendAttrs(callOp);\n-  if (!newCodePath && callOpFrontendAttrs &&\n-      callOpFrontendAttrs.contains(kManualAxes)) {\n-    inShardings = parseStringAttr<sdy::TensorShardingPerValueAttr>(\n-        callOpFrontendAttrs, kInShardings);\n-    outShardings = parseStringAttr<sdy::TensorShardingPerValueAttr>(\n-        callOpFrontendAttrs, kOutShardings);\n-    manualAxes =\n-        parseStringAttr<sdy::ManualAxesAttr>(callOpFrontendAttrs, kManualAxes);\n-  }\n   auto manualComputationOp =\n       rewriter.replaceOpWithNewOp<sdy::ManualComputationOp>(\n           callOp, resultTypes, operands, inShardings, outShardings, manualAxes);"
        },
        {
            "sha": "611044113035fd47692716696017a9f8be842329",
            "filename": "third_party/xla/xla/service/spmd/shardy/test/sdy_round_trip_shard_map_import_legacy_code_path.mlir",
            "status": "removed",
            "additions": 0,
            "deletions": 265,
            "changes": 265,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4e819a83847bddd926720ccfec15c33a902f7a20/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import_legacy_code_path.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4e819a83847bddd926720ccfec15c33a902f7a20/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import_legacy_code_path.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import_legacy_code_path.mlir?ref=4e819a83847bddd926720ccfec15c33a902f7a20",
            "patch": "@@ -1,265 +0,0 @@\n-// RUN: sdy_opt %s -xla-sdy-round-trip-shard-map-import 2>&1 | FileCheck %s\n-\n-sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n-sdy.mesh @mesh_1 = <[\"a\"=2, \"b\"=2, \"c\"=2, \"d\"=2]>\n-\n-// CHECK-LABEL: func @single_manual_comp\n-func.func @single_manual_comp(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body\n-  // CHECK:               %[[MAN_COMP:.*]] = sdy.manual_computation(%arg0, %arg1)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"a\", \"b\"}\n-  // CHECK-SAME:              (%arg2: tensor<2x8xf32>, %arg3: tensor<8x32xf32>) {\n-  // CHECK-NEXT:            %[[ADD_0:.*]] = stablehlo.add %arg2, %arg2 : tensor<2x8xf32>\n-  // CHECK-NEXT:            %[[DOT:.*]] = stablehlo.dot %[[ADD_0]], %arg3 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  // CHECK-NEXT:            %[[REDUCE:.*]] = \"stablehlo.all_reduce\"(%[[DOT]])\n-  // CHECK-NEXT:            ^bb0(%arg4: tensor<f32>, %arg5: tensor<f32>):\n-  // CHECK-NEXT:              %[[ADD_1:.*]] = stablehlo.add %arg4, %arg5 : tensor<f32>\n-  // CHECK-NEXT:              stablehlo.return %[[ADD_1]] : tensor<f32>\n-  // CHECK-NEXT:            }) : (tensor<2x32xf32>) -> tensor<2x32xf32>\n-  // CHECK-NEXT:            sdy.return %[[REDUCE]] : tensor<2x32xf32>\n-  // CHECK-NEXT:          } : (tensor<8x16xf32>, tensor<16x32xf32>) -> tensor<8x32xf32>\n-  // CHECK-NEXT:          return %[[MAN_COMP]] : tensor<8x32xf32>\n-  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n-  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  return %2 : tensor<8x32xf32>\n-}\n-\n-// CHECK-LABEL: func @single_manual_comp_name_is_not_prefix_nor_suffix\n-func.func @single_manual_comp_name_is_not_prefix_nor_suffix(%arg0: tensor<8x8xf32>) -> (tensor<8x8xf32>) {\n-  // CHECK-NOT: call @my_model.___call__.fwd.xla.sdy.manual_computation_body_14.1234\n-  // CHECK:               %[[MAN_COMP:.*]] = sdy.manual_computation(%arg0)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_0, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_0, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"a\"}\n-  // CHECK-SAME:              (%arg1: tensor<2x8xf32>) {\n-  // CHECK-NEXT:            sdy.return %arg1 : tensor<2x8xf32>\n-  // CHECK-NEXT:          } : (tensor<8x8xf32>) -> tensor<8x8xf32>\n-  // CHECK-NEXT:          return %[[MAN_COMP]] : tensor<8x8xf32>\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<8x8xf32>) -> tensor<2x8xf32>\n-  %1 = call @my_model.___call__.fwd.xla.sdy.manual_computation_body_14.1234(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}]>]>\"}} : (tensor<2x8xf32>) -> tensor<2x8xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x8xf32>) -> tensor<8x8xf32>\n-  return %2 : tensor<8x8xf32>\n-}\n-\n-// CHECK-LABEL: func @manual_comp_using_another\n-func.func @manual_comp_using_another(%arg0: tensor<8x8xf32>) -> tensor<8x8xf32> {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body_0\n-  // CHECK:               %[[MAN_COMP_0:.*]] = sdy.manual_computation(%arg0)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_0, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_0, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"a\"}\n-  // CHECK-SAME:              (%arg1: tensor<2x8xf32>) {\n-  // CHECK-NEXT:            sdy.return %arg1 : tensor<2x8xf32>\n-  // CHECK-NEXT:          } : (tensor<8x8xf32>) -> tensor<8x8xf32>\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body_1\n-  // CHECK-NEXT:          %[[MAN_COMP_1:.*]] = sdy.manual_computation(%[[MAN_COMP_0]])\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_0, [{}, {\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_0, [{}, {\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"b\"}\n-  // CHECK-SAME:              (%arg1: tensor<8x4xf32>) {\n-  // CHECK-NEXT:            sdy.return %arg1 : tensor<8x4xf32>\n-  // CHECK-NEXT:          } : (tensor<8x8xf32>) -> tensor<8x8xf32>\n-  // CHECK-NEXT:          return %[[MAN_COMP_1]] : tensor<8x8xf32>\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<8x8xf32>) -> tensor<2x8xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body_0(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}]>]>\"}} : (tensor<2x8xf32>) -> tensor<2x8xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x8xf32>) -> tensor<8x8xf32>\n-  %3 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%2) : (tensor<8x8xf32>) -> tensor<8x4xf32>\n-  %4 = call @local_xla.sdy.manual_computation_body_1(%3) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{}, {\\22b\\22}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{}, {\\22b\\22}]>]>\"}} : (tensor<8x4xf32>) -> tensor<8x4xf32>\n-  %5 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%4) : (tensor<8x4xf32>) -> tensor<8x8xf32>\n-  return %5 : tensor<8x8xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_3(\n-func.func @local_xla.sdy.manual_computation_body_3(%arg0: tensor<2x8xf32>) -> tensor<2x8xf32> {\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<2x8xf32>) -> tensor<2x4xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body_2(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{}, {\\22b\\22}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{}, {\\22b\\22}]>]>\"}} : (tensor<2x4xf32>) -> tensor<2x4xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x4xf32>) -> tensor<2x8xf32>\n-  return %2 : tensor<2x8xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_2(\n-func.func @local_xla.sdy.manual_computation_body_2(%arg0: tensor<2x4xf32>) -> tensor<2x4xf32> {\n-  %0 = stablehlo.multiply %arg0, %arg0 : tensor<2x4xf32>\n-  return %0 : tensor<2x4xf32>\n-}\n-\n-// CHECK-LABEL: func @nested_shmaps\n-func.func @nested_shmaps(%arg0: tensor<4x8xf32>) -> tensor<4x8xf32> {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body_3\n-  // CHECK:               %[[MAN_COMP_0:.*]] = sdy.manual_computation(%arg0)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_1, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_1, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"a\"}\n-  // CHECK-SAME:              (%arg1: tensor<2x8xf32>) {\n-  // CHECK-NEXT:            %[[MAN_COMP_1:.*]] = sdy.manual_computation(%arg1)\n-  // CHECK-SAME{LITERAL}:       in_shardings=[<@mesh_1, [{}, {\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:       out_shardings=[<@mesh_1, [{}, {\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:       manual_axes={\"b\"}\n-  // CHECK-SAME:                (%arg2: tensor<2x4xf32>) {\n-  // CHECK-NEXT:              %[[MULT:.*]] = stablehlo.multiply %arg2, %arg2 : tensor<2x4xf32>\n-  // CHECK-NEXT:              sdy.return %[[MULT]] : tensor<2x4xf32>\n-  // CHECK-NEXT:            } : (tensor<2x8xf32>) -> tensor<2x8xf32>\n-  // CHECK-NEXT:            sdy.return %[[MAN_COMP_1]] : tensor<2x8xf32>\n-  // CHECK-NEXT:          } : (tensor<4x8xf32>) -> tensor<4x8xf32>\n-  // CHECK-NEXT:          return %[[MAN_COMP_0]] : tensor<4x8xf32>\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<4x8xf32>) -> tensor<2x8xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body_3(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{\\22a\\22}, {}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{\\22a\\22}, {}]>]>\"}} : (tensor<2x8xf32>) -> tensor<2x8xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x8xf32>) -> tensor<4x8xf32>\n-  return %2 : tensor<4x8xf32>\n-}\n-\n-// CHECK-LABEL: func @nested_shmaps_extra_op\n-func.func @nested_shmaps_extra_op(%arg0: tensor<4x8xf32>) -> tensor<4x8xf32> {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body_5\n-  // CHECK:               %[[MAN_COMP_0:.*]] = sdy.manual_computation(%arg0)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_1, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_1, [{\"a\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"a\"}\n-  // CHECK-SAME:              (%arg1: tensor<2x8xf32>) {\n-  // CHECK-NEXT:            %[[MAN_COMP_1:.*]] = sdy.manual_computation(%arg1)\n-  // CHECK-SAME{LITERAL}:       in_shardings=[<@mesh_1, [{}, {\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:       out_shardings=[<@mesh_1, [{}, {\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:       manual_axes={\"b\"}\n-  // CHECK-SAME:                (%arg2: tensor<2x4xf32>) {\n-  // CHECK-NEXT:              %[[MULT:.*]] = stablehlo.multiply %arg2, %arg2 : tensor<2x4xf32>\n-  // CHECK-NEXT:              sdy.return %[[MULT]] : tensor<2x4xf32>\n-  // CHECK-NEXT:            } : (tensor<2x8xf32>) -> tensor<2x8xf32>\n-  // CHECK-NEXT:            %[[ADD:.*]] = stablehlo.add %[[MAN_COMP_1]], %[[MAN_COMP_1]] : tensor<2x8xf32>\n-  // CHECK-NEXT:            sdy.return %[[ADD]] : tensor<2x8xf32>\n-  // CHECK-NEXT:          } : (tensor<4x8xf32>) -> tensor<4x8xf32>\n-  // CHECK-NEXT:          return %[[MAN_COMP_0]] : tensor<4x8xf32>\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<4x8xf32>) -> tensor<2x8xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body_5(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{\\22a\\22}, {}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{\\22a\\22}, {}]>]>\"}} : (tensor<2x8xf32>) -> tensor<2x8xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x8xf32>) -> tensor<4x8xf32>\n-  return %2 : tensor<4x8xf32>\n-}\n-\n-// CHECK-LABEL: func @manual_computation_no_inputs\n-func.func @manual_computation_no_inputs() -> tensor<4xi64> {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body_6\n-  // CHECK:               %[[SHMAP:.*]] = sdy.manual_computation()\n-  // CHECK-SAME{LITERAL}:     in_shardings=[]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_0, [{\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"b\"}\n-  // CHECK-SAME{LITERAL}:     () {\n-  // CHECK-NEXT:            %[[C:.*]] = stablehlo.constant dense<[2, 3]> : tensor<2xi64>\n-  // CHECK-NEXT:            sdy.return %[[C]] : tensor<2xi64>\n-  // CHECK-NEXT:          } : () -> tensor<4xi64>\n-  // CHECK-NEXT:          return %[[SHMAP]] : tensor<4xi64>\n-  %0 = call @local_xla.sdy.manual_computation_body_6() {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22b\\22}]>]>\"}} : () -> tensor<2xi64>\n-  %1 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%0) : (tensor<2xi64>) -> tensor<4xi64>\n-  return %1 : tensor<4xi64>\n-}\n-\n-// CHECK-LABEL: func @manual_computation_no_outputs\n-func.func @manual_computation_no_outputs(%arg0: tensor<4xi64>) {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body_7\n-  // CHECK:               sdy.manual_computation(%arg0)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_0, [{\"b\"}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"b\"}\n-  // CHECK-SAME{LITERAL}:     (%arg1: tensor<2xi64>) {\n-  // CHECK-NEXT:            stablehlo.custom_call @sdy_testonly(%arg1) : (tensor<2xi64>) -> ()\n-  // CHECK-NEXT:            sdy.return\n-  // CHECK-NEXT:          } : (tensor<4xi64>) -> ()\n-  // CHECK-NEXT:          return\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<4xi64>) -> tensor<2xi64>\n-  call @local_xla.sdy.manual_computation_body_7(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22b\\22}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[]>\"}} : (tensor<2xi64>) -> ()\n-  return\n-}\n-\n-// CHECK-LABEL: func @manual_computation_no_inputs_no_outputs\n-func.func @manual_computation_no_inputs_no_outputs() {\n-  // CHECK-NEXT: sdy.manual_computation() in_shardings=[] out_shardings=[] manual_axes={} () {\n-  // CHECK-NEXT:   sdy.return\n-  // CHECK-NEXT: } : () -> ()\n-  // CHECK-NEXT: return\n-  call @local_xla.sdy.manual_computation_body_8() {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[]>\"}} : () -> ()\n-  return\n-}\n-\n-// CHECK-LABEL: func @manual_computation_zero_dim_inputs\n-func.func @manual_computation_zero_dim_inputs(%arg0: tensor<0x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<0x32xf32>) {\n-  // CHECK-NOT: call @local_xla.sdy.manual_computation_body\n-  // CHECK:               %[[MAN_COMP:.*]] = sdy.manual_computation(%arg0, %arg1)\n-  // CHECK-SAME{LITERAL}:     in_shardings=[<@mesh_0, [{}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}]>]\n-  // CHECK-SAME{LITERAL}:     out_shardings=[<@mesh_0, [{}, {}], replicated={\"b\"}>]\n-  // CHECK-SAME{LITERAL}:     manual_axes={\"b\"}\n-  // CHECK-SAME:              (%arg2: tensor<0x8xf32>, %arg3: tensor<8x32xf32>) {\n-  // CHECK-NEXT:            %[[DOT:.*]] = stablehlo.dot %arg2, %arg3\n-  // CHECK-NEXT:            sdy.return %[[DOT]]\n-  // CHECK-NEXT:          } : (tensor<0x16xf32>, tensor<16x32xf32>) -> tensor<0x32xf32>\n-  // CHECK-NEXT:          return %[[MAN_COMP]]\n-  %c = stablehlo.constant dense<0.000000e+00> : tensor<0x8xf32>\n-  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) : (tensor<0x16xf32>, tensor<16x32xf32>) -> (tensor<0x8xf32>, tensor<8x32xf32>)\n-  %1 = call @local_xla.sdy.manual_computation_body_9(%c, %0#1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<0x8xf32>, tensor<8x32xf32>) -> tensor<0x32xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<0x32xf32>) -> tensor<0x32xf32>\n-  return %2 : tensor<0x32xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body(\n-func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.add %arg0, %arg0 : tensor<2x8xf32>\n-  %1 = stablehlo.dot %0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %2 = \"stablehlo.all_reduce\"(%1) <{replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>}> ({\n-  ^bb0(%arg2: tensor<f32>, %arg3: tensor<f32>):\n-    %3 = stablehlo.add %arg2, %arg3 : tensor<f32>\n-    stablehlo.return %3 : tensor<f32>\n-  }) : (tensor<2x32xf32>) -> tensor<2x32xf32>\n-  return %2 : tensor<2x32xf32>\n-}\n-\n-func.func @my_model.___call__.fwd.xla.sdy.manual_computation_body_14.1234(%arg0: tensor<2x8xf32>) -> tensor<2x8xf32> {\n-  return %arg0 : tensor<2x8xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_0(\n-func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>) -> tensor<2x8xf32> {\n-  return %arg0 : tensor<2x8xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_1(\n-func.func @local_xla.sdy.manual_computation_body_1(%arg0: tensor<8x4xf32>) -> tensor<8x4xf32> {\n-  return %arg0 : tensor<8x4xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_4(\n-func.func @local_xla.sdy.manual_computation_body_4(%arg0: tensor<2x4xf32>) -> tensor<2x4xf32> {\n-  %0 = stablehlo.multiply %arg0, %arg0 : tensor<2x4xf32>\n-  return %0 : tensor<2x4xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_5(\n-func.func @local_xla.sdy.manual_computation_body_5(%arg0: tensor<2x8xf32>) -> tensor<2x8xf32> {\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<2x8xf32>) -> tensor<2x4xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body_4(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{}, {\\22b\\22}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_1, [{}, {\\22b\\22}]>]>\"}} : (tensor<2x4xf32>) -> tensor<2x4xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x4xf32>) -> tensor<2x8xf32>\n-  %3 = stablehlo.add %2, %2 : tensor<2x8xf32>\n-  return %3 : tensor<2x8xf32>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_6(\n-func.func @local_xla.sdy.manual_computation_body_6() -> tensor<2xi64> {\n-  %c = stablehlo.constant dense<[2, 3]> : tensor<2xi64>\n-  return %c : tensor<2xi64>\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_7(\n-func.func @local_xla.sdy.manual_computation_body_7(%arg0: tensor<2xi64>) {\n-  stablehlo.custom_call @sdy_testonly(%arg0) : (tensor<2xi64>) -> ()\n-  return\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_8(\n-func.func @local_xla.sdy.manual_computation_body_8() {\n-  return\n-}\n-\n-// CHECK-NOT: func @local_xla.sdy.manual_computation_body_9(\n-func.func @local_xla.sdy.manual_computation_body_9(%arg0: tensor<0x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<0x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<0x8xf32>, tensor<8x32xf32>) -> tensor<0x32xf32>\n-  return %0 : tensor<0x32xf32>\n-}"
        }
    ],
    "stats": {
        "total": 281,
        "additions": 1,
        "deletions": 280
    }
}