{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Refactor][1/n] Add virtual base class which all replica groups inherit from.\n\nPiperOrigin-RevId: 845493049",
    "sha": "91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8",
    "files": [
        {
            "sha": "c7a8ecc2eb8f25aa403d99484853ed5b0fa85768",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 11,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8",
            "patch": "@@ -189,7 +189,8 @@ std::vector<std::vector<int64_t>> get_replica_groups_for_full_axes(\n   return replica_groups;\n }\n \n-void MeshAxesReplicaGroupList::InitializeDimToReshapeAndAggregateAxes() {\n+absl::flat_hash_map<int64_t, MeshAxesReplicaGroupList::ReshapeAndAggregateAxes>\n+MeshAxesReplicaGroupList::GetDimToReshapeAndAggregateAxes() const {\n   absl::flat_hash_map<int64_t, std::vector<AxisRef>> dim_to_axes;\n   for (const AxisRef& axis : axes_) {\n     dim_to_axes[axis.mesh_axis_index()].push_back(axis);\n@@ -216,17 +217,14 @@ void MeshAxesReplicaGroupList::InitializeDimToReshapeAndAggregateAxes() {\n     }\n     dim_map[dim] = reshape_and_aggregate_axes;\n   }\n-  dim_to_reshape_and_aggregate_axes_ = dim_map;\n+  return dim_map;\n }\n \n std::pair<std::vector<int64_t>, std::vector<int64_t>>\n-MeshAxesReplicaGroupList::ComputeReindexedAxes() {\n-  if (!dim_to_reshape_and_aggregate_axes_.has_value()) {\n-    InitializeDimToReshapeAndAggregateAxes();\n-  }\n+MeshAxesReplicaGroupList::ComputeReindexedAxes() const {\n   std::vector<int64_t> reindex_axis_sizes, reindexed_grouped_axes;\n   absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes> dim_map =\n-      dim_to_reshape_and_aggregate_axes_.value();\n+      GetDimToReshapeAndAggregateAxes();\n   for (int64_t i = 0; i < mesh_.axis_sizes().size(); ++i) {\n     int64_t axis_size = mesh_.axis_size(i);\n     auto it = dim_map.find(i);\n@@ -247,7 +245,7 @@ MeshAxesReplicaGroupList::ComputeReindexedAxes() {\n }\n \n std::vector<std::vector<int64_t>>\n-MeshAxesReplicaGroupList::flattened_replica_groups() {\n+MeshAxesReplicaGroupList::flattened_replica_groups() const {\n   std::vector<int64_t> reindex_axis_sizes, reindexed_grouped_axes;\n   std::tie(reindex_axis_sizes, reindexed_grouped_axes) = ComputeReindexedAxes();\n   return get_replica_groups_for_full_axes(\n@@ -292,7 +290,7 @@ MeshAxesReplicaGroupList MeshAxesReplicaGroupList::FromProto(\n   return MeshAxesReplicaGroupList(mesh, axes);\n }\n \n-IotaReplicaGroupList MeshAxesReplicaGroupList::ToIotaReplicaGroupList() {\n+IotaReplicaGroupList MeshAxesReplicaGroupList::ToIotaReplicaGroupList() const {\n   CHECK(mesh_.device_assignment().iota().has_value());\n   std::vector<int64_t> reshape_dims, reindexed_grouped_axes;\n   std::tie(reshape_dims, reindexed_grouped_axes) = ComputeReindexedAxes();\n@@ -312,7 +310,7 @@ IotaReplicaGroupList MeshAxesReplicaGroupList::ToIotaReplicaGroupList() {\n                               reshape_dims, transpose_perm);\n }\n \n-CollectiveDeviceList MeshAxesReplicaGroupList::ToCollectiveDeviceList() {\n+CollectiveDeviceList MeshAxesReplicaGroupList::ToCollectiveDeviceList() const {\n   return CollectiveDeviceList(flattened_replica_groups());\n }\n \n@@ -413,15 +411,22 @@ CollectiveDeviceList::flattened_replica_groups() const {\n   return result;\n }\n \n+std::string CollectiveDeviceList::ToString() const {\n+  return ToString(/*print_full_replica_group_list=*/false);\n+}\n+\n std::string CollectiveDeviceList::ToString(\n     bool print_full_replica_group_list) const {\n   if (iota_replica_group_list_.has_value() && !print_full_replica_group_list) {\n     return iota_replica_group_list_->ToString();\n   }\n-\n   return ReplicaGroupsToString(replica_groups());\n }\n \n+void CollectiveDeviceList::Print(Printer* printer) const {\n+  return Print(printer, /*print_full_replica_group_list=*/false);\n+}\n+\n void CollectiveDeviceList::Print(Printer* printer,\n                                  bool print_full_replica_group_list) const {\n   if (iota_replica_group_list_.has_value() && !print_full_replica_group_list) {"
        },
        {
            "sha": "92e23d1310dde5e5f6e029c6a088b1c07f3269e5",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.h",
            "status": "modified",
            "additions": 118,
            "deletions": 44,
            "changes": 162,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h?ref=91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8",
            "patch": "@@ -41,7 +41,57 @@ namespace xla {\n class IotaReplicaGroupList;\n class CollectiveDeviceList;\n \n-class MeshAxesReplicaGroupList {\n+enum class CollectiveDeviceListVersion { kListOfLists, kIota, kMeshAxes };\n+\n+class CollectiveDeviceListBase {\n+ public:\n+  virtual ~CollectiveDeviceListBase() = default;\n+  CollectiveDeviceListBase() = default;\n+  CollectiveDeviceListBase(const CollectiveDeviceListBase&) = default;\n+  CollectiveDeviceListBase& operator=(const CollectiveDeviceListBase&) =\n+      default;\n+  CollectiveDeviceListBase(CollectiveDeviceListBase&&) = default;\n+  CollectiveDeviceListBase& operator=(CollectiveDeviceListBase&&) = default;\n+\n+  virtual int64_t num_replica_groups() const = 0;\n+  virtual int64_t num_devices_per_group() const = 0;\n+  int64_t num_total_devices() const {\n+    return num_replica_groups() * num_devices_per_group();\n+  }\n+  virtual std::vector<std::vector<int64_t>> flattened_replica_groups()\n+      const = 0;\n+  virtual const std::vector<ReplicaGroup>& replica_groups() const {\n+    if (replica_groups_ != nullptr) {\n+      return *replica_groups_;\n+    }\n+    replica_groups_ = std::make_shared<std::vector<ReplicaGroup>>();\n+    replica_groups_->reserve(num_replica_groups());\n+    for (const auto& group : flattened_replica_groups()) {\n+      ReplicaGroup replica_group;\n+      replica_group.mutable_replica_ids()->Add(group.begin(), group.end());\n+      replica_groups_->push_back(std::move(replica_group));\n+    }\n+    return *replica_groups_;\n+  };\n+  virtual void Print(Printer* printer) const = 0;\n+  virtual void Print(Printer* printer,\n+                     bool print_full_replica_group_list) const {\n+    return Print(printer);\n+  };\n+  virtual std::string ToString() const = 0;\n+  virtual std::string ToString(bool print_full_replica_group_list) const {\n+    return ToString();\n+  };\n+\n+  virtual std::unique_ptr<CollectiveDeviceListBase> Clone() const = 0;\n+\n+  virtual CollectiveDeviceListVersion version() const = 0;\n+\n+  // shared_ptr for fast copy.\n+  mutable std::shared_ptr<std::vector<ReplicaGroup>> replica_groups_ = nullptr;\n+};\n+\n+class MeshAxesReplicaGroupList : public CollectiveDeviceListBase {\n   struct ReshapeAndAggregateAxes {\n     std::vector<int64_t> reshape_dims;\n     std::vector<int64_t> aggregate_axes;\n@@ -59,30 +109,33 @@ class MeshAxesReplicaGroupList {\n     return H::combine(std::move(h), c.mesh_, c.axes_);\n   }\n \n-  int64_t num_replica_groups() const;\n-  int64_t num_devices_per_group() const;\n-  std::vector<std::vector<int64_t>> flattened_replica_groups();\n-\n-  void Print(Printer* printer) const;\n-\n-  std::string ToString() const;\n-\n+  int64_t num_replica_groups() const override;\n+  int64_t num_devices_per_group() const override;\n+  std::vector<std::vector<int64_t>> flattened_replica_groups() const override;\n+  void Print(Printer* printer) const override;\n+  std::string ToString() const override;\n   MeshAxesReplicaGroupListProto ToProto() const;\n+  std::unique_ptr<CollectiveDeviceListBase> Clone() const override {\n+    return std::make_unique<MeshAxesReplicaGroupList>(*this);\n+  };\n+  CollectiveDeviceListVersion version() const override {\n+    return CollectiveDeviceListVersion::kMeshAxes;\n+  }\n \n   static MeshAxesReplicaGroupList FromProto(\n       const MeshAxesReplicaGroupListProto& proto);\n \n   // Methods for converting to V2 and V1 representations.\n-  IotaReplicaGroupList ToIotaReplicaGroupList();\n-  CollectiveDeviceList ToCollectiveDeviceList();\n+  IotaReplicaGroupList ToIotaReplicaGroupList() const;\n+  CollectiveDeviceList ToCollectiveDeviceList() const;\n \n  private:\n-  void InitializeDimToReshapeAndAggregateAxes();\n-  std::pair<std::vector<int64_t>, std::vector<int64_t>> ComputeReindexedAxes();\n+  absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes>\n+  GetDimToReshapeAndAggregateAxes() const;\n+  std::pair<std::vector<int64_t>, std::vector<int64_t>> ComputeReindexedAxes()\n+      const;\n   Mesh mesh_;\n   std::vector<AxisRef> axes_;\n-  std::optional<absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes>>\n-      dim_to_reshape_and_aggregate_axes_;\n };\n \n std::string ReplicaGroupsToString(\n@@ -92,7 +145,7 @@ std::string ReplicaGroupsToString(\n // reshaping and transposing an iota array (iota tile assignment). Can be used\n // to represent certain common patterns of device lists in a compact, scalable\n // format.\n-class IotaReplicaGroupList {\n+class IotaReplicaGroupList : public CollectiveDeviceListBase {\n  public:\n   explicit IotaReplicaGroupList(int64_t num_replica_groups,\n                                 int64_t num_devices_per_group)\n@@ -125,20 +178,26 @@ class IotaReplicaGroupList {\n                       c.transpose_perm());\n   }\n \n-  int64_t num_replica_groups() const;\n-  int64_t num_devices_per_group() const;\n+  int64_t num_replica_groups() const override;\n+  int64_t num_devices_per_group() const override;\n   absl::Span<const int64_t> reshape_dims() const {\n     return iota_tile_assignment_.reshape_dims();\n   }\n   absl::Span<const int> transpose_perm() const {\n     return iota_tile_assignment_.transpose_perm();\n   }\n   Array<int64_t> ToArray() const { return iota_tile_assignment_.ToArray(); }\n-  std::vector<std::vector<int64_t>> flattened_replica_groups() const;\n+  std::vector<std::vector<int64_t>> flattened_replica_groups() const override;\n \n-  void Print(Printer* printer) const;\n+  void Print(Printer* printer) const override;\n \n-  std::string ToString() const;\n+  std::string ToString() const override;\n+  std::unique_ptr<CollectiveDeviceListBase> Clone() const override {\n+    return std::make_unique<IotaReplicaGroupList>(*this);\n+  };\n+  CollectiveDeviceListVersion version() const override {\n+    return CollectiveDeviceListVersion::kIota;\n+  }\n \n   IotaReplicaGroupListProto ToProto() const;\n \n@@ -153,22 +212,26 @@ class IotaReplicaGroupList {\n // Represents a series of devices participating in a collective operation\n // (all-gather, all-reduce, etc.). While this directly translates to a list of\n // replica groups, it may be used to represent these lists in compact forms.\n-class CollectiveDeviceList {\n+class CollectiveDeviceList : public CollectiveDeviceListBase {\n  public:\n-  explicit CollectiveDeviceList()\n-      : replica_groups_(std::make_shared<std::vector<ReplicaGroup>>()) {};\n+  explicit CollectiveDeviceList() {\n+    replica_groups_ = std::make_shared<std::vector<ReplicaGroup>>();\n+  };\n \n-  explicit CollectiveDeviceList(std::vector<ReplicaGroup> replica_groups)\n-      : replica_groups_(std::make_shared<std::vector<ReplicaGroup>>(\n-            std::move(replica_groups))) {};\n+  explicit CollectiveDeviceList(std::vector<ReplicaGroup> replica_groups) {\n+    replica_groups_ =\n+        std::make_shared<std::vector<ReplicaGroup>>(std::move(replica_groups));\n+  };\n \n-  explicit CollectiveDeviceList(absl::Span<const ReplicaGroup> replica_groups)\n-      : replica_groups_(std::make_shared<std::vector<ReplicaGroup>>(\n-            replica_groups.begin(), replica_groups.end())) {};\n+  explicit CollectiveDeviceList(absl::Span<const ReplicaGroup> replica_groups) {\n+    replica_groups_ = std::make_shared<std::vector<ReplicaGroup>>(\n+        replica_groups.begin(), replica_groups.end());\n+  };\n \n   explicit CollectiveDeviceList(\n-      absl::Span<const std::vector<int64_t>> replica_groups)\n-      : replica_groups_(ToReplicaGroupVector(replica_groups)) {};\n+      absl::Span<const std::vector<int64_t>> replica_groups) {\n+    replica_groups_ = ToReplicaGroupVector(replica_groups);\n+  };\n \n   // Replica groups are materialized lazily upon first access.\n   explicit CollectiveDeviceList(\n@@ -206,41 +269,51 @@ class CollectiveDeviceList {\n   }\n \n   // Lazyly explands iota if applicable.\n-  const std::vector<ReplicaGroup>& replica_groups() const;\n-  std::vector<std::vector<int64_t>> flattened_replica_groups() const;\n+  const std::vector<ReplicaGroup>& replica_groups() const override;\n+  std::vector<std::vector<int64_t>> flattened_replica_groups() const override;\n   const std::optional<IotaReplicaGroupList>& iota_replica_group_list() const {\n     return iota_replica_group_list_;\n   }\n \n-  int64_t num_replica_groups() const {\n+  int64_t num_replica_groups() const override {\n     return iota_replica_group_list_.has_value()\n                ? iota_replica_group_list_->num_replica_groups()\n                : replica_groups_->size();\n   }\n \n-  int64_t num_devices_per_group() const {\n+  int64_t num_devices_per_group() const override {\n     return iota_replica_group_list_.has_value()\n                ? iota_replica_group_list_->num_devices_per_group()\n                : replica_groups_->begin()->replica_ids_size();\n   }\n \n+  void Print(Printer* printer) const override;\n   void Print(Printer* printer,\n-             bool print_full_replica_group_list = false) const;\n-\n-  std::string ToString(bool print_full_replica_group_list = false) const;\n+             bool print_full_replica_group_list) const override;\n+  std::string ToString() const override;\n+  std::string ToString(bool print_full_replica_group_list) const override;\n+  CollectiveDeviceListVersion version() const override {\n+    if (iota_replica_group_list_.has_value()) {\n+      return CollectiveDeviceListVersion::kIota;\n+    }\n+    return CollectiveDeviceListVersion::kListOfLists;\n+  }\n \n   CollectiveDeviceListProto ToProto() const;\n   static CollectiveDeviceList FromProto(const CollectiveDeviceListProto& proto);\n   static CollectiveDeviceList FromProto(const HloInstructionProto& proto);\n+  std::unique_ptr<CollectiveDeviceListBase> Clone() const override {\n+    return std::make_unique<CollectiveDeviceList>(*this);\n+  };\n \n  private:\n   // Construct collective device list from protobuf replica group start and end\n   // iterators.\n   CollectiveDeviceList(\n       tsl::protobuf::RepeatedPtrField<ReplicaGroup>::const_iterator start,\n-      tsl::protobuf::RepeatedPtrField<ReplicaGroup>::const_iterator end)\n-      : replica_groups_(\n-            std::make_shared<std::vector<ReplicaGroup>>(start, end)) {};\n+      tsl::protobuf::RepeatedPtrField<ReplicaGroup>::const_iterator end) {\n+    replica_groups_ = std::make_shared<std::vector<ReplicaGroup>>(start, end);\n+  };\n \n   static std::shared_ptr<std::vector<ReplicaGroup>> ToReplicaGroupVector(\n       absl::Span<const std::vector<int64_t>> replica_groups) {\n@@ -258,10 +331,11 @@ class CollectiveDeviceList {\n   void MaybeMaterializeFullReplicaGroupList() const;\n \n   std::optional<IotaReplicaGroupList> iota_replica_group_list_;\n-  // shared_ptr for fast copy.\n-  mutable std::shared_ptr<std::vector<ReplicaGroup>> replica_groups_ = nullptr;\n };\n \n+std::optional<CollectiveDeviceList> ConvertToV1CollectiveDeviceList(\n+    const CollectiveDeviceListBase& device_list);\n+\n }  // namespace xla\n \n #endif  // XLA_HLO_IR_REPLICA_GROUP_H_"
        },
        {
            "sha": "4f031265de029f863a4a4255f5dc2bdfe6c1354a",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 21,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc?ref=91e0e5c4e0934182e61ed5c3484b3c11b6a9c5e8",
            "patch": "@@ -4953,12 +4953,6 @@ absl::Status SpmdPartitioningVisitor::HandleRaggedDot(HloInstruction* hlo) {\n \n SPMDCollectiveOpsCreator GetDefaultCollectiveOpsCreator(int64_t num_partitions,\n                                                         int64_t num_replicas) {\n-  auto uses_all_partitions =\n-      [num_partitions](const IotaReplicaGroupList& partition_group_list) {\n-        return partition_group_list.num_replica_groups() *\n-                   partition_group_list.num_devices_per_group() ==\n-               num_partitions;\n-      };\n   auto create_all_reduce_lists_of_lists =\n       [num_replicas, num_partitions](\n           SpmdBuilder* b, HloInstruction* operand, HloComputation* reduction,\n@@ -5053,14 +5047,14 @@ SPMDCollectiveOpsCreator GetDefaultCollectiveOpsCreator(int64_t num_partitions,\n                 b, operand, reduction, partition_subgroups, channel_id);\n           },\n       .create_cross_partition_all_reduce_with_iota_device_list =\n-          [create_all_reduce_lists_of_lists, uses_all_partitions, num_replicas,\n-           num_partitions](SpmdBuilder* b, HloInstruction* operand,\n-                           HloComputation* reduction,\n-                           const IotaReplicaGroupList& partition_group_list,\n-                           int64_t channel_id) {\n+          [create_all_reduce_lists_of_lists, num_replicas, num_partitions](\n+              SpmdBuilder* b, HloInstruction* operand,\n+              HloComputation* reduction,\n+              const IotaReplicaGroupList& partition_group_list,\n+              int64_t channel_id) {\n             // Fallback to list of lists collective creation if the partition\n             // group list does not utilize all the partitions.\n-            if (!uses_all_partitions(partition_group_list)) {\n+            if (partition_group_list.num_total_devices() != num_partitions) {\n               return create_all_reduce_lists_of_lists(\n                   b, operand, reduction,\n                   partition_group_list.flattened_replica_groups(), channel_id);\n@@ -5111,14 +5105,13 @@ SPMDCollectiveOpsCreator GetDefaultCollectiveOpsCreator(int64_t num_partitions,\n                 b, operands, partition_subgroups, channel_id, split_dimension);\n           },\n       .create_cross_partition_all_to_all_with_iota_device_list =\n-          [create_all_to_all_list_of_lists, uses_all_partitions, num_replicas,\n-           num_partitions](\n+          [create_all_to_all_list_of_lists, num_replicas, num_partitions](\n               SpmdBuilder* b, absl::Span<HloInstruction* const> operands,\n               const IotaReplicaGroupList& partition_group_list,\n               int64_t channel_id, std::optional<int64_t> split_dimension) {\n             // Fallback back to list of lists collective creation if the\n             // partition group list does not utilize all the partitions.\n-            if (!uses_all_partitions(partition_group_list)) {\n+            if (partition_group_list.num_total_devices() != num_partitions) {\n               return create_all_to_all_list_of_lists(\n                   b, operands, partition_group_list.flattened_replica_groups(),\n                   channel_id, split_dimension);\n@@ -5143,14 +5136,13 @@ SPMDCollectiveOpsCreator GetDefaultCollectiveOpsCreator(int64_t num_partitions,\n                 all_gather_dimension);\n           },\n       .create_cross_partition_all_gather_with_iota_device_list =\n-          [create_all_gather_list_of_lists, uses_all_partitions, num_replicas,\n-           num_partitions](SpmdBuilder* b, HloInstruction* operand,\n-                           const Shape& ag_shape,\n-                           const IotaReplicaGroupList& partition_group_list,\n-                           int64_t channel_id, int64_t all_gather_dimension) {\n+          [create_all_gather_list_of_lists, num_replicas, num_partitions](\n+              SpmdBuilder* b, HloInstruction* operand, const Shape& ag_shape,\n+              const IotaReplicaGroupList& partition_group_list,\n+              int64_t channel_id, int64_t all_gather_dimension) {\n             // Fallback to list of lists collective creation if the partition\n             // group list does not utilize all the partitions.\n-            if (!uses_all_partitions(partition_group_list)) {\n+            if (partition_group_list.num_total_devices() != num_partitions) {\n               return create_all_gather_list_of_lists(\n                   b, operand, ag_shape,\n                   partition_group_list.flattened_replica_groups(), channel_id,"
        }
    ],
    "stats": {
        "total": 223,
        "additions": 147,
        "deletions": 76
    }
}