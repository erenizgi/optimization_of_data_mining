{
    "author": "ezhulenev",
    "message": "[xla:cpu] Create xla::cpu::BufferAllocationInfo from deprecated cpu_function_runtime::BufferInfo\n\nPiperOrigin-RevId: 817834097",
    "sha": "eba90df183900413f9bee3297e24cca82e3f0afa",
    "files": [
        {
            "sha": "eb807d3fbc5184dcaeff1c3088eff973c840f704",
            "filename": "third_party/xla/xla/backends/cpu/BUILD",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba90df183900413f9bee3297e24cca82e3f0afa/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba90df183900413f9bee3297e24cca82e3f0afa/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2FBUILD?ref=eba90df183900413f9bee3297e24cca82e3f0afa",
            "patch": "@@ -34,6 +34,25 @@ cc_library(\n     deps = [\"@eigen_archive//:eigen3\"],\n )\n \n+cc_library(\n+    name = \"buffer_allocation_info\",\n+    hdrs = [\"buffer_allocation_info.h\"],\n+    visibility = internal_visibility([\":friends\"]),\n+    deps = [\n+        \"//xla:xla_data_proto_cc\",\n+        \"@com_google_absl//absl/log:check\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"buffer_allocation_info_test\",\n+    srcs = [\"buffer_allocation_info_test.cc\"],\n+    deps = [\n+        \":buffer_allocation_info\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n onednn_graph_cc_library(\n     name = \"onednn_emitter\",\n     srcs = [\"onednn_emitter.cc\"],"
        },
        {
            "sha": "63880db378692e0aabb74f7a134b060a2e4e351a",
            "filename": "third_party/xla/xla/backends/cpu/buffer_allocation_info.h",
            "status": "added",
            "additions": 162,
            "deletions": 0,
            "changes": 162,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba90df183900413f9bee3297e24cca82e3f0afa/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbuffer_allocation_info.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba90df183900413f9bee3297e24cca82e3f0afa/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbuffer_allocation_info.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbuffer_allocation_info.h?ref=eba90df183900413f9bee3297e24cca82e3f0afa",
            "patch": "@@ -0,0 +1,162 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_CPU_BUFFER_ALLOCATION_INFO_H_\n+#define XLA_BACKENDS_CPU_BUFFER_ALLOCATION_INFO_H_\n+\n+#include <cstdint>\n+\n+#include \"absl/log/check.h\"\n+\n+namespace xla::cpu {\n+\n+// `BufferAllocationInfo` stores information about buffer allocations required\n+// by an XLA:CPU executable at run time. It corresponds to a `BufferAllocation`\n+// in the `BufferAssignment` for a compiled XLA program.\n+//\n+// This class decouples buffer allocation info from the `BufferAllocation`\n+// class, which brings in a heavy dependency set, including protobuf dependency,\n+// and a `BufferAssignment` itself. We use this lightweight class in places that\n+// don't want to bring in these dependencies, e.g. in AOT compilation.\n+class BufferAllocationInfo {\n+ public:\n+  // Encoded version of `BufferAllocationInfo`, which can be used to reconstruct\n+  // the `BufferAllocationInfo` later. It's used in the AOT compiler, to\n+  // represent buffer allocation info as a lightweight struct.\n+  struct Encoded {\n+    uint64_t packed_kind_and_size = 0;\n+    uint32_t entry_param_number = -1;\n+    uint32_t result_param_number = -1;\n+  };\n+\n+  // Creates a BufferAllocationInfo from a serialized encoding generated by\n+  // `Encode`.\n+  explicit constexpr BufferAllocationInfo(const Encoded& encoded)\n+      : kind_(UnpackKind(encoded.packed_kind_and_size)),\n+        size_(UnpackSize(encoded.packed_kind_and_size)),\n+        entry_param_number_(encoded.entry_param_number),\n+        result_param_number_(encoded.result_param_number) {}\n+\n+  bool is_constant() const { return kind_ == Kind::kConstant; }\n+\n+  bool is_entry_parameter() const {\n+    return kind_ == Kind::kParameter && entry_param_number_ >= 0;\n+  }\n+\n+  int32_t entry_parameter_number() const {\n+    DCHECK(is_entry_parameter());\n+    return entry_param_number_;\n+  }\n+\n+  bool is_result_parameter() const {\n+    return kind_ == Kind::kParameter && result_param_number_ >= 0;\n+  }\n+\n+  int32_t result_parameter_number() const {\n+    DCHECK(is_result_parameter());\n+    return result_param_number_;\n+  }\n+\n+  // Returns true if this buffer is temporary scratch space required by the XLA\n+  // computations. These are always allocated by the runtime.\n+  bool is_temp() const { return kind_ == Kind::kTemp; }\n+\n+  // Returns true if this buffer is allocated on the C stack or into registers.\n+  // These buffers are never allocated by the runtime.\n+  bool is_thread_local() const { return kind_ == Kind::kThreadLocal; }\n+\n+  // Returns the size for this buffer.\n+  uint64_t size() const { return size_; }\n+\n+  // Encodes this BufferAllocationInfo into the struct that can be used\n+  // to reconstruct the BufferAllocationInfo later using the constructor. We\n+  // need this because we use BufferAllocationInfo in places where using\n+  // protocol buffers would negatively impact binary size.\n+  Encoded Encode() const {\n+    static_assert(sizeof(*this) == 16);\n+    return Encoded{\n+        Pack(kind_, size_),\n+        static_cast<uint32_t>(entry_param_number_),\n+        static_cast<uint32_t>(result_param_number_),\n+    };\n+  }\n+\n+  bool operator==(const BufferAllocationInfo& buffer_info) const {\n+    return kind_ == buffer_info.kind_ && size_ == buffer_info.size_ &&\n+           entry_param_number_ == buffer_info.entry_param_number_ &&\n+           result_param_number_ == buffer_info.result_param_number_;\n+  }\n+\n+  static BufferAllocationInfo Temp(uint64_t size) {\n+    return BufferAllocationInfo(Kind::kTemp, size);\n+  }\n+\n+  static BufferAllocationInfo Constant(uint64_t size) {\n+    return BufferAllocationInfo(Kind::kConstant, size);\n+  }\n+\n+  static BufferAllocationInfo EntryParameter(uint64_t size,\n+                                             int32_t entry_param_number) {\n+    return BufferAllocationInfo(Kind::kParameter, size, entry_param_number);\n+  }\n+\n+  static BufferAllocationInfo ResultParameter(uint64_t size,\n+                                              int32_t result_param_number) {\n+    return BufferAllocationInfo(Kind::kParameter, size,\n+                                /*entry_param_number=*/-1, result_param_number);\n+  }\n+\n+  static BufferAllocationInfo InOutParameter(uint64_t size,\n+                                             int32_t entry_param_number,\n+                                             int32_t result_param_number) {\n+    return BufferAllocationInfo(Kind::kParameter, size, entry_param_number);\n+  }\n+\n+  static BufferAllocationInfo ThreadLocal(uint64_t size) {\n+    return BufferAllocationInfo(Kind::kThreadLocal, size);\n+  }\n+\n+ private:\n+  enum class Kind : uint64_t { kConstant, kTemp, kParameter, kThreadLocal };\n+\n+  BufferAllocationInfo(Kind kind, uint64_t size,\n+                       int32_t entry_param_number = -1,\n+                       int32_t result_param_number = -1)\n+      : kind_(kind),\n+        size_(size),\n+        entry_param_number_(entry_param_number),\n+        result_param_number_(result_param_number) {}\n+\n+  static uint64_t Pack(Kind kind, uint64_t size) {\n+    return (static_cast<uint64_t>(size) << 2) | static_cast<uint64_t>(kind);\n+  }\n+\n+  static inline constexpr Kind UnpackKind(uint64_t packed) {\n+    return static_cast<Kind>((packed << 62) >> 62);\n+  }\n+\n+  static inline constexpr uint64_t UnpackSize(uint64_t packed) {\n+    return packed >> 2;\n+  }\n+\n+  Kind kind_ : 2;\n+  uint64_t size_ : 62;\n+  int32_t entry_param_number_ = -1;\n+  int32_t result_param_number_ = -1;\n+};\n+\n+}  // namespace xla::cpu\n+\n+#endif  // XLA_BACKENDS_CPU_BUFFER_ALLOCATION_INFO_H_"
        },
        {
            "sha": "b0b5bd57035fa2861c3f8f91d8e4b459870934e6",
            "filename": "third_party/xla/xla/backends/cpu/buffer_allocation_info_test.cc",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba90df183900413f9bee3297e24cca82e3f0afa/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbuffer_allocation_info_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba90df183900413f9bee3297e24cca82e3f0afa/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbuffer_allocation_info_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fbuffer_allocation_info_test.cc?ref=eba90df183900413f9bee3297e24cca82e3f0afa",
            "patch": "@@ -0,0 +1,40 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/cpu/buffer_allocation_info.h\"\n+\n+#include <gtest/gtest.h>\n+\n+namespace xla::cpu {\n+namespace {\n+\n+TEST(BufferAllocationInfoTest, RoundTrip) {\n+  auto round_trip = [](const BufferAllocationInfo& buffer_info) {\n+    BufferAllocationInfo round_trip(buffer_info.Encode());\n+    ASSERT_EQ(round_trip, buffer_info);\n+  };\n+\n+  round_trip(BufferAllocationInfo::Temp(0));\n+  round_trip(BufferAllocationInfo::Temp(4));\n+  round_trip(BufferAllocationInfo::ThreadLocal(0));\n+  round_trip(BufferAllocationInfo::ThreadLocal(4));\n+  round_trip(BufferAllocationInfo::Constant(0));\n+  round_trip(BufferAllocationInfo::Constant(4));\n+  round_trip(BufferAllocationInfo::EntryParameter(0, 4));\n+  round_trip(BufferAllocationInfo::EntryParameter(4, 0));\n+}\n+\n+}  // namespace\n+}  // namespace xla::cpu"
        }
    ],
    "stats": {
        "total": 221,
        "additions": 221,
        "deletions": 0
    }
}