{
    "author": "mkuperst",
    "message": "[XLA] Remove HLO unstacker.\n\nThe pass is not used.\n\nPiperOrigin-RevId: 824274493",
    "sha": "2de4be94aa160b9ea34d4f967fdfa1b3c137fcda",
    "files": [
        {
            "sha": "3da84fc5026e14683d2c134ba876bee62a73f543",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2de4be94aa160b9ea34d4f967fdfa1b3c137fcda/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2de4be94aa160b9ea34d4f967fdfa1b3c137fcda/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=2de4be94aa160b9ea34d4f967fdfa1b3c137fcda",
            "patch": "@@ -2743,46 +2743,6 @@ xla_cc_test(\n     ],\n )\n \n-cc_library(\n-    name = \"hlo_unstacker\",\n-    srcs = [\"hlo_unstacker.cc\"],\n-    hdrs = [\"hlo_unstacker.h\"],\n-    deps = [\n-        \":hlo_creation_utils\",\n-        \":pattern_matcher\",\n-        \":tuple_util\",\n-        \":while_loop_unroller\",\n-        \"//xla:shape_util\",\n-        \"//xla:util\",\n-        \"//xla/hlo/ir:hlo\",\n-        \"//xla/hlo/pass:hlo_pass\",\n-        \"@com_google_absl//absl/algorithm:container\",\n-        \"@com_google_absl//absl/container:flat_hash_map\",\n-        \"@com_google_absl//absl/container:flat_hash_set\",\n-        \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n-        \"@com_google_absl//absl/strings:string_view\",\n-        \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:statusor\",\n-    ],\n-)\n-\n-xla_cc_test(\n-    name = \"hlo_unstacker_test\",\n-    srcs = [\"hlo_unstacker_test.cc\"],\n-    tags = if_google([\"requires-net:external\"]),\n-    deps = [\n-        \":hlo_unstacker\",\n-        \"//xla/hlo/ir:hlo\",\n-        \"//xla/tests:hlo_test_base\",\n-        \"@com_google_googletest//:gtest_main\",\n-        \"@local_tsl//tsl/platform:statusor\",\n-    ],\n-)\n-\n cc_library(\n     name = \"while_loop_unroller\",\n     srcs = [\"while_loop_unroller.cc\"],"
        },
        {
            "sha": "045ba3d6a27a7420a1c8492877334f955e2dd8a9",
            "filename": "third_party/xla/xla/service/hlo_unstacker.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 1503,
            "changes": 1503,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker.cc?ref=cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
            "patch": "@@ -1,1503 +0,0 @@\n-/* Copyright 2024 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/service/hlo_unstacker.h\"\n-\n-#include <algorithm>\n-#include <cstdint>\n-#include <deque>\n-#include <functional>\n-#include <memory>\n-#include <optional>\n-#include <string>\n-#include <utility>\n-#include <vector>\n-\n-#include \"absl/algorithm/container.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/container/flat_hash_set.h\"\n-#include \"absl/log/check.h\"\n-#include \"absl/log/log.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/strings/match.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"xla/hlo/ir/hlo_computation.h\"\n-#include \"xla/hlo/ir/hlo_instruction.h\"\n-#include \"xla/hlo/ir/hlo_module.h\"\n-#include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/map_util.h\"\n-#include \"xla/service/hlo_creation_utils.h\"\n-#include \"xla/service/pattern_matcher.h\"\n-#include \"xla/service/tuple_util.h\"\n-#include \"xla/service/while_loop_unroller.h\"\n-#include \"xla/shape.h\"\n-#include \"xla/shape_util.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/statusor.h\"\n-\n-namespace xla {\n-namespace {\n-\n-// TODO: b/352400145 - Unify the patterns, handlers and their type into a class\n-// or struct.\n-enum class PatternType {\n-  DSFusionNoBitcastPattern,\n-  DSFusionPattern,\n-  NestedDSFusionPattern,\n-  Other,\n-};\n-\n-static std::string PatternTypeToString(PatternType pattern_type) {\n-  switch (pattern_type) {\n-    case PatternType::DSFusionNoBitcastPattern:\n-      return \"DSFusionNoBitcastPattern\";\n-    case PatternType::DSFusionPattern:\n-      return \"DSFusionPattern\";\n-    case PatternType::NestedDSFusionPattern:\n-      return \"NestedDSFusionPattern\";\n-    case PatternType::Other:\n-      return \"Other\";\n-  }\n-}\n-\n-// Holds the information about custom unstacking patterns.\n-struct PatternInfo {\n-  PatternType type;\n-  std::vector<const HloInstruction*> unstacked_instrs;\n-  const HloInstruction* instr;\n-  Shape unstacked_shape;\n-  HloComputation* unstacking_computation;\n-\n-  std::string ToString() const {\n-    if (unstacking_computation == nullptr) {\n-      return absl::StrCat(\"type: \\n\\t\", PatternTypeToString(type), \"\\n\",\n-                          \"instr: \\n\\t\", instr->name(), \"\\n\", \"shape: \\n\\t\",\n-                          unstacked_shape.ToString(true));\n-    } else {\n-      return absl::StrCat(\"type: \\n\\t\", PatternTypeToString(type), \"\\n\",\n-                          \"instr: \\n\\t\", instr->name(), \"\\n\", \"shape: \\n\\t\",\n-                          unstacked_shape.ToString(true), \"\\n\", \"comp: \\n\",\n-                          unstacking_computation->name());\n-    }\n-  }\n-};\n-\n-// TODO: b/342457472 - Remove this struct and move its field to the\n-// UnstackerTransformer as static members. A struct that holds the required\n-// information for unstacking that is fixed across different unstacker\n-// instastances.\n-struct UnstackerMetadata {\n-  static absl::StatusOr<UnstackerMetadata> Create(\n-      HloModule* module, std::function<bool(HloInstruction*)> unfuse_slice) {\n-    UnstackerMetadata metadata;\n-    TF_ASSIGN_OR_RETURN(\n-        bool prepared,\n-        WhileLoopUnroller::PrepareModuleForUnrolling(module, {}));\n-    if (prepared) {\n-      VLOG(3) << \"Prepared module: \" << module->name() << \" for unstacking.\";\n-    }\n-    std::vector<std::pair<HloInstruction*, WhileLoopConfig>> loops =\n-        WhileLoopUnroller::GetUnrollableLoops(module, {},\n-                                              /*unroll_config=*/std::nullopt);\n-    for (const auto& [instr, while_loop_config] : loops) {\n-      metadata.unrollable_loop_bodies[instr->while_body()] = while_loop_config;\n-      metadata.bodies[instr->while_body()] = instr;\n-    }\n-    metadata.unfuse_slice = unfuse_slice;\n-    return metadata;\n-  }\n-  absl::flat_hash_map<HloComputation*, WhileLoopConfig> unrollable_loop_bodies;\n-  absl::flat_hash_map<const HloComputation*, HloInstruction*> bodies;\n-  // Vector containing pairs of custom patterns and their corresponding handler\n-  // lambdas. The patterns are checked in the order in which they are inserted\n-  // into this vector.\n-  std::vector<\n-      std::pair<std::function<std::optional<PatternInfo>(\n-                    const UnstackerMetadata&, const HloInstruction*, int64_t)>,\n-                std::function<absl::Status(HloInstruction*, const Shape&)>>>\n-      custom_handlers;\n-  std::function<bool(HloInstruction*)> unfuse_slice;\n-};\n-\n-// Performs the two-step unstacking. Each instance of this class is responsible\n-// for a single operand of a while loop.\n-class UnstackerTransformer {\n- public:\n-  // Default unroll_factor of -1 indicates full unrolling\n-  explicit UnstackerTransformer(const UnstackerMetadata& metadata)\n-      : metadata_(metadata) {}\n-\n-  // Given an instruction and the index of the its changed operand, it applies\n-  // the custom handler and populates body_changes lambdas that unstacks the hlo\n-  // graph accordingly.\n-  std::vector<const HloInstruction*> HandleInstruction(\n-      const HloInstruction* instr, int64_t changed_idx) {\n-    // Currently, we only unstack operands that are used within fusion\n-    // computations.\n-    if (instr->opcode() != HloOpcode::kFusion) {\n-      return {};\n-    }\n-    VLOG(3) << \"HandleInstruction(\" << instr->shape().ToString()\n-            << instr->name() << \", \" << changed_idx << \")\";\n-\n-    for (const auto& [custom_pattern, custom_handler] :\n-         metadata_.custom_handlers) {\n-      std::optional<PatternInfo> stacked_user =\n-          custom_pattern(metadata_, instr, changed_idx);\n-      // Try the next pattern if current pattern is not found.\n-      if (!stacked_user.has_value()) {\n-        continue;\n-      }\n-      PatternInfo& pattern_info = stacked_user.value();\n-      pattern_type_ = pattern_info.type;\n-      VLOG(3) << \"PatternInfo:\" << \"\\n\" << pattern_info.ToString();\n-\n-      if (pattern_info.unstacking_computation != nullptr &&\n-          unstacking_computation_ != nullptr) {\n-        if (!absl::EqualsIgnoreCase(\n-                pattern_info.unstacking_computation->ToString(\n-                    HloPrintOptions::Fingerprint()),\n-                unstacking_computation_->ToString(\n-                    HloPrintOptions::Fingerprint()))) {\n-          VLOG(3) << \"Seen multiple unstacking computations, cannot handle: \"\n-                  << \"\\n previous computations: \\n\"\n-                  << unstacking_computation_->ToString(\n-                         HloPrintOptions::Fingerprint())\n-                  << \"\\n current computations: \\n\"\n-                  << pattern_info.unstacking_computation->ToString(\n-                         HloPrintOptions::Fingerprint());\n-          return {};\n-        }\n-      }\n-\n-      if (pattern_info.unstacking_computation != nullptr) {\n-        unstacking_computation_ = pattern_info.unstacking_computation;\n-      }\n-\n-      unstacked_shape_ = std::make_unique<Shape>(pattern_info.unstacked_shape);\n-      unstacked_instrs_.push_back(instr);\n-\n-      // Wrapper function around the unstacker lambda which calls the unstacker.\n-      std::function<absl::Status()> unstack_wrapper =\n-          [&custom_handler = custom_handler,\n-           pattern_info]() mutable -> absl::Status {\n-        HloInstruction* mutable_dynamic_slicing_fusion =\n-            const_cast<HloInstruction*>(pattern_info.instr);\n-        return custom_handler(mutable_dynamic_slicing_fusion,\n-                              pattern_info.unstacked_shape.tuple_shapes(0));\n-      };\n-      body_changes_.push_back(unstack_wrapper);\n-      return pattern_info.unstacked_instrs;\n-    }\n-    return {};\n-  }\n-\n-  const UnstackerMetadata& GetMetadata() const { return metadata_; }\n-\n-  std::vector<const HloInstruction*>& GetUnstackedInstructions() {\n-    return unstacked_instrs_;\n-  }\n-\n-  const Shape* GetUnstackedShape() const { return unstacked_shape_.get(); }\n-\n-  // The function returns a mutable pointer to the unstacking computation since\n-  // the pointer is later used to clone the computation.\n-  HloComputation* GetUnstackingComputation() const {\n-    return unstacking_computation_;\n-  }\n-\n-  std::vector<std::function<void(const UnstackerTransformer&)>>&\n-  GetLoopChanges() {\n-    return loop_changes_;\n-  }\n-\n-  std::vector<std::function<absl::Status()>>& GetBodyChanges() {\n-    return body_changes_;\n-  }\n-\n-  absl::flat_hash_map<HloInstruction*, std::vector<int64_t>>&\n-  GetOperandChanges() {\n-    return operand_changes_;\n-  }\n-\n-  void AddOperandChange(HloInstruction* instr, int64_t index) {\n-    operand_changes_[instr].push_back(index);\n-  }\n-\n-  void AddLoopChange(\n-      std::function<void(const UnstackerTransformer&)> loop_change) {\n-    loop_changes_.push_back(loop_change);\n-  }\n-\n-  PatternType GetPatternType() const { return pattern_type_; }\n-\n- private:\n-  PatternType pattern_type_;\n-  const UnstackerMetadata& metadata_;\n-  // This pointer is populated if the unstacker finds unstackable loop input.\n-  std::unique_ptr<Shape> unstacked_shape_ = nullptr;\n-  // This is a pointer to the computation that is responsible for unstacking. It\n-  // is used to hoist the unstacking computations outside the loop bodies.\n-  // std::unique_ptr<HloComputation>\n-  HloComputation* unstacking_computation_ = nullptr;\n-  // A vector of lambdas that describe necessary changes to the shape of the\n-  // loops to unstack. The lambdas accept the pointer to the new unstacked\n-  // shape.\n-  std::vector<std::function<void(const UnstackerTransformer&)>> loop_changes_;\n-  // a list of lambdas that captures all the changes to the hlo graph needed for\n-  // unstacking.\n-  std::vector<std::function<absl::Status()>> body_changes_;\n-  // A map that tracks the index of the changed operand for instructions of type\n-  // get-tuple-element, tuple, and while during unstacking.\n-  absl::flat_hash_map<HloInstruction*, std::vector<int64_t>> operand_changes_;\n-  // Holds the list of unstacked instructions that will be used to identify\n-  // loops that need to be unrolled.\n-  std::vector<const HloInstruction*> unstacked_instrs_;\n-};\n-\n-bool CanUnstackWhileOperand(const HloInstruction* while_instr,\n-                            UnstackerTransformer& unstacker, int64_t index);\n-\n-bool UnstackWhileOperandAtIndex(\n-    const UnstackerMetadata& metadata, HloInstruction* while_instr,\n-    int64_t index, std::vector<const HloInstruction*>& unstacked_instructions);\n-\n-// Given a gte and an unstacker instance, this function walks down the graph of\n-// the users in BFS manner and propagates the index of the changed input operand\n-// for kGetTupleElement, kTuple, and kWhile instructions. Moreover, if checks if\n-// the a user should be handled with the provided custom handler(s) inside the\n-// unstacker instance. Note that this function does NOT change the shape of any\n-// instruction, it merely keeps track of the instructions and where in the input\n-// operands the change need to be applied later.\n-bool PropagateGteShapeChange(HloInstruction* gte,\n-                             UnstackerTransformer& unstacker) {\n-  VLOG(5) << \"PropagateGteShapeChange(\" << gte->name() << \")\";\n-\n-  HloInstruction* parent_while = nullptr;\n-  if (unstacker.GetMetadata().bodies.contains(gte->parent())) {\n-    parent_while = unstacker.GetMetadata().bodies.at(gte->parent());\n-    if (parent_while->while_body() != gte->parent()) {\n-      parent_while = nullptr;\n-    }\n-  }\n-\n-  std::vector<const HloInstruction*> handled_instrs;\n-  // TODO: b/343457903 - Use HloDataflowAnalysis to track the usage of a value\n-  // instead of manually applying bfs\n-  //\n-  // Apply BFS to propagate the index of the changed operand. We put all the\n-  // changed instructions along with the index of the changed operand in the\n-  // visited map and then propagate the change to the users of the instruction.\n-  absl::flat_hash_map<HloInstruction*, int64_t> visited;\n-  std::deque<HloInstruction*> worklist;\n-  worklist.push_back(gte);\n-  visited.insert({gte, gte->tuple_index()});\n-  unstacker.AddOperandChange(gte, gte->tuple_index());\n-  while (!worklist.empty()) {\n-    HloInstruction* changed_instr_to_propagate = worklist.front();\n-    // The index of the changed operand that needs to be propagated.\n-    int64_t changed_operand_index =\n-        FindOrDie(visited, changed_instr_to_propagate);\n-    worklist.pop_front();\n-    for (HloInstruction* user : changed_instr_to_propagate->users()) {\n-      if (ContainsKey(visited, user)) {\n-        continue;\n-      }\n-      // We explicitly propagate the changed index for three types of users,\n-      // namely, get-tuple-element, tuple and while users. The rationale is that\n-      // the output shape of these three instruction types are inferred only by\n-      // their input operand(s). Finally, we check if the user can be handled by\n-      // the provided custom handler in HandleInstruction method.\n-      if (user->opcode() == HloOpcode::kGetTupleElement) {\n-        if (user->tuple_index() != changed_operand_index) {\n-          continue;\n-        }\n-        // Since we insert the gte user only if the index of the gte is equal to\n-        // the changed operand of its tuple input, we are sure that this gte\n-        // instruction will get the new shape eventually and the\n-        // change_operand_index does not matter.\n-        visited.insert({user, changed_operand_index});\n-        unstacker.AddOperandChange(user, changed_operand_index);\n-        worklist.push_back(user);\n-      } else if (user->opcode() == HloOpcode::kTuple) {\n-        for (int64_t i = 0; i < user->operand_count(); ++i) {\n-          if (user->operand(i) == changed_instr_to_propagate) {\n-            visited.insert({user, i});\n-            unstacker.AddOperandChange(user, i);\n-            worklist.push_back(user);\n-            if (parent_while != nullptr && user->IsRoot() &&\n-                i != gte->tuple_index()) {\n-              bool changed_nested_while =\n-                  CanUnstackWhileOperand(parent_while, unstacker, i);\n-              if (!changed_nested_while) {\n-                return false;\n-              }\n-            }\n-          }\n-        }\n-      } else if (user->opcode() == HloOpcode::kWhile) {\n-        // Recursively check the inner while for unstacking and populate\n-        // unstacker instance.\n-        bool changed_nested_while =\n-            CanUnstackWhileOperand(user, unstacker, changed_operand_index);\n-        if (!changed_nested_while) {\n-          return false;\n-        }\n-        visited.insert({user, changed_operand_index});\n-        unstacker.AddOperandChange(user, changed_operand_index);\n-        worklist.push_back(user);\n-      } else {\n-        if (absl::c_find(handled_instrs, user) != handled_instrs.end()) {\n-          continue;\n-        }\n-        // If already unstacked, we do not need to handle again.\n-        if (user->IsCustomCall(\"DynamicGte\") ||\n-            user->IsCustomCall(\"DynamicTuple\")) {\n-          continue;\n-        }\n-        int64_t use_index = user->operand_index(changed_instr_to_propagate);\n-        std::vector<const HloInstruction*> curr_handled_instrs =\n-            unstacker.HandleInstruction(user, use_index);\n-        if (curr_handled_instrs.empty()) {\n-          VLOG(3) << \"Custom unstacker not found for \" << user->name();\n-          return false;\n-        }\n-        for (const HloInstruction* instr : curr_handled_instrs) {\n-          // TODO: b/352400145 - Here we check if the user has the same shape as\n-          // the stacked tensor (how to capture this more robustly?). if so, we\n-          // need to add the user to the worklist to get updated.\n-          for (HloInstruction* handled_instr_user : instr->users()) {\n-            if (user->shape() == gte->shape()) {\n-              visited.insert({handled_instr_user, changed_operand_index});\n-              unstacker.AddOperandChange(handled_instr_user,\n-                                         changed_operand_index);\n-              worklist.push_back(handled_instr_user);\n-            }\n-          }\n-          handled_instrs.push_back(instr);\n-        }\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-// Within the given computation, finds all the gte instruction with the\n-// following form: get-tuple-elements(operand), index=idx and collects all the\n-// new shapes. new_shape is the new shape at idx of the operand of the gte.\n-bool CanPropagateGteShapeChangesInComputation(\n-    const HloComputation* comp, const HloInstruction* operand,\n-    UnstackerTransformer& shape_transformer, int64_t idx) {\n-  VLOG(3) << \"Propagating shape change of index \" << idx\n-          << \" in : \" << comp->name();\n-  for (HloInstruction* instr : comp->MakeInstructionPostOrder()) {\n-    // We only need to propagate changes through the gte instructions with index\n-    // = idx.\n-    if (instr->opcode() == HloOpcode::kGetTupleElement &&\n-        instr->tuple_index() == idx) {\n-      if (instr->operand(0) != operand) {\n-        continue;\n-      }\n-      // If propagation is not possible (no custom handler provided for the\n-      // users of the candidate), we bail early.\n-      bool can_propagate = PropagateGteShapeChange(instr, shape_transformer);\n-      if (!can_propagate) {\n-        VLOG(3) << \"Failed to propagate shape change for \" << instr->name();\n-        return false;\n-      }\n-    }\n-  }\n-  VLOG(3) << \"Finish propagating shape change of index \" << idx\n-          << \" in: \" << comp->name();\n-  return true;\n-}\n-\n-std::unique_ptr<HloInstruction> DynamicSliceToSlice(\n-    HloInstruction* dynamic_slice, HloInstruction* input, int64_t i) {\n-  std::vector<int64_t> new_start_indices;\n-  new_start_indices.reserve(dynamic_slice->shape().dimensions().size());\n-  std::vector<int64_t> new_limit_indices;\n-  new_limit_indices.reserve(dynamic_slice->shape().dimensions().size());\n-  std::vector<int64_t> new_strides;\n-  new_strides.reserve(dynamic_slice->shape().dimensions().size());\n-  new_start_indices.push_back(i);\n-  new_limit_indices.push_back(i + 1);\n-  new_strides.push_back(1);\n-  for (int64_t j = 1; j < dynamic_slice->shape().dimensions().size(); ++j) {\n-    new_start_indices.push_back(0);\n-    new_limit_indices.push_back(\n-        dynamic_slice->mutable_operand(0)->shape().dimensions(j));\n-    new_strides.push_back(1);\n-  }\n-  return HloInstruction::CreateSlice(dynamic_slice->shape(), input,\n-                                     new_start_indices, new_limit_indices,\n-                                     new_strides);\n-}\n-\n-bool ShouldUnfuseSlices(const UnstackerMetadata& metadata, HloInstruction* ds) {\n-  HloInstruction* input = ds->mutable_operand(0);\n-  for (int64_t i = 0; i < input->shape().dimensions(0); ++i) {\n-    HloInstruction* slice =\n-        ds->AddInstruction(DynamicSliceToSlice(ds, input, i));\n-    if (!metadata.unfuse_slice(slice)) {\n-      CHECK_OK(slice->parent()->RemoveInstruction(slice));\n-      return false;\n-    }\n-    CHECK_OK(slice->parent()->RemoveInstruction(slice));\n-  }\n-  return true;\n-}\n-\n-// This function is responsible for:\n-// 1. Hoisting the unstacking computation outside the while_instr.\n-// 2. Replacing the input of the while_instr with the new unstacked version.\n-void UnstackWhileInput(const UnstackerTransformer& unstacker,\n-                       HloInstruction* while_instr, int64_t index) {\n-  VLOG(3) << \"Unstacking while input: \" << while_instr->name() << \" at \"\n-          << index;\n-  const Shape* new_shape = unstacker.GetUnstackedShape();\n-  HloComputation* unstacking_computation = unstacker.GetUnstackingComputation();\n-  const Shape& slice_shape = new_shape->tuple_shapes(0);\n-  HloInstruction* old_while_input =\n-      while_instr->while_init()->mutable_operand(index);\n-  // If the input is a tuple, i.e., while_instr has already been unstacked\n-  // during unstacking of its parent, we do not need to unstack it again.\n-  if (old_while_input->shape().IsTuple()) {\n-    VLOG(3) << \"Input is already unstacked: \" << old_while_input->name();\n-    return;\n-  }\n-\n-  std::vector<HloInstruction*> slices;\n-  // If the input is an AllocateBuffer, we simply break it down into a tuple of\n-  // AllocateBuffer instructions, one per slice.\n-  if (old_while_input->IsCustomCall(\"AllocateBuffer\")) {\n-    for (int64_t i = 0; i < new_shape->tuple_shapes().size(); ++i) {\n-      slices.push_back(while_instr->AddInstruction(\n-          HloInstruction::CreateCustomCall(slice_shape, {}, \"AllocateBuffer\")));\n-    }\n-  } else {\n-    // TODO: b/341815540 - Instead of creating the unstacked tuple for every\n-    // input index, we should reuse if the input and unstacking computations are\n-    // the same.\n-    //\n-    // Hoist the unstacking computation outside the while_instr and create a\n-    // tuple of slices.\n-    for (int64_t i = 0; i < new_shape->tuple_shapes().size(); ++i) {\n-      HloInstruction* root_instr = unstacking_computation->root_instruction();\n-      // TODO: b/352400145 - After unifying patterns and handlers, instead of\n-      // using the pattern type to determine the unstacked input, we should use\n-      // the pattern object to call the appropriate method.\n-      //\n-      // For DSFusionPattern and NestedDSFusionPattern, we rewrite the\n-      // dynamic-slice as a slice instruction in the hope that these slices are\n-      // later prefetched using async-slice by MSA. For other patterns, we\n-      // resort to the original unstacking computation until we find benefit in\n-      // doing otherwise.\n-      HloInstruction* slice = nullptr;\n-      if (unstacker.GetPatternType() == PatternType::DSFusionPattern ||\n-          unstacker.GetPatternType() == PatternType::NestedDSFusionPattern ||\n-          unstacker.GetPatternType() == PatternType::DSFusionNoBitcastPattern) {\n-        if (unstacker.GetPatternType() == PatternType::DSFusionPattern ||\n-            unstacker.GetPatternType() == PatternType::NestedDSFusionPattern) {\n-          slice = while_instr->AddInstruction(DynamicSliceToSlice(\n-              root_instr->mutable_operand(0), old_while_input, i));\n-        } else if (unstacker.GetPatternType() ==\n-                   PatternType::DSFusionNoBitcastPattern) {\n-          slice = while_instr->AddInstruction(\n-              DynamicSliceToSlice(root_instr, old_while_input, i));\n-        }\n-      }\n-      if (slice == nullptr || !unstacker.GetMetadata().unfuse_slice(slice)) {\n-        std::vector<HloInstruction*> operands = {\n-            old_while_input,\n-            while_instr->AddInstruction(MakeScalarConstantWithShape(\n-                unstacking_computation->parameter_instruction(1)->shape(), i))};\n-        slice = while_instr->AddInstruction(HloInstruction::CreateFusion(\n-            slice_shape, HloInstruction::FusionKind::kLoop, operands,\n-            while_instr->GetModule()->AddEmbeddedComputation(\n-                unstacking_computation->Clone()),\n-            \"hoisted\"));\n-      }\n-      slices.push_back(slice);\n-    }\n-  }\n-  HloInstruction* new_operand_element =\n-      while_instr->AddInstruction(HloInstruction::CreateTuple(slices));\n-  HloInstruction* new_while_init =\n-      TupleUtil::ReplaceTupleWith(new_operand_element,\n-                                  while_instr->while_init(), {index}, false)\n-          .value();\n-  CHECK_OK(while_instr->ReplaceOperandWithDifferentShape(0, new_while_init));\n-}\n-\n-bool CanUnstackWhileOperand(const HloInstruction* while_instr,\n-                            UnstackerTransformer& unstacker, int64_t index) {\n-  VLOG(5) << \"ReplaceWhileOperandShape: \" << while_instr->name() << \" at \"\n-          << index;\n-\n-  bool body_changes_collected = CanPropagateGteShapeChangesInComputation(\n-      while_instr->while_body(),\n-      while_instr->while_body()->parameter_instruction(0), unstacker, index);\n-  if (!body_changes_collected) {\n-    return false;\n-  }\n-\n-  bool condition_changes_collected = CanPropagateGteShapeChangesInComputation(\n-      while_instr->while_condition(),\n-      while_instr->while_condition()->parameter_instruction(0), unstacker,\n-      index);\n-  if (!condition_changes_collected) {\n-    return false;\n-  }\n-\n-  // Check if we can propagate the changes through the output of the while\n-  // at index.\n-  bool parent_changes_collected = CanPropagateGteShapeChangesInComputation(\n-      while_instr->parent(), while_instr, unstacker, index);\n-  if (!parent_changes_collected) {\n-    VLOG(3) << \"Failed: parent_changes_collected\";\n-    return false;\n-  }\n-\n-  HloInstruction* root_operand =\n-      while_instr->while_body()->root_instruction()->mutable_operand(index);\n-  if (root_operand == nullptr) {\n-    return false;\n-  }\n-\n-  HloInstruction* gte_operand = nullptr;\n-  // Currently, we only support unstacking of while operands that either:\n-  // 1. Are parameters of the while_body.\n-  // 2. Are get-tuple-elements of another while instruction.\n-  if (Match(root_operand, match::GetTupleElement(match::Op(&gte_operand)))) {\n-    if (Match(gte_operand, match::While())) {\n-      VLOG(3) << \"Faced a gte originating from loop: \"\n-              << root_operand->ToString();\n-      bool loop_feeding_root_changes_collected = CanUnstackWhileOperand(\n-          root_operand->operand(0), unstacker, root_operand->tuple_index());\n-      if (!loop_feeding_root_changes_collected) {\n-        VLOG(3) << \"Failed: loop \" << root_operand->operand(0)->name()\n-                << \" output at \" << index << \" is not unstackable\";\n-        return false;\n-      }\n-    } else if (!Match(gte_operand, match::Parameter().WithParameterNum(0))) {\n-      VLOG(3) << \"Failed: root operand of while_body at \" << index\n-              << \" is not a parameter\";\n-      return false;\n-    }\n-  }\n-\n-  auto loop_change = [=](const UnstackerTransformer& unstacker,\n-                         HloInstruction* loop, int64_t idx) mutable {\n-    Shape old_shape = ShapeUtil::MakeStaticShape(\n-        loop->while_body()->parameter_instruction(0)->shape());\n-    ShapeUtil::UpdateTupleShape(*unstacker.GetUnstackedShape(), idx,\n-                                &old_shape);\n-\n-    loop->while_body()->ReplaceParameter(\n-        0, HloInstruction::CreateParameter(0, old_shape, \"unstacked\"));\n-    loop->while_condition()->ReplaceParameter(\n-        0, HloInstruction::CreateParameter(0, old_shape, \"unstacked\"));\n-\n-    CHECK_NE(unstacker.GetUnstackingComputation(), nullptr);\n-    UnstackWhileInput(unstacker, loop, idx);\n-    // Update the input and output shape of the loop.\n-    *loop->mutable_shape() = old_shape;\n-  };\n-  auto loop_change_wrapper = [&loop_change, while_instr,\n-                              index](const UnstackerTransformer& unstacker) {\n-    HloInstruction* mutable_loop = const_cast<HloInstruction*>(while_instr);\n-    loop_change(unstacker, mutable_loop, index);\n-  };\n-  unstacker.AddLoopChange(loop_change_wrapper);\n-  return true;\n-}\n-\n-// Apply the two-step unstacking algorithm to the given while_instr at the given\n-// index.\n-bool UnstackWhileOperandAtIndex(\n-    const UnstackerMetadata& metadata, HloInstruction* while_instr,\n-    int64_t index, std::vector<const HloInstruction*>& unstacked_instructions) {\n-  UnstackerTransformer unstacker = UnstackerTransformer(metadata);\n-\n-  // First step of unstacking to determine whether while_instr at index is\n-  // unstackable.\n-  bool can_unstack = CanUnstackWhileOperand(while_instr, unstacker, index);\n-  if (!can_unstack) {\n-    VLOG(3) << \"Unstacking failed for \" << while_instr->name() << \" at \"\n-            << index;\n-    return false;\n-  }\n-\n-  // If unstacker has not found an unstackable shape, there is no point in\n-  // applying the unstacker changes.\n-  if (unstacker.GetUnstackedShape() == nullptr) {\n-    VLOG(3) << \"Failed: unstacked shape is null\";\n-    return false;\n-  }\n-\n-  // If unstacker has not found an unstackable shape, there is no point in\n-  // applying the unstacker changes.\n-  if (unstacker.GetUnstackingComputation() == nullptr) {\n-    VLOG(3) << \"Failed: unstacking computation is null\";\n-    return false;\n-  }\n-\n-  // At this point, we have the unstacked_shape at hand. We go ahead and apply\n-  // all the changes that required the unstacked shape.\n-  //\n-  // Update the shape of get-tuple-element, tuple, and, while instructions\n-  // based on the unstacked_shape and the index of the changed operand.\n-  for (auto& [instr, indices] : unstacker.GetOperandChanges()) {\n-    switch (instr->opcode()) {\n-      case HloOpcode::kGetTupleElement:\n-        VLOG(3) << \"Changing shape of: \" << instr->name();\n-        *instr->mutable_shape() = *unstacker.GetUnstackedShape();\n-        break;\n-      case HloOpcode::kTuple: {\n-        for (int64_t index : indices) {\n-          VLOG(3) << \"Changing shape of: \" << instr->name() << \" at \" << index;\n-          *instr->mutable_shape()->mutable_tuple_shapes(index) =\n-              *unstacker.GetUnstackedShape();\n-        }\n-        break;\n-      }\n-      case HloOpcode::kWhile:\n-        for (int64_t index : indices) {\n-          VLOG(3) << \"Changing shape of: \" << instr->name() << \" at \" << index;\n-          ShapeUtil::UpdateTupleShape(*unstacker.GetUnstackedShape(), index,\n-                                      instr->mutable_shape());\n-        }\n-        break;\n-      default:\n-        LOG(FATAL) << \"Unsupported opcode: \" << instr->name();\n-    }\n-  }\n-  // Apply the changes to the body according to the provided custom handler.\n-  for (const auto& body_change : unstacker.GetBodyChanges()) {\n-    CHECK_OK(body_change());\n-  }\n-  // Apply the changes to the shape of the loop body and condition computations.\n-  for (auto& loop_change : unstacker.GetLoopChanges()) {\n-    loop_change(unstacker);\n-  }\n-  for (const HloInstruction* instr : unstacker.GetUnstackedInstructions()) {\n-    unstacked_instructions.push_back(instr);\n-  }\n-  return true;\n-}\n-\n-Shape MakeUnstackedShapeFromSlice(const Shape& slice_shape, int64_t layers) {\n-  std::vector<Shape> shapes;\n-  shapes.reserve(layers);\n-  for (int64_t i = 0; i < layers; ++i) {\n-    shapes.push_back(slice_shape);\n-  }\n-  return ShapeUtil::MakeTupleShape(shapes);\n-}\n-\n-// Checks if the given instruction is a fusion with num_fusion_params\n-// parameters inside an unrollable loop. If so, it returns the loop config.\n-std::optional<WhileLoopConfig> IsFusionInsideUnrollableLoopWithNumParameter(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    std::optional<int64_t> num_fusion_params) {\n-  if (instr->opcode() != HloOpcode::kFusion) {\n-    return std::nullopt;\n-  }\n-  if (num_fusion_params.has_value()) {\n-    if (instr->fused_parameters().size() != num_fusion_params) {\n-      VLOG(3) << \"Fusion has different number of parameters\";\n-      return std::nullopt;\n-    }\n-  }\n-  if (!metadata.unrollable_loop_bodies.contains(instr->parent())) {\n-    VLOG(5) << \"Fusion not inside unrollable while body, \" << instr->name()\n-            << \" inside \" << instr->parent()->name();\n-    return std::nullopt;\n-  }\n-  return metadata.unrollable_loop_bodies.at(instr->parent());\n-}\n-\n-// Checks if the instruction is a fusion with num_fusion_params parameters\n-// inside an unrollable loop and within its fusion computation there is an\n-// effectively static dynamic-slice instruction on the most major dimension of\n-// the operand at the given stacked_operand_idx. If so, it returns the\n-// dynamic-slice instruction.\n-HloInstruction* GetMostMajorEffectivelyStaticDynamicSliceInFusion(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    std::optional<int64_t> num_fusion_params, int64_t stacked_operand_idx) {\n-  std::optional<WhileLoopConfig> while_instr_config =\n-      IsFusionInsideUnrollableLoopWithNumParameter(metadata, instr,\n-                                                   num_fusion_params);\n-  if (!while_instr_config.has_value()) {\n-    return nullptr;\n-  }\n-  for (HloInstruction* fused_instr :\n-       instr->fused_instructions_computation()->MakeInstructionPostOrder()) {\n-    std::optional<int64_t> dynamic_index =\n-        MatchEffectivelyStaticDynamicSliceInsideLoop(\n-            fused_instr,\n-            instr->fused_instructions_computation()->parameter_instruction(\n-                stacked_operand_idx),\n-            while_instr_config.value());\n-    if (dynamic_index.has_value() && dynamic_index.value() == 0) {\n-      return fused_instr;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-// Checks if the instruction is a fusion with num_fusion_params parameters\n-// inside an unrollable loop and within its fusion computation looks for the\n-// dynamic-index instruction that covers the shape of the operand at the given\n-// index.\n-HloInstruction* GetMostMajorShapeCoveringDynamicIndexInFusion(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    HloOpcode opcode, int64_t num_fusion_params, int64_t stacked_operand_idx) {\n-  std::optional<WhileLoopConfig> while_instr_config =\n-      IsFusionInsideUnrollableLoopWithNumParameter(metadata, instr,\n-                                                   num_fusion_params);\n-  if (!while_instr_config.has_value()) {\n-    return nullptr;\n-  }\n-  for (HloInstruction* fused_instr :\n-       instr->fused_instructions_computation()->MakeInstructionPostOrder()) {\n-    if (fused_instr->opcode() != opcode) {\n-      continue;\n-    }\n-    std::optional<int64_t> dynamic_index =\n-        MatchShapeCoveringDynamicIndexInstruction(\n-            fused_instr,\n-            instr->fused_instructions_computation()->parameter_instruction(\n-                stacked_operand_idx),\n-            opcode, while_instr_config.value());\n-    if (dynamic_index.has_value() && dynamic_index.value() == 0) {\n-      return fused_instr;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-// This function recognizes fusions with the following pattern:\n-// fusion(stacked, f(loop_iteration_var))\n-// computation {\n-//   p0 = parameter(0)\n-//   p1 = parameter(1)\n-//   slice = dynamic_slice(p0, p1, zero, ...)\n-//   ROOT bitcast = bitcast(slice)\n-// }\n-// where f is a function of loop_iteration_var. It indicates that the slicing\n-// offset is effectively static after unrolling.\n-std::optional<PatternInfo> GetDSFusionPattern(const UnstackerMetadata& metadata,\n-                                              const HloInstruction* instr,\n-                                              int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking DSFusion\";\n-  HloInstruction* shape_covering_instr =\n-      GetMostMajorEffectivelyStaticDynamicSliceInFusion(metadata, instr, 2,\n-                                                        stacked_operand_idx);\n-  if (shape_covering_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  if (!ShouldUnfuseSlices(metadata, shape_covering_instr)) {\n-    return std::nullopt;\n-  }\n-  HloInstruction* bitcast_operand = nullptr;\n-  if (Match(instr->fused_instructions_computation()->root_instruction(),\n-            match::Bitcast(match::Op(&bitcast_operand)))) {\n-    if (bitcast_operand == shape_covering_instr) {\n-      PatternInfo pattern_info;\n-      pattern_info.type = PatternType::DSFusionPattern;\n-      pattern_info.instr = instr;\n-      const Shape& slice_shape = shape_covering_instr->shape();\n-      const int64_t num_layers = instr->operand(0)->shape().dimensions(0);\n-      pattern_info.unstacked_shape =\n-          MakeUnstackedShapeFromSlice(slice_shape, num_layers);\n-      pattern_info.unstacking_computation =\n-          instr->fused_instructions_computation();\n-      pattern_info.unstacked_instrs.push_back(instr);\n-      return pattern_info;\n-    }\n-  }\n-  return std::nullopt;\n-}\n-\n-absl::Status UnstackDSFusionPattern(\n-    HloInstruction* mutable_dynamic_slicing_fusion, const Shape& slice_shape) {\n-  HloComputation* parent_loop = mutable_dynamic_slicing_fusion->parent();\n-\n-  HloInstruction* stacked = mutable_dynamic_slicing_fusion->mutable_operand(0);\n-  HloInstruction* offset = mutable_dynamic_slicing_fusion->mutable_operand(1);\n-\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          slice_shape, {stacked, offset}, \"DynamicGte\"));\n-\n-  HloInstruction* bitcast = mutable_dynamic_slicing_fusion->AddInstruction(\n-      HloInstruction::CreateBitcast(mutable_dynamic_slicing_fusion->shape(),\n-                                    new_operand));\n-  return mutable_dynamic_slicing_fusion->ReplaceAllUsesWithDifferentShape(\n-      bitcast);\n-}\n-\n-// This function recognizes fusions with the following pattern:\n-// fusion(stacked, f(loop_iteration_var))\n-// computation {\n-//   p0 = parameter(0)\n-//   p1 = parameter(1)\n-//   ROOT slice = dynamic_slice(p0, p1, zero, ...)\n-// }\n-// where f is a function of loop_iteration_var. It indicates that the slicing\n-// offset is effectively static after unrolling.\n-std::optional<PatternInfo> GetDSFusionNoBitcastPattern(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking DSFusionNoBitcast\";\n-  HloInstruction* shape_covering_instr =\n-      GetMostMajorEffectivelyStaticDynamicSliceInFusion(metadata, instr, 2,\n-                                                        stacked_operand_idx);\n-  if (shape_covering_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  if (instr->fused_instructions_computation()->root_instruction() !=\n-      shape_covering_instr) {\n-    return std::nullopt;\n-  }\n-  PatternInfo pattern_info;\n-  pattern_info.type = PatternType::DSFusionNoBitcastPattern;\n-  pattern_info.instr = instr;\n-  const Shape& slice_shape = shape_covering_instr->shape();\n-  const int64_t num_layers = instr->operand(0)->shape().dimensions(0);\n-  pattern_info.unstacked_shape =\n-      MakeUnstackedShapeFromSlice(slice_shape, num_layers);\n-  pattern_info.unstacking_computation = instr->fused_instructions_computation();\n-  pattern_info.unstacked_instrs.push_back(instr);\n-  return pattern_info;\n-}\n-\n-absl::Status UnstackDSFusionNoBitcastPattern(\n-    HloInstruction* mutable_dynamic_slicing_fusion, const Shape& slice_shape) {\n-  HloComputation* parent_loop = mutable_dynamic_slicing_fusion->parent();\n-\n-  HloInstruction* stacked = mutable_dynamic_slicing_fusion->mutable_operand(0);\n-  HloInstruction* offset = mutable_dynamic_slicing_fusion->mutable_operand(1);\n-\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          slice_shape, {stacked, offset}, \"DynamicGte\"));\n-\n-  return mutable_dynamic_slicing_fusion->ReplaceAllUsesWithDifferentShape(\n-      new_operand);\n-}\n-\n-// This function recognizes fusions with the following pattern:\n-// fusion(stacked, update, loop_iteration_var)\n-// computation {\n-//   p0 = parameter(0)\n-//   p1 = parameter(1)\n-//   p2 = parameter(2)\n-//   update = bitcast(p1)\n-//   ROOT dus = dynamic_update_slice(p0, update, p2, zero, ...)\n-// }\n-std::optional<PatternInfo> GetDUSFusionPattern(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking DUSFusion\";\n-  HloInstruction* shape_covering_instr =\n-      GetMostMajorShapeCoveringDynamicIndexInFusion(\n-          metadata, instr, HloOpcode::kDynamicUpdateSlice, 3,\n-          stacked_operand_idx);\n-  if (shape_covering_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  if (Match(shape_covering_instr->operand(1),\n-            match::Bitcast(match::Parameter()))) {\n-    if (shape_covering_instr->parent()->root_instruction() ==\n-        shape_covering_instr) {\n-      PatternInfo pattern_info;\n-      pattern_info.type = PatternType::Other;\n-      pattern_info.instr = instr;\n-      pattern_info.unstacked_shape = MakeUnstackedShapeFromSlice(\n-          instr->operand(2)->shape(), instr->operand(0)->shape().dimensions(0));\n-      pattern_info.unstacking_computation = nullptr;\n-      pattern_info.unstacked_instrs.push_back(instr);\n-      return pattern_info;\n-    }\n-  }\n-  return std::nullopt;\n-}\n-\n-absl::Status UnstackDUSFusionPattern(\n-    HloInstruction* mutable_dynamic_update_slicing_fusion,\n-    const Shape& slice_shape) {\n-  HloComputation* parent_loop = mutable_dynamic_update_slicing_fusion->parent();\n-  // TODO: (b/350043079) - automatically find the input, offset and update\n-  // indices.\n-  HloInstruction* stacked =\n-      mutable_dynamic_update_slicing_fusion->mutable_operand(0);\n-  HloInstruction* offset =\n-      mutable_dynamic_update_slicing_fusion->mutable_operand(1);\n-  HloInstruction* update =\n-      mutable_dynamic_update_slicing_fusion->mutable_operand(2);\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          stacked->shape(), {stacked, update, offset}, \"DynamicTuple\"));\n-  for (HloInstruction* user : mutable_dynamic_update_slicing_fusion->users()) {\n-    TF_RETURN_IF_ERROR(\n-        mutable_dynamic_update_slicing_fusion->ReplaceUseWithDifferentShape(\n-            user, new_operand));\n-  }\n-  return absl::OkStatus();\n-}\n-\n-// This function recognizes fusions with the following pattern:\n-// fusion(stackd, update, loop_iteration_var)\n-// computation {\n-//   p0 = parameter(0)\n-//   p1 = parameter(1)\n-//   p2 = parameter(2)\n-//   pad = pad(p1, ...)\n-//   update = bitcast(pad)\n-//   ROOT dus = dynamic_update_slice(p0, update, p2, zero, ...)\n-// }\n-std::optional<PatternInfo> GetDUSFusionWithPadPattern(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking DUSFusionWithPad\";\n-  HloInstruction* shape_covering_instr =\n-      GetMostMajorShapeCoveringDynamicIndexInFusion(\n-          metadata, instr, HloOpcode::kDynamicUpdateSlice, 3,\n-          stacked_operand_idx);\n-  if (shape_covering_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  if (Match(\n-          shape_covering_instr->operand(1),\n-          match::Bitcast(match::Pad(match::Parameter(), match::Constant())))) {\n-    if (shape_covering_instr->parent()->root_instruction() ==\n-        shape_covering_instr) {\n-      const HloInstruction* pad_instr =\n-          shape_covering_instr->operand(1)->operand(0);\n-      PatternInfo pattern_info;\n-      pattern_info.type = PatternType::Other;\n-      pattern_info.instr = instr;\n-      pattern_info.unstacked_shape = MakeUnstackedShapeFromSlice(\n-          pad_instr->shape(),\n-          shape_covering_instr->operand(0)->shape().dimensions(0));\n-      pattern_info.unstacking_computation = nullptr;\n-      pattern_info.unstacked_instrs.push_back(instr);\n-      return pattern_info;\n-    }\n-  }\n-  return std::nullopt;\n-}\n-\n-// Unstacks the DUSFusionWithPad pattern by removing the dynamic-update-slice\n-// from the fusion and feeding the padding fusion to the dynamic-tuple\n-// custom-call.\n-absl::Status UnstackDUSFusionWithPadPattern(\n-    HloInstruction* mutable_dynamic_update_slicing_fusion,\n-    const Shape& slice_shape) {\n-  HloComputation* parent_loop = mutable_dynamic_update_slicing_fusion->parent();\n-  HloComputation* fused_computation =\n-      mutable_dynamic_update_slicing_fusion->fused_instructions_computation();\n-  HloInstruction* stacked =\n-      mutable_dynamic_update_slicing_fusion->mutable_operand(\n-          fused_computation->root_instruction()\n-              ->mutable_operand(0)\n-              ->parameter_number());\n-  HloInstruction* offset =\n-      mutable_dynamic_update_slicing_fusion->mutable_operand(\n-          fused_computation->root_instruction()\n-              ->mutable_operand(2)\n-              ->parameter_number());\n-\n-  HloInstruction* pad_instr = fused_computation->root_instruction()\n-                                  ->mutable_operand(1)\n-                                  ->mutable_operand(0);\n-  fused_computation->set_root_instruction(pad_instr, true);\n-  *mutable_dynamic_update_slicing_fusion->mutable_shape() = pad_instr->shape();\n-\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          stacked->shape(),\n-          {stacked, mutable_dynamic_update_slicing_fusion, offset},\n-          \"DynamicTuple\"));\n-  for (HloInstruction* user : mutable_dynamic_update_slicing_fusion->users()) {\n-    if (user != new_operand) {\n-      TF_RETURN_IF_ERROR(\n-          mutable_dynamic_update_slicing_fusion->ReplaceUseWithDifferentShape(\n-              user, new_operand));\n-    }\n-  }\n-  return absl::OkStatus();\n-}\n-\n-// This function recognizes fusions with the following pattern:\n-// fusion(stackd, update, loop_iteration_var)\n-// computation {\n-//   p0 = parameter(0)\n-//   p1 = parameter(1)\n-//   slice = dynamic-slice(p0, p1, zero)\n-//   broadcast = broadcast(constant)\n-//   add = add(slice, broadcast)\n-//   ROOT reduce = reduce(add, zero), apply=+\n-// }\n-std::optional<PatternInfo> GetDSFusionWithAddPattern(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking DSFusionWithAdd\";\n-  HloInstruction* shape_covering_instr =\n-      GetMostMajorShapeCoveringDynamicIndexInFusion(\n-          metadata, instr, HloOpcode::kDynamicSlice, 2, stacked_operand_idx);\n-  if (shape_covering_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  HloComputation* fused_computation = instr->fused_instructions_computation();\n-  HloInstruction* fusion_root = fused_computation->root_instruction();\n-  HloInstruction* add_operand;\n-  if (Match(fusion_root,\n-            match::Reduce(match::Add(match::Op(&add_operand),\n-                                     match::Broadcast(match::Constant())),\n-                          match::Constant()))) {\n-    if (add_operand == shape_covering_instr) {\n-      const int64_t num_layers = instr->operand(0)->shape().dimensions(0);\n-      PatternInfo pattern_info;\n-      pattern_info.type = PatternType::Other;\n-      pattern_info.instr = instr;\n-      pattern_info.unstacked_shape =\n-          MakeUnstackedShapeFromSlice(instr->shape(), num_layers);\n-      HloComputation::Builder builder(\"unstack_add\");\n-      HloInstruction* p0 =\n-          builder.AddInstruction(HloInstruction::CreateParameter(\n-              0, fused_computation->parameter_instruction(0)->shape(), \"p0\"));\n-      HloInstruction* p1 =\n-          builder.AddInstruction(HloInstruction::CreateParameter(\n-              1, fused_computation->parameter_instruction(1)->shape(), \"p1\"));\n-      HloInstruction* zero =\n-          builder.AddInstruction(MakeScalarConstantWithShape(p1->shape(), 0));\n-      std::vector<HloInstruction*> slice_starts;\n-      slice_starts.reserve(shape_covering_instr->shape().dimensions().size());\n-      slice_starts.push_back(p1);\n-      for (int64_t i = 0;\n-           i < static_cast<int64_t>(\n-                   shape_covering_instr->shape().dimensions().size()) -\n-                   1;\n-           i++) {\n-        slice_starts.push_back(zero);\n-      }\n-      HloInstruction* slice =\n-          builder.AddInstruction(HloInstruction::CreateDynamicSlice(\n-              shape_covering_instr->shape(), p0, slice_starts,\n-              shape_covering_instr->dynamic_slice_sizes()));\n-      HloInstruction* zero_reduce =\n-          builder.AddInstruction(MakeScalarConstantWithShape(\n-              ShapeUtil::MakeScalarShape(slice->shape().element_type()), 0));\n-      HloInstruction* reduce =\n-          builder.AddInstruction(HloInstruction::CreateReduce(\n-              instr->shape(), slice, zero_reduce, fusion_root->dimensions(),\n-              fused_computation->root_instruction()->to_apply()));\n-      HloComputation* unstack_add =\n-          instr->GetModule()->AddEmbeddedComputation(builder.Build());\n-      unstack_add->set_root_instruction(reduce);\n-      pattern_info.unstacking_computation = unstack_add;\n-      pattern_info.unstacked_instrs.push_back(instr);\n-      return pattern_info;\n-    }\n-  }\n-  return std::nullopt;\n-}\n-\n-absl::Status UnstackDSFusionWithAddPattern(\n-    HloInstruction* mutable_dynamic_slice_with_add_fusion,\n-    const Shape& slice_shape) {\n-  HloComputation* parent_loop = mutable_dynamic_slice_with_add_fusion->parent();\n-  HloInstruction* stacked =\n-      mutable_dynamic_slice_with_add_fusion->mutable_operand(0);\n-  HloInstruction* offset =\n-      mutable_dynamic_slice_with_add_fusion->mutable_operand(1);\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          slice_shape, {stacked, offset}, \"DynamicGte\"));\n-  HloInstruction* one = parent_loop->AddInstruction(MakeScalarConstantWithShape(\n-      ShapeUtil::MakeScalarShape(slice_shape.element_type()), 1));\n-  HloInstruction* broadcast = parent_loop->AddInstruction(\n-      HloInstruction::CreateBroadcast(slice_shape, one, {}));\n-  HloInstruction* add = mutable_dynamic_slice_with_add_fusion->AddInstruction(\n-      HloInstruction::CreateBinary(new_operand->shape(), HloOpcode::kAdd,\n-                                   new_operand, broadcast));\n-  TF_RETURN_IF_ERROR(\n-      mutable_dynamic_slice_with_add_fusion->ReplaceAllUsesWith(add));\n-  return absl::OkStatus();\n-}\n-\n-// This method checks if the given instruction is a fusion with the following\n-// properties:\n-// 1. It is inside the body of an unrollable loop\n-// 2. The parameter at stacked_operand_index has a single user inside the\n-//    fused computation.\n-// 3. The single user is a fusion with two operands with the following form:\n-//    fusion(stacked_param, slicing_offset)\n-//    (We assume that the stacked parameter is always the first operand and\n-//    the slicing offset is the second operand.)\n-// 4. The fusion user contains a shape-covering dynamic-slice instruction.\n-std::optional<PatternInfo> GetNestedDSFusionPattern(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    int64_t stacked_operand_idx) {\n-  if (instr->opcode() != HloOpcode::kFusion) {\n-    return std::nullopt;\n-  }\n-  if (!metadata.unrollable_loop_bodies.contains(instr->parent())) {\n-    VLOG(5) << \"Instruction not inside unrollable while body, \" << instr->name()\n-            << \" inside \" << instr->parent()->name();\n-    return std::nullopt;\n-  }\n-\n-  WhileLoopConfig while_instr_config =\n-      metadata.unrollable_loop_bodies.at(instr->parent());\n-\n-  VLOG(3) << \"Checking NestedDSFusionPattern\";\n-\n-  HloInstruction* inner_fusion_user = nullptr;\n-  for (HloInstruction* fused_instr :\n-       instr->fused_instructions_computation()->MakeInstructionPostOrder()) {\n-    // Find the changed parameter in the fused computation\n-    if (Match(fused_instr, match::Parameter(stacked_operand_idx))) {\n-      // There must be a single fusion user\n-      if (fused_instr->user_count() != 1) {\n-        return std::nullopt;\n-      }\n-      if (Match(fused_instr->users()[0],\n-                match::Fusion(match::Op(), match::Op()))) {\n-        inner_fusion_user = fused_instr->users()[0];\n-        break;\n-      }\n-    }\n-  }\n-  if (inner_fusion_user == nullptr) {\n-    return std::nullopt;\n-  }\n-  for (HloInstruction* inner_fusion_instr :\n-       inner_fusion_user->fused_instructions_computation()\n-           ->MakeInstructionPostOrder()) {\n-    if (!Match(inner_fusion_instr, match::DynamicSlice())) {\n-      continue;\n-    }\n-    std::optional<int64_t> dynamic_index =\n-        MatchEffectivelyStaticDynamicSliceInsideLoop(\n-            inner_fusion_instr,\n-            inner_fusion_user->fused_instructions_computation()\n-                ->parameter_instruction(0),\n-            while_instr_config);\n-    if (dynamic_index.has_value() && dynamic_index.value() == 0) {\n-      const int64_t num_layers =\n-          inner_fusion_user->operand(0)->shape().dimensions(0);\n-      PatternInfo pattern_info;\n-      pattern_info.type = PatternType::NestedDSFusionPattern;\n-      pattern_info.instr = inner_fusion_user;\n-      pattern_info.unstacked_shape =\n-          MakeUnstackedShapeFromSlice(inner_fusion_instr->shape(), num_layers);\n-      pattern_info.unstacking_computation =\n-          inner_fusion_user->fused_instructions_computation();\n-      pattern_info.unstacked_instrs.push_back(inner_fusion_user);\n-      return pattern_info;\n-    }\n-  }\n-  return std::nullopt;\n-}\n-\n-// The function below captures all the changes necessary to hlo graph for it's\n-// corresponding (GetNestedDSFusionPattern) pattern to unstack.\n-absl::Status UnstackNestedDSFusionPattern(\n-    HloInstruction* mutable_dynamic_slicing_fusion, const Shape& slice_shape) {\n-  // We are sure that this lambda is called with a nested fusion.\n-  HloInstruction* parent_fusion =\n-      mutable_dynamic_slicing_fusion->parent()->FusionInstruction();\n-\n-  // Under the assumption that the stacked parameter is always the first\n-  // operand of the inner fusion.\n-  HloInstruction* stacked_in_ds_fusion =\n-      mutable_dynamic_slicing_fusion->mutable_operand(0);\n-  CHECK_EQ(stacked_in_ds_fusion->opcode(), HloOpcode::kParameter);\n-  int64_t stacked_param_number = stacked_in_ds_fusion->parameter_number();\n-  HloInstruction* stacked =\n-      parent_fusion->mutable_operand(stacked_param_number);\n-\n-  // Under the assumption that the slicing offset is always the second\n-  // operand of the inner fusion.\n-  HloInstruction* offset_in_ds_fusion =\n-      mutable_dynamic_slicing_fusion->mutable_operand(1);\n-  CHECK_EQ(offset_in_ds_fusion->opcode(), HloOpcode::kParameter);\n-  HloInstruction* offset =\n-      parent_fusion->mutable_operand(offset_in_ds_fusion->parameter_number());\n-\n-  HloInstruction* sliced_param =\n-      parent_fusion->fused_instructions_computation()->ReplaceParameter(\n-          stacked_param_number,\n-          HloInstruction::CreateParameter(stacked_param_number, slice_shape,\n-                                          \"sliced\"));\n-  HloInstruction* bitcast = mutable_dynamic_slicing_fusion->AddInstruction(\n-      HloInstruction::CreateBitcast(mutable_dynamic_slicing_fusion->shape(),\n-                                    sliced_param));\n-  HloInstruction* bitcast_fusion =\n-      mutable_dynamic_slicing_fusion->AddInstruction(\n-          HloInstruction::CreateFusion(mutable_dynamic_slicing_fusion->shape(),\n-                                       HloInstruction::FusionKind::kLoop,\n-                                       bitcast));\n-  TF_RETURN_IF_ERROR(\n-      mutable_dynamic_slicing_fusion->ReplaceAllUsesWith(bitcast_fusion));\n-  // Create the custom-call to dynamically get the tuple element given the\n-  // loop iteration number. We rely on WhileLoopUnroller to rewrite this as\n-  // a get-tuple-element hlo once the iteration number is known and loop\n-  // bodies are unrolled.\n-  HloInstruction* new_operand =\n-      parent_fusion->AddInstruction(HloInstruction::CreateCustomCall(\n-          slice_shape, {stacked, offset}, \"DynamicGte\"));\n-  return parent_fusion->ReplaceOperandWithDifferentShape(\n-      sliced_param->parameter_number(), new_operand);\n-}\n-\n-// Identifies the following pattern:\n-//  computation {\n-//     ...\n-//     fusion.1 = fusion(...stacked...) // this is GetDSFusionPattern\n-//     fusion.2 = fusion(...stacked...) // this is GetDUSFusionPattern\n-//     ...\n-//   }\n-std::optional<PatternInfo> GetDSAndDUSPattern(const UnstackerMetadata& metadata,\n-                                              const HloInstruction* instr,\n-                                              int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking DSAndDUSPattern\";\n-  if (instr->opcode() != HloOpcode::kFusion) {\n-    return std::nullopt;\n-  }\n-  const HloInstruction* stacked = instr->operand(stacked_operand_idx);\n-  if (stacked->user_count() != 2) {\n-    return std::nullopt;\n-  }\n-\n-  HloInstruction* shape_covering_ds_instr =\n-      GetMostMajorShapeCoveringDynamicIndexInFusion(\n-          metadata, instr, HloOpcode::kDynamicSlice, 2, stacked_operand_idx);\n-  if (shape_covering_ds_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  HloInstruction* bitcast_operand = nullptr;\n-  if (!Match(instr->fused_instructions_computation()->root_instruction(),\n-             match::Bitcast(match::Op(&bitcast_operand)))) {\n-    return std::nullopt;\n-  }\n-  if (bitcast_operand != shape_covering_ds_instr) {\n-    return std::nullopt;\n-  }\n-  if (!GetDUSFusionPattern(metadata, stacked->users()[1],\n-                           stacked->users()[1]->operand_index(stacked))) {\n-    return std::nullopt;\n-  }\n-  PatternInfo pattern_info;\n-  pattern_info.type = PatternType::Other;\n-  pattern_info.instr = instr;\n-  const Shape& slice_shape = instr->shape();\n-  const int64_t num_layers = instr->operand(0)->shape().dimensions(0);\n-  pattern_info.unstacked_shape =\n-      MakeUnstackedShapeFromSlice(slice_shape, num_layers);\n-  pattern_info.unstacking_computation = instr->fused_instructions_computation();\n-  pattern_info.unstacked_instrs.push_back(instr);\n-  pattern_info.unstacked_instrs.push_back(stacked->users()[1]);\n-  return pattern_info;\n-}\n-\n-absl::Status UnstackDSAndDUSPattern(HloInstruction* mutable_dynamic_slice,\n-                                    const Shape& slice_shape) {\n-  HloInstruction* stacked_gte = mutable_dynamic_slice->mutable_operand(0);\n-  int64_t stacked_gte_index = stacked_gte->tuple_index();\n-  HloComputation* parent = stacked_gte->parent();\n-  ShapeUtil::UpdateTupleShape(stacked_gte->shape(), stacked_gte_index,\n-                              parent->root_instruction()->mutable_shape());\n-\n-  HloComputation* parent_loop = mutable_dynamic_slice->parent();\n-  HloInstruction* stacked = mutable_dynamic_slice->mutable_operand(0);\n-  HloInstruction* offset = mutable_dynamic_slice->mutable_operand(1);\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          slice_shape, {stacked, offset}, \"DynamicGte\"));\n-  TF_RETURN_IF_ERROR(\n-      mutable_dynamic_slice->ReplaceAllUsesWithDifferentShape(new_operand));\n-\n-  HloInstruction* mutable_dynamic_update_slice = stacked_gte->users()[1];\n-  TF_RETURN_IF_ERROR(\n-      UnstackDUSFusionPattern(mutable_dynamic_update_slice, slice_shape));\n-  return absl::OkStatus();\n-}\n-\n-// This function recognizes fusions with the following pattern:\n-// fusion(stacked, loop_iteration_var)\n-// computation {\n-//   p0 = parameter(0)\n-//   p1 = parameter(1)\n-//   slice = dynamic_slice(p0, p1, zero, ...)\n-//   ROOT reduce = reduce(slice, constant)\n-// }\n-std::optional<PatternInfo> GetReduceFusionPattern(\n-    const UnstackerMetadata& metadata, const HloInstruction* instr,\n-    int64_t stacked_operand_idx) {\n-  VLOG(3) << \"Checking ReduceFusion\";\n-  HloInstruction* shape_covering_instr =\n-      GetMostMajorShapeCoveringDynamicIndexInFusion(\n-          metadata, instr, HloOpcode::kDynamicSlice, 2, stacked_operand_idx);\n-  if (shape_covering_instr == nullptr) {\n-    return std::nullopt;\n-  }\n-  if (!ShouldUnfuseSlices(metadata, shape_covering_instr)) {\n-    return std::nullopt;\n-  }\n-  HloInstruction* reduce_operand = nullptr;\n-  HloInstruction* fusion_root =\n-      instr->fused_instructions_computation()->root_instruction();\n-  if (Match(fusion_root, match::Reduce(match::Op(&reduce_operand),\n-                                       match::ConstantScalar())) &&\n-      Match(fusion_root->to_apply()->root_instruction(),\n-            match::Add(match::Parameter(), match::Parameter()))) {\n-    if (reduce_operand == shape_covering_instr) {\n-      PatternInfo pattern_info;\n-      pattern_info.type = PatternType::Other;\n-      pattern_info.instr = instr;\n-      const Shape& slice_shape = instr->shape();\n-      const int64_t num_layers = instr->operand(0)->shape().dimensions(0);\n-      pattern_info.unstacked_shape =\n-          MakeUnstackedShapeFromSlice(slice_shape, num_layers);\n-      pattern_info.unstacking_computation =\n-          instr->fused_instructions_computation();\n-      pattern_info.unstacked_instrs.push_back(instr);\n-      return pattern_info;\n-    }\n-  }\n-\n-  return std::nullopt;\n-}\n-\n-absl::Status UnstackReduceFusionPattern(HloInstruction* mutable_reduce_fusion,\n-                                        const Shape& slice_shape) {\n-  HloComputation* parent_loop = mutable_reduce_fusion->parent();\n-\n-  HloInstruction* stacked = mutable_reduce_fusion->mutable_operand(0);\n-  HloInstruction* offset = mutable_reduce_fusion->mutable_operand(1);\n-\n-  HloInstruction* new_operand =\n-      parent_loop->AddInstruction(HloInstruction::CreateCustomCall(\n-          slice_shape, {stacked, offset}, \"DynamicGte\"));\n-  return mutable_reduce_fusion->ReplaceAllUsesWithDifferentShape(new_operand);\n-}\n-\n-};  // namespace\n-\n-// The entry point of the unstacking algorithm. Given a module, it creates the\n-// unstacking metadata and populates the unstacking custom handler(s). Moreover,\n-// it attempts unstacking each index of the loops in the entry computation of\n-// the module. Finally, it removes the unused computations and unrolls the\n-// module.\n-absl::StatusOr<bool> HloUnstacker::Run(\n-    HloModule* module,\n-    const absl::flat_hash_set<absl::string_view>& execution_threads) {\n-  TF_ASSIGN_OR_RETURN(auto metadata,\n-                      UnstackerMetadata::Create(module, unfuse_slice_));\n-  // The order of the patterns below is important, as it determines the order\n-  // in which the unstacking custom handlers are called. For example, applying\n-  // GetDSAndDUSPattern after GetDSFusionPattern would result in patterns of\n-  // GetDSAndDUSPattern not being recognized since GetDSFusionPattern is a\n-  // sub-pattern of GetDSAndDUSPattern.\n-  metadata.custom_handlers.push_back(\n-      std::make_pair(GetDSAndDUSPattern, UnstackDSAndDUSPattern));\n-  metadata.custom_handlers.push_back(\n-      std::make_pair(GetDSFusionPattern, UnstackDSFusionPattern));\n-  metadata.custom_handlers.push_back(\n-      std::make_pair(GetDUSFusionPattern, UnstackDUSFusionPattern));\n-  metadata.custom_handlers.push_back(std::make_pair(\n-      GetDUSFusionWithPadPattern, UnstackDUSFusionWithPadPattern));\n-  metadata.custom_handlers.push_back(\n-      std::make_pair(GetDSFusionWithAddPattern, UnstackDSFusionWithAddPattern));\n-  metadata.custom_handlers.push_back(\n-      std::make_pair(GetReduceFusionPattern, UnstackReduceFusionPattern));\n-  metadata.custom_handlers.push_back(\n-      std::make_pair(GetNestedDSFusionPattern, UnstackNestedDSFusionPattern));\n-  metadata.custom_handlers.push_back(std::make_pair(\n-      GetDSFusionNoBitcastPattern, UnstackDSFusionNoBitcastPattern));\n-\n-  std::vector<HloInstruction*> entry_loops;\n-  for (HloInstruction* instr :\n-       module->entry_computation()->MakeInstructionPostOrder()) {\n-    // Only unstack standard loops with tuple input and output.\n-    if (Match(instr, match::While(match::Tuple())) &&\n-        Match(instr->while_body()->root_instruction(), match::Tuple())) {\n-      entry_loops.push_back(instr);\n-    }\n-  }\n-\n-  int64_t num_unstacked = 0;\n-  bool unstacked = false;\n-  std::vector<const HloInstruction*> unstacked_instructions;\n-  for (HloInstruction* loop : entry_loops) {\n-    for (int64_t i = 0; i < loop->shape().tuple_shapes().size(); ++i) {\n-      // We don't handle tuples and if we see then we assume they come from a\n-      // previous unstacking attempt.\n-      if (loop->while_init()->operand(i)->shape().IsTuple()) {\n-        continue;\n-      }\n-      VLOG(3) << \"Attempting to unstack \" << loop->name() << \" at \" << i\n-              << \" = \" << loop->while_init()->operand(i)->shape().ToString(true)\n-              << loop->while_init()->operand(i)->ToShortString();\n-      bool current_unstacked =\n-          UnstackWhileOperandAtIndex(metadata, loop, i, unstacked_instructions);\n-      if (current_unstacked) {\n-        num_unstacked++;\n-        unstacked = true;\n-      }\n-      VLOG(3) << \"###################\";\n-    }\n-  }\n-  if (!unstacked) {\n-    return false;\n-  }\n-  // Unstacking computations are cloned, leaving the original unstacking\n-  // computation unused.\n-  TF_RETURN_IF_ERROR(module->RemoveUnusedComputations());\n-  // We rely on the WhileLoopUnroller pass to unroll unstacked loop bodies\n-  // and rewrite custom-calls created by unstacker, i.e., DynamicGte and\n-  // DynamicTuple.\n-  std::vector<HloInstruction*> loops_to_unroll;\n-  for (const HloInstruction* instr : unstacked_instructions) {\n-    HloInstruction* loop = metadata.bodies[instr->parent()];\n-    if (std::find(loops_to_unroll.begin(), loops_to_unroll.end(), loop) ==\n-        loops_to_unroll.end()) {\n-      loops_to_unroll.push_back(loop);\n-    }\n-  }\n-  // Go over the loops in reverse order to unroll the inner loops first.\n-  for (int64_t i = loops_to_unroll.size() - 1; i >= 0; --i) {\n-    HloInstruction* loop = loops_to_unroll[i];\n-    TF_ASSIGN_OR_RETURN(UnrollResult unroll_result,\n-                        WhileLoopUnroller::UnrollAndReturnReplacement(\n-                            loop, /*unroll_factor=*/-1,\n-                            /*wrap_in_trivial_loop=*/false,\n-                            /*force_unroll=*/true, /*prepare=*/false));\n-    bool unrolled = unroll_result.unrolled;\n-    CHECK(unrolled);\n-  }\n-  VLOG(3) << \"after unstacking \\n\" << module->ToString();\n-  VLOG(3) << \"Num unstacked: \" << num_unstacked;\n-  return true;\n-}\n-\n-}  // namespace xla"
        },
        {
            "sha": "bd312e89a2a66a36c31434d1c7c73504ffebda5b",
            "filename": "third_party/xla/xla/service/hlo_unstacker.h",
            "status": "removed",
            "additions": 0,
            "deletions": 100,
            "changes": 100,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker.h?ref=cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
            "patch": "@@ -1,100 +0,0 @@\n-/* Copyright 2024 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef XLA_SERVICE_HLO_UNSTACKER_H_\n-#define XLA_SERVICE_HLO_UNSTACKER_H_\n-\n-#include <stdbool.h>\n-\n-#include <functional>\n-\n-#include \"absl/container/flat_hash_set.h\"\n-#include \"absl/status/statusor.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"xla/hlo/ir/hlo_instruction.h\"\n-#include \"xla/hlo/pass/hlo_pass_interface.h\"\n-\n-namespace xla {\n-// This pass implements unstacking for loop operands. Generally speaking,\n-// unstacking is the act of breaking a rank n tensor into n smaller n-1 rank\n-// tensors without changing the semantics of the program. There are different\n-// patterns that can benefit from unstacking. This pass aims to implement such\n-// patterns. The patterns implemented are not exhaustive by any means. Lets\n-// consider a simple example:\n-// In the pattern below, `I` (the most-major dimension in the stacked tensor),\n-// is equal to the trip count of the while loop and `i` is the iteration\n-// variable of the loop. The stacked input is used only as input to a\n-// shape-covering dynamic-slice (check the definition of a shape-covering\n-// dynamic-slice: `tensorflow/compiler/xla/service/while_loop_unroller.h`)\n-//\n-//   +-while----------------------------------------------------+\n-//   | param = tuple(..., [I,x1,...,xn]stacked, ...)            |\n-//   | ...                                                      |\n-//   | [1,x1,...,xn]slice = ds([I,x1,...,xn]stacked, i, 0, ...) |\n-//   | ...                                                      |\n-//   | ops using the slice                                      |\n-//   | ...                                                      |\n-//   | ROOT = tuple(..., stacked, ...)                          |\n-//   +----------------------------------------------------------+\n-//\n-// This pattern can be unstacked and rewritten as following:\n-//\n-//   +-while-----------------------------------------------------------------+\n-//   | param = tuple(..., ([1,x1,...,xn], ..., [1,x1,...,xn])unstacked, ...) |\n-//   | ...                                                                   |\n-//.  | slice_1 = get_tuple_element(unstacked), index=i                       |\n-//   | ops using the slice_i                                                 |\n-//   | ...                                                                   |\n-//   | ROOT = tuple(..., unstacked, ...)                                     |\n-//   +-----------------------------------------------------------------------+\n-//\n-// where the unstacked input is initialized with the slices outside of the loop:\n-// unstacked = tuple(slice_1, ..., slice_n)\n-// To get each slice, the pass introduces a dynamic version of the\n-// kGetTupleElement instruction using a custom-call. This custom-call is then\n-// replaced with a normal get-tuple-element during loop unrolling.\n-//\n-// Below is a high-level overview of the unstacking algorithm:\n-// We unstack a module by unstacking inputs to the while loops within the entry\n-// computation for every index. Given a while loop and a candidate for\n-// unstacking, the algorithm performs the following two steps:\n-// 1. The first step is to determine if unstacking is possible by checking if\n-//  the unstacking of the while operand at the given index can be propagated\n-//  through the body (and nested bodies if any). Unstacking is possible\n-//  if a pair of pattern and handler is provided that can identify and handle\n-//  such pattern that involves all the uses of the stacked operand at the given\n-//  index.\n-// 2. Apply the unstacking by executing the changes gathered in the first phase.\n-class HloUnstacker : public HloModulePass {\n- public:\n-  ~HloUnstacker() override = default;\n-\n-  explicit HloUnstacker(std::function<bool(HloInstruction*)> unfuse_slice =\n-                            [](HloInstruction* instr) { return true; })\n-      : unfuse_slice_(unfuse_slice) {}\n-\n-  absl::string_view name() const override { return \"hlo_unstacker\"; }\n-  using HloPassInterface::Run;\n-  absl::StatusOr<bool> Run(\n-      HloModule* module,\n-      const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n-\n- private:\n-  std::function<bool(HloInstruction*)> unfuse_slice_;\n-};\n-\n-}  // namespace xla\n-\n-#endif  // XLA_SERVICE_HLO_UNSTACKER_H_"
        },
        {
            "sha": "3a552c5542cfe7aef39f7fbd1c6dbf0c79ad4b5e",
            "filename": "third_party/xla/xla/service/hlo_unstacker_test.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 1503,
            "changes": 1503,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_unstacker_test.cc?ref=cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
            "patch": "@@ -1,1503 +0,0 @@\n-/* Copyright 2024 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/service/hlo_unstacker.h\"\n-\n-#include <cstdint>\n-#include <memory>\n-#include <optional>\n-#include <string>\n-#include <utility>\n-\n-#include <gtest/gtest.h>\n-#include \"xla/hlo/ir/hlo_computation.h\"\n-#include \"xla/hlo/ir/hlo_instruction.h\"\n-#include \"xla/hlo/ir/hlo_module.h\"\n-#include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/tests/hlo_test_base.h\"\n-#include \"tsl/platform/statusor.h\"\n-\n-namespace xla {\n-namespace {\n-\n-using UnstackerTest = HloTestBase;\n-\n-int64_t GetInstrCountWithOpcodeInEntry(HloModule* module, HloOpcode opcode) {\n-  int64_t instr_with_opcode_count = 0;\n-  for (HloInstruction* instr :\n-       module->entry_computation()->MakeInstructionPostOrder()) {\n-    if (instr->opcode() == opcode) {\n-      instr_with_opcode_count++;\n-    }\n-  }\n-  return instr_with_opcode_count;\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPattern) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.slice\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 3);\n-  // Check that the bitcast is unfused and there are not fusions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kFusion),\n-            0);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, NotUnstackDSFusionPattern) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.tuple {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    mult = multiply(param_0.51117, param_0.51117)\n-    ROOT out = tuple(param_0.51117, mult)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.slice\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    fusion_mult = (s8[3,128,128], s8[3,128,128]) fusion(s8[3,128,128] p1), kind=kLoop, calls=%fused_computation.tuple\n-    mult = s8[3,128,128] get-tuple-element(fusion_mult), index=1\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, conv, mult)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_FALSE(unstacked);\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPatternMultipleLoopRootUse) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p2 = s8[3,128,128] get-tuple-element(wide_p), index=3\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] p2, i), kind=kLoop, calls=%fused_computation.slice\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) tuple(inc, conv, p2, p2)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    zero = s8[] constant(0)\n-    buffer = s8[3,128,128] broadcast(zero), dimensions={}\n-    while.input = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) tuple(init, p1, p0, buffer)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 6);\n-  // Check that the bitcast is unfused and there are not fusions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kFusion),\n-            0);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPatternWithUnusedOperand) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.slice\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) tuple(inc, conv, p1, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    zero = s8[] constant(0)\n-    buffer = s8[3,128,128] broadcast(zero), dimensions={}\n-    while.input = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) tuple(init, p1, p0, buffer)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 6);\n-  // Check that the bitcast is unfused and there are not fusions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kFusion),\n-            0);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackReduceFusionPattern) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  dynamic-slice.609.reduce_sub_computation {\n-    lhs.53 = s8[] parameter(0)\n-    rhs.53 = s8[] parameter(1)\n-    ROOT add.3090 = s8[] add(lhs.53, rhs.53)\n-  }\n-\n-  fused_computation.1096.clone {\n-    param_0.5572 = s8[3,128,128] parameter(0)\n-    param_1.6711 = s32[]{:T(128)} parameter(1)\n-    constant.12008 = s32[]{:T(128)} constant(0)\n-    dynamic-slice.1545 = s8[1,128,128] dynamic-slice(param_0.5572, param_1.6711, constant.12008, constant.12008), dynamic_slice_sizes={1,128, 128}\n-    constant.12009 = s8[] constant(-0)\n-    ROOT reduce.919 = s8[128,128] reduce(dynamic-slice.1545, constant.12009), dimensions={0}, to_apply=dynamic-slice.609.reduce_sub_computation\n-  } // fused_computation.1096.clone\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.1096.clone\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPatternNoBitcast) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[1,128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    ROOT %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[1,128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.slice\n-    bitcast.102 = s8[128,128] bitcast(s8[1,128,128] %fusion.67830)\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] bitcast.102), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 3);\n-  // Check that all the fusions are removed.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kFusion),\n-            0);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPatternNoBitcastKeepFused) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[1,128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    ROOT %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[1,128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.slice\n-    bitcast.102 = s8[128,128] bitcast(s8[1,128,128] %fusion.67830)\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] bitcast.102), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  auto unfuse = [](HloInstruction* instruction) { return false; };\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked,\n-                          HloUnstacker(unfuse).Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 0);\n-  // Check that dynamic-slices are still fused.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kFusion),\n-            3);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPatternKeepFused) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT out = s8[128,128] bitcast(%dynamic-slice.22040)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] p1, i), kind=kLoop, calls=%fused_computation.slice\n-    conv = bf16[8,128] convolution(bf16[8,128] p0, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  auto unfuse = [](HloInstruction* instruction) { return false; };\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked,\n-                          HloUnstacker(unfuse).Run(module.get()));\n-  EXPECT_FALSE(unstacked);\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSFusionPatternWithDifferentLayout) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.30.clone (param_0.153: bf16[32,4,64,64,3], param_1.123: s32[]) -> bf16[64,4,64,3] {\n-    %param_0.153 = bf16[32,4,64,64,3]{2,1,4,3,0} parameter(0)\n-    %param_1.123 = s32[]{:T(128)} parameter(1)\n-    %constant.227 = s32[]{:T(128)} constant(0)\n-    %dynamic-slice.5 = bf16[1,4,64,64,3]{2,1,4,3,0} dynamic-slice(bf16[32,4,64,64,3]{2,1,4,3,0} %param_0.153, s32[]{:T(128)} %param_1.123, s32[]{:T(128)} %constant.227, s32[]{:T(128)} %constant.227, s32[]{:T(128)} %constant.227, /*index=5*/s32[]{:T(128)} %constant.227), dynamic_slice_sizes={1,4,64,64,3}\n-    ROOT %bitcast.102 = bf16[64,4,64,3]{0,1,3,2} bitcast(bf16[1,4,64,64,3]{2,1,4,3,0} %dynamic-slice.5)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], bf16[32,4,64,64,3])) -> (s32[], bf16[8,128], bf16[32,4,64,64,3]) {\n-    wide_p = (s32[], bf16[8,128], bf16[32,4,64,64,3]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = bf16[32,4,64,64,3]{2,1,4,3,0} get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67830 = bf16[64,4,64,3]{0,1,3,2} fusion(p1, i), kind=kLoop, calls=%fused_computation.30.clone\n-    ROOT out = (s32[], bf16[8,128], bf16[32,4,64,64,3]) tuple(inc, p0, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], bf16[32,4,64,64,3])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], bf16[32,4,64,64,3]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(32)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = bf16[32,4,64,64,3] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], bf16[32,4,64,64,3]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], bf16[32,4,64,64,3]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = bf16[32,4,64,64,3] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice),\n-            32);\n-  // Check that dynamic-slices are still fused.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kFusion),\n-            0);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt));\n-}\n-\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPattern) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.inner (param_0.34523: bf16[8,128], param_1.30691: s8[3,128,128], p2: s32[]) -> bf16[8,128] {\n-    %param_0.34523 = bf16[8,128] parameter(0)\n-    %param_1.30691 = s8[3,128,128] parameter(1)\n-    p2 = s32[] parameter(2)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice\n-    ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    fusion.conv = bf16[8,128] fusion(p0, p1, i), kind=kOutput, calls=%fused_computation.inner\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, fusion.conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 3);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-// Instead of slicing the entire shape, this test slices only even elements from\n-// the first parameter.\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPatternWithDynamicIndex) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[6,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[6,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[6,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.inner (param_0.34523: bf16[8,128], param_1.30691: s8[6,128,128], p2: s32[]) -> bf16[8,128] {\n-    %param_0.34523 = bf16[8,128] parameter(0)\n-    %param_1.30691 = s8[6,128,128] parameter(1)\n-    p2 = s32[] parameter(2)\n-    %fusion.67830 = s8[128,128] fusion(s8[6,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice\n-    ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[6,128,128])) -> (s32[], bf16[8,128], s8[6,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[6,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[6,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    two = s32[] constant(2)\n-    mult = s32[] multiply(i, two)\n-    fusion.conv = bf16[8,128] fusion(p0, p1, mult), kind=kOutput, calls=%fused_computation.inner\n-    ROOT out = (s32[], bf16[8,128], s8[6,128,128]) tuple(inc, fusion.conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[6,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[6,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[6,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[6,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[6,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[6,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPatternWithMultipleIndex) {\n-  std::string hlo_string = R\"(\n-    HloModule SimpleLoop\n-    %fused_computation.slice.1 (param_0.51117: s8[4,128,128], p1: s32[]) -> s8[128,128] {\n-      %param_0.51117 = s8[4,128,128] parameter(0)\n-      p1 = s32[] parameter(1)\n-      %constant.85694 = s32[] constant(0)\n-      %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[4,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-      ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-    }\n-\n-    %fused_computation.slice.2 (param_0.51117: s8[4,128,128], p1: s32[]) -> s8[128,128] {\n-      %param_0.51117 = s8[4,128,128] parameter(0)\n-      p1 = s32[] parameter(1)\n-      %constant.85694 = s32[] constant(0)\n-      %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[4,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-      ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-    }\n-\n-    %fused_computation.inner.1 (param_0.34523: bf16[8,128], param_1.30691: s8[4,128,128], p2: s32[]) -> bf16[8,128] {\n-      %param_0.34523 = bf16[8,128] parameter(0)\n-      %param_1.30691 = s8[4,128,128] parameter(1)\n-      p2 = s32[] parameter(2)\n-      %fusion.67830 = s8[128,128] fusion(s8[4,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice.1\n-      ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    }\n-\n-    %fused_computation.inner.2 (param_0.34523: bf16[8,128], param_1.30691: s8[4,128,128], p2: s32[]) -> bf16[8,128] {\n-      %param_0.34523 = bf16[8,128] parameter(0)\n-      %param_1.30691 = s8[4,128,128] parameter(1)\n-      p2 = s32[] parameter(2)\n-      %fusion.67830 = s8[128,128] fusion(s8[4,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice.2\n-      ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    }\n-\n-    %while.body (wide_param: (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      // to_be_sliced_while_gte\n-      p1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      p2 = s8[4,128,128] get-tuple-element(wide_p), index=3\n-      one = s32[] constant(1)\n-      inc = s32[] add(i, one)\n-      fusion.conv.1 = bf16[8,128] fusion(p0, p1, i), kind=kOutput, calls=%fused_computation.inner.1\n-      fusion.conv.2 = bf16[8,128] fusion(p0, p2, i), kind=kOutput, calls=%fused_computation.inner.2\n-      plus = bf16[8,128] add(fusion.conv.1, fusion.conv.2)\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128]) tuple(inc, plus, p1, p2)\n-    }\n-\n-    %while.cond (wide_param: (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(4)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-    }\n-\n-    ENTRY main {\n-      p0 = s8[4,128,128] parameter(0)\n-      p1 = s8[4,128,128] parameter(1)\n-      p2 = bf16[8,128] parameter(2)\n-      init = s32[] constant(0)\n-      while.input = (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128]) tuple(init, p2, p0, p1)\n-      while.out = (s32[], bf16[8,128], s8[4,128,128], s8[4,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-      ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-    }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions. For each unstacked input, we\n-  // create 4 slices, 8 in total.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 8);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPatternWithDiffereOperandsOrder) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.inner (param_1.30691: s8[3,128,128], p2: s32[], param_0.34523: bf16[8,128]) -> bf16[8,128] {\n-    %param_0.34523 = bf16[8,128] parameter(2)\n-    %param_1.30691 = s8[3,128,128] parameter(0)\n-    p2 = s32[] parameter(1)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice\n-    ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    fusion.conv = bf16[8,128] fusion(p1, i, p0), kind=kOutput, calls=%fused_computation.inner\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, fusion.conv, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 3);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPatternWithSameUnstackingComps) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice.1 (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.slice.2 (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.inner.1 (param_0.34523: bf16[8,128], param_1.30691: s8[3,128,128], p2: s32[]) -> bf16[8,128] {\n-    %param_0.34523 = bf16[8,128] parameter(0)\n-    %param_1.30691 = s8[3,128,128] parameter(1)\n-    p2 = s32[] parameter(2)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice.1\n-    ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-  }\n-\n-  %fused_computation.inner.2 (param_0.34523: bf16[8,128], param_1.30691: s8[3,128,128], p2: s32[]) -> bf16[8,128] {\n-    %param_0.34523 = bf16[8,128] parameter(0)\n-    %param_1.30691 = s8[3,128,128] parameter(1)\n-    p2 = s32[] parameter(2)\n-    %fusion.67830 = s8[128,128] fusion(s8[3,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice.2\n-    ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    fusion.conv1 = bf16[8,128] fusion(p0, p1, i), kind=kOutput, calls=%fused_computation.inner.1\n-    fusion.conv2 = bf16[8,128] fusion(p0, p1, i), kind=kOutput, calls=%fused_computation.inner.2\n-    add = bf16[8,128] add(fusion.conv1, fusion.conv2)\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, add, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 3);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest,\n-       NotUnstackNestedDSFusionPatternWithDifferentUnstackingComps) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice.1 (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[1,128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    ROOT %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-  }\n-\n-  %fused_computation.slice.2 (param_0.51117: s8[3,128,128], p1: s32[]) -> s8[128,128] {\n-    %param_0.51117 = s8[3,128,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %constant.85694 = s32[] constant(0)\n-    %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[3,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-    ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-  }\n-\n-  %while.body (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> (s32[], bf16[8,128], s8[3,128,128]) {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    p0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-    p1 = s8[3,128,128] get-tuple-element(wide_p), index=2\n-    one = s32[] constant(1)\n-    inc = s32[] add(i, one)\n-    %fusion.67831 = s8[128,128] fusion(p1, i), kind=kLoop, calls=%fused_computation.slice.2\n-    %fusion.67830 = s8[1,128,128] fusion(p1, i), kind=kLoop, calls=%fused_computation.slice.1\n-    %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %fusion.67830)\n-    ROOT out = (s32[], bf16[8,128], s8[3,128,128]) tuple(inc, p0, p1)\n-  }\n-\n-  %while.cond (wide_param: (s32[], bf16[8,128], s8[3,128,128])) -> pred[] {\n-    wide_p = (s32[], bf16[8,128], s8[3,128,128]) parameter(0)\n-    i = s32[] get-tuple-element(wide_p), index=0\n-    %constant.12857 = s32[] constant(3)\n-    ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = s8[3,128,128] parameter(0)\n-    p1 = bf16[8,128] parameter(1)\n-    init = s32[] constant(0)\n-    while.input = (s32[], bf16[8,128], s8[3,128,128]) tuple(init, p1, p0)\n-    while.out = (s32[], bf16[8,128], s8[3,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-    while_use = s8[3,128,128] get-tuple-element(while.out), index=2\n-    ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-  }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  // Currently, we don't unroll if there are multiple nested ds fusions.\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_FALSE(unstacked);\n-}\n-\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPatternSingleNestedLoop) {\n-  std::string hlo_string = R\"(\n-    HloModule SimpleLoop\n-    %fused_computation.slice (param_0.51117: s8[4,128,128], p1: s32[]) -> s8[128,128] {\n-      %param_0.51117 = s8[4,128,128] parameter(0)\n-      p1 = s32[] parameter(1)\n-      %constant.85694 = s32[] constant(0)\n-      %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[4,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-      ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-    }\n-\n-    %fused_computation.inner (param_0.34523: bf16[8,128], param_1.30691: s8[4,128,128], p2: s32[]) -> bf16[8,128] {\n-      %param_0.34523 = bf16[8,128] parameter(0)\n-      %param_1.30691 = s8[4,128,128] parameter(1)\n-      p2 = s32[] parameter(2)\n-      %fusion.67830 = s8[128,128] fusion(s8[4,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice\n-      ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    }\n-\n-    %while.body.inner (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      inner_param_0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      inner_param_1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      one = s32[] constant(1)\n-      inc = s32[] add(i, one)\n-      fusion.conv = bf16[8,128] fusion(inner_param_0, inner_param_1, i), kind=kOutput, calls=%fused_computation.inner\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128]) tuple(inc, fusion.conv, inner_param_1)\n-    }\n-\n-    %while.cond.inner (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(4)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-    }\n-\n-    %while.body (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      param0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      param1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      one = s32[] constant(2)\n-      zero = s32[] constant(0)\n-      mult = s32[] multiply(i, one)\n-      inner.in = (s32[], bf16[8,128], s8[4,128,128]) tuple(zero, param0, param1)\n-      inner.out = (s32[], bf16[8,128], s8[4,128,128]) while(inner.in), condition=%while.cond.inner, body=%while.body.inner\n-      fusion.conv.inner = bf16[8,128] get-tuple-element(inner.out), index=1\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128]) tuple(mult, fusion.conv.inner, param1)\n-    }\n-\n-    %while.cond (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(20)\n-      add = s32[] add(%constant.12857, %constant.12857)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, add), direction=LT\n-    }\n-\n-    ENTRY main {\n-      weight = s8[4,128,128] parameter(0)\n-      p1 = bf16[8,128] parameter(1)\n-      init = s32[] constant(1)\n-      while.input = (s32[], bf16[8,128], s8[4,128,128]) tuple(init, p1, weight)\n-      while.out = (s32[], bf16[8,128], s8[4,128,128]) while(while.input), condition=%while.cond , body=%while.body\n-      ROOT out = bf16[8,128] get-tuple-element(while.out), index=1\n-    }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 4);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackNestedDSFusionPatternTwoNestedLoops) {\n-  std::string hlo_string = R\"(\n-    HloModule SimpleLoop\n-    %fused_computation.slice1 (param_0.51117: s8[4,128,128], p1: s32[]) -> s8[128,128] {\n-      %param_0.51117 = s8[4,128,128] parameter(0)\n-      p1 = s32[] parameter(1)\n-      %constant.85694 = s32[] constant(0)\n-      %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[4,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-      ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-    }\n-\n-    %fused_computation.inner1 (param_0.34523: bf16[8,128], param_1.30691: s8[4,128,128], p2: s32[]) -> bf16[8,128] {\n-      %param_0.34523 = bf16[8,128] parameter(0)\n-      %param_1.30691 = s8[4,128,128] parameter(1)\n-      p2 = s32[] parameter(2)\n-      %fusion.67830 = s8[128,128] fusion(s8[4,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice1\n-      ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    }\n-\n-    %while.body.inner1 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      inner_param_0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      inner_param_1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      one = s32[] constant(1)\n-      inc = s32[] add(i, one)\n-      fusion.conv = bf16[8,128] fusion(inner_param_0, inner_param_1, i), kind=kOutput, calls=%fused_computation.inner1\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128]) tuple(inc, fusion.conv, inner_param_1)\n-    }\n-\n-    %while.cond.inner1 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(4)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-    }\n-\n-    %while.body1 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      param0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      param1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      one = s32[] constant(2)\n-      zero = s32[] constant(0)\n-      mult = s32[] multiply(i, one)\n-      inner.in.1 = (s32[], bf16[8,128], s8[4,128,128]) tuple(zero, param0, param1)\n-      inner.out.1 = (s32[], bf16[8,128], s8[4,128,128]) while(inner.in.1), condition=%while.cond.inner1, body=%while.body.inner1\n-      fusion.conv.inner = bf16[8,128] get-tuple-element(inner.out.1), index=1\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128]) tuple(mult, fusion.conv.inner, param1)\n-    }\n-\n-    %while.cond1 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(20)\n-      add = s32[] add(%constant.12857, %constant.12857)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, add), direction=LT\n-    }\n-\n-    %fused_computation.slice2 (param_0.51117: s8[4,128,128], p1: s32[]) -> s8[128,128] {\n-      %param_0.51117 = s8[4,128,128] parameter(0)\n-      p1 = s32[] parameter(1)\n-      %constant.85694 = s32[] constant(0)\n-      %dynamic-slice.22040 = s8[1,128,128] dynamic-slice(s8[4,128,128] %param_0.51117, p1, s32[] %constant.85694, s32[] %constant.85694), dynamic_slice_sizes={1,128,128}\n-      ROOT %bitcast.31250 = s8[128,128] bitcast(s8[1,128,128] %dynamic-slice.22040)\n-    }\n-\n-    %fused_computation.inner2 (param_0.34523: bf16[8,128], param_1.30691: s8[4,128,128], p2: s32[]) -> bf16[8,128] {\n-      %param_0.34523 = bf16[8,128] parameter(0)\n-      %param_1.30691 = s8[4,128,128] parameter(1)\n-      p2 = s32[] parameter(2)\n-      %fusion.67830 = s8[128,128] fusion(s8[4,128,128] %param_1.30691, p2), kind=kLoop, calls=%fused_computation.slice2\n-      ROOT %convolution.3447 = bf16[8,128] convolution(bf16[8,128] %param_0.34523, s8[128,128] %fusion.67830), dim_labels=bf_io->bf\n-    }\n-\n-    %while.body.inner2 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      inner_param_0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      inner_param_1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      one = s32[] constant(1)\n-      inc = s32[] add(i, one)\n-      fusion.conv = bf16[8,128] fusion(inner_param_0, inner_param_1, i), kind=kOutput, calls=%fused_computation.inner2\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128]) tuple(inc, fusion.conv, inner_param_1)\n-    }\n-\n-    %while.cond.inner2 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(4)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, s32[] %constant.12857), direction=LT\n-    }\n-\n-    %while.body2 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> (s32[], bf16[8,128], s8[4,128,128]) {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      param0 = bf16[8,128] get-tuple-element(wide_p), index=1\n-      param1 = s8[4,128,128] get-tuple-element(wide_p), index=2\n-      one = s32[] constant(2)\n-      zero = s32[] constant(0)\n-      mult = s32[] multiply(i, one)\n-      inner.in.2 = (s32[], bf16[8,128], s8[4,128,128]) tuple(zero, param0, param1)\n-      inner.out.2 = (s32[], bf16[8,128], s8[4,128,128]) while(inner.in.2), condition=%while.cond.inner2, body=%while.body.inner2\n-      fusion.conv.inner = bf16[8,128] get-tuple-element(inner.out.2), index=1\n-      ROOT out = (s32[], bf16[8,128], s8[4,128,128]) tuple(mult, fusion.conv.inner, param1)\n-    }\n-\n-    %while.cond2 (wide_param: (s32[], bf16[8,128], s8[4,128,128])) -> pred[] {\n-      wide_p = (s32[], bf16[8,128], s8[4,128,128]) parameter(0)\n-      i = s32[] get-tuple-element(wide_p), index=0\n-      %constant.12857 = s32[] constant(20)\n-      add = s32[] add(%constant.12857, %constant.12857)\n-      ROOT %compare.1921 = pred[]{:T(512)} compare(s32[] i, add), direction=LT\n-    }\n-\n-    ENTRY main {\n-      weight = s8[4,128,128] parameter(0)\n-      p1 = bf16[8,128] parameter(1)\n-      init = s32[] constant(1)\n-      while.input = (s32[], bf16[8,128], s8[4,128,128]) tuple(init, p1, weight)\n-      while.out = (s32[], bf16[8,128], s8[4,128,128]) while(while.input), condition=%while.cond1 , body=%while.body1\n-      init2 = s32[] get-tuple-element(while.out), index=0\n-      second.while.input = (s32[], bf16[8,128], s8[4,128,128]) tuple(init2, p1, weight)\n-      second.while.out = (s32[], bf16[8,128], s8[4,128,128]) while(second.while.input), condition=%while.cond2 , body=%while.body2\n-      out = bf16[8,128] get-tuple-element(while.out), index=1\n-      second.out = bf16[8,128] get-tuple-element(second.while.out), index=1\n-      ROOT result = bf16[8,128] add(out, second.out)\n-    }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  // Check for the creation of slice instructions. For each loop there is one\n-  // unstacked input that creates 4 slices, in total 8 slices for two loops.\n-  EXPECT_EQ(GetInstrCountWithOpcodeInEntry(module.get(), HloOpcode::kSlice), 8);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-TEST_F(UnstackerTest, UnstackDSAndDUSPattern) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  %fused_computation.slice (param_0.51117: s32[4,3], offset: s32[]) -> s32[3] {\n-    %param_0.51117 = s32[4,3] parameter(0)\n-    offset = s32[] parameter(1)\n-    zero = s32[] constant(0)\n-    %dynamic-slice.22040 = s32[1,3] dynamic-slice(s32[4,3] %param_0.51117, offset, zero), dynamic_slice_sizes={1,3}\n-    ROOT %bitcast.31250 = s32[3] bitcast(s32[1,3] %dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.update.slice (param_0.51117: s32[4,3], p1: s32[], p2: s32[3]) -> s32[4,3] {\n-    %param_0.51117 = s32[4,3] parameter(0)\n-    %p1 = s32[] parameter(1)\n-    %p2 = s32[3] parameter(2)\n-    %zero = s32[] constant(0)\n-    %bitcast.31250 = s32[1,3] bitcast(%p2)\n-    ROOT output_dus = s32[4,3]{1,0} dynamic-update-slice(%param_0.51117, %bitcast.31250, %p1, zero)\n-  }\n-\n-  SimpleLoop.body {\n-    loop_var.1 = (s32[], s32[4,3]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1), index=0\n-    get-tuple-element.2 = s32[4,3] get-tuple-element(loop_var.1), index=1\n-    zero = s32[] constant(0)\n-\n-    some_const = s32[3] constant({0,1,2})\n-    constant.1 = s32[] constant(1)\n-    idx = s32[] add(get-tuple-element.1, constant.1)\n-    ds = s32[3]{0} fusion(get-tuple-element.2, get-tuple-element.1), kind=kLoop, calls=%fused_computation.slice\n-    update = s32[3] add(ds, ds)\n-    dus = s32[3] dynamic-update-slice(ds, update, zero)\n-    output = s32[4,3] fusion(get-tuple-element.2, get-tuple-element.1, dus), kind=kLoop, calls=%fused_computation.update.slice\n-    ROOT tuple = (s32[], s32[4,3]) tuple(idx, output)\n-  }\n-  SimpleLoop.condition {\n-    loop_var.1 = (s32[], s32[4,3]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1), index=0\n-    constant.2 = s32[] constant(4)\n-    ROOT less-than = pred[] compare(get-tuple-element.1, constant.2), direction=LT\n-  }\n-  ENTRY SimpleLoop {\n-    reference = s32[4,3] parameter(0)\n-    zero = s32[] constant(0)\n-    zero1 = s32[] constant(0)\n-    one = s32[] constant(1)\n-    tuple.1 = (s32[], s32[4,3]) tuple(zero, reference)\n-    while = (s32[], s32[4,3]) while(tuple.1), condition=SimpleLoop.condition, body=SimpleLoop.body\n-    ROOT out = s32[] get-tuple-element(while), index=0\n-  }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-// Unstacking outer loop at index 1 forces to unstacked inner while at index 1\n-// as well. This is because the output of the outer loop at index 1 is aliased\n-// to the output of the inner while at index 1.\n-TEST_F(UnstackerTest, UnstackDSAndDUSPatternNestedLoop) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-\n-  %fused_computation.slice (param_0.51117: bf16[4,1,8,257,128], offset: s32[]) -> bf16[1,8,257,128] {\n-    %param_0.51117 = bf16[4,1,8,257,128] parameter(0)\n-    offset = s32[] parameter(1)\n-    zero = s32[] constant(0)\n-    %dynamic-slice.22040 = bf16[1,1,8,257,128]\n-    dynamic-slice(bf16[4,1,8,257,128] %param_0.51117, offset, zero, zero, zero, zero), dynamic_slice_sizes={1,1,8,257,128}\n-    ROOT %bitcast.31250 = bf16[1,8,257,128] bitcast(%dynamic-slice.22040)\n-  }\n-\n-  %fused_computation.slice.2 (param_0.51117: bf16[4,1,8,257,128], offset: s32[]) -> bf16[1,8,257,128] {\n-    %param_0.51117 = bf16[4,1,8,257,128] parameter(0)\n-    offset = s32[] parameter(1)\n-    zero = s32[] constant(0)\n-    %dynamic-slice.22040 = bf16[1,1,8,257,128] dynamic-slice(bf16[4,1,8,257,128] %param_0.51117, offset, zero, zero, zero, zero), dynamic_slice_sizes={1,1,8,257,128}\n-    ROOT %bitcast.31250 = bf16[1,8,257,128] bitcast(%dynamic-slice.22040)\n-  }\n-\n-  inner.body {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128], bf16[4,1,8,257,128]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1), index=0\n-    get-tuple-element.2 = bf16[4,1,8,257,128] get-tuple-element(loop_var.1), index=1\n-    get-tuple-element.3 = bf16[4,1,8,257,128] get-tuple-element(loop_var.1), index=2\n-    sliced = bf16[1,8,257,128] fusion(get-tuple-element.2, get-tuple-element.1), kind=kLoop, calls=%fused_computation.slice\n-    sliced.2 = bf16[1,8,257,128] fusion(get-tuple-element.3, get-tuple-element.1), kind=kLoop,calls=%fused_computation.slice.2\n-    temp = bf16[1,8,257,128] add(sliced, sliced.2)\n-    one = s32[] constant(1) idx = s32[] add(get-tuple-element.1, one)\n-    ROOT out = tuple(idx, get-tuple-element.2, get-tuple-element.3)\n-  }\n-  inner.condition {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128], bf16[4,1,8,257,128])\n-    parameter(0) get-tuple-element.1 = s32[] get-tuple-element(loop_var.1),\n-    index=0 constant.2 = s32[] constant(4) ROOT less-than = pred[]\n-    compare(get-tuple-element.1, constant.2), direction=LT\n-  }\n-\n-  outer.body {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128], bf16[4,1,8,257,128]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1), index=0\n-    get-tuple-element.2 = bf16[4,1,8,257,128] get-tuple-element(loop_var.1), index=1\n-    get-tuple-element.3 = bf16[4,1,8,257,128] get-tuple-element(loop_var.1), index=2\n-    zero = s32[] constant(0)\n-    buffer = bf16[4,1,8,257,128] custom-call(), custom_call_target=\"AllocateBuffer\"\n-    inner.input = tuple(zero, buffer, get-tuple-element.2)\n-    inner = while(inner.input), condition=inner.condition, body=inner.body\n-    out1 = bf16[4,1,8,257,128] get-tuple-element(inner), index=1\n-    one = s32[] constant(1)\n-    idx = s32[] add(get-tuple-element.1, one)\n-    ROOT tuple = (s32[], bf16[4,1,8,257,128], bf16[4,1,8,257,128]) tuple(idx, out1, get-tuple-element.3)\n-  }\n-  outer.condition {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128], bf16[4,1,8,257,128])\n-    parameter(0) get-tuple-element.1 = s32[] get-tuple-element(loop_var.1),\n-    index=0 constant.2 = s32[] constant(4) mul = s32[]\n-    multiply(get-tuple-element.1, constant.2) ROOT less-than = pred[]\n-    compare(get-tuple-element.1, mul), direction=LT\n-  }\n-\n-  ENTRY SimpleLoop {\n-    param1 = bf16[4,1,8,257,128] parameter(0)\n-    param2 = bf16[4,1,8,257,128] parameter(1)\n-    zero = s32[] constant(0)\n-    zero1 = s32[] constant(0)\n-    one = s32[] constant(1)\n-    tuple.1 = tuple(zero, param1, param2)\n-    while = while(tuple.1), condition=outer.condition, body=outer.body\n-    ROOT out = s32[] get-tuple-element(while), index=0\n-  }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-// Unstacking the first loop at index 1 forces to unstack the second loop at\n-// index 1 as well.\n-TEST_F(UnstackerTest, UnstackDSAndDUSPatternLoopFeedingLoop) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-\n-  %fused_computation.update.slice (param_0.51117: bf16[4,1,8,257,128], p1: s32[], param_0.51118: bf16[1,8,257,128]) -> bf16[4,1,8,257,128] {\n-    %param_0.51117 = bf16[4,1,8,257,128] parameter(0)\n-    p1 = s32[] parameter(1)\n-    %param_0.51118 = bf16[1,8,257,128] parameter(2)\n-    bitcast = bf16[1,1,8,257,128] bitcast(param_0.51118)\n-    %constant.85694 = s32[] constant(0)\n-    ROOT %dynamic-update-slice.22040 = bf16[4,1,8,257,128] dynamic-update-slice(bf16[4,1,8,257,128] %param_0.51117, bitcast, p1, s32[] %constant.85694, s32[] %constant.85694, s32[] %constant.85694, s32[] %constant.85694)\n-  }\n-\n-  %fused_computation.slice (param_0.51117: bf16[4,1,8,257,128], offset:s32[]) -> bf16[1,8,257,128] {\n-    %param_0.51117 = bf16[4,1,8,257,128] parameter(0)\n-    offset = s32[] parameter(1)\n-    zero = s32[] constant(0)\n-    %dynamic-slice.22040 = bf16[1,1,8,257,128] dynamic-slice(bf16[4,1,8,257,128] %param_0.51117, offset, zero, zero, zero, zero), dynamic_slice_sizes={1,1,8,257,128}\n-    ROOT %bitcast.31250 = bf16[1,8,257,128] bitcast(%dynamic-slice.22040)\n-  }\n-\n-  first.body {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1),index=0\n-    get-tuple-element.2 = bf16[4,1,8,257,128] get-tuple-element(loop_var.1), index=1\n-    constant = bf16[1,8,257,128] constant({...})\n-    sliced = bf16[1,8,257,128] fusion(get-tuple-element.2, get-tuple-element.1), kind=kLoop, calls=%fused_computation.slice\n-    tmp = bf16[1,8,257,128] add(sliced, sliced)\n-    one = s32[] constant(1)\n-    idx = s32[] add(get-tuple-element.1, one)\n-    ROOT out = tuple(idx, get-tuple-element.2)\n-  }\n-  first.condition {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1), index=0\n-    constant.2 = s32[] constant(4)\n-    ROOT less-than = pred[] compare(get-tuple-element.1, constant.2), direction=LT\n-  }\n-\n-  next.body {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1),index=0\n-    get-tuple-element.2 = bf16[4,1,8,257,128] get-tuple-element(loop_var.1), index=1\n-    constant = bf16[1,8,257,128] constant({...})\n-    update.sliced = bf16[4,1,8,257,128] fusion(get-tuple-element.2, get-tuple-element.1, constant), kind=kLoop, calls=%fused_computation.update.slice\n-    one = s32[] constant(1)\n-    idx = s32[] add(get-tuple-element.1, one)\n-    ROOT out = tuple(idx, update.sliced)\n-  }\n-  next.condition {\n-    loop_var.1 = (s32[], bf16[4,1,8,257,128]) parameter(0)\n-    get-tuple-element.1 = s32[] get-tuple-element(loop_var.1), index=0\n-    constant.2 = s32[] constant(4)\n-    ROOT less-than = pred[] compare(get-tuple-element.1, constant.2), direction=LT\n-  }\n-\n-  ENTRY SimpleLoop {\n-    param1 = bf16[4,1,8,257,128] parameter(0)\n-    param2 = bf16[4,1,8,257,128] parameter(1)\n-    zero = s32[] constant(0)\n-    zero1 = s32[] constant(0)\n-    one = s32[] constant(1)\n-    tuple.1 = tuple(zero, param1)\n-    while = while(tuple.1), condition=first.condition, body=first.body\n-    while.out = bf16[4,1,8,257,128] get-tuple-element(while), index=1\n-    next.input = tuple(zero, while.out)\n-    next = while(next.input), condition=next.condition, body=next.body\n-    ROOT out = s32[] get-tuple-element(next), index=0\n-  }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-}\n-\n-TEST_F(UnstackerTest, UnstackDUSFusionWithPadPatternLoopFeedingLoop) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-  fused_computation.75.clone {\n-    param_0.5713 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} parameter(0)\n-    param_2.4396 = bf16[1,8,257,128]{3,2,1,0:T(8,128)(2,1)} parameter(2)\n-    constant.12166 = bf16[]{:T(256)} constant(0)\n-    pad.496 = bf16[1,8,513,128]{3,2,1,0:T(8,128)(2,1)} pad(param_2.4396, constant.12166), padding=0_0x0_0x0_256x0_0\n-    bitcast.1262 = bf16[1,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} bitcast(pad.496)\n-    param_1.6823 = s32[]{:T(128)} parameter(1)\n-    constant.12165 = s32[]{:T(128)} constant(0)\n-    ROOT dynamic-update-slice.193 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} dynamic-update-slice(param_0.5713, bitcast.1262, param_1.6823, constant.12165, constant.12165, /*index=5*/constant.12165, constant.12165)\n-  } // fused_computation.75.clone\n-\n-  fused_computation.1 {\n-    param_0.5712 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}parameter(0)\n-    param_1.6822 = s32[]{:T(128)} parameter(1)\n-    constant.12164 = s32[]{:T(128)} constant(0)\n-    dynamic-slice.1597 = bf16[1,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} dynamic-slice(param_0.5712, param_1.6822, constant.12164, constant.12164, constant.12164, /*index=5*/constant.12164), dynamic_slice_sizes={1,1,8,513,128}\n-    ROOT bitcast.1261 = bf16[1,8,513,128]{3,2,1,0:T(8,128)(2,1)} bitcast(dynamic-slice.1597)\n-  }\n-\n-  first.body {\n-    wide.param.29 = (s32[]{:T(128)}, bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}) parameter(0)\n-    get-tuple-element.12177 = s32[]{:T(128)} get-tuple-element(wide.param.29), index=0\n-    constant.12144..sunk.2 = s32[]{:T(128)} constant(1)\n-    add.4517 = s32[]{:T(128)} add(get-tuple-element.12177, constant.12144..sunk.2)\n-    get-tuple-element.12178 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} get-tuple-element(wide.param.29), index=1\n-    fusion.2381 = bf16[1,8,513,128]{3,2,1,0:T(8,128)(2,1)} fusion(get-tuple-element.12178, get-tuple-element.12177), kind=kLoop, calls=fused_computation.1\n-    tmp = bf16[1,8,513,128]{3,2,1,0:T(8,128)(2,1)} add(fusion.2381, fusion.2381)\n-    ROOT tuple.949 = (s32[]{:T(128)}, bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}) tuple(add.4517, get-tuple-element.12178)\n-  } // wide.region_54.2652.clone_spmd\n-\n-  first.cond {\n-    wide.param.28 = (s32[]{:T(128)}, bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}) parameter(0)\n-    get-tuple-element.12167 = s32[]{:T(128)} get-tuple-element(wide.param.28), index=0\n-    constant.12162 = s32[]{:T(128)} constant(2)\n-    ROOT compare.1815 = pred[]{:T(512)} compare(get-tuple-element.12167, constant.12162), direction=LT\n-  }\n-\n-  wide.region_54.2652.clone_spmd {\n-    wide.param.29 = (s32[]{:T(128)}, bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}) parameter(0)\n-    get-tuple-element.12177 = s32[]{:T(128)} get-tuple-element(wide.param.29), index=0\n-    constant.12144..sunk.2 = s32[]{:T(128)} constant(1)\n-    add.4517 = s32[]{:T(128)} add(get-tuple-element.12177, constant.12144..sunk.2)\n-    get-tuple-element.12178 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} get-tuple-element(wide.param.29), index=1\n-    update = bf16[1,8,257,128]{3,2,1,0:T(8,128)(2,1)} constant({...})\n-    fusion.2382 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} fusion(get-tuple-element.12178, get-tuple-element.12177, update), kind=kLoop, calls=fused_computation.75.clone\n-    ROOT tuple.949 = (s32[]{:T(128)}, bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}) tuple(add.4517, fusion.2382)\n-  } // wide.region_54.2652.clone_spmd\n-\n-  wide.region_55.2732.clone_spmd {\n-    wide.param.28 = (s32[]{:T(128)}, bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)}) parameter(0)\n-    get-tuple-element.12167 = s32[]{:T(128)} get-tuple-element(wide.param.28), index=0\n-    constant.12162 = s32[]{:T(128)} constant(2)\n-    ROOT compare.1815 = pred[]{:T(512)} compare(get-tuple-element.12167, constant.12162), direction=LT\n-  }\n-  ENTRY main {\n-    p0 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} parameter(0)\n-    init = s32[]{:T(128)} constant(0)\n-    first.input = tuple(init, p0)\n-    first.out = while(first.input), condition=first.cond , body=first.body\n-    o1 = bf16[2,1,8,513,128]{4,3,2,1,0:T(8,128)(2,1)} get-tuple-element(first.out), index=1\n-    input = tuple(init, o1)\n-    out = while(input), condition=wide.region_55.2732.clone_spmd , body=wide.region_54.2652.clone_spmd\n-    ROOT res = s32[]{:T(128)} get-tuple-element(out), index=0\n-  }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-}\n-\n-TEST_F(UnstackerTest, UnstackDUSFusionWithAddPattern) {\n-  std::string hlo_string = R\"(\n-  HloModule SimpleLoop\n-\n-  add.2771.reduce_sub_computation {\n-    lhs.44 = bf16[] parameter(0)\n-    rhs.44 = bf16[] parameter(1)\n-    ROOT add.3079 = bf16[] add(lhs.44, rhs.44)\n-  }\n-\n-  fused_computation.75.clone {\n-    param_0.31658 = bf16[2,4096]{1,0:T(8,128)(2,1)} parameter(0)\n-    param_1.26202 = s32[]{:T(128)} parameter(1)\n-    constant.47557 = s32[]{:T(128)} constant(0)\n-    dynamic-slice.12289 = bf16[1,4096]{1,0:T(2,128)(2,1)} dynamic-slice(param_0.31658, param_1.26202, constant.47557), dynamic_slice_sizes={1,4096}\n-    constant.47559 = bf16[]{:T(256)} constant(1)\n-    broadcast.39214 = bf16[1,4096]{1,0:T(2,128)(2,1)} broadcast(constant.47559), dimensions={}\n-    add.13176 = bf16[1,4096]{1,0:T(2,128)(2,1)} add(dynamic-slice.12289, broadcast.39214)\n-    constant.47558 = bf16[] constant(-0)\n-    ROOT reduce.8210 = bf16[4096]{0:T(1024)(128)(2,1)} reduce(add.13176, constant.47558), dimensions={0}, to_apply=add.2771.reduce_sub_computation\n-  } // fused_computation.75.clone\n-\n-  first.body {\n-    wide.param.29 = (s32[]{:T(128)}, bf16[2,4096]{1,0:T(8,128)(2,1)}) parameter(0)\n-    get-tuple-element.12177 = s32[]{:T(128)} get-tuple-element(wide.param.29), index=0\n-    constant.12144..sunk.2 = s32[]{:T(128)} constant(1)\n-    add.4517 = s32[]{:T(128)} add(get-tuple-element.12177, constant.12144..sunk.2)\n-    get-tuple-element.12178 = bf16[2,4096]{1,0:T(8,128)(2,1)} get-tuple-element(wide.param.29), index=1\n-    fusion.2381 = bf16[4096]{0:T(1024)(128)(2,1)} fusion(get-tuple-element.12178, get-tuple-element.12177), kind=kLoop, calls=fused_computation.75.clone\n-    tmp = bf16[4096]{0:T(1024)(128)(2,1)} add(fusion.2381, fusion.2381)\n-    ROOT tuple.949 = (s32[]{:T(128)}, bf16[2,4096]{1,0:T(8,128)(2,1)}) tuple(add.4517, get-tuple-element.12178)\n-  } // wide.region_54.2652.clone_spmd\n-\n-  first.cond {\n-    wide.param.28 = (s32[]{:T(128)}, bf16[2,4096]{1,0:T(8,128)(2,1)}) parameter(0)\n-    get-tuple-element.12167 = s32[]{:T(128)} get-tuple-element(wide.param.28), index=0\n-    constant.12162 = s32[]{:T(128)} constant(2)\n-    ROOT compare.1815 = pred[]{:T(512)} compare(get-tuple-element.12167, constant.12162), direction=LT\n-  }\n-\n-  ENTRY main {\n-    p0 = bf16[2,4096]{1,0:T(8,128)(2,1)} parameter(0)\n-    init = s32[]{:T(128)} constant(0)\n-    first.input = tuple(init, p0)\n-    first.out = while(first.input), condition=first.cond , body=first.body\n-    ROOT o1 = s32[]{:T(128)} get-tuple-element(first.out), index=0\n-  }\n-  )\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(hlo_string));\n-  auto original = module->Clone();\n-  TF_ASSERT_OK_AND_ASSIGN(bool unstacked, HloUnstacker().Run(module.get()));\n-  EXPECT_TRUE(unstacked);\n-  EXPECT_TRUE(RunAndCompareTwoModules(std::move(module), std::move(original),\n-                                      std::nullopt, false));\n-}\n-\n-}  // namespace\n-}  // namespace xla"
        }
    ],
    "stats": {
        "total": 3146,
        "additions": 0,
        "deletions": 3146
    }
}