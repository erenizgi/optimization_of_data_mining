{
    "author": "hawkinsp",
    "message": "Reverts ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e\n\nPiperOrigin-RevId: 811311201",
    "sha": "14235e047c28f20321b3453385b20bda9b053457",
    "files": [
        {
            "sha": "92dce5588027743d51b6fe34f8d8c9bb107e9262",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -570,15 +570,13 @@ xla_test(\n         \"//xla/pjrt:pjrt_future\",\n         \"//xla/pjrt/distributed:in_memory_key_value_store\",\n         \"//xla/pjrt/gpu:se_gpu_pjrt_client\",\n-        \"//xla/service:computation_placer_hdr\",\n         \"//xla/service:custom_call_target_registry\",\n         \"//xla/stream_executor/gpu:gpu_init\",\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:status\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n-        \"@com_google_absl//absl/cleanup\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\","
        },
        {
            "sha": "3499654563e358ccf7cdd3d7bb6b63853d7469c0",
            "filename": "third_party/xla/xla/pjrt/c/CHANGELOG.md",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -1,9 +1,5 @@\n # PJRT C API changelog\n \n-## 0.79\n-\n-* Added `PJRT_LoadedExecutable_GetDeviceAssignment.`\n-\n ## 0.78\n \n * Add incarnations to `PJRT_ExecuteOptions`."
        },
        {
            "sha": "8f61f0b10cb315c2b11ca6e2b50304ebb5db6e15",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 2,
            "deletions": 32,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -102,7 +102,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Extension_Base, next);\n // Changes include:\n // * Adding a new field to the PJRT_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define PJRT_API_MINOR 79\n+#define PJRT_API_MINOR 78\n \n // The plugin should set the major_version and minor_version of\n // PJRT_Api.pjrt_api_version to be the `PJRT_API_MAJOR` and `PJRT_API_MINOR` in\n@@ -1503,35 +1503,6 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_LoadedExecutable_GetExecutable_Args, executable);\n typedef PJRT_Error* PJRT_LoadedExecutable_GetExecutable(\n     PJRT_LoadedExecutable_GetExecutable_Args* args);\n \n-typedef struct PJRT_DeviceAssignmentSerialized PJRT_DeviceAssignmentSerialized;\n-\n-struct PJRT_LoadedExecutable_GetDeviceAssignment_Args {\n-  size_t struct_size;\n-  PJRT_Extension_Base* extension_start;\n-  PJRT_LoadedExecutable* executable;\n-\n-  // Lives only as long as serialized_device_assignment\n-  const char* serialized_bytes;  // out\n-  size_t serialized_bytes_size;  // out\n-\n-  PJRT_DeviceAssignmentSerialized*\n-      serialized_device_assignment;  // backs serialized_bytes.\n-  // cleanup fn must be called to free the backing memory for serialized_bytes.\n-  // Should only be called once on serialized_device_assignment.\n-  void (*serialized_device_assignment_deleter)(\n-      PJRT_DeviceAssignmentSerialized* da);  // out\n-};\n-PJRT_DEFINE_STRUCT_TRAITS(PJRT_LoadedExecutable_GetDeviceAssignment_Args,\n-                          serialized_device_assignment_deleter);\n-\n-// Retrieves the serialized DeviceAssignmentProto for a given\n-// PJRT_LoadedExecutable. The implementation allocates the serialized data,\n-// which is valid as long as `serialized_device_assignment` is alive. The\n-// caller must call `serialized_device_assignment_deleter` to free the\n-// backing memory.\n-typedef PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n-    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args);\n-\n struct PJRT_Executable_Name_Args {\n   size_t struct_size;\n   PJRT_Extension_Base* extension_start;\n@@ -2676,12 +2647,11 @@ typedef struct PJRT_Api {\n   _PJRT_API_STRUCT_FIELD(PJRT_TopologyDescription_Deserialize);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateAliasBuffer);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_FulfillAliasBuffer);\n-  _PJRT_API_STRUCT_FIELD(PJRT_LoadedExecutable_GetDeviceAssignment);\n } PJRT_Api;\n \n enum {\n   PJRT_Api_STRUCT_SIZE =\n-      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_LoadedExecutable_GetDeviceAssignment)\n+      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Client_FulfillAliasBuffer)\n };\n \n #undef _PJRT_API_STRUCT_FIELD"
        },
        {
            "sha": "d93ee3bb3d4943cd4fd1084a6359f1ae4adea747",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_gpu_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -30,7 +30,6 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n-#include \"absl/cleanup/cleanup.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n@@ -62,7 +61,6 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n-#include \"xla/service/computation_placer.h\"\n #include \"xla/service/custom_call_target_registry.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n@@ -288,44 +286,6 @@ TEST_F(PjrtCApiGpuExecutableTest, GetCompiledMemoryStats) {\n   EXPECT_EQ(ref_stats.host_temp_size_in_bytes, stats.host_temp_size_in_bytes);\n }\n \n-TEST_F(PjrtCApiGpuExecutableTest, GetDeviceAssignment) {\n-  PJRT_LoadedExecutable_GetDeviceAssignment_Args args;\n-  args.struct_size = PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE;\n-  args.extension_start = nullptr;\n-  args.executable = executable_.get();\n-\n-  PJRT_Error* error = api_->PJRT_LoadedExecutable_GetDeviceAssignment(&args);\n-  ASSERT_EQ(error, nullptr);\n-\n-  absl::Cleanup cleanup = [&args] {\n-    args.serialized_device_assignment_deleter(\n-        args.serialized_device_assignment);\n-  };\n-\n-  // Deserialize\n-  xla::DeviceAssignmentProto proto;\n-  std::string serialized_proto(args.serialized_bytes,\n-                               args.serialized_bytes_size);\n-  ASSERT_TRUE(proto.ParseFromString(serialized_proto));\n-  TF_ASSERT_OK_AND_ASSIGN(auto device_assignment,\n-                          xla::DeviceAssignment::Deserialize(proto));\n-\n-  // Use the PJRT C++ API to create a reference device assignment.\n-  const xla::DeviceAssignment& ref_device_assignment =\n-      executable_->get()->device_assignment();\n-\n-  // Compare with reference to ensure the C++ and C APIs are equivalent.\n-  EXPECT_EQ(device_assignment->replica_count(),\n-            ref_device_assignment.replica_count());\n-  EXPECT_EQ(device_assignment->computation_count(),\n-            ref_device_assignment.computation_count());\n-  for (int i = 0; i < device_assignment->replica_count(); ++i) {\n-    for (int j = 0; j < device_assignment->computation_count(); ++j) {\n-      EXPECT_EQ((*device_assignment)(i, j), ref_device_assignment(i, j));\n-    }\n-  }\n-}\n-\n TEST_F(PjrtCApiGpuTest, CreateAndDestroyExecuteContext) {\n   PJRT_ExecuteContext_Create_Args create_arg;\n   create_arg.struct_size = PJRT_ExecuteContext_Create_Args_STRUCT_SIZE;"
        },
        {
            "sha": "325b2abd3fc8908e68a8ef071f611979ae473139",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -942,9 +942,6 @@ FieldOffsetsAndSizesForVersion(int major_version, int minor_version) {\n       add_field(\"PJRT_Client_CreateAliasBuffer\", kFnPtrSize);\n       add_field(\"PJRT_Client_FulfillAliasBuffer\", kFnPtrSize);\n     }\n-    if (minor_version >= 79) {\n-      add_field(\"PJRT_LoadedExecutable_GetDeviceAssignment\", kFnPtrSize);\n-    }\n     return version_offsets_and_sizes;\n   }\n   LOG(FATAL) << \"Unsupported API version: \" << major_version << \".\"\n@@ -1333,9 +1330,6 @@ TEST_F(PjrtCAbiTestBase, FieldOffsetsAndSizes) {\n           {\"PJRT_Client_FulfillAliasBuffer\",\n            {offsetof(PJRT_Api, PJRT_Client_FulfillAliasBuffer),\n             sizeof(PJRT_Api::PJRT_Client_FulfillAliasBuffer)}},\n-          {\"PJRT_LoadedExecutable_GetDeviceAssignment\",\n-           {offsetof(PJRT_Api, PJRT_LoadedExecutable_GetDeviceAssignment),\n-            sizeof(PJRT_Api::PJRT_LoadedExecutable_GetDeviceAssignment)}},\n       };\n   ASSERT_EQ(api_->pjrt_api_version.major_version, PJRT_API_MAJOR);\n   ASSERT_EQ(api_->pjrt_api_version.minor_version, PJRT_API_MINOR);"
        },
        {
            "sha": "66211e98152baec5907e7b7fd443a015917ad935",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 53,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -2581,57 +2581,6 @@ PJRT_Error* PJRT_TopologyDescription_Deserialize(\n   return nullptr;\n }\n \n-PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n-    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args) {\n-  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n-      \"PJRT_LoadedExecutable_GetDeviceAssignment_Args\",\n-      PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE,\n-      args->struct_size));\n-\n-  // A portable executable doesn't have a device assignment. Return an empty\n-  // assignment and no-op deleter in this case.\n-  PJRT_ASSIGN_OR_RETURN(\n-      xla::CompileOptions compile_options,\n-      args->executable->executable->GetExecutable()->GetCompileOptions());\n-  if (compile_options.compile_portable_executable) {\n-    args->serialized_bytes_size = 0;\n-    args->serialized_device_assignment = nullptr;\n-    args->serialized_device_assignment_deleter =\n-        +[](PJRT_DeviceAssignmentSerialized* serialized_device_assignment) {};\n-    return nullptr;\n-  }\n-\n-  const xla::DeviceAssignment& device_assignment =\n-      args->executable->executable->device_assignment();\n-\n-  xla::DeviceAssignmentProto proto;\n-  device_assignment.Serialize(&proto);\n-\n-  std::string serialized_proto;\n-  if (!proto.SerializeToString(&serialized_proto)) {\n-    return new PJRT_Error{xla::ResourceExhausted(\n-        \"%s: Device assignment serialization failed, likely due to exceeding \"\n-        \"the max supported protobuf size of 2 GiB.\",\n-        __func__)};\n-  }\n-\n-  PJRT_DeviceAssignmentSerialized* serialized_da =\n-      new PJRT_DeviceAssignmentSerialized;\n-  if (serialized_da == nullptr) {\n-    return new PJRT_Error{xla::ResourceExhausted(\n-        \"Out of memory for `PJRT_LoadedExecutable_GetDeviceAssignment()`\")};\n-  }\n-  serialized_da->serialized = std::move(serialized_proto);\n-  args->serialized_device_assignment = serialized_da;\n-  args->serialized_bytes = serialized_da->serialized.data();\n-  args->serialized_bytes_size = serialized_da->serialized.size();\n-  args->serialized_device_assignment_deleter =\n-      +[](PJRT_DeviceAssignmentSerialized* serialized_device_assignment) {\n-        delete serialized_device_assignment;\n-      };\n-  return nullptr;\n-}\n-\n // ---------------------------------- Layouts ----------------------------------\n \n PJRT_Error* PJRT_Layouts_MemoryLayout_Destroy(\n@@ -3095,8 +3044,6 @@ PJRT_Api CreatePjrtApi(PJRT_Client_Create* create_fn,\n       pjrt::PJRT_Client_CreateAliasBuffer,\n       /*PJRT_Client_FulfillAliasBuffer=*/\n       pjrt::PJRT_Client_FulfillAliasBuffer,\n-      /*PJRT_LoadedExecutable_GetDeviceAssignment=*/\n-      pjrt::PJRT_LoadedExecutable_GetDeviceAssignment,\n   };\n }\n "
        },
        {
            "sha": "7e7b0a3086fa98c324b2957c2b341dc6d6e4f5db",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.h",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -210,10 +210,6 @@ struct PJRT_SerializedExecutable {\n   std::string serialized;\n };\n \n-struct PJRT_DeviceAssignmentSerialized {\n-  std::string serialized;\n-};\n-\n struct PJRT_SerializedTopology {\n   std::string serialized;\n };\n@@ -388,8 +384,6 @@ PJRT_Error* PJRT_LoadedExecutable_GetExecutable(\n // until the next major version upgrade.\n PJRT_Error* PJRT_LoadedExecutable_Fingerprint(\n     PJRT_LoadedExecutable_Fingerprint_Args* args);\n-PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n-    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args);\n \n PJRT_Error* PJRT_Buffer_Destroy(PJRT_Buffer_Destroy_Args* args);\n PJRT_Error* PJRT_Buffer_ElementType(PJRT_Buffer_ElementType_Args* args);"
        },
        {
            "sha": "796b91d80d747f64daa10b8ce3a44ee34de6994c",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 35,
            "changes": 35,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -1802,7 +1802,6 @@ PjRtCApiLoadedExecutable::PjRtCApiLoadedExecutable(\n   executable_ =\n       std::make_unique<PjRtCApiExecutable>(pjrt_c_api(), args.executable);\n   InitDevices();\n-  InitDeviceAssignment();\n }\n \n void PjRtCApiLoadedExecutable::InitDevices() {\n@@ -1827,40 +1826,6 @@ void PjRtCApiLoadedExecutable::InitDevices() {\n   }\n }\n \n-void PjRtCApiLoadedExecutable::InitDeviceAssignment() {\n-  PJRT_LoadedExecutable_GetDeviceAssignment_Args args;\n-  args.struct_size = PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE;\n-  args.extension_start = nullptr;\n-  args.executable = c_loaded_executable();\n-\n-  const PJRT_Api* api = pjrt_c_api();\n-\n-  pjrt::LogFatalIfPjrtError(\n-      api->PJRT_LoadedExecutable_GetDeviceAssignment(&args), api);\n-\n-  absl::Cleanup cleanup = [&args] {\n-    args.serialized_device_assignment_deleter(\n-        args.serialized_device_assignment);\n-  };\n-\n-  // If `serialized_bytes_size` is 0, this executable is portable and has no\n-  // device assignment.\n-  if (args.serialized_bytes_size == 0) {\n-    device_assignment_ = nullptr;\n-    return;\n-  }\n-\n-  std::string serialized_proto(args.serialized_bytes,\n-                               args.serialized_bytes_size);\n-  DeviceAssignmentProto proto;\n-  CHECK(proto.ParseFromString(serialized_proto));\n-\n-  absl::StatusOr<std::unique_ptr<DeviceAssignment>> device_assignment =\n-      DeviceAssignment::Deserialize(proto);\n-  CHECK_OK(device_assignment.status());\n-  device_assignment_ = std::move(*device_assignment);\n-}\n-\n static std::vector<std::vector<PJRT_Buffer*>> Convert2DCppBuffersToCBuffers(\n     absl::Span<const std::vector<PjRtBuffer*>> cpp_lists) {\n   std::vector<std::vector<PJRT_Buffer*>> c_lists;"
        },
        {
            "sha": "27a9922875126700a951e6f53f15a30e4bd17759",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -617,11 +617,7 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n   }\n \n   const DeviceAssignment& device_assignment() const override {\n-    CHECK(device_assignment_ != nullptr)\n-        << \"device_assignment_ is a nullptr. This is likely because \"\n-           \"PjRtCApiLoadedExecutable::device_assignment() was called on a \"\n-           \"portable executable, which does not have a device assignment.\";\n-    return *device_assignment_;\n+    CHECK(false) << \"PJRT C API does not support device_assignment\";\n   }\n \n   absl::Span<const LogicalDeviceIds> addressable_device_logical_ids()\n@@ -755,10 +751,8 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n       loaded_executable_;\n   std::unique_ptr<PjRtCApiExecutable> executable_;\n   std::vector<PjRtDevice*> addressable_devices_;\n-  std::unique_ptr<const DeviceAssignment> device_assignment_;\n \n   void InitDevices();\n-  void InitDeviceAssignment();\n };\n \n class CApiCopyToDeviceStream : public CopyToDeviceStream {"
        },
        {
            "sha": "7b0dd9a724edf201e5417e3506923a6644c3ec8c",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 29,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14235e047c28f20321b3453385b20bda9b053457/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc?ref=14235e047c28f20321b3453385b20bda9b053457",
            "patch": "@@ -350,35 +350,6 @@ TEST(PjRtClientTest, CanQueryMemoryDescriptions) {\n   }\n }\n \n-TEST(PjRtCApiClientTest, GetDeviceAssignment) {\n-  SetUpCpuPjRtApi();\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,\n-                          GetCApiClient(\"cpu\"));\n-  ASSERT_GT(client->addressable_devices().size(), 1);\n-\n-  XlaBuilder builder(\"Identity\");\n-  Shape shape = ShapeUtil::MakeShape(S32, {2, 3});\n-  auto input = Parameter(&builder, 0, shape, \"input\");\n-  auto computation = builder.Build(input).value();\n-\n-  DeviceAssignment device_assignment(1, 2);\n-  device_assignment(0, 0) = 0;\n-  device_assignment(0, 1) = 1;\n-\n-  CompileOptions options;\n-  options.executable_build_options.set_device_assignment(device_assignment);\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtLoadedExecutable> executable,\n-                          client->CompileAndLoad(computation, options));\n-\n-  const DeviceAssignment& retrieved_assignment =\n-      executable->device_assignment();\n-  EXPECT_EQ(retrieved_assignment.replica_count(), 1);\n-  EXPECT_EQ(retrieved_assignment.computation_count(), 2);\n-  EXPECT_EQ(retrieved_assignment(0, 0), 0);\n-  EXPECT_EQ(retrieved_assignment(0, 1), 1);\n-}\n-\n TEST(PjRtCApiClientTest, WrapClientAroundCApi) {\n   const PJRT_Api* c_api = ::pjrt::cpu_plugin::GetCpuPjrtApi();\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,"
        }
    ],
    "stats": {
        "total": 217,
        "additions": 3,
        "deletions": 214
    }
}