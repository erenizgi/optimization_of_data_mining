{
    "author": "bhavani-subramanian",
    "message": "PR #34137: [XLA:GPU][oneAPI] SYCL stream and tests\n\nImported from GitHub PR https://github.com/openxla/xla/pull/34137\n\nCo-author: @kanvi-nervana.\n\nThis PR implements SYCL stream and adds corresponding tests. The tests will be updated to use `SyclExecutor` once it is implemented.\n\nCopybara import of the project:\n\n--\n93049b95b9fbd1bfee32db56dbe1062fafac76bf by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nAdded sycl_stream and tests\n\n--\nf0b1689a4144ad1974f907f08a4d658cd6b7c7fa by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nCode cleanup\n\n--\n47d6a1153f2f4634434301f8710207d78238f01c by Bhavani Subramanian <bhavani1.subramanian@intel.com>:\n\nRemoved future include and related test from SyclStreamTest\n\nMerging this change closes #34137\n\nPiperOrigin-RevId: 838917251",
    "sha": "983811d524d698cea33ec892eef4d0df5fb56196",
    "files": [
        {
            "sha": "cdd6ebfc2a5759584012d7129823be0d8d97567c",
            "filename": "third_party/xla/xla/stream_executor/sycl/BUILD",
            "status": "modified",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2FBUILD?ref=983811d524d698cea33ec892eef4d0df5fb56196",
            "patch": "@@ -123,6 +123,55 @@ xla_cc_test(\n     ],\n )\n \n+sycl_library(\n+    name = \"sycl_stream\",\n+    srcs = [\"sycl_stream.cc\"],\n+    hdrs = [\"sycl_stream.h\"],\n+    tags = [\n+        \"gpu\",\n+        \"oneapi-only\",\n+    ],\n+    deps = [\n+        \":sycl_context\",\n+        \":sycl_event\",\n+        \"//xla/stream_executor:device_memory\",\n+        \"//xla/stream_executor:event\",\n+        \"//xla/stream_executor:event_based_timer\",\n+        \"//xla/stream_executor:stream\",\n+        \"//xla/stream_executor:stream_common\",\n+        \"//xla/tsl/platform:logging\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+    ],\n+)\n+\n+xla_test(\n+    name = \"sycl_stream_test\",\n+    srcs = [\"sycl_stream_test.cc\"],\n+    backends = [\"gpu\"],\n+    tags = [\n+        \"gpu\",\n+        \"oneapi-only\",\n+    ],\n+    deps = [\n+        \":sycl_event\",\n+        \":sycl_platform_id\",\n+        \":sycl_stream\",\n+        \"//xla/backends/gpu/runtime:kernel_thunk\",\n+        \"//xla/service/gpu:gpu_executable\",\n+        \"//xla/stream_executor:device_memory\",\n+        \"//xla/stream_executor:platform_manager\",\n+        \"//xla/stream_executor:typed_kernel_factory\",\n+        \"//xla/tests:llvm_irgen_test_base\",\n+        \"//xla/tsl/platform:status_matchers\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"sycl_solver_context\",\n     srcs = [\"sycl_solver_context.cc\"],"
        },
        {
            "sha": "ef45cb481b36624c148bfdbb7460bfeed58f2bcf",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_stream.cc",
            "status": "added",
            "additions": 323,
            "deletions": 0,
            "changes": 323,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream.cc?ref=983811d524d698cea33ec892eef4d0df5fb56196",
            "patch": "@@ -0,0 +1,323 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/sycl/sycl_stream.h\"\n+\n+#include \"xla/tsl/platform/logging.h\"\n+\n+namespace stream_executor::sycl {\n+\n+namespace {\n+\n+absl::Status LaunchSyclKernel(\n+    StreamExecutor* executor, absl::string_view kernel_name,\n+    ::sycl::kernel* function, unsigned int thread_dim_x,\n+    unsigned int thread_dim_y, unsigned int thread_dim_z,\n+    unsigned int block_dim_x, unsigned int block_dim_y,\n+    unsigned int block_dim_z, unsigned int shared_mem_bytes,\n+    ::sycl::queue* stream_handle, void** kernel_params, void** extra) {\n+  VLOG(2) << \"Launching kernel '\" << kernel_name << \"' using ThreadDim{\"\n+          << thread_dim_x << \", \" << thread_dim_y << \", \" << thread_dim_z\n+          << \"}, BlockDim{\" << block_dim_x << \", \" << block_dim_y << \", \"\n+          << block_dim_z << \"}; function: \" << (const void*)function;\n+\n+  if (function == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"LaunchSyclKernel: No kernel function provided.\");\n+  }\n+\n+  if (stream_handle == nullptr) {\n+    return absl::InvalidArgumentError(\n+        \"LaunchSyclKernel: No stream handle provided.\");\n+  }\n+\n+  ::sycl::range<3> global_range(block_dim_z * thread_dim_z,\n+                                block_dim_y * thread_dim_y,\n+                                block_dim_x * thread_dim_x);\n+  ::sycl::range<3> local_range(thread_dim_z, thread_dim_y, thread_dim_x);\n+  ::sycl::nd_range<3> nd_range(global_range, local_range);\n+\n+  stream_handle->submit([&](::sycl::handler& cgh) {\n+    if (kernel_params == nullptr) {\n+      VLOG(2) << \"LaunchSyclKernel: No kernel parameters provided; launching \"\n+                 \"kernel.\";\n+      cgh.parallel_for(nd_range, *function);\n+      return;\n+    }\n+\n+    // kernel_params is expected to be an array of two pointers:\n+    // kernel_params[0]: pointer to array of kernel argument pointers\n+    // kernel_params[1]: pointer to number of kernel arguments\n+    if (kernel_params[0] == nullptr || kernel_params[1] == nullptr) {\n+      LOG(ERROR)\n+          << \"LaunchSyclKernel: kernel_params[0] or kernel_params[1] is null, \"\n+             \"cannot set kernel arguments.\";\n+      return;\n+    }\n+\n+    void** arg_ptrs = static_cast<void**>(kernel_params[0]);\n+    size_t* num_args_ptr = static_cast<size_t*>(kernel_params[1]);\n+    size_t num_args = num_args_ptr ? *num_args_ptr : 0;\n+\n+    for (size_t arg_index = 0; arg_index < num_args; ++arg_index) {\n+      if (arg_ptrs[arg_index] == nullptr) {\n+        LOG(ERROR) << \"LaunchSyclKernel: kernel argument \" << arg_index\n+                   << \" is null, cannot set kernel argument.\";\n+        return;\n+      }\n+      VLOG(2) << \"Setting kernel argument \" << arg_index\n+              << \" at address: \" << arg_ptrs[arg_index];\n+      cgh.set_arg(arg_index, arg_ptrs[arg_index]);\n+    }\n+\n+    if (num_args == 0) {\n+      VLOG(2)\n+          << \"LaunchSyclKernel: No kernel arguments to set; launching kernel.\";\n+    }\n+    cgh.parallel_for(nd_range, *function);\n+  });\n+  return absl::OkStatus();\n+}\n+\n+absl::Status LaunchSyclKernel(\n+    StreamExecutor* executor, absl::string_view kernel_name,\n+    ::sycl::kernel* function, unsigned int cluster_dim_x,\n+    unsigned int cluster_dim_y, unsigned int cluster_dim_z,\n+    unsigned int thread_dim_x, unsigned int thread_dim_y,\n+    unsigned int thread_dim_z, unsigned int block_dim_x,\n+    unsigned int block_dim_y, unsigned int block_dim_z,\n+    unsigned int shared_mem_bytes, ::sycl::queue* stream_handle,\n+    void** kernel_params, void** extra) {\n+  if (cluster_dim_x != 1 || cluster_dim_y != 1 || cluster_dim_z != 1)\n+    return absl::UnimplementedError(\n+        \"LaunchSyclKernel: Non-default cluster dimensions are not supported.\");\n+  return LaunchSyclKernel(executor, kernel_name, function, thread_dim_x,\n+                          thread_dim_y, thread_dim_z, block_dim_x, block_dim_y,\n+                          block_dim_z, shared_mem_bytes, stream_handle,\n+                          kernel_params, extra);\n+}\n+\n+}  // namespace\n+\n+absl::Status SyclStream::WaitFor(Stream* other) {\n+  SyclStream* other_stream = static_cast<SyclStream*>(other);\n+  TF_RETURN_IF_ERROR(other_stream->RecordCompletedEvent());\n+  return SyclEvent::WaitStreamOnEvent(\n+      executor_, stream_handle_.get(),\n+      other_stream->completed_event_.GetEvent());\n+}\n+\n+absl::Status SyclStream::RecordEvent(Event* event) {\n+  ::sycl::event sycl_event = static_cast<SyclEvent*>(event)->GetEvent();\n+  TF_ASSIGN_OR_RETURN(std::optional<::sycl::event> recent_event,\n+                      SyclGetRecentEventFromStream(stream_handle_.get()));\n+  if (!recent_event.has_value()) {\n+    // TODO(intel-tf): Record sycl_event via SyclEvent's SetEvent() if no\n+    // recent event is found.\n+    return absl::InternalError(\n+        \"RecordEvent: No event returned from SyclGetRecentEventFromStream\");\n+  }\n+  // Update the event to the most recent one on the stream.\n+  sycl_event = recent_event.value();\n+  VLOG(2) << \"Recording SYCL event on stream \" << stream_handle_.get();\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::WaitFor(Event* event) {\n+  return SyclEvent::WaitStreamOnEvent(\n+      executor_, stream_handle_.get(),\n+      static_cast<SyclEvent*>(event)->GetEvent());\n+}\n+\n+absl::Status SyclStream::Memset32(DeviceMemoryBase* location, uint32_t pattern,\n+                                  uint64_t size) {\n+  VLOG(2) << \"Enqueuing memset32 operation onto stream \" << stream_handle_.get()\n+          << \" at location \" << reinterpret_cast<const void*>(location)\n+          << \" with size \" << size << \" and pattern 0x\" << std::hex << pattern\n+          << std::dec;\n+  if (absl::bit_cast<uintptr_t>(location->opaque()) % alignof(uint32_t) != 0) {\n+    return absl::InvalidArgumentError(\"Location must be 4 byte aligned\");\n+  }\n+  if (size % sizeof(uint32_t) != 0) {\n+    return absl::InvalidArgumentError(\"Size must be a multiple of 4 bytes.\");\n+  }\n+  TF_RETURN_IF_ERROR(SyclMemfillDeviceAsync(\n+      stream_handle_.get(), const_cast<void*>(location->opaque()), pattern,\n+      size / sizeof(uint32_t)));\n+  VLOG(2) << \"Successfully enqueued async memset32 of \"\n+          << size / sizeof(uint32_t) << \" uint32s at \" << location\n+          << \" with value 0x\" << std::hex << pattern << std::dec\n+          << \" on stream \" << stream_handle_;\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::MemZero(DeviceMemoryBase* location, uint64_t size) {\n+  if (absl::bit_cast<uintptr_t>(location->opaque()) % alignof(uint32_t) == 0 &&\n+      size % sizeof(uint32_t) == 0) {\n+    return SyclStream::Memset32(location, 0x0, size);\n+  }\n+  TF_RETURN_IF_ERROR(SyclMemsetDeviceAsync(\n+      stream_handle_.get(), const_cast<void*>(location->opaque()), 0x0, size));\n+  VLOG(2) << \"Successfully enqueued async memset8 of \" << size << \" bytes at \"\n+          << location << \" with value 0x0 on stream \" << stream_handle_;\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::Memcpy(DeviceMemoryBase* gpu_dst, const void* host_src,\n+                                uint64_t size) {\n+  TF_RETURN_IF_ERROR(SyclMemcpyHostToDeviceAsync(\n+      stream_handle_.get(), const_cast<void*>(gpu_dst->opaque()), host_src,\n+      size));\n+  VLOG(2) << \"Successfully enqueued async memcpy H2D of \" << size << \" bytes\"\n+          << \" from \" << host_src << \" to \" << gpu_dst << \" on stream \"\n+          << stream_handle_;\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::Memcpy(void* host_dst, const DeviceMemoryBase& gpu_src,\n+                                uint64_t size) {\n+  TF_RETURN_IF_ERROR(\n+      SyclMemcpyDeviceToHostAsync(stream_handle_.get(), host_dst,\n+                                  const_cast<void*>(gpu_src.opaque()), size));\n+  VLOG(2) << \"Successfully enqueued async memcpy D2H of \" << size << \" bytes\"\n+          << \" from \" << gpu_src.opaque() << \" to \" << host_dst << \" on stream \"\n+          << stream_handle_;\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::Memcpy(DeviceMemoryBase* gpu_dst,\n+                                const DeviceMemoryBase& gpu_src,\n+                                uint64_t size) {\n+  TF_RETURN_IF_ERROR(SyclMemcpyDeviceToDeviceAsync(\n+      stream_handle_.get(), const_cast<void*>(gpu_dst->opaque()),\n+      const_cast<void*>(gpu_src.opaque()), size));\n+  VLOG(2) << \"Successfully enqueued async memcpy D2D of \" << size << \" bytes\"\n+          << \" from \" << gpu_src.opaque() << \" to \" << gpu_dst << \" on stream \"\n+          << stream_handle_;\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::DoHostCallbackWithStatus(\n+    absl::AnyInvocable<absl::Status() &&> callback) {\n+  // Heap-allocate and wrap the callback to ensure its lifetime for async\n+  // execution.\n+  auto callback_ptr =\n+      new absl::AnyInvocable<void() &&>([cb = std::move(callback)]() mutable {\n+        absl::Status status = std::move(cb)();\n+        if (!status.ok()) {\n+          LOG(WARNING) << \"Host callback failed: \" << status;\n+        }\n+      });\n+  // Cast to void* to simplify lambda capture for SYCL host task.\n+  auto callback_ptr_void = reinterpret_cast<void*>(callback_ptr);\n+\n+  // Lambda invokes and deletes the callback.\n+  auto callback_function = std::function<void()>([callback_ptr_void]() {\n+    auto* callback_ptr =\n+        reinterpret_cast<absl::AnyInvocable<void() &&>*>(callback_ptr_void);\n+    std::move (*callback_ptr)();\n+    delete callback_ptr;\n+  });\n+\n+  // Enqueue the host callback for asynchronous execution.\n+  stream_handle_->submit([&](::sycl::handler& cgh) {\n+    cgh.host_task(std::move(callback_function));\n+  });\n+\n+  // Callback successfully enqueued. Since it is executed asynchronously,\n+  // return OK status even if the callback itself may fail.\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SyclStream::BlockHostUntilDone() {\n+  stream_handle_->wait();\n+  return absl::OkStatus();\n+}\n+\n+absl::StatusOr<std::unique_ptr<SyclStream>> SyclStream::Create(\n+    StreamExecutor* executor, bool enable_multiple_streams,\n+    std::optional<std::variant<StreamPriority, int>> priority) {\n+  // Determine stream priority.\n+  int stream_priority = 0;\n+  if (priority.has_value()) {\n+    if (std::holds_alternative<int>(priority.value())) {\n+      stream_priority = std::get<int>(priority.value());\n+    } else if (std::get<StreamPriority>(priority.value()) ==\n+               StreamPriority::Default) {\n+      stream_priority = 0;\n+    } else {\n+      return absl::UnimplementedError(\n+          \"SyclStream::Create: SYCL does not support non-default (non-zero) \"\n+          \"stream priority.\");\n+    }\n+  }\n+\n+  VLOG(0) << \"Creating stream for device ordinal \" << executor->device_ordinal()\n+          << (enable_multiple_streams ? \" with\" : \" without\")\n+          << \" multiple streams enabled\";\n+\n+  TF_ASSIGN_OR_RETURN(StreamPtr stream_handle,\n+                      SyclStreamPool::GetOrCreateStream(\n+                          executor->device_ordinal(), enable_multiple_streams));\n+\n+  TF_ASSIGN_OR_RETURN(SyclEvent completed_event, SyclEvent::Create(executor));\n+\n+  return std::unique_ptr<SyclStream>(new SyclStream(\n+      executor, std::move(completed_event), priority, stream_handle));\n+}\n+\n+SyclStream::~SyclStream() {\n+  // Wait for all pending operations to complete before destroying the stream.\n+  BlockHostUntilDone().IgnoreError();\n+\n+  // Remove this stream from the executor's list of allocated streams.\n+  executor_->DeallocateStream(this);\n+\n+  // Destroy the underlying SYCL stream.\n+  absl::Status destroy_status = SyclStreamPool::DestroyStream(\n+      executor_->device_ordinal(), stream_handle_);\n+  if (!destroy_status.ok()) {\n+    LOG(ERROR) << \"Failed to destroy stream \" << stream_handle_.get()\n+               << \" for device \" << executor_->device_ordinal() << \", got \"\n+               << destroy_status;\n+  } else {\n+    VLOG(2) << \"Successfully destroyed stream \" << stream_handle_.get()\n+            << \" for device \" << executor_->device_ordinal();\n+    stream_handle_ = nullptr;\n+  }\n+}\n+\n+absl::Status SyclStream::RecordCompletedEvent() {\n+  return RecordEvent(&completed_event_);\n+}\n+\n+absl::Status SyclStream::LaunchKernel(\n+    const ThreadDim& thread_dims, const BlockDim& block_dims,\n+    const std::optional<ClusterDim>& cluster_dims, void* function,\n+    absl::string_view name, void** args, int64_t shmem_bytes) {\n+  if (cluster_dims.has_value()) {\n+    return LaunchSyclKernel(\n+        executor_, name, static_cast<::sycl::kernel*>(function),\n+        cluster_dims->x, cluster_dims->y, cluster_dims->z, thread_dims.x,\n+        thread_dims.y, thread_dims.z, block_dims.x, block_dims.y, block_dims.z,\n+        shmem_bytes, stream_handle_.get(), args, /*extra=*/nullptr);\n+  }\n+  return LaunchSyclKernel(\n+      executor_, name, static_cast<::sycl::kernel*>(function), thread_dims.x,\n+      thread_dims.y, thread_dims.z, block_dims.x, block_dims.y, block_dims.z,\n+      shmem_bytes, stream_handle_.get(), args, /*extra=*/nullptr);\n+}\n+\n+}  // namespace stream_executor::sycl"
        },
        {
            "sha": "80b72cf7153837abf2cf2218e4315f60f8dec056",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_stream.h",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream.h?ref=983811d524d698cea33ec892eef4d0df5fb56196",
            "patch": "@@ -0,0 +1,138 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_STREAM_EXECUTOR_SYCL_SYCL_STREAM_H_\n+#define XLA_STREAM_EXECUTOR_SYCL_SYCL_STREAM_H_\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/event.h\"\n+#include \"xla/stream_executor/event_based_timer.h\"\n+#include \"xla/stream_executor/stream.h\"\n+#include \"xla/stream_executor/stream_common.h\"\n+#include \"xla/stream_executor/sycl/sycl_context.h\"\n+#include \"xla/stream_executor/sycl/sycl_event.h\"\n+\n+namespace stream_executor::sycl {\n+\n+class SyclStream : public StreamCommon {\n+ public:\n+  // Makes the current stream wait until all operations enqueued in the other\n+  // stream up to its most recently recorded event have completed.\n+  absl::Status WaitFor(Stream* other) override;\n+\n+  // Records the most recent event on the current stream into the given Event\n+  // object. This typically marks the point up to which work has been enqueued\n+  // on the stream. This allows other streams or operations to synchronize with\n+  // this point in the stream's execution.\n+  absl::Status RecordEvent(Event* event) override;\n+\n+  // Blocks execution on the current stream until the given event is completed.\n+  absl::Status WaitFor(Event* event) override;\n+\n+  // Enqueues an asynchronous operation to set the specified device memory\n+  // region to the given value.\n+  absl::Status Memset32(DeviceMemoryBase* location, uint32_t pattern,\n+                        uint64_t size) override;\n+\n+  // Enqueues an asynchronous operation to zero out the specified device memory\n+  // region.\n+  absl::Status MemZero(DeviceMemoryBase* location, uint64_t size) override;\n+\n+  // Enqueues an asynchronous copy from host memory to device memory.\n+  absl::Status Memcpy(DeviceMemoryBase* gpu_dst, const void* host_src,\n+                      uint64_t size) override;\n+\n+  // Enqueues an asynchronous copy from device memory to host memory.\n+  absl::Status Memcpy(void* host_dst, const DeviceMemoryBase& gpu_src,\n+                      uint64_t size) override;\n+\n+  // Enqueues an asynchronous copy from one device memory region to another.\n+  absl::Status Memcpy(DeviceMemoryBase* gpu_dst,\n+                      const DeviceMemoryBase& gpu_src, uint64_t size) override;\n+\n+  // Enqueues a host callback to be executed after all previously enqueued\n+  // operations on the current stream have completed.\n+  absl::Status DoHostCallbackWithStatus(\n+      absl::AnyInvocable<absl::Status() &&> callback) override;\n+\n+  // Blocks the host until all previously enqueued operations on the current\n+  // stream have completed.\n+  absl::Status BlockHostUntilDone() override;\n+\n+  // Returns a platform-specific handle for the underlying SYCL stream.\n+  Stream::PlatformSpecificHandle platform_specific_handle() const override {\n+    return {stream_handle_.get()};\n+  }\n+\n+  // Creates an event-based timer for measuring elapsed time on the current\n+  // stream.\n+  absl::StatusOr<std::unique_ptr<EventBasedTimer>> CreateEventBasedTimer(\n+      bool use_delay_kernel) override {\n+    return executor_->CreateEventBasedTimer(this, use_delay_kernel);\n+  }\n+\n+  // Creates a new SyclStream instance for the specified executor.\n+  // Supports optional stream priority and multiple streams per device.\n+  static absl::StatusOr<std::unique_ptr<SyclStream>> Create(\n+      StreamExecutor* executor, bool enable_multiple_streams,\n+      std::optional<std::variant<StreamPriority, int>> priority);\n+\n+  // Destructor: waits for all pending operations on the stream to complete,\n+  // deallocates the stream from the executor, and destroys the underlying SYCL\n+  // stream.\n+  ~SyclStream() override;\n+\n+  ::sycl::queue* stream_handle() const { return stream_handle_.get(); }\n+\n+ private:\n+  SyclStream(StreamExecutor* executor, SyclEvent completed_event,\n+             std::optional<std::variant<StreamPriority, int>> priority,\n+             StreamPtr stream_handle)\n+      : StreamCommon(executor, priority),\n+        executor_(executor),\n+        completed_event_(std::move(completed_event)),\n+        stream_handle_(std::move(stream_handle)) {}\n+\n+  // Updates 'completed_event_' to the most recent event available on the\n+  // current stream. This allows other streams or events to synchronize with\n+  // this point.\n+  // NOTE: This does *not* record a new event; it only copies the most recent\n+  // event. Actual event recording will be implemented in the future.\n+  absl::Status RecordCompletedEvent();\n+\n+  // Launches a SYCL kernel on the current stream with the specified thread,\n+  // block, and optional cluster dimensions, kernel function, name, arguments,\n+  // and shared memory size.\n+  absl::Status LaunchKernel(const ThreadDim& thread_dims,\n+                            const BlockDim& block_dims,\n+                            const std::optional<ClusterDim>& cluster_dims,\n+                            void* function, absl::string_view name, void** args,\n+                            int64_t shmem_bytes) override;\n+\n+  // The Executor to which this stream is bound.\n+  StreamExecutor* executor_;\n+\n+  // The most recent event recorded on this stream, representing the completion\n+  // of all operations enqueued up to that point.\n+  SyclEvent completed_event_;\n+\n+  // The underlying SYCL stream (queue).\n+  StreamPtr stream_handle_;\n+};\n+\n+}  // namespace stream_executor::sycl\n+#endif  // XLA_STREAM_EXECUTOR_SYCL_SYCL_STREAM_H_"
        },
        {
            "sha": "44f004d47c41e7d15662307aa274d4d2509475f3",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_stream_test.cc",
            "status": "added",
            "additions": 359,
            "deletions": 0,
            "changes": 359,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_stream_test.cc?ref=983811d524d698cea33ec892eef4d0df5fb56196",
            "patch": "@@ -0,0 +1,359 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/sycl/sycl_stream.h\"\n+\n+#include <algorithm>\n+#include <array>\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/backends/gpu/runtime/kernel_thunk.h\"\n+#include \"xla/service/gpu/gpu_executable.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/platform_manager.h\"\n+#include \"xla/stream_executor/sycl/sycl_event.h\"\n+#include \"xla/stream_executor/sycl/sycl_platform_id.h\"\n+#include \"xla/stream_executor/typed_kernel_factory.h\"\n+#include \"xla/tests/llvm_irgen_test_base.h\"\n+#include \"xla/tsl/platform/status_matchers.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace stream_executor::sycl {\n+namespace {\n+\n+constexpr int kDefaultDeviceOrdinal = 0;\n+\n+using ::testing::Each;\n+using ::testing::ElementsAre;\n+using ::testing::ElementsAreArray;\n+using ::testing::HasSubstr;\n+using ::testing::UnorderedElementsAreArray;\n+\n+class SyclStreamTest : public xla::LlvmIrGenTestBase {\n+ public:\n+  // TODO(intel-tf): Use SyclExecutor once it is implemented.\n+  StreamExecutor* executor_;\n+\n+ private:\n+  void SetUp() override {\n+    TF_ASSERT_OK_AND_ASSIGN(\n+        Platform * platform,\n+        stream_executor::PlatformManager::PlatformWithId(kSyclPlatformId));\n+    TF_ASSERT_OK_AND_ASSIGN(executor_,\n+                            platform->ExecutorForDevice(kDefaultDeviceOrdinal));\n+  }\n+};\n+\n+TEST_F(SyclStreamTest, CreateWithNonDefaultPriority) {\n+  // SYCL doesn't support stream priorities yet, so we expect creation to fail\n+  // if a non-default priority is requested.\n+  EXPECT_THAT(SyclStream::Create(executor_,\n+                                 /*enable_multiple_streams=*/false,\n+                                 /*priority=*/StreamPriority::Highest),\n+              absl_testing::StatusIs(absl::StatusCode::kUnimplemented));\n+}\n+\n+TEST_F(SyclStreamTest, Memset32) {\n+  constexpr int kBufferNumElements = 42;\n+  DeviceMemory<uint32_t> device_buffer =\n+      executor_->AllocateArray<uint32_t>(kBufferNumElements, 0);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  constexpr uint64_t kBufferSizeBytes = kBufferNumElements * sizeof(uint32_t);\n+\n+  // Should fail due to the invalid size parameter.\n+  EXPECT_THAT(\n+      stream->Memset32(&device_buffer, 0xDEADBEEF, kBufferSizeBytes + 1),\n+      absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  // Should fail due to the non-4-byte-aligned pointer.\n+  DeviceMemoryBase unaligned_device_memory =\n+      device_buffer.GetByteSlice(/*offset_bytes=*/1, /*size_bytes=*/0);\n+  EXPECT_THAT(stream->Memset32(&unaligned_device_memory, 0xDEADBEEF,\n+                               kBufferSizeBytes + 1),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  // Correct call. Should succeed.\n+  EXPECT_THAT(stream->Memset32(&device_buffer, 0xDEADBEEF, kBufferSizeBytes),\n+              absl_testing::IsOk());\n+\n+  std::array<uint32_t, kBufferNumElements> host_buffer;\n+  EXPECT_THAT(\n+      stream->Memcpy(host_buffer.data(), device_buffer, kBufferSizeBytes),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+  EXPECT_THAT(host_buffer, Each(0xDEADBEEF));\n+}\n+\n+TEST_F(SyclStreamTest, MemZero) {\n+  constexpr int kBufferNumElements = 42;\n+  DeviceMemory<uint32_t> device_buffer =\n+      executor_->AllocateArray<uint32_t>(kBufferNumElements, 0);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  constexpr uint64_t kBufferSizeBytes = kBufferNumElements * sizeof(uint32_t);\n+\n+  EXPECT_THAT(stream->Memset32(&device_buffer, 0xDEADBEEF, kBufferSizeBytes),\n+              absl_testing::IsOk());\n+\n+  // We overwrite half the device_buffer with zeros.\n+  EXPECT_THAT(stream->MemZero(&device_buffer,\n+                              kBufferNumElements / 2 * sizeof(uint32_t)),\n+              absl_testing::IsOk());\n+\n+  std::array<uint32_t, kBufferNumElements> host_buffer;\n+  EXPECT_THAT(\n+      stream->Memcpy(host_buffer.data(), device_buffer, kBufferSizeBytes),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+  // We expect the first half of the host_buffer to be zeros.\n+  EXPECT_THAT(\n+      absl::MakeConstSpan(host_buffer).subspan(0, kBufferNumElements / 2),\n+      Each(0x0));\n+\n+  // And it shouldn't have touched the second half.\n+  EXPECT_THAT(absl::MakeConstSpan(host_buffer).subspan(kBufferNumElements / 2),\n+              Each(0xDEADBEEF));\n+}\n+\n+TEST_F(SyclStreamTest, MemcpyHostToDeviceAndBack) {\n+  constexpr int kBufferNumElements = 42;\n+  DeviceMemory<uint32_t> device_buffer =\n+      executor_->AllocateArray<uint32_t>(kBufferNumElements, 0);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  constexpr uint64_t kBufferSizeBytes = kBufferNumElements * sizeof(uint32_t);\n+\n+  std::array<uint32_t, kBufferNumElements> src_buffer;\n+  std::generate(src_buffer.begin(), src_buffer.end(),\n+                [i = 0]() mutable { return i++; });\n+\n+  EXPECT_THAT(\n+      stream->Memcpy(&device_buffer, src_buffer.data(), kBufferSizeBytes),\n+      absl_testing::IsOk());\n+\n+  std::array<uint32_t, kBufferNumElements> host_buffer;\n+  EXPECT_THAT(\n+      stream->Memcpy(host_buffer.data(), device_buffer, kBufferSizeBytes),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+  EXPECT_THAT(host_buffer, ElementsAreArray(src_buffer));\n+}\n+\n+TEST_F(SyclStreamTest, MemcpyDeviceToDevice) {\n+  constexpr int kBufferNumElements = 42;\n+  DeviceMemory<uint32_t> device_buffer1 =\n+      executor_->AllocateArray<uint32_t>(kBufferNumElements, 0);\n+  DeviceMemory<uint32_t> device_buffer2 =\n+      executor_->AllocateArray<uint32_t>(kBufferNumElements, 0);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  constexpr uint64_t kBufferSizeBytes = kBufferNumElements * sizeof(uint32_t);\n+\n+  EXPECT_THAT(stream->Memset32(&device_buffer1, 0xDEADBEEF, kBufferSizeBytes),\n+              absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->Memcpy(&device_buffer2, device_buffer1, kBufferSizeBytes),\n+              absl_testing::IsOk());\n+\n+  std::array<uint32_t, kBufferNumElements> host_buffer;\n+  EXPECT_THAT(\n+      stream->Memcpy(host_buffer.data(), device_buffer2, kBufferSizeBytes),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+  EXPECT_THAT(host_buffer, Each(0xDEADBEEF));\n+}\n+\n+TEST_F(SyclStreamTest, DoHostCallbackAndBlockHostUntilDone) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  bool callback_called = false;\n+  EXPECT_THAT(\n+      stream->DoHostCallback([&callback_called]() { callback_called = true; }),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+  EXPECT_TRUE(callback_called);\n+}\n+\n+TEST_F(SyclStreamTest, LaunchKernel) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  using AddKernel =\n+      TypedKernelFactory<DeviceMemory<int32_t>, DeviceMemory<int32_t>,\n+                         DeviceMemory<int32_t>>;\n+\n+  absl::string_view hlo_ir = R\"(\n+    ENTRY e {\n+      p0 = u32[4] parameter(0)\n+      p1 = u32[4] parameter(1)\n+      ROOT res = u32[4] add(p0, p1)\n+    })\";\n+\n+  xla::HloModuleConfig config;\n+  config.set_debug_options(GetDebugOptionsForTest());\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> hlo_module,\n+                          xla::ParseAndReturnUnverifiedModule(hlo_ir, config));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<xla::Executable> exec,\n+      CompileToExecutable(std::move(hlo_module),\n+                          /*run_optimization_passes=*/true));\n+\n+  auto* gpu_exec = static_cast<xla::gpu::GpuExecutable*>(exec.get());\n+  ASSERT_NE(gpu_exec, nullptr);\n+\n+  const xla::gpu::SequentialThunk& seq_thunk = gpu_exec->GetThunk();\n+  EXPECT_EQ(seq_thunk.thunks().size(), 1);\n+\n+  const xla::gpu::Thunk* thunk = seq_thunk.thunks().at(0).get();\n+  ASSERT_NE(thunk, nullptr);\n+  EXPECT_EQ(thunk->kind(), xla::gpu::Thunk::Kind::kKernel);\n+\n+  const auto* kernel_thunk = dynamic_cast<const xla::gpu::KernelThunk*>(thunk);\n+  ASSERT_NE(kernel_thunk, nullptr);\n+\n+  std::string kernel_name = kernel_thunk->kernel_name();\n+\n+  std::vector<uint8_t> spirv_binary(gpu_exec->binary());\n+\n+  KernelLoaderSpec spec = KernelLoaderSpec::CreateCudaCubinInMemorySpec(\n+      spirv_binary, kernel_name, 3);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto add, AddKernel::Create(executor_, spec));\n+\n+  constexpr int64_t kLength = 4;\n+  constexpr int64_t kByteLength = sizeof(int32_t) * kLength;\n+\n+  // Prepare arguments: a=3, b=2, c=0\n+  DeviceMemory<int32_t> a = executor_->AllocateArray<int32_t>(kLength, 0);\n+  DeviceMemory<int32_t> b = executor_->AllocateArray<int32_t>(kLength, 0);\n+  DeviceMemory<int32_t> c = executor_->AllocateArray<int32_t>(kLength, 0);\n+\n+  EXPECT_THAT(stream->Memset32(&a, 3, kByteLength), absl_testing::IsOk());\n+  EXPECT_THAT(stream->Memset32(&b, 2, kByteLength), absl_testing::IsOk());\n+  EXPECT_THAT(stream->MemZero(&c, kByteLength), absl_testing::IsOk());\n+  EXPECT_THAT(add.Launch(ThreadDim(kLength), BlockDim(), stream.get(), a, b, c),\n+              absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+\n+  std::array<int32_t, kLength> host_buffer;\n+  EXPECT_THAT(stream->Memcpy(host_buffer.data(), c, kByteLength),\n+              absl_testing::IsOk());\n+  EXPECT_THAT(host_buffer, Each(5));\n+}\n+\n+TEST_F(SyclStreamTest, SetName) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  constexpr absl::string_view kStreamName = \"Test stream\";\n+  stream->SetName(std::string(kStreamName));\n+  EXPECT_EQ(stream->GetName(), kStreamName);\n+}\n+\n+TEST_F(SyclStreamTest, WaitForEvent) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/false,\n+                                             /*priority=*/std::nullopt));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(SyclEvent event, SyclEvent::Create(executor_));\n+\n+  EXPECT_THAT(stream->WaitFor(&event), absl_testing::IsOk());\n+\n+  bool callback_called = false;\n+  EXPECT_THAT(\n+      stream->DoHostCallback([&callback_called]() { callback_called = true; }),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream->RecordEvent(&event), absl_testing::IsOk());\n+  EXPECT_THAT(stream->BlockHostUntilDone(), absl_testing::IsOk());\n+  EXPECT_TRUE(callback_called);\n+}\n+\n+// SYCL does not guarantee any specific ordering of host callbacks\n+// across different streams, even when using event or stream waits.\n+// Therefore, the WaitForOtherStream test (which tests WaitFor(Stream* other))\n+// is omitted for SYCL.\n+\n+TEST_F(SyclStreamTest, MultipleStreams) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream1,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/true,\n+                                             /*priority=*/std::nullopt));\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<SyclStream> stream2,\n+                          SyclStream::Create(executor_,\n+                                             /*enable_multiple_streams=*/true,\n+                                             /*priority=*/std::nullopt));\n+\n+  std::vector<int> host_buffer;\n+  EXPECT_THAT(\n+      stream1->DoHostCallback([&host_buffer]() { host_buffer.push_back(1); }),\n+      absl_testing::IsOk());\n+  EXPECT_THAT(\n+      stream2->DoHostCallback([&host_buffer]() { host_buffer.push_back(2); }),\n+      absl_testing::IsOk());\n+\n+  EXPECT_THAT(stream1->BlockHostUntilDone(), absl_testing::IsOk());\n+  EXPECT_THAT(stream2->BlockHostUntilDone(), absl_testing::IsOk());\n+\n+  std::vector<int> expected = {1, 2};\n+\n+  // Callbacks may run concurrently or in any order since the streams are\n+  // independent.\n+  EXPECT_THAT(host_buffer, UnorderedElementsAreArray(expected));\n+}\n+\n+}  // namespace\n+}  // namespace stream_executor::sycl"
        },
        {
            "sha": "59825f8d3a785e9ca51a0663847028df05829473",
            "filename": "third_party/xla/xla/stream_executor/sycl/sycl_timer_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/983811d524d698cea33ec892eef4d0df5fb56196/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fsycl%2Fsycl_timer_test.cc?ref=983811d524d698cea33ec892eef4d0df5fb56196",
            "patch": "@@ -203,7 +203,7 @@ class SyclTimerTest : public ::testing::Test {\n     ASSERT_THAT(stream->Memset32(&a, 1.0, kByteLength), IsOk());\n     ASSERT_THAT(stream->Memset32(&b, 2.0, kByteLength), IsOk());\n     ASSERT_THAT(stream->Memset32(&c, 0.0, kByteLength), IsOk());\n-    ASSERT_THAT(add.Launch(ThreadDim(), BlockDim(kLength), stream, a, b, c),\n+    ASSERT_THAT(add.Launch(ThreadDim(kLength), BlockDim(), stream, a, b, c),\n                 IsOk());\n   }\n "
        }
    ],
    "stats": {
        "total": 871,
        "additions": 870,
        "deletions": 1
    }
}