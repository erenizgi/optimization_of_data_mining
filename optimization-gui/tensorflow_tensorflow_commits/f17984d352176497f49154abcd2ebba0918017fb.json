{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 846214738",
    "sha": "f17984d352176497f49154abcd2ebba0918017fb",
    "files": [
        {
            "sha": "a3a5c5a72c2f0186ea03db456ca4c9c3a9f18697",
            "filename": "tensorflow/core/util/proto/decode.h",
            "status": "modified",
            "additions": 112,
            "deletions": 106,
            "changes": 218,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdecode.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdecode.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fdecode.h?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -42,7 +42,7 @@ using tensorflow::protobuf::io::StringOutputStream;\n // Converts an uint64 to an int64 without loss of information.\n // Unsigned values greater than INT64_MAX are represented as\n // negative numbers by wrapping (same as twos-complement bit equivalence).\n-inline int64_t WrapUnsignedAsSigned64(uint64 unsigned_value) {\n+inline int64_t WrapUnsignedAsSigned64(uint64_t unsigned_value) {\n   // For a detailed explanation of why this works to wrap unsigned ints, see\n   // http://stackoverflow.com/questions/13150449/efficient-unsigned-to-signed-cast-avoiding-implementation-defined-behavior\n   // Both if tests should be optimized out.\n@@ -59,16 +59,16 @@ inline int64_t WrapUnsignedAsSigned64(uint64 unsigned_value) {\n // Converts an uint32 to an int32 without loss of information.\n // Unsigned values greater than INT_MAX are represented as\n // negative numbers by wrapping (same as twos-complement bit equivalence).\n-inline int32 WrapUnsignedAsSigned32(uint32 unsigned_value) {\n+inline int32_t WrapUnsignedAsSigned32(uint32_t unsigned_value) {\n   // For a detailed explanation of why this works to wrap unsigned ints, see\n   // http://stackoverflow.com/questions/13150449/efficient-unsigned-to-signed-cast-avoiding-implementation-defined-behavior\n   // Both if tests should be optimized out.\n   if (unsigned_value <= INT_MAX) {\n-    return static_cast<int32>(unsigned_value);\n+    return static_cast<int32_t>(unsigned_value);\n   }\n   // The C++ spec allows an architecture where this test is required.\n   if (unsigned_value >= INT_MIN) {\n-    return static_cast<int32>(unsigned_value - INT_MIN) + INT_MIN;\n+    return static_cast<int32_t>(unsigned_value - INT_MIN) + INT_MIN;\n   }\n   return 0;  // This should never occur.\n }\n@@ -78,8 +78,8 @@ inline int32 WrapUnsignedAsSigned32(uint32 unsigned_value) {\n // space in the buffer.\n // The ok value will be set to false if the buffer does not contain\n // a valid varint.\n-inline const uint8* ReadVarint64FromArray(const uint8* buffer, bool* ok,\n-                                          uint64* value);\n+inline const uint8_t* ReadVarint64FromArray(const uint8_t* buffer, bool* ok,\n+                                            uint64_t* value);\n \n // Reads a single varint32 from a byte array.\n // It is the caller's responsibility to ensure that there is enough\n@@ -89,10 +89,10 @@ inline const uint8* ReadVarint64FromArray(const uint8* buffer, bool* ok,\n // This is slightly less efficient than the private version in\n // coded_stream.cc but we duplicate less code by calling\n // the 64 bit version instead of copying the code.\n-inline const uint8* ReadVarint32FromArray(const uint8* buffer, bool* ok,\n-                                          uint32* value) {\n-  uint64 tmp = 0;\n-  const uint8* buf = ReadVarint64FromArray(buffer, ok, &tmp);\n+inline const uint8_t* ReadVarint32FromArray(const uint8_t* buffer, bool* ok,\n+                                            uint32_t* value) {\n+  uint64_t tmp = 0;\n+  const uint8_t* buf = ReadVarint64FromArray(buffer, ok, &tmp);\n   *value = tmp & 0xffffffff;\n   return buf;\n }\n@@ -101,117 +101,117 @@ inline const uint8* ReadVarint32FromArray(const uint8* buffer, bool* ok,\n // The array is part of a Tensor that was allocated by the caller\n // with type TensorType, while DeclaredType is the proto field type.\n template <class TensorType, enum WireFormatLite::FieldType DeclaredType>\n-const uint8* ReadFromArray(const uint8* buf, TensorType* value);\n+const uint8_t* ReadFromArray(const uint8_t* buf, TensorType* value);\n \n template <>\n-inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_INT32>(\n-    const uint8* buf, int64_t* value) {\n-  uint32 temp = 0;\n+inline const uint8_t* ReadFromArray<int64_t, WireFormatLite::TYPE_INT32>(\n+    const uint8_t* buf, int64_t* value) {\n+  uint32_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint32FromArray(buf, &unused_ok, &temp);\n   *value = static_cast<int64_t>(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<int32, WireFormatLite::TYPE_INT32>(\n-    const uint8* buf, int32* value) {\n-  uint32 temp = 0;\n+inline const uint8_t* ReadFromArray<int32_t, WireFormatLite::TYPE_INT32>(\n+    const uint8_t* buf, int32_t* value) {\n+  uint32_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint32FromArray(buf, &unused_ok, &temp);\n-  *value = static_cast<int32>(temp);\n+  *value = static_cast<int32_t>(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_INT64>(\n-    const uint8* buf, int64_t* value) {\n-  uint64 temp = 0;\n+inline const uint8_t* ReadFromArray<int64_t, WireFormatLite::TYPE_INT64>(\n+    const uint8_t* buf, int64_t* value) {\n+  uint64_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint64FromArray(buf, &unused_ok, &temp);\n   *value = WrapUnsignedAsSigned64(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<uint64, WireFormatLite::TYPE_UINT32>(\n-    const uint8* buf, uint64* value) {\n-  uint32 temp = 0;\n+inline const uint8_t* ReadFromArray<uint64_t, WireFormatLite::TYPE_UINT32>(\n+    const uint8_t* buf, uint64_t* value) {\n+  uint32_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint32FromArray(buf, &unused_ok, &temp);\n   *value = temp;\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<uint32, WireFormatLite::TYPE_UINT32>(\n-    const uint8* buf, uint32* value) {\n+inline const uint8_t* ReadFromArray<uint32_t, WireFormatLite::TYPE_UINT32>(\n+    const uint8_t* buf, uint32_t* value) {\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   return ReadVarint32FromArray(buf, &unused_ok, value);\n }\n \n template <>\n-inline const uint8* ReadFromArray<uint64, WireFormatLite::TYPE_UINT64>(\n-    const uint8* buf, uint64* value) {\n+inline const uint8_t* ReadFromArray<uint64_t, WireFormatLite::TYPE_UINT64>(\n+    const uint8_t* buf, uint64_t* value) {\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   return ReadVarint64FromArray(buf, &unused_ok, value);\n }\n \n template <>\n-inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_SINT32>(\n-    const uint8* buf, int64_t* value) {\n-  uint64 temp = 0;\n+inline const uint8_t* ReadFromArray<int64_t, WireFormatLite::TYPE_SINT32>(\n+    const uint8_t* buf, int64_t* value) {\n+  uint64_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint64FromArray(buf, &unused_ok, &temp);\n   *value = WireFormatLite::ZigZagDecode32(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<int32, WireFormatLite::TYPE_SINT32>(\n-    const uint8* buf, int32* value) {\n-  uint32 temp = 0;\n+inline const uint8_t* ReadFromArray<int32_t, WireFormatLite::TYPE_SINT32>(\n+    const uint8_t* buf, int32_t* value) {\n+  uint32_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint32FromArray(buf, &unused_ok, &temp);\n   *value = WireFormatLite::ZigZagDecode32(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_SINT64>(\n-    const uint8* buf, int64_t* value) {\n-  uint64 temp = 0;\n+inline const uint8_t* ReadFromArray<int64_t, WireFormatLite::TYPE_SINT64>(\n+    const uint8_t* buf, int64_t* value) {\n+  uint64_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint64FromArray(buf, &unused_ok, &temp);\n   *value = WireFormatLite::ZigZagDecode64(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<uint64, WireFormatLite::TYPE_FIXED32>(\n-    const uint8* buf, uint64* value) {\n-  uint32 temp;\n-  buf = WireFormatLite::ReadPrimitiveFromArray<uint32,\n+inline const uint8_t* ReadFromArray<uint64_t, WireFormatLite::TYPE_FIXED32>(\n+    const uint8_t* buf, uint64_t* value) {\n+  uint32_t temp;\n+  buf = WireFormatLite::ReadPrimitiveFromArray<uint32_t,\n                                                WireFormatLite::TYPE_FIXED32>(\n       buf, &temp);\n   *value = temp;\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<uint32, WireFormatLite::TYPE_FIXED32>(\n-    const uint8* buf, uint32* value) {\n-  uint32 temp;\n-  buf = WireFormatLite::ReadPrimitiveFromArray<uint32,\n+inline const uint8_t* ReadFromArray<uint32_t, WireFormatLite::TYPE_FIXED32>(\n+    const uint8_t* buf, uint32_t* value) {\n+  uint32_t temp;\n+  buf = WireFormatLite::ReadPrimitiveFromArray<uint32_t,\n                                                WireFormatLite::TYPE_FIXED32>(\n       buf, &temp);\n   *value = WrapUnsignedAsSigned32(temp);\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<uint64, WireFormatLite::TYPE_FIXED64>(\n-    const uint8* buf, uint64* value) {\n+inline const uint8_t* ReadFromArray<uint64_t, WireFormatLite::TYPE_FIXED64>(\n+    const uint8_t* buf, uint64_t* value) {\n   protobuf_uint64 temp;\n   buf = WireFormatLite::ReadPrimitiveFromArray<protobuf_uint64,\n                                                WireFormatLite::TYPE_FIXED64>(\n@@ -221,27 +221,27 @@ inline const uint8* ReadFromArray<uint64, WireFormatLite::TYPE_FIXED64>(\n }\n \n template <>\n-inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_SFIXED32>(\n-    const uint8* buf, int64_t* value) {\n+inline const uint8_t* ReadFromArray<int64_t, WireFormatLite::TYPE_SFIXED32>(\n+    const uint8_t* buf, int64_t* value) {\n   int32_t temp;\n-  buf = WireFormatLite::ReadPrimitiveFromArray<int32,\n+  buf = WireFormatLite::ReadPrimitiveFromArray<int32_t,\n                                                WireFormatLite::TYPE_SFIXED32>(\n       buf, &temp);\n   *value = temp;\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<int32, WireFormatLite::TYPE_SFIXED32>(\n-    const uint8* buf, int32* value) {\n-  return WireFormatLite::ReadPrimitiveFromArray<int32,\n+inline const uint8_t* ReadFromArray<int32_t, WireFormatLite::TYPE_SFIXED32>(\n+    const uint8_t* buf, int32_t* value) {\n+  return WireFormatLite::ReadPrimitiveFromArray<int32_t,\n                                                 WireFormatLite::TYPE_SFIXED32>(\n       buf, value);\n }\n \n template <>\n-inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_SFIXED64>(\n-    const uint8* buf, int64_t* value) {\n+inline const uint8_t* ReadFromArray<int64_t, WireFormatLite::TYPE_SFIXED64>(\n+    const uint8_t* buf, int64_t* value) {\n   protobuf_int64 temp;\n   buf = WireFormatLite::ReadPrimitiveFromArray<protobuf_int64,\n                                                WireFormatLite::TYPE_SFIXED64>(\n@@ -251,16 +251,16 @@ inline const uint8* ReadFromArray<int64_t, WireFormatLite::TYPE_SFIXED64>(\n }\n \n template <>\n-inline const uint8* ReadFromArray<float, WireFormatLite::TYPE_FLOAT>(\n-    const uint8* buf, float* value) {\n+inline const uint8_t* ReadFromArray<float, WireFormatLite::TYPE_FLOAT>(\n+    const uint8_t* buf, float* value) {\n   return WireFormatLite::ReadPrimitiveFromArray<float,\n                                                 WireFormatLite::TYPE_FLOAT>(\n       buf, value);\n }\n \n template <>\n-inline const uint8* ReadFromArray<double, WireFormatLite::TYPE_FLOAT>(\n-    const uint8* buf, double* value) {\n+inline const uint8_t* ReadFromArray<double, WireFormatLite::TYPE_FLOAT>(\n+    const uint8_t* buf, double* value) {\n   float temp;\n   buf =\n       WireFormatLite::ReadPrimitiveFromArray<float, WireFormatLite::TYPE_FLOAT>(\n@@ -270,27 +270,27 @@ inline const uint8* ReadFromArray<double, WireFormatLite::TYPE_FLOAT>(\n }\n \n template <>\n-inline const uint8* ReadFromArray<double, WireFormatLite::TYPE_DOUBLE>(\n-    const uint8* buf, double* value) {\n+inline const uint8_t* ReadFromArray<double, WireFormatLite::TYPE_DOUBLE>(\n+    const uint8_t* buf, double* value) {\n   return WireFormatLite::ReadPrimitiveFromArray<double,\n                                                 WireFormatLite::TYPE_DOUBLE>(\n       buf, value);\n }\n \n template <>\n-inline const uint8* ReadFromArray<bool, WireFormatLite::TYPE_BOOL>(\n-    const uint8* buf, bool* value) {\n-  uint64 temp = 0;\n+inline const uint8_t* ReadFromArray<bool, WireFormatLite::TYPE_BOOL>(\n+    const uint8_t* buf, bool* value) {\n+  uint64_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint64FromArray(buf, &unused_ok, &temp);\n   *value = temp != 0;\n   return buf;\n }\n \n template <>\n-inline const uint8* ReadFromArray<int, WireFormatLite::TYPE_ENUM>(\n-    const uint8* buf, int* value) {\n-  uint32 temp = 0;\n+inline const uint8_t* ReadFromArray<int, WireFormatLite::TYPE_ENUM>(\n+    const uint8_t* buf, int* value) {\n+  uint32_t temp = 0;\n   bool unused_ok;  // The Counting pass would have failed if this were corrupt.\n   buf = ReadVarint32FromArray(buf, &unused_ok, &temp);\n   *value = static_cast<int>(temp);\n@@ -304,8 +304,8 @@ template <class TensorType, enum WireFormatLite::FieldType DeclaredType>\n inline int ReadPackedPrimitives(const void* bufp, const size_t len,\n                                 const int index, const int stride,\n                                 void* datap) {\n-  const uint8* buf = reinterpret_cast<const uint8*>(bufp);\n-  const uint8* bound = buf + len;\n+  const uint8_t* buf = reinterpret_cast<const uint8_t*>(bufp);\n+  const uint8_t* bound = buf + len;\n   TensorType* data = reinterpret_cast<TensorType*>(datap) + index;\n   int count;\n \n@@ -340,7 +340,7 @@ inline absl::Status ReadPrimitive(CodedInputStream* input, int index,\n inline absl::Status ReadBytes(CodedInputStream* input, int index, void* datap) {\n   tstring* data = reinterpret_cast<tstring*>(datap) + index;\n \n-  uint32 length;\n+  uint32_t length;\n   if (!input->ReadVarint32(&length)) {\n     return errors::DataLoss(\"Failed reading bytes\");\n   }\n@@ -370,7 +370,7 @@ inline absl::Status ReadGroupBytes(CodedInputStream* input, int field_number,\n   // TYPE_GROUP is deprecated and currently no tests in\n   // tensorflow/python/kernel_tests/proto:decode_proto_op_test target a\n   // TYPE_GROUP tag, we use std::string as a read buffer.\n-  string buf;\n+  std::string buf;\n   StringOutputStream string_stream(&buf);\n   {\n     CodedOutputStream out(&string_stream);\n@@ -412,31 +412,33 @@ inline absl::Status ReadValue(CodedInputStream* input,\n       return ReadPrimitive<protobuf_int64, int64_t, WireFormatLite::TYPE_INT64>(\n           input, index, datap);\n     case WireFormatLite::TYPE_UINT64:\n-      return ReadPrimitive<protobuf_uint64, uint64,\n+      return ReadPrimitive<protobuf_uint64, uint64_t,\n                            WireFormatLite::TYPE_UINT64>(input, index, datap);\n     case WireFormatLite::TYPE_INT32:\n       switch (dtype) {\n         case DataType::DT_INT64:\n-          return ReadPrimitive<int32, int64_t, WireFormatLite::TYPE_INT32>(\n+          return ReadPrimitive<int32_t, int64_t, WireFormatLite::TYPE_INT32>(\n               input, index, datap);\n         case DataType::DT_INT32:\n-          return ReadPrimitive<int32, int32, WireFormatLite::TYPE_INT32>(\n+          return ReadPrimitive<int32_t, int32_t, WireFormatLite::TYPE_INT32>(\n               input, index, datap);\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_INT32 for \",\n                                   DataTypeString(dtype));\n       }\n     case WireFormatLite::TYPE_FIXED64:\n-      return ReadPrimitive<protobuf_uint64, uint64,\n+      return ReadPrimitive<protobuf_uint64, uint64_t,\n                            WireFormatLite::TYPE_FIXED64>(input, index, datap);\n     case WireFormatLite::TYPE_FIXED32:\n       switch (dtype) {\n         case DataType::DT_UINT64:\n-          return ReadPrimitive<uint32, uint64, WireFormatLite::TYPE_FIXED32>(\n-              input, index, datap);\n+          return ReadPrimitive<uint32_t, uint64_t,\n+                               WireFormatLite::TYPE_FIXED32>(input, index,\n+                                                             datap);\n         case DataType::DT_UINT32:\n-          return ReadPrimitive<uint32, uint32, WireFormatLite::TYPE_FIXED32>(\n-              input, index, datap);\n+          return ReadPrimitive<uint32_t, uint32_t,\n+                               WireFormatLite::TYPE_FIXED32>(input, index,\n+                                                             datap);\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_FIXED32 for \",\n                                   DataTypeString(dtype));\n@@ -455,25 +457,25 @@ inline absl::Status ReadValue(CodedInputStream* input,\n     case WireFormatLite::TYPE_UINT32:\n       switch (dtype) {\n         case DataType::DT_UINT64:\n-          return ReadPrimitive<uint32, uint64, WireFormatLite::TYPE_UINT32>(\n+          return ReadPrimitive<uint32_t, uint64_t, WireFormatLite::TYPE_UINT32>(\n               input, index, datap);\n         case DataType::DT_UINT32:\n-          return ReadPrimitive<uint32, uint32, WireFormatLite::TYPE_UINT32>(\n+          return ReadPrimitive<uint32_t, uint32_t, WireFormatLite::TYPE_UINT32>(\n               input, index, datap);\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_UINT32 for \",\n                                   DataTypeString(dtype));\n       }\n     case WireFormatLite::TYPE_ENUM:\n-      return ReadPrimitive<int32, int32, WireFormatLite::TYPE_ENUM>(\n+      return ReadPrimitive<int32_t, int32_t, WireFormatLite::TYPE_ENUM>(\n           input, index, datap);\n     case WireFormatLite::TYPE_SFIXED32:\n       switch (dtype) {\n         case DataType::DT_INT64:\n-          return ReadPrimitive<int32, int64_t, WireFormatLite::TYPE_SFIXED32>(\n+          return ReadPrimitive<int32_t, int64_t, WireFormatLite::TYPE_SFIXED32>(\n               input, index, datap);\n         case DataType::DT_INT32:\n-          return ReadPrimitive<int32, int32, WireFormatLite::TYPE_SFIXED32>(\n+          return ReadPrimitive<int32_t, int32_t, WireFormatLite::TYPE_SFIXED32>(\n               input, index, datap);\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_SFIXED32 for \",\n@@ -485,10 +487,10 @@ inline absl::Status ReadValue(CodedInputStream* input,\n     case WireFormatLite::TYPE_SINT32:\n       switch (dtype) {\n         case DataType::DT_INT64:\n-          return ReadPrimitive<int32, int64_t, WireFormatLite::TYPE_SINT32>(\n+          return ReadPrimitive<int32_t, int64_t, WireFormatLite::TYPE_SINT32>(\n               input, index, datap);\n         case DataType::DT_INT32:\n-          return ReadPrimitive<int32, int32, WireFormatLite::TYPE_SINT32>(\n+          return ReadPrimitive<int32_t, int32_t, WireFormatLite::TYPE_SINT32>(\n               input, index, datap);\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_SINT32 for \",\n@@ -533,7 +535,7 @@ inline absl::Status ReadPackedFromArray(\n           buf, buf_size, *index, stride, data);\n       return absl::OkStatus();\n     case WireFormatLite::TYPE_UINT64:\n-      *index += ReadPackedPrimitives<uint64, WireFormatLite::TYPE_UINT64>(\n+      *index += ReadPackedPrimitives<uint64_t, WireFormatLite::TYPE_UINT64>(\n           buf, buf_size, *index, stride, data);\n       return absl::OkStatus();\n     case WireFormatLite::TYPE_INT32:\n@@ -543,26 +545,28 @@ inline absl::Status ReadPackedFromArray(\n               buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         case DataType::DT_INT32:\n-          *index += ReadPackedPrimitives<int32, WireFormatLite::TYPE_INT32>(\n+          *index += ReadPackedPrimitives<int32_t, WireFormatLite::TYPE_INT32>(\n               buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_INT32 for \",\n                                   DataTypeString(dtype));\n       }\n     case WireFormatLite::TYPE_FIXED64:\n-      *index += ReadPackedPrimitives<uint64, WireFormatLite::TYPE_FIXED64>(\n+      *index += ReadPackedPrimitives<uint64_t, WireFormatLite::TYPE_FIXED64>(\n           buf, buf_size, *index, stride, data);\n       return absl::OkStatus();\n     case WireFormatLite::TYPE_FIXED32:\n       switch (dtype) {\n         case DataType::DT_UINT64:\n-          *index += ReadPackedPrimitives<uint64, WireFormatLite::TYPE_FIXED32>(\n-              buf, buf_size, *index, stride, data);\n+          *index +=\n+              ReadPackedPrimitives<uint64_t, WireFormatLite::TYPE_FIXED32>(\n+                  buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         case DataType::DT_UINT32:\n-          *index += ReadPackedPrimitives<uint32, WireFormatLite::TYPE_FIXED32>(\n-              buf, buf_size, *index, stride, data);\n+          *index +=\n+              ReadPackedPrimitives<uint32_t, WireFormatLite::TYPE_FIXED32>(\n+                  buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_FIXED32 for \",\n@@ -580,19 +584,19 @@ inline absl::Status ReadPackedFromArray(\n     case WireFormatLite::TYPE_UINT32:\n       switch (dtype) {\n         case DataType::DT_UINT64:\n-          *index += ReadPackedPrimitives<uint64, WireFormatLite::TYPE_UINT32>(\n+          *index += ReadPackedPrimitives<uint64_t, WireFormatLite::TYPE_UINT32>(\n               buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         case DataType::DT_UINT32:\n-          *index += ReadPackedPrimitives<uint32, WireFormatLite::TYPE_UINT32>(\n+          *index += ReadPackedPrimitives<uint32_t, WireFormatLite::TYPE_UINT32>(\n               buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_UINT32 for \",\n                                   DataTypeString(dtype));\n       }\n     case WireFormatLite::TYPE_ENUM:\n-      *index += ReadPackedPrimitives<int32, WireFormatLite::TYPE_ENUM>(\n+      *index += ReadPackedPrimitives<int32_t, WireFormatLite::TYPE_ENUM>(\n           buf, buf_size, *index, stride, data);\n       return absl::OkStatus();\n     case WireFormatLite::TYPE_SFIXED32:\n@@ -603,8 +607,9 @@ inline absl::Status ReadPackedFromArray(\n                   buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         case DataType::DT_INT32:\n-          *index += ReadPackedPrimitives<int32, WireFormatLite::TYPE_SFIXED32>(\n-              buf, buf_size, *index, stride, data);\n+          *index +=\n+              ReadPackedPrimitives<int32_t, WireFormatLite::TYPE_SFIXED32>(\n+                  buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         default:\n           return errors::DataLoss(\"Failed reading TYPE_INT32 for \",\n@@ -622,7 +627,7 @@ inline absl::Status ReadPackedFromArray(\n               buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         case DataType::DT_INT32:\n-          *index += ReadPackedPrimitives<int32, WireFormatLite::TYPE_SINT32>(\n+          *index += ReadPackedPrimitives<int32_t, WireFormatLite::TYPE_SINT32>(\n               buf, buf_size, *index, stride, data);\n           return absl::OkStatus();\n         default:\n@@ -645,14 +650,14 @@ inline absl::Status ReadPackedFromArray(\n // Important: This routine may read as much as kMaxVarintBytes from\n // the buffer. It is the caller's responsibility to make sure that there is\n // enough space in the buffer.\n-inline const uint8* ReadVarint64FromArray(const uint8* buffer, bool* ok,\n-                                          uint64* value) {\n-  const uint8* ptr = buffer;\n-  uint32 b;\n+inline const uint8_t* ReadVarint64FromArray(const uint8_t* buffer, bool* ok,\n+                                            uint64_t* value) {\n+  const uint8_t* ptr = buffer;\n+  uint32_t b;\n \n   // Splitting into 32-bit pieces gives better performance on 32-bit\n   // processors.\n-  uint32 part0 = 0, part1 = 0, part2 = 0;\n+  uint32_t part0 = 0, part1 = 0, part2 = 0;\n \n   b = *(ptr++);\n   part0 = b;\n@@ -702,8 +707,9 @@ inline const uint8* ReadVarint64FromArray(const uint8* buffer, bool* ok,\n \n done:\n   *ok = true;\n-  *value = (static_cast<uint64>(part0)) | (static_cast<uint64>(part1) << 28) |\n-           (static_cast<uint64>(part2) << 56);\n+  *value = (static_cast<uint64_t>(part0)) |\n+           (static_cast<uint64_t>(part1) << 28) |\n+           (static_cast<uint64_t>(part2) << 56);\n   return ptr;\n }\n "
        },
        {
            "sha": "e8184f6b2fabfc12d86247ca81b77c682877ba90",
            "filename": "tensorflow/core/util/proto/descriptor_pool_registry.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptor_pool_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptor_pool_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptor_pool_registry.cc?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -27,19 +27,19 @@ DescriptorPoolRegistry* DescriptorPoolRegistry::Global() {\n }\n \n DescriptorPoolRegistry::DescriptorPoolFn* DescriptorPoolRegistry::Get(\n-    const string& source) {\n+    const std::string& source) {\n   auto found = fns_.find(source);\n   if (found == fns_.end()) return nullptr;\n   return &found->second;\n }\n \n void DescriptorPoolRegistry::Register(\n-    const string& source,\n+    const std::string& source,\n     const DescriptorPoolRegistry::DescriptorPoolFn& pool_fn) {\n   auto existing = Get(source);\n   CHECK_EQ(existing, nullptr)\n       << \"descriptor pool for source: \" << source << \" already registered\";\n-  fns_.insert(std::pair<const string&, DescriptorPoolFn>(source, pool_fn));\n+  fns_.insert(std::pair<const std::string&, DescriptorPoolFn>(source, pool_fn));\n }\n \n }  // namespace tensorflow"
        },
        {
            "sha": "5718243c15cbab66e5893685c08531de52a76ff0",
            "filename": "tensorflow/core/util/proto/descriptor_pool_registry.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptor_pool_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptor_pool_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptor_pool_registry.h?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -39,21 +39,21 @@ class DescriptorPoolRegistry {\n   static DescriptorPoolRegistry* Global();\n \n   // Returns a pointer to a descriptor pool function for the given source.\n-  DescriptorPoolFn* Get(const string& source);\n+  DescriptorPoolFn* Get(const std::string& source);\n \n   // Registers a descriptor pool factory.\n-  void Register(const string& source, const DescriptorPoolFn& pool_fn);\n+  void Register(const std::string& source, const DescriptorPoolFn& pool_fn);\n \n  private:\n-  std::map<string, DescriptorPoolFn> fns_;\n+  std::map<std::string, DescriptorPoolFn> fns_;\n };\n \n namespace descriptor_pool_registration {\n \n class DescriptorPoolRegistration {\n  public:\n   DescriptorPoolRegistration(\n-      const string& source,\n+      const std::string& source,\n       const DescriptorPoolRegistry::DescriptorPoolFn& pool_fn) {\n     DescriptorPoolRegistry::Global()->Register(source, pool_fn);\n   }"
        },
        {
            "sha": "e485499c94d5f7071308b0a9fa0b16e45124dd6d",
            "filename": "tensorflow/core/util/proto/descriptors.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptors.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptors.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptors.cc?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -45,7 +45,7 @@ absl::Status CreatePoolFromSet(\n // The file must contain a serialized `FileDescriptorSet`. See\n // `GetDescriptorPool()` for more information.\n absl::Status GetDescriptorPoolFromFile(\n-    tensorflow::Env* env, const string& filename,\n+    tensorflow::Env* env, const std::string& filename,\n     std::unique_ptr<protobuf::DescriptorPool>* owned_desc_pool) {\n   absl::Status st = env->FileExists(filename);\n   if (!st.ok()) {\n@@ -66,7 +66,7 @@ absl::Status GetDescriptorPoolFromFile(\n }\n \n absl::Status GetDescriptorPoolFromBinary(\n-    const string& source,\n+    const std::string& source,\n     std::unique_ptr<protobuf::DescriptorPool>* owned_desc_pool) {\n   if (!absl::StartsWith(source, \"bytes://\")) {\n     return errors::InvalidArgument(absl::StrCat(\n@@ -76,7 +76,7 @@ absl::Status GetDescriptorPoolFromBinary(\n   }\n   // Parse the FileDescriptorSet.\n   protobuf::FileDescriptorSet proto;\n-  if (!proto.ParseFromString(string(absl::StripPrefix(source, \"bytes://\")))) {\n+  if (!proto.ParseFromString(absl::StripPrefix(source, \"bytes://\"))) {\n     return errors::InvalidArgument(absl::StrCat(\n         \"Source does not represent serialized file descriptor set proto. \",\n         \"This may be due to a missing dependency on the file containing \",\n@@ -88,7 +88,7 @@ absl::Status GetDescriptorPoolFromBinary(\n }  // namespace\n \n absl::Status GetDescriptorPool(\n-    Env* env, string const& descriptor_source,\n+    Env* env, const std::string& descriptor_source,\n     protobuf::DescriptorPool const** desc_pool,\n     std::unique_ptr<protobuf::DescriptorPool>* owned_desc_pool) {\n   // Attempt to lookup the pool in the registry."
        },
        {
            "sha": "7b6ce3b97b50531f28d54e003cde9efd2292d986",
            "filename": "tensorflow/core/util/proto/descriptors.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptors.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptors.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fdescriptors.h?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -46,7 +46,7 @@ using tsl::Env;\n // Custom schemas can be supported by registering a handler with the\n // `DescriptorPoolRegistry`.\n absl::Status GetDescriptorPool(\n-    Env* env, string const& descriptor_source,\n+    Env* env, const std::string& descriptor_source,\n     protobuf::DescriptorPool const** desc_pool,\n     std::unique_ptr<protobuf::DescriptorPool>* owned_desc_pool);\n "
        },
        {
            "sha": "f0a103eaa2823c3ee6c13ace25a046f08366146c",
            "filename": "tensorflow/core/util/proto/proto_utils.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils.cc?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -79,20 +79,20 @@ absl::Status ParseTextFormatFromString(absl::string_view input,\n     return absl::Status(absl::StatusCode::kInvalidArgument,\n                         \"output must be non NULL\");\n   }\n-  string err;\n+  std::string err;\n   StringErrorCollector err_collector(&err, /*one-indexing=*/true);\n   protobuf::TextFormat::Parser parser;\n   parser.RecordErrorsTo(&err_collector);\n-  if (!parser.ParseFromString(string(input), output)) {\n+  if (!parser.ParseFromString(input, output)) {\n     return absl::Status(absl::StatusCode::kInvalidArgument, err);\n   }\n   return absl::OkStatus();\n }\n \n-StringErrorCollector::StringErrorCollector(string* error_text)\n+StringErrorCollector::StringErrorCollector(std::string* error_text)\n     : StringErrorCollector(error_text, false) {}\n \n-StringErrorCollector::StringErrorCollector(string* error_text,\n+StringErrorCollector::StringErrorCollector(std::string* error_text,\n                                            bool one_indexing)\n     : error_text_(error_text), index_offset_(one_indexing ? 1 : 0) {\n   DCHECK(error_text_ != nullptr) << \"error_text must be non NULL\";"
        },
        {
            "sha": "65c73e35c15f8bb27aad0051d6898375c7406b48",
            "filename": "tensorflow/core/util/proto/proto_utils.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils.h?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -44,11 +44,11 @@ class StringErrorCollector : public protobuf::io::ErrorCollector {\n  public:\n   // String error_text is unowned and must remain valid during the use of\n   // StringErrorCollector.\n-  explicit StringErrorCollector(string* error_text);\n+  explicit StringErrorCollector(std::string* error_text);\n   // If one_indexing is set to true, all line and column numbers will be\n   // increased by one for cases when provided indices are 0-indexed and\n   // 1-indexed error messages are desired\n-  StringErrorCollector(string* error_text, bool one_indexing);\n+  StringErrorCollector(std::string* error_text, bool one_indexing);\n   StringErrorCollector(const StringErrorCollector&) = delete;\n   StringErrorCollector& operator=(const StringErrorCollector&) = delete;\n \n@@ -61,7 +61,7 @@ class StringErrorCollector : public protobuf::io::ErrorCollector {\n                      absl::string_view message) override;\n \n  private:\n-  string* const error_text_;\n+  std::string* const error_text_;\n   const int index_offset_;\n };\n "
        },
        {
            "sha": "460e41ad770c3150c4f352945ef2c4ed1202f75c",
            "filename": "tensorflow/core/util/proto/proto_utils_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f17984d352176497f49154abcd2ebba0918017fb/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fproto%2Fproto_utils_test.cc?ref=f17984d352176497f49154abcd2ebba0918017fb",
            "patch": "@@ -61,37 +61,37 @@ TEST(ParseTextFormatFromStringTest, DiesOnNullOutputPointer) {\n }\n \n TEST(StringErrorCollectorTest, AppendsError) {\n-  string err;\n+  std::string err;\n   StringErrorCollector collector(&err);\n   collector.RecordError(1, 2, \"foo\");\n   EXPECT_EQ(\"1(2): foo\\n\", err);\n }\n \n TEST(StringErrorCollectorTest, AppendsWarning) {\n-  string err;\n+  std::string err;\n   StringErrorCollector collector(&err);\n   collector.RecordWarning(1, 2, \"foo\");\n   EXPECT_EQ(\"1(2): foo\\n\", err);\n }\n \n TEST(StringErrorCollectorTest, AppendsMultipleError) {\n-  string err;\n+  std::string err;\n   StringErrorCollector collector(&err);\n   collector.RecordError(1, 2, \"foo\");\n   collector.RecordError(3, 4, \"bar\");\n   EXPECT_EQ(\"1(2): foo\\n3(4): bar\\n\", err);\n }\n \n TEST(StringErrorCollectorTest, AppendsMultipleWarning) {\n-  string err;\n+  std::string err;\n   StringErrorCollector collector(&err);\n   collector.RecordWarning(1, 2, \"foo\");\n   collector.RecordWarning(3, 4, \"bar\");\n   EXPECT_EQ(\"1(2): foo\\n3(4): bar\\n\", err);\n }\n \n TEST(StringErrorCollectorTest, OffsetWorks) {\n-  string err;\n+  std::string err;\n   StringErrorCollector collector(&err, true);\n   collector.RecordError(1, 2, \"foo\");\n   collector.RecordWarning(3, 4, \"bar\");"
        }
    ],
    "stats": {
        "total": 266,
        "additions": 136,
        "deletions": 130
    }
}