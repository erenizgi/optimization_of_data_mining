{
    "author": "unknown",
    "message": "[XLA:GPU] Add flags for filtering debugged thunks\n\nChecking all buffers is way too heavy and causes timeouts, so we need the ability to focus on interesting parts of the thunk graph.\n\n`--xla_gpu_experimental_thunk_buffer_debug_filter_by_thunk_id_ranges` allows limiting thunk IDs to selected ranges or values. The IDs are assigned in the order of emitting thunks, which should (TM) be stable and allow bisecting to find culprit thunk(s). The IDs are given as comma-separated list of integers, closed or half-open ranges (e.g. `:2,5,7:8,12:` to match <=2, 5, 7, 8 and >=12).\n\n`--xla_gpu_experimental_thunk_buffer_debug_filter_by_profile_annotation_re` allows matching by thunk's profile annotation. This is a comma-separated list of regexes that will be matched against `ThunkInfo::profile_annotation`. The thunk's profile annotation needs to match any of the regexes.\n\nThey are meant to work with all thunk debug buffer instrumentation (currently: checksums, NaNs). If both flags are defined, the thunk will have to pass both the ID and profile annotation filters to get instrumented.\n\nImplementation of the filtering logic is not included in this CL.\n\nPiperOrigin-RevId: 826457166",
    "sha": "718fe5695ea4adbea29420df28fc41be81d3a5d2",
    "files": [
        {
            "sha": "106d7c6839437a53d66f791d8bc670809a97a86d",
            "filename": "third_party/xla/xla/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2FBUILD?ref=718fe5695ea4adbea29420df28fc41be81d3a5d2",
            "patch": "@@ -1212,6 +1212,7 @@ cc_library(\n     name = \"debug_options_flags\",\n     srcs = [\n         \"debug_options_flags.cc\",\n+        \"debug_options_parsers.cc\",\n         \"debug_options_parsers.h\",\n     ],\n     hdrs = [\"debug_options_flags.h\"],\n@@ -1234,6 +1235,7 @@ cc_library(\n             \"@com_google_absl//absl/algorithm:container\",\n             \"@com_google_absl//absl/base\",\n             \"@com_google_absl//absl/base:no_destructor\",\n+            \"@com_google_absl//absl/base:nullability\",\n             \"@com_google_absl//absl/container:flat_hash_map\",\n             \"@com_google_absl//absl/container:flat_hash_set\",\n             \"@com_google_absl//absl/container:node_hash_map\",\n@@ -1277,6 +1279,7 @@ xla_cc_test(\n             \"//xla/tsl/platform:env\",\n             \"//xla/tsl/platform:test\",\n             \"//xla/tsl/util:command_line_flags\",\n+            \"@com_google_absl//absl/base:nullability\",\n             \"@com_google_absl//absl/container:flat_hash_map\",\n             \"@com_google_absl//absl/status\",\n             \"@com_google_absl//absl/status:status_matchers\","
        },
        {
            "sha": "35cf6a5d6dceb5db9e62e5757aa2445b01084bfd",
            "filename": "third_party/xla/xla/debug_options_flags.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 1,
            "changes": 45,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_flags.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_flags.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fdebug_options_flags.cc?ref=718fe5695ea4adbea29420df28fc41be81d3a5d2",
            "patch": "@@ -774,7 +774,9 @@ void MakeDebugOptionsFlags(std::vector<tsl::Flag>* flag_list,\n         DebugOptions::WhileLoopUnrolling unroll_strategy;\n         bool parsed = DebugOptions::WhileLoopUnrolling_Parse(\n             absl::AsciiStrToUpper(input), &unroll_strategy);\n-        if (!parsed) return false;\n+        if (!parsed) {\n+          return false;\n+        }\n         debug_options->set_xla_gpu_enable_while_loop_unrolling(unroll_strategy);\n         return true;\n       };\n@@ -885,6 +887,35 @@ void MakeDebugOptionsFlags(std::vector<tsl::Flag>* flag_list,\n         debug_options->set_xla_detect_unstable_reductions(detection_mode);\n         return true;\n       };\n+\n+  // Custom \"sub-parser\" for\n+  // xla_gpu_experimental_thunk_buffer_debug_filter_by_thunk_id_ranges.\n+  auto setter_for_thunk_buffer_debug_filter_by_thunk_id =\n+      [debug_options](const std::string& value) {\n+        for (const auto& range_str : absl::StrSplit(value, ',')) {\n+          IntRangeInclusive* range =\n+              debug_options\n+                  ->mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+                  ->add_thunk_id_ranges();\n+          if (!details::ParseIntRangeInclusive(range_str, *range)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      };\n+\n+  // Custom \"sub-parser\" for\n+  // xla_gpu_experimental_thunk_buffer_debug_filter_by_profile_annotation_re.\n+  auto setter_for_thunk_buffer_debug_filter_by_profile_annotation =\n+      [debug_options](const std::string& value) {\n+        for (const auto& regex_str : absl::StrSplit(value, ',')) {\n+          debug_options\n+              ->mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+              ->add_profile_annotation_regexes(regex_str);\n+        }\n+        return true;\n+      };\n+\n   // Don't use an initializer list for initializing the vector; this would\n   // create a temporary copy, and exceeds the stack space when compiling with\n   // certain configurations.\n@@ -2623,6 +2654,18 @@ void MakeDebugOptionsFlags(std::vector<tsl::Flag>* flag_list,\n       debug_options->xla_gpu_experimental_enable_checksum_tracing_on_thunks(),\n       \"Enables an experimental feature to record checksums of selected thunk \"\n       \"inputs/outputs.\"));\n+  flag_list->push_back(tsl::Flag(\n+      \"xla_gpu_experimental_thunk_buffer_debug_filter_by_thunk_id_ranges\",\n+      setter_for_thunk_buffer_debug_filter_by_thunk_id, \"(none)\",\n+      \"Limits the thunk buffer debug instrumentation to thunks with IDs \"\n+      \"matching one or more ranges defined as a single integer, min:max \"\n+      \"(inclusive), or half-open min:/:max.\"));\n+  flag_list->push_back(tsl::Flag(\n+      \"xla_gpu_experimental_thunk_buffer_debug_filter_by_profile_annotation_re\",\n+      setter_for_thunk_buffer_debug_filter_by_profile_annotation, \"(none)\",\n+      \"Limits the thunk buffer debug instrumentation to thunks with profile \"\n+      \"annotations matching one or more regexes passed as comma-separated \"\n+      \"string.\"));\n }  // NOLINT(readability/fn_size)\n \n // Allocates flag_values and flag_objects; this function must not be called more"
        },
        {
            "sha": "ef2756b114af4221b8e849d1d34060059a7fbb81",
            "filename": "third_party/xla/xla/debug_options_parsers.cc",
            "status": "added",
            "additions": 71,
            "deletions": 0,
            "changes": 71,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_parsers.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_parsers.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fdebug_options_parsers.cc?ref=718fe5695ea4adbea29420df28fc41be81d3a5d2",
            "patch": "@@ -0,0 +1,71 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/debug_options_parsers.h\"\n+\n+#include <cstdint>\n+#include <limits>\n+#include <vector>\n+\n+#include \"absl/strings/numbers.h\"\n+#include \"absl/strings/str_split.h\"\n+#include \"absl/strings/string_view.h\"\n+\n+namespace xla {\n+namespace details {\n+\n+bool ParseIntRangeInclusive(absl::string_view string_value,\n+                            IntRangeInclusive& range) {\n+  std::vector<absl::string_view> parts = absl::StrSplit(string_value, ':');\n+\n+  if (parts.size() == 1) {\n+    // A single integer x is a valid [x, x] range.\n+    int64_t first;\n+    if (!absl::SimpleAtoi(parts[0], &first)) {\n+      return false;\n+    }\n+    range.set_first(first);\n+    range.set_last(first);\n+    return true;\n+  }\n+\n+  if (parts.size() == 2) {\n+    if (parts[0].empty() && parts[1].empty()) {\n+      // \":\" is not a valid range.\n+      return false;\n+    }\n+\n+    // Allow semi-open ranges (e.g. \"1:\", \":100\").\n+    int64_t first = std::numeric_limits<int64_t>::min();\n+    int64_t last = std::numeric_limits<int64_t>::max();\n+    if (!parts[0].empty() && !absl::SimpleAtoi(parts[0], &first)) {\n+      return false;\n+    }\n+    if (!parts[1].empty() && !absl::SimpleAtoi(parts[1], &last)) {\n+      return false;\n+    }\n+    if (first > last) {\n+      return false;\n+    }\n+    range.set_first(first);\n+    range.set_last(last);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+}  // namespace details\n+}  // namespace xla"
        },
        {
            "sha": "dd9fce01c02aa46c2d420d555db69d414579f122",
            "filename": "third_party/xla/xla/debug_options_parsers.h",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_parsers.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_parsers.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fdebug_options_parsers.h?ref=718fe5695ea4adbea29420df28fc41be81d3a5d2",
            "patch": "@@ -99,6 +99,19 @@ struct RepeatedFlagModifier {\n //   -> [(add, \"A\"), (remove, \"B\"), (add, \"C\")]\n absl::StatusOr<std::vector<RepeatedFlagModifier>> ParseRepeatedEnumModifiers(\n     absl::string_view flag_value, absl::string_view add_prefix = \"\");\n+\n+// Parses a string representation of an inclusive range into `range`.\n+//\n+// The string representation can be either:\n+// - a single integer x,\n+// - a range min:max,\n+// - a half-open range min: or :max.\n+// The range is inclusive on both ends.\n+//\n+// Returns true if the string is a valid range representation.\n+bool ParseIntRangeInclusive(absl::string_view string_value,\n+                            IntRangeInclusive& range);\n+\n }  // namespace details\n \n }  // namespace xla"
        },
        {
            "sha": "74b33f91b3f857366567eb689ab488bb6a698a8c",
            "filename": "third_party/xla/xla/debug_options_parsers_test.cc",
            "status": "modified",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_parsers_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fdebug_options_parsers_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fdebug_options_parsers_test.cc?ref=718fe5695ea4adbea29420df28fc41be81d3a5d2",
            "patch": "@@ -17,6 +17,8 @@ limitations under the License.\n \n #include \"xla/debug_options_parsers.h\"\n \n+#include <cstdint>\n+#include <limits>\n #include <string>\n #include <vector>\n \n@@ -44,6 +46,7 @@ using ::absl_testing::IsOkAndHolds;\n using ::absl_testing::StatusIs;\n using ::testing::ElementsAre;\n using ::testing::IsEmpty;\n+using ::xla::details::ParseIntRangeInclusive;\n using ::xla::details::ParseRepeatedEnumModifiers;\n using ::xla::details::RepeatedFlagModifier;\n \n@@ -546,6 +549,49 @@ TEST(ParseRepeatedEnumFlagsTest, XnnFusionType) {\n   TestLibraryFusionType(\"xnn\");\n }\n \n+TEST(ParseIntRangeInclusiveTest, SingleInteger) {\n+  IntRangeInclusive range;\n+  EXPECT_TRUE(ParseIntRangeInclusive(\"10\", range));\n+  EXPECT_EQ(range.first(), 10);\n+  EXPECT_EQ(range.last(), 10);\n+}\n+\n+TEST(ParseIntRangeInclusiveTest, Range) {\n+  IntRangeInclusive range;\n+  EXPECT_TRUE(ParseIntRangeInclusive(\"10:20\", range));\n+  EXPECT_EQ(range.first(), 10);\n+  EXPECT_EQ(range.last(), 20);\n+}\n+\n+TEST(ParseIntRangeInclusiveTest, HalfOpenRangeWithMin) {\n+  IntRangeInclusive range;\n+  EXPECT_TRUE(ParseIntRangeInclusive(\"10:\", range));\n+  EXPECT_EQ(range.first(), 10);\n+  EXPECT_EQ(range.last(), std::numeric_limits<int64_t>::max());\n+}\n+\n+TEST(ParseIntRangeInclusiveTest, HalfOpenRangeWithMax) {\n+  IntRangeInclusive range;\n+  EXPECT_TRUE(ParseIntRangeInclusive(\":100\", range));\n+  EXPECT_EQ(range.first(), std::numeric_limits<int64_t>::min());\n+  EXPECT_EQ(range.last(), 100);\n+}\n+\n+TEST(ParseIntRangeInclusiveTest, InvalidRange) {\n+  IntRangeInclusive range;\n+  EXPECT_FALSE(ParseIntRangeInclusive(\"10:20:30\", range));\n+}\n+\n+TEST(ParseIntRangeInclusiveTest, InvalidHalfOpenRange) {\n+  IntRangeInclusive range;\n+  EXPECT_FALSE(ParseIntRangeInclusive(\":\", range));\n+}\n+\n+TEST(ParseIntRangeInclusiveTest, ReversedRange) {\n+  IntRangeInclusive range;\n+  EXPECT_FALSE(ParseIntRangeInclusive(\"20:10\", range));\n+}\n+\n }  // namespace\n }  // namespace xla\n "
        },
        {
            "sha": "fc777d2bb44de73dc70352816a445fa8ff3e21bc",
            "filename": "third_party/xla/xla/xla.proto",
            "status": "modified",
            "additions": 23,
            "deletions": 1,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fxla.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/718fe5695ea4adbea29420df28fc41be81d3a5d2/third_party%2Fxla%2Fxla%2Fxla.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fxla.proto?ref=718fe5695ea4adbea29420df28fc41be81d3a5d2",
            "patch": "@@ -26,6 +26,24 @@ message CompilationEnvironmentsProto {\n   repeated google.protobuf.Any environments = 1;\n }\n \n+// A [first; last] range of integers, inclusive on both ends.\n+message IntRangeInclusive {\n+  int64 first = 1;\n+  int64 last = 2;\n+}\n+\n+// Set of filters for limiting the thunk buffer debug instrumentation to\n+// specific thunks. Only meaningful in combination with either\n+// `xla_gpu_experimental_enable_checksum_tracing_on_thunks` or\n+// `xla_gpu_experimental_enable_checksum_validation_on_thunks`.\n+message ThunkBufferDebugFilter {\n+  // If set, only thunk IDs matching one or more of the ranges will be included.\n+  repeated IntRangeInclusive thunk_id_ranges = 1;\n+  // If set, only thunks with profile annotations matching one or more of the\n+  // regexes will be included.\n+  repeated string profile_annotation_regexes = 2;\n+}\n+\n // Debugging options for XLA. These options may change at any time - there are\n // no guarantees about backward or forward compatibility for these fields with\n // the exception of few stable GPU feature flags (see `GetFlagStatus` in\n@@ -328,6 +346,10 @@ message DebugOptions {\n     reserved 2;  // Was PIPELINE_PARALLELISM_OPT_LEVEL_ENABLE_CYCLE_DECOMPOSER\n   }\n \n+  // Limits the thunk buffer debug instrumentation to specific thunks.\n+  optional ThunkBufferDebugFilter\n+      xla_gpu_experimental_thunk_buffer_debug_filter = 423;\n+\n   // If true, every time an HLO module is run, we will dump an\n   // HloUnoptimizedSnapshot (essentially, a serialized unoptimizedmodule plus\n   // its inputs) to the --xla_dump_to directory. This flag is currently\n@@ -1366,7 +1388,7 @@ message DebugOptions {\n   // Note: when adding a new flag, please add it to one of the hardware-specific\n   // or hardware-agnostic sections at the top of this proto message.\n \n-  // Next id: 423\n+  // Next id: 424\n \n   // Extra options to pass to the compilation backend (e.g. LLVM); specific\n   // interpretation of these values is left to the backend."
        }
    ],
    "stats": {
        "total": 202,
        "additions": 200,
        "deletions": 2
    }
}