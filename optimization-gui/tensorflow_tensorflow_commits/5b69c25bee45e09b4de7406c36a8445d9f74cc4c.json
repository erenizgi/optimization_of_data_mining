{
    "author": "bmass02",
    "message": "Add a profiler for subprocesses.\n\nPiperOrigin-RevId: 805455652",
    "sha": "5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
    "files": [
        {
            "sha": "5fd46bafba12e5c4d0ba715909519dc1dcdcf94b",
            "filename": "tensorflow/core/profiler/rpc/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/tensorflow%2Fcore%2Fprofiler%2Frpc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/tensorflow%2Fcore%2Fprofiler%2Frpc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fprofiler%2Frpc%2FBUILD?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -38,6 +38,7 @@ cc_library(\n             \"//tensorflow/core/data/service:__pkg__\",\n             \"//tensorflow/core/distributed_runtime/rpc:__pkg__\",\n             \"//tensorflow_serving/model_servers:__pkg__\",\n+            \"@local_xla//xla/backends/profiler/subprocess:__pkg__\",\n         ],\n     ),\n     deps = ["
        },
        {
            "sha": "83a117fbeb586b2f09cc883332c8d94218eeddfb",
            "filename": "third_party/xla/third_party/tsl/tsl/profiler/lib/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Flib%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Flib%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Flib%2FBUILD?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -369,6 +369,7 @@ cc_library(\n         \"@local_xla//xla/backends/profiler/plugin:__pkg__\",\n         \"//learning/brain/tfrc/executor/stream_executor:__pkg__\",\n         \"@local_xla//xla/backends/profiler/cpu:__pkg__\",\n+        \"@local_xla//xla/backends/profiler/subprocess:__pkg__\",\n     ]),\n     deps = [\n         \":profiler_interface\","
        },
        {
            "sha": "0b151f9ab38b3c83ed0b79692044e357b4ac6669",
            "filename": "third_party/xla/third_party/tsl/tsl/profiler/protobuf/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Fprotobuf%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Fprotobuf%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Fprotobuf%2FBUILD?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -44,6 +44,7 @@ tf_proto_library(\n     protodeps = [\n         \":profiler_options_proto\",\n         \":profiler_service_monitor_result_proto\",\n+        \":xplane_proto\",\n     ],\n     use_grpc_namespace = True,\n     visibility = [\"//visibility:public\"],"
        },
        {
            "sha": "2419d8290918d5a66d1251a15b18dcf93ef857c8",
            "filename": "third_party/xla/third_party/tsl/tsl/profiler/protobuf/profiler_service.proto",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Fprotobuf%2Fprofiler_service.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Fprotobuf%2Fprofiler_service.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fprofiler%2Fprotobuf%2Fprofiler_service.proto?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -4,6 +4,7 @@ package tensorflow;\n \n import \"tsl/profiler/protobuf/profiler_options.proto\";\n import \"tsl/profiler/protobuf/profiler_service_monitor_result.proto\";\n+import \"tsl/profiler/protobuf/xplane.proto\";\n \n // The ProfilerService service retrieves performance information about\n // the programs running on connected devices over a period of time.\n@@ -29,7 +30,7 @@ message ToolRequestOptions {\n   bool save_to_repo = 3;\n }\n \n-// Next-ID: 9\n+// Next-ID: 10\n message ProfileRequest {\n   // In future, the caller will be able to customize when profiling starts and\n   // stops. For now, it collects `duration_ms` milliseconds worth of data.\n@@ -59,6 +60,8 @@ message ProfileRequest {\n   // We use it as identifier in part of our output filename.\n   string host_name = 7;\n \n+  // If true, the response will contain the XSpace in the response.\n+  bool emit_xspace = 9;\n   // In future, the caller will indicate which TF session is being profiled, and\n   // only data relating to that program will be returned. For now, we assume\n   // all activity during the profiling period is relevant.\n@@ -73,7 +76,7 @@ message ProfileToolData {\n   bytes data = 2;\n }\n \n-// Next-ID: 8\n+// Next-ID: 9\n message ProfileResponse {\n   // Data payload for each required tools.\n   repeated ProfileToolData tool_data = 6;\n@@ -82,6 +85,10 @@ message ProfileResponse {\n   // way to figure out whether the captured trace is empty.\n   bool empty_trace = 7;\n \n+  // The XSpace proto containing the raw profiling data (e.g. pre-analysis).\n+  // This field is only populated if ProfileRequest.emit_xspace is true.\n+  tensorflow.profiler.XSpace xspace = 8;\n+\n   reserved 1, 2, 3, 4, 5;\n }\n "
        },
        {
            "sha": "143939612d5f688258727129ddb744bd2c12ac4d",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/BUILD",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2FBUILD?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,122 @@\n+load(\n+    \"//xla:xla.default.bzl\",\n+    \"xla_cc_test\",\n+)\n+load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\")\n+load(\"//xla/tsl:tsl.default.bzl\", \"tsl_grpc_cc_dependencies\")\n+load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_binary\", \"cc_library\")\n+load(\"//xla/tsl/profiler/builds:build_config.bzl\", \"tf_profiler_copts\")\n+\n+# copybara:uncomment package(default_applicable_licenses = [\"//tensorflow:license\"])\n+\n+cc_library(\n+    name = \"subprocess_registry\",\n+    srcs = [\"subprocess_registry.cc\"],\n+    hdrs = [\"subprocess_registry.h\"],\n+    visibility = internal_visibility([\n+        \"//xla/python:__pkg__\",\n+    ]),\n+    deps = [\n+        \"//xla/tsl/platform:env\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@local_tsl//tsl/profiler/protobuf:profiler_service_cc_grpc_proto\",\n+    ] + tsl_grpc_cc_dependencies(),\n+)\n+\n+xla_cc_test(\n+    name = \"subprocess_registry_test\",\n+    srcs = [\"subprocess_registry_test.cc\"],\n+    deps = [\n+        \":subprocess_registry\",\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/platform:test_main\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"subprocess_profiling_session\",\n+    srcs = [\"subprocess_profiling_session.cc\"],\n+    hdrs = [\"subprocess_profiling_session.h\"],\n+    copts = tf_profiler_copts(),\n+    visibility = internal_visibility([\n+        \"//xla/python:__pkg__\",\n+    ]),\n+    deps = [\n+        \":subprocess_registry\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/profiler/utils:xplane_schema\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/memory\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/time\",\n+        \"@local_tsl//tsl/profiler/lib:profiler_collection\",\n+        \"@local_tsl//tsl/profiler/lib:profiler_factory\",\n+        \"@local_tsl//tsl/profiler/lib:profiler_interface\",\n+        \"@local_tsl//tsl/profiler/protobuf:profiler_options_proto_cc\",\n+        \"@local_tsl//tsl/profiler/protobuf:profiler_service_proto_cc\",\n+        \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n+    ] + tsl_grpc_cc_dependencies(),\n+    alwayslink = True,\n+)\n+\n+xla_cc_test(\n+    name = \"subprocess_profiling_session_test\",\n+    srcs = [\"subprocess_profiling_session_test.cc\"],\n+    args = [\"--vmodule=subprocess_profiling_session=10\"],\n+    data = [\":subprocess_main\"],\n+    env = {\n+        \"XPROF_TEST_SUBPROCESS_MAIN_PATH\": \"$(rlocationpath :subprocess_main)\",\n+    },\n+    deps = [\n+        \":subprocess_profiling_session\",\n+        \":subprocess_registry\",\n+        \"//xla/backends/profiler:profiler_backends\",  # buildcleaner: keep\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:resource_loader\",\n+        \"//xla/tsl/platform:subprocess\",\n+        \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/platform:test_main\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/time\",\n+        \"@com_google_googletest//:gtest\",\n+        \"@local_tsl//tsl/platform\",\n+        \"@local_tsl//tsl/platform:env\",\n+        \"@local_tsl//tsl/platform:path\",\n+        \"@local_tsl//tsl/profiler/lib:profiler_session\",\n+        \"@local_tsl//tsl/profiler/lib:traceme\",\n+        \"@local_tsl//tsl/profiler/protobuf:profiler_options_proto_cc\",\n+        \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n+    ] + tsl_grpc_cc_dependencies(),\n+)\n+\n+cc_binary(\n+    name = \"subprocess_main\",\n+    testonly = True,\n+    srcs = [\"subprocess_main.cc\"],\n+    visibility = internal_visibility([\n+        \"//xla/backends/profiler/subprocess:__pkg__\",\n+    ]),\n+    deps = [\n+        \"//xla/backends/profiler:profiler_backends\",  # buildcleaner: keep\n+        \"//xla/tsl/profiler/rpc:profiler_server_impl\",\n+        \"//xla/tsl/util:command_line_flags\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/time\",\n+        \"@local_tsl//tsl/platform:platform_port\",\n+        \"@local_tsl//tsl/profiler/lib:traceme\",\n+    ],\n+)"
        },
        {
            "sha": "235915e1bce1f6057cea8f4bb87bf6c167c279a5",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_main.cc",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_main.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_main.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_main.cc?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,46 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include <cstdint>\n+#include <memory>\n+#include <vector>\n+\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/tsl/profiler/rpc/profiler_server.h\"\n+#include \"xla/tsl/util/command_line_flags.h\"\n+#include \"tsl/platform/init_main.h\"\n+#include \"tsl/profiler/lib/traceme.h\"\n+\n+int main(int argc, char** argv) {\n+  int port = 0;\n+  std::vector<tsl::Flag> flag_list = {\n+      tsl::Flag(\"port\", &port, \"Port to start the profiler server on.\")};\n+  tsl::Flags::Parse(&argc, argv, flag_list);\n+  tsl::port::InitMain(argv[0], &argc, &argv);\n+\n+  auto profiler_server = std::make_unique<tsl::profiler::ProfilerServer>();\n+  profiler_server->StartProfilerServer(port);\n+\n+  uint64_t iteration = 0;\n+  while (true) {\n+    tsl::profiler::TraceMe trace_me([&] {\n+      return absl::StrCat(\"subprocess_test_\", port, \"_\", iteration++);\n+    });\n+    absl::SleepFor(absl::Milliseconds(10));\n+  }\n+  return 0;\n+}"
        },
        {
            "sha": "dc0741cc86db1553077c749645d1e1e725dd81db",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_profiling_session.cc",
            "status": "added",
            "additions": 227,
            "deletions": 0,
            "changes": 227,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session.cc?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,227 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/subprocess/subprocess_profiling_session.h\"\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"grpcpp/client_context.h\"\n+#include \"grpcpp/support/status.h\"\n+#include \"xla/backends/profiler/subprocess/subprocess_registry.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/profiler/utils/xplane_schema.h\"\n+#include \"tsl/profiler/lib/profiler_collection.h\"\n+#include \"tsl/profiler/lib/profiler_factory.h\"\n+#include \"tsl/profiler/lib/profiler_interface.h\"\n+#include \"tsl/profiler/protobuf/profiler_service.pb.h\"\n+#include \"tsl/profiler/protobuf/xplane.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace subprocess {\n+namespace {\n+\n+// Set an infinite default duration to support programmatic and end-to-end\n+// profiling.\n+constexpr uint64_t kInfiniteDurationMs = std::numeric_limits<uint64_t>::max();\n+\n+inline absl::Status FromGrpcStatus(const ::grpc::Status& s) {\n+  return s.ok() ? absl::OkStatus()\n+                : absl::Status(static_cast<absl::StatusCode>(s.error_code()),\n+                               s.error_message());\n+}\n+\n+absl::StatusOr<tensorflow::ProfileRequest> BuildProfileRequest(\n+    const SubprocessInfo& subprocess_info,\n+    const tensorflow::ProfileOptions& options) {\n+  tensorflow::ProfileRequest request;\n+  *request.mutable_opts() = options;\n+  // Only support CPU profiling for now. To support other device types, they\n+  // will need to be updated to correctly handle subprocess traces.\n+  request.mutable_opts()->set_device_type(tensorflow::ProfileOptions::CPU);\n+  request.set_session_id(absl::StrCat(\"subprocess_\", subprocess_info.pid, \"_\",\n+                                      absl::ToUnixMillis(absl::Now())));\n+  request.set_emit_xspace(true);\n+  // Use an infinite duration to support programmatic and end-to-end profiling.\n+  request.set_duration_ms(kInfiniteDurationMs);\n+  request.mutable_opts()->set_duration_ms(kInfiniteDurationMs);\n+  return request;\n+}\n+\n+class SubprocessProfilingSession : public tsl::profiler::ProfilerInterface {\n+ public:\n+  SubprocessProfilingSession(const SubprocessInfo& subprocess_info,\n+                             const tensorflow::ProfileRequest& request)\n+      : subprocess_info_(subprocess_info), request_(request) {\n+    // Set the empty trace flag to true by default. This will be set to false\n+    // once the response is received from the subprocess.\n+    response_.set_empty_trace(true);\n+  }\n+  // Not copyable or movable\n+  SubprocessProfilingSession(const SubprocessProfilingSession&) = delete;\n+  SubprocessProfilingSession& operator=(const SubprocessProfilingSession&) =\n+      delete;\n+\n+  absl::Status Start() override;\n+  absl::Status Stop() override;\n+  absl::Status CollectData(tensorflow::profiler::XSpace* space) override;\n+\n+ private:\n+  SubprocessInfo subprocess_info_;\n+  tensorflow::ProfileRequest request_;\n+  tensorflow::ProfileResponse response_;\n+  grpc::ClientContext context_;\n+  grpc::CompletionQueue completion_queue_;\n+  grpc::Status grpc_status_;\n+  std::unique_ptr<grpc::ClientAsyncResponseReader<tensorflow::ProfileResponse>>\n+      rpc_;\n+};\n+\n+absl::Status SubprocessProfilingSession::Start() {\n+  if (rpc_) {\n+    return absl::FailedPreconditionError(\n+        \"Another subprocess profiling session already started.\");\n+  }\n+  context_.set_wait_for_ready(true);\n+  rpc_ = subprocess_info_.profiler_stub->AsyncProfile(&context_, request_,\n+                                                      &completion_queue_);\n+  if (!rpc_) {\n+    return absl::InternalError(\"Failed to start profiling session.\");\n+  }\n+  // Register a memory location for the response with a tag of 1. This tag will\n+  // be used to verify the results from the CompletionQueue::Next call in\n+  // Stop().\n+  rpc_->Finish(&response_, &grpc_status_, (void*)1);\n+  return absl::OkStatus();\n+}\n+\n+absl::Status SubprocessProfilingSession::Stop() {\n+  if (!rpc_) {\n+    return absl::FailedPreconditionError(\n+        \"Subprocess profiling session not started.\");\n+  }\n+  tensorflow::TerminateRequest terminate_request;\n+  terminate_request.set_session_id(request_.session_id());\n+  tensorflow::TerminateResponse terminate_response;\n+  grpc::ClientContext context;\n+  TF_RETURN_IF_ERROR(FromGrpcStatus(subprocess_info_.profiler_stub->Terminate(\n+      &context, terminate_request, &terminate_response)));\n+\n+  // Wait for the response from the AsyncProfile+Finish calls.\n+  void* got_tag;\n+  bool ok = false;\n+  bool success = completion_queue_.Next(&got_tag, &ok);\n+  // Verify the response is correct by checking for the tag we passed in the\n+  // call to Finish(). See\n+  // https://grpc.io/docs/languages/cpp/async/#async-client for more details.\n+  if (!success || !ok || got_tag != (void*)1) {\n+    return absl::InternalError(\"Failed to get response from profiler service\");\n+  }\n+  TF_RETURN_IF_ERROR(FromGrpcStatus(grpc_status_));\n+  return absl::OkStatus();\n+}\n+\n+std::string WrapSubprocessMessage(absl::string_view message,\n+                                  const SubprocessInfo& subprocess_info) {\n+  return absl::StrCat(\"[Subprocess \", subprocess_info.pid, \"] \", message);\n+}\n+\n+absl::Status SubprocessProfilingSession::CollectData(\n+    tensorflow::profiler::XSpace* space) {\n+  if (space == nullptr) {\n+    return absl::InvalidArgumentError(\"space is null\");\n+  }\n+  if (response_.empty_trace()) {\n+    space->add_warnings(\n+        absl::StrCat(\"No XSpace data returned from subprocess: \",\n+                     subprocess_info_.DebugString()));\n+  }\n+  for (const auto& plane : response_.xspace().planes()) {\n+    // TODO(b/416884677): Implement merging task env planes from subprocesses to\n+    // propagate metadata.\n+    if (plane.name() == tsl::profiler::kTaskEnvPlaneName) {\n+      // Throw away the task env plane from subprocesses for now.\n+      continue;\n+    }\n+    *space->add_planes() = plane;\n+  }\n+  for (const auto& warning : response_.xspace().warnings()) {\n+    space->add_warnings(WrapSubprocessMessage(warning, subprocess_info_));\n+  }\n+  for (const auto& error : response_.xspace().errors()) {\n+    space->add_errors(WrapSubprocessMessage(error, subprocess_info_));\n+  }\n+  // Do not fail other profilers due to subprocess profiling failure.\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace\n+\n+absl::StatusOr<std::unique_ptr<tsl::profiler::ProfilerInterface>>\n+CreateSubprocessProfilingSession(const SubprocessInfo& subprocess_info,\n+                                 const tensorflow::ProfileOptions& options) {\n+  TF_ASSIGN_OR_RETURN(tensorflow::ProfileRequest request,\n+                      BuildProfileRequest(subprocess_info, options));\n+  if (subprocess_info.profiler_stub == nullptr) {\n+    return absl::InvalidArgumentError(\"Profiler stub is null\");\n+  }\n+  return std::make_unique<SubprocessProfilingSession>(subprocess_info, request);\n+}\n+\n+namespace {\n+\n+std::unique_ptr<tsl::profiler::ProfilerInterface> CreateSubprocessProfilers(\n+    const tensorflow::ProfileOptions& options) {\n+  std::vector<SubprocessInfo> subprocesses = GetRegisteredSubprocesses();\n+  std::vector<std::unique_ptr<tsl::profiler::ProfilerInterface>>\n+      subprocess_profilers;\n+  subprocess_profilers.reserve(subprocesses.size());\n+  for (const auto& subprocess_info : subprocesses) {\n+    absl::StatusOr<std::unique_ptr<tsl::profiler::ProfilerInterface>>\n+        subprocess_profiler =\n+            CreateSubprocessProfilingSession(subprocess_info, options);\n+    if (!subprocess_profiler.ok()) {\n+      LOG(ERROR) << \"Failed to create subprocess profiling session: \"\n+                 << subprocess_profiler.status();\n+      continue;\n+    }\n+    subprocess_profilers.push_back(std::move(*subprocess_profiler));\n+  }\n+  return std::make_unique<tsl::profiler::ProfilerCollection>(\n+      std::move(subprocess_profilers));\n+};\n+\n+// Register the subprocess profiler factory.\n+auto register_subprocess_profiler_factory = [] {\n+  RegisterProfilerFactory(&CreateSubprocessProfilers);\n+  return 0;\n+}();\n+\n+}  // namespace\n+}  // namespace subprocess\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "f7d13019273e0efdf834338664f711e482669706",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_profiling_session.h",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session.h?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,43 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_PROFILER_SUBPROCESS_SUBPROCESS_PROFILING_SESSION_H_\n+#define XLA_BACKENDS_PROFILER_SUBPROCESS_SUBPROCESS_PROFILING_SESSION_H_\n+\n+#include <memory>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"xla/backends/profiler/subprocess/subprocess_registry.h\"\n+#include \"tsl/profiler/lib/profiler_interface.h\"\n+#include \"tsl/profiler/protobuf/profiler_options.pb.h\"\n+#include \"tsl/profiler/protobuf/profiler_service.pb.h\"\n+#include \"tsl/profiler/protobuf/xplane.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace subprocess {\n+\n+// Creates a profiler for the specified subprocess. The subprocess must have a\n+// ProfilerService gRPC server listening on the address specified in\n+// `subprocess_info`.\n+absl::StatusOr<std::unique_ptr<tsl::profiler::ProfilerInterface>>\n+CreateSubprocessProfilingSession(const SubprocessInfo& subprocess_info,\n+                                 const tensorflow::ProfileOptions& options);\n+\n+}  // namespace subprocess\n+}  // namespace profiler\n+}  // namespace xla\n+\n+#endif  // XLA_BACKENDS_PROFILER_SUBPROCESS_SUBPROCESS_PROFILING_SESSION_H_"
        },
        {
            "sha": "460a24f97e70d8e7eb932990a5f82014524a0192",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_profiling_session_test.cc",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_profiling_session_test.cc?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,173 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/subprocess/subprocess_profiling_session.h\"  // IWYU pragma: keep\n+\n+#include <netinet/in.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <sys/wait.h>\n+#include <unistd.h>\n+\n+#include <cstdlib>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"absl/strings/match.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/strings/str_split.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/backends/profiler/subprocess/subprocess_registry.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/subprocess.h\"\n+#include \"xla/tsl/platform/test.h\"\n+#include \"tsl/platform/path.h\"\n+#include \"tsl/profiler/lib/profiler_session.h\"\n+#include \"tsl/profiler/lib/traceme.h\"\n+#include \"tsl/profiler/protobuf/profiler_options.pb.h\"\n+#include \"tsl/profiler/protobuf/xplane.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace subprocess {\n+namespace {\n+\n+using ::absl_testing::IsOk;\n+using ::testing::IsEmpty;\n+using ::testing::Not;\n+\n+std::unique_ptr<tsl::SubProcess> CreateSubProcess(\n+    const std::vector<std::string>& args) {\n+  auto subprocess = std::make_unique<tsl::SubProcess>();\n+  subprocess->SetProgram(args[0], args);\n+  subprocess->SetChannelAction(tsl::CHAN_STDOUT, tsl::ACTION_DUPPARENT);\n+  subprocess->SetChannelAction(tsl::CHAN_STDERR, tsl::ACTION_DUPPARENT);\n+  return subprocess;\n+}\n+\n+class SubprocessProfilingSessionTest : public ::testing::Test {\n+ public:\n+  void SetUpSubprocesses(int num_subprocesses) {\n+    std::string subprocess_main_path =\n+        std::getenv(\"XPROF_TEST_SUBPROCESS_MAIN_PATH\");\n+    ASSERT_FALSE(subprocess_main_path.empty())\n+        << \"The env variable XPROF_TEST_SUBPROCESS_MAIN_PATH is required.\";\n+    const char* srcdir = std::getenv(\"TEST_SRCDIR\");\n+    ASSERT_NE(srcdir, nullptr) << \"Environment variable TEST_SRCDIR unset!\";\n+    subprocess_main_path = tsl::io::JoinPath(srcdir, subprocess_main_path);\n+    ASSERT_TRUE(subprocesses_.empty());\n+    subprocesses_.resize(num_subprocesses);\n+    for (int i = 0; i < num_subprocesses; ++i) {\n+      std::vector<std::string> args;\n+      args.push_back(subprocess_main_path);\n+      int port = tsl::testing::PickUnusedPortOrDie();\n+      args.push_back(absl::StrCat(\"--port=\", port));\n+\n+      SubProcessRuntime& subprocess_runtime = subprocesses_[i];\n+      subprocess_runtime.port = port;\n+      subprocess_runtime.subprocess = CreateSubProcess(args);\n+      ASSERT_TRUE(subprocess_runtime.subprocess->Start());\n+      ASSERT_THAT(\n+          RegisterSubprocess(subprocess_runtime.port, subprocess_runtime.port),\n+          IsOk());\n+    }\n+    // Wait for connections to be established.\n+    absl::SleepFor(absl::Seconds(1));\n+  }\n+\n+  void TearDown() override {\n+    for (auto& subprocess_runtime : subprocesses_) {\n+      ASSERT_NE(subprocess_runtime.subprocess, nullptr);\n+      ASSERT_TRUE(subprocess_runtime.subprocess->Kill(SIGKILL));\n+      ASSERT_THAT(UnregisterSubprocess(subprocess_runtime.port), IsOk());\n+    }\n+  }\n+\n+  struct SubProcessRuntime {\n+    std::unique_ptr<tsl::SubProcess> subprocess;\n+    int port;\n+  };\n+  std::vector<SubProcessRuntime> subprocesses_;\n+};\n+\n+TEST_F(SubprocessProfilingSessionTest, MultipleSubprocessesIntegrationTest) {\n+  SetUpSubprocesses(3);\n+\n+  auto session =\n+      tsl::ProfilerSession::Create(tsl::ProfilerSession::DefaultOptions());\n+  auto deadline = absl::Now() + absl::Seconds(1);\n+  while (absl::Now() < deadline) {\n+    tsl::profiler::TraceMe trace_me(\"main_process\");\n+    absl::SleepFor(absl::Milliseconds(10));\n+  }\n+  tensorflow::profiler::XSpace space;\n+  ASSERT_THAT(session->CollectData(&space), IsOk());\n+\n+  ASSERT_THAT(space.planes(), Not(IsEmpty()));\n+\n+  absl::flat_hash_set<std::string> trace_me_names;\n+  for (const auto& plane : space.planes()) {\n+    const auto& event_metadata = plane.event_metadata();\n+    for (const auto& line : plane.lines()) {\n+      if (!line.events().empty()) {\n+        const auto& event = line.events(0);\n+        std::string trace_me_name =\n+            event_metadata.at(event.metadata_id()).name();\n+        if (absl::StartsWith(trace_me_name, \"subprocess_test_\")) {\n+          std::vector<std::string> parts = absl::StrSplit(\n+              event_metadata.at(event.metadata_id()).name(), '_');\n+          ASSERT_EQ(parts.size(), 4)\n+              << \"Invalid trace me name: \" << trace_me_name;\n+          trace_me_name = absl::StrJoin(parts.begin(), parts.end() - 1, \"_\");\n+        }\n+        trace_me_names.insert(trace_me_name);\n+      }\n+    }\n+  }\n+  absl::flat_hash_set<std::string> expected_trace_me_names;\n+  expected_trace_me_names.insert(\"main_process\");\n+  for (const auto& subproc : subprocesses_) {\n+    // The pid is actually the port number since tsl::SubProcess does not\n+    // expose the pid.\n+    expected_trace_me_names.insert(\n+        absl::StrCat(\"subprocess_test_\", subproc.port));\n+  }\n+  EXPECT_EQ(trace_me_names, expected_trace_me_names);\n+\n+  // Emit the collected XSpace as an undeclared output file.\n+  const char* outputs_dir = std::getenv(\"TEST_UNDECLARED_OUTPUTS_DIR\");\n+  if (outputs_dir != nullptr) {\n+    std::string output_path = tsl::io::JoinPath(outputs_dir, \"xspace.pb\");\n+    ASSERT_THAT(tsl::WriteBinaryProto(tsl::Env::Default(), output_path, space),\n+                IsOk());\n+    LOG(INFO) << \"Wrote XSpace proto to: \" << output_path;\n+  } else {\n+    LOG(WARNING)\n+        << \"TEST_UNDECLARED_OUTPUTS_DIR not set, skipping writing xspace.pb\";\n+  }\n+}\n+\n+}  // namespace\n+}  // namespace subprocess\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "9bb3967438923e6d007b1c40d9a62561b502414f",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_registry.cc",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry.cc?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,119 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/subprocess/subprocess_registry.h\"\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"grpcpp/security/credentials.h\"\n+#include \"grpcpp/support/channel_arguments.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"tsl/profiler/protobuf/profiler_service.grpc.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace subprocess {\n+namespace {\n+\n+// Registry of subprocesses.\n+struct Registry {\n+  absl::Mutex mu;\n+  absl::flat_hash_set<SubprocessInfo> subprocesses ABSL_GUARDED_BY(mu);\n+};\n+\n+// Global registry of subprocesses.\n+Registry& registry() {\n+  static absl::NoDestructor<Registry> registry;\n+  return *registry;\n+}\n+\n+absl::Status RegisterSubprocess(SubprocessInfo&& subprocess_info) {\n+  // This check ensures that there can't be a loop in the subprocess profiler\n+  // graph.\n+  if (subprocess_info.pid == tsl::Env::Default()->GetProcessId()) {\n+    return absl::InvalidArgumentError(\n+        \"Cannot register subprocess with the same pid as current process.\");\n+  }\n+  ::grpc::ChannelArguments channel_args;\n+  channel_args.SetMaxReceiveMessageSize(std::numeric_limits<int32_t>::max());\n+  auto channel = ::grpc::CreateCustomChannel(\n+      subprocess_info.address, ::grpc::InsecureChannelCredentials(),\n+      channel_args);\n+  if (!channel) {\n+    return absl::InternalError(\n+        absl::StrCat(\"Unable to create channel to \", subprocess_info.address));\n+  }\n+  subprocess_info.profiler_stub =\n+      tensorflow::grpc::ProfilerService::NewStub(channel);\n+  {\n+    absl::MutexLock l(&registry().mu);\n+    if (!registry().subprocesses.insert(subprocess_info).second) {\n+      return absl::AlreadyExistsError(\n+          absl::StrCat(subprocess_info.DebugString(), \" already registered\"));\n+    }\n+  }\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace\n+\n+std::string SubprocessInfo::DebugString() const {\n+  return absl::StrCat(\"SubprocessInfo(pid: \", pid, \", address: \", address, \")\");\n+}\n+\n+absl::Status RegisterSubprocess(pid_t pid, int port) {\n+  return RegisterSubprocess({pid, absl::StrCat(\"localhost:\", port)});\n+}\n+\n+absl::Status RegisterSubprocess(pid_t pid,\n+                                absl::string_view unix_domain_socket) {\n+  return RegisterSubprocess({pid, absl::StrCat(\"unix:\", unix_domain_socket)});\n+}\n+\n+absl::Status UnregisterSubprocess(pid_t pid) {\n+  absl::MutexLock l(&registry().mu);\n+  if (registry().subprocesses.erase({pid, \"\"}) == 0) {\n+    LOG(WARNING) << \"Subprocess \" << pid << \" not found\";\n+    return absl::NotFoundError(absl::StrCat(pid, \" not found\"));\n+  }\n+  return absl::OkStatus();\n+}\n+\n+std::vector<SubprocessInfo> GetRegisteredSubprocesses() {\n+  absl::MutexLock l(&registry().mu);\n+  std::vector<SubprocessInfo> subprocesses;\n+  subprocesses.reserve(registry().subprocesses.size());\n+  for (const SubprocessInfo& subprocess_info : registry().subprocesses) {\n+    subprocesses.push_back(subprocess_info);\n+  }\n+  return subprocesses;\n+}\n+\n+}  // namespace subprocess\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "98b4b022b3a7e6a407d4ec631ebc989b0953395c",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_registry.h",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry.h?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,78 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_PROFILER_SUBPROCESS_SUBPROCESS_REGISTRY_H_\n+#define XLA_BACKENDS_PROFILER_SUBPROCESS_SUBPROCESS_REGISTRY_H_\n+\n+#include <sys/types.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"tsl/profiler/protobuf/profiler_service.grpc.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace subprocess {\n+\n+// Information about a registered subprocess.\n+struct SubprocessInfo {\n+  pid_t pid;\n+  std::string address;\n+  std::shared_ptr<tensorflow::grpc::ProfilerService::Stub> profiler_stub;\n+\n+  template <typename H>\n+  friend H AbslHashValue(H h, const SubprocessInfo& subprocess) {\n+    return H::combine(std::move(h), subprocess.pid);\n+  }\n+\n+  bool operator==(const SubprocessInfo& other) const {\n+    return pid == other.pid;\n+  }\n+\n+  bool operator!=(const SubprocessInfo& other) const {\n+    return !(*this == other);\n+  }\n+\n+  std::string DebugString() const;\n+};\n+\n+// Registers a subprocess that has a running HTTP server listening on the given\n+// port or Unix domain socket, so that it can be profiled using the\n+// subprocess profiler.\n+// It is expected to call `RegisterSubprocess` after starting the subprocess.\n+// This method will create a stub to the ProfilerService in the subprocess, and\n+// may block for a while until the stub is ready or connection times out.\n+// RETURNS: an error if the subprocess is already registered or if the\n+// subprocess stub cannot be created.\n+absl::Status RegisterSubprocess(pid_t pid, int port);\n+absl::Status RegisterSubprocess(pid_t pid,\n+                                absl::string_view unix_domain_socket);\n+\n+// Unregisters a subprocess by just erasing it from the registry. If there are\n+// in-flight profiling sessions, they will NOT be cancelled.\n+absl::Status UnregisterSubprocess(pid_t pid);\n+\n+// Returns all currently registered subprocesses.\n+std::vector<SubprocessInfo> GetRegisteredSubprocesses();\n+\n+}  // namespace subprocess\n+}  // namespace profiler\n+}  // namespace xla\n+\n+#endif  // XLA_BACKENDS_PROFILER_SUBPROCESS_SUBPROCESS_REGISTRY_H_"
        },
        {
            "sha": "cd9336bf8ef1bc06bf9db917e92ab375f0462130",
            "filename": "third_party/xla/xla/backends/profiler/subprocess/subprocess_registry_test.cc",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fsubprocess%2Fsubprocess_registry_test.cc?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -0,0 +1,53 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/subprocess/subprocess_registry.h\"\n+\n+#include \"absl/status/status_matchers.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/test.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace subprocess {\n+namespace {\n+\n+using absl_testing::IsOk;\n+using ::testing::Not;\n+\n+TEST(SubprocessRegistryTest, FailsToRegisterCurrentProcessAsSubprocess) {\n+  EXPECT_THAT(RegisterSubprocess(tsl::Env::Default()->GetProcessId(), 1234),\n+              Not(IsOk()));\n+}\n+\n+TEST(SubprocessRegistryTest, RegistersSubprocessWithPort) {\n+  EXPECT_THAT(RegisterSubprocess(1234, tsl::testing::PickUnusedPortOrDie()),\n+              IsOk());\n+}\n+\n+TEST(SubprocessRegistryTest, RegistersSubprocessWithUnixDomainSocket) {\n+  EXPECT_THAT(RegisterSubprocess(12345, \"/tmp/valid_socket\"), IsOk());\n+}\n+\n+TEST(SubprocessRegistryTest, FailsToRegisterSubprocessTwice) {\n+  int port = tsl::testing::PickUnusedPortOrDie();\n+  EXPECT_THAT(RegisterSubprocess(123456, port), IsOk());\n+  EXPECT_THAT(RegisterSubprocess(123456, port), Not(IsOk()));\n+}\n+\n+}  // namespace\n+}  // namespace subprocess\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "0d00aec61180919b4595cd7760cdc337beabdd59",
            "filename": "third_party/xla/xla/tsl/profiler/rpc/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Frpc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Frpc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Frpc%2FBUILD?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -28,6 +28,7 @@ cc_library(\n         \"//tensorflow_serving/model_servers:__pkg__\",\n         \"//tensorflow/python/profiler/internal:__pkg__\",\n         \"//third_party/xprof/pywrap:__pkg__\",\n+        \"//xla/tsl/profiler:friends\",\n     ]),\n     deps = [\n         \"//xla/tsl/platform:env\",\n@@ -36,13 +37,15 @@ cc_library(\n         \"//xla/tsl/platform:logging\",\n         \"//xla/tsl/platform:macros\",\n         \"//xla/tsl/platform:status\",\n+        \"//xla/tsl/platform:types\",\n         \"//xla/tsl/profiler/rpc/client:save_profile\",\n         \"//xla/tsl/profiler/utils:file_system_utils\",\n         \"//xla/tsl/profiler/utils:math_utils\",\n         \"//xla/tsl/profiler/utils:time_utils\",\n         \"//xla/tsl/profiler/utils:xplane_utils\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/memory\",\n+        \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@local_tsl//tsl/profiler/lib:profiler_session\","
        },
        {
            "sha": "394ce8470972665799c43281afe3cf6628df08e6",
            "filename": "third_party/xla/xla/tsl/profiler/rpc/profiler_service_impl.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 11,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Frpc%2Fprofiler_service_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5b69c25bee45e09b4de7406c36a8445d9f74cc4c/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Frpc%2Fprofiler_service_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Frpc%2Fprofiler_service_impl.cc?ref=5b69c25bee45e09b4de7406c36a8445d9f74cc4c",
            "patch": "@@ -15,9 +15,11 @@ limitations under the License.\n \n #include \"xla/tsl/profiler/rpc/profiler_service_impl.h\"\n \n+#include <cstdint>\n #include <memory>\n \n #include \"absl/container/flat_hash_map.h\"\n+#include \"absl/status/status.h\"\n #include \"absl/strings/str_replace.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"grpcpp/support/status.h\"\n@@ -50,15 +52,21 @@ using tensorflow::TerminateResponse;\n \n // Collects data in XSpace format. The data is saved to a repository\n // unconditionally.\n-absl::Status CollectDataToRepository(const ProfileRequest& request,\n-                                     ProfilerSession* profiler,\n-                                     ProfileResponse* response) {\n+absl::Status CollectData(const ProfileRequest& request,\n+                         ProfilerSession* profiler, ProfileResponse* response) {\n   response->set_empty_trace(true);\n   // Read the profile data into xspace.\n-  XSpace xspace;\n-  TF_RETURN_IF_ERROR(profiler->CollectData(&xspace));\n-  VLOG(3) << \"Collected XSpace to repository.\";\n-  response->set_empty_trace(IsEmpty(xspace));\n+  tensorflow::profiler::XSpace xspace;\n+  tensorflow::profiler::XSpace* xspace_ptr =\n+      request.emit_xspace() ? response->mutable_xspace() : &xspace;\n+  TF_RETURN_IF_ERROR(profiler->CollectData(xspace_ptr));\n+  VLOG(3) << \"Collected XSpace to \"\n+          << (request.emit_xspace() ? \"response\" : \"repository\") << \".\";\n+  response->set_empty_trace(IsEmpty(*xspace_ptr));\n+\n+  if (request.emit_xspace()) {\n+    return absl::OkStatus();\n+  }\n \n   return SaveXSpace(request.repository_root(), request.session_id(),\n                     request.host_name(), xspace);\n@@ -83,9 +91,11 @@ class ProfilerServiceImpl : public tensorflow::grpc::ProfilerService::Service {\n     }\n \n     Env* env = Env::Default();\n-    uint64 duration_ns = MilliToNano(req->opts().duration_ms());\n-    uint64 deadline = GetCurrentTimeNanos() + duration_ns;\n-    while (GetCurrentTimeNanos() < deadline) {\n+    int64_t start_time_ns = GetCurrentTimeNanos();\n+    // TODO(b/416884677): Handle server shutdown gracefully by surfacing a\n+    // shutdown signal here and responding with what has been profiled so far.\n+    while (NanoToMilli(GetCurrentTimeNanos() - start_time_ns) <\n+           req->opts().duration_ms()) {\n       env->SleepForMicroseconds(EnvTime::kMillisToMicros);\n       if (ctx->IsCancelled()) {\n         return ::grpc::Status::CANCELLED;\n@@ -97,7 +107,7 @@ class ProfilerServiceImpl : public tensorflow::grpc::ProfilerService::Service {\n       }\n     }\n \n-    status = CollectDataToRepository(*req, profiler.get(), response);\n+    status = CollectData(*req, profiler.get(), response);\n     if (!status.ok()) {\n       return ::grpc::Status(::grpc::StatusCode::INTERNAL,\n                             std::string(status.message()));"
        }
    ],
    "stats": {
        "total": 910,
        "additions": 897,
        "deletions": 13
    }
}