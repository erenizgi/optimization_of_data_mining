{
    "author": "jparkerh",
    "message": "Add `pjrt/c_api_client` directory.\n\nThis new directory contains the thick client wrapper that provides a C++ (e.g., `PjRtClient`, `PjRtDevice`) on top of the purely C-style PJRT C API. The `README.md` details the classes implemented to wrap the C API structures. This existed previously, generating this directory to improve organization and prepare for splitting these dependencies out from a monofile in further cls.\n\nPiperOrigin-RevId: 814737385",
    "sha": "52bf968be54f45d93d598a146a3e50b43e80bb44",
    "files": [
        {
            "sha": "9044db711d8a172fddea4b66ade7379584b9f0f2",
            "filename": "third_party/xla/xla/pjrt/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 108,
            "changes": 117,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -45,6 +45,15 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"pjrt_c_api_client\",\n+    hdrs = [\"pjrt_c_api_client.h\"],\n+    visibility = internal_visibility([\":friends\"]),\n+    deps = [\n+        \"//xla/pjrt/c_api_client:pjrt_c_api_client\",\n+    ],\n+)\n+\n cc_library(\n     name = \"event_pool\",\n     srcs = [\"event_pool.cc\"],\n@@ -935,114 +944,6 @@ xla_cc_test(\n     ],\n )\n \n-cc_library(\n-    name = \"pjrt_c_api_client\",\n-    srcs = [\"pjrt_c_api_client.cc\"],\n-    hdrs = [\"pjrt_c_api_client.h\"],\n-    visibility = internal_visibility([\":friends\"]),\n-    deps = [\n-        \":mlir_to_hlo\",\n-        \":pjrt_api\",\n-        \":pjrt_client\",\n-        \":pjrt_common\",\n-        \":pjrt_compiler\",\n-        \":pjrt_device_description\",\n-        \":pjrt_executable\",\n-        \":pjrt_future\",\n-        \":pjrt_layout\",\n-        \"//xla:future\",\n-        \"//xla:literal\",\n-        \"//xla:shape_util\",\n-        \"//xla:util\",\n-        \"//xla:xla_data_proto_cc\",\n-        \"//xla:xla_proto_cc\",\n-        \"//xla/ffi:execution_context\",\n-        \"//xla/hlo/builder:xla_computation\",\n-        \"//xla/hlo/ir:hlo\",\n-        \"//xla/hlo/translate/mhlo_to_hlo:mlir_hlo_to_hlo\",\n-        \"//xla/mlir_hlo:mhlo_passes\",\n-        \"//xla/pjrt/c:pjrt_c_api_ffi_extension_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_helpers\",\n-        \"//xla/pjrt/c:pjrt_c_api_layouts_extension_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_memory_descriptions_extension_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_profiler_extension_hdrs\",\n-        \"//xla/pjrt/c:pjrt_c_api_stream_extension_hdrs\",\n-        \"//xla/pjrt/distributed:key_value_store_interface\",\n-        \"//xla/pjrt/extensions/cross_host_transfers:pjrt_c_api_cross_host_transfer_extension\",\n-        \"//xla/pjrt/extensions/executable_metadata:executable_metadata_extension\",\n-        \"//xla/pjrt/extensions/host_allocator:host_allocator_extension\",\n-        \"//xla/pjrt/extensions/host_allocator:host_allocator_interface_impl\",\n-        \"//xla/pjrt/proto:compile_options_proto_cc\",\n-        \"//xla/pjrt/proto:topology_description_proto_cc\",\n-        \"//xla/service:computation_placer_hdr\",\n-        \"//xla/service:hlo_cost_analysis\",\n-        \"//xla/service:hlo_proto_cc\",\n-        \"//xla/tsl/framework:allocator\",\n-        \"//xla/tsl/platform:errors\",\n-        \"//xla/tsl/platform:status\",\n-        \"//xla/tsl/platform:statusor\",\n-        \"//xla/tsl/protobuf:coordination_service_proto_cc\",\n-        \"@com_google_absl//absl/cleanup\",\n-        \"@com_google_absl//absl/container:flat_hash_map\",\n-        \"@com_google_absl//absl/container:inlined_vector\",\n-        \"@com_google_absl//absl/functional:any_invocable\",\n-        \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n-        \"@com_google_absl//absl/strings:str_format\",\n-        \"@com_google_absl//absl/synchronization\",\n-        \"@com_google_absl//absl/types:span\",\n-        \"@llvm-project//llvm:Support\",\n-        \"@llvm-project//mlir:IR\",\n-        \"@llvm-project//mlir:Pass\",\n-        \"@llvm-project//mlir:Support\",\n-        \"@local_tsl//tsl/platform:casts\",\n-        \"@local_tsl//tsl/platform:fingerprint\",\n-    ],\n-)\n-\n-xla_cc_test(\n-    name = \"pjrt_c_api_client_test\",\n-    srcs = [\"pjrt_c_api_client_test.cc\"],\n-    tags = [\n-        \"nomsan\",\n-    ],\n-    deps = [\n-        \":mlir_to_hlo\",\n-        \":pjrt_api\",\n-        \":pjrt_c_api_client\",\n-        \":pjrt_client\",\n-        \":pjrt_compiler\",\n-        \":pjrt_device_description\",\n-        \":pjrt_executable\",\n-        \"//xla:literal\",\n-        \"//xla:literal_util\",\n-        \"//xla:shape_util\",\n-        \"//xla/backends/cpu:alignment\",\n-        \"//xla/ffi\",\n-        \"//xla/ffi:ffi_api\",\n-        \"//xla/hlo/builder:xla_builder\",\n-        \"//xla/hlo/builder:xla_computation\",\n-        \"//xla/hlo/parser:hlo_parser\",\n-        \"//xla/pjrt/c:pjrt_c_api_cpu_internal\",\n-        \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n-        \"//xla/service:computation_placer_hdr\",\n-        \"//xla/tests:literal_test_util\",\n-        \"//xla/tsl/lib/core:status_test_util\",\n-        \"//xla/tsl/platform:statusor\",\n-        \"//xla/tsl/platform:test\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/strings:str_format\",\n-        \"@com_google_absl//absl/types:span\",\n-        \"@com_google_googletest//:gtest_main\",\n-        \"@llvm-project//mlir:IR\",\n-        \"@stablehlo//:version\",\n-    ],\n-)\n-\n cc_library(\n     name = \"tf_pjrt_client\",\n     srcs = [\"tf_pjrt_client.cc\"],"
        },
        {
            "sha": "ebf3806131c41d1b677a97d6430aa2953167f66c",
            "filename": "third_party/xla/xla/pjrt/c_api_client/BUILD",
            "status": "added",
            "additions": 133,
            "deletions": 0,
            "changes": 133,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -0,0 +1,133 @@\n+load(\"//xla:xla.default.bzl\", \"xla_cc_test\")\n+load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\")\n+load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_library\")\n+\n+package(\n+    # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n+    default_visibility = internal_visibility([\"//xla:internal\"]),\n+    licenses = [\"notice\"],\n+)\n+\n+package_group(\n+    name = \"friends\",\n+    includes = [\n+        \"//xla:friends\",\n+        \"//xla:internal\",\n+    ],\n+    packages = [\n+        \"//tensorflow/core/tfrt/ifrt/...\",\n+        \"//third_party/australis/...\",\n+        \"//third_party/gxlang/...\",\n+        \"//third_party/openxla_pjrt_plugin/...\",\n+        \"//third_party/py/jax/...\",\n+        \"//third_party/torch_tpu/...\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"pjrt_c_api_client\",\n+    srcs = [\"pjrt_c_api_client.cc\"],\n+    hdrs = [\"pjrt_c_api_client.h\"],\n+    visibility = internal_visibility([\":friends\"]),\n+    deps = [\n+        \"//xla:future\",\n+        \"//xla:literal\",\n+        \"//xla:shape_util\",\n+        \"//xla:util\",\n+        \"//xla:xla_data_proto_cc\",\n+        \"//xla:xla_proto_cc\",\n+        \"//xla/ffi:execution_context\",\n+        \"//xla/hlo/builder:xla_computation\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/translate/mhlo_to_hlo:mlir_hlo_to_hlo\",\n+        \"//xla/mlir_hlo:mhlo_passes\",\n+        \"//xla/pjrt:mlir_to_hlo\",\n+        \"//xla/pjrt:pjrt_api\",\n+        \"//xla/pjrt:pjrt_client\",\n+        \"//xla/pjrt:pjrt_common\",\n+        \"//xla/pjrt:pjrt_compiler\",\n+        \"//xla/pjrt:pjrt_device_description\",\n+        \"//xla/pjrt:pjrt_executable\",\n+        \"//xla/pjrt:pjrt_future\",\n+        \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/pjrt/c:pjrt_c_api_ffi_extension_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_helpers\",\n+        \"//xla/pjrt/c:pjrt_c_api_layouts_extension_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_memory_descriptions_extension_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_profiler_extension_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_stream_extension_hdrs\",\n+        \"//xla/pjrt/distributed:key_value_store_interface\",\n+        \"//xla/pjrt/extensions/cross_host_transfers:pjrt_c_api_cross_host_transfer_extension\",\n+        \"//xla/pjrt/extensions/executable_metadata:executable_metadata_extension\",\n+        \"//xla/pjrt/extensions/host_allocator:host_allocator_extension\",\n+        \"//xla/pjrt/extensions/host_allocator:host_allocator_interface_impl\",\n+        \"//xla/pjrt/proto:compile_options_proto_cc\",\n+        \"//xla/pjrt/proto:topology_description_proto_cc\",\n+        \"//xla/service:computation_placer_hdr\",\n+        \"//xla/service:hlo_cost_analysis\",\n+        \"//xla/service:hlo_proto_cc\",\n+        \"//xla/tsl/framework:allocator\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:status\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/protobuf:coordination_service_proto_cc\",\n+        \"@com_google_absl//absl/cleanup\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/container:inlined_vector\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:IR\",\n+        \"@llvm-project//mlir:Pass\",\n+        \"@llvm-project//mlir:Support\",\n+        \"@local_tsl//tsl/platform:casts\",\n+        \"@local_tsl//tsl/platform:fingerprint\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"pjrt_c_api_client_test\",\n+    srcs = [\"pjrt_c_api_client_test.cc\"],\n+    tags = [\n+        \"nomsan\",\n+    ],\n+    deps = [\n+        \":pjrt_c_api_client\",\n+        \"//xla:literal\",\n+        \"//xla:literal_util\",\n+        \"//xla:shape_util\",\n+        \"//xla/backends/cpu:alignment\",\n+        \"//xla/ffi\",\n+        \"//xla/ffi:ffi_api\",\n+        \"//xla/hlo/builder:xla_builder\",\n+        \"//xla/hlo/builder:xla_computation\",\n+        \"//xla/hlo/parser:hlo_parser\",\n+        \"//xla/pjrt:mlir_to_hlo\",\n+        \"//xla/pjrt:pjrt_api\",\n+        \"//xla/pjrt:pjrt_client\",\n+        \"//xla/pjrt:pjrt_compiler\",\n+        \"//xla/pjrt:pjrt_device_description\",\n+        \"//xla/pjrt:pjrt_executable\",\n+        \"//xla/pjrt/c:pjrt_c_api_cpu_internal\",\n+        \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n+        \"//xla/service:computation_placer_hdr\",\n+        \"//xla/tests:literal_test_util\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//mlir:IR\",\n+        \"@stablehlo//:version\",\n+    ],\n+)"
        },
        {
            "sha": "f727e9b563d0f8783191b3216970db3ae9366256",
            "filename": "third_party/xla/xla/pjrt/c_api_client/README.md",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FREADME.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FREADME.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FREADME.md?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -0,0 +1,54 @@\n+# PJRT C API Client\n+\n+This directory contains the \"top sandwich\" of the PJRT C API. This is a\n+thick client wrapper that can be used to interface with plugins presenting\n+the PJRT C API.\n+\n+The primary purpose of the code in this folder is to provide a C++\n+object-oriented interface (`PjRtClient`, `PjRtDevice`, etc.) on top of the\n+purely C-style PJRT C API. This allows existing XLA/JAX code that uses the\n+`PjRt` C++ interface to interact with PJRT providers implemented as C API\n+plugins.\n+\n+The key classes implemented in this folder, wrapping the PJRT C API,\n+include:\n+\n+*   `PjRtCApiClient`: Implements the `PjRtClient` interface, serving as the\n+    main entry point for interacting with a PJRT C API plugin. It wraps the\n+    `PJRT_Client` structure.\n+*   `PjRtCApiDeviceDescription`: Implements `PjRtDeviceDescription`,\n+    wrapping the `PJRT_DeviceDescription` structure to provide details about\n+    a device.\n+*   `PjRtCApiDevice`: Implements `PjRtDevice`, representing a single device\n+    managed by the `PjRtCApiClient`. It wraps the `PJRT_Device` structure.\n+*   `PjRtCApiMemorySpace`: Implements `PjRtMemorySpace`, wrapping the\n+    `PJRT_Memory` structure to represent a memory space on a device.\n+*   `PjRtCApiExecutable`: Implements `PjRtExecutable`, representing a\n+    compiled but not yet loaded executable. It wraps the `PJRT_Executable`\n+    structure.\n+*   `PjRtCApiLoadedExecutable`: Implements `PjRtLoadedExecutable`,\n+    representing an executable loaded onto devices and ready for execution.\n+    It wraps the `PJRT_LoadedExecutable` structure.\n+*   `PjRtCApiBuffer`: Implements `PjRtBuffer`, representing a device buffer.\n+    It wraps the `PJRT_Buffer` structure. Internally, it uses `PJRT_Event`\n+    (wrapped by `pjrt::ConvertCEventToCppFuture`) to manage buffer\n+    readiness.\n+*   `PjRtCApiTopologyDescription`: Implements `PjRtTopologyDescription`,\n+    representing the device topology. It wraps the `PJRT_TopologyDescription`\n+    structure.\n+*   `PjRtCApiCompiler`: Implements `PjRtCompiler`, providing Ahead-of-Time\n+    (AOT) compilation capabilities by wrapping C API functions like\n+    `PJRT_Compile` and `PJRT_TopologyDescription_Deserialize`.\n+*   `PjRtCApiAsyncHostToDeviceTransferManager`: Implements\n+    `PjRtClient::AsyncHostToDeviceTransferManager`, wrapping the\n+    `PJRT_AsyncHostToDeviceTransferManager` structure for asynchronous\n+    host-to-device transfers.\n+*   `PjRtCApiExternalReference`: A helper class used by `PjRtCApiBuffer` to\n+    manage external reference counts on `PJRT_Buffer` objects.\n+*   `CApiCopyToDeviceStream`: Implements `CopyToDeviceStream`, wrapping the\n+    `PJRT_CopyToDeviceStream` structure used in receive callbacks for\n+    cross-host transfers.\n+\n+These `PjRtCApi*` and `CApi*` classes translate calls from the standard\n+XLA/JAX C++ `PjRt` interfaces into the corresponding C API function calls,\n+effectively acting as an adapter layer."
        },
        {
            "sha": "63a98fa89b924a97facac436c27e2fbc674ea1b2",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "renamed",
            "additions": 1,
            "deletions": 10,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -13,27 +13,21 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include \"xla/pjrt/pjrt_c_api_client.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_client.h\"\n \n #include <cstddef>\n #include <cstdint>\n #include <functional>\n #include <memory>\n #include <optional>\n-#include <string>\n-#include <utility>\n #include <variant>\n-#include <vector>\n \n #include \"absl/cleanup/cleanup.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/container/inlined_vector.h\"\n #include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n@@ -45,7 +39,6 @@ limitations under the License.\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/future.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n-#include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/translate/mhlo_to_hlo/mlir_hlo_to_hlo.h\"\n #include \"xla/layout.h\"\n #include \"xla/layout_util.h\"\n@@ -70,7 +63,6 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_device_description.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n-#include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/pjrt/proto/compile_options.pb.h\"\n #include \"xla/service/computation_placer.h\"\n@@ -82,7 +74,6 @@ limitations under the License.\n #include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/protobuf/coordination_service.pb.h\"\n-#include \"xla/util.h\"\n #include \"xla/xla.pb.h\"\n #include \"xla/xla_data.pb.h\"\n #include \"tsl/platform/casts.h\"",
            "previous_filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc"
        },
        {
            "sha": "02d52d3347e097d6973d197d4cb26175fd385b04",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.h",
            "status": "added",
            "additions": 814,
            "deletions": 0,
            "changes": 814,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -0,0 +1,814 @@\n+/* Copyright 2022 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PJRT_C_API_CLIENT_PJRT_C_API_CLIENT_H_\n+#define XLA_PJRT_C_API_CLIENT_PJRT_C_API_CLIENT_H_\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <functional>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <utility>\n+#include <variant>\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/inlined_vector.h\"\n+#include \"absl/functional/any_invocable.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/types/span.h\"\n+#include \"mlir/IR/BuiltinOps.h\"\n+#include \"xla/future.h\"\n+#include \"xla/hlo/builder/xla_computation.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/layout.h\"\n+#include \"xla/literal.h\"\n+#include \"xla/pjrt/c/pjrt_c_api.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n+#include \"xla/pjrt/distributed/key_value_store_interface.h\"\n+#include \"xla/pjrt/pjrt_client.h\"\n+#include \"xla/pjrt/pjrt_common.h\"\n+#include \"xla/pjrt/pjrt_compiler.h\"\n+#include \"xla/pjrt/pjrt_device_description.h\"\n+#include \"xla/pjrt/pjrt_executable.h\"\n+#include \"xla/pjrt/pjrt_future.h\"\n+#include \"xla/pjrt/pjrt_layout.h\"\n+#include \"xla/pjrt/proto/topology_description.pb.h\"\n+#include \"xla/service/computation_placer.h\"\n+#include \"xla/service/hlo_cost_analysis.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/tsl/framework/allocator.h\"\n+#include \"xla/tsl/protobuf/coordination_service.pb.h\"\n+#include \"xla/util.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla {\n+\n+class PjRtCApiClient;\n+\n+class PjRtCApiDeviceDescription : public PjRtDeviceDescription {\n+ public:\n+  PjRtCApiDeviceDescription(const PJRT_Api* c_api,\n+                            PJRT_DeviceDescription* device_description);\n+\n+  int id() const override;\n+\n+  int process_index() const override;\n+\n+  absl::string_view device_kind() const override;\n+\n+  absl::string_view DebugString() const override;\n+\n+  absl::string_view ToString() const override;\n+\n+  const absl::flat_hash_map<std::string, PjRtDeviceAttribute>& Attributes()\n+      const override;\n+\n+  absl::Span<const PjRtMemorySpaceDescription* const> memory_spaces()\n+      const override;\n+\n+  absl::StatusOr<const PjRtMemorySpaceDescription*> default_memory_space()\n+      const override;\n+\n+ private:\n+  const PJRT_Api* c_api_;\n+  // `device_description_` is owned by the `PJRT_Client` wrapped by `client_`\n+  PJRT_DeviceDescription* device_description_;\n+  // Device specific attributes with corresponding values.\n+  absl::flat_hash_map<std::string, xla::PjRtDeviceAttribute> attributes_;\n+  mutable std::vector<PjRtMemorySpaceDescription> memory_space_descriptions_;\n+  mutable std::vector<PjRtMemorySpaceDescription*>\n+      memory_space_description_pointers_;\n+  mutable absl::StatusOr<PjRtMemorySpaceDescription*>\n+      default_memory_space_description_;\n+\n+  // Initializes device specific attributes.\n+  void InitAttributes();\n+  // Initialize device specific memory descriptions.\n+  void InitMemoryDescriptions() const;\n+};\n+\n+class PjRtCApiMemorySpace : public PjRtMemorySpace {\n+ public:\n+  explicit PjRtCApiMemorySpace(PJRT_Memory* c_memory, PjRtCApiClient* client)\n+      : client_(client), c_memory_(c_memory) {}\n+\n+  PjRtClient* client() const override;\n+\n+  absl::Span<PjRtDevice* const> devices() const override { return devices_; }\n+\n+  int id() const override;\n+\n+  absl::string_view kind() const override;\n+  int kind_id() const override;\n+\n+  absl::string_view DebugString() const override;\n+\n+  absl::string_view ToString() const override;\n+\n+  const PJRT_Api* pjrt_c_api() const;\n+\n+  PJRT_Memory* c_memory() const { return c_memory_; }\n+\n+ private:\n+  friend class PjRtCApiClient;\n+\n+  PjRtCApiClient* client_;\n+  PJRT_Memory* c_memory_;\n+  std::vector<PjRtDevice*> devices_;\n+};\n+\n+class PjRtCApiDevice : public PjRtDevice {\n+ public:\n+  explicit PjRtCApiDevice(PJRT_Device* device, PjRtCApiClient* client);\n+\n+  PjRtClient* client() const override;\n+\n+  bool IsAddressable() const override;\n+\n+  PjRtLocalHardwareId local_hardware_id() const override;\n+\n+  absl::Status TransferToInfeed(const LiteralSlice& literal) override {\n+    return Unimplemented(\n+        \"PJRT C API does not support TransferToInfeed. Please report an issue \"\n+        \"at https://github.com/google/jax/issues if you need this feature.\");\n+  }\n+\n+  absl::Status TransferFromOutfeed(MutableBorrowingLiteral literal) override {\n+    return Unimplemented(\n+        \"PJRT C API does not support TransferFromOutfeed. Please report an \"\n+        \"issue at https://github.com/google/jax/issues if you need this \"\n+        \"feature.\");\n+  }\n+\n+  absl::Span<PjRtMemorySpace* const> memory_spaces() const override {\n+    return memory_spaces_;\n+  }\n+\n+  absl::StatusOr<PjRtMemorySpace*> default_memory_space() const override;\n+\n+  std::unique_ptr<ScopedAsyncTrackingEvent> CreateAsyncTrackingEvent(\n+      absl::string_view description) const override {\n+    LOG(FATAL)\n+        << \"PJRT C API does not support CreateAsyncTrackingEvent. Please \"\n+           \"report an issue at https://github.com/google/jax/issues if you \"\n+           \"need this feature.\";\n+    return nullptr;\n+  }\n+\n+  PJRT_Device* c_device() const { return device_; }\n+\n+  const PjRtCApiDeviceDescription& description() const override {\n+    return description_;\n+  }\n+\n+  absl::StatusOr<tsl::AllocatorStats> GetAllocatorStats() const override;\n+\n+  absl::StatusOr<std::intptr_t> GetStreamForExternalReadyEvents()\n+      const override;\n+\n+ private:\n+  friend class PjRtCApiClient;\n+\n+  PjRtCApiClient* client_ = nullptr;\n+  // `device_` is owned by the `PJRT_Client` wrapped by `client_`\n+  PJRT_Device* device_;\n+  PjRtCApiDeviceDescription description_;\n+  std::vector<PjRtMemorySpace*> memory_spaces_;\n+};\n+\n+class PjRtCApiCompiler : public PjRtCompiler {\n+ public:\n+  explicit PjRtCApiCompiler(const PJRT_Api* c_api) : c_api_(c_api) {}\n+\n+  absl::StatusOr<std::unique_ptr<PjRtExecutable>> Compile(\n+      CompileOptions options, const XlaComputation& computation,\n+      const PjRtTopologyDescription& topology, PjRtClient* client) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtExecutable>> Compile(\n+      CompileOptions options, mlir::ModuleOp module,\n+      const PjRtTopologyDescription& topology, PjRtClient* client) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>>\n+  DeserializePjRtTopologyDescription(\n+      const std::string& serialized_topology) override;\n+\n+ private:\n+  const PJRT_Api* c_api_;\n+};\n+\n+class PjRtCApiTopologyDescription : public PjRtTopologyDescription {\n+ public:\n+  // `owned` indicates whether this PjRtCApiTopologyDescription should take\n+  // ownership of `c_topology`, i.e., if owned is true,\n+  // PJRT_TopologyDescription_Destroy will be called on `c_topology` when this\n+  // PjRtCApiTopologyDescription is destroyed.\n+  PjRtCApiTopologyDescription(const PJRT_Api* c_api,\n+                              PJRT_TopologyDescription* c_topology, bool owned);\n+\n+  PjRtPlatformId platform_id() const override { return platform_id_; }\n+\n+  absl::string_view platform_name() const override { return platform_name_; }\n+\n+  absl::string_view platform_version() const override;\n+\n+  std::optional<PjRtCompiler*> compiler() const override {\n+    return compiler_.get();\n+  }\n+\n+  PJRT_TopologyDescription* c_topology() const { return c_topology_; }\n+\n+  std::vector<std::unique_ptr<const PjRtDeviceDescription>> DeviceDescriptions()\n+      const override;\n+\n+  absl::StatusOr<std::string> Serialize() const override;\n+\n+  // Returns vendor specific attributes about the topology.\n+  const absl::flat_hash_map<std::string, PjRtDeviceAttribute>& Attributes()\n+      const override {\n+    return attributes_;\n+  }\n+\n+  absl::StatusOr<Layout> GetDefaultLayout(\n+      PrimitiveType element_type,\n+      absl::Span<const int64_t> dims) const override;\n+\n+ private:\n+  std::unique_ptr<PjRtCApiCompiler> compiler_;\n+  const PJRT_Api* c_api_;\n+  // nullptr iff the PJRT_TopologyDescription isn't owned by this wrapper\n+  // (i.e. by the caller).\n+  std::unique_ptr<PJRT_TopologyDescription,\n+                  ::pjrt::PJRT_TopologyDescriptionDeleter>\n+      owned_c_topology_;\n+  PJRT_TopologyDescription* c_topology_;\n+  // Device specific attributes with corresponding values.\n+  absl::flat_hash_map<std::string, xla::PjRtDeviceAttribute> attributes_;\n+\n+  const std::string platform_name_;\n+  const PjRtPlatformId platform_id_;\n+\n+  // Initializes device specific attributes.\n+  void InitAttributes();\n+};\n+\n+class PjRtCApiClient : public PjRtClient {\n+ public:\n+  PjRtCApiClient(\n+      const PJRT_Api* c_api, PJRT_Client* c_client,\n+      std::unique_ptr<::pjrt::PJRT_KeyValueCallbackData> kv_callback_data);\n+\n+  int process_index() const override;\n+\n+  int device_count() const override;\n+  int addressable_device_count() const override;\n+\n+  absl::Span<PjRtDevice* const> devices() const override;\n+  absl::Span<PjRtDevice* const> addressable_devices() const override;\n+\n+  absl::StatusOr<PjRtDevice*> LookupDevice(\n+      PjRtGlobalDeviceId global_device_id) const override;\n+\n+  absl::StatusOr<PjRtDevice*> LookupAddressableDevice(\n+      PjRtLocalDeviceId local_device_id) const override;\n+\n+  void UpdateGlobalProcessInfo(\n+      absl::Span<tensorflow::CoordinatedTaskStateInfo> infos) override;\n+\n+  absl::Span<PjRtMemorySpace* const> memory_spaces() const override;\n+\n+  PjRtPlatformId platform_id() const override { return platform_id_; }\n+\n+  absl::string_view platform_name() const override { return platform_name_; };\n+\n+  absl::string_view platform_version() const override;\n+\n+  std::optional<PjRtPluginAttributes> plugin_attributes() const override;\n+\n+  absl::StatusOr<DeviceAssignment> GetDefaultDeviceAssignment(\n+      int num_replicas, int num_partitions) const override;\n+\n+  absl::StatusOr<std::unique_ptr<HloCostAnalysis>> GetHloCostAnalysis()\n+      const override {\n+    return Unimplemented(\n+        \"PJRT C API does not support GetHloCostAnalysis. Please report an \"\n+        \"issue at https://github.com/google/jax/issues if you need this \"\n+        \"feature.\");\n+  }\n+\n+  absl::StatusOr<Layout> GetDefaultLayout(\n+      PrimitiveType element_type, absl::Span<const int64_t> dims) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>> CompileAndLoad(\n+      const XlaComputation& computation, CompileOptions options) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>> CompileAndLoad(\n+      mlir::ModuleOp module, CompileOptions options) override;\n+\n+  // `PjRtCApiClient::LoadSerializedExecutable()` ignores `LoadOptions` arg\n+  absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>>\n+  LoadSerializedExecutable(absl::string_view serialized,\n+                           std::optional<CompileOptions> options,\n+                           const LoadOptions& load_options) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n+      const Shape& shape, PjRtMemorySpace* memory_space) override;\n+\n+  absl::StatusOr<\n+      std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+  CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) override;\n+\n+  absl::StatusOr<const PjRtTopologyDescription*> GetTopologyDescription()\n+      const override;\n+\n+  absl::StatusOr<HostAllocator*> GetHostAllocator() const override;\n+\n+  absl::StatusOr<std::unique_ptr<AsyncHostToDeviceTransferManager>>\n+  CreateBuffersForAsyncHostToDevice(\n+      absl::Span<const ShapeSpec> shape_specs,\n+      std::optional<absl::Span<const std::optional<Layout>>> device_layouts,\n+      PjRtMemorySpace* memory_space) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtBuffer>> BufferFromHostBuffer(\n+      const void* data, PrimitiveType type, absl::Span<int64_t const> dims,\n+      std::optional<absl::Span<int64_t const>> byte_strides,\n+      HostBufferSemantics host_buffer_semantics,\n+      absl::AnyInvocable<void() &&> on_done_with_host_buffer,\n+      PjRtMemorySpace* memory_space, const Layout* device_layout) override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtBuffer>> BufferFromHostLiteral(\n+      const LiteralSlice& literal, PjRtMemorySpace* memory_space,\n+      const Layout* device_layout) override {\n+    return Unimplemented(\n+        \"PJRT C API does not support BufferFromHostLiteral. Please report an \"\n+        \"issue at https://github.com/google/jax/issues if you need this \"\n+        \"feature.\");\n+  }\n+\n+  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateViewOfDeviceBuffer(\n+      void* device_ptr, const Shape& shape, PjRtMemorySpace* memory_space,\n+      std::function<void()> on_delete_callback,\n+      std::optional<std::intptr_t> stream) override;\n+\n+  absl::StatusOr<std::uintptr_t> UnsafeBufferPointer(\n+      PjRtBuffer* buffer) override;\n+\n+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n+  MakeCrossHostReceiveBuffers(absl::Span<const Shape> shapes,\n+                              PjRtDevice* device,\n+                              PjRtCrossHostRecvNotifier notifier) override;\n+\n+  absl::Status DmaMap(void* data, size_t size) override;\n+\n+  absl::Status DmaUnmap(void* data) override;\n+\n+  const PJRT_Api* pjrt_c_api() const;\n+\n+  PJRT_Client* pjrt_c_client() { return c_client_.get(); }\n+\n+  PjRtCApiDevice* GetCppDevice(PJRT_Device* c_device) const {\n+    auto it = c_to_cpp_device_map_.find(c_device);\n+    CHECK(it != c_to_cpp_device_map_.end());\n+    return it->second;\n+  }\n+\n+  PjRtCApiMemorySpace* GetCppMemory(PJRT_Memory* c_memory) const {\n+    auto it = c_to_cpp_memory_map_.find(c_memory);\n+    CHECK(it != c_to_cpp_memory_map_.end());\n+    return it->second;\n+  }\n+\n+  PjRtHostMemoryForDeviceManager* GetPjRtHostMemoryForDeviceManager()\n+      const override {\n+    return nullptr;\n+  }\n+\n+  using CrossHostRecvNotifierFunction =\n+      std::function<void(PJRT_Error*, const char**, size_t*, size_t)>;\n+\n+  template <typename ExtType>\n+  ExtType* FindExtension(PJRT_Extension_Type type) const {\n+    return reinterpret_cast<ExtType*>(FindExtensionImpl(type));  // NOLINT\n+  }\n+\n+ private:\n+  void InitDevicesAndMemorySpaces();\n+  void InitAttributes();\n+  PJRT_Extension_Base* FindExtensionImpl(PJRT_Extension_Type type) const;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtBuffer>> BufferFromHostBufferInternalImpl(\n+      const void* data, PrimitiveType type, absl::Span<int64_t const> dims,\n+      std::optional<absl::Span<int64_t const>> byte_strides,\n+      HostBufferSemantics host_buffer_semantics,\n+      absl::AnyInvocable<void() &&> on_done_with_host_buffer,\n+      std::variant<PjRtDevice*, PjRtMemorySpace*> device_or_memory,\n+      const Layout* device_layout);\n+\n+  const PJRT_Api* c_api_;\n+  std::unique_ptr<PJRT_Client, ::pjrt::PJRT_ClientDeleter> c_client_;\n+  std::unique_ptr<::pjrt::PJRT_KeyValueCallbackData> kv_callback_data_;\n+  std::vector<std::unique_ptr<PjRtCApiDevice>> owned_devices_;\n+  std::vector<PjRtDevice*> devices_;\n+  std::vector<PjRtDevice*> addressable_devices_;\n+  absl::flat_hash_map<PJRT_Device*, PjRtCApiDevice*> c_to_cpp_device_map_;\n+  std::vector<std::unique_ptr<PjRtCApiMemorySpace>> owned_memory_spaces_;\n+  std::vector<PjRtMemorySpace*> addressable_memory_spaces_;\n+  absl::flat_hash_map<PJRT_Memory*, PjRtCApiMemorySpace*> c_to_cpp_memory_map_;\n+  // There may be an error fetching the topology desc via the C API\n+  // (e.g. unimplemented). Save the error during client init so we can return it\n+  // from GetTopologyDescription().\n+  absl::StatusOr<const PjRtCApiTopologyDescription> topo_desc_;\n+  absl::flat_hash_map<PJRT_Extension_Type, PJRT_Extension_Base*> extensions_;\n+  // Not all PJRT C API implementations support the host allocator extension.\n+  absl::StatusOr<std::unique_ptr<PjRtClient::HostAllocator>> host_allocator_;\n+\n+  const std::string platform_version_;\n+  const std::string platform_name_;\n+  const PjRtPlatformId platform_id_;\n+  absl::flat_hash_map<std::string, xla::PjRtValueType> attributes_;\n+};\n+\n+class PjRtCApiBuffer : public PjRtBuffer {\n+ public:\n+  PjRtCApiBuffer(PjRtCApiClient* client, PJRT_Buffer* buffer);\n+\n+  PrimitiveType element_type() const override;\n+\n+  absl::Span<const int64_t> dimensions() const override;\n+\n+  std::shared_ptr<const PjRtLayout> layout() const override;\n+\n+  // PJRT C API doesn't support tuple buffers.\n+  bool IsTuple() const override { return false; }\n+\n+  const Shape& on_device_shape() const override;\n+\n+  bool has_dynamic_dimensions() const override;\n+\n+  absl::Span<const bool> is_dynamic_dimension() const override;\n+\n+  absl::StatusOr<std::vector<int64_t>> logical_dimensions() override;\n+\n+  absl::StatusOr<Shape> logical_on_device_shape() override;\n+\n+  PjRtMemorySpace* memory_space() const override;\n+\n+  PjRtDevice* device() const override;\n+\n+  PjRtClient* client() const override { return client_; }\n+\n+  absl::StatusOr<std::unique_ptr<ExternalReference>> AcquireExternalReference()\n+      override;\n+\n+  Future<> ToLiteral(MutableLiteralBase* literal) override;\n+  Future<> LazyToLiteral(\n+      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override;\n+\n+  absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n+\n+  Future<> CopyRawToHost(void* dst, int64_t offset,\n+                         int64_t transfer_size) override;\n+\n+  void Delete() override;\n+\n+  absl::StatusOr<std::unique_ptr<ExternalReference>>\n+  ReleaseDeviceMemoryOwnership(bool wait_for_operations_to_complete) override {\n+    return Unimplemented(\n+        \"PJRT C API does not support ReleaseDeviceMemoryOwnership\");\n+  }\n+\n+  bool IsDeleted() const override;\n+\n+  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n+      PjRtMemorySpace* dst_memory_space) override;\n+\n+  void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n+                          RemoteSendCallback on_done) override;\n+\n+  Future<> GetReadyFuture() override;\n+\n+  bool IsOnCpu() const override;\n+\n+  PJRT_Buffer* c_buffer() const { return buffer_.get(); }\n+\n+  const PJRT_Api* pjrt_c_api() const { return client_->pjrt_c_api(); }\n+\n+ private:\n+  // Gets the raw pointer to `readiness_event_`. If `readiness_event_` has not\n+  // yet been initialized, this function does so before returning the pointer.\n+  PJRT_Event* GetReadyEvent();\n+\n+  // `MakePromiseTrackEvent` sets `readiness_promise_` up to track\n+  // `readiness_event_`. This is used to implement `GetReadyFuture()`.\n+  // `readiness_promise_` should be created before calling this function.\n+  void MakePromiseTrackEvent();\n+\n+  PjRtCApiClient* client_;\n+  std::unique_ptr<PJRT_Buffer, ::pjrt::PJRT_BufferDeleter> buffer_;\n+  std::unique_ptr<PJRT_Event, ::pjrt::PJRT_EventDeleter> readiness_event_;\n+  // This is a shared_ptr to keep the underlying future alive even if\n+  // `readiness_promise` is destroyed before `readiness_event`, and the callback\n+  // we set on `readiness_event` modifies `readiness_promise_`.\n+  std::shared_ptr<Promise<>> readiness_promise_;\n+  // Future tied to the `readiness_promise_`.\n+  Future<> readiness_future_;\n+  // Set and cached the first time layout() is called.\n+  mutable std::shared_ptr<const PjRtLayout> layout_;\n+  // Set and cached the first time is_dynamic_dimension() is called.\n+  mutable std::optional<absl::InlinedVector<bool, InlineRank()>>\n+      is_dynamic_dimension_;\n+  // Used to synchronize concurrent setting of cached values.\n+  mutable absl::Mutex mu_;\n+  // Cached result of on_device_shape();\n+  mutable std::optional<Shape> on_device_shape_;\n+};\n+\n+class PjRtCApiExternalReference : public PjRtBuffer::ExternalReference {\n+ public:\n+  PjRtCApiExternalReference(PjRtCApiClient* client, PjRtCApiBuffer* buffer,\n+                            void* data_ptr)\n+      : client_(client), buffer_(buffer) {\n+    data_ptr_ = data_ptr;\n+  }\n+  ~PjRtCApiExternalReference() override;\n+\n+  absl::Status WaitUntilBufferReadyOnStream(std::intptr_t stream) override;\n+\n+ private:\n+  PjRtCApiClient* client_;\n+  PjRtCApiBuffer* buffer_;\n+};\n+\n+class PjRtCApiExecutable : public PjRtExecutable {\n+ public:\n+  PjRtCApiExecutable(const PJRT_Api* c_api, PJRT_Executable* executable);\n+\n+  absl::string_view name() const override;\n+  int num_replicas() const override;\n+  int num_partitions() const override;\n+\n+  int64_t SizeOfGeneratedCodeInBytes() const override;\n+\n+  absl::StatusOr<absl::flat_hash_map<std::string, PjRtValueType>>\n+  GetCostAnalysis() const override;\n+\n+  absl::StatusOr<std::vector<std::shared_ptr<HloModule>>> GetHloModules()\n+      const override;\n+\n+  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override {\n+    return pjrt::GetCompiledMemoryStats(c_api_, executable_.get());\n+  }\n+\n+  absl::StatusOr<std::vector<Shape>> GetOutputShapes() const override {\n+    LOG(FATAL) << \"PjRtExecutable::GetOutputShapes() not implemented in PJRT C \"\n+                  \"API. Please use PjRtExecutable::GetOutputElementTypes() or \"\n+                  \"PjRtExecutable::GetOutputDimensions().\";\n+  }\n+\n+  absl::StatusOr<std::vector<std::vector<PrimitiveType>>>\n+  GetOutputElementTypes() const override;\n+\n+  absl::StatusOr<std::vector<std::vector<DimensionVector>>>\n+  GetOutputDimensions() const override;\n+\n+  absl::StatusOr<std::vector<std::vector<absl::string_view>>>\n+  GetOutputMemoryKinds() const override;\n+\n+  const PJRT_Api* pjrt_c_api() const { return c_api_; }\n+  PJRT_Executable* c_executable() const { return executable_.get(); }\n+\n+  absl::StatusOr<std::string> SerializeExecutable() const override;\n+\n+  absl::StatusOr<std::string> FingerprintExecutable() const override;\n+\n+  // TODO(b/438000615): Move this to PjRtLoadedExecutable.\n+  absl::StatusOr<std::string> GetSerializedExecutableMetadata() const;\n+\n+ private:\n+  const PJRT_Api* c_api_;\n+  std::unique_ptr<PJRT_Executable, ::pjrt::PJRT_ExecutableDeleter> executable_;\n+};\n+\n+class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n+ public:\n+  PjRtCApiLoadedExecutable(PjRtCApiClient* client,\n+                           PJRT_LoadedExecutable* executable);\n+\n+  PjRtClient* client() const override { return client_; }\n+  absl::string_view name() const override { return executable_->name(); }\n+  int num_replicas() const override { return executable_->num_replicas(); }\n+  int num_partitions() const override { return executable_->num_partitions(); }\n+\n+  int64_t SizeOfGeneratedCodeInBytes() const override {\n+    return executable_->SizeOfGeneratedCodeInBytes();\n+  }\n+\n+  absl::StatusOr<absl::flat_hash_map<std::string, PjRtValueType>>\n+  GetCostAnalysis() const override {\n+    return executable_->GetCostAnalysis();\n+  }\n+\n+  const DeviceAssignment& device_assignment() const override {\n+    CHECK(device_assignment_ != nullptr)\n+        << \"device_assignment_ is a nullptr. This is likely because \"\n+           \"PjRtCApiLoadedExecutable::device_assignment() was called on a \"\n+           \"portable executable, which does not have a device assignment.\";\n+    return *device_assignment_;\n+  }\n+\n+  absl::Span<const LogicalDeviceIds> addressable_device_logical_ids()\n+      const override {\n+    CHECK(false)\n+        << \"PJRT C API does not support addressable_device_logical_ids\";\n+  }\n+\n+  absl::Span<PjRtDevice* const> addressable_devices() const override {\n+    return addressable_devices_;\n+  }\n+\n+  absl::StatusOr<std::vector<std::shared_ptr<HloModule>>> GetHloModules()\n+      const override {\n+    return executable_->GetHloModules();\n+  }\n+\n+  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override {\n+    return executable_->GetCompiledMemoryStats();\n+  }\n+\n+  absl::StatusOr<std::vector<Shape>> GetOutputShapes() const override {\n+    LOG(FATAL)\n+        << \"PjRtLoadedExecutable::GetOutputShapes() not implemented in PJRT C \"\n+           \"API. Please use PjRtLoadedExecutable::GetOutputElementTypes() or \"\n+           \"PjRtLoadedExecutable::GetOutputDimensions().\";\n+  }\n+\n+  absl::StatusOr<std::vector<std::vector<PrimitiveType>>>\n+  GetOutputElementTypes() const override {\n+    return executable_->GetOutputElementTypes();\n+  }\n+\n+  absl::StatusOr<std::vector<std::vector<DimensionVector>>>\n+  GetOutputDimensions() const override {\n+    return executable_->GetOutputDimensions();\n+  }\n+\n+  absl::StatusOr<std::vector<std::vector<absl::string_view>>>\n+  GetOutputMemoryKinds() const override {\n+    return executable_->GetOutputMemoryKinds();\n+  }\n+\n+  absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(\n+      absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n+      const ExecuteOptions& options,\n+      std::optional<std::vector<Future<>>>& returned_futures) const override;\n+\n+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n+      absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n+      bool fill_future) const override;\n+\n+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n+      absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n+      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n+      bool fill_future) const override;\n+\n+  void Delete() override;\n+  bool IsDeleted() const override;\n+\n+  absl::StatusOr<std::string> SerializeExecutable() const override {\n+    return executable_->SerializeExecutable();\n+  }\n+\n+  const PJRT_Api* pjrt_c_api() const { return client_->pjrt_c_api(); }\n+  PJRT_Executable* c_executable() const { return executable_->c_executable(); }\n+\n+  PJRT_LoadedExecutable* c_loaded_executable() const {\n+    return loaded_executable_.get();\n+  }\n+\n+  // std::function version of PJRT_SendCallback\n+  using SendCallbackFunction = std::function<PJRT_Error*(\n+      PJRT_Chunk*, PJRT_CallbackError*, size_t, bool)>;\n+  // std::function version of PJRT_RecvCallback\n+  using RecvCallbackFunction = std::function<void(PJRT_CopyToDeviceStream*)>;\n+\n+  // Override to call FingerprintExecutable through the wrapped\n+  // PjRtCApiExecutable.\n+  absl::StatusOr<std::string> FingerprintExecutable() const override;\n+\n+ private:\n+  // Groups data needed to support send/recv execution callbacks.\n+  struct SendRecvCallbackData {\n+    std::vector<std::vector<PJRT_SendCallbackInfo>> c_send_callbacks;\n+    std::vector<PJRT_SendCallbackInfo*> c_send_callback_lists;\n+    std::vector<std::vector<PJRT_RecvCallbackInfo>> c_recv_callbacks;\n+    std::vector<PJRT_RecvCallbackInfo*> c_recv_callback_lists;\n+    std::vector<SendCallbackFunction> send_callback_functions;\n+    std::vector<RecvCallbackFunction> recv_callback_functions;\n+  };\n+\n+  // Returns the number of outputs of the executable.\n+  absl::StatusOr<size_t> GetNumOutputs() const;\n+\n+  // Allocates memory for the `Execute` output.\n+  // These functions are a little verbose, but allocating the correct amount of\n+  // memory on initialization (thus avoiding `resize` calls) provides a\n+  // significant performance optimization.\n+  absl::StatusOr<std::vector<std::vector<PJRT_Buffer*>>>\n+  InitializeOutputListsStorage(size_t outer_size) const;\n+  absl::StatusOr<std::vector<PJRT_Buffer**>> InitializeOutputLists(\n+      std::vector<std::vector<PJRT_Buffer*>>& c_output_lists_storage) const;\n+\n+  // Gets common Execute_Args for use in various Execute* functions.\n+  // device_complete_events in the return is set if the input\n+  // device_complete_events has value.\n+  absl::StatusOr<PJRT_LoadedExecutable_Execute_Args> GetCommonExecuteArgs(\n+      absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n+      const ExecuteOptions& options, PJRT_ExecuteOptions& c_options,\n+      std::vector<std::vector<PJRT_Buffer*>>& c_argument_lists_storage,\n+      std::vector<PJRT_Buffer**>& c_arguments,\n+      std::optional<std::vector<PJRT_Event*>>& device_complete_events,\n+      SendRecvCallbackData& send_recv_callback_data,\n+      std::vector<int64_t>& non_donatable_input_indices_storage,\n+      std::vector<int>& task_ids_storage,\n+      std::vector<int64_t>& incarnation_ids_storage) const;\n+\n+  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n+  ExecuteWithSingleDevice(absl::Span<PjRtBuffer* const> argument_handles,\n+                          PjRtDevice* device, const ExecuteOptions& options,\n+                          std::optional<Future<>>& returned_future,\n+                          bool fill_future) const;\n+\n+  PjRtCApiClient* client_;\n+  std::unique_ptr<PJRT_LoadedExecutable, ::pjrt::PJRT_LoadedExecutableDeleter>\n+      loaded_executable_;\n+  std::unique_ptr<PjRtCApiExecutable> executable_;\n+  std::vector<PjRtDevice*> addressable_devices_;\n+  std::unique_ptr<const DeviceAssignment> device_assignment_;\n+\n+  void InitDevices();\n+  void InitDeviceAssignment();\n+};\n+\n+class CApiCopyToDeviceStream : public CopyToDeviceStream {\n+ public:\n+  CApiCopyToDeviceStream(PJRT_CopyToDeviceStream* c_stream,\n+                         const PJRT_Api* c_api);\n+  ~CApiCopyToDeviceStream() override;\n+\n+  Future<> AddChunk(PjRtChunk chunk) override;\n+\n+ private:\n+  PJRT_CopyToDeviceStream* c_stream_;\n+  const PJRT_Api* c_api_;\n+};\n+\n+absl::StatusOr<std::unique_ptr<PjRtClient>> GetCApiClient(\n+    absl::string_view device_type,\n+    const absl::flat_hash_map<std::string, PjRtValueType>& create_options = {},\n+    std::shared_ptr<KeyValueStoreInterface> kv_store = nullptr);\n+\n+absl::StatusOr<std::unique_ptr<PjRtClient>> WrapClientAroundCApi(\n+    const PJRT_Api* c_api,\n+    const absl::flat_hash_map<std::string, PjRtValueType>& create_options = {},\n+    std::shared_ptr<KeyValueStoreInterface> kv_store = nullptr);\n+\n+absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>> GetCApiTopology(\n+    const PJRT_Api* c_api, absl::string_view topology_name,\n+    const absl::flat_hash_map<std::string, PjRtValueType>& create_options);\n+\n+// A variant that takes `device_type` as an input, used for plugins that are not\n+// registered with standard way (xla_bridge.register_plugin).\n+// TODO(b/322357665): Delete this method after TPU plugin changes to use the\n+// standard registration.\n+absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>> GetCApiTopology(\n+    absl::string_view device_type, absl::string_view topology_name,\n+    const absl::flat_hash_map<std::string, PjRtValueType>& create_options = {});\n+\n+absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler(\n+    absl::string_view device_type);\n+\n+absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler();\n+\n+}  // namespace xla\n+\n+#endif  // XLA_PJRT_C_API_CLIENT_PJRT_C_API_CLIENT_H_"
        },
        {
            "sha": "21eb1b686a77c0c45da69f24708ffbde50b1ddde",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client_test.cc",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -12,7 +12,7 @@ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n-#include \"xla/pjrt/pjrt_c_api_client.h\"\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_client.h\"\n \n #include <unistd.h>\n ",
            "previous_filename": "third_party/xla/xla/pjrt/pjrt_c_api_client_test.cc"
        },
        {
            "sha": "e89d8fc6d6db9ce4b2bcf8c87e8b04ead7d15ca3",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 2,
            "deletions": 796,
            "changes": 798,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/52bf968be54f45d93d598a146a3e50b43e80bb44/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=52bf968be54f45d93d598a146a3e50b43e80bb44",
            "patch": "@@ -1,4 +1,4 @@\n-/* Copyright 2022 The OpenXLA Authors.\n+/* Copyright 2025 The OpenXLA Authors.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n@@ -16,800 +16,6 @@ limitations under the License.\n #ifndef XLA_PJRT_PJRT_C_API_CLIENT_H_\n #define XLA_PJRT_PJRT_C_API_CLIENT_H_\n \n-#include <cstddef>\n-#include <cstdint>\n-#include <functional>\n-#include <memory>\n-#include <optional>\n-#include <string>\n-#include <utility>\n-#include <variant>\n-#include <vector>\n-\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/container/inlined_vector.h\"\n-#include \"absl/functional/any_invocable.h\"\n-#include \"absl/log/check.h\"\n-#include \"absl/log/log.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"absl/synchronization/mutex.h\"\n-#include \"absl/types/span.h\"\n-#include \"mlir/IR/BuiltinOps.h\"\n-#include \"xla/future.h\"\n-#include \"xla/hlo/builder/xla_computation.h\"\n-#include \"xla/hlo/ir/hlo_module.h\"\n-#include \"xla/layout.h\"\n-#include \"xla/literal.h\"\n-#include \"xla/pjrt/c/pjrt_c_api.h\"\n-#include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n-#include \"xla/pjrt/distributed/key_value_store_interface.h\"\n-#include \"xla/pjrt/extensions/host_allocator/host_allocator_interface_impl.h\"\n-#include \"xla/pjrt/pjrt_client.h\"\n-#include \"xla/pjrt/pjrt_common.h\"\n-#include \"xla/pjrt/pjrt_compiler.h\"\n-#include \"xla/pjrt/pjrt_device_description.h\"\n-#include \"xla/pjrt/pjrt_executable.h\"\n-#include \"xla/pjrt/pjrt_future.h\"\n-#include \"xla/pjrt/pjrt_layout.h\"\n-#include \"xla/pjrt/proto/topology_description.pb.h\"\n-#include \"xla/service/computation_placer.h\"\n-#include \"xla/service/hlo_cost_analysis.h\"\n-#include \"xla/shape.h\"\n-#include \"xla/tsl/framework/allocator.h\"\n-#include \"xla/tsl/protobuf/coordination_service.pb.h\"\n-#include \"xla/util.h\"\n-#include \"xla/xla_data.pb.h\"\n-\n-namespace xla {\n-\n-class PjRtCApiClient;\n-\n-class PjRtCApiDeviceDescription : public PjRtDeviceDescription {\n- public:\n-  PjRtCApiDeviceDescription(const PJRT_Api* c_api,\n-                            PJRT_DeviceDescription* device_description);\n-\n-  int id() const override;\n-\n-  int process_index() const override;\n-\n-  absl::string_view device_kind() const override;\n-\n-  absl::string_view DebugString() const override;\n-\n-  absl::string_view ToString() const override;\n-\n-  const absl::flat_hash_map<std::string, PjRtDeviceAttribute>& Attributes()\n-      const override;\n-\n-  absl::Span<const PjRtMemorySpaceDescription* const> memory_spaces()\n-      const override;\n-\n-  absl::StatusOr<const PjRtMemorySpaceDescription*> default_memory_space()\n-      const override;\n-\n- private:\n-  const PJRT_Api* c_api_;\n-  // `device_description_` is owned by the `PJRT_Client` wrapped by `client_`\n-  PJRT_DeviceDescription* device_description_;\n-  // Device specific attributes with corresponding values.\n-  absl::flat_hash_map<std::string, xla::PjRtDeviceAttribute> attributes_;\n-  mutable std::vector<PjRtMemorySpaceDescription> memory_space_descriptions_;\n-  mutable std::vector<PjRtMemorySpaceDescription*>\n-      memory_space_description_pointers_;\n-  mutable absl::StatusOr<PjRtMemorySpaceDescription*>\n-      default_memory_space_description_;\n-\n-  // Initializes device specific attributes.\n-  void InitAttributes();\n-  // Initialize device specific memory descriptions.\n-  void InitMemoryDescriptions() const;\n-};\n-\n-class PjRtCApiMemorySpace : public PjRtMemorySpace {\n- public:\n-  explicit PjRtCApiMemorySpace(PJRT_Memory* c_memory, PjRtCApiClient* client)\n-      : client_(client), c_memory_(c_memory) {}\n-\n-  PjRtClient* client() const override;\n-\n-  absl::Span<PjRtDevice* const> devices() const override { return devices_; }\n-\n-  int id() const override;\n-\n-  absl::string_view kind() const override;\n-  int kind_id() const override;\n-\n-  absl::string_view DebugString() const override;\n-\n-  absl::string_view ToString() const override;\n-\n-  const PJRT_Api* pjrt_c_api() const;\n-\n-  PJRT_Memory* c_memory() const { return c_memory_; }\n-\n- private:\n-  friend class PjRtCApiClient;\n-\n-  PjRtCApiClient* client_;\n-  PJRT_Memory* c_memory_;\n-  std::vector<PjRtDevice*> devices_;\n-};\n-\n-class PjRtCApiDevice : public PjRtDevice {\n- public:\n-  explicit PjRtCApiDevice(PJRT_Device* device, PjRtCApiClient* client);\n-\n-  PjRtClient* client() const override;\n-\n-  bool IsAddressable() const override;\n-\n-  PjRtLocalHardwareId local_hardware_id() const override;\n-\n-  absl::Status TransferToInfeed(const LiteralSlice& literal) override {\n-    return Unimplemented(\n-        \"PJRT C API does not support TransferToInfeed. Please report an issue \"\n-        \"at https://github.com/google/jax/issues if you need this feature.\");\n-  }\n-\n-  absl::Status TransferFromOutfeed(MutableBorrowingLiteral literal) override {\n-    return Unimplemented(\n-        \"PJRT C API does not support TransferFromOutfeed. Please report an \"\n-        \"issue at https://github.com/google/jax/issues if you need this \"\n-        \"feature.\");\n-  }\n-\n-  absl::Span<PjRtMemorySpace* const> memory_spaces() const override {\n-    return memory_spaces_;\n-  }\n-\n-  absl::StatusOr<PjRtMemorySpace*> default_memory_space() const override;\n-\n-  std::unique_ptr<ScopedAsyncTrackingEvent> CreateAsyncTrackingEvent(\n-      absl::string_view description) const override {\n-    LOG(FATAL)\n-        << \"PJRT C API does not support CreateAsyncTrackingEvent. Please \"\n-           \"report an issue at https://github.com/google/jax/issues if you \"\n-           \"need this feature.\";\n-    return nullptr;\n-  }\n-\n-  PJRT_Device* c_device() const { return device_; }\n-\n-  const PjRtCApiDeviceDescription& description() const override {\n-    return description_;\n-  }\n-\n-  absl::StatusOr<tsl::AllocatorStats> GetAllocatorStats() const override;\n-\n-  absl::StatusOr<std::intptr_t> GetStreamForExternalReadyEvents()\n-      const override;\n-\n- private:\n-  friend class PjRtCApiClient;\n-\n-  PjRtCApiClient* client_ = nullptr;\n-  // `device_` is owned by the `PJRT_Client` wrapped by `client_`\n-  PJRT_Device* device_;\n-  PjRtCApiDeviceDescription description_;\n-  std::vector<PjRtMemorySpace*> memory_spaces_;\n-};\n-\n-class PjRtCApiCompiler : public PjRtCompiler {\n- public:\n-  explicit PjRtCApiCompiler(const PJRT_Api* c_api) : c_api_(c_api) {}\n-\n-  absl::StatusOr<std::unique_ptr<PjRtExecutable>> Compile(\n-      CompileOptions options, const XlaComputation& computation,\n-      const PjRtTopologyDescription& topology, PjRtClient* client) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtExecutable>> Compile(\n-      CompileOptions options, mlir::ModuleOp module,\n-      const PjRtTopologyDescription& topology, PjRtClient* client) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>>\n-  DeserializePjRtTopologyDescription(\n-      const std::string& serialized_topology) override;\n-\n- private:\n-  const PJRT_Api* c_api_;\n-};\n-\n-class PjRtCApiTopologyDescription : public PjRtTopologyDescription {\n- public:\n-  // `owned` indicates whether this PjRtCApiTopologyDescription should take\n-  // ownership of `c_topology`, i.e., if owned is true,\n-  // PJRT_TopologyDescription_Destroy will be called on `c_topology` when this\n-  // PjRtCApiTopologyDescription is destroyed.\n-  PjRtCApiTopologyDescription(const PJRT_Api* c_api,\n-                              PJRT_TopologyDescription* c_topology, bool owned);\n-\n-  PjRtPlatformId platform_id() const override { return platform_id_; }\n-\n-  absl::string_view platform_name() const override { return platform_name_; }\n-\n-  absl::string_view platform_version() const override;\n-\n-  std::optional<PjRtCompiler*> compiler() const override {\n-    return compiler_.get();\n-  }\n-\n-  PJRT_TopologyDescription* c_topology() const { return c_topology_; }\n-\n-  std::vector<std::unique_ptr<const PjRtDeviceDescription>> DeviceDescriptions()\n-      const override;\n-\n-  absl::StatusOr<std::string> Serialize() const override;\n-\n-  // Returns vendor specific attributes about the topology.\n-  const absl::flat_hash_map<std::string, PjRtDeviceAttribute>& Attributes()\n-      const override {\n-    return attributes_;\n-  }\n-\n-  absl::StatusOr<Layout> GetDefaultLayout(\n-      PrimitiveType element_type,\n-      absl::Span<const int64_t> dims) const override;\n-\n- private:\n-  std::unique_ptr<PjRtCApiCompiler> compiler_;\n-  const PJRT_Api* c_api_;\n-  // nullptr iff the PJRT_TopologyDescription isn't owned by this wrapper\n-  // (i.e. by the caller).\n-  std::unique_ptr<PJRT_TopologyDescription,\n-                  ::pjrt::PJRT_TopologyDescriptionDeleter>\n-      owned_c_topology_;\n-  PJRT_TopologyDescription* c_topology_;\n-  // Device specific attributes with corresponding values.\n-  absl::flat_hash_map<std::string, xla::PjRtDeviceAttribute> attributes_;\n-\n-  const std::string platform_name_;\n-  const PjRtPlatformId platform_id_;\n-\n-  // Initializes device specific attributes.\n-  void InitAttributes();\n-};\n-\n-class PjRtCApiClient : public PjRtClient {\n- public:\n-  PjRtCApiClient(\n-      const PJRT_Api* c_api, PJRT_Client* c_client,\n-      std::unique_ptr<::pjrt::PJRT_KeyValueCallbackData> kv_callback_data);\n-\n-  int process_index() const override;\n-\n-  int device_count() const override;\n-  int addressable_device_count() const override;\n-\n-  absl::Span<PjRtDevice* const> devices() const override;\n-  absl::Span<PjRtDevice* const> addressable_devices() const override;\n-\n-  absl::StatusOr<PjRtDevice*> LookupDevice(\n-      PjRtGlobalDeviceId global_device_id) const override;\n-\n-  absl::StatusOr<PjRtDevice*> LookupAddressableDevice(\n-      PjRtLocalDeviceId local_device_id) const override;\n-\n-  void UpdateGlobalProcessInfo(\n-      absl::Span<tensorflow::CoordinatedTaskStateInfo> infos) override;\n-\n-  absl::Span<PjRtMemorySpace* const> memory_spaces() const override;\n-\n-  PjRtPlatformId platform_id() const override { return platform_id_; }\n-\n-  absl::string_view platform_name() const override { return platform_name_; };\n-\n-  absl::string_view platform_version() const override;\n-\n-  std::optional<PjRtPluginAttributes> plugin_attributes() const override;\n-\n-  absl::StatusOr<DeviceAssignment> GetDefaultDeviceAssignment(\n-      int num_replicas, int num_partitions) const override;\n-\n-  absl::StatusOr<std::unique_ptr<HloCostAnalysis>> GetHloCostAnalysis()\n-      const override {\n-    return Unimplemented(\n-        \"PJRT C API does not support GetHloCostAnalysis. Please report an \"\n-        \"issue at https://github.com/google/jax/issues if you need this \"\n-        \"feature.\");\n-  }\n-\n-  absl::StatusOr<Layout> GetDefaultLayout(\n-      PrimitiveType element_type, absl::Span<const int64_t> dims) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>> CompileAndLoad(\n-      const XlaComputation& computation, CompileOptions options) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>> CompileAndLoad(\n-      mlir::ModuleOp module, CompileOptions options) override;\n-\n-  // `PjRtCApiClient::LoadSerializedExecutable()` ignores `LoadOptions` arg\n-  absl::StatusOr<std::unique_ptr<PjRtLoadedExecutable>>\n-  LoadSerializedExecutable(absl::string_view serialized,\n-                           std::optional<CompileOptions> options,\n-                           const LoadOptions& load_options) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n-      const Shape& shape, PjRtMemorySpace* memory_space) override;\n-\n-  absl::StatusOr<\n-      std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n-  CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) override;\n-\n-  absl::StatusOr<const PjRtTopologyDescription*> GetTopologyDescription()\n-      const override;\n-\n-  absl::StatusOr<HostAllocator*> GetHostAllocator() const override;\n-\n-  absl::StatusOr<std::unique_ptr<AsyncHostToDeviceTransferManager>>\n-  CreateBuffersForAsyncHostToDevice(\n-      absl::Span<const ShapeSpec> shape_specs,\n-      std::optional<absl::Span<const std::optional<Layout>>> device_layouts,\n-      PjRtMemorySpace* memory_space) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> BufferFromHostBuffer(\n-      const void* data, PrimitiveType type, absl::Span<int64_t const> dims,\n-      std::optional<absl::Span<int64_t const>> byte_strides,\n-      HostBufferSemantics host_buffer_semantics,\n-      absl::AnyInvocable<void() &&> on_done_with_host_buffer,\n-      PjRtMemorySpace* memory_space, const Layout* device_layout) override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> BufferFromHostLiteral(\n-      const LiteralSlice& literal, PjRtMemorySpace* memory_space,\n-      const Layout* device_layout) override {\n-    return Unimplemented(\n-        \"PJRT C API does not support BufferFromHostLiteral. Please report an \"\n-        \"issue at https://github.com/google/jax/issues if you need this \"\n-        \"feature.\");\n-  }\n-\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateViewOfDeviceBuffer(\n-      void* device_ptr, const Shape& shape, PjRtMemorySpace* memory_space,\n-      std::function<void()> on_delete_callback,\n-      std::optional<std::intptr_t> stream) override;\n-\n-  absl::StatusOr<std::uintptr_t> UnsafeBufferPointer(\n-      PjRtBuffer* buffer) override;\n-\n-  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n-  MakeCrossHostReceiveBuffers(absl::Span<const Shape> shapes,\n-                              PjRtDevice* device,\n-                              PjRtCrossHostRecvNotifier notifier) override;\n-\n-  absl::Status DmaMap(void* data, size_t size) override;\n-\n-  absl::Status DmaUnmap(void* data) override;\n-\n-  const PJRT_Api* pjrt_c_api() const;\n-\n-  PJRT_Client* pjrt_c_client() { return c_client_.get(); }\n-\n-  PjRtCApiDevice* GetCppDevice(PJRT_Device* c_device) const {\n-    auto it = c_to_cpp_device_map_.find(c_device);\n-    CHECK(it != c_to_cpp_device_map_.end());\n-    return it->second;\n-  }\n-\n-  PjRtCApiMemorySpace* GetCppMemory(PJRT_Memory* c_memory) const {\n-    auto it = c_to_cpp_memory_map_.find(c_memory);\n-    CHECK(it != c_to_cpp_memory_map_.end());\n-    return it->second;\n-  }\n-\n-  PjRtHostMemoryForDeviceManager* GetPjRtHostMemoryForDeviceManager()\n-      const override {\n-    return nullptr;\n-  }\n-\n-  using CrossHostRecvNotifierFunction =\n-      std::function<void(PJRT_Error*, const char**, size_t*, size_t)>;\n-\n-  template <typename ExtType>\n-  ExtType* FindExtension(PJRT_Extension_Type type) const {\n-    return reinterpret_cast<ExtType*>(FindExtensionImpl(type));  // NOLINT\n-  }\n-\n- private:\n-  void InitDevicesAndMemorySpaces();\n-  void InitAttributes();\n-  PJRT_Extension_Base* FindExtensionImpl(PJRT_Extension_Type type) const;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> BufferFromHostBufferInternalImpl(\n-      const void* data, PrimitiveType type, absl::Span<int64_t const> dims,\n-      std::optional<absl::Span<int64_t const>> byte_strides,\n-      HostBufferSemantics host_buffer_semantics,\n-      absl::AnyInvocable<void() &&> on_done_with_host_buffer,\n-      std::variant<PjRtDevice*, PjRtMemorySpace*> device_or_memory,\n-      const Layout* device_layout);\n-\n-  const PJRT_Api* c_api_;\n-  std::unique_ptr<PJRT_Client, ::pjrt::PJRT_ClientDeleter> c_client_;\n-  std::unique_ptr<::pjrt::PJRT_KeyValueCallbackData> kv_callback_data_;\n-  std::vector<std::unique_ptr<PjRtCApiDevice>> owned_devices_;\n-  std::vector<PjRtDevice*> devices_;\n-  std::vector<PjRtDevice*> addressable_devices_;\n-  absl::flat_hash_map<PJRT_Device*, PjRtCApiDevice*> c_to_cpp_device_map_;\n-  std::vector<std::unique_ptr<PjRtCApiMemorySpace>> owned_memory_spaces_;\n-  std::vector<PjRtMemorySpace*> addressable_memory_spaces_;\n-  absl::flat_hash_map<PJRT_Memory*, PjRtCApiMemorySpace*> c_to_cpp_memory_map_;\n-  // There may be an error fetching the topology desc via the C API\n-  // (e.g. unimplemented). Save the error during client init so we can return it\n-  // from GetTopologyDescription().\n-  absl::StatusOr<const PjRtCApiTopologyDescription> topo_desc_;\n-  absl::flat_hash_map<PJRT_Extension_Type, PJRT_Extension_Base*> extensions_;\n-  // Not all PJRT C API implementations support the host allocator extension.\n-  absl::StatusOr<std::unique_ptr<PjRtClient::HostAllocator>> host_allocator_;\n-\n-  const std::string platform_version_;\n-  const std::string platform_name_;\n-  const PjRtPlatformId platform_id_;\n-  absl::flat_hash_map<std::string, xla::PjRtValueType> attributes_;\n-};\n-\n-class PjRtCApiBuffer : public PjRtBuffer {\n- public:\n-  PjRtCApiBuffer(PjRtCApiClient* client, PJRT_Buffer* buffer);\n-\n-  PrimitiveType element_type() const override;\n-\n-  absl::Span<const int64_t> dimensions() const override;\n-\n-  std::shared_ptr<const PjRtLayout> layout() const override;\n-\n-  // PJRT C API doesn't support tuple buffers.\n-  bool IsTuple() const override { return false; }\n-\n-  const Shape& on_device_shape() const override;\n-\n-  bool has_dynamic_dimensions() const override;\n-\n-  absl::Span<const bool> is_dynamic_dimension() const override;\n-\n-  absl::StatusOr<std::vector<int64_t>> logical_dimensions() override;\n-\n-  absl::StatusOr<Shape> logical_on_device_shape() override;\n-\n-  PjRtMemorySpace* memory_space() const override;\n-\n-  PjRtDevice* device() const override;\n-\n-  PjRtClient* client() const override { return client_; }\n-\n-  absl::StatusOr<std::unique_ptr<ExternalReference>> AcquireExternalReference()\n-      override;\n-\n-  Future<> ToLiteral(MutableLiteralBase* literal) override;\n-  Future<> LazyToLiteral(\n-      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override;\n-\n-  absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n-\n-  Future<> CopyRawToHost(void* dst, int64_t offset,\n-                         int64_t transfer_size) override;\n-\n-  void Delete() override;\n-\n-  absl::StatusOr<std::unique_ptr<ExternalReference>>\n-  ReleaseDeviceMemoryOwnership(bool wait_for_operations_to_complete) override {\n-    return Unimplemented(\n-        \"PJRT C API does not support ReleaseDeviceMemoryOwnership\");\n-  }\n-\n-  bool IsDeleted() const override;\n-\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToMemorySpace(\n-      PjRtMemorySpace* dst_memory_space) override;\n-\n-  void CopyToRemoteDevice(Future<std::string> serialized_descriptor,\n-                          RemoteSendCallback on_done) override;\n-\n-  Future<> GetReadyFuture() override;\n-\n-  bool IsOnCpu() const override;\n-\n-  PJRT_Buffer* c_buffer() const { return buffer_.get(); }\n-\n-  const PJRT_Api* pjrt_c_api() const { return client_->pjrt_c_api(); }\n-\n- private:\n-  // Gets the raw pointer to `readiness_event_`. If `readiness_event_` has not\n-  // yet been initialized, this function does so before returning the pointer.\n-  PJRT_Event* GetReadyEvent();\n-\n-  // `MakePromiseTrackEvent` sets `readiness_promise_` up to track\n-  // `readiness_event_`. This is used to implement `GetReadyFuture()`.\n-  // `readiness_promise_` should be created before calling this function.\n-  void MakePromiseTrackEvent();\n-\n-  PjRtCApiClient* client_;\n-  std::unique_ptr<PJRT_Buffer, ::pjrt::PJRT_BufferDeleter> buffer_;\n-  std::unique_ptr<PJRT_Event, ::pjrt::PJRT_EventDeleter> readiness_event_;\n-  // This is a shared_ptr to keep the underlying future alive even if\n-  // `readiness_promise` is destroyed before `readiness_event`, and the callback\n-  // we set on `readiness_event` modifies `readiness_promise_`.\n-  std::shared_ptr<Promise<>> readiness_promise_;\n-  // Future tied to the `readiness_promise_`.\n-  Future<> readiness_future_;\n-  // Set and cached the first time layout() is called.\n-  mutable std::shared_ptr<const PjRtLayout> layout_;\n-  // Set and cached the first time is_dynamic_dimension() is called.\n-  mutable std::optional<absl::InlinedVector<bool, InlineRank()>>\n-      is_dynamic_dimension_;\n-  // Used to synchronize concurrent setting of cached values.\n-  mutable absl::Mutex mu_;\n-  // Cached result of on_device_shape();\n-  mutable std::optional<Shape> on_device_shape_;\n-};\n-\n-class PjRtCApiExternalReference : public PjRtBuffer::ExternalReference {\n- public:\n-  PjRtCApiExternalReference(PjRtCApiClient* client, PjRtCApiBuffer* buffer,\n-                            void* data_ptr)\n-      : client_(client), buffer_(buffer) {\n-    data_ptr_ = data_ptr;\n-  }\n-  ~PjRtCApiExternalReference() override;\n-\n-  absl::Status WaitUntilBufferReadyOnStream(std::intptr_t stream) override;\n-\n- private:\n-  PjRtCApiClient* client_;\n-  PjRtCApiBuffer* buffer_;\n-};\n-\n-class PjRtCApiExecutable : public PjRtExecutable {\n- public:\n-  PjRtCApiExecutable(const PJRT_Api* c_api, PJRT_Executable* executable);\n-\n-  absl::string_view name() const override;\n-  int num_replicas() const override;\n-  int num_partitions() const override;\n-\n-  int64_t SizeOfGeneratedCodeInBytes() const override;\n-\n-  absl::StatusOr<absl::flat_hash_map<std::string, PjRtValueType>>\n-  GetCostAnalysis() const override;\n-\n-  absl::StatusOr<std::vector<std::shared_ptr<HloModule>>> GetHloModules()\n-      const override;\n-\n-  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override {\n-    return pjrt::GetCompiledMemoryStats(c_api_, executable_.get());\n-  }\n-\n-  absl::StatusOr<std::vector<Shape>> GetOutputShapes() const override {\n-    LOG(FATAL) << \"PjRtExecutable::GetOutputShapes() not implemented in PJRT C \"\n-                  \"API. Please use PjRtExecutable::GetOutputElementTypes() or \"\n-                  \"PjRtExecutable::GetOutputDimensions().\";\n-  }\n-\n-  absl::StatusOr<std::vector<std::vector<PrimitiveType>>>\n-  GetOutputElementTypes() const override;\n-\n-  absl::StatusOr<std::vector<std::vector<DimensionVector>>>\n-  GetOutputDimensions() const override;\n-\n-  absl::StatusOr<std::vector<std::vector<absl::string_view>>>\n-  GetOutputMemoryKinds() const override;\n-\n-  const PJRT_Api* pjrt_c_api() const { return c_api_; }\n-  PJRT_Executable* c_executable() const { return executable_.get(); }\n-\n-  absl::StatusOr<std::string> SerializeExecutable() const override;\n-\n-  absl::StatusOr<std::string> FingerprintExecutable() const override;\n-\n-  // TODO(b/438000615): Move this to PjRtLoadedExecutable.\n-  absl::StatusOr<std::string> GetSerializedExecutableMetadata() const;\n-\n- private:\n-  const PJRT_Api* c_api_;\n-  std::unique_ptr<PJRT_Executable, ::pjrt::PJRT_ExecutableDeleter> executable_;\n-};\n-\n-class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n- public:\n-  PjRtCApiLoadedExecutable(PjRtCApiClient* client,\n-                           PJRT_LoadedExecutable* executable);\n-\n-  PjRtClient* client() const override { return client_; }\n-  absl::string_view name() const override { return executable_->name(); }\n-  int num_replicas() const override { return executable_->num_replicas(); }\n-  int num_partitions() const override { return executable_->num_partitions(); }\n-\n-  int64_t SizeOfGeneratedCodeInBytes() const override {\n-    return executable_->SizeOfGeneratedCodeInBytes();\n-  }\n-\n-  absl::StatusOr<absl::flat_hash_map<std::string, PjRtValueType>>\n-  GetCostAnalysis() const override {\n-    return executable_->GetCostAnalysis();\n-  }\n-\n-  const DeviceAssignment& device_assignment() const override {\n-    CHECK(device_assignment_ != nullptr)\n-        << \"device_assignment_ is a nullptr. This is likely because \"\n-           \"PjRtCApiLoadedExecutable::device_assignment() was called on a \"\n-           \"portable executable, which does not have a device assignment.\";\n-    return *device_assignment_;\n-  }\n-\n-  absl::Span<const LogicalDeviceIds> addressable_device_logical_ids()\n-      const override {\n-    CHECK(false)\n-        << \"PJRT C API does not support addressable_device_logical_ids\";\n-  }\n-\n-  absl::Span<PjRtDevice* const> addressable_devices() const override {\n-    return addressable_devices_;\n-  }\n-\n-  absl::StatusOr<std::vector<std::shared_ptr<HloModule>>> GetHloModules()\n-      const override {\n-    return executable_->GetHloModules();\n-  }\n-\n-  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override {\n-    return executable_->GetCompiledMemoryStats();\n-  }\n-\n-  absl::StatusOr<std::vector<Shape>> GetOutputShapes() const override {\n-    LOG(FATAL)\n-        << \"PjRtLoadedExecutable::GetOutputShapes() not implemented in PJRT C \"\n-           \"API. Please use PjRtLoadedExecutable::GetOutputElementTypes() or \"\n-           \"PjRtLoadedExecutable::GetOutputDimensions().\";\n-  }\n-\n-  absl::StatusOr<std::vector<std::vector<PrimitiveType>>>\n-  GetOutputElementTypes() const override {\n-    return executable_->GetOutputElementTypes();\n-  }\n-\n-  absl::StatusOr<std::vector<std::vector<DimensionVector>>>\n-  GetOutputDimensions() const override {\n-    return executable_->GetOutputDimensions();\n-  }\n-\n-  absl::StatusOr<std::vector<std::vector<absl::string_view>>>\n-  GetOutputMemoryKinds() const override {\n-    return executable_->GetOutputMemoryKinds();\n-  }\n-\n-  absl::StatusOr<std::vector<std::vector<std::unique_ptr<PjRtBuffer>>>> Execute(\n-      absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n-      const ExecuteOptions& options,\n-      std::optional<std::vector<Future<>>>& returned_futures) const override;\n-\n-  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecuteSharded(\n-      absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n-      bool fill_future) const override;\n-\n-  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>> ExecutePortable(\n-      absl::Span<PjRtBuffer* const> argument_handles, PjRtDevice* device,\n-      const ExecuteOptions& options, std::optional<Future<>>& returned_future,\n-      bool fill_future) const override;\n-\n-  void Delete() override;\n-  bool IsDeleted() const override;\n-\n-  absl::StatusOr<std::string> SerializeExecutable() const override {\n-    return executable_->SerializeExecutable();\n-  }\n-\n-  const PJRT_Api* pjrt_c_api() const { return client_->pjrt_c_api(); }\n-  PJRT_Executable* c_executable() const { return executable_->c_executable(); }\n-\n-  PJRT_LoadedExecutable* c_loaded_executable() const {\n-    return loaded_executable_.get();\n-  }\n-\n-  // std::function version of PJRT_SendCallback\n-  using SendCallbackFunction = std::function<PJRT_Error*(\n-      PJRT_Chunk*, PJRT_CallbackError*, size_t, bool)>;\n-  // std::function version of PJRT_RecvCallback\n-  using RecvCallbackFunction = std::function<void(PJRT_CopyToDeviceStream*)>;\n-\n-  // Override to call FingerprintExecutable through the wrapped\n-  // PjRtCApiExecutable.\n-  absl::StatusOr<std::string> FingerprintExecutable() const override;\n-\n- private:\n-  // Groups data needed to support send/recv execution callbacks.\n-  struct SendRecvCallbackData {\n-    std::vector<std::vector<PJRT_SendCallbackInfo>> c_send_callbacks;\n-    std::vector<PJRT_SendCallbackInfo*> c_send_callback_lists;\n-    std::vector<std::vector<PJRT_RecvCallbackInfo>> c_recv_callbacks;\n-    std::vector<PJRT_RecvCallbackInfo*> c_recv_callback_lists;\n-    std::vector<SendCallbackFunction> send_callback_functions;\n-    std::vector<RecvCallbackFunction> recv_callback_functions;\n-  };\n-\n-  // Returns the number of outputs of the executable.\n-  absl::StatusOr<size_t> GetNumOutputs() const;\n-\n-  // Allocates memory for the `Execute` output.\n-  // These functions are a little verbose, but allocating the correct amount of\n-  // memory on initialization (thus avoiding `resize` calls) provides a\n-  // significant performance optimization.\n-  absl::StatusOr<std::vector<std::vector<PJRT_Buffer*>>>\n-  InitializeOutputListsStorage(size_t outer_size) const;\n-  absl::StatusOr<std::vector<PJRT_Buffer**>> InitializeOutputLists(\n-      std::vector<std::vector<PJRT_Buffer*>>& c_output_lists_storage) const;\n-\n-  // Gets common Execute_Args for use in various Execute* functions.\n-  // device_complete_events in the return is set if the input\n-  // device_complete_events has value.\n-  absl::StatusOr<PJRT_LoadedExecutable_Execute_Args> GetCommonExecuteArgs(\n-      absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n-      const ExecuteOptions& options, PJRT_ExecuteOptions& c_options,\n-      std::vector<std::vector<PJRT_Buffer*>>& c_argument_lists_storage,\n-      std::vector<PJRT_Buffer**>& c_arguments,\n-      std::optional<std::vector<PJRT_Event*>>& device_complete_events,\n-      SendRecvCallbackData& send_recv_callback_data,\n-      std::vector<int64_t>& non_donatable_input_indices_storage,\n-      std::vector<int>& task_ids_storage,\n-      std::vector<int64_t>& incarnation_ids_storage) const;\n-\n-  absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n-  ExecuteWithSingleDevice(absl::Span<PjRtBuffer* const> argument_handles,\n-                          PjRtDevice* device, const ExecuteOptions& options,\n-                          std::optional<Future<>>& returned_future,\n-                          bool fill_future) const;\n-\n-  PjRtCApiClient* client_;\n-  std::unique_ptr<PJRT_LoadedExecutable, ::pjrt::PJRT_LoadedExecutableDeleter>\n-      loaded_executable_;\n-  std::unique_ptr<PjRtCApiExecutable> executable_;\n-  std::vector<PjRtDevice*> addressable_devices_;\n-  std::unique_ptr<const DeviceAssignment> device_assignment_;\n-\n-  void InitDevices();\n-  void InitDeviceAssignment();\n-};\n-\n-class CApiCopyToDeviceStream : public CopyToDeviceStream {\n- public:\n-  CApiCopyToDeviceStream(PJRT_CopyToDeviceStream* c_stream,\n-                         const PJRT_Api* c_api);\n-  ~CApiCopyToDeviceStream() override;\n-\n-  Future<> AddChunk(PjRtChunk chunk) override;\n-\n- private:\n-  PJRT_CopyToDeviceStream* c_stream_;\n-  const PJRT_Api* c_api_;\n-};\n-\n-absl::StatusOr<std::unique_ptr<PjRtClient>> GetCApiClient(\n-    absl::string_view device_type,\n-    const absl::flat_hash_map<std::string, PjRtValueType>& create_options = {},\n-    std::shared_ptr<KeyValueStoreInterface> kv_store = nullptr);\n-\n-absl::StatusOr<std::unique_ptr<PjRtClient>> WrapClientAroundCApi(\n-    const PJRT_Api* c_api,\n-    const absl::flat_hash_map<std::string, PjRtValueType>& create_options = {},\n-    std::shared_ptr<KeyValueStoreInterface> kv_store = nullptr);\n-\n-absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>> GetCApiTopology(\n-    const PJRT_Api* c_api, absl::string_view topology_name,\n-    const absl::flat_hash_map<std::string, PjRtValueType>& create_options);\n-\n-// A variant that takes `device_type` as an input, used for plugins that are not\n-// registered with standard way (xla_bridge.register_plugin).\n-// TODO(b/322357665): Delete this method after TPU plugin changes to use the\n-// standard registration.\n-absl::StatusOr<std::unique_ptr<PjRtTopologyDescription>> GetCApiTopology(\n-    absl::string_view device_type, absl::string_view topology_name,\n-    const absl::flat_hash_map<std::string, PjRtValueType>& create_options = {});\n-\n-absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler(\n-    absl::string_view device_type);\n-\n-absl::StatusOr<std::unique_ptr<PjRtCompiler>> GetCApiCompiler();\n-\n-}  // namespace xla\n+#include \"xla/pjrt/c_api_client/pjrt_c_api_client.h\"\n \n #endif  // XLA_PJRT_PJRT_C_API_CLIENT_H_"
        }
    ],
    "stats": {
        "total": 1929,
        "additions": 1014,
        "deletions": 915
    }
}