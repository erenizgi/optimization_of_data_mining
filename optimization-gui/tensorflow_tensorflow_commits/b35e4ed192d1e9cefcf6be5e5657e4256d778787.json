{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Refactor][4/n] Update replica group classes to hide implementation details (via private/protected) to external callers.\n\nPiperOrigin-RevId: 846860541",
    "sha": "b35e4ed192d1e9cefcf6be5e5657e4256d778787",
    "files": [
        {
            "sha": "a06b50fd4f1eb40e86870c34824c15da3be68338",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.h",
            "status": "modified",
            "additions": 34,
            "deletions": 41,
            "changes": 75,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b35e4ed192d1e9cefcf6be5e5657e4256d778787/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b35e4ed192d1e9cefcf6be5e5657e4256d778787/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h?ref=b35e4ed192d1e9cefcf6be5e5657e4256d778787",
            "patch": "@@ -43,6 +43,8 @@ class CollectiveDeviceList;\n \n enum class CollectiveDeviceListVersion { kListOfLists, kIota, kMeshAxes };\n \n+// Base class providing the interface for all collective device list\n+// representations.\n class CollectiveDeviceListBase {\n  public:\n   virtual ~CollectiveDeviceListBase() = default;\n@@ -73,6 +75,7 @@ class CollectiveDeviceListBase {\n   }\n   virtual std::vector<std::vector<int64_t>> flattened_replica_groups()\n       const = 0;\n+\n   virtual const std::vector<ReplicaGroup>& replica_groups() const {\n     if (replica_groups_ != nullptr) {\n       return *replica_groups_;\n@@ -86,33 +89,30 @@ class CollectiveDeviceListBase {\n     }\n     return *replica_groups_;\n   };\n+\n   virtual void Print(Printer* printer) const = 0;\n   virtual void Print(Printer* printer,\n                      bool print_full_replica_group_list) const {\n-    return Print(printer);\n-  };\n+    Print(printer);\n+  }\n   virtual std::string ToString() const = 0;\n   virtual std::string ToString(bool print_full_replica_group_list) const {\n     return ToString();\n   };\n \n   virtual std::unique_ptr<CollectiveDeviceListBase> Clone() const = 0;\n-\n   virtual CollectiveDeviceListVersion version() const = 0;\n \n-  // shared_ptr for fast copy.\n-  mutable std::shared_ptr<std::vector<ReplicaGroup>> replica_groups_ = nullptr;\n-\n  protected:\n+  // Used by operator== to check equality of derived types.\n   virtual bool isEqual(const CollectiveDeviceListBase& other) const = 0;\n+\n+  // shared_ptr for fast copy and lazy materialization.\n+  mutable std::shared_ptr<std::vector<ReplicaGroup>> replica_groups_ = nullptr;\n };\n \n+// Compact representation using Mesh and Axis indices.\n class MeshAxesReplicaGroupList : public CollectiveDeviceListBase {\n-  struct ReshapeAndAggregateAxes {\n-    std::vector<int64_t> reshape_dims;\n-    std::vector<int64_t> aggregate_axes;\n-  };\n-\n  public:\n   explicit MeshAxesReplicaGroupList(Mesh mesh, std::vector<AxisRef> axes);\n \n@@ -125,49 +125,49 @@ class MeshAxesReplicaGroupList : public CollectiveDeviceListBase {\n     return H::combine(std::move(h), c.mesh_, c.axes_);\n   }\n \n+  // Overrides\n   int64_t num_replica_groups() const override;\n   int64_t num_devices_per_group() const override;\n   std::vector<std::vector<int64_t>> flattened_replica_groups() const override;\n   void Print(Printer* printer) const override;\n   std::string ToString() const override;\n   MeshAxesReplicaGroupListProto ToProto() const;\n+\n   std::unique_ptr<CollectiveDeviceListBase> Clone() const override {\n     return std::make_unique<MeshAxesReplicaGroupList>(*this);\n-  };\n+  }\n   CollectiveDeviceListVersion version() const override {\n     return CollectiveDeviceListVersion::kMeshAxes;\n   }\n \n+  // Conversion and Serialization\n   static MeshAxesReplicaGroupList FromProto(\n       const MeshAxesReplicaGroupListProto& proto);\n-\n-  // Methods for converting to V2 and V1 representations.\n   IotaReplicaGroupList ToIotaReplicaGroupList() const;\n   CollectiveDeviceList ToCollectiveDeviceList() const;\n \n  protected:\n   bool isEqual(const CollectiveDeviceListBase& other) const override {\n-    const MeshAxesReplicaGroupList& rhs =\n-        static_cast<const MeshAxesReplicaGroupList&>(other);\n-    return *this == rhs;\n+    return *this == static_cast<const MeshAxesReplicaGroupList&>(other);\n   }\n \n  private:\n+  struct ReshapeAndAggregateAxes {\n+    std::vector<int64_t> reshape_dims;\n+    std::vector<int64_t> aggregate_axes;\n+  };\n+\n+  // Internal helpers for computing device groups.\n   absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes>\n   GetDimToReshapeAndAggregateAxes() const;\n   std::pair<std::vector<int64_t>, std::vector<int64_t>> ComputeReindexedAxes()\n       const;\n+\n   Mesh mesh_;\n   std::vector<AxisRef> axes_;\n };\n \n-std::string ReplicaGroupsToString(\n-    absl::Span<const ReplicaGroup> replica_groups);\n-\n-// Represents a list of replica groups (a list of list of devices) with\n-// reshaping and transposing an iota array (iota tile assignment). Can be used\n-// to represent certain common patterns of device lists in a compact, scalable\n-// format.\n+// Representation using Iota patterns (reshaping/transposing linear ranges).\n class IotaReplicaGroupList : public CollectiveDeviceListBase {\n  public:\n   explicit IotaReplicaGroupList(int64_t num_replica_groups,\n@@ -213,24 +213,21 @@ class IotaReplicaGroupList : public CollectiveDeviceListBase {\n   std::vector<std::vector<int64_t>> flattened_replica_groups() const override;\n \n   void Print(Printer* printer) const override;\n-\n   std::string ToString() const override;\n+\n   std::unique_ptr<CollectiveDeviceListBase> Clone() const override {\n     return std::make_unique<IotaReplicaGroupList>(*this);\n-  };\n+  }\n   CollectiveDeviceListVersion version() const override {\n     return CollectiveDeviceListVersion::kIota;\n   }\n \n   IotaReplicaGroupListProto ToProto() const;\n-\n   static IotaReplicaGroupList FromProto(const IotaReplicaGroupListProto& proto);\n \n  protected:\n   bool isEqual(const CollectiveDeviceListBase& other) const override {\n-    const IotaReplicaGroupList& rhs =\n-        static_cast<const IotaReplicaGroupList&>(other);\n-    return *this == rhs;\n+    return *this == static_cast<const IotaReplicaGroupList&>(other);\n   }\n \n  private:\n@@ -239,9 +236,7 @@ class IotaReplicaGroupList : public CollectiveDeviceListBase {\n   int64_t num_devices_per_group_ = -1;\n };\n \n-// Represents a series of devices participating in a collective operation\n-// (all-gather, all-reduce, etc.). While this directly translates to a list of\n-// replica groups, it may be used to represent these lists in compact forms.\n+// Legacy/Explicit representation using an explicit list of ReplicaGroups.\n class CollectiveDeviceList : public CollectiveDeviceListBase {\n  public:\n   explicit CollectiveDeviceList() {\n@@ -263,7 +258,6 @@ class CollectiveDeviceList : public CollectiveDeviceListBase {\n     replica_groups_ = ToReplicaGroupVector(replica_groups);\n   };\n \n-  // Replica groups are materialized lazily upon first access.\n   explicit CollectiveDeviceList(\n       const IotaReplicaGroupList& iota_replica_group_list)\n       : iota_replica_group_list_(iota_replica_group_list) {}\n@@ -298,7 +292,7 @@ class CollectiveDeviceList : public CollectiveDeviceListBase {\n     return h;\n   }\n \n-  // Lazyly explands iota if applicable.\n+  // Overrides\n   const std::vector<ReplicaGroup>& replica_groups() const override;\n   std::vector<std::vector<int64_t>> flattened_replica_groups() const override;\n   const std::optional<IotaReplicaGroupList>& iota_replica_group_list() const {\n@@ -322,6 +316,7 @@ class CollectiveDeviceList : public CollectiveDeviceListBase {\n              bool print_full_replica_group_list) const override;\n   std::string ToString() const override;\n   std::string ToString(bool print_full_replica_group_list) const override;\n+\n   CollectiveDeviceListVersion version() const override {\n     if (iota_replica_group_list_.has_value()) {\n       return CollectiveDeviceListVersion::kIota;\n@@ -332,20 +327,17 @@ class CollectiveDeviceList : public CollectiveDeviceListBase {\n   CollectiveDeviceListProto ToProto() const;\n   static CollectiveDeviceList FromProto(const CollectiveDeviceListProto& proto);\n   static CollectiveDeviceList FromProto(const HloInstructionProto& proto);\n+\n   std::unique_ptr<CollectiveDeviceListBase> Clone() const override {\n     return std::make_unique<CollectiveDeviceList>(*this);\n   };\n \n  protected:\n   bool isEqual(const CollectiveDeviceListBase& other) const override {\n-    const CollectiveDeviceList& rhs =\n-        static_cast<const CollectiveDeviceList&>(other);\n-    return *this == rhs;\n+    return *this == static_cast<const CollectiveDeviceList&>(other);\n   }\n \n  private:\n-  // Construct collective device list from protobuf replica group start and end\n-  // iterators.\n   CollectiveDeviceList(\n       tsl::protobuf::RepeatedPtrField<ReplicaGroup>::const_iterator start,\n       tsl::protobuf::RepeatedPtrField<ReplicaGroup>::const_iterator end) {\n@@ -364,12 +356,13 @@ class CollectiveDeviceList : public CollectiveDeviceListBase {\n     return result;\n   }\n \n-  // Load replica groups from iota tile assignment if not already done so.\n   void MaybeMaterializeFullReplicaGroupList() const;\n \n   std::optional<IotaReplicaGroupList> iota_replica_group_list_;\n };\n \n+std::string ReplicaGroupsToString(\n+    absl::Span<const ReplicaGroup> replica_groups);\n CollectiveDeviceList ConvertToV1CollectiveDeviceList(\n     const CollectiveDeviceListBase& device_list);\n "
        }
    ],
    "stats": {
        "total": 75,
        "additions": 34,
        "deletions": 41
    }
}