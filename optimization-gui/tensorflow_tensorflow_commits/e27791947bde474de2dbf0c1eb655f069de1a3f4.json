{
    "author": "zvikinoza",
    "message": "HLO module linking\n\nImplements the linking logic using an iterative DFS traversal. Computations are processed in post-order to ensure callees are linked before their callers.\nStubs (placeholders for computations in other modules) are replaced by cloning their full implementation (\"principal\") based on information in HloLinkingManifest.\nThe implementation correctly handles cycles and shared computations (diamond dependencies) by tracking computations currently being linked and those already linked.\nHloCloneContext is used to manage the cloning process and map stubs to their linked counterparts.\n\nPiperOrigin-RevId: 833380472",
    "sha": "e27791947bde474de2dbf0c1eb655f069de1a3f4",
    "files": [
        {
            "sha": "be56adb2f4c5365eb8cd8c30ae76c591246a83e8",
            "filename": "third_party/xla/xla/hlo/separate_compilation/BUILD",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2FBUILD?ref=e27791947bde474de2dbf0c1eb655f069de1a3f4",
            "patch": "@@ -48,6 +48,28 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"hlo_module_linking\",\n+    srcs = [\"hlo_module_linking.cc\"],\n+    hdrs = [\"hlo_module_linking.h\"],\n+    deps = [\n+        \":hlo_linking_manifest\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/transforms/simplifiers:hlo_dce\",\n+        \"//xla/service:compilation_environments\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/base:nullability\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+    ],\n+)\n+\n # Tests below\n \n xla_test(\n@@ -70,3 +92,29 @@ xla_test(\n         \"@com_google_googletest//:gtest_main\",\n     ],\n )\n+\n+xla_test(\n+    name = \"hlo_module_linking_test\",\n+    size = \"small\",\n+    srcs = [\"hlo_module_linking_test.cc\"],\n+    backends = [\"cpu\"],\n+    deps = [\n+        \":hlo_linking_manifest\",\n+        \":hlo_module_linking\",\n+        \":hlo_module_splitting\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/service:compiler\",\n+        \"//xla/service:hlo_verifier\",\n+        \"//xla/service:platform_util\",\n+        \"//xla/stream_executor:platform\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_googletest//:gtest\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)"
        },
        {
            "sha": "82cf884716c34e533d63da0d1fcff7a0cd3e7cf7",
            "filename": "third_party/xla/xla/hlo/separate_compilation/hlo_module_linking.cc",
            "status": "added",
            "additions": 221,
            "deletions": 0,
            "changes": 221,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking.cc?ref=e27791947bde474de2dbf0c1eb655f069de1a3f4",
            "patch": "@@ -0,0 +1,221 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/separate_compilation/hlo_module_linking.h\"\n+\n+#include <memory>\n+#include <stack>\n+#include <vector>\n+\n+#include \"absl/base/nullability.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"xla/hlo/ir/hlo_clone_context.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/ir/hlo_print_options.h\"\n+#include \"xla/hlo/separate_compilation/hlo_linking_manifest.h\"\n+#include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n+#include \"xla/service/compilation_environments.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla::separate_compilation {\n+\n+namespace {\n+struct TraversalState {\n+  // The principal computation to link\n+  const HloComputation* absl_nonnull principal;\n+  // The original stub this principal replaces\n+  const HloComputation* absl_nonnull stub;\n+  // True if we started linking `computation`; callees pushed.\n+  bool entered = false;\n+};\n+\n+// Helper class to encapsulate the state and logic of linking HLO computations.\n+class HloLinker {\n+ public:\n+  HloLinker(HloModule* module, const HloLinkingManifest& linking_manifest,\n+            const HloComputation* root_computation)\n+      : module_(module),\n+        linking_manifest_(linking_manifest),\n+        root_computation_(root_computation),\n+        clone_context_(module) {}\n+\n+  absl::StatusOr<HloComputation*> Link() {\n+    // Slightly abusing `TraversalState` here to avoid adding more boilerplate.\n+    // Stub field should hold a stub, but here stub == root_computation.\n+    stack_.push({root_computation_, root_computation_, false});\n+\n+    HloComputation* result = nullptr;\n+\n+    while (!stack_.empty()) {\n+      TraversalState& current = stack_.top();\n+\n+      if (SkipIfFinished(current)) {\n+        VLOG(6) << \"Already linked: \" << current.stub->name();\n+\n+      } else if (!current.entered) {\n+        VLOG(6) << \"First visit to link: \" << current.principal->name();\n+        TF_RETURN_IF_ERROR(HandleFirstVisit(current));\n+\n+      } else {\n+        VLOG(6) << \"Second visit to link: \" << current.principal->name();\n+        HloComputation* linked_computation = HandleSecondVisit(current);\n+        if (current.principal == root_computation_) {\n+          result = linked_computation;\n+        }\n+      }\n+    }\n+\n+    CHECK(result != nullptr)\n+        << \"Failed to produce a linked version of the root computation: \"\n+        << root_computation_->name();\n+    return result;\n+  }\n+\n+ private:\n+  // If the principal computation corresponding to state.stub has already been\n+  // linked, map state.stub to the existing linked computation and pops state\n+  // from stack_. Returns true if we popped, false otherwise.\n+  bool SkipIfFinished(const TraversalState& state) {\n+    if (auto it = finished_principals_.find(state.principal);\n+        it != finished_principals_.end()) {\n+      clone_context_.MapComputation(state.stub, it->second);\n+      stack_.pop();\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  // First time visiting `state.principal`: check for cycles, mark as entered,\n+  // and push dependencies to stack_.\n+  absl::Status HandleFirstVisit(TraversalState& state) {\n+    if (!being_linked_.insert(state.principal).second) {\n+      // Computation is currently being linked, which indicates we entered\n+      // but have not finished all children and exited, i.e. we came back\n+      // to it through its descendants forming a cycle.\n+      return absl::InternalError(absl::StrCat(\n+          \"Discovered a cycle during linking, involving computation: \",\n+          state.principal->name()));\n+    }\n+    state.entered = true;\n+\n+    PushDependencies(state);\n+    return absl::OkStatus();\n+  }\n+\n+  // Pushes dependencies of `state.principal` onto stack_ if they are stubs\n+  // that need to be linked.\n+  void PushDependencies(const TraversalState& state) {\n+    std::vector<HloInstruction*> post_order_instrs =\n+        state.principal->MakeInstructionPostOrder();\n+    VLOG(6) << \"Processing callees:\";\n+    for (HloInstruction* caller : post_order_instrs) {\n+      if (caller->opcode() != HloOpcode::kCall) {\n+        continue;\n+      }\n+      HloComputation* callee = caller->to_apply();\n+\n+      // If callee is a stub it will be in the linking manifest.\n+      // Non-stub callees within the same source module are handled\n+      // automatically by CloneInContext.\n+      if (auto it = linking_manifest_.stub_links.find(callee);\n+          it != linking_manifest_.stub_links.end()) {\n+        // Only push if its principal hasn't been mapped yet.\n+        if (clone_context_.FindComputation(callee) == nullptr) {\n+          const HloComputation* principal = it->second;\n+          stack_.push({principal, callee, false});\n+        }\n+      }\n+    }\n+  }\n+\n+  // Second time visiting `state.principal`: all dependencies are linked.\n+  // Clone `state.principal` into module_, update context, and pop from stack_.\n+  HloComputation* HandleSecondVisit(TraversalState& state) {\n+    // We are missing const overload for DeepCloneComputations with non-null\n+    // context.\n+    HloComputation* mutable_principal = const_cast<HloComputation*>(  // NOLINT\n+        state.principal);  // This method is effectively const.\n+\n+    HloComputation* linked_computation =\n+        module_->DeepCloneComputation(mutable_principal, &clone_context_);\n+    // TODO: b/429370488 - Add original names to `HloLinkingManifest`.\n+    linked_computation->SetAndSanitizeName(\n+        absl::StrCat(\"linked.\", linked_count_++));\n+    VLOG(6) << \"Processed: \" << linked_computation->ToString() << \" unique_id(\"\n+            << linked_computation->unique_id() << \")\";\n+\n+    clone_context_.MapComputation(state.stub, linked_computation);\n+    finished_principals_.insert({state.principal, linked_computation});\n+\n+    being_linked_.erase(state.principal);\n+    stack_.pop();\n+    return linked_computation;\n+  }\n+\n+  HloModule* module_;\n+  const HloLinkingManifest& linking_manifest_;\n+  const HloComputation* root_computation_;\n+\n+  // Cycle detection.\n+  absl::flat_hash_set<const HloComputation*> being_linked_;\n+  absl::flat_hash_map<const HloComputation*, HloComputation*>\n+      finished_principals_;\n+  std::stack<TraversalState, std::vector<TraversalState>> stack_;\n+\n+  HloCloneContext clone_context_;\n+  int linked_count_ = 0;\n+};\n+}  // namespace\n+\n+absl::StatusOr<std::unique_ptr<HloModule>> LinkComputation(\n+    const HloLinkingManifest& linking_manifest,\n+    const HloComputation* absl_nonnull root_computation) {\n+  VLOG(6) << \"Root computation: \" << root_computation->name();\n+  auto linked_module = std::make_unique<HloModule>(\n+      \"linked_module\", linking_manifest.module_config,\n+      std::make_unique<CompilationEnvironments>(\n+          *linking_manifest.compilation_environment));\n+\n+  HloLinker linker(linked_module.get(), linking_manifest, root_computation);\n+  TF_ASSIGN_OR_RETURN(HloComputation * linked_clone_ptr, linker.Link());\n+\n+  linked_module->ReplaceEntryComputation(linked_clone_ptr);\n+  xla::HloDCE dce_pass;\n+  TF_RETURN_IF_ERROR(dce_pass.Run(linked_module.get()).status());\n+\n+  if (VLOG_IS_ON(6)) {\n+    for (const HloComputation* comp : linked_module->computations()) {\n+      LOG(INFO) << comp->name() << \" [\" << comp->unique_id() << \"]\";\n+      for (const HloInstruction* instr : comp->instructions()) {\n+        LOG(INFO) << \"  \" << instr->ToString() << \" [\" << instr->unique_id()\n+                  << \"]\";\n+      }\n+    }\n+    LOG(INFO) << linked_module->ToString(HloPrintOptions().set_print_ids(true));\n+  }\n+  return linked_module;\n+}\n+\n+}  // namespace xla::separate_compilation"
        },
        {
            "sha": "a6a68aae1d6e2c1b89eccb55db5fd9085f61b7c4",
            "filename": "third_party/xla/xla/hlo/separate_compilation/hlo_module_linking.h",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking.h?ref=e27791947bde474de2dbf0c1eb655f069de1a3f4",
            "patch": "@@ -0,0 +1,43 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_HLO_SEPARATE_COMPILATION_HLO_MODULE_LINKING_H_\n+#define XLA_HLO_SEPARATE_COMPILATION_HLO_MODULE_LINKING_H_\n+\n+#include <memory>\n+\n+#include \"absl/base/nullability.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/separate_compilation/hlo_linking_manifest.h\"\n+\n+namespace xla::separate_compilation {\n+\n+// Link all the callees together with the `root_computation` in the provided\n+// module. Returns the pointer to the linked version of `root_computation`\n+// in the `module`.\n+absl::StatusOr<HloComputation* absl_nonnull> LinkComputationInto(\n+    HloModule* module, const HloLinkingManifest& linking_manifest,\n+    const HloComputation* absl_nonnull root_computation);\n+\n+// Create a new module by linking computations starting from `root_computation`.\n+absl::StatusOr<std::unique_ptr<HloModule>> LinkComputation(\n+    const HloLinkingManifest& linking_manifest,\n+    const HloComputation* absl_nonnull root_computation);\n+\n+}  // namespace xla::separate_compilation\n+\n+#endif  // XLA_HLO_SEPARATE_COMPILATION_HLO_MODULE_LINKING_H_"
        },
        {
            "sha": "2ebba94ada5c876727dbdfa0ef1fbffc0d0f7515",
            "filename": "third_party/xla/xla/hlo/separate_compilation/hlo_module_linking_test.cc",
            "status": "added",
            "additions": 309,
            "deletions": 0,
            "changes": 309,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e27791947bde474de2dbf0c1eb655f069de1a3f4/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fseparate_compilation%2Fhlo_module_linking_test.cc?ref=e27791947bde474de2dbf0c1eb655f069de1a3f4",
            "patch": "@@ -0,0 +1,309 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/separate_compilation/hlo_module_linking.h\"\n+\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_print_options.h\"\n+#include \"xla/hlo/separate_compilation/hlo_linking_manifest.h\"\n+#include \"xla/hlo/separate_compilation/hlo_module_splitting.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/service/compiler.h\"\n+#include \"xla/service/hlo_verifier.h\"\n+#include \"xla/service/platform_util.h\"\n+#include \"xla/stream_executor/platform.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla::separate_compilation {\n+namespace {\n+\n+// Function to normalize an HloModule by removing/replacing names.\n+void NormalizeHloModule(xla::HloModule& module) {\n+  // 1. Clear names from module (as clone keeps the original names)\n+  module.set_name(\"module\");\n+  VLOG(6) << module.name() << \" instr count: \" << module.instruction_count();\n+\n+  // 2. Get computations in post order\n+  std::vector<HloComputation*> computations_post_order =\n+      module.MakeComputationPostOrder(/*dfs_postorder=*/true);\n+\n+  // 3. Initialize visited set and counter\n+  absl::flat_hash_set<const HloComputation*> visited;\n+  int computation_counter = 0;\n+  // 4. Number computations in post order\n+  for (HloComputation* computation : computations_post_order) {\n+    if (!visited.insert(computation).second) {\n+      continue;\n+    }\n+    VLOG(6) << computation->ToString()\n+            << \" instr count: \" << computation->instruction_count();\n+    computation->SetAndSanitizeName(\n+        absl::StrCat(\"computation_\", computation_counter++));\n+    // 5. Number instructions inside the computation\n+    int instruction_counter = 0;\n+    for (HloInstruction* instruction :\n+         computation->MakeInstructionPostOrder()) {\n+      VLOG(6) << \"  \" << instruction->ToString();\n+      instruction->SetAndSanitizeName(\n+          absl::StrCat(\"instruction_\", instruction_counter++));\n+    }\n+  }\n+}\n+\n+bool AreHloModulesEquivalent(xla::HloModule& module1, xla::HloModule& module2) {\n+  auto module1_copy = module1.Clone(\"module1_copy\");\n+  auto module2_copy = module2.Clone(\"module2_copy\");\n+\n+  NormalizeHloModule(*module1_copy);\n+  NormalizeHloModule(*module2_copy);\n+\n+  xla::HloPrintOptions options;\n+  options.set_canonicalize_computations(true);\n+\n+  auto module1_str = module1_copy->ToString(options);\n+  auto module2_str = module2_copy->ToString(options);\n+\n+  VLOG(6) << module2_str;\n+  VLOG(6) << \"Module 1 normalized string: \" << module1_str << \"\\n\"\n+          << \"Module 2 normalized string: \" << module2_str;\n+  return module1_str == module2_str;\n+}\n+\n+class LinkingTest : public HloHardwareIndependentTestBase {};\n+\n+TEST_F(LinkingTest, SingleCallLinking) {\n+  constexpr absl::string_view module_text = R\"(\n+    HloModule simple_module\n+\n+    %comp {\n+      %p = f32[] parameter(0)\n+      ROOT %result = f32[] negate(%p)\n+    }\n+\n+    ENTRY %main {\n+      %p = f32[] parameter(0)\n+      ROOT %result = f32[] call(%p), to_apply=%comp\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto original_module,\n+                          ParseAndReturnVerifiedModule(module_text));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module_split_group,\n+                          CreateHloModuleSplitGroup(*original_module));\n+  // LOG the split group.\n+  for (const auto& split : module_split_group->module_splits) {\n+    LOG(INFO) << \"Split: \" << split->submodule->name();\n+    LOG(INFO) << \"Split module: \" << split->submodule->ToString();\n+    LOG(INFO) << \"Computation map:\";\n+    for (const auto& [original, cloned] : split->computation_map) {\n+      LOG(INFO) << \"original: \" << original->name()\n+                << \" ==>> clones: \" << cloned->name();\n+    }\n+    LOG(INFO) << \"Call sites:\";\n+    for (const auto* call_site : split->call_sites) {\n+      LOG(INFO) << \"  \" << call_site->name();\n+    }\n+    LOG(INFO) << \" Stub links:\";\n+    for (const auto& [stub, comp] : split->stub_map) {\n+      LOG(INFO) << \" stub: \" << stub->name()\n+                << \" ==>> original: \" << comp->name();\n+    }\n+  }\n+  // LOG the address book.\n+  for (const auto& [comp, split] : module_split_group->address_book) {\n+    LOG(INFO) << \"Original: \" << comp->name()\n+              << \" Split: \" << split->submodule->name();\n+  }\n+  // LOG the linking manifest stub links\n+  LOG(INFO) << \"Linking manifest stub links:\";\n+  for (const auto& [stub, comp] :\n+       module_split_group->linking_manifest.stub_links) {\n+    LOG(INFO) << \"  \" << stub->name() << \" ==>> \" << comp->name();\n+  }\n+\n+  const HloLinkingManifest& linking_manifest =\n+      module_split_group->linking_manifest;\n+  auto* original_root = FindComputation(original_module.get(), \"main\");\n+  auto* split_group_root = module_split_group->address_book.at(original_root)\n+                               ->computation_map.at(original_root);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto linked_module,\n+                          LinkComputation(linking_manifest, split_group_root));\n+  HloVerifier verifier(HloVerifierOpts{});\n+  TF_ASSERT_OK(verifier.Run(linked_module.get()));\n+\n+  EXPECT_TRUE(AreHloModulesEquivalent(*original_module, *linked_module));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(stream_executor::Platform * platform,\n+                          PlatformUtil::GetPlatform(\"cpu\"));\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<Compiler> compiler,\n+                          Compiler::GetForPlatform(platform));\n+  TF_EXPECT_OK(compiler->RunHloPasses(original_module->Clone(),\n+                                      /*executor=*/nullptr,\n+                                      Compiler::CompileOptions{}));\n+  VLOG(6) << linked_module->ToString();\n+  TF_ASSERT_OK(compiler->RunHloPasses(std::move(linked_module),\n+                                      /*executor=*/nullptr,\n+                                      Compiler::CompileOptions{}));\n+}\n+\n+TEST_F(LinkingTest, ChainGraphLinking) {\n+  constexpr absl::string_view module_text = R\"(\n+    HloModule nested_calls\n+\n+    %comp3 {\n+      %p = f32[] parameter(0)\n+      ROOT %result = f32[] exponential(%p)\n+    }\n+\n+    %comp2 {\n+      %p = f32[] parameter(0)\n+      %c = f32[] constant(3.0)\n+      %call_res = f32[] call(%p), to_apply=%comp3\n+      ROOT %result = f32[] add(%call_res, %c)\n+    }\n+\n+    %comp1 {\n+      %p = f32[] parameter(0)\n+      %c = f32[] constant(2.0)\n+      %call_res = f32[] call(%p), to_apply=%comp2\n+      ROOT %result = f32[] multiply(%call_res, %c)\n+    }\n+\n+    ENTRY %main {\n+      %p = f32[] parameter(0)\n+      %call_res = f32[] call(%p), to_apply=%comp1\n+      ROOT %result = f32[] add(%call_res, %p)\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto original_module,\n+                          ParseAndReturnVerifiedModule(module_text));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module_split_group,\n+                          CreateHloModuleSplitGroup(*original_module));\n+\n+  const HloLinkingManifest& linking_manifest =\n+      module_split_group->linking_manifest;\n+  auto* original_root = FindComputation(original_module.get(), \"main\");\n+  auto* split_group_root = module_split_group->address_book.at(original_root)\n+                               ->computation_map.at(original_root);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto linked_module,\n+                          LinkComputation(linking_manifest, split_group_root));\n+  HloVerifier verifier(HloVerifierOpts{});\n+  TF_ASSERT_OK(verifier.Run(linked_module.get()));\n+\n+  EXPECT_TRUE(AreHloModulesEquivalent(*original_module, *linked_module));\n+  TF_ASSERT_OK_AND_ASSIGN(stream_executor::Platform * platform,\n+                          PlatformUtil::GetPlatform(\"cpu\"));\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<Compiler> compiler,\n+                          Compiler::GetForPlatform(platform));\n+  VLOG(6) << linked_module->ToString();\n+  TF_EXPECT_OK(compiler->RunHloPasses(std::move(linked_module),\n+                                      /*executor=*/nullptr,\n+                                      Compiler::CompileOptions{}));\n+  TF_EXPECT_OK(compiler->RunHloPasses(original_module->Clone(),\n+                                      /*executor=*/nullptr,\n+                                      Compiler::CompileOptions{}));\n+}\n+\n+TEST_F(LinkingTest, DiamondGraphLinking) {\n+  constexpr absl::string_view module_text = R\"(\n+    HloModule shared_callee_module\n+\n+    %fusion.2 (x: f32[]) -> f32[] {\n+      %x = f32[] parameter(0)\n+      ROOT %add = f32[] negate(f32[] %x)\n+    }\n+\n+    %y {\n+      %p = f32[] parameter(0)\n+      ROOT %result = f32[] exponential(%p)\n+    }\n+\n+    %x {\n+      %p = f32[] parameter(0)\n+      %call_y = f32[] call(%p), to_apply=%y\n+      ROOT %result = f32[] cosine(%call_y)\n+    }\n+\n+    %a {\n+      %p = f32[] parameter(0)\n+      %c = f32[] constant(5.0)\n+      %call_x = f32[] call(%p), to_apply=%x\n+      ROOT %result = f32[] add(%call_x, %c)\n+    }\n+\n+    %b {\n+      %p = f32[] parameter(0)\n+      %f = f32[] fusion(%p), kind=kLoop, calls=%fusion.2\n+      %call_x = f32[] call(%p), to_apply=%x\n+      ROOT %result = f32[] subtract(%call_x, %f)\n+    }\n+\n+    ENTRY %main {\n+      %p_entry = f32[] parameter(0)\n+      %call_a = f32[] call(%p_entry), to_apply=%a\n+      %call_b = f32[] call(%p_entry), to_apply=%b\n+      ROOT %result = f32[] add(%call_a, %call_b)\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto original_module,\n+                          ParseAndReturnVerifiedModule(module_text));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module_split_group,\n+                          CreateHloModuleSplitGroup(*original_module));\n+\n+  const HloLinkingManifest& linking_manifest =\n+      module_split_group->linking_manifest;\n+  auto* original_root = FindComputation(original_module.get(), \"main\");\n+  ASSERT_TRUE(module_split_group->address_book.contains(original_root));\n+  auto* split = module_split_group->address_book.at(original_root);\n+  ASSERT_TRUE(split->computation_map.contains(original_root));\n+  auto* split_root = split->computation_map.at(original_root);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto linked_module,\n+                          LinkComputation(linking_manifest, split_root));\n+  HloVerifier verifier(HloVerifierOpts{});\n+  TF_ASSERT_OK(verifier.Run(linked_module.get()));\n+\n+  EXPECT_TRUE(AreHloModulesEquivalent(*original_module, *linked_module));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(stream_executor::Platform * platform,\n+                          PlatformUtil::GetPlatform(\"cpu\"));\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<Compiler> compiler,\n+                          Compiler::GetForPlatform(platform));\n+  TF_EXPECT_OK(compiler->RunHloPasses(original_module->Clone(),\n+                                      /*executor=*/nullptr,\n+                                      Compiler::CompileOptions{}));\n+  VLOG(6) << linked_module->ToString();\n+  TF_EXPECT_OK(compiler->RunHloPasses(std::move(linked_module),\n+                                      /*executor=*/nullptr,\n+                                      Compiler::CompileOptions{}));\n+}\n+\n+}  // namespace\n+}  // namespace xla::separate_compilation"
        }
    ],
    "stats": {
        "total": 621,
        "additions": 621,
        "deletions": 0
    }
}