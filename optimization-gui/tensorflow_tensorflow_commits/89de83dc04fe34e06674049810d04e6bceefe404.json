{
    "author": "tensorflower-gardener",
    "message": "[XLA:Original Value] Propagate OriginalValue information when hoisting loop-invariant instructions.\n\nWhen `HoistLoopInvariantInstructions` creates a new while loop, the `OriginalValue` for the new while instruction is constructed. Elements from the original while tuple retain their original values. For hoisted instructions, their original values are copied, and the original instruction name is prefixed to indicate they are loop-invariant values hoisted out of the while loop.\n\nAlso, introduced `GetOriginalCallInstructionName` and use it in `CallInliner`.\n\nPiperOrigin-RevId: 814772914",
    "sha": "89de83dc04fe34e06674049810d04e6bceefe404",
    "files": [
        {
            "sha": "c42bb9664e40590f566c0c339aaf51add55f63ad",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -309,4 +309,24 @@ bool OriginalValue::IsCompatibleWith(const Shape& shape) const {\n   return tree().IsStructurallyCompatible(shape);\n }\n \n+std::optional<std::string> OriginalValue::GetOriginalCallLikeInstructions()\n+    const {\n+  if (is_synthetic_call()) {\n+    // Synthetic call are transparent and hence resulting in empty call\n+    // instructions.\n+    return \"\";\n+  }\n+  if (IsEmpty()) {\n+    // Currently we don't track original call information separately and rely\n+    // on the first leaf to find the original call information. So if there are\n+    // no leaves we return std::nullopt.\n+    return std::nullopt;\n+  }\n+  auto original_array = original_arrays().begin()->second;\n+  if (!original_array.has_value()) {\n+    return std::nullopt;\n+  }\n+  return original_array->instruction_name;\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "039745fa3726d03f8fc38bf788e8230fc31f68a8",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -135,6 +135,12 @@ class OriginalValue {\n     return !(*this == other);\n   }\n \n+  // Gets the (partial) call hierarchy string of the original call instructions\n+  // that this OriginalValue is associated with. Returns std::nullopt if this\n+  // OriginalValue is not associated with a call instruction or the call\n+  // hierarchy is lost (e.g., after complicated optimizations).\n+  std::optional<std::string> GetOriginalCallLikeInstructions() const;\n+\n   template <typename H>\n   friend H AbslHashValue(H h, const OriginalValue& value) {\n     h = H::combine(std::move(h), value.is_synthetic_call());"
        },
        {
            "sha": "ee8af2ae47336fb296e51bd68b517f4490be73e3",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -4706,10 +4706,10 @@ xla_cc_test(\n         \"//xla/hlo/utils:hlo_matchers\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n \n@@ -4828,6 +4828,8 @@ cc_library(\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/hlo/transforms/simplifiers:hlo_dce\",\n         \"//xla/hlo/transforms/simplifiers:tuple_simplifier\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n@@ -4836,8 +4838,6 @@ cc_library(\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n-        \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n \n@@ -4856,8 +4856,8 @@ xla_cc_test(\n         \"//xla/hlo/utils:hlo_matchers\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/log\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n \n@@ -4872,13 +4872,16 @@ cc_library(\n         \"//xla/hlo/analysis:while_loop_analysis\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/pass:hlo_pass\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/container:inlined_vector\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n     ],\n )\n@@ -4894,6 +4897,7 @@ xla_cc_test(\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/utils:hlo_matchers\",\n         \"//xla/tests:xla_internal_test_main\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_googletest//:gtest\",\n         \"@local_tsl//tsl/platform:statusor\",\n     ],"
        },
        {
            "sha": "c73718066b5277a0f73c8afa9c86556e2bfd06a6",
            "filename": "third_party/xla/xla/service/call_inliner.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 6,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcall_inliner.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -214,9 +214,21 @@ class SubcomputationInsertionVisitor : public DfsHloVisitorWithDefault {\n       new_hlo_pointer->set_original_value(nullptr);\n       return;\n     }\n+    std::optional<std::string> call_instructions =\n+        call_original_value->GetOriginalCallLikeInstructions();\n+    if (!call_instructions.has_value()) {\n+      // If the call instruction is lost, we must drop the original values\n+      // on the inlined instructions because the call hierarchy is lost.\n+      new_hlo_pointer->set_original_value(nullptr);\n+      return;\n+    }\n     new_hlo_pointer->CopyOriginalValue(hlo, /*clone=*/true,\n                                        /*issue_warning=*/true);\n-    if (call_original_value->is_synthetic_call()) {\n+    if (call_instructions->empty()) {\n+      // Empty call instructions means the call is synthetic and hence the\n+      // inlined instruction do not need to be prefixed with the call\n+      // instructions. Hence we can just return here to have the copied original\n+      // value to be used.\n       return;\n     }\n     std::shared_ptr<OriginalValue> original_value =\n@@ -227,12 +239,8 @@ class SubcomputationInsertionVisitor : public DfsHloVisitorWithDefault {\n     for (auto& pair : original_value->mutable_original_arrays()) {\n       std::optional<OriginalArray>& original_array = pair.second;\n       if (original_array.has_value()) {\n-        std::string call_instruction_name =\n-            call_original_value->original_arrays()\n-                .begin()\n-                ->second->instruction_name;\n         original_array->instruction_name = absl::StrCat(\n-            call_instruction_name, \"/\", original_array->instruction_name);\n+            *call_instructions, \"/\", original_array->instruction_name);\n       }\n     }\n   }"
        },
        {
            "sha": "4baab74005d4e5ab2da3cb0ea31294e661470a52",
            "filename": "third_party/xla/xla/service/while_loop_expensive_invariant_code_motion.cc",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -17,7 +17,10 @@ limitations under the License.\n \n #include <cstdint>\n #include <iterator>\n+#include <memory>\n+#include <optional>\n #include <string>\n+#include <utility>\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n@@ -27,10 +30,20 @@ limitations under the License.\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/analysis/while_loop_analysis.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/ir/hlo_print_options.h\"\n+#include \"xla/map_util.h\"\n #include \"xla/service/while_util.h\"\n+#include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n \n namespace xla {\n@@ -101,6 +114,32 @@ static void CreateLoopInvariantCopy(\n             old_instruction->CloneWithNewOperands(old_instruction->shape(),\n                                                   new_operands));\n \n+        std::optional<std::string> original_call_instructions;\n+        if (while_instr->original_value() != nullptr) {\n+          original_call_instructions =\n+              while_instr->original_value()->GetOriginalCallLikeInstructions();\n+        }\n+        if (original_call_instructions.has_value() &&\n+            old_instruction->original_value() != nullptr) {\n+          std::string original_call_prefix;\n+          if (!original_call_instructions->empty()) {\n+            // We only add the wildcard iteration count if the call-like\n+            // instruction is available.\n+            original_call_prefix =\n+                absl::StrCat(*original_call_instructions, \"#*/\");\n+          }\n+\n+          auto new_original_value = std::make_shared<OriginalValue>(\n+              *old_instruction->original_value());\n+          for (auto& [shape_index, original_array] :\n+               new_original_value->mutable_original_arrays()) {\n+            if (original_array) {\n+              original_array->instruction_name = absl::StrCat(\n+                  original_call_prefix, original_array->instruction_name);\n+            }\n+          }\n+          new_instruction->set_original_value(std::move(new_original_value));\n+        }\n         info.hoisted_copy = new_instruction;\n       }\n "
        },
        {
            "sha": "7ec33b871255c970e4b03b3a9a3bf37afd54a8ad",
            "filename": "third_party/xla/xla/service/while_loop_expensive_invariant_code_motion_test.cc",
            "status": "modified",
            "additions": 71,
            "deletions": 1,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion_test.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -23,8 +23,8 @@ limitations under the License.\n #include \"xla/hlo/parser/hlo_parser.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/utils/hlo_matchers.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla {\n namespace {\n@@ -268,5 +268,75 @@ ENTRY entry {\n   EXPECT_FALSE(simplified_loop);\n }\n \n+TEST_F(WhileLoopExpensiveInvariantCodeMotionTest, HoistWithOriginalValue) {\n+  const char* const hlo_string = R\"(\n+HloModule licm_ov_test\n+\n+body {\n+  p_body = (f32[8,8], f32[16, 8]) parameter(0)\n+  b = f32[16, 8] get-tuple-element(p_body), index=1\n+  const = f32[] constant(1.0)\n+  lhs = f32[8, 16] broadcast(const), dimensions={}, origin={{\"lhs.1\"}}\n+  dot = f32[8,8] dot(lhs, b), lhs_contracting_dims={1}, rhs_contracting_dims={0}, origin={{\"dot.1\"}}\n+  a = f32[8,8] get-tuple-element(p_body), index=0\n+  add = f32[8,8] add(a, dot)\n+  ROOT root = (f32[8,8], f32[16,8]) tuple(add, b)\n+}\n+\n+condition {\n+  p_cond = (f32[8,8], f32[16, 8]) parameter(0)\n+  ROOT result = pred[] constant(true)\n+}\n+\n+ENTRY entry {\n+  param0 = f32[8,8] parameter(0)\n+  param1 = f32[16, 8] parameter(1)\n+  while_init = (f32[8,8], f32[16,8]) tuple(param0, param1)\n+  ROOT while0 = (f32[8,8], f32[16, 8]) while(while_init), condition=condition, body=body, origin={({\"while.5\" {0}},{\"while.5\" {1}})}\n+}\n+)\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(hlo_string));\n+  HloComputation* body = m->GetComputationWithName(\"body\");\n+  HloInstruction* dot = body->GetInstructionWithName(\"dot\");\n+  HloInstruction* lhs = body->GetInstructionWithName(\"lhs\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool simplified_loop,\n+      WhileLoopExpensiveInvariantCodeMotion(\n+          /*worth_hoisting_individually=*/HloPredicateIsOp<HloOpcode::kDot>)\n+          .Run(m.get()));\n+  EXPECT_TRUE(simplified_loop);\n+\n+  HloInstruction* transformed_while = nullptr;\n+  for (auto* instr : m->entry_computation()->instructions()) {\n+    if (instr->opcode() == HloOpcode::kWhile) {\n+      transformed_while = instr;\n+      break;\n+    }\n+  }\n+  ASSERT_NE(transformed_while, nullptr);\n+\n+  HloInstruction* hoisted_dot = nullptr;\n+  HloInstruction* hoisted_lhs = nullptr;\n+  for (auto* instr : m->entry_computation()->instructions()) {\n+    if (instr->opcode() == HloOpcode::kDot && instr->shape() == dot->shape()) {\n+      hoisted_dot = instr;\n+    }\n+    if (instr->opcode() == HloOpcode::kBroadcast &&\n+        instr->shape() == lhs->shape()) {\n+      hoisted_lhs = instr;\n+    }\n+  }\n+  ASSERT_NE(hoisted_dot, nullptr);\n+  ASSERT_NE(hoisted_lhs, nullptr);\n+  ASSERT_NE(hoisted_dot->original_value(), nullptr);\n+  EXPECT_EQ(hoisted_dot->original_value()->ToString(), \"{\\\"while.5#*/dot.1\\\"}\");\n+  ASSERT_NE(hoisted_lhs->original_value(), nullptr);\n+  EXPECT_EQ(hoisted_lhs->original_value()->ToString(), \"{\\\"while.5#*/lhs.1\\\"}\");\n+  ASSERT_NE(transformed_while->original_value(), nullptr);\n+  EXPECT_EQ(transformed_while->original_value()->ToString(),\n+            \"({\\\"while.5\\\" {0}}, {\\\"while.5\\\" {1}}, {\\\"while.5#*/dot.1\\\"})\");\n+}\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "9a80fd78063dbc1ff3c5ee9e4fcccaf23a2c24b8",
            "filename": "third_party/xla/xla/service/while_loop_invariant_code_motion.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 2,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -17,7 +17,10 @@ limitations under the License.\n \n #include <cstdint>\n #include <iterator>\n+#include <memory>\n+#include <optional>\n #include <string>\n+#include <utility>\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n@@ -26,21 +29,24 @@ limitations under the License.\n #include \"absl/container/inlined_vector.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/analysis/while_loop_analysis.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n #include \"xla/hlo/transforms/simplifiers/tuple_simplifier.h\"\n #include \"xla/map_util.h\"\n #include \"xla/service/compile_time_cap.h\"\n #include \"xla/service/while_util.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla {\n \n@@ -93,6 +99,33 @@ static void CreateLoopInvariantCopy(\n           parent_of_while->AddInstruction(old_instruction->CloneWithNewOperands(\n               old_instruction->shape(), new_operands));\n \n+      std::optional<std::string> original_call_instructions;\n+      if (while_instr->original_value() != nullptr) {\n+        original_call_instructions =\n+            while_instr->original_value()->GetOriginalCallLikeInstructions();\n+      }\n+      if (original_call_instructions.has_value() &&\n+          old_instruction->original_value() != nullptr) {\n+        std::string original_call_prefix;\n+        if (!original_call_instructions->empty()) {\n+          // We only add the wildcard iteration count if the call-like\n+          // instruction is available.\n+          original_call_prefix =\n+              absl::StrCat(*original_call_instructions, \"#*/\");\n+        }\n+\n+        auto new_original_value =\n+            std::make_shared<OriginalValue>(*old_instruction->original_value());\n+        for (auto& [shape_index, original_array] :\n+             new_original_value->mutable_original_arrays()) {\n+          if (original_array) {\n+            original_array->instruction_name = absl::StrCat(\n+                original_call_prefix, original_array->instruction_name);\n+          }\n+        }\n+        new_instruction->set_original_value(std::move(new_original_value));\n+      }\n+\n       InsertOrDie(hoisted_instructions, old_instruction, new_instruction);\n \n       // Approximately half of the instructions that would normally be present"
        },
        {
            "sha": "3d4cff93ea68e21905aca1d0f7eb7fecb23524b5",
            "filename": "third_party/xla/xla/service/while_loop_invariant_code_motion_test.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 1,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion_test.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -32,8 +32,8 @@ limitations under the License.\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla {\n namespace {\n@@ -771,5 +771,63 @@ TEST_F(WhileLoopInvariantCodeMotionTest, RespectFrontendAttrDisablingHoisting) {\n   EXPECT_FALSE(simplified_loop);\n }\n \n+TEST_F(WhileLoopInvariantCodeMotionTest, HoistWithOriginalValue) {\n+  const char* const hlo_string = R\"(\n+HloModule licm_ov_test\n+\n+body {\n+  p_body = (s32[], s32[]) parameter(0)\n+  gte0 = s32[] get-tuple-element(p_body), index=0\n+  c = s32[] constant(1), origin={{\"c.1\"}}\n+  add = s32[] add(gte0, c), origin={{\"add.1\"}}\n+  ROOT tuple = (s32[], s32[]) tuple(gte0, add)\n+}\n+\n+cond {\n+  p_cond = (s32[], s32[]) parameter(0)\n+  ROOT result = pred[] constant(true)\n+}\n+\n+ENTRY entry {\n+  p_entry_0 = s32[] parameter(0)\n+  while_init = (s32[], s32[]) tuple(p_entry_0, p_entry_0)\n+  ROOT while0 = (s32[], s32[]) while(while_init), condition=cond, body=body, origin={({\"while.5\" {0}},{\"while.5\" {1}})}\n+}\n+)\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(hlo_string));\n+  HloComputation* body = m->GetComputationWithName(\"body\");\n+  HloInstruction* c = body->GetInstructionWithName(\"c\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool simplified_loop,\n+      WhileLoopInvariantCodeMotion{/*hoist_constants=*/true}.Run(m.get()));\n+  EXPECT_TRUE(simplified_loop);\n+\n+  HloInstruction* transformed_while;\n+  FindOnlyWhileInstruction(m->entry_computation(), &transformed_while);\n+\n+  HloInstruction* hoisted_c = nullptr;\n+  HloInstruction* hoisted_add = nullptr;\n+  for (auto* instr : m->entry_computation()->instructions()) {\n+    if (instr->opcode() == HloOpcode::kConstant &&\n+        instr->shape() == c->shape()) {\n+      hoisted_c = instr;\n+    }\n+    if (instr->opcode() == HloOpcode::kAdd) {\n+      hoisted_add = instr;\n+    }\n+  }\n+  ASSERT_NE(hoisted_c, nullptr);\n+  ASSERT_NE(hoisted_add, nullptr);\n+  ASSERT_NE(hoisted_c->original_value(), nullptr);\n+  EXPECT_EQ(hoisted_c->original_value()->ToString(), \"{\\\"while.5#*/c.1\\\"}\");\n+  ASSERT_NE(hoisted_add->original_value(), nullptr);\n+  EXPECT_EQ(hoisted_add->original_value()->ToString(), \"{\\\"while.5#*/add.1\\\"}\");\n+  ASSERT_NE(transformed_while->original_value(), nullptr);\n+  EXPECT_EQ(transformed_while->original_value()->ToString(),\n+            \"({\\\"while.5\\\" {0}}, {\\\"while.5\\\" {1}}, {\\\"while.5#*/c.1\\\"}, \"\n+            \"{\\\"while.5#*/add.1\\\"})\");\n+}\n+\n }  // namespace\n }  // namespace xla"
        },
        {
            "sha": "a3352c23ffa7b0601133bcfa93ba6107569b7b51",
            "filename": "third_party/xla/xla/service/while_util.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -164,6 +164,33 @@ WhileUtil::MakeInstructionsLiveIn(\n   HloInstruction* new_while = while_instr->AddInstruction(\n       HloInstruction::CreateWhile(new_while_shape, new_while_condition,\n                                   new_while_body, new_while_init));\n+  if (while_instr->original_value() != nullptr) {\n+    OriginalValue new_original_value(new_while_shape);\n+    for (auto& [shape_index, original_array] :\n+         new_original_value.mutable_original_arrays()) {\n+      // The hoisted instructions are appended to the end of the while\n+      // instruction, so the shape indices smaller than\n+      // `elements_in_old_while_shape` are all the old original arrays that\n+      // need to be propagated.\n+      if (shape_index[0] < elements_in_old_while_shape) {\n+        original_array =\n+            while_instr->original_value()->tree().element(shape_index);\n+      } else {\n+        // If the element is new (i.e., hoisted), fetch its original value from\n+        // the instruction that was hoisted.\n+        int instruction_idx = shape_index[0] - elements_in_old_while_shape;\n+        HloInstruction* instruction = instructions[instruction_idx];\n+        if (instruction->original_value() != nullptr) {\n+          ShapeIndex shape_index_in_instruction = shape_index;\n+          shape_index_in_instruction.erase(shape_index_in_instruction.begin());\n+          original_array = instruction->original_value()->original_array(\n+              shape_index_in_instruction);\n+        }\n+      }\n+    }\n+    new_while->set_original_value(\n+        std::make_shared<OriginalValue>(std::move(new_original_value)));\n+  }\n \n   // We want to get rid of the old while instruction even if it has side\n   // effecting operations so we do a manual HloComputation::RemoveInstruction"
        },
        {
            "sha": "35060031b97a5b56ae51c81bca574123b13f9af2",
            "filename": "third_party/xla/xla/service/while_util_test.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 1,
            "changes": 49,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/89de83dc04fe34e06674049810d04e6bceefe404/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util_test.cc?ref=89de83dc04fe34e06674049810d04e6bceefe404",
            "patch": "@@ -29,8 +29,8 @@ limitations under the License.\n #include \"xla/hlo/testlib/verified_hlo_module.h\"\n #include \"xla/hlo/utils/hlo_matchers.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla {\n namespace {\n@@ -141,6 +141,53 @@ TEST_F(WhileUtilTest, MakeTwoInstructionsLive) {\n                         op::GetTupleElement(op::Parameter(0), 3)));\n }\n \n+TEST_F(WhileUtilTest, MakeInstructionLiveInWithOriginalValue) {\n+  const char* const hlo_string = R\"(\n+HloModule ModuleWithWhile\n+\n+while_body {\n+  ROOT p_body = (s32[], s32[]) parameter(0)\n+}\n+\n+while_condition {\n+  p_cond = (s32[], s32[]) parameter(0)\n+  ROOT result = pred[] constant(true)\n+}\n+\n+ENTRY entry {\n+  p_entry_0 = s32[] parameter(0), origin={{\"p0\"}}\n+  p_entry_1 = s32[] parameter(1), origin={{\"p1\"}}\n+  live_in_1 = f32[] parameter(2), origin={{\"live_in_1\"}}\n+  live_in_2 = f32[] parameter(3)\n+  live_tuple = (s32[], s32[]) tuple(p_entry_0, p_entry_1), origin={({\"tuple_1\"}, {\"tuple_2\"})}\n+  while_init = (s32[], s32[]) tuple(p_entry_0, p_entry_1)\n+  ROOT while0 = (s32[], s32[]) while(while_init), condition=while_condition, body=while_body, origin={({\"p0_while\"},{\"p1_while\"})}\n+}\n+)\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  HloComputation* entry_computation = module->entry_computation();\n+  HloInstruction* while_instr = entry_computation->root_instruction();\n+  ASSERT_EQ(while_instr->opcode(), HloOpcode::kWhile);\n+  HloInstruction* live_in_1 = entry_computation->parameter_instruction(2);\n+  HloInstruction* live_in_2 = entry_computation->parameter_instruction(3);\n+  HloInstruction* live_tuple =\n+      entry_computation->GetInstructionWithName(\"live_tuple\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      WhileUtil::MakeInstructionsLiveInResult make_live_in_result,\n+      WhileUtil::MakeInstructionsLiveIn(\n+          while_instr,\n+          /*instructions=*/{live_in_1, live_in_2, live_tuple}));\n+\n+  HloInstruction* new_while_instr = make_live_in_result.new_while_instr;\n+  ASSERT_NE(new_while_instr->original_value(), nullptr);\n+  EXPECT_EQ(new_while_instr->original_value()->ToString(),\n+            \"({\\\"p0_while\\\"}, {\\\"p1_while\\\"}, {\\\"live_in_1\\\"}, {}, \"\n+            \"({\\\"tuple_1\\\"}, {\\\"tuple_2\\\"}))\");\n+}\n+\n TEST_F(WhileUtilTest, GetInvariantGTEsForWhileBody) {\n   const char* const hlo_string = R\"(\n HloModule ModuleWithWhile"
        }
    ],
    "stats": {
        "total": 342,
        "additions": 327,
        "deletions": 15
    }
}