{
    "author": "pschuh",
    "message": "Implement PjRtStreamExecutorRawBuffer::CopyToLiteralAsync and allow\nPjRtStreamExecutorBuffer to just use inherited literal conversion logic.\n\nPiperOrigin-RevId: 819490746",
    "sha": "7dbc996979d2da847311eb28f796770cefeeb065",
    "files": [
        {
            "sha": "04670447eb7b1764d5b39b1e24f7b1fc7f2309b1",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 224,
            "changes": 224,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=7dbc996979d2da847311eb28f796770cefeeb065",
            "patch": "@@ -1404,230 +1404,6 @@ void PjRtStreamExecutorBuffer::ConvertUsageHold(TrackedDeviceBuffer* buffer,\n   DecrementUsage();\n }\n \n-Future<> PjRtStreamExecutorBuffer::LazyToLiteral(\n-    absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) {\n-  auto buffer = std::move(generator)();\n-  return ToLiteralHelper(std::move(buffer));\n-}\n-\n-Future<> PjRtStreamExecutorBuffer::ToLiteral(MutableLiteralBase* literal) {\n-  return ToLiteralHelper(Future<MutableLiteralBase*>(literal));\n-}\n-\n-Future<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n-    Future<MutableLiteralBase*> literal) {\n-  VLOG(3) << \"PjRtStreamExecutorBuffer::ToLiteral\";\n-  auto* se_device = tensorflow::down_cast<PjRtStreamExecutorDevice*>(device());\n-  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n-  LocalDeviceState* local_device = se_device->local_device_state();\n-  se::Stream* stream = local_device->GetDeviceToHostStream();\n-  auto device_buffer = GetBufferWithUsageHold();\n-  if (!device_buffer.ok()) {\n-    return Future<>(\n-        InvalidArgument(\"ToLiteral() called on deleted or donated buffer: %s\",\n-                        device_buffer.status().ToString()));\n-  }\n-\n-  auto [promise, future] = Future<>::MakePromise();\n-  auto usage_event = BufferSequencingEvent::Create(se_client->thread_pool());\n-\n-  TransferManager* transfer_manager =\n-      se_client->client()->backend().transfer_manager();\n-\n-  auto device_memory = device_buffer->device_memory();\n-  auto definition_events = device_buffer->definition_events();\n-  auto first_definition_event = definition_events[0];\n-\n-  // When using the ComputeSynchronized allocation model, retain a\n-  // reference to the device_buffer until the copy completes, to\n-  // ensure that the buffer isn't deleted or donated while it is still\n-  // in use. The choice of retaining a reference at the host is a\n-  // heuristic; the alternative is to ensure, before freeing the\n-  // buffer, that the compute stream is synchronized past the\n-  // transfer, but it seems better to hold onto the buffer too long\n-  // than to stall the compute stream, particularly since the\n-  // overwhelmingly common use case of CopyToHostAsync will hold onto\n-  // the reference long enough to read the buffer in a subsequent call\n-  // to ToLiteral.\n-  device_buffer.ConvertUsageHold(stream, usage_event, /*reference_held=*/true);\n-\n-  auto [literal_and_transpose_promise, literal_and_transpose_future] =\n-      Future<std::pair<MutableLiteralBase*,\n-                       std::shared_ptr<TransposePlan>>>::MakePromise();\n-\n-  literal.OnReady(\n-      [client = se_client, on_device_shape{on_device_shape()},\n-       promise = std::move(literal_and_transpose_promise)](\n-          const absl::StatusOr<MutableLiteralBase*>& value) mutable {\n-        if (!value.ok()) {\n-          promise.Set(value.status());\n-          return;\n-        }\n-\n-        MutableLiteralBase* literal = *std::move(value);\n-\n-        std::shared_ptr<TransposePlan> transpose;\n-        if (on_device_shape.IsArray()) {\n-          xla::Layout literal_layout;\n-          if (literal->shape().has_layout()) {\n-            literal_layout = literal->shape().layout();\n-          } else {\n-            literal_layout = LayoutUtil::MakeDescendingLayout(\n-                on_device_shape.dimensions().size());\n-          }\n-\n-          if (on_device_shape.layout() != literal_layout) {\n-            absl::InlinedVector<int64_t, 4> byte_strides(\n-                on_device_shape.dimensions().size());\n-            absl::Status s = ShapeUtil::ByteStrides(\n-                on_device_shape, absl::MakeSpan(byte_strides));\n-            if (!s.ok()) {\n-              promise.Set(s);\n-              return;\n-            }\n-            absl::Span<const int64_t> dims = on_device_shape.dimensions();\n-            absl::InlinedVector<int64_t, 4> permutation(dims.size());\n-            absl::c_reverse_copy(literal_layout.minor_to_major(),\n-                                 permutation.begin());\n-            TransposePlan::Options options;\n-            options.elem_size_in_bytes =\n-                primitive_util::ByteWidth(on_device_shape.element_type());\n-            options.dims = on_device_shape.dimensions();\n-            options.permutation = permutation;\n-            options.input_layout = TransposePlan::Striding{byte_strides};\n-            {\n-              absl::MutexLock lock(&client->transpose_mu_);\n-              absl::StatusOr<std::shared_ptr<TransposePlan>> t =\n-                  client->transpose_cache_.GetOrCreate(options);\n-              if (!t.ok()) {\n-                promise.Set(t.status());\n-                return;\n-              }\n-              transpose = *std::move(t);\n-            }\n-          }\n-        }\n-        promise.Set(std::make_pair(literal, std::move(transpose)));\n-      });\n-\n-  auto async_to_literal = [client = se_client, usage_event,\n-                           device_memory = std::move(device_memory),\n-                           definition_events = std::move(definition_events),\n-                           stream, device = se_device,\n-                           transfer_manager = std::move(transfer_manager),\n-                           on_device_shape{on_device_shape()},\n-                           literal_and_transpose =\n-                               std::move(literal_and_transpose_future),\n-                           promise = std::move(promise).ToShared(),\n-                           local_device]() mutable {\n-    absl::StatusOr<EventPool::Handle> event_or =\n-        local_device->event_pool().AllocateEvent(stream->parent());\n-    if (!event_or.ok()) {\n-      promise->Set(event_or.status());\n-      return;\n-    }\n-\n-    absl::Status defined_status = definition_events[0]->GetDefinedStatus();\n-    if (!defined_status.ok()) {\n-      promise->Set(defined_status);\n-      return;\n-    }\n-\n-    literal_and_transpose.OnReady(\n-        [client, usage_event = std::move(usage_event),\n-         device_memory = std::move(device_memory),\n-         definition_events = std::move(definition_events),\n-         stream = std::move(stream), device,\n-         transfer_manager = std::move(transfer_manager),\n-         on_device_shape = std::move(on_device_shape),\n-         promise = std::move(promise), local_device = std::move(local_device),\n-         event_or = std::move(event_or)](\n-            const absl::StatusOr<\n-                std::pair<MutableLiteralBase*, std::shared_ptr<TransposePlan>>>&\n-                value) mutable {\n-          if (!value.ok()) {\n-            promise->Set(value.status());\n-            return;\n-          }\n-\n-          auto [literal, transpose] = *std::move(value);\n-\n-          WaitForBufferDefinitionEventsOnStream(\n-              absl::MakeSpan(definition_events), stream);\n-\n-          ShapedBuffer shaped_buffer =\n-              device_memory->AsShapedBuffer(device, on_device_shape);\n-\n-          GenericTransferManager::LiteralFromDeviceMetadata transfer_metadata;\n-          // We never call device functions from the `done` callback.\n-          transfer_metadata.callback_is_host_callback_safe = true;\n-\n-          TransferManager::TransferMetadata* transfer_metadata_ptr =\n-              (dynamic_cast<GenericTransferManager*>(transfer_manager) !=\n-               nullptr)\n-                  ? &transfer_metadata\n-                  : nullptr;\n-\n-          if (transpose) {\n-            // Copy the device buffer to a temporary literal with descending\n-            // layout and transpose to the requested layout.\n-\n-            Shape stage_shape = literal->shape();\n-            *stage_shape.mutable_layout() = LayoutUtil::MakeDescendingLayout(\n-                stage_shape.dimensions().size());\n-            auto staged = std::make_shared<Literal>(stage_shape);\n-\n-            transfer_manager->TransferLiteralFromDevice(\n-                stream, shaped_buffer, staged.get(),\n-                [transpose = std::move(transpose), promise, staged,\n-                 literal = std::move(literal)](absl::Status status) mutable {\n-                  if (status.ok()) {\n-                    transpose->Execute(staged->untyped_data(),\n-                                       literal->untyped_data());\n-                  }\n-                  promise->Set(std::move(status));\n-                },\n-                transfer_metadata_ptr);\n-          } else {\n-            transfer_manager->TransferLiteralFromDevice(\n-                stream, shaped_buffer, literal,\n-                [promise](absl::Status status) mutable {\n-                  promise->Set(std::move(status));\n-                },\n-                transfer_metadata_ptr);\n-          }\n-\n-          client->ThenRecordEvent(usage_event, local_device,\n-                                  std::move(event_or).value(), stream);\n-\n-          absl::Status defined_status =\n-              local_device->ThenRelease(stream, device_memory);\n-          if (!defined_status.ok()) {\n-            promise->Set(defined_status);\n-          }\n-        });\n-  };\n-\n-  first_definition_event->ExecuteOrAddToFutureTasks(\n-      \"async_to_literal\", std::move(async_to_literal));\n-\n-  return FutureHelpers::WithProfiling(\n-      std::move(future),\n-      /*on_block_start=*/\n-      []() {\n-        tsl::profiler::TraceMeProducer traceme(\n-            \"PjRtStreamExecutorBuffer::ToLiteral\");\n-        VLOG(3) << \"PjRtStreamExecutorBuffer::ToLiteral\";\n-        return FutureHelpers::ProfilingKeys(\n-            {/*traceme_context_id =*/traceme.GetContextId()});\n-      },\n-      /*on_block_end=*/\n-      [](FutureHelpers::ProfilingKeys keys) {\n-        tsl::profiler::TraceMeConsumer traceme(\n-            \"PjRtStreamExecutorBuffer::ToLiteral\", keys.traceme_context_id);\n-      });\n-}\n-\n absl::StatusOr<size_t> PjRtStreamExecutorBuffer::GetOnDeviceSizeInBytes()\n     const {\n   absl::MutexLock lock(&mu_);"
        },
        {
            "sha": "5f71ce677bd076586f9fe2e8251195c055ed8334",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=7dbc996979d2da847311eb28f796770cefeeb065",
            "patch": "@@ -600,11 +600,6 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n   PjRtStreamExecutorBuffer& operator=(const PjRtStreamExecutorBuffer&) = delete;\n   PjRtStreamExecutorBuffer& operator=(PjRtStreamExecutorBuffer&&) = delete;\n \n-  using PjRtBuffer::ToLiteralSync;\n-  Future<> ToLiteral(MutableLiteralBase* literal) override;\n-  Future<> LazyToLiteral(\n-      absl::AnyInvocable<Future<MutableLiteralBase*>() &&> generator) override;\n-\n   absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n \n   Future<> CopyRawToHost(void* dst, int64_t offset,\n@@ -689,8 +684,6 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n                      const TrackedDeviceBuffer& src_device_buffer);\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CopyToDeviceMemorySpace(\n       PjRtDevice* dst_device, PjRtMemorySpace* dst_memory_space = nullptr);\n-\n-  Future<> ToLiteralHelper(Future<MutableLiteralBase*> literal);\n };\n \n // Allocates the device buffers for a buffer that will be used as the"
        },
        {
            "sha": "c3535afd0adf1206cafc4cb9b95ffaede2b79e74",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 114,
            "deletions": 3,
            "changes": 117,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=7dbc996979d2da847311eb28f796770cefeeb065",
            "patch": "@@ -16,13 +16,22 @@ limitations under the License.\n #include \"xla/pjrt/se_raw_buffer.h\"\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n #include <utility>\n \n+#include \"absl/algorithm/container.h\"\n+#include \"absl/container/inlined_vector.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/future.h\"\n+#include \"xla/layout.h\"\n+#include \"xla/layout_util.h\"\n+#include \"xla/literal.h\"\n #include \"xla/pjrt/buffer_sequencing_event.h\"\n #include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/local_device_state.h\"\n@@ -31,6 +40,10 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_stream_executor_client.h\"\n #include \"xla/pjrt/raw_buffer.h\"\n #include \"xla/pjrt/tracked_device_buffer.h\"\n+#include \"xla/pjrt/transpose.h\"\n+#include \"xla/primitive_util.h\"\n+#include \"xla/service/generic_transfer_manager.h\"\n+#include \"xla/shape_util.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/stream.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n@@ -201,9 +214,107 @@ void PjRtStreamExecutorRawBuffer::ReadDynamicShape(\n void PjRtStreamExecutorRawBuffer::CopyToLiteralAsync(\n     Promise<> promise, tsl::RCReference<PjRtDeviceEventPromise> device_promise,\n     MutableLiteralBase* literal, xla::Shape shape) {\n-  device_promise->SetError(\n-      absl::UnimplementedError(\"Cannot CopyToLiteralAsync.\"));\n-  promise.Set(absl::UnimplementedError(\"Cannot CopyToLiteralAsync.\"));\n+  auto usage_event = BufferSequencingEvent::Create(client_->thread_pool());\n+  client_->async_work_runner()->Schedule(\n+      [usage_event, local_device = local_device_,\n+       on_device_shape = std::move(shape), promise = std::move(promise),\n+       literal, client = client_, memory_space = memory_space_,\n+       device_buffer = device_buffer_]() mutable {\n+        std::shared_ptr<TransposePlan> transpose;\n+        se::Stream* stream = local_device->GetDeviceToHostStream();\n+        TransferManager* transfer_manager =\n+            client->client()->backend().transfer_manager();\n+        if (on_device_shape.IsArray()) {\n+          xla::Layout literal_layout;\n+          if (literal->shape().has_layout()) {\n+            literal_layout = literal->shape().layout();\n+          } else {\n+            literal_layout = LayoutUtil::MakeDescendingLayout(\n+                on_device_shape.dimensions().size());\n+          }\n+\n+          if (on_device_shape.layout() != literal_layout) {\n+            absl::InlinedVector<int64_t, 4> byte_strides(\n+                on_device_shape.dimensions().size());\n+            absl::Status s = ShapeUtil::ByteStrides(\n+                on_device_shape, absl::MakeSpan(byte_strides));\n+            if (!s.ok()) {\n+              promise.Set(s);\n+              client->SetEventAsError(usage_event, s);\n+              return;\n+            }\n+            absl::Span<const int64_t> dims = on_device_shape.dimensions();\n+            absl::InlinedVector<int64_t, 4> permutation(dims.size());\n+            absl::c_reverse_copy(literal_layout.minor_to_major(),\n+                                 permutation.begin());\n+            TransposePlan::Options options;\n+            options.elem_size_in_bytes =\n+                primitive_util::ByteWidth(on_device_shape.element_type());\n+            options.dims = on_device_shape.dimensions();\n+            options.permutation = permutation;\n+            options.input_layout = TransposePlan::Striding{byte_strides};\n+            {\n+              absl::MutexLock lock(&client->transpose_mu_);\n+              absl::StatusOr<std::shared_ptr<TransposePlan>> t =\n+                  client->transpose_cache_.GetOrCreate(options);\n+              if (!t.ok()) {\n+                promise.Set(t.status());\n+                client->SetEventAsError(usage_event, t.status());\n+                return;\n+              }\n+              transpose = *std::move(t);\n+            }\n+          }\n+        }\n+\n+        ShapedBuffer shaped_buffer = device_buffer->AsShapedBuffer(\n+            memory_space->devices()[0], on_device_shape);\n+\n+        GenericTransferManager::LiteralFromDeviceMetadata transfer_metadata;\n+        // We never call device functions from the `done` callback.\n+        transfer_metadata.callback_is_host_callback_safe = true;\n+\n+        TransferManager::TransferMetadata* transfer_metadata_ptr =\n+            (dynamic_cast<GenericTransferManager*>(transfer_manager) != nullptr)\n+                ? &transfer_metadata\n+                : nullptr;\n+\n+        if (transpose) {\n+          // Copy the device buffer to a temporary literal with descending\n+          // layout and transpose to the requested layout.\n+\n+          Shape stage_shape = literal->shape();\n+          *stage_shape.mutable_layout() =\n+              LayoutUtil::MakeDescendingLayout(stage_shape.dimensions().size());\n+          auto staged = std::make_shared<Literal>(stage_shape);\n+\n+          transfer_manager->TransferLiteralFromDevice(\n+              stream, shaped_buffer, staged.get(),\n+              [transpose = std::move(transpose),\n+               promise = std::move(promise).ToShared(), staged,\n+               literal = std::move(literal)](absl::Status status) mutable {\n+                if (status.ok()) {\n+                  transpose->Execute(staged->untyped_data(),\n+                                     literal->untyped_data());\n+                }\n+                promise->Set(std::move(status));\n+              },\n+              transfer_metadata_ptr);\n+        } else {\n+          transfer_manager->TransferLiteralFromDevice(\n+              stream, shaped_buffer, literal,\n+              [promise =\n+                   std::move(promise).ToShared()](absl::Status status) mutable {\n+                promise->Set(std::move(status));\n+              },\n+              transfer_metadata_ptr);\n+        }\n+\n+        CHECK_OK(local_device->AllocateAndRecordEvent(usage_event, stream));\n+      });\n+\n+  device_promise->Set(\n+      tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(std::move(usage_event)));\n }\n \n absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>"
        },
        {
            "sha": "a8a0d52f3684e7a9c15d3431a3eb954f2f61bb45",
            "filename": "third_party/xla/xla/tools/multihost_hlo_runner/functional_hlo_runner.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Ftools%2Fmultihost_hlo_runner%2Ffunctional_hlo_runner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7dbc996979d2da847311eb28f796770cefeeb065/third_party%2Fxla%2Fxla%2Ftools%2Fmultihost_hlo_runner%2Ffunctional_hlo_runner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fmultihost_hlo_runner%2Ffunctional_hlo_runner.cc?ref=7dbc996979d2da847311eb28f796770cefeeb065",
            "patch": "@@ -372,8 +372,10 @@ absl::StatusOr<PerDeviceLiteralVecType> FetchAndLogOutput(\n         TF_RET_CHECK(buffer->device() == output_buffers[i][0]->device())\n             << \"All outputs from a given vector of outputs should be for the \"\n                \"same device\";\n+        TF_ASSIGN_OR_RETURN(auto logical_shape,\n+                            buffer->logical_on_device_shape());\n         output_slice.emplace_back(\n-            ShapeUtil::DeviceShapeToHostShape(buffer->on_device_shape()));\n+            ShapeUtil::DeviceShapeToHostShape(logical_shape));\n         buffer->ToLiteral(&output_slice.back()).OnReady([&](absl::Status s) {\n           absl::MutexLock lock(mu);\n           --num_pending_transfers;"
        }
    ],
    "stats": {
        "total": 352,
        "additions": 117,
        "deletions": 235
    }
}