{
    "author": "tensorflower-gardener",
    "message": "Merge pull request #99207 from tensorflow:fixtypos31\n\nPiperOrigin-RevId: 797790333",
    "sha": "c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584",
    "files": [
        {
            "sha": "d63d84726d71a438dcb4aca5e157f688ae51a025",
            "filename": "tensorflow/python/ops/array_ops_stack.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Farray_ops_stack.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Farray_ops_stack.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Farray_ops_stack.py?ref=c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584",
            "patch": "@@ -183,7 +183,7 @@ def unstack(value, num=None, axis=0, name=\"unstack\"):\n   must be a constant value.\n \n   If you actually need a variable number of tensors in a single `tf.function`\n-  trace, you will need to use exlicit loops and a `tf.TensorArray` instead.\n+  trace, you will need to use explicit loops and a `tf.TensorArray` instead.\n \n   Args:\n     value: A rank `R > 0` `Tensor` to be unstacked."
        },
        {
            "sha": "f124bc691323931da3537efaca0c93ba52fdcbf9",
            "filename": "tensorflow/python/ops/image_ops_impl.py",
            "status": "modified",
            "additions": 18,
            "deletions": 18,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fimage_ops_impl.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fimage_ops_impl.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fimage_ops_impl.py?ref=c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584",
            "patch": "@@ -5277,13 +5277,13 @@ def _self_suppression(iou, _, iou_sum, iou_threshold):\n \n   Args:\n     iou: a tensor of shape [batch_size, num_boxes_with_padding] representing\n-    intersection over union.\n+      intersection over union.\n     iou_sum: a scalar tensor.\n     iou_threshold: a scalar tensor.\n \n   Returns:\n     iou_suppressed: a tensor of shape [batch_size, num_boxes_with_padding].\n-    iou_diff: a scalar tensor representing whether any box is supressed in\n+    iou_diff: a scalar tensor representing whether any box is suppressed in\n       this step.\n     iou_sum_new: a scalar tensor of shape [batch_size] that represents\n       the iou sum after suppression.\n@@ -5314,8 +5314,8 @@ def _cross_suppression(boxes, box_slice, iou_threshold, inner_idx, tile_size):\n     boxes: a tensor of shape [batch_size, num_boxes_with_padding, 4]\n     box_slice: a tensor of shape [batch_size, tile_size, 4]\n     iou_threshold: a scalar tensor\n-    inner_idx: a scalar tensor representing the tile index of the tile\n-      that is used to supress box_slice\n+    inner_idx: a scalar tensor representing the tile index of the tile that is\n+      used to suppress box_slice\n     tile_size: an integer representing the number of boxes in a tile\n \n   Returns:\n@@ -5520,7 +5520,7 @@ def non_max_suppression_padded_v2(boxes,\n   (i.e., lying in the interval `[0, 1]`) or absolute. The bounding box\n   coordinates are cannonicalized to `[y_min, x_min, y_max, x_max]`,\n   where `(y_min, x_min)` and `(y_max, x_mas)` are the coordinates of the lower\n-  left and upper right corner. User may indiciate the input box coordinates are\n+  left and upper right corner. User may indicate the input box coordinates are\n   already canonicalized to eliminate redundant work by setting\n   canonicalized_coordinates to `True`. Note that this algorithm is agnostic to\n   where the origin is in the coordinate system. Note that this algorithm is\n@@ -5581,25 +5581,25 @@ def non_max_suppression_padded_v2(boxes,\n     boxes: a tensor of rank 2 or higher with a shape of [..., num_boxes, 4].\n       Dimensions except the last two are batch dimensions. The last dimension\n       represents box coordinates, given as [y_1, x_1, y_2, x_2]. The coordinates\n-      on each dimension can be given in any order\n-      (see also `canonicalized_coordinates`) but must describe a box with\n-      a positive area.\n+      on each dimension can be given in any order (see also\n+      `canonicalized_coordinates`) but must describe a box with a positive area.\n     scores: a tensor of rank 1 or higher with a shape of [..., num_boxes].\n     max_output_size: a scalar integer `Tensor` representing the maximum number\n       of boxes to be selected by non max suppression.\n     iou_threshold: a float representing the threshold for deciding whether boxes\n       overlap too much with respect to IoU (intersection over union).\n     score_threshold: a float representing the threshold for box scores. Boxes\n       with a score that is not larger than this threshold will be suppressed.\n-    sorted_input: a boolean indicating whether the input boxes and scores\n-      are sorted in descending order by the score.\n-    canonicalized_coordinates: if box coordinates are given as\n-    `[y_min, x_min, y_max, x_max]`, setting to True eliminate redundant\n-     computation to canonicalize box coordinates.\n-    tile_size: an integer representing the number of boxes in a tile, i.e.,\n-      the maximum number of boxes per image that can be used to suppress other\n-      boxes in parallel; larger tile_size means larger parallelism and\n-      potentially more redundant work.\n+    sorted_input: a boolean indicating whether the input boxes and scores are\n+      sorted in descending order by the score.\n+    canonicalized_coordinates: if box coordinates are given as `[y_min, x_min,\n+      y_max, x_max]`, setting to True eliminate redundant computation to\n+      canonicalize box coordinates.\n+    tile_size: an integer representing the number of boxes in a tile, i.e., the\n+      maximum number of boxes per image that can be used to suppress other boxes\n+      in parallel; larger tile_size means larger parallelism and potentially\n+      more redundant work.\n+\n   Returns:\n     idx: a tensor with a shape of [..., num_boxes] representing the\n       indices selected by non-max suppression. The leading dimensions\n@@ -5666,7 +5666,7 @@ def _sort_scores_and_boxes(scores, boxes):\n       boxes = array_ops.concat([y_min, x_min, y_max, x_max], axis=2)\n   # TODO(@bhack): https://github.com/tensorflow/tensorflow/issues/56089\n   # this will be required after deprecation\n-  #else:\n+  # else:\n   #  y_1, x_1, y_2, x_2 = array_ops.split(\n   #      value=boxes, num_or_size_splits=4, axis=2)\n "
        },
        {
            "sha": "d7a56ac848243b6eca6d3b2623429eced68b2098",
            "filename": "tensorflow/python/ops/parsing_ops.py",
            "status": "modified",
            "additions": 11,
            "deletions": 18,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fparsing_ops.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fparsing_ops.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fparsing_ops.py?ref=c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584",
            "patch": "@@ -863,13 +863,13 @@ def decode_raw(input_bytes,\n \n   This is because each byte in the input is converted to a new value on the\n   output (if output type is `uint8` or `int8`, otherwise chunks of inputs get\n-  coverted to a new value):\n+  converted to a new value):\n \n   >>> tf.io.decode_raw(tf.constant(\"123\"), tf.uint8)\n   <tf.Tensor: shape=(3,), dtype=uint8, numpy=array([49, 50, 51], dtype=uint8)>\n   >>> tf.io.decode_raw(tf.constant(\"1234\"), tf.uint8)\n   <tf.Tensor: shape=(4,), dtype=uint8, numpy=array([49, 50, 51, 52], ...\n-  >>> # chuncked output\n+  >>> # chunked output\n   >>> tf.io.decode_raw(tf.constant(\"12\"), tf.uint16)\n   <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([12849], dtype=uint16)>\n   >>> tf.io.decode_raw(tf.constant(\"1234\"), tf.uint16)\n@@ -936,23 +936,16 @@ def decode_raw(input_bytes,\n          [14136, 13622, 13108, 12594]], dtype=int16)>\n \n   Args:\n-    input_bytes:\n-      Each element of the input Tensor is converted to an array of bytes.\n-\n-      Currently, this must be a tensor of strings (bytes), although semantically\n-      the operation should support any input.\n-    out_type:\n-      `DType` of the output. Acceptable types are `half`, `float`, `double`,\n-      `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`.\n-    little_endian:\n-      Whether the `input_bytes` data is in little-endian format. Data will be\n-      converted into host byte order if necessary.\n-    fixed_length:\n-      If set, the first `fixed_length` bytes of each element will be converted.\n-      Data will be zero-padded or truncated to the specified length.\n-\n+    input_bytes: Each element of the input Tensor is converted to an array of\n+      bytes.  Currently, this must be a tensor of strings (bytes), although\n+      semantically the operation should support any input.\n+    out_type: `DType` of the output. Acceptable types are `half`, `float`,\n+      `double`, `int32`, `uint16`, `uint8`, `int16`, `int8`, `int64`.\n+    little_endian: Whether the `input_bytes` data is in little-endian format.\n+      Data will be converted into host byte order if necessary.\n+    fixed_length: If set, the first `fixed_length` bytes of each element will be\n+      converted. Data will be zero-padded or truncated to the specified length.\n       `fixed_length` must be a multiple of the size of `out_type`.\n-\n       `fixed_length` must be specified if the elements of `input_bytes` are of\n       variable length.\n     name: A name for the operation (optional)."
        },
        {
            "sha": "727dce79e5d3f209e84d6308c51c95f742de4b7f",
            "filename": "tensorflow/python/ops/ragged/dynamic_ragged_shape.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fragged%2Fdynamic_ragged_shape.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fragged%2Fdynamic_ragged_shape.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fragged%2Fdynamic_ragged_shape.py?ref=c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584",
            "patch": "@@ -1441,7 +1441,7 @@ def _merge_with(\n       \"\"\"Merges all information between two specs.\n \n       Specs are expected to represent the same information modulo\n-      num_row_partitons.\n+      num_row_partitions.\n \n       If the specs are of different ranks, then fail.\n \n@@ -2163,7 +2163,7 @@ def broadcast_flat_values(self, rt, inner_dimensions=True):\n     If you add target_shape.row_partitions, you will get the full broadcasted\n     shape.\n \n-    If inner_dimensions==False, the result is a dense tensor that satsifies\n+    If inner_dimensions==False, the result is a dense tensor that satisfies\n     certain properties:\n     1. broadcast_to(result, target_shape.inner_shape) will give the result\n        if inner_dimensions==True.\n@@ -3048,7 +3048,7 @@ def gi_broadcast():\n     # Several optimizations can occur here.\n     # old_row_starts == old_value_rowids, because:\n     #   if you are broadcasting, then the source has uniform row length of 1,\n-    #   implying original_rp.row_splits == tf.range(orgininal_rp.nvals + 1)\n+    #   implying original_rp.row_splits == tf.range(original_rp.nvals + 1)\n     # When broadcasting, there is no need to add offsets to the\n     # source, because the source has size 1.\n     # Also, this is always valid, because we enforce source and destination"
        },
        {
            "sha": "2f9d240bbe6c7bd76108552ccb9ceabb215c74a4",
            "filename": "tensorflow/python/ops/special_math_ops.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fspecial_math_ops.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584/tensorflow%2Fpython%2Fops%2Fspecial_math_ops.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fspecial_math_ops.py?ref=c32a1bdfa0fcaa59d3dd077ddfff1f3bbfe2c584",
            "patch": "@@ -847,7 +847,7 @@ def _einsum_v1_parse_and_resolve_equation(equation, input_shapes):\n       tensor, filling in missing output subscripts and broadcast axes.\n \n   Raises:\n-    ValueError: If equation is in the uncorrect format, incorrect number of\n+    ValueError: If equation is in the incorrect format, incorrect number of\n       inputs given or broadcast axes \"...\" or output axes could not be resolved.\n   \"\"\"\n   equation = equation.replace(' ', '')"
        }
    ],
    "stats": {
        "total": 75,
        "additions": 34,
        "deletions": 41
    }
}