{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845711498",
    "sha": "ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
    "files": [
        {
            "sha": "24e9a8cc5fb98ee7ba95a7b9a7bb0dee469d27b2",
            "filename": "tensorflow/core/kernels/sparse/add_op.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fadd_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fadd_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fadd_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -93,19 +93,19 @@ class CSRSparseMatrixAddFunctor {\n \n     Tensor c_batch_ptr_t(cpu_allocator(), DT_INT32,\n                          TensorShape({batch_size + 1}));\n-    auto c_batch_ptr = c_batch_ptr_t.vec<int32>();\n+    auto c_batch_ptr = c_batch_ptr_t.vec<int32_t>();\n     c_batch_ptr(0) = 0;\n \n     Tensor c_row_ptr_t;\n     TF_RETURN_IF_ERROR(ctx_->allocate_temp(\n         DT_INT32, TensorShape({batch_size * (rows + 1)}), &c_row_ptr_t));\n-    auto c_row_ptr = c_row_ptr_t.vec<int32>();\n+    auto c_row_ptr = c_row_ptr_t.vec<int32_t>();\n \n     // Set the output row pointers to zero, in case we hit any empty\n     // combinations of rows in a and b.\n-    functor::SetZeroFunctor<Device, int32> set_zero;\n+    functor::SetZeroFunctor<Device, int32_t> set_zero;\n     const Device& d = ctx_->eigen_device<Device>();\n-    set_zero(d, c_row_ptr_t.flat<int32>());\n+    set_zero(d, c_row_ptr_t.flat<int32_t>());\n \n     size_t maxWorkspaceSize = 0;\n     for (int i = 0; i < batch_size; ++i) {\n@@ -125,7 +125,7 @@ class CSRSparseMatrixAddFunctor {\n     Tensor temp;\n     TF_RETURN_IF_ERROR(ctx_->allocate_temp(\n         DT_INT8, TensorShape({static_cast<int64_t>(maxWorkspaceSize)}), &temp));\n-    void* workspace = temp.flat<int8>().data();\n+    void* workspace = temp.flat<int8_t>().data();\n \n     for (int i = 0; i < batch_size; ++i) {\n       // Calculate output sizes for all minibatch entries.\n@@ -138,8 +138,8 @@ class CSRSparseMatrixAddFunctor {\n                                   a.values_vec<T>(i), a_dense_shape};\n       ConstCSRComponent<T> b_comp{b.row_pointers_vec(i), b.col_indices_vec(i),\n                                   b.values_vec<T>(i), b_dense_shape};\n-      TTypes<int32>::UnalignedVec c_row_ptr_i(&c_row_ptr(i * (rows + 1)),\n-                                              rows + 1);\n+      TTypes<int32_t>::UnalignedVec c_row_ptr_i(&c_row_ptr(i * (rows + 1)),\n+                                                rows + 1);\n       int c_nnz_i;\n       TF_RETURN_IF_ERROR(csr_geam.GetOutputStructure(\n           a_comp, b_comp, c_row_ptr_i, &c_nnz_i, workspace));"
        },
        {
            "sha": "6829145263baa56770a6ad4c15c6b7d0d0406b06",
            "filename": "tensorflow/core/kernels/sparse/csr_sparse_matrix_to_dense_op.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fcsr_sparse_matrix_to_dense_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fcsr_sparse_matrix_to_dense_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fcsr_sparse_matrix_to_dense_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -73,9 +73,9 @@ class CSRSparseMatrixToDenseCPUOp : public OpKernel {\n     const int64_t num_rows = dense_shape((rank == 2) ? 0 : 1);\n     const int64_t num_cols = dense_shape((rank == 2) ? 1 : 2);\n \n-    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32>();\n-    auto row_ptr = csr_sparse_matrix->row_pointers().vec<int32>();\n-    auto col_ind = csr_sparse_matrix->col_indices().vec<int32>();\n+    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32_t>();\n+    auto row_ptr = csr_sparse_matrix->row_pointers().vec<int32_t>();\n+    auto col_ind = csr_sparse_matrix->col_indices().vec<int32_t>();\n     auto values = csr_sparse_matrix->values().vec<T>();\n \n     TensorShape dense_tensor_shape;\n@@ -159,14 +159,14 @@ class CSRSparseMatrixToDenseGPUOp : public OpKernel {\n     functor::CSRSparseMatrixToCOOSparseMatrix<Device> csr_to_coo;\n     auto indices = indices_t.matrix<int64_t>();\n \n-    auto csr_row_ptr = csr_sparse_matrix->row_pointers().vec<int32>();\n-    auto coo_col_ind = csr_sparse_matrix->col_indices().vec<int32>();\n-    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32>();\n+    auto csr_row_ptr = csr_sparse_matrix->row_pointers().vec<int32_t>();\n+    auto coo_col_ind = csr_sparse_matrix->col_indices().vec<int32_t>();\n+    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32_t>();\n \n     Tensor coo_row_ind_t;\n     OP_REQUIRES_OK(c, c->allocate_temp(DT_INT32, TensorShape({total_nnz}),\n                                        &coo_row_ind_t));\n-    auto coo_row_ind = coo_row_ind_t.vec<int32>();\n+    auto coo_row_ind = coo_row_ind_t.vec<int32_t>();\n \n     // TODO(ebrevdo): just write a custom kernel that converts from\n     // csr to dense.\n@@ -176,9 +176,9 @@ class CSRSparseMatrixToDenseGPUOp : public OpKernel {\n         // No copying required.  Avoid failure case below.\n         continue;\n       }\n-      const TTypes<int32>::UnalignedConstVec csr_row_ptr_i(\n+      const TTypes<int32_t>::UnalignedConstVec csr_row_ptr_i(\n           &csr_row_ptr((rows + 1) * i), rows + 1);\n-      const TTypes<int32>::UnalignedVec coo_row_ind_i(\n+      const TTypes<int32_t>::UnalignedVec coo_row_ind_i(\n           &coo_row_ind(csr_sparse_matrix->batch_offset(i)), nnz_i);\n       OP_REQUIRES_OK(c, csr_to_coo(c, csr_row_ptr_i, coo_row_ind_i));\n     }"
        },
        {
            "sha": "903d3acbc67966eae3dc0cdc418dfb4759fa0a4d",
            "filename": "tensorflow/core/kernels/sparse/csr_sparse_matrix_to_sparse_tensor_op.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fcsr_sparse_matrix_to_sparse_tensor_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fcsr_sparse_matrix_to_sparse_tensor_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fcsr_sparse_matrix_to_sparse_tensor_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -91,9 +91,9 @@ class CSRSparseMatrixToSparseTensorCPUOp : public OpKernel {\n         c, c->allocate_output(0, TensorShape({total_nnz, rank}), &indices));\n     auto indices_flat = indices->template flat<int64_t>();\n \n-    auto csr_row_ptr = csr_sparse_matrix->row_pointers().vec<int32>();\n-    auto csr_col_ind = csr_sparse_matrix->col_indices().vec<int32>();\n-    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32>();\n+    auto csr_row_ptr = csr_sparse_matrix->row_pointers().vec<int32_t>();\n+    auto csr_col_ind = csr_sparse_matrix->col_indices().vec<int32_t>();\n+    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32_t>();\n \n     // Process the individual batches in parallel using a threadpool.\n     auto shard = [&](int64_t batch_begin, int64_t batch_end) {\n@@ -165,14 +165,14 @@ class CSRSparseMatrixToSparseTensorGPUOp : public OpKernel {\n     functor::CSRSparseMatrixToCOOSparseMatrix<Device> csr_to_coo;\n     auto indices = indices_t->matrix<int64_t>();\n \n-    auto csr_row_ptr = csr_sparse_matrix->row_pointers().vec<int32>();\n-    auto coo_col_ind = csr_sparse_matrix->col_indices().vec<int32>();\n-    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32>();\n+    auto csr_row_ptr = csr_sparse_matrix->row_pointers().vec<int32_t>();\n+    auto coo_col_ind = csr_sparse_matrix->col_indices().vec<int32_t>();\n+    auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32_t>();\n \n     Tensor coo_row_ind_t;\n     OP_REQUIRES_OK(c, c->allocate_temp(DT_INT32, TensorShape({total_nnz}),\n                                        &coo_row_ind_t));\n-    auto coo_row_ind = coo_row_ind_t.vec<int32>();\n+    auto coo_row_ind = coo_row_ind_t.vec<int32_t>();\n \n     // TODO(ebrevdo): Convert to one or two single kernel calls,\n     // where the kernels are batch-friendly.\n@@ -182,9 +182,9 @@ class CSRSparseMatrixToSparseTensorGPUOp : public OpKernel {\n         // No copying required.  Avoid failure case below.\n         continue;\n       }\n-      const TTypes<int32>::UnalignedConstVec csr_row_ptr_i(\n+      const TTypes<int32_t>::UnalignedConstVec csr_row_ptr_i(\n           &csr_row_ptr((rows + 1) * i), rows + 1);\n-      const TTypes<int32>::UnalignedVec coo_row_ind_i(\n+      const TTypes<int32_t>::UnalignedVec coo_row_ind_i(\n           &coo_row_ind(csr_sparse_matrix->batch_offset(i)), nnz_i);\n       OP_REQUIRES_OK(c, csr_to_coo(c, csr_row_ptr_i, coo_row_ind_i));\n     }"
        },
        {
            "sha": "11601d8cf3b6efcd063f363546bd0637bf7bd7f9",
            "filename": "tensorflow/core/kernels/sparse/dense_to_csr_sparse_matrix_op.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fdense_to_csr_sparse_matrix_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fdense_to_csr_sparse_matrix_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fdense_to_csr_sparse_matrix_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -99,15 +99,16 @@ class DenseToCSRSparseMatrixCPUOp : public OpKernel {\n                        TensorShape({(num_rows + 1) * batch_size}));\n \n     // Fill the row pointers with zeros.\n-    functor::SetZeroFunctor<Device, int32> set_zero;\n-    set_zero(ctx->eigen_device<Device>(), csr_row_ptr.flat<int32>());\n+    functor::SetZeroFunctor<Device, int32_t> set_zero;\n+    set_zero(ctx->eigen_device<Device>(), csr_row_ptr.flat<int32_t>());\n \n     // Convert from COO to CSR format.\n     functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n     OP_REQUIRES_OK(\n-        ctx, coo_to_csr(batch_size, num_rows, num_cols,\n-                        indices.matrix<int64_t>(), batch_ptr.vec<int32>(),\n-                        csr_row_ptr.vec<int32>(), csr_col_ind.vec<int32>()));\n+        ctx,\n+        coo_to_csr(batch_size, num_rows, num_cols, indices.matrix<int64_t>(),\n+                   batch_ptr.vec<int32_t>(), csr_row_ptr.vec<int32_t>(),\n+                   csr_col_ind.vec<int32_t>()));\n \n     CSRSparseMatrix output_csr_matrix;\n     OP_REQUIRES_OK(ctx, CSRSparseMatrix::CreateCSRSparseMatrix("
        },
        {
            "sha": "dd84b556e002abc39811bdff142681ad3c05efb6",
            "filename": "tensorflow/core/kernels/sparse/kernels.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -31,8 +31,8 @@ namespace functor {\n \n absl::Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(\n     int64_t batch_size, int num_rows, int num_cols,\n-    TTypes<int64_t>::ConstMatrix indices, TTypes<int32>::Vec batch_ptr,\n-    TTypes<int32>::Vec csr_row_ptr, TTypes<int32>::Vec csr_col_ind) {\n+    TTypes<int64_t>::ConstMatrix indices, TTypes<int32_t>::Vec batch_ptr,\n+    TTypes<int32_t>::Vec csr_row_ptr, TTypes<int32_t>::Vec csr_col_ind) {\n   // Validate inputs.\n   if (batch_ptr.size() != batch_size + 1) {\n     return errors::InvalidArgument("
        },
        {
            "sha": "14441de5d3cad3d43c7c05ccaa9efaf4391e3311",
            "filename": "tensorflow/core/kernels/sparse/kernels.h",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels.h?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -42,7 +42,7 @@ template <typename Device>\n struct CalculateNNZPerBatchMatrixFromIndices {\n   absl::Status operator()(OpKernelContext* c,\n                           TTypes<int64_t>::ConstMatrix indices,\n-                          TTypes<int32>::Vec nnz_per_batch);\n+                          TTypes<int32_t>::Vec nnz_per_batch);\n };\n \n // Split a subset of a SparseTensors' indices into two vectors:\n@@ -63,8 +63,8 @@ template <typename Device>\n struct SparseTensorToCOOSparseMatrix {\n   void operator()(const Device& d, TTypes<int64_t>::ConstVec host_dense_shape,\n                   TTypes<int64_t>::ConstMatrix indices,\n-                  TTypes<int32>::Vec coo_row_ind,\n-                  TTypes<int32>::Vec coo_col_ind);\n+                  TTypes<int32_t>::Vec coo_row_ind,\n+                  TTypes<int32_t>::Vec coo_col_ind);\n };\n \n // Write coo batch, row, and column vectors to output matrix indices:\n@@ -89,9 +89,9 @@ template <typename Device>\n struct COOSparseMatrixToSparseTensor {\n   absl::Status operator()(OpKernelContext* c,\n                           TTypes<int64_t>::ConstVec host_dense_shape,\n-                          TTypes<int32>::ConstVec host_batch_ptrs,\n-                          TTypes<int32>::Vec coo_row_ind,\n-                          TTypes<int32>::ConstVec coo_col_ind,\n+                          TTypes<int32_t>::ConstVec host_batch_ptrs,\n+                          TTypes<int32_t>::Vec coo_row_ind,\n+                          TTypes<int32_t>::ConstVec coo_col_ind,\n                           TTypes<int64_t>::Matrix indices);\n };\n \n@@ -105,8 +105,8 @@ struct COOSparseMatrixToSparseTensor {\n template <typename Device>\n struct COOSparseMatrixToCSRSparseMatrix {\n   absl::Status operator()(OpKernelContext* c, const int rows, const int cols,\n-                          TTypes<int32>::UnalignedVec coo_row_ind,\n-                          TTypes<int32>::UnalignedVec csr_row_ptr);\n+                          TTypes<int32_t>::UnalignedVec coo_row_ind,\n+                          TTypes<int32_t>::UnalignedVec csr_row_ptr);\n };\n \n // Convert a matrix of (batched) coo row and column indices to CSR SparseMatrix\n@@ -126,9 +126,9 @@ struct COOSparseMatrixToCSRSparseMatrix {\n struct SparseTensorToCSRSparseMatrixCPUFunctor {\n   absl::Status operator()(int64_t batch_size, int num_rows, int num_cols,\n                           TTypes<int64_t>::ConstMatrix indices,\n-                          TTypes<int32>::Vec batch_ptr,\n-                          TTypes<int32>::Vec csr_row_ptr,\n-                          TTypes<int32>::Vec csr_col_ind);\n+                          TTypes<int32_t>::Vec batch_ptr,\n+                          TTypes<int32_t>::Vec csr_row_ptr,\n+                          TTypes<int32_t>::Vec csr_col_ind);\n };\n \n // Convert a vector of csr row pointers to coo row indices.\n@@ -141,8 +141,8 @@ struct SparseTensorToCSRSparseMatrixCPUFunctor {\n template <typename Device>\n struct CSRSparseMatrixToCOOSparseMatrix {\n   absl::Status operator()(OpKernelContext* c,\n-                          TTypes<int32>::UnalignedConstVec csr_row_ptr,\n-                          TTypes<int32>::UnalignedVec coo_row_ind);\n+                          TTypes<int32_t>::UnalignedConstVec csr_row_ptr,\n+                          TTypes<int32_t>::UnalignedVec coo_row_ind);\n };\n \n // Calculates C = matmul(A, B) or C = matmul(A, B)^T, where A is in CSR format\n@@ -176,10 +176,10 @@ struct CSRStructureModifyingFunctor {\n                                         const ConstCSRComponent<T>& b,\n                                         size_t* bufferSize) = 0;\n \n-  virtual absl::Status GetOutputStructure(const ConstCSRComponent<T>& a,\n-                                          const ConstCSRComponent<T>& b,\n-                                          TTypes<int32>::UnalignedVec c_row_ptr,\n-                                          int* output_nnz, void* workspace) = 0;\n+  virtual absl::Status GetOutputStructure(\n+      const ConstCSRComponent<T>& a, const ConstCSRComponent<T>& b,\n+      TTypes<int32_t>::UnalignedVec c_row_ptr, int* output_nnz,\n+      void* workspace) = 0;\n \n   virtual absl::Status Compute(const ConstCSRComponent<T>& a,\n                                const ConstCSRComponent<T>& b,"
        },
        {
            "sha": "dc13ef622563575bef1321b1b76f0d4b26c0dd91",
            "filename": "tensorflow/core/kernels/sparse/kernels_test.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 32,
            "changes": 65,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fkernels_test.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -38,19 +38,19 @@ TEST(SparseTensorToCSRSparseMatrix, SingleBatchConversion) {\n       test::AsTensor<int64_t>({0, 0, 2, 3, 2, 4, 3, 0}, TensorShape({4, 2}));\n   Tensor batch_ptr(DT_INT32, {2});\n   Tensor csr_col_ind(DT_INT32, {4});\n-  auto csr_row_ptr = test::AsTensor<int32>({0, 0, 0, 0, 0});\n+  auto csr_row_ptr = test::AsTensor<int32_t>({0, 0, 0, 0, 0});\n \n   functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n   TF_EXPECT_OK(coo_to_csr(/*batch_size=*/1, /*num_rows=*/4, /*num_cols=*/5,\n                           indices.template matrix<int64_t>(),\n-                          batch_ptr.vec<int32>(), csr_row_ptr.vec<int32>(),\n-                          csr_col_ind.vec<int32>()));\n-\n-  test::ExpectTensorEqual<int32>(batch_ptr, test::AsTensor<int32>({0, 4}));\n-  test::ExpectTensorEqual<int32>(csr_row_ptr,\n-                                 test::AsTensor<int32>({0, 1, 1, 3, 4}));\n-  test::ExpectTensorEqual<int32>(csr_col_ind,\n-                                 test::AsTensor<int32>({0, 3, 4, 0}));\n+                          batch_ptr.vec<int32_t>(), csr_row_ptr.vec<int32_t>(),\n+                          csr_col_ind.vec<int32_t>()));\n+\n+  test::ExpectTensorEqual<int32_t>(batch_ptr, test::AsTensor<int32_t>({0, 4}));\n+  test::ExpectTensorEqual<int32_t>(csr_row_ptr,\n+                                   test::AsTensor<int32_t>({0, 1, 1, 3, 4}));\n+  test::ExpectTensorEqual<int32_t>(csr_col_ind,\n+                                   test::AsTensor<int32_t>({0, 3, 4, 0}));\n }\n \n TEST(SparseTensorToCSRSparseMatrix, BatchConversion) {\n@@ -63,21 +63,22 @@ TEST(SparseTensorToCSRSparseMatrix, BatchConversion) {\n   Tensor csr_col_ind(DT_INT32, {3});\n   // row pointers have size = batch_size * (num_rows + 1) = 3 * 4 = 12\n   Tensor csr_row_ptr(DT_INT32, {12});\n-  test::FillFn<int32>(&csr_row_ptr, [](int unused) { return 0; });\n+  test::FillFn<int32_t>(&csr_row_ptr, [](int unused) { return 0; });\n \n   functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n   TF_EXPECT_OK(coo_to_csr(/*batch_size=*/3, /*num_rows=*/3, /*num_cols=*/4,\n                           indices.template matrix<int64_t>(),\n-                          batch_ptr.vec<int32>(), csr_row_ptr.vec<int32>(),\n-                          csr_col_ind.vec<int32>()));\n-\n-  test::ExpectTensorEqual<int32>(batch_ptr,\n-                                 test::AsTensor<int32>({0, 2, 2, 3}));\n-  test::ExpectTensorEqual<int32>(csr_row_ptr,\n-                                 test::AsTensor<int32>({0, 1, 1, 2,  //\n-                                                        0, 0, 0, 0,  //\n-                                                        0, 1, 1, 1}));\n-  test::ExpectTensorEqual<int32>(csr_col_ind, test::AsTensor<int32>({0, 3, 1}));\n+                          batch_ptr.vec<int32_t>(), csr_row_ptr.vec<int32_t>(),\n+                          csr_col_ind.vec<int32_t>()));\n+\n+  test::ExpectTensorEqual<int32_t>(batch_ptr,\n+                                   test::AsTensor<int32_t>({0, 2, 2, 3}));\n+  test::ExpectTensorEqual<int32_t>(csr_row_ptr,\n+                                   test::AsTensor<int32_t>({0, 1, 1, 2,  //\n+                                                            0, 0, 0, 0,  //\n+                                                            0, 1, 1, 1}));\n+  test::ExpectTensorEqual<int32_t>(csr_col_ind,\n+                                   test::AsTensor<int32_t>({0, 3, 1}));\n }\n \n TEST(SparseTensorToCSRSparseMatrix, InvalidBatchThrowsIllegalArgument) {\n@@ -90,13 +91,13 @@ TEST(SparseTensorToCSRSparseMatrix, InvalidBatchThrowsIllegalArgument) {\n   Tensor csr_col_ind(DT_INT32, {3});\n   // row pointers have size = batch_size * (num_rows + 1) = 3 * 4 = 12\n   Tensor csr_row_ptr(DT_INT32, {12});\n-  test::FillFn<int32>(&csr_row_ptr, [](int unused) { return 0; });\n+  test::FillFn<int32_t>(&csr_row_ptr, [](int unused) { return 0; });\n \n   functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n   EXPECT_THAT(\n       coo_to_csr(/*batch_size=*/3, /*num_rows=*/3, /*num_cols=*/4,\n-                 indices.template matrix<int64_t>(), batch_ptr.vec<int32>(),\n-                 csr_row_ptr.vec<int32>(), csr_col_ind.vec<int32>()),\n+                 indices.template matrix<int64_t>(), batch_ptr.vec<int32_t>(),\n+                 csr_row_ptr.vec<int32_t>(), csr_col_ind.vec<int32_t>()),\n       absl_testing::StatusIs(tsl::error::Code::INVALID_ARGUMENT,\n                              ::testing::ContainsRegex(\n                                  \"Batch index .* is outside of valid range\")));\n@@ -111,13 +112,13 @@ TEST(SparseTensorToCSRSparseMatrix, InvalidRowThrowsIllegalArgument) {\n   Tensor csr_col_ind(DT_INT32, {3});\n   // row pointers have size = batch_size * (num_rows + 1) = 3 * 4 = 12\n   Tensor csr_row_ptr(DT_INT32, {12});\n-  test::FillFn<int32>(&csr_row_ptr, [](int unused) { return 0; });\n+  test::FillFn<int32_t>(&csr_row_ptr, [](int unused) { return 0; });\n \n   functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n   EXPECT_THAT(\n       coo_to_csr(/*batch_size=*/3, /*num_rows=*/3, /*num_cols=*/4,\n-                 indices.template matrix<int64_t>(), batch_ptr.vec<int32>(),\n-                 csr_row_ptr.vec<int32>(), csr_col_ind.vec<int32>()),\n+                 indices.template matrix<int64_t>(), batch_ptr.vec<int32_t>(),\n+                 csr_row_ptr.vec<int32_t>(), csr_col_ind.vec<int32_t>()),\n       absl_testing::StatusIs(\n           tsl::error::Code::INVALID_ARGUMENT,\n           ::testing::ContainsRegex(\"Row index .* is outside of valid range\")));\n@@ -132,13 +133,13 @@ TEST(SparseTensorToCSRSparseMatrix, InvalidColThrowsIllegalArgument) {\n   Tensor csr_col_ind(DT_INT32, {3});\n   // row pointers have size = batch_size * (num_rows + 1) = 3 * 4 = 12\n   Tensor csr_row_ptr(DT_INT32, {12});\n-  test::FillFn<int32>(&csr_row_ptr, [](int unused) { return 0; });\n+  test::FillFn<int32_t>(&csr_row_ptr, [](int unused) { return 0; });\n \n   functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n   EXPECT_THAT(\n       coo_to_csr(/*batch_size=*/3, /*num_rows=*/3, /*num_cols=*/4,\n-                 indices.template matrix<int64_t>(), batch_ptr.vec<int32>(),\n-                 csr_row_ptr.vec<int32>(), csr_col_ind.vec<int32>()),\n+                 indices.template matrix<int64_t>(), batch_ptr.vec<int32_t>(),\n+                 csr_row_ptr.vec<int32_t>(), csr_col_ind.vec<int32_t>()),\n       absl_testing::StatusIs(tsl::error::Code::INVALID_ARGUMENT,\n                              ::testing::ContainsRegex(\n                                  \"Column index .* is outside of valid range\")));\n@@ -154,13 +155,13 @@ TEST(SparseTensorToCSRSparseMatrix, InvalidRankIllegalArgument) {\n   Tensor csr_col_ind(DT_INT32, {3});\n   // row pointers have size = batch_size * (num_rows + 1) = 3 * 4 = 12\n   Tensor csr_row_ptr(DT_INT32, {12});\n-  test::FillFn<int32>(&csr_row_ptr, [](int unused) { return 0; });\n+  test::FillFn<int32_t>(&csr_row_ptr, [](int unused) { return 0; });\n \n   functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n   EXPECT_THAT(\n       coo_to_csr(/*batch_size=*/3, /*num_rows=*/3, /*num_cols=*/4,\n-                 indices.template matrix<int64_t>(), batch_ptr.vec<int32>(),\n-                 csr_row_ptr.vec<int32>(), csr_col_ind.vec<int32>()),\n+                 indices.template matrix<int64_t>(), batch_ptr.vec<int32_t>(),\n+                 csr_row_ptr.vec<int32_t>(), csr_col_ind.vec<int32_t>()),\n       absl_testing::StatusIs(tsl::error::Code::INVALID_ARGUMENT,\n                              ::testing::ContainsRegex(\n                                  \"Indices must have either 2 or 3 columns.\")));"
        },
        {
            "sha": "ad8095b1cdc9255cbcfbd9f9a931783ca9945cbc",
            "filename": "tensorflow/core/kernels/sparse/nnz_op.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fnnz_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fnnz_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fnnz_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -53,7 +53,7 @@ class CSRNNZOp : public OpKernel {\n           c, nnz_shape.AddDimWithStatus(csr_sparse_matrix->batch_size()));\n     }\n     OP_REQUIRES_OK(c, c->allocate_output(0, nnz_shape, &nnz_t));\n-    auto nnz = nnz_t->flat<int32>();\n+    auto nnz = nnz_t->flat<int32_t>();\n     for (int i = 0; i < csr_sparse_matrix->batch_size(); ++i) {\n       nnz(i) = csr_sparse_matrix->nnz(i);\n     }"
        },
        {
            "sha": "afe0a1322ba8660e18b3bc846178417cb0d5994b",
            "filename": "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_cholesky_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_cholesky_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_cholesky_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -93,7 +93,7 @@ class CSRSparseCholeskyCPUOp : public OpKernel {\n \n     // Allocate batch pointers.\n     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));\n-    auto batch_ptr_vec = batch_ptr.vec<int32>();\n+    auto batch_ptr_vec = batch_ptr.vec<int32_t>();\n     batch_ptr_vec(0) = 0;\n \n     // Temporary vector of Eigen SparseMatrices to store the Sparse Cholesky\n@@ -130,7 +130,7 @@ class CSRSparseCholeskyCPUOp : public OpKernel {\n                                    Eigen::NaturalOrdering<int>>\n                   solver;\n               auto permutation_indices_flat =\n-                  input_permutation_indices.flat<int32>().data();\n+                  input_permutation_indices.flat<int32_t>().data();\n \n               // Invert the fill-in reducing ordering and apply it to the input\n               // sparse matrix.\n@@ -183,8 +183,8 @@ class CSRSparseCholeskyCPUOp : public OpKernel {\n     Tensor output_col_ind(cpu_allocator(), DT_INT32, TensorShape({total_nnz}));\n     Tensor output_values(cpu_allocator(), DataTypeToEnum<T>::value,\n                          TensorShape({total_nnz}));\n-    auto output_row_ptr_ptr = output_row_ptr.flat<int32>().data();\n-    auto output_col_ind_ptr = output_col_ind.flat<int32>().data();\n+    auto output_row_ptr_ptr = output_row_ptr.flat<int32_t>().data();\n+    auto output_col_ind_ptr = output_col_ind.flat<int32_t>().data();\n     auto output_values_ptr = output_values.flat<T>().data();\n \n     // Copy the output matrices from each batch into the CSRSparseMatrix"
        },
        {
            "sha": "0455fa374538fcaa698344f80b85a1c1605fe081",
            "filename": "tensorflow/core/kernels/sparse/sparse_mat_mul_op.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_mat_mul_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_mat_mul_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_mat_mul_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -188,7 +188,7 @@ class CSRSparseMatMulCPUOp : public OpKernel {\n \n     // Set batch pointers.\n     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));\n-    auto batch_ptr_vec = batch_ptr.vec<int32>();\n+    auto batch_ptr_vec = batch_ptr.vec<int32_t>();\n     batch_ptr_vec(0) = 0;\n \n     // Store intermediate matrix products for each batch.\n@@ -248,8 +248,8 @@ class CSRSparseMatMulCPUOp : public OpKernel {\n     Tensor output_col_ind(cpu_allocator(), DT_INT32, TensorShape({total_nnz}));\n     Tensor output_values(cpu_allocator(), DataTypeToEnum<T>::value,\n                          TensorShape({total_nnz}));\n-    auto output_row_ptr_ptr = output_row_ptr.flat<int32>().data();\n-    auto output_col_ind_ptr = output_col_ind.flat<int32>().data();\n+    auto output_row_ptr_ptr = output_row_ptr.flat<int32_t>().data();\n+    auto output_col_ind_ptr = output_col_ind.flat<int32_t>().data();\n     auto output_values_ptr = output_values.flat<T>().data();\n \n     // Copy the output matrices from each batch into the CSRSparseMatrix\n@@ -411,14 +411,14 @@ class CSRSparseMatMulGPUOp : public OpKernel {\n \n     Tensor c_batch_ptr_t(cpu_allocator(), DT_INT32,\n                          TensorShape({batch_size + 1}));\n-    auto c_batch_ptr = c_batch_ptr_t.vec<int32>();\n+    auto c_batch_ptr = c_batch_ptr_t.vec<int32_t>();\n     c_batch_ptr(0) = 0;\n \n     Tensor c_row_ptr_t;\n     OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                             DT_INT32, TensorShape({batch_size * (rows + 1)}),\n                             &c_row_ptr_t));\n-    auto c_row_ptr = c_row_ptr_t.vec<int32>();\n+    auto c_row_ptr = c_row_ptr_t.vec<int32_t>();\n \n     // Possibly transpose a.\n     const CSRSparseMatrix* a_input_matrix;\n@@ -643,8 +643,8 @@ class CSRSparseMatMulGPUOp : public OpKernel {\n                                   b_input_matrix->values_vec<T>(b_batch),\n                                   b_input_dense_shape};\n \n-      TTypes<int32>::UnalignedVec c_row_ptr_i(&c_row_ptr(i * (rows + 1)),\n-                                              rows + 1);\n+      TTypes<int32_t>::UnalignedVec c_row_ptr_i(&c_row_ptr(i * (rows + 1)),\n+                                                rows + 1);\n \n       int c_nnz_i;\n       OP_REQUIRES_OK(ctx,"
        },
        {
            "sha": "d3db1f29871d80bf691dd20321089a753e2a56db",
            "filename": "tensorflow/core/kernels/sparse/sparse_matrix.h",
            "status": "modified",
            "additions": 24,
            "deletions": 22,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_matrix.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_matrix.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_matrix.h?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -217,40 +217,40 @@ class CSRSparseMatrix {\n     return dense_shape_;\n   }\n \n-  inline TTypes<int32>::UnalignedVec row_pointers_vec(int batch) {\n+  inline TTypes<int32_t>::UnalignedVec row_pointers_vec(int batch) {\n     DCHECK(valid());\n     DCHECK_LT(batch, batch_size());\n     const int64_t rows = dense_shape().vec<int64_t>()((dims() == 2) ? 0 : 1);\n     const int offset = batch * (rows + 1);\n-    return TTypes<int32>::UnalignedVec(row_pointers_vec_->data() + offset,\n-                                       rows + 1);\n+    return TTypes<int32_t>::UnalignedVec(row_pointers_vec_->data() + offset,\n+                                         rows + 1);\n   }\n \n-  inline TTypes<int32>::UnalignedConstVec row_pointers_vec(int batch) const {\n+  inline TTypes<int32_t>::UnalignedConstVec row_pointers_vec(int batch) const {\n     DCHECK(valid());\n     DCHECK_LT(batch, batch_size());\n     const int64_t rows = dense_shape().vec<int64_t>()((dims() == 2) ? 0 : 1);\n     const int offset = batch * (rows + 1);\n-    return TTypes<int32>::UnalignedConstVec(row_pointers_vec_->data() + offset,\n-                                            rows + 1);\n+    return TTypes<int32_t>::UnalignedConstVec(\n+        row_pointers_vec_->data() + offset, rows + 1);\n   }\n \n-  inline TTypes<int32>::UnalignedVec col_indices_vec(int batch) {\n+  inline TTypes<int32_t>::UnalignedVec col_indices_vec(int batch) {\n     DCHECK(valid());\n     DCHECK_LT(batch, batch_size());\n     const int offset = (*batch_pointers_vec_)(batch);\n     const int nnz_in_batch = nnz(batch);\n-    return TTypes<int32>::UnalignedVec(col_indices_vec_->data() + offset,\n-                                       nnz_in_batch);\n+    return TTypes<int32_t>::UnalignedVec(col_indices_vec_->data() + offset,\n+                                         nnz_in_batch);\n   }\n \n-  inline TTypes<int32>::UnalignedConstVec col_indices_vec(int batch) const {\n+  inline TTypes<int32_t>::UnalignedConstVec col_indices_vec(int batch) const {\n     DCHECK(valid());\n     DCHECK_LT(batch, batch_size());\n     const int offset = (*batch_pointers_vec_)(batch);\n     const int nnz_in_batch = nnz(batch);\n-    return TTypes<int32>::UnalignedConstVec(col_indices_vec_->data() + offset,\n-                                            nnz_in_batch);\n+    return TTypes<int32_t>::UnalignedConstVec(col_indices_vec_->data() + offset,\n+                                              nnz_in_batch);\n   }\n \n   template <typename T>\n@@ -411,9 +411,11 @@ class CSRSparseMatrix {\n   void SetupVecs() {\n     if (!metadata_.validated) return;\n     batch_pointers_vec_.reset(\n-        new TTypes<int32>::Vec(batch_pointers_.vec<int32>()));\n-    row_pointers_vec_.reset(new TTypes<int32>::Vec(row_pointers_.vec<int32>()));\n-    col_indices_vec_.reset(new TTypes<int32>::Vec(col_indices_.vec<int32>()));\n+        new TTypes<int32_t>::Vec(batch_pointers_.vec<int32_t>()));\n+    row_pointers_vec_.reset(\n+        new TTypes<int32_t>::Vec(row_pointers_.vec<int32_t>()));\n+    col_indices_vec_.reset(\n+        new TTypes<int32_t>::Vec(col_indices_.vec<int32_t>()));\n   }\n \n   void ClearVecs() {\n@@ -537,9 +539,9 @@ class CSRSparseMatrix {\n   Tensor row_pointers_;\n   Tensor col_indices_;\n   Tensor values_;\n-  std::unique_ptr<TTypes<int32>::Vec> batch_pointers_vec_;\n-  std::unique_ptr<TTypes<int32>::Vec> row_pointers_vec_;\n-  std::unique_ptr<TTypes<int32>::Vec> col_indices_vec_;\n+  std::unique_ptr<TTypes<int32_t>::Vec> batch_pointers_vec_;\n+  std::unique_ptr<TTypes<int32_t>::Vec> row_pointers_vec_;\n+  std::unique_ptr<TTypes<int32_t>::Vec> col_indices_vec_;\n };\n \n // Call BinaryFunctor<Device, T>()(ctx, a, b, c)\n@@ -616,16 +618,16 @@ absl::Status CSRSparseMatrixUnaryHelper(OpKernelContext* ctx,\n \n template <typename T>\n struct ConstCSRComponent {\n-  TTypes<int32>::UnalignedConstVec row_ptr;\n-  TTypes<int32>::UnalignedConstVec col_ind;\n+  TTypes<int32_t>::UnalignedConstVec row_ptr;\n+  TTypes<int32_t>::UnalignedConstVec col_ind;\n   typename TTypes<T>::UnalignedConstVec values;\n   TTypes<int64_t>::ConstVec dense_shape_host;\n };\n \n template <typename T>\n struct CSRComponent {\n-  TTypes<int32>::UnalignedVec row_ptr;\n-  TTypes<int32>::UnalignedVec col_ind;\n+  TTypes<int32_t>::UnalignedVec row_ptr;\n+  TTypes<int32_t>::UnalignedVec col_ind;\n   typename TTypes<T>::UnalignedVec values;\n   TTypes<int64_t>::Vec dense_shape_host;\n };"
        },
        {
            "sha": "353a8ecb0aa86be003f8d814ea57738bd6165071",
            "filename": "tensorflow/core/kernels/sparse/sparse_matrix_components_op.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_matrix_components_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_matrix_components_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_matrix_components_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -57,7 +57,7 @@ class CSRSparseMatrixComponentsOp : public OpKernel {\n     OP_REQUIRES(c, index_t.dims() == 0,\n                 errors::InvalidArgument(\"index should be a scalar, but saw: \",\n                                         index_t.DebugString()));\n-    int32_t index = index_t.scalar<int32>()();\n+    int32_t index = index_t.scalar<int32_t>()();\n     OP_REQUIRES(c, index >= 0 && index < csr_sparse_matrix->batch_size(),\n                 errors::InvalidArgument(\"index (\", index, \") not in [0, \",\n                                         csr_sparse_matrix->batch_size(), \")\"));\n@@ -67,7 +67,7 @@ class CSRSparseMatrixComponentsOp : public OpKernel {\n       c->set_output(1, csr_sparse_matrix->col_indices());\n       c->set_output(2, csr_sparse_matrix->values());\n     } else {\n-      auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32>();\n+      auto batch_ptrs = csr_sparse_matrix->batch_pointers().vec<int32_t>();\n       auto dense_shape = csr_sparse_matrix->dense_shape().vec<int64_t>();\n       int64_t rows = dense_shape(1);\n       int nnz = batch_ptrs(index + 1) - batch_ptrs(index);\n@@ -78,23 +78,23 @@ class CSRSparseMatrixComponentsOp : public OpKernel {\n           c, c->allocate_output(0, TensorShape({rows + 1}), &row_ptrs_t));\n       OP_REQUIRES_OK(c, c->allocate_output(1, TensorShape({nnz}), &col_inds_t));\n       OP_REQUIRES_OK(c, c->allocate_output(2, TensorShape({nnz}), &values_t));\n-      auto row_ptrs = row_ptrs_t->vec<int32>();\n-      auto col_inds = col_inds_t->vec<int32>();\n+      auto row_ptrs = row_ptrs_t->vec<int32_t>();\n+      auto col_inds = col_inds_t->vec<int32_t>();\n       auto values = values_t->vec<T>();\n \n-      functor::Slice<Device, int32, 1> slice_int;\n+      functor::Slice<Device, int32_t, 1> slice_int;\n       functor::Slice<Device, T, 1> slice_t;\n       typedef Eigen::DSizes<Eigen::DenseIndex, 1> EVec;\n       const Device& d = c->eigen_device<Device>();\n       slice_int(d,\n                 /*output*/ row_ptrs,\n-                /*input*/ csr_sparse_matrix->row_pointers().vec<int32>(),\n+                /*input*/ csr_sparse_matrix->row_pointers().vec<int32_t>(),\n                 /*slice_indices*/\n                 EVec{static_cast<Eigen::DenseIndex>(index * (rows + 1))},\n                 /*slice_sizes*/ EVec{static_cast<Eigen::DenseIndex>(rows + 1)});\n       slice_int(d,\n                 /*output*/ col_inds,\n-                /*input*/ csr_sparse_matrix->col_indices().vec<int32>(),\n+                /*input*/ csr_sparse_matrix->col_indices().vec<int32_t>(),\n                 /*slice_indices*/ EVec{batch_ptrs(index)},\n                 /*slice_sizes*/ EVec{nnz});\n       slice_t(d,"
        },
        {
            "sha": "259e9a97cd2ff3da1e09d351682e578ad467bcdf",
            "filename": "tensorflow/core/kernels/sparse/sparse_tensor_to_csr_sparse_matrix_op.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_tensor_to_csr_sparse_matrix_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_tensor_to_csr_sparse_matrix_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fsparse_tensor_to_csr_sparse_matrix_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -74,7 +74,7 @@ class SparseTensorToCSRSparseMatrixCPUOp : public OpKernel {\n     const int64_t num_cols = dense_shape_vec((rank == 2) ? 1 : 2);\n     const int64_t total_nnz = values.NumElements();\n \n-    static constexpr int64_t kInt32Max = std::numeric_limits<int32>::max();\n+    static constexpr int64_t kInt32Max = std::numeric_limits<int32_t>::max();\n     OP_REQUIRES(\n         ctx, batch_size < kInt32Max,\n         errors::InvalidArgument(\"dense_shape batch_size must be < Int32Max,\"\n@@ -106,16 +106,16 @@ class SparseTensorToCSRSparseMatrixCPUOp : public OpKernel {\n     Tensor csr_row_ptr(cpu_allocator(), DT_INT32, csr_row_ind_shape);\n \n     // Fill the row pointers with zeros.\n-    functor::SetZeroFunctor<CPUDevice, int32> set_zero;\n-    set_zero(ctx->eigen_device<CPUDevice>(), csr_row_ptr.flat<int32>());\n+    functor::SetZeroFunctor<CPUDevice, int32_t> set_zero;\n+    set_zero(ctx->eigen_device<CPUDevice>(), csr_row_ptr.flat<int32_t>());\n \n     // Convert from COO to CSR format.\n     functor::SparseTensorToCSRSparseMatrixCPUFunctor coo_to_csr;\n     OP_REQUIRES_OK(\n         ctx,\n         coo_to_csr(batch_size, num_rows, num_cols,\n-                   indices.template matrix<int64_t>(), batch_ptr.vec<int32>(),\n-                   csr_row_ptr.vec<int32>(), csr_col_ind.vec<int32>()));\n+                   indices.template matrix<int64_t>(), batch_ptr.vec<int32_t>(),\n+                   csr_row_ptr.vec<int32_t>(), csr_col_ind.vec<int32_t>()));\n \n     // Create the CSRSparseMatrix object from its component Tensors and prepare\n     // the Variant output Tensor."
        },
        {
            "sha": "d81c80672b31bc092070000519089622bca83281",
            "filename": "tensorflow/core/kernels/sparse/transpose_op.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Ftranspose_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Ftranspose_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Ftranspose_op.cc?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -182,9 +182,9 @@ absl::Status CSRSparseMatrixTranspose<Device, T>::operator()(\n \n   // Set the output row pointers to zero, in case we hit any empty\n   // input batches.\n-  functor::SetZeroFunctor<Device, int32> set_zero;\n+  functor::SetZeroFunctor<Device, int32_t> set_zero;\n   const Device& d = ctx->eigen_device<Device>();\n-  set_zero(d, output_row_ptr_t.flat<int32>());\n+  set_zero(d, output_row_ptr_t.flat<int32_t>());\n \n   functor::CSRSparseMatrixTransposeComponent<Device, T> transpose_component;\n   for (int i = 0; i < batch_size; ++i) {"
        },
        {
            "sha": "8f6c09fdb0fa687b174a43a270d7317f8645c75a",
            "filename": "tensorflow/core/kernels/sparse/zeros_op.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fzeros_op.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee8cc68fc7697db01c7270345d6c89d315e0d4ad/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fzeros_op.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fsparse%2Fzeros_op.h?ref=ee8cc68fc7697db01c7270345d6c89d315e0d4ad",
            "patch": "@@ -54,7 +54,7 @@ struct CSRSparseMatrixZeros {\n \n     Tensor batch_ptr_t(cpu_allocator(), DT_INT32,\n                        TensorShape({batch_size + 1}));\n-    batch_ptr_t.vec<int32>().setZero();  // On host.\n+    batch_ptr_t.vec<int32_t>().setZero();  // On host.\n \n     Allocator* allocator = c->device()->GetAllocator(AllocatorAttributes());\n     // An all-zeros CSR matrix is composed of an empty set of column\n@@ -66,10 +66,10 @@ struct CSRSparseMatrixZeros {\n     Tensor coo_col_ind_t(allocator, DT_INT32, TensorShape({0}));\n     Tensor csr_values_t(allocator, dtype, TensorShape({0}));\n     const Device& d = c->eigen_device<Device>();\n-    functor::SetZeroFunctor<Device, int32> set_zero;\n+    functor::SetZeroFunctor<Device, int32_t> set_zero;\n     TF_RETURN_IF_ERROR(c->allocate_temp(\n         DT_INT32, TensorShape({batch_size * (rows + 1)}), &csr_row_ptr_t));\n-    set_zero(d, csr_row_ptr_t.flat<int32>());\n+    set_zero(d, csr_row_ptr_t.flat<int32_t>());\n \n     TF_RETURN_IF_ERROR(CSRSparseMatrix::CreateCSRSparseMatrix(\n         dtype, dense_shape_t, batch_ptr_t, csr_row_ptr_t, coo_col_ind_t,"
        }
    ],
    "stats": {
        "total": 268,
        "additions": 136,
        "deletions": 132
    }
}