{
    "author": "jcai19",
    "message": "[XLA][Numerics][HLO Value Tracking] Support HLO original values in ConditionalSimplifier pass\n\nThis updates the original value of a conditional op when unused tuple elements are removed.\n\nPiperOrigin-RevId: 846802773",
    "sha": "aa95cad5da857d0e0ff88f9e544715502be51ff0",
    "files": [
        {
            "sha": "26157ab983ec1f25720cedd323b2874d116ec195",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -31,6 +31,7 @@ cc_library(\n         \"hlo_module_metadata.cc\",\n         \"hlo_opcode.cc\",\n         \"hlo_original_value.cc\",\n+        \"hlo_original_value_util.cc\",\n         \"hlo_schedule.cc\",\n         \"hlo_sharding_metadata.cc\",\n         \"replica_group.cc\",\n@@ -51,6 +52,7 @@ cc_library(\n         \"hlo_op_metadata.h\",\n         \"hlo_opcode.h\",\n         \"hlo_original_value.h\",\n+        \"hlo_original_value_util.h\",\n         \"hlo_print_options.h\",\n         \"hlo_schedule.h\",\n         \"hlo_sharding.h\","
        },
        {
            "sha": "c370122c43179c899af203b829fe8cb45595b11f",
            "filename": "third_party/xla/xla/hlo/ir/hlo_instruction.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -60,6 +60,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_op_metadata.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/ir/hlo_sharding.h\"\n #include \"xla/hlo/ir/hlo_sharding_metadata.h\""
        },
        {
            "sha": "dfb08c3b78047745ccb87ad5136beb60bc87dad3",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -55,7 +55,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_input_output_alias_config.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/ir/hlo_schedule.h\"\n #include \"xla/hlo/ir/hlo_sharding.h\""
        },
        {
            "sha": "51eb648979a1cc9ca43d0becfbe271291b2c1ea9",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 53,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -24,17 +24,13 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/base/no_destructor.h\"\n-#include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/check.h\"\n-#include \"absl/log/log.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n-#include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/hlo/utils/pointer_utils.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tuple_tree.h\"\n@@ -247,55 +243,6 @@ std::shared_ptr<OriginalValue> OriginalValue::CreateFromInstruction(\n   return original_value;\n }\n \n-void CopyOriginalValue(const HloInstruction* src_instruction,\n-                       HloInstruction* dest_instruction, bool clone,\n-                       bool issue_warning) {\n-  if (!src_instruction || !dest_instruction ||\n-      !ShapeUtil::Compatible(src_instruction->shape(),\n-                             dest_instruction->shape())) {\n-    if (issue_warning) {\n-      LOG(WARNING)\n-          << \"Expect the new instruction to have the same shape with the old \"\n-             \"instruction when moving over original_value\";\n-    }\n-    return;\n-  }\n-\n-  std::shared_ptr<OriginalValue> original_value =\n-      src_instruction->original_value();\n-  if (!original_value) {\n-    return;\n-  }\n-\n-  if (!clone || original_value->is_synthetic_call()) {\n-    dest_instruction->set_original_value(original_value);\n-    return;\n-  }\n-\n-  // Deep clone the tree.\n-  auto cloned_tree = std::make_shared<OriginalValue>(original_value->tree());\n-  dest_instruction->set_original_value(cloned_tree);\n-}\n-\n-void DeduplicateOriginalValues(HloModule* module) {\n-  absl::flat_hash_set<std::shared_ptr<OriginalValue>,\n-                      PointeeHash<OriginalValue>, PointeeEqual<OriginalValue>>\n-      unique_original_values;\n-  for (HloComputation* computation : module->computations()) {\n-    for (HloInstruction* instruction : computation->instructions()) {\n-      if (std::shared_ptr<OriginalValue> original_value =\n-              instruction->original_value()) {\n-        auto p = unique_original_values.insert(original_value);\n-        if (!p.second) {\n-          // Reassign the pointer with the existing identical object and release\n-          // the duplicate.\n-          instruction->set_original_value(*p.first);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n /* static */\n TupleTree<std::optional<OriginalArray>>&\n OriginalValue::EmptyOriginalValueTupleTree() {"
        },
        {
            "sha": "92eb1fab1fd46586fd45c5ec97d61201155fd871",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value.h",
            "status": "modified",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -167,17 +167,5 @@ class OriginalValue {\n       data_;\n };\n \n-// Copies the original value of the source to the destination instruction if the\n-// shapes of the source and destination are compatible. This performs a deep\n-// copy if clone is set to true. Otherwise, it performs a shallow copy. Print a\n-// warning if the shapes are not compatible and issue_warning is set to true.\n-void CopyOriginalValue(const HloInstruction* src_instruction,\n-                       HloInstruction* dest_instruction, bool clone,\n-                       bool issue_warning);\n-\n-// Removes duplicates of original value objects referenced in the module to save\n-// memory storage.\n-void DeduplicateOriginalValues(HloModule* module);\n }  // namespace xla\n-\n #endif  // XLA_HLO_IR_HLO_ORIGINAL_VALUE_H_"
        },
        {
            "sha": "c3a8d55425f2bb94a0d5705ff01c743ee6534dc5",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_test.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include <gtest/gtest.h>\n #include \"absl/hash/hash_testing.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/platform/statusor.h\""
        },
        {
            "sha": "2c8fa9d56a64cee8a1fbd67ecd580e5e93a00b5f",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value_util.cc",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_util.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -0,0 +1,78 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n+\n+#include <memory>\n+\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/log.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/utils/pointer_utils.h\"\n+#include \"xla/shape_util.h\"\n+\n+namespace xla {\n+\n+void CopyOriginalValue(const HloInstruction* src_instruction,\n+                       HloInstruction* dest_instruction, bool clone,\n+                       bool issue_warning) {\n+  if (!src_instruction || !dest_instruction ||\n+      !ShapeUtil::Compatible(src_instruction->shape(),\n+                             dest_instruction->shape())) {\n+    if (issue_warning) {\n+      LOG(WARNING)\n+          << \"Expect the new instruction to have the same shape with the old \"\n+             \"instruction when moving over original_value\";\n+    }\n+    return;\n+  }\n+\n+  std::shared_ptr<OriginalValue> original_value =\n+      src_instruction->original_value();\n+  if (!original_value) {\n+    return;\n+  }\n+\n+  if (!clone || original_value->is_synthetic_call()) {\n+    dest_instruction->set_original_value(original_value);\n+    return;\n+  }\n+\n+  // Deep clone the tree.\n+  auto cloned_tree = std::make_shared<OriginalValue>(original_value->tree());\n+  dest_instruction->set_original_value(cloned_tree);\n+}\n+\n+void DeduplicateOriginalValues(HloModule* module) {\n+  absl::flat_hash_set<std::shared_ptr<OriginalValue>,\n+                      PointeeHash<OriginalValue>, PointeeEqual<OriginalValue>>\n+      unique_original_values;\n+  for (HloComputation* computation : module->computations()) {\n+    for (HloInstruction* instruction : computation->instructions()) {\n+      if (std::shared_ptr<OriginalValue> original_value =\n+              instruction->original_value()) {\n+        auto p = unique_original_values.insert(original_value);\n+        if (!p.second) {\n+          // Reassign the pointer with the existing identical object and release\n+          // the duplicate.\n+          instruction->set_original_value(*p.first);\n+        }\n+      }\n+    }\n+  }\n+}\n+}  // namespace xla"
        },
        {
            "sha": "94ca6f5debdc16a98fc694a0cf20e3396f445271",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value_util.h",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value_util.h?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -0,0 +1,69 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_HLO_IR_HLO_ORIGINAL_VALUE_UTIL_H_\n+#define XLA_HLO_IR_HLO_ORIGINAL_VALUE_UTIL_H_\n+\n+#include <cstdint>\n+#include <memory>\n+#include <type_traits>\n+\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_original_value.h\"\n+\n+namespace xla {\n+\n+// Copies the original value of the source to the destination instruction.\n+// Original arrays in the source original value are rearranged in the new\n+// original value according to the given mapping of old to new tuple indices.\n+template <typename T>\n+std::enable_if_t<std::is_integral_v<T>> CopyOriginalValue(\n+    const HloInstruction* src_instruction, HloInstruction* dest_instruction,\n+    const absl::flat_hash_map<T, T>& old_to_new_tuple_idx) {\n+  std::shared_ptr<OriginalValue> old_original_value =\n+      src_instruction->original_value();\n+  if (!old_original_value) {\n+    return;\n+  }\n+  const int64_t src_tuple_size = old_original_value->tree().num_leaves();\n+  const int64_t dest_tuple_size = old_to_new_tuple_idx.size();\n+  std::shared_ptr<xla::OriginalValue> new_original_value =\n+      std::make_shared<xla::OriginalValue>(dest_instruction->shape());\n+  for (const auto& [old_idx, new_idx] : old_to_new_tuple_idx) {\n+    if (old_idx < 0 || old_idx >= src_tuple_size || new_idx < 0 ||\n+        new_idx >= dest_tuple_size) {\n+      return;\n+    }\n+    new_original_value->mutable_tree()->CopySubtreeFrom(\n+        old_original_value->tree(), {old_idx}, {new_idx});\n+  }\n+  dest_instruction->set_original_value(new_original_value);\n+}\n+\n+// Copies the original value of the source to the destination instruction if the\n+// shapes of the source and destination are compatible. This performs a deep\n+// copy if clone is set to true. Otherwise, it performs a shallow copy. Print a\n+// warning if the shapes are not compatible and issue_warning is set to true.\n+void CopyOriginalValue(const HloInstruction* src_instruction,\n+                       HloInstruction* dest_instruction, bool clone,\n+                       bool issue_warning);\n+\n+// Removes duplicates of original value objects referenced in the module to save\n+// memory storage.\n+void DeduplicateOriginalValues(HloModule* module);\n+}  // namespace xla\n+\n+#endif  // XLA_HLO_IR_HLO_ORIGINAL_VALUE_UTIL_H_"
        },
        {
            "sha": "626fc80f49839d841e84b4fa72147f47356dbb8d",
            "filename": "third_party/xla/xla/hlo/parser/hlo_parser.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fparser%2Fhlo_parser.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fparser%2Fhlo_parser.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fparser%2Fhlo_parser.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -58,6 +58,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n #include \"xla/hlo/ir/hlo_schedule.h\"\n #include \"xla/hlo/ir/hlo_sharding.h\"\n #include \"xla/hlo/ir/hlo_sharding_metadata.h\""
        },
        {
            "sha": "085c27f698c40e9ed36d59cb6ae0f7cfbef90b6d",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -2638,16 +2638,20 @@ xla_cc_test(\n     srcs = [\"conditional_simplifier_test.cc\"],\n     deps = [\n         \":conditional_simplifier\",\n+        \":hlo_verifier\",\n         \"//xla:literal_util\",\n         \"//xla:shape_util\",\n         \"//xla:types\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:test\",\n+        \"//xla/hlo/testlib:verified_hlo_module\",\n         \"//xla/hlo/utils:hlo_matchers\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@local_tsl//tsl/platform:status\",\n     ],\n )"
        },
        {
            "sha": "7b9ea64becffbe7bbef9878fbce6075d7aadf1f9",
            "filename": "third_party/xla/xla/service/conditional_simplifier.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_simplifier.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -31,6 +31,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n #include \"xla/literal.h\"\n #include \"xla/service/call_graph.h\"\n #include \"xla/service/call_inliner.h\"\n@@ -300,6 +301,7 @@ bool RemoveUnusedTupleElements(HloInstruction* conditional_op) {\n \n   // Replace the conditional instruction itself.\n   *conditional_op->mutable_shape() = new_shape;\n+  CopyOriginalValue(conditional_op, conditional_op, old_to_new_mapping);\n \n   // Reroute all user GTE instructions to new tuple indices.\n   for (HloInstruction* user : conditional_op->users()) {"
        },
        {
            "sha": "c300276556642d28356029a9dc3b4a9d4b85dc4a",
            "filename": "third_party/xla/xla/service/conditional_simplifier_test.cc",
            "status": "modified",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_simplifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_simplifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_simplifier_test.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -15,18 +15,23 @@ limitations under the License.\n \n #include \"xla/service/conditional_simplifier.h\"\n \n+#include <memory>\n #include <string>\n #include <utility>\n \n+#include \"absl/strings/string_view.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/test.h\"\n+#include \"xla/hlo/testlib/verified_hlo_module.h\"\n #include \"xla/hlo/utils/hlo_matchers.h\"\n #include \"xla/literal_util.h\"\n+#include \"xla/service/hlo_verifier.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/types.h\"\n #include \"xla/xla_data.pb.h\"\n #include \"tsl/platform/status.h\"\n@@ -512,6 +517,53 @@ ENTRY entry {\n                   op::GetTupleElement(op::Tuple(op::AfterAll()), 0))));\n }\n \n+TEST_F(ConditionalSimplifierTest, RemoveUnusedTupleElementsWithOriginalValue) {\n+  absl::string_view hlo_string =\n+      R\"(\n+HloModule FirstTupleElementUnusedAndRemoved\n+\n+on_true {\n+  arg_tuple.7 = (f32[10,10]{1,0}) parameter(0)\n+  get-tuple-element.9 = f32[10,10]{1,0} get-tuple-element(arg_tuple.7), index=0\n+  copy = f32[10,10]{1,0} copy(get-tuple-element.9)\n+  ROOT tuple.6 = (f32[10,10]{1,0}, f32[10,10]{1,0}) tuple(copy, get-tuple-element.9), origin={({\"tuple.6\" {0}}, {\"tuple.6\" {1}})}\n+}\n+\n+on_false {\n+  constant.17 = f32[] constant(0)\n+  constant.18 = f32[] constant(1)\n+  rng.19 = f32[10,10]{1,0} rng(constant.17, constant.18), distribution=rng_uniform\n+  arg_tuple.14 = (f32[10,10]{1,0}) parameter(0)\n+  get-tuple-element.16 = f32[10,10]{1,0} get-tuple-element(arg_tuple.14), index=0\n+  ROOT tuple.7 = (f32[10,10]{1,0}, f32[10,10]{1,0}) tuple(rng.19, get-tuple-element.16), origin={({\"tuple.7\" {0}}, {\"tuple.7\" {1}})}\n+}\n+\n+ENTRY main {\n+  constant.38 = pred[] constant(true)\n+  arg_tuple.30 = (s32[], f32[10,10]{1,0}) parameter(0)\n+  get-tuple-element.21 = f32[10,10]{1,0} get-tuple-element(arg_tuple.30), index=1\n+  tuple.1 = (f32[10,10]{1,0}) tuple(get-tuple-element.21)\n+  conditional = (f32[10,10]{1,0}, f32[10,10]{1,0}) conditional(constant.38, tuple.1, tuple.1), true_computation=on_true, false_computation=on_false, origin={({\"cond\" {0}}, {\"cond\" {1}})}\n+  get-second-index = f32[10,10]{1,0} get-tuple-element(conditional), index=1\n+  ROOT result = (f32[10,10]{1,0}) tuple(get-second-index)\n+}\n+)\";\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       ParseAndReturnVerifiedModule(hlo_string));\n+\n+  ASSERT_OK_AND_ASSIGN(bool changed, ConditionalSimplifier().Run(module.get()));\n+  EXPECT_TRUE(changed);\n+  HloVerifier v(/*layout_sensitive=*/false, /*allow_mixed_precision=*/false);\n+  TF_ASSERT_OK(v.Run(module.get()));\n+  const HloInstruction* conditional =\n+      FindInstruction(module.get(), \"conditional\");\n+  // The first element of \"conditional\" result tuple (f32[10,10], f32[10,10])\n+  // should be removed since it is not referenced by any GTE instructions (see\n+  // \"get-second-index\" instruction in hlo_string).\n+  EXPECT_EQ(ShapeUtil::TupleElementCount(conditional->shape()), 1);\n+  EXPECT_EQ(conditional->original_value()->ToString(), R\"(({\"cond\" {1}}))\");\n+}\n+\n }  // namespace\n \n }  // namespace xla"
        },
        {
            "sha": "a1aab5b744e8f88d0e7f8e96b46a55ef4ba5f433",
            "filename": "third_party/xla/xla/service/while_loop_simplifier.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 33,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier.cc?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -37,7 +37,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/hlo/ir/hlo_original_value.h\"\n+#include \"xla/hlo/ir/hlo_original_value_util.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n #include \"xla/hlo/utils/hlo_query.h\"\n@@ -152,35 +152,6 @@ static absl::StatusOr<HloInstruction*> RemoveDeadTupleIndices(\n     HloInstruction* while_op, absl::flat_hash_set<int64_t>& used_tuple_indices,\n     std::optional<absl::flat_hash_map<int32_t, int32_t>>\n         dead_to_surviving_index = std::nullopt) {\n-  auto copy_remaining_original_arrays =\n-      [&](const HloInstruction* src_instruction,\n-          HloInstruction* dest_instruction,\n-          const absl::flat_hash_map<int64_t, int64_t>& old_to_new_tuple_idx) {\n-        std::shared_ptr<OriginalValue> original_value =\n-            src_instruction->original_value();\n-        if (!original_value) {\n-          return;\n-        }\n-\n-        const int64_t src_tuple_size =\n-                          src_instruction->shape().tuple_shapes().size(),\n-                      dest_tuple_size =\n-                          dest_instruction->shape().tuple_shapes().size();\n-        std::shared_ptr<OriginalValue> old_original_value =\n-            src_instruction->original_value();\n-        std::shared_ptr<xla::OriginalValue> new_original_value =\n-            std::make_shared<xla::OriginalValue>(dest_instruction->shape());\n-        for (const auto& [old_idx, new_idx] : old_to_new_tuple_idx) {\n-          if (old_idx < 0 || old_idx >= src_tuple_size || new_idx < 0 ||\n-              new_idx >= dest_tuple_size) {\n-            return;\n-          }\n-          new_original_value->mutable_tree()->CopySubtreeFrom(\n-              old_original_value->tree(), {old_idx}, {new_idx});\n-        }\n-        dest_instruction->set_original_value(new_original_value);\n-      };\n-\n   // Build up maps from the old/new to the new/old tuple indices.\n   std::vector<int64_t> new_to_old_tuple_idx(used_tuple_indices.begin(),\n                                             used_tuple_indices.end());\n@@ -306,9 +277,8 @@ static absl::StatusOr<HloInstruction*> RemoveDeadTupleIndices(\n   CopyFrontendAttributes(while_op, new_while_op);\n   CopyMetadata(while_op, new_while_op);\n \n-  copy_remaining_original_arrays(while_init, new_while_init,\n-                                 old_to_new_tuple_idx);\n-  copy_remaining_original_arrays(while_op, new_while_op, old_to_new_tuple_idx);\n+  CopyOriginalValue(while_init, new_while_init, old_to_new_tuple_idx);\n+  CopyOriginalValue(while_op, new_while_op, old_to_new_tuple_idx);\n \n   // Create a tuple op that recreates the output of the old while op.  That is,\n   // we transform to"
        },
        {
            "sha": "92952b7a66fe39f264e57b65d4310553be527ede",
            "filename": "third_party/xla/xla/tuple_tree.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Ftuple_tree.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/aa95cad5da857d0e0ff88f9e544715502be51ff0/third_party%2Fxla%2Fxla%2Ftuple_tree.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftuple_tree.h?ref=aa95cad5da857d0e0ff88f9e544715502be51ff0",
            "patch": "@@ -502,6 +502,8 @@ class TupleTree {\n     return const_reverse_leaf_iterator(leaf_begin());\n   }\n \n+  size_t num_leaves() const { return std::distance(leaf_begin(), leaf_end()); }\n+\n   // Returns an iterator pointing to the node at the given ShapeIndex.\n   // Returns end() if the index is not found.\n   iterator find(ShapeIndexView index) {"
        }
    ],
    "stats": {
        "total": 315,
        "additions": 216,
        "deletions": 99
    }
}