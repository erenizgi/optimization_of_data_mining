{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809700622",
    "sha": "5eeae7eda4d35715d7b53b444f8a7e42816ea987",
    "files": [
        {
            "sha": "a6d6e1c61987b319208eafc9f5334fafc1b0a0c1",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_async_execution_tracker.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_async_execution_tracker.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_async_execution_tracker.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_async_execution_tracker.cc?ref=5eeae7eda4d35715d7b53b444f8a7e42816ea987",
            "patch": "@@ -59,15 +59,15 @@ void CpuScopedAsyncExecution::SetError(absl::Status error) {\n \n CpuScopedAsyncExecution CpuAsyncExecutionTracker::NewAsyncExecution(\n     int32_t launch_id, tsl::AsyncValueRef<CpuEvent> execute_event) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   Key async_execution_key = execute_event.GetAsyncValue();\n   executions_[launch_id].insert(\n       {async_execution_key, std::move(execute_event)});\n   return CpuScopedAsyncExecution(this, launch_id, async_execution_key);\n }\n \n bool CpuAsyncExecutionTracker::SetError(int32_t launch_id, absl::Status error) {\n-  absl::ReleasableMutexLock lock(&mu_);\n+  absl::ReleasableMutexLock lock(mu_);\n   auto it = executions_.find(launch_id);\n   if (it != executions_.end()) {\n     absl::flat_hash_map<Key, tsl::AsyncValueRef<CpuEvent>> execute_events =\n@@ -100,7 +100,7 @@ bool CpuAsyncExecutionTracker::SetError(int32_t launch_id, absl::Status error) {\n \n void CpuAsyncExecutionTracker::SetError(int32_t launch_id, Key key,\n                                         absl::Status error) {\n-  absl::ReleasableMutexLock lock(&mu_);\n+  absl::ReleasableMutexLock lock(mu_);\n   auto it = executions_.find(launch_id);\n   if (it != executions_.end()) {\n     auto it2 = it->second.find(key);\n@@ -120,7 +120,7 @@ void CpuAsyncExecutionTracker::SetError(int32_t launch_id, Key key,\n }\n \n void CpuAsyncExecutionTracker::SetStateConcrete(int32_t launch_id, Key key) {\n-  absl::ReleasableMutexLock lock(&mu_);\n+  absl::ReleasableMutexLock lock(mu_);\n   auto it = executions_.find(launch_id);\n   if (it != executions_.end()) {\n     auto it2 = it->second.find(key);\n@@ -141,7 +141,7 @@ void CpuAsyncExecutionTracker::SetStateConcrete(int32_t launch_id, Key key) {\n \n void CpuAsyncExecutionTracker::RemoveAsyncExecution(int32_t launch_id,\n                                                     Key key) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto it = executions_.find(launch_id);\n   if (it != executions_.end()) {\n     auto it2 = it->second.find(key);"
        },
        {
            "sha": "e520f9a37518e4c62f59207696e04f3c4ab6239b",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=5eeae7eda4d35715d7b53b444f8a7e42816ea987",
            "patch": "@@ -1994,7 +1994,7 @@ PjRtCpuExecutable::Execute(\n           }\n         }\n \n-        absl::MutexLock lock(&mu);\n+        absl::MutexLock lock(mu);\n         --running;\n         if (!statusor.ok()) {\n           if (failed == 0) {\n@@ -2016,7 +2016,7 @@ PjRtCpuExecutable::Execute(\n         mu.AssertHeld();\n         return running == 0;\n       };\n-      absl::MutexLock lock(&mu);\n+      absl::MutexLock lock(mu);\n       mu.Await(absl::Condition(&done_running));\n     }\n "
        },
        {
            "sha": "a80478155d8bef4dbc80ac0f36357632b169428b",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h?ref=5eeae7eda4d35715d7b53b444f8a7e42816ea987",
            "patch": "@@ -188,7 +188,7 @@ class PjRtCpuClient final : public CommonPjRtClient {\n   CollectiveLaunchEvent GetLastCollectiveLaunchEvent(\n       size_t num_addressable_devices) {\n     tsl::CountDownAsyncValueRef<CpuEvent> count_down(num_addressable_devices);\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     auto last_launch = std::move(last_collective_launch_event_);\n     last_collective_launch_event_ = count_down.AsRef();\n     return std::make_pair(std::move(last_launch), std::move(count_down));"
        },
        {
            "sha": "4c58aa2bd55d4f12e5bc962549af8ff6455d9f5a",
            "filename": "third_party/xla/xla/pjrt/cpu/execution_stream_event_map.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fexecution_stream_event_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fexecution_stream_event_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fexecution_stream_event_map.h?ref=5eeae7eda4d35715d7b53b444f8a7e42816ea987",
            "patch": "@@ -32,7 +32,7 @@ class ExecutionStreamEventMap {\n  public:\n   tsl::AsyncValueRef<CpuEvent> GetLastEnqueueEvent(\n       int64_t execution_stream_id) {\n-    absl::MutexLock lock(&lock_);\n+    absl::MutexLock lock(lock_);\n     auto iter = map_.find(execution_stream_id);\n     if (iter != map_.end()) {\n       return iter->second;\n@@ -42,12 +42,12 @@ class ExecutionStreamEventMap {\n \n   void SetLastEnqueueEvent(int64_t execution_stream_id,\n                            tsl::AsyncValueRef<CpuEvent> event) {\n-    absl::MutexLock lock(&lock_);\n+    absl::MutexLock lock(lock_);\n     map_[execution_stream_id] = std::move(event);\n   }\n \n   void Clear(int64_t execution_stream_id, tsl::AsyncValuePtr<CpuEvent> event) {\n-    absl::MutexLock lock(&lock_);\n+    absl::MutexLock lock(lock_);\n \n     auto iter = map_.find(execution_stream_id);\n     if (iter != map_.end()) {"
        },
        {
            "sha": "9d7edd51a83b572b96767da51b91d8f6fb117679",
            "filename": "third_party/xla/xla/pjrt/cpu/raw_buffer.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fraw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5eeae7eda4d35715d7b53b444f8a7e42816ea987/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fraw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fraw_buffer.cc?ref=5eeae7eda4d35715d7b53b444f8a7e42816ea987",
            "patch": "@@ -231,7 +231,7 @@ CpuRawBuffer::CopyFromHostBuffer(\n       if (byte_strides) {\n         options.input_layout = TransposePlan::Striding{*byte_strides};\n       }\n-      absl::MutexLock lock(transpose_mu);\n+      absl::MutexLock lock(*transpose_mu);\n       TF_ASSIGN_OR_RETURN(transpose, transpose_cache->GetOrCreate(options));\n     }\n     if (!is_packed) {"
        }
    ],
    "stats": {
        "total": 24,
        "additions": 12,
        "deletions": 12
    }
}