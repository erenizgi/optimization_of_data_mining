{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 830280244",
    "sha": "768b244490b0b06a149abfb210b864a45fc767af",
    "files": [
        {
            "sha": "fcbb4b7d3672a3e3f759a6804943a9941ef0cf13",
            "filename": "tensorflow/core/framework/node_def_builder.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -32,7 +32,7 @@ NodeDefBuilder::NodeOut::NodeOut() {\n }\n \n void NodeDefBuilder::NodeOut::Reset(absl::string_view n, int i, DataType dt) {\n-  node = string(n);\n+  node = std::string(n);\n   index = i;\n   data_type = dt;\n }\n@@ -41,9 +41,9 @@ NodeDefBuilder::NodeDefBuilder(absl::string_view name,\n                                absl::string_view op_name,\n                                const OpRegistryInterface* op_registry,\n                                const NodeDebugInfo* debug) {\n-  node_def_.set_name(string(name));\n+  node_def_.set_name(name);\n   const absl::Status status =\n-      op_registry->LookUpOpDef(string(op_name), &op_def_);\n+      op_registry->LookUpOpDef(std::string(op_name), &op_def_);\n   if (status.ok()) {\n     Initialize();\n   } else {\n@@ -62,7 +62,7 @@ NodeDefBuilder::NodeDefBuilder(absl::string_view name,\n \n NodeDefBuilder::NodeDefBuilder(absl::string_view name, const OpDef* op_def)\n     : op_def_(op_def) {\n-  node_def_.set_name(string(name));\n+  node_def_.set_name(name);\n   Initialize();\n }\n \n@@ -182,7 +182,7 @@ void NodeDefBuilder::AddInput(absl::string_view src_node, int src_index) {\n   } else if (src_index > 0) {\n     node_def_.add_input(absl::StrCat(src_node, \":\", src_index));\n   } else {\n-    node_def_.add_input(string(src_node));\n+    node_def_.add_input(std::string(src_node));\n   }\n }\n \n@@ -210,13 +210,13 @@ NodeDefBuilder& NodeDefBuilder::ControlInput(absl::string_view src_node) {\n }\n \n NodeDefBuilder& NodeDefBuilder::Device(absl::string_view device_spec) {\n-  node_def_.set_device(string(device_spec));\n+  node_def_.set_device(device_spec);\n   return *this;\n }\n \n absl::Status NodeDefBuilder::Finalize(NodeDef* node_def, bool consume) {\n-  const std::vector<string>* errors_ptr = &errors_;\n-  std::vector<string> errors_storage;\n+  const std::vector<std::string>* errors_ptr = &errors_;\n+  std::vector<std::string> errors_storage;\n   if (op_def_ != nullptr && inputs_specified_ < op_def_->input_arg_size()) {\n     // Since this is a const method, to add an error, we have to make\n     // a copy of the existing errors.\n@@ -318,9 +318,9 @@ ATTR(const TensorProto&)\n ATTR(const NameAttrList&)\n ATTR(absl::Span<const absl::string_view>)\n ATTR(absl::Span<const char* const>)\n-ATTR(absl::Span<const string>)\n+ATTR(absl::Span<const std::string>)\n ATTR(absl::Span<const tstring>)\n-ATTR(absl::Span<const int32>)\n+ATTR(absl::Span<const int32_t>)\n ATTR(absl::Span<const int64_t>)\n ATTR(absl::Span<const float>)\n ATTR(absl::Span<const bool>)"
        },
        {
            "sha": "6b74b20fd85ad36e10fac251514bd728390d489e",
            "filename": "tensorflow/core/framework/node_def_builder.h",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -56,7 +56,7 @@ class NodeDefBuilder {\n     NodeOut(absl::string_view n, int i, DataType dt);\n     NodeOut();  // uninitialized, call Reset() before use.\n     void Reset(absl::string_view n, int i, DataType dt);\n-    string node;\n+    std::string node;\n     int index;\n     DataType data_type;\n   };\n@@ -112,9 +112,10 @@ class NodeDefBuilder {\n                        absl::Span<const absl::string_view> value);\n   NodeDefBuilder& Attr(absl::string_view name,\n                        absl::Span<const char* const> value);\n-  NodeDefBuilder& Attr(absl::string_view name, absl::Span<const string> value);\n+  NodeDefBuilder& Attr(absl::string_view name,\n+                       absl::Span<const std::string> value);\n   NodeDefBuilder& Attr(absl::string_view name, absl::Span<const tstring> value);\n-  NodeDefBuilder& Attr(absl::string_view name, absl::Span<const int32> value);\n+  NodeDefBuilder& Attr(absl::string_view name, absl::Span<const int32_t> value);\n   NodeDefBuilder& Attr(absl::string_view name, absl::Span<const int64_t> value);\n   NodeDefBuilder& Attr(absl::string_view name, absl::Span<const float> value);\n   NodeDefBuilder& Attr(absl::string_view name, absl::Span<const bool> value);\n@@ -145,7 +146,7 @@ class NodeDefBuilder {\n   absl::Status Finalize(NodeDef* node_def, bool consume = false);\n \n   // Accessors for the values set in the constructor.\n-  const string& node_name() const { return node_def_.name(); }\n+  const std::string& node_name() const { return node_def_.name(); }\n   const OpDef& op_def() const { return *op_def_; }\n \n  private:\n@@ -189,8 +190,8 @@ class NodeDefBuilder {\n   const OpDef* op_def_;\n   NodeDef node_def_;\n   int inputs_specified_;\n-  std::vector<string> control_inputs_;\n-  std::vector<string> errors_;\n+  std::vector<std::string> control_inputs_;\n+  std::vector<std::string> errors_;\n };\n \n }  // namespace tensorflow"
        },
        {
            "sha": "c769537ab13d947101fde1d593c96bff59688920",
            "filename": "tensorflow/core/framework/node_def_builder_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_builder_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -79,12 +79,12 @@ class NodeDefBuilderTest : public ::testing::Test {\n   // Calls Finalize() and verifies it returns an error.\n   // Each message must appear as a substring of the error.\n   void ExpectFailures(NodeDefBuilder& builder,  // NOLINT\n-                      const std::vector<string>& messages) {\n+                      const std::vector<std::string>& messages) {\n     NodeDef node_def;\n     absl::Status status = builder.Finalize(&node_def);\n     EXPECT_FALSE(status.ok()) << SummarizeNodeDef(node_def);\n     if (status.ok()) return;\n-    for (const string& message : messages) {\n+    for (const std::string& message : messages) {\n       EXPECT_TRUE(absl::StrContains(status.message(), message))\n           << status << \", \" << message;\n     }\n@@ -93,14 +93,14 @@ class NodeDefBuilderTest : public ::testing::Test {\n   // Calls Finalize() and verifies it returns an error.\n   // Message must appear as a substring of the error.\n   void ExpectFailure(NodeDefBuilder& builder,  // NOLINT\n-                     const string& message) {\n+                     const std::string& message) {\n     ExpectFailures(builder, {message});\n   }\n \n   // Like ExpectFailure(), except that the error can come from\n   // ValidateNodeDef().\n   void ExpectInvalid(NodeDefBuilder& builder,  // NOLINT\n-                     const string& message) {\n+                     const std::string& message) {\n     NodeDef node_def;\n     absl::Status status = builder.Finalize(&node_def);\n     if (status.ok()) {\n@@ -822,9 +822,9 @@ TEST_F(NodeDefBuilderTest, AttrManyDefault) {\n                     .Input(FakeInput(DT_FLOAT))\n                     .Attr(\"a\", \"foo\")\n                     .Attr(\"e\", \"foo\")\n-                    .Attr(\"b\", std::vector<string>({\"bar\", \"baz\"}))\n+                    .Attr(\"b\", std::vector<std::string>({\"bar\", \"baz\"}))\n                     .Attr(\"f\", 1.0f),\n-                {DT_FLOAT}, {}, R\"proto(\n+                {DT_FLOAT}, {}, R\"pb(\n     op: \"AttrManyDefaultAndInferred\"\n     input: \"a\"\n     attr {\n@@ -854,7 +854,7 @@ TEST_F(NodeDefBuilderTest, AttrManyDefault) {\n     attr {\n       key: \"d\"\n       value { f: 0.3 }\n-    })proto\");\n+    })pb\");\n }\n \n TEST_F(NodeDefBuilderTest, AttrListDefault) {"
        },
        {
            "sha": "42c5e841c9941748f035b4fc82296f7577321c25",
            "filename": "tensorflow/core/framework/node_def_util.cc",
            "status": "modified",
            "additions": 50,
            "deletions": 47,
            "changes": 97,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_util.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -64,18 +64,18 @@ AttrSlice::AttrSlice(const NodeDef& node_def)\n \n AttrSlice::AttrSlice(const AttrValueMap* a) : ndef_(nullptr), attrs_(a) {}\n \n-string SummarizeAttrsHelper(AttrSlice attrs, absl::string_view device) {\n-  string ret;\n+std::string SummarizeAttrsHelper(AttrSlice attrs, absl::string_view device) {\n+  std::string ret;\n \n   // We sort the attrs so the output is deterministic.\n-  std::vector<string> attr_names;\n+  std::vector<std::string> attr_names;\n   attr_names.reserve(attrs.size());\n   for (const auto& attr : attrs) {\n     attr_names.push_back(attr.first);\n   }\n   std::sort(attr_names.begin(), attr_names.end());\n   bool first = true;\n-  for (const string& attr_name : attr_names) {\n+  for (const std::string& attr_name : attr_names) {\n     if (!first) absl::StrAppend(&ret, \", \");\n     first = false;\n     absl::StrAppend(&ret, attr_name, \"=\",\n@@ -91,34 +91,36 @@ string SummarizeAttrsHelper(AttrSlice attrs, absl::string_view device) {\n   return ret;\n }\n \n-string AttrSlice::SummarizeNode() const {\n+std::string AttrSlice::SummarizeNode() const {\n   return ndef_\n              ? SummarizeNodeDef(*ndef_)\n              : absl::StrCat(\n                    \"[\", SummarizeAttrsHelper(*this, absl::string_view()), \"]\");\n }\n \n-string AttrSlice::DebugString() const {\n-  std::vector<string> attr_key_vals;\n+std::string AttrSlice::DebugString() const {\n+  std::vector<std::string> attr_key_vals;\n   attr_key_vals.reserve(attrs()->size());\n   for (const auto& it : *this) {\n-    const string& name = it.first;\n+    const std::string& name = it.first;\n     const AttrValue& attr_value = it.second;\n     attr_key_vals.push_back(\n         absl::StrCat(name, \"=\", SummarizeAttrValue(attr_value)));\n   }\n   return absl::StrJoin(attr_key_vals, \", \");\n }\n \n-string SummarizeNodeDef(const NodeDef& node_def, int max_inputs_in_summary) {\n-  string ret = absl::StrCat(errors::FormatNodeNameForError(node_def.name()),\n-                            \" = \", node_def.op(), \"[\");\n+std::string SummarizeNodeDef(const NodeDef& node_def,\n+                             int max_inputs_in_summary) {\n+  std::string ret =\n+      absl::StrCat(errors::FormatNodeNameForError(node_def.name()), \" = \",\n+                   node_def.op(), \"[\");\n   absl::StrAppend(&ret, SummarizeAttrsHelper(node_def, node_def.device()));\n   absl::StrAppend(&ret, \"](\");\n \n   // Output inputs, including control inputs, verbatim.\n   bool first = true;\n-  for (const string& input : node_def.input()) {\n+  for (const std::string& input : node_def.input()) {\n     if (!first) absl::StrAppend(&ret, \", \");\n     first = false;\n     if (max_inputs_in_summary-- == 0) {\n@@ -131,22 +133,22 @@ string SummarizeNodeDef(const NodeDef& node_def, int max_inputs_in_summary) {\n   return ret;\n }\n \n-string SummarizeAttrs(const NodeDef& node_def) {\n+std::string SummarizeAttrs(const NodeDef& node_def) {\n   return SummarizeAttrsHelper(node_def, node_def.device());\n }\n \n-string FormatNodeDefForError(\n+std::string FormatNodeDefForError(\n     absl::string_view node_name, bool has_experimental_debug_info,\n     const NodeDef_ExperimentalDebugInfo& experimental_debug_info) {\n   return !has_experimental_debug_info ||\n                  experimental_debug_info.original_node_names().empty()\n-             ? errors::FormatNodeNameForError(string(node_name))\n+             ? errors::FormatNodeNameForError(node_name)\n              : errors::FormatOriginalNodeLocationForError(\n                    experimental_debug_info.original_node_names(),\n                    experimental_debug_info.original_func_names());\n }\n \n-string FormatNodeDefForError(const NodeDef& node_def) {\n+std::string FormatNodeDefForError(const NodeDef& node_def) {\n   return FormatNodeDefForError(node_def.name(),\n                                node_def.has_experimental_debug_info(),\n                                node_def.experimental_debug_info());\n@@ -174,7 +176,7 @@ const AttrValue* AttrSlice::Find(absl::string_view attr_name) const {\n   return nullptr;\n }\n \n-const AttrValue* AttrSlice::FindByString(const string& attr_name) const {\n+const AttrValue* AttrSlice::FindByString(const std::string& attr_name) const {\n   auto iter = attrs()->find(attr_name);\n   if (iter != attrs()->end()) {\n     return &iter->second;\n@@ -205,7 +207,7 @@ absl::Status AttrSlice::Find(absl::string_view attr_name,\n   return CheckFind(attr_name, *attr_value);\n }\n \n-absl::Status AttrSlice::FindByString(const string& attr_name,\n+absl::Status AttrSlice::FindByString(const std::string& attr_name,\n                                      const AttrValue** attr_value) const {\n   *attr_value = FindByString(attr_name);\n   return CheckFind(attr_name, *attr_value);\n@@ -288,19 +290,19 @@ bool AttrSlice::EqualAttrs(AttrSlice other, Scratch* scratch) const {\n   }\n DEFINE_GET_ATTR(tstring, s, \"string\", emplace_back, v, ;)\n DEFINE_TRY_GET_ATTR(tstring, s, \"string\", emplace_back, v, ;)\n-DEFINE_GET_ATTR(string, s, \"string\", emplace_back, v, ;)\n-DEFINE_TRY_GET_ATTR(string, s, \"string\", emplace_back, v, ;)\n+DEFINE_GET_ATTR(std::string, s, \"string\", emplace_back, v, ;)\n+DEFINE_TRY_GET_ATTR(std::string, s, \"string\", emplace_back, v, ;)\n DEFINE_GET_ATTR(int64_t, i, \"int\", emplace_back, v, ;)\n DEFINE_TRY_GET_ATTR(int64_t, i, \"int\", emplace_back, v, ;)\n DEFINE_GET_ATTR(\n-    int32, i, \"int\", emplace_back, static_cast<int32>(v),\n-    if (static_cast<int64_t>(static_cast<int32>(v)) != v) {\n+    int32_t, i, \"int\", emplace_back, static_cast<int32_t>(v),\n+    if (static_cast<int64_t>(static_cast<int32_t>(v)) != v) {\n       return errors::InvalidArgument(\"Attr \", attr_name, \" has value \", v,\n                                      \" out of range for an int32\");\n     })\n DEFINE_TRY_GET_ATTR(\n-    int32, i, \"int\", emplace_back, static_cast<int32>(v),\n-    if (static_cast<int64_t>(static_cast<int32>(v)) != v) {\n+    int32_t, i, \"int\", emplace_back, static_cast<int32_t>(v),\n+    if (static_cast<int64_t>(static_cast<int32_t>(v)) != v) {\n       static int log_counter = 0;\n       if (log_counter < 10) {\n         log_counter++;\n@@ -345,13 +347,13 @@ DEFINE_GET_ATTR(NameAttrList, func, \"func\", emplace_back, v, ;);\n #undef DEFINE_GET_ATTR\n \n bool HasNodeAttr(const NodeDef& node_def, absl::string_view attr_name) {\n-  return node_def.attr().find(string(attr_name)) != node_def.attr().end();\n+  return node_def.attr().find(std::string(attr_name)) != node_def.attr().end();\n }\n \n-static const string& kEmptyString = *new string();\n+static const std::string& kEmptyString = *new std::string();\n \n-const string& GetNodeAttrString(const AttrSlice& attrs,\n-                                absl::string_view attr_name) {\n+const std::string& GetNodeAttrString(const AttrSlice& attrs,\n+                                     absl::string_view attr_name) {\n   const AttrValue* attr_value = attrs.Find(attr_name);\n   if (attr_value == nullptr) {\n     return kEmptyString;\n@@ -364,7 +366,7 @@ const string& GetNodeAttrString(const AttrSlice& attrs,\n }\n \n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                    std::vector<const string*>* value) {\n+                    std::vector<const std::string*>* value) {\n   const AttrValue* attr_value = attrs.Find(attr_name);\n   if (attr_value == nullptr) {\n     return false;\n@@ -456,7 +458,7 @@ bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n \n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          Padding* value) {\n-  string str_value;\n+  std::string str_value;\n   TF_RETURN_IF_ERROR(GetNodeAttr(attrs, attr_name, &str_value));\n   return GetPaddingFromString(str_value, value);\n }\n@@ -473,7 +475,7 @@ absl::Status AddArgToSig(const NodeDefOrAttrSlice& node_or_attrs,\n     TF_RETURN_IF_ERROR(\n         GetNodeAttr(node_or_attrs, arg_def.number_attr(), &repeats));\n     // We can't handle outputs that are larger than int32 sizes.\n-    if (static_cast<int64_t>(static_cast<int32>(repeats)) != repeats) {\n+    if (static_cast<int64_t>(static_cast<int32_t>(repeats)) != repeats) {\n       return errors::InvalidArgument(\"Number of outputs is too big: \", repeats);\n     }\n     if (repeats < 0) {\n@@ -645,10 +647,10 @@ absl::Status ValidateNodeDef(const NodeDef& node_def, const OpDef& op_def) {\n   bool seen_control = false;\n   size_t num_inputs = 0;\n   // TODO(josh11b): Unify the input field validation.\n-  for (const string& input : node_def.input()) {\n+  for (const std::string& input : node_def.input()) {\n     if (absl::StartsWith(input, \"^\")) {\n       seen_control = true;\n-      if (input.find(':') != string::npos) {\n+      if (input.find(':') != std::string::npos) {\n         return errors::InvalidArgument(\"Control input '\", input,\n                                        \"' must not have ':' in NodeDef: \",\n                                        FormatNodeDefForError(node_def));\n@@ -662,7 +664,7 @@ absl::Status ValidateNodeDef(const NodeDef& node_def, const OpDef& op_def) {\n     }\n   }\n \n-  std::unordered_map<string, const OpDef::AttrDef*> op_attrs;\n+  std::unordered_map<std::string, const OpDef::AttrDef*> op_attrs;\n   for (const auto& attr : op_def.attr()) {\n     if (!gtl::InsertIfNotPresent(&op_attrs, attr.name(), &attr)) {\n       return errors::InvalidArgument(\"OpDef has duplicate attr name '\",\n@@ -700,7 +702,7 @@ absl::Status ValidateNodeDef(const NodeDef& node_def, const OpDef& op_def) {\n \n   // Were all attrs in the OpDef found in the NodeDef?\n   if (!op_attrs.empty()) {\n-    string attrs;\n+    std::string attrs;\n     for (const auto& attr_pair : op_attrs) {\n       if (!attrs.empty()) absl::StrAppend(&attrs, \"', '\");\n       absl::StrAppend(&attrs, attr_pair.first);\n@@ -870,7 +872,8 @@ const absl::string_view kColocationGroupPrefixStringPiece(\n \n }  // namespace\n \n-absl::Status ValidateOpInput(const string& input_name, bool* is_control_input) {\n+absl::Status ValidateOpInput(const std::string& input_name,\n+                             bool* is_control_input) {\n   *is_control_input = false;\n   if (IsValidDataInputName(input_name)) {\n     return absl::OkStatus();\n@@ -882,7 +885,7 @@ absl::Status ValidateOpInput(const string& input_name, bool* is_control_input) {\n   }\n }\n \n-absl::Status ValidateNodeName(const string& node_name) {\n+absl::Status ValidateNodeName(const std::string& node_name) {\n   if (IsValidNodeName(node_name)) {\n     return absl::OkStatus();\n   } else {\n@@ -896,7 +899,7 @@ absl::Status ValidateExternalNodeDefSyntax(const NodeDef& node_def) {\n     return AttachDef(s, node_def);\n   }\n   bool in_control_inputs = false;\n-  for (const string& input_name : node_def.input()) {\n+  for (const std::string& input_name : node_def.input()) {\n     bool is_control_input;\n     s = ValidateOpInput(input_name, &is_control_input);\n     if (!s.ok()) {\n@@ -915,7 +918,7 @@ absl::Status ValidateExternalNodeDefSyntax(const NodeDef& node_def) {\n \n absl::Status AttachDef(const absl::Status& status, const NodeDef& node_def,\n                        bool allow_multiple_formatted_node) {\n-  string node_error;\n+  std::string node_error;\n   if (!allow_multiple_formatted_node &&\n       absl::StrContains(status.message(), \"{{node \")) {\n     node_error = node_def.name();\n@@ -930,11 +933,11 @@ absl::Status AttachDef(const absl::Status& status, const NodeDef& node_def,\n void AddNodeAttr(absl::string_view name, const AttrValue& value,\n                  NodeDef* node_def) {\n   node_def->mutable_attr()->insert(\n-      AttrValueMap::value_type(string(name), value));\n+      AttrValueMap::value_type(std::string(name), value));\n }\n \n void AddNodeAttr(absl::string_view name, AttrValue&& value, NodeDef* node_def) {\n-  (*node_def->mutable_attr())[string(name)] = std::move(value);\n+  (*node_def->mutable_attr())[std::string(name)] = std::move(value);\n }\n \n #define ADD_NODE_ATTR(T)                                           \\\n@@ -957,8 +960,8 @@ ADD_NODE_ATTR(const TensorProto&)\n ADD_NODE_ATTR(const NameAttrList&)\n ADD_NODE_ATTR(absl::Span<const absl::string_view>)\n ADD_NODE_ATTR(absl::Span<const char* const>)\n-ADD_NODE_ATTR(absl::Span<const string>)\n-ADD_NODE_ATTR(absl::Span<const int32>)\n+ADD_NODE_ATTR(absl::Span<const std::string>)\n+ADD_NODE_ATTR(absl::Span<const int32_t>)\n ADD_NODE_ATTR(absl::Span<const int64_t>)\n ADD_NODE_ATTR(absl::Span<const float>)\n ADD_NODE_ATTR(absl::Span<const bool>)\n@@ -973,7 +976,7 @@ ADD_NODE_ATTR(absl::Span<const NameAttrList>)\n \n void AddAttr(absl::string_view name, const AttrValue& value,\n              AttrValueMap* map) {\n-  map->insert(AttrValueMap::value_type(string(name), value));\n+  map->insert(AttrValueMap::value_type(std::string(name), value));\n }\n \n #define ADD_ATTR(T)                                            \\\n@@ -994,7 +997,7 @@ absl::Status AddPrefixAndSuffixToNode(absl::string_view prefix,\n   // Update frame name to avoid multiple LoopCond nodes in one frame.\n   if (uniquify_frame_name &&\n       (node_def->op() == \"Enter\" || node_def->op() == \"RefEnter\")) {\n-    string frame_name;\n+    std::string frame_name;\n     TF_RETURN_IF_ERROR(GetNodeAttr(*node_def, \"frame_name\", &frame_name));\n     AttrValue& attr = (*node_def->mutable_attr())[\"frame_name\"];\n     frame_name = absl::StrCat(prefix, frame_name, suffix);\n@@ -1005,7 +1008,7 @@ absl::Status AddPrefixAndSuffixToNode(absl::string_view prefix,\n }\n \n absl::Status MaybeAddPrefixToColocationConstraints(\n-    const std::unordered_set<string>& match, absl::string_view prefix,\n+    const std::unordered_set<std::string>& match, absl::string_view prefix,\n     NodeDef* node_def) {\n   auto attr = node_def->mutable_attr()->find(kColocationAttrName);\n   if (attr == node_def->mutable_attr()->end()) {\n@@ -1016,7 +1019,7 @@ absl::Status MaybeAddPrefixToColocationConstraints(\n   for (size_t i = 0; i < constraints_size; ++i) {\n     absl::string_view original(constraints_list->s(i));\n     if (absl::ConsumePrefix(&original, kColocationGroupPrefixStringPiece)) {\n-      if (match.find(string(original)) != match.end()) {\n+      if (match.find(std::string(original)) != match.end()) {\n         (*constraints_list->mutable_s(i)) =\n             absl::StrCat(kColocationGroupPrefix, prefix, original);\n       }"
        },
        {
            "sha": "1dd97f9e4137db08754aec4ba84313185cda5bef",
            "filename": "tensorflow/core/framework/node_def_util.h",
            "status": "modified",
            "additions": 15,
            "deletions": 13,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_util.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -81,7 +81,7 @@ std::string FormatNodeDefForError(\n     absl::string_view node_name, bool has_experimental_debug_info,\n     const NodeDef_ExperimentalDebugInfo& experimental_debug_info);\n \n-typedef protobuf::Map<string, AttrValue> AttrValueMap;\n+typedef protobuf::Map<std::string, AttrValue> AttrValueMap;\n \n // Adds an attr with name <name> and value <value> to *node_def.\n // The type of the attr is based on the type of value.\n@@ -109,9 +109,9 @@ void AddNodeAttr(absl::string_view name,\n                  absl::Span<const absl::string_view> value, NodeDef* node_def);\n void AddNodeAttr(absl::string_view name, absl::Span<const char* const> value,\n                  NodeDef* node_def);\n-void AddNodeAttr(absl::string_view name, absl::Span<const string> value,\n+void AddNodeAttr(absl::string_view name, absl::Span<const std::string> value,\n                  NodeDef* node_def);\n-void AddNodeAttr(absl::string_view name, absl::Span<const int32> value,\n+void AddNodeAttr(absl::string_view name, absl::Span<const int32_t> value,\n                  NodeDef* node_def);\n void AddNodeAttr(absl::string_view name, absl::Span<const int64_t> value,\n                  NodeDef* node_def);\n@@ -221,7 +221,7 @@ absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          int64_t* value);  // type: \"int\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                         int32* value);  // type: \"int\"\n+                         int32_t* value);  // type: \"int\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          float* value);  // type: \"float\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n@@ -236,14 +236,15 @@ absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          PartialTensorShape* value);  // type: \"shape\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          Tensor* value);  // type: \"tensor\"\n-absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                         std::vector<string>* value);  // type \"list(string)\"\n+absl::Status GetNodeAttr(\n+    const AttrSlice& attrs, absl::string_view attr_name,\n+    std::vector<std::string>* value);  // type \"list(string)\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          std::vector<tstring>* value);  // type \"list(tstring)\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          std::vector<int64_t>* value);  // type \"list(int)\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                         std::vector<int32>* value);  // type \"list(int)\"\n+                         std::vector<int32_t>* value);  // type \"list(int)\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                          std::vector<float>* value);  // type \"list(float)\"\n absl::Status GetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n@@ -302,7 +303,7 @@ bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                     std::vector<int64_t>* value);  // type: \"int\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                    int32* value);  // type: \"int\"\n+                    int32_t* value);  // type: \"int\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                     float* value);  // type: \"float\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n@@ -313,11 +314,11 @@ bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                     TensorShape* value);  // type: \"shape\"\n \n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                    std::vector<string>* value);  // type: \"list(string)\"\n+                    std::vector<std::string>* value);  // type: \"list(string)\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                     std::vector<tstring>* value);  // type: \"list(tstring)\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                    std::vector<int32>* value);  // type: \"list(int)\"\n+                    std::vector<int32_t>* value);  // type: \"list(int)\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n                     std::vector<float>* value);  // type: \"list(float)\"\n bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n@@ -329,8 +330,9 @@ bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n \n // Overloads of TryGetNodeAttr() that avoid copying the non-POD attribute\n // values.\n-bool TryGetNodeAttr(const AttrSlice& attrs, absl::string_view attr_name,\n-                    std::vector<const string*>* value);  // type: \"list(string)\"\n+bool TryGetNodeAttr(\n+    const AttrSlice& attrs, absl::string_view attr_name,\n+    std::vector<const std::string*>* value);  // type: \"list(string)\"\n bool TryGetNodeAttr(\n     const AttrSlice& attrs, absl::string_view attr_name,\n     std::vector<const TensorShapeProto*>* value);  // type: \"list(shape)\"\n@@ -442,7 +444,7 @@ absl::Status AddPrefixAndSuffixToNode(absl::string_view prefix,\n // Appends the given prefix to the colocation group name if the name exists\n // in `to_match`.\n absl::Status MaybeAddPrefixToColocationConstraints(\n-    const std::unordered_set<string>& match, absl::string_view prefix,\n+    const std::unordered_set<std::string>& match, absl::string_view prefix,\n     NodeDef* node_def);\n \n // Updates the colocation constraint name with the one provided in the map (if"
        },
        {
            "sha": "66a37a41ee3f8a19b4cfa682d1d1e8ea502a7b8f",
            "filename": "tensorflow/core/framework/node_def_util_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_def_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_util_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -37,7 +37,7 @@ OpDef ToOpDef(const OpDefBuilder& builder) {\n   return op_reg_data.op_def;\n }\n \n-NodeDef ToNodeDef(const string& text) {\n+NodeDef ToNodeDef(const std::string& text) {\n   NodeDef node_def;\n   EXPECT_TRUE(protobuf::TextFormat::MergeFromString(text, &node_def));\n   return node_def;\n@@ -56,7 +56,7 @@ void ExpectSuccess(const NodeDef& good, const OpDef& op_def) {\n }\n \n void ExpectFailure(const NodeDef& bad, const OpDef& op_def,\n-                   const string& message) {\n+                   const std::string& message) {\n   absl::Status status = ValidateNodeDef(bad, op_def);\n \n   EXPECT_FALSE(status.ok()) << \"NodeDef: \" << SummarizeNodeDef(bad)\n@@ -322,7 +322,7 @@ void ExpectValidSyntax(const NodeDef& good) {\n       << \"NodeDef: \" << SummarizeNodeDef(good);\n }\n \n-void ExpectInvalidSyntax(const NodeDef& bad, const string& message) {\n+void ExpectInvalidSyntax(const NodeDef& bad, const std::string& message) {\n   absl::Status status = ValidateExternalNodeDefSyntax(bad);\n \n   ASSERT_FALSE(status.ok()) << \"NodeDef: \" << SummarizeNodeDef(bad);\n@@ -761,11 +761,11 @@ TEST(AddPrefixAndSuffixToNode, Enter) {\n   node_def.set_name(\"enter\");\n   node_def.set_op(\"Enter\");\n   AddNodeAttr(\"frame_name\", \"test_frame\", &node_def);\n-  const string prefix = \"prefix/\";\n-  const string suffix = \"/suffix\";\n+  const std::string prefix = \"prefix/\";\n+  const std::string suffix = \"/suffix\";\n   TF_ASSERT_OK(AddPrefixAndSuffixToNode(prefix, suffix, &node_def));\n   EXPECT_EQ(\"prefix/enter/suffix\", node_def.name());\n-  string frame_name;\n+  std::string frame_name;\n   TF_ASSERT_OK(GetNodeAttr(node_def, \"frame_name\", &frame_name));\n   EXPECT_EQ(\"prefix/test_frame/suffix\", frame_name);\n }\n@@ -780,23 +780,23 @@ TEST(MaybeAddPrefixToColocationConstraints, Basic) {\n                absl::StrCat(kColocationGroupPrefix, \"Node3\")},\n               &node_def);\n \n-  std::unordered_set<string> match;\n+  std::unordered_set<std::string> match;\n   match.insert(\"Node1\");\n   match.insert(\"Node3\");\n   TF_ASSERT_OK(MaybeAddPrefixToColocationConstraints(match, \"fn/\", &node_def));\n-  std::vector<string> coloc_constraints;\n+  std::vector<std::string> coloc_constraints;\n   TF_ASSERT_OK(GetNodeAttr(node_def, kColocationAttrName, &coloc_constraints));\n-  EXPECT_EQ(\n-      coloc_constraints,\n-      std::vector<string>({\"loc:@fn/Node1\", \"loc:@Node2\", \"loc:@fn/Node3\"}));\n+  EXPECT_EQ(coloc_constraints,\n+            std::vector<std::string>(\n+                {\"loc:@fn/Node1\", \"loc:@Node2\", \"loc:@fn/Node3\"}));\n }\n \n TEST(MaybeAddPrefixToColocationConstraints, NoConstraints) {\n   NodeDef node_def;\n   node_def.set_name(\"Identity\");\n   node_def.set_op(\"Identity\");\n \n-  std::unordered_set<string> match;\n+  std::unordered_set<std::string> match;\n   match.insert(\"Node1\");\n   match.insert(\"Node3\");\n   TF_ASSERT_OK(MaybeAddPrefixToColocationConstraints(match, \"fn/\", &node_def));\n@@ -817,10 +817,10 @@ TEST(MaybeUpdateColocationConstraintsWithMap, Basic) {\n   node_map[\"Node1\"] = \"Node4\";\n   node_map[\"Invalid\"] = \"Node5\";\n   TF_ASSERT_OK(MaybeUpdateColocationConstraintsWithMap(node_map, &node_def));\n-  std::vector<string> coloc_constraints;\n+  std::vector<std::string> coloc_constraints;\n   TF_ASSERT_OK(GetNodeAttr(node_def, kColocationAttrName, &coloc_constraints));\n-  EXPECT_EQ(coloc_constraints,\n-            std::vector<string>({\"loc:@Node4\", \"loc:@Node2\", \"loc:@Node3\"}));\n+  EXPECT_EQ(coloc_constraints, std::vector<std::string>(\n+                                   {\"loc:@Node4\", \"loc:@Node2\", \"loc:@Node3\"}));\n }\n \n TEST(MaybeUpdateColocationConstraintsWithMap, NoConstraints) {"
        },
        {
            "sha": "28f992c4e4dff457c6769f6385768367132da6ad",
            "filename": "tensorflow/core/framework/node_properties_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_properties_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fnode_properties_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_properties_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -40,7 +40,7 @@ class MockOpRegistry : public OpRegistryInterface {\n   // Returns an error status and sets *op_reg_data to nullptr if no OpDef is\n   // registered under that name, otherwise returns the registered OpDef.\n   // Caller must not delete the returned pointer.\n-  absl::Status LookUp(const string& op_type_name,\n+  absl::Status LookUp(const std::string& op_type_name,\n                       const OpRegistrationData** op_reg_data) const override {\n     if (op_type_name == \"Foo\") {\n       *op_reg_data = &op_reg_;"
        },
        {
            "sha": "7688578d8513f5d6d496c6329eb527b10b869667",
            "filename": "tensorflow/core/framework/op.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 9,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -39,7 +39,7 @@ absl::Status DefaultValidator(const OpRegistryInterface& op_registry) {\n \n // OpRegistry -----------------------------------------------------------------\n \n-absl::Status OpRegistryInterface::LookUpOpDef(const string& op_type_name,\n+absl::Status OpRegistryInterface::LookUpOpDef(const std::string& op_type_name,\n                                               const OpDef** op_def) const {\n   *op_def = nullptr;\n   const OpRegistrationData* op_reg_data = nullptr;\n@@ -62,7 +62,7 @@ void OpRegistry::Register(const OpRegistrationDataFactory& op_data_factory) {\n \n namespace {\n // Helper function that returns Status message for failed LookUp.\n-absl::Status OpNotFound(const string& op_type_name) {\n+absl::Status OpNotFound(const std::string& op_type_name) {\n   absl::Status status = errors::NotFound(\n       \"Op type not registered '\", op_type_name, \"' in binary running on \",\n       port::Hostname(), \". \",\n@@ -76,13 +76,14 @@ absl::Status OpNotFound(const string& op_type_name) {\n }\n }  // namespace\n \n-absl::Status OpRegistry::LookUp(const string& op_type_name,\n+absl::Status OpRegistry::LookUp(const std::string& op_type_name,\n                                 const OpRegistrationData** op_reg_data) const {\n   if ((*op_reg_data = LookUp(op_type_name))) return absl::OkStatus();\n   return OpNotFound(op_type_name);\n }\n \n-const OpRegistrationData* OpRegistry::LookUp(const string& op_type_name) const {\n+const OpRegistrationData* OpRegistry::LookUp(\n+    const std::string& op_type_name) const {\n   {\n     tf_shared_lock l(mu_);\n     if (initialized_) {\n@@ -96,7 +97,7 @@ const OpRegistrationData* OpRegistry::LookUp(const string& op_type_name) const {\n }\n \n const OpRegistrationData* OpRegistry::LookUpSlow(\n-    const string& op_type_name) const {\n+    const std::string& op_type_name) const {\n   const OpRegistrationData* res = nullptr;\n \n   bool first_call = false;\n@@ -195,10 +196,10 @@ absl::Status OpRegistry::ProcessRegistrations() const {\n   return CallDeferred();\n }\n \n-string OpRegistry::DebugString(bool include_internal) const {\n+std::string OpRegistry::DebugString(bool include_internal) const {\n   OpList op_list;\n   Export(include_internal, &op_list);\n-  string ret;\n+  std::string ret;\n   for (const auto& op : op_list.op()) {\n     absl::StrAppend(&ret, SummarizeOpDef(op), \"\\n\");\n   }\n@@ -268,7 +269,7 @@ OpListOpRegistry::OpListOpRegistry(const OpList* op_list) {\n }\n \n const OpRegistrationData* OpListOpRegistry::LookUp(\n-    const string& op_type_name) const {\n+    const std::string& op_type_name) const {\n   auto iter = index_.find(op_type_name);\n   if (iter == index_.end()) {\n     return nullptr;\n@@ -277,7 +278,8 @@ const OpRegistrationData* OpListOpRegistry::LookUp(\n }\n \n absl::Status OpListOpRegistry::LookUp(\n-    const string& op_type_name, const OpRegistrationData** op_reg_data) const {\n+    const std::string& op_type_name,\n+    const OpRegistrationData** op_reg_data) const {\n   if ((*op_reg_data = LookUp(op_type_name))) return absl::OkStatus();\n   return OpNotFound(op_type_name);\n }"
        },
        {
            "sha": "251d58bdd01a15a2e8d6c3e20e79e49223837f96",
            "filename": "tensorflow/core/framework/op.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -165,7 +165,8 @@ class OpRegistry : public OpRegistryInterface {\n   // Functions in deferred_ may only be called with mu_ held.\n   mutable std::vector<OpRegistrationDataFactory> deferred_ TF_GUARDED_BY(mu_);\n   // Values are owned.\n-  mutable absl::flat_hash_map<string, std::unique_ptr<const OpRegistrationData>>\n+  mutable absl::flat_hash_map<std::string,\n+                              std::unique_ptr<const OpRegistrationData>>\n       registry_ TF_GUARDED_BY(mu_);\n   mutable bool initialized_ TF_GUARDED_BY(mu_);\n \n@@ -193,7 +194,8 @@ class OpListOpRegistry : public OpRegistryInterface {\n \n  private:\n   // Values are owned.\n-  absl::flat_hash_map<string, std::unique_ptr<const OpRegistrationData>> index_;\n+  absl::flat_hash_map<std::string, std::unique_ptr<const OpRegistrationData>>\n+      index_;\n };\n \n // Support for defining the OpDef (specifying the semantics of the Op and how"
        },
        {
            "sha": "f6087d6d5f33ed5e32b17c7051884649b1d4c581",
            "filename": "tensorflow/core/framework/op_compatibility_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_compatibility_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_compatibility_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_compatibility_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -88,10 +88,10 @@ class OpCompatibilityTest : public OpsTestBase {\n     TF_ASSERT_OK(RunOpKernel());\n   }\n \n-  string Result() { return GetOutput(0)->scalar<tstring>()(); }\n+  std::string Result() { return GetOutput(0)->scalar<tstring>()(); }\n \n   void ExpectIncompatible(const OpDef& old_op_def, const OpDef& new_op_def,\n-                          const string& error) {\n+                          const std::string& error) {\n     // Test OpDefCompatible gives the same answer without the node_def.\n     absl::Status status = OpDefCompatible(old_op_def, new_op_def);\n     if (status.ok()) {\n@@ -103,8 +103,9 @@ class OpCompatibilityTest : public OpsTestBase {\n     }\n   }\n \n-  void ExpectInvalid(const OpDef& old_op_def, const string& validation_error,\n-                     const string& compatibility_error) {\n+  void ExpectInvalid(const OpDef& old_op_def,\n+                     const std::string& validation_error,\n+                     const std::string& compatibility_error) {\n     // Record the original signature before we change *node_def().\n     DataTypeVector old_in_types, old_out_types;\n     TF_ASSERT_OK(InOutTypesForNode(*node_def(), old_op_def, &old_in_types,\n@@ -127,7 +128,7 @@ class OpCompatibilityTest : public OpsTestBase {\n   }\n \n   void ExpectTypeMismatch(const OpDef& old_op_def,\n-                          const string& compatibility_error) {\n+                          const std::string& compatibility_error) {\n     // Record the original signature before we change *node_def().\n     DataTypeVector old_in_types, old_out_types;\n     TF_ASSERT_OK(InOutTypesForNode(*node_def(), old_op_def, &old_in_types,\n@@ -153,7 +154,7 @@ class OpCompatibilityTest : public OpsTestBase {\n   }\n \n   void ExpectRenameFailure(const OpDef& old_op_def,\n-                           const string& compatibility_error) {\n+                           const std::string& compatibility_error) {\n     // This should be all that is needed to get compatibility.\n     const OpDef* new_op_def = RegisteredOpDef();\n     AddDefaultsToNodeDef(*new_op_def, node_def());\n@@ -166,7 +167,7 @@ class OpCompatibilityTest : public OpsTestBase {\n   }\n \n   void ExpectDefaultChangeFailure(const OpDef& old_op_def,\n-                                  const string& compatibility_error) {\n+                                  const std::string& compatibility_error) {\n     // This should be all that is needed to get compatibility.\n     const OpDef* new_op_def = RegisteredOpDef();\n     AddDefaultsToNodeDef(*new_op_def, node_def());"
        },
        {
            "sha": "9265f5b10ed7e42160efd9f2697d55fc9f69244c",
            "filename": "tensorflow/core/framework/op_def_builder.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 27,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_builder.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -36,7 +36,7 @@ namespace tensorflow {\n \n namespace {\n \n-string AttrError(absl::string_view orig, const string& op_name) {\n+std::string AttrError(absl::string_view orig, const std::string& op_name) {\n   return absl::StrCat(\" from Attr(\\\"\", orig, \"\\\") for Op \", op_name);\n }\n \n@@ -62,7 +62,7 @@ bool ConsumeListPrefix(absl::string_view* sp) {\n \n bool ConsumeQuotedString(char quote_ch, absl::string_view* sp,\n                          absl::string_view* out) {\n-  const string quote_str(1, quote_ch);\n+  const std::string quote_str(1, quote_ch);\n   return Scanner(*sp)\n       .OneLiteral(quote_str.c_str())\n       .RestartCapture()\n@@ -150,7 +150,7 @@ bool ProcessCompoundType(const absl::string_view type_string,\n }\n \n void FinalizeAttr(absl::string_view spec, bool allow_attr_type_any,\n-                  OpDef* op_def, std::vector<string>* errors) {\n+                  OpDef* op_def, std::vector<std::string>* errors) {\n   OpDef::AttrDef* attr = op_def->add_attr();\n   absl::string_view orig(spec);\n \n@@ -161,7 +161,7 @@ void FinalizeAttr(absl::string_view spec, bool allow_attr_type_any,\n \n   // Read \"<type>\" or \"list(<type>)\".\n   bool is_list = ConsumeListPrefix(&spec);\n-  string type;\n+  std::string type;\n   absl::string_view type_string;  // Used if type == \"type\"\n   if (absl::ConsumePrefix(&spec, \"string\")) {\n     type = \"string\";\n@@ -197,8 +197,8 @@ void FinalizeAttr(absl::string_view spec, bool allow_attr_type_any,\n         VERIFY(ConsumeQuotedString('\"', &spec, &escaped_string) ||\n                    ConsumeQuotedString('\\'', &spec, &escaped_string),\n                \"Trouble parsing allowed string at '\", spec, \"'\");\n-        string unescaped;\n-        string error;\n+        std::string unescaped;\n+        std::string error;\n         VERIFY(absl::CUnescape(escaped_string, &unescaped, &error),\n                \"Trouble unescaping \\\"\", escaped_string,\n                \"\\\", got error: \", error);\n@@ -274,8 +274,8 @@ void FinalizeAttr(absl::string_view spec, bool allow_attr_type_any,\n \n #undef VERIFY\n \n-string InOutError(bool is_output, absl::string_view orig,\n-                  const string& op_name) {\n+std::string InOutError(bool is_output, absl::string_view orig,\n+                       const std::string& op_name) {\n   return strings::StrCat(\" from \", is_output ? \"Output\" : \"Input\", \"(\\\"\", orig,\n                          \"\\\") for Op \", op_name);\n }\n@@ -343,7 +343,7 @@ bool ConsumeControlOutName(absl::string_view* sp, absl::string_view* out) {\n   } while (false)\n \n void FinalizeInputOrOutput(absl::string_view spec, bool is_output,\n-                           OpDef* op_def, std::vector<string>* errors) {\n+                           OpDef* op_def, std::vector<std::string>* errors) {\n   OpDef::ArgDef* arg =\n       is_output ? op_def->add_output_arg() : op_def->add_input_arg();\n \n@@ -426,12 +426,13 @@ void FinalizeInputOrOutput(absl::string_view spec, bool is_output,\n \n #undef VERIFY\n \n-string ControlOutError(absl::string_view orig, const string& op_name) {\n+std::string ControlOutError(absl::string_view orig,\n+                            const std::string& op_name) {\n   return absl::StrCat(\" from ControlOutput(\\\"\", orig, \"\\\") for Op \", op_name);\n }\n \n void FinalizeControlOutput(absl::string_view name, OpDef* op_def,\n-                           std::vector<string>* errors) {\n+                           std::vector<std::string>* errors) {\n   absl::string_view orig(name);\n \n   // Parse control output name.\n@@ -441,7 +442,7 @@ void FinalizeControlOutput(absl::string_view name, OpDef* op_def,\n                                    ControlOutError(orig, op_def->name())));\n   }\n \n-  *op_def->add_control_output() = string(tmp_name.data(), tmp_name.size());\n+  *op_def->add_control_output() = std::string(tmp_name.data(), tmp_name.size());\n }\n \n int num_leading_spaces(absl::string_view s) {\n@@ -467,12 +468,12 @@ bool IsDocNameColon(absl::string_view s) {\n   return ConsumeDocNameColon(&s, nullptr /* out */);\n }\n \n-void FinalizeDoc(const string& text, OpDef* op_def,\n-                 std::vector<string>* errors) {\n-  std::vector<string> lines = str_util::Split(text, '\\n');\n+void FinalizeDoc(const std::string& text, OpDef* op_def,\n+                 std::vector<std::string>* errors) {\n+  std::vector<std::string> lines = str_util::Split(text, '\\n');\n \n   // Remove trailing spaces.\n-  for (string& line : lines) {\n+  for (std::string& line : lines) {\n     absl::StripTrailingAsciiWhitespace(&line);\n   }\n \n@@ -493,8 +494,9 @@ void FinalizeDoc(const string& text, OpDef* op_def,\n   int end_l = l;\n   // Trim trailing blank lines from the description.\n   while (start_l < end_l && lines[end_l - 1].empty()) --end_l;\n-  string desc = absl::StrJoin(\n-      absl::Span<const string>(lines.data() + start_l, end_l - start_l), \"\\n\");\n+  std::string desc = absl::StrJoin(\n+      absl::Span<const std::string>(lines.data() + start_l, end_l - start_l),\n+      \"\\n\");\n   if (!desc.empty()) op_def->set_description(desc);\n \n   // name: description\n@@ -528,7 +530,7 @@ void FinalizeDoc(const string& text, OpDef* op_def,\n       if (!description[i].empty()) description[i].remove_prefix(min_indent);\n     }\n     // Concatenate lines into a single string.\n-    const string complete(absl::StrJoin(description, \"\\n\"));\n+    const std::string complete(absl::StrJoin(description, \"\\n\"));\n \n     // Find name.\n     bool found = false;\n@@ -561,31 +563,31 @@ void FinalizeDoc(const string& text, OpDef* op_def,\n \n }  // namespace\n \n-OpDefBuilder::OpDefBuilder(string op_name) {\n+OpDefBuilder::OpDefBuilder(std::string op_name) {\n   op_def()->set_name(std::move(op_name));\n }\n \n-OpDefBuilder& OpDefBuilder::Attr(string spec) {\n+OpDefBuilder& OpDefBuilder::Attr(std::string spec) {\n   attrs_.push_back(std::move(spec));\n   return *this;\n }\n \n-OpDefBuilder& OpDefBuilder::Input(string spec) {\n+OpDefBuilder& OpDefBuilder::Input(std::string spec) {\n   inputs_.push_back(std::move(spec));\n   return *this;\n }\n \n-OpDefBuilder& OpDefBuilder::Output(string spec) {\n+OpDefBuilder& OpDefBuilder::Output(std::string spec) {\n   outputs_.push_back(std::move(spec));\n   return *this;\n }\n \n-OpDefBuilder& OpDefBuilder::ControlOutput(string name) {\n+OpDefBuilder& OpDefBuilder::ControlOutput(std::string name) {\n   control_outputs_.push_back(std::move(name));\n   return *this;\n }\n \n-OpDefBuilder& OpDefBuilder::Doc(string text) {\n+OpDefBuilder& OpDefBuilder::Doc(std::string text) {\n #ifndef TF_LEAN_BINARY\n   if (!doc_.empty()) {\n     errors_.push_back(\n@@ -622,7 +624,7 @@ OpDefBuilder& OpDefBuilder::SetIsDistributedCommunication() {\n   return *this;\n }\n \n-OpDefBuilder& OpDefBuilder::Deprecated(int version, string explanation) {\n+OpDefBuilder& OpDefBuilder::Deprecated(int version, std::string explanation) {\n   if (op_def()->has_deprecation()) {\n     errors_.push_back(\n         absl::StrCat(\"Deprecated called twice for Op \", op_def()->name()));\n@@ -667,7 +669,7 @@ OpDefBuilder& OpDefBuilder::AllowAttrTypeAny() {\n }\n \n absl::Status OpDefBuilder::Finalize(OpRegistrationData* op_reg_data) const {\n-  std::vector<string> errors = errors_;\n+  std::vector<std::string> errors = errors_;\n   *op_reg_data = op_reg_data_;\n \n   OpDef* op_def = &op_reg_data->op_def;"
        },
        {
            "sha": "3df88e028c2bd28a72b8aa5d8573be9d1608b6eb",
            "filename": "tensorflow/core/framework/op_def_builder.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_builder.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_builder.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_builder.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -40,7 +40,7 @@ typedef std::vector<std::reference_wrapper<const FullTypeDef>> TypeRefVector;\n // A callback into the type inference process, allowing type inference functions\n // to request inferring the type of some function (assumed to exist in the\n // runtime). The function is specified by name.\n-typedef std::function<absl::StatusOr<FullTypeDef>(const string&,\n+typedef std::function<absl::StatusOr<FullTypeDef>(const std::string&,\n                                                   const TypeRefVector&)>\n     FunctionTypeInferrer;\n \n@@ -266,12 +266,12 @@ class OpDefBuilder {\n   OpDef* op_def() { return &op_reg_data_.op_def; }\n \n   OpRegistrationData op_reg_data_;\n-  std::vector<string> attrs_;\n-  std::vector<string> inputs_;\n-  std::vector<string> outputs_;\n-  std::vector<string> control_outputs_;\n+  std::vector<std::string> attrs_;\n+  std::vector<std::string> inputs_;\n+  std::vector<std::string> outputs_;\n+  std::vector<std::string> control_outputs_;\n   std::string doc_;\n-  std::vector<string> errors_;\n+  std::vector<std::string> errors_;\n   bool allow_attr_type_any_ = false;\n };\n "
        },
        {
            "sha": "8dad7a721dad34ab4ca6b874a0cc9efc690444fb",
            "filename": "tensorflow/core/framework/op_def_builder_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_builder_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -74,7 +74,7 @@ class OpDefBuilderTest : public ::testing::Test {\n     }\n   }\n \n-  void ExpectFailure(const OpDefBuilder& builder, const string& error) {\n+  void ExpectFailure(const OpDefBuilder& builder, const std::string& error) {\n     OpRegistrationData op_reg_data;\n     absl::Status status = builder.Finalize(&op_reg_data);\n     EXPECT_FALSE(status.ok());"
        },
        {
            "sha": "b11360b68bb4a64b0fe61b00b708dfb235249e02",
            "filename": "tensorflow/core/framework/op_def_util.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 32,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_util.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -48,7 +48,7 @@ absl::Status AllowedTypeValue(DataType dt, const OpDef::AttrDef& attr) {\n       return absl::OkStatus();\n     }\n   }\n-  string allowed_str;\n+  std::string allowed_str;\n   for (int i = 0; i < allowed_values.list().type_size(); ++i) {\n     if (!allowed_str.empty()) {\n       absl::StrAppend(&allowed_str, \", \");\n@@ -61,15 +61,16 @@ absl::Status AllowedTypeValue(DataType dt, const OpDef::AttrDef& attr) {\n       \" is not in the list of allowed values: \", allowed_str);\n }\n \n-absl::Status AllowedStringValue(const string& str, const OpDef::AttrDef& attr) {\n+absl::Status AllowedStringValue(const std::string& str,\n+                                const OpDef::AttrDef& attr) {\n   const AttrValue& allowed_values(attr.allowed_values());\n   for (const auto& allowed : allowed_values.list().s()) {\n     if (str == allowed) {\n       return absl::OkStatus();\n     }\n   }\n-  string allowed_str;\n-  for (const string& allowed : allowed_values.list().s()) {\n+  std::string allowed_str;\n+  for (const std::string& allowed : allowed_values.list().s()) {\n     if (!allowed_str.empty()) {\n       absl::StrAppend(&allowed_str, \", \");\n     }\n@@ -135,7 +136,7 @@ absl::Status ValidateAttrValue(const AttrValue& attr_value,\n     } else if (attr.type() == \"string\") {\n       TF_RETURN_IF_ERROR(AllowedStringValue(attr_value.s(), attr));\n     } else if (attr.type() == \"list(string)\") {\n-      for (const string& str : attr_value.list().s()) {\n+      for (const std::string& str : attr_value.list().s()) {\n         TF_RETURN_IF_ERROR(AllowedStringValue(str, attr));\n       }\n     } else {\n@@ -193,7 +194,7 @@ const ApiDef::Arg* FindInputArg(absl::string_view name, const ApiDef& api_def) {\n static absl::Status ValidateArg(const OpDef::ArgDef& arg, const OpDef& op_def,\n                                 bool output,\n                                 absl::flat_hash_set<absl::string_view>* names) {\n-  const string suffix =\n+  const std::string suffix =\n       absl::StrCat(output ? \" for output '\" : \" for input '\", arg.name(), \"'\");\n   VALIDATE(names->emplace(arg.name()).second, \"Duplicate name: \", arg.name());\n   VALIDATE(HasAttrStyleType(arg), \"Missing type\", suffix);\n@@ -320,7 +321,7 @@ absl::Status ValidateOpDef(const OpDef& op_def) {\n \n     // Validate allowed_values\n     if (attr.has_allowed_values()) {\n-      const string list_type =\n+      const std::string list_type =\n           is_list ? attr.type() : absl::StrCat(\"list(\", attr.type(), \")\");\n       TF_RETURN_WITH_CONTEXT_IF_ERROR(\n           AttrValueHasType(attr.allowed_values(), list_type), \" for attr '\",\n@@ -360,7 +361,7 @@ absl::Status CheckOpDeprecation(const OpDef& op_def, int graph_def_version) {\n     } else {\n       // Warn only once for each op name, and do it in a threadsafe manner.\n       static mutex mu(LINKER_INITIALIZED);\n-      static auto* warned = new absl::flat_hash_set<string>();\n+      static auto* warned = new absl::flat_hash_set<std::string>();\n       bool warn;\n       {\n         mutex_lock lock(mu);\n@@ -378,8 +379,9 @@ absl::Status CheckOpDeprecation(const OpDef& op_def, int graph_def_version) {\n \n namespace {\n \n-string SummarizeArgs(const protobuf::RepeatedPtrField<OpDef::ArgDef>& args) {\n-  string ret;\n+std::string SummarizeArgs(\n+    const protobuf::RepeatedPtrField<OpDef::ArgDef>& args) {\n+  std::string ret;\n   for (const OpDef::ArgDef& arg : args) {\n     if (!ret.empty()) absl::StrAppend(&ret, \", \");\n     absl::StrAppend(&ret, arg.name(), \":\");\n@@ -399,8 +401,8 @@ string SummarizeArgs(const protobuf::RepeatedPtrField<OpDef::ArgDef>& args) {\n \n }  // namespace\n \n-string SummarizeOpDef(const OpDef& op_def) {\n-  string ret = absl::StrCat(\"Op<name=\", op_def.name());\n+std::string SummarizeOpDef(const OpDef& op_def) {\n+  std::string ret = absl::StrCat(\"Op<name=\", op_def.name());\n   absl::StrAppend(&ret, \"; signature=\", SummarizeArgs(op_def.input_arg()),\n                   \" -> \", SummarizeArgs(op_def.output_arg()));\n   for (int i = 0; i < op_def.attr_size(); ++i) {\n@@ -474,12 +476,12 @@ bool MoreRestrictive(const OpDef::AttrDef& old_attr,\n   return false;\n }\n \n-string AllowedStr(const OpDef::AttrDef& attr) {\n+std::string AllowedStr(const OpDef::AttrDef& attr) {\n   if (!attr.has_allowed_values()) return \"no restriction\";\n   return SummarizeAttrValue(attr.allowed_values());\n }\n \n-string DefaultAttrStr(const OpDef::AttrDef& attr) {\n+std::string DefaultAttrStr(const OpDef::AttrDef& attr) {\n   if (!attr.has_default_value()) return \"no default\";\n   return SummarizeAttrValue(attr.default_value());\n }\n@@ -495,7 +497,7 @@ bool HigherMinimum(const OpDef::AttrDef& old_attr,\n   return new_attr.minimum() > old_attr.minimum();\n }\n \n-string MinStr(const OpDef::AttrDef& attr) {\n+std::string MinStr(const OpDef::AttrDef& attr) {\n   if (!attr.has_minimum()) return \"no minimum\";\n   return absl::StrCat(attr.minimum());\n }\n@@ -509,7 +511,7 @@ void FillAttrMap(const OpDef& op_def, AttrMap* attr_map) {\n \n // Add a comma to *s every call but the first (*add_comma should be\n // initialized to false).\n-void AddComma(string* s, bool* add_comma) {\n+void AddComma(std::string* s, bool* add_comma) {\n   if (*add_comma) {\n     absl::StrAppend(s, \", \");\n   } else {\n@@ -518,7 +520,7 @@ void AddComma(string* s, bool* add_comma) {\n }\n \n // Will add the `name` from arg if name is true.\n-void AddName(string* s, bool name, const OpDef::ArgDef& arg) {\n+void AddName(std::string* s, bool name, const OpDef::ArgDef& arg) {\n   if (name) {\n     absl::StrAppend(s, arg.name(), \":\");\n   }\n@@ -535,11 +537,11 @@ void AddName(string* s, bool name, const OpDef::ArgDef& arg) {\n //\n // We get the types by either using the attrs in args if they are in\n // old_attrs, or substituting the default value from new_attrs.\n-string ComputeArgSignature(\n+std::string ComputeArgSignature(\n     const protobuf::RepeatedPtrField<OpDef::ArgDef>& args,\n     const AttrMap& old_attrs, const AttrMap& new_attrs, std::vector<bool>* ref,\n     bool names) {\n-  string s;\n+  std::string s;\n   bool add_comma = false;\n   for (const OpDef::ArgDef& arg : args) {\n     if (!arg.type_list_attr().empty()) {\n@@ -568,7 +570,7 @@ string ComputeArgSignature(\n       }\n     } else {\n       int num = 1;  // How many input/outputs does this represent?\n-      string type;  // What is the type of this arg?\n+      std::string type;  // What is the type of this arg?\n       AddName(&type, names, arg);\n       if (!arg.number_attr().empty()) {\n         // N * type case.\n@@ -655,9 +657,9 @@ absl::Status OpDefCompatible(const OpDef& old_op, const OpDef& new_op) {\n   }\n \n   std::vector<bool> old_in_ref, new_in_ref, old_out_ref, new_out_ref;\n-  const string old_in_sig = ComputeArgSignature(\n+  const std::string old_in_sig = ComputeArgSignature(\n       old_op.input_arg(), old_attrs, new_attrs, &old_in_ref, false /* names */);\n-  const string new_in_sig = ComputeArgSignature(\n+  const std::string new_in_sig = ComputeArgSignature(\n       new_op.input_arg(), old_attrs, new_attrs, &new_in_ref, false /* names */);\n   VALIDATE(old_in_sig == new_in_sig, \"Input signature mismatch '\", old_in_sig,\n            \"' vs. '\", new_in_sig, \"'\");\n@@ -669,10 +671,10 @@ absl::Status OpDefCompatible(const OpDef& old_op, const OpDef& new_op) {\n              \" changed from non-ref to ref\");\n   }\n \n-  const string old_out_sig =\n+  const std::string old_out_sig =\n       ComputeArgSignature(old_op.output_arg(), old_attrs, new_attrs,\n                           &old_out_ref, true /* names */);\n-  const string new_out_sig =\n+  const std::string new_out_sig =\n       ComputeArgSignature(new_op.output_arg(), old_attrs, new_attrs,\n                           &new_out_ref, true /* names */);\n   VALIDATE(old_out_sig == new_out_sig, \"Output signature mismatch '\",\n@@ -805,13 +807,13 @@ bool AttrDefEqual(const OpDef::AttrDef& a1, const OpDef::AttrDef& a2) {\n   return true;\n }\n \n-uint64 AttrDefHash(const OpDef::AttrDef& a) {\n-  uint64 h = Hash64(a.name());\n+uint64_t AttrDefHash(const OpDef::AttrDef& a) {\n+  uint64_t h = Hash64(a.name());\n   h = Hash64(a.type().data(), a.type().size(), h);\n   h = Hash64Combine(AttrValueHash(a.default_value()), h);\n   h = Hash64(a.description().data(), a.description().size(), h);\n-  h = Hash64Combine(static_cast<uint64>(a.has_minimum()), h);\n-  h = Hash64Combine(static_cast<uint64>(a.minimum()), h);\n+  h = Hash64Combine(static_cast<uint64_t>(a.has_minimum()), h);\n+  h = Hash64Combine(static_cast<uint64_t>(a.minimum()), h);\n   h = Hash64Combine(AttrValueHash(a.allowed_values()), h);\n   return h;\n }\n@@ -837,7 +839,7 @@ bool RepeatedAttrDefEqual(\n   return true;\n }\n \n-uint64 RepeatedAttrDefHash(\n+uint64_t RepeatedAttrDefHash(\n     const protobuf::RepeatedPtrField<OpDef::AttrDef>& a) {\n   // Insert AttrDefs into map to deterministically sort by name\n   std::vector<const OpDef::AttrDef*> a_sorted;\n@@ -850,7 +852,7 @@ uint64 RepeatedAttrDefHash(\n               return lhs->name() < rhs->name();\n             });\n   // Iterate and combines hashes of keys and values\n-  uint64 h = 0xDECAFCAFFE;\n+  uint64_t h = 0xDECAFCAFFE;\n   for (const auto& def : a_sorted) {\n     h = Hash64(def->name().data(), def->name().size(), h);\n     h = Hash64Combine(AttrDefHash(*def), h);\n@@ -884,8 +886,8 @@ bool OpDefEqual(const OpDef& o1, const OpDef& o2) {\n   return AreSerializedProtosEqual(o1_copy, o2_copy);\n }\n \n-uint64 OpDefHash(const OpDef& o) {\n-  uint64 h = RepeatedAttrDefHash(o.attr());\n+uint64_t OpDefHash(const OpDef& o) {\n+  uint64_t h = RepeatedAttrDefHash(o.attr());\n \n   // Compute deterministic order-independent control outputs hash.\n   std::vector<const char*> control_output;"
        },
        {
            "sha": "abaaeefb03c9a824a65a84d4f40d8ad898f24a83",
            "filename": "tensorflow/core/framework/op_def_util.h",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_util.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -88,22 +88,23 @@ void RemoveNonDeprecationDescriptionsFromOpDef(OpDef* op_def);\n bool AttrDefEqual(const OpDef::AttrDef& a1, const OpDef::AttrDef& a2);\n \n // Returns hash of `a` that is consistent with AttrDefEqual.\n-uint64 AttrDefHash(const OpDef::AttrDef& a);\n+uint64_t AttrDefHash(const OpDef::AttrDef& a);\n \n // Returns true if all AttrDefs in `a1` equal corresponding AttrDefs in\n // `a2`. Correspondence is established by name.\n bool RepeatedAttrDefEqual(const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n                           const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2);\n \n // Returns hash of `a` that is consistent with RepeatedAttrDefEqual\n-uint64 RepeatedAttrDefHash(const protobuf::RepeatedPtrField<OpDef::AttrDef>& a);\n+uint64_t RepeatedAttrDefHash(\n+    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a);\n \n // Returns true if `o1` is equal to `o2`.\n // Equality includes all the fields. OpDef.attr field is treated as a set.\n bool OpDefEqual(const OpDef& o1, const OpDef& o2);\n \n // Returns hash of `o` that is consistent with AttrDefEqual.\n-uint64 OpDefHash(const OpDef& o);\n+uint64_t OpDefHash(const OpDef& o);\n \n }  // namespace tensorflow\n "
        },
        {
            "sha": "41fd90d4e79fcfb5f34a8240ba62a5151e7c895b",
            "filename": "tensorflow/core/framework/op_def_util_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_def_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_util_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -27,21 +27,21 @@ limitations under the License.\n namespace tensorflow {\n namespace {\n \n-OpDef FromText(const string& text) {\n+OpDef FromText(const std::string& text) {\n   OpDef op_def;\n   EXPECT_TRUE(protobuf::TextFormat::MergeFromString(text, &op_def));\n   return op_def;\n }\n \n-OpDef::AttrDef ADef(const string& text) {\n+OpDef::AttrDef ADef(const std::string& text) {\n   OpDef::AttrDef attr_def;\n   EXPECT_TRUE(protobuf::TextFormat::MergeFromString(text, &attr_def));\n   return attr_def;\n }\n \n class ValidateOpDefTest : public ::testing::Test {\n  protected:\n-  absl::Status TestProto(const string& text) {\n+  absl::Status TestProto(const std::string& text) {\n     return ValidateOpDef(FromText(text));\n   }\n \n@@ -58,7 +58,7 @@ class ValidateOpDefTest : public ::testing::Test {\n };\n \n namespace {\n-void ExpectFailure(const absl::Status& status, const string& message) {\n+void ExpectFailure(const absl::Status& status, const std::string& message) {\n   EXPECT_FALSE(status.ok()) << \"Did not see error with: \" << message;\n   if (!status.ok()) {\n     LOG(INFO) << \"message: \" << status;\n@@ -516,9 +516,9 @@ void ExpectDifferent(const OpDef& o1, const OpDef& o2) {\n }\n \n TEST(OpDefEqualityTest, EqualAndHash) {\n-  string a1 = \"attr { name: 'a' type: 'string' } \";\n-  string a2 = \"attr { name: 'b' type: 'string' } \";\n-  string a3 = \"attr { name: 'c' type: 'int32' } \";\n+  std::string a1 = \"attr { name: 'a' type: 'string' } \";\n+  std::string a2 = \"attr { name: 'b' type: 'string' } \";\n+  std::string a3 = \"attr { name: 'c' type: 'int32' } \";\n   OpDef o1 = FromText(absl::StrCat(\"name: 'MatMul' \", a1));\n   OpDef o2 = FromText(absl::StrCat(\"name: 'MatMul' \", a2));\n   OpDef o3 = FromText(absl::StrCat(\"name: 'MatMul' \", a1, a2));"
        },
        {
            "sha": "79766a2d187d9370aad5650a9aa8f66dd6e991fe",
            "filename": "tensorflow/core/framework/op_gen_lib.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 34,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -30,10 +30,11 @@ limitations under the License.\n \n namespace tensorflow {\n \n-string WordWrap(absl::string_view prefix, absl::string_view str, int width) {\n-  const string indent_next_line = \"\\n\" + Spaces(prefix.size());\n+std::string WordWrap(absl::string_view prefix, absl::string_view str,\n+                     int width) {\n+  const std::string indent_next_line = \"\\n\" + Spaces(prefix.size());\n   width -= prefix.size();\n-  string result;\n+  std::string result;\n   absl::StrAppend(&result, prefix);\n \n   while (!str.empty()) {\n@@ -100,8 +101,8 @@ static bool SplitAt(char split_ch, absl::string_view* orig,\n \n // Does this line start with \"<spaces><field>:\" where \"<field>\" is\n // in multi_line_fields? Sets *colon_pos to the position of the colon.\n-static bool StartsWithFieldName(absl::string_view line,\n-                                const std::vector<string>& multi_line_fields) {\n+static bool StartsWithFieldName(\n+    absl::string_view line, const std::vector<std::string>& multi_line_fields) {\n   absl::string_view up_to_colon;\n   if (!SplitAt(':', &line, &up_to_colon)) return false;\n   while (absl::ConsumePrefix(&up_to_colon, \" \"))\n@@ -115,8 +116,8 @@ static bool StartsWithFieldName(absl::string_view line,\n }\n \n static bool ConvertLine(absl::string_view line,\n-                        const std::vector<string>& multi_line_fields,\n-                        string* ml) {\n+                        const std::vector<std::string>& multi_line_fields,\n+                        std::string* ml) {\n   // Is this a field we should convert?\n   if (!StartsWithFieldName(line, multi_line_fields)) {\n     return false;\n@@ -140,16 +141,16 @@ static bool ConvertLine(absl::string_view line,\n   absl::string_view suffix = after_colon.substr(last_quote + 1);\n   // We've now parsed line into '<up_to_colon>: \"<escaped>\"<suffix>'\n \n-  string unescaped;\n+  std::string unescaped;\n   if (!absl::CUnescape(escaped, &unescaped, nullptr)) {\n     // Error unescaping, abort the conversion.\n     return false;\n   }\n   // No more errors possible at this point.\n \n   // Find a string to mark the end that isn't in unescaped.\n-  string end = \"END\";\n-  for (int s = 0; unescaped.find(end) != string::npos; ++s) {\n+  std::string end = \"END\";\n+  for (int s = 0; unescaped.find(end) != std::string::npos; ++s) {\n     end = absl::StrCat(\"END\", s);\n   }\n \n@@ -163,9 +164,10 @@ static bool ConvertLine(absl::string_view line,\n   return true;\n }\n \n-string PBTxtToMultiline(absl::string_view pbtxt,\n-                        const std::vector<string>& multi_line_fields) {\n-  string ml;\n+std::string PBTxtToMultiline(\n+    absl::string_view pbtxt,\n+    const std::vector<std::string>& multi_line_fields) {\n+  std::string ml;\n   // Probably big enough, since the input and output are about the\n   // same size, but just a guess.\n   ml.reserve(pbtxt.size() * (17. / 16));\n@@ -184,20 +186,21 @@ string PBTxtToMultiline(absl::string_view pbtxt,\n // Given a single line of text `line` with first : at `colon`, determine if\n // there is an \"<<END\" expression after the colon and if so return true and set\n // `*end` to everything after the \"<<\".\n-static bool FindMultiline(absl::string_view line, size_t colon, string* end) {\n+static bool FindMultiline(absl::string_view line, size_t colon,\n+                          std::string* end) {\n   if (colon == absl::string_view::npos) return false;\n   line.remove_prefix(colon + 1);\n   while (absl::ConsumePrefix(&line, \" \")) {\n   }\n   if (absl::ConsumePrefix(&line, \"<<\")) {\n-    *end = string(line);\n+    *end = std::string(line);\n     return true;\n   }\n   return false;\n }\n \n-string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n-  string pbtxt;\n+std::string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n+  std::string pbtxt;\n   // Probably big enough, since the input and output are about the\n   // same size, but just a guess.\n   pbtxt.reserve(multiline_pbtxt.size() * (33. / 32));\n@@ -209,7 +212,7 @@ string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n       break;\n     }\n \n-    string end;\n+    std::string end;\n     auto colon = line.find(':');\n     if (!FindMultiline(line, colon, &end)) {\n       // Normal case: not a multi-line string, just output the line as-is.\n@@ -229,7 +232,7 @@ string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n     absl::StrAppend(&pbtxt, line.substr(0, colon + 1));\n \n     // Add every line to unescaped until we see the \"END\" string.\n-    string unescaped;\n+    std::string unescaped;\n     bool first = true;\n     while (!multiline_pbtxt.empty()) {\n       SplitAt('\\n', &multiline_pbtxt, &line);\n@@ -250,13 +253,14 @@ string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n   return pbtxt;\n }\n \n-static void StringReplace(const string& from, const string& to, string* s) {\n+static void StringReplace(const std::string& from, const std::string& to,\n+                          std::string* s) {\n   // Split *s into pieces delimited by `from`.\n-  std::vector<string> split;\n-  string::size_type pos = 0;\n+  std::vector<std::string> split;\n+  std::string::size_type pos = 0;\n   while (pos < s->size()) {\n     auto found = s->find(from, pos);\n-    if (found == string::npos) {\n+    if (found == std::string::npos) {\n       split.push_back(s->substr(pos));\n       break;\n     } else {\n@@ -271,10 +275,10 @@ static void StringReplace(const string& from, const string& to, string* s) {\n   *s = absl::StrJoin(split, to);\n }\n \n-static void RenameInDocs(const string& from, const string& to,\n+static void RenameInDocs(const std::string& from, const std::string& to,\n                          ApiDef* api_def) {\n-  const string from_quoted = absl::StrCat(\"`\", from, \"`\");\n-  const string to_quoted = absl::StrCat(\"`\", to, \"`\");\n+  const std::string from_quoted = absl::StrCat(\"`\", from, \"`\");\n+  const std::string to_quoted = absl::StrCat(\"`\", to, \"`\");\n   for (int i = 0; i < api_def->in_arg_size(); ++i) {\n     if (!api_def->in_arg(i).description().empty()) {\n       StringReplace(from_quoted, to_quoted,\n@@ -480,17 +484,17 @@ ApiDefMap::ApiDefMap(const OpList& op_list) {\n \n ApiDefMap::~ApiDefMap() {}\n \n-absl::Status ApiDefMap::LoadFileList(Env* env,\n-                                     const std::vector<string>& filenames) {\n+absl::Status ApiDefMap::LoadFileList(\n+    Env* env, const std::vector<std::string>& filenames) {\n   for (const auto& filename : filenames) {\n     TF_RETURN_IF_ERROR(LoadFile(env, filename));\n   }\n   return absl::OkStatus();\n }\n \n-absl::Status ApiDefMap::LoadFile(Env* env, const string& filename) {\n+absl::Status ApiDefMap::LoadFile(Env* env, const std::string& filename) {\n   if (filename.empty()) return absl::OkStatus();\n-  string contents;\n+  std::string contents;\n   TF_RETURN_IF_ERROR(ReadFileToString(env, filename, &contents));\n   absl::Status status = LoadApiDef(contents);\n   if (!status.ok()) {\n@@ -502,8 +506,8 @@ absl::Status ApiDefMap::LoadFile(Env* env, const string& filename) {\n   return absl::OkStatus();\n }\n \n-absl::Status ApiDefMap::LoadApiDef(const string& api_def_file_contents) {\n-  const string contents = PBTxtFromMultiline(api_def_file_contents);\n+absl::Status ApiDefMap::LoadApiDef(const std::string& api_def_file_contents) {\n+  const std::string contents = PBTxtFromMultiline(api_def_file_contents);\n   ApiDefs api_defs;\n   TF_RETURN_IF_ERROR(\n       proto_utils::ParseTextFormatFromString(contents, &api_defs));\n@@ -522,7 +526,7 @@ void ApiDefMap::UpdateDocs() {\n   for (auto& name_and_api_def : map_) {\n     auto& api_def = name_and_api_def.second;\n     CHECK_GT(api_def.endpoint_size(), 0);\n-    const string canonical_name = api_def.endpoint(0).name();\n+    const std::string canonical_name = api_def.endpoint(0).name();\n     if (api_def.graph_op_name() != canonical_name) {\n       RenameInDocs(api_def.graph_op_name(), canonical_name, &api_def);\n     }\n@@ -544,7 +548,7 @@ void ApiDefMap::UpdateDocs() {\n   }\n }\n \n-const tensorflow::ApiDef* ApiDefMap::GetApiDef(const string& name) const {\n+const tensorflow::ApiDef* ApiDefMap::GetApiDef(const std::string& name) const {\n   return gtl::FindOrNull(map_, name);\n }\n }  // namespace tensorflow"
        },
        {
            "sha": "e5414c031abdca67b1f22be4e1fab425111ec548",
            "filename": "tensorflow/core/framework/op_gen_lib.h",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -29,23 +29,24 @@ namespace tensorflow {\n // Forward declare protos so their symbols can be removed from .so exports\n class OpDef;\n \n-inline string Spaces(int n) { return string(n, ' '); }\n+inline std::string Spaces(int n) { return std::string(n, ' '); }\n \n // Wrap prefix + str to be at most width characters, indenting every line\n // after the first by prefix.size() spaces.  Intended use case is something\n // like prefix = \"  Foo(\" and str is a list of arguments (terminated by a \")\").\n // TODO(josh11b): Option to wrap on \", \" instead of \" \" when possible.\n-string WordWrap(absl::string_view prefix, absl::string_view str, int width);\n+std::string WordWrap(absl::string_view prefix, absl::string_view str,\n+                     int width);\n \n // Looks for an \"=\" at the beginning of *description.  If found, strips it off\n // (and any following spaces) from *description and return true.  Otherwise\n // returns false.\n bool ConsumeEquals(absl::string_view* description);\n \n // Convert text-serialized protobufs to/from multiline format.\n-string PBTxtToMultiline(absl::string_view pbtxt,\n-                        const std::vector<string>& multi_line_fields);\n-string PBTxtFromMultiline(absl::string_view multiline_pbtxt);\n+std::string PBTxtToMultiline(absl::string_view pbtxt,\n+                             const std::vector<std::string>& multi_line_fields);\n+std::string PBTxtFromMultiline(absl::string_view multiline_pbtxt);\n \n // Takes a list of files with ApiDefs text protos, and allows you to\n // look up the specific ApiDef for any given op.\n@@ -62,20 +63,21 @@ class ApiDefMap {\n   // definitions take precedence.\n   // ApiDefs loaded from files must contain a subset of ops defined\n   // in the OpList passed to the constructor.\n-  absl::Status LoadFileList(Env* env, const std::vector<string>& filenames);\n+  absl::Status LoadFileList(Env* env,\n+                            const std::vector<std::string>& filenames);\n \n   // Load a single file. Api definitions are merged if the same\n   // op definition is loaded multiple times. Later-loaded\n   // definitions take precedence.\n   // ApiDefs loaded from file must contain a subset of ops defined\n   // in the OpList passed to the constructor.\n-  absl::Status LoadFile(Env* env, const string& filename);\n+  absl::Status LoadFile(Env* env, const std::string& filename);\n \n   // Load ApiDefs from string containing ApiDefs text proto.\n   // api_def_file_contents is expected to be in \"multiline format\".\n   // ApiDefs must contain a subset of ops defined in OpsList\n   // passed to the constructor.\n-  absl::Status LoadApiDef(const string& api_def_file_contents);\n+  absl::Status LoadApiDef(const std::string& api_def_file_contents);\n \n   // Updates ApiDef docs. For example, if ApiDef renames an argument\n   // or attribute, applies these renames to descriptions as well.\n@@ -89,10 +91,10 @@ class ApiDefMap {\n   // Note: Returned ApiDef pointer should stay valid even after calling\n   // Load* functions defined above. Subsequent calls to Load* might modify\n   // returned ApiDef contents, but should never remove the ApiDef itself.\n-  const ApiDef* GetApiDef(const string& name) const;\n+  const ApiDef* GetApiDef(const std::string& name) const;\n \n  private:\n-  std::unordered_map<string, ApiDef> map_;\n+  std::unordered_map<std::string, ApiDef> map_;\n };\n \n }  // namespace tensorflow"
        },
        {
            "sha": "b06646d9fc51bd37cd3a42cd931bacfc123cbcc5",
            "filename": "tensorflow/core/framework/op_gen_lib_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_gen_lib_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_gen_lib_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_gen_lib_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -72,7 +72,7 @@ END\n \n TEST(OpGenLibTest, MultilinePBTxt) {\n   // Non-multiline pbtxt\n-  const string pbtxt = R\"(foo: \"abc\"\n+  const std::string pbtxt = R\"(foo: \"abc\"\n foo: \"\"\n foo: \"\\n\\n\"\n foo: \"abc\\nEND\"\n@@ -81,7 +81,7 @@ bar: \"quotes:\\\"\"\n )\";\n \n   // Field \"foo\" converted to multiline but not \"bar\".\n-  const string ml_foo = R\"(foo: <<END\n+  const std::string ml_foo = R\"(foo: <<END\n abc\n END\n foo: <<END\n@@ -105,7 +105,7 @@ bar: \"quotes:\\\"\"\n )\";\n \n   // Both fields \"foo\" and \"bar\" converted to multiline.\n-  const string ml_foo_bar = R\"(foo: <<END\n+  const std::string ml_foo_bar = R\"(foo: <<END\n abc\n END\n foo: <<END\n@@ -161,10 +161,10 @@ TEST(OpGenLibTest, PBTxtToMultilineErrorCases) {\n }\n \n TEST(OpGenLibTest, PBTxtToMultilineComments) {\n-  const string pbtxt = R\"(f: \"bar\"  # Comment 1\n+  const std::string pbtxt = R\"(f: \"bar\"  # Comment 1\n     f: \"\\n\"  # Comment 2\n )\";\n-  const string ml = R\"(f: <<END\n+  const std::string ml = R\"(f: <<END\n bar\n END  # Comment 1\n     f: <<END\n@@ -267,15 +267,15 @@ TEST(OpGenLibTest, ApiDefLoadSingleApiDef) {\n }\n \n TEST(OpGenLibTest, ApiDefOverrideVisibility) {\n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"testop\"\n   endpoint {\n     name: \"testop2\"\n   }\n }\n )\";\n-  const string api_def2 = R\"(\n+  const std::string api_def2 = R\"(\n op {\n   graph_op_name: \"testop\"\n   visibility: HIDDEN\n@@ -304,7 +304,7 @@ op {\n }\n \n TEST(OpGenLibTest, ApiDefOverrideEndpoints) {\n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"testop\"\n   endpoint {\n@@ -327,7 +327,7 @@ op {\n }\n \n TEST(OpGenLibTest, ApiDefOverrideArgs) {\n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"testop\"\n   in_arg {\n@@ -363,7 +363,7 @@ op {\n }\n \n TEST(OpGenLibTest, ApiDefOverrideDescriptions) {\n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"testop\"\n   summary: \"New summary\"\n@@ -375,7 +375,7 @@ END\n }\n )\";\n \n-  const string api_def2 = R\"(\n+  const std::string api_def2 = R\"(\n op {\n   graph_op_name: \"testop\"\n   description_prefix: \"B\"\n@@ -402,7 +402,7 @@ op {\n }\n \n TEST(OpGenLibTest, ApiDefInvalidOpInOverride) {\n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"different_testop\"\n   endpoint {\n@@ -420,22 +420,22 @@ op {\n }\n \n TEST(OpGenLibTest, ApiDefInvalidArgOrder) {\n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"testop\"\n   arg_order: \"arg_a\"\n   arg_order: \"unexpected_arg\"\n }\n )\";\n \n-  const string api_def2 = R\"(\n+  const std::string api_def2 = R\"(\n op {\n   graph_op_name: \"testop\"\n   arg_order: \"arg_a\"\n }\n )\";\n \n-  const string api_def3 = R\"(\n+  const std::string api_def3 = R\"(\n op {\n   graph_op_name: \"testop\"\n   arg_order: \"arg_a\"\n@@ -462,7 +462,7 @@ op {\n }\n \n TEST(OpGenLibTest, ApiDefInvalidSyntax) {\n-  const string api_def = R\"pb(\n+  const std::string api_def = R\"pb(\n     op { bad_op_name: \"testop\" }\n   )pb\";\n \n@@ -474,7 +474,7 @@ TEST(OpGenLibTest, ApiDefInvalidSyntax) {\n }\n \n TEST(OpGenLibTest, ApiDefUpdateDocs) {\n-  const string op_list1 = R\"(op {\n+  const std::string op_list1 = R\"(op {\n   name: \"testop\"\n   input_arg {\n     name: \"arg_a\"\n@@ -492,7 +492,7 @@ TEST(OpGenLibTest, ApiDefUpdateDocs) {\n }\n )\";\n \n-  const string api_def1 = R\"(\n+  const std::string api_def1 = R\"(\n op {\n   graph_op_name: \"testop\"\n   endpoint {\n@@ -519,7 +519,7 @@ op {\n   TF_CHECK_OK(api_map.LoadApiDef(api_def1));\n   api_map.UpdateDocs();\n \n-  const string expected_description =\n+  const std::string expected_description =\n       \"`arg_aa`, `arg_cc`, `attr_aa`, `testop2`\";\n   EXPECT_EQ(expected_description, api_map.GetApiDef(\"testop\")->description());\n   EXPECT_EQ(expected_description,"
        },
        {
            "sha": "79d85cf24420db67b9b8914de5f96337aadb8cb0",
            "filename": "tensorflow/core/framework/op_kernel.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 35,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_kernel.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -213,10 +213,10 @@ absl::Status OpKernel::OutputRange(absl::string_view output_name, int* start,\n   }\n }\n \n-string OpKernel::ShapeTraceString(const OpKernelContext& ctx) const {\n+std::string OpKernel::ShapeTraceString(const OpKernelContext& ctx) const {\n   int num_inputs = ctx.num_inputs();\n   if (num_inputs == 0) return \"\";\n-  std::vector<string> tensor_shapes;\n+  std::vector<std::string> tensor_shapes;\n   tensor_shapes.reserve(num_inputs);\n   for (int i = 0; i < num_inputs; i++) {\n     if (!ctx.has_input(i)) {\n@@ -235,11 +235,12 @@ string OpKernel::ShapeTraceString(const OpKernelContext& ctx) const {\n   return absl::StrCat(\"(\", absl::StrJoin(tensor_shapes, \";\"), \")\");\n }\n \n-string OpKernel::TraceString(const OpKernelContext& ctx, bool verbose) const {\n-  string trace_string =\n+std::string OpKernel::TraceString(const OpKernelContext& ctx,\n+                                  bool verbose) const {\n+  std::string trace_string =\n       tsl::profiler::TraceMeOp(name_view(), type_string_view());\n   if (verbose) {\n-    string shape = ShapeTraceString(ctx);\n+    std::string shape = ShapeTraceString(ctx);\n     if (!shape.empty()) {\n       trace_string = tsl::profiler::TraceMeEncode(std::move(trace_string),\n                                                   {{\"shape\", shape}});\n@@ -709,7 +710,7 @@ absl::Status OpKernelContext::output_list(absl::string_view name,\n \n void OpKernelContext::maybe_initialize_scope_id_set() {\n   if (allocated_scope_ids_ == nullptr) {\n-    allocated_scope_ids_ = std::make_unique<std::unordered_set<int32>>();\n+    allocated_scope_ids_ = std::make_unique<std::unordered_set<int32_t>>();\n   }\n }\n \n@@ -988,7 +989,7 @@ void OpKernelContext::maybe_track_allocations_for_set_output(\n     const auto it = std::find_if(\n         tracking_state_->temp_tensor_buffer_and_size.begin(),\n         tracking_state_->temp_tensor_buffer_and_size.end(),\n-        [&tensor](const std::pair<const void*, int64>& e) {\n+        [&tensor](const std::pair<const void*, int64_t>& e) {\n           return e.first == static_cast<const void*>(tensor.data());\n         });\n     if (it != tracking_state_->temp_tensor_buffer_and_size.end()) {\n@@ -1141,11 +1142,11 @@ void OpKernelContext::set_record_memory_consumption(bool v) {\n   }\n }\n \n-const string& OpKernelContext::executor_type() const {\n+const std::string& OpKernelContext::executor_type() const {\n   if (params_->executor_type) {\n     return *params_->executor_type;\n   } else {\n-    static const string& kEmptyString = *new string(\"\");\n+    static const std::string& kEmptyString = *new std::string(\"\");\n     return kEmptyString;\n   }\n }\n@@ -1158,7 +1159,7 @@ struct KernelRegistration {\n       : def(d), kernel_class_name(c), factory(std::move(f)) {}\n \n   const KernelDef def;\n-  const string kernel_class_name;\n+  const std::string kernel_class_name;\n   std::unique_ptr<kernel_factory::OpKernelFactory> factory;\n };\n \n@@ -1167,7 +1168,7 @@ struct KernelRegistration {\n // KernelDef.\n struct KernelRegistry {\n   mutex mu;\n-  std::unordered_multimap<string, KernelRegistration> registry\n+  std::unordered_multimap<std::string, KernelRegistration> registry\n       TF_GUARDED_BY(mu);\n };\n \n@@ -1183,11 +1184,11 @@ static const char kKernelLibPattern[] = \"libtfkernel*.so\";\n \n // Returns Status::OK if the dynamic library at the given path is safe to\n // load with some level of confidence.\n-static absl::Status IsProbablySafeToLoad(const string& path) {\n+static absl::Status IsProbablySafeToLoad(const std::string& path) {\n   // A map of platform string to required CPU feature.\n   using port::CPUFeature;\n   static const auto* feature_map =\n-      new std::map<string, std::pair<CPUFeature, string>>{\n+      new std::map<std::string, std::pair<CPUFeature, std::string>>{\n           {\"__AVX512VL__=1\", FEATURE(CPUFeature::AVX512VL)},\n       };\n \n@@ -1209,7 +1210,7 @@ static absl::Status IsProbablySafeToLoad(const string& path) {\n     }\n   }\n   if (!missing_features.empty()) {\n-    string errmsg = \"Missing CPU features: \";\n+    std::string errmsg = \"Missing CPU features: \";\n     errmsg.append(absl::StrJoin(missing_features, \", \"));\n     return errors::FailedPrecondition(errmsg);\n   }\n@@ -1227,14 +1228,14 @@ void LoadDynamicKernelsInternal() {\n     override_abi_check = strcmp(_abi_check_env_var, \"1\") == 0;\n   }\n \n-  string bazel_kernel_dir =\n+  std::string bazel_kernel_dir =\n       io::JoinPath(env->GetRunfilesDir(), \"tensorflow\", \"core\", \"kernels\");\n-  std::vector<string> files;\n+  std::vector<std::string> files;\n   absl::Status s_kernel_dir = env->GetChildren(bazel_kernel_dir, &files);\n   if (s_kernel_dir.ok()) {\n-    string dll_spec = io::JoinPath(bazel_kernel_dir, kKernelLibPattern);\n+    std::string dll_spec = io::JoinPath(bazel_kernel_dir, kKernelLibPattern);\n     for (const auto& file : files) {\n-      string fullpath = io::JoinPath(bazel_kernel_dir, file);\n+      std::string fullpath = io::JoinPath(bazel_kernel_dir, file);\n       if (env->MatchPath(fullpath, dll_spec)) {\n         absl::Status s = IsProbablySafeToLoad(fullpath);\n         if (!s.ok() && override_abi_check) {\n@@ -1263,8 +1264,8 @@ void LoadDynamicKernels() {\n   absl::call_once(dll_loader_flag, LoadDynamicKernelsInternal);\n }\n \n-static string Key(absl::string_view op_type, const DeviceType& device_type,\n-                  absl::string_view label) {\n+static std::string Key(absl::string_view op_type, const DeviceType& device_type,\n+                       absl::string_view label) {\n   return strings::StrCat(op_type, \":\", DeviceTypeString(device_type), \":\",\n                          label);\n }\n@@ -1274,12 +1275,12 @@ static string Key(absl::string_view op_type, const DeviceType& device_type,\n // to JIT kernels during the static registration, to allow them to be found\n // during lookup as normal kernels.\n void SetupOrDisableJit(KernelRegistry* registry) {\n-  std::unordered_multimap<string, KernelRegistration> jit_kernels;\n+  std::unordered_multimap<std::string, KernelRegistration> jit_kernels;\n   bool remove_jit_kernels = absl::StrContains(\n       absl::NullSafeStringView(getenv(kDisableJitKernelsEnvVar)), \"1\");\n \n   mutex_lock l(registry->mu);\n-  std::unordered_multimap<string, KernelRegistration>& all_kernels =\n+  std::unordered_multimap<std::string, KernelRegistration>& all_kernels =\n       registry->registry;\n   auto it = all_kernels.begin();\n   while (it != all_kernels.end()) {\n@@ -1344,7 +1345,7 @@ namespace kernel_factory {\n void OpKernelRegistrar::InitInternal(const KernelDef* kernel_def,\n                                      absl::string_view kernel_class_name,\n                                      std::unique_ptr<OpKernelFactory> factory) {\n-  const string key =\n+  const std::string key =\n       Key(kernel_def->op(), DeviceType(kernel_def->device_type()),\n           kernel_def->label());\n \n@@ -1374,9 +1375,9 @@ OpKernel* OpKernelRegistrar::PtrOpKernelFactory::Create(\n namespace {\n \n // Label defaults to empty if not found in NodeDef.\n-const string& GetKernelLabelAttr(const AttrSlice& node_attrs) {\n-  static const string& kKernelAttr = *new string(\"_kernel\");\n-  static const string& kEmptyString = *new string(\"\");\n+const std::string& GetKernelLabelAttr(const AttrSlice& node_attrs) {\n+  static const std::string& kKernelAttr = *new std::string(\"_kernel\");\n+  static const std::string& kEmptyString = *new std::string(\"\");\n \n   // NOTE: We inline the implementation of `GetNodeAttrString()` here in order\n   // to use the `AttrSlice::FindByString()` overload, which does a more\n@@ -1399,9 +1400,9 @@ absl::Status FindKernelRegistration(\n   *reg = nullptr;\n   *was_attr_mismatch = false;\n \n-  const string& label = GetKernelLabelAttr(node_attrs);\n+  const std::string& label = GetKernelLabelAttr(node_attrs);\n \n-  const string key = Key(node_op, device_type, label);\n+  const std::string key = Key(node_op, device_type, label);\n   auto typed_registry = GlobalKernelRegistryTyped();\n   tf_shared_lock lock(typed_registry->mu);\n   auto regs = typed_registry->registry.equal_range(key);\n@@ -1434,7 +1435,7 @@ absl::Status FindKernelRegistration(\n   // default kernel.\n   if (*reg == nullptr &&\n       !IsSymbolicExecutionDevice(device_type.type_string())) {\n-    const string default_key = Key(node_op, DEVICE_DEFAULT, label);\n+    const std::string default_key = Key(node_op, DEVICE_DEFAULT, label);\n     auto regs = typed_registry->registry.equal_range(default_key);\n     for (auto iter = regs.first; iter != regs.second; ++iter) {\n       // If there is a kernel registered for the op and device_type,\n@@ -1496,7 +1497,8 @@ absl::Status FindKernelDef(\n     bool has_experimental_debug_info,\n     const NodeDef_ExperimentalDebugInfo& experimental_debug_info,\n     absl::string_view node_op, absl::string_view node_device,\n-    AttrSlice node_attrs, const KernelDef** def, string* kernel_class_name) {\n+    AttrSlice node_attrs, const KernelDef** def,\n+    std::string* kernel_class_name) {\n   const KernelRegistration* reg = nullptr;\n   bool was_attr_mismatch;\n   TF_RETURN_IF_ERROR(FindKernelRegistration(\n@@ -1535,7 +1537,7 @@ absl::Status FindKernelDef(\n \n absl::Status FindKernelDef(const DeviceType& device_type,\n                            const NodeDef& node_def, const KernelDef** def,\n-                           string* kernel_class_name) {\n+                           std::string* kernel_class_name) {\n   return FindKernelDef(\n       device_type, node_def.name(), node_def.has_experimental_debug_info(),\n       node_def.experimental_debug_info(), node_def.op(), node_def.device(),\n@@ -1600,8 +1602,8 @@ absl::Status SupportedDeviceTypesForNode(\n \n     std::stable_sort(prioritized_device_types->begin(),\n                      prioritized_device_types->end(),\n-                     [](const std::pair<DeviceType, int32>& a,\n-                        const std::pair<DeviceType, int32>& b) {\n+                     [](const std::pair<DeviceType, int32_t>& a,\n+                        const std::pair<DeviceType, int32_t>& b) {\n                        return a.second > b.second;\n                      });\n   } else {\n@@ -1644,10 +1646,10 @@ KernelList GetRegisteredKernelsForOp(absl::string_view op_name) {\n   return GetFilteredRegisteredKernels(op_pred);\n }\n \n-string KernelsRegisteredForOp(absl::string_view op_name) {\n+std::string KernelsRegisteredForOp(absl::string_view op_name) {\n   KernelList kernel_list = GetRegisteredKernelsForOp(op_name);\n   if (kernel_list.kernel_size() == 0) return \"  <no registered kernels>\\n\";\n-  string ret;\n+  std::string ret;\n   for (const auto& kernel_def : kernel_list.kernel()) {\n     absl::StrAppend(&ret, \"  device='\", kernel_def.device_type(), \"'\");\n     if (!kernel_def.label().empty()) {"
        },
        {
            "sha": "1181c593cfc8defc3cae4f55ea742c35d83f324d",
            "filename": "tensorflow/core/framework/op_kernel.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_kernel.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -1315,7 +1315,7 @@ class OpKernelContext {\n \n   // Keep track of calls to ScopedAllocator.\n   // TODO(ayushd): change to absl::flat_hash_set.\n-  std::unique_ptr<std::unordered_set<int32>> allocated_scope_ids_;\n+  std::unique_ptr<std::unordered_set<int32_t>> allocated_scope_ids_;\n \n   // The following data members are only used when allocation tracking is\n   // enabled, memory consumption is being recorded, or tensor access is being"
        },
        {
            "sha": "9d7eff71641541da9a13a62b008fccfa67fee93c",
            "filename": "tensorflow/core/framework/op_kernel_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 18,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_kernel_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -93,7 +93,7 @@ class TestOp3Cpu : public tensorflow::OpKernel {\n };\n \n REGISTER_KERNEL_BUILDER(\n-    Name(\"Test3\").Device(DEVICE_CPU).TypeConstraint<int8>(\"T\"), TestOp3Cpu);\n+    Name(\"Test3\").Device(DEVICE_CPU).TypeConstraint<int8_t>(\"T\"), TestOp3Cpu);\n \n namespace {\n \n@@ -179,8 +179,9 @@ class OpKernelTest : public ::testing::Test {\n   OpKernelTest() : device_(Env::Default()) {}\n \n  protected:\n-  NodeDef CreateNodeDef(const string& op_type, const DataTypeVector& inputs,\n-                        const string& device = \"\") {\n+  NodeDef CreateNodeDef(const std::string& op_type,\n+                        const DataTypeVector& inputs,\n+                        const std::string& device = \"\") {\n     NodeDefBuilder builder(op_type + \"-op\", op_type);\n     for (DataType dt : inputs) {\n       builder.Input(FakeInput(dt));\n@@ -191,7 +192,7 @@ class OpKernelTest : public ::testing::Test {\n     return node_def;\n   }\n \n-  void ExpectEqual(const string& what, const DataTypeVector& expected,\n+  void ExpectEqual(const std::string& what, const DataTypeVector& expected,\n                    const DataTypeVector& observed) {\n     EXPECT_EQ(expected.size(), observed.size()) << what;\n     const size_t size = std::min(expected.size(), observed.size());\n@@ -202,7 +203,7 @@ class OpKernelTest : public ::testing::Test {\n     }\n   }\n \n-  void ExpectSuccess(const string& op_type, DeviceType device_type,\n+  void ExpectSuccess(const std::string& op_type, DeviceType device_type,\n                      const DataTypeVector& inputs,\n                      const DataTypeVector& outputs) {\n     absl::Status status;\n@@ -217,7 +218,7 @@ class OpKernelTest : public ::testing::Test {\n     }\n   }\n \n-  void ExpectFailure(const string& ascii_node_def, DeviceType device_type,\n+  void ExpectFailure(const std::string& ascii_node_def, DeviceType device_type,\n                      error::Code code) {\n     NodeDef node_def;\n     protobuf::TextFormat::ParseFromString(ascii_node_def, &node_def);\n@@ -266,8 +267,9 @@ TEST_F(OpKernelTest, CpuTypeRegistered) {\n }\n \n TEST_F(OpKernelTest, KernelNotRegistered) {\n-  const string& local_device = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n-  const string& remote_device = \"/job:worker/replica:0/task:0/device\";\n+  const std::string& local_device =\n+      \"/job:localhost/replica:0/task:0/device:CPU:0\";\n+  const std::string& remote_device = \"/job:worker/replica:0/task:0/device\";\n   {\n     // Try a node def of an op which does not have kernel. And the requested\n     // device in NodeDef is on a different address space than the local device.\n@@ -810,7 +812,7 @@ TEST_F(OpKernelBuilderTest, OpOutputList) {\n class GetAttrKernel : public ::tensorflow::OpKernel {\n  public:\n   explicit GetAttrKernel(OpKernelConstruction* context) : OpKernel(context) {\n-    string attr_name;\n+    std::string attr_name;\n     OP_REQUIRES_OK(context, context->GetAttr(\"attr_name\", &attr_name));\n \n     status.emplace_back(\"s\", context->GetAttr(attr_name, &s));\n@@ -836,11 +838,11 @@ class GetAttrKernel : public ::tensorflow::OpKernel {\n   }\n   void Compute(::tensorflow::OpKernelContext* context) override {}\n \n-  void ExpectOk(std::initializer_list<string> keys) {\n+  void ExpectOk(std::initializer_list<std::string> keys) {\n     for (const auto& key_status : status) {\n       // Only the status for keys in \"keys\" should be ok().\n       bool in_keys = false;\n-      for (const string& key : keys) {\n+      for (const std::string& key : keys) {\n         if (key_status.first == key) {\n           in_keys = true;\n         }\n@@ -850,12 +852,12 @@ class GetAttrKernel : public ::tensorflow::OpKernel {\n     }\n   }\n \n-  string s;\n-  std::vector<string> s_list;\n+  std::string s;\n+  std::vector<std::string> s_list;\n   int64_t i;\n   std::vector<int64_t> i_list;\n-  int32 i32;\n-  std::vector<int32> i32_list;\n+  int32_t i32;\n+  std::vector<int32_t> i32_list;\n   float f;\n   std::vector<float> f_list;\n   bool b;\n@@ -867,7 +869,7 @@ class GetAttrKernel : public ::tensorflow::OpKernel {\n   std::vector<TensorShapeProto> shape_proto_list;\n   TensorShape shape;\n   std::vector<TensorShape> shape_list;\n-  std::vector<std::pair<string, absl::Status>> status;\n+  std::vector<std::pair<std::string, absl::Status>> status;\n };\n \n class GetAttrTest : public OpKernelBuilderTest {};\n@@ -884,7 +886,7 @@ TEST_F(GetAttrTest, StringList) {\n                     {\"attr_name|string|'a'\", \"a|list(string)|['foo', 'bar']\"});\n   auto* get_attr_kernel = static_cast<GetAttrKernel*>(op_kernel.get());\n   get_attr_kernel->ExpectOk({\"s_list\"});\n-  EXPECT_EQ(std::vector<string>({\"foo\", \"bar\"}), get_attr_kernel->s_list);\n+  EXPECT_EQ(std::vector<std::string>({\"foo\", \"bar\"}), get_attr_kernel->s_list);\n \n   op_kernel = ExpectSuccess(\"GetAttrStringList\", DEVICE_CPU,\n                             {\"attr_name|string|'b'\", \"a|list(string)|['baz']\"});\n@@ -914,7 +916,7 @@ TEST_F(GetAttrTest, Int) {\n   get_attr_kernel = static_cast<GetAttrKernel*>(op_kernel.get());\n   get_attr_kernel->ExpectOk({\"i_list\", \"i32_list\"});\n   EXPECT_EQ(std::vector<int64_t>({-1, 2, -4}), get_attr_kernel->i_list);\n-  EXPECT_EQ(std::vector<int32>({-1, 2, -4}), get_attr_kernel->i32_list);\n+  EXPECT_EQ(std::vector<int32_t>({-1, 2, -4}), get_attr_kernel->i32_list);\n \n   // 8589934592 == 2^33, too big to fit in an int32\n   op_kernel = ExpectSuccess(\"GetAttrInt\", DEVICE_CPU,"
        },
        {
            "sha": "9300f1590398469c7b99ed61d401c804c32c4dc6",
            "filename": "tensorflow/core/framework/op_kernel_test_base.h",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel_test_base.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_kernel_test_base.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_kernel_test_base.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -54,13 +54,13 @@ static std::vector<DeviceType> DeviceTypes() {\n class OpKernelBuilderTest : public ::testing::Test {\n  protected:\n   // Each attr is described by a \"name|type|value\".\n-  NodeDef CreateNodeDef(const string& op_type,\n-                        const std::vector<string>& attrs) {\n+  NodeDef CreateNodeDef(const std::string& op_type,\n+                        const std::vector<std::string>& attrs) {\n     NodeDef node_def;\n     node_def.set_name(op_type + \"-op\");\n     node_def.set_op(op_type);\n-    for (const string& attr_desc : attrs) {\n-      std::vector<string> parts = str_util::Split(attr_desc, '|');\n+    for (const std::string& attr_desc : attrs) {\n+      std::vector<std::string> parts = str_util::Split(attr_desc, '|');\n       CHECK_EQ(parts.size(), 3);\n       AttrValue attr_value;\n       CHECK(ParseAttrValue(parts[1], parts[2], &attr_value)) << attr_desc;\n@@ -70,9 +70,9 @@ class OpKernelBuilderTest : public ::testing::Test {\n     return node_def;\n   }\n \n-  std::unique_ptr<OpKernel> ExpectSuccess(const string& op_type,\n+  std::unique_ptr<OpKernel> ExpectSuccess(const std::string& op_type,\n                                           const DeviceType& device_type,\n-                                          const std::vector<string>& attrs,\n+                                          const std::vector<std::string>& attrs,\n                                           DataTypeSlice input_types = {}) {\n     absl::Status status;\n     NodeDef def = CreateNodeDef(op_type, attrs);\n@@ -110,8 +110,8 @@ class OpKernelBuilderTest : public ::testing::Test {\n     return op;\n   }\n \n-  void ExpectFailure(const string& op_type, const DeviceType& device_type,\n-                     const std::vector<string>& attrs, error::Code code) {\n+  void ExpectFailure(const std::string& op_type, const DeviceType& device_type,\n+                     const std::vector<std::string>& attrs, error::Code code) {\n     absl::Status status;\n     const NodeDef def = CreateNodeDef(op_type, attrs);\n     Env* env = Env::Default();\n@@ -142,17 +142,17 @@ class OpKernelBuilderTest : public ::testing::Test {\n     }\n   }\n \n-  string GetKernelClassName(const string& op_type,\n-                            const DeviceType& device_type,\n-                            const std::vector<string>& attrs,\n-                            DataTypeSlice input_types = {}) {\n+  std::string GetKernelClassName(const std::string& op_type,\n+                                 const DeviceType& device_type,\n+                                 const std::vector<std::string>& attrs,\n+                                 DataTypeSlice input_types = {}) {\n     NodeDef def = CreateNodeDef(op_type, attrs);\n     for (size_t i = 0; i < input_types.size(); ++i) {\n       def.add_input(\"a:0\");\n     }\n \n     const KernelDef* kernel_def = nullptr;\n-    string kernel_class_name;\n+    std::string kernel_class_name;\n     const absl::Status status =\n         FindKernelDef(device_type, def, &kernel_def, &kernel_class_name);\n     if (status.ok()) {"
        },
        {
            "sha": "7b4e2f97c62d90efd87f86d4131c5ab9d8868094",
            "filename": "tensorflow/core/framework/op_registration_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_registration_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_registration_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_registration_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -24,7 +24,7 @@ namespace tensorflow {\n \n namespace {\n \n-void Register(const string& op_name, OpRegistry* registry) {\n+void Register(const std::string& op_name, OpRegistry* registry) {\n   registry->Register(\n       [op_name](OpRegistrationData* op_reg_data) -> absl::Status {\n         op_reg_data->op_def.set_name(op_name);"
        },
        {
            "sha": "ca75d2af8a466f7e06caee5ef68cc623d41771c0",
            "filename": "tensorflow/core/framework/op_segment.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_segment.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_segment.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_segment.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -35,8 +35,9 @@ OpSegment::~OpSegment() {\n   for (const auto& kv : sessions_) delete kv.second;\n }\n \n-absl::Status OpSegment::FindOrCreate(const string& session_handle,\n-                                     const string& node_name, OpKernel** kernel,\n+absl::Status OpSegment::FindOrCreate(const std::string& session_handle,\n+                                     const std::string& node_name,\n+                                     OpKernel** kernel,\n                                      CreateKernelFn create_fn) {\n   {\n     mutex_lock l(mu_);\n@@ -71,7 +72,7 @@ absl::Status OpSegment::FindOrCreate(const string& session_handle,\n   return absl::OkStatus();\n }\n \n-void OpSegment::AddHold(const string& session_handle) {\n+void OpSegment::AddHold(const std::string& session_handle) {\n   mutex_lock l(mu_);\n   Item** item = &sessions_[session_handle];\n   if (*item == nullptr) {\n@@ -81,7 +82,7 @@ void OpSegment::AddHold(const string& session_handle) {\n   }\n }\n \n-void OpSegment::RemoveHold(const string& session_handle) {\n+void OpSegment::RemoveHold(const std::string& session_handle) {\n   Item* item = nullptr;\n   {\n     mutex_lock l(mu_);\n@@ -101,7 +102,7 @@ void OpSegment::RemoveHold(const string& session_handle) {\n }\n \n bool OpSegment::ShouldOwnKernel(FunctionLibraryRuntime* lib,\n-                                const string& node_op) {\n+                                const std::string& node_op) {\n   // OpSegment should not own kernel if the node is stateless, or a function.\n   return lib->IsStateful(node_op) &&\n          lib->GetFunctionLibraryDefinition()->Find(node_op) == nullptr &&"
        },
        {
            "sha": "e2726fe7f11e98de6afddb27ebe868d4663073c1",
            "filename": "tensorflow/core/framework/op_segment.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_segment.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fop_segment.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_segment.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -67,7 +67,7 @@ class OpSegment {\n \n  private:\n   // op name -> OpKernel\n-  typedef std::unordered_map<string, OpKernel*> KernelMap;\n+  typedef std::unordered_map<std::string, OpKernel*> KernelMap;\n   struct Item {\n     int num_holds = 1;      // Num of holds put on the session.\n     KernelMap name_kernel;  // op name -> kernel.\n@@ -76,7 +76,7 @@ class OpSegment {\n \n   // session handle -> item.\n   // Session handles are produced by strings::FpToString()\n-  typedef std::unordered_map<string, Item*> SessionMap;\n+  typedef std::unordered_map<std::string, Item*> SessionMap;\n \n   mutable mutex mu_;\n   SessionMap sessions_ TF_GUARDED_BY(mu_);"
        },
        {
            "sha": "aad2ae197689f247bd1e6d2ff431da126e4e17bd",
            "filename": "tensorflow/core/framework/ops_util.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fops_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fops_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fops_util.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -64,8 +64,8 @@ absl::Status GetBroadcastSize(const int index, const int in_size,\n   return absl::OkStatus();\n }\n \n-string SanitizeThreadSuffix(string suffix) {\n-  string clean;\n+std::string SanitizeThreadSuffix(std::string suffix) {\n+  std::string clean;\n   for (int i = 0; i < suffix.size(); ++i) {\n     const char ch = suffix[i];\n     if (absl::ascii_isalnum(ch) || ch == '_' || ch == '-') {"
        },
        {
            "sha": "7ca37906f061f84ebfb9be4f66a5470bb9b8ee68",
            "filename": "tensorflow/core/framework/queue_interface.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fqueue_interface.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fqueue_interface.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fqueue_interface.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -85,11 +85,11 @@ class QueueInterface : public ResourceBase {\n   virtual absl::Status MatchesNodeDef(const NodeDef& node_def) = 0;\n \n   // Returns the number of elements in the queue.\n-  virtual int32 size() const = 0;\n+  virtual int32_t size() const = 0;\n \n   virtual const DataTypeVector& component_dtypes() const = 0;\n \n-  string DebugString() const override {\n+  std::string DebugString() const override {\n     return absl::StrCat(\"A Queue of size: \", size());\n   }\n "
        },
        {
            "sha": "916f391d529d10c6ffa2c3c179ee536dd821dc47",
            "filename": "tensorflow/core/framework/reader_base.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Freader_base.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Freader_base.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Freader_base.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -29,7 +29,7 @@ namespace tensorflow {\n \n // ReaderBase ------------------------------------------------------\n \n-ReaderBase::ReaderBase(const string& name) : name_(name) {}\n+ReaderBase::ReaderBase(const std::string& name) : name_(name) {}\n \n int64_t ReaderBase::NumRecordsProduced() {\n   mutex_lock lock(mu_);\n@@ -199,9 +199,9 @@ void ReaderBase::Read(QueueInterface* queue, tstring* key, tstring* value,\n   }\n }\n \n-string ReaderBase::GetNextWorkLocked(QueueInterface* queue,\n-                                     OpKernelContext* context) const {\n-  string work;\n+std::string ReaderBase::GetNextWorkLocked(QueueInterface* queue,\n+                                          OpKernelContext* context) const {\n+  std::string work;\n   absl::Notification n;\n   queue->TryDequeue(\n       context, [context, &n, &work](const QueueInterface::Tuple& tuple) {\n@@ -246,7 +246,7 @@ absl::Status ReaderBase::RestoreBaseState(const ReaderBaseState& state) {\n #if defined(__ANDROID__) || defined(__EMSCRIPTEN__)\n     const string debug_string = \"<debug state not available>\";\n #else\n-    const string debug_string = state.DebugString();\n+    const std::string debug_string = state.DebugString();\n #endif\n     return errors::InvalidArgument(\n         \"Unexpected negative value when restoring in \", name(), \": \",\n@@ -256,7 +256,7 @@ absl::Status ReaderBase::RestoreBaseState(const ReaderBaseState& state) {\n #if defined(__ANDROID__) || (__EMSCRIPTEN__)\n     const string debug_string = \"<debug state not available>\";\n #else\n-    const string debug_string = state.DebugString();\n+    const std::string debug_string = state.DebugString();\n #endif\n     return errors::InvalidArgument(\n         \"Inconsistent work started vs. finished when restoring in \", name(),"
        },
        {
            "sha": "2cd63ea5355526bf32284ae53f6f7f5fd62a2a60",
            "filename": "tensorflow/core/framework/reader_base.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Freader_base.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Freader_base.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Freader_base.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -31,7 +31,7 @@ class ReaderBase : public ReaderInterface {\n  public:\n   // name: For use in error messages, should mention both the name of\n   // the op and the node.\n-  explicit ReaderBase(const string& name);\n+  explicit ReaderBase(const std::string& name);\n \n   // Note that methods with names ending in \"Locked\" are called while\n   // the ReaderBase's mutex is held.\n@@ -87,7 +87,7 @@ class ReaderBase : public ReaderInterface {\n   const tstring& current_work() const { return work_; }\n \n   // What was passed to the constructor.\n-  const string& name() const { return name_; }\n+  const std::string& name() const { return name_; }\n \n   // Produce the key name (from current_work and the actual key).\n   tstring KeyName(const tstring& key) const;\n@@ -106,8 +106,8 @@ class ReaderBase : public ReaderInterface {\n   // For descendants that wish to obtain the next work item in a different way.\n   // For implementing Read().  Dequeues the next work item from\n   // *queue, and if successful returns \"work\" (a string). May block.\n-  virtual string GetNextWorkLocked(QueueInterface* queue,\n-                                   OpKernelContext* context) const;\n+  virtual std::string GetNextWorkLocked(QueueInterface* queue,\n+                                        OpKernelContext* context) const;\n \n   // Implementations of ReaderInterface methods.  These ensure thread-safety\n   // and call the methods above to do the work.\n@@ -127,7 +127,7 @@ class ReaderBase : public ReaderInterface {\n   absl::Status RestoreState(const tstring& state) override;\n \n   mutable mutex mu_;\n-  const string name_;\n+  const std::string name_;\n   int64_t work_started_ = 0;\n   int64_t work_finished_ = 0;\n   int64_t num_records_produced_ = 0;"
        },
        {
            "sha": "c8c1f1302811b86709fe9b6b65368dc220602024",
            "filename": "tensorflow/core/framework/reader_interface.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Freader_interface.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Freader_interface.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Freader_interface.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -77,7 +77,7 @@ class ReaderInterface : public ResourceBase {\n   // Note: Must Reset on error.\n   virtual absl::Status RestoreState(const tstring& state) = 0;\n \n-  string DebugString() const override { return \"a reader\"; }\n+  std::string DebugString() const override { return \"a reader\"; }\n \n  protected:\n   ~ReaderInterface() override {}"
        },
        {
            "sha": "a264ed0c710b30c6f0b8b046a0b029ef4b14fd76",
            "filename": "tensorflow/core/framework/register_types_traits.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fregister_types_traits.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fregister_types_traits.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fregister_types_traits.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -44,15 +44,15 @@ struct proxy_type_pod<CPUDevice, 8> {\n };\n template <>\n struct proxy_type_pod<CPUDevice, 4> {\n-  typedef ::tensorflow::int32 type;\n+  typedef int32_t type;\n };\n template <>\n struct proxy_type_pod<CPUDevice, 2> {\n-  typedef ::tensorflow::int16 type;\n+  typedef int16_t type;\n };\n template <>\n struct proxy_type_pod<CPUDevice, 1> {\n-  typedef ::tensorflow::int8 type;\n+  typedef int8_t type;\n };\n template <>\n struct proxy_type_pod<GPUDevice, 8> {\n@@ -68,7 +68,7 @@ struct proxy_type_pod<GPUDevice, 2> {\n };\n template <>\n struct proxy_type_pod<GPUDevice, 1> {\n-  typedef ::tensorflow::int8 type;\n+  typedef int8_t type;\n };\n \n "
        },
        {
            "sha": "cbe5935907f7915b8e38f0de7fba0027b6b24547",
            "filename": "tensorflow/core/framework/rendezvous.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frendezvous.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frendezvous.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frendezvous.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -53,9 +53,11 @@ Rendezvous::ParsedKey& Rendezvous::ParsedKey::operator=(const ParsedKey& b) {\n }\n \n /*  static */\n-string Rendezvous::CreateKey(const string& src_device, uint64 src_incarnation,\n-                             const string& dst_device, const string& name,\n-                             const FrameAndIter& frame_iter) {\n+std::string Rendezvous::CreateKey(const std::string& src_device,\n+                                  uint64_t src_incarnation,\n+                                  const std::string& dst_device,\n+                                  const std::string& name,\n+                                  const FrameAndIter& frame_iter) {\n   // NOTE: ';' is not used in the device name's job name.\n   //\n   // We include both sender and receiver in the key to facilitate"
        },
        {
            "sha": "f28df3bcaf2c896484ce7f08d3c3e45711df598f",
            "filename": "tensorflow/core/framework/rendezvous.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frendezvous.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frendezvous.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frendezvous.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -60,7 +60,7 @@ class RendezvousInterface {\n   struct ParsedKey {\n     absl::string_view src_device;\n     DeviceNameUtils::ParsedName src;\n-    uint64 src_incarnation = 0;\n+    uint64_t src_incarnation = 0;\n     absl::string_view dst_device;\n     DeviceNameUtils::ParsedName dst;\n     absl::string_view edge_name;\n@@ -159,7 +159,7 @@ class Rendezvous : public RendezvousInterface, public core::WeakRefCounted {\n   // \"src_device\" to \"dst_device\". The tensor is generated in the frame\n   // and iteration specified by \"frame_iter\".\n   static std::string CreateKey(const std::string& src_device,\n-                               uint64 src_incarnation,\n+                               uint64_t src_incarnation,\n                                const std::string& dst_device,\n                                const std::string& name,\n                                const FrameAndIter& frame_iter);"
        },
        {
            "sha": "bdaab9f3c5a32226b5cc03c1e0b2f3cd89269f98",
            "filename": "tensorflow/core/framework/rendezvous_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frendezvous_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frendezvous_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frendezvous_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -39,7 +39,7 @@ namespace tensorflow {\n namespace {\n \n TEST(RendezvousTest, Key) {\n-  const string key = Rendezvous::CreateKey(\n+  const std::string key = Rendezvous::CreateKey(\n       \"/job:mnist/replica:1/task:2/CPU:0\", 7890,\n       \"/job:mnist/replica:1/task:2/device:GPU:0\", \"var0\", FrameAndIter(0, 0));\n   EXPECT_EQ(key,\n@@ -83,23 +83,23 @@ class LocalRendezvousTest : public ::testing::Test {\n };\n \n // string -> Tensor<string>\n-Tensor V(const string& content) {\n+Tensor V(const std::string& content) {\n   Tensor tensor(DT_STRING, TensorShape({}));\n   tensor.scalar<tstring>()() = content;\n   return tensor;\n }\n \n // Tensor<string> -> string\n-string V(const Tensor& tensor) {\n+std::string V(const Tensor& tensor) {\n   CHECK_EQ(tensor.dtype(), DT_STRING);\n   CHECK(TensorShapeUtils::IsScalar(tensor.shape()));\n   return tensor.scalar<tstring>()();\n }\n \n-Rendezvous::ParsedKey MakeKey(const string& name) {\n-  string s = Rendezvous::CreateKey(\"/job:mnist/replica:1/task:2/CPU:0\", 7890,\n-                                   \"/job:mnist/replica:1/task:2/device:GPU:0\",\n-                                   name, FrameAndIter(0, 0));\n+Rendezvous::ParsedKey MakeKey(const std::string& name) {\n+  std::string s = Rendezvous::CreateKey(\n+      \"/job:mnist/replica:1/task:2/CPU:0\", 7890,\n+      \"/job:mnist/replica:1/task:2/device:GPU:0\", name, FrameAndIter(0, 0));\n   Rendezvous::ParsedKey k;\n   TF_EXPECT_OK(Rendezvous::ParseKey(s, &k));\n   return k;"
        },
        {
            "sha": "4a8f291c36853e9924702f94f87119c2f76b05db",
            "filename": "tensorflow/core/framework/resource_handle.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_handle.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_handle.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_handle.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -67,8 +67,8 @@ class ResourceHandle {\n \n   // Hash code for the type of the resource. Is only valid in the same device\n   // and in the same execution.\n-  uint64 hash_code() const { return hash_code_; }\n-  void set_hash_code(uint64 hash_code) { hash_code_ = hash_code; }\n+  uint64_t hash_code() const { return hash_code_; }\n+  void set_hash_code(uint64_t hash_code) { hash_code_ = hash_code; }\n \n   // For debug-only, the name of the type pointed to by this handle, if\n   // available.\n@@ -135,15 +135,15 @@ class ResourceHandle {\n   // does not hold a strong reference to the resource.\n   template <typename T>\n   static ResourceHandle MakeRefCountingHandle(\n-      T* resource, const string& device_name,\n+      T* resource, const std::string& device_name,\n       const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes = {},\n       const absl::optional<ManagedStackTrace>& definition_stack_trace = {}) {\n     return MakeRefCountingHandle(resource, device_name, TypeIndex::Make<T>(),\n                                  dtypes_and_shapes, definition_stack_trace);\n   }\n \n   static ResourceHandle MakeRefCountingHandle(\n-      ResourceBase* resource, const string& device_name,\n+      ResourceBase* resource, const std::string& device_name,\n       const TypeIndex& type_index,\n       const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes = {},\n       const absl::optional<ManagedStackTrace>& definition_stack_trace = {});\n@@ -178,7 +178,7 @@ class ResourceHandle {\n   std::string device_;\n   std::string container_;\n   std::string name_;\n-  uint64 hash_code_ = 0;\n+  uint64_t hash_code_ = 0;\n   std::string maybe_type_name_;\n   std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes_;\n   std::optional<ManagedStackTrace> definition_stack_trace_;"
        },
        {
            "sha": "022b128c145d57a8a6d0483a4565450bceda57ff",
            "filename": "tensorflow/core/framework/resource_handle_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_handle_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_handle_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_handle_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -37,7 +37,7 @@ class MockResource : public ResourceBase {\n       *alive_ = false;\n     }\n   }\n-  string DebugString() const override { return \"\"; }\n+  std::string DebugString() const override { return \"\"; }\n   bool* alive_;\n   int payload_;\n };"
        },
        {
            "sha": "c83acfe5329311e704e2e06530e56bded97e725b",
            "filename": "tensorflow/core/framework/resource_mgr.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 39,
            "changes": 79,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_mgr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_mgr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_mgr.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -40,8 +40,8 @@ limitations under the License.\n namespace tensorflow {\n \n ResourceHandle MakeResourceHandle(\n-    const string& container, const string& name, const DeviceBase& device,\n-    const TypeIndex& type_index,\n+    const std::string& container, const std::string& name,\n+    const DeviceBase& device, const TypeIndex& type_index,\n     const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes,\n     const absl::optional<ManagedStackTrace>& definition_stack_trace) {\n   ResourceHandle result;\n@@ -62,8 +62,8 @@ ResourceHandle MakeResourceHandle(\n \n absl::Status MakeResourceHandleToOutput(OpKernelContext* context,\n                                         int output_index,\n-                                        const string& container,\n-                                        const string& name,\n+                                        const std::string& container,\n+                                        const std::string& name,\n                                         const TypeIndex& type_index) {\n   Tensor* handle;\n   TF_RETURN_IF_ERROR(\n@@ -86,8 +86,8 @@ absl::Status ValidateDevice(OpKernelContext* ctx, const ResourceHandle& p) {\n \n }  // end namespace internal\n \n-absl::Status ResourceMgr::InsertDebugTypeName(uint64 hash_code,\n-                                              const string& type_name) {\n+absl::Status ResourceMgr::InsertDebugTypeName(uint64_t hash_code,\n+                                              const std::string& type_name) {\n   auto iter = debug_type_names_.emplace(hash_code, type_name);\n   if (iter.first->second != type_name) {\n     return errors::AlreadyExists(\"Duplicate hash code found for type \",\n@@ -96,7 +96,7 @@ absl::Status ResourceMgr::InsertDebugTypeName(uint64 hash_code,\n   return absl::OkStatus();\n }\n \n-const char* ResourceMgr::DebugTypeName(uint64 hash_code) const {\n+const char* ResourceMgr::DebugTypeName(uint64_t hash_code) const {\n   auto type_name_iter = debug_type_names_.find(hash_code);\n   if (type_name_iter == debug_type_names_.end()) {\n     return \"<unknown>\";\n@@ -107,8 +107,8 @@ const char* ResourceMgr::DebugTypeName(uint64 hash_code) const {\n \n ResourceMgr::ResourceAndName::ResourceAndName() : name(nullptr) {}\n \n-ResourceMgr::ResourceAndName::ResourceAndName(const string& name)\n-    : name(std::make_unique<string>(name)) {}\n+ResourceMgr::ResourceAndName::ResourceAndName(const std::string& name)\n+    : name(std::make_unique<std::string>(name)) {}\n \n core::RefCountPtr<ResourceBase> ResourceMgr::ResourceAndName::GetResource()\n     const {\n@@ -141,15 +141,15 @@ ResourceMgr::ResourceAndName& ResourceMgr::ResourceAndName::operator=(\n \n ResourceMgr::ResourceMgr() : default_container_(\"localhost\") {}\n \n-ResourceMgr::ResourceMgr(const string& default_container)\n+ResourceMgr::ResourceMgr(const std::string& default_container)\n     : default_container_(default_container) {}\n \n ResourceMgr::~ResourceMgr() { Clear(); }\n \n void ResourceMgr::Clear() {\n   // We do the deallocation outside of the lock to avoid a potential deadlock\n   // in case any of the destructors access the resource manager.\n-  absl::flat_hash_map<string, Container*> tmp_containers;\n+  absl::flat_hash_map<std::string, Container*> tmp_containers;\n   {\n     mutex_lock l(mu_);\n     tmp_containers = std::move(containers_);\n@@ -181,17 +181,17 @@ void ResourceMgr::Finalize() {\n   finalized_ = true;\n }\n \n-string ResourceMgr::DebugString() const {\n+std::string ResourceMgr::DebugString() const {\n   mutex_lock l(mu_);\n   struct Line {\n-    const string* container;\n-    const string type;\n-    const string* resource;\n-    const string detail;\n+    const std::string* container;\n+    const std::string type;\n+    const std::string* resource;\n+    const std::string detail;\n   };\n   std::vector<Line> lines;\n   for (const auto& p : containers_) {\n-    const string& container = p.first;\n+    const std::string& container = p.first;\n     for (const auto& q : *p.second) {\n       const Key& key = q.first;\n       const char* type = DebugTypeName(key.first);\n@@ -201,7 +201,7 @@ string ResourceMgr::DebugString() const {\n       lines.push_back(l);\n     }\n   }\n-  std::vector<string> text;\n+  std::vector<std::string> text;\n   text.reserve(lines.size());\n   for (const Line& line : lines) {\n     text.push_back(strings::Printf(\n@@ -212,9 +212,9 @@ string ResourceMgr::DebugString() const {\n   return absl::StrJoin(text, \"\\n\");\n }\n \n-absl::Status ResourceMgr::DoCreate(const string& container_name, TypeIndex type,\n-                                   const string& name, ResourceBase* resource,\n-                                   bool owns_resource) {\n+absl::Status ResourceMgr::DoCreate(const std::string& container_name,\n+                                   TypeIndex type, const std::string& name,\n+                                   ResourceBase* resource, bool owns_resource) {\n   if (finalized_) {\n     return absl::FailedPreconditionError(\n         \"ResourceMgr is finalized. Cannot create a new resource\");\n@@ -267,16 +267,16 @@ absl::Status ResourceMgr::Lookup(const ResourceHandle& handle,\n                   /*type_name=*/\"ResourceBase\", handle.name(), resource);\n }\n \n-absl::Status ResourceMgr::DoLookup(const string& container, TypeIndex type,\n-                                   const string& name,\n+absl::Status ResourceMgr::DoLookup(const std::string& container, TypeIndex type,\n+                                   const std::string& name,\n                                    ResourceBase** resource) const {\n   return DoLookup(container, type.hash_code(), type.name(), name, resource);\n }\n \n-absl::Status ResourceMgr::DoLookup(const string& container,\n-                                   uint64 type_hash_code,\n-                                   const string& type_name,\n-                                   const string& resource_name,\n+absl::Status ResourceMgr::DoLookup(const std::string& container,\n+                                   uint64_t type_hash_code,\n+                                   const std::string& type_name,\n+                                   const std::string& resource_name,\n                                    ResourceBase** resource) const {\n   const Container* b = gtl::FindPtrOrNull(containers_, container);\n   if (b == nullptr) {\n@@ -299,8 +299,9 @@ absl::Status ResourceMgr::DoLookup(const string& container,\n }\n \n absl::Status ResourceMgr::PopResourceAndName(\n-    const string& container, uint64 type_hash_code, const string& resource_name,\n-    const string& type_name, ResourceAndName& resource_and_name) {\n+    const std::string& container, uint64_t type_hash_code,\n+    const std::string& resource_name, const std::string& type_name,\n+    ResourceAndName& resource_and_name) {\n   mutex_lock l(mu_);\n   Container* b = gtl::FindPtrOrNull(containers_, container);\n   if (b == nullptr) {\n@@ -316,10 +317,10 @@ absl::Status ResourceMgr::PopResourceAndName(\n   return absl::OkStatus();\n }\n \n-absl::Status ResourceMgr::DoDelete(const string& container,\n-                                   uint64 type_hash_code,\n-                                   const string& resource_name,\n-                                   const string& type_name) {\n+absl::Status ResourceMgr::DoDelete(const std::string& container,\n+                                   uint64_t type_hash_code,\n+                                   const std::string& resource_name,\n+                                   const std::string& type_name) {\n   ResourceAndName resource_and_name;\n   TF_RETURN_IF_ERROR(PopResourceAndName(\n       container, type_hash_code, resource_name, type_name, resource_and_name));\n@@ -335,8 +336,8 @@ absl::Status ResourceMgr::DoDelete(const string& container,\n   return absl::OkStatus();\n }\n \n-absl::Status ResourceMgr::DoDelete(const string& container, TypeIndex type,\n-                                   const string& resource_name) {\n+absl::Status ResourceMgr::DoDelete(const std::string& container, TypeIndex type,\n+                                   const std::string& resource_name) {\n   return DoDelete(container, type.hash_code(), resource_name, type.name());\n }\n \n@@ -345,7 +346,7 @@ absl::Status ResourceMgr::Delete(const ResourceHandle& handle) {\n                   \"<unknown>\");\n }\n \n-absl::Status ResourceMgr::Cleanup(const string& container) {\n+absl::Status ResourceMgr::Cleanup(const std::string& container) {\n   {\n     tf_shared_lock l(mu_);\n     if (!gtl::FindOrNull(containers_, container)) {\n@@ -382,13 +383,13 @@ absl::Status ContainerInfo::Init(ResourceMgr* rmgr, const NodeDef& ndef,\n                                  bool use_node_name_as_default) {\n   CHECK(rmgr);\n   rmgr_ = rmgr;\n-  string attr_container;\n+  std::string attr_container;\n   TF_RETURN_IF_ERROR(GetNodeAttr(ndef, \"container\", &attr_container));\n   if (!attr_container.empty() && !IsValidContainerName(attr_container)) {\n     return errors::InvalidArgument(\"container contains invalid characters: \",\n                                    attr_container);\n   }\n-  string attr_shared_name;\n+  std::string attr_shared_name;\n   TF_RETURN_IF_ERROR(GetNodeAttr(ndef, \"shared_name\", &attr_shared_name));\n   if (!attr_shared_name.empty() && (attr_shared_name[0] == '_')) {\n     return errors::InvalidArgument(\"shared_name cannot start with '_':\",\n@@ -411,7 +412,7 @@ absl::Status ContainerInfo::Init(ResourceMgr* rmgr, const NodeDef& ndef,\n   return absl::OkStatus();\n }\n \n-string ContainerInfo::DebugString() const {\n+std::string ContainerInfo::DebugString() const {\n   return strings::StrCat(\"[\", container(), \",\", name(), \",\",\n                          resource_is_private_to_kernel() ? \"private\" : \"public\",\n                          \"]\");"
        },
        {
            "sha": "406dcf39315bd0668edb6ac54a078b6c2b30ba63",
            "filename": "tensorflow/core/framework/resource_mgr.h",
            "status": "modified",
            "additions": 20,
            "deletions": 19,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_mgr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_mgr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_mgr.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -86,14 +86,14 @@ class ScopedStepContainer {\n   // cleanup: callback to delete a container of this name.\n   // prefix: optional string prefix to disambiguate step containers.\n   ScopedStepContainer(const int64_t step_id,\n-                      std::function<void(const string&)> cleanup)\n+                      std::function<void(const std::string&)> cleanup)\n       : step_id_(step_id),\n         container_(absl::StrCat(\"__per_step_\", step_id)),\n         cleanup_(cleanup),\n         dirty_(false) {}\n \n   ScopedStepContainer(const int64_t step_id,\n-                      std::function<void(const string&)> cleanup,\n+                      std::function<void(const std::string&)> cleanup,\n                       const std::string& prefix)\n       : step_id_(step_id),\n         container_(absl::StrCat(\"__\", prefix, \"_per_step_\", step_id)),\n@@ -141,7 +141,7 @@ class ScopedStepContainer {\n  private:\n   const int64_t step_id_;\n   const std::string container_;\n-  const std::function<void(const string&)> cleanup_;\n+  const std::function<void(const std::string&)> cleanup_;\n   mutex mu_;\n   mutable std::atomic<bool> dirty_ TF_GUARDED_BY(mu_);\n };\n@@ -200,7 +200,7 @@ class ResourceMgr {\n   // then this function does not modify resources[i].\n   template <typename T, bool use_dynamic_cast = false>\n   absl::Status LookupMany(\n-      absl::Span<std::pair<const string*, const string*> const>\n+      absl::Span<std::pair<const std::string*, const std::string*> const>\n           containers_and_names,\n       std::vector<core::RefCountPtr<T>>* resources) const;\n \n@@ -245,7 +245,7 @@ class ResourceMgr {\n   std::string DebugString() const;\n \n  private:\n-  typedef std::pair<uint64, absl::string_view> Key;\n+  typedef std::pair<uint64_t, absl::string_view> Key;\n   struct KeyHash {\n     std::size_t operator()(const Key& k) const {\n       return Hash64(k.second.data(), k.second.size(), k.first);\n@@ -262,7 +262,7 @@ class ResourceMgr {\n     std::unique_ptr<std::string> name;\n \n     ResourceAndName();\n-    explicit ResourceAndName(const string& name);\n+    explicit ResourceAndName(const std::string& name);\n     ResourceAndName(ResourceAndName&& other) noexcept;\n     ~ResourceAndName();\n \n@@ -281,15 +281,15 @@ class ResourceMgr {\n \n   const std::string default_container_;\n   mutable mutex mu_;\n-  absl::flat_hash_map<string, Container*> containers_ TF_GUARDED_BY(mu_);\n+  absl::flat_hash_map<std::string, Container*> containers_ TF_GUARDED_BY(mu_);\n   bool finalized_ TF_GUARDED_BY(mu_) = false;\n \n   template <typename T, bool use_dynamic_cast = false>\n   absl::Status LookupInternal(const std::string& container,\n                               const std::string& name, T** resource) const\n       TF_SHARED_LOCKS_REQUIRED(mu_);\n   absl::Status LookupInternal(const std::string& container,\n-                              uint64 type_hash_code, const std::string& name,\n+                              uint64_t type_hash_code, const std::string& name,\n                               ResourceBase** resource) const\n       TF_SHARED_LOCKS_REQUIRED(mu_);\n \n@@ -300,13 +300,13 @@ class ResourceMgr {\n   absl::Status DoLookup(const std::string& container, TypeIndex type,\n                         const std::string& name, ResourceBase** resource) const\n       TF_SHARED_LOCKS_REQUIRED(mu_);\n-  absl::Status DoLookup(const std::string& container, uint64 type_hash_code,\n+  absl::Status DoLookup(const std::string& container, uint64_t type_hash_code,\n                         const std::string& type_name,\n                         const std::string& resource_name,\n                         ResourceBase** resource) const\n       TF_SHARED_LOCKS_REQUIRED(mu_);\n \n-  absl::Status DoDelete(const std::string& container, uint64 type_hash_code,\n+  absl::Status DoDelete(const std::string& container, uint64_t type_hash_code,\n                         const std::string& resource_name,\n                         const std::string& type_name);\n   absl::Status DoDelete(const std::string& container, TypeIndex type,\n@@ -315,23 +315,24 @@ class ResourceMgr {\n   // Pops the ResourceAndName entry. The entry is moved from the list to\n   // the output argument `resource_and_name`.\n   absl::Status PopResourceAndName(const std::string& container,\n-                                  uint64 type_hash_code,\n+                                  uint64_t type_hash_code,\n                                   const std::string& resource_name,\n                                   const std::string& type_name,\n                                   ResourceAndName& resource_and_name);\n   // Inserts the type name for 'hash_code' into the hash_code to type name map.\n-  absl::Status InsertDebugTypeName(uint64 hash_code,\n+  absl::Status InsertDebugTypeName(uint64_t hash_code,\n                                    const std::string& type_name)\n       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n \n   // Returns the type name for the 'hash_code'.\n   // Returns \"<unknown>\" if a resource with such a type was never inserted into\n   // the container.\n-  const char* DebugTypeName(uint64 hash_code) const\n+  const char* DebugTypeName(uint64_t hash_code) const\n       TF_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n \n   // Map from type hash_code to type name.\n-  std::unordered_map<uint64, string> debug_type_names_ TF_GUARDED_BY(mu_);\n+  std::unordered_map<uint64_t, std::string> debug_type_names_\n+      TF_GUARDED_BY(mu_);\n \n   ResourceMgr(const ResourceMgr&) = delete;\n   void operator=(const ResourceMgr&) = delete;\n@@ -560,8 +561,8 @@ class ResourceHandlesOp : public OpKernel {\n   bool IsExpensive() override { return false; }\n \n  private:\n-  std::vector<string> containers_;\n-  std::vector<string> names_;\n+  std::vector<std::string> containers_;\n+  std::vector<std::string> names_;\n   mutex mutex_;\n   std::vector<Tensor> resources_;\n   std::atomic<bool> initialized_{false};\n@@ -682,7 +683,7 @@ absl::Status ResourceMgr::Lookup(const std::string& container,\n \n template <typename T, bool use_dynamic_cast>\n absl::Status ResourceMgr::LookupMany(\n-    absl::Span<std::pair<const string*, const string*> const>\n+    absl::Span<std::pair<const std::string*, const std::string*> const>\n         containers_and_names,\n     std::vector<core::RefCountPtr<T>>* resources) const {\n   CheckDeriveFromResourceBase<T>();\n@@ -854,8 +855,8 @@ template <typename T>\n absl::Status LookupResources(OpKernelContext* ctx,\n                              absl::Span<ResourceHandle const* const> p,\n                              std::vector<core::RefCountPtr<T>>* values) {\n-  std::vector<std::pair<const string*, const string*>> containers_and_names(\n-      p.size());\n+  std::vector<std::pair<const std::string*, const std::string*>>\n+      containers_and_names(p.size());\n   for (size_t i = 0; i < p.size(); ++i) {\n     TF_RETURN_IF_ERROR(internal::ValidateDeviceAndType<T>(ctx, *p[i]));\n     containers_and_names[i] = {&p[i]->container(), &p[i]->name()};"
        },
        {
            "sha": "363abbf4fccb9089e327b7cc18aabe47a203305d",
            "filename": "tensorflow/core/framework/resource_mgr_test.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 28,
            "changes": 61,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_mgr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_mgr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_mgr_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -45,24 +45,28 @@ using ::tsl::testing::StatusIs;\n \n class Resource : public ResourceBase {\n  public:\n-  explicit Resource(const string& label) : label_(label) {}\n+  explicit Resource(const std::string& label) : label_(label) {}\n   ~Resource() override {}\n \n-  string DebugString() const override { return absl::StrCat(\"R/\", label_); }\n+  std::string DebugString() const override {\n+    return absl::StrCat(\"R/\", label_);\n+  }\n \n  private:\n-  string label_;\n+  std::string label_;\n };\n \n class Other : public ResourceBase {\n  public:\n-  explicit Other(const string& label) : label_(label) {}\n+  explicit Other(const std::string& label) : label_(label) {}\n   ~Other() override {}\n \n-  string DebugString() const override { return absl::StrCat(\"O/\", label_); }\n+  std::string DebugString() const override {\n+    return absl::StrCat(\"O/\", label_);\n+  }\n \n  private:\n-  string label_;\n+  std::string label_;\n };\n \n class Finalizable : public ResourceBase {\n@@ -79,38 +83,38 @@ class Finalizable : public ResourceBase {\n };\n \n template <typename T>\n-string Find(const ResourceMgr& rm, const string& container,\n-            const string& name) {\n+std::string Find(const ResourceMgr& rm, const std::string& container,\n+                 const std::string& name) {\n   T* r;\n   TF_CHECK_OK(rm.Lookup(container, name, &r));\n-  const string ret = r->DebugString();\n+  const std::string ret = r->DebugString();\n   r->Unref();\n   return ret;\n }\n \n template <typename T>\n-string LookupOrCreate(ResourceMgr* rm, const string& container,\n-                      const string& name, const string& label) {\n+std::string LookupOrCreate(ResourceMgr* rm, const std::string& container,\n+                           const std::string& name, const std::string& label) {\n   T* r;\n   TF_CHECK_OK(rm->LookupOrCreate<T>(container, name, &r, [&label](T** ret) {\n     *ret = new T(label);\n     return absl::OkStatus();\n   }));\n-  const string ret = r->DebugString();\n+  const std::string ret = r->DebugString();\n   r->Unref();\n   return ret;\n }\n \n static void HasError(const absl::Status& s, const error::Code code,\n-                     const string& substr) {\n+                     const std::string& substr) {\n   EXPECT_EQ(s.code(), code);\n   EXPECT_TRUE(absl::StrContains(s.message(), substr))\n       << s << \", expected substring \" << substr;\n }\n \n template <typename T>\n-absl::Status FindErr(const ResourceMgr& rm, const string& container,\n-                     const string& name) {\n+absl::Status FindErr(const ResourceMgr& rm, const std::string& container,\n+                     const std::string& name) {\n   T* r;\n   absl::Status s = rm.Lookup(container, name, &r);\n   CHECK(!s.ok());\n@@ -323,9 +327,9 @@ TEST(ResourceMgrTest, CreateUnownedFailAfterFinalize) {\n   finalizable->Unref();\n }\n \n-absl::Status ComputePolicy(const string& attr_container,\n-                           const string& attr_shared_name,\n-                           bool use_node_name_as_default, string* result) {\n+absl::Status ComputePolicy(const std::string& attr_container,\n+                           const std::string& attr_shared_name,\n+                           bool use_node_name_as_default, std::string* result) {\n   ContainerInfo cinfo;\n   ResourceMgr rmgr;\n   NodeDef ndef;\n@@ -341,9 +345,10 @@ absl::Status ComputePolicy(const string& attr_container,\n   return absl::OkStatus();\n }\n \n-string Policy(const string& attr_container, const string& attr_shared_name,\n-              bool use_node_name_as_default) {\n-  string ret;\n+std::string Policy(const std::string& attr_container,\n+                   const std::string& attr_shared_name,\n+                   bool use_node_name_as_default) {\n+  std::string ret;\n   TF_CHECK_OK(ComputePolicy(attr_container, attr_shared_name,\n                             use_node_name_as_default, &ret));\n   return ret;\n@@ -365,10 +370,10 @@ TEST(ContainerInfo, Basic) {\n   EXPECT_EQ(Policy(\".cat\", \"bar\", true), \"[.cat,bar,public]\");\n }\n \n-absl::Status WrongPolicy(const string& attr_container,\n-                         const string& attr_shared_name,\n+absl::Status WrongPolicy(const std::string& attr_container,\n+                         const std::string& attr_shared_name,\n                          bool use_node_name_as_default) {\n-  string dbg;\n+  std::string dbg;\n   auto s = ComputePolicy(attr_container, attr_shared_name,\n                          use_node_name_as_default, &dbg);\n   CHECK(!s.ok());\n@@ -396,7 +401,7 @@ TEST(ContainerInfo, Error) {\n // handles.\n class StubDevice : public DeviceBase {\n  public:\n-  explicit StubDevice(const string& name) : DeviceBase(nullptr) {\n+  explicit StubDevice(const std::string& name) : DeviceBase(nullptr) {\n     attr_.set_name(name);\n   }\n \n@@ -405,7 +410,7 @@ class StubDevice : public DeviceBase {\n   }\n \n   const DeviceAttributes& attributes() const override { return attr_; }\n-  const string& name() const override { return attr_.name(); }\n+  const std::string& name() const override { return attr_.name(); }\n \n  private:\n   DeviceAttributes attr_;\n@@ -414,7 +419,7 @@ class StubDevice : public DeviceBase {\n // Empty stub resource for testing resource handles.\n class StubResource : public ResourceBase {\n  public:\n-  string DebugString() const override { return \"\"; }\n+  std::string DebugString() const override { return \"\"; }\n   int value_{0};\n };\n \n@@ -560,7 +565,7 @@ TEST(ResourceHandleTest, DifferentDevice) {\n // Other stub resource to test type-checking of resource handles.\n class OtherStubResource : public ResourceBase {\n  public:\n-  string DebugString() const override { return \"\"; }\n+  std::string DebugString() const override { return \"\"; }\n };\n \n TEST(ResourceHandleTest, DifferentType) {"
        },
        {
            "sha": "983cbdcf588aa9db6a940901523ff2e16d8781c5",
            "filename": "tensorflow/core/framework/resource_op_kernel_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_op_kernel_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fresource_op_kernel_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_op_kernel_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -47,7 +47,7 @@ class StubDevice : public DeviceBase {\n // Stub resource for testing resource op kernel.\n class StubResource : public ResourceBase {\n  public:\n-  string DebugString() const override { return \"\"; }\n+  std::string DebugString() const override { return \"\"; }\n   int code;\n };\n \n@@ -84,8 +84,8 @@ REGISTER_KERNEL_BUILDER(Name(\"StubResourceOp\").Device(DEVICE_CPU),\n \n class ResourceOpKernelTest : public ::testing::Test {\n  protected:\n-  std::unique_ptr<StubResourceOpKernel> CreateOp(int code,\n-                                                 const string& shared_name) {\n+  std::unique_ptr<StubResourceOpKernel> CreateOp(\n+      int code, const std::string& shared_name) {\n     static std::atomic<int64_t> count(0);\n     NodeDef node_def;\n     TF_CHECK_OK(NodeDefBuilder(absl::StrCat(\"test-node\", count.fetch_add(1)),\n@@ -137,7 +137,7 @@ TEST_F(ResourceOpKernelTest, PrivateResource) {\n   // TODO(gonnet): This test is brittle since it assumes that the\n   // ResourceManager is untouched and thus the private resource name starts\n   // with \"_0_\".\n-  const string key = \"_0_\" + op->name();\n+  const std::string key = \"_0_\" + op->name();\n \n   StubResource* resource;\n   TF_ASSERT_OK(\n@@ -155,7 +155,7 @@ TEST_F(ResourceOpKernelTest, PrivateResource) {\n }\n \n TEST_F(ResourceOpKernelTest, SharedResource) {\n-  const string shared_name = \"shared_stub\";\n+  const std::string shared_name = \"shared_stub\";\n   const int code = -201;\n   auto op = CreateOp(code, shared_name);\n   ASSERT_NE(op, nullptr);\n@@ -199,7 +199,7 @@ TEST_F(ResourceOpKernelTest, VerifyResource) {\n }\n \n TEST_F(ResourceOpKernelTest, ContainerClearedBetweenRuns) {\n-  const string shared_name = \"shared_stub\";\n+  const std::string shared_name = \"shared_stub\";\n   const int code = -201;\n   auto op = CreateOp(code, shared_name);\n   ASSERT_NE(op, nullptr);"
        },
        {
            "sha": "4836961f46f08cf6bbe56c4058a8d404773dd3d3",
            "filename": "tensorflow/core/framework/run_handler.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 19,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frun_handler.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -48,7 +48,7 @@ typedef Eigen::RunQueue<Task, 1024> Queue;\n \n namespace internal {\n RunHandlerEnvironment::RunHandlerEnvironment(\n-    Env* env, const ThreadOptions& thread_options, const string& name)\n+    Env* env, const ThreadOptions& thread_options, const std::string& name)\n     : env_(env), thread_options_(thread_options), name_(name) {}\n \n RunHandlerEnvironment::EnvThread* RunHandlerEnvironment::CreateThread(\n@@ -67,7 +67,7 @@ RunHandlerEnvironment::EnvThread* RunHandlerEnvironment::CreateThread(\n \n RunHandlerEnvironment::Task RunHandlerEnvironment::CreateTask(\n     std::function<void()> f) {\n-  uint64 id = 0;\n+  uint64_t id = 0;\n   if (tsl::tracing::EventCollector::IsEnabled()) {\n     id = tsl::tracing::GetUniqueArg();\n     tsl::tracing::RecordEvent(tsl::tracing::EventCategory::kScheduleClosure,\n@@ -126,7 +126,7 @@ void WaitOnWaiter(Waiter* waiter, Waiter* queue_head, mutex* mutex,\n \n ThreadWorkSource::ThreadWorkSource()\n     : non_blocking_work_sharding_factor_(\n-          static_cast<int32>(ParamFromEnvWithDefault(\n+          static_cast<int32_t>(ParamFromEnvWithDefault(\n               \"TF_RUN_HANDLER_NUM_OF_NON_BLOCKING_QUEUES\", 1))),\n       non_blocking_work_queues_(non_blocking_work_sharding_factor_),\n       blocking_inflight_(0),\n@@ -261,7 +261,8 @@ int64_t ThreadWorkSource::GetTracemeId() {\n \n void ThreadWorkSource::SetTracemeId(int64_t value) { traceme_id_ = value; }\n \n-void ThreadWorkSource::SetWaiter(uint64 version, Waiter* waiter, mutex* mutex) {\n+void ThreadWorkSource::SetWaiter(uint64_t version, Waiter* waiter,\n+                                 mutex* mutex) {\n   {\n     tf_shared_lock lock(run_handler_waiter_mu_);\n     // Most of the request won't change sub pool for recomputation.\n@@ -313,7 +314,7 @@ std::string ThreadWorkSource::ToString() {\n \n RunHandlerThreadPool::RunHandlerThreadPool(\n     int num_blocking_threads, int num_non_blocking_threads, Env* env,\n-    const ThreadOptions& thread_options, const string& name,\n+    const ThreadOptions& thread_options, const std::string& name,\n     Eigen::MaxSizeVector<mutex>* waiters_mu,\n     Eigen::MaxSizeVector<Waiter>* queue_waiters)\n     : num_threads_(num_blocking_threads + num_non_blocking_threads),\n@@ -407,7 +408,7 @@ void RunHandlerThreadPool::AddWorkToQueue(ThreadWorkSource* tws,\n // provide better performance due to less lock retention. The drawback is that\n // the profiler will be a bit harder to read.\n void RunHandlerThreadPool::SetThreadWorkSources(\n-    int tid, int start_request_idx, uint64 version,\n+    int tid, int start_request_idx, uint64_t version,\n     const Eigen::MaxSizeVector<ThreadWorkSource*>& thread_work_sources) {\n   mutex_lock l(thread_data_[tid].mu);\n   if (version > thread_data_[tid].new_version) {\n@@ -478,12 +479,12 @@ RunHandlerThreadPool::ThreadData::ThreadData()\n     : new_version(0),\n       current_index(0),\n       new_thread_work_sources(\n-          new Eigen::MaxSizeVector<ThreadWorkSource*>(static_cast<int32>(\n+          new Eigen::MaxSizeVector<ThreadWorkSource*>(static_cast<int32_t>(\n               ParamFromEnvWithDefault(\"TF_RUN_HANDLER_MAX_CONCURRENT_HANDLERS\",\n                                       kMaxConcurrentHandlers)))),\n       current_version(0),\n       current_thread_work_sources(\n-          new Eigen::MaxSizeVector<ThreadWorkSource*>(static_cast<int32>(\n+          new Eigen::MaxSizeVector<ThreadWorkSource*>(static_cast<int32_t>(\n               ParamFromEnvWithDefault(\"TF_RUN_HANDLER_MAX_CONCURRENT_HANDLERS\",\n                                       kMaxConcurrentHandlers)))) {}\n \n@@ -734,7 +735,7 @@ class RunHandler::Impl {\n \n   // Stores now time (in microseconds) since unix epoch when the handler is\n   // requested via RunHandlerPool::Get().\n-  uint64 start_time_us() const { return start_time_us_; }\n+  uint64_t start_time_us() const { return start_time_us_; }\n   int64_t step_id() const { return step_id_; }\n   void ScheduleInterOpClosure(std::function<void()> fn);\n   void ScheduleIntraOpClosure(std::function<void()> fn);\n@@ -763,7 +764,7 @@ class RunHandler::Impl {\n   };\n \n   RunHandlerPool::Impl* pool_impl_;  // NOT OWNED.\n-  uint64 start_time_us_;\n+  uint64_t start_time_us_;\n   int64_t step_id_;\n   std::unique_ptr<thread::ThreadPoolInterface> thread_pool_interface_;\n   internal::ThreadWorkSource tws_;\n@@ -776,7 +777,7 @@ class RunHandler::Impl {\n class RunHandlerPool::Impl {\n  public:\n   explicit Impl(int num_inter_op_threads, int num_intra_op_threads)\n-      : max_handlers_(static_cast<int32>(ParamFromEnvWithDefault(\n+      : max_handlers_(static_cast<int32_t>(ParamFromEnvWithDefault(\n             \"TF_RUN_HANDLER_MAX_CONCURRENT_HANDLERS\", kMaxConcurrentHandlers))),\n         waiters_mu_(\n             ParamFromEnvWithDefault(\"TF_RUN_HANDLER_NUM_SUB_THREAD_POOL\", 2)),\n@@ -838,10 +839,10 @@ class RunHandlerPool::Impl {\n         thread_work_sources =\n             std::make_unique<Eigen::MaxSizeVector<internal::ThreadWorkSource*>>(\n \n-                static_cast<int32>(ParamFromEnvWithDefault(\n+                static_cast<int32_t>(ParamFromEnvWithDefault(\n                     \"TF_RUN_HANDLER_MAX_CONCURRENT_HANDLERS\",\n                     kMaxConcurrentHandlers)));\n-    uint64 version;\n+    uint64_t version;\n     int num_active_requests;\n     RunHandler::Impl* handler_impl;\n     {\n@@ -899,7 +900,7 @@ class RunHandlerPool::Impl {\n     CHECK_EQ(handler->tws()->TaskQueueSize(true), 0);   // Crash OK.\n     CHECK_EQ(handler->tws()->TaskQueueSize(false), 0);  // Crash OK.\n \n-    uint64 now = tensorflow::EnvTime::NowMicros();\n+    uint64_t now = tensorflow::EnvTime::NowMicros();\n     double elapsed = (now - handler->start_time_us()) / 1000.0;\n     time_hist_.Add(elapsed);\n \n@@ -935,7 +936,7 @@ class RunHandlerPool::Impl {\n \n  private:\n   void RecomputePoolStats(\n-      int num_active_requests, uint64 version,\n+      int num_active_requests, uint64_t version,\n       const Eigen::MaxSizeVector<internal::ThreadWorkSource*>&\n           thread_work_sources);\n \n@@ -971,7 +972,7 @@ class RunHandlerPool::Impl {\n };\n \n void RunHandlerPool::Impl::RecomputePoolStats(\n-    int num_active_requests, uint64 version,\n+    int num_active_requests, uint64_t version,\n     const Eigen::MaxSizeVector<internal::ThreadWorkSource*>&\n         thread_work_sources) {\n   if (num_active_requests == 0) return;\n@@ -1019,9 +1020,9 @@ void RunHandlerPool::Impl::LogInfo() {\n     int num_active_requests = sorted_active_handlers_.size();\n     VLOG(1) << \"Printing time histogram: \" << time_hist_.ToString();\n     VLOG(1) << \"Active session runs: \" << num_active_requests;\n-    uint64 now = tensorflow::Env::Default()->NowMicros();\n-    string times_str = \"\";\n-    string ids_str = \"\";\n+    uint64_t now = tensorflow::Env::Default()->NowMicros();\n+    std::string times_str = \"\";\n+    std::string ids_str = \"\";\n     auto it = sorted_active_handlers_.cbegin();\n     for (int i = 0; i < num_active_requests; ++i) {\n       if (i > 0) {"
        },
        {
            "sha": "993be4a9eb4c0e0f971dec5efbaf683b45f9b648",
            "filename": "tensorflow/core/framework/run_handler.h",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frun_handler.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -115,19 +115,19 @@ class RunHandlerEnvironment {\n   struct TaskImpl {\n     std::function<void()> f;\n     Context context;\n-    uint64 trace_id;\n+    uint64_t trace_id;\n   };\n   Env* const env_;\n   const ThreadOptions thread_options_;\n-  const string name_;\n+  const std::string name_;\n \n  public:\n   struct Task {\n     std::unique_ptr<TaskImpl> f;\n   };\n \n   RunHandlerEnvironment(Env* env, const ThreadOptions& thread_options,\n-                        const string& name);\n+                        const std::string& name);\n \n   EnvThread* CreateThread(std::function<void()> f,\n                           const std::string& thread_name);\n@@ -174,7 +174,7 @@ class ThreadWorkSource {\n \n   void SetTracemeId(int64_t value);\n \n-  void SetWaiter(uint64 version, Waiter* waiter, mutex* mutex);\n+  void SetWaiter(uint64_t version, Waiter* waiter, mutex* mutex);\n \n   int64_t GetInflightTaskCount(bool is_blocking);\n \n@@ -193,7 +193,7 @@ class ThreadWorkSource {\n     Queue queue;\n   };\n \n-  int32 non_blocking_work_sharding_factor_;\n+  int32_t non_blocking_work_sharding_factor_;\n   Eigen::MaxSizeVector<NonBlockingQueue*> non_blocking_work_queues_;\n \n   std::atomic<int64_t> blocking_inflight_;\n@@ -207,7 +207,7 @@ class ThreadWorkSource {\n   std::atomic<int64_t> traceme_id_;\n \n   mutex run_handler_waiter_mu_;\n-  uint64 version_ TF_GUARDED_BY(run_handler_waiter_mu_);\n+  uint64_t version_ TF_GUARDED_BY(run_handler_waiter_mu_);\n   mutex* sub_thread_pool_waiter_mu_ TF_GUARDED_BY(run_handler_waiter_mu_);\n   Waiter* sub_thread_pool_waiter_ TF_GUARDED_BY(run_handler_waiter_mu_);\n };\n@@ -222,7 +222,7 @@ class RunHandlerThreadPool {\n \n   RunHandlerThreadPool(int num_blocking_threads, int num_non_blocking_threads,\n                        Env* env, const ThreadOptions& thread_options,\n-                       const string& name,\n+                       const std::string& name,\n                        Eigen::MaxSizeVector<mutex>* waiters_mu,\n                        Eigen::MaxSizeVector<Waiter>* queue_waiters);\n \n@@ -239,7 +239,7 @@ class RunHandlerThreadPool {\n   // The request with start_request_idx will be attempted first. Other requests\n   // will be attempted in FIFO order based on their arrival time.\n   void SetThreadWorkSources(\n-      int tid, int start_request_idx, uint64 version,\n+      int tid, int start_request_idx, uint64_t version,\n       const Eigen::MaxSizeVector<ThreadWorkSource*>& thread_work_sources);\n \n   PerThread* GetPerThread();\n@@ -273,14 +273,14 @@ class RunHandlerThreadPool {\n   struct ThreadData {\n     ThreadData();\n     mutex mu;\n-    uint64 new_version;\n+    uint64_t new_version;\n     condition_variable sources_not_empty;\n     std::unique_ptr<Thread> thread;\n     int current_index;\n     std::unique_ptr<Eigen::MaxSizeVector<ThreadWorkSource*>>\n         new_thread_work_sources TF_GUARDED_BY(mu);\n \n-    uint64 current_version;\n+    uint64_t current_version;\n     // Should only be accessed by one thread.\n     std::unique_ptr<Eigen::MaxSizeVector<ThreadWorkSource*>>\n         current_thread_work_sources;\n@@ -294,7 +294,7 @@ class RunHandlerThreadPool {\n   Eigen::MaxSizeVector<ThreadData> thread_data_;\n   internal::RunHandlerEnvironment env_;\n   std::atomic<bool> cancelled_;\n-  string name_;\n+  std::string name_;\n   Eigen::MaxSizeVector<mutex>* waiters_mu_;\n   Eigen::MaxSizeVector<Waiter>* queue_waiters_;\n "
        },
        {
            "sha": "aab7869c139472528af903869bb4a87c12e47a25",
            "filename": "tensorflow/core/framework/run_handler_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frun_handler_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -638,11 +638,11 @@ class RunHandlerTest : public ::testing::Test {\n     ASSERT_EQ(setenv(\"TF_NUM_INTEROP_THREADS\", \"16\", true), 0);\n   }\n \n-  string a_;\n-  string x_;\n-  string y_;\n-  string y_neg_;\n-  string z_;\n+  std::string a_;\n+  std::string x_;\n+  std::string y_;\n+  std::string y_neg_;\n+  std::string z_;\n   GraphDef def_;\n };\n \n@@ -651,11 +651,11 @@ TEST_F(RunHandlerTest, UseRunHandlerPoolEnableSubPool) {\n   auto session = CreateSession();\n   ASSERT_TRUE(session != nullptr);\n   EXPECT_EQ(absl::OkStatus(), session->Create(def_));\n-  std::vector<std::pair<string, Tensor>> inputs;\n+  std::vector<std::pair<std::string, Tensor>> inputs;\n \n   // Request two targets: one fetch output and one non-fetched output.\n-  std::vector<string> output_names = {y_ + \":0\"};\n-  std::vector<string> target_nodes = {y_neg_};\n+  std::vector<std::string> output_names = {y_ + \":0\"};\n+  std::vector<std::string> target_nodes = {y_neg_};\n   std::vector<Tensor> outputs;\n \n   // Prepares RunOptions and RunMetadata\n@@ -687,10 +687,10 @@ TEST_F(RunHandlerTest, TestConcurrencyUseRunHandlerPool) {\n   thread::ThreadPool* tp = new thread::ThreadPool(Env::Default(), \"test\", 4);\n \n   // Run the graph 1000 times in 4 different threads concurrently.\n-  std::vector<string> output_names = {y_ + \":0\"};\n+  std::vector<std::string> output_names = {y_ + \":0\"};\n   auto fn = [&session, output_names, run_options]() {\n     for (int i = 0; i < 1000; ++i) {\n-      std::vector<std::pair<string, Tensor>> inputs;\n+      std::vector<std::pair<std::string, Tensor>> inputs;\n       std::vector<Tensor> outputs;\n       // Run the graph\n       absl::Status s = session->Run(run_options, inputs, output_names, {},\n@@ -715,11 +715,11 @@ TEST_F(RunHandlerTest, UseRunHandlerPoolEnableSubPoolWithPriority) {\n   auto session = CreateSession();\n   ASSERT_TRUE(session != nullptr);\n   EXPECT_EQ(absl::OkStatus(), session->Create(def_));\n-  std::vector<std::pair<string, Tensor>> inputs;\n+  std::vector<std::pair<std::string, Tensor>> inputs;\n \n   // Request two targets: one fetch output and one non-fetched output.\n-  std::vector<string> output_names = {y_ + \":0\"};\n-  std::vector<string> target_nodes = {y_neg_};\n+  std::vector<std::string> output_names = {y_ + \":0\"};\n+  std::vector<std::string> target_nodes = {y_neg_};\n   std::vector<Tensor> outputs;\n \n   // Prepares RunOptions and RunMetadata\n@@ -751,15 +751,15 @@ TEST_F(RunHandlerTest, TestConcurrencyUseRunHandlerPoolWithPriority) {\n   thread::ThreadPool* tp = new thread::ThreadPool(Env::Default(), \"test\", 4);\n \n   // Run the graph 1000 times in 4 different threads concurrently.\n-  std::vector<string> output_names = {y_ + \":0\"};\n+  std::vector<std::string> output_names = {y_ + \":0\"};\n   auto fn = [&session, output_names]() {\n     for (int i = 0; i < 1000; ++i) {\n       RunOptions run_options;\n       run_options.mutable_experimental()->set_use_run_handler_pool(true);\n       run_options.mutable_experimental()\n           ->mutable_run_handler_pool_options()\n           ->set_priority(i % 4);\n-      std::vector<std::pair<string, Tensor>> inputs;\n+      std::vector<std::pair<std::string, Tensor>> inputs;\n       std::vector<Tensor> outputs;\n       // Run the graph\n       absl::Status s = session->Run(run_options, inputs, output_names, {},"
        },
        {
            "sha": "85ce55fc2400766048c1b4c0d03a488fe9c9e307",
            "filename": "tensorflow/core/framework/run_handler_util.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frun_handler_util.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -35,7 +35,7 @@ std::vector<double> ParamFromEnvWithDefault(const char* var_name,\n   if (!val) {\n     return default_value;\n   }\n-  std::vector<string> splits = str_util::Split(val, \",\");\n+  std::vector<std::string> splits = str_util::Split(val, \",\");\n   std::vector<double> result;\n   result.reserve(splits.size());\n   for (auto& split : splits) {\n@@ -56,7 +56,7 @@ std::vector<int> ParamFromEnvWithDefault(const char* var_name,\n   if (!val) {\n     return default_value;\n   }\n-  std::vector<string> splits = str_util::Split(val, \",\");\n+  std::vector<std::string> splits = str_util::Split(val, \",\");\n   std::vector<int> result;\n   result.reserve(splits.size());\n   for (auto& split : splits) {"
        },
        {
            "sha": "e3e3a2ae57e354ca57ea6102f999b9857bac9b53",
            "filename": "tensorflow/core/framework/run_handler_util_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Frun_handler_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frun_handler_util_test.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -37,7 +37,7 @@ void VerifySchedulingRanges(int num_active_requests, int num_threads,\n \n   ComputeInterOpSchedulingRanges(num_active_requests, num_threads,\n                                  min_threads_per_request, &start, &end);\n-  string range_str = \"\";\n+  std::string range_str = \"\";\n   for (int i = 0; i < num_active_requests; ++i) {\n     if (i > 0) range_str += \" \";\n     range_str += strings::StrCat(\"[\", start[i], \", \", end[i], \")\");\n@@ -107,7 +107,7 @@ TEST(RunHandlerUtilTest, TestComputeInterOpStealingRanges) {\n   for (int i = 0; i < num_inter_op_threads; ++i) {\n     int expected_start = stealing_ranges[i / 6][0];\n     int expected_end = stealing_ranges[i / 6][1];\n-    string message =\n+    std::string message =\n         strings::StrCat(\"Stealing range of thread \", i, \" should be [\",\n                         expected_start, \", \", expected_end, \"]\");\n     ASSERT_EQ(start_vec[i], expected_start) << message;"
        },
        {
            "sha": "84ec0d45c4852c152b6c092b1bf7a90ab889354b",
            "filename": "tensorflow/core/framework/session_state.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fsession_state.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fsession_state.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fsession_state.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -50,7 +50,7 @@ class SessionState {\n   int64_t tensor_id_ = 0;\n \n   // The live tensors in the session. A map from tensor handle to tensor.\n-  std::unordered_map<string, Tensor> tensors_;\n+  std::unordered_map<std::string, Tensor> tensors_;\n };\n \n // The tensor store remembers the tensors we choose to keep for the\n@@ -71,7 +71,7 @@ class TensorStore {\n   absl::Status AddTensor(const std::string& name, const TensorAndKey& tk);\n \n   // Save the tensors in the tensor store of this run to the session.\n-  absl::Status SaveTensors(const std::vector<string>& output_names,\n+  absl::Status SaveTensors(const std::vector<std::string>& output_names,\n                            SessionState* session_state);\n \n   // Returns true if no tensors have been added to this store.\n@@ -83,7 +83,7 @@ class TensorStore {\n \n   // The tensors that will be saved to session state when this run completes.\n   // A map from tensor string name to tensor.\n-  std::unordered_map<string, TensorAndKey> tensors_ TF_GUARDED_BY(lock_);\n+  std::unordered_map<std::string, TensorAndKey> tensors_ TF_GUARDED_BY(lock_);\n };\n \n }  // namespace tensorflow"
        },
        {
            "sha": "79e4cdfc141d0aff4f0d0104612644aabfd9bc23",
            "filename": "tensorflow/core/framework/shape_inference.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fshape_inference.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fshape_inference.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fshape_inference.cc?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -282,32 +282,32 @@ DimensionHandle InferenceContext::NumElements(ShapeHandle s) {\n   }\n }\n \n-string InferenceContext::DebugString(ShapeHandle s) {\n+std::string InferenceContext::DebugString(ShapeHandle s) {\n   if (RankKnown(s)) {\n-    std::vector<string> vals;\n+    std::vector<std::string> vals;\n     for (auto d : s->dims_) vals.push_back(DebugString(d));\n     return absl::StrCat(\"[\", absl::StrJoin(vals, \",\"), \"]\");\n   } else {\n     return \"?\";\n   }\n }\n \n-string InferenceContext::DebugString(DimensionHandle d) {\n+std::string InferenceContext::DebugString(DimensionHandle d) {\n   return ValueKnown(d) ? absl::StrCat(Value(d)) : \"?\";\n }\n \n-string InferenceContext::DebugString() const {\n+std::string InferenceContext::DebugString() const {\n   return absl::StrCat(\"InferenceContext for node: \", attrs_.SummarizeNode());\n }\n \n-string InferenceContext::DebugString(const ShapeAndType& shape_and_type) {\n+std::string InferenceContext::DebugString(const ShapeAndType& shape_and_type) {\n   return absl::StrCat(DebugString(shape_and_type.shape), \":\",\n                       DataTypeString(shape_and_type.dtype));\n }\n \n-string InferenceContext::DebugString(\n+std::string InferenceContext::DebugString(\n     absl::Span<const ShapeAndType> shape_and_types) {\n-  std::vector<string> pieces;\n+  std::vector<std::string> pieces;\n   for (const ShapeAndType& s : shape_and_types) {\n     pieces.push_back(DebugString(s));\n   }\n@@ -316,7 +316,7 @@ string InferenceContext::DebugString(\n \n absl::Status InferenceContext::WithRank(ShapeHandle shape, int64_t rank,\n                                         ShapeHandle* out) {\n-  if (rank > kint32max) {\n+  if (rank > std::numeric_limits<int32_t>::max()) {\n     return errors::InvalidArgument(\"Rank cannot exceed kint32max\");\n   }\n   const int32_t existing = Rank(shape);\n@@ -341,7 +341,7 @@ absl::Status InferenceContext::WithRank(ShapeHandle shape, int64_t rank,\n \n absl::Status InferenceContext::WithRankAtLeast(ShapeHandle shape, int64_t rank,\n                                                ShapeHandle* out) {\n-  if (rank > kint32max) {\n+  if (rank > std::numeric_limits<int32_t>::max()) {\n     return errors::InvalidArgument(\"Rank cannot exceed kint32max\");\n   }\n   const int32_t existing = Rank(shape);\n@@ -356,7 +356,7 @@ absl::Status InferenceContext::WithRankAtLeast(ShapeHandle shape, int64_t rank,\n \n absl::Status InferenceContext::WithRankAtMost(ShapeHandle shape, int64_t rank,\n                                               ShapeHandle* out) {\n-  if (rank > kint32max) {\n+  if (rank > std::numeric_limits<int32_t>::max()) {\n     return errors::InvalidArgument(\"Rank cannot exceed kint32max\");\n   }\n   const int32_t existing = Rank(shape);\n@@ -812,7 +812,7 @@ absl::Status InferenceContext::InternalMakeShapeFromTensor(\n \n   if (t->shape().dims() == 0) {\n     if (t->dtype() == DataType::DT_INT32) {\n-      auto flat_t = t->scalar<int32>();\n+      auto flat_t = t->scalar<int32_t>();\n       if (flat_t() != -1) {\n         *out = nullptr;\n         return errors::InvalidArgument(\n@@ -853,7 +853,7 @@ absl::Status InferenceContext::InternalMakeShapeFromTensor(\n   }\n   std::vector<DimensionHandle> dims;\n   if (t->dtype() == DataType::DT_INT32) {\n-    auto flat_t = t->flat<int32>();\n+    auto flat_t = t->flat<int32_t>();\n     for (int i = 0; i < flat_t.size(); ++i) {\n       const int32_t val = flat_t(i);\n       if (val < -1) {\n@@ -939,7 +939,7 @@ absl::Status InferenceContext::GetScalarFromTensor(const Tensor* t,\n     *val = t->scalar<int16_t>()();\n     return absl::OkStatus();\n   } else if (t->dtype() == DataType::DT_INT32) {\n-    *val = t->scalar<int32>()();\n+    *val = t->scalar<int32_t>()();\n     return absl::OkStatus();\n   } else if (t->dtype() == DataType::DT_INT64) {\n     *val = t->scalar<int64_t>()();\n@@ -959,7 +959,7 @@ absl::Status InferenceContext::GetScalarFromTensor(const Tensor* t, int64_t idx,\n   }\n \n   if (t->dtype() == DataType::DT_INT32) {\n-    auto flat_t = t->flat<int32>();\n+    auto flat_t = t->flat<int32_t>();\n     if (idx < 0 || idx >= flat_t.size()) {\n       return errors::InvalidArgument(\"Invalid index \", idx,\n                                      \" for Tensor of size \", flat_t.size());\n@@ -1069,7 +1069,7 @@ absl::Status InferenceContext::Add(DimensionHandle first,\n     // get pair of values which cannot be store in output. Check below will\n     // report error. We still need to avoid undefined behavior of signed\n     // overflow and use unsigned addition.\n-    const int64_t sum = static_cast<uint64>(first_value) + second_value;\n+    const int64_t sum = static_cast<uint64_t>(first_value) + second_value;\n     if (sum < 0) {\n       return errors::InvalidArgument(\"Dimension size overflow from adding \",\n                                      first_value, \" and \", second_value);\n@@ -1170,15 +1170,15 @@ absl::Status InferenceContext::Max(DimensionHandle first,\n }\n \n absl::Status InferenceContext::AttachContext(const absl::Status& status) {\n-  std::vector<string> input_shapes;\n+  std::vector<std::string> input_shapes;\n   input_shapes.reserve(inputs_.size());\n   for (const ShapeHandle& input_shape : inputs_) {\n     input_shapes.emplace_back(DebugString(input_shape));\n   }\n \n   // Add information about the input tensors and partial tensor shapes used.\n-  std::vector<string> input_from_tensors_str;\n-  std::vector<string> input_from_tensors_as_shape_str;\n+  std::vector<std::string> input_from_tensors_str;\n+  std::vector<std::string> input_from_tensors_as_shape_str;\n   input_from_tensors_as_shape_str.reserve(inputs_.size());\n   for (int i = 0, end = inputs_.size(); i < end; ++i) {\n     const int input_tensors_as_shapes_size = input_tensors_as_shapes_.size();\n@@ -1197,7 +1197,7 @@ absl::Status InferenceContext::AttachContext(const absl::Status& status) {\n     }\n   }\n \n-  string error_context =\n+  std::string error_context =\n       absl::StrCat(\" for '\", attrs_.SummarizeNode(),\n                    \"' with input shapes: \", absl::StrJoin(input_shapes, \", \"));\n   if (!input_from_tensors_str.empty()) {"
        },
        {
            "sha": "6065ab22fa875676cba480735ffc79655d088bbd",
            "filename": "tensorflow/core/framework/shape_inference.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fshape_inference.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/768b244490b0b06a149abfb210b864a45fc767af/tensorflow%2Fcore%2Fframework%2Fshape_inference.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fshape_inference.h?ref=768b244490b0b06a149abfb210b864a45fc767af",
            "patch": "@@ -158,7 +158,7 @@ class Shape {\n   Shape(const std::vector<DimensionHandle>& dims);\n   ~Shape() {}\n \n-  const int32 rank_;\n+  const int32_t rank_;\n   const std::vector<DimensionHandle> dims_;\n \n   friend class InferenceContext;\n@@ -430,7 +430,7 @@ class InferenceContext {\n     return s->dims_[idx];\n   }\n \n-  static int32 Rank(ShapeHandle s) {\n+  static int32_t Rank(ShapeHandle s) {\n     return s.IsSet() ? s->rank_ : kUnknownRank;\n   }\n   static bool RankKnown(ShapeHandle s) {"
        }
    ],
    "stats": {
        "total": 1105,
        "additions": 571,
        "deletions": 534
    }
}