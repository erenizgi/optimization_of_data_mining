{
    "author": "beckerhe",
    "message": "Move Attribute types from call_frame.cc into attribute_map.cc\n\nThis is moving `Scalar`, `Array`, `Dictionary`, `FlatAttribute`, `FlatAttributeMap`, and `AttributeMap` from `CallFrameBuilder` into the `xla::ffi` namespace.\n\nIt also moves the code into `attribute_map.{cc|h}`.\n\nAll these types are basically aliases from some kind of `std::variant` type. This change is a preparation for making them proper types and add `ToProto` and `FromProto` methods.\n\nPiperOrigin-RevId: 824435281",
    "sha": "76a084f18132ecf9d449962bff195eb928574d76",
    "files": [
        {
            "sha": "0ee33256beea1397733f64b3a91f1bf2352754b0",
            "filename": "third_party/xla/xla/backends/cpu/runtime/custom_call_thunk.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fcustom_call_thunk.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fcustom_call_thunk.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fcustom_call_thunk.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -60,7 +60,7 @@ limitations under the License.\n \n namespace xla::cpu {\n \n-using AttributesMap = ffi::CallFrameBuilder::AttributesMap;\n+using AttributesMap = ffi::AttributesMap;\n \n static absl::StatusOr<AttributesMap> ParseAttributes(\n     absl::string_view backend_config) {"
        },
        {
            "sha": "ac6ab6a6a654e44d9534143cfd7c990bd5118ddc",
            "filename": "third_party/xla/xla/backends/gpu/codegen/custom.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -878,7 +878,7 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n   // For XLA FFI handlers we decode opaque backend config into attributes map\n   // at IR emission time, so that we do not need to parse MLIR at run time.\n   // For FFI handlers backend config must be a compatible MLIR dictionary.\n-  CustomCallThunk::AttributesMap attributes;\n+  ffi::AttributesMap attributes;\n \n   // For information about this calling convention, see\n   // xla/g3doc/custom_call.md."
        },
        {
            "sha": "5af1b4e64c4eec154f6a4f2dac834de17e5478b4",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -706,6 +706,7 @@ cc_library(\n         \"//xla:executable_run_options\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n+        \"//xla/ffi:attribute_map\",\n         \"//xla/ffi:call_frame\",\n         \"//xla/ffi:execution_context\",\n         \"//xla/ffi:execution_state\","
        },
        {
            "sha": "6124d605e532d358af29bc9eb8e87221ad1a4cf1",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_cmd.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -989,7 +989,7 @@ class CuDnnCmd : public TracedCommandBufferCmd {\n class CustomCallCmd : public CommandBufferCmd {\n  public:\n   using CustomCallTarget = CustomCallThunk::CustomCallTarget;\n-  using AttributesMap = CustomCallThunk::AttributesMap;\n+  using AttributesMap = ffi::AttributesMap;\n \n   // This is a legacy custom call API that is discouraged, and will be\n   // deprecated once XLA:FFI mechanism is ready."
        },
        {
            "sha": "8b8acee10e5ffae02aad9894792a17030ac233eb",
            "filename": "third_party/xla/xla/backends/gpu/runtime/custom_call_thunk.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcustom_call_thunk.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcustom_call_thunk.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcustom_call_thunk.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -38,6 +38,7 @@ limitations under the License.\n #include \"xla/backends/gpu/runtime/thunk.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/ffi/call_frame.h\"\n #include \"xla/ffi/execution_state.h\"\n #include \"xla/ffi/ffi_api.h\"\n@@ -69,7 +70,7 @@ using xla::ffi::CallOptions;\n static absl::StatusOr<ffi::CallFrame> BuildCallFramePrototype(\n     absl::Span<const std::optional<ShapedSlice>> operands,\n     absl::Span<const std::optional<ShapedSlice>> results,\n-    CustomCallThunk::AttributesMap attributes) {\n+    ffi::AttributesMap attributes) {\n   CallFrameBuilder builder(\n       /*num_args=*/operands.size(),\n       /*num_rets=*/results.size());\n@@ -204,8 +205,9 @@ absl::StatusOr<std::unique_ptr<CustomCallThunk>> CustomCallThunk::Create(\n absl::StatusOr<std::unique_ptr<CustomCallThunk>> CustomCallThunk::Create(\n     ThunkInfo thunk_info, std::string target_name,\n     std::vector<std::optional<ShapedSlice>> operands,\n-    std::vector<std::optional<ShapedSlice>> results, AttributesMap attributes,\n-    const HloComputation* called_computation, absl::string_view platform_name) {\n+    std::vector<std::optional<ShapedSlice>> results,\n+    ffi::AttributesMap attributes, const HloComputation* called_computation,\n+    absl::string_view platform_name) {\n   TF_ASSIGN_OR_RETURN(ffi::HandlerRegistration registration,\n                       ffi::FindHandler(target_name, platform_name));\n \n@@ -218,8 +220,8 @@ absl::StatusOr<std::unique_ptr<CustomCallThunk>> CustomCallThunk::Create(\n     ThunkInfo thunk_info, std::string target_name,\n     XLA_FFI_Handler_Bundle bundle,\n     std::vector<std::optional<ShapedSlice>> operands,\n-    std::vector<std::optional<ShapedSlice>> results, AttributesMap attributes,\n-    const HloComputation* called_computation) {\n+    std::vector<std::optional<ShapedSlice>> results,\n+    ffi::AttributesMap attributes, const HloComputation* called_computation) {\n   auto execution_state = std::make_unique<ffi::ExecutionState>();\n \n   // Initialize FFI handler state if it has an instantiate callback.\n@@ -267,7 +269,7 @@ CustomCallThunk::CustomCallThunk(\n     XLA_FFI_Handler_Bundle bundle,\n     std::vector<std::optional<ShapedSlice>> operands,\n     std::vector<std::optional<ShapedSlice>> results, CallFrame call_frame,\n-    AttributesMap attributes,\n+    ffi::AttributesMap attributes,\n     std::unique_ptr<ffi::ExecutionState> execution_state,\n     const HloComputation* called_computation)\n     : Thunk(Thunk::kCustomCall, thunk_info),"
        },
        {
            "sha": "c598615edd9c3697c5dc89a306e6efc89e695e66",
            "filename": "third_party/xla/xla/backends/gpu/runtime/custom_call_thunk.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcustom_call_thunk.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcustom_call_thunk.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcustom_call_thunk.h?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -29,6 +29,7 @@ limitations under the License.\n #include \"xla/backends/gpu/runtime/thunk.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/ffi/call_frame.h\"\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n@@ -59,9 +60,6 @@ class CustomCallThunk : public Thunk {\n       std::function<void(stream_executor::Stream*, void**, const char*, size_t,\n                          XlaCustomCallStatus*)>;\n \n-  using Attribute = ffi::CallFrameBuilder::Attribute;\n-  using AttributesMap = ffi::CallFrameBuilder::AttributesMap;\n-\n   // Creates a serializable custom call thunk. The callback is resolved using\n   // the legacy CustomCall registry. For new code please use XLA FFI instead.\n   static absl::StatusOr<std::unique_ptr<CustomCallThunk>> Create(\n@@ -84,7 +82,8 @@ class CustomCallThunk : public Thunk {\n   static absl::StatusOr<std::unique_ptr<CustomCallThunk>> Create(\n       ThunkInfo thunk_info, std::string target_name,\n       std::vector<std::optional<ShapedSlice>> operands,\n-      std::vector<std::optional<ShapedSlice>> results, AttributesMap attributes,\n+      std::vector<std::optional<ShapedSlice>> results,\n+      xla::ffi::AttributesMap attributes,\n       const HloComputation* called_computation,\n       absl::string_view platform_name);\n \n@@ -95,7 +94,8 @@ class CustomCallThunk : public Thunk {\n       ThunkInfo thunk_info, std::string target_name,\n       XLA_FFI_Handler_Bundle bundle,\n       std::vector<std::optional<ShapedSlice>> operands,\n-      std::vector<std::optional<ShapedSlice>> results, AttributesMap attributes,\n+      std::vector<std::optional<ShapedSlice>> results,\n+      xla::ffi::AttributesMap attributes,\n       const HloComputation* called_computation);\n \n   absl::Status Prepare(const PrepareParams& params,\n@@ -130,7 +130,7 @@ class CustomCallThunk : public Thunk {\n                   XLA_FFI_Handler_Bundle bundle,\n                   std::vector<std::optional<ShapedSlice>> operands,\n                   std::vector<std::optional<ShapedSlice>> results,\n-                  ffi::CallFrame call_frame, AttributesMap attributes,\n+                  ffi::CallFrame call_frame, xla::ffi::AttributesMap attributes,\n                   std::unique_ptr<ffi::ExecutionState> execution_state,\n                   const HloComputation* called_computation);\n \n@@ -160,7 +160,7 @@ class CustomCallThunk : public Thunk {\n   // functions with XLA runtime. It's under construction, and still misses\n   // a lot of features. Long term it will replace legacy custom calls.\n   std::optional<XLA_FFI_Handler_Bundle> bundle_;\n-  std::optional<AttributesMap> attributes_;\n+  std::optional<xla::ffi::AttributesMap> attributes_;\n \n   // Reference call frame pre-initialized at construction time.\n   std::optional<ffi::CallFrame> call_frame_;"
        },
        {
            "sha": "8e9e966edc3622e19f5769f9f43b9368cdd2a10a",
            "filename": "third_party/xla/xla/backends/gpu/runtime/dynamic_slice_thunk_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -570,7 +570,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpy) {\n       seq.emplace_back(),\n       CustomCallThunk::Create(Thunk::ThunkInfo(), \"__xla_test$$memcpy\",\n                               registration.bundle, operands, results,\n-                              /*attributes=*/CustomCallThunk::AttributesMap(),\n+                              /*attributes=*/ffi::AttributesMap(),\n                               /*called_computation=*/nullptr));\n \n   // Wrapping dynamic slice thunk around the custom call thunk.\n@@ -731,7 +731,7 @@ TEST_F(DynamicSliceThunkTest, SlicedOutputMemcpy) {\n       seq.emplace_back(),\n       CustomCallThunk::Create(Thunk::ThunkInfo(), \"__xla_test$$memcpy\",\n                               registration.bundle, operands, results,\n-                              /*attributes=*/CustomCallThunk::AttributesMap(),\n+                              /*attributes=*/ffi::AttributesMap(),\n                               /*called_computation=*/nullptr));\n \n   // Wrapping dynamic slice thunk around the custom call thunk.\n@@ -1451,7 +1451,7 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpyOOB) {\n       seq.emplace_back(),\n       CustomCallThunk::Create(Thunk::ThunkInfo(), \"__xla_test$$memcpy\",\n                               registration.bundle, operands, results,\n-                              /*attributes=*/CustomCallThunk::AttributesMap(),\n+                              /*attributes=*/ffi::AttributesMap(),\n                               /*called_computation=*/nullptr));\n \n   // Wrapping dynamic slice thunk around the custom call thunk."
        },
        {
            "sha": "dff514d6bb58349c616bd337ee843482c2264993",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -22,6 +22,7 @@ cc_library(\n     hdrs = [\"call_frame.h\"],\n     deps = [\n         \":api\",\n+        \":attribute_map\",\n         \"//xla:types\",\n         \"//xla:util\",\n         \"//xla:xla_data_proto_cc\",\n@@ -44,6 +45,7 @@ xla_cc_test(\n     name = \"call_frame_test\",\n     srcs = [\"call_frame_test.cc\"],\n     deps = [\n+        \":attribute_map\",\n         \":call_frame\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/ffi/api:c_api\",\n@@ -196,16 +198,16 @@ cc_library(\n     srcs = [\"attribute_map.cc\"],\n     hdrs = [\"attribute_map.h\"],\n     deps = [\n-        \":call_frame\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@llvm-project//llvm:Support\",\n         \"@llvm-project//mlir:IR\",\n         \"@llvm-project//mlir:Support\",\n-        \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n \n@@ -216,6 +218,7 @@ xla_cc_test(\n     features = [\"-use_header_modules\"],\n     shuffle_tests = False,\n     deps = [\n+        \":attribute_map\",\n         \":call_frame\",\n         \":execution_context\",\n         \":execution_state\","
        },
        {
            "sha": "fe1d90a14a26217c5735d4427e05e6cd053eba51",
            "filename": "third_party/xla/xla/ffi/api/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -85,6 +85,7 @@ xla_cc_test(\n         \"//xla:executable_run_options\",\n         \"//xla:shape_util\",\n         \"//xla:xla_data_proto_cc\",\n+        \"//xla/ffi:attribute_map\",\n         \"//xla/ffi:call_frame\",\n         \"//xla/ffi:execution_context\",\n         \"//xla/ffi:execution_state\","
        },
        {
            "sha": "f5e5e7e34cf8ee94324921ade95ec45aaef6d2f1",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 17,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -38,6 +38,7 @@ limitations under the License.\n #include \"absl/synchronization/blocking_counter.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/ffi/call_frame.h\"\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n@@ -117,6 +118,7 @@ XLA_FFI_REGISTER_STRUCT_ATTR_DECODING(\n \n namespace xla::ffi {\n \n+using ::absl_testing::StatusIs;\n using ::testing::HasSubstr;\n \n TEST(FfiTest, DataTypeEnumValue) {\n@@ -577,9 +579,8 @@ TEST(FfiTest, MissingBufferArgument) {\n       [](auto) { return Error::Success(); });\n   auto status = Call(*handler, call_frame);\n \n-  EXPECT_THAT(status,\n-              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument,\n-                                     HasSubstr(\"Wrong number of arguments\")));\n+  EXPECT_THAT(status, StatusIs(absl::StatusCode::kInvalidArgument,\n+                               HasSubstr(\"Wrong number of arguments\")));\n }\n \n TEST(FfiTest, WrongRankBufferArgument) {\n@@ -595,9 +596,8 @@ TEST(FfiTest, WrongRankBufferArgument) {\n   auto status = Call(*handler, call_frame);\n \n   EXPECT_THAT(status,\n-              absl_testing::StatusIs(\n-                  absl::StatusCode::kInvalidArgument,\n-                  HasSubstr(\"Wrong buffer rank: expected 1 but got 2\")));\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Wrong buffer rank: expected 1 but got 2\")));\n }\n \n TEST(FfiTest, WrongTypeBufferArgument) {\n@@ -612,10 +612,10 @@ TEST(FfiTest, WrongTypeBufferArgument) {\n       [](auto) { return Error::Success(); });\n   auto status = Call(*handler, call_frame);\n \n-  EXPECT_THAT(status,\n-              absl_testing::StatusIs(\n-                  absl::StatusCode::kInvalidArgument,\n-                  HasSubstr(\"Wrong buffer dtype: expected F32 but got S32\")));\n+  EXPECT_THAT(\n+      status,\n+      StatusIs(absl::StatusCode::kInvalidArgument,\n+               HasSubstr(\"Wrong buffer dtype: expected F32 but got S32\")));\n }\n \n TEST(FfiTest, WrongNumberOfArguments) {\n@@ -631,9 +631,8 @@ TEST(FfiTest, WrongNumberOfArguments) {\n       Ffi::Bind().Attr<int>(\"foo\").To([](int foo) { return Error::Success(); });\n   auto status = Call(*handler, call_frame);\n \n-  EXPECT_THAT(status,\n-              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument,\n-                                     HasSubstr(\"Wrong number of attributes\")));\n+  EXPECT_THAT(status, StatusIs(absl::StatusCode::kInvalidArgument,\n+                               HasSubstr(\"Wrong number of attributes\")));\n   EXPECT_THAT(status.message(), HasSubstr(\"foo\"));\n   EXPECT_THAT(status.message(), HasSubstr(\"bar\"));\n }\n@@ -1072,10 +1071,10 @@ TEST(FfiTest, AttrsAsDictionary) {\n }\n \n TEST(FfiTest, DictionaryAttr) {\n-  CallFrameBuilder::AttributesMap dict0;\n+  AttributesMap dict0;\n   dict0.try_emplace(\"i32\", 42);\n \n-  CallFrameBuilder::AttributesMap dict1;\n+  AttributesMap dict1;\n   dict1.try_emplace(\"f32\", 42.0f);\n \n   CallFrameBuilder::AttributesBuilder attrs;\n@@ -1119,7 +1118,7 @@ TEST(FfiTest, DictionaryAttr) {\n }\n \n TEST(FfiTest, StructAttr) {\n-  CallFrameBuilder::AttributesMap dict;\n+  AttributesMap dict;\n   dict.try_emplace(\"i32\", 42);\n   dict.try_emplace(\"f32\", 42.0f);\n \n@@ -1232,7 +1231,7 @@ TEST(FfiTest, EnumAttr) {\n }\n \n TEST(FfiTest, WrongEnumAttrType) {\n-  CallFrameBuilder::AttributesMap dict;\n+  AttributesMap dict;\n   dict.try_emplace(\"i32\", 42);\n \n   CallFrameBuilder::AttributesBuilder attrs;"
        },
        {
            "sha": "4fd6a309a32f801b646244486a7d6bf3eec52fcc",
            "filename": "third_party/xla/xla/ffi/attribute_map.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 30,
            "changes": 61,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -24,28 +24,26 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n-#include \"llvm/ADT/TypeSwitch.h\"\n+#include \"llvm/ADT/TypeSwitch.h\"  // IWYU pragma: keep\n #include \"mlir/IR/Attributes.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n #include \"mlir/Support/LLVM.h\"\n-#include \"xla/ffi/call_frame.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n \n namespace xla::ffi {\n-\n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertBoolAttr(\n-    absl::string_view name, mlir::BoolAttr boolean) {\n+static absl::StatusOr<Attribute> ConvertBoolAttr(absl::string_view name,\n+                                                 mlir::BoolAttr boolean) {\n   return static_cast<bool>(boolean.getValue());\n }\n \n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertStringAttr(\n-    absl::string_view name, mlir::StringAttr str) {\n+static absl::StatusOr<Attribute> ConvertStringAttr(absl::string_view name,\n+                                                   mlir::StringAttr str) {\n   return str.getValue().str();\n }\n \n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertIntegerAttr(\n-    absl::string_view name, mlir::IntegerAttr integer) {\n+static absl::StatusOr<Attribute> ConvertIntegerAttr(absl::string_view name,\n+                                                    mlir::IntegerAttr integer) {\n   if (integer.getType().isUnsignedInteger()) {\n     switch (integer.getType().getIntOrFloatBitWidth()) {\n       case 8:\n@@ -77,8 +75,8 @@ static absl::StatusOr<CallFrameBuilder::Attribute> ConvertIntegerAttr(\n   }\n }\n \n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertFloatAttr(\n-    absl::string_view name, mlir::FloatAttr fp) {\n+static absl::StatusOr<Attribute> ConvertFloatAttr(absl::string_view name,\n+                                                  mlir::FloatAttr fp) {\n   switch (fp.getType().getIntOrFloatBitWidth()) {\n     case 32:\n       return static_cast<float>(fp.getValue().convertToFloat());\n@@ -90,24 +88,28 @@ static absl::StatusOr<CallFrameBuilder::Attribute> ConvertFloatAttr(\n   }\n }\n \n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertArrayAttr(\n-    absl::string_view name, mlir::DenseArrayAttr arr) {\n+static absl::StatusOr<Attribute> ConvertArrayAttr(absl::string_view name,\n+                                                  mlir::DenseArrayAttr arr) {\n   if (auto dense = mlir::dyn_cast<mlir::DenseI8ArrayAttr>(arr)) {\n     return dense.asArrayRef().vec();\n-  } else if (auto dense = mlir::dyn_cast<mlir::DenseI16ArrayAttr>(arr)) {\n+  }\n+  if (auto dense = mlir::dyn_cast<mlir::DenseI16ArrayAttr>(arr)) {\n     return dense.asArrayRef().vec();\n-  } else if (auto dense = mlir::dyn_cast<mlir::DenseI32ArrayAttr>(arr)) {\n+  }\n+  if (auto dense = mlir::dyn_cast<mlir::DenseI32ArrayAttr>(arr)) {\n     return dense.asArrayRef().vec();\n-  } else if (auto dense = mlir::dyn_cast<mlir::DenseI64ArrayAttr>(arr)) {\n+  }\n+  if (auto dense = mlir::dyn_cast<mlir::DenseI64ArrayAttr>(arr)) {\n     return dense.asArrayRef().vec();\n-  } else if (auto dense = mlir::dyn_cast<mlir::DenseF32ArrayAttr>(arr)) {\n+  }\n+  if (auto dense = mlir::dyn_cast<mlir::DenseF32ArrayAttr>(arr)) {\n     return dense.asArrayRef().vec();\n-  } else if (auto dense = mlir::dyn_cast<mlir::DenseF64ArrayAttr>(arr)) {\n+  }\n+  if (auto dense = mlir::dyn_cast<mlir::DenseF64ArrayAttr>(arr)) {\n     return dense.asArrayRef().vec();\n-  } else {\n-    return absl::InvalidArgumentError(\n-        absl::StrCat(\"Unsupported array element type for attribute: \", name));\n   }\n+  return absl::InvalidArgumentError(\n+      absl::StrCat(\"Unsupported array element type for attribute: \", name));\n }\n \n template <typename T>\n@@ -117,7 +119,7 @@ static std::vector<T> CopyDenseElementsToVec(\n   return std::vector<T>(it.begin(), it.end());\n }\n \n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertDenseElementsAttr(\n+static absl::StatusOr<Attribute> ConvertDenseElementsAttr(\n     absl::string_view name, mlir::DenseIntOrFPElementsAttr arr) {\n   auto type = arr.getElementType();\n   if (type.isInteger()) {\n@@ -156,16 +158,15 @@ static absl::StatusOr<CallFrameBuilder::Attribute> ConvertDenseElementsAttr(\n       absl::StrCat(\"Unsupported array element type for attribute: \", name));\n }\n \n-static absl::StatusOr<CallFrameBuilder::Attribute> ConvertDictionaryAttr(\n+static absl::StatusOr<Attribute> ConvertDictionaryAttr(\n     absl::string_view name, mlir::DictionaryAttr dict) {\n   TF_ASSIGN_OR_RETURN(auto attrs, BuildAttributesMap(dict));\n-  return CallFrameBuilder::Dictionary{\n-      std::make_shared<CallFrameBuilder::AttributesMap>(std::move(attrs))};\n+  return AttributesDictionary{\n+      std::make_shared<AttributesMap>(std::move(attrs))};\n }\n \n-absl::StatusOr<CallFrameBuilder::AttributesMap> BuildAttributesMap(\n-    mlir::DictionaryAttr dict) {\n-  CallFrameBuilder::AttributesMap attributes;\n+absl::StatusOr<AttributesMap> BuildAttributesMap(mlir::DictionaryAttr dict) {\n+  AttributesMap attributes;\n   for (auto& kv : dict) {\n     absl::string_view name = kv.getName().strref();\n     mlir::Attribute value = kv.getValue();"
        },
        {
            "sha": "a97d8862f78ca1d5f9d186e4d6f603770c0af8bd",
            "filename": "third_party/xla/xla/ffi/attribute_map.h",
            "status": "modified",
            "additions": 52,
            "deletions": 3,
            "changes": 55,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fattribute_map.h?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -16,16 +16,65 @@ limitations under the License.\n #ifndef XLA_FFI_ATTRIBUTE_MAP_H_\n #define XLA_FFI_ATTRIBUTE_MAP_H_\n \n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <variant>\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_map.h\"\n #include \"absl/status/statusor.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n-#include \"xla/ffi/call_frame.h\"\n \n namespace xla::ffi {\n+namespace internal {\n+// A little bit of template metaprogramming to append type to std::variant.\n+template <typename V, class T>\n+struct AppendType;\n+\n+template <typename... Ts, class T>\n+struct AppendType<std::variant<Ts...>, T> {\n+  using Type = std::variant<Ts..., T>;\n+};\n+}  // namespace internal\n+\n+// A single scalar value.\n+using Scalar = std::variant<bool, int8_t, int16_t, int32_t, int64_t, uint8_t,\n+                            uint16_t, uint32_t, uint64_t, float, double>;\n+\n+// An array of elements of the same Scalar type.\n+using Array = std::variant<std::vector<int8_t>, std::vector<int16_t>,\n+                           std::vector<int32_t>, std::vector<int64_t>,\n+                           std::vector<uint8_t>, std::vector<uint16_t>,\n+                           std::vector<uint32_t>, std::vector<uint64_t>,\n+                           std::vector<float>, std::vector<double>>;\n+\n+// Attributes that do not support nested dictionaries.\n+using FlatAttribute = std::variant<Scalar, Array, std::string>;\n+\n+// A map that maps from an arbitrary name (string key) to a flat attribute.\n+using FlatAttributesMap = absl::flat_hash_map<std::string, FlatAttribute>;\n+\n+// Forward declaration of the recursive type.\n+struct AttributesDictionary;\n+\n+// Attributes that support arbitrary nesting.\n+using Attribute =\n+    internal::AppendType<FlatAttribute, AttributesDictionary>::Type;\n+\n+// AttributesMap is a map from an arbitrary name (string key) to an attribute.\n+using AttributesMap = absl::flat_hash_map<std::string, Attribute>;\n+\n+// Dictionary is just a wrapper around `AttributesMap`. We need an indirection\n+// through `std::shared_ptr` to be able to define recursive `std::variant`. We\n+// use shared pointer to keep `AttributesMap` copyable.\n+struct AttributesDictionary {\n+  std::shared_ptr<AttributesMap> attrs;\n+};\n \n // Converts MLIR dictionary attribute attached to a custom call operation to a\n // custom call handler attributes that are forwarded to the FFI handler.\n-absl::StatusOr<CallFrameBuilder::AttributesMap> BuildAttributesMap(\n-    mlir::DictionaryAttr dict);\n+absl::StatusOr<AttributesMap> BuildAttributesMap(mlir::DictionaryAttr dict);\n \n }  // namespace xla::ffi\n "
        },
        {
            "sha": "70d4a823f3f20c4b5876763edc783923728d8c8b",
            "filename": "third_party/xla/xla/ffi/call_frame.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -34,6 +34,7 @@ limitations under the License.\n #include \"xla/ffi/api/api.h\"\n #include \"xla/ffi/api/c_api.h\"\n #include \"xla/ffi/api/c_api_internal.h\"  // IWYU pragma: keep\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/util.h\"\n@@ -51,7 +52,7 @@ struct CallFrameBuilder::Buffer {\n   absl::InlinedVector<int64_t, 4> dims;\n };\n \n-CallFrameBuilder::AttributesMap CallFrameBuilder::AttributesBuilder::Build() {\n+AttributesMap CallFrameBuilder::AttributesBuilder::Build() {\n   return std::move(attrs_);\n }\n \n@@ -65,8 +66,9 @@ void CallFrameBuilder::AttributesBuilder::Insert(std::string name,\n \n void CallFrameBuilder::AttributesBuilder::Insert(std::string name,\n                                                  AttributesMap attrs) {\n-  attrs_.try_emplace(std::move(name),\n-                     Dictionary{std::make_shared<AttributesMap>(attrs)});\n+  attrs_.try_emplace(\n+      std::move(name),\n+      AttributesDictionary{std::make_shared<AttributesMap>(attrs)});\n }\n \n void CallFrameBuilder::AttributesBuilder::Append(AttributesMap attrs) {\n@@ -160,13 +162,13 @@ struct CallFrame::Dictionary {\n };\n \n struct CallFrame::Array {\n-  CallFrameBuilder::Array value;  // XLA_FFI_Array::data\n+  xla::ffi::Array value;  // XLA_FFI_Array::data\n \n   XLA_FFI_Array array = {};\n };\n \n struct CallFrame::Scalar {\n-  CallFrameBuilder::Scalar value;  // XLA_FFI_Scalar::value\n+  xla::ffi::Scalar value;  // XLA_FFI_Scalar::value\n \n   XLA_FFI_Scalar scalar = {};\n };\n@@ -413,20 +415,20 @@ std::unique_ptr<CallFrame::Results> CallFrame::FixUpRets(\n // An std::visit overload set for converting CallFrameBuilder::Attribute to\n // CallFrame::Attribute.\n struct CallFrame::ConvertAttribute {\n-  CallFrame::Attribute operator()(const CallFrameBuilder::Array& array) {\n+  CallFrame::Attribute operator()(const xla::ffi::Array& array) {\n     return CallFrame::Array{array};\n   }\n \n-  CallFrame::Attribute operator()(const CallFrameBuilder::Scalar& scalar) {\n+  CallFrame::Attribute operator()(const xla::ffi::Scalar& scalar) {\n     return CallFrame::Scalar{scalar};\n   }\n \n   CallFrame::Attribute operator()(const std::string& str) {\n     return CallFrame::String{str};\n   }\n \n-  CallFrame::Attribute operator()(const CallFrameBuilder::Dictionary& dict) {\n-    return CallFrame::Dictionary{CreateAttrs(*dict.attrs)};\n+  CallFrame::Attribute operator()(const xla::ffi::AttributesDictionary& dict) {\n+    return Dictionary{CreateAttrs(*dict.attrs)};\n   }\n };\n \n@@ -498,7 +500,7 @@ struct CallFrame::AttributeStorage {\n };\n \n std::unique_ptr<CallFrame::Attributes> CallFrame::CreateAttrs(\n-    const CallFrameBuilder::AttributesMap& battrs) {\n+    const xla::ffi::AttributesMap& battrs) {\n   auto attrs = std::make_unique<Attributes>();\n \n   // Convert call frame builder attributes to a collection of named attributes."
        },
        {
            "sha": "32dceead1d9b4b610d4b923ad7ce3463f7841e97",
            "filename": "third_party/xla/xla/ffi/call_frame.h",
            "status": "modified",
            "additions": 2,
            "deletions": 37,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame.h?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -29,6 +29,7 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/types/span.h\"\n #include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/types.h\"  // IWYU pragma: keep\n #include \"xla/xla_data.pb.h\"\n@@ -45,48 +46,13 @@ namespace xla::ffi {\n class CallFrame;  // forward declare\n \n class CallFrameBuilder {\n-  // A little bit of template metaprogramming to append type to std::variant.\n-  template <typename V, class T>\n-  struct AppendType;\n-\n-  template <typename... Ts, class T>\n-  struct AppendType<std::variant<Ts...>, T> {\n-    using Type = std::variant<Ts..., T>;\n-  };\n-\n  public:\n   CallFrameBuilder(size_t num_args, size_t num_rets);\n   ~CallFrameBuilder();\n \n   CallFrameBuilder(CallFrameBuilder&&);\n   CallFrameBuilder& operator=(CallFrameBuilder&&);\n \n-  using Scalar = std::variant<bool, int8_t, int16_t, int32_t, int64_t, uint8_t,\n-                              uint16_t, uint32_t, uint64_t, float, double>;\n-  using Array = std::variant<std::vector<int8_t>, std::vector<int16_t>,\n-                             std::vector<int32_t>, std::vector<int64_t>,\n-                             std::vector<uint8_t>, std::vector<uint16_t>,\n-                             std::vector<uint32_t>, std::vector<uint64_t>,\n-                             std::vector<float>, std::vector<double>>;\n-\n-  // Declare implementation detail structs for call frame builder storage.\n-  struct Dictionary;\n-\n-  // Attributes that do not support nested dictionaries.\n-  using FlatAttribute = std::variant<Scalar, Array, std::string>;\n-  using FlatAttributesMap = absl::flat_hash_map<std::string, FlatAttribute>;\n-\n-  // Attributes that support arbitrary nesting.\n-  using Attribute = typename AppendType<FlatAttribute, Dictionary>::Type;\n-  using AttributesMap = absl::flat_hash_map<std::string, Attribute>;\n-\n-  // Dictionary is just a wrapper around AttributesMap. We need an indirection\n-  // through `std::shared_ptr` to be able to define recursive `std::variant`. We\n-  // use shared pointer to keep `AttributesMap` copyable.\n-  struct Dictionary {\n-    std::shared_ptr<AttributesMap> attrs;\n-  };\n-\n   // A helper class to build call frame attributes.\n   class AttributesBuilder {\n    public:\n@@ -224,8 +190,7 @@ class CallFrame {\n   //===----- Call frame attributes ----------------------------------------===//\n \n   // Creates call frame attributes from the call frame builder attributes.\n-  static std::unique_ptr<Attributes> CreateAttrs(\n-      const CallFrameBuilder::AttributesMap& attrs);\n+  static std::unique_ptr<Attributes> CreateAttrs(const AttributesMap& attrs);\n \n   // Fixes up call frame attributes by initializing XLA FFI structs with valid\n   // pointers into storage objects."
        },
        {
            "sha": "f73461fc7d297f10c80a72b9cfaf5a0f92abb70d",
            "filename": "third_party/xla/xla/ffi/call_frame_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fcall_frame_test.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include <gtest/gtest.h>\n #include \"absl/strings/str_cat.h\"\n #include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/test.h\"\n@@ -131,7 +132,7 @@ void BM_AddBufferArg(benchmark::State& state) {\n void BM_AddAttributes(benchmark::State& state) {\n   size_t num_attrs = state.range(0);\n \n-  CallFrameBuilder::AttributesMap attrs;\n+  AttributesMap attrs;\n   for (size_t i = 0; i < num_attrs; ++i) {\n     attrs.try_emplace(absl::StrCat(\"attr_\", i), 42);\n   }"
        },
        {
            "sha": "0edd10045b68d485a1f7264d6cd893211d0593b3",
            "filename": "third_party/xla/xla/ffi/ffi_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -35,6 +35,7 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/ffi/api/c_api.h\"\n+#include \"xla/ffi/attribute_map.h\"\n #include \"xla/ffi/call_frame.h\"\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n@@ -412,10 +413,10 @@ TEST(FfiTest, AttrsAsDictionary) {\n }\n \n TEST(FfiTest, DictionaryAttr) {\n-  CallFrameBuilder::AttributesMap dict0;\n+  AttributesMap dict0;\n   dict0.try_emplace(\"i32\", 42);\n \n-  CallFrameBuilder::AttributesMap dict1;\n+  AttributesMap dict1;\n   dict1.try_emplace(\"f32\", 42.0f);\n \n   CallFrameBuilder::AttributesBuilder attrs;\n@@ -458,7 +459,7 @@ TEST(FfiTest, DictionaryAttr) {\n }\n \n TEST(FfiTest, StructAttr) {\n-  CallFrameBuilder::AttributesMap dict;\n+  AttributesMap dict;\n   dict.try_emplace(\"i32\", 42);\n   dict.try_emplace(\"f32\", 42.0f);\n "
        },
        {
            "sha": "2b90b1b2bd333b00150dda4868c53a041a3dfebc",
            "filename": "third_party/xla/xla/service/gpu/ir_emitter_unnested.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fir_emitter_unnested.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/76a084f18132ecf9d449962bff195eb928574d76/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fir_emitter_unnested.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fir_emitter_unnested.cc?ref=76a084f18132ecf9d449962bff195eb928574d76",
            "patch": "@@ -1199,7 +1199,7 @@ absl::Status IrEmitterUnnested::EmitCustomCallThunk(\n   // attributes map at IR emission time, so that we do not need to\n   // parse MLIR at run time. For FFI handlers backend config must be\n   // a compatible MLIR dictionary.\n-  CustomCallThunk::AttributesMap attributes;\n+  ffi::AttributesMap attributes;\n \n   auto backend_config = instr->backend_config<GpuBackendConfig>();\n   if (!backend_config.ok()) {"
        }
    ],
    "stats": {
        "total": 273,
        "additions": 149,
        "deletions": 124
    }
}