{
    "author": "ZixuanJiang",
    "message": "Update the interface in spmd_partitioner_test.cc.\n\nAvoid passing too many arguments. Instead, specify the options in every single test case if needed.\n\nPure refactoring without behavior change.\n\nPiperOrigin-RevId: 813654132",
    "sha": "7f77d41d7b67cfe2a9ec9026cc939c4fd48244ed",
    "files": [
        {
            "sha": "3c569b1fe380bcdef3b00f00b90d9e775a56fa5d",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_test.cc",
            "status": "modified",
            "additions": 154,
            "deletions": 303,
            "changes": 457,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f77d41d7b67cfe2a9ec9026cc939c4fd48244ed/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f77d41d7b67cfe2a9ec9026cc939c4fd48244ed/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_test.cc?ref=7f77d41d7b67cfe2a9ec9026cc939c4fd48244ed",
            "patch": "@@ -83,37 +83,9 @@ class SpmdPartitioningTest\n  public:\n   absl::StatusOr<std::unique_ptr<HloModule>> PartitionComputation(\n       absl::string_view hlo_module, int64_t num_devices,\n-      bool use_all_gather = false, bool conv_halo_exchange_always_on_lhs = true,\n-      bool choose_faster_windowed_einsum = false,\n-      bool unroll_windowed_einsum = false,\n-      bool bidirectional_windowed_einsum = false,\n-      int64_t threshold_for_windowed_einsum_mib = -1,\n-      std::vector<GatherScatterPartitioningMethod> gather_methods =\n-          {GatherScatterPartitioningMethod::kExplicitBatch,\n-           GatherScatterPartitioningMethod::kIndexParallel},\n-      std::vector<GatherScatterPartitioningMethod> scatter_methods =\n-          {GatherScatterPartitioningMethod::kExplicitBatch,\n-           GatherScatterPartitioningMethod::kIndexParallel},\n-      std::optional<int64_t> total_bytes_windowed_einsum_threshold =\n-          std::nullopt) {\n-    // Some tests (BackpropFilter convs) set this flag false to test two\n-    // different paths of the implementation.\n-    SpmdPartitionerOptions options;\n-    options.conv_halo_exchange_always_on_lhs = conv_halo_exchange_always_on_lhs;\n+      SpmdPartitionerOptions options = SpmdPartitionerOptions(),\n+      bool use_all_gather = false) {\n     options.allow_module_signature_change = true;\n-    options.choose_faster_windowed_einsum_over_mem =\n-        choose_faster_windowed_einsum;\n-    options.unroll_windowed_einsum = unroll_windowed_einsum;\n-    options.bidirectional_windowed_einsum = bidirectional_windowed_einsum;\n-    options.partial_windowed_einsum = true;\n-    options.total_bytes_windowed_einsum_threshold =\n-        total_bytes_windowed_einsum_threshold;\n-    if (threshold_for_windowed_einsum_mib >= 0) {\n-      options.threshold_for_windowed_einsum_mib =\n-          threshold_for_windowed_einsum_mib;\n-    }\n-    options.preferred_gather_partition_methods = gather_methods;\n-    options.preferred_scatter_partition_methods = scatter_methods;\n     auto collective_ops_creator =\n         GetDefaultCollectiveOpsCreator(num_devices, /*num_replicas=*/1);\n     // Do not use all-gather for pattern-matching purpose, as the partitioner\n@@ -2230,11 +2202,11 @@ ENTRY entry {\n     window={size=28x28 pad=1_1x1_1}, dim_labels=f01b_i01o->01bf, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.conv_halo_exchange_always_on_lhs = false;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/false));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -2270,12 +2242,11 @@ ENTRY entry {\n   ROOT %conv = f32[7,7,3,64] convolution(%lhs.copy, %rhs.copy),\n     window={size=112x112 pad=3_2x3_2 rhs_dilate=2x2}, dim_labels=f01b_i01o->01bf, sharding={replicated}\n })\";\n-\n+  SpmdPartitionerOptions options;\n+  options.conv_halo_exchange_always_on_lhs = false;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/false));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -2313,11 +2284,11 @@ ENTRY entry {\n     window={size=28x28 pad=0_-1x0_-1 rhs_dilate=2x2}, dim_labels=f01b_i01o->01bf, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.conv_halo_exchange_always_on_lhs = false;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/false));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -2347,11 +2318,11 @@ ENTRY entry {\n     window={size=7x7 pad=1_0x1_0 rhs_dilate=2x2}, dim_labels=f01b_i01o->01bf, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.conv_halo_exchange_always_on_lhs = false;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/false));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -5142,11 +5113,11 @@ ENTRY entry {\n     dim_labels=bf_io->bf, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.conv_halo_exchange_always_on_lhs = false;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/false));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -5304,15 +5275,11 @@ ENTRY entry {\n   ROOT %dot.224 = f32[2048,2176]{1,0} dot(f32[2048,2,3264]{2,1,0} %p0, f32[2,3264,2176]{2,1,0} %p1), lhs_contracting_dims={1,2}, rhs_contracting_dims={0,1}, sharding={devices=[1,2]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   // Check while op.\n@@ -5357,15 +5324,11 @@ ENTRY entry {\n   ROOT %dot.224 = f32[4096,2176]{1,0} dot(f32[4096,2,3264]{2,1,0} %p0, f32[2,3264,2176]{2,1,0} %p1), lhs_contracting_dims={1,2}, rhs_contracting_dims={0,1}, sharding={devices=[1,2]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   // Check while op.\n@@ -5415,15 +5378,12 @@ ENTRY entry {\n   ROOT %dot.128 = bf16[512,768]{1,0} dot(bf16[512,4,512]{2,1,0} %multiply.611, bf16[4,512,768]{2,1,0} %reshape.1074), lhs_contracting_dims={1,2}, rhs_contracting_dims={0,1}, sharding={devices=[16,4]<=[64]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.choose_faster_windowed_einsum_over_mem = true;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/64,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/true,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/64, options));\n   VLOG(1) << module->ToString();\n \n   // Check while op.\n@@ -5469,15 +5429,14 @@ ENTRY entry {\n   ROOT dot.1104 = bf16[32,64,1025,16384]{3,2,1,0} dot(reshape.9434, reshape.9438), lhs_batch_dims={2}, lhs_contracting_dims={3}, rhs_batch_dims={0}, rhs_contracting_dims={1}, sharding={devices=[1,8,1,8]<=[64]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n+  options.bidirectional_windowed_einsum = true;\n+  options.choose_faster_windowed_einsum_over_mem = true;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/64,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/true,\n-                           /*unroll_windowed_einsum=*/true,\n-                           /*bidirectional_windowed_einsum=*/true,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/64, options));\n   VLOG(1) << module->ToString();\n   TF_ASSERT_OK(HloVerifier(/*layout_sensitive=*/false,\n                            /*allow_mixed_precision=*/false)\n@@ -5511,18 +5470,12 @@ ENTRY entry {\n   ROOT %dot.224 = f32[2048,2176]{1,0} dot(f32[2048,2,3264]{2,1,0} %p0, f32[2,3264,2176]{2,1,0} %p1), lhs_contracting_dims={1,2}, rhs_contracting_dims={0,1}, sharding={devices=[1,2]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 5;\n+  options.total_bytes_windowed_einsum_threshold = 1 << 30;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/5,\n-                           {GatherScatterPartitioningMethod::kExplicitBatch},\n-                           {GatherScatterPartitioningMethod::kExplicitBatch},\n-                           /*total_bytes_windowed_einsum_threshold=*/1 << 30));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n   // Total bytes threshold overrides threshold_for_windowed_einsum_mib,\n   // there shouldn't be any while loop after partitioner.\n@@ -5564,15 +5517,11 @@ ENTRY entry {\n   ROOT %dot.224 = f32[2048,2176]{1,0} dot(f32[2048,2,3264]{2,1,0} %p0, f32[2,3264,2176]{2,1,0} %p1), lhs_contracting_dims={1,2}, rhs_contracting_dims={0,1}, sharding={devices=[1,2]0,1}, frontend_attributes={_xla_collective_matmul=\"none\"}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   ASSERT_FALSE(absl::c_any_of(module->entry_computation()->instructions(),\n                               [](const HloInstruction* inst) {\n                                 return inst->opcode() == HloOpcode::kWhile;\n@@ -5975,13 +5924,11 @@ ENTRY entry {\n     sharding={devices=[1,4,1]<=[4]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n \n   const auto lhs = AllOf(\n@@ -6051,14 +5998,11 @@ ENTRY entry {\n     sharding={devices=[1,4,1]<=[4]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n   const auto lhs = AllOf(\n       op::Copy(op::DynamicSlice(op::Parameter(0), op::Constant(),\n@@ -6220,13 +6164,11 @@ ENTRY entry {\n     sharding={devices=[2,1,4,1]<=[8]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n   VLOG(1) << module->ToString();\n \n   const auto lhs =\n@@ -6296,14 +6238,11 @@ ENTRY entry {\n     sharding={devices=[2,1,4,1]<=[8]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n   VLOG(1) << module->ToString();\n \n   const auto lhs =\n@@ -6511,13 +6450,11 @@ ENTRY entry {\n   ROOT %t = tuple(%dot, %dot2)\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n   const auto root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(\n@@ -6583,14 +6520,11 @@ ENTRY entry {\n   ROOT %t = tuple(%dot, %dot2)\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n   const auto root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(\n@@ -6724,13 +6658,11 @@ ENTRY entry {\n     sharding={devices=[1,2,1]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -6796,14 +6728,11 @@ ENTRY entry {\n     sharding={devices=[1,4,1]<=[4]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -6947,13 +6876,11 @@ ENTRY entry {\n     sharding={devices=[1,2,1]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7024,14 +6951,11 @@ ENTRY entry {\n     sharding={devices=[1,4,1]<=[4]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7285,13 +7209,11 @@ ENTRY entry {\n     to_apply=sum, sharding={devices=[1,2]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7389,14 +7311,11 @@ ENTRY entry {\n     to_apply=sum, sharding={devices=[1,4]<=[4]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7534,13 +7453,11 @@ ENTRY entry {\n     to_apply=sum, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7634,14 +7551,11 @@ ENTRY entry {\n     to_apply=sum, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7753,13 +7667,11 @@ ENTRY entry {\n     sharding={devices=[1,2,1]0,1}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.unroll_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/2,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/2, options));\n   VLOG(1) << module->ToString();\n \n   const auto root = module->entry_computation()->root_instruction();\n@@ -7834,14 +7746,11 @@ ENTRY entry {\n     sharding={devices=[1,4,1]<=[4]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false,\n-                           /*unroll_windowed_einsum =*/false,\n-                           /*bidirectional_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/4, options));\n   VLOG(1) << module->ToString();\n \n   auto input_subtuple =\n@@ -12210,19 +12119,14 @@ ENTRY %module {\n     collapsed_slice_dims={0,1}, start_index_map={1,0}, index_vector_dim=0,\n     slice_sizes={1,1,2,2}, sharding={devices=[4,2,1,1]<=[8]}\n })\";\n+  SpmdPartitionerOptions options;\n   for (const GatherScatterPartitioningMethod& method :\n        {GatherScatterPartitioningMethod::kIndexParallel,\n         GatherScatterPartitioningMethod::kIndexPassthrough}) {\n+    options.preferred_gather_partition_methods = {method};\n     TF_ASSERT_OK_AND_ASSIGN(\n         auto module,\n-        PartitionComputation(hlo_string, /*num_devices=*/8,\n-                             /*use_all_gather=*/false,\n-                             /*conv_halo_exchange_always_on_lhs=*/true,\n-                             /*choose_faster_windowed_einsum=*/false,\n-                             /*unroll_windowed_einsum=*/false,\n-                             /*bidirectional_windowed_einsum=*/false,\n-                             /*threshold_for_windowed_einsum_mib=*/-1, {method},\n-                             {method}));\n+        PartitionComputation(hlo_string, /*num_devices=*/8, options));\n     VLOG(1) << module->ToString();\n     auto operand = AllOf(op::Shape(\"s32[2,4,2,2]\"), op::Parameter());\n     auto indices = AllOf(op::Shape(\"s32[2,2,2]\"), op::Subtract());\n@@ -12500,12 +12404,12 @@ ENTRY entry {\n     collapsed_slice_dims={0}, start_index_map={0}, index_vector_dim=2,\n     slice_sizes={1,16}, sharding={devices=[4,1,1,8]<=[32] last_tile_dim_replicate}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.preferred_gather_partition_methods = {\n+      GatherScatterPartitioningMethod::kTrivialSlicedOperand};\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(\n-          hlo_string, /*num_devices=*/32, /*use_all_gather=*/false, true, false,\n-          false, false, -1,\n-          {GatherScatterPartitioningMethod::kTrivialSlicedOperand}));\n+      PartitionComputation(hlo_string, /*num_devices=*/32, options));\n   VLOG(1) << module->ToString();\n   HloInstruction* root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(root, op::AllReduce(op::Select(_, _, op::Gather(_, _))));\n@@ -12532,11 +12436,12 @@ ENTRY entry {\n     collapsed_slice_dims={0}, start_index_map={0}, index_vector_dim=2,\n     slice_sizes={1,16}, sharding={devices=[4,1,1,8]<=[32] last_tile_dim_replicate}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.preferred_gather_partition_methods = {\n+      GatherScatterPartitioningMethod::kIndexParallel};\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(\n-          hlo_string, /*num_devices=*/32, /*use_all_gather=*/false, true, false,\n-          false, false, -1, {GatherScatterPartitioningMethod::kIndexParallel}));\n+      PartitionComputation(hlo_string, /*num_devices=*/32, options));\n   VLOG(1) << module->ToString();\n   HloInstruction* root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(\n@@ -13204,19 +13109,14 @@ ENTRY %module {\n     index_vector_dim=0, sharding={replicated}\n })\";\n \n+  SpmdPartitionerOptions options;\n   for (const GatherScatterPartitioningMethod& method :\n        {GatherScatterPartitioningMethod::kIndexParallel,\n         GatherScatterPartitioningMethod::kIndexPassthrough}) {\n+    options.preferred_scatter_partition_methods = {method};\n     TF_ASSERT_OK_AND_ASSIGN(\n         auto module,\n-        PartitionComputation(hlo_string, /*num_devices=*/8,\n-                             /*use_all_gather=*/false,\n-                             /*conv_halo_exchange_always_on_lhs=*/true,\n-                             /*choose_faster_windowed_einsum=*/false,\n-                             /*unroll_windowed_einsum=*/false,\n-                             /*bidirectional_windowed_einsum=*/false,\n-                             /*threshold_for_windowed_einsum_mib=*/-1, {method},\n-                             {method}));\n+        PartitionComputation(hlo_string, /*num_devices=*/8, options));\n     VLOG(1) << module->ToString();\n     auto operand = AllOf(op::Shape(\"s32[2,4,2,2]\"), op::Select());\n     auto indices = AllOf(op::Shape(\"s32[2,2,2]\"), op::Subtract());\n@@ -13491,12 +13391,12 @@ ENTRY entry {\n       scatter_dims_to_operand_dims={0},\n       index_vector_dim=2, sharding={devices=[8,1,4]<=[4,8]T(1,0) last_tile_dim_replicate}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.preferred_scatter_partition_methods = {\n+      GatherScatterPartitioningMethod::kTrivialSlicedOperand};\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(\n-          hlo_string, /*num_devices=*/32, /*use_all_gather=*/false, true, false,\n-          false, false, -1,\n-          {GatherScatterPartitioningMethod::kTrivialSlicedOperand}));\n+      PartitionComputation(hlo_string, /*num_devices=*/32, options));\n   VLOG(1) << module->ToString();\n   HloInstruction* root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(root, op::AllReduce(op::Scatter(op::Select(_, _, _),\n@@ -13530,11 +13430,12 @@ ENTRY entry {\n       scatter_dims_to_operand_dims={0},\n       index_vector_dim=2, sharding={devices=[8,1,4]<=[4,8]T(1,0) last_tile_dim_replicate}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.preferred_scatter_partition_methods = {\n+      GatherScatterPartitioningMethod::kIndexParallel};\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(\n-          hlo_string, /*num_devices=*/32, /*use_all_gather=*/false, true, false,\n-          false, false, -1, {GatherScatterPartitioningMethod::kIndexParallel}));\n+      PartitionComputation(hlo_string, /*num_devices=*/32, options));\n   VLOG(1) << module->ToString();\n   auto all_to_all = FindInstruction(module.get(), HloOpcode::kAllToAll);\n   EXPECT_NE(all_to_all, nullptr);\n@@ -13775,12 +13676,8 @@ ENTRY %module {\n     reshape(bf16[128,1024,4,176,256,1,1]{6,5,4,3,2,1,0} %convolution.3),\n     sharding={replicated}\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          PartitionComputation(hlo_string, /*num_devices=*/8));\n   const HloInstruction* while_inst = FindInstruction(module.get(), \"while\");\n   EXPECT_NE(while_inst, nullptr);\n   const HloComputation* cond_comp = while_inst->while_condition();\n@@ -13811,12 +13708,11 @@ ENTRY %module {\n     reshape(bf16[128,1024,4,176,256,1,1]{6,5,4,3,2,1,0} %convolution.3),\n     sharding={replicated}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.choose_faster_windowed_einsum_over_mem = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n   const HloInstruction* while_inst = FindInstruction(module.get(), \"while\");\n   EXPECT_NE(while_inst, nullptr);\n   const HloComputation* cond_comp = while_inst->while_condition();\n@@ -13854,12 +13750,11 @@ ENTRY entry {\n   ROOT %output = bf16[16,36,256,16,4,288,1]{6,5,4,3,2,1,0}\n    copy(%convolution.10), sharding={replicated}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.choose_faster_windowed_einsum_over_mem = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/32,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/32, options));\n   const HloInstruction* while_inst = FindInstruction(module.get(), \"while\");\n   EXPECT_NE(while_inst, nullptr);\n   const HloComputation* cond_comp = while_inst->while_condition();\n@@ -13897,12 +13792,8 @@ ENTRY entry {\n   ROOT %output = bf16[16,36,256,16,4,288,1]{6,5,4,3,2,1,0}\n    copy(%convolution.10), sharding={replicated}\n })\";\n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/32,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          PartitionComputation(hlo_string, /*num_devices=*/32));\n   const HloInstruction* while_inst = FindInstruction(module.get(), \"while\");\n   EXPECT_NE(while_inst, nullptr);\n   const HloComputation* cond_comp = while_inst->while_condition();\n@@ -13932,12 +13823,11 @@ ENTRY entry {\n     sharding={devices=[2,2,2]<=[8]}\n   ROOT %output = f32[8,2,2] copy(%dot), sharding={replicated}\n })\";\n+  SpmdPartitionerOptions options;\n+  options.choose_faster_windowed_einsum_over_mem = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs =*/true,\n-                           /*choose_faster_windowed_einsum =*/true));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n \n   const HloInstruction* dot_op = FindInstruction(module.get(), HloOpcode::kDot);\n   auto op1 = op::Shape(\"f32[4,2,4,4]\");\n@@ -13960,12 +13850,8 @@ ENTRY entry {\n     sharding={devices=[1,2,1,2]<=[4]}\n })\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/4,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/true));\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          PartitionComputation(hlo_string, /*num_devices=*/4));\n   VLOG(1) << module->ToString();\n   const auto root = module->entry_computation()->root_instruction();\n   auto dot = AllOf(op::Shape(\"f32[16,32,24,1024]\"),\n@@ -15849,15 +15735,12 @@ ENTRY %entry {\n   ROOT %dot.339 = bf16[64,2048,65536]{2,1,0} dot(bf16[64,2048,20480]{2,1,0} %copy.11, bf16[20480,65536]{1,0} %reshape.44), lhs_contracting_dims={2}, rhs_contracting_dims={0}, sharding={devices=[8,1,4]<=[32]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.choose_faster_windowed_einsum_over_mem = true;\n+  options.bidirectional_windowed_einsum = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/32,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/true,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/true,\n-                           /*threshold_for_windowed_einsum_mib=*/-1));\n+      PartitionComputation(hlo_string, /*num_devices=*/32, options));\n   XLA_VLOG_LINES(1, module->ToString());\n \n   // Check while op.\n@@ -15884,15 +15767,12 @@ ENTRY entry {\n   ROOT %dot = f32[8,2048,2176]{2,1,0} dot(f32[8,2048,3264]{2,1,0} %p0, f32[3264,2176]{1,0} %p1), lhs_contracting_dims={2}, rhs_contracting_dims={0}, sharding={devices=[2,1,4]<=[8]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.partial_windowed_einsum = true;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n \n   // While op.\n   const auto arg0 = AllOf(op::Parameter(0), op::Shape(\"f32[4,512,3264]\"));\n@@ -15961,15 +15841,12 @@ ENTRY entry {\n   ROOT %dot = f32[8,2048,2176]{2,1,0} dot(f32[8,2048,3264]{2,1,0} %p0, f32[3264,2176]{1,0} %p1), lhs_contracting_dims={2}, rhs_contracting_dims={0}, sharding={devices=[2,1,4]<=[8]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.partial_windowed_einsum = true;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/true,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n \n   // While op.\n   const auto arg0 = AllOf(op::Parameter(0), op::Shape(\"f32[4,512,3264]\"));\n@@ -16038,15 +15915,11 @@ ENTRY entry {\n   ROOT %dot = f32[8,2048,2176]{2,1,0} dot(f32[8,2048,3264]{2,1,0} %p0, f32[3264,2176]{1,0} %p1), lhs_contracting_dims={2}, rhs_contracting_dims={0}, sharding={devices=[2,1,4]0,2,4,6,1,3,5,7}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n \n   const auto root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(root, AllOf(op::Dot(), op::Shape(\"f32[4,2048,544]\")));\n@@ -16064,15 +15937,11 @@ ENTRY entry {\n   ROOT %dot = f32[8,2048,2176]{2,1,0} dot(f32[8,2048,3264]{2,1,0} %p0, f32[3264,2176]{1,0} %p1), lhs_contracting_dims={2}, rhs_contracting_dims={0}, sharding={devices=[2,1,4]<=[8]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n \n   const auto root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(root, AllOf(op::Dot(), op::Shape(\"f32[4,2048,544]\")));\n@@ -16090,15 +15959,11 @@ ENTRY entry {\n   ROOT %dot = f32[8,2048,2176]{2,1,0} dot(f32[8,2048,3264]{2,1,0} %p0, f32[3264,2176]{1,0} %p1), lhs_contracting_dims={2}, rhs_contracting_dims={0}, sharding={devices=[1,1,8]<=[8]}\n })\";\n \n+  SpmdPartitionerOptions options;\n+  options.threshold_for_windowed_einsum_mib = 0;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/8,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/false,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/false,\n-                           /*threshold_for_windowed_einsum_mib=*/0));\n+      PartitionComputation(hlo_string, /*num_devices=*/8, options));\n \n   const auto root = module->entry_computation()->root_instruction();\n   EXPECT_THAT(root, AllOf(op::Dot(), op::Shape(\"f32[8,2048,272]\")));\n@@ -16119,14 +15984,7 @@ ENTRY %extracted_computation (param: f32[13,128,312,16,312]) -> f32[13,39936,499\n })\";\n \n   TF_ASSERT_OK_AND_ASSIGN(\n-      auto module,\n-      PartitionComputation(hlo_string, /*num_devices=*/128,\n-                           /*use_all_gather=*/false,\n-                           /*conv_halo_exchange_always_on_lhs=*/true,\n-                           /*choose_faster_windowed_einsum=*/true,\n-                           /*unroll_windowed_einsum=*/false,\n-                           /*bidirectional_windowed_einsum=*/true,\n-                           /*threshold_for_windowed_einsum_mib=*/-1));\n+      auto module, PartitionComputation(hlo_string, /*num_devices=*/128));\n   XLA_VLOG_LINES(1, module->ToString());\n   // Check an all-to-all is emitted for resharding.\n   auto all_to_all = FindInstruction(module.get(), HloOpcode::kAllToAll);\n@@ -16151,13 +16009,8 @@ ENTRY entry {\n   ROOT sort.209 = (f32[4,16384,4096]{2,1,0}, s32[4,16384,4096]{2,1,0}) sort(param.0, param.1), dimensions={2}, to_apply=top_k_gt_f32_comparator_64.35303, sharding={{devices=[4,4,4]<=[64]}, {devices=[4,4,4]<=[64]}}\n })\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto module,\n-      PartitionComputation(\n-          hlo_string, /*num_devices=*/64,\n-          /*use_all_gather=*/false,\n-          /*conv_halo_exchange_always_on_lhs=*/true,\n-          /*xla_tpu_enable_log_recorder_partitioned_logging=*/true));\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          PartitionComputation(hlo_string, /*num_devices=*/64));\n   XLA_VLOG_LINES(1, module->ToString());\n \n   EXPECT_THAT(\n@@ -16195,13 +16048,9 @@ ENTRY offloading (param0: f32[1,256,128]) -> f32[1,256,128] {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto module,\n-      PartitionComputation(\n-          hlo_string, /*num_devices=*/4,\n-          /*use_all_gather=*/false,\n-          /*conv_halo_exchange_always_on_lhs=*/true,\n-          /*xla_tpu_enable_log_recorder_partitioned_logging=*/true));\n+  SpmdPartitionerOptions options;\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          PartitionComputation(hlo_string, /*num_devices=*/4));\n   XLA_VLOG_LINES(1, module->ToString());\n \n   // Check that the partitioner does not insert any sharding code between\n@@ -16627,6 +16476,7 @@ ENTRY entry {\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           PartitionComputation(hlo_string, /*num_devices=*/16,\n+                                               SpmdPartitionerOptions(),\n                                                /*use_all_gather=*/true));\n   const HloComputation* recovery_computation =\n       module->original_value_recovery_table()\n@@ -16689,6 +16539,7 @@ ENTRY entry {\n \n   TF_ASSERT_OK_AND_ASSIGN(auto module,\n                           PartitionComputation(hlo_string, /*num_devices=*/16,\n+                                               SpmdPartitionerOptions(),\n                                                /*use_all_gather=*/true));\n   const HloComputation* recovery_computation =\n       module->original_value_recovery_table()"
        }
    ],
    "stats": {
        "total": 457,
        "additions": 154,
        "deletions": 303
    }
}