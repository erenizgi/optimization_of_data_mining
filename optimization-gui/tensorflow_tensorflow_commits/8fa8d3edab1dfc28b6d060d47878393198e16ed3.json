{
    "author": "apivovarov",
    "message": "Add patch for improved floating-point handling in `select_warpsort`.\n\nThis patch, corresponding to Raft PR #2807, updates `select_warpsort.cuh` to use `cub::Traits` for bitwise representation of floating-point and signed integer types, ensuring more stable comparisons, especially for infinities and NaNs. It also includes necessary adjustments to tests.\n\nPiperOrigin-RevId: 810634702",
    "sha": "8fa8d3edab1dfc28b6d060d47878393198e16ed3",
    "files": [
        {
            "sha": "0287ed51809e5c4acd6702f1d5447a1ac7e5193a",
            "filename": "third_party/xla/third_party/raft/pr-2807.patch",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8fa8d3edab1dfc28b6d060d47878393198e16ed3/third_party%2Fxla%2Fthird_party%2Fraft%2Fpr-2807.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8fa8d3edab1dfc28b6d060d47878393198e16ed3/third_party%2Fxla%2Fthird_party%2Fraft%2Fpr-2807.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fraft%2Fpr-2807.patch?ref=8fa8d3edab1dfc28b6d060d47878393198e16ed3",
            "patch": "@@ -0,0 +1,106 @@\n+diff --git a/cpp/include/raft/matrix/detail/select_warpsort.cuh b/cpp/include/raft/matrix/detail/select_warpsort.cuh\n+--- a/cpp/include/raft/matrix/detail/select_warpsort.cuh\n++++ b/cpp/include/raft/matrix/detail/select_warpsort.cuh\n+@@ -31,6 +31,8 @@\n+ #include <rmm/device_uvector.hpp>\n+ #include <rmm/resource_ref.hpp>\n+ \n++#include <cub/util_type.cuh>  // cub::Traits\n++\n+ #include <algorithm>\n+ #include <functional>\n+ #include <type_traits>\n+@@ -765,7 +767,13 @@ template <template <int, bool, typename,\n+                                                 IdxT* out_idx)\n+ {\n+   extern __shared__ __align__(256) uint8_t smem_buf_bytes[];\n+-  using bq_t         = block_sort<WarpSortClass, Capacity, Ascending, T, IdxT>;\n++  // Map the value type T to an appropriate uint type using cub traits.\n++  // This gives us two advantages:\n++  //   1. More stable behavior for IEEE 754 floating-point values w.r.t. infinity and NaN\n++  //      (the behavior matches the select_radix implementation)\n++  //   2. Fewer expensive template instantiations\n++  using bits_t       = typename cub::Traits<T>::UnsignedBits;\n++  using bq_t         = block_sort<WarpSortClass, Capacity, Ascending, bits_t, IdxT>;\n+   uint8_t* warp_smem = bq_t::queue_t::mem_required(blockDim.x) > 0 ? smem_buf_bytes : nullptr;\n+   bq_t queue(k, warp_smem);\n+   const size_t batch_id = blockIdx.y;\n+@@ -779,13 +787,17 @@ template <template <int, bool, typename,\n+   const IdxT stride         = gridDim.x * blockDim.x;\n+   const IdxT per_thread_lim = l_len + laneId();\n+   for (IdxT i = threadIdx.x + blockIdx.x * blockDim.x; i < per_thread_lim; i += stride) {\n+-    queue.add(i < l_len ? __ldcs(in + i) : WarpSortClass<Capacity, Ascending, T, IdxT>::kDummy,\n++    // Twiddle the input value to ensure proper comparison of floating-point and signed int values\n++    queue.add(i < l_len ? cub::Traits<T>::TwiddleIn(__ldcs(reinterpret_cast<const bits_t*>(in) + i))\n++                        : WarpSortClass<Capacity, Ascending, bits_t, IdxT>::kDummy,\n+               (i < l_len && in_idx != nullptr) ? __ldcs(in_idx + i) : i);\n+   }\n+ \n+   queue.done(smem_buf_bytes);\n+   const int block_id = blockIdx.x + gridDim.x * blockIdx.y;\n+-  queue.store(out + block_id * k, out_idx + block_id * k);\n++  queue.store(reinterpret_cast<bits_t*>(out) + block_id * k,\n++              out_idx + block_id * k,\n++              cub::Traits<T>::TwiddleOut);  // Restore the FP / signed int representation.\n+ }\n+ \n+ struct launch_params {\n+diff --git a/cpp/tests/matrix/select_k.cuh b/cpp/tests/matrix/select_k.cuh\n+--- a/cpp/tests/matrix/select_k.cuh\n++++ b/cpp/tests/matrix/select_k.cuh\n+@@ -234,12 +234,17 @@ struct SelectK  // NOLINT\n+ \n+     // If the dists (keys) are the same, different corresponding ids may end up in the selection\n+     // due to non-deterministic nature of some implementations.\n+-    auto compare_ids = [this](const IdxT& i, const IdxT& j) {\n++    auto compare_ids = [this](const IdxT& i, const IdxT& j, const size_t pos) {\n+       if (i == j) return true;\n+       auto& in_ids   = ref.get_in_ids();\n+       auto& in_dists = ref.get_in_dists();\n+-      auto ix_i = static_cast<int64_t>(std::find(in_ids.begin(), in_ids.end(), i) - in_ids.begin());\n+-      auto ix_j = static_cast<int64_t>(std::find(in_ids.begin(), in_ids.end(), j) - in_ids.begin());\n++      auto batch     = pos / spec.k;\n++      auto start_pos = in_ids.begin() + batch * spec.len;\n++      // Get the indices of found neighbor ids in the source (input ids)\n++      auto ix_i =\n++        static_cast<int64_t>(std::find(start_pos, start_pos + spec.len, i) - in_ids.begin());\n++      auto ix_j =\n++        static_cast<int64_t>(std::find(start_pos, start_pos + spec.len, j) - in_ids.begin());\n+       auto forgive_i = forgive_algo(ref.algo, i);\n+       auto forgive_j = forgive_algo(res.algo, j);\n+       // Some algorithms return invalid indices in special cases.\n+diff --git a/cpp/tests/sparse/select_k_csr.cu b/cpp/tests/sparse/select_k_csr.cu\n+--- a/cpp/tests/sparse/select_k_csr.cu\n++++ b/cpp/tests/sparse/select_k_csr.cu\n+@@ -56,7 +56,7 @@ struct CompareApproxWithInf {\n+   CompareApproxWithInf(T eps_) : eps(eps_) {}\n+   bool operator()(const T& a, const T& b) const\n+   {\n+-    if (std::isinf(a) && std::isinf(b)) return true;\n++    if ((std::isinf(a) || std::isnan(a)) && (std::isinf(b) || std::isnan(b))) return true;\n+     T diff  = std::abs(a - b);\n+     T m     = std::max(std::abs(a), std::abs(b));\n+     T ratio = diff > eps ? diff / m : diff;\n+diff --git a/cpp/tests/test_utils.cuh b/cpp/tests/test_utils.cuh\n+--- a/cpp/tests/test_utils.cuh\n++++ b/cpp/tests/test_utils.cuh\n+@@ -188,9 +188,16 @@ testing::AssertionResult hostVecMatch(co\n+            << \"vector sizez mismatch: \"\n+            << \"actual=\" << n << \" != expected=\" << expected_h.size() << \"; \";\n+   for (size_t i = 0; i < n; ++i) {\n+-    auto exp = expected_h[i];\n+-    auto act = actual_h[i];\n+-    if (!eq_compare(exp, act)) {\n++    auto exp       = expected_h[i];\n++    auto act       = actual_h[i];\n++    bool are_equal = [&]() {\n++      if constexpr (std::is_invocable_v<L, decltype(exp), decltype(act), size_t>) {\n++        return eq_compare(exp, act, i);\n++      } else {\n++        return eq_compare(exp, act);\n++      }\n++    }();\n++    if (!are_equal) {\n+       return testing::AssertionFailure()\n+              << \"actual=\" << act << \" != expected=\" << exp << \" @\" << i << \"; \";\n+     }"
        },
        {
            "sha": "201f7a9cdd18c4e1e0d070237f0ad8d0e3adb5d5",
            "filename": "third_party/xla/third_party/raft/workspace.bzl",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8fa8d3edab1dfc28b6d060d47878393198e16ed3/third_party%2Fxla%2Fthird_party%2Fraft%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8fa8d3edab1dfc28b6d060d47878393198e16ed3/third_party%2Fxla%2Fthird_party%2Fraft%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fraft%2Fworkspace.bzl?ref=8fa8d3edab1dfc28b6d060d47878393198e16ed3",
            "patch": "@@ -18,6 +18,7 @@ def repo():\n             \"//third_party/raft:cudart_utils.hpp.patch\",\n             \"//third_party/raft:vectorized.cuh.patch\",\n             \"//third_party/raft:clang_cuda_intrinsics.h.patch\",\n+            \"//third_party/raft:pr-2807.patch\",\n             \"//third_party/raft:logger_macros.hpp.patch\",\n             \"//third_party/raft:select_k_runner.hpp.patch\",\n             \"//third_party/raft:select_k_runner.cu.cc.patch\","
        }
    ],
    "stats": {
        "total": 107,
        "additions": 107,
        "deletions": 0
    }
}