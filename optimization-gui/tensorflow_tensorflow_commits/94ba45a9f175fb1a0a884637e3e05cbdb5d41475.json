{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832601544",
    "sha": "94ba45a9f175fb1a0a884637e3e05cbdb5d41475",
    "files": [
        {
            "sha": "91eab6f8438dc2ecadc10093bd5fdfac045e2359",
            "filename": "tensorflow/dtensor/mlir/spmd_expander_common.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/94ba45a9f175fb1a0a884637e3e05cbdb5d41475/tensorflow%2Fdtensor%2Fmlir%2Fspmd_expander_common.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/94ba45a9f175fb1a0a884637e3e05cbdb5d41475/tensorflow%2Fdtensor%2Fmlir%2Fspmd_expander_common.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fdtensor%2Fmlir%2Fspmd_expander_common.cc?ref=94ba45a9f175fb1a0a884637e3e05cbdb5d41475",
            "patch": "@@ -227,7 +227,7 @@ StatusOr<Layout> GetBroadcastLayoutForElementWise(\n   const int rank_offset_b = std::max(0, rank_a - rank_b);\n   absl::flat_hash_map<std::string, int> mesh_dim_map_a;\n   absl::flat_hash_map<std::string, int> mesh_dim_map_b;\n-  std::vector<string> output_layout_specs;\n+  std::vector<std::string> output_layout_specs;\n \n   auto unsharded_specs = [](const int new_size) -> std::vector<std::string> {\n     std::vector<std::string> spec_strs(new_size, Layout::kUnshardedDim);\n@@ -531,7 +531,7 @@ StatusOr<mlir::Value> GetMeshCoordinatesFromCluster(\n   // has the given mesh in it. If it exists, simply return that op's value.\n   TF_ASSIGN_OR_RETURN(const auto mesh, ExtractDeviceMeshFromOp(cluster));\n   if (!mesh) return errors::InvalidArgument(\"missing mesh on cluster\");\n-  string serialized_mesh = mesh->ToString();\n+  std::string serialized_mesh = mesh->ToString();\n   mlir::Value ret_val;\n   auto result = cluster.walk([&](mlir::TF::FloorModOp op) -> mlir::WalkResult {\n     if (op->hasAttrOfType<mlir::StringAttr>(kMeshCoordinatesAttr) &&\n@@ -547,12 +547,12 @@ StatusOr<mlir::Value> GetMeshCoordinatesFromCluster(\n \n   // We didn't find a FloorModOp for the given mesh, so we must produce the\n   // FloorModOp and add the attr so we can find it on next call.\n-  std::vector<int32> mesh_shape(mesh->rank());\n+  std::vector<int32_t> mesh_shape(mesh->rank());\n   for (int i = 0; i < mesh->rank(); ++i) mesh_shape[i] = mesh->dim(i).size;\n \n   // This product represents the [b*c*d, c*d, d, 1] from the function\n   // documentation.\n-  std::vector<int32> running_product(mesh->rank());\n+  std::vector<int32_t> running_product(mesh->rank());\n   running_product[mesh->rank() - 1] = 1;\n   for (int i = mesh->rank() - 1; i > 0; --i)\n     running_product[i - 1] = running_product[i] * mesh_shape[i];\n@@ -685,13 +685,13 @@ namespace {\n // used. In order to ensure that all branch functions of TF control flow ops are\n // unique, we keep track of atomic counter for each control flow functions.\n // See b/174253694 for more details.\n-std::atomic<int32> dtensor_controlflow_function_counter{0};\n+std::atomic<int32_t> dtensor_controlflow_function_counter{0};\n \n }  // namespace\n \n mlir::StringAttr GetUniqueControlflowFnName(const std::string& prefix,\n                                             mlir::OpBuilder& builder) {\n-  int32 unique_id = dtensor_controlflow_function_counter++;\n+  int32_t unique_id = dtensor_controlflow_function_counter++;\n   return builder.getStringAttr(\n       absl::StrCat(prefix, \"_dtensor_function_\", unique_id));\n }"
        },
        {
            "sha": "60271a08b8922d8af5f1cce41f8fad989cb21c46",
            "filename": "tensorflow/dtensor/mlir/tpu_integration.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/94ba45a9f175fb1a0a884637e3e05cbdb5d41475/tensorflow%2Fdtensor%2Fmlir%2Ftpu_integration.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/94ba45a9f175fb1a0a884637e3e05cbdb5d41475/tensorflow%2Fdtensor%2Fmlir%2Ftpu_integration.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fdtensor%2Fmlir%2Ftpu_integration.cc?ref=94ba45a9f175fb1a0a884637e3e05cbdb5d41475",
            "patch": "@@ -81,7 +81,7 @@ void IdentifyTPUFunctions(\n   if (!main_func) return;\n \n   for (auto call : main_func.getOps<mlir::TF::StatefulPartitionedCallOp>()) {\n-    auto mesh_or_status = Mesh::FromString(string(call.getConfig()));\n+    auto mesh_or_status = Mesh::FromString(std::string(call.getConfig()));\n     // Function calls created by end users instead of being converted from\n     // tf_device.cluster do not have a serialized mesh as a config attribute. We\n     // ignore the error returned from parsing in this case."
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}