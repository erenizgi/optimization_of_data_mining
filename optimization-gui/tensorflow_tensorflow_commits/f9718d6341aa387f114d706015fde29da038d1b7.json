{
    "author": "mwhittaker",
    "message": "Simplify coordination service configs.\n\nPreviously, both the `CoordinationService` and `CoordinationServiceAgent` used\nthe `tensorflow::CoordinationServiceConfig` proto. Now, both classes have their\nown `Config` structs with the options they need.\n\nPiperOrigin-RevId: 844902942",
    "sha": "f9718d6341aa387f114d706015fde29da038d1b7",
    "files": [
        {
            "sha": "09bbb1060763cc15cf23612c9e1e0f525c25bf43",
            "filename": "third_party/xla/xla/pjrt/distributed/client.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 16,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -78,7 +78,7 @@ class DistributedRuntimeCoordinationServiceClient\n \n  private:\n   std::unique_ptr<CoordinationServiceAgent> coord_agent_;\n-  tensorflow::CoordinationServiceConfig config_;\n+  CoordinationServiceAgent::Config config_;\n   absl::Duration min_connect_barrier_timeout_;\n   int task_id_;\n };\n@@ -87,20 +87,14 @@ DistributedRuntimeCoordinationServiceClient::\n     DistributedRuntimeCoordinationServiceClient(\n         std::shared_ptr<::grpc::Channel> channel, const Options& options) {\n   // Convert options to coordination config.\n-  tensorflow::CoordinationServiceConfig config;\n-  config.set_service_type(\"standalone\");\n-  config.set_service_leader(\"/job:jax_worker/task:0\");\n-  config.set_cluster_register_timeout_in_ms(\n-      absl::ToInt64Milliseconds(options.init_timeout));\n-  config.set_heartbeat_timeout_in_ms(\n-      absl::ToInt64Milliseconds(options.heartbeat_timeout));\n-  config.set_cluster_register_with_barrier(true);\n-  config.set_shutdown_barrier_timeout_in_ms(\n-      absl::ToInt64Milliseconds(options.shutdown_timeout));\n-  config.set_agent_destruction_without_shutdown(\n-      !options.shutdown_on_destruction);\n-  config.set_poll_for_error_from_service_at_startup(\n-      options.poll_for_error_from_service_at_startup);\n+  CoordinationServiceAgent::Config config;\n+  config.service_leader = \"/job:jax_worker/task:0\";\n+  config.cluster_register_timeout = options.init_timeout;\n+  config.heartbeat_timeout = options.heartbeat_timeout;\n+  config.shutdown_barrier_timeout = options.shutdown_timeout;\n+  config.agent_destruction_without_shutdown = !options.shutdown_on_destruction;\n+  config.poll_for_error_from_service_at_startup =\n+      options.poll_for_error_from_service_at_startup;\n \n   std::unique_ptr<CoordinationClient> leader_client;\n   leader_client.reset(NewGrpcCoordinationClient(channel));\n@@ -132,7 +126,7 @@ absl::Status DistributedRuntimeCoordinationServiceClient::Connect() {\n            \"scheduled, or 3) scheduling delays. Consider setting a longer \"\n            \"initialization timeout if such delays are expected, the timeout is \"\n            \"currently set to: \"\n-        << absl::Milliseconds(config_.cluster_register_timeout_in_ms())\n+        << config_.cluster_register_timeout\n         << \".\\n\\nOriginal runtime error: \" << s;\n   } else {\n     LOG(ERROR) << \"Failed to connect to distributed JAX controller: \" << s;"
        },
        {
            "sha": "a24a4726930acaa3e660937cc9fbcf1e367f5eab",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -53,12 +53,9 @@ cc_library(\n     srcs = [\"coordination_service.cc\"],\n     hdrs = [\"coordination_service.h\"],\n     deps = [\n-        \":coordination_client\",\n         \":coordination_service_error_util\",\n         \":key_value_store\",\n         \"//xla/service:global_device_id\",\n-        \"//xla/tsl/distributed_runtime:call_options\",\n-        \"//xla/tsl/lib/gtl:int_type\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:status\",\n@@ -142,18 +139,15 @@ cc_library(\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n-        \"@com_google_absl//absl/functional:any_invocable\",\n         \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n-        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/time\",\n-        \"@com_google_absl//absl/types:span\",\n         \"@local_tsl//tsl/platform:random\",\n     ],\n )"
        },
        {
            "sha": "783efd39fa4010beeda34bd135ca9393e0f1bb75",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/client_server_test.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 24,
            "changes": 45,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -54,7 +54,6 @@ limitations under the License.\n \n namespace xla {\n namespace {\n-using ::tensorflow::CoordinationServiceConfig;\n using ::testing::AnyOf;\n using ::testing::ElementsAre;\n using ::testing::HasSubstr;\n@@ -79,42 +78,40 @@ MATCHER_P2(IsKvEntry, key, value, \"\") {\n \n class ClientServerTest : public ::testing::Test {\n  public:\n-  CoordinationServiceConfig GetConfig(\n+  CoordinationServiceAgent::Config GetConfig(\n       absl::Duration init_and_shutdown_timeout,\n       bool shutdown_on_destruction = true,\n       bool cluster_register_with_barrier = true,\n       bool cluster_shutdown_with_barrier = true) {\n     // Set config.\n-    tensorflow::CoordinationServiceConfig config;\n-    config.set_service_type(\"standalone\");\n-    config.set_service_leader(\"/job:agent/task:0\");\n-    config.set_cluster_register_timeout_in_ms(\n-        absl::ToInt64Milliseconds(init_and_shutdown_timeout));\n-    config.set_heartbeat_timeout_in_ms(\n-        absl::ToInt64Milliseconds(kHeartbeatTimeout));\n+    CoordinationServiceAgent::Config config;\n+    config.service_leader = \"/job:agent/task:0\";\n+    config.cluster_register_timeout = init_and_shutdown_timeout;\n+    config.heartbeat_timeout = kHeartbeatTimeout;\n     if (cluster_shutdown_with_barrier) {\n-      config.set_shutdown_barrier_timeout_in_ms(\n-          absl::ToInt64Milliseconds(init_and_shutdown_timeout));\n+      config.shutdown_barrier_timeout = init_and_shutdown_timeout;\n     }\n-    config.set_agent_destruction_without_shutdown(!shutdown_on_destruction);\n+    config.agent_destruction_without_shutdown = !shutdown_on_destruction;\n     // TODO(b/369222279): Add more test cases that exercise TF behaviour (no\n     // barrier).\n-    config.set_cluster_register_with_barrier(cluster_register_with_barrier);\n-    config.set_poll_for_error_from_service_at_startup(true);\n+    config.poll_for_error_from_service_at_startup = true;\n     return config;\n   }\n \n-  CoordinationServiceConfig GetServiceConfig(\n+  CoordinationService::Config GetServiceConfig(\n       int num_nodes, absl::Duration init_and_shutdown_timeout,\n       bool cluster_register_with_barrier, bool cluster_shutdown_with_barrier) {\n-    auto config =\n-        GetConfig(init_and_shutdown_timeout,\n-                  /*shutdown_on_destruction=*/true,\n-                  cluster_register_with_barrier, cluster_shutdown_with_barrier);\n-    tensorflow::CoordinatedJob* job =\n-        config.mutable_coordinated_job_list()->Add();\n-    job->set_name(\"agent\");\n-    job->set_num_tasks(num_nodes);\n+    CoordinationService::Config config;\n+    config.cluster_register_timeout = init_and_shutdown_timeout;\n+    config.heartbeat_timeout = kHeartbeatTimeout;\n+    if (cluster_shutdown_with_barrier) {\n+      config.shutdown_barrier_timeout = init_and_shutdown_timeout;\n+    }\n+    config.cluster_register_with_barrier = cluster_register_with_barrier;\n+    tensorflow::CoordinatedJob job;\n+    job.set_name(\"agent\");\n+    job.set_num_tasks(num_nodes);\n+    config.coordinated_job_list.push_back(job);\n     auto service =\n         std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n     return config;\n@@ -134,7 +131,7 @@ class ClientServerTest : public ::testing::Test {\n     leader_client.reset(NewGrpcCoordinationClient(channel));\n \n     auto coord_agent = CreateCoordinationServiceAgent();\n-    CoordinationServiceConfig config =\n+    CoordinationServiceAgent::Config config =\n         GetConfig(init_and_shutdown_timeout, shutdown_on_destruction);\n     const absl::Status status = coord_agent->Initialize(\n         tsl::Env::Default(), \"agent\", node_id, config, std::move(leader_client),"
        },
        {
            "sha": "a3ec50ee8f59716fd5d8a11c638ff4b753d072cd",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 33,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -42,9 +42,7 @@ limitations under the License.\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n #include \"absl/types/span.h\"\n-#include \"xla/pjrt/distributed/coordination/coordination_client.h\"\n #include \"xla/pjrt/distributed/coordination/coordination_service_error_util.h\"\n-#include \"xla/tsl/distributed_runtime/call_options.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/status.h\"\n@@ -61,16 +59,12 @@ namespace {\n using tensorflow::CoordinatedTask;\n using tensorflow::CoordinatedTaskState;\n using tensorflow::CoordinatedTaskStateInfo;\n-using tensorflow::CoordinationServiceConfig;\n-using tensorflow::CoordinationServiceError;\n using tensorflow::DeviceInfo;\n using tensorflow::KeyValueEntry;\n \n constexpr char kClusterRegisterBarrierId[] =\n     \"[Init]Wait_for_all_tasks_to_register\";\n constexpr absl::Duration kDevicePropagationTimeout = absl::Hours(1);\n-constexpr int kDefaultHeartbeatTimeoutMs = 10 * 1000;  // 10 seconds\n-constexpr int kServiceToClientTimeoutMs = 10 * 1000;   // 10 seconds\n constexpr size_t kOngoingBarriersSoftLimit = 20;\n constexpr char kHealthCheckThread[] = \"CoordinationServiceHealthCheck\";\n // Limit the number of stragglers we log to avoid `RESOURCE_EXHAUSTED` errors in\n@@ -200,25 +194,10 @@ bool CoordinationService::TaskState::IsDisconnectedBeyondGracePeriod() {\n          tsl::Env::Default()->NowMicros() > disconnect_grace_period_us_;\n }\n \n-CoordinationService::CoordinationService(\n-    tsl::Env* env, const CoordinationServiceConfig& config)\n-    : env_(*env),\n-      heartbeat_timeout_ms_([&config]() -> uint64_t {\n-        return config.heartbeat_timeout_in_ms() > 0\n-                   ? config.heartbeat_timeout_in_ms()\n-                   : kDefaultHeartbeatTimeoutMs;\n-      }()),\n-      cluster_register_with_barrier_(config.cluster_register_with_barrier()),\n-      cluster_register_timeout_(\n-          absl::Milliseconds(config.cluster_register_timeout_in_ms())),\n-      shutdown_barrier_timeout_(\n-          absl::Milliseconds(config.shutdown_barrier_timeout_in_ms())),\n-      allow_new_incarnation_to_reconnect_(\n-          config.allow_new_incarnation_to_reconnect()) {\n+CoordinationService::CoordinationService(tsl::Env* env, const Config& config)\n+    : env_(*env), config_(config) {\n   LOG(INFO) << \"Initializing CoordinationService\";\n-  recoverable_jobs_ = absl::flat_hash_set<std::string>(\n-      config.recoverable_jobs().cbegin(), config.recoverable_jobs().cend());\n-  for (const auto& job : config.coordinated_job_list()) {\n+  for (const auto& job : config_.coordinated_job_list) {\n     for (int i = 0; i < job.num_tasks(); ++i) {\n       const std::string task_name = GetTaskName(job.name(), i);\n       cluster_state_.emplace(task_name, std::make_unique<TaskState>(task_name));\n@@ -237,7 +216,8 @@ void CoordinationService::CheckHeartbeatTimeout() {\n       continue;\n     }\n     const bool is_stale =\n-        task_state->TimeSinceLastHeartbeatMs() > heartbeat_timeout_ms_;\n+        absl::Milliseconds(task_state->TimeSinceLastHeartbeatMs()) >\n+        config_.heartbeat_timeout;\n     VLOG(10) << \"Checking staleness for \" << task_name\n              << \" stale?=\" << is_stale;\n     if (is_stale) {\n@@ -598,7 +578,7 @@ void CoordinationService::RegisterTaskAsync(const CoordinatedTask& task,\n   const auto task_status = task_cluster_state->GetStatus();\n \n   if (task_state == CoordinatedTaskState::TASKSTATE_DISCONNECTED ||\n-      ((allow_new_incarnation_to_reconnect_ ||\n+      ((config_.allow_new_incarnation_to_reconnect ||\n         task_cluster_state->IsRecoverable()) &&\n        (absl::IsUnavailable(task_status) &&\n         task_status.GetPayload(CoordinationErrorPayloadKey())))) {\n@@ -609,7 +589,7 @@ void CoordinationService::RegisterTaskAsync(const CoordinatedTask& task,\n     //   an unavailable error state, but has now restarted (possibly with\n     //   a new incarnation). This is only allowed if configured with\n     //   `allow_new_incarnation_to_reconnect`.\n-    if (cluster_register_with_barrier_) {\n+    if (config_.cluster_register_with_barrier) {\n       // Impose barrier so that all tasks can register together.\n       // Note: it is possible that the same task restarts multiple times and\n       // registers itself with new incarnations.\n@@ -633,7 +613,7 @@ void CoordinationService::RegisterTaskAsync(const CoordinatedTask& task,\n       }\n       BarrierAsyncLocked(\n           kClusterRegisterBarrierId, kUniqueBarrierCounter,\n-          cluster_register_timeout_, task, {},\n+          config_.cluster_register_timeout, task, {},\n           ConnectAfterBarrierPasses(task_name, incarnation, std::move(done)));\n       ClusterStateUpdated();\n       return;\n@@ -711,7 +691,8 @@ void CoordinationService::WaitForAllTasks(const CoordinatedTask& task,\n void CoordinationService::ShutdownTaskAsync(const CoordinatedTask& task,\n                                             tsl::StatusCallback done) {\n   VLOG(3) << \"Task \" << GetTaskName(task) << \" invoked ShutdownTaskAsync()\";\n-  if (shutdown_barrier_timeout_ > absl::ZeroDuration() && !task.recoverable()) {\n+  if (config_.shutdown_barrier_timeout > absl::ZeroDuration() &&\n+      !task.recoverable()) {\n     // Impose shutdown barrier so that all (non-recoverable) tasks can\n     // disconnect together.\n     // Notes:\n@@ -725,7 +706,7 @@ void CoordinationService::ShutdownTaskAsync(const CoordinatedTask& task,\n     //    all tasks.\n     auto shutdown_tasks = GetTasksForShutdownBarrier();\n     BarrierAsync(shutdown_barrier_id_, kUniqueBarrierCounter,\n-                 shutdown_barrier_timeout_, task, shutdown_tasks,\n+                 config_.shutdown_barrier_timeout, task, shutdown_tasks,\n                  [done = std::move(done)](const absl::Status& s,\n                                           int64_t unused_counter) {\n                    if (s.ok()) {\n@@ -776,7 +757,8 @@ absl::Status CoordinationService::DisconnectTask(const CoordinatedTask& task) {\n \n   // Disconnect task.\n   task_state->Disconnect(\n-      /*grace_period_duration_us=*/heartbeat_timeout_ms_ * 1000);\n+      /*grace_period_duration_us=*/absl::ToInt64Milliseconds(\n+          config_.heartbeat_timeout));\n   LeaveOngoingBarriers(task, \"task disconnected\");\n   RefreshAliveness();\n   error_polling_state_.RemoveTask(task, \"task has disconnected.\");\n@@ -1443,7 +1425,8 @@ void CoordinationService::PassBarrier(BarrierState* barrier,\n            \"some tasks were never scheduled, or 3) scheduling delays. Consider \"\n            \"setting a longer initialization timeout if such delays are \"\n            \"expected, the timeout is currently set to: \"\n-        << cluster_register_timeout_ << \".\\n\\nOriginal error: \" << result;\n+        << config_.cluster_register_timeout\n+        << \".\\n\\nOriginal error: \" << result;\n     return;\n   }\n   // Special hook for shutdown barrier to disconnect tasks at the barrier and\n@@ -1829,7 +1812,8 @@ void CoordinationService::CompleteShutdownAfterBarrier(\n \n bool CoordinationService::isRecoverableJob(\n     const absl::string_view task_name) const {\n-  return recoverable_jobs_.find(task_name) != recoverable_jobs_.end();\n+  return config_.recoverable_jobs.find(task_name) !=\n+         config_.recoverable_jobs.end();\n }\n \n void CoordinationService::SendErrorPollingResponseOrFailAllTasks("
        },
        {
            "sha": "898f262691fbadf28230b81bd59a47f28fcdd358",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service.h",
            "status": "modified",
            "additions": 41,
            "deletions": 15,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.h?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -19,8 +19,9 @@ limitations under the License.\n #include <cstdint>\n #include <functional>\n #include <memory>\n+#include <optional>\n #include <string>\n-#include <utility>\n+#include <tuple>\n #include <vector>\n \n #include \"absl/base/thread_annotations.h\"\n@@ -35,10 +36,9 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/time/time.h\"\n-#include \"xla/pjrt/distributed/coordination/coordination_client.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/pjrt/distributed/coordination/key_value_store.h\"\n #include \"xla/service/global_device_id.h\"\n-#include \"xla/tsl/lib/gtl/int_type.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/protobuf/coordination_config.pb.h\"\n@@ -65,6 +65,42 @@ namespace xla {\n // tasks. Each task interacts with the service through CoordinationServiceAgent.\n class CoordinationService {\n  public:\n+  struct Config {\n+    // Maximum wait time for all members in the cluster to be registered.\n+    absl::Duration cluster_register_timeout = absl::Minutes(60);\n+\n+    // Denotes if we should synchronize the agents' register attempts by\n+    // blocking on a barrier. This is useful for synchronized restarts.\n+    bool cluster_register_with_barrier = false;\n+\n+    // Heartbeat timeout, if a task does not record heartbeat in this time\n+    // window, it will be considered disconnected.\n+    // Note: This is also used as a grace period to accept any heartbeats after\n+    // the agent has disconnected, to account for the lag time between the\n+    // service recording the state change and the agent stopping heartbeats.\n+    absl::Duration heartbeat_timeout = absl::Seconds(10);\n+\n+    // The list of `CoordinatedJob`s that will register in coordination service.\n+    std::vector<tensorflow::CoordinatedJob> coordinated_job_list;\n+\n+    // Denotes how long to wait for all coordination agents to reach the\n+    // barriers (after the first shutdown request) before disconnecting\n+    // together. If set to 0, no barrier is imposed upon shutdown and each\n+    // worker can disconnect individually.\n+    absl::Duration shutdown_barrier_timeout = absl::ZeroDuration();\n+\n+    // The list of jobs which are recoverable. If a task in this list fails,\n+    // it will not propagate error to other tasks.\n+    // If empty, no jobs will be recoverable and every task failure will cause\n+    // error propagation to other tasks.\n+    absl::flat_hash_set<std::string> recoverable_jobs;\n+\n+    // If a task restarts with a new incarnation, we may allow it to reconnect\n+    // silently. This is useful when we know that a task can immediately resume\n+    // work upon re-connecting to the service.\n+    bool allow_new_incarnation_to_reconnect = false;\n+  };\n+\n   using StatusOrValueCallback =\n       std::function<void(const absl::StatusOr<absl::string_view>&)>;\n   using BarrierCallback = std::function<void(const absl::Status&, int64_t)>;\n@@ -89,8 +125,7 @@ class CoordinationService {\n       absl::flat_hash_set<tensorflow::CoordinatedTask, CoordinatedTaskHash,\n                           CoordinatedTaskEqual>;\n \n-  CoordinationService(tsl::Env* env,\n-                      const tensorflow::CoordinationServiceConfig& config);\n+  CoordinationService(tsl::Env* env, const Config& config);\n \n   ~CoordinationService() {\n     absl::MutexLock lock(state_mu_);\n@@ -612,14 +647,7 @@ class CoordinationService {\n \n   tsl::Env& env_;\n   const IncarnationId service_incarnation_{tsl::random::New64()};\n-  const uint64_t heartbeat_timeout_ms_;\n-  bool cluster_register_with_barrier_ = false;\n-  const absl::Duration cluster_register_timeout_;\n-  const absl::Duration shutdown_barrier_timeout_;\n-  // If a task restarts with a new incarnation, we may allow it to reconnect\n-  // silently if configured. This is useful when we know that a task can\n-  // immediately resume work upon re-connecting to the service.\n-  bool allow_new_incarnation_to_reconnect_ = false;\n+  const Config config_;\n \n   std::function<tensorflow::DeviceInfo(const tensorflow::DeviceInfo& devices)>\n       post_aggregate_device_fn_;\n@@ -650,8 +678,6 @@ class CoordinationService {\n   // The state of all pending GetAliveTasks calls.\n   std::vector<AlivenessState> aliveness_states_ ABSL_GUARDED_BY(state_mu_);\n \n-  absl::flat_hash_set<std::string> recoverable_jobs_;\n-\n   // When the tasks connect to coordination service after cluster initialization\n   // is done, they will be added to this set.\n   // Tasks connecting after cluster initialization indicate that they"
        },
        {
            "sha": "5ab814869e4b96d414273de30950d97a7fafcb36",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 35,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -36,16 +36,13 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/strings/substitute.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/synchronization/notification.h\"\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n-#include \"absl/types/span.h\"\n #include \"xla/pjrt/distributed/coordination/coordination_client.h\"\n-#include \"xla/pjrt/distributed/coordination/coordination_service.h\"\n #include \"xla/pjrt/distributed/coordination/coordination_service_error_util.h\"\n #include \"xla/tsl/distributed_runtime/call_options.h\"\n #include \"xla/tsl/framework/cancellation.h\"\n@@ -59,7 +56,6 @@ namespace xla {\n using tensorflow::CoordinatedTask;\n using tensorflow::CoordinatedTaskState;\n using tensorflow::CoordinatedTaskStateInfo;\n-using tensorflow::CoordinationServiceConfig;\n using tensorflow::DeviceInfo;\n using tensorflow::KeyValueEntry;\n \n@@ -69,27 +65,22 @@ auto* enabled_usage_metric = tsl::monitoring::Gauge<bool, 0>::New(\n     \"/coordination_service/v2/agent/enabled\",\n     \"Tracks usage of coordination service.\");\n \n-constexpr absl::Duration kDefaultClusterRegisterTimeout = absl::Hours(1);\n-constexpr absl::Duration kDefaultHeartbeatTimeout = absl::Seconds(10);\n-constexpr absl::Duration kDefaultShutdownTimeout = absl::Seconds(10);\n constexpr char kHeartbeatThread[] = \"CoordinationServiceHeartbeatLoop\";\n \n }  // namespace\n \n absl::Status CoordinationServiceAgent::Initialize(\n     tsl::Env* env, absl::string_view job_name, int task_id,\n-    const CoordinationServiceConfig& configs,\n-    std::unique_ptr<CoordinationClient> leader_client,\n+    const Config& config, std::unique_ptr<CoordinationClient> leader_client,\n     tsl::StatusCallback error_fn) {\n-  return Initialize(env, job_name, task_id, configs, std::move(leader_client),\n+  return Initialize(env, job_name, task_id, config, std::move(leader_client),\n                     error_fn,\n                     /*recoverable=*/false);\n }\n \n absl::Status CoordinationServiceAgent::Initialize(\n     tsl::Env* env, absl::string_view job_name, int task_id,\n-    const CoordinationServiceConfig& configs,\n-    std::unique_ptr<CoordinationClient> leader_client,\n+    const Config& config, std::unique_ptr<CoordinationClient> leader_client,\n     tsl::StatusCallback error_fn, bool recoverable) {\n   CoordinatedTask task;\n   task.set_job_name(std::string(job_name));\n@@ -102,12 +93,11 @@ absl::Status CoordinationServiceAgent::Initialize(\n            \"`WaitAtBarrier` explicitly at the end of the program.\";\n     task.set_recoverable(true);\n   }\n-  return Initialize(env, task, configs, std::move(leader_client), error_fn);\n+  return Initialize(env, task, config, std::move(leader_client), error_fn);\n }\n \n absl::Status CoordinationServiceAgent::Initialize(\n-    tsl::Env* env, const CoordinatedTask& task,\n-    const CoordinationServiceConfig& configs,\n+    tsl::Env* env, const CoordinatedTask& task, const Config& config,\n     std::unique_ptr<CoordinationClient> leader_client,\n     tsl::StatusCallback error_fn) {\n   enabled_usage_metric->GetCell()->Set(true);\n@@ -119,8 +109,8 @@ absl::Status CoordinationServiceAgent::Initialize(\n \n   env_ = env;\n   task_ = task;\n-  configs_ = configs;\n-  if (configs_.service_leader().empty()) {\n+  config_ = config;\n+  if (config_.service_leader.empty()) {\n     return MakeCoordinationError(absl::InvalidArgumentError(\n         \"CoordinationServiceAgent must be initialized with a valid leader.\"));\n   }\n@@ -183,13 +173,9 @@ absl::Status CoordinationServiceAgent::Connect() {\n   request.set_incarnation(incarnation_id_.value());\n   RegisterTaskResponse response;\n \n-  const int64_t register_timeout =\n-      configs_.cluster_register_timeout_in_ms() > 0\n-          ? configs_.cluster_register_timeout_in_ms()\n-          : absl::ToInt64Milliseconds(kDefaultClusterRegisterTimeout);\n   // Give 5 seconds for any service-related timeouts to propagate.\n   const absl::Time deadline =\n-      absl::Now() + absl::Milliseconds(register_timeout) + absl::Seconds(5);\n+      absl::Now() + config_.cluster_register_timeout + absl::Seconds(5);\n   int attempt = 0;\n   std::default_random_engine generator;\n   std::uniform_real_distribution<double> distribution(0.0, 1.0);\n@@ -244,7 +230,7 @@ absl::Status CoordinationServiceAgent::Connect() {\n       tsl::ThreadOptions(), kHeartbeatThread,\n       absl::bind_front(&CoordinationServiceAgent::StartSendingHeartbeats,\n                        this)));\n-  if (configs_.poll_for_error_from_service_at_startup()) {\n+  if (config_.poll_for_error_from_service_at_startup) {\n     StartPollingForError();\n   }\n   return absl::OkStatus();\n@@ -255,12 +241,9 @@ void CoordinationServiceAgent::StartSendingHeartbeats() {\n   *request.mutable_source_task() = task_;\n   request.set_incarnation(incarnation_id_.value());\n   HeartbeatResponse response;\n-  const int64_t heartbeat_interval_ms =\n-      configs_.heartbeat_timeout_in_ms() > 0\n-          ? configs_.heartbeat_timeout_in_ms() / 2\n-          : absl::ToInt64Milliseconds(kDefaultHeartbeatTimeout) / 2;\n+  const absl::Duration heartbeat_interval = config_.heartbeat_timeout;\n   tsl::CallOptions call_opts;\n-  call_opts.SetTimeout(heartbeat_interval_ms);\n+  call_opts.SetTimeout(absl::ToInt64Milliseconds(heartbeat_interval));\n \n   while (true) {\n     absl::Status status;\n@@ -302,7 +285,7 @@ void CoordinationServiceAgent::StartSendingHeartbeats() {\n     {\n       absl::MutexLock l(shutdown_mu_);\n       shutdown_mu_.AwaitWithTimeout(absl::Condition(&shutting_down_),\n-                                    absl::Milliseconds(heartbeat_interval_ms));\n+                                    config_.heartbeat_timeout);\n       if (shutting_down_) {\n         return;\n       }\n@@ -524,18 +507,15 @@ absl::Status CoordinationServiceAgent::ShutdownInternal() {\n     is_connected = state_ == CoordinatedTaskState::TASKSTATE_CONNECTED;\n   }\n   // Disconnect agent from service.\n-  if (!configs_.agent_destruction_without_shutdown() && is_connected) {\n+  if (!config_.agent_destruction_without_shutdown && is_connected) {\n     LOG(INFO) << \"Coordination agent has initiated Shutdown().\";\n     ShutdownTaskRequest request;\n     *request.mutable_source_task() = task_;\n     ShutdownTaskResponse response;\n     tsl::CallOptions call_opts;\n+    // Add 5s for service-related errors to propagate.\n     const int64_t shutdown_timeout =\n-        (configs_.shutdown_barrier_timeout_in_ms() > 0\n-             ? configs_.shutdown_barrier_timeout_in_ms()\n-             : absl::ToInt64Milliseconds(kDefaultShutdownTimeout)) +\n-        // Add 5s for service-related errors to propagate.\n-        5 * 1000;\n+        absl::ToInt64Milliseconds(config_.shutdown_barrier_timeout) + 5 * 1000;\n     call_opts.SetTimeout(shutdown_timeout);\n \n     absl::Notification n;"
        },
        {
            "sha": "77621a073b14cd86d4a2858d902a76a36ea9bf17",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent.h",
            "status": "modified",
            "additions": 34,
            "deletions": 8,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.h?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -27,14 +27,12 @@ limitations under the License.\n #include \"absl/base/thread_annotations.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n-#include \"absl/functional/any_invocable.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/time/time.h\"\n-#include \"absl/types/span.h\"\n #include \"xla/pjrt/distributed/coordination/coordination_client.h\"\n #include \"xla/pjrt/distributed/coordination/coordination_service.h\"\n #include \"xla/tsl/distributed_runtime/call_options.h\"\n@@ -70,6 +68,36 @@ namespace xla {\n //                               registered or wrong config).\n class CoordinationServiceAgent {\n  public:\n+  struct Config {\n+    // Address where the coordination service instance is hosted.\n+    std::string service_leader;\n+\n+    // Maximum wait time for all members in the cluster to be registered.\n+    absl::Duration cluster_register_timeout = absl::Hours(1);\n+\n+    // Heartbeat timeout, if a task does not record heartbeat in this time\n+    // window, it will be considered disconnected.\n+    // Note: This is also used as a grace period to accept any heartbeats after\n+    // the agent has disconnected, to account for the lag time between the\n+    // service recording the state change and the agent stopping heartbeats.\n+    absl::Duration heartbeat_timeout = absl::Seconds(10);\n+\n+    // Denotes how long to wait for all coordination agents to reach the\n+    // barriers (after the first shutdown request) before disconnecting\n+    // together. If set to 0, no barrier is imposed upon shutdown and each\n+    // worker can disconnect individually.\n+    absl::Duration shutdown_barrier_timeout = absl::Seconds(10);\n+\n+    // If set, agents do not make an explicit Shutdown() call. Service will only\n+    // find out about the disconnected agent via stale heartbeats. Used for\n+    // testing.\n+    bool agent_destruction_without_shutdown = false;\n+\n+    // Use long polling to get error from coordination service as the error\n+    // propagation mechanism.\n+    bool poll_for_error_from_service_at_startup = false;\n+  };\n+\n   using StatusOrValueCallback =\n       std::function<void(const absl::StatusOr<std::string>&)>;\n   // Collection of key-value pairs in the same directory.\n@@ -86,18 +114,16 @@ class CoordinationServiceAgent {\n   }\n \n   absl::Status Initialize(tsl::Env* env, absl::string_view job_name,\n-                          int task_id,\n-                          const tensorflow::CoordinationServiceConfig& configs,\n+                          int task_id, const Config& config,\n                           std::unique_ptr<CoordinationClient> leader_client,\n                           tsl::StatusCallback error_fn, bool recoverable);\n   absl::Status Initialize(tsl::Env* env, absl::string_view job_name,\n-                          int task_id,\n-                          const tensorflow::CoordinationServiceConfig& configs,\n+                          int task_id, const Config& config,\n                           std::unique_ptr<CoordinationClient> leader_client,\n                           tsl::StatusCallback error_fn);\n   absl::Status Initialize(tsl::Env* env,\n                           const tensorflow::CoordinatedTask& task,\n-                          const tensorflow::CoordinationServiceConfig& configs,\n+                          const Config& config,\n                           std::unique_ptr<CoordinationClient> leader_client,\n                           tsl::StatusCallback error_fn);\n \n@@ -380,7 +406,7 @@ class CoordinationServiceAgent {\n   tsl::Env* env_ = nullptr;  // Not owned.\n   const IncarnationId incarnation_id_{tsl::random::New64()};\n   tensorflow::CoordinatedTask task_;\n-  tensorflow::CoordinationServiceConfig configs_;\n+  Config config_;\n   tsl::StatusCallback error_fn_;\n \n   mutable absl::Mutex state_mu_;"
        },
        {
            "sha": "0caa18b97102a11288dde992f3a0fd656f1b87d4",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 14,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent_test.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -41,7 +41,6 @@ limitations under the License.\n namespace xla {\n namespace {\n using tensorflow::CoordinatedTask;\n-using tensorflow::CoordinationServiceConfig;\n using tensorflow::KeyValueEntry;\n \n using ::testing::_;\n@@ -181,8 +180,8 @@ class CoordinationServiceAgentTest : public ::testing::Test {\n   }\n \n   // Should be called after mocking service responses, before testing the agent.\n-  void InitializeAgent(CoordinationServiceConfig config = {}) {\n-    config.set_service_leader(\"test_leader\");\n+  void InitializeAgent(CoordinationServiceAgent::Config config = {}) {\n+    config.service_leader = \"test_leader\";\n     TF_ASSERT_OK(agent_->Initialize(\n         tsl::Env::Default(), /*job_name=*/\"test_job\",\n         /*task_id=*/0, config, std::move(client_),\n@@ -456,8 +455,8 @@ TEST_F(CoordinationServiceAgentTest, ConnectAfterReset_WithErrorPolling) {\n       .WillOnce(DoAll(SetArgPointee<2>(mocked_response),\n                       InvokeArgument<3>(absl::InternalError(\"Test Error.\"))));\n \n-  CoordinationServiceConfig config;\n-  config.set_poll_for_error_from_service_at_startup(true);\n+  CoordinationServiceAgent::Config config;\n+  config.poll_for_error_from_service_at_startup = true;\n   InitializeAgent(config);\n   // The agent will be in ERROR state after the first call to Connect()\n   // because the error polling thread will be created and will immediately\n@@ -483,8 +482,8 @@ TEST_F(CoordinationServiceAgentTest, CancelledPollForErrorRequest) {\n       .WillOnce(DoAll(SetArgPointee<2>(mocked_response),\n                       InvokeArgument<3>(absl::CancelledError(\"Test Error.\"))));\n \n-  CoordinationServiceConfig config;\n-  config.set_poll_for_error_from_service_at_startup(true);\n+  CoordinationServiceAgent::Config config;\n+  config.poll_for_error_from_service_at_startup = true;\n   InitializeAgent(config);\n   TF_ASSERT_OK(agent_->Connect());\n   // Wait a bit for the error polling thread to start.\n@@ -501,8 +500,8 @@ TEST_F(CoordinationServiceAgentTest, InvalidPollForErrorRequest) {\n           DoAll(SetArgPointee<2>(mocked_response),\n                 InvokeArgument<3>(absl::InvalidArgumentError(\"Test Error.\"))));\n \n-  CoordinationServiceConfig config;\n-  config.set_poll_for_error_from_service_at_startup(true);\n+  CoordinationServiceAgent::Config config;\n+  config.poll_for_error_from_service_at_startup = true;\n   InitializeAgent(config);\n   TF_ASSERT_OK(agent_->Connect());\n   // Wait a bit for the error polling thread to start.\n@@ -519,8 +518,8 @@ TEST_F(CoordinationServiceAgentTest,\n           SetArgPointee<2>(mocked_response),\n           InvokeArgument<3>(absl::FailedPreconditionError(\"Test Error.\"))));\n \n-  CoordinationServiceConfig config;\n-  config.set_poll_for_error_from_service_at_startup(true);\n+  CoordinationServiceAgent::Config config;\n+  config.poll_for_error_from_service_at_startup = true;\n   InitializeAgent(config);\n   TF_ASSERT_OK(agent_->Connect());\n   // Wait a bit for the error polling thread to start.\n@@ -598,10 +597,9 @@ TEST_F(CoordinationServiceAgentTest, Connect_AbortedErrorShouldFailEventually) {\n   EXPECT_CALL(*GetClient(), RegisterTaskAsync(_, _, _, _))\n       .WillRepeatedly(\n           InvokeArgument<3>(absl::AbortedError(\"DuplicateTaskRegistration\")));\n-  CoordinationServiceConfig config;\n+  CoordinationServiceAgent::Config config;\n   // Connect should only be retried for 3 seconds.\n-  config.set_cluster_register_timeout_in_ms(\n-      absl::ToInt64Milliseconds(absl::Seconds(3)));\n+  config.cluster_register_timeout = absl::Seconds(3);\n   InitializeAgent(config);\n \n   absl::Status s = agent_->Connect();"
        },
        {
            "sha": "7a08a8c0bf310038cd8020d2568265c2417475ec",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_test.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_test.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -1,4 +1,4 @@\n-/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n+/*r Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n@@ -78,12 +78,12 @@ KeyValueEntry CreateKv(const std::string& key, const std::string& value) {\n   return kv;\n }\n \n-CoordinationServiceConfig GetCoordinationServiceConfig(int num_tasks) {\n-  CoordinationServiceConfig config;\n-  config.set_service_type(kCoordinationServiceType);\n-  CoordinatedJob* job = config.mutable_coordinated_job_list()->Add();\n-  job->set_name(\"worker\");\n-  job->set_num_tasks(num_tasks);\n+CoordinationService::Config GetCoordinationServiceConfig(int num_tasks) {\n+  CoordinationService::Config config;\n+  CoordinatedJob job;\n+  job.set_name(\"worker\");\n+  job.set_num_tasks(num_tasks);\n+  config.coordinated_job_list.push_back(std::move(job));\n   return config;\n }\n \n@@ -168,7 +168,8 @@ class CoordinationBarrierTest : public ::testing::Test {\n       tasks_.push_back(task);\n       clients_.push_back(std::move(client));\n     }\n-    CoordinationServiceConfig config = GetCoordinationServiceConfig(num_tasks);\n+    CoordinationService::Config config =\n+        GetCoordinationServiceConfig(num_tasks);\n \n     coord_service_ =\n         std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n@@ -232,24 +233,21 @@ class CoordinateTwoTasksTest : public ::testing::Test {\n       bool enable_register_barrier = false,\n       bool set_worker_job_recoverable = false,\n       bool allow_new_incarnation_to_reconnect = false) {\n-    CoordinationServiceConfig config =\n+    CoordinationService::Config config =\n         GetCoordinationServiceConfig(/*num_tasks=*/2);\n-    config.set_heartbeat_timeout_in_ms(kHeartbeatTimeout /\n-                                       absl::Milliseconds(1));\n+    config.heartbeat_timeout = kHeartbeatTimeout;\n     if (set_worker_job_recoverable) {\n-      config.mutable_recoverable_jobs()->Add(\"worker\");\n+      config.recoverable_jobs.insert(\"worker\");\n     }\n     if (enable_shutdown_barrier) {\n-      config.set_shutdown_barrier_timeout_in_ms(kShutdownBarrierTimeout /\n-                                                absl::Milliseconds(1));\n+      config.shutdown_barrier_timeout = kShutdownBarrierTimeout;\n     }\n     if (enable_register_barrier) {\n-      config.set_cluster_register_with_barrier(true);\n-      config.set_cluster_register_timeout_in_ms(absl::Seconds(1) /\n-                                                absl::Milliseconds(1));\n+      config.cluster_register_with_barrier = true;\n+      config.cluster_register_timeout = absl::Seconds(1);\n     }\n     if (allow_new_incarnation_to_reconnect) {\n-      config.set_allow_new_incarnation_to_reconnect(true);\n+      config.allow_new_incarnation_to_reconnect = true;\n     }\n     // Init service.\n     coord_service_ =\n@@ -322,14 +320,15 @@ TEST(CoordinationServiceTest, TestCoordinatedJobs) {\n   evaluator.set_job_name(\"evaluator\");\n   evaluator.set_task_id(0);\n \n-  CoordinationServiceConfig config;\n-  config.set_service_type(kCoordinationServiceType);\n-  CoordinatedJob* chief_job = config.mutable_coordinated_job_list()->Add();\n-  chief_job->set_name(\"chief\");\n-  chief_job->set_num_tasks(1);\n-  CoordinatedJob* worker_job = config.mutable_coordinated_job_list()->Add();\n-  worker_job->set_name(\"worker\");\n-  worker_job->set_num_tasks(2);\n+  CoordinationService::Config config;\n+  CoordinatedJob chief_job;\n+  chief_job.set_name(\"chief\");\n+  chief_job.set_num_tasks(1);\n+  config.coordinated_job_list.push_back(chief_job);\n+  CoordinatedJob worker_job;\n+  worker_job.set_name(\"worker\");\n+  worker_job.set_num_tasks(2);\n+  config.coordinated_job_list.push_back(worker_job);\n \n   auto coord_service =\n       std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n@@ -369,7 +368,7 @@ TEST(CoordinationServiceTest, TestCoordinatedJobs) {\n // In this case, the agent would retry Connect() and should succeed if it has\n // the same incarnation.\n TEST(CoordinationServiceTest, RegisterTask_AlreadyConnected_Succeeds) {\n-  const CoordinationServiceConfig config =\n+  const CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n   CoordinatedTask task_0;\n   task_0.set_job_name(\"worker\");\n@@ -388,7 +387,7 @@ TEST(CoordinationServiceTest, RegisterTask_AlreadyConnected_Succeeds) {\n \n TEST(CoordinationServiceTest,\n      RegisterTask_AlreadyConnectedDifferentIncarnation_Fails) {\n-  const CoordinationServiceConfig config =\n+  const CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n   CoordinatedTask task_0;\n   task_0.set_job_name(\"worker\");\n@@ -408,7 +407,7 @@ TEST(CoordinationServiceTest,\n }\n \n TEST(CoordinationServiceTest, RegisterTask_AlreadyInError_Fails) {\n-  CoordinationServiceConfig config =\n+  CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n   CoordinatedTask task_0;\n   task_0.set_job_name(\"worker\");\n@@ -854,7 +853,7 @@ TEST_F(CoordinateTwoTasksTest, TestSetGetValues) {\n }\n \n TEST(CoordinationServiceTest, TryGetKeyValue) {\n-  const CoordinationServiceConfig config =\n+  const CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n   std::unique_ptr<CoordinationService> coord_service =\n       std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n@@ -876,7 +875,7 @@ TEST(CoordinationServiceTest, TryGetKeyValue) {\n }\n \n TEST(CoordinationServiceTest, IncrementKeyValue) {\n-  const CoordinationServiceConfig config =\n+  const CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/1);\n   std::unique_ptr<CoordinationService> coord_service =\n       std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n@@ -975,7 +974,7 @@ TEST_F(CoordinateTwoTasksTest,\n // Verify that coordination service can gather each task's device info and\n // propagate the aggregated cluster device info correctly.\n TEST(CoordinationServiceTest, ListClusterDevices_TfDevice) {\n-  const CoordinationServiceConfig config =\n+  const CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/3);\n   CoordinatedTask task_0;\n   task_0.set_job_name(\"worker\");\n@@ -1032,7 +1031,7 @@ TEST(CoordinationServiceTest, ListClusterDevices_TfDevice) {\n // Task devices should not be added twice if same task calls WaitForAllDevices()\n // twice.\n TEST(CoordinationServiceTest, ListClusterDevices_DevicesAreNotAddedTwice) {\n-  const CoordinationServiceConfig config =\n+  const CoordinationService::Config config =\n       GetCoordinationServiceConfig(/*num_tasks=*/2);\n   CoordinatedTask task_0;\n   task_0.set_job_name(\"worker\");\n@@ -2110,10 +2109,9 @@ TEST_F(CoordinateTwoTasksTest,\n }\n \n TEST(CoordinationServiceTest, RecoverableAndNonRecoverableTasks) {\n-  CoordinationServiceConfig config;\n-  config.set_service_type(kCoordinationServiceType);\n+  CoordinationService::Config config;\n   // Workers are recoverable, chief is not.\n-  config.mutable_recoverable_jobs()->Add(\"worker\");\n+  config.recoverable_jobs.insert(\"worker\");\n   CoordinatedTask chief;\n   chief.set_job_name(\"chief\");\n   chief.set_task_id(0);\n@@ -2123,12 +2121,14 @@ TEST(CoordinationServiceTest, RecoverableAndNonRecoverableTasks) {\n   CoordinatedTask task_1;\n   task_1.set_job_name(\"worker\");\n   task_1.set_task_id(1);\n-  CoordinatedJob* chief_job = config.mutable_coordinated_job_list()->Add();\n-  chief_job->set_name(\"chief\");\n-  chief_job->set_num_tasks(1);\n-  CoordinatedJob* worker_job = config.mutable_coordinated_job_list()->Add();\n-  worker_job->set_name(\"worker\");\n-  worker_job->set_num_tasks(2);\n+  CoordinatedJob chief_job;\n+  chief_job.set_name(\"chief\");\n+  chief_job.set_num_tasks(1);\n+  config.coordinated_job_list.push_back(chief_job);\n+  CoordinatedJob worker_job;\n+  worker_job.set_name(\"worker\");\n+  worker_job.set_num_tasks(2);\n+  config.coordinated_job_list.push_back(worker_job);\n \n   std::unique_ptr<CoordinationService> coord_service =\n       std::make_unique<CoordinationService>(tsl::Env::Default(), config);"
        },
        {
            "sha": "3fed3b8b36cd1b2ecf7d030e38cd37e7ff01632d",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_sync_manager_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -43,7 +43,6 @@ namespace xla {\n namespace {\n using tensorflow::CoordinatedJob;\n using tensorflow::CoordinatedTask;\n-using tensorflow::CoordinationServiceConfig;\n \n constexpr char kJobName[] = \"test_worker\";\n \n@@ -144,11 +143,11 @@ class PreemptionSyncManagerTest : public ::testing::Test {\n         [service = coord_rpc_service_.get()]() { service->HandleRPCsLoop(); }));\n   }\n   std::unique_ptr<CoordinationService> EnableCoordinationService() {\n-    CoordinationServiceConfig config;\n-    config.set_service_type(\"standalone\");\n-    CoordinatedJob* job = config.mutable_coordinated_job_list()->Add();\n-    job->set_name(kJobName);\n-    job->set_num_tasks(2);\n+    CoordinationService::Config config;\n+    CoordinatedJob job;\n+    job.set_name(kJobName);\n+    job.set_num_tasks(2);\n+    config.coordinated_job_list.push_back(job);\n     return std::make_unique<CoordinationService>(tsl::Env::Default(), config);\n   }\n   void InitializeAndConnectCoordinationAgents() {\n@@ -161,8 +160,8 @@ class PreemptionSyncManagerTest : public ::testing::Test {\n     auto error_fn = [](const absl::Status& status) {\n       LOG(ERROR) << \"Coordination service agent in error status: \" << status;\n     };\n-    CoordinationServiceConfig coord_config;\n-    coord_config.set_service_leader(\"test_leader\");\n+    CoordinationServiceAgent::Config coord_config;\n+    coord_config.service_leader = \"test_leader\";\n     CHECK_OK(coord_agent_->Initialize(tsl::Env::Default(), kJobName,\n                                       /*task_id=*/0, coord_config,\n                                       std::move(coord_client), error_fn));"
        },
        {
            "sha": "513341bbd42c3ece719266c001b7279ffb87e985",
            "filename": "third_party/xla/xla/pjrt/distributed/service.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 14,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fservice.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f9718d6341aa387f114d706015fde29da038d1b7/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fservice.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fservice.cc?ref=f9718d6341aa387f114d706015fde29da038d1b7",
            "patch": "@@ -37,20 +37,15 @@ namespace {\n std::unique_ptr<xla::CoordinationService> EnableCoordinationService(\n     const xla::CoordinationServiceImpl::Options& options) {\n   const std::string job_name = \"jax_worker\";\n-  tensorflow::CoordinationServiceConfig config;\n-  config.set_service_type(\"standalone\");\n-  config.set_service_leader(absl::StrCat(\"/job:\", job_name, \"/task:0\"));\n-  config.set_cluster_register_timeout_in_ms(\n-      absl::ToInt64Milliseconds(options.cluster_register_timeout));\n-  config.set_cluster_register_with_barrier(true);\n-  config.set_heartbeat_timeout_in_ms(\n-      absl::ToInt64Milliseconds(options.heartbeat_timeout));\n-  config.set_shutdown_barrier_timeout_in_ms(\n-      absl::ToInt64Milliseconds(options.shutdown_timeout));\n-  tensorflow::CoordinatedJob* job =\n-      config.mutable_coordinated_job_list()->Add();\n-  job->set_name(job_name);\n-  job->set_num_tasks(options.num_nodes);\n+  xla::CoordinationService::Config config;\n+  config.cluster_register_timeout = options.cluster_register_timeout;\n+  config.cluster_register_with_barrier = true;\n+  config.heartbeat_timeout = options.heartbeat_timeout;\n+  config.shutdown_barrier_timeout = options.shutdown_timeout;\n+  tensorflow::CoordinatedJob job;\n+  job.set_name(job_name);\n+  job.set_num_tasks(options.num_nodes);\n+  config.coordinated_job_list.push_back(job);\n   auto service =\n       std::make_unique<xla::CoordinationService>(options.env, config);\n   return service;"
        }
    ],
    "stats": {
        "total": 423,
        "additions": 208,
        "deletions": 215
    }
}