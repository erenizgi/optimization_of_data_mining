{
    "author": "tensorflower-gardener",
    "message": "[XLA] Hoist slices through all element-wise binary operations.\n\nPiperOrigin-RevId: 804863046",
    "sha": "785029e4ba21d7d19621677ab1ad106e923a875b",
    "files": [
        {
            "sha": "28401a75ad28c092d695ebb2f48cd02e2961bed2",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 22,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/785029e4ba21d7d19621677ab1ad106e923a875b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/785029e4ba21d7d19621677ab1ad106e923a875b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc?ref=785029e4ba21d7d19621677ab1ad106e923a875b",
            "patch": "@@ -32,21 +32,20 @@ namespace xla {\n \n namespace {\n \n-// Helper function to attempt hoisting a slice through an add operation.\n-// Returns true if a change was made.\n-absl::StatusOr<bool> TryHoistSliceThroughAdd(HloInstruction* instruction,\n-                                             HloComputation* computation) {\n+// Helper function to attempt hoisting a slice through an element-wise binary\n+// operation. Returns true if a change was made.\n+absl::StatusOr<bool> TryHoistSliceThroughElementwiseBinaryOperation(\n+    HloInstruction* instruction, HloComputation* computation) {\n   if (instruction->opcode() != HloOpcode::kSlice) {\n     return false;\n   }\n-  HloInstruction* operand = instruction->mutable_operand(0);\n-  if (operand->opcode() != HloOpcode::kAdd) {\n+  HloInstruction* slice_operand = instruction->mutable_operand(0);\n+  if (!slice_operand->IsElementwiseBinary()) {\n     return false;\n   }\n \n-  HloInstruction* add = operand;\n-  HloInstruction* lhs = add->mutable_operand(0);\n-  HloInstruction* rhs = add->mutable_operand(1);\n+  HloInstruction* lhs = slice_operand->mutable_operand(0);\n+  HloInstruction* rhs = slice_operand->mutable_operand(1);\n \n   if (lhs->shape() != rhs->shape()) {\n     VLOG(1) << \" Operand shapes do not match: \" << lhs->shape() << \" and \"\n@@ -59,10 +58,11 @@ absl::StatusOr<bool> TryHoistSliceThroughAdd(HloInstruction* instruction,\n             << instruction->shape().element_type();\n     return false;\n   }\n-  if (instruction->shape().element_type() != add->shape().element_type()) {\n-    VLOG(1) << \" Slice element type does not match add element type: \"\n+  if (instruction->shape().element_type() !=\n+      slice_operand->shape().element_type()) {\n+    VLOG(1) << \" Slice element type does not match slice operand element type: \"\n             << instruction->shape().element_type() << \" and \"\n-            << add->shape().element_type();\n+            << slice_operand->shape().element_type();\n     return false;\n   }\n \n@@ -76,27 +76,26 @@ absl::StatusOr<bool> TryHoistSliceThroughAdd(HloInstruction* instruction,\n           instruction->shape(), rhs, instruction->slice_starts(),\n           instruction->slice_limits(), instruction->slice_strides()));\n   TF_RETURN_IF_ERROR(computation->ReplaceWithNewInstruction(\n-      instruction,\n-      HloInstruction::CreateBinary(instruction->shape(), HloOpcode::kAdd,\n-                                   lhs_slice, rhs_slice)));\n+      instruction, HloInstruction::CreateBinary(instruction->shape(),\n+                                                slice_operand->opcode(),\n+                                                lhs_slice, rhs_slice)));\n   return true;\n }\n \n // As slices reduce the size of the input, it can be beneficial to hoist\n // slices as high in the graph as possible, ideally right after parameter\n // reads, which could reduce both compute and memory costs.\n //\n-// Currently, this pass hoists slice operations through add operations.\n-// Note that this pass can create redundant slices, which can be removed by\n-// running CSE.\n+// Currently, this pass hoists slice operations through element-wise binary\n+// operations. Note that this pass can create redundant slices, which can be\n+// removed by running CSE.\n //\n // Note that algebraic simplifier also has `HandleSlice` function.\n absl::StatusOr<bool> HoistSliceOperations(HloComputation* computation) {\n   bool changed = false;\n   bool changed_on_last_iteration = false;\n-  // TODO(b/434724820): Generalize to element-wise operations.\n-  // TODO(b/434724820): Consider also other operations like broadcast, reduce,\n-  // transpose, etc.\n+  // TODO(b/434724820): Consider also other operations that aren't handled in\n+  // algebraic simplifier.\n   // TODO(b/434724820): Make this more efficient by e.g. using a worklist or a\n   // topological sort.\n   do {\n@@ -106,7 +105,8 @@ absl::StatusOr<bool> HoistSliceOperations(HloComputation* computation) {\n         computation->MakeInstructionPostOrder();\n     for (HloInstruction* instruction : instructions) {\n       TF_ASSIGN_OR_RETURN(bool instruction_changed,\n-                          TryHoistSliceThroughAdd(instruction, computation));\n+                          TryHoistSliceThroughElementwiseBinaryOperation(\n+                              instruction, computation));\n       if (instruction_changed) {\n         changed_on_last_iteration = true;\n         break;"
        },
        {
            "sha": "b163582d09973a07b484bba6d62d786549abb3f4",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister_test.cc",
            "status": "modified",
            "additions": 77,
            "deletions": 19,
            "changes": 96,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/785029e4ba21d7d19621677ab1ad106e923a875b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/785029e4ba21d7d19621677ab1ad106e923a875b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc?ref=785029e4ba21d7d19621677ab1ad106e923a875b",
            "patch": "@@ -74,15 +74,18 @@ TEST_F(SliceHoisterTest, HoistSliceThroughAdd) {\n   EXPECT_THAT(param_1_slice->slice_strides(), ElementsAre(1, 1));\n }\n \n-TEST_F(SliceHoisterTest, HoistSliceThroughMultipleAdds) {\n+TEST_F(SliceHoisterTest, HoistSliceThroughMultipleElementwiseBinaryOperations) {\n   absl::string_view module_str = R\"(\n     HloModule module\n     ENTRY main {\n       param_0 = f32[8,9] parameter(0)\n       param_1 = f32[8,9] parameter(1)\n-      add_op_1 = f32[8,9] add(f32[8,9] param_0, f32[8,9] param_1)\n-      add_op_2 = f32[8,9] add(f32[8,9] add_op_1, f32[8,9] param_1)\n-      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op_2), slice={[0:2], [0:9]}\n+      param_2 = f32[8,9] parameter(2)\n+      multiply_op = f32[8,9] multiply(f32[8,9] param_0, f32[8,9] param_1)\n+      add_op = f32[8,9] add(f32[8,9] multiply_op, f32[8,9] param_1)\n+      divide_op = f32[8,9] divide(f32[8,9] add_op, f32[8,9] param_2)\n+      power_op = f32[8,9] power(f32[8,9] param_2, f32[8,9] divide_op)\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] power_op), slice={[0:2], [0:9]}\n     }\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n@@ -95,7 +98,8 @@ TEST_F(SliceHoisterTest, HoistSliceThroughMultipleAdds) {\n   SCOPED_TRACE(module->ToString());\n   EXPECT_TRUE(changed);\n \n-  HloCSE cse = HloCSE(false);\n+  HloCSE cse = HloCSE(\n+      false);  // CSE to remove the redundant slices of param_1 and param_2.\n   TF_ASSERT_OK_AND_ASSIGN(changed, RunHloPass(&cse, module.get()));\n \n   SCOPED_TRACE(module->ToString());\n@@ -104,22 +108,31 @@ TEST_F(SliceHoisterTest, HoistSliceThroughMultipleAdds) {\n   HloInstruction* root_instruction =\n       module->entry_computation()->root_instruction();\n   const HloInstruction* param_0_slice = nullptr;\n-  const HloInstruction* param_1_first_slice = nullptr;\n-  const HloInstruction* param_1_second_slice = nullptr;\n+  const HloInstruction* param_1_slice_1 = nullptr;\n+  const HloInstruction* param_1_slice_2 = nullptr;\n+  const HloInstruction* param_2_slice_1 = nullptr;\n+  const HloInstruction* param_2_slice_2 = nullptr;\n   EXPECT_THAT(\n       root_instruction,\n-      GmockMatch(m::Add(m::Add(m::Slice(&param_0_slice, m::Parameter(0)),\n-                               m::Op(&param_1_first_slice)),\n-                        m::Op(&param_1_second_slice))));\n-  // The slice of param_1 should be evaluated only once and reused.\n-  EXPECT_EQ(param_1_first_slice, param_1_second_slice);\n-  EXPECT_THAT(param_1_first_slice, GmockMatch(m::Slice(m::Parameter(1))));\n-  EXPECT_THAT(param_0_slice->slice_starts(), ElementsAre(0, 0));\n-  EXPECT_THAT(param_0_slice->slice_limits(), ElementsAre(2, 9));\n-  EXPECT_THAT(param_0_slice->slice_strides(), ElementsAre(1, 1));\n-  EXPECT_THAT(param_1_first_slice->slice_starts(), ElementsAre(0, 0));\n-  EXPECT_THAT(param_1_first_slice->slice_limits(), ElementsAre(2, 9));\n-  EXPECT_THAT(param_1_first_slice->slice_strides(), ElementsAre(1, 1));\n+      GmockMatch(m::Power(\n+          m::Slice(&param_2_slice_1, m::Parameter(2)),\n+          m::Divide(\n+              m::Add(m::Multiply(m::Slice(&param_0_slice, m::Parameter(0)),\n+                                 m::Slice(&param_1_slice_1, m::Parameter(1))),\n+                     m::Slice(&param_1_slice_2, m::Parameter(1))),\n+              m::Slice(&param_2_slice_2, m::Parameter(2))))));\n+  // The slices of param_1 and param_2 should be evaluated only once and\n+  // reused.\n+  EXPECT_EQ(param_1_slice_1, param_1_slice_2);\n+  EXPECT_EQ(param_2_slice_1, param_2_slice_2);\n+  auto check_slice_attributes = [](const HloInstruction* slice) {\n+    EXPECT_THAT(slice->slice_starts(), ElementsAre(0, 0));\n+    EXPECT_THAT(slice->slice_limits(), ElementsAre(2, 9));\n+    EXPECT_THAT(slice->slice_strides(), ElementsAre(1, 1));\n+  };\n+  check_slice_attributes(param_0_slice);\n+  check_slice_attributes(param_1_slice_1);\n+  check_slice_attributes(param_2_slice_1);\n }\n \n TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughAddIfElementTypesDoNotMatch) {\n@@ -180,5 +193,50 @@ TEST_F(SliceHoisterTest,\n   SCOPED_TRACE(module->ToString());\n   EXPECT_FALSE(changed);\n }\n+\n+// Dot is not an element-wise operation.\n+TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughDot) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      p0 = f32[8,10] parameter(0)\n+      p1 = f32[10,9] parameter(1)\n+      dot_op = f32[8,9] dot(p0, p1), lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] dot_op), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_FALSE(changed);\n+}\n+\n+// Negate is not a binary operation.\n+// TODO(b/434724820): Hoist slices through element-wise unary operations.\n+TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughNegate) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      p0 = f32[8,9] parameter(0)\n+      neg_op = f32[8,9] negate(p0)\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] neg_op), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_FALSE(changed);\n+}\n+\n }  // anonymous namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 140,
        "additions": 99,
        "deletions": 41
    }
}