{
    "author": "hyeontaek",
    "message": "[JAX] Use `PyUserContext` in IFRT objects in place of explicit `traceback` member\n\nThis change makes jaxlib use `xla::ifrt::PyUserContext` for all\n`xla::ifrt::Array` and `xla::ifrt::LoadedExecutable` objects, replacing the\nexplicit `traceback` member of `PyArray` and `PyLoadedExecutable`. This ensures\nthat `jax::Traceback` is accessible by both JAX- and IFRT-level code.\n\nUser-visible change: JAX array's `traceback` will return `None` instead of a\ntraceback object if the array has been deleted or donated.\n\nNote that several locations of setting up `xla::ifrt::PyUserContext` using\n`xla::ifrt::UserContextScope` have been updated from original\n`jax::Traceback::Get()` call locations.\n\n* `UserContextScope` is extended to cover IFRT operations.\n* `UserContextScope` is often moved to a call site so that the same scope can\nbe shared across multiple lower-level calls.\n\nThe coverage of `PyUserContext` propagation is verified with builds that\nenable `-DIFRT_REQUIRE_USER_CONTEXT`, which checks if\n`UserContextScope::current()` calls return any non-nullptr\n`UserContext.`\n\nPiperOrigin-RevId: 814076720",
    "sha": "b4c7a874cddd731c374c65cecf14116a7987b33a",
    "files": [
        {
            "sha": "e0bd46b2788165a0fcb0603ff1aa8693d14040a6",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD?ref=b4c7a874cddd731c374c65cecf14116a7987b33a",
            "patch": "@@ -74,6 +74,7 @@ cc_library(\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:attribute_map\",\n+        \"//xla/python/ifrt:user_context\",\n         \"//xla/python/ifrt/hlo:hlo_program\",\n         \"//xla/python/ifrt/ir\",\n         \"//xla/python/ifrt/ir:atom_program_compiler\","
        },
        {
            "sha": "fbd4f41c157e0f313f2c1dd4416bee12e2fd6372",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/ifrt_compile_atom_program_pass.cc",
            "status": "modified",
            "additions": 103,
            "deletions": 102,
            "changes": 205,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_compile_atom_program_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_compile_atom_program_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fifrt_compile_atom_program_pass.cc?ref=b4c7a874cddd731c374c65cecf14116a7987b33a",
            "patch": "@@ -45,6 +45,7 @@ limitations under the License.\n #include \"mlir/Pass/PassRegistry.h\"\n #include \"mlir/Support/LLVM.h\"\n #include \"mlir/Support/TypeID.h\"\n+#include \"mlir/Support/WalkResult.h\"\n #include \"shardy/dialect/sdy/ir/dialect.h\"\n #include \"stablehlo/dialect/StablehloOps.h\"\n #include \"xla/mlir_hlo/mhlo/IR/hlo_ops.h\"\n@@ -55,6 +56,7 @@ limitations under the License.\n #include \"xla/python/ifrt/ir/transforms/multi_threaded_atom_program_compiler.h\"\n #include \"xla/python/ifrt/ir/transforms/passes.h\"\n #include \"xla/python/ifrt/ir/transforms/utils.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/service/spmd/shardy/constants.h\"\n #include \"xla/service/spmd/shardy/utils.h\"\n@@ -76,7 +78,8 @@ class IfrtCompileAtomProgramPass\n       std::shared_ptr<AtomExecutableMap> atom_executable_map)\n       : atom_program_compiler_(std::move(compiler),\n                                std::move(compile_options_overrides), false),\n-        atom_executable_map_(std::move(atom_executable_map)) {}\n+        atom_executable_map_(std::move(atom_executable_map)),\n+        user_context_(UserContextScope::current()) {}\n \n   llvm::StringRef getArgument() const override {\n     return \"ifrt-compile-atom-program\";\n@@ -107,6 +110,9 @@ class IfrtCompileAtomProgramPass\n \n   // Map from symbol name of LoadedExecutableOp to LoadedExecutable.\n   std::shared_ptr<AtomExecutableMap> atom_executable_map_;\n+\n+  // User context to use for compilation.\n+  UserContextRef user_context_;\n };\n \n void IfrtCompileAtomProgramPass::runOnOperation() {\n@@ -127,118 +133,113 @@ void IfrtCompileAtomProgramPass::runOnOperation() {\n   llvm::MapVector<CallOp, std::string> call_op_to_error;\n \n   // Walk and dispatch the compilations in parallel.\n-  module_op.walk(\n-      [&](CallOp call_op) -> mlir::WalkResult {\n-        // Do not dispatch the atom program for compilation it has already been\n-        // dispatched.\n-        if (!call_to_compile_futures.contains(call_op)) {\n-          mlir::func::FuncOp callee = call_op.getCalleeOp(symbol_table);\n-          auto callee_module =\n-              llvm::dyn_cast<mlir::ModuleOp>(callee->getParentOp());\n-          if (callee.getSymName() != kCalleeMainFuncName ||\n-              callee_module == nullptr) {\n-            // No need to clone the call op because it won't be modified if\n-            // any error is encountered.\n-            call_op_to_error.try_emplace(\n-                call_op,\n-                absl::StrCat(\n-                    \"requires callee outlined as `\", kCalleeMainFuncName.str(),\n-                    \"` function in a ModuleOp. Actual callee name: \",\n-                    callee.getSymName().str(), \". Actual callee parent: \",\n-                    callee->getParentOp()->getName().getStringRef().str()));\n-            return mlir::WalkResult::advance();\n-          }\n+  module_op.walk([&](CallOp call_op) -> mlir::WalkResult {\n+    xla::ifrt::UserContextScope user_context_scope(user_context_);\n+    // Do not dispatch the atom program for compilation it has already been\n+    // dispatched.\n+    if (!call_to_compile_futures.contains(call_op)) {\n+      mlir::func::FuncOp callee = call_op.getCalleeOp(symbol_table);\n+      auto callee_module =\n+          llvm::dyn_cast<mlir::ModuleOp>(callee->getParentOp());\n+      if (callee.getSymName() != kCalleeMainFuncName ||\n+          callee_module == nullptr) {\n+        // No need to clone the call op because it won't be modified if\n+        // any error is encountered.\n+        call_op_to_error.try_emplace(\n+            call_op,\n+            absl::StrCat(\n+                \"requires callee outlined as `\", kCalleeMainFuncName.str(),\n+                \"` function in a ModuleOp. Actual callee name: \",\n+                callee.getSymName().str(), \". Actual callee parent: \",\n+                callee->getParentOp()->getName().getStringRef().str()));\n+        return mlir::WalkResult::advance();\n+      }\n \n-          // TODO(b/433244129) - remove after 6 months bwd compatibility window.\n-          if (sdy_meshes_round_trip_attr &&\n-              call_op->hasAttr(kIsSdyPartitioned)) {\n-            // Add the meshes roundtrip attribute to the callee module if the\n-            // atom program was partitioned with sdy.\n-            xla::sdy::setFrontendAttribute(callee_module,\n-                                           xla::sdy::kMeshesRoundTripAttr,\n-                                           sdy_meshes_round_trip_attr);\n-          }\n+      // TODO(b/433244129) - remove after 6 months bwd compatibility window.\n+      if (sdy_meshes_round_trip_attr && call_op->hasAttr(kIsSdyPartitioned)) {\n+        // Add the meshes roundtrip attribute to the callee module if the\n+        // atom program was partitioned with sdy.\n+        xla::sdy::setFrontendAttribute(callee_module,\n+                                       xla::sdy::kMeshesRoundTripAttr,\n+                                       sdy_meshes_round_trip_attr);\n+      }\n \n-          absl::StatusOr<CompileFuture> compile_future =\n-              atom_program_compiler_.CompileModule(call_op, callee_module);\n-          if (!compile_future.ok()) {\n-            call_op_to_error.try_emplace(\n-                call_op,\n-                absl::StrCat(\n-                    \"failed to dispatch compilation of atom executable: \",\n-                    compile_future.status().ToString()));\n-            return mlir::WalkResult::advance();\n-          }\n-          // Clone the CallOp because it will be modified later, but we want\n-          // to keep the original to be able to access the future.\n-          call_to_compile_futures[call_op.clone()] = *std::move(compile_future);\n-        }\n+      absl::StatusOr<CompileFuture> compile_future =\n+          atom_program_compiler_.CompileModule(call_op, callee_module);\n+      if (!compile_future.ok()) {\n+        call_op_to_error.try_emplace(\n+            call_op,\n+            absl::StrCat(\"failed to dispatch compilation of atom executable: \",\n+                         compile_future.status().ToString()));\n         return mlir::WalkResult::advance();\n-      });\n+      }\n+      // Clone the CallOp because it will be modified later, but we want\n+      // to keep the original to be able to access the future.\n+      call_to_compile_futures[call_op.clone()] = *std::move(compile_future);\n+    }\n+    return mlir::WalkResult::advance();\n+  });\n \n   if (call_op_to_error.empty()) {\n     // Map from the hash of the CallOp to the symbol ref of the\n     // LoadedExecutableOp.\n     llvm::DenseMap<CallOp, mlir::SymbolRefAttr, IfrtCallOpInfo>\n         call_op_to_loaded_exec_op_ref;\n     // Walk, wait on compilations, and generate LoadedExecutableOps.\n-    module_op.walk(\n-        [&](CallOp call_op) -> mlir::WalkResult {\n-          mlir::SymbolRefAttr loaded_exec_op_ref;\n-          if (auto loaded_exec_op_ref_it =\n-                  call_op_to_loaded_exec_op_ref.find(call_op);\n-              loaded_exec_op_ref_it != call_op_to_loaded_exec_op_ref.end()) {\n-            // Reuse the symbol ref to the LoadedExecutableOp if we've already\n-            // created an op for the CallOp.\n-            loaded_exec_op_ref = loaded_exec_op_ref_it->second;\n-          } else {\n-            auto compile_result = call_to_compile_futures[call_op].Await();\n-            if (!compile_result.ok()) {\n-              call_op_to_error.try_emplace(\n-                  call_op,\n-                  absl::StrCat(\n-                      \"failed to dispatch compilation of atom executable: \",\n-                      compile_result.status().ToString()));\n-              return mlir::WalkResult::advance();\n-            }\n-            auto callee_module = llvm::dyn_cast<mlir::ModuleOp>(\n-                call_op.getCalleeOp(symbol_table)->getParentOp());\n-            absl::StatusOr<mlir::SymbolRefAttr> symbol_ref =\n-                GenerateLoadedExecutableOp(callee_module, compile_result->name,\n-                                           call_op, builder);\n-            if (!symbol_ref.ok()) {\n-              call_op_to_error.try_emplace(\n-                  call_op,\n-                  absl::StrCat(\"failed to generate loaded executable op: \",\n-                               symbol_ref.status().ToString()));\n-              return mlir::WalkResult::advance();\n-            }\n-            loaded_exec_op_ref = *symbol_ref;\n-            // Clone the CallOp because it will be modified next, but we want to\n-            // keep the original to get the symbol ref for equal CallOps.\n-            call_op_to_loaded_exec_op_ref[call_op.clone()] = loaded_exec_op_ref;\n-            // Save the atom program executable to extend its lifetime.\n-            CHECK(atom_executable_map_\n-                      ->try_emplace(compile_result->name,\n-                                    std::move(compile_result->executable))\n-                      .second)\n-                << \"Failed to insert atom program executable to map. \"\n-                << \"Executable `\" << compile_result->name << \"` already exists\";\n-          }\n-\n-          // Generate CallLoadedExecutableOp.\n-          builder.setInsertionPointAfter(call_op);\n-          auto new_call = builder.create<CallLoadedExecutableOp>(\n-              call_op.getLoc(), call_op.getResultTypes(), call_op.getInputs(),\n-              call_op.getControlInputs(), call_op.getArgAttrsAttr(),\n-              call_op.getResAttrsAttr(), loaded_exec_op_ref,\n-              call_op.getIoAliases(), call_op.getDonatedInputIndices());\n-          new_call->setDiscardableAttrs(\n-              call_op->getDiscardableAttrDictionary());\n-          call_op.replaceAllUsesWith(new_call.getResults());\n-          call_op.erase();\n+    module_op.walk([&](CallOp call_op) -> mlir::WalkResult {\n+      mlir::SymbolRefAttr loaded_exec_op_ref;\n+      if (auto loaded_exec_op_ref_it =\n+              call_op_to_loaded_exec_op_ref.find(call_op);\n+          loaded_exec_op_ref_it != call_op_to_loaded_exec_op_ref.end()) {\n+        // Reuse the symbol ref to the LoadedExecutableOp if we've already\n+        // created an op for the CallOp.\n+        loaded_exec_op_ref = loaded_exec_op_ref_it->second;\n+      } else {\n+        auto compile_result = call_to_compile_futures[call_op].Await();\n+        if (!compile_result.ok()) {\n+          call_op_to_error.try_emplace(\n+              call_op,\n+              absl::StrCat(\n+                  \"failed to dispatch compilation of atom executable: \",\n+                  compile_result.status().ToString()));\n           return mlir::WalkResult::advance();\n-        });\n+        }\n+        auto callee_module = llvm::dyn_cast<mlir::ModuleOp>(\n+            call_op.getCalleeOp(symbol_table)->getParentOp());\n+        absl::StatusOr<mlir::SymbolRefAttr> symbol_ref =\n+            GenerateLoadedExecutableOp(callee_module, compile_result->name,\n+                                       call_op, builder);\n+        if (!symbol_ref.ok()) {\n+          call_op_to_error.try_emplace(\n+              call_op, absl::StrCat(\"failed to generate loaded executable op: \",\n+                                    symbol_ref.status().ToString()));\n+          return mlir::WalkResult::advance();\n+        }\n+        loaded_exec_op_ref = *symbol_ref;\n+        // Clone the CallOp because it will be modified next, but we want to\n+        // keep the original to get the symbol ref for equal CallOps.\n+        call_op_to_loaded_exec_op_ref[call_op.clone()] = loaded_exec_op_ref;\n+        // Save the atom program executable to extend its lifetime.\n+        CHECK(atom_executable_map_\n+                  ->try_emplace(compile_result->name,\n+                                std::move(compile_result->executable))\n+                  .second)\n+            << \"Failed to insert atom program executable to map. \"\n+            << \"Executable `\" << compile_result->name << \"` already exists\";\n+      }\n+\n+      // Generate CallLoadedExecutableOp.\n+      builder.setInsertionPointAfter(call_op);\n+      auto new_call = builder.create<CallLoadedExecutableOp>(\n+          call_op.getLoc(), call_op.getResultTypes(), call_op.getInputs(),\n+          call_op.getControlInputs(), call_op.getArgAttrsAttr(),\n+          call_op.getResAttrsAttr(), loaded_exec_op_ref, call_op.getIoAliases(),\n+          call_op.getDonatedInputIndices());\n+      new_call->setDiscardableAttrs(call_op->getDiscardableAttrDictionary());\n+      call_op.replaceAllUsesWith(new_call.getResults());\n+      call_op.erase();\n+      return mlir::WalkResult::advance();\n+    });\n     // Erase the CallOp clones that we're used as keys of the map.\n     for (auto& [call_op, loaded_exec_op_ref] : call_op_to_loaded_exec_op_ref) {\n       call_op.erase();"
        },
        {
            "sha": "244e6dc8fb8972f98bc733d46f80c81bb1d988c1",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/multi_threaded_atom_program_compiler.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc?ref=b4c7a874cddd731c374c65cecf14116a7987b33a",
            "patch": "@@ -46,6 +46,7 @@ limitations under the License.\n #include \"xla/python/ifrt/ir/ifrt_ops.h\"\n #include \"xla/python/ifrt/ir/transforms/utils.h\"\n #include \"xla/python/ifrt/shape.h\"\n+#include \"xla/python/ifrt/user_context.h\"\n #include \"xla/service/compilation_environments.h\"\n #include \"xla/service/computation_placer.h\"\n #include \"xla/service/hlo.pb.h\"\n@@ -204,7 +205,9 @@ absl::StatusOr<CompileFuture> MultiThreadedAtomProgramCompiler::CompileXla(\n   auto [promise, future] = CompileFuture::MakePromise();\n   ScheduleWork(thread_pool, [this, hlo_program = std::move(hlo_program),\n                              compile_options = std::move(compile_options),\n+                             user_context = UserContextScope::current(),\n                              promise = std::move(promise)]() mutable {\n+    UserContextScope user_context_scope(std::move(user_context));\n     promise.Set(compiler_->CompileXla(std::move(hlo_program),\n                                       std::move(compile_options)));\n   });"
        },
        {
            "sha": "046f28f5f396db5c718b7f24a1187236e6a7f4b8",
            "filename": "third_party/xla/xla/python/ifrt/user_context.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b4c7a874cddd731c374c65cecf14116a7987b33a/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fuser_context.cc?ref=b4c7a874cddd731c374c65cecf14116a7987b33a",
            "patch": "@@ -124,6 +124,9 @@ UserContextScope::~UserContextScope() {\n \n absl_nullable const UserContextRef& UserContextScope::current() {\n   if (current_context == nullptr) {\n+#ifdef IFRT_REQUIRE_USER_CONTEXT\n+    CHECK(false) << \"User context is required but not set\";\n+#endif\n     return *kNullContext;\n   }\n   return *current_context;"
        }
    ],
    "stats": {
        "total": 212,
        "additions": 110,
        "deletions": 102
    }
}