{
    "author": "tensorflower-gardener",
    "message": "Reverts a9e592c777ffcf06a4af8db98666a2f19949dcb9\n\nPiperOrigin-RevId: 840760379",
    "sha": "a6a3e9f37c4c18324785ac5f35222f93dfe4adaa",
    "files": [
        {
            "sha": "a6559d567dff6d436a6ce5f6d27021a56ee7c9d0",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=a6a3e9f37c4c18324785ac5f35222f93dfe4adaa",
            "patch": "@@ -1805,8 +1805,6 @@ cc_library(\n         \"@com_google_absl//absl/container:btree\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n-        \"@com_google_absl//absl/functional:any_invocable\",\n-        \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/memory\","
        },
        {
            "sha": "03e7f2f96239bb4c64257211dee35bbfc2a7e903",
            "filename": "third_party/xla/xla/service/buffer_assignment.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 71,
            "changes": 103,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc?ref=a6a3e9f37c4c18324785ac5f35222f93dfe4adaa",
            "patch": "@@ -34,8 +34,6 @@ limitations under the License.\n #include \"absl/container/btree_map.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n-#include \"absl/functional/any_invocable.h\"\n-#include \"absl/functional/bind_front.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/memory/memory.h\"\n@@ -82,45 +80,6 @@ using absl::StrAppendFormat;\n using memory_space_assignment::PresetAssignments;\n using ::tsl::strings::HumanReadableNumBytes;\n \n-std::optional<bool> CompareSize(\n-    absl::AnyInvocable<int64_t(const HloBuffer&)> size_of, const HloBuffer* a,\n-    const HloBuffer* b) {\n-  const int64_t a_size = size_of(*a);\n-  const int64_t b_size = size_of(*b);\n-  if (a_size != b_size) {\n-    return a_size > b_size;  // use \">\" for decreasing size.\n-  }\n-  return std::nullopt;\n-};\n-\n-std::optional<bool> CompareLiveOut(const HloAliasAnalysis* alias_analysis,\n-                                   const HloBuffer* a, const HloBuffer* b) {\n-  const bool a_live_out = alias_analysis->BufferLivesOut(*a);\n-  const bool b_live_out = alias_analysis->BufferLivesOut(*b);\n-  if (a_live_out != b_live_out) {\n-    return a_live_out;\n-  }\n-  return std::nullopt;\n-};\n-\n-std::optional<bool> ComparePosition(\n-    const absl::flat_hash_map<const HloInstruction*, int>* post_order_position,\n-    const HloBuffer* a, const HloBuffer* b) {\n-  auto compare = [post_order_position](const HloValue* value1,\n-                                       const HloValue* value2) {\n-    return post_order_position->at(value1->instruction()) <\n-           post_order_position->at(value2->instruction());\n-  };\n-  const HloValue* a_min = *absl::c_min_element(a->values(), compare);\n-  const HloValue* b_min = *absl::c_min_element(b->values(), compare);\n-  int a_position = post_order_position->at(a_min->instruction());\n-  int b_position = post_order_position->at(b_min->instruction());\n-  if (a_position != b_position) {\n-    return a_position < b_position;\n-  }\n-  return std::nullopt;\n-}\n-\n absl::flat_hash_map<int64_t, const HloInstruction*> BuildIdToHloInstructionMap(\n     const HloModule* module) {\n   // Build a map from a unique_id to corresponding HloInstruction in the module.\n@@ -1805,37 +1764,39 @@ absl::Status BufferAssigner::AssignBuffersForComputations(\n     }\n   }\n \n-  using Comparator = absl::AnyInvocable<std::optional<bool>(\n-      const HloBuffer* a, const HloBuffer* b)>;\n-  auto size_of = absl::bind_front(&BufferAssignment::HloBufferSize, assignment);\n-  Comparator compare_size = absl::bind_front(CompareSize, size_of);\n-  Comparator compare_live_out =\n-      absl::bind_front(CompareLiveOut, &alias_analysis);\n-  Comparator compare_position =\n-      absl::bind_front(ComparePosition, &post_order_position);\n-  std::vector<Comparator> comparators;\n-  switch (opts_.buffer_order) {\n-    case BufferOrder::kBiggestFirst:\n-      comparators.push_back(std::move(compare_size));\n-      comparators.push_back(std::move(compare_live_out));\n-      comparators.push_back(std::move(compare_position));\n-      break;\n-    case BufferOrder::kTopological:\n-      comparators.push_back(std::move(compare_position));\n-      comparators.push_back(std::move(compare_size));\n-      comparators.push_back(std::move(compare_live_out));\n-      break;\n-  }\n+  absl::c_sort(\n+      sorted_buffers, [&post_order_position, &alias_analysis, assignment](\n+                          const HloBuffer* a, const HloBuffer* b) {\n+        // Primary sort is by decreasing buffer size.\n+        const int64_t a_size = assignment->HloBufferSize(*a);\n+        const int64_t b_size = assignment->HloBufferSize(*b);\n+        if (a_size != b_size) {\n+          return a_size > b_size;  // use \">\" for decreasing size.\n+        }\n \n-  absl::c_sort(sorted_buffers,\n-               [&comparators](const HloBuffer* a, const HloBuffer* b) {\n-                 for (Comparator& c : comparators) {\n-                   if (std::optional<bool> lt = c(a, b); lt.has_value()) {\n-                     return *lt;\n-                   }\n-                 }\n-                 return a->id() < b->id();\n-               });\n+        const bool a_live_out = alias_analysis.BufferLivesOut(*a);\n+        const bool b_live_out = alias_analysis.BufferLivesOut(*b);\n+        if (a_live_out != b_live_out) {\n+          return a_live_out;\n+        }\n+        auto compare = [&post_order_position](const HloValue* value1,\n+                                              const HloValue* value2) {\n+          return post_order_position.at(value1->instruction()) <\n+                 post_order_position.at(value2->instruction());\n+        };\n+        const HloValue* a_min = *absl::c_min_element(a->values(), compare);\n+        const HloValue* b_min = *absl::c_min_element(b->values(), compare);\n+        if (post_order_position.at(a_min->instruction()) <\n+            post_order_position.at(b_min->instruction())) {\n+          return true;\n+        } else if (post_order_position.at(a_min->instruction()) >\n+                   post_order_position.at(b_min->instruction())) {\n+          return false;\n+        }\n+\n+        // Use buffer ids to break ties and ensure a stable ordering.\n+        return a->id() < b->id();\n+      });\n \n   std::vector<BufferAllocation::Index> allocation_indices;\n "
        },
        {
            "sha": "1b8e5b61cfa4d1ba7f8d4f03e0ded56a43204033",
            "filename": "third_party/xla/xla/service/buffer_assignment.h",
            "status": "modified",
            "additions": 0,
            "deletions": 8,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h?ref=a6a3e9f37c4c18324785ac5f35222f93dfe4adaa",
            "patch": "@@ -30,7 +30,6 @@ limitations under the License.\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n-#include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n@@ -720,12 +719,6 @@ class BufferAssigner {\n   using PrivateStacks = absl::flat_hash_map<BufferValue::Color,\n                                             std::vector<const HloComputation*>>;\n \n-  // The order in which to process buffers during buffer assignment.\n-  enum class BufferOrder {\n-    kBiggestFirst,  // Process the biggest buffers first.\n-    kTopological,   // Process buffers in topological order.\n-  };\n-\n   // Options for BufferAssigner::Run.\n   struct Options {\n     // If true, allocate buffers for constant instructions.\n@@ -748,7 +741,6 @@ class BufferAssigner {\n         heap_buffer_interval_compare;\n     std::optional<BufferAssignment::BufferIsolationOptions> isolation_options;\n     std::optional<BufferValue::Color> temp_buffer_color;\n-    BufferOrder buffer_order = BufferOrder::kBiggestFirst;\n   };\n \n   static Colorer DefaultColorer() {"
        },
        {
            "sha": "895657789c891fd6c840f80713447ab1d53702bd",
            "filename": "third_party/xla/xla/service/cpu/cpu_compiler.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 7,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6a3e9f37c4c18324785ac5f35222f93dfe4adaa/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc?ref=a6a3e9f37c4c18324785ac5f35222f93dfe4adaa",
            "patch": "@@ -2354,13 +2354,10 @@ CpuCompiler::CreateBufferAssignment(const HloModule& module) const {\n   AliasInfo alias_info;\n   BufferAssigner::Options opts;\n   opts.allocate_buffers_for_constants = true;\n-  opts.buffer_order = BufferAssigner::BufferOrder::kTopological;\n-  // We use a DependencyHloOrdering rather than a SequentialHloOrdering to\n-  // increase the amount of concurrency the program can execute with.\n-  return BufferAssigner::Run(&module,\n-                             std::make_unique<DependencyHloOrdering>(&module),\n-                             BufferSizeBytesFunction(), &alias_info,\n-                             memory_alignment, std::move(opts));\n+  return BufferAssigner::Run(\n+      &module, std::make_unique<SequentialHloOrdering>(module.schedule()),\n+      BufferSizeBytesFunction(), &alias_info, memory_alignment,\n+      std::move(opts));\n }\n \n }  // namespace cpu"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 36,
        "deletions": 88
    }
}