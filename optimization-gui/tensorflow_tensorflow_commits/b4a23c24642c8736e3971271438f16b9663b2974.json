{
    "author": "emilyfertig",
    "message": "[PJRT C API] Implement `xla::PjRtCrossHostSendCancelNotifier`.\n\nThis is part of the `MakeCrossHostReceiveBuffers`/`CopyToRemoteDevice` PJRT cross-host transfer API.\n\nPiperOrigin-RevId: 846355464",
    "sha": "b4a23c24642c8736e3971271438f16b9663b2974",
    "files": [
        {
            "sha": "50af005112244eb160390f379a73635f85a750ae",
            "filename": "third_party/xla/xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.cc",
            "status": "modified",
            "additions": 136,
            "deletions": 42,
            "changes": 178,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b4a23c24642c8736e3971271438f16b9663b2974/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b4a23c24642c8736e3971271438f16b9663b2974/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.cc?ref=b4a23c24642c8736e3971271438f16b9663b2974",
            "patch": "@@ -36,6 +36,97 @@ limitations under the License.\n #include \"xla/shape.h\"\n \n namespace pjrt {\n+namespace {\n+\n+// Nested callback functions for the C API version of\n+// xla::PjRtClient::MakeCrossHostReceiveBuffers.\n+using CrossHostRecvNotifierFunction = std::function<void(\n+    PJRT_Error* error, const char** serialized_descriptors,\n+    size_t* descriptors_sizes, size_t num_descriptors,\n+    PJRT_Transfers_CrossHostSendCancelNotifier cancel_notifier,\n+    void* cancel_notifier_user_arg)>;\n+using CrossHostSendCancelNotifierFunction = std::function<void(\n+    const char* serialized_descriptor, size_t serialized_descriptor_size,\n+    PJRT_Error_Code error_code, const char* error_message,\n+    size_t error_message_size,\n+    PJRT_Transfers_CrossHostOnCanceledCallback on_canceled,\n+    void* on_canceled_user_arg)>;\n+using CrossHostOnCanceledCallbackFunction =\n+    std::function<void(PJRT_Error* error)>;\n+\n+// Callback function for the C API version of\n+// xla::PjRtBuffer::CopyToRemoteDevice.\n+using RemoteSendCallbackFunction =\n+    std::function<void(PJRT_Error* error, bool sends_were_enqueued)>;\n+\n+xla::PjRtCrossHostRecvNotifier CCrossHostRecvNotifierToCpp(\n+    const PJRT_Transfers_CrossHostRecvNotifierInfo& c_notifier) {\n+  return [user_arg = c_notifier.user_arg, notifier = c_notifier.notifier](\n+             absl::StatusOr<xla::PjRtCrossHostRecvState> recv_state) {\n+    // Define the function to pass as `cancel_notifier_user_arg` to\n+    // `notifier`.\n+    auto cancel_notifier_function = new CrossHostSendCancelNotifierFunction(\n+        [cpp_cancel_notifier = std::move(recv_state->cancel_notifier)](\n+            const char* serialized_descriptor,\n+            size_t serialized_descriptor_size, PJRT_Error_Code error_code,\n+            const char* error_message, size_t error_message_size,\n+            PJRT_Transfers_CrossHostOnCanceledCallback on_canceled,\n+            void* on_canceled_user_arg) {\n+          std::string serialized_descriptor_str(serialized_descriptor,\n+                                                serialized_descriptor_size);\n+          std::string error_message_str(error_message, error_message_size);\n+          absl::Status state(pjrt::PjrtErrorCodeToStatusCode(error_code),\n+                             error_message_str);\n+          auto cpp_on_canceled = [user_arg = on_canceled_user_arg,\n+                                  on_canceled =\n+                                      on_canceled](absl::Status status) {\n+            auto error = new PJRT_Error{status};\n+            on_canceled(error, user_arg);\n+            delete error;\n+          };\n+          return cpp_cancel_notifier(std::move(serialized_descriptor_str),\n+                                     std::move(state),\n+                                     std::move(cpp_on_canceled));\n+        });\n+    PJRT_Transfers_CrossHostSendCancelNotifier cancel_notifier =\n+        [](const char* serialized_descriptor, size_t serialized_descriptor_size,\n+           PJRT_Error_Code error, const char* error_message,\n+           size_t error_message_size,\n+           PJRT_Transfers_CrossHostOnCanceledCallback on_canceled,\n+           void* on_canceled_user_arg, void* user_arg) {\n+          CrossHostSendCancelNotifierFunction* cancel_notifier_fn =\n+              reinterpret_cast<CrossHostSendCancelNotifierFunction*>(user_arg);\n+          (*cancel_notifier_fn)(serialized_descriptor,\n+                                serialized_descriptor_size, error,\n+                                error_message, error_message_size, on_canceled,\n+                                on_canceled_user_arg);\n+        };\n+    if (!recv_state.ok()) {\n+      auto error = new PJRT_Error{recv_state.status()};\n+      notifier(error, nullptr, nullptr, 0, user_arg, cancel_notifier,\n+               cancel_notifier_function);\n+      delete error;\n+      return;\n+    }\n+    // Convert serialized descriptors to char*.\n+    std::vector<xla::PjRtCrossHostRecvDescriptors>& descriptors =\n+        recv_state->descriptors;\n+    std::vector<size_t> descriptors_sizes;\n+    descriptors_sizes.reserve(descriptors.size());\n+    std::vector<const char*> serialized_descriptors;\n+    serialized_descriptors.reserve(descriptors.size());\n+    for (int i = 0; i < descriptors.size(); ++i) {\n+      serialized_descriptors.push_back(\n+          descriptors[i].serialized_descriptors.front().c_str());\n+      descriptors_sizes.push_back(\n+          descriptors[i].serialized_descriptors.front().size());\n+    }\n+    notifier(nullptr, serialized_descriptors.data(), descriptors_sizes.data(),\n+             descriptors.size(), user_arg, cancel_notifier,\n+             cancel_notifier_function);\n+  };\n+}\n+}  // namespace\n \n PJRT_Error* PJRT_Transfers_PJRT_Client_CrossHostReceiveBuffers(\n     PJRT_Transfers_PJRT_Client_CrossHostReceiveBuffers_Args* args) {\n@@ -106,41 +197,44 @@ PJRT_Error* PJRT_Transfers_PJRT_Client_CrossHostSendBuffers(\n   return nullptr;\n }\n \n-namespace {\n-static xla::PjRtCrossHostRecvNotifier CCrossHostRecvNotifierToCpp(\n-    const PJRT_Transfers_CrossHostRecvNotifierInfo& c_notifier) {\n-  return [user_arg = c_notifier.user_arg, notifier = c_notifier.notifier](\n-             absl::StatusOr<xla::PjRtCrossHostRecvState> recv_state) {\n-    if (!recv_state.ok()) {\n-      auto error = new PJRT_Error{recv_state.status()};\n-      notifier(error, nullptr, nullptr, 0, user_arg);\n-      return;\n-    }\n-    auto& descriptors = recv_state->descriptors;\n-    std::vector<size_t> descriptors_sizes;\n-    descriptors_sizes.reserve(descriptors.size());\n-    std::vector<const char*> serialized_descriptors;\n-    serialized_descriptors.reserve(descriptors.size());\n-    for (int i = 0; i < descriptors.size(); ++i) {\n-      serialized_descriptors.push_back(\n-          descriptors[i].serialized_descriptors.front().c_str());\n-      descriptors_sizes.push_back(\n-          descriptors[i].serialized_descriptors.front().size());\n-    }\n-    notifier(nullptr, serialized_descriptors.data(), descriptors_sizes.data(),\n-             descriptors.size(), user_arg);\n-  };\n-}\n-}  // namespace\n-\n PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n     const PJRT_Api* c_api, xla::PjRtCrossHostRecvNotifier cpp_notifier) {\n-  using CrossHostRecvNotifierFunction =\n-      std::function<void(PJRT_Error*, const char**, size_t*, size_t)>;\n   auto notifier_function = new CrossHostRecvNotifierFunction(\n       [cpp_notifier = std::move(cpp_notifier), c_api](\n           PJRT_Error* error, const char** serialized_descriptors,\n-          size_t* descriptors_sizes, size_t num_descriptors) {\n+          size_t* descriptors_sizes, size_t num_descriptors,\n+          PJRT_Transfers_CrossHostSendCancelNotifier cancel_notifier,\n+          void* cancel_notifier_user_arg) {\n+        xla::PjRtCrossHostSendCancelNotifier cpp_cancel_notifier =\n+            [user_arg = cancel_notifier_user_arg, notifier = cancel_notifier,\n+             c_api](absl::string_view serialized_descriptor,\n+                    absl::Status reason,\n+                    std::function<void(absl::Status)> on_canceled) {\n+              PJRT_Error_Code error_code =\n+                  pjrt::StatusCodeToPjrtErrorCode(reason.code());\n+              // Define the function to pass as `on_canceled_user_arg` to\n+              // the cancel notifier.\n+              auto on_canceled_function =\n+                  new CrossHostOnCanceledCallbackFunction(\n+                      [cpp_on_canceled = std::move(on_canceled),\n+                       c_api](PJRT_Error* error) {\n+                        absl::Status status =\n+                            ::pjrt::PjrtErrorToStatus(error, c_api);\n+                        cpp_on_canceled(status);\n+                      });\n+              PJRT_Transfers_CrossHostOnCanceledCallback on_canceled_callback =\n+                  [](PJRT_Error* error, void* user_arg) {\n+                    CrossHostOnCanceledCallbackFunction* on_canceled_fn =\n+                        reinterpret_cast<CrossHostOnCanceledCallbackFunction*>(\n+                            user_arg);\n+                    (*on_canceled_fn)(error);\n+                    delete on_canceled_fn;\n+                  };\n+              notifier(serialized_descriptor.data(),\n+                       serialized_descriptor.size(), error_code,\n+                       reason.message().data(), reason.message().size(),\n+                       on_canceled_callback, on_canceled_function, user_arg);\n+            };\n         if (error != nullptr) {\n           absl::Status state = ::pjrt::PjrtErrorToStatus(error, c_api);\n           return cpp_notifier(std::move(state));\n@@ -154,34 +248,34 @@ PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n           state.descriptors.push_back(std::move(descriptors));\n         }\n \n-        // TODO(emilyaf): Support cancellation.\n-        xla::PjRtCrossHostSendCancelNotifier cancel_notifier =\n-            [](absl::string_view, absl::Status,\n-               std::function<void(absl::Status)>) {\n-              LOG(FATAL) << \"MakeCrossHostReceiveBuffers: Cancellation is not \"\n-                            \"supported in PJRT C API.\";\n-            };\n-        state.cancel_notifier = cancel_notifier;\n+        state.cancel_notifier = cpp_cancel_notifier;\n         return cpp_notifier(std::move(state));\n       });\n   return PJRT_Transfers_CrossHostRecvNotifierInfo{\n       /*user_arg=*/notifier_function,\n       /*notifier=*/\n       [](PJRT_Error* error, const char** serialized_descriptors,\n-         size_t* descriptors_sizes, size_t num_descriptors, void* user_arg) {\n+         size_t* descriptors_sizes, size_t num_descriptors, void* user_arg,\n+         PJRT_Transfers_CrossHostSendCancelNotifier cancel_notifier,\n+         void* cancel_notifier_user_arg) {\n         CrossHostRecvNotifierFunction* notifier_fn =\n             reinterpret_cast<CrossHostRecvNotifierFunction*>(user_arg);\n         (*notifier_fn)(error, serialized_descriptors, descriptors_sizes,\n-                       num_descriptors);\n+                       num_descriptors, cancel_notifier,\n+                       cancel_notifier_user_arg);\n         delete notifier_fn;\n+        // The cancellation callback isn't always called, so instead of freeing\n+        // it after usage, we free it here after the notifier is called.\n+        CrossHostSendCancelNotifierFunction* cancel_notifier_fn =\n+            reinterpret_cast<CrossHostSendCancelNotifierFunction*>(\n+                cancel_notifier_user_arg);\n+        delete cancel_notifier_fn;\n       }};\n }\n \n PJRT_Transfers_CrossHostRemoteSendCallbackInfo\n CppCrossHostRemoteSendCallbackToC(\n     const PJRT_Api* c_api, xla::PjRtBuffer::RemoteSendCallback cpp_callback) {\n-  using RemoteSendCallbackFunction =\n-      std::function<void(PJRT_Error * error, bool sends_were_enqueued)>;\n   auto on_done_function = new RemoteSendCallbackFunction(\n       [cpp_callback = std::move(cpp_callback), c_api](\n           PJRT_Error* error, bool sends_were_enqueued) {"
        },
        {
            "sha": "98dff8fe57ebba7b84cbcb8a212a08f8631c82ec",
            "filename": "third_party/xla/xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.h",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b4a23c24642c8736e3971271438f16b9663b2974/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b4a23c24642c8736e3971271438f16b9663b2974/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.h?ref=b4a23c24642c8736e3971271438f16b9663b2974",
            "patch": "@@ -35,7 +35,7 @@ extern \"C\" {\n // CrossHostSendBuffers and CrossHostReceiveBuffers. These methods allow PjRt\n // clients to implement various optimizations for cross-host transfers.\n \n-#define PJRT_API_CROSS_HOST_TRANSFERS_EXTENSION_VERSION 3\n+#define PJRT_API_CROSS_HOST_TRANSFERS_EXTENSION_VERSION 4\n \n // ---------------------------------- Methods ----------------------------------\n \n@@ -83,9 +83,21 @@ typedef PJRT_Error* PJRT_Transfers_PJRT_Client_CrossHostReceiveBuffers(\n \n // The structs and methods below correspond to the original cross-host transfers\n // API.\n+typedef void (*PJRT_Transfers_CrossHostOnCanceledCallback)(PJRT_Error* error,\n+                                                           void* user_arg);\n+\n+typedef void (*PJRT_Transfers_CrossHostSendCancelNotifier)(\n+    const char* serialized_descriptor, size_t serialized_descriptor_size,\n+    PJRT_Error_Code reason, const char* error_message,\n+    size_t error_message_size,\n+    PJRT_Transfers_CrossHostOnCanceledCallback on_canceled,\n+    void* on_canceled_user_arg, void* user_arg);\n+\n typedef void (*PJRT_Transfers_CrossHostRecvNotifier)(\n     PJRT_Error* error, const char** serialized_descriptors,\n-    size_t* descriptors_sizes, size_t num_descriptors, void* user_arg);\n+    size_t* descriptors_sizes, size_t num_descriptors, void* user_arg,\n+    PJRT_Transfers_CrossHostSendCancelNotifier cancel_notifier,\n+    void* cancel_notifier_user_arg);\n \n struct PJRT_Transfers_CrossHostRecvNotifierInfo {\n   void* user_arg;"
        }
    ],
    "stats": {
        "total": 194,
        "additions": 150,
        "deletions": 44
    }
}