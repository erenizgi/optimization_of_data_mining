{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Move PjRtFuture from XLA to tsl::Future\n\nPiperOrigin-RevId: 811110940",
    "sha": "d995c59067ab2f92a71f191c37cef5b02d837ede",
    "files": [
        {
            "sha": "609312d7100ec57ea8c30f8d1e0d4f247a52fa12",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=d995c59067ab2f92a71f191c37cef5b02d837ede",
            "patch": "@@ -126,6 +126,40 @@ tsl_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"future\",\n+    srcs = [\"future.cc\"],\n+    hdrs = [\"future.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    deps = [\n+        \":async_value\",\n+        \":ref_count\",\n+        \"//xla/tsl/platform:logging\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/meta:type_traits\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_absl//absl/utility\",\n+    ],\n+)\n+\n+tsl_cc_test(\n+    name = \"future_test\",\n+    srcs = [\"future_test.cc\"],\n+    deps = [\n+        \":future\",\n+        \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/platform:test_benchmark\",\n+        \"//xla/tsl/platform:test_main\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+    ],\n+)\n+\n cc_library(\n     name = \"ref_count\",\n     hdrs = [\"ref_count.h\"],"
        },
        {
            "sha": "e194bea351414c3a093f1e307005e1e3c83186ff",
            "filename": "third_party/xla/xla/tsl/concurrency/future.cc",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.cc?ref=d995c59067ab2f92a71f191c37cef5b02d837ede",
            "patch": "@@ -0,0 +1,96 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tsl/concurrency/future.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <memory>\n+#include <tuple>\n+#include <utility>\n+\n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/base/optimization.h\"\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/tsl/concurrency/async_value_ref.h\"\n+\n+namespace tsl {\n+\n+// Construct an immediately ready promise in the static storage. This avoids\n+// heap allocation and reference counting operations on a hot path.\n+static tsl::internal::AsyncValueStorage<absl::Status> ready_promise_storage;\n+absl::NoDestructor<tsl::AsyncValueOwningRef<absl::Status>>\n+    Future<>::ready_promise_(\n+        tsl::MakeAvailableAsyncValueRef<absl::Status>(ready_promise_storage));\n+\n+namespace {\n+struct State {\n+  explicit State(int32_t size) : pending_count(size) {\n+    std::tie(promise, future) = Future<>::MakePromise();\n+  }\n+\n+  std::atomic<int32_t> pending_count;\n+  Future<>::Promise promise;\n+  Future<> future;\n+\n+  absl::Mutex mu;\n+  absl::Status status ABSL_GUARDED_BY(&mu);\n+};\n+}  // namespace\n+\n+Future<> JoinFutures(absl::Span<const Future<>> futures) {\n+  VLOG(2) << \"xla::JoinFutures: \" << futures.size() << \" futures\";\n+  if (futures.empty()) {\n+    return Future<>(absl::OkStatus());\n+  }\n+  if (futures.size() == 1) {\n+    return futures.front();\n+  }\n+\n+  auto state = std::make_shared<State>(futures.size());\n+\n+  for (const Future<>& future : futures) {\n+    future.OnReady([state](absl::Status status) {\n+      if (ABSL_PREDICT_FALSE(!status.ok())) {\n+        absl::MutexLock lock(&state->mu);\n+        if (VLOG_IS_ON(2)) {\n+          if (!state->status.ok() && status.code() != state->status.code()) {\n+            VLOG(2) << \"Ignoring status \" << status\n+                    << \" because first error was \" << state->status;\n+          }\n+        }\n+        state->status.Update(status);\n+      }\n+\n+      int32_t pending_count =\n+          state->pending_count.fetch_sub(1, std::memory_order_acq_rel);\n+      CHECK_GE(pending_count, 1) << \"Pending count can't drop below 0\";\n+\n+      if (pending_count == 1) {\n+        absl::MutexLock lock(&state->mu);\n+        state->promise.Set(std::move(state->status));\n+      }\n+    });\n+  }\n+\n+  return std::move(state->future);\n+}\n+\n+}  // namespace tsl"
        },
        {
            "sha": "dab68855f9b2b105afdcdc8162d6912378944690",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "added",
            "additions": 918,
            "deletions": 0,
            "changes": 918,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=d995c59067ab2f92a71f191c37cef5b02d837ede",
            "patch": "@@ -0,0 +1,918 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TSL_CONCURRENCY_FUTURE_H_\n+#define XLA_TSL_CONCURRENCY_FUTURE_H_\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <functional>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/base/optimization.h\"\n+#include \"absl/meta/type_traits.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/types/span.h\"\n+#include \"absl/utility/utility.h\"\n+#include \"xla/tsl/concurrency/async_value.h\"\n+#include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/platform/logging.h\"\n+\n+namespace tsl {\n+\n+// A Future<T> is a container for an asynchronous value of type T with value\n+// semantics. This is alternative to AsyncValueRef<T> which has a smart-pointer\n+// semantics.\n+//\n+// Key differences between Future<t> and AsyncValueRef<T>:\n+//\n+// 1. Reading and writing asynchronous value is split between Future<T> and\n+//    Promise<T>.\n+//\n+// 2. Promise<T> is a move-only type, and prevents accidentally setting the\n+//    value more than once through different copies of the Promise object.\n+//\n+// 3. Future<T> of move-only type `T` is also a move-only type, and it's\n+//    possible to safely move the value out of the future object once. This is\n+//    impossible to check at compile time with AsyncValueRef<T>.\n+//\n+// 4. Future<> is a stateless type that can be used to represent a Future that\n+//    doesn't have a value type, and is used to signal an event completion.\n+template <class T = void>\n+class Future;\n+\n+// Returns a `Future` that will be successful if all `futures` complete\n+// successfully, or return a first encountered error.\n+Future<> JoinFutures(absl::Span<const Future<>> futures);\n+\n+// Helpers for using Futures.\n+class FutureHelpers {\n+ public:\n+  // Keys that are returned by an implementation-specific handler when a client\n+  // starts to block on a promise.\n+  //\n+  // For now, contains a single UID that can be used to identify a TraceMe, but\n+  // made extensible to allow support for other profilers such as endoscope.\n+  struct ProfilingKeys {\n+    uint64_t traceme_context_id = -1;\n+  };\n+\n+  // Signature of handler called by the Future class before it starts to\n+  // block a thread.\n+  using OnBlockStart = std::function<ProfilingKeys()>;\n+\n+  // Signature of handler called by the Future class after it finishes\n+  // blocking a thread.\n+  using OnBlockEnd = std::function<void(ProfilingKeys)>;\n+\n+  // Returns a Future<T> with optionally updated profiling handlers. If\n+  // profiling handlers are not provided, the original ones will be used.\n+  template <typename T>\n+  static Future<T> WithProfiling(Future<T> future,\n+                                 OnBlockStart on_block_start = nullptr,\n+                                 OnBlockEnd on_block_end = nullptr) {\n+    return Future<T>(std::move(future.promise_),\n+                     on_block_start ? std::move(on_block_start)\n+                                    : std::move(future.on_block_start_),\n+                     on_block_end ? std::move(on_block_end)\n+                                  : std::move(future.on_block_end_));\n+  }\n+};\n+\n+namespace internal {\n+\n+// A base class to conditionally disable copy constructor and assignment for a\n+// Future<T> (by default we always disable copy constructor when `T` is not\n+// copyable), which makes Future<T> an `std::unique_ptr`-like container for\n+// move-only types.\n+template <bool is_move_only>\n+class FutureMoveControl;\n+\n+template <>\n+class FutureMoveControl</*is_move_only=*/true> {\n+ protected:\n+  FutureMoveControl() = default;\n+\n+  FutureMoveControl(const FutureMoveControl&) = delete;\n+  FutureMoveControl& operator=(const FutureMoveControl&) = delete;\n+\n+  FutureMoveControl(FutureMoveControl&&) = default;\n+  FutureMoveControl& operator=(FutureMoveControl&&) = default;\n+};\n+\n+template <>\n+class FutureMoveControl</*is_move_only=*/false> {\n+ protected:\n+  FutureMoveControl() = default;\n+\n+  FutureMoveControl(const FutureMoveControl&) = default;\n+  FutureMoveControl& operator=(const FutureMoveControl&) = default;\n+\n+  FutureMoveControl(FutureMoveControl&&) = default;\n+  FutureMoveControl& operator=(FutureMoveControl&&) = default;\n+};\n+\n+// A base class for a stateful future Future<T> and a stateless future Future<>.\n+// If `is_move_only` is true, Future derived from this class acts as a move-only\n+// type and the value can be passed to the caller only using move assignment\n+// (applied to Await and OnReady APIs).\n+template <typename T, bool is_move_only = !std::is_copy_constructible_v<T>>\n+class FutureBase : public FutureMoveControl<is_move_only> {\n+ protected:\n+  // A protected constructor that hides AsyncValueRef implementation detail\n+  // from the end users of Future and Promise. Must not be made public!\n+  FutureBase(tsl::AsyncValueRef<T> promise,\n+             FutureHelpers::OnBlockStart on_block_start,\n+             FutureHelpers::OnBlockEnd on_block_end)\n+      : promise_(std::move(promise)),\n+        on_block_start_(std::move(on_block_start)),\n+        on_block_end_(std::move(on_block_end)) {}\n+\n+ public:\n+  FutureBase() = default;\n+\n+  // Constructor for an already-available Future.\n+  //\n+  // Typically used to eagerly return error values when async work will not\n+  // be enqueued, e.g., due to invalid arguments.\n+  explicit FutureBase(T t, FutureHelpers::OnBlockStart on_block_start = nullptr,\n+                      FutureHelpers::OnBlockEnd on_block_end = nullptr)\n+      : FutureBase(tsl::MakeAvailableAsyncValueRef<T>(std::move(t)),\n+                   std::move(on_block_start), std::move(on_block_end)) {}\n+\n+  bool IsValid() const { return promise_ != nullptr; }\n+\n+  // Two functions exist to know whether the future is ready, to accommodate\n+  // the fact some backends (e.g. distributed ones) could take a non-trivial\n+  // time to check the state of a future.\n+  //\n+  // `IsReady()` is guaranteed to return true if the future became ready\n+  // before `IsReady()` was called. `IsReady()` will return immediately if a\n+  // call to `Await()` has already returned, or any callback passed to\n+  // `OnReady` has already been triggered. Otherwise IsReady() may block for\n+  // the duration of a network message on some backends.\n+  bool IsReady() const {\n+    CHECK(IsValid());\n+    return promise_.IsAvailable();\n+  }\n+  // `IsKnownReady()` is guaranteed to return immediately. `IsKnownReady()` will\n+  // always return true if a call to `Await()` has already returned, or any\n+  // callback passed to `OnReady` has already been triggered. Otherwise,\n+  // `IsKnownReady()` may return false in some cases in which the future was\n+  // ready before `IsKnownReady()` was called.\n+  bool IsKnownReady() const {\n+    CHECK(IsValid());\n+    return promise_.IsAvailable();\n+  }\n+\n+  explicit operator bool() const { return static_cast<bool>(promise_); }\n+\n+  // Returns a pointer to the underlying AsyncValue that can be used to\n+  // track completion of a future. It is undefined behavior to access the\n+  // value stored in the AsyncValue.\n+  tsl::AsyncValue* async_value() const { return promise_.GetAsyncValue(); }\n+\n+ protected:\n+  static constexpr bool IsMoveOnly() { return is_move_only; }\n+\n+  // Future<T>::Promise provides a facility to store a value or an error\n+  // that is later acquired asynchronously via a Future<T> constructed from\n+  // the promise object. Note that the promise object is meant to be used only\n+  // once (set value or error).\n+  class Promise {\n+   public:\n+    Promise() = default;\n+\n+    Promise(Promise&& other) = default;\n+    Promise& operator=(Promise&& other) = default;\n+\n+    explicit operator bool() const { return static_cast<bool>(promise_); }\n+\n+    // Returns if this promise is the unique reference to the underlying value.\n+    // That is, this method returns true only if all of the following conditions\n+    // are satisfied:\n+    //\n+    // - The promise is the only reference to the underlying value, i.e., there\n+    //   are no other promises or futures associated with this value.\n+    // - There are no OnReady callbacks registered to this promise.\n+    //\n+    // This may be used by the caller of `Set()` to short-circuit the work to\n+    // fulfill the promise if no one will ever consume the value. Even in that\n+    // case, consider fulfilling the promise with an error (e.g., `CANCELLED`)\n+    // instead of dropping the promise without fulfilling it in order to make\n+    // debugging easier. Also, be aware that the current promise may still be\n+    // used to mint a future.\n+    bool IsUniqueReference() const {\n+      return promise_.IsUnique() && !promise_.HasWaiter();\n+    }\n+\n+   protected:\n+    explicit Promise(tsl::AsyncValueRef<T> promise)\n+        : promise_(std::move(promise)) {}\n+\n+    template <typename... Args>\n+    void emplace(Args&&... args) const {\n+      DCHECK(promise_) << \"Promise must wrap an async value\";\n+      promise_.template emplace<Args...>(std::forward<Args>(args)...);\n+    }\n+\n+    // Takes a reference to the underlying AsyncValueRef container.\n+    tsl::AsyncValueRef<T> ref() const { return promise_; }\n+\n+   private:\n+    tsl::AsyncValueRef<T> promise_;\n+  };\n+\n+  class ProfilingCleanup {\n+   public:\n+    ProfilingCleanup(const FutureBase* parent,\n+                     FutureHelpers::ProfilingKeys keys)\n+        : parent_(parent), keys_(std::move(keys)) {}\n+    ~ProfilingCleanup() {\n+      if (parent_ && parent_->on_block_end_) {\n+        parent_->on_block_end_(std::move(keys_));\n+      }\n+    }\n+    ProfilingCleanup(const ProfilingCleanup& other) = delete;\n+    ProfilingCleanup(ProfilingCleanup&& other) = delete;\n+\n+   private:\n+    const FutureBase* parent_;\n+    FutureHelpers::ProfilingKeys keys_;\n+  };\n+\n+  ProfilingCleanup OnBlockStartScope() const {\n+    return ProfilingCleanup(this, on_block_start_\n+                                      ? on_block_start_()\n+                                      : FutureHelpers::ProfilingKeys());\n+  }\n+\n+  // Calls block_until_ready_fn to wait until the underlying AsyncValue is\n+  // concrete. block_until_ready_fn should be equivalent to\n+  // tsl::BlockUntilReady.\n+  template <typename Fn>\n+  void BlockUntilReady(Fn&& block_until_ready_fn) const {\n+    CHECK(IsValid());\n+    if (!promise_.IsAvailable()) {\n+      ProfilingCleanup scope = OnBlockStartScope();\n+      block_until_ready_fn(promise_.GetAsyncValue());\n+    }\n+    DCHECK(promise_.IsConcrete());\n+  }\n+\n+  // Blocks the calling thread until the future is ready, then returns the\n+  // final value.\n+  const T& Await() const& {\n+    BlockUntilReady(\n+        static_cast<void (*)(tsl::AsyncValue*)>(tsl::BlockUntilReady));\n+    return *promise_;\n+  }\n+\n+  // Blocks the calling thread until the future is ready, then returns the\n+  // final value.\n+  std::conditional_t<is_move_only, T, const T&> Await() && {\n+    BlockUntilReady(\n+        static_cast<void (*)(tsl::AsyncValue*)>(tsl::BlockUntilReady));\n+\n+    if constexpr (is_move_only) {\n+      return std::move(*promise_);\n+    } else {\n+      // We can't move from the promise to the caller because for copyable\n+      // futures we can have multiple copies of the Future sharing the\n+      // same underlying promise object.\n+      return *promise_;\n+    }\n+  }\n+\n+  // Returns a Future<> that becomes ready when *this is ready. If *this\n+  // completes with an error, the returned future will also be an error.\n+  //\n+  // This function defined out of line as it requires Future<> definition.\n+  Future<> GetReadyFuture() const;\n+\n+  // Registers callback to be called once the promise is ready, with the final\n+  // value.\n+  //\n+  // callback may be called on an internal system thread or the calling thread.\n+  // The client should avoid any potentially re-entrant API calls within the\n+  // callback, for example by using the callback to enqueue work on a\n+  // client-owned threadpool.\n+  template <typename F,\n+            std::enable_if_t<!is_move_only &&\n+                             std::is_invocable_v<F, const T&>>* = nullptr>\n+  void OnReady(F&& f) const& {\n+    CHECK(IsValid());\n+    promise_.AndThen(\n+        [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n+          DCHECK(promise.IsConcrete());\n+          f(*promise);\n+        });\n+  }\n+\n+  // Registers callback to be called once the promise is ready, with the final\n+  // value.\n+  //\n+  // callback may be called on an internal system thread or the calling thread.\n+  // The client should avoid any potentially re-entrant API calls within the\n+  // callback, for example by using the callback to enqueue work on a\n+  // client-owned threadpool.\n+  template <typename F,\n+            std::enable_if_t<is_move_only ? std::is_invocable_v<F, T>\n+                                          : std::is_invocable_v<F, const T&>>* =\n+                nullptr>\n+  void OnReady(F&& f) && {\n+    CHECK(IsValid());\n+    promise_.AndThen(\n+        [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n+          DCHECK(promise.IsConcrete());\n+          if constexpr (is_move_only) {\n+            f(std::move(*promise));\n+          } else {\n+            // We can't move from the promise to the caller because for copyable\n+            // futures we can have multiple copies of the Future sharing the\n+            // same underlying promise object.\n+            f(*promise);\n+          }\n+        });\n+  }\n+\n+ protected:\n+  // Returns a placeholder error that can be used when short-circuiting promises\n+  // with no other references.\n+  static absl::Status AbortedError() {\n+    return absl::AbortedError(\n+        \"Fulfilling the promise with an aborted error since the value is no \"\n+        \"longer referenced by any futures or OnReady callbacks; if this error \"\n+        \"is exposed to any future, that indicates a bug\");\n+  }\n+\n+ private:\n+  friend class tsl::FutureHelpers;\n+\n+  tsl::AsyncValueRef<T> promise_;\n+\n+  // Function that is called before a thread starts blocking on the promise.\n+  FutureHelpers::OnBlockStart on_block_start_;\n+  // Function that is called after a thread finishes blocking on the promise.\n+  FutureHelpers::OnBlockEnd on_block_end_;\n+};\n+\n+}  // namespace internal\n+\n+// Future<T> is a simple future that is returned by  APIs that enqueue\n+// asynchronous work, reporting a value of type T when the work is complete.\n+//\n+// Future can be used by the client to wait for work to complete, either via\n+// a blocking call or a callback.\n+//\n+// The implementation wraps a AsyncValueRef<T>, but in contrast to AsyncValueRef\n+// which has a smart-pointer semantics, future has a value semantics, i.e.\n+// future of a move-only type also is a move-only type. You can think of a\n+// move-only future as a box to pass a value of type `T` between asynchronous\n+// producer/consumer: you can open the box once to put the value into it and you\n+// can open the box only once to take the value out of it. For copyable types\n+// Future<T> is a copyable type, although all copies share the same underlying\n+// async value.\n+template <class T>\n+class Future : public internal::FutureBase<absl::StatusOr<T>> {\n+  using Base = internal::FutureBase<absl::StatusOr<T>>;\n+\n+  static constexpr bool is_move_only = Base::IsMoveOnly();  // NOLINT\n+\n+  template <typename U>\n+  static constexpr bool is_status_or =  // NOLINT\n+      tsl::internal::is_status_or_v<U>;\n+\n+  static_assert(!std::is_same_v<T, absl::Status>,\n+                \"Use Future<> specialization for stateless futures\");\n+\n+  static_assert(\n+      !internal::IsStatusOr<T>::value,\n+      \"Future<T> already has an implicit absl::StatusOr<T> semantics\");\n+\n+ public:\n+  Future() = default;\n+\n+  // Constructs an immediately available future with the given value.\n+  explicit Future(absl::StatusOr<T> value) : Base(std::move(value)) {}\n+\n+  // Constructs and immediately available future from the given value.\n+  template <typename U,\n+            std::enable_if_t<std::is_constructible_v<T, U>>* = nullptr>\n+  explicit Future(U value) : Base(std::forward<U>(value)) {}\n+\n+  class Promise : public Base::Promise {\n+   public:\n+    using Base::Promise::Promise;\n+\n+    // Sets the value of the promise. Must be called at most once.\n+    //\n+    // After Set is called, value will be delivered to waiters on the Future\n+    // constructed from a promise, via blocking or callbacks.\n+    void Set(absl::StatusOr<T> value) {\n+      Base::Promise::emplace(std::move(value));\n+    }\n+\n+    // A helper function to convert move-only Promise to shared_ptr, which is\n+    // useful when the promise has to be captured by a std::function.\n+    std::shared_ptr<Promise> ToShared() && {\n+      return std::make_shared<Promise>(std::move(*this));\n+    }\n+\n+    // Returns a future associated with the promise. We use a trick we an extra\n+    // template parameter to disable converting promise to future for move-only\n+    // types, as it is illegal to create multiple move-only futures sharing the\n+    // underlying async value storage. For move-only types, the only way to\n+    // create a future is to call `MakePromise`.\n+    template <typename U = void,\n+              std::enable_if_t<!is_move_only && std::is_void_v<U>>* = nullptr>\n+    Future<T> future(FutureHelpers::OnBlockStart on_block_start = nullptr,\n+                     FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n+      return Future<T>(*this, std::move(on_block_start),\n+                       std::move(on_block_end));\n+    }\n+\n+   private:\n+    template <typename>\n+    friend class Future;\n+  };\n+\n+  // Returns a pair of connected Promise and Future<T>. Setting the returned\n+  // promise will fulfill the connected future.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  static std::pair<Promise, Future<T>> MakePromise(\n+      FutureHelpers::OnBlockStart on_block_start = nullptr,\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n+    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n+    Future<T> future(promise, std::move(on_block_start),\n+                     std::move(on_block_end));\n+    return std::make_pair(std::move(promise), std::move(future));\n+  }\n+\n+  using Base::Await;\n+  using Base::GetReadyFuture;\n+  using Base::OnReady;\n+\n+  // Returns an Future<R> that is constructed from the result of invoking\n+  // functor `f` with *this value. If *this completes with an error, returned\n+  // future will also be an error.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage:\n+  //\n+  // future.Map<R>([](const T& value) -> U {\n+  //   return U(value); // R must be constructible from U\n+  // })\n+  //\n+  template <typename R, typename F,\n+            typename U = std::invoke_result_t<F, const T&>,\n+            std::enable_if_t<!is_move_only && std::is_constructible_v<R, U>>* =\n+                nullptr>\n+  Future<R> Map(F&& f) const& {\n+    auto [promise, future] = Future<R>::MakePromise();\n+\n+    using Value = const absl::StatusOr<T>&;\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n+        promise.emplace(absl::in_place_t{}, f(*value));\n+      } else {\n+        promise.Set(value.status());\n+      }\n+    });\n+\n+    return std::move(future);\n+  }\n+\n+  // Returns an Future<R> that is constructed from the result of invoking\n+  // functor `f` with *this value. If *this completes with an error, returned\n+  // future will also be an error.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage: move-only type T passed by value\n+  //\n+  // std::move(future).Map<R>([](T value) -> U {\n+  //   return U(std::move(value)); // R must be constructible from U\n+  // })\n+  //\n+  template <typename R, typename F,\n+            typename U = std::invoke_result_t<\n+                F, std::conditional_t<is_move_only, T, const T&>>,\n+            std::enable_if_t<std::is_constructible_v<R, U>>* = nullptr>\n+  Future<R> Map(F&& f) && {\n+    auto [promise, future] = Future<R>::MakePromise();\n+\n+    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n+                                     const absl::StatusOr<T>&>;\n+    std::move(*this).OnReady([promise = std::move(promise),\n+                              f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n+        if constexpr (is_move_only) {\n+          promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n+        } else {\n+          promise.emplace(absl::in_place_t{}, f(*value));\n+        }\n+      } else {\n+        promise.Set(value.status());\n+      }\n+    });\n+\n+    return std::move(future);\n+  }\n+\n+  // Returns an Future<R> that is constructed from the result of invoking\n+  // functor `f` with *this value. If *this completes with an error, returned\n+  // future will also be an error. Functor `f` must return a value of type\n+  // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n+  // is automatically unwrapped and returned as a future payload.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage:\n+  //\n+  // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n+  //   return U(value); // R must be constructible from U\n+  // })\n+  //\n+  template <\n+      typename R, typename F, typename U = std::invoke_result_t<F, const T&>,\n+      std::enable_if_t<!is_move_only && is_status_or<U> &&\n+                       std::is_constructible_v<R, typename U::value_type>>* =\n+          nullptr>\n+  Future<R> TryMap(F&& f) const& {\n+    auto [promise, future] = Future<R>::MakePromise();\n+\n+    using Value = const absl::StatusOr<T>&;\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n+        auto result = f(*value);\n+        if (ABSL_PREDICT_TRUE(result.ok())) {\n+          promise.emplace(absl::in_place_t{}, *std::move(result));\n+        } else {\n+          promise.Set(std::move(result).status());\n+        }\n+      } else {\n+        promise.Set(value.status());\n+      }\n+    });\n+\n+    return std::move(future);\n+  }\n+\n+  // Returns an Future<R> that is constructed from the result of invoking\n+  // functor `f` with *this value. If *this completes with an error, returned\n+  // future will also be an error. Functor `f` must return a value of type\n+  // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n+  // is automatically unwrapped and returned as a future payload.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage: move-only type T passed by rvalue\n+  //\n+  // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n+  //   return U(value); // R must be constructible from U\n+  // })\n+  //\n+  template <typename R, typename F,\n+            typename U = std::invoke_result_t<\n+                F, std::conditional_t<is_move_only, T, const T&>>,\n+            std::enable_if_t<\n+                is_status_or<U> &&\n+                std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n+  Future<R> TryMap(F&& f) && {\n+    auto [promise, future] = Future<R>::MakePromise();\n+\n+    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n+                                     const absl::StatusOr<T>&>;\n+    std::move(*this).OnReady([promise = std::move(promise),\n+                              f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n+        auto result = [&] {\n+          if constexpr (is_move_only) {\n+            return f(std::move(*value));\n+          } else {\n+            return f(*value);\n+          }\n+        }();\n+        if (ABSL_PREDICT_TRUE(result.ok())) {\n+          promise.emplace(absl::in_place_t{}, *std::move(result));\n+        } else {\n+          promise.Set(std::move(result).status());\n+        }\n+      } else {\n+        promise.Set(value.status());\n+      }\n+    });\n+\n+    return std::move(future);\n+  }\n+\n+  // A `Map` overload that automatically infers the type of result from `f`.\n+  template <typename F, typename R = std::invoke_result_t<F, const T&>>\n+  Future<R> Map(F&& f) const& {\n+    return Map<R>(std::forward<F>(f));\n+  }\n+\n+  // A `Map` overload that automatically infers the type of result from `f`.\n+  template <typename F, typename R = std::invoke_result_t<\n+                            F, std::conditional_t<is_move_only, T, const T&>>>\n+  Future<R> Map(F&& f) && {\n+    return std::move(*this).template Map<R>(std::forward<F>(f));\n+  }\n+\n+  // A `TryMap` overload that automatically infers the type of result from `f`.\n+  template <typename F, typename R = std::invoke_result_t<F, const T&>,\n+            std::enable_if_t<is_status_or<R>>* = nullptr>\n+  Future<typename R::value_type> TryMap(F&& f) const& {\n+    return TryMap<typename R::value_type>(std::forward<F>(f));\n+  }\n+\n+  // A `TryMap` overload that automatically infers the type of result from `f`.\n+  template <typename F,\n+            typename R = std::invoke_result_t<\n+                F, std::conditional_t<is_move_only, T, const T&>>,\n+            std::enable_if_t<is_status_or<R>>* = nullptr>\n+  Future<typename R::value_type> TryMap(F&& f) && {\n+    return std::move(*this).template TryMap<typename R::value_type>(\n+        std::forward<F>(f));\n+  }\n+\n+ private:\n+  friend class FutureHelpers;\n+\n+  // Bring FutureBase constructors in scope.\n+  using Base::Base;\n+\n+  // Constructor for unavailable future that will be fulfilled later via the\n+  // promise object.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  Future(const Promise& promise, FutureHelpers::OnBlockStart on_block_start,\n+         FutureHelpers::OnBlockEnd on_block_end)\n+      : Base(promise.ref(), std::move(on_block_start),\n+             std::move(on_block_end)) {}\n+};\n+\n+// Future<void> specialization for communicating stateless events.\n+//\n+// See Future<T> documentation above for more details.\n+template <>\n+class Future<void> : public internal::FutureBase<absl::Status> {\n+  using Base = internal::FutureBase<absl::Status>;\n+\n+  template <typename U>\n+  static constexpr bool is_status_or =  // NOLINT\n+      tsl::internal::is_status_or_v<U>;\n+\n+ public:\n+  Future() = default;\n+\n+  // Constructor for a future that is immediately ready with a given status.\n+  // For futures that are immediately ready with OK status, we use a global non\n+  // reference-counted async value that avoids heap allocation and reference\n+  // counting operations on a hot path.\n+  explicit Future(absl::Status status)\n+      : Base(ABSL_PREDICT_TRUE(status.ok())\n+                 ? ready_promise_->AsRef()\n+                 : tsl::MakeAvailableAsyncValueRef<absl::Status>(\n+                       std::move(status)),\n+             /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n+\n+  class Promise : public Base::Promise {\n+   public:\n+    using Base::Promise::Promise;\n+\n+    // Sets the promise completed with a given status. Must be called at most\n+    // once.\n+    //\n+    // After Set is called, completion event will be delivered to waiters on the\n+    // Future constructed from a promise, via blocking or callbacks.\n+    void Set(absl::Status status = absl::OkStatus()) {\n+      Base::Promise::emplace(std::move(status));\n+    }\n+\n+    // A helper function to convert move-only Promise to shared_ptr, which is\n+    // useful when the promise has to be captured by a std::function.\n+    std::shared_ptr<Promise> ToShared() && {\n+      return std::make_shared<Promise>(std::move(*this));\n+    }\n+\n+    // Returns a future associated with the promise.\n+    Future<> future(FutureHelpers::OnBlockStart on_block_start = nullptr,\n+                    FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n+      return Future<>(*this, std::move(on_block_start),\n+                      std::move(on_block_end));\n+    }\n+\n+   private:\n+    friend class Future<void>;\n+  };\n+\n+  // Returns a pair of connected Promise and Future<>. Setting the returned\n+  // promise will fulfill the connected future.\n+  static std::pair<Promise, Future<>> MakePromise(\n+      FutureHelpers::OnBlockStart on_block_start = nullptr,\n+      FutureHelpers::OnBlockEnd on_block_end = nullptr) {\n+    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n+    Future<> future(promise, std::move(on_block_start),\n+                    std::move(on_block_end));\n+    return std::make_pair(std::move(promise), std::move(future));\n+  }\n+\n+  using Base::Await;\n+  using Base::BlockUntilReady;\n+  using Base::OnReady;\n+\n+  // Returns an Future<R> that is constructed from the result of invoking\n+  // functor `f`. If *this completes with an error, returned future will also be\n+  // an error.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage:\n+  //\n+  // future.Map<R>([]() -> U {\n+  //   return U(value); // R must be constructible from U\n+  // })\n+  //\n+  template <typename R, typename F, typename U = std::invoke_result_t<F>>\n+  Future<R> Map(F&& f) {\n+    auto [promise, future] = Future<R>::MakePromise();\n+\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](absl::Status status) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n+        promise.emplace(absl::in_place_t{}, f());\n+      } else {\n+        promise.Set(std::move(status));\n+      }\n+    });\n+\n+    return std::move(future);\n+  }\n+\n+  // Returns an Future<R> that is constructed from the result of invoking\n+  // functor `f`. If *this completes with an error, returned future will also be\n+  // an error. Functor `f` must return a value of type absl::StatusOr<U> where R\n+  // is constructible from U. Returned absl::StatusOr is automatically unwrapped\n+  // and returned as a future payload.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage:\n+  //\n+  // future.TryMap<R>([]() -> absl::StatusOr<U> {\n+  //   return U(value); // R must be constructible from U\n+  // })\n+  //\n+  template <typename R, typename F, typename U = std::invoke_result_t<F>,\n+            std::enable_if_t<\n+                is_status_or<U> &&\n+                std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n+  Future<R> TryMap(F&& f) {\n+    auto [promise, future] = Future<R>::MakePromise();\n+\n+    OnReady([promise = std::move(promise),\n+             f = std::forward<F>(f)](absl::Status status) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n+        auto result = f();\n+        if (ABSL_PREDICT_TRUE(result.ok())) {\n+          promise.emplace(absl::in_place_t{}, *std::move(result));\n+        } else {\n+          promise.Set(std::move(result).status());\n+        }\n+      } else {\n+        promise.Set(std::move(status));\n+      }\n+    });\n+\n+    return std::move(future);\n+  }\n+\n+  // A `Map` overload that automatically infers the type of result from `f`.\n+  template <typename F, typename R = std::invoke_result_t<F>>\n+  Future<R> Map(F&& f) {\n+    return Map<R>(std::forward<F>(f));\n+  }\n+\n+  // A `TryMap` overload that automatically infers the type of result from `f`.\n+  template <typename F, typename R = std::invoke_result_t<F>,\n+            std::enable_if_t<is_status_or<R>>* = nullptr>\n+  Future<typename R::value_type> TryMap(F&& f) {\n+    return TryMap<typename R::value_type>(std::forward<F>(f));\n+  }\n+\n+  // Returns an Future<R> that is constructed from the given value. If *this\n+  // completes with an error, returned future will also be an error.\n+  //\n+  // Note: The implementation may choose to not run `f` if it can infer that the\n+  // returned future will never be used. Do not use this method if `f` has a\n+  // side effect that must always be executed when the future becomes ready.\n+  //\n+  // Sample usage: make buffer available when future is ready\n+  //\n+  // std::unique_ptr<Buffer> buffer = ...;\n+  // future.MapTo<R>(std::move(buffer));\n+  template <typename R>\n+  Future<absl::remove_cvref_t<R>> MapTo(R&& value) {\n+    return Map<absl::remove_cvref_t<R>>(\n+        [value = std::forward<R>(value)]() mutable {\n+          return std::move(value);\n+        });\n+  }\n+\n+ private:\n+  friend class FutureHelpers;\n+\n+  // A promise that is immediately ready with OK status. Async value allocated\n+  // in the static storage and is not reference-counted.\n+  static absl::NoDestructor<tsl::AsyncValueOwningRef<absl::Status>>\n+      ready_promise_;\n+\n+  // Bring FutureBase constructors in scope.\n+  using Base::Base;\n+\n+  // Constructor for unavailable future that will be fulfilled later via the\n+  // promise object.\n+  //\n+  // - on_block_start is called before Await starts to block.\n+  // - on_block_end is called after Await finishes blocking.\n+  Future(const Promise& promise, FutureHelpers::OnBlockStart on_block_start,\n+         FutureHelpers::OnBlockEnd on_block_end)\n+      : Base(promise.ref(), std::move(on_block_start),\n+             std::move(on_block_end)) {}\n+};\n+\n+// Bring Promise implementation into the tsl namespace.\n+template <typename T>\n+using Promise = typename Future<T>::Promise;  // NOLINT\n+\n+//===----------------------------------------------------------------------===//\n+// internal::FutureBase<T> implementation.\n+//===----------------------------------------------------------------------===//\n+\n+namespace internal {\n+\n+template <typename T, bool is_move_only>\n+Future<> FutureBase<T, is_move_only>::GetReadyFuture() const {\n+  auto [promise, future] = Future<>::MakePromise();\n+  promise_.AndThen(\n+      [self = promise_.AsPtr(), promise = std::move(promise)]() mutable {\n+        if constexpr (std::is_same_v<T, absl::Status>) {\n+          promise.Set(*self);\n+        } else {\n+          promise.Set(self->status());\n+        }\n+      });\n+  return std::move(future);\n+}\n+\n+}  // namespace internal\n+}  // namespace tsl\n+\n+#endif  // XLA_TSL_CONCURRENCY_FUTURE_H_"
        },
        {
            "sha": "901c9cb2874ed633a347247e3b9e832ceaa4ca47",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "added",
            "additions": 680,
            "deletions": 0,
            "changes": 680,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d995c59067ab2f92a71f191c37cef5b02d837ede/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=d995c59067ab2f92a71f191c37cef5b02d837ede",
            "patch": "@@ -0,0 +1,680 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tsl/concurrency/future.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n+#include \"xla/tsl/platform/test_benchmark.h\"\n+\n+namespace tsl {\n+\n+TEST(FutureTest, StatusConstructedFuture) {\n+  Future<> future = Future<>(absl::OkStatus());\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_EQ(future.Await(), absl::OkStatus());\n+}\n+\n+TEST(FutureTest, ValueConstructedFuture) {\n+  Future<int32_t> future = Future<int32_t>(42);\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_EQ(future.Await(), absl::StatusOr<int32_t>(42));\n+}\n+\n+TEST(FutureTest, StatelessFuture) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  promise.Set();\n+  EXPECT_TRUE(future.IsReady());\n+\n+  EXPECT_EQ(future.Await(), absl::OkStatus());\n+\n+  future.OnReady(\n+      [](absl::Status status) { EXPECT_EQ(status, absl::OkStatus()); });\n+}\n+\n+TEST(FutureTest, CreateFutureFromPromise) {\n+  auto [promise, _] = Future<int32_t>::MakePromise();\n+  Future<int32_t> future = promise.future();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  promise.Set(42);\n+  EXPECT_EQ(*future.Await(), 42);\n+}\n+\n+TEST(FutureTest, StatefulFutureToStateless) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<> ready_future = future.GetReadyFuture();\n+\n+  EXPECT_FALSE(ready_future.IsReady());\n+  promise.Set(42);\n+  EXPECT_EQ(ready_future.Await(), absl::OkStatus());\n+}\n+\n+TEST(FutureTest, StatefulFutureToStatelessError) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<> ready_future = future.GetReadyFuture();\n+\n+  EXPECT_FALSE(ready_future.IsReady());\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_EQ(ready_future.Await(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, MoveOnlyFutureToStateless) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  Future<> ready_future = future.GetReadyFuture();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(ready_future.IsReady());\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+  EXPECT_EQ(ready_future.Await(), absl::OkStatus());\n+}\n+\n+TEST(FutureTest, MoveOnlyFutureToStatelessError) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  Future<> ready_future = future.GetReadyFuture();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(ready_future.IsReady());\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_EQ(ready_future.Await(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, CopyableFuture) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+  Future<int32_t> copy_constructed(future);\n+  Future<int32_t> copy_assigned = future;\n+\n+  EXPECT_FALSE(copy_constructed.IsReady());\n+  EXPECT_FALSE(copy_assigned.IsReady());\n+  promise.Set(42);\n+  EXPECT_TRUE(copy_constructed.IsReady());\n+  EXPECT_TRUE(copy_assigned.IsReady());\n+}\n+\n+TEST(FutureTest, MoveConstructedFuture) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  Future<std::unique_ptr<int32_t>> move_constructed(std::move(future));\n+\n+  EXPECT_FALSE(move_constructed.IsReady());\n+  promise.Set(std::make_unique<int32_t>(42));\n+  EXPECT_TRUE(move_constructed.IsReady());\n+}\n+\n+TEST(FutureTest, MoveAssignedFuture) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  Future<std::unique_ptr<int32_t>> move_assigned = std::move(future);\n+\n+  EXPECT_FALSE(move_assigned.IsReady());\n+  promise.Set(std::make_unique<int32_t>(42));\n+  EXPECT_TRUE(move_assigned.IsReady());\n+}\n+\n+TEST(FutureTest, AwaitMoveOnlyFuture) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+\n+  EXPECT_EQ(**future.Await(), 42);\n+  EXPECT_EQ(**std::move(future).Await(), 42);\n+}\n+\n+TEST(FutureTest, OnReadyRvalueFuture) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+  promise.Set(42);\n+\n+  std::move(future).OnReady(\n+      [](absl::StatusOr<int32_t> value) { EXPECT_EQ(*value, 42); });\n+}\n+\n+TEST(FutureTest, OnReadyMoveOnlyFuture) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+\n+  std::move(future).OnReady([](absl::StatusOr<std::unique_ptr<int32_t>> value) {\n+    EXPECT_EQ(**value, 42);\n+  });\n+}\n+\n+TEST(FutureTest, UnlinkedPromiseIsUnique) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  EXPECT_FALSE(promise.IsUniqueReference());\n+  future = {};\n+  EXPECT_TRUE(promise.IsUniqueReference());\n+}\n+\n+TEST(FutureTest, PromiseIsUnique) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  // Future is linked to the promise object.\n+  EXPECT_FALSE(promise.IsUniqueReference());\n+\n+  // Future is destroyed, but we added a callback to underlying value.\n+  future.OnReady([](const absl::Status&) {});\n+  future = {};\n+  EXPECT_FALSE(promise.IsUniqueReference());\n+\n+  // Once promise is fulfilled, the callback is executed, and because we\n+  // destroyed the future, the underlying value is not referenced by anyone\n+  // else, and the promise becomes unique.\n+  promise.Set();\n+  EXPECT_TRUE(promise.IsUniqueReference());\n+}\n+\n+TEST(FutureTest, MapCopyableFuture) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(42);\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_TRUE(mapped.IsReady());\n+\n+  EXPECT_EQ(*future.Await(), 42);\n+  EXPECT_EQ(*mapped.Await(), 84.0f);\n+\n+  Future<int32_t> mapped_again =\n+      std::move(mapped).Map([](float v) -> int32_t { return v; });\n+  EXPECT_EQ(*mapped_again.Await(), 84);\n+}\n+\n+TEST(FutureTest, MapCopyableFutureError) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, MapMoveOnlyFuture) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  Future<std::unique_ptr<float>> mapped =\n+      std::move(future).Map([](std::unique_ptr<int32_t> v) {\n+        return std::make_unique<float>(*v * 2.0f);\n+      });\n+\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(**mapped.Await(), 84.0f);\n+}\n+\n+TEST(FutureTest, MapMoveOnlyFutureError) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  Future<std::unique_ptr<float>> mapped =\n+      std::move(future).Map([](std::unique_ptr<int32_t> v) {\n+        return std::make_unique<float>(*v * 2.0f);\n+      });\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, MapCopyableWithInplaceConstructor) {\n+  struct Struct {\n+    explicit Struct(int32_t v) : v(v) {}\n+    int32_t v;\n+  };\n+\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<Struct> mapped = future.Map<Struct>([](int32_t v) { return v; });\n+\n+  promise.Set(42);\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await()->v, 42);\n+}\n+\n+TEST(FutureTest, MapMoveOnlyWithInplaceConstructor) {\n+  struct Struct {\n+    explicit Struct(int32_t v) : v(v) {}\n+    int32_t v;\n+  };\n+\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+  Future<Struct> mapped = std::move(future).Map<Struct>(\n+      [](std::unique_ptr<int32_t> v) { return *v; });\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await()->v, 42);\n+}\n+\n+TEST(FutureTest, MapUnusedResult) {\n+  auto [promise, future] = Future<int>::MakePromise();\n+\n+  bool called = false;\n+  future.Map([&](int) {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set(1);\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(FutureTest, MapStatusUnusedResult) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  bool called = false;\n+  future.Map([&]() {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set();\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(FutureTest, TryMapCopyableFuture) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<float> mapped = future.TryMap(\n+      [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(42);\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_TRUE(mapped.IsReady());\n+\n+  EXPECT_EQ(*future.Await(), 42);\n+  EXPECT_EQ(*mapped.Await(), 84.0f);\n+\n+  Future<int32_t> mapped_again = std::move(mapped).TryMap(\n+      [](float v) -> absl::StatusOr<int32_t> { return v; });\n+  EXPECT_EQ(*mapped_again.Await(), 84);\n+}\n+\n+TEST(FutureTest, TryMapCopyableFutureForwardError) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<float> mapped = future.TryMap(\n+      [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, TryMapCopyableFutureCreateError) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+  Future<float> mapped = future.TryMap([](int32_t v) -> absl::StatusOr<float> {\n+    return absl::InternalError(\"test\");\n+  });\n+\n+  promise.Set(42);\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, TryMapMoveOnlyFuture) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  Future<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n+      [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n+        return std::make_unique<float>(*v * 2.0f);\n+      });\n+\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(**mapped.Await(), 84.0f);\n+}\n+\n+TEST(FutureTest, TryMapMoveOnlyFutureForwardError) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  Future<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n+      [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n+        return std::make_unique<float>(*v * 2.0f);\n+      });\n+\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, TryMapMoveOnlyFutureCreateError) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  Future<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n+      [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n+        return absl::InternalError(\"test\");\n+      });\n+\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(std::make_unique<int32_t>(42));\n+\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, TryMapUnusedResult) {\n+  auto [promise, future] = Future<int>::MakePromise();\n+\n+  bool called = false;\n+  future.TryMap([&](int) -> absl::StatusOr<int> {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set(1);\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(FutureTest, TryMapStatusUnusedResult) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  bool called = false;\n+  future.TryMap([&]() -> absl::StatusOr<int> {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set();\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(FutureTest, StatelessError) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_TRUE(future.IsReady());\n+\n+  absl::Status status = future.Await();\n+  EXPECT_EQ(status, absl::InternalError(\"test\"));\n+\n+  future.OnReady([](absl::Status status) {\n+    EXPECT_EQ(status, absl::InternalError(\"test\"));\n+  });\n+}\n+\n+TEST(FutureTest, StatelessImmediate) {\n+  Future<> ok_future(absl::OkStatus());\n+  Future<> error_future(absl::InternalError(\"test\"));\n+\n+  EXPECT_TRUE(ok_future.IsReady());\n+  EXPECT_TRUE(error_future.IsReady());\n+\n+  EXPECT_EQ(ok_future.Await(), absl::OkStatus());\n+  EXPECT_EQ(error_future.Await(), absl::InternalError(\"test\"));\n+\n+  ok_future.OnReady(\n+      [](absl::Status status) { EXPECT_EQ(status, absl::OkStatus()); });\n+\n+  error_future.OnReady([](absl::Status status) {\n+    EXPECT_EQ(status, absl::InternalError(\"test\"));\n+  });\n+}\n+\n+TEST(FutureTest, MapStatelessFuture) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  Future<float> mapped = future.Map([]() { return 42.0f; });\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(absl::OkStatus());\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_TRUE(mapped.IsReady());\n+\n+  EXPECT_EQ(future.Await(), absl::OkStatus());\n+  EXPECT_EQ(*mapped.Await(), 42.0f);\n+}\n+\n+TEST(FutureTest, MapStatelessFutureError) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  Future<float> mapped = future.Map([]() { return 42.0f; });\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_TRUE(mapped.IsReady());\n+\n+  EXPECT_EQ(future.Await(), absl::InternalError(\"test\"));\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, TryMapStatelessFuture) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  Future<float> mapped =\n+      future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(absl::OkStatus());\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_TRUE(mapped.IsReady());\n+\n+  EXPECT_EQ(future.Await(), absl::OkStatus());\n+  EXPECT_EQ(*mapped.Await(), 42.0f);\n+}\n+\n+TEST(FutureTest, TryMapStatelessFutureForwardError) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  Future<float> mapped =\n+      future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n+\n+  promise.Set(absl::InternalError(\"test\"));\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, TryMapStatelessFutureCreateError) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  Future<float> mapped = future.TryMap(\n+      []() -> absl::StatusOr<float> { return absl::InternalError(\"test\"); });\n+\n+  promise.Set(absl::OkStatus());\n+  EXPECT_TRUE(mapped.IsReady());\n+  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n+}\n+\n+TEST(FutureTest, MapToStatelessFuture) {\n+  auto [promise, future] = Future<>::MakePromise();\n+  Future<float> mapped = future.MapTo(42.0f);\n+\n+  EXPECT_FALSE(future.IsReady());\n+  EXPECT_FALSE(mapped.IsReady());\n+\n+  promise.Set(absl::OkStatus());\n+  EXPECT_TRUE(future.IsReady());\n+  EXPECT_TRUE(mapped.IsReady());\n+\n+  EXPECT_EQ(future.Await(), absl::OkStatus());\n+  EXPECT_EQ(*mapped.Await(), 42.0f);\n+}\n+\n+TEST(FutureTest, StatefulFuture) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  promise.Set(42);\n+  EXPECT_TRUE(future.IsReady());\n+\n+  future.OnReady([](absl::StatusOr<int32_t> value) { EXPECT_EQ(*value, 42); });\n+}\n+\n+TEST(FutureTest, StatusFuture) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  promise.Set(absl::OkStatus());\n+  EXPECT_TRUE(future.IsReady());\n+\n+  future.OnReady(\n+      [](absl::Status status) { EXPECT_EQ(status, absl::OkStatus()); });\n+}\n+\n+TEST(FutureTest, StatusOrFuture) {\n+  auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+  EXPECT_FALSE(future.IsReady());\n+  promise.Set(42);\n+  EXPECT_TRUE(future.IsReady());\n+\n+  future.OnReady([](absl::StatusOr<int32_t> value) { EXPECT_EQ(*value, 42); });\n+}\n+\n+TEST(FutureTest, JoinFutures) {\n+  auto empty_join = JoinFutures({});\n+  EXPECT_TRUE(empty_join.IsReady());\n+  EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n+\n+  auto [promise0, future0] = Future<>::MakePromise();\n+  auto [promise1, future1] = Future<>::MakePromise();\n+\n+  std::vector<Future<>> futures0 = {future0};\n+  std::vector<Future<>> futures1 = {future0, future1};\n+\n+  auto join_one = JoinFutures(futures0);\n+  EXPECT_FALSE(join_one.IsReady());\n+\n+  auto join_two = JoinFutures(futures1);\n+  EXPECT_FALSE(join_two.IsReady());\n+\n+  promise0.Set();\n+  EXPECT_TRUE(join_one.IsReady());\n+  EXPECT_FALSE(join_two.IsReady());\n+  EXPECT_EQ(join_one.Await(), absl::OkStatus());\n+\n+  promise1.Set();\n+  EXPECT_TRUE(join_two.IsReady());\n+  EXPECT_EQ(join_two.Await(), absl::OkStatus());\n+}\n+\n+TEST(FutureTest, JoinErrors) {\n+  auto empty_join = JoinFutures({});\n+  EXPECT_TRUE(empty_join.IsReady());\n+  EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n+\n+  auto [promise0, future0] = Future<>::MakePromise();\n+  auto [promise1, future1] = Future<>::MakePromise();\n+\n+  std::vector<Future<>> futures0 = {future0};\n+  std::vector<Future<>> futures1 = {future0, future1};\n+\n+  auto join_one = JoinFutures(futures0);\n+  EXPECT_FALSE(join_one.IsReady());\n+\n+  auto join_two = JoinFutures(futures1);\n+  EXPECT_FALSE(join_two.IsReady());\n+\n+  promise0.Set(absl::InternalError(\"error #0\"));\n+  EXPECT_TRUE(join_one.IsReady());\n+  EXPECT_FALSE(join_two.IsReady());\n+  EXPECT_EQ(join_one.Await(), absl::InternalError(\"error #0\"));\n+\n+  promise1.Set(absl::InternalError(\"error #1\"));\n+  EXPECT_TRUE(join_two.IsReady());\n+  EXPECT_EQ(join_two.Await(), absl::InternalError(\"error #0\"));\n+}\n+\n+TEST(FutureTest, WithProfiling) {\n+  auto [promise, future] = Future<int32_t>::MakePromise(\n+      [&] { return FutureHelpers::ProfilingKeys{}; },\n+      [&](FutureHelpers::ProfilingKeys) {});\n+\n+  auto update_profiling = FutureHelpers::WithProfiling(\n+      std::move(future), [&] { return FutureHelpers::ProfilingKeys{}; },\n+      [&](FutureHelpers::ProfilingKeys) {});\n+\n+  EXPECT_FALSE(update_profiling.IsReady());\n+\n+  promise.Set(42);\n+\n+  EXPECT_TRUE(update_profiling.IsReady());\n+  EXPECT_EQ(*update_profiling.Await(), 42);\n+}\n+\n+TEST(FutureTest, MakeSharedPromise) {\n+  {  // Stateless future.\n+    auto [promise, future] = Future<>::MakePromise();\n+\n+    auto shared_promise = std::move(promise).ToShared();\n+    shared_promise->Set();\n+\n+    // NOLINTNEXTLINE(bugprone-use-after-move)\n+    EXPECT_FALSE(static_cast<bool>(promise));\n+\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(future.Await(), absl::OkStatus());\n+  }\n+\n+  {  // Stateful future.\n+    auto [promise, future] = Future<int32_t>::MakePromise();\n+\n+    auto shared_promise = std::move(promise).ToShared();\n+    shared_promise->Set(42);\n+\n+    // NOLINTNEXTLINE(bugprone-use-after-move)\n+    EXPECT_FALSE(static_cast<bool>(promise));\n+\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(*future.Await(), 42);\n+  }\n+}\n+\n+//===----------------------------------------------------------------------===//\n+// Performance benchmarks.\n+//===----------------------------------------------------------------------===//\n+\n+static void BM_CreateOkFuture(benchmark::State& state) {\n+  for (auto _ : state) {\n+    Future<> future(absl::OkStatus());\n+    benchmark::DoNotOptimize(future);\n+  }\n+}\n+\n+static void BM_StatelessMapTo(benchmark::State& state) {\n+  std::shared_ptr<float> value = std::make_shared<float>(42.0f);\n+\n+  for (auto _ : state) {\n+    Future<> future(absl::OkStatus());\n+    Future<std::shared_ptr<float>> mapped = future.MapTo(value);\n+    benchmark::DoNotOptimize(mapped);\n+  }\n+}\n+\n+BENCHMARK(BM_CreateOkFuture);\n+BENCHMARK(BM_StatelessMapTo);\n+\n+}  // namespace tsl"
        }
    ],
    "stats": {
        "total": 1728,
        "additions": 1728,
        "deletions": 0
    }
}