{
    "author": "tensorflower-gardener",
    "message": "Move CollectiveMetadataTest to a separate file.\n\nPiperOrigin-RevId: 839275803",
    "sha": "5fd8d481dc7568282762d367daae608565353f28",
    "files": [
        {
            "sha": "478e24b7a4681065a844f4cb1b85aff96c53cf22",
            "filename": "third_party/xla/xla/tests/BUILD",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd8d481dc7568282762d367daae608565353f28/third_party%2Fxla%2Fxla%2Ftests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd8d481dc7568282762d367daae608565353f28/third_party%2Fxla%2Fxla%2Ftests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2FBUILD?ref=5fd8d481dc7568282762d367daae608565353f28",
            "patch": "@@ -2960,6 +2960,33 @@ xla_test(\n     ],\n )\n \n+xla_test(\n+    name = \"collective_metadata_test\",\n+    srcs = [\"collective_metadata_test.cc\"],\n+    backend_tags = {\n+        \"gpu\": [\n+            \"multi_gpu\",\n+        ],\n+        \"nvgpu_any\": [\n+            \"broken\",\n+            \"no_oss\",\n+        ],\n+    },\n+    backends = [\n+        \"gpu\",\n+    ],\n+    deps = [\n+        \":collective_ops_e2e_test_base\",\n+        \":xla_internal_test_main\",\n+        \"//xla:literal\",\n+        \"//xla:literal_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)\n+\n xla_test(\n     name = \"collective_ops_sharded_unsharded_e2e_test\",\n     srcs = [\"collective_ops_sharded_unsharded_e2e_test.cc\"],"
        },
        {
            "sha": "f2416aeaeaa7a0dbbd35b6cf437d03cd02f1a7ad",
            "filename": "third_party/xla/xla/tests/collective_metadata_test.cc",
            "status": "added",
            "additions": 177,
            "deletions": 0,
            "changes": 177,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd8d481dc7568282762d367daae608565353f28/third_party%2Fxla%2Fxla%2Ftests%2Fcollective_metadata_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd8d481dc7568282762d367daae608565353f28/third_party%2Fxla%2Fxla%2Ftests%2Fcollective_metadata_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fcollective_metadata_test.cc?ref=5fd8d481dc7568282762d367daae608565353f28",
            "patch": "@@ -0,0 +1,177 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#include <array>\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/literal.h\"\n+#include \"xla/literal_util.h\"\n+#include \"xla/tests/collective_ops_e2e_test_base.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n+\n+namespace xla {\n+namespace {\n+\n+class CollectiveMetadataTest : public CollectiveOpsE2ETestBase {\n+ protected:\n+  void SetUp() override {\n+    CollectiveOpsE2ETestBase::SetUp();\n+    if (!IsHopperAndHigher()) {\n+      GTEST_SKIP() << \"Test requires Hopper or newer architecture since it's \"\n+                      \"using a multicast.\";\n+    }\n+  }\n+};\n+\n+TEST_F(CollectiveMetadataTest, ConstructCollectiveMetadata) {\n+  const absl::string_view kModuleStr = R\"(\n+  HloModule test, replica_count=2\n+\n+  ENTRY test_computation {\n+    param_0 = f32[4] parameter(0)\n+    param_1 = f32[4] parameter(1)\n+    copy_1 = f32[4]{0:S(1)} copy(param_1)\n+\n+    const_0 = f32[1] constant({10})\n+\n+    result_tuple = (f32[4], f32[4]{0:S(1)}, f32[1], u64[9]) custom-call(param_0, copy_1, const_0), custom_call_target=\"CollectiveMetadata\", output_to_operand_aliasing={{0}: (0, {}), {1}: (1, {})}\n+    ROOT get_tuple_element = u64[9] get-tuple-element(result_tuple), index=3\n+  })\";\n+\n+  constexpr int kNumReplicas = 2;\n+  ASSERT_GE(hlo_runner_->device_count(), kNumReplicas)\n+      << \"Test requires at least \" << kNumReplicas << \" devices (\"\n+      << hlo_runner_->device_count() << \" available)\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto unoptimized_module,\n+      ParseAndReturnVerifiedModule(kModuleStr, kNumReplicas));\n+\n+  Literal input_0 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n+  Literal input_1 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      ExecutionResult execution_result,\n+      ExecuteReplicated(std::move(unoptimized_module),\n+                        /*arguments=*/std::vector<Literal*>{&input_0, &input_1},\n+                        /*run_hlo_passes=*/false));\n+  const std::vector<Literal>& result = execution_result.results;\n+  ASSERT_EQ(result.size(), kNumReplicas);\n+\n+  absl::Span<const uint64_t> first_result_data = result[0].data<uint64_t>();\n+  absl::Span<const uint64_t> second_result_data = result[1].data<uint64_t>();\n+  constexpr int kNumElements = 9;\n+  ASSERT_EQ(first_result_data.size(), kNumElements);\n+  ASSERT_EQ(second_result_data.size(), kNumElements);\n+\n+  // Check the rank in the first position.\n+  EXPECT_EQ(first_result_data[0], 0);\n+  EXPECT_EQ(second_result_data[0], 1);\n+\n+  // Check pointer to peers in the second position.\n+  EXPECT_NE(first_result_data[1], 0);\n+  EXPECT_NE(second_result_data[1], 0);\n+\n+  // Check pointer to multimem metadata in the third position.\n+  EXPECT_NE(first_result_data[2], 0);\n+  EXPECT_NE(second_result_data[2], 0);\n+\n+  // Check param_to_peers structure.\n+  for (int i = 3; i < kNumElements; ++i) {\n+    EXPECT_NE(first_result_data[i], 0);\n+    EXPECT_EQ(second_result_data[i], first_result_data[i]);\n+  }\n+}\n+\n+TEST_F(CollectiveMetadataTest, ConstructCollectiveMetadataWithReplicaGroup) {\n+  const absl::string_view kModuleStr = R\"(\n+  HloModule test, replica_count=4\n+\n+  ENTRY test_computation {\n+    param_0 = f32[4] parameter(0)\n+    param_1 = f32[4] parameter(1)\n+    copy_1 = f32[4]{0:S(1)} copy(param_1)\n+\n+    result_tuple = (f32[4], f32[4]{0:S(1)}, u64[7]) custom-call(param_0, copy_1), custom_call_target=\"CollectiveMetadata\", output_to_operand_aliasing={{0}: (0, {}), {1}: (1, {})}, backend_config=\"{\\\"collective_metadata_backend_config\\\":{\\\"collective_devices\\\": { \\\"replica_groups\\\": [{\\\"replica_ids\\\": [0,1]}, {\\\"replica_ids\\\": [2,3]}]}}}\"\n+    ROOT get_tuple_element = u64[7] get-tuple-element(result_tuple), index=2\n+  })\";\n+\n+  constexpr int kNumReplicas = 4;\n+  if (hlo_runner_->device_count() < kNumReplicas) {\n+    GTEST_SKIP() << \"Test requires at least \" << kNumReplicas << \" devices (\"\n+                 << hlo_runner_->device_count() << \" available)\";\n+  }\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto module, ParseAndReturnVerifiedModule(kModuleStr, kNumReplicas));\n+\n+  Literal input_0 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n+  Literal input_1 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      ExecutionResult execution_result,\n+      ExecuteReplicated(std::move(module),\n+                        /*arguments=*/std::vector<Literal*>{&input_0, &input_1},\n+                        /*run_hlo_passes=*/false));\n+  const std::vector<Literal>& result = execution_result.results;\n+  ASSERT_EQ(result.size(), kNumReplicas);\n+  absl::Span<const uint64_t> replica_0_result_0_data =\n+      result[0].data<uint64_t>();\n+  absl::Span<const uint64_t> replica_0_result_1_data =\n+      result[1].data<uint64_t>();\n+  absl::Span<const uint64_t> replica_1_result_0_data =\n+      result[2].data<uint64_t>();\n+  absl::Span<const uint64_t> replica_1_result_1_data =\n+      result[3].data<uint64_t>();\n+\n+  // Check the rank in the first position.\n+  constexpr int kNumElements = 7;\n+  ASSERT_EQ(replica_0_result_0_data.size(), kNumElements);\n+  ASSERT_EQ(replica_0_result_1_data.size(), kNumElements);\n+  ASSERT_EQ(replica_1_result_0_data.size(), kNumElements);\n+  ASSERT_EQ(replica_1_result_1_data.size(), kNumElements);\n+\n+  EXPECT_EQ(replica_0_result_0_data[0], 0);\n+  EXPECT_EQ(replica_0_result_1_data[0], 1);\n+  EXPECT_EQ(replica_1_result_0_data[0], 0);\n+  EXPECT_EQ(replica_1_result_1_data[0], 1);\n+\n+  // Check pointer to peers in the second position.\n+  EXPECT_NE(replica_0_result_0_data[1], 0);\n+  EXPECT_NE(replica_0_result_1_data[1], 0);\n+  EXPECT_NE(replica_1_result_0_data[1], 0);\n+  EXPECT_NE(replica_1_result_1_data[1], 0);\n+\n+  // Check pointer to multimem metadata in the third position.\n+  EXPECT_NE(replica_0_result_0_data[2], 0);\n+  EXPECT_NE(replica_0_result_1_data[2], 0);\n+  EXPECT_NE(replica_1_result_0_data[2], 0);\n+  EXPECT_NE(replica_1_result_1_data[2], 0);\n+\n+  // Check param_to_peers structure.\n+  for (int i = 3; i < kNumElements; ++i) {\n+    EXPECT_NE(replica_0_result_0_data[i], 0);\n+    EXPECT_EQ(replica_0_result_1_data[i], replica_0_result_0_data[i]);\n+    EXPECT_NE(replica_1_result_0_data[i], 0);\n+    EXPECT_EQ(replica_1_result_1_data[i], replica_1_result_0_data[i]);\n+  }\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        },
        {
            "sha": "4470b0425f0fa078abd5714ff91b0ac99464bb57",
            "filename": "third_party/xla/xla/tests/collective_ops_e2e_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 145,
            "changes": 145,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fd8d481dc7568282762d367daae608565353f28/third_party%2Fxla%2Fxla%2Ftests%2Fcollective_ops_e2e_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fd8d481dc7568282762d367daae608565353f28/third_party%2Fxla%2Fxla%2Ftests%2Fcollective_ops_e2e_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fcollective_ops_e2e_test.cc?ref=5fd8d481dc7568282762d367daae608565353f28",
            "patch": "@@ -2871,150 +2871,5 @@ INSTANTIATE_TEST_SUITE_P(\n       return absl::StrCat(GetAsyncTestName(std::get<0>(info.param)), \"_\",\n                           std::get<1>(info.param) ? \"one_shot\" : \"nccl\");\n     });\n-\n-class CollectiveMetadataTest : public CollectiveOpsE2ETestBase {\n- protected:\n-  void SetUp() override {\n-    CollectiveOpsE2ETestBase::SetUp();\n-    if (!IsHopperAndHigher()) {\n-      GTEST_SKIP() << \"Test requires Hopper or newer architecture since it's \"\n-                      \"using a multicast.\";\n-    }\n-  }\n-};\n-\n-TEST_F(CollectiveMetadataTest, ConstructCollectiveMetadata) {\n-  const absl::string_view kModuleStr = R\"(\n-  HloModule test, replica_count=2\n-\n-  ENTRY test_computation {\n-    param_0 = f32[4] parameter(0)\n-    param_1 = f32[4] parameter(1)\n-    copy_1 = f32[4]{0:S(1)} copy(param_1)\n-\n-    const_0 = f32[1] constant({10})\n-\n-    result_tuple = (f32[4], f32[4]{0:S(1)}, f32[1], u64[9]) custom-call(param_0, copy_1, const_0), custom_call_target=\"CollectiveMetadata\", output_to_operand_aliasing={{0}: (0, {}), {1}: (1, {})}\n-    ROOT get_tuple_element = u64[9] get-tuple-element(result_tuple), index=3\n-  })\";\n-\n-  constexpr int kNumReplicas = 2;\n-  ASSERT_GE(hlo_runner_->device_count(), kNumReplicas)\n-      << \"Test requires at least \" << kNumReplicas << \" devices (\"\n-      << hlo_runner_->device_count() << \" available)\";\n-\n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto unoptimized_module,\n-      ParseAndReturnVerifiedModule(kModuleStr, kNumReplicas));\n-\n-  Literal input_0 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n-  Literal input_1 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n-  TF_ASSERT_OK_AND_ASSIGN(\n-      ExecutionResult execution_result,\n-      ExecuteReplicated(std::move(unoptimized_module),\n-                        /*arguments=*/std::vector<Literal*>{&input_0, &input_1},\n-                        /*run_hlo_passes=*/false));\n-  const std::vector<Literal>& result = execution_result.results;\n-  ASSERT_EQ(result.size(), kNumReplicas);\n-\n-  absl::Span<const uint64_t> first_result_data = result[0].data<uint64_t>();\n-  absl::Span<const uint64_t> second_result_data = result[1].data<uint64_t>();\n-  constexpr int kNumElements = 9;\n-  ASSERT_EQ(first_result_data.size(), kNumElements);\n-  ASSERT_EQ(second_result_data.size(), kNumElements);\n-\n-  // Check the rank in the first position.\n-  EXPECT_EQ(first_result_data[0], 0);\n-  EXPECT_EQ(second_result_data[0], 1);\n-\n-  // Check pointer to peers in the second position.\n-  EXPECT_NE(first_result_data[1], 0);\n-  EXPECT_NE(second_result_data[1], 0);\n-\n-  // Check pointer to multimem metadata in the third position.\n-  EXPECT_NE(first_result_data[2], 0);\n-  EXPECT_NE(second_result_data[2], 0);\n-\n-  // Check param_to_peers structure.\n-  for (int i = 3; i < kNumElements; ++i) {\n-    EXPECT_NE(first_result_data[i], 0);\n-    EXPECT_EQ(second_result_data[i], first_result_data[i]);\n-  }\n-}\n-\n-TEST_F(CollectiveMetadataTest, ConstructCollectiveMetadataWithReplicaGroup) {\n-  const absl::string_view kModuleStr = R\"(\n-  HloModule test, replica_count=4\n-\n-  ENTRY test_computation {\n-    param_0 = f32[4] parameter(0)\n-    param_1 = f32[4] parameter(1)\n-    copy_1 = f32[4]{0:S(1)} copy(param_1)\n-\n-    result_tuple = (f32[4], f32[4]{0:S(1)}, u64[7]) custom-call(param_0, copy_1), custom_call_target=\"CollectiveMetadata\", output_to_operand_aliasing={{0}: (0, {}), {1}: (1, {})}, backend_config=\"{\\\"collective_metadata_backend_config\\\":{\\\"collective_devices\\\": { \\\"replica_groups\\\": [{\\\"replica_ids\\\": [0,1]}, {\\\"replica_ids\\\": [2,3]}]}}}\"\n-    ROOT get_tuple_element = u64[7] get-tuple-element(result_tuple), index=2\n-  })\";\n-\n-  constexpr int kNumReplicas = 4;\n-  if (hlo_runner_->device_count() < kNumReplicas) {\n-    GTEST_SKIP() << \"Test requires at least \" << kNumReplicas << \" devices (\"\n-                 << hlo_runner_->device_count() << \" available)\";\n-  }\n-\n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto module, ParseAndReturnVerifiedModule(kModuleStr, kNumReplicas));\n-\n-  Literal input_0 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n-  Literal input_1 = LiteralUtil::CreateR1<float>({1.0f, 2.0f, 3.0f, 4.0f});\n-\n-  TF_ASSERT_OK_AND_ASSIGN(\n-      ExecutionResult execution_result,\n-      ExecuteReplicated(std::move(module),\n-                        /*arguments=*/std::vector<Literal*>{&input_0, &input_1},\n-                        /*run_hlo_passes=*/false));\n-  const std::vector<Literal>& result = execution_result.results;\n-  ASSERT_EQ(result.size(), kNumReplicas);\n-  absl::Span<const uint64_t> replica_0_result_0_data =\n-      result[0].data<uint64_t>();\n-  absl::Span<const uint64_t> replica_0_result_1_data =\n-      result[1].data<uint64_t>();\n-  absl::Span<const uint64_t> replica_1_result_0_data =\n-      result[2].data<uint64_t>();\n-  absl::Span<const uint64_t> replica_1_result_1_data =\n-      result[3].data<uint64_t>();\n-\n-  // Check the rank in the first position.\n-  constexpr int kNumElements = 7;\n-  ASSERT_EQ(replica_0_result_0_data.size(), kNumElements);\n-  ASSERT_EQ(replica_0_result_1_data.size(), kNumElements);\n-  ASSERT_EQ(replica_1_result_0_data.size(), kNumElements);\n-  ASSERT_EQ(replica_1_result_1_data.size(), kNumElements);\n-\n-  EXPECT_EQ(replica_0_result_0_data[0], 0);\n-  EXPECT_EQ(replica_0_result_1_data[0], 1);\n-  EXPECT_EQ(replica_1_result_0_data[0], 0);\n-  EXPECT_EQ(replica_1_result_1_data[0], 1);\n-\n-  // Check pointer to peers in the second position.\n-  EXPECT_NE(replica_0_result_0_data[1], 0);\n-  EXPECT_NE(replica_0_result_1_data[1], 0);\n-  EXPECT_NE(replica_1_result_0_data[1], 0);\n-  EXPECT_NE(replica_1_result_1_data[1], 0);\n-\n-  // Check pointer to multimem metadata in the third position.\n-  EXPECT_NE(replica_0_result_0_data[2], 0);\n-  EXPECT_NE(replica_0_result_1_data[2], 0);\n-  EXPECT_NE(replica_1_result_0_data[2], 0);\n-  EXPECT_NE(replica_1_result_1_data[2], 0);\n-\n-  // Check param_to_peers structure.\n-  for (int i = 3; i < kNumElements; ++i) {\n-    EXPECT_NE(replica_0_result_0_data[i], 0);\n-    EXPECT_EQ(replica_0_result_1_data[i], replica_0_result_0_data[i]);\n-    EXPECT_NE(replica_1_result_0_data[i], 0);\n-    EXPECT_EQ(replica_1_result_1_data[i], replica_1_result_0_data[i]);\n-  }\n-}\n-\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 349,
        "additions": 204,
        "deletions": 145
    }
}