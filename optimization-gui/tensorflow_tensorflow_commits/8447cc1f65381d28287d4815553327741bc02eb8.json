{
    "author": "beckerhe",
    "message": "KernelSpecTest improvements and cleanups\n\n- Improves how we invent pointers to CUDA kernels\n- Adds parameter comments for ambigious parameters\n- Makes use of `ParseTextProtoOrDie`\n\nPiperOrigin-RevId: 833234269",
    "sha": "8447cc1f65381d28287d4815553327741bc02eb8",
    "files": [
        {
            "sha": "1edeaefe169d9b6aca136adb04362185d350bdc1",
            "filename": "third_party/xla/xla/stream_executor/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8447cc1f65381d28287d4815553327741bc02eb8/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8447cc1f65381d28287d4815553327741bc02eb8/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD?ref=8447cc1f65381d28287d4815553327741bc02eb8",
            "patch": "@@ -613,14 +613,13 @@ xla_cc_test(\n         \":kernel_spec\",\n         \":kernel_spec_proto_cc\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/util:safe_reinterpret_cast\",\n         \"//xla/tsl/util/proto:parse_text_proto\",\n         \"//xla/tsl/util/proto:proto_matchers\",\n-        \"@com_google_absl//absl/base\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\",\n-        \"@com_google_protobuf//:protobuf\",\n     ],\n )\n "
        },
        {
            "sha": "71065e5ad50a81e03fe33e1ea35eb70bcfc1c993",
            "filename": "third_party/xla/xla/stream_executor/kernel_spec_test.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 44,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8447cc1f65381d28287d4815553327741bc02eb8/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8447cc1f65381d28287d4815553327741bc02eb8/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_spec_test.cc?ref=8447cc1f65381d28287d4815553327741bc02eb8",
            "patch": "@@ -23,16 +23,15 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n-#include \"absl/base/casts.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/strings/string_view.h\"\n-#include \"google/protobuf/text_format.h\"\n #include \"xla/stream_executor/kernel_argument_packing_spec.h\"\n #include \"xla/stream_executor/kernel_spec.pb.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/util/proto/parse_text_proto.h\"\n #include \"xla/tsl/util/proto/proto_matchers.h\"\n+#include \"xla/tsl/util/safe_reinterpret_cast.h\"\n \n namespace stream_executor {\n namespace {\n@@ -44,10 +43,17 @@ using ::testing::Optional;\n using ::tsl::proto_testing::EqualsProto;\n using ::tsl::proto_testing::ParseTextProtoOrDie;\n \n+// Creates a pointer to a CUDA kernel with a value that can be used to identify\n+// it later. Note that this is not a valid pointer, but that's fine as long\n+// as we don't try to dereference it.\n+void* InventPointerToCudaKernel(std::uintptr_t value) {\n+  return tsl::safe_reinterpret_cast<void*>(value);\n+}\n+\n TEST(KernelLoaderSpec, InProcessSymbol) {\n-  void* symbol = absl::bit_cast<void*>(0xDEADBEEFul);\n-  auto spec = stream_executor::KernelLoaderSpec::CreateInProcessSymbolSpec(\n-      symbol, \"kernel24\", 2);\n+  void* symbol = InventPointerToCudaKernel(0xDEADBEEF);\n+  auto spec = KernelLoaderSpec::CreateInProcessSymbolSpec(symbol, \"kernel24\",\n+                                                          /*arity=*/2);\n   EXPECT_FALSE(spec.has_cuda_cubin_in_memory());\n   EXPECT_FALSE(spec.has_cuda_ptx_in_memory());\n   EXPECT_TRUE(spec.has_in_process_symbol());\n@@ -59,8 +65,8 @@ TEST(KernelLoaderSpec, InProcessSymbol) {\n \n TEST(KernelLoaderSpec, CudaCubin) {\n   static constexpr std::array<uint8_t, 4> kCubinData = {0xDE, 0xAD, 0xBE, 0xEF};\n-  auto spec = stream_executor::KernelLoaderSpec::CreateCudaCubinInMemorySpec(\n-      kCubinData, \"kernel24\", 2);\n+  auto spec = KernelLoaderSpec::CreateCudaCubinInMemorySpec(\n+      kCubinData, \"kernel24\", /*arity=*/2);\n   EXPECT_TRUE(spec.has_cuda_cubin_in_memory());\n   EXPECT_FALSE(spec.has_cuda_ptx_in_memory());\n   EXPECT_FALSE(spec.has_in_process_symbol());\n@@ -72,10 +78,9 @@ TEST(KernelLoaderSpec, CudaCubin) {\n \n TEST(KernelLoaderSpec, OwningCudaCubin) {\n   static constexpr std::array<uint8_t, 4> kCubinData = {0xDE, 0xAD, 0xBE, 0xEF};\n-  auto spec =\n-      stream_executor::KernelLoaderSpec::CreateOwningCudaCubinInMemorySpec(\n-          std::vector<uint8_t>{kCubinData.begin(), kCubinData.end()},\n-          \"kernel24\", 2);\n+  auto spec = KernelLoaderSpec::CreateOwningCudaCubinInMemorySpec(\n+      std::vector<uint8_t>{kCubinData.begin(), kCubinData.end()}, \"kernel24\",\n+      /*arity=*/2);\n   EXPECT_TRUE(spec.has_cuda_cubin_in_memory());\n   EXPECT_FALSE(spec.has_cuda_ptx_in_memory());\n   EXPECT_FALSE(spec.has_in_process_symbol());\n@@ -87,8 +92,8 @@ TEST(KernelLoaderSpec, OwningCudaCubin) {\n \n TEST(KernelLoaderSpec, CudaPtx) {\n   static constexpr absl::string_view kPtxData = \"PTX DEADBEEF\";\n-  auto spec = stream_executor::KernelLoaderSpec::CreateCudaPtxInMemorySpec(\n-      kPtxData, \"kernel24\", 2);\n+  auto spec = KernelLoaderSpec::CreateCudaPtxInMemorySpec(kPtxData, \"kernel24\",\n+                                                          /*arity=*/2);\n   EXPECT_FALSE(spec.has_cuda_cubin_in_memory());\n   EXPECT_TRUE(spec.has_cuda_ptx_in_memory());\n   EXPECT_FALSE(spec.has_in_process_symbol());\n@@ -100,9 +105,8 @@ TEST(KernelLoaderSpec, CudaPtx) {\n \n TEST(KernelLoaderSpec, OwningCudaPtx) {\n   static constexpr absl::string_view kPtxData = \"PTX DEADBEEF\";\n-  auto spec =\n-      stream_executor::KernelLoaderSpec::CreateOwningCudaPtxInMemorySpec(\n-          std::string{kPtxData}, \"kernel24\", 2);\n+  auto spec = KernelLoaderSpec::CreateOwningCudaPtxInMemorySpec(\n+      std::string{kPtxData}, \"kernel24\", /*arity=*/2);\n   EXPECT_FALSE(spec.has_cuda_cubin_in_memory());\n   EXPECT_TRUE(spec.has_cuda_ptx_in_memory());\n   EXPECT_FALSE(spec.has_in_process_symbol());\n@@ -113,14 +117,11 @@ TEST(KernelLoaderSpec, OwningCudaPtx) {\n }\n \n TEST(KernelLoaderSpec, PtxKernelFromProto) {\n-  KernelLoaderSpecProto proto;\n-  ASSERT_TRUE(tsl::protobuf::TextFormat::ParseFromString(\n-      R\"pb(\n-        ptx { data: \"PTX!\" }\n-        kernel_name: \"kernel_name\"\n-        arity: 42\n-      )pb\",\n-      &proto));\n+  auto proto = ParseTextProtoOrDie<KernelLoaderSpecProto>(R\"pb(\n+    ptx { data: \"PTX!\" }\n+    kernel_name: \"kernel_name\"\n+    arity: 42\n+  )pb\");\n \n   TF_ASSERT_OK_AND_ASSIGN(KernelLoaderSpec spec,\n                           KernelLoaderSpec::FromProto(proto));\n@@ -131,8 +132,8 @@ TEST(KernelLoaderSpec, PtxKernelFromProto) {\n }\n \n TEST(KernelLoaderSpec, PtxKernelToProto) {\n-  auto spec = stream_executor::KernelLoaderSpec::CreateCudaPtxInMemorySpec(\n-      \"PTX!\", \"kernel_name\", 42);\n+  auto spec = KernelLoaderSpec::CreateCudaPtxInMemorySpec(\"PTX!\", \"kernel_name\",\n+                                                          /*arity=*/42);\n \n   EXPECT_THAT(spec.ToProto(), absl_testing::IsOkAndHolds(EqualsProto(R\"pb(\n                 ptx { data: \"PTX!\" }\n@@ -142,14 +143,11 @@ TEST(KernelLoaderSpec, PtxKernelToProto) {\n }\n \n TEST(KernelLoaderSpec, CubinKernelFromProto) {\n-  KernelLoaderSpecProto proto;\n-  ASSERT_TRUE(tsl::protobuf::TextFormat::ParseFromString(\n-      R\"pb(\n-        cubin { data: \"CUBIN\" }\n-        kernel_name: \"kernel_name\"\n-        arity: 42\n-      )pb\",\n-      &proto));\n+  auto proto = ParseTextProtoOrDie<KernelLoaderSpecProto>(R\"pb(\n+    cubin { data: \"CUBIN\" }\n+    kernel_name: \"kernel_name\"\n+    arity: 42\n+  )pb\");\n \n   TF_ASSERT_OK_AND_ASSIGN(KernelLoaderSpec spec,\n                           KernelLoaderSpec::FromProto(proto));\n@@ -162,10 +160,10 @@ TEST(KernelLoaderSpec, CubinKernelFromProto) {\n \n TEST(KernelLoaderSpec, CubinKernelToProto) {\n   std::array<uint8_t, 5> kCubin = {'C', 'U', 'B', 'I', 'N'};\n-  auto spec = stream_executor::KernelLoaderSpec::CreateCudaCubinInMemorySpec(\n-      kCubin, \"kernel_name\", 42);\n+  auto spec = KernelLoaderSpec::CreateCudaCubinInMemorySpec(\n+      kCubin, \"kernel_name\", /*arity=*/42);\n \n-  EXPECT_THAT(spec.ToProto(), absl_testing::IsOkAndHolds(EqualsProto(R\"pb(\n+  EXPECT_THAT(spec.ToProto(), IsOkAndHolds(EqualsProto(R\"pb(\n                 cubin { data: \"CUBIN\" }\n                 kernel_name: \"kernel_name\"\n                 arity: 42\n@@ -180,7 +178,7 @@ TEST(KernelLoaderSpec, InProcessSymbolFromProto) {\n   )pb\");\n \n   const auto symbol_resolver = [](absl::string_view name) {\n-    return absl::bit_cast<void*>(static_cast<uintptr_t>(0x1234567890));\n+    return InventPointerToCudaKernel(0x1234567890);\n   };\n \n   TF_ASSERT_OK_AND_ASSIGN(KernelLoaderSpec spec,\n@@ -189,8 +187,7 @@ TEST(KernelLoaderSpec, InProcessSymbolFromProto) {\n   EXPECT_EQ(spec.arity(), 42);\n   EXPECT_THAT(spec.in_process_symbol(),\n               Optional(Field(&InProcessSymbol::symbol,\n-                             absl::bit_cast<void*>(\n-                                 static_cast<uintptr_t>(0x1234567890)))));\n+                             InventPointerToCudaKernel(0x1234567890))));\n   EXPECT_THAT(spec.in_process_symbol(),\n               Optional(Field(&InProcessSymbol::persistent_name,\n                              \"persistent_kernel_name\")));\n@@ -201,16 +198,15 @@ TEST(KernelLoaderSpec, InProcessSymbolFromProto) {\n }\n \n TEST(KernelLoaderSpec, InProcessSymbolToProto) {\n-  auto non_serializable_spec =\n-      stream_executor::KernelLoaderSpec::CreateInProcessSymbolSpec(\n-          nullptr, \"kernel_name\", 42);\n+  auto non_serializable_spec = KernelLoaderSpec::CreateInProcessSymbolSpec(\n+      /*symbol=*/nullptr, \"kernel_name\", 42);\n \n   // InProcessSymbol specs without a persistent name cannot be serialized.\n   EXPECT_THAT(non_serializable_spec.ToProto(),\n               StatusIs(absl::StatusCode::kInvalidArgument));\n \n   auto serializable_spec =\n-      stream_executor::KernelLoaderSpec::CreateSerializableInProcessSymbolSpec(\n+      KernelLoaderSpec::CreateSerializableInProcessSymbolSpec(\n           \"persistent_kernel_name\", nullptr, \"kernel_name\", 42);\n   EXPECT_THAT(serializable_spec.ToProto(), IsOkAndHolds(EqualsProto(R\"pb(\n                 in_process_symbol { persistent_name: \"persistent_kernel_name\" }"
        }
    ],
    "stats": {
        "total": 87,
        "additions": 41,
        "deletions": 46
    }
}