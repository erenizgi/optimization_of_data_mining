{
    "author": "tensorflower-gardener",
    "message": "Cache uncompress functions\n\nPiperOrigin-RevId: 820213031",
    "sha": "2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99",
    "files": [
        {
            "sha": "59eae8fcca33b8e425c85df1bc0ed1f0173ff368",
            "filename": "tensorflow/python/data/experimental/ops/BUILD",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2FBUILD?ref=2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99",
            "patch": "@@ -1,4 +1,5 @@\n load(\"//tensorflow:strict.default.bzl\", \"py_strict_library\")\n+load(\"//tensorflow:tensorflow.default.bzl\", \"tf_py_strict_test\")\n \n package(\n     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n@@ -67,7 +68,7 @@ py_strict_library(\n     ],\n     deps = [\n         \":compression_ops\",\n-        \"//tensorflow/core:protos_all_py\",\n+        \"//tensorflow/core/protobuf:for_core_protos_py_proto\",\n         \"//tensorflow/python:tf2\",\n         \"//tensorflow/python/data/experimental/service:_pywrap_server_lib\",\n         \"//tensorflow/python/data/experimental/service:_pywrap_utils_exp\",\n@@ -82,10 +83,24 @@ py_strict_library(\n         \"//tensorflow/python/ops:experimental_dataset_ops_gen\",\n         \"//tensorflow/python/ops:string_ops\",\n         \"//tensorflow/python/saved_model:nested_structure_coder\",\n+        \"//tensorflow/python/util:nest\",\n         \"//tensorflow/python/util:tf_export\",\n     ],\n )\n \n+tf_py_strict_test(\n+    name = \"data_service_ops_test\",\n+    srcs = [\"data_service_ops_test.py\"],\n+    deps = [\n+        \":data_service_ops\",\n+        \"//tensorflow/python/framework:dtypes\",\n+        \"//tensorflow/python/framework:tensor_shape\",\n+        \"//tensorflow/python/framework:tensor_spec\",\n+        \"//tensorflow/python/ops/ragged:ragged_tensor\",\n+        \"//tensorflow/python/platform:client_testlib\",\n+    ],\n+)\n+\n py_strict_library(\n     name = \"distributed_save_op\",\n     srcs = ["
        },
        {
            "sha": "7ad917b377645fd4ff405b658af8123fe4c59445",
            "filename": "tensorflow/python/data/experimental/ops/data_service_ops.py",
            "status": "modified",
            "additions": 38,
            "deletions": 4,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2Fdata_service_ops.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2Fdata_service_ops.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2Fdata_service_ops.py?ref=2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99",
            "patch": "@@ -36,6 +36,7 @@\n from tensorflow.python.ops import gen_experimental_dataset_ops\n from tensorflow.python.ops import string_ops\n from tensorflow.python.saved_model import nested_structure_coder\n+from tensorflow.python.util import nest\n from tensorflow.python.util.tf_export import tf_export\n \n COMPRESSION_AUTO = \"AUTO\"\n@@ -228,6 +229,42 @@ def _to_string(dataset_id) -> str:\n           if isinstance(dataset_id, bytes) else str(dataset_id))\n \n \n+class HashableElementSpec:\n+  \"\"\"Wrapper for element_spec to make it hashable.\"\"\"\n+\n+  def __init__(self, element_spec):\n+    self.element_spec = element_spec\n+    self._flattened_reprs = tuple(repr(s) for s in nest.flatten(element_spec))\n+    self._hash = hash(self._flattened_reprs)\n+\n+  def __hash__(self):\n+    return self._hash\n+\n+  def __eq__(self, other):\n+    if not isinstance(other, HashableElementSpec):\n+      return NotImplemented\n+    return self._flattened_reprs == other._flattened_reprs\n+\n+\n+@functools.lru_cache(maxsize=128)\n+def _get_uncompress_func(\n+    hashable_spec: HashableElementSpec,\n+) -> structured_function.StructuredFunctionWrapper:\n+  \"\"\"Returns a cached StructuredFunctionWrapper for uncompression.\n+\n+  Args:\n+    hashable_spec: A HashableElementSpec wrapping a nested structure of\n+      `tf.TypeSpec`s representing the type of elements produced by the dataset.\n+  \"\"\"\n+  return structured_function.StructuredFunctionWrapper(\n+      lambda x: compression_ops.uncompress(\n+          x, output_spec=hashable_spec.element_spec\n+      ),\n+      transformation_name=\"DataServiceDataset.uncompress()\",\n+      input_structure=tensor.TensorSpec(shape=(), dtype=dtypes.variant),\n+  )\n+\n+\n class _DataServiceDatasetV2(dataset_ops.DatasetSource):\n   \"\"\"A `Dataset` that reads elements from the tf.data service.\"\"\"\n \n@@ -340,10 +377,7 @@ def __init__(self,\n         dtype=dtypes.int64,\n         name=\"max_outstanding_requests\")\n     self._element_spec = element_spec\n-    uncompress_func = structured_function.StructuredFunctionWrapper(\n-        lambda x: compression_ops.uncompress(x, output_spec=element_spec),\n-        transformation_name=\"DataServiceDataset.uncompress()\",\n-        input_structure=tensor.TensorSpec(shape=(), dtype=dtypes.variant))\n+    uncompress_func = _get_uncompress_func(HashableElementSpec(element_spec))\n     cross_trainer_cache_options = (\n         cross_trainer_cache._to_proto().SerializeToString()\n         if cross_trainer_cache else None)"
        },
        {
            "sha": "c1c1b3c7b3e228d1dc6a51ea6689f7e9edf8eb81",
            "filename": "tensorflow/python/data/experimental/ops/data_service_ops_test.py",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2Fdata_service_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2Fdata_service_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fdata%2Fexperimental%2Fops%2Fdata_service_ops_test.py?ref=2ec0b2b4cacfc1bd78d1575a0c4bea582611cc99",
            "patch": "@@ -0,0 +1,99 @@\n+# Copyright 2024 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Tests for HashableElementSpec and related functionality.\"\"\"\n+\n+from tensorflow.python.data.experimental.ops import data_service_ops\n+from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import tensor_shape\n+from tensorflow.python.framework import tensor_spec\n+from tensorflow.python.ops.ragged import ragged_tensor\n+from tensorflow.python.platform import test\n+\n+\n+class HashableElementSpecTest(test.TestCase):\n+\n+  def testEqual(self):\n+    spec1 = data_service_ops.HashableElementSpec(\n+        tensor_spec.TensorSpec(shape=(), dtype=dtypes.int32)\n+    )\n+    spec2 = data_service_ops.HashableElementSpec(\n+        tensor_spec.TensorSpec(shape=(), dtype=dtypes.int32)\n+    )\n+    self.assertEqual(spec1, spec2)\n+    self.assertEqual(hash(spec1), hash(spec2))\n+\n+  def testNotEqual(self):\n+    spec1 = data_service_ops.HashableElementSpec(\n+        tensor_spec.TensorSpec(shape=(), dtype=dtypes.int32)\n+    )\n+    spec2 = data_service_ops.HashableElementSpec(\n+        tensor_spec.TensorSpec(shape=(), dtype=dtypes.int64)\n+    )\n+    self.assertNotEqual(spec1, spec2)\n+    self.assertNotEqual(hash(spec1), hash(spec2))\n+\n+  def testNotEqualOtherType(self):\n+    spec1 = data_service_ops.HashableElementSpec(\n+        tensor_spec.TensorSpec(shape=(), dtype=dtypes.int32)\n+    )\n+    self.assertNotEqual(spec1, 123)\n+\n+  def testGetUncompressFuncCache(self):\n+    spec1 = tensor_spec.TensorSpec(shape=(), dtype=dtypes.int32)\n+    spec2 = tensor_spec.TensorSpec(shape=(), dtype=dtypes.int64)\n+    data_service_ops._get_uncompress_func.cache_clear()\n+    func1 = data_service_ops._get_uncompress_func(\n+        data_service_ops.HashableElementSpec(spec1)\n+    )\n+    func2 = data_service_ops._get_uncompress_func(\n+        data_service_ops.HashableElementSpec(spec1)\n+    )\n+    func3 = data_service_ops._get_uncompress_func(\n+        data_service_ops.HashableElementSpec(spec2)\n+    )\n+    self.assertIs(func1, func2)\n+    self.assertIsNot(func1, func3)\n+\n+  def testRaggedTensorUncompressFuncCache(self):\n+    spec1 = ragged_tensor.RaggedTensorSpec(\n+        [3, None], dtypes.int32, 1, dtypes.int64\n+    )\n+    spec1_long_format = ragged_tensor.RaggedTensorSpec(\n+        tensor_shape.TensorShape(\n+            [tensor_shape.Dimension(3), tensor_shape.Dimension(None)]\n+        ),\n+        dtypes.int32,\n+        1,\n+        dtypes.int64,\n+    )\n+    spec2 = ragged_tensor.RaggedTensorSpec(\n+        ([3, None]), dtypes.int64, 1, dtypes.int64\n+    )\n+    data_service_ops._get_uncompress_func.cache_clear()\n+    func1a = data_service_ops._get_uncompress_func(\n+        data_service_ops.HashableElementSpec(spec1)\n+    )\n+    func1b = data_service_ops._get_uncompress_func(\n+        data_service_ops.HashableElementSpec(spec1_long_format)\n+    )\n+    func2 = data_service_ops._get_uncompress_func(\n+        data_service_ops.HashableElementSpec(spec2)\n+    )\n+    self.assertIs(func1a, func1b)\n+    self.assertIsNot(func1a, func2)\n+\n+\n+if __name__ == \"__main__\":\n+  test.main()"
        }
    ],
    "stats": {
        "total": 158,
        "additions": 153,
        "deletions": 5
    }
}