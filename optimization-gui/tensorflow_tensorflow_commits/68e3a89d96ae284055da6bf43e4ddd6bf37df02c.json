{
    "author": "tensorflower-gardener",
    "message": "[SymbolicMap] Add AffineMap from/to converters\n\nAdds methods to convert from/to SymbolicMap-AffineMap. Implemented in `symbolic_map_converter.cc` to keep the dependencies clean.\n\nPiperOrigin-RevId: 807593543",
    "sha": "68e3a89d96ae284055da6bf43e4ddd6bf37df02c",
    "files": [
        {
            "sha": "eff889bf953a50dab7fbbb7422b29cc9bb347a60",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/BUILD",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD?ref=68e3a89d96ae284055da6bf43e4ddd6bf37df02c",
            "patch": "@@ -261,3 +261,30 @@ xla_cc_test(\n         \"@llvm-project//llvm:Support\",\n     ],\n )\n+\n+cc_library(\n+    name = \"symbolic_map_converter\",\n+    srcs = [\"symbolic_map_converter.cc\"],\n+    hdrs = [\"symbolic_map_converter.h\"],\n+    deps = [\n+        \":symbolic_expr\",\n+        \":symbolic_map\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:IR\",\n+        \"@llvm-project//mlir:Support\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"symbolic_map_converter_test\",\n+    srcs = [\"symbolic_map_converter_test.cc\"],\n+    deps = [\n+        \":symbolic_expr\",\n+        \":symbolic_map\",\n+        \":symbolic_map_converter\",\n+        \"//xla/hlo/analysis:indexing_test_utils\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)"
        },
        {
            "sha": "7ee64c018e8e07b1b965778a01635b6f528d06cc",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter.cc",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc?ref=68e3a89d96ae284055da6bf43e4ddd6bf37df02c",
            "patch": "@@ -0,0 +1,148 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/service/gpu/model/experimental/symbolic_map_converter.h\"\n+\n+#include <cstdint>\n+\n+#include \"llvm/ADT/SmallVector.h\"\n+#include \"mlir/IR/AffineExpr.h\"\n+#include \"mlir/IR/AffineMap.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"mlir/Support/LLVM.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_map.h\"\n+\n+namespace xla {\n+namespace gpu {\n+namespace {\n+\n+// Helper function to convert mlir::AffineExpr to xla::gpu::SymbolicExpr.\n+SymbolicExpr AffineToSymbolic(mlir::AffineExpr affine_expr,\n+                              SymbolicExprContext* context, int num_dims) {\n+  switch (affine_expr.getKind()) {\n+    case mlir::AffineExprKind::Constant:\n+      return context->CreateConstant(\n+          mlir::cast<mlir::AffineConstantExpr>(affine_expr).getValue());\n+    case mlir::AffineExprKind::DimId:\n+      return context->CreateVariable(\n+          mlir::cast<mlir::AffineDimExpr>(affine_expr).getPosition());\n+    case mlir::AffineExprKind::SymbolId:\n+      return context->CreateVariable(\n+          mlir::cast<mlir::AffineSymbolExpr>(affine_expr).getPosition() +\n+          num_dims);\n+    case mlir::AffineExprKind::Add: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolic(bin_op.getLHS(), context, num_dims) +\n+             AffineToSymbolic(bin_op.getRHS(), context, num_dims);\n+    }\n+    case mlir::AffineExprKind::Mul: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolic(bin_op.getLHS(), context, num_dims) *\n+             AffineToSymbolic(bin_op.getRHS(), context, num_dims);\n+    }\n+    case mlir::AffineExprKind::FloorDiv: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolic(bin_op.getLHS(), context, num_dims)\n+          .floorDiv(AffineToSymbolic(bin_op.getRHS(), context, num_dims));\n+    }\n+    case mlir::AffineExprKind::CeilDiv: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolic(bin_op.getLHS(), context, num_dims)\n+          .ceilDiv(AffineToSymbolic(bin_op.getRHS(), context, num_dims));\n+    }\n+    case mlir::AffineExprKind::Mod: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolic(bin_op.getLHS(), context, num_dims) %\n+             AffineToSymbolic(bin_op.getRHS(), context, num_dims);\n+    }\n+  }\n+}\n+\n+// Helper function to convert xla::gpu::SymbolicExpr to mlir::AffineExpr.\n+mlir::AffineExpr SymbolicToAffine(SymbolicExpr symbolic_expr,\n+                                  mlir::MLIRContext* context, int num_dims) {\n+  mlir::AffineExpr lhs, rhs;\n+  if (symbolic_expr.GetLHS() && symbolic_expr.GetRHS()) {\n+    lhs = SymbolicToAffine(symbolic_expr.GetLHS(), context, num_dims);\n+    rhs = SymbolicToAffine(symbolic_expr.GetRHS(), context, num_dims);\n+    if (!lhs || !rhs) {\n+      return mlir::AffineExpr();\n+    }\n+  }\n+\n+  switch (symbolic_expr.GetType()) {\n+    case SymbolicExprType::kConstant:\n+      return mlir::getAffineConstantExpr(symbolic_expr.GetValue(), context);\n+    case SymbolicExprType::kVariable: {\n+      int64_t id = symbolic_expr.GetValue();\n+      if (id < num_dims) {\n+        return mlir::getAffineDimExpr(id, context);\n+      }\n+      return mlir::getAffineSymbolExpr(id - num_dims, context);\n+    }\n+    case SymbolicExprType::kAdd:\n+      return lhs + rhs;\n+    case SymbolicExprType::kMul:\n+      return lhs * rhs;\n+    case SymbolicExprType::kFloorDiv:\n+      return mlir::getAffineBinaryOpExpr(mlir::AffineExprKind::FloorDiv, lhs,\n+                                         rhs);\n+    case SymbolicExprType::kCeilDiv:\n+      return mlir::getAffineBinaryOpExpr(mlir::AffineExprKind::CeilDiv, lhs,\n+                                         rhs);\n+    case SymbolicExprType::kMod:\n+      return mlir::getAffineBinaryOpExpr(mlir::AffineExprKind::Mod, lhs, rhs);\n+    default:\n+      // kMax and kMin are not supported in mlir::AffineExpr.\n+      return mlir::AffineExpr();\n+  }\n+}\n+\n+}  // namespace\n+\n+SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n+                                   SymbolicExprContext* context) {\n+  llvm::SmallVector<SymbolicExpr> results;\n+  results.reserve(affine_map.getNumResults());\n+  int num_dims = affine_map.getNumDims();\n+  for (mlir::AffineExpr expr : affine_map.getResults()) {\n+    results.push_back(AffineToSymbolic(expr, context, num_dims));\n+  }\n+  return SymbolicMap::Get(context, num_dims, affine_map.getNumSymbols(),\n+                          results);\n+}\n+\n+mlir::AffineMap SymbolicMapToAffineMap(SymbolicMap symbolic_map,\n+                                       mlir::MLIRContext* context) {\n+  int num_dims = symbolic_map.GetNumDims();\n+  int num_symbols = symbolic_map.GetNumSymbols();\n+  llvm::SmallVector<mlir::AffineExpr> results;\n+  results.reserve(symbolic_map.GetNumResults());\n+  for (SymbolicExpr expr : symbolic_map.GetResults()) {\n+    mlir::AffineExpr affine_expr =\n+        SymbolicToAffine(expr, context, symbolic_map.GetNumDims());\n+    if (!affine_expr) {\n+      // Conversion failed.\n+      return mlir::AffineMap();\n+    }\n+    results.push_back(affine_expr);\n+  }\n+\n+  return mlir::AffineMap::get(num_dims, num_symbols, results, context);\n+}\n+\n+}  // namespace gpu\n+}  // namespace xla"
        },
        {
            "sha": "8737c231836aabb87f08923a340c6af3b2adfe7f",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter.h",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h?ref=68e3a89d96ae284055da6bf43e4ddd6bf37df02c",
            "patch": "@@ -0,0 +1,38 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_SERVICE_GPU_MODEL_EXPERIMENTAL_SYMBOLIC_MAP_CONVERTER_H_\n+#define XLA_SERVICE_GPU_MODEL_EXPERIMENTAL_SYMBOLIC_MAP_CONVERTER_H_\n+\n+#include \"mlir/IR/AffineMap.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_map.h\"\n+\n+namespace xla {\n+namespace gpu {\n+\n+// Converts an mlir::AffineMap to xla::gpu::SymbolicMap.\n+SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n+                                   SymbolicExprContext* context);\n+\n+// Converts xla::gpu::SymbolicMap to an mlir::AffineMap.\n+// Returns a null AffineMap if the conversion is not possible.\n+mlir::AffineMap SymbolicMapToAffineMap(SymbolicMap symbolic_map,\n+                                       mlir::MLIRContext* context);\n+\n+}  // namespace gpu\n+}  // namespace xla\n+\n+#endif  // XLA_SERVICE_GPU_MODEL_EXPERIMENTAL_SYMBOLIC_MAP_CONVERTER_H_"
        },
        {
            "sha": "a166e89f12ed6014098bc21c394af5437ec252bf",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter_test.cc",
            "status": "added",
            "additions": 86,
            "deletions": 0,
            "changes": 86,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/68e3a89d96ae284055da6bf43e4ddd6bf37df02c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc?ref=68e3a89d96ae284055da6bf43e4ddd6bf37df02c",
            "patch": "@@ -0,0 +1,86 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/service/gpu/model/experimental/symbolic_map_converter.h\"\n+\n+#include <gtest/gtest.h>\n+#include \"llvm/ADT/SmallVector.h\"\n+#include \"mlir/IR/AffineExpr.h\"\n+#include \"mlir/IR/AffineMap.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/hlo/analysis/indexing_test_utils.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_map.h\"\n+\n+namespace xla {\n+namespace gpu {\n+namespace {\n+\n+using ::mlir::AffineMap;\n+using ::mlir::MLIRContext;\n+\n+TEST(SymbolicMapConverterTest, AffineToSymbolicRoundTrip) {\n+  MLIRContext mlir_context;\n+  SymbolicExprContext symbolic_context;\n+\n+  AffineMap affine_map = ParseAffineMap(\n+      \"(d0, d1)[s0, s1] -> (d0 + s1 * 2, d1 - s0, d0 floordiv 3, d1 mod 4)\",\n+      &mlir_context);\n+\n+  SymbolicMap symbolic_map =\n+      AffineMapToSymbolicMap(affine_map, &symbolic_context);\n+\n+  EXPECT_EQ(symbolic_map.GetNumResults(), 4);\n+\n+  AffineMap round_trip_map =\n+      SymbolicMapToAffineMap(symbolic_map, &mlir_context);\n+  EXPECT_EQ(affine_map, round_trip_map);\n+}\n+\n+TEST(SymbolicMapConverterTest, SymbolicToAffineFailure) {\n+  MLIRContext mlir_context;\n+  SymbolicExprContext symbolic_context;\n+\n+  SymbolicExpr d0 = symbolic_context.CreateVariable(0);\n+  SymbolicExpr c1 = symbolic_context.CreateConstant(1);\n+  // kMax is not representable in AffineExpr.\n+  SymbolicExpr max_expr = d0.max(c1);\n+\n+  AffineMap affine_map = SymbolicMapToAffineMap(\n+      SymbolicMap::Get(&symbolic_context, 1, 0, {max_expr}), &mlir_context);\n+  EXPECT_FALSE(affine_map);\n+}\n+\n+TEST(SymbolicMapConverterTest, SymbolicToAffineNestedFailure) {\n+  MLIRContext mlir_context;\n+  SymbolicExprContext symbolic_context;\n+\n+  SymbolicExpr d0 = symbolic_context.CreateVariable(0);\n+  SymbolicExpr c1 = symbolic_context.CreateConstant(1);\n+  SymbolicExpr c2 = symbolic_context.CreateConstant(2);\n+\n+  // d0 + max(c1, c2). max is not representable in AffineExpr.\n+  SymbolicExpr nested_max_expr = d0 + c1.max(c2);\n+\n+  // This should not crash and should return a null AffineMap.\n+  AffineMap affine_map = SymbolicMapToAffineMap(\n+      SymbolicMap::Get(&symbolic_context, 1, 0, {nested_max_expr}),\n+      &mlir_context);\n+  EXPECT_FALSE(affine_map);\n+}\n+\n+}  // namespace\n+}  // namespace gpu\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 299,
        "additions": 299,
        "deletions": 0
    }
}