{
    "author": "mkuperst",
    "message": "[XLA] Make TryRemoveRepeatedWhileTupleIndices faster, step 2/2.\n\nFollows up on step 1 by making the dynamic-update-slice case behave in the same way.\n\nReverts 2136cdc2180283b2187558ef0abb78c397723587\n\nPiperOrigin-RevId: 797301633",
    "sha": "7b11943b9ea336cf64d7c0a5a7d3e849554149fc",
    "files": [
        {
            "sha": "d97ed547a8d24307bf1fddc65ac26d9f6083416b",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b11943b9ea336cf64d7c0a5a7d3e849554149fc/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b11943b9ea336cf64d7c0a5a7d3e849554149fc/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=7b11943b9ea336cf64d7c0a5a7d3e849554149fc",
            "patch": "@@ -2946,6 +2946,7 @@ xla_cc_test(\n         \"//xla/hlo/utils:hlo_matchers\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_googletest//:gtest\","
        },
        {
            "sha": "183bdc6aee7c5ef75033cae30c25b477e26982b2",
            "filename": "third_party/xla/xla/service/while_loop_simplifier.cc",
            "status": "modified",
            "additions": 76,
            "deletions": 171,
            "changes": 247,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b11943b9ea336cf64d7c0a5a7d3e849554149fc/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b11943b9ea336cf64d7c0a5a7d3e849554149fc/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier.cc?ref=7b11943b9ea336cf64d7c0a5a7d3e849554149fc",
            "patch": "@@ -148,7 +148,8 @@ void CopyMetadata(HloInstruction* old_while_op, HloInstruction* new_while_op) {\n // indices in the final shape with a copy of the removed index.\n static absl::StatusOr<HloInstruction*> RemoveDeadTupleIndices(\n     HloInstruction* while_op, absl::flat_hash_set<int64_t>& used_tuple_indices,\n-    int64_t index_for_replaced = -1) {\n+    std::optional<absl::flat_hash_map<int32_t, int32_t>>\n+        dead_to_surviving_index = std::nullopt) {\n   // Build up maps from the old/new to the new/old tuple indices.\n   std::vector<int64_t> new_to_old_tuple_idx(used_tuple_indices.begin(),\n                                             used_tuple_indices.end());\n@@ -296,10 +297,12 @@ static absl::StatusOr<HloInstruction*> RemoveDeadTupleIndices(\n   for (int64_t old_idx = 0; old_idx < tuple_size; ++old_idx) {\n     auto new_tuple_idx_it = old_to_new_tuple_idx.find(old_idx);\n     if (new_tuple_idx_it != old_to_new_tuple_idx.end() ||\n-        index_for_replaced != -1) {\n-      int64_t gte_idx = new_tuple_idx_it != old_to_new_tuple_idx.end()\n-                            ? new_tuple_idx_it->second\n-                            : index_for_replaced;\n+        dead_to_surviving_index.has_value()) {\n+      int64_t gte_idx =\n+          new_tuple_idx_it != old_to_new_tuple_idx.end()\n+              ? new_tuple_idx_it->second\n+              : old_to_new_tuple_idx.find((*dead_to_surviving_index)[old_idx])\n+                    ->second;\n       new_tuple_elems.push_back(\n           computation->AddInstruction(HloInstruction::CreateGetTupleElement(\n               new_while_op->shape().tuple_shapes(gte_idx), new_while_op,\n@@ -573,58 +576,6 @@ absl::StatusOr<bool> TryRemoveDeadWhileParams(HloInstruction* while_op) {\n   return true;\n }\n \n-// This is a helper function for TryRemoveRepeatedWhileTupleIndices. It removes\n-// duplicates by replacing them with tuple_index, followed by a call to\n-// RemoveDeadTupleIndices.\n-static absl::StatusOr<HloInstruction*> TryRemoveRepeatedWhileTupleIndicesHelper(\n-    HloInstruction* while_op, const int64_t tuple_index, bool replace_with_init,\n-    absl::flat_hash_set<int64_t>& duplicates) {\n-  HloComputation* while_cond = while_op->while_condition();\n-  HloComputation* while_body = while_op->while_body();\n-  HloInstruction* while_init = while_op->mutable_operand(0);\n-\n-  VLOG(2) << \"while_init \" << while_init->ToString() << \" operands \"\n-          << while_init->operand_count();\n-  VLOG(2) << \"while_body_root \" << while_body->root_instruction()->ToString()\n-          << \" operands \" << while_body->root_instruction()->operand_count();\n-\n-  // Change the loop body and condition such that uses of the duplicates are\n-  // replaced with the original tuple element.\n-  for (HloComputation* comp : {while_body, while_cond}) {\n-    auto new_get = comp->AddInstruction(HloInstruction::CreateGetTupleElement(\n-        comp->parameter_instruction(0)->shape().tuple_shapes(tuple_index),\n-        comp->parameter_instruction(0), tuple_index));\n-\n-    std::vector<HloInstruction*> instrs_to_replace;\n-    for (auto* instr : comp->instructions()) {\n-      if (instr->opcode() == HloOpcode::kGetTupleElement &&\n-          duplicates.contains(instr->tuple_index()) &&\n-          instr->operand(0) == comp->parameter_instruction(0)) {\n-        instrs_to_replace.push_back(instr);\n-      }\n-    }\n-\n-    for (auto instr : instrs_to_replace) {\n-      TF_RETURN_IF_ERROR(comp->ReplaceInstruction(instr, new_get));\n-    }\n-  }\n-\n-  // We know which tuple indices are useful; i.e, those which aren't duplicates.\n-  absl::flat_hash_set<int64_t> used_tuple_indices;\n-  for (int index = 0; index < while_init->shape().tuple_shapes().size();\n-       ++index) {\n-    if (!duplicates.count(index)) {\n-      used_tuple_indices.insert(index);\n-    }\n-  }\n-  // Remove the duplicate tuple elements.\n-  TF_ASSIGN_OR_RETURN(\n-      while_op, RemoveDeadTupleIndices(while_op, used_tuple_indices,\n-                                       replace_with_init ? -1 : tuple_index));\n-\n-  return while_op;\n-}\n-\n // Returns if this instruction looks like an insertion inside a variable of a\n // while loop.\n static bool IsDynamicUpdateSliceWhileInsertion(\n@@ -635,12 +586,10 @@ static bool IsDynamicUpdateSliceWhileInsertion(\n }\n \n namespace {\n-// TODO(b/434256891): This won't need to return the WhileOp and can just return\n-// bool once we fix the DynamicUpdateSlice case.\n+template <typename KeyToIndicesMap>\n absl::StatusOr<HloInstruction*> RemoveRepeatedWhileTupleIndices(\n-    HloInstruction* while_op,\n-    const absl::flat_hash_map<const HloInstruction*, std::vector<int32_t>>&\n-        init_to_indices) {\n+    HloInstruction* while_op, const KeyToIndicesMap& key_to_indices,\n+    bool replace_with_init) {\n   // We want to do two things here:\n   // a) Make sure that all of the Param -> GTE(i) -> ROOT Tuple chains where the\n   // indices belong to the same equivalence set use the same index.\n@@ -649,7 +598,7 @@ absl::StatusOr<HloInstruction*> RemoveRepeatedWhileTupleIndices(\n   // First, find all the indices that belong to a non-trivial (size >= 2) set,\n   // and decide, for each set, which index to keep, and which will be removed.\n   absl::flat_hash_map<int32_t, int32_t> dead_to_surviving_index;\n-  for (const auto& [init_elem, indices] : init_to_indices) {\n+  for (const auto& [key, indices] : key_to_indices) {\n     if (indices.size() < 2) {\n       continue;\n     }\n@@ -709,12 +658,36 @@ absl::StatusOr<HloInstruction*> RemoveRepeatedWhileTupleIndices(\n     }\n   }\n \n-  TF_ASSIGN_OR_RETURN(while_op,\n-                      RemoveDeadTupleIndices(while_op, used_tuple_indices, -1));\n+  TF_ASSIGN_OR_RETURN(\n+      while_op,\n+      RemoveDeadTupleIndices(\n+          while_op, used_tuple_indices,\n+          replace_with_init ? std::nullopt\n+                            : std::make_optional(dead_to_surviving_index)));\n \n   return while_op;\n }\n \n+struct RepeatedWhileTupleIndicesKey {\n+  const HloInstruction* init_value;\n+  const HloInstruction* dynamic_update_slice_value;\n+  std::vector<const HloInstruction*> dynamic_update_slice_indices;\n+};\n+\n+bool operator==(const RepeatedWhileTupleIndicesKey& lhs,\n+                const RepeatedWhileTupleIndicesKey& rhs) {\n+  return lhs.init_value == rhs.init_value &&\n+         lhs.dynamic_update_slice_value == rhs.dynamic_update_slice_value &&\n+         absl::c_equal(lhs.dynamic_update_slice_indices,\n+                       rhs.dynamic_update_slice_indices);\n+}\n+\n+template <typename H>\n+H AbslHashValue(H h, const RepeatedWhileTupleIndicesKey& key) {\n+  return H::combine(std::move(h), key.init_value,\n+                    key.dynamic_update_slice_value,\n+                    key.dynamic_update_slice_indices);\n+}\n }  // namespace\n \n // If the while loop init passes the same values to several tuple indices, and\n@@ -731,9 +704,7 @@ static absl::StatusOr<bool> TryRemoveRepeatedWhileTupleIndices(\n     return false;\n   }\n \n-  // TODO(b/434256891): These should become const when we fix the DUS case too.\n   HloInstruction* while_init = while_op->mutable_operand(0);\n-  HloComputation* while_cond = while_op->while_condition();\n   HloComputation* while_body = while_op->while_body();\n   HloInstruction* while_body_root = while_body->root_instruction();\n \n@@ -754,129 +725,63 @@ static absl::StatusOr<bool> TryRemoveRepeatedWhileTupleIndices(\n     return false;\n   }\n \n-  bool changed = false;\n-\n-  // TODO(b/434256891): Fix the DynamicUpdateSlice case in a similar fashion.\n   absl::flat_hash_map<const HloInstruction*, std::vector<int32_t>>\n       init_to_indices;\n+  absl::flat_hash_map<RepeatedWhileTupleIndicesKey, std::vector<int32_t>>\n+      dus_key_to_indices;\n+  const auto gte_at_index = [](const HloInstruction* maybe_gte, int32_t index) {\n+    return maybe_gte->opcode() == HloOpcode::kGetTupleElement &&\n+           maybe_gte->operand(0) ==\n+               maybe_gte->parent()->parameter_instruction(0) &&\n+           maybe_gte->tuple_index() == index;\n+  };\n+\n   // For each index in the input tuple, find all the indices where the only use\n-  // in the while body is `Param -> GTE(index) -> ROOT Tuple`, and split such\n-  // indices into equivalence sets based on the input value into the while.\n+  // in the while body is either `Param -> GTE(index) -> ROOT Tuple`, or the\n+  // dynamic-update-slice equivalent, and split such indices into equivalence\n+  // sets based on the input value into the while.\n   for (int index = 0; index < while_init->shape().tuple_shapes().size();\n        ++index) {\n     const HloInstruction* body_elem = while_body_root->operand(index);\n-    if (body_elem->opcode() != HloOpcode::kGetTupleElement ||\n-        body_elem->operand(0) != while_body->parameter_instruction(0) ||\n-        body_elem->tuple_index() != index) {\n-      continue;\n-    }\n     const HloInstruction* init_elem = while_init->operand(index);\n-    init_to_indices[init_elem].push_back(index);\n+    if (gte_at_index(body_elem, index)) {\n+      init_to_indices[init_elem].push_back(index);\n+    }\n   }\n \n   // Only keep one index for each equivalence set.\n   HloInstruction* original_while_op = while_op;\n   TF_ASSIGN_OR_RETURN(\n-      while_op, RemoveRepeatedWhileTupleIndices(while_op, init_to_indices));\n-  if (while_op != original_while_op) {\n-    changed = true;\n-  }\n+      while_op, RemoveRepeatedWhileTupleIndices(while_op, init_to_indices,\n+                                                /*replace_with_init=*/true));\n \n+  // In theory, we could handle the \"simple\" case and the \"dynamic-update-slice\"\n+  // case in one go, but it's probably not worth the added complexity, so do it\n+  // separately.\n   while_init = while_op->mutable_operand(0);\n-  while_cond = while_op->while_condition();\n   while_body = while_op->while_body();\n   while_body_root = while_body->root_instruction();\n-\n-  int index_to_investigate = 0;\n-  while (index_to_investigate < while_init->shape().tuple_shapes().size()) {\n-    auto& while_shape = while_init->shape();\n-    VLOG(2) << \"Iterating \" << index_to_investigate;\n-\n-    absl::flat_hash_set<int64_t> duplicates;\n-    auto* pivot_init_elem = while_init->operand(index_to_investigate);\n-    auto* pivot_body_elem = while_body_root->operand(index_to_investigate);\n-    if (IsDynamicUpdateSliceWhileInsertion(pivot_body_elem, while_body)) {\n-      if (pivot_body_elem->operand(0)->tuple_index() != index_to_investigate) {\n-        VLOG(2)\n-            << \"Mismatch between pivot_body_elem->operand(0)->tuple_index() \"\n-            << pivot_body_elem->operand(0)->tuple_index()\n-            << \" index_to_investigate \" << index_to_investigate;\n-        index_to_investigate++;\n-        continue;\n-      }\n-    } else {\n-      index_to_investigate++;\n-      continue;\n-    }\n-\n-    // Look from index_to_investigate onwards to see if it is repeated.\n-    for (int64_t i = index_to_investigate + 1;\n-         i < while_shape.tuple_shapes().size(); ++i) {\n-      auto* init_elem = while_init->operand(i);\n-      auto* body_elem = while_body_root->operand(i);\n-      if (IsDynamicUpdateSliceWhileInsertion(pivot_body_elem, while_body) &&\n-          IsDynamicUpdateSliceWhileInsertion(body_elem, while_body)) {\n-        if (pivot_body_elem->operand_count() != body_elem->operand_count()) {\n-          VLOG(2) << \"Mismatch in operand count of dynamic-update-slice \"\n-                  << pivot_body_elem->operand_count() << \" vs \"\n-                  << body_elem->operand_count();\n-          continue;\n-        }\n-        if (body_elem->operand(0)->tuple_index() != i) {\n-          VLOG(2) << \"Mismatch between body_elem->operand(0)->tuple_index() \"\n-                  << body_elem->operand(0)->tuple_index() << \" i \" << i;\n-          continue;\n-        }\n-        if (pivot_body_elem->operand(0) == body_elem->operand(0)) {\n-          VLOG(2) << \"Inserting in the same input index\";\n-          continue;\n-        }\n-        bool mismatch = false;\n-        for (int64_t i = 1; i < body_elem->operand_count(); ++i) {\n-          if (body_elem->operand(i) != pivot_body_elem->operand(i)) {\n-            VLOG(2) << \"Mismatch in insertion indices or values\";\n-            mismatch = true;\n-            break;\n-          }\n-        }\n-        if (mismatch) {\n-          continue;\n-        }\n-      } else {\n-        continue;\n-      }\n-\n-      if (pivot_init_elem == init_elem) {\n-        VLOG(2) << \"init_elem \" << init_elem->ToString() << \" pivot_init_elem \"\n-                << pivot_init_elem->ToString();\n-        VLOG(2) << \"body_elem \" << body_elem->ToString() << \" pivot_body_elem \"\n-                << pivot_body_elem->ToString();\n-        duplicates.insert(i);\n-      }\n-    }\n-\n-    // If duplicates are found, call the helper to remove them.\n-    if (!duplicates.empty()) {\n-      VLOG(2) << \"Duplicate found \" << duplicates.size() << \" pivot_init \"\n-              << pivot_init_elem->ToString();\n-      TF_ASSIGN_OR_RETURN(while_op,\n-                          TryRemoveRepeatedWhileTupleIndicesHelper(\n-                              while_op, index_to_investigate,\n-                              /*replace_with_init=*/false, duplicates));\n-      changed = true;\n-      VLOG(2) << \"Changed while_op \" << while_op->ToString()\n-              << \" while_op operand count \" << while_op->operand_count();\n-      // Update the while loop variables so we can continue looking for\n-      // duplicates of a different index.\n-      while_init = while_op->mutable_operand(0);\n-      while_cond = while_op->while_condition();\n-      while_body = while_op->while_body();\n-      while_body_root = while_body->root_instruction();\n+  for (int index = 0; index < while_init->shape().tuple_shapes().size();\n+       ++index) {\n+    const HloInstruction* body_elem = while_body_root->operand(index);\n+    const HloInstruction* init_elem = while_init->operand(index);\n+    if (body_elem->opcode() == HloOpcode::kDynamicUpdateSlice &&\n+        gte_at_index(body_elem->operand(0), index)) {\n+      const HloDynamicIndexInstruction* dus =\n+          Cast<HloDynamicIndexInstruction>(body_elem);\n+      dus_key_to_indices[RepeatedWhileTupleIndicesKey{\n+                             init_elem, body_elem->operand(1),\n+                             std::vector<const HloInstruction*>(\n+                                 dus->index_operands().begin(),\n+                                 dus->index_operands().end())}]\n+          .push_back(index);\n     }\n-    index_to_investigate++;\n   }\n+  TF_ASSIGN_OR_RETURN(\n+      while_op, RemoveRepeatedWhileTupleIndices(while_op, dus_key_to_indices,\n+                                                /*replace_with_init=*/false));\n \n-  return changed;\n+  return while_op != original_while_op;\n }\n \n // Removes each loop parameter (i.e. member of the while loop tuple) that is a"
        },
        {
            "sha": "953526affe78eea4de8a645f256f3bcf0b547699",
            "filename": "third_party/xla/xla/service/while_loop_simplifier_test.cc",
            "status": "modified",
            "additions": 133,
            "deletions": 0,
            "changes": 133,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b11943b9ea336cf64d7c0a5a7d3e849554149fc/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b11943b9ea336cf64d7c0a5a7d3e849554149fc/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_simplifier_test.cc?ref=7b11943b9ea336cf64d7c0a5a7d3e849554149fc",
            "patch": "@@ -37,6 +37,7 @@ limitations under the License.\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla {\n@@ -1346,6 +1347,138 @@ ENTRY %main.44 (Arg_0.1: f32[]) -> (f32[], f32[3], f32[3]) {\n   EXPECT_TRUE(ShapeUtil::Equal(\n       new_while->while_condition()->parameter_instruction(0)->shape(),\n       new_while_shape));\n+  EXPECT_TRUE(TupleSimplifier().Run(m.get()).ok());\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              op::Tuple(op::GetTupleElement(op::While(), 1),\n+                        op::GetTupleElement(op::While(), 2),\n+                        op::GetTupleElement(op::While(), 2)));\n+}\n+\n+TEST_F(WhileLoopSimplifierTest, RemoveDynUpdSliceTwoPairs) {\n+  const std::string hlo_string = R\"(\n+  HloModule dus\n+\n+%while.body (arg_tuple: (f32[3], f32[3], f32[3], f32[3], s32[])) -> (f32[3], f32[3], f32[3], f32[3], s32[]) {\n+  %arg_tuple = (f32[3], f32[3], f32[3], f32[3], s32[]) parameter(0)\n+  %get-tuple-element.0 = f32[3] get-tuple-element(%arg_tuple), index=0\n+  %get-tuple-element.1 = f32[3] get-tuple-element(%arg_tuple), index=1\n+  %get-tuple-element.2 = f32[3] get-tuple-element(%arg_tuple), index=2\n+  %get-tuple-element.3 = f32[3] get-tuple-element(%arg_tuple), index=3\n+  %get-tuple-element.4 = s32[] get-tuple-element(%arg_tuple), index=4\n+  %constant.1 = s32[] constant(1)\n+  %constant.v0 = f32[1] constant({0.0})\n+  %constant.v1 = f32[1] constant({1.0})\n+  %dynamic-update-slice.0 = f32[3] dynamic-update-slice(%get-tuple-element.0, %constant.v0, s32[] %constant.1)\n+  %dynamic-update-slice.1 = f32[3] dynamic-update-slice(%get-tuple-element.1, %constant.v1, s32[] %get-tuple-element.4)\n+  %dynamic-update-slice.2 = f32[3] dynamic-update-slice(%get-tuple-element.2, %constant.v1, s32[] %get-tuple-element.4)\n+  %dynamic-update-slice.3 = f32[3] dynamic-update-slice(%get-tuple-element.3, %constant.v0, s32[] %constant.1)\n+  %add = add(s32[] %get-tuple-element.4, s32[] %constant.1)\n+  ROOT %tuple = tuple(%dynamic-update-slice.0, %dynamic-update-slice.1, %dynamic-update-slice.2, %dynamic-update-slice.3, %add)\n+}\n+\n+%while.condition (arg_tuple.cond:(f32[3], f32[3], f32[3], f32[3], s32[])) -> pred[] {\n+  %arg_tuple.cond = (f32[3], f32[3], f32[3], f32[3], s32[]) parameter(0)\n+  %get-tuple-element.cond = s32[] get-tuple-element(%arg_tuple.cond), index=4\n+  %constant.3 = s32[] constant(3)\n+  ROOT %compare = pred[] compare(s32[] %get-tuple-element.cond, s32[] %constant.3), direction=LT\n+}\n+\n+ENTRY %main (arg.0: f32[3], arg.1: f32[3]) -> (f32[3], f32[3], f32[3], f32[3]) {\n+  %constant.0 = s32[] constant(0)\n+  %arg.0 = f32[3] parameter(0)\n+  %arg.1 = f32[3] parameter(1)\n+  %input = tuple(%arg.0, %arg.1, %arg.1, %arg.0, %constant.0)\n+  %while = while(%input), condition=%while.condition, body=%while.body\n+  %get-tuple-element.out0 = f32[3] get-tuple-element(%while), index=0\n+  %get-tuple-element.out1 = f32[3] get-tuple-element(%while), index=1\n+  %get-tuple-element.out2 = f32[3] get-tuple-element(%while), index=2\n+  %get-tuple-element.out3 = f32[3] get-tuple-element(%while), index=3\n+  ROOT %root = tuple(%get-tuple-element.out0, %get-tuple-element.out1, %get-tuple-element.out2, %get-tuple-element.out3)\n+}\n+)\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  ASSERT_TRUE(WhileLoopSimplifier().Run(module.get()).value());\n+  HloInstruction* new_while = FindFirstWhile(module.get());\n+  Shape new_while_shape = ParseShape(\"(f32[3], f32[3], s32[])\").value();\n+  EXPECT_TRUE(ShapeUtil::Equal(new_while->shape(), new_while_shape));\n+  EXPECT_TRUE(ShapeUtil::Equal(\n+      new_while->while_body()->root_instruction()->shape(), new_while_shape));\n+  EXPECT_TRUE(ShapeUtil::Equal(\n+      new_while->while_body()->parameter_instruction(0)->shape(),\n+      new_while_shape));\n+  EXPECT_TRUE(ShapeUtil::Equal(\n+      new_while->while_condition()->parameter_instruction(0)->shape(),\n+      new_while_shape));\n+  EXPECT_TRUE(TupleSimplifier().Run(module.get()).ok());\n+  EXPECT_THAT(module->entry_computation()->root_instruction(),\n+              op::Tuple(op::GetTupleElement(op::While(), 0),\n+                        op::GetTupleElement(op::While(), 1),\n+                        op::GetTupleElement(op::While(), 1),\n+                        op::GetTupleElement(op::While(), 0)));\n+}\n+\n+TEST_F(WhileLoopSimplifierTest, RemoveMixedRegularAndDynUpdSlice) {\n+  const std::string hlo_string = R\"(\n+  HloModule dus\n+\n+%while.body (arg_tuple: (f32[3], f32[2], f32[2], f32[3], s32[])) -> (f32[3], f32[2], f32[2], f32[3], s32[]) {\n+  %arg_tuple = (f32[3], f32[2], f32[2], f32[3], s32[]) parameter(0)\n+  %get-tuple-element.0 = f32[3] get-tuple-element(%arg_tuple), index=0\n+  %get-tuple-element.1 = f32[2] get-tuple-element(%arg_tuple), index=1\n+  %get-tuple-element.2 = f32[2] get-tuple-element(%arg_tuple), index=2\n+  %get-tuple-element.3 = f32[3] get-tuple-element(%arg_tuple), index=3\n+  %get-tuple-element.4 = s32[] get-tuple-element(%arg_tuple), index=4\n+  %constant.1 = s32[] constant(1)\n+  %constant.v0 = f32[1] constant({0.0})\n+  %constant.v1 = f32[1] constant({1.0})\n+  %dynamic-update-slice.0 = f32[3] dynamic-update-slice(%get-tuple-element.0, %constant.v0, s32[] %constant.1)\n+  %dynamic-update-slice.3 = f32[3] dynamic-update-slice(%get-tuple-element.3, %constant.v0, s32[] %constant.1)\n+  %add = add(s32[] %get-tuple-element.4, s32[] %constant.1)\n+  ROOT %tuple = tuple(%dynamic-update-slice.0, %get-tuple-element.1, %get-tuple-element.2, %dynamic-update-slice.3, %add)\n+}\n+\n+%while.condition (arg_tuple.cond:(f32[3], f32[2], f32[2], f32[3], s32[])) -> pred[] {\n+  %arg_tuple.cond = (f32[3], f32[2], f32[2], f32[3], s32[]) parameter(0)\n+  %get-tuple-element.cond = s32[] get-tuple-element(%arg_tuple.cond), index=4\n+  %constant.3 = s32[] constant(3)\n+  ROOT %compare = pred[] compare(s32[] %get-tuple-element.cond, s32[] %constant.3), direction=LT\n+}\n+\n+ENTRY %main (arg.0: f32[3], arg.1: f32[2]) -> (f32[3], f32[2], f32[2], f32[3]) {\n+  %constant.0 = s32[] constant(0)\n+  %arg.0 = f32[3] parameter(0)\n+  %arg.1 = f32[2] parameter(1)\n+  %input = tuple(%arg.0, %arg.1, %arg.1, %arg.0, %constant.0)\n+  %while = while(%input), condition=%while.condition, body=%while.body\n+  %get-tuple-element.out0 = f32[3] get-tuple-element(%while), index=0\n+  %get-tuple-element.out1 = f32[2] get-tuple-element(%while), index=1\n+  %get-tuple-element.out2 = f32[2] get-tuple-element(%while), index=2\n+  %get-tuple-element.out3 = f32[3] get-tuple-element(%while), index=3\n+  ROOT %root = tuple(%get-tuple-element.out0, %get-tuple-element.out1, %get-tuple-element.out2, %get-tuple-element.out3)\n+}\n+)\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  ASSERT_TRUE(WhileLoopSimplifier().Run(module.get()).value());\n+  HloInstruction* new_while = FindFirstWhile(module.get());\n+  Shape new_while_shape = ParseShape(\"(f32[3], f32[2], s32[])\").value();\n+  EXPECT_TRUE(ShapeUtil::Equal(new_while->shape(), new_while_shape));\n+  EXPECT_TRUE(ShapeUtil::Equal(\n+      new_while->while_body()->root_instruction()->shape(), new_while_shape));\n+  EXPECT_TRUE(ShapeUtil::Equal(\n+      new_while->while_body()->parameter_instruction(0)->shape(),\n+      new_while_shape));\n+  EXPECT_TRUE(ShapeUtil::Equal(\n+      new_while->while_condition()->parameter_instruction(0)->shape(),\n+      new_while_shape));\n+  EXPECT_TRUE(TupleSimplifier().Run(module.get()).ok());\n+  EXPECT_THAT(module->entry_computation()->root_instruction(),\n+              op::Tuple(op::GetTupleElement(op::While(), 0),\n+                        op::GetTupleElement(op::While(), 1), op::Parameter(1),\n+                        op::GetTupleElement(op::While(), 0)));\n }\n \n }  // namespace"
        }
    ],
    "stats": {
        "total": 381,
        "additions": 210,
        "deletions": 171
    }
}