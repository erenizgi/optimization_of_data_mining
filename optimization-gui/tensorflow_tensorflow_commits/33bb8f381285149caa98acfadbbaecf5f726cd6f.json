{
    "author": "EusebioDM",
    "message": "Use switch to read ThunkProto impl variant, instead of if/else chain\n\nThere's no official style guide discouraging reading this via an if/else chain, but I think using a switch is cleaner.\n\nBenefits:\n\n* Its clear at a glance that only one branch will execute.\n* It gets rid of the existing [Clang cyclomatic complexity warning](https://clang.llvm.org/extra/clang-tidy/checks/readability/function-cognitive-complexity.html) in the DeserializeThunkProto method(although arguably it hasn't changed).\n* Run slightly faster (probably doesn't matter)\n\nBut let me know if you disagree.\n\nPiperOrigin-RevId: 816739539",
    "sha": "33bb8f381285149caa98acfadbbaecf5f726cd6f",
    "files": [
        {
            "sha": "4412c0b0cb7c34367063bc9d1b4fc4b9f96a12da",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/33bb8f381285149caa98acfadbbaecf5f726cd6f/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/33bb8f381285149caa98acfadbbaecf5f726cd6f/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=33bb8f381285149caa98acfadbbaecf5f726cd6f",
            "patch": "@@ -2324,7 +2324,7 @@ cc_library(\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/types:span\",\n-        \"@local_tsl//tsl/platform:protobuf\",\n+        \"@com_google_protobuf//:protobuf\",\n     ],\n )\n "
        },
        {
            "sha": "c943144dc69f6e0c3331417231d73f02eeaf98b0",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_proto_deserialization.cc",
            "status": "modified",
            "additions": 92,
            "deletions": 104,
            "changes": 196,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/33bb8f381285149caa98acfadbbaecf5f726cd6f/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_proto_deserialization.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/33bb8f381285149caa98acfadbbaecf5f726cd6f/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_proto_deserialization.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_proto_deserialization.cc?ref=33bb8f381285149caa98acfadbbaecf5f726cd6f",
            "patch": "@@ -25,6 +25,8 @@ limitations under the License.\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n+#include \"google/protobuf/descriptor.h\"\n+#include \"google/protobuf/message.h\"\n #include \"xla/backends/gpu/runtime/conditional_thunk.h\"\n #include \"xla/backends/gpu/runtime/copy_thunk.h\"\n #include \"xla/backends/gpu/runtime/cudnn_thunk.h\"\n@@ -43,7 +45,6 @@ limitations under the License.\n #include \"xla/backends/gpu/runtime/while_thunk.h\"\n #include \"xla/service/buffer_assignment.h\"\n #include \"xla/tsl/platform/statusor.h\"\n-#include \"tsl/platform/protobuf.h\"\n \n namespace xla::gpu {\n \n@@ -71,111 +72,98 @@ absl::StatusOr<std::unique_ptr<Thunk>> DeserializeThunkProto(\n   TF_ASSIGN_OR_RETURN(Thunk::ThunkInfo thunk_info,\n                       Thunk::ThunkInfo::FromProto(thunk_proto.thunk_info()));\n \n-  if (thunk_proto.has_sequential_thunk()) {\n-    auto deserializer = [&buffer_allocations](const ThunkProto& thunk_proto) {\n-      return DeserializeThunkProto(thunk_proto, buffer_allocations);\n-    };\n-\n-    return SequentialThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.sequential_thunk(), deserializer);\n-  }\n-  if (thunk_proto.has_copy_thunk()) {\n-    return CopyThunk::FromProto(std::move(thunk_info), thunk_proto.copy_thunk(),\n-                                buffer_allocations);\n-  }\n-  if (thunk_proto.has_device_to_host_copy_thunk()) {\n-    return DeviceToHostCopyThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.device_to_host_copy_thunk(),\n-        buffer_allocations);\n-  }\n-  if (thunk_proto.has_host_to_device_copy_thunk()) {\n-    return HostToDeviceCopyThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.host_to_device_copy_thunk(),\n-        buffer_allocations);\n-  }\n-  if (thunk_proto.has_device_to_device_copy_thunk()) {\n-    return DeviceToDeviceCopyThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.device_to_device_copy_thunk(),\n-        buffer_allocations);\n-  }\n-  if (thunk_proto.has_while_thunk()) {\n-    return WhileThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.while_thunk(), buffer_allocations,\n-        [&buffer_allocations](const ThunkProto& thunk_proto) {\n-          return DeserializeThunkProto(thunk_proto, buffer_allocations);\n-        });\n-  }\n-  if (thunk_proto.has_conditional_thunk()) {\n-    return ConditionalThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.conditional_thunk(),\n-        buffer_allocations,\n-        [&buffer_allocations](const ThunkProto& thunk_proto) {\n-          return DeserializeThunkProto(thunk_proto, buffer_allocations);\n-        });\n-  }\n-  if (thunk_proto.has_gemm_thunk()) {\n-    return GemmThunk::FromProto(std::move(thunk_info), thunk_proto.gemm_thunk(),\n-                                buffer_allocations);\n-  }\n-  if (thunk_proto.has_wait_for_streams_thunk()) {\n-    return WaitForStreamsThunk::FromProto(std::move(thunk_info),\n-                                          thunk_proto.wait_for_streams_thunk());\n-  }\n-  if (thunk_proto.has_triangular_solve_thunk()) {\n-    return TriangularSolveThunk::FromProto(std::move(thunk_info),\n-                                           thunk_proto.triangular_solve_thunk(),\n-                                           buffer_allocations);\n-  }\n-  if (thunk_proto.has_kernel_thunk()) {\n-    return KernelThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.kernel_thunk(), buffer_allocations);\n-  }\n-  if (thunk_proto.has_replica_id_thunk()) {\n-    return ReplicaIdThunk::FromProto(std::move(thunk_info),\n-                                     thunk_proto.replica_id_thunk(),\n-                                     buffer_allocations);\n-  }\n-  if (thunk_proto.has_partition_id_thunk()) {\n-    return PartitionIdThunk::FromProto(std::move(thunk_info),\n-                                       thunk_proto.partition_id_thunk(),\n+  switch (thunk_proto.impl_case()) {\n+    case ThunkProto::kSequentialThunk: {\n+      auto deserializer = [&buffer_allocations](const ThunkProto& thunk_proto) {\n+        return DeserializeThunkProto(thunk_proto, buffer_allocations);\n+      };\n+      return SequentialThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.sequential_thunk(), deserializer);\n+    }\n+    case ThunkProto::kCopyThunk:\n+      return CopyThunk::FromProto(std::move(thunk_info),\n+                                  thunk_proto.copy_thunk(), buffer_allocations);\n+    case ThunkProto::kDeviceToHostCopyThunk:\n+      return DeviceToHostCopyThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.device_to_host_copy_thunk(),\n+          buffer_allocations);\n+    case ThunkProto::kHostToDeviceCopyThunk:\n+      return HostToDeviceCopyThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.host_to_device_copy_thunk(),\n+          buffer_allocations);\n+    case ThunkProto::kDeviceToDeviceCopyThunk:\n+      return DeviceToDeviceCopyThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.device_to_device_copy_thunk(),\n+          buffer_allocations);\n+    case ThunkProto::kWhileThunk:\n+      return WhileThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.while_thunk(), buffer_allocations,\n+          [&buffer_allocations](const ThunkProto& thunk_proto) {\n+            return DeserializeThunkProto(thunk_proto, buffer_allocations);\n+          });\n+    case ThunkProto::kConditionalThunk:\n+      return ConditionalThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.conditional_thunk(),\n+          buffer_allocations,\n+          [&buffer_allocations](const ThunkProto& thunk_proto) {\n+            return DeserializeThunkProto(thunk_proto, buffer_allocations);\n+          });\n+    case ThunkProto::kGemmThunk:\n+      return GemmThunk::FromProto(std::move(thunk_info),\n+                                  thunk_proto.gemm_thunk(), buffer_allocations);\n+    case ThunkProto::kWaitForStreamsThunk:\n+      return WaitForStreamsThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.wait_for_streams_thunk());\n+    case ThunkProto::kTriangularSolveThunk:\n+      return TriangularSolveThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.triangular_solve_thunk(),\n+          buffer_allocations);\n+    case ThunkProto::kKernelThunk:\n+      return KernelThunk::FromProto(std::move(thunk_info),\n+                                    thunk_proto.kernel_thunk(),\n+                                    buffer_allocations);\n+    case ThunkProto::kReplicaIdThunk:\n+      return ReplicaIdThunk::FromProto(std::move(thunk_info),\n+                                       thunk_proto.replica_id_thunk(),\n                                        buffer_allocations);\n+    case ThunkProto::kPartitionIdThunk:\n+      return PartitionIdThunk::FromProto(std::move(thunk_info),\n+                                         thunk_proto.partition_id_thunk(),\n+                                         buffer_allocations);\n+    case ThunkProto::kCudnnThunk:\n+      return CuDnnThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.cudnn_thunk(), buffer_allocations);\n+    case ThunkProto::kMemzeroThunk:\n+      return MemzeroThunk::FromProto(std::move(thunk_info),\n+                                     thunk_proto.memzero_thunk(),\n+                                     buffer_allocations);\n+    case ThunkProto::kInfeedThunk:\n+      return InfeedThunk::FromProto(std::move(thunk_info),\n+                                    thunk_proto.infeed_thunk(),\n+                                    buffer_allocations);\n+    case ThunkProto::kCublasLtMatmulThunk:\n+      return CublasLtMatmulThunk::FromProto(\n+          std::move(thunk_info), thunk_proto.cublas_lt_matmul_thunk(),\n+          buffer_allocations);\n+    case ThunkProto::kNormThunk:\n+      return NormThunk::FromProto(std::move(thunk_info),\n+                                  thunk_proto.norm_thunk(), buffer_allocations);\n+\n+    default:\n+      std::optional<absl::string_view> unsupported_thunk_type =\n+          GetStoredThunkTypeName(thunk_proto);\n+\n+      if (!unsupported_thunk_type.has_value()) {\n+        return absl::InvalidArgumentError(\n+            \"Encountered ThunkProto without an embedded thunk. This indicates \"\n+            \"that the loaded executable contains a thunk type that is not \"\n+            \"supported by this version of XLA.\");\n+      }\n+\n+      return absl::InvalidArgumentError(absl::StrFormat(\n+          \"Thunk deserialization of thunks of type %s is not yet supported.\",\n+          GetStoredThunkTypeName(thunk_proto).value()));\n   }\n-  if (thunk_proto.has_cudnn_thunk()) {\n-    return CuDnnThunk::FromProto(std::move(thunk_info),\n-                                 thunk_proto.cudnn_thunk(), buffer_allocations);\n-  }\n-  if (thunk_proto.has_memzero_thunk()) {\n-    return MemzeroThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.memzero_thunk(), buffer_allocations);\n-  }\n-  if (thunk_proto.has_infeed_thunk()) {\n-    return InfeedThunk::FromProto(\n-        std::move(thunk_info), thunk_proto.infeed_thunk(), buffer_allocations);\n-  }\n-\n-  if (thunk_proto.has_cublas_lt_matmul_thunk()) {\n-    return CublasLtMatmulThunk::FromProto(std::move(thunk_info),\n-                                          thunk_proto.cublas_lt_matmul_thunk(),\n-                                          buffer_allocations);\n-  }\n-  if (thunk_proto.has_norm_thunk()) {\n-    return NormThunk::FromProto(std::move(thunk_info), thunk_proto.norm_thunk(),\n-                                buffer_allocations);\n-  }\n-\n-  std::optional<absl::string_view> unsupported_thunk_type =\n-      GetStoredThunkTypeName(thunk_proto);\n-\n-  if (!unsupported_thunk_type.has_value()) {\n-    return absl::InvalidArgumentError(\n-        \"Encountered ThunkProto without an embedded thunk. This indicates that \"\n-        \"the loaded executable contains a thunk type that is not supported by \"\n-        \"this version of XLA.\");\n-  }\n-\n-  return absl::InvalidArgumentError(absl::StrFormat(\n-      \"Thunk deserialization of thunks of type %s is not yet supported.\",\n-      GetStoredThunkTypeName(thunk_proto).value()));\n }\n \n }  // namespace xla::gpu"
        }
    ],
    "stats": {
        "total": 198,
        "additions": 93,
        "deletions": 105
    }
}