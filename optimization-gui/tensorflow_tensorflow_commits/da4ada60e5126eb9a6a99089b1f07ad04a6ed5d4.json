{
    "author": "tensorflower-gardener",
    "message": "Add serialization and deserialization of IFRT IR MPMD executables.\n\nPiperOrigin-RevId: 839758650",
    "sha": "da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4",
    "files": [
        {
            "sha": "c48becc712bcb4f041bd92e548d357f8d2a270db",
            "filename": "third_party/xla/xla/python/ifrt/ir/BUILD",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD?ref=da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4",
            "patch": "@@ -158,6 +158,42 @@ tf_proto_library(\n     visibility = [\"//xla/python/ifrt:users\"],\n )\n \n+tf_proto_library(\n+    name = \"ifrt_ir_executable_version_proto\",\n+    srcs = [\"ifrt_ir_executable_version.proto\"],\n+    visibility = [\"//xla/python/ifrt:users\"],\n+    deps = [\n+    ],\n+)\n+\n+cc_library(\n+    name = \"ifrt_ir_executable_version\",\n+    srcs = [\"ifrt_ir_executable_version.cc\"],\n+    hdrs = [\"ifrt_ir_executable_version.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    visibility = [\"//xla/python/ifrt:users\"],\n+    deps = [\n+        \":ifrt_ir_executable_version_proto_cc\",\n+        \":version\",\n+        \"//xla:util\",\n+        \"//xla/python/ifrt\",\n+        \"//xla/python/ifrt:device_proto_cc\",\n+        \"//xla/python/ifrt:serdes\",\n+        \"//xla/python/ifrt:serdes_version\",\n+        \"//xla/python/ifrt:serdes_week_4_old_version_accessor\",\n+        \"//xla/python/pjrt_ifrt:xla_executable_version\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:Support\",\n+    ],\n+)\n+\n cc_library(\n     name = \"ifrt_ir_program\",\n     srcs = [\"ifrt_ir_program.cc\"],"
        },
        {
            "sha": "76cad284e95c046b0f9ff38018af0bfc2902c771",
            "filename": "third_party/xla/xla/python/ifrt/ir/ifrt_ir_executable_version.cc",
            "status": "added",
            "additions": 342,
            "deletions": 0,
            "changes": 342,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.cc?ref=da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4",
            "patch": "@@ -0,0 +1,342 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/python/ifrt/ir/ifrt_ir_executable_version.h\"\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/Support/Casting.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"mlir/Support/LLVM.h\"\n+#include \"xla/python/ifrt/client.h\"\n+#include \"xla/python/ifrt/compiler.h\"\n+#include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/device.pb.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n+#include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/ir/ifrt_ir_executable_version.pb.h\"\n+#include \"xla/python/ifrt/ir/version.h\"\n+#include \"xla/python/ifrt/serdes.h\"\n+#include \"xla/python/ifrt/serdes_version.h\"\n+#include \"xla/python/ifrt/serdes_week_4_old_version_accessor.h\"\n+#include \"xla/python/pjrt_ifrt/xla_executable_version.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/util.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+[[maybe_unused]] char IfrtIrExecutableVersionDeserializeOptions::ID = 0;\n+[[maybe_unused]] char IfrtIrExecutableVersion::ID = 0;\n+\n+namespace {\n+absl::StatusOr<int> FindLogicalDeviceId(\n+    const absl::flat_hash_map<xla::ifrt::DeviceId, int>&\n+        device_id_to_logical_device_id,\n+    xla::ifrt::DeviceId device_id) {\n+  auto it = device_id_to_logical_device_id.find(device_id);\n+  if (it == device_id_to_logical_device_id.end()) {\n+    return absl::NotFoundError(absl::StrCat(\n+        \"Device id \", device_id.value(), \" not found in device assignments\"));\n+  }\n+  return it->second;\n+}\n+\n+absl::StatusOr<xla::ifrt::Device*> FindDevice(\n+    const xla::ifrt::DeviceListRef& devices, xla::ifrt::DeviceId device_id) {\n+  for (xla::ifrt::Device* device : devices->devices()) {\n+    if (device->Id() == device_id) {\n+      return device;\n+    }\n+  }\n+  return absl::NotFoundError(absl::StrCat(\"Device id \", device_id.value(),\n+                                          \" not found in device list\"));\n+}\n+\n+absl::StatusOr<xla::ifrt::DeviceListRef> MakeDeviceListFromAtomDeviceIds(\n+    xla::ifrt::Client& client, const xla::ifrt::DeviceListRef& devices,\n+    const std::vector<xla::ifrt::DeviceId>& atom_device_ids) {\n+  std::vector<xla::ifrt::Device*> device_ptrs;\n+  device_ptrs.reserve(atom_device_ids.size());\n+  for (const auto& atom_device_id : atom_device_ids) {\n+    TF_ASSIGN_OR_RETURN(xla::ifrt::Device * device,\n+                        FindDevice(devices, atom_device_id));\n+    device_ptrs.push_back(device);\n+  }\n+  return client.MakeDeviceList(device_ptrs);\n+}\n+}  // namespace\n+\n+IfrtIrExecutableVersion::IfrtIrExecutableVersion(\n+    Version ifrt_version,\n+    absl::Span<const xla::ifrt::DeviceId> device_assignments,\n+    std::vector<AtomExecutableVersion> runtime_abi_versions)\n+    : ifrt_version(std::move(ifrt_version)),\n+      device_assignments(device_assignments.begin(), device_assignments.end()),\n+      runtime_abi_versions(std::move(runtime_abi_versions)) {}\n+\n+bool IfrtIrExecutableVersion::IsCompatibleWith(\n+    const ExecutableVersion& other) const {\n+  if (this == &other) {\n+    return true;\n+  }\n+  if (auto other_ifrt_ir_executable_version =\n+          llvm::dyn_cast<IfrtIrExecutableVersion>(&other)) {\n+    return (ifrt_version == other_ifrt_ir_executable_version->ifrt_version);\n+  }\n+  return false;\n+}\n+\n+bool IfrtIrExecutableVersion::IsCompatibleWith(\n+    xla::ifrt::Client& client, const xla::ifrt::DeviceListRef& devices,\n+    const ExecutableVersion& other) const {\n+  if (!IsCompatibleWith(other)) {\n+    return false;\n+  }\n+  const auto* other_ifrt_ir_executable_version =\n+      llvm::cast<IfrtIrExecutableVersion>(&other);\n+  // This version is compatible with the other IFRT IR version if the other's\n+  // atom executables are compatible with the client on the given devices.\n+  for (const auto& [runtime_abi_version, atom_devices] :\n+       other_ifrt_ir_executable_version->runtime_abi_versions) {\n+    absl::StatusOr<xla::ifrt::DeviceListRef> atom_device_list =\n+        MakeDeviceListFromAtomDeviceIds(client, devices, atom_devices);\n+    if (!atom_device_list.ok()) {\n+      LOG(ERROR) << \"Failed to make device list from atom device ids: \"\n+                 << atom_device_list.status();\n+      return false;\n+    }\n+    absl::Status status =\n+        client.GetDefaultCompiler()->IsExecutableVersionCompatible(\n+            *runtime_abi_version, *atom_device_list);\n+    if (!status.ok()) {\n+      LOG(ERROR) << \"Executable version not compatible: \" << status;\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+absl::StatusOr<IfrtIrExecutableVersionProto> IfrtIrExecutableVersion::ToProto(\n+    SerDesVersion version) const {\n+  if (version.version_number() < SerDesVersionNumber(0)) {\n+    return absl::FailedPreconditionError(\n+        absl::StrCat(\"Unsupported \", version.version_number(),\n+                     \" for IfrtIrExecutableVersion serialization\"));\n+  }\n+\n+  // Create a map from runtime device id to logical device id.\n+  absl::flat_hash_map<xla::ifrt::DeviceId, int> device_id_to_logical_device_id;\n+  for (int i = 0; i < device_assignments.size(); ++i) {\n+    auto [_, inserted] =\n+        device_id_to_logical_device_id.insert({device_assignments[i], i});\n+    if (!inserted) {\n+      return absl::InvalidArgumentError(\n+          absl::StrCat(\"Duplicate device id \", device_assignments[i].value(),\n+                       \" found in device assignments\"));\n+    }\n+  }\n+\n+  IfrtIrExecutableVersionProto proto;\n+  proto.set_version_number(SerDesVersionNumber(0).value());\n+  proto.set_ifrt_ir_version(ifrt_version.toString());\n+  for (const auto& [runtime_abi_version, atom_devices] : runtime_abi_versions) {\n+    xla::ifrt::Serialized serialized_runtime_abi_version;\n+    TF_ASSIGN_OR_RETURN(\n+        serialized_runtime_abi_version,\n+        xla::ifrt::Serialize(\n+            *runtime_abi_version,\n+            std::make_unique<xla::ifrt::SerializeOptions>(\n+                xla::ifrt::SerDesWeek4OldVersionAccessor::Get())));\n+\n+    AtomExecutableVersionProto atom_executable_version_proto;\n+    if (!serialized_runtime_abi_version.SerializeToString(\n+            atom_executable_version_proto.mutable_executable_version())) {\n+      return absl::InternalError(\"Failed to serialize runtime ABI version\");\n+    }\n+\n+    for (auto& device : atom_devices) {\n+      TF_ASSIGN_OR_RETURN(\n+          int logical_device_id,\n+          FindLogicalDeviceId(device_id_to_logical_device_id, device));\n+      atom_executable_version_proto.add_logical_device_indexes(\n+          logical_device_id);\n+    }\n+    *proto.add_executable_versions() = atom_executable_version_proto;\n+  }\n+\n+  return proto;\n+}\n+\n+absl::StatusOr<std::unique_ptr<IfrtIrExecutableVersion>>\n+IfrtIrExecutableVersion::FromProto(\n+    std::vector<xla::ifrt::DeviceId> device_assignments,\n+    const IfrtIrExecutableVersionProto& proto) {\n+  const SerDesVersionNumber version_number(proto.version_number());\n+  if (version_number != SerDesVersionNumber(0)) {\n+    return absl::FailedPreconditionError(\n+        absl::StrCat(\"Unsupported \", version_number,\n+                     \" for IfrtIrExecutableVersion deserialization\"));\n+  }\n+  std::vector<AtomExecutableVersion> atom_executable_versions;\n+  for (const auto& atom_executable_version_proto :\n+       proto.executable_versions()) {\n+    AtomExecutableVersion atom_executable_version;\n+    xla::ifrt::Serialized serialized_runtime_abi_version;\n+    if (!serialized_runtime_abi_version.ParseFromString(\n+            atom_executable_version_proto.executable_version())) {\n+      return absl::InvalidArgumentError(\n+          \"Failed to parse serialized runtime ABI version\");\n+    }\n+\n+    TF_ASSIGN_OR_RETURN(atom_executable_version.runtime_abi_version,\n+                        xla::ifrt::Deserialize<xla::ifrt::ExecutableVersion>(\n+                            serialized_runtime_abi_version,\n+                            std::make_unique<xla::ifrt::DeserializeOptions>()));\n+\n+    for (auto logical_device_id :\n+         atom_executable_version_proto.logical_device_indexes()) {\n+      if (logical_device_id >= device_assignments.size()) {\n+        return absl::InvalidArgumentError(\"Logical device id is out of range\");\n+      }\n+      atom_executable_version.devices.push_back(\n+          device_assignments[logical_device_id]);\n+    }\n+\n+    atom_executable_versions.emplace_back(std::move(atom_executable_version));\n+  }\n+\n+  auto ifrt_version = Version::fromString(proto.ifrt_ir_version());\n+  if (mlir::failed(ifrt_version)) {\n+    return absl::InvalidArgumentError(absl::StrCat(\n+        \"Failed to parse IFRT IR version: \", proto.ifrt_ir_version()));\n+  }\n+  return std::make_unique<IfrtIrExecutableVersion>(\n+      *ifrt_version, device_assignments, std::move(atom_executable_versions));\n+}\n+\n+std::string IfrtIrExecutableVersion::ToString() const {\n+  std::vector<std::string> runtime_abi_version_strs;\n+  runtime_abi_version_strs.reserve(runtime_abi_versions.size());\n+  for (const auto& [runtime_abi_version, atom_devices] : runtime_abi_versions) {\n+    if (auto xla_executable_version =\n+            llvm::dyn_cast<XlaExecutableVersion>(runtime_abi_version.get())) {\n+      runtime_abi_version_strs.push_back(absl::StrCat(\n+          \"{platform_id=\", xla_executable_version->platform_id,\n+          \", runtime_abi_version=\", xla_executable_version->runtime_abi_version,\n+          \", devices=[\",\n+          absl::StrJoin(atom_devices, \",\",\n+                        [](std::string* out, xla::ifrt::DeviceId device_id) {\n+                          absl::StrAppend(out, device_id.value());\n+                        }),\n+          \"]}\"));\n+    } else {\n+      runtime_abi_version_strs.push_back(\"(unknown)\");\n+    }\n+  }\n+  return absl::StrCat(\"IfrtIrExecutableVersion(\", ifrt_version.toString(),\n+                      \", runtime_abi_versions=[\",\n+                      absl::StrJoin(runtime_abi_version_strs, \", \"), \"])\");\n+}\n+\n+absl::StatusOr<std::unique_ptr<IfrtIrExecutableVersion>>\n+ToIfrtIrExecutableVersion(\n+    std::unique_ptr<ExecutableVersion> executable_version) {\n+  if (!executable_version) {\n+    return absl::InvalidArgumentError(\"executable_version is null\");\n+  }\n+  if (llvm::isa_and_nonnull<IfrtIrExecutableVersion>(\n+          executable_version.get())) {\n+    return xla::unique_ptr_down_cast<IfrtIrExecutableVersion>(\n+        std::move(executable_version));\n+  }\n+  return absl::InvalidArgumentError(\n+      \"executable_version is not IfrtIrExecutableVersion\");\n+}\n+\n+namespace {\n+\n+class IfrtIrExecutableVersionSerDes\n+    : public llvm::RTTIExtends<IfrtIrExecutableVersionSerDes, SerDes> {\n+ public:\n+  absl::string_view type_name() const override {\n+    return \"xla::ifrt::IfrtIrExecutableVersion\";\n+  }\n+\n+  absl::StatusOr<std::string> Serialize(\n+      const Serializable& serializable,\n+      std::unique_ptr<SerializeOptions> options) override {\n+    const SerDesVersion version = GetRequestedSerDesVersion(options.get());\n+\n+    const auto& ifrt_ir_executable_version =\n+        llvm::cast<IfrtIrExecutableVersion>(serializable);\n+\n+    TF_ASSIGN_OR_RETURN(IfrtIrExecutableVersionProto proto,\n+                        ifrt_ir_executable_version.ToProto(version));\n+    std::string serialized;\n+    if (!proto.SerializeToString(&serialized)) {\n+      return absl::InternalError(\n+          \"Failed to serialize IfrtIrExecutableVersionProto\");\n+    }\n+    return serialized;\n+  }\n+\n+  absl::StatusOr<std::unique_ptr<Serializable>> Deserialize(\n+      const std::string& serialized,\n+      std::unique_ptr<DeserializeOptions> options) override {\n+    auto* deserialize_options =\n+        llvm::dyn_cast<IfrtIrExecutableVersionDeserializeOptions>(\n+            options.get());\n+    if (deserialize_options == nullptr) {\n+      return absl::InvalidArgumentError(\n+          \"IfrtIrExecutableVersionDeserializeOptions not found\");\n+    }\n+    IfrtIrExecutableVersionProto proto;\n+    if (!proto.ParseFromString(serialized)) {\n+      return absl::InvalidArgumentError(\n+          \"Failed to parse IfrtIrExecutableVersionProto\");\n+    }\n+    return IfrtIrExecutableVersion::FromProto(\n+        deserialize_options->device_assignments, proto);\n+  }\n+\n+  IfrtIrExecutableVersionSerDes() = default;\n+  ~IfrtIrExecutableVersionSerDes() override = default;\n+\n+  static char ID;  // NOLINT\n+};\n+\n+}  // namespace\n+\n+[[maybe_unused]] char IfrtIrExecutableVersionSerDes::ID = 0;\n+\n+bool register_ifrt_ir_executable_version_serdes = ([]{\n+    RegisterSerDes<IfrtIrExecutableVersion>(\n+        std::make_unique<IfrtIrExecutableVersionSerDes>());\n+    }(), true);\n+\n+}  // namespace ifrt\n+}  // namespace xla"
        },
        {
            "sha": "69654ff05ef3511a9c85191180e5529e7726d30f",
            "filename": "third_party/xla/xla/python/ifrt/ir/ifrt_ir_executable_version.h",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.h?ref=da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4",
            "patch": "@@ -0,0 +1,105 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_PYTHON_IFRT_IR_IFRT_IR_EXECUTABLE_VERSION_H_\n+#define XLA_PYTHON_IFRT_IR_IFRT_IR_EXECUTABLE_VERSION_H_\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/Support/ExtensibleRTTI.h\"\n+#include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n+#include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/ir/ifrt_ir_executable_version.pb.h\"\n+#include \"xla/python/ifrt/ir/version.h\"\n+#include \"xla/python/ifrt/serdes.h\"\n+#include \"xla/python/ifrt/serdes_version.h\"\n+\n+namespace xla {\n+namespace ifrt {\n+\n+struct IfrtIrExecutableVersionDeserializeOptions\n+    : llvm::RTTIExtends<IfrtIrExecutableVersionDeserializeOptions,\n+                        xla::ifrt::DeserializeOptions> {\n+  explicit IfrtIrExecutableVersionDeserializeOptions(\n+      xla::ifrt::Client* client,\n+      absl::Span<const xla::ifrt::DeviceId> device_assignments)\n+      : client(client),\n+        device_assignments(device_assignments.begin(),\n+                           device_assignments.end()) {}\n+\n+  static char ID;  // NOLINT\n+\n+  xla::ifrt::Client* client = nullptr;\n+  std::vector<xla::ifrt::DeviceId> device_assignments;\n+};\n+\n+struct IfrtIrExecutableVersion\n+    : llvm::RTTIExtends<IfrtIrExecutableVersion, ExecutableVersion> {\n+  // Tracking the runtime ABI version of an atom executable and the devices that\n+  // it is to be used on.\n+  struct AtomExecutableVersion {\n+    std::unique_ptr<xla::ifrt::ExecutableVersion> runtime_abi_version;\n+    std::vector<xla::ifrt::DeviceId> devices;\n+  };\n+\n+  IfrtIrExecutableVersion() = default;\n+  explicit IfrtIrExecutableVersion(\n+      Version ifrt_version,\n+      absl::Span<const xla::ifrt::DeviceId> device_assignments = {},\n+      std::vector<AtomExecutableVersion> runtime_abi_versions = {});\n+\n+  // The version of the IFRT IR.\n+  Version ifrt_version;\n+  // Mapping from logical device ids in IFRT IR MLIR module to runtime device\n+  // ids obtained from IFRT client.\n+  std::vector<xla::ifrt::DeviceId> device_assignments;\n+  // Atom executable runtime ABI versions and their device assignments.\n+  std::vector<AtomExecutableVersion> runtime_abi_versions;\n+\n+  // Returns true if the IFRT IR version is compatible with the other version.\n+  bool IsCompatibleWith(const ExecutableVersion& other) const override;\n+\n+  // Returns true if the IFRT IR version is compatible with the other version\n+  // and the runtime ABI version is compatible with the given client on the\n+  // given devices.\n+  bool IsCompatibleWith(xla::ifrt::Client& client,\n+                        const xla::ifrt::DeviceListRef& devices,\n+                        const ExecutableVersion& other) const;\n+\n+  absl::StatusOr<IfrtIrExecutableVersionProto> ToProto(\n+      SerDesVersion version = SerDesVersion::current()) const;\n+  static absl::StatusOr<std::unique_ptr<IfrtIrExecutableVersion>> FromProto(\n+      std::vector<xla::ifrt::DeviceId> device_assignments,\n+      const IfrtIrExecutableVersionProto& proto);\n+\n+  // Returns a string representation of the version for logging purposes.\n+  std::string ToString() const;\n+\n+  static char ID;  // NOLINT\n+};\n+\n+absl::StatusOr<std::unique_ptr<IfrtIrExecutableVersion>>\n+ToIfrtIrExecutableVersion(\n+    std::unique_ptr<ExecutableVersion> executable_version);\n+\n+}  // namespace ifrt\n+}  // namespace xla\n+\n+#endif  // XLA_PYTHON_IFRT_IR_IFRT_IR_EXECUTABLE_VERSION_H_"
        },
        {
            "sha": "ad1d4a0dc08f817c129f0ec8ec2d770a2fbf07bd",
            "filename": "third_party/xla/xla/python/ifrt/ir/ifrt_ir_executable_version.proto",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_executable_version.proto?ref=da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4",
            "patch": "@@ -0,0 +1,23 @@\n+syntax = \"proto3\";\n+\n+package xla.ifrt;\n+\n+option java_multiple_files = true;\n+\n+// The executable version of an atom executable and the device indexes that\n+// it is to be used on.\n+message AtomExecutableVersionProto {\n+  bytes executable_version = 1;\n+  // The original logical device indexes of the devices that the atom\n+  // executable was compiled for.\n+  repeated int32 logical_device_indexes = 2;\n+}\n+\n+// Proto representation of IfrtIrExecutableVersion.\n+message IfrtIrExecutableVersionProto {\n+  int32 version_number = 1;\n+  // String of the form \"major.minor.patch\", representing the IFRT IR version.\n+  string ifrt_ir_version = 2;\n+  // Serialized executable versions of atom executables.\n+  repeated AtomExecutableVersionProto executable_versions = 3;\n+}"
        },
        {
            "sha": "8c012be08ee3fd5722b15cba8aa1868c5d831fd2",
            "filename": "third_party/xla/xla/python/ifrt/ir/ifrt_ir_program.h",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_program.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_program.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fifrt_ir_program.h?ref=da4ada60e5126eb9a6a99089b1f07ad04a6ed5d4",
            "patch": "@@ -19,6 +19,7 @@ limitations under the License.\n #include <cstddef>\n #include <cstdint>\n #include <memory>\n+#include <optional>\n #include <string>\n #include <utility>\n #include <vector>\n@@ -36,7 +37,9 @@ limitations under the License.\n #include \"mlir/IR/OwningOpRef.h\"\n #include \"xla/python/ifrt/compiler.h\"\n #include \"xla/python/ifrt/device.h\"\n+#include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/executable.h\"\n+#include \"xla/python/ifrt/executable_serdes.h\"\n #include \"xla/python/ifrt/ir/ifrt_ir_compile_options.pb.h\"\n #include \"xla/python/ifrt/program.h\"\n #include \"xla/python/ifrt/serdes.h\"\n@@ -104,9 +107,16 @@ struct SerializeIfrtIRProgramOptions\n // deserialization will use the provided MLIR context and the returned program\n // will not own a MLIR context.\n struct DeserializeIfrtIRProgramOptions\n-    : llvm::RTTIExtends<DeserializeIfrtIRProgramOptions, DeserializeOptions> {\n+    : llvm::RTTIExtends<DeserializeIfrtIRProgramOptions,\n+                        DeserializeExecutableOptions> {\n   explicit DeserializeIfrtIRProgramOptions(mlir::MLIRContext* context)\n       : context(context) {}\n+  DeserializeIfrtIRProgramOptions(\n+      mlir::MLIRContext* context,\n+      std::optional<xla::ifrt::DeviceListRef> device_list)\n+      : llvm::RTTIExtends<DeserializeIfrtIRProgramOptions,\n+                          DeserializeExecutableOptions>(device_list),\n+        context(context) {}\n \n   static char ID;  // NOLINT\n "
        }
    ],
    "stats": {
        "total": 518,
        "additions": 517,
        "deletions": 1
    }
}