{
    "author": "jcai19",
    "message": "[XLA][Numerics][HLO Original Values] Handles original values of while loops in TPU reduce code motion pass\n\nThis updates the original value of a while loop after its input/output shape gets changed after the pass sinks qualified reduce instructions into its body.\n\nPiperOrigin-RevId: 826618908",
    "sha": "a6e123761d01eaac4a842b6cd80f35af010808f7",
    "files": [
        {
            "sha": "d62cb20233986ded791bd1a3e3e3e76c2cbeaa42",
            "filename": "third_party/xla/xla/hlo/ir/hlo_instruction.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.h?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -2467,16 +2467,16 @@ class alignas(kInstructionTypeMask + 1) HloInstruction {\n   std::shared_ptr<OriginalValue> original_value() const;\n   void set_original_value(std::shared_ptr<OriginalValue> original_value);\n \n-  // Copy original value from the input instruction if the source and\n+  // Copies original value from the input instruction if the source and\n   // destination shapes are compatible. This performs a deep copy if clone is\n   // set to true. Otherwise, it performs a shallow copy. Print a warning if the\n   // shapes are not compatible and issue_warning is set to true.\n   void CopyOriginalValue(const HloInstruction* instruction, bool clone = false,\n                          bool issue_warning = false);\n \n  protected:\n-  // Internal constructor for a given opcode/shape, other fields must be filled\n-  // by factory methods.\n+  // Internal constructor for a given opcode/shape, other fields must be\n+  // filled by factory methods.\n   HloInstruction(HloOpcode opcode, const Shape& shape);\n \n   void RemoveAllOperands() { operands_.clear(); }"
        },
        {
            "sha": "5ccfebc6839308597752b2d314491c2d921829fe",
            "filename": "third_party/xla/xla/hlo/ir/hlo_original_value.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_original_value.h?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -129,6 +129,8 @@ class OriginalValue {\n \n   bool IsCompatibleWith(const Shape& shape) const;\n \n+  bool IsTuple() const { return tree().IsTuple(); }\n+\n   bool operator==(const OriginalValue& other) const;\n \n   bool operator!=(const OriginalValue& other) const {"
        },
        {
            "sha": "d520201d5416dd27adb89157fab5131f0e8e33e6",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -4639,6 +4639,7 @@ xla_cc_test(\n     srcs = [\"while_util_test.cc\"],\n     deps = [\n         \":while_util\",\n+        \"//xla:shape_util\",\n         \"//xla:util\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n@@ -4906,8 +4907,6 @@ cc_library(\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n-        \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n "
        },
        {
            "sha": "e363c7e20cc70f0e8ab9149da0eb4922002eef62",
            "filename": "third_party/xla/xla/service/while_loop_fusible_sinking.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 33,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking.cc?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -42,8 +42,6 @@ limitations under the License.\n #include \"xla/shape_util.h\"\n #include \"xla/util.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla {\n \n@@ -97,29 +95,6 @@ absl::Status UpdateWhileUsesWithTuple(HloInstruction* while_instr,\n   return absl::OkStatus();\n }\n \n-void AppendOriginalValues(HloInstruction* instr,\n-                          const HloInstruction::InstructionVector& new_operands,\n-                          int64_t next_index) {\n-  if (instr->original_value() != nullptr && !new_operands.empty()) {\n-    std::shared_ptr<OriginalValue> old_original_value = instr->original_value(),\n-                                   new_original_value =\n-                                       std::make_shared<OriginalValue>(\n-                                           instr->shape());\n-    for (auto& [shape_index, original_array] : old_original_value->tree()) {\n-      *new_original_value->mutable_tree()->mutable_element(shape_index) =\n-          original_array;\n-    }\n-\n-    for (int64_t i = 0; i < new_operands.size(); ++i) {\n-      if (new_operands[i]->original_value() != nullptr) {\n-        new_original_value->mutable_tree()->CopySubtreeFrom(\n-            new_operands[i]->original_value()->tree(), {}, {next_index + i});\n-      }\n-    }\n-    return instr->set_original_value(new_original_value);\n-  }\n-}\n-\n // Appends the given new operand to while input and update loops computations\n // and shape accordingly and returns the gte instruction within the body that\n // represents the new operand.\n@@ -130,8 +105,6 @@ absl::StatusOr<HloInstruction*> AppendToWhileState(\n   ShapeUtil::AppendShapeToTuple(new_operand->shape(),\n                                 while_input->mutable_shape());\n   while_input->AppendOperand(new_operand);\n-  AppendOriginalValues(while_input, {new_operand},\n-                       while_input->operand_count() - 1);\n   // Update the body computation.\n   HloComputation* body = while_instr->while_body();\n   *body->parameter_instruction(0)->mutable_shape() = while_input->shape();\n@@ -149,8 +122,8 @@ absl::StatusOr<HloInstruction*> AppendToWhileState(\n   TF_RETURN_IF_ERROR(\n       UpdateWhileUsesWithTuple(while_instr, while_input->operand_count() - 1));\n   *while_instr->mutable_shape() = while_input->shape();\n-  AppendOriginalValues(while_instr, {new_operand},\n-                       while_input->operand_count() - 1);\n+  // The new body root tuple element has the same value as the new operand.\n+  AppendToWhileLoopOriginalValue(while_instr, {new_operand});\n \n   return new_gte;\n }\n@@ -499,11 +472,11 @@ absl::StatusOr<bool> WhileLoopFusibleSinking::TrySinkingFusiblesIntoWhileLoop(\n       root->AppendOperand(new_operands[i]);\n     }\n     *(init_value->mutable_shape()) = parameter->shape();\n-    AppendOriginalValues(init_value, fusion->operands(),\n-                         next_index - fusion->operand_count());\n     *(while_instr->mutable_shape()) = parameter->shape();\n-    AppendOriginalValues(while_instr, fusion->operands(),\n-                         next_index - fusion->operand_count());\n+    //\n+    // The new body root tuple elements have the same value as the fusion\n+    // operands.\n+    AppendToWhileLoopOriginalValue(while_instr, fusion->operands());\n     *(while_cond->parameter_instruction(0)->mutable_shape()) =\n         parameter->shape();\n     *(root->mutable_shape()) = parameter->shape();"
        },
        {
            "sha": "f5baf95b30dc179e5e9b62987796f8fa0276f548",
            "filename": "third_party/xla/xla/service/while_loop_fusible_sinking_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking_test.cc?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -471,11 +471,11 @@ ENTRY entry {\n   HloInstruction* while_instr = FindInstruction(module.get(), \"while\");\n   ASSERT_NE(while_instr->original_value(), nullptr);\n   EXPECT_EQ(while_instr->original_value()->ToString(),\n-            \"({\\\"while\\\" {0}}, {\\\"while\\\" {1}}, {\\\"parameter\\\"})\");\n+            R\"(({\"while\" {0}}, {\"while\" {1}}, {\"parameter\"}))\");\n   HloInstruction* while_init = while_instr->while_init();\n   ASSERT_NE(while_init->original_value(), nullptr);\n   EXPECT_EQ(while_init->original_value()->ToString(),\n-            \"({\\\"constant\\\"}, {\\\"mask\\\"}, {\\\"parameter\\\"})\");\n+            R\"(({\"constant\"}, {\"mask\"}, {\"parameter\"}))\");\n }\n \n TEST_F(WhileLoopFusibleSinkingTest, PlumbSingleBroadcastWithOriginalValue) {\n@@ -518,11 +518,11 @@ TEST_F(WhileLoopFusibleSinkingTest, PlumbSingleBroadcastWithOriginalValue) {\n   HloInstruction* while_instr = FindInstruction(module.get(), \"while\");\n   ASSERT_NE(while_instr->original_value(), nullptr);\n   EXPECT_EQ(while_instr->original_value()->ToString(),\n-            \"({\\\"while\\\" {0}}, {\\\"while\\\" {1}}, {\\\"while\\\" {2}}, {\\\"zero\\\"})\");\n+            R\"(({\"while\" {0}}, {\"while\" {1}}, {\"while\" {2}}, {\"zero\"}))\");\n   HloInstruction* while_init = while_instr->while_init();\n   ASSERT_NE(while_init->original_value(), nullptr);\n   EXPECT_EQ(while_init->original_value()->ToString(),\n-            \"({\\\"zero\\\"}, {\\\"zeros32\\\"}, {\\\"broadcast\\\"}, {\\\"zero\\\"})\");\n+            R\"(({\"zero\"}, {\"zeros32\"}, {\"broadcast\"}, {\"zero\"}))\");\n }\n \n }  // namespace"
        },
        {
            "sha": "7e092d2bc2682d71d2445b1a53d277eef769a472",
            "filename": "third_party/xla/xla/service/while_util.cc",
            "status": "modified",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -15,6 +15,7 @@ limitations under the License.\n \n #include \"xla/service/while_util.h\"\n \n+#include <algorithm>\n #include <cstdint>\n #include <functional>\n #include <iterator>\n@@ -615,4 +616,70 @@ absl::Status WhileUtil::IncrementWhileLoopTripCount(\n   return induction_var->ReplaceAllUsesWith(decremented_induction_var);\n }\n \n+void AppendToWhileLoopOriginalValue(\n+    HloInstruction* while_instr,\n+    const HloInstruction::InstructionVector& new_while_input_tuple_elements) {\n+  auto append_to_original_value = [&](HloInstruction* instr,\n+                                      int64_t next_index) {\n+    std::shared_ptr<OriginalValue> old_original_value = instr->original_value();\n+    if (old_original_value != nullptr &&\n+        old_original_value->IsCompatibleWith(instr->shape())) {\n+      return;\n+    }\n+\n+    // Returns if neither the instruction nor any of its new tuple elements have\n+    // an original value.\n+    if (old_original_value == nullptr) {\n+      bool has_original_value = false;\n+      std::for_each(new_while_input_tuple_elements.begin(),\n+                    new_while_input_tuple_elements.end(),\n+                    [&has_original_value](const HloInstruction* instr) {\n+                      has_original_value |=\n+                          (instr->original_value() != nullptr &&\n+                           !instr->original_value()->IsEmpty());\n+                    });\n+      if (!has_original_value) {\n+        return;\n+      }\n+    }\n+\n+    std::shared_ptr<OriginalValue> new_original_value =\n+        std::make_shared<OriginalValue>(instr->shape());\n+    if (old_original_value != nullptr) {\n+      if (!old_original_value->IsTuple()) {\n+        new_original_value->mutable_tree()->CopySubtreeFrom(\n+            old_original_value->tree(), {}, {0});\n+      } else {\n+        for (auto& [shape_index, original_array] : old_original_value->tree()) {\n+          *new_original_value->mutable_original_array(shape_index) =\n+              original_array;\n+        }\n+      }\n+    }\n+\n+    for (int64_t i = 0; i < new_while_input_tuple_elements.size(); ++i) {\n+      if (new_while_input_tuple_elements[i]->original_value() != nullptr) {\n+        new_original_value->mutable_tree()->CopySubtreeFrom(\n+            new_while_input_tuple_elements[i]->original_value()->tree(), {},\n+            {next_index + i});\n+      }\n+    }\n+    instr->set_original_value(new_original_value);\n+  };\n+\n+  if (while_instr->opcode() != HloOpcode::kWhile) {\n+    return;\n+  }\n+  const Shape& while_shape = while_instr->shape();\n+  if (!while_shape.IsTuple()) {\n+    return;\n+  }\n+  // Calculates the start index for the new tuple elements in the new original\n+  // value.\n+  int64_t next_index =\n+      while_shape.tuple_shapes().size() - new_while_input_tuple_elements.size();\n+  append_to_original_value(while_instr->while_init(), next_index);\n+  append_to_original_value(while_instr, next_index);\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "7b2a820ced8024cda0d037a3ba5793b632f47a93",
            "filename": "third_party/xla/xla/service/while_util.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a6e123761d01eaac4a842b6cd80f35af010808f7/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.h?ref=a6e123761d01eaac4a842b6cd80f35af010808f7",
            "patch": "@@ -155,6 +155,15 @@ class WhileUtil {\n   static absl::Status IncrementWhileLoopTripCount(\n       const HloInstruction& while_instruction, int32_t increment);\n };\n+\n+// This is a helper function to update the original value after some\n+// transformations append new elements to the while input tuple (or turn it into\n+// a tuple if it was not one before). It appends the original values of the\n+// new elements after existing children of the root node of the old original\n+// value. This is done for both the input and output of the loop respectively.\n+void AppendToWhileLoopOriginalValue(\n+    HloInstruction* while_instr,\n+    const HloInstruction::InstructionVector& new_while_input_tuple_elements);\n }  // namespace xla\n \n #endif  // XLA_SERVICE_WHILE_UTIL_H_"
        }
    ],
    "stats": {
        "total": 134,
        "additions": 92,
        "deletions": 42
    }
}