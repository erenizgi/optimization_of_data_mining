{
    "author": "majnemer",
    "message": "[TF] Migrate to ABSL logging.\n\nNo functional change is intended.\n\nPiperOrigin-RevId: 811904046",
    "sha": "f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144",
    "files": [
        {
            "sha": "8fa3e726e6a83788f1a652e5100f29044adc9861",
            "filename": "tensorflow/c/experimental/filesystem/plugins/gcs/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2FBUILD?ref=f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144",
            "patch": "@@ -36,7 +36,9 @@ cc_library(\n         \"//tensorflow/c/experimental/filesystem:filesystem_interface\",\n         \"@com_github_googlecloudplatform_google_cloud_cpp//:storage_client\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n     ],\n )\n@@ -66,6 +68,8 @@ cc_library(\n         \"//tensorflow/c:logging\",\n         \"//tensorflow/c:tf_status\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/time\",\n     ],"
        },
        {
            "sha": "3b9650b74163150d710d7b9f5221743e1cb39999",
            "filename": "tensorflow/c/experimental/filesystem/plugins/gcs/gcs_filesystem.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 36,
            "changes": 74,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fgcs_filesystem.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fgcs_filesystem.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fgcs_filesystem.cc?ref=f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144",
            "patch": "@@ -29,8 +29,10 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/base/thread_annotations.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_format.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"third_party/cloud_cpp/google/cloud/common_options.h\"\n #include \"third_party/cloud_cpp/google/cloud/options.h\"\n@@ -151,8 +153,8 @@ static int64_t LoadBufferFromGCS(const std::string& path, size_t offset,\n   }\n   // `TF_OUT_OF_RANGE` isn't considered as an error. So we clear it here.\n   TF_SetStatus(status, TF_OK, \"\");\n-  TF_VLog(1, \"Successful read of %s @ %u of size: %u\", path.c_str(), offset,\n-          read);\n+  VLOG(1) << absl::StrFormat(\"Successful read of %s @ %u of size: %u\", path,\n+                             offset, read);\n   stream.read(buffer, read);\n   read = stream.gcount();\n   if (read < buffer_size) {\n@@ -165,8 +167,8 @@ static int64_t LoadBufferFromGCS(const std::string& path, size_t offset,\n                                   path, \" @ \", offset)\n                          .c_str());\n       }\n-      TF_VLog(2, \"Successful integrity check for: %s @ %u\", path.c_str(),\n-              offset);\n+      VLOG(2) << absl::StrFormat(\"Successful integrity check for: %s @ %u\",\n+                                 path, offset);\n     }\n   }\n   return read;\n@@ -306,8 +308,8 @@ static void SyncImpl(const std::string& bucket, const std::string& object,\n       TF_SetStatusFromGCSStatus(metadata.status(), status);\n       return;\n     }\n-    TF_VLog(3, \"AppendObject: gs://%s/%s to gs://%s/%s\", bucket.c_str(),\n-            temporary_object.c_str(), bucket.c_str(), object.c_str());\n+    VLOG(3) << absl::StrFormat(\"AppendObject: gs://%s/%s to gs://%s/%s\", bucket,\n+                               temporary_object, bucket, object);\n     const std::vector<gcs::ComposeSourceObject> source_objects = {\n         {object, {}, {}}, {temporary_object, {}, {}}};\n     metadata = gcs_client->ComposeObject(bucket, source_objects, object,\n@@ -346,8 +348,8 @@ void Append(const TF_WritableFile* file, const char* buffer, size_t n,\n                  \"The internal temporary file is not writable.\");\n     return;\n   }\n-  TF_VLog(3, \"Append: gs://%s/%s size %u\", gcs_file->bucket.c_str(),\n-          gcs_file->object.c_str(), n);\n+  VLOG(3) << absl::StrFormat(\"Append: gs://%s/%s size %u\", gcs_file->bucket,\n+                             gcs_file->object, n);\n   gcs_file->sync_need = true;\n   gcs_file->outfile.write(buffer, n);\n   if (!gcs_file->outfile)\n@@ -373,17 +375,17 @@ int64_t Tell(const TF_WritableFile* file, TF_Status* status) {\n void Flush(const TF_WritableFile* file, TF_Status* status) {\n   auto gcs_file = static_cast<GCSFile*>(file->plugin_file);\n   if (gcs_file->sync_need) {\n-    TF_VLog(3, \"Flush started: gs://%s/%s\", gcs_file->bucket.c_str(),\n-            gcs_file->object.c_str());\n+    VLOG(3) << absl::StrFormat(\"Flush started: gs://%s/%s\", gcs_file->bucket,\n+                               gcs_file->object);\n     if (!gcs_file->outfile) {\n       TF_SetStatus(status, TF_INTERNAL,\n                    \"Could not append to the internal temporary file.\");\n       return;\n     }\n     SyncImpl(gcs_file->bucket, gcs_file->object, &gcs_file->offset,\n              &gcs_file->outfile, gcs_file->gcs_client, status);\n-    TF_VLog(3, \"Flush finished: gs://%s/%s\", gcs_file->bucket.c_str(),\n-            gcs_file->object.c_str());\n+    VLOG(3) << absl::StrFormat(\"Flush finished: gs://%s/%s\", gcs_file->bucket,\n+                               gcs_file->object);\n     if (TF_GetCode(status) != TF_OK) return;\n     gcs_file->sync_need = false;\n   } else {\n@@ -393,15 +395,15 @@ void Flush(const TF_WritableFile* file, TF_Status* status) {\n \n void Sync(const TF_WritableFile* file, TF_Status* status) {\n   auto gcs_file = static_cast<GCSFile*>(file->plugin_file);\n-  TF_VLog(3, \"Sync: gs://%s/%s\", gcs_file->bucket.c_str(),\n-          gcs_file->object.c_str());\n+  VLOG(3) << absl::StrFormat(\"Sync: gs://%s/%s\", gcs_file->bucket,\n+                             gcs_file->object);\n   Flush(file, status);\n }\n \n void Close(const TF_WritableFile* file, TF_Status* status) {\n   auto gcs_file = static_cast<GCSFile*>(file->plugin_file);\n-  TF_VLog(3, \"Close: gs://%s/%s\", gcs_file->bucket.c_str(),\n-          gcs_file->object.c_str());\n+  VLOG(3) << absl::StrFormat(\"Close: gs://%s/%s\", gcs_file->bucket,\n+                             gcs_file->object);\n   if (gcs_file->sync_need) {\n     Flush(file, status);\n   }\n@@ -467,8 +469,9 @@ GCSFile::GCSFile(gcs::Client&& gcs_client)\n   if (max_staleness_env && absl::SimpleAtoi(max_staleness_env, &value)) {\n     max_staleness = value;\n   }\n-  TF_VLog(1, \"GCS cache max size = %u ; block size = %u ; max staleness = %u\",\n-          max_bytes, block_size, max_staleness);\n+  VLOG(1) << absl::StrFormat(\n+      \"GCS cache max size = %u ; block size = %u ; max staleness = %u\",\n+      max_bytes, block_size, max_staleness);\n \n   file_block_cache = std::make_unique<RamFileBlockCache>(\n       block_size, max_bytes, max_staleness,\n@@ -563,10 +566,10 @@ static void UncachedStatForObject(const std::string& bucket,\n   stat->base.mtime_nsec =\n       metadata->time_storage_class_updated().time_since_epoch().count();\n   stat->base.is_directory = object.back() == '/';\n-  TF_VLog(1,\n-          \"Stat of: gs://%s/%s --  length: %u generation: %u; mtime_nsec: %u;\",\n-          bucket.c_str(), object.c_str(), stat->base.length,\n-          stat->generation_number, stat->base.mtime_nsec);\n+  VLOG(1) << absl::StrFormat(\n+      \"Stat of: gs://%s/%s --  length: %u generation: %u; mtime_nsec: %u;\",\n+      bucket, object, stat->base.length, stat->generation_number,\n+      stat->base.mtime_nsec);\n   return TF_SetStatus(status, TF_OK, \"\");\n }\n \n@@ -601,10 +604,9 @@ void NewRandomAccessFile(const TF_Filesystem* filesystem, const char* path,\n       if (TF_GetCode(status) != TF_OK) return -1;\n       if (!gcs_file->file_block_cache->ValidateAndUpdateFileSignature(\n               path, stat.generation_number)) {\n-        TF_VLog(\n-            1,\n-            \"File signature has been changed. Refreshing the cache. Path: %s\",\n-            path.c_str());\n+        VLOG(1)\n+            << \"File signature has been changed. Refreshing the cache. Path: \"\n+            << path;\n       }\n       read = gcs_file->file_block_cache->Read(path, offset, n, buffer, status);\n     } else {\n@@ -636,7 +638,7 @@ void NewWritableFile(const TF_Filesystem* filesystem, const char* path,\n        (gcs_file->compose ? 0 : -1)});\n   // We are responsible for freeing the pointer returned by TF_GetTempFileName\n   free(temp_file_name);\n-  TF_VLog(3, \"GcsWritableFile: %s\", path);\n+  VLOG(3) << \"GcsWritableFile: \" << path;\n   TF_SetStatus(status, TF_OK, \"\");\n }\n \n@@ -683,8 +685,8 @@ void NewAppendableFile(const TF_Filesystem* filesystem, const char* path,\n       return;\n     }\n   }\n-  TF_VLog(3, \"GcsWritableFile: %s with existing file %s\", path,\n-          temp_file_name.c_str());\n+  VLOG(3) << absl::StrFormat(\"GcsWritableFile: %s with existing file %s\", path,\n+                             temp_file_name);\n   TF_SetStatus(status, TF_OK, \"\");\n }\n \n@@ -876,10 +878,10 @@ void CreateDir(const TF_Filesystem* filesystem, const char* path,\n                TF_Status* status) {\n   std::string dir = path;\n   MaybeAppendSlash(&dir);\n-  TF_VLog(3,\n-          \"CreateDir: creating directory with path: %s and \"\n-          \"path_with_slash: %s\",\n-          path, dir.c_str());\n+  VLOG(3) << absl::StrFormat(\n+      \"CreateDir: creating directory with path: %s and \"\n+      \"path_with_slash: %s\",\n+      path, dir);\n   std::string bucket, object;\n   ParseGCSPath(dir, true, &bucket, &object, status);\n   if (TF_GetCode(status) != TF_OK) return;\n@@ -897,7 +899,7 @@ void CreateDir(const TF_Filesystem* filesystem, const char* path,\n   PathExists(filesystem, dir.c_str(), status);\n   if (TF_GetCode(status) == TF_OK) {\n     // Use the original name for a correct error here.\n-    TF_VLog(3, \"CreateDir: directory already exists, not uploading %s\", path);\n+    VLOG(3) << \"CreateDir: directory already exists, not uploading \" << path;\n     return TF_SetStatus(status, TF_ALREADY_EXISTS, path);\n   }\n \n@@ -1007,7 +1009,7 @@ bool IsDirectory(const TF_Filesystem* filesystem, const char* path,\n static void RenameObject(const TF_Filesystem* filesystem,\n                          const std::string& src, const std::string& dst,\n                          TF_Status* status) {\n-  TF_VLog(3, \"RenameObject: started %s to %s\", src.c_str(), dst.c_str());\n+  VLOG(3) << absl::StrFormat(\"RenameObject: started %s to %s\", src, dst);\n   std::string bucket_src, object_src;\n   ParseGCSPath(src, false, &bucket_src, &object_src, status);\n   if (TF_GetCode(status) != TF_OK) return;\n@@ -1022,7 +1024,7 @@ static void RenameObject(const TF_Filesystem* filesystem,\n       gcs::Fields(\"done,rewriteToken\"));\n   TF_SetStatusFromGCSStatus(metadata.status(), status);\n   if (TF_GetCode(status) != TF_OK) return;\n-  TF_VLog(3, \"RenameObject: finished %s to %s\", src.c_str(), dst.c_str());\n+  VLOG(3) << absl::StrFormat(\"RenameObject: finished %s to %s\", src, dst);\n \n   ClearFileCaches(gcs_file, dst);\n   DeleteFile(filesystem, src.c_str(), status);"
        },
        {
            "sha": "0060abc76699c3ddb82eed15130a3dada532f28c",
            "filename": "tensorflow/c/experimental/filesystem/plugins/gcs/ram_file_block_cache.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fram_file_block_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fram_file_block_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fram_file_block_cache.h?ref=f1b1fdda26cbea2c6c3d50b19ee55ceae74bc144",
            "patch": "@@ -28,6 +28,8 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/base/thread_annotations.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/str_format.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/synchronization/notification.h\"\n #include \"tensorflow/c/env.h\"\n@@ -69,8 +71,8 @@ class RamFileBlockCache {\n       pruning_thread_.reset(\n           TF_StartThread(&thread_options, \"TF_prune_FBC\", PruneThread, this));\n     }\n-    TF_VLog(1, \"GCS file block cache is %s.\\n\",\n-            (IsCacheEnabled() ? \"enabled\" : \"disabled\"));\n+    VLOG(1) << absl::StrFormat(\"GCS file block cache is %s.\\n\",\n+                               (IsCacheEnabled() ? \"enabled\" : \"disabled\"));\n   }\n \n   ~RamFileBlockCache() {"
        }
    ],
    "stats": {
        "total": 84,
        "additions": 46,
        "deletions": 38
    }
}