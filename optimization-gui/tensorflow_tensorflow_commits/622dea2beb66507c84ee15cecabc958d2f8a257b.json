{
    "author": "tensorflower-gardener",
    "message": "[XLA] Create a SliceHoister HLO pass.\n\nThis CL hoists slices through add operations. It'll be beneficial in cases like having an add operation that has only one user which is a slice that removes most of the elements. It can degrade the efficiency in cases like having an add operation with multiple different slice users that keep most of the elements, since then the addition will be repeated for every slice user.\n\nIt'll have follow-up CLs before it's added to the pipeline.\n\nPiperOrigin-RevId: 803455702",
    "sha": "622dea2beb66507c84ee15cecabc958d2f8a257b",
    "files": [
        {
            "sha": "563439030d00ef231aa388fbcf1b7bc50408e776",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/BUILD",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD?ref=622dea2beb66507c84ee15cecabc958d2f8a257b",
            "patch": "@@ -1706,6 +1706,38 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"slice_hoister\",\n+    srcs = [\"slice_hoister.cc\"],\n+    hdrs = [\"slice_hoister.h\"],\n+    deps = [\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/pass:hlo_pass\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"slice_hoister_test\",\n+    srcs = [\"slice_hoister_test.cc\"],\n+    deps = [\n+        \":slice_hoister\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/testlib:pattern_matcher_gmock\",\n+        \"//xla/service:hlo_cse\",\n+        \"//xla/service:pattern_matcher\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"unflatten_call_graph\",\n     srcs = [\"unflatten_call_graph.cc\"],"
        },
        {
            "sha": "c8307e04ec9dbc3670bdda3c2075db0915c2b436",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister.cc",
            "status": "added",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc?ref=622dea2beb66507c84ee15cecabc958d2f8a257b",
            "patch": "@@ -0,0 +1,134 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/transforms/simplifiers/slice_hoister.h\"\n+\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+\n+namespace {\n+\n+// Helper function to attempt hoisting a slice through an add operation.\n+// Returns true if a change was made.\n+absl::StatusOr<bool> TryHoistSliceThroughAdd(HloInstruction* instruction,\n+                                             HloComputation* computation) {\n+  if (instruction->opcode() != HloOpcode::kSlice) {\n+    return false;\n+  }\n+  HloInstruction* operand = instruction->mutable_operand(0);\n+  if (operand->opcode() != HloOpcode::kAdd) {\n+    return false;\n+  }\n+\n+  HloInstruction* add = operand;\n+  HloInstruction* lhs = add->mutable_operand(0);\n+  HloInstruction* rhs = add->mutable_operand(1);\n+\n+  if (lhs->shape() != rhs->shape()) {\n+    VLOG(1) << \" Operand shapes do not match: \" << lhs->shape() << \" and \"\n+            << rhs->shape();\n+    return false;\n+  }\n+  if (lhs->shape().element_type() != instruction->shape().element_type()) {\n+    VLOG(1) << \" Slice element type does not match operand element type: \"\n+            << lhs->shape().element_type() << \" and \"\n+            << instruction->shape().element_type();\n+    return false;\n+  }\n+  if (instruction->shape().element_type() != add->shape().element_type()) {\n+    VLOG(1) << \" Slice element type does not match add element type: \"\n+            << instruction->shape().element_type() << \" and \"\n+            << add->shape().element_type();\n+    return false;\n+  }\n+\n+  // All checks passed, perform the hoisting.\n+  HloInstruction* lhs_slice =\n+      computation->AddInstruction(HloInstruction::CreateSlice(\n+          instruction->shape(), lhs, instruction->slice_starts(),\n+          instruction->slice_limits(), instruction->slice_strides()));\n+  HloInstruction* rhs_slice =\n+      computation->AddInstruction(HloInstruction::CreateSlice(\n+          instruction->shape(), rhs, instruction->slice_starts(),\n+          instruction->slice_limits(), instruction->slice_strides()));\n+  TF_RETURN_IF_ERROR(computation->ReplaceWithNewInstruction(\n+      instruction,\n+      HloInstruction::CreateBinary(instruction->shape(), HloOpcode::kAdd,\n+                                   lhs_slice, rhs_slice)));\n+  return true;\n+}\n+\n+// As slices reduce the size of the input, it can be beneficial to hoist\n+// slices as high in the graph as possible, ideally right after parameter\n+// reads, which could reduce both compute and memory costs.\n+//\n+// Currently, this pass hoists slice operations through add operations.\n+// Note that this pass can create redundant slices, which can be removed by\n+// running CSE.\n+//\n+// Note that algebraic simplifier also has `HandleSlice` function.\n+absl::StatusOr<bool> HoistSliceOperations(HloComputation* computation) {\n+  bool changed = false;\n+  bool changed_on_last_iteration = false;\n+  // TODO(b/434724820): Generalize to element-wise operations.\n+  // TODO(b/434724820): Consider also other operations like broadcast, reduce,\n+  // transpose, etc.\n+  // TODO(b/434724820): Make this more efficient by e.g. using a worklist or a\n+  // topological sort.\n+  do {\n+    changed |= changed_on_last_iteration;\n+    changed_on_last_iteration = false;\n+    std::vector<HloInstruction*> instructions =\n+        computation->MakeInstructionPostOrder();\n+    for (HloInstruction* instruction : instructions) {\n+      TF_ASSIGN_OR_RETURN(bool instruction_changed,\n+                          TryHoistSliceThroughAdd(instruction, computation));\n+      if (instruction_changed) {\n+        changed_on_last_iteration = true;\n+        break;\n+      }\n+    }\n+  } while (changed_on_last_iteration);\n+\n+  return changed;\n+}\n+}  // anonymous namespace\n+\n+absl::StatusOr<bool> SliceHoister::Run(\n+    HloModule* module,\n+    const absl::flat_hash_set<absl::string_view>& execution_threads) {\n+  bool changed = false;\n+  for (HloComputation* computation :\n+       module->MakeNonfusionComputations(execution_threads)) {\n+    TF_ASSIGN_OR_RETURN(bool changed_computation,\n+                        HoistSliceOperations(computation));\n+    changed |= changed_computation;\n+  }\n+  return changed;\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "f66aeee1f7685e03577da2a6fd6c0371ac15bc7c",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister.h",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.h?ref=622dea2beb66507c84ee15cecabc958d2f8a257b",
            "patch": "@@ -0,0 +1,41 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_HLO_TRANSFORMS_SIMPLIFIERS_SLICE_HOISTER_H_\n+#define XLA_HLO_TRANSFORMS_SIMPLIFIERS_SLICE_HOISTER_H_\n+\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/pass/hlo_pass_interface.h\"\n+\n+namespace xla {\n+\n+// An HLO pass that hoists slice operations through add operations.\n+class SliceHoister : public HloModulePass {\n+ public:\n+  SliceHoister() = default;\n+\n+  absl::string_view name() const override { return \"slice-hoister\"; }\n+  using HloPassInterface::Run;\n+  absl::StatusOr<bool> Run(\n+      HloModule* module,\n+      const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_HLO_TRANSFORMS_SIMPLIFIERS_SLICE_HOISTER_H_"
        },
        {
            "sha": "49a39a47569e120e59d0c50e7b38176a098fd104",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister_test.cc",
            "status": "added",
            "additions": 184,
            "deletions": 0,
            "changes": 184,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/622dea2beb66507c84ee15cecabc958d2f8a257b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc?ref=622dea2beb66507c84ee15cecabc958d2f8a257b",
            "patch": "@@ -0,0 +1,184 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/transforms/simplifiers/slice_hoister.h\"\n+\n+#include <memory>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/testlib/pattern_matcher_gmock.h\"\n+#include \"xla/service/hlo_cse.h\"\n+#include \"xla/service/pattern_matcher.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace {\n+\n+namespace m = xla::match;\n+using ::testing::ElementsAre;\n+\n+class SliceHoisterTest : public HloHardwareIndependentTestBase {\n+ public:\n+  SliceHoisterTest()\n+      : HloHardwareIndependentTestBase(\n+            /*verifier_layout_sensitive=*/false,\n+            /*allow_mixed_precision_in_hlo_verifier=*/true) {};\n+};\n+\n+TEST_F(SliceHoisterTest, HoistSliceThroughAdd) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      add_op = f32[8,9] add(f32[8,9] parameter(0), f32[8,9] parameter(1))\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_TRUE(changed);\n+  HloInstruction* root_instruction =\n+      module->entry_computation()->root_instruction();\n+  const HloInstruction* param_0_slice = nullptr;\n+  const HloInstruction* param_1_slice = nullptr;\n+  EXPECT_THAT(root_instruction,\n+              GmockMatch(m::Add(m::Slice(&param_0_slice, m::Parameter(0)),\n+                                m::Slice(&param_1_slice, m::Parameter(1)))));\n+  EXPECT_THAT(param_0_slice->slice_starts(), ElementsAre(0, 0));\n+  EXPECT_THAT(param_0_slice->slice_limits(), ElementsAre(2, 9));\n+  EXPECT_THAT(param_0_slice->slice_strides(), ElementsAre(1, 1));\n+  EXPECT_THAT(param_1_slice->slice_starts(), ElementsAre(0, 0));\n+  EXPECT_THAT(param_1_slice->slice_limits(), ElementsAre(2, 9));\n+  EXPECT_THAT(param_1_slice->slice_strides(), ElementsAre(1, 1));\n+}\n+\n+TEST_F(SliceHoisterTest, HoistSliceThroughMultipleAdds) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      param_0 = f32[8,9] parameter(0)\n+      param_1 = f32[8,9] parameter(1)\n+      add_op_1 = f32[8,9] add(f32[8,9] param_0, f32[8,9] param_1)\n+      add_op_2 = f32[8,9] add(f32[8,9] add_op_1, f32[8,9] param_1)\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op_2), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_TRUE(changed);\n+\n+  HloCSE cse = HloCSE(false);\n+  TF_ASSERT_OK_AND_ASSIGN(changed, RunHloPass(&cse, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_TRUE(changed);\n+\n+  HloInstruction* root_instruction =\n+      module->entry_computation()->root_instruction();\n+  const HloInstruction* param_0_slice = nullptr;\n+  const HloInstruction* param_1_first_slice = nullptr;\n+  const HloInstruction* param_1_second_slice = nullptr;\n+  EXPECT_THAT(\n+      root_instruction,\n+      GmockMatch(m::Add(m::Add(m::Slice(&param_0_slice, m::Parameter(0)),\n+                               m::Op(&param_1_first_slice)),\n+                        m::Op(&param_1_second_slice))));\n+  // The slice of param_1 should be evaluated only once and reused.\n+  EXPECT_EQ(param_1_first_slice, param_1_second_slice);\n+  EXPECT_THAT(param_1_first_slice, GmockMatch(m::Slice(m::Parameter(1))));\n+  EXPECT_THAT(param_0_slice->slice_starts(), ElementsAre(0, 0));\n+  EXPECT_THAT(param_0_slice->slice_limits(), ElementsAre(2, 9));\n+  EXPECT_THAT(param_0_slice->slice_strides(), ElementsAre(1, 1));\n+  EXPECT_THAT(param_1_first_slice->slice_starts(), ElementsAre(0, 0));\n+  EXPECT_THAT(param_1_first_slice->slice_limits(), ElementsAre(2, 9));\n+  EXPECT_THAT(param_1_first_slice->slice_strides(), ElementsAre(1, 1));\n+}\n+\n+TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughAddIfElementTypesDoNotMatch) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      add_op = f32[8,9] add(f16[8,9] parameter(0), f32[8,9] parameter(1))\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_FALSE(changed);\n+}\n+\n+TEST_F(SliceHoisterTest,\n+       DoesNotHoistSliceThroughAddIfAddTypeDoesNotMatchSliceType) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      add_op = f32[8,9] add(f32[8,9] parameter(0), f32[8,9] parameter(1))\n+      ROOT slice_op = f16[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_FALSE(changed);\n+}\n+\n+TEST_F(SliceHoisterTest,\n+       DoesNotHoistSliceThroughAddIfAddTypeDoesNotMatchOperandsType) {\n+  absl::string_view module_str = R\"(\n+    HloModule module\n+    ENTRY main {\n+      add_op = f32[8,9] add(f16[8,9] parameter(0), f16[8,9] parameter(1))\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  SliceHoister slice_hoister;\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          RunHloPass(&slice_hoister, module.get()));\n+\n+  SCOPED_TRACE(module->ToString());\n+  EXPECT_FALSE(changed);\n+}\n+}  // anonymous namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 391,
        "additions": 391,
        "deletions": 0
    }
}