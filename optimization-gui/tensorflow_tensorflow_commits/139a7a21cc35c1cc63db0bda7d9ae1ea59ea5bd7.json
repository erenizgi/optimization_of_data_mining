{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809721577",
    "sha": "139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7",
    "files": [
        {
            "sha": "c75682ab0eb765152d7e0c3e4c1bb0450e554ad8",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/basic_string_array.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc?ref=139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7",
            "patch": "@@ -131,12 +131,12 @@ Future<> BasicStringArray::Delete() {\n }\n \n bool BasicStringArray::IsDeleted() const {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   return is_deleted_;\n }\n \n void BasicStringArray::DeleteInternal() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (is_deleted_) {\n     return;\n   }\n@@ -148,7 +148,7 @@ void BasicStringArray::DeleteInternal() {\n \n Future<> BasicStringArray::GetReadyFuture() const {\n   DCHECK(this);\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (is_deleted_) {\n     return Future<>(\n         absl::FailedPreconditionError(\"Array has already been deleted\"));\n@@ -169,7 +169,7 @@ BasicStringArray::DisassembleIntoSingleDeviceArrays(\n         *sharding_->devices());\n   }\n \n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (is_deleted_) {\n     return absl::FailedPreconditionError(\"Array has already been deleted\");\n   }\n@@ -263,7 +263,7 @@ Future<> BasicStringArray::CopyToHostBuffer(\n     void* data, std::optional<absl::Span<const int64_t>> byte_strides,\n     ArrayCopySemantics semantics) {\n   DCHECK(this);\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (is_deleted_) {\n     return Future<>(\n         absl::FailedPreconditionError(\"Array has already been deleted\"));\n@@ -301,7 +301,7 @@ absl::StatusOr<ArrayRef> BasicStringArray::Copy(\n     std::optional<xla::ifrt::MemoryKind> memory_kind,\n     ArrayCopySemantics semantics) {\n   DCHECK(this);\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (is_deleted_) {\n     return absl::FailedPreconditionError(\"Array has already been deleted\");\n   }\n@@ -355,7 +355,7 @@ absl::StatusOr<ArrayRef> BasicStringArray::Copy(\n // Makes a single sharded BasicStringArray from the first shard.\n absl::StatusOr<ArrayRef> BasicStringArray::FullyReplicatedShard(\n     ArrayCopySemantics semantics) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (is_deleted_) {\n     return absl::FailedPreconditionError(\"Array has already been deleted\");\n   }"
        },
        {
            "sha": "979462bdd80521f0f7c8ef9fe06e1f9fcba89a7d",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_client.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc?ref=139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7",
            "patch": "@@ -663,7 +663,7 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n                         promise = std::move(buffers_promise).ToShared()](\n                            absl::StatusOr<BasicStringArray::Buffers> strbuf,\n                            int shard_index) mutable {\n-    absl::MutexLock lock(&state->mu);\n+    absl::MutexLock lock(state->mu);\n     if (state->num_buffers_to_copy == 0) {\n       // Nothing to be done. We get here if the buffers of a single\n       // device array became ready with a an error previously.\n@@ -892,7 +892,7 @@ PjRtClient::PjRtClient(std::shared_ptr<xla::PjRtClient> pjrt_client)\n       attributes_(MakeAttributeMap(pjrt_client_.get())) {}\n \n PjRtClient::~PjRtClient() {\n-  absl::MutexLock lock(&shutting_down_mu_);\n+  absl::MutexLock lock(shutting_down_mu_);\n   shutting_down_ = true;\n }\n \n@@ -1411,7 +1411,7 @@ PjRtClient::CopyArraysForCrossHostFallback(\n     absl::Span<ArrayRef> arrays, DeviceListRef src_devices,\n     DeviceListRef dst_devices, std::optional<MemoryKind> memory_kind) {\n   {\n-    absl::MutexLock lock(&(transfer_server_mu_));\n+    absl::MutexLock lock(transfer_server_mu_);\n     TF_RETURN_IF_ERROR(InitializeTransferServer());\n   }\n   return (*transfer_server_)\n@@ -1439,14 +1439,14 @@ absl::Status PjRtClient::WatchGlobalProcessInfo(\n         [this, &response,\n          &done](absl::StatusOr<tensorflow::WatchJobStateResponse> r) {\n           response = std::move(r);\n-          absl::MutexLock lock(&shutting_down_mu_);\n+          absl::MutexLock lock(shutting_down_mu_);\n           done = true;\n         });\n \n     {\n       // Wait for the WatchJobStateAsync call to finish or for us to shut down,\n       // whichever happens first.\n-      absl::MutexLock lock(&shutting_down_mu_);\n+      absl::MutexLock lock(shutting_down_mu_);\n       auto done_or_shutting_down = [this, &done]() {\n         shutting_down_mu_.AssertHeld();\n         return done || shutting_down_;"
        },
        {
            "sha": "84c615479b2e389f1d885f07333efd077123e16d",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_tuple.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_tuple.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_tuple.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_tuple.cc?ref=139a7a21cc35c1cc63db0bda7d9ae1ea59ea5bd7",
            "patch": "@@ -51,7 +51,7 @@ Future<> PjRtTuple::GetReadyFuture() const {\n \n Future<> PjRtTuple::Delete() {\n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if (!is_deleted_.HasBeenNotified()) {\n       is_deleted_.Notify();\n     }"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 13,
        "deletions": 13
    }
}