{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 829745705",
    "sha": "7c2de2a3df89aabbebabda17b004249ba88e5856",
    "files": [
        {
            "sha": "6a86c996f2b0442a2863d67fa3923f8765587b30",
            "filename": "third_party/xla/xla/pjrt/buffer_sequencing_event.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fbuffer_sequencing_event.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fbuffer_sequencing_event.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fbuffer_sequencing_event.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -65,7 +65,7 @@ void BufferSequencingEvent::WaitForEventOnStream(se::Stream* stream) {\n     return;\n   }\n \n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   // The set of defined streams is expected to be very small indeed (usually\n   // 1-2), so a simple linear scan should be fast enough.\n   if (std::find(streams_defined_on_.begin(), streams_defined_on_.end(),\n@@ -103,7 +103,7 @@ bool BufferSequencingEvent::IsPredeterminedErrorOrDefinedOn(\n \n   // The set of defined streams is expected to be very small indeed (usually\n   // 1-2), so a simple linear scan should be fast enough.\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   return absl::c_find(streams_defined_on_, stream) != streams_defined_on_.end();\n }\n "
        },
        {
            "sha": "ac365b511cf8cd4512d857c90ba2da53d116e6a8",
            "filename": "third_party/xla/xla/pjrt/host_callback.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.h?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -64,7 +64,7 @@ class ThreadSafePjRtChunkQueue {\n  public:\n   // Push a PjRtChunk into the queue.\n   void Push(PjRtChunk chunk) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if (promises_.empty()) {\n       queue_.push_back(std::move(chunk));\n       return;\n@@ -76,7 +76,7 @@ class ThreadSafePjRtChunkQueue {\n \n   // Pop a PjRtChunk future from the queue.\n   Future<PjRtChunk> Pop() {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if (queue_.empty()) {\n       auto [promise, future] = Future<PjRtChunk>::MakePromise();\n       promises_.push_back(std::move(promise));"
        },
        {
            "sha": "197b0529c95c07d9d9b3c1bf34c8f5b5d11e465f",
            "filename": "third_party/xla/xla/pjrt/host_to_device_transfer_manager.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_to_device_transfer_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_to_device_transfer_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_to_device_transfer_manager.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -175,7 +175,7 @@ class CommonAsyncHostToDeviceTransferManager\n       return transfers_in_flight_ == 0;\n     };\n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       // Make sure we don't leave dangling pointers in cleanup routines even\n       // if the client lets the object go out of scope.\n       mu_.Await(absl::Condition(&transfers_finished));\n@@ -215,7 +215,7 @@ class CommonAsyncHostToDeviceTransferManager\n   absl::Status TransferLiteralToBuffer(\n       int buffer_index, const LiteralSlice& literal,\n       absl::AnyInvocable<void() &&> on_done) override {\n-    absl::ReleasableMutexLock l(&mu_);\n+    absl::ReleasableMutexLock l(mu_);\n \n     DCHECK_LT(buffer_index, undispatched_buffer_refs_.size());\n     tsl::RCReference<CommonPjRtRawBuffer>& undispatched_buffer_ref =\n@@ -264,7 +264,7 @@ class CommonAsyncHostToDeviceTransferManager\n                     definition_event = std::move(definition_event),\n                     on_done = std::move(on_done)]() mutable {\n       {\n-        absl::MutexLock l(&mu_);\n+        absl::MutexLock l(mu_);\n \n         CHECK_GT(transfers_in_flight_, 0);\n         --transfers_in_flight_;\n@@ -306,7 +306,7 @@ class CommonAsyncHostToDeviceTransferManager\n   absl::Status TransferRawDataToSubBuffer(\n       int buffer_index, const void* data, int64_t offset, int64_t transfer_size,\n       bool is_last_transfer, absl::AnyInvocable<void() &&> on_done) override {\n-    absl::ReleasableMutexLock l(&mu_);\n+    absl::ReleasableMutexLock l(mu_);\n     DCHECK_LT(buffer_index, undispatched_buffer_refs_.size());\n     tsl::RCReference<CommonPjRtRawBuffer> undispatched_buffer_ref;\n     // Drop reference to the buffer if this is the last transfer.\n@@ -351,7 +351,7 @@ class CommonAsyncHostToDeviceTransferManager\n             data, offset, transfer_size));\n     if (client_->event_tracking_enabled()) {\n       // Acquire when logging, for the sake of definition_events_.\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       std::string op_name = debug_info_.has_value()\n                                 ? absl::StrCat(\" Op:\", debug_info_.value())\n                                 : \"\";\n@@ -367,7 +367,7 @@ class CommonAsyncHostToDeviceTransferManager\n                                  on_done = std::move(on_done)]() mutable {\n       tsl::RCReference<PjRtDeviceEventPromise> definition_event;\n       {\n-        absl::MutexLock l(&mu_);\n+        absl::MutexLock l(mu_);\n \n         CHECK_GT(transfers_in_flight_, 0);\n         --transfers_in_flight_;\n@@ -414,7 +414,7 @@ class CommonAsyncHostToDeviceTransferManager\n   }\n \n   void SetBufferError(int buffer_index, absl::Status error) override {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     // For a given buffer_index, SetBufferError can't be called twice, or\n     // called after the last transfer has been enqueued.\n     auto definition_event = std::move(definition_events_[buffer_index]);\n@@ -427,7 +427,7 @@ class CommonAsyncHostToDeviceTransferManager\n \n   void AddTransferMetadata(const TransferMetadata& meta) override {\n     if (client_->event_tracking_enabled()) {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       std::string annotation =\n           absl::StrCat(\" \", absl::StrJoin(meta, \" \", absl::PairFormatter(\":\")));\n       for (int i = 0; i < definition_events_.size(); ++i) {"
        },
        {
            "sha": "6f376b49ed5ee7b3f0c49a1d0383831033fdbf17",
            "filename": "third_party/xla/xla/pjrt/local_device_state.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Flocal_device_state.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Flocal_device_state.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Flocal_device_state.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -159,7 +159,7 @@ absl::Status LocalDeviceState::SynchronizeAllActivity() {\n   // fixed, we could remove the BlockHostUntilDone call.\n   status.Update(compute_stream_->BlockHostUntilDone());\n   if (callback_stream_map_.has_value()) {\n-    absl::MutexLock lock(&callback_stream_map_mu_);\n+    absl::MutexLock lock(callback_stream_map_mu_);\n     for (auto& callback_stream : callback_stream_map_.value()) {\n       status.Update(callback_stream.second->BlockHostUntilDone());\n     }\n@@ -188,7 +188,7 @@ absl::Status LocalDeviceState::ThenExecuteCallback(\n   tsl::profiler::TraceMe traceme(\"ThenExecuteCallback\");\n   if (callback_stream_map_.has_value()) {\n     // Prevent concurrent updates to the callback stream map.\n-    absl::MutexLock lock(&callback_stream_map_mu_);\n+    absl::MutexLock lock(callback_stream_map_mu_);\n     auto callback_stream = callback_stream_map_->find(stream);\n     if (callback_stream == callback_stream_map_->end()) {\n       TF_ASSIGN_OR_RETURN(auto new_stream, executor_->CreateStream());\n@@ -207,23 +207,23 @@ absl::Status LocalDeviceState::ThenExecuteCallback(\n }\n \n se::Stream* LocalDeviceState::GetDeviceToHostStream() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   int i = next_device_to_host_stream_;\n   next_device_to_host_stream_ =\n       (next_device_to_host_stream_ + 1) % device_to_host_streams_.size();\n   return device_to_host_streams_.at(i).get();\n }\n \n se::Stream* LocalDeviceState::GetDeviceToDeviceStream() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   int i = next_device_to_device_stream_;\n   next_device_to_device_stream_ =\n       (next_device_to_device_stream_ + 1) % device_to_device_streams_.size();\n   return device_to_device_streams_.at(i).get();\n }\n \n se::Stream* LocalDeviceState::GetFixedSizePoolUsageStream() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   int i = next_fixed_size_pool_usage_stream_;\n   next_fixed_size_pool_usage_stream_ =\n       (next_fixed_size_pool_usage_stream_ + 1) %\n@@ -232,7 +232,7 @@ se::Stream* LocalDeviceState::GetFixedSizePoolUsageStream() {\n }\n \n se::Stream* LocalDeviceState::GetExternalReadyEventStream() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   int i = next_external_ready_event_stream_;\n   next_external_ready_event_stream_ = (next_external_ready_event_stream_ + 1) %\n                                       external_ready_event_streams_.size();\n@@ -256,7 +256,7 @@ absl::StatusOr<se::Stream*> LocalDeviceState::GetStreamFromExternalStream(\n }\n \n std::vector<se::Stream*> LocalDeviceState::GetDeviceToDeviceStreams() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   std::vector<se::Stream*> result;\n   result.reserve(device_to_device_streams_.size());\n   for (const auto& stream : device_to_device_streams_) {\n@@ -267,7 +267,7 @@ std::vector<se::Stream*> LocalDeviceState::GetDeviceToDeviceStreams() {\n \n std::unique_ptr<se::Stream> LocalDeviceState::BorrowStreamFromPool() {\n   {\n-    absl::MutexLock lock(&stream_pool_mu_);\n+    absl::MutexLock lock(stream_pool_mu_);\n     if (!usage_stream_pool_.empty()) {\n       std::unique_ptr<se::Stream> stream = std::move(usage_stream_pool_.top());\n       usage_stream_pool_.pop();\n@@ -294,12 +294,12 @@ void LocalDeviceState::ReturnStreamToPool(std::unique_ptr<se::Stream> stream) {\n   if (status.code() != tsl::error::ABORTED) {\n     CHECK(stream->ok()) << status;\n   }\n-  absl::MutexLock lock(&stream_pool_mu_);\n+  absl::MutexLock lock(stream_pool_mu_);\n   usage_stream_pool_.push(std::move(stream));\n }\n \n int LocalDeviceState::GetNewPrngSeed() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   int x = 0;\n   do {\n     x = prng_seed_distribution_(prng_seed_generator_);\n@@ -355,7 +355,7 @@ LocalDeviceState::GetEventForComputeStreamSyncPoint(\n   }\n   mu_.unlock();\n   event.AndThen([this, cur_sync_point]() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     while (base_compute_event_sequence_id_ < cur_sync_point) {\n       compute_events_.pop_front();\n       ++base_compute_event_sequence_id_;"
        },
        {
            "sha": "f35a13e9aafe40b0eaed0363cdfc4c0d4a03baff",
            "filename": "third_party/xla/xla/pjrt/pjrt_client.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -391,14 +391,14 @@ class CopyToDeviceStream {\n   // Returns the amount of data the stream currently has either transferred or\n   // has buffered to transfer.\n   int64_t current_bytes() const ABSL_LOCKS_EXCLUDED(mu_) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return current_bytes_;\n   }\n \n   // Returns true if the stream is complete; all expected bytes have been\n   // transferred or are buffered to transfer.\n   bool IsComplete() const ABSL_LOCKS_EXCLUDED(mu_) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return IsCompleteLocked();\n   }\n "
        },
        {
            "sha": "4fddbe0dc5d33187c54e3862b9074eb93aad69b4",
            "filename": "third_party/xla/xla/pjrt/pjrt_client_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client_test.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -48,13 +48,13 @@ class TestClientFactory {\n  public:\n   void Register(\n       std::function<absl::StatusOr<std::unique_ptr<PjRtClient>>()> factory) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     CHECK(!factory_);\n     factory_ = std::move(factory);\n   }\n \n   std::function<absl::StatusOr<std::unique_ptr<PjRtClient>>()> Get() const {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return factory_;\n   }\n "
        },
        {
            "sha": "a5e830f2a158fc00ff014327d2455edaeac4afe4",
            "filename": "third_party/xla/xla/pjrt/pjrt_compiler.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_compiler.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -47,14 +47,14 @@ CompilerRegistry() {\n void PjRtRegisterCompiler(absl::string_view platform_name,\n                           std::unique_ptr<PjRtCompiler> compiler) {\n   CHECK(compiler != nullptr);\n-  absl::MutexLock l(&registry_mutex);\n+  absl::MutexLock l(registry_mutex);\n   auto* compiler_registry = CompilerRegistry();\n   CHECK(!compiler_registry->contains(platform_name));\n   (*compiler_registry)[platform_name] = std::move(compiler);\n }\n \n absl::StatusOr<PjRtCompiler*> GetPjRtCompiler(absl::string_view platform_name) {\n-  absl::ReaderMutexLock l(&registry_mutex);\n+  absl::ReaderMutexLock l(registry_mutex);\n   const auto* compiler_registry = CompilerRegistry();\n   auto it = compiler_registry->find(platform_name);\n   if (it == compiler_registry->end()) {\n@@ -72,7 +72,7 @@ absl::StatusOr<std::unique_ptr<PjRtExecutable>> PjRtCompile(\n     return (*topology_compiler)\n         ->Compile(std::move(options), computation, topology, client);\n   }\n-  absl::ReaderMutexLock l(&registry_mutex);\n+  absl::ReaderMutexLock l(registry_mutex);\n   const auto* compiler_registry = CompilerRegistry();\n   auto it = compiler_registry->find(topology.platform_name());\n   if (it == compiler_registry->end()) {\n@@ -90,7 +90,7 @@ absl::StatusOr<std::unique_ptr<PjRtExecutable>> PjRtCompile(\n     return (*topology_compiler)\n         ->Compile(std::move(options), module, topology, client);\n   }\n-  absl::ReaderMutexLock l(&registry_mutex);\n+  absl::ReaderMutexLock l(registry_mutex);\n   const auto* compiler_registry = CompilerRegistry();\n   auto it = compiler_registry->find(topology.platform_name());\n   if (it == compiler_registry->end()) {"
        },
        {
            "sha": "4c76380257f487a07364104910b3b4d1d0d7de80",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client_test.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -162,7 +162,7 @@ TEST(PjRtStreamExecutorClientTest, DonateWithControlDependency) {\n       ShapeUtil::DeviceShapeToHostShape(blocked_buffer->on_device_shape()));\n   bool got_literal = false;\n   blocked_buffer->ToLiteral(result_literal.get()).OnReady([&](absl::Status s) {\n-    absl::MutexLock l(&mu);\n+    absl::MutexLock l(mu);\n     TF_ASSERT_OK(s);\n     got_literal = true;\n   });\n@@ -174,7 +174,7 @@ TEST(PjRtStreamExecutorClientTest, DonateWithControlDependency) {\n   EXPECT_TRUE(future.IsReady());\n \n   {\n-    absl::MutexLock l(&mu);\n+    absl::MutexLock l(mu);\n     mu.Await(absl::Condition(&got_literal));\n   }\n "
        },
        {
            "sha": "7d0aacee98f345bc2af826b680b91a2a26afe035",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -319,7 +319,7 @@ void PjRtStreamExecutorRawBuffer::CopyToLiteralAsync(\n             options.permutation = permutation;\n             options.input_layout = TransposePlan::Striding{byte_strides};\n             {\n-              absl::MutexLock lock(&client->transpose_mu_);\n+              absl::MutexLock lock(client->transpose_mu_);\n               absl::StatusOr<std::shared_ptr<TransposePlan>> t =\n                   client->transpose_cache_.GetOrCreate(options);\n               if (!t.ok()) {"
        },
        {
            "sha": "7a86c6df0dc1a8ff55383ff4a962d7570e446308",
            "filename": "third_party/xla/xla/pjrt/semaphore.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fsemaphore.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fsemaphore.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fsemaphore.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -41,12 +41,12 @@ void Semaphore::Acquire(int64_t amount) {\n \n   mu_.LockWhen(absl::Condition(&CanAcquire, &args));\n   value_ -= amount;\n-  mu_.Unlock();\n+  mu_.unlock();\n }\n \n bool Semaphore::TryAcquire(int64_t amount) {\n   CHECK_GE(amount, 0);\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (value_ >= amount) {\n     value_ -= amount;\n     return true;\n@@ -56,7 +56,7 @@ bool Semaphore::TryAcquire(int64_t amount) {\n \n void Semaphore::Release(int64_t amount) {\n   CHECK_GE(amount, 0);\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   value_ += amount;\n }\n "
        },
        {
            "sha": "1013b3ff24d36fd9956dc3f1231c1fa4bdd3761a",
            "filename": "third_party/xla/xla/pjrt/tf_pjrt_client.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftf_pjrt_client.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -161,7 +161,7 @@ static int GetMutexId(\n void TfPjRtClient::TrackBuffer(TfPjRtBuffer* buffer) {\n   int mutex_id = GetMutexId(buffer, mutex_id_from_device_id_);\n   {\n-    absl::MutexLock lock(&alive_buffers_[mutex_id].mu);\n+    absl::MutexLock lock(alive_buffers_[mutex_id].mu);\n     alive_buffers_[mutex_id].alive_buffers.insert(buffer);\n   }\n }\n@@ -172,15 +172,15 @@ void TfPjRtClient::UntrackBuffer(const TfPjRtBuffer* buffer) {\n   }\n   int mutex_id = GetMutexId(buffer, mutex_id_from_device_id_);\n   {\n-    absl::MutexLock lock(&alive_buffers_[mutex_id].mu);\n+    absl::MutexLock lock(alive_buffers_[mutex_id].mu);\n     alive_buffers_[mutex_id].alive_buffers.erase(buffer);\n   }\n }\n \n void TfPjRtClient::DestroyWrappedBuffersAndClient() {\n   int num_mutexes = alive_buffers_.size();\n   for (int i = 0; i < num_mutexes; ++i) {\n-    absl::MutexLock lock(&alive_buffers_[i].mu);\n+    absl::MutexLock lock(alive_buffers_[i].mu);\n     for (auto* buffer : alive_buffers_[i].alive_buffers) {\n       buffer->DestroyWrappedBuffer();\n     }"
        },
        {
            "sha": "0154f8d84413cd9cca9082fd2a487bc70f40b426",
            "filename": "third_party/xla/xla/pjrt/worker_thread.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fworker_thread.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7c2de2a3df89aabbebabda17b004249ba88e5856/third_party%2Fxla%2Fxla%2Fpjrt%2Fworker_thread.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fworker_thread.cc?ref=7c2de2a3df89aabbebabda17b004249ba88e5856",
            "patch": "@@ -30,13 +30,13 @@ WorkerThread::WorkerThread(tsl::Env* env, const std::string& name) {\n }\n \n WorkerThread::~WorkerThread() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   work_queue_.push(nullptr);\n }\n \n void WorkerThread::Schedule(absl::AnyInvocable<void() &&> fn) {\n   CHECK(fn != nullptr);\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   work_queue_.push(std::move(fn));\n }\n \n@@ -46,7 +46,7 @@ void WorkerThread::WorkLoop() {\n   while (true) {\n     absl::AnyInvocable<void() &&> fn;\n     {\n-      absl::MutexLock lock(&mu_);\n+      absl::MutexLock lock(mu_);\n       mu_.Await(absl::Condition(this, &WorkerThread::WorkAvailable));\n       fn = std::move(work_queue_.front());\n       work_queue_.pop();"
        }
    ],
    "stats": {
        "total": 86,
        "additions": 43,
        "deletions": 43
    }
}