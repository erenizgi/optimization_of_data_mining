{
    "author": "thcmbs",
    "message": "[XLA] Extend reshape-transpose chain removal to include bitcasts.\n\n+ Allow the chain to start from <transpose, reshape, bitcast> instead of only reshape\n+ Add a layout sensitive mode to the simplification\n\nPiperOrigin-RevId: 846150097",
    "sha": "2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b",
    "files": [
        {
            "sha": "85d50f4c030665f69433a72ac5fe75eb4f6ed31e",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD?ref=2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b",
            "patch": "@@ -405,6 +405,7 @@ cc_library(\n         \"//xla/service:pattern_matcher\",\n         \"//xla/service:shape_inference\",\n         \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:status_macros\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:nullability\","
        },
        {
            "sha": "53d73d88643a5e230b98d7773684aa47088da421",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.cc",
            "status": "modified",
            "additions": 87,
            "deletions": 26,
            "changes": 113,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc?ref=2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b",
            "patch": "@@ -74,6 +74,7 @@ limitations under the License.\n #include \"xla/util.h\"\n #include \"xla/window_util.h\"\n #include \"xla/xla_data.pb.h\"\n+#include \"xla/tsl/platform/status_macros.h\"\n \n namespace xla {\n \n@@ -1300,6 +1301,7 @@ absl::Status AlgebraicSimplifierVisitor::HandleBitcast(\n     VLOG(3) << bitcast->ToString() << \" has control predecessors, skipping.\";\n     return absl::OkStatus();\n   }\n+\n   // If a bitcast feeds a bitcast, make it a single bitcast.\n   // Make sure the whole chain of bitcasts is optimized.\n   if (bitcast->operand(0)->opcode() == HloOpcode::kBitcast) {\n@@ -1325,6 +1327,12 @@ absl::Status AlgebraicSimplifierVisitor::HandleBitcast(\n     bitcast = new_bitcast;\n   }\n \n+  ASSIGN_OR_RETURN(bool transpose_chain_removed,\n+                   TryRemovingBitcastOrReshapeTransposeChain(bitcast));\n+  if (transpose_chain_removed) {\n+    return absl::OkStatus();\n+  }\n+\n   // Check whether we can potentially simplify the bitcast into a broadcast\n   // operand.\n   if (bitcast->opcode() == HloOpcode::kBitcast &&\n@@ -6138,12 +6146,12 @@ absl::Status AlgebraicSimplifierVisitor::HandleRemainder(\n }\n \n absl::StatusOr<bool>\n-AlgebraicSimplifierVisitor::TryRemovingReshapeTransposeChain(\n-    HloInstruction* reshape) {\n-  // Detect a chain of transposes and reshapes that can be replaced with a\n-  // nop. All reshapes only add, remove or shuffle degenerate dimensions, such\n-  // as [x,y,z]->[x,y,1,z] or its reverse, [x,y,1,z]->[x,1,y,z], etc. And all\n-  // the shapes in the chain have at most one degenerate dimension. Then all\n+AlgebraicSimplifierVisitor::TryRemovingBitcastOrReshapeTransposeChain(\n+    HloInstruction* instruction) {\n+  // Detect a chain of transposes and reshapes/bitcasts that can be replaced\n+  // with a nop. All reshapes only add, remove or shuffle degenerate dimensions,\n+  // such as [x,y,z]->[x,y,1,z] or its reverse, [x,y,1,z]->[x,1,y,z], etc. And\n+  // all the shapes in the chain have at most one degenerate dimension. Then all\n   // the transposes in the chain effectively permute x,y,z, while the\n   // degenerate dimension is ignored. As long as all transposes compose to\n   // identity permutation, the chain can be replaced with a nop if the\n@@ -6157,12 +6165,19 @@ AlgebraicSimplifierVisitor::TryRemovingReshapeTransposeChain(\n                            });\n   };\n \n-  auto is_valid_reshape = [&](const HloInstruction* reshape) {\n-    CHECK(reshape->opcode() == HloOpcode::kReshape);\n-    return get_num_of_degenerate_dimensions(reshape->shape()) <= 1 &&\n-           get_num_of_degenerate_dimensions(reshape->operand(0)->shape()) <=\n-               1 &&\n-           reshape->ReshapeMerelyInsertsOrDeletes1SizedDimensions();\n+  auto is_valid_reshape_or_bitcast = [&](const HloInstruction* inst) {\n+    if (inst->opcode() != HloOpcode::kReshape &&\n+        inst->opcode() != HloOpcode::kBitcast) {\n+      return false;\n+    }\n+    if (inst->opcode() == HloOpcode::kBitcast &&\n+        !options_.ReshapeIsBitcast(inst->operand(0)->shape(), inst->shape())) {\n+      return false;\n+    }\n+    return get_num_of_degenerate_dimensions(inst->shape()) <= 1 &&\n+           get_num_of_degenerate_dimensions(inst->operand(0)->shape()) <= 1 &&\n+           ShapeUtil::InsertedOrDeleted1SizedDimensions(\n+               inst->operand(0)->shape(), inst->shape());\n   };\n \n   auto get_degenerate_dimension = [](const Shape& shape) {\n@@ -6204,19 +6219,34 @@ AlgebraicSimplifierVisitor::TryRemovingReshapeTransposeChain(\n     return DimensionVector(permutation.begin(), permutation.end());\n   };\n \n-  if (!options_.is_layout_sensitive() && is_valid_reshape(reshape)) {\n-    int64_t effective_size = ShapeUtil::TrueNumDimensions(reshape->shape());\n+  bool is_valid_start = false;\n+  if (instruction->opcode() == HloOpcode::kTranspose) {\n+    is_valid_start = !IsIdentityPermutation(instruction->dimensions());\n+  } else {\n+    is_valid_start = is_valid_reshape_or_bitcast(instruction);\n+  }\n+\n+  if (is_valid_start) {\n+    int64_t effective_size = ShapeUtil::TrueNumDimensions(instruction->shape());\n     std::vector<int64_t> permutation(effective_size);\n     // Init with identity permutation.\n     std::iota(permutation.begin(), permutation.end(), 0);\n \n+    if (instruction->opcode() == HloOpcode::kTranspose) {\n+      auto effective_perm = get_effective_permutation(\n+          instruction->dimensions(), instruction->operand(0)->shape(),\n+          instruction->shape());\n+      permutation.assign(effective_perm.begin(), effective_perm.end());\n+    }\n+\n     bool is_nop = true;\n     HloInstruction* starting_instruction = nullptr;\n-    HloInstruction* current = reshape->mutable_operand(0);\n+    HloInstruction* current = instruction->mutable_operand(0);\n     while (current->opcode() == HloOpcode::kReshape ||\n-           current->opcode() == HloOpcode::kTranspose) {\n-      if (current->opcode() == HloOpcode::kReshape &&\n-          !is_valid_reshape(current)) {\n+           current->opcode() == HloOpcode::kTranspose ||\n+           current->opcode() == HloOpcode::kBitcast) {\n+      if (current->opcode() != HloOpcode::kTranspose &&\n+          !is_valid_reshape_or_bitcast(current)) {\n         is_nop = false;\n         break;\n       }\n@@ -6238,13 +6268,38 @@ AlgebraicSimplifierVisitor::TryRemovingReshapeTransposeChain(\n     }\n \n     if (is_nop && starting_instruction != nullptr &&\n-        Shape::Equal().IgnoreLayout()(\n-            reshape->shape(), starting_instruction->operand(0)->shape()) &&\n         IsIdentityPermutation(permutation)) {\n-      VLOG(2) << \"Deleting reshape-transpose chain: \" << reshape->ToString();\n-      TF_RETURN_IF_ERROR(ReplaceInstruction(\n-          reshape, starting_instruction->mutable_operand(0)));\n-      return true;\n+      HloInstruction* new_operand = starting_instruction->mutable_operand(0);\n+      bool replace_success = false;\n+      if (options_.is_layout_sensitive()) {\n+        if (ShapeUtil::Equal(instruction->shape(), new_operand->shape())) {\n+          RETURN_IF_ERROR(ReplaceInstruction(instruction, new_operand));\n+          replace_success = true;\n+        } else if (options_.ReshapeIsBitcast(new_operand->shape(),\n+                                             instruction->shape())) {\n+          // If ReshapeIsBitcast is true, the shapes are guaranteed to have the\n+          // same in-memory representation, including padding and tiling\n+          // effects. Therefore, their byte sizes must be equal.\n+          DCHECK_EQ(ShapeUtil::ByteSizeOf(new_operand->shape()),\n+                    ShapeUtil::ByteSizeOf(instruction->shape()))\n+              << \"ReshapeIsBitcast is true, but byte sizes differ.\";\n+          RETURN_IF_ERROR(ReplaceWithNewInstruction(\n+              instruction, HloInstruction::CreateBitcast(instruction->shape(),\n+                                                         new_operand)));\n+          replace_success = true;\n+        }\n+      } else {  // Non-layout sensitive.\n+        if (Shape::Equal().IgnoreLayout()(instruction->shape(),\n+                                          new_operand->shape())) {\n+          RETURN_IF_ERROR(ReplaceInstruction(instruction, new_operand));\n+          replace_success = true;\n+        }\n+      }\n+      if (replace_success) {\n+        VLOG(2) << \"Deleting bitcast-or-reshape-transpose chain: \"\n+                << instruction->ToString();\n+        return true;\n+      }\n     }\n   }\n   return false;\n@@ -6287,8 +6342,8 @@ absl::Status AlgebraicSimplifierVisitor::HandleReshape(\n     return ReplaceInstruction(reshape, operand);\n   }\n \n-  TF_ASSIGN_OR_RETURN(bool reshape_transpose_chain_removed,\n-                      TryRemovingReshapeTransposeChain(reshape));\n+  ASSIGN_OR_RETURN(bool reshape_transpose_chain_removed,\n+                   TryRemovingBitcastOrReshapeTransposeChain(reshape));\n   if (reshape_transpose_chain_removed) {\n     return absl::OkStatus();\n   }\n@@ -9058,6 +9113,12 @@ absl::Status AlgebraicSimplifierVisitor::HandleTranspose(\n                                            transpose->dimensions())));\n   }\n \n+  ASSIGN_OR_RETURN(bool chain_removed,\n+                   TryRemovingBitcastOrReshapeTransposeChain(transpose));\n+  if (chain_removed) {\n+    return absl::OkStatus();\n+  }\n+\n   const auto consider_swapping_dot_operands = [&](HloInstruction* dot) {\n     // If the RHS is a parameter-like, and the LHS is not, do not swap the\n     // operands, since the dot operands are in a convenient order for layout"
        },
        {
            "sha": "878487131013433fb3c528f742cffc9e9752fe9d",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.h?ref=2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b",
            "patch": "@@ -855,10 +855,10 @@ class AlgebraicSimplifierVisitor : public DfsHloRewriteVisitor {\n                                         bool multi_output_reduce,\n                                         HloReduceInstruction* reduce);\n \n-  // Detects a chain of transposes and reshapes that can be replaced with a\n-  // nop.\n-  absl::StatusOr<bool> TryRemovingReshapeTransposeChain(\n-      HloInstruction* reshape);\n+  // Detects a chain of transposes and reshapes (or bitcasts) that can be\n+  // replaced with a nop.\n+  absl::StatusOr<bool> TryRemovingBitcastOrReshapeTransposeChain(\n+      HloInstruction* instruction);\n \n   // Helper function for HandleReduce. Reorders reduce dot\n   // to a dot reduce. reduce(dot(A, B)) to dot(A, reduce(B))"
        },
        {
            "sha": "377ec2c76a81f87781abdf24068b9694f0aa428a",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier_test.cc",
            "status": "modified",
            "additions": 107,
            "deletions": 1,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc?ref=2df2c4fac75e6792b3f304d1a6ec7e9a23e3c25b",
            "patch": "@@ -338,13 +338,91 @@ TEST_F(AlgebraicSimplifierTest, EliminateReshapeTransposeChain) {\n   ROOT %reshape.96336 = f32[224,4,1,4096] reshape(%transpose.8665)\n     }\n   )\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n   AlgebraicSimplifier(default_options_).Run(m.get()).value();\n   VLOG(2) << \"Module after: \" << m->ToString();\n   EXPECT_THAT(m->entry_computation()->root_instruction(),\n               GmockMatch(m::Parameter(0)));\n }\n \n+TEST_F(AlgebraicSimplifierTest, EliminateBitcastTransposeChain) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+    HloModule m\n+    test {\n+      param = f32[10, 20] parameter(0)\n+      transpose = f32[20, 10] transpose(param), dimensions={1, 0}\n+      bitcast = f32[1, 20, 10] reshape(transpose)\n+      transpose2 = f32[1, 10, 20] transpose(bitcast), dimensions={0, 2, 1}\n+      ROOT bitcast2 = f32[10, 20] reshape(transpose2)\n+    }\n+  )\";\n+  ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  AlgebraicSimplifierOptions options = default_options_;\n+  options.set_is_layout_sensitive(false);\n+  AlgebraicSimplifier simplifier(options);\n+  ASSERT_TRUE(simplifier.Run(m.get()).value());\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              GmockMatch(m::Parameter(0)));\n+}\n+\n+TEST_F(AlgebraicSimplifierTest, EliminateBitcastTransposeChain_DifferentTypes) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+    HloModule m\n+    test {\n+      param = f32[10, 20] parameter(0)\n+      transpose = f32[20, 10] transpose(param), dimensions={1, 0}\n+      bitcast = s32[1, 20, 10] bitcast(transpose)\n+      transpose2 = s32[1, 10, 20] transpose(bitcast), dimensions={0, 2, 1}\n+      ROOT bitcast2 = f32[10, 20] bitcast(transpose2)\n+    }\n+  )\";\n+  ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  AlgebraicSimplifierOptions options = default_options_;\n+  options.set_is_layout_sensitive(false);\n+  AlgebraicSimplifier simplifier(options);\n+  ASSERT_FALSE(simplifier.Run(m.get()).value());\n+}\n+\n+TEST_F(AlgebraicSimplifierTest, BitcastTransposeChainReshapeIsBitcast) {\n+  const std::string hlo_string = R\"(\n+    HloModule m\n+    ENTRY test {\n+      p0 = bf16[512,16,3072]{2,1,0} parameter(0)\n+      transpose.3 = bf16[512,3072,16]{2,1,0} transpose(p0), dimensions={0,2,1}\n+      bitcast = bf16[1,512,3072,16]{3,2,1,0} bitcast(transpose.3)\n+      transpose.2 = bf16[1,512,16,3072]{3,2,1,0} transpose(bitcast), dimensions={0,1,3,2}\n+      ROOT bitcast.1 = bf16[8192,3072]{1,0} bitcast(transpose.2)\n+    }\n+  )\";\n+  ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(hlo_string));\n+  AlgebraicSimplifierOptions options = default_options_;\n+  options.set_is_layout_sensitive(true);\n+  AlgebraicSimplifier simplifier(options);\n+  ASSERT_TRUE(simplifier.Run(m.get()).value());\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              GmockMatch(m::Bitcast(m::Parameter(0))));\n+}\n+\n+TEST_F(AlgebraicSimplifierTest, LayoutSensitive_EqualShapes_StartTranspose) {\n+  const std::string hlo_string = R\"(\n+    HloModule m\n+    ENTRY test {\n+      p0 = f32[2,3]{1,0} parameter(0)\n+      t1 = f32[3,2]{1,0} transpose(p0), dimensions={1,0}\n+      b1 = f32[1,3,2]{2,1,0} bitcast(t1)\n+      t2 = f32[1,2,3]{2,1,0} transpose(b1), dimensions={0,2,1}\n+      ROOT b2 = f32[2,3]{1,0} bitcast(t2)\n+    }\n+  )\";\n+  ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(hlo_string));\n+  AlgebraicSimplifierOptions options = default_options_;\n+  options.set_is_layout_sensitive(true);\n+  AlgebraicSimplifier simplifier(options);\n+  ASSERT_TRUE(simplifier.Run(m.get()).value());\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              GmockMatch(m::Parameter(0)));\n+}\n+\n // Reshape-transpose chain is not eliminated since effective transposes\n // do not compose to identity permutation.\n TEST_F(AlgebraicSimplifierTest, NotEliminateReshapeTransposeChain) {\n@@ -13090,5 +13168,33 @@ TEST_F(AlgebraicSimplifierTest, ConditionalWithConvert) {\n                   )));\n }\n \n+TEST_F(AlgebraicSimplifierTest,\n+       BitcastTransposeChain_InvalidBitcastLayoutChange) {\n+  // This test ensures that a bitcast which effectively acts as a transpose (due\n+  // to layout change) prevents the removal of the transpose chain.\n+  //\n+  // Buggy behavior: Simplifier sees Transpose(1,0) ... Transpose(1,0), thinks\n+  // they cancel out, ignores the Bitcast's layout effect, and simplifies to p0.\n+  const std::string hlo_string = R\"(\n+    HloModule m\n+    ENTRY test {\n+      p0 = f32[10,10]{0,1} parameter(0)\n+      t1 = f32[10,10]{0,1} transpose(p0), dimensions={1,0}\n+      b1 = f32[10,10]{1,0} bitcast(t1)\n+      ROOT t2 = f32[10,10]{0,1} transpose(b1), dimensions={1,0}\n+    }\n+  )\";\n+  ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(hlo_string));\n+\n+  AlgebraicSimplifierOptions options = default_options_;\n+  options.set_is_layout_sensitive(true);\n+  AlgebraicSimplifier simplifier(options);\n+  simplifier.Run(m.get()).value();\n+\n+  // Ensure it didn't incorrectly simplify to the parameter.\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              Not(GmockMatch(m::Parameter(0))));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 230,
        "additions": 199,
        "deletions": 31
    }
}