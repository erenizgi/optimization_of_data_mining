{
    "author": "ezhulenev",
    "message": "[xla:gpu] Document CommandBufferCmd statelessness and StateManager\n\nPiperOrigin-RevId: 842088918",
    "sha": "419991f7da1549cadeecb5a1ee3166075fb57726",
    "files": [
        {
            "sha": "31dc41b43596d031a724b8a859c38dd0f6e9b794",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_cmd.h",
            "status": "modified",
            "additions": 39,
            "deletions": 3,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/419991f7da1549cadeecb5a1ee3166075fb57726/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/419991f7da1549cadeecb5a1ee3166075fb57726/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h?ref=419991f7da1549cadeecb5a1ee3166075fb57726",
            "patch": "@@ -118,6 +118,8 @@ std::string CommandBufferCmdString(CommandBufferCmdType type);\n // CommandBufferCmd\n //===----------------------------------------------------------------------===//\n \n+using ResourceUseVector = absl::InlinedVector<ResourceUse, 1>;\n+\n // Command is a Thunk counterpart that instead of launching operations directly\n // on the underlying device records them into command buffers.\n //\n@@ -127,9 +129,41 @@ std::string CommandBufferCmdString(CommandBufferCmdType type);\n //\n // Commands must be thread safe as they can be recorded into multiple command\n // buffers concurrently on different stream executors.\n-\n-using ResourceUseVector = absl::InlinedVector<ResourceUse, 1>;\n-\n+//\n+// IMPORTANT: In contrast to GPU thunks, commands MUST be stateless. Thunk state\n+// typically belongs to the Thunk instance itself, and tends to be kept in\n+// synchronized hash maps keyed by `se::StreamExecutor*` pointer. Commands on\n+// the other hand should attach state to the underlying command buffer, and\n+// because the number of command buffers that can be instantiated from a command\n+// sequence is unbounded (as we have an eviction policy for command buffers),\n+// keeping a state in a map inside the command will lead to memory leaks.\n+//\n+// Commands have an external state manager, which is responsible for managing\n+// the lifetime of command state. See `State` and `StateManager` classes below.\n+//\n+// To make command stateful, it needs a `params.state` indirection:\n+//\n+//   class MyCommand : public CommandBufferCmd {\n+//     public:\n+//\n+//     // Container for mutable state required for command execution.\n+//     struct MyState : CommandBufferCmd::State {\n+//       ...\n+//     };\n+//\n+//     absl::StatusOr<Command*> Record(...) override {\n+//       // Attach a new instance of `MyState` to the `command_buffer`. When\n+//       // command buffer will be destroyed, the state will be destroyed as\n+//       // well automatically by XLA runtime. If this command will be recorded\n+//       // into another command buffer, the state will be re-created\n+//       // automatically using the provided callback.\n+//       MyState* my_state = record_params.state.GetOrCreate<MyState>(this,\n+//         command_buffer, [&] { // create MyState for a `command_buffer` });\n+//       ...\n+//     }\n+//\n+//   };\n+//\n class CommandBufferCmd {\n  public:\n   explicit CommandBufferCmd(\n@@ -156,6 +190,8 @@ class CommandBufferCmd {\n   // Externally managed state (owned and synchronized by CommandBufferThunk)\n   // allows commands to attach a piece of information to command buffer in a\n   // safe and performant way.\n+  //\n+  // See example above next to `CommandBufferCmd` definition.\n   class State {\n    public:\n     virtual ~State() = default;"
        }
    ],
    "stats": {
        "total": 42,
        "additions": 39,
        "deletions": 3
    }
}