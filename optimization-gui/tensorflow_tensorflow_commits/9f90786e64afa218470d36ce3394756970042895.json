{
    "author": "ezhulenev",
    "message": "[stream_executor] Make sure that DeviceAddress behaves like a pointer wrt comparison to nullptr_t and casting to bool\n\nPiperOrigin-RevId: 842292205",
    "sha": "9f90786e64afa218470d36ce3394756970042895",
    "files": [
        {
            "sha": "5c1481cc227da1d9b6a243a02586bb22bbe62cd1",
            "filename": "third_party/xla/xla/stream_executor/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f90786e64afa218470d36ce3394756970042895/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f90786e64afa218470d36ce3394756970042895/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD?ref=9f90786e64afa218470d36ce3394756970042895",
            "patch": "@@ -82,6 +82,15 @@ cc_library(\n     ],\n )\n \n+xla_cc_test(\n+    name = \"device_address_test\",\n+    srcs = [\"device_address_test.cc\"],\n+    deps = [\n+        \":device_address\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"device_address_handle\",\n     srcs = [\"device_address_handle.cc\"],"
        },
        {
            "sha": "9884ade4430b7d0a8607e81f3599ae19539e0b02",
            "filename": "third_party/xla/xla/stream_executor/device_address.h",
            "status": "modified",
            "additions": 25,
            "deletions": 25,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f90786e64afa218470d36ce3394756970042895/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_address.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f90786e64afa218470d36ce3394756970042895/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_address.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_address.h?ref=9f90786e64afa218470d36ce3394756970042895",
            "patch": "@@ -41,7 +41,7 @@ namespace stream_executor {\n // check for `opaque` being null to determine if the device address is null.\n class DeviceAddressBase {\n  public:\n-  // Default constructor instantiates a null-pointed, zero-sized device memory\n+  // Default constructor instantiates a null-pointed, zero-sized device address\n   // region. An opaque pointer may be provided -- see header for details on the\n   // opacity of that pointer.\n   explicit DeviceAddressBase(void* opaque = nullptr, uint64_t size = 0)\n@@ -53,33 +53,35 @@ class DeviceAddressBase {\n     //  explicit DeviceAddressBase(void *opaque) = delete;\n   }\n \n-  // Returns whether the backing memory is the null pointer.\n+  // Returns whether the backing address is the null pointer.\n   // A `== nullptr` convenience method is also provided.\n   bool is_null() const { return opaque_ == nullptr; }\n \n+  explicit operator bool() const { return !is_null(); }\n+\n   bool operator==(std::nullptr_t other) const { return is_null(); }\n   bool operator!=(std::nullptr_t other) const { return !is_null(); }\n \n   bool operator==(const DeviceAddressBase& other) const {\n     return opaque_ == other.opaque_ && size_ == other.size_;\n   }\n \n-  // Provides a partial order between device memory values.\n+  // Provides a partial order between device address values.\n   //\n   // This operator is provided so that this object can be used as a key in an\n   // ordered map.\n   bool operator<(const DeviceAddressBase& other) const {\n     return std::tie(opaque_, size_) < std::tie(other.opaque_, other.size_);\n   }\n \n-  // Returns the size, in bytes, for the backing memory.\n+  // Returns the size, in bytes, for the backing address range.\n   uint64_t size() const { return size_; }\n \n   // Warning: note that the pointer returned is not necessarily directly to\n   // device virtual address space, but is platform-dependent.\n   void* opaque() const { return opaque_; }\n \n-  // Returns the payload of this memory region.\n+  // Returns the payload of this address range.\n   uint64_t payload() const { return payload_; }\n \n   // Sets payload to given value.\n@@ -91,60 +93,58 @@ class DeviceAddressBase {\n     return opaque() == other.opaque() && size() == other.size();\n   }\n \n-  // Creates a memory region (slice) inside another allocated memory region.\n-  // Offset and size are in bytes.\n+  // Creates and address range slice at the given offset and size. Offset and\n+  // size are in bytes.\n   ABSL_ATTRIBUTE_ALWAYS_INLINE DeviceAddressBase\n   GetByteSlice(uint64_t offset_bytes, uint64_t size_bytes) const {\n     DCHECK(offset_bytes + size_bytes <= size_)\n-        << \"requested slice allocation (offset + size) is greater \"\n-        << \"than parent allocation size: (\" << offset_bytes << \" + \"\n-        << size_bytes << \") vs. (\" << size_ << \")\";\n+        << \"requested address slice (offset + size) is out of bounds \"\n+        << \"of parent address: (\" << offset_bytes << \" + \" << size_bytes\n+        << \") vs. (\" << size_ << \")\";\n \n     return DeviceAddressBase(\n         reinterpret_cast<std::byte*>(opaque_) + offset_bytes, size_bytes);\n   }\n \n  private:\n-  void* opaque_;   // Platform-dependent value representing addressable memory.\n-  uint64_t size_;  // Size in bytes of this allocation.\n-  uint64_t payload_ = 0;  // Payload data associated with this allocation.\n+  void* opaque_;          // Platform-dependent value representing base address.\n+  uint64_t size_;         // Size in bytes of this address range.\n+  uint64_t payload_ = 0;  // Payload data associated with this address.\n };\n \n // Typed wrapper around \"void *\"-like DeviceAddressBase.\n //\n // For example, DeviceAddress<int32_t> is a simple wrapper around\n-// DeviceAddressBase that represents one or more integers in Device memory.\n+// DeviceAddressBase that represents one or more integers on Device.\n template <typename T>\n class DeviceAddress final : public DeviceAddressBase {\n  public:\n-  // Default constructor instantiates a null-pointed, zero-sized memory region.\n+  // Default constructor instantiates a null-pointed, zero-sized addess range.\n   DeviceAddress() : DeviceAddressBase(nullptr, 0) {}\n   explicit DeviceAddress(std::nullptr_t) : DeviceAddress() {}\n \n-  // Typed device memory regions may be constructed from untyped device memory\n-  // regions, this effectively amounts to a cast from a void*.\n+  // Typed device address range may be constructed from untyped device address\n+  // range, this effectively amounts to a cast from a void*.\n   explicit DeviceAddress(const DeviceAddressBase& other)\n-      : DeviceAddressBase(const_cast<DeviceAddressBase&>(other).opaque(),\n-                          other.size()) {\n+      : DeviceAddressBase(other.opaque(), other.size()) {\n     SetPayload(other.payload());\n   }\n \n-  // Returns the number of elements of type T that constitute this\n-  // allocation.\n+  // Returns the number of elements of type T that constitute this address.\n   uint64_t ElementCount() const { return size() / sizeof(T); }\n \n-  // Returns pointer to the allocated data\n+  // Returns a base pointer to the data.\n   T* base() const { return reinterpret_cast<T*>(opaque()); }\n \n   // Creates a typed area of DeviceAddress with a given opaque pointer and the\n-  // quantity of bytes in the allocation. This function is broken out to\n+  // quantity of bytes in the address range. This function is broken out to\n   // distinguish bytes from an element count.\n   static DeviceAddress<T> MakeFromByteSize(void* opaque, uint64_t bytes) {\n     return DeviceAddress<T>(opaque, bytes);\n   }\n \n-  // Creates a memory region (slice) inside another allocated memory region.\n-  // Offset and size are specified in terms of T elements.\n+  // Creates and address range slice at the given offset and count. Offset and\n+  // count are specified in terms of T elements.\n   DeviceAddress<T> GetSlice(uint64_t element_offset, uint64_t element_count) {\n     return DeviceAddress<T>(\n         GetByteSlice(sizeof(T) * element_offset, sizeof(T) * element_count));"
        },
        {
            "sha": "71acd21672215e1afe2e5b74a810dba1f6853f8b",
            "filename": "third_party/xla/xla/stream_executor/device_address_test.cc",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f90786e64afa218470d36ce3394756970042895/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_address_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f90786e64afa218470d36ce3394756970042895/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_address_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_address_test.cc?ref=9f90786e64afa218470d36ce3394756970042895",
            "patch": "@@ -0,0 +1,40 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/device_address.h\"\n+\n+#include <cstdint>\n+\n+#include <gtest/gtest.h>\n+\n+namespace stream_executor {\n+namespace {\n+\n+TEST(DeviceAddressTest, NullptrComparisons) {\n+  {\n+    DeviceAddressBase null_ptr;\n+    EXPECT_FALSE(null_ptr);\n+    EXPECT_TRUE(null_ptr == nullptr);\n+  }\n+\n+  {\n+    DeviceAddress<int32_t> null_ptr;\n+    EXPECT_FALSE(null_ptr);\n+    EXPECT_TRUE(null_ptr == nullptr);\n+  }\n+}\n+\n+}  // namespace\n+}  // namespace stream_executor"
        }
    ],
    "stats": {
        "total": 99,
        "additions": 74,
        "deletions": 25
    }
}