{
    "author": "SiqiaoWu1993",
    "message": "Internal change only\n\nPiperOrigin-RevId: 835402919",
    "sha": "fb6ccccc7893fc17466eab401e06c378e07e3a0a",
    "files": [
        {
            "sha": "9d0efd51791b87c0e07705283f9e5f063f3f4e51",
            "filename": "tensorflow/compiler/mlir/tfrt/transforms/ifrt/ifrt_types.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcompiler%2Fmlir%2Ftfrt%2Ftransforms%2Fifrt%2Fifrt_types.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcompiler%2Fmlir%2Ftfrt%2Ftransforms%2Fifrt%2Fifrt_types.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Ftfrt%2Ftransforms%2Fifrt%2Fifrt_types.h?ref=fb6ccccc7893fc17466eab401e06c378e07e3a0a",
            "patch": "@@ -25,6 +25,10 @@ namespace ifrt_serving {\n struct DtypeAndShape {\n   tensorflow::DataType dtype;\n   tensorflow::TensorShape shape;\n+\n+  bool operator==(const DtypeAndShape& other) const {\n+    return dtype == other.dtype && shape == other.shape;\n+  }\n };\n \n }  // namespace ifrt_serving"
        },
        {
            "sha": "879a5667a3486b052ed0ffae8475f363540dadbc",
            "filename": "tensorflow/core/tfrt/ifrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcore%2Ftfrt%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcore%2Ftfrt%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fifrt%2FBUILD?ref=fb6ccccc7893fc17466eab401e06c378e07e3a0a",
            "patch": "@@ -467,6 +467,7 @@ tf_cc_test(\n         \"//tensorflow/core/framework:tensor\",\n         \"//tensorflow/core/framework:tensor_testutil\",\n         \"//tensorflow/core/framework:types_proto_cc\",\n+        \"@com_google_absl//absl/base:log_severity\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_googletest//:gtest_main\","
        },
        {
            "sha": "e626f64f808f9143782a93964706299bc4a2d48b",
            "filename": "tensorflow/core/tfrt/ifrt/ifrt_restore_tensor_registry.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcore%2Ftfrt%2Fifrt%2Fifrt_restore_tensor_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcore%2Ftfrt%2Fifrt%2Fifrt_restore_tensor_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fifrt%2Fifrt_restore_tensor_registry.cc?ref=fb6ccccc7893fc17466eab401e06c378e07e3a0a",
            "patch": "@@ -36,8 +36,20 @@ absl::Status IfrtRestoreTensorRegistry::TryRegister(\n   absl::MutexLock lock(mutex_);\n   auto& info = restored_tensors_[name];\n   if (info.tensor_future.IsValid()) {\n-    return absl::AlreadyExistsError(\n-        absl::StrCat(\"Variable '\", name, \"' already registered.\"));\n+    if (info.dtype_and_shape != restored_tensor_info.dtype_and_shape) {\n+      return absl::InvalidArgumentError(absl::StrCat(\n+          \"Variable '\", name, \"' already registered with dtype \",\n+          info.dtype_and_shape.dtype, \" and shape \",\n+          info.dtype_and_shape.shape.DebugString(),\n+          \" but trying to register with dtype \",\n+          restored_tensor_info.dtype_and_shape.dtype, \" and shape \",\n+          restored_tensor_info.dtype_and_shape.shape.DebugString()));\n+    }\n+    LOG(WARNING)\n+        << \"Variable named '\" << name\n+        << \"' has been already registered. Ignore request of a new tensor with \"\n+           \"same name, dtype and shape.\";\n+    return absl::OkStatus();\n   }\n   info = std::move(restored_tensor_info);\n   return absl::OkStatus();"
        },
        {
            "sha": "b5aa63e4ec753c03eb1ec4e01bb203343f3be597",
            "filename": "tensorflow/core/tfrt/ifrt/ifrt_restore_tensor_registry_test.cc",
            "status": "modified",
            "additions": 65,
            "deletions": 2,
            "changes": 67,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcore%2Ftfrt%2Fifrt%2Fifrt_restore_tensor_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fb6ccccc7893fc17466eab401e06c378e07e3a0a/tensorflow%2Fcore%2Ftfrt%2Fifrt%2Fifrt_restore_tensor_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fifrt%2Fifrt_restore_tensor_registry_test.cc?ref=fb6ccccc7893fc17466eab401e06c378e07e3a0a",
            "patch": "@@ -18,6 +18,8 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"testing/base/public/mock-log.h\"\n+#include \"absl/base/log_severity.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"tensorflow/compiler/mlir/tfrt/transforms/ifrt/ifrt_types.h\"\n@@ -34,6 +36,12 @@ namespace tensorflow {\n namespace ifrt_serving {\n namespace {\n \n+using ::testing::_;\n+using ::testing::AnyNumber;\n+using ::testing::HasSubstr;\n+using ::testing::kDoNotCaptureLogsYet;\n+using ::testing::ScopedMockLog;\n+\n TEST(IfrtRestoreTensorRegistryTest, RetrieveNonRegisteredTensorFails) {\n   IfrtRestoreTensorRegistry registry;\n   EXPECT_THAT(registry.GetRestoredTensor(\"input_tensor_1\").Await(),\n@@ -53,7 +61,52 @@ TEST(IfrtRestoreTensorRegistryTest, SetNonExistedTensorAsUsedByHostFails) {\n               absl_testing::StatusIs(absl::StatusCode::kNotFound));\n }\n \n-TEST(IfrtRestoreTensorRegistryTest, RegisteredExistedTensorFails) {\n+TEST(IfrtRestoreTensorRegistryTest,\n+     RegisteredExistedTensorwithDifferentDtypeAndShapeFails) {\n+  auto input_tensor =\n+      test::AsTensor<int32_t>({1, 2, 3, 4}, tensorflow::TensorShape({2, 2}));\n+  auto [promise, future] = tsl::Future<tensorflow::Tensor>::MakePromise();\n+\n+  IfrtRestoreTensorRegistry::RestoredTensorInfo restored_tensor_info = {\n+      .used_by_host = false,\n+      .dtype_and_shape =\n+          {\n+              .dtype = DT_INT32,\n+              .shape = tensorflow::TensorShape({2, 2}),\n+          },\n+      .tensor_future = future};\n+  IfrtRestoreTensorRegistry registry;\n+  EXPECT_THAT(registry.TryRegister(\"input_tensor_2\", restored_tensor_info),\n+              absl_testing::IsOk());\n+  promise.Set(input_tensor);\n+  IfrtRestoreTensorRegistry::RestoredTensorInfo\n+      restored_tensor_info_with_different_dtype = {\n+          .used_by_host = false,\n+          .dtype_and_shape =\n+              {\n+                  .dtype = DT_INT64,\n+                  .shape = tensorflow::TensorShape({2, 2}),\n+              },\n+          .tensor_future = future};\n+  EXPECT_THAT(registry.TryRegister(\"input_tensor_2\",\n+                                   restored_tensor_info_with_different_dtype),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+  IfrtRestoreTensorRegistry::RestoredTensorInfo\n+      restored_tensor_info_with_different_shape = {\n+          .used_by_host = false,\n+          .dtype_and_shape =\n+              {\n+                  .dtype = DT_INT32,\n+                  .shape = tensorflow::TensorShape({2, 3}),\n+              },\n+          .tensor_future = future};\n+  EXPECT_THAT(registry.TryRegister(\"input_tensor_2\",\n+                                   restored_tensor_info_with_different_shape),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n+TEST(IfrtRestoreTensorRegistryTest,\n+     RegisteredExistedTensorWithSameDtypeAndShapeSucceedsAndWarningIsLogged) {\n   auto input_tensor =\n       test::AsTensor<int32_t>({1, 2, 3, 4}, tensorflow::TensorShape({2, 2}));\n   auto [promise, future] = tsl::Future<tensorflow::Tensor>::MakePromise();\n@@ -70,8 +123,18 @@ TEST(IfrtRestoreTensorRegistryTest, RegisteredExistedTensorFails) {\n   EXPECT_THAT(registry.TryRegister(\"input_tensor_2\", restored_tensor_info),\n               absl_testing::IsOk());\n   promise.Set(input_tensor);\n+\n+  ScopedMockLog mock_log(kDoNotCaptureLogsYet);\n+  EXPECT_CALL(mock_log, Log).Times(AnyNumber());\n+  EXPECT_CALL(mock_log,\n+              Log(base_logging::WARNING, _,\n+                  HasSubstr(\"Variable named 'input_tensor_2' has been already \"\n+                            \"registered. Ignore request of a new tensor\")))\n+      .Times(1);\n+  mock_log.StartCapturingLogs();\n+\n   EXPECT_THAT(registry.TryRegister(\"input_tensor_2\", restored_tensor_info),\n-              absl_testing::StatusIs(absl::StatusCode::kAlreadyExists));\n+              absl_testing::IsOk());\n }\n \n TEST(IfrtRestoreTensorRegistryTest, SetTensorAsUsedByHost) {"
        }
    ],
    "stats": {
        "total": 88,
        "additions": 84,
        "deletions": 4
    }
}