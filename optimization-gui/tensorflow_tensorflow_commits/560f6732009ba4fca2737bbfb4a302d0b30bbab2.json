{
    "author": "jparkerh",
    "message": "Add Create and Fulfill AliasBuffers to the C API\n\nThis CL adds the concept of an AliasBuffer to the PJRT C API. The AliasBuffer can be created/defined based off of a yet-to-be-created buffer, allowing consumers to accept the alias, awaiting the population of that buffer by future execution events. This support is needed for Torch TPU to allow for run-ahead of the dispatcher.\n\nPiperOrigin-RevId: 810014122",
    "sha": "560f6732009ba4fca2737bbfb4a302d0b30bbab2",
    "files": [
        {
            "sha": "7873a7dbc0f72ea90d875349b6deacdf0b8fc5d1",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -29,6 +29,7 @@ cc_library(\n     name = \"pjrt_c_api_hdrs\",\n     hdrs = [\"pjrt_c_api.h\"],\n     visibility = [\"//visibility:public\"],\n+    deps = [\"@com_google_absl//absl/status\"],\n )\n \n cc_library(\n@@ -256,6 +257,8 @@ cc_library(\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_future\",\n         \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/pjrt:pjrt_stream_executor_client\",\n+        \"//xla/pjrt:raw_buffer\",\n         \"//xla/pjrt/distributed:key_value_store_interface\",\n         \"//xla/pjrt/proto:compile_options_proto_cc\",\n         \"//xla/pjrt/proto:topology_description_proto_cc\",\n@@ -275,11 +278,11 @@ cc_library(\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/time\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//mlir:IR\",\n-        \"@local_tsl//tsl/platform:casts\",\n         \"@local_tsl//tsl/profiler/lib:connected_traceme\",\n         \"@local_tsl//tsl/profiler/lib:context_types_hdrs\",\n     ],"
        },
        {
            "sha": "5848b94d0c2bd43124be8bc9be41cb8ea7cea6ca",
            "filename": "third_party/xla/xla/pjrt/c/CHANGELOG.md",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -1,5 +1,9 @@\n # PJRT C API changelog\n \n+## 0.77\n+\n+* Added buffer aliasing support to the PJRT C API\n+\n ## 0.76\n \n * Added `call_location` to `PJRT_ExecuteOptions`"
        },
        {
            "sha": "4112ef44a07bb230bdcd7c19b17e618bf475ed84",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 49,
            "deletions": 5,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -101,7 +101,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Extension_Base, next);\n // Changes include:\n // * Adding a new field to the PJRT_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define PJRT_API_MINOR 76\n+#define PJRT_API_MINOR 77\n \n // The plugin should set the major_version and minor_version of\n // PJRT_Api.pjrt_api_version to be the `PJRT_API_MAJOR` and `PJRT_API_MINOR` in\n@@ -149,6 +149,7 @@ typedef void PJRT_Error_Message(PJRT_Error_Message_Args* args);\n \n // Codes are based on https://abseil.io/docs/cpp/guides/status-codes\n typedef enum {\n+  PJRT_Error_Code_OK = 0,\n   PJRT_Error_Code_CANCELLED = 1,\n   PJRT_Error_Code_UNKNOWN = 2,\n   PJRT_Error_Code_INVALID_ARGUMENT = 3,\n@@ -335,14 +336,15 @@ typedef struct PJRT_TopologyDescription PJRT_TopologyDescription;\n typedef struct PJRT_Executable PJRT_Executable;\n typedef struct PJRT_LoadedExecutable PJRT_LoadedExecutable;\n typedef struct PJRT_Buffer PJRT_Buffer;\n+typedef struct PJRT_FulfillAliasBufferCallback PJRT_FulfillAliasBufferCallback;\n typedef struct PJRT_AsyncHostToDeviceTransferManager\n     PJRT_AsyncHostToDeviceTransferManager;\n typedef struct PJRT_PhaseCompiler PJRT_PhaseCompiler;\n \n // The caller of PJRT_Client_Create can optionally provide a key-value store\n-// accessible across nodes and/or processes. KV store access may be necessary to\n-// create some multi-node/multi-process clients. The caller can provide the two\n-// callbacks below to access the key-value store.\n+// accessible across nodes and/or processes. KV store access may be necessary\n+// to create some multi-node/multi-process clients. The caller can provide the\n+// two callbacks below to access the key-value store.\n \n // A callback to delete the value returned by PJRT_KeyValueGetCallback.\n typedef void (*PJRT_KeyValueGetCallback_ValueDeleter)(char* value);\n@@ -989,6 +991,46 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Client_CreateUninitializedBuffer_Args, buffer);\n typedef PJRT_Error* PJRT_Client_CreateUninitializedBuffer(\n     PJRT_Client_CreateUninitializedBuffer_Args* args);\n \n+struct PJRT_Client_CreateAliasBuffer_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+  PJRT_Client* client;\n+\n+  // Destination memory space for the buffer alias.\n+  PJRT_Memory* memory;\n+\n+  // Shape fields.\n+  const int64_t* shape_dims;\n+  size_t shape_num_dims;\n+  PJRT_Buffer_Type shape_element_type;\n+  PJRT_Buffer_MemoryLayout* shape_layout;\n+\n+  PJRT_Buffer* alias_buffer;                                 // out\n+  PJRT_FulfillAliasBufferCallback* fulfill_alias_buffer_cb;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_Client_CreateAliasBuffer_Args,\n+                          fulfill_alias_buffer_cb);\n+\n+typedef PJRT_Error* PJRT_Client_CreateAliasBuffer(\n+    PJRT_Client_CreateAliasBuffer_Args* args);\n+\n+struct PJRT_Client_FulfillAliasBuffer_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+  PJRT_Client* client;\n+\n+  PJRT_Buffer* buffer;                                       // in\n+  PJRT_Error_Code status_code;                               // in\n+  const char* error_message;                                 // in\n+  size_t error_message_size;                                 // in\n+  PJRT_FulfillAliasBufferCallback* fulfill_alias_buffer_cb;  // in\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_Client_FulfillAliasBuffer_Args,\n+                          fulfill_alias_buffer_cb);\n+\n+typedef PJRT_Error* PJRT_Client_FulfillAliasBuffer(\n+    PJRT_Client_FulfillAliasBuffer_Args* args);\n+\n struct PJRT_Client_BufferFromHostBuffer_Args {\n   size_t struct_size;\n   PJRT_Extension_Base* extension_start;\n@@ -2596,11 +2638,13 @@ typedef struct PJRT_Api {\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateUninitializedBuffer);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_UpdateGlobalProcessInfo);\n   _PJRT_API_STRUCT_FIELD(PJRT_TopologyDescription_Deserialize);\n+  _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateAliasBuffer);\n+  _PJRT_API_STRUCT_FIELD(PJRT_Client_FulfillAliasBuffer);\n } PJRT_Api;\n \n enum {\n   PJRT_Api_STRUCT_SIZE =\n-      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_TopologyDescription_Deserialize)\n+      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Client_FulfillAliasBuffer)\n };\n \n #undef _PJRT_API_STRUCT_FIELD"
        },
        {
            "sha": "a03c3ec591e9789f59ed32ace232374940644169",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_helpers.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_helpers.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_helpers.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_helpers.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -187,6 +187,7 @@ absl::StatusCode PjrtErrorToStatusCode(const PJRT_Error* error,\n \n absl::StatusCode PjrtErrorCodeToStatusCode(PJRT_Error_Code code) {\n   switch (code) {\n+    case PJRT_Error_Code_OK:\n     case PJRT_Error_Code_CANCELLED:\n     case PJRT_Error_Code_UNKNOWN:\n     case PJRT_Error_Code_INVALID_ARGUMENT:"
        },
        {
            "sha": "325b2abd3fc8908e68a8ef071f611979ae473139",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_test.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -938,6 +938,10 @@ FieldOffsetsAndSizesForVersion(int major_version, int minor_version) {\n     if (minor_version >= 75) {\n       add_field(\"PJRT_TopologyDescription_Deserialize\", kFnPtrSize);\n     }\n+    if (minor_version >= 77) {\n+      add_field(\"PJRT_Client_CreateAliasBuffer\", kFnPtrSize);\n+      add_field(\"PJRT_Client_FulfillAliasBuffer\", kFnPtrSize);\n+    }\n     return version_offsets_and_sizes;\n   }\n   LOG(FATAL) << \"Unsupported API version: \" << major_version << \".\"\n@@ -1320,6 +1324,12 @@ TEST_F(PjrtCAbiTestBase, FieldOffsetsAndSizes) {\n           {\"PJRT_TopologyDescription_Deserialize\",\n            {offsetof(PJRT_Api, PJRT_TopologyDescription_Deserialize),\n             sizeof(PJRT_Api::PJRT_TopologyDescription_Deserialize)}},\n+          {\"PJRT_Client_CreateAliasBuffer\",\n+           {offsetof(PJRT_Api, PJRT_Client_CreateAliasBuffer),\n+            sizeof(PJRT_Api::PJRT_Client_CreateAliasBuffer)}},\n+          {\"PJRT_Client_FulfillAliasBuffer\",\n+           {offsetof(PJRT_Api, PJRT_Client_FulfillAliasBuffer),\n+            sizeof(PJRT_Api::PJRT_Client_FulfillAliasBuffer)}},\n       };\n   ASSERT_EQ(api_->pjrt_api_version.major_version, PJRT_API_MAJOR);\n   ASSERT_EQ(api_->pjrt_api_version.minor_version, PJRT_API_MINOR);"
        },
        {
            "sha": "8af482887d32d5b8ad44bf54eeb2f7d6f6e5e1f3",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include <memory>\n #include <optional>\n #include <string>\n+#include <tuple>\n #include <utility>\n #include <variant>\n #include <vector>\n@@ -34,6 +35,7 @@ limitations under the License.\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/time/time.h\"\n@@ -60,6 +62,7 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/pjrt/proto/compile_options.pb.h\"\n #include \"xla/pjrt/proto/topology_description.pb.h\"\n+#include \"xla/pjrt/raw_buffer.h\"\n #include \"xla/service/computation_placer.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/shape.h\"\n@@ -936,6 +939,66 @@ PJRT_Error* PJRT_Client_CreateUninitializedBuffer(\n   return nullptr;\n }\n \n+PJRT_Error* PJRT_Client_CreateAliasBuffer(\n+    PJRT_Client_CreateAliasBuffer_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_Client_CreateAliasBuffer_Args\",\n+      PJRT_Client_CreateAliasBuffer_Args_STRUCT_SIZE, args->struct_size));\n+  int64_t traceme_context_id = pjrt::GetTracemeContextId(args);\n+  tsl::profiler::TraceMeConsumer consumer(\n+      \"PJRT_Client_CreateBufferAlias\",\n+      tsl::profiler::ContextType::kPjrtLibraryCall, traceme_context_id);\n+\n+  PJRT_ASSIGN_OR_RETURN(\n+      xla::Shape shape,\n+      pjrt::BuildXlaShapeFromC(args->shape_element_type, args->shape_dims,\n+                               args->shape_num_dims, args->shape_layout));\n+\n+  PJRT_ASSIGN_OR_RETURN(auto alias_buffer,\n+                        args->client->client->CreateAliasBuffer(\n+                            shape, args->memory->memory_space));\n+\n+  args->fulfill_alias_buffer_cb =\n+      new PJRT_FulfillAliasBufferCallback{std::move(alias_buffer.second)};\n+  args->alias_buffer =\n+      new PJRT_Buffer{std::move(alias_buffer.first), args->client};\n+  return nullptr;\n+}\n+\n+PJRT_Error* PJRT_Client_FulfillAliasBuffer(\n+    PJRT_Client_FulfillAliasBuffer_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_Client_FulfillAliasBuffer_Args\",\n+      PJRT_Client_FulfillAliasBuffer_Args_STRUCT_SIZE, args->struct_size));\n+  if (args->fulfill_alias_buffer_cb == nullptr) {\n+    return new PJRT_Error{absl::InvalidArgumentError(\n+        \"PJRT_Client_FulfillAliasBuffer_Args.fulfill_alias_buffer_cb is null\")};\n+  }\n+  std::unique_ptr<PJRT_FulfillAliasBufferCallback>\n+      fulfill_alias_buffer_cb_owner(args->fulfill_alias_buffer_cb);\n+  xla::PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb =\n+      std::move(fulfill_alias_buffer_cb_owner->fulfill_alias_buffer_cb);\n+\n+  absl::StatusOr<xla::PjRtBuffer*> real_buffer_or;\n+  if (args->status_code == 0) {  // PJRT_Error_Code_OK\n+    if (args->buffer == nullptr) {\n+      return new PJRT_Error{absl::InvalidArgumentError(\n+          \"Buffer passed to fulfillment callback is null\")};\n+    }\n+    real_buffer_or = args->buffer->buffer.get();\n+  } else {\n+    real_buffer_or = absl::Status(\n+        pjrt::PjrtErrorCodeToStatusCode(args->status_code),\n+        absl::string_view(args->error_message, args->error_message_size));\n+  }\n+\n+  absl::Status status = std::move(fulfill_alias_buffer_cb)(real_buffer_or);\n+  if (!status.ok()) {\n+    return new PJRT_Error{status};\n+  }\n+  return nullptr;\n+}\n+\n PJRT_Error* PJRT_Client_BufferFromHostBuffer(\n     PJRT_Client_BufferFromHostBuffer_Args* args) {\n   PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n@@ -2968,6 +3031,10 @@ PJRT_Api CreatePjrtApi(PJRT_Client_Create* create_fn,\n       pjrt::PJRT_Client_UpdateGlobalProcessInfo,\n       /*PJRT_TopologyDescription_Deserialize=*/\n       pjrt::PJRT_TopologyDescription_Deserialize,\n+      /*PJRT_Client_CreateAliasBuffer=*/\n+      pjrt::PJRT_Client_CreateAliasBuffer,\n+      /*PJRT_Client_FulfillAliasBuffer=*/\n+      pjrt::PJRT_Client_FulfillAliasBuffer,\n   };\n }\n "
        },
        {
            "sha": "7e7b0a3086fa98c324b2957c2b341dc6d6e4f5db",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n \n #include \"absl/base/thread_annotations.h\"\n #include \"absl/container/flat_hash_map.h\"\n+#include \"absl/functional/any_invocable.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -197,6 +198,10 @@ struct PJRT_Buffer {\n       external_references;\n };\n \n+struct PJRT_FulfillAliasBufferCallback {\n+  xla::PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb;\n+};\n+\n struct PJRT_Event {\n   xla::PjRtFuture<> future;\n };\n@@ -283,6 +288,10 @@ PJRT_Error* PJRT_Client_DefaultDeviceAssignment(\n     PJRT_Client_DefaultDeviceAssignment_Args* args);\n PJRT_Error* PJRT_Client_CreateUninitializedBuffer(\n     PJRT_Client_CreateUninitializedBuffer_Args* args);\n+PJRT_Error* PJRT_Client_CreateAliasBuffer(\n+    PJRT_Client_CreateAliasBuffer_Args* args);\n+PJRT_Error* PJRT_Client_FulfillAliasBuffer(\n+    PJRT_Client_FulfillAliasBuffer_Args* args);\n PJRT_Error* PJRT_Client_BufferFromHostBuffer(\n     PJRT_Client_BufferFromHostBuffer_Args* args);\n PJRT_Error* PJRT_Client_CreateViewOfDeviceBuffer("
        },
        {
            "sha": "3bce0f8f02d6daff80a724862a7d5f8fd69658d1",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -194,6 +194,78 @@ CommonPjRtClient::CreateUninitializedBuffer(const Shape& shape,\n   return output_buffer;\n }\n \n+absl::StatusOr<\n+    std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+CommonPjRtClient::CreateAliasBuffer(const Shape& shape,\n+                                    PjRtMemorySpace* memory_space) {\n+  auto buffer_promise = tsl::MakeIndirectAsyncValue();\n+  auto raw_buffer_or = CreateRawBufferAsyncValue(memory_space, buffer_promise);\n+  if (!raw_buffer_or.ok()) {\n+    buffer_promise->SetError(raw_buffer_or.status());\n+    return raw_buffer_or.status();\n+  }\n+  auto raw_buffer = std::move(raw_buffer_or).value();\n+\n+  tsl::RCReference<xla::PjRtDeviceEventPromise> definition_event_promise;\n+  tsl::RCReference<xla::PjRtDeviceEvent> definition_event;\n+  TF_ASSIGN_OR_RETURN(\n+      std::tie(definition_event_promise, definition_event),\n+      CreateLinkedEventPromise(memory_space, \"MakePjRtBufferChannel\"));\n+\n+  // Make a placeholder PjRtBuffer that will be fulfilled when the\n+  // buffer_promise is fulfilled.\n+  TF_ASSIGN_OR_RETURN(\n+      auto result_buffer,\n+      DefineBuffer(shape, std::move(raw_buffer), {std::move(definition_event)},\n+                   /*raw_buffer_is_mutable=*/true));\n+\n+  xla::PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb =\n+      [buffer_promise = std::move(buffer_promise),\n+       definition_event_promise = std::move(definition_event_promise),\n+       memory_space,\n+       shape](absl::StatusOr<xla::PjRtBuffer*> buffer_or) -> absl::Status {\n+    tsl::RCReference<xla::PjRtDeviceEvent> device_event;\n+    if (!buffer_or.ok()) {\n+      definition_event_promise->SetError(buffer_or.status());\n+      buffer_promise->SetError(buffer_or.status());\n+      return buffer_or.status();\n+    }\n+    xla::PjRtBuffer* buffer = buffer_or.value();\n+    if (buffer->on_device_shape() != shape) {\n+      auto status = absl::InvalidArgumentError(absl::StrFormat(\n+          \"Shape mismatch in CreateAliasBuffer: expected %s, got %s\",\n+          shape.ToString(), buffer->on_device_shape().ToString()));\n+      definition_event_promise->SetError(status);\n+      buffer_promise->SetError(status);\n+      return status;\n+    }\n+    xla::CommonPjRtBuffer* common_buffer =\n+        dynamic_cast<xla::CommonPjRtBuffer*>(buffer);\n+    if (common_buffer == nullptr) {\n+      auto status = absl::InternalError(\"Failed to cast to CommonPjRtBuffer\");\n+      definition_event_promise->SetError(status);\n+      buffer_promise->SetError(status);\n+      return status;\n+    }\n+    xla::CommonPjRtBuffer::ScopedHold hold = common_buffer->GetBufferWithHold(\n+        xla::CommonPjRtBuffer::ScopedHold::kDonation);\n+    TF_ASSIGN_OR_RETURN(device_event,\n+                        hold.buffer()->GetDefinitionEvent(memory_space));\n+    // raw buffer. We forward it to the real buffer's raw buffer.\n+    tsl::RCReference<CommonPjRtRawBuffer> real_raw_buffer =\n+        hold.buffer()->GetRawBuffer(memory_space);\n+    TF_ASSIGN_OR_RETURN(tsl::RCReference<tsl::AsyncValue> underlying_av,\n+                        real_raw_buffer->GetRawBufferAsyncValue());\n+    buffer_promise->ForwardTo(std::move(underlying_av));\n+    definition_event_promise->Set(device_event);\n+    hold.ConfirmDonation();\n+    return absl::OkStatus();\n+  };\n+\n+  return std::make_pair(std::move(result_buffer),\n+                        std::move(fulfill_alias_buffer_cb));\n+}\n+\n absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n CommonPjRtClient::BufferFromHostBuffer(\n     const void* data, PrimitiveType type, absl::Span<int64_t const> dims,"
        },
        {
            "sha": "055801dd113e412b5505a19c1fe24c4d99920df5",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.h",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -121,6 +121,14 @@ class CommonPjRtClient : public PjRtClient {\n         \"CreateLinkedEventPromise is not supported\");\n   }\n \n+  virtual absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n+  CreateRawBufferAsyncValue(\n+      PjRtMemorySpace* memory_space,\n+      tsl::RCReference<tsl::IndirectAsyncValue> buffer_promise) {\n+    return absl::UnimplementedError(\n+        \"CreateRawBufferAsyncValue is not supported\");\n+  }\n+\n   // Track a user-provided future with attached debug_info (if\n   // event_tracking_enabled()).\n   virtual void TrackFuture(PjRtMemorySpace* memory_space,\n@@ -179,6 +187,10 @@ class CommonPjRtClient : public PjRtClient {\n       const LiteralSlice& literal, PjRtMemorySpace* memory_space,\n       const Layout* device_layout) override;\n \n+  absl::StatusOr<\n+      std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+  CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) override;\n+\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n       const Shape& shape, PjRtMemorySpace* memory_space) override;\n "
        },
        {
            "sha": "c6279779e9d96f5b934fe33899ee27b95d79103e",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -1001,7 +1001,7 @@ absl::StatusOr<std::unique_ptr<PjRtBuffer>> PjRtCpuClient::DefineBuffer(\n       std::make_unique<TrackedCpuDeviceBuffer>(\n           /*owns_buffers=*/raw_buffer_is_mutable,\n           tsl::down_cast<CpuRawBuffer*>(raw_buffer.get())->buffer(),\n-          std::move(definition_events)),\n+          ShapeUtil::ByteSizeOf(on_device_shape), std::move(definition_events)),\n       raw_buffer->memory_space()));\n }\n \n@@ -1016,6 +1016,15 @@ PjRtCpuClient::AllocateRawBuffer(PjRtMemorySpace* memory_space,\n                                      *allocator_);\n }\n \n+absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n+PjRtCpuClient::CreateRawBufferAsyncValue(\n+    PjRtMemorySpace* memory_space,\n+    tsl::RCReference<tsl::IndirectAsyncValue> buffer_promise) {\n+  return tsl::MakeRef<CpuRawBuffer>(\n+      memory_space,\n+      tsl::AsyncValueRef<CpuDeviceMemory>(std::move(buffer_promise)));\n+}\n+\n absl::StatusOr<int64_t> PjRtCpuClient::GetOnDeviceBytesCount(\n     PjRtMemorySpace* memory_space, const xla::Shape& shape) const {\n   return xla::ShapeUtil::ByteSizeOf(shape);"
        },
        {
            "sha": "6e4cd1c42d2ba626d70bd3c708fd5db904b5cdbb",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -68,6 +68,7 @@ limitations under the License.\n #include \"xla/service/hlo_cost_analysis.h\"\n #include \"xla/service/hlo_module_config.h\"\n #include \"xla/shape.h\"\n+#include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n@@ -199,6 +200,11 @@ class PjRtCpuClient final : public CommonPjRtClient {\n     return &topology_;\n   }\n \n+  absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n+  CreateRawBufferAsyncValue(\n+      PjRtMemorySpace* memory_space,\n+      tsl::RCReference<tsl::IndirectAsyncValue> buffer_promise) override;\n+\n   absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>> AllocateRawBuffer(\n       PjRtMemorySpace* memory_space, size_t on_device_bytes_count,\n       bool retry_on_oom, tsl::AsyncValueRef<bool> allocate_after) override;"
        },
        {
            "sha": "b7754990a36fb7bbb6d78ad43c54c6dc0ec4cb38",
            "filename": "third_party/xla/xla/pjrt/cpu/raw_buffer.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fraw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fraw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fraw_buffer.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -159,6 +159,11 @@ class CpuRawBuffer : public CommonPjRtRawBuffer {\n               tsl::RCReference<PjRtDeviceEventPromise> src_usage_event_promise,\n               ::tsl::AsyncValueRef<bool> allocation_event) override;\n \n+  absl::StatusOr<tsl::RCReference<tsl::AsyncValue>> GetRawBufferAsyncValue()\n+      override {\n+    return buffer_.CopyRCRef();\n+  }\n+\n  private:\n   PjRtMemorySpace* const memory_space_;\n   tsl::AsyncValueRef<CpuDeviceMemory> buffer_;"
        },
        {
            "sha": "c9fec672e3b5bb52671467b157974e31ed27658e",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -343,6 +343,16 @@ PjRtFuture<> TrackedCpuDeviceBuffer::GetReadyFuture(\n   return future;\n }\n \n+absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>\n+TrackedCpuDeviceBuffer::GetDefinitionEvent(PjRtMemorySpace* memory_space) {\n+  if (!definition_event_) {\n+    return absl::InternalError(\n+        \"GetDefinitionEvent only supported on CPU for buffers with \"\n+        \"exactly 1 definition event.\");\n+  }\n+  return tsl::MakeRef<CpuTrackedDeviceEvent>(definition_event_);\n+}\n+\n absl::Status TrackedCpuDeviceBuffer::BlockForOperationsToComplete(\n     PjRtMemorySpace* memory_space) {\n   // Block the host until all usage events have completed. We do not return"
        },
        {
            "sha": "82a4a10e1f037a25cb1df5891c5ab0eb6caeb5f8",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -201,6 +201,9 @@ class TrackedCpuDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   std::vector<tsl::RCReference<tsl::AsyncValue>> GetAsyncValueDefinitionEvents()\n       override;\n \n+  absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>> GetDefinitionEvent(\n+      PjRtMemorySpace* memory_space) override;\n+\n   tsl::RCReference<CommonPjRtRawBuffer> GetRawBuffer(\n       PjRtMemorySpace* memory_space) override;\n "
        },
        {
            "sha": "dab609973dced88124762ae4816c75225c10c5cd",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -562,6 +562,96 @@ PjRtCApiClient::CreateUninitializedBuffer(const Shape& shape,\n   return buffer;\n }\n \n+absl::Status FulfillAliasBuffer(\n+    const PJRT_Api* pjrt_c_api, absl::StatusOr<PjRtBuffer*> real_buffer_or,\n+    PJRT_FulfillAliasBufferCallback* fulfill_alias_buffer_cb) {\n+  if (pjrt_c_api->pjrt_api_version.major_version == 0 &&\n+      pjrt_c_api->pjrt_api_version.minor_version < 76) {\n+    return absl::UnimplementedError(\n+        \"PJRT_Client_FulfillAliasBuffer requires PJRT C API version 0.76 or \"\n+        \"higher.\");\n+  }\n+  PJRT_Client_FulfillAliasBuffer_Args args;\n+  args.struct_size = PJRT_Client_FulfillAliasBuffer_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.fulfill_alias_buffer_cb = fulfill_alias_buffer_cb;\n+\n+  if (real_buffer_or.ok()) {\n+    // We have a real buffer, make sure it's a PjRtCApiBuffer and pass it to the\n+    // C API.\n+    PjRtCApiBuffer* c_buffer =\n+        tensorflow::down_cast<PjRtCApiBuffer*>(real_buffer_or.value());\n+    args.buffer = c_buffer->c_buffer();\n+    args.status_code = PJRT_Error_Code_OK;\n+    args.error_message = nullptr;\n+    args.error_message_size = 0;\n+  } else {\n+    // If the real buffer is an error, then we need to fulfill that alias\n+    // buffer with a nullptr.\n+    args.buffer = nullptr;\n+    args.status_code =\n+        pjrt::StatusCodeToPjrtErrorCode(real_buffer_or.status().code());\n+    args.error_message = real_buffer_or.status().message().data();\n+    args.error_message_size = real_buffer_or.status().message().size();\n+  }\n+\n+  PJRT_Error* error = pjrt_c_api->PJRT_Client_FulfillAliasBuffer(&args);\n+  if (error != nullptr) {\n+    return pjrt::PjrtErrorToStatus(error, pjrt_c_api);\n+  }\n+  return absl::OkStatus();\n+}\n+\n+absl::StatusOr<\n+    std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+PjRtCApiClient::CreateAliasBuffer(const Shape& shape,\n+                                  PjRtMemorySpace* memory_space) {\n+  if (pjrt_c_api()->pjrt_api_version.major_version == 0 &&\n+      pjrt_c_api()->pjrt_api_version.minor_version < 76) {\n+    return absl::UnimplementedError(\n+        \"PJRT_Client_CreateBufferAlias requires PJRT C API version 0.76 or \"\n+        \"higher.\");\n+  }\n+\n+  PJRT_Client_CreateAliasBuffer_Args args;\n+  args.struct_size = PJRT_Client_CreateAliasBuffer_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.client = c_client_.get();\n+\n+  args.shape_dims = shape.dimensions().data();\n+  args.shape_num_dims = shape.dimensions().size();\n+  args.shape_element_type = pjrt::ConvertToPjRtBufferType(shape.element_type());\n+\n+  pjrt::BufferMemoryLayoutData c_layout_data;\n+  if (shape.has_layout()) {\n+    TF_ASSIGN_OR_RETURN(c_layout_data,\n+                        pjrt::ConvertToBufferMemoryLayoutData(shape.layout()));\n+    args.shape_layout = &c_layout_data.c_layout;\n+  } else {\n+    args.shape_layout = nullptr;\n+  }\n+\n+  args.memory =\n+      tensorflow::down_cast<PjRtCApiMemorySpace*>(memory_space)->c_memory();\n+  args.alias_buffer = nullptr;\n+\n+  RETURN_STATUS_IF_PJRT_ERROR(c_api_->PJRT_Client_CreateAliasBuffer(&args),\n+                              c_api_);\n+\n+  std::unique_ptr<PjRtBuffer> alias_buffer(\n+      std::make_unique<PjRtCApiBuffer>(this, args.alias_buffer));\n+\n+  PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb =\n+      [pjrt_c_api = pjrt_c_api(),\n+       fulfill_alias_buffer_cb = args.fulfill_alias_buffer_cb](\n+          absl::StatusOr<PjRtBuffer*> real_buffer) -> absl::Status {\n+    return FulfillAliasBuffer(pjrt_c_api, real_buffer, fulfill_alias_buffer_cb);\n+  };\n+\n+  return std::make_pair(std::move(alias_buffer),\n+                        std::move(fulfill_alias_buffer_cb));\n+}\n+\n absl::StatusOr<const PjRtTopologyDescription*>\n PjRtCApiClient::GetTopologyDescription() const {\n   if (!topo_desc_.ok()) {"
        },
        {
            "sha": "77cbf6c905b1c74c78239870b356f288bc579662",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -332,6 +332,10 @@ class PjRtCApiClient : public PjRtClient {\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n       const Shape& shape, PjRtMemorySpace* memory_space) override;\n \n+  absl::StatusOr<\n+      std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+  CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) override;\n+\n   absl::StatusOr<const PjRtTopologyDescription*> GetTopologyDescription()\n       const override;\n "
        },
        {
            "sha": "7b0dd9a724edf201e5417e3506923a6644c3ec8c",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client_test.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -14,6 +14,8 @@ limitations under the License.\n ==============================================================================*/\n #include \"xla/pjrt/pjrt_c_api_client.h\"\n \n+#include <unistd.h>\n+\n #include <array>\n #include <cstddef>\n #include <cstdint>\n@@ -70,6 +72,60 @@ static void SetUpCpuPjRtApi() {\n   }\n }\n \n+TEST(PjRtCApiClientTest, FulfillAliasBuffer) {\n+  SetUpCpuPjRtApi();\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,\n+                          GetCApiClient(\"cpu\"));\n+\n+  std::vector<int32_t> data{1, 2, 3, 4, 5, 6};\n+  Shape shape = ShapeUtil::MakeShape(S32, {2, 3});\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto alias_buffer,\n+      client->CreateAliasBuffer(shape, client->memory_spaces()[0]));\n+\n+  // Create a buffer from host data.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto param,\n+      client->BufferFromHostBuffer(\n+          data.data(), shape.element_type(), shape.dimensions(),\n+          /*byte_strides=*/std::nullopt,\n+          PjRtClient::HostBufferSemantics::kImmutableOnlyDuringCall, nullptr,\n+          client->memory_spaces()[0], /*device_layout=*/nullptr));\n+\n+  // Define a simple \"add one\" kernel.\n+  XlaBuilder builder(\"add_one\");\n+  auto input = Parameter(&builder, 0, shape, \"input\");\n+  auto one = ConstantR0<int32_t>(&builder, 1);\n+  auto add = Add(input, one);\n+  auto computation = builder.Build(add).value();\n+\n+  // Compile and load the executable.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<PjRtLoadedExecutable> executable,\n+      client->CompileAndLoad(computation, CompileOptions()));\n+\n+  // Execute the kernel.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::vector<std::vector<std::unique_ptr<PjRtBuffer>>> results,\n+      executable->Execute({{param.get()}}, ExecuteOptions()));\n+  ASSERT_EQ(results.size(), 1);\n+  ASSERT_EQ(results[0].size(), 1);\n+  std::unique_ptr<PjRtBuffer>& result_buffer = results[0][0];\n+\n+  // Wait for the result buffer to be ready.\n+  TF_ASSERT_OK(result_buffer->GetReadyFuture().Await());\n+\n+  // Fulfill the alias buffer with the result of the add one kernel.\n+  ASSERT_NE(alias_buffer.second, nullptr);\n+  TF_ASSERT_OK(std::move(alias_buffer.second)(result_buffer.get()));\n+  TF_ASSERT_OK_AND_ASSIGN(auto alias_literal,\n+                          alias_buffer.first->ToLiteralSync());\n+\n+  // Expected result: data + 1\n+  EXPECT_TRUE(LiteralTestUtil::Equal(\n+      LiteralUtil::CreateR2<int32_t>({{2, 3, 4}, {5, 6, 7}}), *alias_literal));\n+}\n+\n TEST(PjRtCApiClientTest, IsDynamicDimension) {\n   SetUpCpuPjRtApi();\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,"
        },
        {
            "sha": "94666e2d79dc285de9fe14d35603ccf69509f89a",
            "filename": "third_party/xla/xla/pjrt/pjrt_client.h",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_client.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -67,12 +67,16 @@ limitations under the License.\n // PjRt stands for \"Pretty much Just another RunTime\".\n namespace xla {\n \n+class PjRtBuffer;\n class PjRtClient;\n class PjRtDevice;\n class PjRtLoadedExecutable;\n class PjRtExecutableForwarder;\n struct CompileOptions;\n \n+typedef absl::AnyInvocable<absl::Status(absl::StatusOr<PjRtBuffer*>)>\n+    PjRtFulfillAliasBufferCallback;\n+\n class PjRtMemorySpace {\n  public:\n   virtual ~PjRtMemorySpace() = default;\n@@ -253,9 +257,6 @@ class PjRtDevice {\n   }\n };\n \n-// Forward declaration.\n-class PjRtBuffer;\n-\n // Helper struct for cross host transfers, returned by the callback from a call\n // to PjRtBuffer::MakeCrossHostReceiveBuffers or\n // PjRtBuffer::MakeCrossHostReceiveBuffersForGather.\n@@ -677,6 +678,14 @@ class PjRtClient {\n         \"CreateUninitializedBuffer is not supported.\");\n   }\n \n+  // Creates a buffer that is an alias of another buffer. The alias buffer\n+  // is initially uninitialized and must be fulfilled later.\n+  virtual absl::StatusOr<\n+      std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+  CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) {\n+    return absl::UnimplementedError(\"CreateAliasBuffer is not supported.\");\n+  }\n+\n   // Creates buffer in the given memory space that carries an error future\n   // without allocating memory.\n   virtual absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateErrorBuffer("
        },
        {
            "sha": "a56cf50728a42cf7af60b8d107bfeed77ca621b1",
            "filename": "third_party/xla/xla/pjrt/raw_buffer.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/560f6732009ba4fca2737bbfb4a302d0b30bbab2/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h?ref=560f6732009ba4fca2737bbfb4a302d0b30bbab2",
            "patch": "@@ -18,12 +18,14 @@ limitations under the License.\n \n #include <optional>\n \n+#include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"xla/literal.h\"\n #include \"xla/pjrt/async_work_runner.h\"\n #include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/shape.h\"\n+#include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n@@ -167,6 +169,13 @@ class CommonPjRtRawBuffer : public PjRtRawBuffer {\n       tsl::RCReference<PjRtDeviceEventPromise> definition_event_promise,\n       tsl::RCReference<PjRtDeviceEventPromise> src_usage_event_promise,\n       ::tsl::AsyncValueRef<bool> allocation_event);\n+\n+  // Returns the async value associated with the buffer.\n+  virtual absl::StatusOr<tsl::RCReference<tsl::AsyncValue>>\n+  GetRawBufferAsyncValue() {\n+    return absl::UnimplementedError(\n+        \"GetRawBufferAsyncValue is not implemented.\");\n+  }\n };\n \n class RegisterRawBufferFactory {"
        }
    ],
    "stats": {
        "total": 443,
        "additions": 433,
        "deletions": 10
    }
}