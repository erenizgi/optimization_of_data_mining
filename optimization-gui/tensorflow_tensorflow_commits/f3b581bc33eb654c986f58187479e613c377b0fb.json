{
    "author": "unknown",
    "message": "[XLA:GPU] Allow creating SdcLog out of preallocated DeviceMemory\n\nIn actual use, device memory used by thunks is managed externally. We'll have\nto use whatever the buffer assignment gives us rather than allocating on the\nfly.\n\nPiperOrigin-RevId: 817158433",
    "sha": "f3b581bc33eb654c986f58187479e613c377b0fb",
    "files": [
        {
            "sha": "5effa8fc923ffcfc2ec2de6409411d5d85f89aa3",
            "filename": "third_party/xla/xla/stream_executor/cuda/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2FBUILD?ref=f3b581bc33eb654c986f58187479e613c377b0fb",
            "patch": "@@ -433,9 +433,7 @@ cc_library(\n         \"//xla/stream_executor:device_memory\",\n         \"//xla/stream_executor:device_memory_allocator\",\n         \"//xla/stream_executor:stream\",\n-        \"//xla/stream_executor:stream_executor_h\",\n         \"//xla/tsl/platform:errors\",\n-        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:str_format\",\n@@ -448,12 +446,15 @@ xla_test(\n     backends = [\"gpu\"],\n     deps = [\n         \":sdc_log\",\n+        \"//xla/stream_executor:device_memory\",\n         \"//xla/stream_executor:platform\",\n         \"//xla/stream_executor:platform_manager\",\n         \"//xla/stream_executor:stream\",\n         \"//xla/stream_executor:stream_executor_h\",\n         \"//xla/stream_executor:stream_executor_memory_allocator\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_googletest//:gtest_main\",\n     ],\n )"
        },
        {
            "sha": "5515cd4bbe9051757b229509e904979452a775af",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_log.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 19,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.cc?ref=f3b581bc33eb654c986f58187479e613c377b0fb",
            "patch": "@@ -19,7 +19,6 @@ limitations under the License.\n #include <cstdint>\n #include <cstdlib>\n #include <cstring>\n-#include <utility>\n #include <vector>\n \n #include \"absl/status/status.h\"\n@@ -28,53 +27,57 @@ limitations under the License.\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/device_memory_allocator.h\"\n #include \"xla/stream_executor/stream.h\"\n-#include \"xla/stream_executor/stream_executor.h\"\n #include \"xla/tsl/platform/errors.h\"\n-#include \"xla/tsl/platform/statusor.h\"\n \n namespace stream_executor::cuda {\n \n absl::StatusOr<SdcLog> SdcLog::CreateOnDevice(\n-    uint32_t max_entries, Stream& stream, DeviceMemoryAllocator& allocator) {\n-  TF_ASSIGN_OR_RETURN(\n-      OwningDeviceMemory memory,\n-      allocator.Allocate(\n-          stream.parent()->device_ordinal(),\n-          sizeof(SdcLogHeader) + max_entries * sizeof(SdcLogEntry)));\n-  if (memory.is_null()) {\n-    return absl::InternalError(absl::StrFormat(\n-        \"Failed to allocate SdcLog for %u entries\", max_entries));\n+    Stream& stream, DeviceMemory<uint8_t> log_buffer) {\n+  if (log_buffer.is_null()) {\n+    return absl::InvalidArgumentError(\"Log buffer must be non-null\");\n   }\n \n+  static constexpr size_t kMinBufferSize =\n+      sizeof(SdcLogHeader) + sizeof(SdcLogEntry);\n+  if (log_buffer.size() < kMinBufferSize) {\n+    return absl::InvalidArgumentError(\n+        absl::StrFormat(\"Log buffer size %u is too small to hold any log \"\n+                        \"entries (required: %u bytes)\",\n+                        log_buffer.size(), kMinBufferSize));\n+  }\n+\n+  const uint32_t max_entries =\n+      (log_buffer.size() - sizeof(SdcLogHeader)) / sizeof(SdcLogEntry);\n   const SdcLogHeader empty_header{\n       /*write_idx=*/0,\n       /*capacity=*/max_entries,\n   };\n   TF_RETURN_IF_ERROR(\n-      stream.Memcpy(memory.ptr(), &empty_header, sizeof(empty_header)));\n-  return SdcLog(std::move(memory));\n+      stream.Memcpy(&log_buffer, &empty_header, sizeof(empty_header)));\n+  return SdcLog(log_buffer);\n }\n \n absl::StatusOr<SdcLogHeader> SdcLog::ReadHeaderFromDevice(\n     Stream& stream) const {\n   SdcLogHeader header;\n-  TF_RETURN_IF_ERROR(stream.Memcpy(&header, memory_.cref(), sizeof(header)));\n+  TF_RETURN_IF_ERROR(stream.Memcpy(&header, memory_, sizeof(header)));\n   TF_RETURN_IF_ERROR(stream.BlockHostUntilDone());\n   return header;\n }\n \n absl::StatusOr<std::vector<SdcLogEntry>> SdcLog::ReadFromDevice(\n     Stream& stream) const {\n-  std::vector<uint8_t> buffer(memory_->size());\n-  TF_RETURN_IF_ERROR(\n-      stream.Memcpy(buffer.data(), memory_.cref(), memory_->size()));\n+  std::vector<uint8_t> buffer(memory_.size());\n+  TF_RETURN_IF_ERROR(stream.Memcpy(buffer.data(), memory_, memory_.size()));\n   TF_RETURN_IF_ERROR(stream.BlockHostUntilDone());\n \n   SdcLogHeader header;\n   memcpy(&header, buffer.data(), sizeof(header));\n \n+  const uint32_t max_entries =\n+      (memory_.size() - sizeof(SdcLogHeader)) / sizeof(SdcLogEntry);\n   const size_t initialized_entries =\n-      std::min(header.capacity, header.write_idx);\n+      std::min(max_entries, std::min(header.capacity, header.write_idx));\n   std::vector<SdcLogEntry> entries(initialized_entries);\n   memcpy(entries.data(), buffer.data() + sizeof(header),\n          initialized_entries * sizeof(SdcLogEntry));"
        },
        {
            "sha": "e958e0d1a0a1f49ad8d28ea4cf5b627566c10ccb",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_log.h",
            "status": "modified",
            "additions": 19,
            "deletions": 11,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.h?ref=f3b581bc33eb654c986f58187479e613c377b0fb",
            "patch": "@@ -18,7 +18,6 @@ limitations under the License.\n \n #include <cstddef>\n #include <cstdint>\n-#include <utility>\n #include <vector>\n \n #include \"absl/status/statusor.h\"\n@@ -59,15 +58,24 @@ static_assert(offsetof(SdcLogHeader, capacity) == sizeof(uint32_t));\n // SdcLogEntry structs.\n class SdcLog {\n  public:\n-  // Uses `allocator` to allocate an empty `SdcLog` on the device with enough\n-  // capacity to hold `max_entries` of `SdcLogEntry` structs.\n+  // Returns the number of bytes required to store a log with `entries`\n+  // entries.\n+  static constexpr size_t RequiredSizeForEntries(size_t entries) {\n+    return sizeof(SdcLogHeader) + sizeof(SdcLogEntry) * entries;\n+  }\n+\n+  // Initializes an empty `SdcLog` using a `log_buffer` allocated in device\n+  // memory.\n   //\n-  // `allocator` must be associated with the same device as `stream`, and must\n-  // outlive the returned `SdcLog`.\n+  // `log_buffer` must be allocated in memory of the same device `stream` is\n+  // associated with. `log_buffer` must outlive the returned `SdcLog`.\n   //\n   // Contents of the log can be retrieved with `SdcLog::ReadFromDevice`.\n+  //\n+  // Fails with `absl::StatusCode::kInvalidArgument` if `log_buffer` is too\n+  // small to hold any entries.\n   static absl::StatusOr<SdcLog> CreateOnDevice(\n-      uint32_t max_entries, Stream& stream, DeviceMemoryAllocator& allocator);\n+      Stream& stream, DeviceMemory<uint8_t> log_buffer);\n \n   // Reads the header from the device log.\n   //\n@@ -90,22 +98,22 @@ class SdcLog {\n   // destroyed.\n   DeviceMemory<SdcLogHeader> GetDeviceHeader() const {\n     return DeviceMemory<SdcLogHeader>(\n-        memory_->GetByteSlice(0, sizeof(SdcLogHeader)));\n+        memory_.GetByteSlice(0, sizeof(SdcLogHeader)));\n   }\n \n   // Returns a view of the `SdcLogEntry` array.\n   //\n   // The returned `DeviceMemory` gets invalidated when the `SdcLog` is\n   // destroyed.\n   DeviceMemory<SdcLogEntry> GetDeviceEntries() const {\n-    return DeviceMemory<SdcLogEntry>(memory_->GetByteSlice(\n-        sizeof(SdcLogHeader), memory_->size() - sizeof(SdcLogHeader)));\n+    return DeviceMemory<SdcLogEntry>(memory_.GetByteSlice(\n+        sizeof(SdcLogHeader), memory_.size() - sizeof(SdcLogHeader)));\n   }\n \n  private:\n-  explicit SdcLog(OwningDeviceMemory&& memory) : memory_(std::move(memory)) {}\n+  explicit SdcLog(DeviceMemory<uint8_t> memory) : memory_(memory) {}\n \n-  OwningDeviceMemory memory_;\n+  DeviceMemory<uint8_t> memory_;\n };\n \n }  // namespace stream_executor::cuda"
        },
        {
            "sha": "89e73d88dd1d22229bcd89cb23e483174dd2b72f",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_log_test.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 10,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log_test.cc?ref=f3b581bc33eb654c986f58187479e613c377b0fb",
            "patch": "@@ -20,7 +20,11 @@ limitations under the License.\n #include <memory>\n #include <optional>\n \n+#include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/platform.h\"\n #include \"xla/stream_executor/platform_manager.h\"\n #include \"xla/stream_executor/stream.h\"\n@@ -49,39 +53,61 @@ class SdcLogTest : public ::testing::Test {\n   std::unique_ptr<se::StreamExecutorMemoryAllocator> allocator_;\n };\n \n-TEST_F(SdcLogTest, CreateSdcLogOnDevice_AllocatesEmptyLog) {\n-  TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/10, *stream_, *allocator_));\n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_InitializesEmptyLog) {\n+  se::DeviceMemory<uint8_t> log_buffer =\n+      executor_->AllocateArray<uint8_t>(1024);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      se::cuda::SdcLog device_log,\n+      se::cuda::SdcLog::CreateOnDevice(*stream_, log_buffer));\n   TF_ASSERT_OK_AND_ASSIGN(auto host_log, device_log.ReadFromDevice(*stream_));\n \n   EXPECT_EQ(host_log.size(), 0);\n }\n \n-TEST_F(SdcLogTest, CreateSdcLogOnDevice_AllocatesEnoughSpace) {\n-  constexpr uint32_t kMaxEntries = 10;\n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_InitializesLogWithCorrectCapacity) {\n+  constexpr size_t kMaxEntries = 10;\n   constexpr size_t kExpectedHeaderSize = sizeof(se::cuda::SdcLogHeader);\n   constexpr size_t kExpectedEntriesSize =\n       sizeof(se::cuda::SdcLogEntry) * kMaxEntries;\n+  se::DeviceMemory<uint8_t> log_buffer = executor_->AllocateArray<uint8_t>(\n+      kExpectedHeaderSize + kExpectedEntriesSize);\n \n   TF_ASSERT_OK_AND_ASSIGN(\n       se::cuda::SdcLog device_log,\n-      se::cuda::SdcLog::CreateOnDevice(kMaxEntries, *stream_, *allocator_));\n+      se::cuda::SdcLog::CreateOnDevice(*stream_, log_buffer));\n+\n   EXPECT_EQ(device_log.GetDeviceHeader().size(), kExpectedHeaderSize);\n   EXPECT_EQ(device_log.GetDeviceEntries().size(), kExpectedEntriesSize);\n }\n \n TEST_F(SdcLogTest, CreateSdcLogOnDevice_InitializesHeader) {\n-  constexpr uint32_t kMaxEntries = 10;\n+  constexpr size_t kMaxEntries = 123;\n+  se::DeviceMemory<uint8_t> log_buffer = executor_->AllocateArray<uint8_t>(\n+      se::cuda::SdcLog::RequiredSizeForEntries(kMaxEntries));\n \n   TF_ASSERT_OK_AND_ASSIGN(\n       se::cuda::SdcLog device_log,\n-      se::cuda::SdcLog::CreateOnDevice(kMaxEntries, *stream_, *allocator_));\n-\n+      se::cuda::SdcLog::CreateOnDevice(*stream_, log_buffer));\n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLogHeader header,\n                           device_log.ReadHeaderFromDevice(*stream_));\n+\n   EXPECT_EQ(header.write_idx, 0);\n   EXPECT_EQ(header.capacity, kMaxEntries);\n }\n \n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_FailsForNullBuffer) {\n+  EXPECT_THAT(\n+      se::cuda::SdcLog::CreateOnDevice(*stream_, se::DeviceMemory<uint8_t>()),\n+      absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_FailsForTooSmallBuffer) {\n+  se::DeviceMemory<uint8_t> log_buffer = executor_->AllocateArray<uint8_t>(\n+      se::cuda::SdcLog::RequiredSizeForEntries(1) - 1);\n+\n+  EXPECT_THAT(se::cuda::SdcLog::CreateOnDevice(*stream_, log_buffer),\n+              absl_testing::StatusIs(absl::StatusCode::kInvalidArgument));\n+}\n+\n }  // namespace"
        },
        {
            "sha": "530de932b8699537fd954a435c2ea152e0e000ca",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_xor_checksum_kernel_cuda_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 12,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_xor_checksum_kernel_cuda_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f3b581bc33eb654c986f58187479e613c377b0fb/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_xor_checksum_kernel_cuda_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_xor_checksum_kernel_cuda_test.cc?ref=f3b581bc33eb654c986f58187479e613c377b0fb",
            "patch": "@@ -44,6 +44,7 @@ limitations under the License.\n \n namespace se = stream_executor;\n \n+namespace stream_executor::cuda {\n namespace {\n \n class ChecksumKernelTest : public ::testing::Test {\n@@ -107,6 +108,7 @@ class ChecksumKernelTest : public ::testing::Test {\n };\n \n TEST_F(ChecksumKernelTest, ComputesCorrectChecksumForMultipleOf32Bit) {\n+  se::DeviceMemory<uint8_t> mem = executor_->AllocateArray<uint8_t>(1024);\n   std::vector<uint8_t> input = std::vector<uint8_t>(1024, 0x55);\n   // Xor with the expected checksum value.\n   // Assumes the device uses little-endian byte order.\n@@ -117,8 +119,7 @@ TEST_F(ChecksumKernelTest, ComputesCorrectChecksumForMultipleOf32Bit) {\n   constexpr uint32_t kExpectedChecksum = 0x12345678;\n \n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/10, *stream_, *allocator_));\n+                          se::cuda::SdcLog::CreateOnDevice(*stream_, mem));\n \n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/0, input, device_log));\n \n@@ -129,10 +130,10 @@ TEST_F(ChecksumKernelTest, ComputesCorrectChecksumForMultipleOf32Bit) {\n \n TEST_F(ChecksumKernelTest,\n        PadsMostSignifantBitsOfIncomplete32BitInputWordWithZeros) {\n+  se::DeviceMemory<uint8_t> mem = executor_->AllocateArray<uint8_t>(1024);\n   const std::vector<uint8_t> kInput = std::vector<uint8_t>(1023, 0x55);\n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/10, *stream_, *allocator_));\n+                          se::cuda::SdcLog::CreateOnDevice(*stream_, mem));\n \n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/0, kInput, device_log));\n \n@@ -143,14 +144,14 @@ TEST_F(ChecksumKernelTest,\n }\n \n TEST_F(ChecksumKernelTest, ComputesCorrectChecksumInParallel) {\n+  se::DeviceMemory<uint8_t> mem = executor_->AllocateArray<uint8_t>(1024);\n   std::vector<uint32_t> input =\n       std::vector<uint32_t>(64 * 1024 / sizeof(uint32_t), 0x55aa55aa);\n   // Xor with the expected checksum value.\n   input[1000] ^= 0x12345678;\n   constexpr uint32_t kExpectedChecksum = 0x12345678;\n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/10, *stream_, *allocator_));\n+                          se::cuda::SdcLog::CreateOnDevice(*stream_, mem));\n \n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/0, input, device_log,\n                                       se::ThreadDim(2, 4, 8)));\n@@ -161,14 +162,14 @@ TEST_F(ChecksumKernelTest, ComputesCorrectChecksumInParallel) {\n }\n \n TEST_F(ChecksumKernelTest, ComputesCorrectChecksumInParallelWithMaxThreads) {\n+  se::DeviceMemory<uint8_t> mem = executor_->AllocateArray<uint8_t>(1024);\n   std::vector<uint32_t> input =\n       std::vector<uint32_t>(64 * 1024 / sizeof(uint32_t), 0x55aa55aa);\n   // Xor with the expected checksum value.\n   input[1000] ^= 0x12345678;\n   constexpr uint32_t kExpectedChecksum = 0x12345678;\n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/10, *stream_, *allocator_));\n+                          se::cuda::SdcLog::CreateOnDevice(*stream_, mem));\n \n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/0, input, device_log,\n                                       se::ThreadDim(128, 4, 2)));\n@@ -179,12 +180,12 @@ TEST_F(ChecksumKernelTest, ComputesCorrectChecksumInParallelWithMaxThreads) {\n }\n \n TEST_F(ChecksumKernelTest, AppendsChecksumsToLog) {\n+  se::DeviceMemory<uint8_t> mem = executor_->AllocateArray<uint8_t>(1024);\n   constexpr std::array<uint32_t, 1> kInput123 = {0x01230123};\n   constexpr std::array<uint32_t, 1> kInput456 = {0x04560456};\n   constexpr std::array<uint32_t, 1> kInput789 = {0x07890789};\n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/10, *stream_, *allocator_));\n+                          se::cuda::SdcLog::CreateOnDevice(*stream_, mem));\n \n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/123, kInput123, device_log));\n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/456, kInput456, device_log));\n@@ -201,12 +202,13 @@ TEST_F(ChecksumKernelTest, AppendsChecksumsToLog) {\n }\n \n TEST_F(ChecksumKernelTest, DiscardsOverflowingChecksums) {\n+  se::DeviceMemory<uint8_t> mem = executor_->AllocateArray<uint8_t>(\n+      sizeof(SdcLogHeader) + sizeof(SdcLogEntry) * 2);\n   constexpr std::array<uint32_t, 1> kInput123 = {0x01230123};\n   constexpr std::array<uint32_t, 1> kInput456 = {0x04560456};\n   constexpr std::array<uint32_t, 1> kInput789 = {0x07890789};\n   TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n-                          se::cuda::SdcLog::CreateOnDevice(\n-                              /*max_entries=*/2, *stream_, *allocator_));\n+                          se::cuda::SdcLog::CreateOnDevice(*stream_, mem));\n \n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/123, kInput123, device_log));\n   TF_EXPECT_OK(AppendChecksumOnDevice(/*entry_id=*/456, kInput456, device_log));\n@@ -222,3 +224,4 @@ TEST_F(ChecksumKernelTest, DiscardsOverflowingChecksums) {\n }\n \n }  // namespace\n+}  // namespace stream_executor::cuda"
        }
    ],
    "stats": {
        "total": 149,
        "additions": 95,
        "deletions": 54
    }
}