{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 826749442",
    "sha": "ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
    "files": [
        {
            "sha": "1a44dd7e373911ee72497ee96abbeb9839f158cb",
            "filename": "tensorflow/core/grappler/graph_topology_view.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgraph_topology_view.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgraph_topology_view.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_topology_view.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -65,7 +65,7 @@ absl::Status GraphTopologyView::InitializeFromGraph(\n     const auto src = node_name_to_index_.find(edge.src.node->name());\n     const bool valid_src = src != node_name_to_index_.end();\n     if (!valid_src) {\n-      const string error_message =\n+      const std::string error_message =\n           absl::StrCat(\"Non-existent src node: \", edge.src.node->name());\n       if (skip_invalid_edges_) {\n         VLOG(0) << \"Skip error: \" << error_message;\n@@ -78,7 +78,7 @@ absl::Status GraphTopologyView::InitializeFromGraph(\n     const bool valid_dst = dst != node_name_to_index_.end();\n \n     if (!valid_dst) {\n-      const string error_message =\n+      const std::string error_message =\n           absl::StrCat(\"Non-existent dst node: \", edge.dst.node->name());\n       if (skip_invalid_edges_) {\n         VLOG(0) << \"Skip error: \" << error_message;\n@@ -103,7 +103,7 @@ absl::Status GraphTopologyView::InitializeFromGraph(\n     const NodeDef& node = graph.node(node_idx);\n     fanins_[node_idx].reserve(node.input_size());\n \n-    for (const string& input : node.input()) {\n+    for (const std::string& input : node.input()) {\n       TensorId tensor = ParseTensorName(input);\n       if (ignore_control_edges && IsTensorIdControl(tensor)) {\n         continue;\n@@ -112,8 +112,8 @@ absl::Status GraphTopologyView::InitializeFromGraph(\n       const bool valid_input = it != node_name_to_index_.end();\n \n       if (!valid_input) {\n-        const string error_message = absl::StrCat(\"Non-existent input \", input,\n-                                                  \" in node \", node.name());\n+        const std::string error_message = absl::StrCat(\n+            \"Non-existent input \", input, \" in node \", node.name());\n         if (skip_invalid_edges_) {\n           VLOG(3) << \"Skip error: \" << error_message;\n         } else {"
        },
        {
            "sha": "adda65d886b6674f9e0738e28ac3fefe89f4eacf",
            "filename": "tensorflow/core/grappler/graph_topology_view_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgraph_topology_view_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgraph_topology_view_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_topology_view_test.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -24,7 +24,7 @@ namespace grappler {\n \n class GraphTopologyViewTest : public ::testing::Test {\n  protected:\n-  using NodeConfig = std::pair<string, std::vector<string>>;\n+  using NodeConfig = std::pair<std::string, std::vector<std::string>>;\n \n   static GraphDef CreateGraph(const std::vector<NodeConfig>& nodes) {\n     GraphDef graph;\n@@ -35,7 +35,7 @@ class GraphTopologyViewTest : public ::testing::Test {\n \n       NodeDef node_def;\n       node_def.set_name(node_name);\n-      for (const string& input : node_inputs) {\n+      for (const std::string& input : node_inputs) {\n         node_def.add_input(input);\n       }\n "
        },
        {
            "sha": "a637c2f4e207a0918a139d07ee0bdc9824351588",
            "filename": "tensorflow/core/grappler/graph_view_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgraph_view_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgraph_view_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_view_test.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -161,16 +161,16 @@ TEST_F(GraphViewTest, BasicGraph) {\n   const NodeDef* add_node = graph.GetNode(\"AddN\");\n   EXPECT_NE(add_node, nullptr);\n \n-  absl::flat_hash_set<string> fanouts;\n-  absl::flat_hash_set<string> expected_fanouts = {\"AddN_2:0\", \"AddN_3:0\"};\n+  absl::flat_hash_set<std::string> fanouts;\n+  absl::flat_hash_set<std::string> expected_fanouts = {\"AddN_2:0\", \"AddN_3:0\"};\n   for (const auto& fo : graph.GetFanouts(*add_node, false)) {\n     fanouts.insert(absl::StrCat(fo.node->name(), \":\", fo.port_id));\n   }\n   EXPECT_EQ(graph.NumFanouts(*add_node, false), 2);\n   EXPECT_EQ(fanouts, expected_fanouts);\n \n-  absl::flat_hash_set<string> fanins;\n-  absl::flat_hash_set<string> expected_fanins = {\"Sign_1:0\", \"Sign:0\"};\n+  absl::flat_hash_set<std::string> fanins;\n+  absl::flat_hash_set<std::string> expected_fanins = {\"Sign_1:0\", \"Sign:0\"};\n   for (const auto& fi : graph.GetFanins(*add_node, false)) {\n     fanins.insert(absl::StrCat(fi.node->name(), \":\", fi.port_id));\n   }"
        },
        {
            "sha": "b6da0ed010e1892ad770c927d91c133d63d74521",
            "filename": "tensorflow/core/grappler/grappler_item.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -74,9 +74,9 @@ std::vector<const NodeDef*> GrapplerItem::MainOpsFanin() const {\n }\n \n std::vector<const NodeDef*> GrapplerItem::EnqueueOpsFanin() const {\n-  std::vector<string> enqueue_ops;\n+  std::vector<std::string> enqueue_ops;\n   for (const auto& queue_runner : queue_runners) {\n-    for (const string& enqueue_op : queue_runner.enqueue_op_name()) {\n+    for (const std::string& enqueue_op : queue_runner.enqueue_op_name()) {\n       enqueue_ops.push_back(enqueue_op);\n     }\n   }\n@@ -103,9 +103,9 @@ std::vector<const NodeDef*> GrapplerItem::MainVariables() const {\n   return vars;\n }\n \n-std::unordered_set<string> GrapplerItem::NodesToPreserve() const {\n-  std::unordered_set<string> result;\n-  for (const string& f : fetch) {\n+std::unordered_set<std::string> GrapplerItem::NodesToPreserve() const {\n+  std::unordered_set<std::string> result;\n+  for (const std::string& f : fetch) {\n     VLOG(1) << \"Add fetch \" << f;\n     result.insert(NodeName(f));\n   }\n@@ -130,7 +130,7 @@ std::unordered_set<string> GrapplerItem::NodesToPreserve() const {\n   }\n \n   for (const auto& queue_runner : queue_runners) {\n-    for (const string& enqueue_op : queue_runner.enqueue_op_name()) {\n+    for (const std::string& enqueue_op : queue_runner.enqueue_op_name()) {\n       result.insert(NodeName(enqueue_op));\n     }\n     if (!queue_runner.close_op_name().empty()) {\n@@ -167,11 +167,11 @@ std::unordered_set<string> GrapplerItem::NodesToPreserve() const {\n   return result;\n }\n \n-const std::unordered_set<string>& GrapplerItem::devices() const {\n+const std::unordered_set<std::string>& GrapplerItem::devices() const {\n   return devices_;\n }\n \n-absl::Status GrapplerItem::AddDevice(const string& device) {\n+absl::Status GrapplerItem::AddDevice(const std::string& device) {\n   DeviceNameUtils::ParsedName name;\n \n   if (!DeviceNameUtils::ParseFullName(device, &name)) {\n@@ -189,7 +189,7 @@ absl::Status GrapplerItem::AddDevice(const string& device) {\n \n absl::Status GrapplerItem::AddDevices(const GrapplerItem& other) {\n   std::vector<absl::string_view> invalid_devices;\n-  for (const string& device : other.devices()) {\n+  for (const std::string& device : other.devices()) {\n     absl::Status added = AddDevice(device);\n     if (!added.ok()) invalid_devices.emplace_back(device);\n   }"
        },
        {
            "sha": "98e70d599fa4c9719349b983d35300c9c2183bd8",
            "filename": "tensorflow/core/grappler/grappler_item.h",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item.h?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -46,30 +46,30 @@ struct GrapplerItem {\n   // Create a copy of this GrapplerItem with graph swapped with the argument.\n   GrapplerItem WithGraph(GraphDef&& graph) const;\n \n-  string id;  // A unique id for this item\n+  std::string id;  // A unique id for this item\n \n   // Inputs\n   GraphDef graph;\n-  std::vector<std::pair<string, Tensor>> feed;\n-  std::vector<string> fetch;\n+  std::vector<std::pair<std::string, Tensor>> feed;\n+  std::vector<std::string> fetch;\n \n   // Initialization op(s).\n-  std::vector<string> init_ops;\n+  std::vector<std::string> init_ops;\n   // Expected initialization time in seconds, or 0 if unknown\n   int64_t expected_init_time = 0;\n \n   // Save/restore ops (if any)\n-  string save_op;\n-  string restore_op;\n-  string save_restore_loc_tensor;\n+  std::string save_op;\n+  std::string restore_op;\n+  std::string save_restore_loc_tensor;\n \n   // Queue runner(s) required to run the queue(s) of this model.\n   std::vector<QueueRunnerDef> queue_runners;\n \n   // List of op names to keep in the graph. This includes nodes that are\n   // referenced in various collections, and therefore must be preserved to\n   // ensure that the optimized metagraph can still be loaded.\n-  std::vector<string> keep_ops;\n+  std::vector<std::string> keep_ops;\n \n   // Return the set of node evaluated during a regular train/inference step.\n   std::vector<const NodeDef*> MainOpsFanin() const;\n@@ -81,7 +81,7 @@ struct GrapplerItem {\n   std::vector<const NodeDef*> MainVariables() const;\n   // Return a set of node names that must be preserved. This includes feed and\n   // fetch nodes, keep_ops, init_ops.\n-  std::unordered_set<string> NodesToPreserve() const;\n+  std::unordered_set<std::string> NodesToPreserve() const;\n \n   struct OptimizationOptions {\n     // Is it allowed to add nodes to the graph that do not have registered\n@@ -108,11 +108,11 @@ struct GrapplerItem {\n     int intra_op_parallelism_threads = tsl::port::MaxParallelism();\n   };\n \n-  const std::unordered_set<string>& devices() const;\n+  const std::unordered_set<std::string>& devices() const;\n   // Adds a device to a set of available devices, only if it's a valid fully\n   // defined device name. Returns `OkStatus()` if successfully added a device,\n   // and an error otherwise.\n-  absl::Status AddDevice(const string& device);\n+  absl::Status AddDevice(const std::string& device);\n   // Adds all valid devices from the other Grappler item to the device set.\n   absl::Status AddDevices(const GrapplerItem& other);\n   // Adds all valid devices from the nodes of the graph to the device set.\n@@ -132,7 +132,7 @@ struct GrapplerItem {\n   // A set of fully defined device names that can be used to place the nodes of\n   // the `graph`.\n   // Example of a fully defined name: \"/job:work/replica:1/task:1/device:CPU:0\"\n-  std::unordered_set<string> devices_;\n+  std::unordered_set<std::string> devices_;\n \n   OptimizationOptions optimization_options_;\n };"
        },
        {
            "sha": "ee1964096cd7209ea158cccd8166f35997befd76",
            "filename": "tensorflow/core/grappler/grappler_item_builder.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 16,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -95,15 +95,15 @@ absl::Status ReplaceUnknownShapeDim(const ItemConfig& cfg,\n                                     const TensorShapeProto& shape_pb_in,\n                                     TensorShapeProto* shape_pb_out,\n                                     TensorShape* shape_out) {\n-  std::vector<int32> dims;\n+  std::vector<int32_t> dims;\n   for (const auto& dim_proto : shape_pb_in.dim()) {\n     if (cfg.placeholder_unknown_output_shape_dim >= 0 &&\n         dim_proto.size() == -1) {\n       dims.push_back(cfg.placeholder_unknown_output_shape_dim);\n       shape_pb_out->add_dim()->set_size(\n           cfg.placeholder_unknown_output_shape_dim);\n     } else {\n-      dims.push_back(std::max<int32>(1, dim_proto.size()));\n+      dims.push_back(std::max<int32_t>(1, dim_proto.size()));\n       shape_pb_out->add_dim()->set_size(dim_proto.size());\n     }\n   }\n@@ -117,7 +117,7 @@ absl::Status ReplaceUnknownShapeDim(const ItemConfig& cfg,\n // (b/134092018).\n absl::Status UpdatePlaceholderShape(\n     const ItemConfig& cfg,\n-    const std::unordered_set<string>& signature_feed_nodes,\n+    const std::unordered_set<std::string>& signature_feed_nodes,\n     GrapplerItem* new_item, NodeDef* node) {\n   if (node->attr().count(\"dtype\") == 0) {\n     return absl::InternalError(absl::StrCat(\"Unknown type for placeholder \",\n@@ -188,7 +188,7 @@ absl::Status UpdatePlaceholderShape(\n   } else if (cfg.feed_nodes.count(node->name()) > 0) {\n     // If specific feed nodes were given, only update their tensors.\n     auto it = find_if(new_item->feed.begin(), new_item->feed.end(),\n-                      [&node](std::pair<string, Tensor>& f) {\n+                      [&node](std::pair<std::string, Tensor>& f) {\n                         return f.first == node->name();\n                       });\n     DCHECK(it != new_item->feed.end());\n@@ -294,7 +294,8 @@ absl::Status RuntimeGraphOptimizer(const GraphDef& graph_def_arg,\n }\n \n std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n-    const string& id, const MetaGraphDef& meta_graph, const ItemConfig& cfg) {\n+    const std::string& id, const MetaGraphDef& meta_graph,\n+    const ItemConfig& cfg) {\n   if (id.empty()) {\n     LOG(ERROR) << \"id must be non-empty.\";\n     return nullptr;\n@@ -305,7 +306,7 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n \n   // Fill in feed nodes from config, if any provided.\n   for (const auto& feed_node : cfg.feed_nodes) {\n-    const string feed_name = NodeName(feed_node);\n+    const std::string feed_name = NodeName(feed_node);\n     new_item->feed.emplace_back(feed_name, Tensor());\n   }\n   for (const auto& fetch_node : cfg.fetch_nodes) {\n@@ -325,8 +326,8 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n \n   // Detect feed and fetch nodes from signature defs. Signatures may share same\n   // inputs or outputs.\n-  std::unordered_set<string> signature_feed_nodes;\n-  std::unordered_set<string> signature_fetch_nodes;\n+  std::unordered_set<std::string> signature_feed_nodes;\n+  std::unordered_set<std::string> signature_fetch_nodes;\n   for (const auto& name_and_signature : meta_graph.signature_def()) {\n     for (const auto& name_and_input : name_and_signature.second.inputs()) {\n       const TensorInfo& input = name_and_input.second;\n@@ -442,7 +443,7 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n   // have to run restore op first.\n \n   // Try to find initializers from variables and tables as init ops.\n-  for (const string& var_collection :\n+  for (const std::string& var_collection :\n        {\"variables\", \"local_variables\", \"model_variables\",\n         \"trainable_variables\"}) {\n     if (meta_graph.collection_def().count(var_collection) == 0) {\n@@ -476,7 +477,7 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n   // We keep the mapping from asset node to asset files. This should have been\n   // used as feed but since asset node is usually a constant node, we will fill\n   // the values of these constant nodes with their actual asset file paths.\n-  std::unordered_map<string, string> asset_node_to_value;\n+  std::unordered_map<std::string, std::string> asset_node_to_value;\n \n   // Assets file may have changed their directory, we assemble their new paths\n   // if assets_directory_override is set. We also make sure we still can\n@@ -495,8 +496,8 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n               LOG(ERROR) << \"Failed to parse AssetFile.\";\n               continue;\n             }\n-            string asset_filepath = io::JoinPath(cfg.assets_directory_override,\n-                                                 asset_file_def.filename());\n+            std::string asset_filepath = io::JoinPath(\n+                cfg.assets_directory_override, asset_file_def.filename());\n             if (!FilesExist({asset_filepath}, nullptr)) {\n               LOG(ERROR) << \"Can't access one or more of the asset files \"\n                          << asset_filepath << \", skipping this input\";\n@@ -514,7 +515,7 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n   } else if (meta_graph.collection_def().count(\"asset_filepaths\") > 0) {\n     const CollectionDef& file_paths =\n         meta_graph.collection_def().at(\"asset_filepaths\");\n-    std::vector<string> paths;\n+    std::vector<std::string> paths;\n     for (const auto& raw_path : file_paths.bytes_list().value()) {\n       paths.push_back(raw_path);\n     }\n@@ -544,7 +545,7 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n   // Add each node referenced in a collection to the list of nodes to keep.\n   for (const auto& col : meta_graph.collection_def()) {\n     const CollectionDef& collection = col.second;\n-    for (const string& node : collection.node_list().value()) {\n+    for (const std::string& node : collection.node_list().value()) {\n       new_item->keep_ops.push_back(NodeName(node));\n     }\n   }\n@@ -654,7 +655,7 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n   }\n \n   // Validate feed, fetch and init nodes\n-  std::unordered_set<string> nodes;\n+  std::unordered_set<std::string> nodes;\n   for (const auto& node : new_item->graph.node()) {\n     nodes.insert(node.name());\n   }\n@@ -680,7 +681,8 @@ std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n }\n \n std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDefFile(\n-    const string& id, const string& meta_graph_file, const ItemConfig& cfg) {\n+    const std::string& id, const std::string& meta_graph_file,\n+    const ItemConfig& cfg) {\n   MetaGraphDef meta_graph;\n   if (!ReadMetaGraphDefFromFile(meta_graph_file, &meta_graph).ok()) {\n     LOG(ERROR) << \"Failed to read \" << meta_graph_file;"
        },
        {
            "sha": "f16ffef470240a68d38376d237a351f7f460e65a",
            "filename": "tensorflow/core/grappler/grappler_item_builder.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder.h?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -43,13 +43,13 @@ struct ItemConfig {\n   // Has no effect if \"inline_functions\" is disabled.\n   bool erase_noinline_attributes = false;\n   // If non-empty, override the directory of asset paths.\n-  string assets_directory_override;\n+  std::string assets_directory_override;\n   // If true, runs ModelPruner on the graph.\n   bool prune_graph = false;\n   // Override feed nodes list.\n-  std::set<string> feed_nodes;\n+  std::set<std::string> feed_nodes;\n   // Override fetch nodes list.\n-  std::set<string> fetch_nodes;\n+  std::set<std::string> fetch_nodes;\n \n   // Configs for graph optimizations from common_runtime. This is NOT Grappler\n   // function optimizer. When Grappler is invoked at runtime, it is typically\n@@ -71,13 +71,15 @@ absl::Status RuntimeGraphOptimizer(const GraphDef& graph_def_arg,\n // Factory method for creating a GrapplerItem from a MetaGraphDef.\n // Returns nullptr if the given meta_graph cannot be converted.\n std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDef(\n-    const string& id, const MetaGraphDef& meta_graph, const ItemConfig& cfg);\n+    const std::string& id, const MetaGraphDef& meta_graph,\n+    const ItemConfig& cfg);\n \n // Factory method for creating a GrapplerItem from a file\n // containing a MetaGraphDef in either binary or text format.\n // Returns nullptr if the given meta_graph cannot be converted.\n std::unique_ptr<GrapplerItem> GrapplerItemFromMetaGraphDefFile(\n-    const string& id, const string& meta_graph_file, const ItemConfig& cfg);\n+    const std::string& id, const std::string& meta_graph_file,\n+    const ItemConfig& cfg);\n \n }  // end namespace grappler\n }  // end namespace tensorflow"
        },
        {
            "sha": "472909e1790a9129c4ae7e8ec20d1636a9cbc60d",
            "filename": "tensorflow/core/grappler/grappler_item_builder_test.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_builder_test.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -42,19 +42,19 @@ TEST_F(GrapplerItemBuilderTest, AssetFilepathOverrideTest) {\n   Output var =\n       ops::Variable(s.WithOpName(\"var\"), TensorShape(), DataType::DT_FLOAT);\n   Output filename_node =\n-      ops::Const(s.WithOpName(\"filename\"), string(\"model\"), TensorShape());\n+      ops::Const(s.WithOpName(\"filename\"), std::string(\"model\"), TensorShape());\n   Output tensor_name =\n-      ops::Const(s.WithOpName(\"tensorname\"), string(\"var\"), TensorShape());\n+      ops::Const(s.WithOpName(\"tensorname\"), std::string(\"var\"), TensorShape());\n   Output restore = ops::Restore(s.WithOpName(\"restore\"), filename_node,\n                                 tensor_name, DataType::DT_FLOAT);\n   Output assign = ops::Assign(s.WithOpName(\"assign\"), var, restore);\n \n   TF_CHECK_OK(s.ToGraphDef(meta_graph.mutable_graph_def()));\n \n-  string temp_dir = testing::TmpDir();\n+  std::string temp_dir = testing::TmpDir();\n \n   Env *env = Env::Default();\n-  string filename =\n+  std::string filename =\n       io::JoinPath(temp_dir, \"grappler_item_builder_test_filename\");\n   env->DeleteFile(filename).IgnoreError();\n   std::unique_ptr<WritableFile> file_to_write;\n@@ -88,7 +88,7 @@ TEST_F(GrapplerItemBuilderTest, AssetFilepathOverrideTest) {\n       ASSERT_TRUE(iter->second.has_tensor());\n       ASSERT_EQ(1, iter->second.tensor().string_val_size());\n \n-      string tensor_string_val = iter->second.tensor().string_val(0);\n+      std::string tensor_string_val = iter->second.tensor().string_val(0);\n       EXPECT_EQ(tensor_string_val, filename);\n     }\n   }\n@@ -100,12 +100,12 @@ TEST_F(GrapplerItemBuilderTest, AssetFilepathOverrideTest_FileNotAccessible) {\n   tensorflow::Scope s = tensorflow::Scope::NewRootScope();\n   Output var =\n       ops::Variable(s.WithOpName(\"var\"), TensorShape(), DataType::DT_FLOAT);\n-  Output filename_node1 =\n-      ops::Const(s.WithOpName(\"filename1\"), string(\"model1\"), TensorShape());\n-  Output filename_node2 =\n-      ops::Const(s.WithOpName(\"filename2\"), string(\"model2\"), TensorShape());\n+  Output filename_node1 = ops::Const(s.WithOpName(\"filename1\"),\n+                                     std::string(\"model1\"), TensorShape());\n+  Output filename_node2 = ops::Const(s.WithOpName(\"filename2\"),\n+                                     std::string(\"model2\"), TensorShape());\n   Output tensor_name =\n-      ops::Const(s.WithOpName(\"tensorname\"), string(\"var\"), TensorShape());\n+      ops::Const(s.WithOpName(\"tensorname\"), std::string(\"var\"), TensorShape());\n   Output restore1 = ops::Restore(s.WithOpName(\"restore1\"), filename_node1,\n                                  tensor_name, DataType::DT_FLOAT);\n   Output restore2 = ops::Restore(s.WithOpName(\"restore2\"), filename_node1,\n@@ -115,11 +115,11 @@ TEST_F(GrapplerItemBuilderTest, AssetFilepathOverrideTest_FileNotAccessible) {\n \n   TF_CHECK_OK(s.ToGraphDef(meta_graph.mutable_graph_def()));\n \n-  string temp_dir = testing::TmpDir();\n+  std::string temp_dir = testing::TmpDir();\n \n   // Create the first AssetFileDef that has a valid file.\n   Env *env = Env::Default();\n-  string filename1 =\n+  std::string filename1 =\n       io::JoinPath(temp_dir, \"grappler_item_builder_test_filename1\");\n   env->DeleteFile(filename1).IgnoreError();\n   std::unique_ptr<WritableFile> file_to_write;\n@@ -132,7 +132,7 @@ TEST_F(GrapplerItemBuilderTest, AssetFilepathOverrideTest_FileNotAccessible) {\n   *asset_file_def1.mutable_filename() = \"grappler_item_builder_test_filename1\";\n \n   // Create the second AssetFileDef that has not a valid file.\n-  string filename2 =\n+  std::string filename2 =\n       io::JoinPath(temp_dir, \"grappler_item_builder_test_filename1\");\n   env->DeleteFile(filename2).IgnoreError();\n   EXPECT_FALSE(env->FileExists(filename2).ok());"
        },
        {
            "sha": "f023d7f1f6e746f2a24b3f213e73f864906f7044",
            "filename": "tensorflow/core/grappler/grappler_item_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ef2889930568c17c5ee2cf8b50c23d3a85ea7e32/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgrappler_item_test.cc?ref=ef2889930568c17c5ee2cf8b50c23d3a85ea7e32",
            "patch": "@@ -33,11 +33,11 @@ TEST_F(GrapplerItemTest, Basic) {\n \n   EXPECT_TRUE(item.InitOpsFanin().empty());\n \n-  std::vector<string> graph_nodes;\n+  std::vector<std::string> graph_nodes;\n   for (const auto& node : item.graph.node()) {\n     graph_nodes.push_back(node.name());\n   }\n-  std::vector<string> main_ops;\n+  std::vector<std::string> main_ops;\n   for (const auto& node : item.MainOpsFanin()) {\n     main_ops.push_back(node->name());\n   }\n@@ -49,9 +49,9 @@ TEST_F(GrapplerItemTest, Basic) {\n TEST_F(GrapplerItemTest, InferDevices) {\n   using test::function::NDef;\n \n-  const string cpu0 = \"/job:work/replica:1/task:1/device:CPU:0\";\n-  const string cpu1 = \"/job:work/replica:1/task:1/device:CPU:1\";\n-  const string cpu2 = \"/device:CPU:2\";\n+  const std::string cpu0 = \"/job:work/replica:1/task:1/device:CPU:0\";\n+  const std::string cpu1 = \"/job:work/replica:1/task:1/device:CPU:1\";\n+  const std::string cpu2 = \"/device:CPU:2\";\n \n   GrapplerItem item;\n   item.graph = test::function::GDef("
        }
    ],
    "stats": {
        "total": 146,
        "additions": 75,
        "deletions": 71
    }
}