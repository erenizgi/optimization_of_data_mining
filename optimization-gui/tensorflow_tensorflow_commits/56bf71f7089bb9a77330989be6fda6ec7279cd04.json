{
    "author": "cezheng",
    "message": "[PJRT] Add host buffer semantics args to common pjrt client. Also remove redundant thread pool dispatch from BufferFromHostLiteral since the backend impl of LinearizeInto should decide that.\n\nPiperOrigin-RevId: 805131549",
    "sha": "56bf71f7089bb9a77330989be6fda6ec7279cd04",
    "files": [
        {
            "sha": "bd25f8630709b130fe8611e0111140f90a5a6547",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 43,
            "changes": 64,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=56bf71f7089bb9a77330989be6fda6ec7279cd04",
            "patch": "@@ -141,48 +141,20 @@ CommonPjRtClient::BufferFromHostLiteral(const LiteralSlice& literal,\n   TF_ASSIGN_OR_RETURN(\n       Shape device_shape,\n       MakeDefaultShapeForMemorySpace(memory_space, shape, device_layout));\n+  TF_ASSIGN_OR_RETURN(int64_t on_device_bytes_count,\n+                      GetOnDeviceBytesCount(memory_space, device_shape));\n+  TF_ASSIGN_OR_RETURN(auto raw_buffer,\n+                      AllocateRawBuffer(memory_space, on_device_bytes_count,\n+                                        /*retry_on_oom=*/true,\n+                                        /*allocate_after=*/{}));\n   TF_ASSIGN_OR_RETURN(\n-      auto promise_and_event,\n-      CreateLinkedEventPromise(memory_space, \"BufferFromHostLiteral\"));\n-  tsl::RCReference<CommonPjRtRawBuffer> raw_buffer;\n-  std::unique_ptr<PjRtBuffer> output_buffer;\n-  absl::Status s = [&]() {\n-    TF_ASSIGN_OR_RETURN(int64_t on_device_bytes_count,\n-                        GetOnDeviceBytesCount(memory_space, device_shape));\n-    TF_ASSIGN_OR_RETURN(raw_buffer,\n-                        AllocateRawBuffer(memory_space, on_device_bytes_count,\n-                                          /*retry_on_oom=*/true,\n-                                          /*allocate_after=*/{}));\n-    TF_ASSIGN_OR_RETURN(output_buffer,\n-                        DefineBuffer(device_shape, raw_buffer,\n-                                     {std::move(promise_and_event.second)},\n-                                     /*raw_buffer_is_mutable=*/true));\n-    return absl::OkStatus();\n-  }();\n-  if (!s.ok()) {\n-    promise_and_event.first->SetError(s);\n-    return s;\n-  }\n-\n-  async_work_runner()->Schedule(\n-      [this, shape, literal, raw_buffer = std::move(raw_buffer),\n-       definition_event = std::move(promise_and_event.first),\n-       device_layout = device_shape.layout(),\n-       context_id = producer.GetContextId()]() mutable {\n-        tsl::profiler::TraceMeConsumer consumer(\n-            \"BufferFromHostLiteral H2D Dispatch\",\n-            tsl::profiler::ContextType::kPjRt, context_id);\n-        auto status_or_h2d_transfer_event =\n-            LinearizeInto(literal, device_layout, std::move(raw_buffer));\n-        CHECK_OK(status_or_h2d_transfer_event);\n-        auto h2d_transfer_event = *std::move(status_or_h2d_transfer_event);\n-        if (event_tracking_enabled()) {\n-          h2d_transfer_event->AppendDescriptionToEvent(\n-              \" TransferToDevice \", {definition_event.get()});\n-        }\n-        definition_event->Set(std::move(h2d_transfer_event));\n-      });\n-  return output_buffer;\n+      auto definition_event,\n+      LinearizeInto(literal, device_shape.layout(),\n+                    HostBufferSemantics::kImmutableUntilTransferCompletes,\n+                    raw_buffer));\n+  return DefineBuffer(device_shape, std::move(raw_buffer),\n+                      {std::move(definition_event)},\n+                      /*raw_buffer_is_mutable=*/true);\n }\n \n absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n@@ -427,14 +399,18 @@ CommonPjRtBufferImpl::CopyToCpuMemorySpace(const xla::Shape& dst_shape,\n           status_or_h2d_transfer_event;\n       if (needs_second_copy) {\n         status_or_h2d_transfer_event = dst_client->LinearizeInto(\n-            *literal, dst_shape.layout(), dst_raw_buffer);\n+            *literal, dst_shape.layout(),\n+            PjRtClient::HostBufferSemantics::kImmutableUntilTransferCompletes,\n+            dst_raw_buffer);\n       } else {\n         status_or_h2d_transfer_event =\n             dst_raw_buffer->MakeAllocationReadyEvent();\n       }\n       if (!status_or_h2d_transfer_event.ok()) {\n         definition_event_promise->SetError(status);\n       } else {\n+        status_or_h2d_transfer_event.value()->AndThen(\n+            [literal = std::move(literal)] {});\n         definition_event_promise->Set(*std::move(status_or_h2d_transfer_event));\n       }\n     }\n@@ -637,7 +613,9 @@ CommonPjRtBufferImpl::CopyFromCpuToMemorySpace(\n               std::make_unique<MutableBorrowingLiteral>(\n                   reinterpret_cast<char*>(base_ptr), src_shape);\n           auto status_or_h2d_transfer_event = dst_client->LinearizeInto(\n-              *literal, device_layout, std::move(dst_raw_buffer));\n+              *literal, device_layout,\n+              PjRtClient::HostBufferSemantics::kImmutableUntilTransferCompletes,\n+              std::move(dst_raw_buffer));\n           CHECK_OK(status_or_h2d_transfer_event);\n           auto h2d_transfer_event = *std::move(status_or_h2d_transfer_event);\n           h2d_transfer_event->AndThen("
        },
        {
            "sha": "5b53e771d815d67de99244fef6d9bae52df962b1",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.h?ref=56bf71f7089bb9a77330989be6fda6ec7279cd04",
            "patch": "@@ -74,6 +74,7 @@ class CommonPjRtClient : public PjRtClient {\n   // for when the linearization is complete.\n   virtual absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>> LinearizeInto(\n       const LiteralSlice& literal, const xla::Layout& layout,\n+      HostBufferSemantics host_buffer_semantics,\n       tsl::RCReference<CommonPjRtRawBuffer> raw_buffer) {\n     return absl::UnimplementedError(\"LinearizeInto is not supported\");\n   }"
        },
        {
            "sha": "41a617c6bdf561f170d0a8e4ce1eb94ad3d972b4",
            "filename": "third_party/xla/xla/pjrt/cpu/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD?ref=56bf71f7089bb9a77330989be6fda6ec7279cd04",
            "patch": "@@ -143,10 +143,8 @@ cc_library(\n         \":cpu_device\",\n         \":cpu_event\",\n         \"//xla:array\",\n-        \"//xla:cpu_function_runtime\",\n         \"//xla:debug_options_flags\",\n         \"//xla:executable_run_options\",\n-        \"//xla:execution_options_util\",\n         \"//xla:literal\",\n         \"//xla:literal_util\",\n         \"//xla:shape_util\",\n@@ -174,7 +172,6 @@ cc_library(\n         \"//xla/pjrt:layout_mode\",\n         \"//xla/pjrt:mlir_to_hlo\",\n         \"//xla/pjrt:pjrt_client\",\n-        \"//xla/pjrt:pjrt_client_utils\",\n         \"//xla/pjrt:pjrt_common\",\n         \"//xla/pjrt:pjrt_compiler\",\n         \"//xla/pjrt:pjrt_executable\",\n@@ -194,8 +191,6 @@ cc_library(\n         \"//xla/service:buffer_assignment\",\n         \"//xla/service:compiler\",\n         \"//xla/service:computation_placer_hdr\",\n-        \"//xla/service:custom_call_status_internal\",\n-        \"//xla/service:custom_call_status_public_headers\",\n         \"//xla/service:dump\",\n         \"//xla/service:executable\",\n         \"//xla/service:hlo_cost_analysis\",\n@@ -235,8 +230,6 @@ cc_library(\n         \"@local_tsl//tsl/platform:denormal\",\n         \"@local_tsl//tsl/platform:fingerprint\",\n         \"@local_tsl//tsl/platform:setround\",\n-        \"@local_tsl//tsl/profiler/lib:connected_traceme\",\n-        \"@local_tsl//tsl/profiler/lib:context_types_hdrs\",\n         \"@local_tsl//tsl/profiler/lib:traceme\",\n     ],\n )"
        },
        {
            "sha": "4a60aabfc791b48b97e25f2429ae9b3808b4100b",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=56bf71f7089bb9a77330989be6fda6ec7279cd04",
            "patch": "@@ -945,7 +945,13 @@ PjRtCpuClient::LinearizeHostBufferInto(\n \n absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>> PjRtCpuClient::LinearizeInto(\n     const LiteralSlice& literal, const xla::Layout& layout,\n+    HostBufferSemantics host_buffer_semantics,\n     tsl::RCReference<CommonPjRtRawBuffer> raw_buffer) {\n+  if (host_buffer_semantics ==\n+      PjRtClient::HostBufferSemantics::kImmutableOnlyDuringCall) {\n+    return absl::UnimplementedError(\n+        \"ImmutableOnlyDuringCall semantics is not supported on CPU.\");\n+  }\n   return tsl::down_cast<CpuRawBuffer*>(raw_buffer.get())\n       ->CopyFromLiteral(literal, layout, async_work_runner());\n }"
        },
        {
            "sha": "1fbed0fc2bf19c7979f31161c26e15dfef1f928f",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.h?ref=56bf71f7089bb9a77330989be6fda6ec7279cd04",
            "patch": "@@ -228,6 +228,7 @@ class PjRtCpuClient final : public CommonPjRtClient {\n \n   absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>> LinearizeInto(\n       const LiteralSlice& literal, const xla::Layout& layout,\n+      HostBufferSemantics host_buffer_semantics,\n       tsl::RCReference<CommonPjRtRawBuffer> raw_buffer) override;\n \n   absl::StatusOr<xla::Shape> MakeDefaultShapeForMemorySpace("
        },
        {
            "sha": "23e52b1c80d0b66f26e7e78173e28f552b0446bf",
            "filename": "third_party/xla/xla/pjrt/host_to_device_transfer_manager.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 53,
            "changes": 94,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_to_device_transfer_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/56bf71f7089bb9a77330989be6fda6ec7279cd04/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_to_device_transfer_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_to_device_transfer_manager.cc?ref=56bf71f7089bb9a77330989be6fda6ec7279cd04",
            "patch": "@@ -248,60 +248,48 @@ class CommonAsyncHostToDeviceTransferManager\n     tsl::profiler::TraceMeProducer producer(\"TransferLiteralToBuffer\",\n                                             tsl::profiler::ContextType::kPjRt);\n \n-    // The host to device transfer is performed on a thread pool, mostly because\n-    // it includes linearization that may be slow.\n-    // TODO(misard) assess if it would be preferable to introduce a heuristic to\n-    // put the transfer into the calling thread for small literals.\n-    async_work_runner_->Schedule(\n-        [this, buffer_index, literal, raw_buffer = std::move(raw_buffer),\n-         definition_event = std::move(definition_event),\n-         on_done = std::move(on_done),\n-         context_id = producer.GetContextId()]() mutable {\n-          tsl::profiler::TraceMeConsumer consumer(\n-              \"TransferLiteralToBuffer H2D Dispatch\",\n-              tsl::profiler::ContextType::kPjRt, context_id);\n-          auto status_or_h2d_transfer_event = client_->LinearizeInto(\n-              literal, device_shapes_[buffer_index].layout(), raw_buffer);\n-          CHECK_OK(status_or_h2d_transfer_event);\n-          auto h2d_transfer_event = *std::move(status_or_h2d_transfer_event);\n-          if (client_->event_tracking_enabled()) {\n-            h2d_transfer_event->AppendDescriptionToEvent(\n-                \" TransferToDevice TransferLiteralToBuffer\",\n-                {definition_event.get()});\n-          }\n+    TF_ASSIGN_OR_RETURN(\n+        auto h2d_transfer_event,\n+        client_->LinearizeInto(\n+            literal, device_shapes_[buffer_index].layout(),\n+            PjRtClient::HostBufferSemantics::kImmutableUntilTransferCompletes,\n+            raw_buffer));\n+    if (client_->event_tracking_enabled()) {\n+      h2d_transfer_event->AppendDescriptionToEvent(\n+          \" TransferToDevice TransferLiteralToBuffer\",\n+          {definition_event.get()});\n+    }\n \n-          auto cleanup = [this, buffer_index,\n-                          transfer_event = h2d_transfer_event,\n-                          definition_event = std::move(definition_event),\n-                          on_done = std::move(on_done)]() mutable {\n-            {\n-              absl::MutexLock l(&mu_);\n-\n-              CHECK_GT(transfers_in_flight_, 0);\n-              --transfers_in_flight_;\n-              CHECK_EQ(buffer_transfers_in_flight_[buffer_index], 1);\n-              --buffer_transfers_in_flight_[buffer_index];\n-              CHECK_GT(remaining_buffer_count_, 0);\n-              --remaining_buffer_count_;\n-            }\n-\n-            // Call on_done after finishing all housekeeping and releasing the\n-            // lock.\n-            //\n-            // NOTE: on_done may call ~AsyncHostToDeviceTransferManager(), so we\n-            // don't touch any class members after this point.\n-            std::move(on_done)();\n-\n-            // Unblock the definition event after calling on_done, just in case\n-            // the caller wanted some serialization between finding out about\n-            // the buffers becoming available and them being released.\n-            CHECK(definition_event);\n-            // Dependency of event on transfer_event was recorded above in\n-            // AppendDescriptionToEvent.\n-            definition_event->Set(std::move(transfer_event));\n-          };\n-          h2d_transfer_event->AndThen(std::move(cleanup));\n-        });\n+    auto cleanup = [this, buffer_index, transfer_event = h2d_transfer_event,\n+                    definition_event = std::move(definition_event),\n+                    on_done = std::move(on_done)]() mutable {\n+      {\n+        absl::MutexLock l(&mu_);\n+\n+        CHECK_GT(transfers_in_flight_, 0);\n+        --transfers_in_flight_;\n+        CHECK_EQ(buffer_transfers_in_flight_[buffer_index], 1);\n+        --buffer_transfers_in_flight_[buffer_index];\n+        CHECK_GT(remaining_buffer_count_, 0);\n+        --remaining_buffer_count_;\n+      }\n+\n+      // Call on_done after finishing all housekeeping and releasing the\n+      // lock.\n+      //\n+      // NOTE: on_done may call ~AsyncHostToDeviceTransferManager(), so we\n+      // don't touch any class members after this point.\n+      std::move(on_done)();\n+\n+      // Unblock the definition event after calling on_done, just in case\n+      // the caller wanted some serialization between finding out about\n+      // the buffers becoming available and them being released.\n+      CHECK(definition_event);\n+      // Dependency of event on transfer_event was recorded above in\n+      // AppendDescriptionToEvent.\n+      definition_event->Set(std::move(transfer_event));\n+    };\n+    h2d_transfer_event->AndThen(std::move(cleanup));\n \n     return absl::OkStatus();\n   }"
        }
    ],
    "stats": {
        "total": 173,
        "additions": 70,
        "deletions": 103
    }
}