{
    "author": "WillFroom",
    "message": "[XLA:CPU][XTile] Move CreateSimplifyArithPass to also be part of the tiled lowering.\n\nPiperOrigin-RevId: 833377700",
    "sha": "26600e2deca823b096b8a6bdc344fdab046951ef",
    "files": [
        {
            "sha": "5b829b15d8119c718a4b02381379f94977fb68f2",
            "filename": "third_party/xla/xla/backends/cpu/codegen/fusion_compiler.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/26600e2deca823b096b8a6bdc344fdab046951ef/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ffusion_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/26600e2deca823b096b8a6bdc344fdab046951ef/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ffusion_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ffusion_compiler.cc?ref=26600e2deca823b096b8a6bdc344fdab046951ef",
            "patch": "@@ -188,7 +188,10 @@ static std::unique_ptr<::mlir::Pass> CreateConvertMathToLLVMPass() {\n // The final lowering passes common to both scalar and tiled kernels.\n // These passes are primarily responsible for lowering individual ops to\n // their LLVM equivalent.\n-static void AddGenericLoweringPasses(mlir::OpPassManager& pm) {\n+static void AddGenericLoweringPasses(mlir::OpPassManager& pm,\n+                                     bool fast_min_max) {\n+  pm.addNestedPass<mlir::func::FuncOp>(\n+      emitters::CreateSimplifyArithPass(fast_min_max));\n   pm.addPass(emitters::CreateSimplifyAffinePass());\n   pm.addPass(mlir::createCanonicalizerPass());\n \n@@ -275,9 +278,8 @@ static void AddScalarLoweringPasses(mlir::OpPassManager& pm,\n   // simplify-affine has maximally folded expressions to work with.\n   pm.addPass(mlir::createCanonicalizerPass());\n   pm.addPass(mlir::createCSEPass());\n-  pm.addNestedPass<mlir::func::FuncOp>(\n-      emitters::CreateSimplifyArithPass(fast_min_max));\n-  AddGenericLoweringPasses(pm);\n+\n+  AddGenericLoweringPasses(pm, fast_min_max);\n }\n \n static void AddBufferizationPasses(mlir::OpPassManager& pm) {\n@@ -328,7 +330,7 @@ static void AddTiledOptimizationPasses(mlir::OpPassManager& pm) {\n // Lowering passes for the tiled emitter.\n // The input IR is from the xtile dialect which uses tensors that are converted\n // first to the vector dialect and then to LLVM.\n-static void AddTiledLoweringPasses(mlir::OpPassManager& pm) {\n+static void AddTiledLoweringPasses(mlir::OpPassManager& pm, bool fast_min_max) {\n   pm.addPass(cpu::CreateMemrefCopyToLoopsPass());\n   pm.addPass(cpu::createLowerToLLVMPass());\n   pm.addPass(mlir::createConvertVectorToSCFPass(\n@@ -341,7 +343,7 @@ static void AddTiledLoweringPasses(mlir::OpPassManager& pm) {\n   pm.addPass(mlir::createConvertComplexToStandardPass());\n   pm.addPass(mlir::memref::createExpandStridedMetadataPass());\n \n-  AddGenericLoweringPasses(pm);\n+  AddGenericLoweringPasses(pm, fast_min_max);\n }\n \n static int GetLlvmFunctionDefCount(mlir::ModuleOp m) {\n@@ -391,7 +393,7 @@ FusionCompiler::FusionCompiler(mlir::MLIRContext* context, Options options,\n     tiled_pass_manager_.addPass(\n         std::make_unique<ModuleCallbackPass>(hooks_.post_optimization));\n   }\n-  AddTiledLoweringPasses(tiled_pass_manager_);\n+  AddTiledLoweringPasses(tiled_pass_manager_, options_.fast_min_max);\n \n   scalar_pass_manager_.addInstrumentation(\n       std::make_unique<TraceInstrumentation>());\n@@ -451,6 +453,9 @@ absl::StatusOr<std::unique_ptr<llvm::Module>> FusionCompiler::Compile(\n       mlir_module, llvm_context,\n       absl::StrCat(kXlaModuleIdentifier, \"_\", module_name));\n \n+  TF_RET_CHECK(llvm_module != nullptr)\n+      << \"Failed to translate module to LLVM IR.\";\n+\n   if (mlir::Attribute options =\n           mlir_module->getAttr(xla::ExtraBackendOptionsAttr::name)) {\n     const auto formatter = [](std::string* out, const mlir::StringAttr& attr) {\n@@ -470,9 +475,6 @@ absl::StatusOr<std::unique_ptr<llvm::Module>> FusionCompiler::Compile(\n                               mlir::cast<mlir::StringAttr>(options).str());\n   }\n \n-  TF_RET_CHECK(llvm_module != nullptr)\n-      << \"Failed to translate module to LLVM IR.\";\n-\n   llvm_module->setDataLayout(llvm_module->getDataLayout());\n \n   if (options_.fast_math_flags.any()) {"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 12,
        "deletions": 10
    }
}