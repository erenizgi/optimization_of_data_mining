{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832859096",
    "sha": "d90e3192640e0286591f810139817e213f8409e5",
    "files": [
        {
            "sha": "b4181ad695d80f47cc6ff3d878ae849a2ea9155e",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/rpc/grpc_channel_common.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_channel_common.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_channel_common.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_channel_common.h?ref=d90e3192640e0286591f810139817e213f8409e5",
            "patch": "@@ -42,7 +42,7 @@ class GenericCachingChannelCache : public ChannelCacheT {\n \n   ~GenericCachingChannelCache() override {}\n \n-  SharedGrpcChannelPtr FindWorkerChannel(const string& target) override {\n+  SharedGrpcChannelPtr FindWorkerChannel(const std::string& target) override {\n     {\n       absl::MutexLock l(mu_);\n       auto iter = channels_.find(target);\n@@ -60,7 +60,7 @@ class GenericCachingChannelCache : public ChannelCacheT {\n \n     {\n       absl::MutexLock l(mu_);\n-      typename absl::flat_hash_map<string, ChannelState>::iterator iter;\n+      typename absl::flat_hash_map<std::string, ChannelState>::iterator iter;\n       bool was_inserted;\n       std::tie(iter, was_inserted) = channels_.insert({target, new_chan_state});\n       VLOG(2) << \"Channel cache for target: \" << target\n@@ -74,7 +74,7 @@ class GenericCachingChannelCache : public ChannelCacheT {\n   // Find the ClientChannel for \"target\".  Only called when no channel was\n   // found in the channels_ cache for \"target\".  A non nullptr result will be\n   // cached in channels_.\n-  virtual SharedGrpcChannelPtr FindChannelOnce(const string& target) = 0;\n+  virtual SharedGrpcChannelPtr FindChannelOnce(const std::string& target) = 0;\n \n  private:\n   struct ChannelState {\n@@ -96,7 +96,7 @@ class GenericCachingChannelCache : public ChannelCacheT {\n   const int num_channels_per_target_;\n   // TODO(zhifengc): Eviction when the map becomes too big.\n   absl::Mutex mu_;\n-  absl::flat_hash_map<string, ChannelState> channels_ TF_GUARDED_BY(mu_);\n+  absl::flat_hash_map<std::string, ChannelState> channels_ TF_GUARDED_BY(mu_);\n };\n \n }  // namespace tsl"
        },
        {
            "sha": "235b4d98391c170b5f57b958d162283223ef1eba",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/rpc/grpc_state.h",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_state.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_state.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_state.h?ref=d90e3192640e0286591f810139817e213f8409e5",
            "patch": "@@ -50,7 +50,7 @@ class RPCState : public GrpcClientCQTag {\n       const ::grpc::string& method, const protobuf::Message& request,\n       Response* response, StatusCallback done, CallOptions* call_opts,\n       thread::ThreadPool* threadpool, int32_t max_retries = 0,\n-      bool fail_fast = true, const string* target = nullptr,\n+      bool fail_fast = true, const std::string* target = nullptr,\n       std::function<bool(::grpc::ByteBuffer*, Response*)> parse_proto_fn =\n           [](::grpc::ByteBuffer* src, Response* dst) {\n             return tsl::GrpcMaybeParseProto(src, dst);\n@@ -69,18 +69,19 @@ class RPCState : public GrpcClientCQTag {\n             // on worker task failures, except a few cases such as GetStatus\n             // in cluster initialization and collective param resolution.\n             [fail_fast, &done]() -> bool {\n-              string fail_fast_env;\n+              std::string fail_fast_env;\n               TF_CHECK_OK(ReadStringFromEnvVar(\"GRPC_FAIL_FAST\", \"use_caller\",\n                                                &fail_fast_env));\n-              string fail_fast_env_lower = absl::AsciiStrToLower(fail_fast_env);\n+              std::string fail_fast_env_lower =\n+                  absl::AsciiStrToLower(fail_fast_env);\n               if (fail_fast_env_lower == \"true\") {\n                 return true;\n               } else if (fail_fast_env_lower == \"use_caller\") {\n                 return fail_fast;\n               } else if (fail_fast_env_lower == \"false\") {\n                 return false;\n               } else {\n-                string error_message = absl::StrCat(\n+                std::string error_message = absl::StrCat(\n                     \"Invalid GRPC_FAIL_FAST config: \", fail_fast_env);\n                 LOG(WARNING) << error_message;\n                 done(errors::InvalidArgument(error_message));\n@@ -96,7 +97,7 @@ class RPCState : public GrpcClientCQTag {\n       const ::grpc::string& method, const Request& request, Response* response,\n       StatusCallback done, CallOptions* call_opts,\n       thread::ThreadPool* threadpool, bool fail_fast, int64_t timeout_in_ms,\n-      int32_t max_retries, const string* target,\n+      int32_t max_retries, const std::string* target,\n       std::function<bool(::grpc::ByteBuffer*, Response*)> parse_proto_fn =\n           [](::grpc::ByteBuffer* src, Response* dst) {\n             return tsl::GrpcMaybeParseProto(src, dst);\n@@ -186,7 +187,7 @@ class RPCState : public GrpcClientCQTag {\n                                         [this]() { StartCall(); });\n     } else {\n       // Attach additional GRPC error information if any to the final status\n-      string error_msg = std::string(s.message());\n+      std::string error_msg = std::string(s.message());\n       absl::StrAppend(&error_msg, \"\\nAdditional GRPC error information\");\n       if (target_) {\n         absl::StrAppend(&error_msg, \" from remote target \", *target_);\n@@ -247,7 +248,7 @@ class RPCState : public GrpcClientCQTag {\n   ::grpc::GenericStub* stub_;\n   ::grpc::string method_;\n   bool fail_fast_;\n-  const string* target_;\n+  const std::string* target_;\n   std::function<bool(::grpc::ByteBuffer*, Response*)> parse_proto_fn_ = nullptr;\n };\n }  // namespace tsl"
        },
        {
            "sha": "cb86ac69ce38e2f274c434bbe0dbc7413827a547",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/rpc/grpc_util.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util.cc?ref=d90e3192640e0286591f810139817e213f8409e5",
            "patch": "@@ -39,15 +39,16 @@ bool GrpcMaybeParseProto(::grpc::ByteBuffer* src, protobuf::Message* dst) {\n \n // GrpcMaybeUnparseProto from a string simply copies the string to the\n // ByteBuffer.\n-::grpc::Status GrpcMaybeUnparseProto(const string& src, grpc::ByteBuffer* dst) {\n+::grpc::Status GrpcMaybeUnparseProto(const std::string& src,\n+                                     grpc::ByteBuffer* dst) {\n   ::grpc::Slice s(src.data(), src.size());\n   ::grpc::ByteBuffer buffer(&s, 1);\n   dst->Swap(&buffer);\n   return ::grpc::Status::OK;\n }\n \n // GrpcMaybeParseProto simply copies bytes into the string.\n-bool GrpcMaybeParseProto(grpc::ByteBuffer* src, string* dst) {\n+bool GrpcMaybeParseProto(grpc::ByteBuffer* src, std::string* dst) {\n   dst->clear();\n   dst->reserve(src->Length());\n   std::vector<::grpc::Slice> slices;"
        },
        {
            "sha": "7830312c6d482906757311ee2e573b40e4d0f750",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/rpc/grpc_util.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util.h?ref=d90e3192640e0286591f810139817e213f8409e5",
            "patch": "@@ -98,8 +98,8 @@ inline ::grpc::Status ToGrpcStatus(const absl::Status& s) {\n   } else {\n     if (s.message().size() > 3072 /* 3k bytes */) {\n       // TODO(b/62947679): Remove truncation once the gRPC issue is resolved.\n-      string scratch = strings::Printf(\"%.3072s ... [truncated]\",\n-                                       absl::StatusMessageAsCStr(s));\n+      std::string scratch = strings::Printf(\"%.3072s ... [truncated]\",\n+                                            absl::StatusMessageAsCStr(s));\n       LOG(ERROR) << \"Truncated error message: \" << s;\n       return ::grpc::Status(static_cast<::grpc::StatusCode>(s.code()), scratch,\n                             SerializePayloads(s));\n@@ -119,11 +119,11 @@ ::grpc::Status GrpcMaybeUnparseProto(const protobuf::Message& src,\n bool GrpcMaybeParseProto(::grpc::ByteBuffer* src, protobuf::Message* dst);\n \n // Copy string src to grpc buffer *dst.\n-::grpc::Status GrpcMaybeUnparseProto(const string& src,\n+::grpc::Status GrpcMaybeUnparseProto(const std::string& src,\n                                      ::grpc::ByteBuffer* dst);\n \n // Copy grpc buffer src to string *dst.\n-bool GrpcMaybeParseProto(::grpc::ByteBuffer* src, string* dst);\n+bool GrpcMaybeParseProto(::grpc::ByteBuffer* src, std::string* dst);\n \n // Copy grpc buffer src to tstring *dst.\n bool GrpcMaybeParseProto(::grpc::ByteBuffer* src, tstring* dst);"
        },
        {
            "sha": "61832e333c76c65d366a9d87f5b5309ddb8a590a",
            "filename": "third_party/xla/xla/tsl/distributed_runtime/rpc/grpc_util_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d90e3192640e0286591f810139817e213f8409e5/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fdistributed_runtime%2Frpc%2Fgrpc_util_test.cc?ref=d90e3192640e0286591f810139817e213f8409e5",
            "patch": "@@ -32,18 +32,18 @@ namespace {\n using tsl::proto_testing::EqualsProto;\n using tsl::test::TestRequest;\n \n-string ToString(const grpc::ByteBuffer& buf) {\n+std::string ToString(const grpc::ByteBuffer& buf) {\n   std::vector<grpc::Slice> slices;\n   CHECK(buf.Dump(&slices).ok());\n-  string result;\n+  std::string result;\n   for (const grpc::Slice& s : slices) {\n     result.append(reinterpret_cast<const char*>(s.begin()), s.size());\n   }\n   return result;\n }\n \n // Return a ByteBuffer that contains str split up into num_slices slices.\n-grpc::ByteBuffer MakeBuffer(const string& str, int num_slices) {\n+grpc::ByteBuffer MakeBuffer(const std::string& str, int num_slices) {\n   // Convert to a ByteBuffer.\n   std::vector<::grpc::Slice> slices;\n   const size_t per_slice = (str.size() + num_slices - 1) / num_slices;\n@@ -65,7 +65,7 @@ TestRequest MakeProto(int size) {\n   int index = 0;\n   while (approx_size < size) {\n     int item_size = std::min(size - approx_size, 1024);\n-    proto.add_data(string(item_size, 'a' + static_cast<char>(index % 26)));\n+    proto.add_data(std::string(item_size, 'a' + static_cast<char>(index % 26)));\n     approx_size += item_size + 3;  // +3 for encoding overhead.\n     index++;\n   }\n@@ -105,7 +105,7 @@ TEST(GrpcProto, UnparseToString) {\n   TestRequest proto;\n   proto.add_data(\"hello\");\n   proto.add_data(\"world\");\n-  string str;\n+  std::string str;\n   CHECK(proto.SerializeToString(&str));\n   grpc::ByteBuffer buf;\n   ASSERT_TRUE(GrpcMaybeUnparseProto(str, &buf).ok());\n@@ -153,7 +153,7 @@ TEST(GrpcProto, ParseFromString) {\n        }) {\n     TestRequest proto = MakeProto(c.length);\n     ::grpc::ByteBuffer src = MakeBuffer(proto.SerializeAsString(), c.slices);\n-    string parsed_str;\n+    std::string parsed_str;\n     TestRequest parsed;\n     ASSERT_TRUE(GrpcMaybeParseProto(&src, &parsed_str))\n         << c.length << \" \" << c.slices;\n@@ -179,7 +179,7 @@ static void BM_UnparseString(::testing::benchmark::State& state) {\n   auto proto = MakeProto(size);\n \n   for (auto s : state) {\n-    string buf;\n+    std::string buf;\n     proto.SerializeToString(&buf);\n   }\n }\n@@ -207,7 +207,7 @@ static void BM_ParseString(::testing::benchmark::State& state) {\n   const int size = state.range(0);\n \n   TestRequest proto = MakeProto(size);\n-  string serial = proto.SerializeAsString();\n+  std::string serial = proto.SerializeAsString();\n \n   for (auto s : state) {\n     CHECK(proto.ParseFromString(serial));"
        }
    ],
    "stats": {
        "total": 52,
        "additions": 27,
        "deletions": 25
    }
}