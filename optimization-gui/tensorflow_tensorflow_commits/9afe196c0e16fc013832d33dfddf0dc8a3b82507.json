{
    "author": "unknown",
    "message": "[XLA] Add BufferUse::ContentValidity, remove MemoryAccess::kReadWrite\n\nRemove kReadWrite, which has no use for memory access tracking. Instead, add\nContentValidity as a separate field in BufferUse, that represents whether the\nbuffer has defined contents at thunk execution start/end.\n\nPiperOrigin-RevId: 816183462",
    "sha": "9afe196c0e16fc013832d33dfddf0dc8a3b82507",
    "files": [
        {
            "sha": "baee061d9c59a96526c9746fa9ab2a8836659ae2",
            "filename": "third_party/xla/xla/runtime/buffer_use.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9afe196c0e16fc013832d33dfddf0dc8a3b82507/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9afe196c0e16fc013832d33dfddf0dc8a3b82507/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use.cc?ref=9afe196c0e16fc013832d33dfddf0dc8a3b82507",
            "patch": "@@ -26,14 +26,10 @@ BufferUse::ReadWriteSet::ReadWriteSet() = default;\n \n void BufferUse::ReadWriteSet::Add(BufferUse use) {\n   switch (use.access()) {\n-    case BufferUse::kRead:\n+    case BufferUse::MemoryAccess::kRead:\n       AddRead(use.slice());\n       break;\n-    case BufferUse::kWrite:\n-      AddWrite(use.slice());\n-      break;\n-    case BufferUse::kReadWrite:\n-      AddRead(use.slice());\n+    case BufferUse::MemoryAccess::kWrite:\n       AddWrite(use.slice());\n       break;\n   }\n@@ -48,7 +44,9 @@ void BufferUse::ReadWriteSet::AddWrite(BufferAllocation::Slice slice) {\n }\n \n void BufferUse::ReadWriteSet::AddAll(absl::Span<const BufferUse> uses) {\n-  for (const auto& use : uses) Add(use);\n+  for (const auto& use : uses) {\n+    Add(use);\n+  }\n }\n \n bool BufferUse::ReadWriteSet::HasConflicts(const BufferUse& use) const {\n@@ -61,8 +59,9 @@ bool BufferUse::ReadWriteSet::HasConflicts(const BufferUse& use) const {\n            });\n   };\n \n-  return use.HasWriteAccess() ? overlaps(write_, use) || overlaps(read_, use)\n-                              : overlaps(write_, use);\n+  return use.access() == MemoryAccess::kWrite\n+             ? overlaps(write_, use) || overlaps(read_, use)\n+             : overlaps(write_, use);\n }\n \n bool BufferUse::ReadWriteSet::HasConflicts(const ReadWriteSet& other) {"
        },
        {
            "sha": "b0b23af59a06e883da8b89399ea58f65b568d28c",
            "filename": "third_party/xla/xla/runtime/buffer_use.h",
            "status": "modified",
            "additions": 59,
            "deletions": 19,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9afe196c0e16fc013832d33dfddf0dc8a3b82507/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9afe196c0e16fc013832d33dfddf0dc8a3b82507/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use.h?ref=9afe196c0e16fc013832d33dfddf0dc8a3b82507",
            "patch": "@@ -17,7 +17,7 @@ limitations under the License.\n #define XLA_RUNTIME_BUFFER_USE_H_\n \n #include <cstdint>\n-#include <string>\n+#include <tuple>\n \n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/types/span.h\"\n@@ -33,37 +33,73 @@ namespace xla {\n //   thunk. This is used to detect non-deterministic behavior via checksumming.\n class BufferUse {\n  public:\n-  enum class MemoryAccess : uint32_t {\n-    kRead = 1 << 0,\n-    kWrite = 1 << 1,\n-    kReadWrite = kRead | kWrite,\n+  enum class MemoryAccess {\n+    // The buffer is only read.\n+    kRead,\n+    // The buffer is read and written to.\n+    kWrite,\n   };\n \n   static constexpr MemoryAccess kRead = MemoryAccess::kRead;\n   static constexpr MemoryAccess kWrite = MemoryAccess::kWrite;\n-  static constexpr MemoryAccess kReadWrite = MemoryAccess::kReadWrite;\n+\n+  // Flags that indicate whether the contents of a buffer are defined before and\n+  // after execution of a thunk.\n+  enum class ContentValidity : uint32_t {\n+    // The thunk uses the buffer as a scratch space. There are no guarantees\n+    // about the buffer's contents outside of the thunk's execution.\n+    kUndefined = 0,\n+    // The buffer is initialized when thunk starts execution. This is the case\n+    // for parameters.\n+    kDefinedOnInput = 1 << 0,\n+    // The buffer is initialized when thunk finishes execution. This is the case\n+    // for outputs and parameters the thunk does not modify.\n+    kDefinedOnOutput = 1 << 1,\n+\n+    kDefinedOnInputAndOutput = kDefinedOnInput | kDefinedOnOutput,\n+  };\n \n   BufferUse(BufferAllocation::Slice slice, MemoryAccess access)\n-      : slice_(slice), access_(access) {}\n+      : BufferUse(slice, access,\n+                  access == MemoryAccess::kRead\n+                      ? ContentValidity::kDefinedOnInputAndOutput\n+                      : ContentValidity::kDefinedOnOutput) {}\n+\n+  BufferUse(BufferAllocation::Slice slice, MemoryAccess access,\n+            ContentValidity content_validity)\n+      : slice_(slice), access_(access), content_validity_(content_validity) {}\n \n   static BufferUse Read(BufferAllocation::Slice slice) {\n-    return BufferUse(slice, MemoryAccess::kRead);\n+    return BufferUse(slice, MemoryAccess::kRead,\n+                     ContentValidity::kDefinedOnInputAndOutput);\n   }\n \n   static BufferUse Write(BufferAllocation::Slice slice) {\n-    return BufferUse(slice, MemoryAccess::kWrite);\n+    return BufferUse(slice, MemoryAccess::kWrite,\n+                     ContentValidity::kDefinedOnOutput);\n+  }\n+\n+  static BufferUse Scratch(BufferAllocation::Slice slice) {\n+    return BufferUse(slice, MemoryAccess::kWrite, ContentValidity::kUndefined);\n   }\n \n-  static BufferUse ReadWrite(BufferAllocation::Slice slice) {\n-    return BufferUse(slice, MemoryAccess::kReadWrite);\n+  static BufferUse Consume(BufferAllocation::Slice slice) {\n+    return BufferUse(slice, MemoryAccess::kWrite,\n+                     ContentValidity::kDefinedOnInput);\n   }\n \n-  bool HasReadAccess() const {\n-    return static_cast<uint32_t>(access_) & static_cast<uint32_t>(kRead);\n+  // Returns true if the buffer contains initialized data when thunk starts\n+  // execution.\n+  bool HasDefinedContentsOnInput() const {\n+    return static_cast<uint32_t>(content_validity_) &\n+           static_cast<uint32_t>(ContentValidity::kDefinedOnInput);\n   }\n \n-  bool HasWriteAccess() const {\n-    return static_cast<uint32_t>(access_) & static_cast<uint32_t>(kWrite);\n+  // Returns true if the buffer contains initialized data when thunk finishes\n+  // execution.\n+  bool HasDefinedContentsOnOutput() const {\n+    return static_cast<uint32_t>(content_validity_) &\n+           static_cast<uint32_t>(ContentValidity::kDefinedOnOutput);\n   }\n \n   // ReadWriteSet tracks a set of read and write buffer slices.\n@@ -88,13 +124,15 @@ class BufferUse {\n   };\n \n   bool operator==(const BufferUse& other) const {\n-    return slice_ == other.slice_ && access_ == other.access_;\n+    return std::tie(slice_, access_, content_validity_) ==\n+           std::tie(other.slice_, other.access_, other.content_validity_);\n   }\n \n   bool operator!=(const BufferUse& other) const { return !(*this == other); }\n \n   const BufferAllocation::Slice& slice() const { return slice_; }\n   MemoryAccess access() const { return access_; }\n+  ContentValidity content_validity() const { return content_validity_; }\n \n   template <typename H>\n   friend H AbslHashValue(H h, const BufferUse& use) {\n@@ -103,14 +141,16 @@ class BufferUse {\n \n   template <typename Sink>\n   friend void AbslStringify(Sink& sink, const BufferUse& use) {\n-    absl::Format(&sink, \"slice: %v, access: %s%s\", use.slice_,\n-                 use.HasReadAccess() ? \"R\" : \"\",\n-                 use.HasWriteAccess() ? \"W\" : \"\");\n+    absl::Format(&sink, \"{slice: %v, access: %s, content_validity: %s%s}\",\n+                 use.slice_, use.access() == MemoryAccess::kRead ? \"R\" : \"W\",\n+                 use.HasDefinedContentsOnInput() ? \"I\" : \"\",\n+                 use.HasDefinedContentsOnOutput() ? \"O\" : \"\");\n   }\n \n  private:\n   BufferAllocation::Slice slice_;\n   MemoryAccess access_;\n+  ContentValidity content_validity_;\n };\n \n }  // namespace xla"
        },
        {
            "sha": "055724ea072cefee745fccb61cb58785ed77d24f",
            "filename": "third_party/xla/xla/runtime/buffer_use_test.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 19,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9afe196c0e16fc013832d33dfddf0dc8a3b82507/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9afe196c0e16fc013832d33dfddf0dc8a3b82507/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fruntime%2Fbuffer_use_test.cc?ref=9afe196c0e16fc013832d33dfddf0dc8a3b82507",
            "patch": "@@ -26,41 +26,60 @@ TEST(BufferUseTest, Equality) {\n   BufferAllocation alloc(/*index=*/0, /*size=*/1024, /*color=*/0);\n   BufferAllocation::Slice slice0(&alloc, 0, 10);\n \n-  BufferUse use0(slice0, BufferUse::MemoryAccess::kRead);\n-  BufferUse use1(slice0, BufferUse::MemoryAccess::kWrite);\n-  BufferUse use2(slice0, BufferUse::MemoryAccess::kRead);\n+  BufferUse use_read0 = BufferUse::Read(slice0);\n+  BufferUse use_read1 = BufferUse::Read(slice0);\n+  BufferUse use_write = BufferUse::Write(slice0);\n+  BufferUse use_scratch = BufferUse::Scratch(slice0);\n+  BufferUse use_consume = BufferUse::Consume(slice0);\n \n-  EXPECT_NE(use0, use1);\n-  EXPECT_EQ(use0, use2);\n+  EXPECT_EQ(use_read0, use_read1);\n+  EXPECT_NE(use_read0, use_write);\n+  EXPECT_NE(use_read0, use_scratch);\n+  EXPECT_NE(use_read0, use_consume);\n+\n+  EXPECT_NE(use_write, use_scratch);\n+  EXPECT_NE(use_write, use_consume);\n+\n+  EXPECT_NE(use_scratch, use_consume);\n }\n \n-TEST(BufferUseTest, HasReadWriteAccess) {\n+TEST(BufferUseTest, HasDefinedContents) {\n   BufferAllocation alloc(/*index=*/0, /*size=*/1024, /*color=*/0);\n   BufferAllocation::Slice slice(&alloc, 0, 10);\n \n   BufferUse read = BufferUse::Read(slice);\n-  EXPECT_TRUE(read.HasReadAccess());\n-  EXPECT_FALSE(read.HasWriteAccess());\n+  EXPECT_TRUE(read.HasDefinedContentsOnInput());\n+  EXPECT_TRUE(read.HasDefinedContentsOnOutput());\n \n   BufferUse write = BufferUse::Write(slice);\n-  EXPECT_FALSE(write.HasReadAccess());\n-  EXPECT_TRUE(write.HasWriteAccess());\n+  EXPECT_FALSE(write.HasDefinedContentsOnInput());\n+  EXPECT_TRUE(write.HasDefinedContentsOnOutput());\n+\n+  BufferUse scratch = BufferUse::Scratch(slice);\n+  EXPECT_FALSE(scratch.HasDefinedContentsOnInput());\n+  EXPECT_FALSE(scratch.HasDefinedContentsOnOutput());\n \n-  BufferUse read_write = BufferUse::ReadWrite(slice);\n-  EXPECT_TRUE(read_write.HasReadAccess());\n-  EXPECT_TRUE(read_write.HasWriteAccess());\n+  BufferUse consume = BufferUse::Consume(slice);\n+  EXPECT_TRUE(consume.HasDefinedContentsOnInput());\n+  EXPECT_FALSE(consume.HasDefinedContentsOnOutput());\n }\n \n TEST(BufferUseTest, AbslStringify) {\n   BufferAllocation alloc(/*index=*/0, /*size=*/1024, /*color=*/0);\n   BufferAllocation::Slice slice(&alloc, 0, 10);\n \n-  EXPECT_EQ(absl::StrCat(BufferUse::Read(slice)),\n-            \"slice: {index:0, offset:0, size:10}, access: R\");\n-  EXPECT_EQ(absl::StrCat(BufferUse::Write(slice)),\n-            \"slice: {index:0, offset:0, size:10}, access: W\");\n-  EXPECT_EQ(absl::StrCat(BufferUse::ReadWrite(slice)),\n-            \"slice: {index:0, offset:0, size:10}, access: RW\");\n+  EXPECT_EQ(\n+      absl::StrCat(BufferUse::Read(slice)),\n+      \"{slice: {index:0, offset:0, size:10}, access: R, content_validity: IO}\");\n+  EXPECT_EQ(\n+      absl::StrCat(BufferUse::Write(slice)),\n+      \"{slice: {index:0, offset:0, size:10}, access: W, content_validity: O}\");\n+  EXPECT_EQ(\n+      absl::StrCat(BufferUse::Scratch(slice)),\n+      \"{slice: {index:0, offset:0, size:10}, access: W, content_validity: }\");\n+  EXPECT_EQ(\n+      absl::StrCat(BufferUse::Consume(slice)),\n+      \"{slice: {index:0, offset:0, size:10}, access: W, content_validity: I}\");\n }\n \n TEST(BufferUseTest, ReadWriteSet) {"
        }
    ],
    "stats": {
        "total": 152,
        "additions": 105,
        "deletions": 47
    }
}