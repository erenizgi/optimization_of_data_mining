{
    "author": "junwhanahn",
    "message": "Short-circuit `Map` and `TryMap` when we know the result will be unused\n\nPiperOrigin-RevId: 803135798",
    "sha": "dac7e6eb6a193f95222aaba4b218a19ba712f5f8",
    "files": [
        {
            "sha": "56f41c3a3032fbd5638c0c4ef5fb278634e3f74f",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dac7e6eb6a193f95222aaba4b218a19ba712f5f8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dac7e6eb6a193f95222aaba4b218a19ba712f5f8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=dac7e6eb6a193f95222aaba4b218a19ba712f5f8",
            "patch": "@@ -390,6 +390,16 @@ class PjRtFutureBase : public PjRtFutureMoveControl<is_move_only> {\n         });\n   }\n \n+ protected:\n+  // Returns a placeholder error that can be used when short-circuiting promises\n+  // with no other references.\n+  static absl::Status AbortedError() {\n+    return absl::AbortedError(\n+        \"Fulfilling the promise with an aborted error since the value is no \"\n+        \"longer referenced by any futures or OnReady callbacks; if this error \"\n+        \"is exposed to any future, that indicates a bug\");\n+  }\n+\n  private:\n   tsl::AsyncValueRef<T> promise_;\n \n@@ -511,6 +521,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n \n     using Value = const absl::StatusOr<T>&;\n     OnReady([promise, f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n       if (ABSL_PREDICT_TRUE(value.ok())) {\n         promise.emplace(absl::in_place_t{}, f(*value));\n       } else {\n@@ -542,6 +556,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n                                      const absl::StatusOr<T>&>;\n     std::move(*this).OnReady(\n         [promise, f = std::forward<F>(f)](Value value) mutable {\n+          if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+            promise.Set(Base::AbortedError());\n+            return;\n+          }\n           if (ABSL_PREDICT_TRUE(value.ok())) {\n             if constexpr (is_move_only) {\n               promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n@@ -578,6 +596,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n \n     using Value = const absl::StatusOr<T>&;\n     OnReady([promise, f = std::forward<F>(f)](Value value) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n       if (ABSL_PREDICT_TRUE(value.ok())) {\n         auto result = f(*value);\n         if (ABSL_PREDICT_TRUE(result.ok())) {\n@@ -618,6 +640,10 @@ class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n                                      const absl::StatusOr<T>&>;\n     std::move(*this).OnReady(\n         [promise, f = std::forward<F>(f)](Value value) mutable {\n+          if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+            promise.Set(Base::AbortedError());\n+            return;\n+          }\n           if (ABSL_PREDICT_TRUE(value.ok())) {\n             auto result = [&] {\n               if constexpr (is_move_only) {\n@@ -759,6 +785,10 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n     auto promise = PjRtFuture<R>::CreatePromise();\n \n     OnReady([promise, f = std::forward<F>(f)](absl::Status status) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n       if (ABSL_PREDICT_TRUE(status.ok())) {\n         promise.emplace(absl::in_place_t{}, f());\n       } else {\n@@ -789,6 +819,10 @@ class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n     auto promise = PjRtFuture<R>::CreatePromise();\n \n     OnReady([promise, f = std::forward<F>(f)](absl::Status status) mutable {\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n       if (ABSL_PREDICT_TRUE(status.ok())) {\n         auto result = f();\n         if (ABSL_PREDICT_TRUE(result.ok())) {"
        },
        {
            "sha": "a92a35a9be9f3a0dc0ac6fa6ef584723340259ec",
            "filename": "third_party/xla/xla/pjrt/pjrt_future_test.cc",
            "status": "modified",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dac7e6eb6a193f95222aaba4b218a19ba712f5f8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dac7e6eb6a193f95222aaba4b218a19ba712f5f8/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc?ref=dac7e6eb6a193f95222aaba4b218a19ba712f5f8",
            "patch": "@@ -275,6 +275,32 @@ TEST(PjRtFutureTest, MapMoveOnlyWithInplaceConstructor) {\n   EXPECT_EQ(mapped.Await()->v, 42);\n }\n \n+TEST(PjRtFutureTest, MapUnusedResult) {\n+  auto promise = PjRtFuture<int>::CreatePromise();\n+  PjRtFuture<int> future(promise);\n+\n+  bool called = false;\n+  future.Map([&](int) {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set(1);\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(PjRtFutureTest, MapStatusUnusedResult) {\n+  auto promise = PjRtFuture<>::CreatePromise();\n+  PjRtFuture<> future(promise);\n+\n+  bool called = false;\n+  future.Map([&]() {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set();\n+  EXPECT_FALSE(called);\n+}\n+\n TEST(PjRtFutureTest, TryMapCopyableFuture) {\n   auto promise = PjRtFuture<int32_t>::CreatePromise();\n   PjRtFuture<int32_t> future(promise);\n@@ -371,6 +397,32 @@ TEST(PjRtFutureTest, TryMapMoveOnlyFutureCreateError) {\n   EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n }\n \n+TEST(PjRtFutureTest, TryMapUnusedResult) {\n+  auto promise = PjRtFuture<int>::CreatePromise();\n+  PjRtFuture<int> future(promise);\n+\n+  bool called = false;\n+  future.TryMap([&](int) -> absl::StatusOr<int> {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set(1);\n+  EXPECT_FALSE(called);\n+}\n+\n+TEST(PjRtFutureTest, TryMapStatusUnusedResult) {\n+  auto promise = PjRtFuture<>::CreatePromise();\n+  PjRtFuture<> future(promise);\n+\n+  bool called = false;\n+  future.TryMap([&]() -> absl::StatusOr<int> {\n+    called = true;\n+    return 2;\n+  });\n+  promise.Set();\n+  EXPECT_FALSE(called);\n+}\n+\n TEST(PjRtFutureTest, StatelessError) {\n   auto [promise, future] = PjRtFuture<>::MakePromise();\n "
        }
    ],
    "stats": {
        "total": 86,
        "additions": 86,
        "deletions": 0
    }
}