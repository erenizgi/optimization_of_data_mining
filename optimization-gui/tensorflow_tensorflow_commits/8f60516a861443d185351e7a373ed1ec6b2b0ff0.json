{
    "author": "tensorflower-gardener",
    "message": "Refactor: Move common SymbolicMapTest setup to the fixture.\n\nThis change moves the initialization of commonly used `SymbolicExpr` and a sample `SymbolicMap` into the `SymbolicMapTest` fixture to reduce code duplication across tests.\n\nPiperOrigin-RevId: 826161168",
    "sha": "8f60516a861443d185351e7a373ed1ec6b2b0ff0",
    "files": [
        {
            "sha": "0991468d86cfcbb89cd360e1aaf489ffe4042327",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_test.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 73,
            "changes": 121,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f60516a861443d185351e7a373ed1ec6b2b0ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f60516a861443d185351e7a373ed1ec6b2b0ff0/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc?ref=8f60516a861443d185351e7a373ed1ec6b2b0ff0",
            "patch": "@@ -30,42 +30,52 @@ using ::testing::ElementsAre;\n \n struct SymbolicMapTest : public ::testing::Test {\n   mlir::MLIRContext mlir_context;\n-  SymbolicExprContext ctx{&mlir_context};\n+  SymbolicExprContext ctx;\n+  SymbolicExpr d0;\n+  SymbolicExpr d1;\n+  static constexpr int kSampleDims = 2;\n+  SymbolicExpr s0;\n+  SymbolicExpr s1;\n+  static constexpr int kSampleSymbols = 2;\n+  SymbolicExpr c2;\n+  SymbolicExpr c10;\n+  SymbolicMap sample_map;\n+\n+  SymbolicMapTest()\n+      : ctx(&mlir_context),\n+        d0(CreateDimExpr(&ctx, 0)),\n+        d1(CreateDimExpr(&ctx, 1)),\n+        s0(CreateSymbolExpr(&ctx, 0, kSampleDims)),\n+        s1(CreateSymbolExpr(&ctx, 1, kSampleDims)),\n+        c2(ctx.CreateConstant(2)),\n+        c10(ctx.CreateConstant(10)),\n+        sample_map(SymbolicMap::Get(&ctx, kSampleDims, kSampleSymbols,\n+                                    {d0 + s0, d1 * s1})) {}\n };\n \n TEST_F(SymbolicMapTest, GetSymbolAndDimExpressions) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n-  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n-  SymbolicMap map = SymbolicMap::Get(&ctx, 2, 2, {d0 + s0, d1 * s1});\n-  EXPECT_EQ(map.GetSymbolExpression(0), s0);\n-  EXPECT_EQ(map.GetSymbolExpression(1), s1);\n-  EXPECT_EQ(map.GetDimExpression(0), d0);\n-  EXPECT_EQ(map.GetDimExpression(1), d1);\n+  EXPECT_EQ(sample_map.GetSymbolExpression(0), s0);\n+  EXPECT_EQ(sample_map.GetSymbolExpression(1), s1);\n+  EXPECT_EQ(sample_map.GetDimExpression(0), d0);\n+  EXPECT_EQ(sample_map.GetDimExpression(1), d1);\n }\n \n TEST_F(SymbolicMapTest, ToString) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n-  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n-\n-  SymbolicMap map = SymbolicMap::Get(&ctx, 2, 2, {d0 + s0, d1 * s1});\n-  EXPECT_EQ(map.ToString(), \"(d0, d1)[s0, s1] -> ((d0 + s0), (d1 * s1))\");\n+  EXPECT_EQ(sample_map.ToString(),\n+            \"(d0, d1)[s0, s1] -> ((d0 + s0), (d1 * s1))\");\n \n   SymbolicMap empty_map = SymbolicMap::Get(&ctx, 0, 0, {});\n   EXPECT_EQ(empty_map.ToString(), \"()[] -> ()\");\n \n-  SymbolicMap dims_only = SymbolicMap::Get(&ctx, 2, 0, {d0, d1});\n+  SymbolicMap dims_only = SymbolicMap::Get(&ctx, kSampleDims, 0, {d0, d1});\n   EXPECT_EQ(dims_only.ToString(), \"(d0, d1)[] -> (d0, d1)\");\n \n   SymbolicExpr s0_no_dims =\n       CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/0);\n   SymbolicExpr s1_no_dims =\n       CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/0);\n   SymbolicMap symbols_only =\n-      SymbolicMap::Get(&ctx, 0, 2, {s0_no_dims, s1_no_dims});\n+      SymbolicMap::Get(&ctx, 0, kSampleSymbols, {s0_no_dims, s1_no_dims});\n   EXPECT_EQ(symbols_only.ToString(), \"()[s0, s1] -> (s0, s1)\");\n }\n \n@@ -120,18 +130,11 @@ TEST_F(SymbolicMapTest, GetConstantResults) {\n }\n \n TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n-  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n-  SymbolicExpr c1 = ctx.CreateConstant(10);\n-  SymbolicExpr c2 = ctx.CreateConstant(20);\n   SymbolicExpr c3 = ctx.CreateConstant(30);\n \n-  SymbolicMap map_basic = SymbolicMap::Get(&ctx, 2, 2, {d0 + s0, d1 * s1});\n-  SymbolicMap replaced_basic = map_basic.ReplaceDimsAndSymbols(\n-      {c1, c2}, {c3, d0}, map_basic.GetNumDims(), map_basic.GetNumSymbols());\n-  EXPECT_THAT(replaced_basic.GetResults(), ElementsAre(c1 + c3, c2 * d0));\n+  SymbolicMap replaced_basic = sample_map.ReplaceDimsAndSymbols(\n+      {c10, c2}, {c3, d0}, sample_map.GetNumDims(), sample_map.GetNumSymbols());\n+  EXPECT_THAT(replaced_basic.GetResults(), ElementsAre(c10 + c3, c2 * d0));\n \n   SymbolicMap map_empty = SymbolicMap::Get(&ctx, 0, 0, {});\n   SymbolicMap replaced_empty = map_empty.ReplaceDimsAndSymbols({}, {}, 0, 0);\n@@ -143,53 +146,28 @@ TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n   SymbolicExpr new_d1 = CreateDimExpr(&ctx, 1);\n   SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n   SymbolicMap replaced_change_dims = map_change_dims.ReplaceDimsAndSymbols(\n-      {new_d0 * c1 + new_d1}, {new_s0}, 2, 1);\n+      {new_d0 * c10 + new_d1}, {new_s0}, 2, 1);\n   EXPECT_EQ(replaced_change_dims.GetNumDims(), 2);\n   EXPECT_EQ(replaced_change_dims.GetNumSymbols(), 1);\n   EXPECT_THAT(replaced_change_dims.GetResults(),\n-              ElementsAre((new_d0 * c1 + new_d1) + new_s0 * c2));\n+              ElementsAre((new_d0 * c10 + new_d1) + new_s0 * c2));\n }\n \n TEST_F(SymbolicMapTest, ReplaceDimsAndSymbolsOnlyDims) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  int num_dims = 2;\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, 0, num_dims);\n-  SymbolicExpr s1 = CreateSymbolExpr(&ctx, 1, num_dims);\n-  int num_symbols = 2;\n-  SymbolicExpr c1 = ctx.CreateConstant(10);\n-  SymbolicExpr c2 = ctx.CreateConstant(20);\n-\n-  SymbolicMap map =\n-      SymbolicMap::Get(&ctx, num_dims, num_symbols, {d0 + s0, d1 * s1});\n-  SymbolicMap replaced = map.ReplaceDimsAndSymbols(\n-      /*dim_replacements=*/{c1, c2}, /*sym_replacements=*/{}, num_dims,\n-      num_symbols);\n-  EXPECT_THAT(replaced.GetResults(), ElementsAre(c1 + s0, c2 * s1));\n+  SymbolicMap replaced = sample_map.ReplaceDimsAndSymbols(\n+      /*dim_replacements=*/{c10, c2}, /*sym_replacements=*/{},\n+      sample_map.GetNumDims(), sample_map.GetNumSymbols());\n+  EXPECT_THAT(replaced.GetResults(), ElementsAre(c10 + s0, c2 * s1));\n }\n \n TEST_F(SymbolicMapTest, ReplaceDimsAndSymbolsOnlySymbols) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  int num_dims = 2;\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, 0, num_dims);\n-  SymbolicExpr s1 = CreateSymbolExpr(&ctx, 1, num_dims);\n-  int num_symbols = 2;\n-  SymbolicExpr c1 = ctx.CreateConstant(10);\n-  SymbolicExpr c2 = ctx.CreateConstant(20);\n-\n-  SymbolicMap map =\n-      SymbolicMap::Get(&ctx, num_dims, num_symbols, {d0 + s0, d1 * s1});\n-  SymbolicMap replaced = map.ReplaceDimsAndSymbols(\n-      /*dim_replacements=*/{}, /*sym_replacements=*/{c1, c2}, num_dims,\n-      num_symbols);\n-  EXPECT_THAT(replaced.GetResults(), ElementsAre(d0 + c1, d1 * c2));\n+  SymbolicMap replaced = sample_map.ReplaceDimsAndSymbols(\n+      /*dim_replacements=*/{}, /*sym_replacements=*/{c10, c2},\n+      sample_map.GetNumDims(), sample_map.GetNumSymbols());\n+  EXPECT_THAT(replaced.GetResults(), ElementsAre(d0 + c10, d1 * c2));\n }\n \n TEST_F(SymbolicMapTest, Compose) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-\n   // Composition without Symbols\n   SymbolicMap map1_no_symbols = SymbolicMap::Get(&ctx, 1, 0, {d0 * 2});\n   SymbolicMap map2_no_symbols = SymbolicMap::Get(&ctx, 1, 0, {d0 + 5});\n@@ -243,9 +221,6 @@ TEST_F(SymbolicMapTest, Compose) {\n }\n \n TEST_F(SymbolicMapTest, Replace) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr c2 = ctx.CreateConstant(2);\n   SymbolicExpr c5 = ctx.CreateConstant(5);\n \n   SymbolicExpr expr0 = (d0 + c2) * d1;\n@@ -264,15 +239,15 @@ TEST_F(SymbolicMapTest, Replace) {\n }\n \n TEST_F(SymbolicMapTest, GetUnusedVariables) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n+  [[maybe_unused]] SymbolicExpr d2 = CreateDimExpr(&ctx, 2);\n   // d2 is unused.\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/3);\n-  SymbolicExpr s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/3);\n-  SymbolicExpr c2 = ctx.CreateConstant(2);\n+  [[maybe_unused]] SymbolicExpr s0_3dims =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/3);\n+  SymbolicExpr s1_3dims =\n+      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/3);\n \n   // Map with used and unused dims and symbols.\n-  SymbolicMap map = SymbolicMap::Get(&ctx, 3, 2, {d0 + s1, d1 * c2});\n+  SymbolicMap map = SymbolicMap::Get(&ctx, 3, 2, {d0 + s1_3dims, d1 * c2});\n \n   llvm::SmallBitVector unused_dims = GetUnusedDimensionsBitVector(map);\n   EXPECT_EQ(unused_dims.size(), 3);"
        }
    ],
    "stats": {
        "total": 121,
        "additions": 48,
        "deletions": 73
    }
}