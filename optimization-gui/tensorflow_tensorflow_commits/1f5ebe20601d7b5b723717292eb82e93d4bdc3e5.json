{
    "author": "tensorflower-gardener",
    "message": "Localizes RemapInstructionIds to the computation level, avoiding bugs from protos generated with local ids as the operand ids instead of the more general unique id. Updates comments to be more informative.\n\nPiperOrigin-RevId: 810865030",
    "sha": "1f5ebe20601d7b5b723717292eb82e93d4bdc3e5",
    "files": [
        {
            "sha": "cbcc7ee916e3bc799d89ee0d1fe07c4ae1c94be1",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=1f5ebe20601d7b5b723717292eb82e93d4bdc3e5",
            "patch": "@@ -237,6 +237,7 @@ xla_cc_test(\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:protobuf\",\n     ],\n )\n "
        },
        {
            "sha": "12d56878b808e20e2aefcfd1b5beea6aa2646ce7",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 24,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.cc?ref=1f5ebe20601d7b5b723717292eb82e93d4bdc3e5",
            "patch": "@@ -185,7 +185,6 @@ HloComputation* HloModule::AddComputationInternal(\n     computation->SetUniqueId(ReadAndIncrementNextUniqueComputationId());\n     // Computation sets unique ID internally in sequence\n     // Recompacts the instructions vector to remove nullptr entries.\n-    // computation->RecompactInstructions();\n     computation->Cleanup();\n   } else {\n     // Don't uniquify the names of the computation or instruction, but we must\n@@ -634,20 +633,18 @@ absl::Status HloModule::CheckUniqueNamesAndIdsForComputationsAndInstructions()\n }\n \n /* static */\n-absl::Status HloModule::UpdateIdsInSchedules(\n-    HloModuleProto& proto,\n+absl::Status HloModule::UpdateIdsInSchedule(\n+    HloModuleProto& proto, int64_t computation_proto_id,\n     absl::flat_hash_map<int64_t, int64_t>& old_instr_id_to_new_id) {\n-  for (HloComputationProto& computation_proto : *proto.mutable_computations()) {\n-    if (proto.schedule().sequences().contains(computation_proto.id())) {\n-      HloScheduleProto::InstructionSequence& sequence =\n-          (*proto.mutable_schedule()\n-                ->mutable_sequences())[computation_proto.id()];\n-      for (int64_t& instr_id : *sequence.mutable_instruction_ids()) {\n-        TF_RET_CHECK(old_instr_id_to_new_id.contains(instr_id))\n-            << \"Instruction id \" << instr_id\n-            << \" not found in map when updating schedule ids.\";\n-        instr_id = old_instr_id_to_new_id[instr_id];\n-      }\n+  if (proto.schedule().sequences().contains(computation_proto_id)) {\n+    HloScheduleProto::InstructionSequence& sequence =\n+        (*proto.mutable_schedule()->mutable_sequences())[computation_proto_id];\n+    for (int64_t& instr_id : *sequence.mutable_instruction_ids()) {\n+      int64_t local_instr_id = HloInstruction::CalculateLocalId(instr_id);\n+      TF_RET_CHECK(old_instr_id_to_new_id.contains(local_instr_id))\n+          << \"Instruction id \" << instr_id\n+          << \" not found in map when updating schedule ids.\";\n+      instr_id = old_instr_id_to_new_id[local_instr_id];\n     }\n   }\n   return absl::OkStatus();\n@@ -656,36 +653,45 @@ absl::Status HloModule::UpdateIdsInSchedules(\n /* static */\n absl::StatusOr<HloModuleProto> HloModule::RemapInstructionIds(\n     const HloModuleProto& proto) {\n-  absl::flat_hash_map<int64_t, int64_t> old_instr_id_to_new_id;\n   HloModuleProto proto_copy = proto;\n   for (HloComputationProto& computation_proto :\n        *proto_copy.mutable_computations()) {\n     int64_t next_instr_id = 0;\n+    int64_t new_root_id = -1;\n+    absl::flat_hash_map<int64_t, int64_t> old_instr_id_to_new_id;\n     for (HloInstructionProto& instr_proto :\n          *computation_proto.mutable_instructions()) {\n       int64_t old_instr_id = instr_proto.id();\n       instr_proto.set_id(next_instr_id++);\n-      old_instr_id_to_new_id[old_instr_id] = instr_proto.id();\n+      old_instr_id_to_new_id[HloInstruction::CalculateLocalId(old_instr_id)] =\n+          instr_proto.id();\n+      if (HloInstruction::CalculateLocalId(old_instr_id) ==\n+          HloInstruction::CalculateLocalId(computation_proto.root_id())) {\n+        new_root_id = instr_proto.id();\n+      }\n     }\n     // Fix operands and control_predecessors.\n     for (HloInstructionProto& instr_proto :\n          *computation_proto.mutable_instructions()) {\n       for (int64_t& operand_id : *instr_proto.mutable_operand_ids()) {\n-        operand_id = old_instr_id_to_new_id[operand_id];\n+        operand_id = old_instr_id_to_new_id[HloInstruction::CalculateLocalId(\n+            operand_id)];\n       }\n       for (int64_t& control_predecessor_id :\n            *instr_proto.mutable_control_predecessor_ids()) {\n-        control_predecessor_id = old_instr_id_to_new_id[control_predecessor_id];\n+        control_predecessor_id =\n+            old_instr_id_to_new_id[HloInstruction::CalculateLocalId(\n+                control_predecessor_id)];\n       }\n     }\n     // Fix root_id.\n-    TF_RET_CHECK(old_instr_id_to_new_id.contains(computation_proto.root_id()))\n-        << \"Root id \" << computation_proto.root_id()\n-        << \" not found in computation proto.\";\n-    computation_proto.set_root_id(\n-        old_instr_id_to_new_id[computation_proto.root_id()]);\n+    TF_RET_CHECK(new_root_id != -1) << \"Root id \" << computation_proto.root_id()\n+                                    << \" not found in computation proto.\";\n+    computation_proto.set_root_id(new_root_id);\n+    // Fix schedule.\n+    TF_RETURN_IF_ERROR(UpdateIdsInSchedule(proto_copy, computation_proto.id(),\n+                                           old_instr_id_to_new_id));\n   }\n-  TF_RETURN_IF_ERROR(UpdateIdsInSchedules(proto_copy, old_instr_id_to_new_id));\n   return proto_copy;\n }\n "
        },
        {
            "sha": "33d29c841e46a6857292a7b24e148510711dced1",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module.h",
            "status": "modified",
            "additions": 13,
            "deletions": 6,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module.h?ref=1f5ebe20601d7b5b723717292eb82e93d4bdc3e5",
            "patch": "@@ -465,19 +465,26 @@ class HloModule {\n   uint64_t ToFingerprint(const HloPrintOptions& options) const;\n \n   // Remaps the instruction ids in the proto to be consecutive. This is useful\n-  // for loading a proto that had its ids manually created or created\n-  // incorrectly.\n+  // for loading a proto that had its ids manually created, created incorrectly\n+  // or in an older version of the compiler. Instructions will only have the\n+  // local id in the id field.\n   static absl::StatusOr<HloModuleProto> RemapInstructionIds(\n       const HloModuleProto& proto);\n \n-  // Updates the instruction ids in the module's schedules to match the new\n-  // instruction ids as defined by the old_instr_id_to_new_id map.\n-  static absl::Status UpdateIdsInSchedules(\n-      HloModuleProto& proto,\n+  // Updates the instruction ids in the computation's schedule to match the new\n+  // instruction ids as defined by the old_instr_id_to_new_id map. The map only\n+  // needs to be consistent and unique within the computation level.\n+  static absl::Status UpdateIdsInSchedule(\n+      HloModuleProto& proto, int64_t computation_proto_id,\n       absl::flat_hash_map<int64_t, int64_t>& old_instr_id_to_new_id);\n \n   // Convert an HloModule to or from a proto.\n   HloModuleProto ToProto() const;\n+\n+  // Converts an HloModuleProto to an HloModule. If the module had its ids\n+  // manually changed or was created in an older version of the compiler, it\n+  // might be necessary to call RemapInstructionIds to make the ids consistent\n+  // and compact.\n   static absl::StatusOr<std::unique_ptr<HloModule>> CreateFromProto(\n       const HloModuleProto& proto, const HloModuleConfig& module_config,\n       bool prohibit_empty_literal = true,"
        },
        {
            "sha": "8b103f1b12b89b824c2b6f6e48e917d7b95225e4",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module_test.cc",
            "status": "modified",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f5ebe20601d7b5b723717292eb82e93d4bdc3e5/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_test.cc?ref=1f5ebe20601d7b5b723717292eb82e93d4bdc3e5",
            "patch": "@@ -44,11 +44,13 @@ limitations under the License.\n #include \"xla/util.h\"\n #include \"xla/xla.pb.h\"\n #include \"xla/xla_data.pb.h\"\n+#include \"tsl/platform/protobuf.h\"\n \n namespace xla {\n namespace {\n \n using ::testing::ElementsAre;\n+using ::testing::Eq;\n using ::testing::IsEmpty;\n using ::testing::UnorderedElementsAre;\n \n@@ -747,5 +749,113 @@ TEST(HloModuleTest, TestUniqueIdIs64Bits) {\n   TF_EXPECT_OK(module->CheckUniqueNamesAndIdsForComputationsAndInstructions());\n }\n \n+TEST(HloModuleTest, TestRemapInstructionIdsResolvesOperands) {\n+  HloModuleProto hlo_module_proto;\n+  ASSERT_TRUE(tsl::protobuf::TextFormat::ParseFromString(R\"(\n+  name: \"hlo_module_proto\"\n+  entry_computation_id: 1\n+computations {\n+  name: \"basic_computation\"\n+  id: 2\n+  root_id: 1\n+  instructions {\n+    name: \"parameter.0\"\n+    opcode: \"parameter\"\n+    id: 1\n+  }\n+  instructions {\n+    name: \"parameter.1\"\n+    opcode: \"parameter\"\n+    id: 2\n+  }\n+  instructions {\n+    name: \"add.0\"\n+    opcode: \"add\"\n+    id: 3\n+    operand_ids: 1\n+    operand_ids: 2\n+  }\n+  instructions {\n+    name: \"add.1\"\n+    opcode: \"add\"\n+    id: 4\n+    operand_ids: 1\n+    operand_ids: 3\n+  }\n+  instructions {\n+    name: \"add.2\"\n+    opcode: \"add\"\n+    id: 5\n+    operand_ids: 2\n+    operand_ids: 3\n+  }\n+}\n+\n+computations {\n+  name: \"entry_computation\"\n+  id: 1\n+  root_id: 12884901895\n+  instructions {\n+    name: \"Arg_0.1\"\n+    opcode: \"parameter\"\n+    id: 12884901889\n+  }\n+  instructions {\n+    name: \"slice.2\"\n+    opcode: \"slice\"\n+    id: 12884901890\n+    operand_ids: 1\n+  }\n+  instructions {\n+    name: \"squeeze.2\"\n+    opcode: \"reshape\"\n+    id: 12884901891\n+    operand_ids: 2\n+  }\n+  instructions {\n+    name: \"add.39\"\n+    opcode: \"broadcast\"\n+    id: 12884901892\n+    operand_ids: 3\n+  }\n+  instructions {\n+    name: \"iota_2x32_shape.1\"\n+    opcode: \"iota\"\n+    id: 12884901893\n+  }\n+  instructions {\n+    name: \"slice.3\"\n+    opcode: \"slice\"\n+    id: 12884901894\n+    operand_ids: 1\n+  }\n+  instructions {\n+    name: \"squeeze.3\"\n+    opcode: \"reshape\"\n+    id: 7\n+    operand_ids: 6\n+  }\n+}\n+\n+)\",\n+                                                         &hlo_module_proto));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(HloModuleProto remapped_hlo_module_proto,\n+                          HloModule::RemapInstructionIds(hlo_module_proto));\n+\n+  HloInstructionProto squeeze_3_instr =\n+      remapped_hlo_module_proto.computations(1).instructions(6);\n+\n+  // Instruction squeeze.3's operand is slice.3, which should be remapped to\n+  // id 5.\n+  EXPECT_THAT(\n+      remapped_hlo_module_proto.computations(1).instructions(6).operand_ids(),\n+      ElementsAre(5));\n+  // squeeze.3 is the root because its local id matches the local part of the\n+  // root id specified in the proto.\n+  EXPECT_THAT(remapped_hlo_module_proto.computations(1).instructions(6).id(),\n+              Eq(remapped_hlo_module_proto.computations(1).root_id()));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 184,
        "additions": 154,
        "deletions": 30
    }
}