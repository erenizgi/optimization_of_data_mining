{
    "author": "ezhulenev",
    "message": "[xla:ffi] Add type checking isa<T>() APIs to RemainingArgs, RemainingRets and Dictionary\n\nPiperOrigin-RevId: 823157056",
    "sha": "eb36f8770a38ee64de66f18b5b0bcfcedde757aa",
    "files": [
        {
            "sha": "2c4d27f3835407de61bc6c418ba7f116b2112526",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 36,
            "deletions": 3,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb36f8770a38ee64de66f18b5b0bcfcedde757aa/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb36f8770a38ee64de66f18b5b0bcfcedde757aa/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=eb36f8770a38ee64de66f18b5b0bcfcedde757aa",
            "patch": "@@ -903,6 +903,7 @@ struct AttrsBinding<Dictionary> {\n //\n //   template <>\n //   struct ArgDecoding<MyType> {\n+//     static bool Isa(XLA_FFI_ArgType type, void* arg);\n //     static std::optional<MyType> Decode(XLA_FFI_ArgType type, void* arg);\n //   };\n //\n@@ -920,6 +921,7 @@ struct ArgDecoding;\n //\n //   template <>\n //   struct RetDecoding<MyType> {\n+//     static bool Isa(XLA_FFI_RetType type, void* ret);\n //     static std::optional<MyType> Decode(XLA_FFI_RetType type, void* ret);\n //   };\n //\n@@ -937,9 +939,10 @@ struct RetDecoding;\n //\n //   template <>\n //   struct AttrDecoding<MyType> {\n-//    using Type = <handler argument type for attribute type MyType>\n-//    static std::optional<MyType> Decode(XLA_FFI_AttrType type, void* attr,\n-//                                        DiagnosticEngine&);\n+//     using Type = <handler argument type for attribute type MyType>\n+//     static bool Isa(XLA_FFI_AttrType type, void* attr);\n+//     static std::optional<MyType> Decode(XLA_FFI_AttrType type, void* attr,\n+//                                         DiagnosticEngine&);\n //   }\n //\n template <typename T>\n@@ -1205,6 +1208,12 @@ class RemainingArgsBase {\n     assert(offset <= args_->size && \"illegal remaining args offset\");\n   }\n \n+  template <typename T>\n+  bool isa(size_t index) const {\n+    size_t idx = offset() + index;\n+    return ArgDecoding<T>::Isa(args_->types[idx], args_->args[idx]);\n+  }\n+\n   size_t size() const { return args_->size - offset_; }\n   bool empty() const { return size() == 0; }\n \n@@ -1232,6 +1241,12 @@ class RemainingRetsBase {\n     assert(offset <= rets_->size && \"illegal remaining rets offset\");\n   }\n \n+  template <typename T>\n+  bool isa(size_t index) const {\n+    size_t idx = offset_ + index;\n+    return RetDecoding<T>::Isa(rets_->types[idx], rets_->rets[idx]);\n+  }\n+\n   size_t size() const { return rets_->size - offset_; }\n   bool empty() const { return size() == 0; }\n \n@@ -1264,6 +1279,18 @@ class DictionaryBase {\n \n   bool contains(std::string_view name) const { return Find(name).has_value(); }\n \n+  template <typename T>\n+  bool contains(std::string_view name) const {\n+    std::optional<size_t> idx = Find(name);\n+    if (XLA_FFI_PREDICT_FALSE(!idx.has_value())) {\n+      return false;\n+    }\n+\n+    XLA_FFI_AttrType attr_type = attrs_->types[*idx];\n+    void* attr = attrs_->attrs[*idx];\n+    return AttrDecoding<T>::Isa(attr_type, attr);\n+  }\n+\n  protected:\n   template <typename T, typename... Ts>\n   friend struct DecodeDictionaryAttr;\n@@ -1768,6 +1795,12 @@ class Handler : public Ffi {\n   template <>                                                              \\\n   struct AttrDecoding<T> {                                                 \\\n     using Type = T;                                                        \\\n+    XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static bool Isa(XLA_FFI_AttrType type, \\\n+                                                    void* attr) {          \\\n+      return type == XLA_FFI_AttrType_SCALAR &&                            \\\n+             reinterpret_cast<XLA_FFI_Scalar*>(attr)->dtype == TYPE;       \\\n+    }                                                                      \\\n+                                                                           \\\n     XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static std::optional<T> Decode(        \\\n         XLA_FFI_AttrType type, void* attr, DiagnosticEngine& diagnostic) { \\\n       if (XLA_FFI_PREDICT_FALSE(type != XLA_FFI_AttrType_SCALAR)) {        \\"
        },
        {
            "sha": "4687b2354fad84d7d0074486ad3f1a62096bf869",
            "filename": "third_party/xla/xla/ffi/api/ffi.h",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb36f8770a38ee64de66f18b5b0bcfcedde757aa/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb36f8770a38ee64de66f18b5b0bcfcedde757aa/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h?ref=eb36f8770a38ee64de66f18b5b0bcfcedde757aa",
            "patch": "@@ -747,6 +747,12 @@ using Token = BufferR0<DataType::TOKEN>;  // NOLINT\n \n namespace internal {\n \n+template <DataType dtype, size_t rank>\n+XLA_FFI_ATTRIBUTE_ALWAYS_INLINE bool IsaBuffer(XLA_FFI_Buffer* buf) {\n+  return static_cast<DataType>(buf->dtype) == dtype &&\n+         (rank == internal::kDynamicRank || buf->rank == rank);\n+}\n+\n template <DataType dtype, size_t rank>\n XLA_FFI_ATTRIBUTE_ALWAYS_INLINE std::optional<Buffer<dtype, rank>> DecodeBuffer(\n     XLA_FFI_Buffer* buf, DiagnosticEngine& diagnostic) {\n@@ -820,6 +826,11 @@ inline std::ostream& operator<<(std::ostream& os, const XLA_FFI_ArgType type) {\n \n template <>\n struct ArgDecoding<AnyBuffer> {\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n+  static bool Isa(XLA_FFI_ArgType type, void* arg) {\n+    return type == XLA_FFI_ArgType_BUFFER;\n+  }\n+\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n   static std::optional<AnyBuffer> Decode(XLA_FFI_ArgType type, void* arg,\n                                          DiagnosticEngine& diagnostic) {\n@@ -833,6 +844,13 @@ struct ArgDecoding<AnyBuffer> {\n \n template <DataType dtype, size_t rank>\n struct ArgDecoding<Buffer<dtype, rank>> {\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n+  static bool Isa(XLA_FFI_ArgType type, void* arg) {\n+    return type == XLA_FFI_ArgType_BUFFER &&\n+           internal::IsaBuffer<dtype, rank>(\n+               reinterpret_cast<XLA_FFI_Buffer*>(arg));\n+  }\n+\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n   static std::optional<Buffer<dtype, rank>> Decode(\n       XLA_FFI_ArgType type, void* arg, DiagnosticEngine& diagnostic) {\n@@ -895,6 +913,11 @@ inline std::ostream& operator<<(std::ostream& os, const XLA_FFI_RetType type) {\n \n template <>\n struct RetDecoding<AnyBuffer> {\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n+  static bool Isa(XLA_FFI_RetType type, void* ret) {\n+    return type == XLA_FFI_RetType_BUFFER;\n+  }\n+\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n   static std::optional<Result<AnyBuffer>> Decode(XLA_FFI_RetType type,\n                                                  void* ret,\n@@ -909,6 +932,13 @@ struct RetDecoding<AnyBuffer> {\n \n template <DataType dtype, size_t rank>\n struct RetDecoding<Buffer<dtype, rank>> {\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n+  static bool Isa(XLA_FFI_RetType type, void* ret) {\n+    return type == XLA_FFI_RetType_BUFFER &&\n+           internal::IsaBuffer<dtype, rank>(\n+               reinterpret_cast<XLA_FFI_Buffer*>(ret));\n+  }\n+\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n   static std::optional<Result<Buffer<dtype, rank>>> Decode(\n       XLA_FFI_RetType type, void* ret, DiagnosticEngine& diagnostic) {\n@@ -1001,6 +1031,11 @@ template <>\n struct AttrDecoding<std::string_view> {\n   using Type = std::string_view;\n \n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static bool Isa(XLA_FFI_AttrType type,\n+                                                  void* attr) {\n+    return type == XLA_FFI_AttrType_STRING;\n+  }\n+\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static std::optional<std::string_view> Decode(\n       XLA_FFI_AttrType type, void* attr, DiagnosticEngine& diagnostic) {\n     if (XLA_FFI_PREDICT_FALSE(type != XLA_FFI_AttrType_STRING)) {"
        },
        {
            "sha": "996dbd21e2e1649bf3afd5f30031dcbcb6f928ff",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb36f8770a38ee64de66f18b5b0bcfcedde757aa/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb36f8770a38ee64de66f18b5b0bcfcedde757aa/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=eb36f8770a38ee64de66f18b5b0bcfcedde757aa",
            "patch": "@@ -639,6 +639,9 @@ TEST(FfiTest, RemainingArgs) {\n   auto fn = [&](RemainingArgs args) {\n     EXPECT_EQ(args.size(), 1);\n \n+    EXPECT_TRUE(args.isa<AnyBuffer>(0));\n+    EXPECT_FALSE(args.isa<BufferR2<F64>>(0));\n+\n     ErrorOr<AnyBuffer> arg0 = args.get<AnyBuffer>(0);\n     ErrorOr<AnyBuffer> arg1 = args.get<AnyBuffer>(1);\n \n@@ -666,6 +669,9 @@ TEST(FfiTest, RemainingRets) {\n   auto fn = [&](Result<AnyBuffer> ret, RemainingRets rets) {\n     EXPECT_EQ(rets.size(), 1);\n \n+    EXPECT_TRUE(rets.isa<AnyBuffer>(0));\n+    EXPECT_FALSE(rets.isa<BufferR2<F64>>(0));\n+\n     ErrorOr<Result<AnyBuffer>> ret0 = rets.get<AnyBuffer>(0);\n     ErrorOr<Result<AnyBuffer>> ret1 = rets.get<AnyBuffer>(1);\n \n@@ -860,8 +866,17 @@ TEST(FfiTest, AutoBindingStructs) {\n \n TEST(FfiTest, AutoBindingDictionary) {\n   auto handler = Ffi::BindTo(+[](Dictionary attrs) {\n+    EXPECT_TRUE(attrs.contains(\"i32\"));\n+    EXPECT_TRUE(attrs.contains(\"f32\"));\n+\n+    EXPECT_TRUE(attrs.contains<int32_t>(\"i32\"));\n+    EXPECT_TRUE(attrs.contains<float>(\"f32\"));\n+    EXPECT_FALSE(attrs.contains<int64_t>(\"i32\"));\n+    EXPECT_FALSE(attrs.contains<int64_t>(\"f32\"));\n+\n     EXPECT_EQ(*attrs.get<int32_t>(\"i32\"), 42);\n     EXPECT_EQ(*attrs.get<float>(\"f32\"), 42.0f);\n+\n     return Error::Success();\n   });\n "
        }
    ],
    "stats": {
        "total": 89,
        "additions": 86,
        "deletions": 3
    }
}