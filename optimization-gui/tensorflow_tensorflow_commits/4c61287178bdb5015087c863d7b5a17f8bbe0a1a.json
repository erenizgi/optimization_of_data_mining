{
    "author": "ermilovmaxim",
    "message": "[XLA:GPU] move RocmComputeCapability into its own header\n\nPiperOrigin-RevId: 816348852",
    "sha": "4c61287178bdb5015087c863d7b5a17f8bbe0a1a",
    "files": [
        {
            "sha": "2c85399cf4208242a3d2a845f465863ba297b476",
            "filename": "third_party/xla/xla/service/conditional_code_motion.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_code_motion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_code_motion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fconditional_code_motion.cc?ref=4c61287178bdb5015087c863d7b5a17f8bbe0a1a",
            "patch": "@@ -30,10 +30,14 @@ limitations under the License.\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_split.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/debug_options_flags.h\"\n #include \"xla/hlo/ir/hlo_casting_utils.h\"\n+#include \"xla/hlo/ir/hlo_clone_context.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\""
        },
        {
            "sha": "361a537225e087158059a1ae18fa6348d31f9f3c",
            "filename": "third_party/xla/xla/stream_executor/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD?ref=4c61287178bdb5015087c863d7b5a17f8bbe0a1a",
            "patch": "@@ -63,13 +63,12 @@ cc_library(\n         \":launch_dim\",\n         \":semantic_version\",\n         \"//xla/stream_executor/cuda:cuda_compute_capability\",\n+        \"//xla/stream_executor/rocm:rocm_compute_capability\",\n         \"//xla/tsl/lib/math:math_util\",\n         \"//xla/tsl/platform:statusor\",\n-        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n     ],\n )\n "
        },
        {
            "sha": "fa394c2ee23c0b18dfc1150730bd1d32ca11d50e",
            "filename": "third_party/xla/xla/stream_executor/device_description.h",
            "status": "modified",
            "additions": 1,
            "deletions": 186,
            "changes": 187,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_description.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_description.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fdevice_description.h?ref=4c61287178bdb5015087c863d7b5a17f8bbe0a1a",
            "patch": "@@ -20,207 +20,22 @@ limitations under the License.\n #ifndef XLA_STREAM_EXECUTOR_DEVICE_DESCRIPTION_H_\n #define XLA_STREAM_EXECUTOR_DEVICE_DESCRIPTION_H_\n \n-#include <algorithm>\n #include <cassert>\n #include <cstdint>\n-#include <cstring>\n #include <string>\n #include <type_traits>\n #include <utility>\n #include <variant>\n-#include <vector>\n \n-#include \"absl/algorithm/container.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/match.h\"\n-#include \"absl/strings/str_join.h\"\n-#include \"absl/strings/str_split.h\"\n-#include \"absl/strings/string_view.h\"\n #include \"xla/stream_executor/cuda/cuda_compute_capability.h\"\n #include \"xla/stream_executor/device_description.pb.h\"\n #include \"xla/stream_executor/launch_dim.h\"\n+#include \"xla/stream_executor/rocm/rocm_compute_capability.h\"\n #include \"xla/stream_executor/semantic_version.h\"\n \n namespace stream_executor {\n \n-// ROCm compute capability, as reported by the device description.\n-class RocmComputeCapability {\n- public:\n-  // gcn_arch_name example --  gfx90a:sramecc+:xnack-\n-  // gfx_version is the \"gfx90a\" part of the gcn_arch_name\n-  explicit RocmComputeCapability(std::string gcn_arch_name)\n-      : gcn_arch_name_(std::move(gcn_arch_name)) {}\n-\n-  explicit RocmComputeCapability(const RocmComputeCapabilityProto& proto)\n-      : gcn_arch_name_(proto.gcn_arch_name()) {}\n-\n-  RocmComputeCapability() = default;\n-\n-  std::string gcn_arch_name() const { return gcn_arch_name_; }\n-\n-  std::string ToString() const { return gcn_arch_name(); }\n-\n-  RocmComputeCapabilityProto ToProto() const {\n-    RocmComputeCapabilityProto proto;\n-    proto.set_gcn_arch_name(gcn_arch_name_);\n-    return proto;\n-  }\n-\n-  bool operator==(const RocmComputeCapability& other) const {\n-    return gcn_arch_name_ == other.gcn_arch_name_;\n-  }\n-\n-  bool operator!=(const RocmComputeCapability& other) const {\n-    return !this->operator==(other);\n-  }\n-\n-  std::string gfx_version() const {\n-    //  std::strchr() is faster for the case than std::string::find()\n-    const char* const p_colon = std::strchr(gcn_arch_name_.c_str(), ':');\n-    if (nullptr == p_colon) {\n-      return gcn_arch_name_;  // likely it's the default invalid value\n-    }\n-    return std::string(gcn_arch_name_.c_str(), p_colon);\n-  }\n-\n-  // note, while there's no particular reason to make the lists public, it won't\n-  // hurt since they are immutable, but keeping them close to methods simplifies\n-  // maintanance.\n-  static constexpr absl::string_view kSupportedGfxVersions[]{\n-      \"gfx900\",   // MI25\n-      \"gfx906\",   // MI50 / MI60\n-      \"gfx908\",   // MI100\n-      \"gfx90a\",   // MI200\n-      \"gfx942\",   // MI300\n-      \"gfx950\",   // MI350\n-      \"gfx1030\",  // RX68xx / RX69xx\n-      \"gfx1100\",  // RX7900\n-      \"gfx1101\",  // RX7700 / RX7800\n-      \"gfx1103\", \"gfx1150\", \"gfx1151\", \"gfx1200\", \"gfx1201\",\n-  };\n-\n-  bool is_supported_gfx_version() const {\n-    return IsThisGfxInAnyList(kSupportedGfxVersions);\n-  }\n-\n-  std::string supported_gfx_versions_str() const {\n-    return absl::StrJoin(kSupportedGfxVersions, \", \");\n-  }\n-\n-  bool gfx9_mi100() const { return gfx_version() == \"gfx908\"; }\n-\n-  static constexpr absl::string_view kMI100Series[] = {\"gfx908\"};\n-\n-  bool gfx9_mi200() const { return gfx_version() == \"gfx90a\"; }\n-\n-  static constexpr absl::string_view kMI200Series[] = {\"gfx90a\"};\n-\n-  bool gfx9_mi300() const { return gfx_version() == \"gfx942\"; }\n-\n-  bool gfx9_mi350() const { return gfx_version() == \"gfx950\"; }\n-\n-  static constexpr absl::string_view kMI300Series[] = {\"gfx942\", \"gfx950\"};\n-  bool gfx9_mi300_series() const { return IsThisGfxInAnyList(kMI300Series); }\n-\n-  bool gfx9_mi100_or_later() const {\n-    return IsThisGfxInAnyList(kMI300Series, kMI200Series, kMI100Series);\n-  }\n-\n-  bool gfx9_mi200_or_later() const {\n-    return IsThisGfxInAnyList(kMI300Series, kMI200Series);\n-  }\n-\n-  bool gfx10_rx68xx() const { return gfx_version() == \"gfx1030\"; }\n-\n-  bool gfx10_rx69xx() const { return gfx_version() == \"gfx1030\"; }\n-\n-  bool gfx11() const { return absl::StartsWith(gfx_version(), \"gfx11\"); }\n-\n-  static constexpr absl::string_view kGfx11Discrete[] = {\"gfx1100\", \"gfx1101\"};\n-  bool gfx11_discrete() const { return IsThisGfxInAnyList(kGfx11Discrete); }\n-\n-  static constexpr absl::string_view kGfx11Apu[] = {\"gfx1103\", \"gfx1150\",\n-                                                    \"gfx1151\"};\n-  bool gfx11_apu() const { return IsThisGfxInAnyList(kGfx11Apu); }\n-\n-  static constexpr absl::string_view kGfx11Rx7900[] = {\"gfx1100\", \"gfx1101\",\n-                                                       \"gfx1102\"};\n-  bool gfx11_rx7900() const {\n-    // TODO(AMD/TF): instead of this, other gfx11*() methods might be better\n-    return IsThisGfxInAnyList(kGfx11Rx7900);\n-  }\n-\n-  bool gfx12() const { return absl::StartsWith(gfx_version(), \"gfx12\"); }\n-\n-  static constexpr absl::string_view kGfx12Discrete[] = {\"gfx1200\", \"gfx1201\"};\n-  bool gfx12_discrete() const { return IsThisGfxInAnyList(kGfx12Discrete); }\n-\n-  bool gfx12_rx8900() const { return gfx12_discrete(); }\n-\n-  bool has_nhwc_layout_support() const { return gfx9_mi100_or_later(); }\n-\n-  bool has_bf16_dtype_support() const {\n-    return gfx9_mi100_or_later() || gfx12() || gfx11();\n-  }\n-\n-  bool has_fast_fp16_support() const {\n-    return gfx9_mi100_or_later() || gfx11() || gfx10_rx68xx() || gfx10_rx69xx();\n-  }\n-\n-  bool has_mfma_instr_support() const { return gfx9_mi100_or_later(); }\n-\n-  bool has_amd_matrix_core() const {\n-    return gfx9_mi100_or_later() || gfx12() || gfx11();\n-  }\n-\n-  bool has_packed_fp16_atomics_support() const { return gfx9_mi100_or_later(); }\n-\n-  bool has_packed_bf16_atomics_support() const { return gfx9_mi300_series(); }\n-\n-  bool fence_before_barrier() const {\n-    static constexpr absl::string_view kList[] = {\"gfx900\", \"gfx906\"};\n-    return !IsThisGfxInAnyList(kList);\n-  }\n-\n-  bool has_hipblaslt() const {\n-    return IsThisGfxInAnyList(kMI300Series, kMI200Series, kGfx12Discrete,\n-                              kGfx11Discrete, kGfx11Apu);\n-  }\n-\n-  bool has_fp8_support() const {\n-    return has_ocp_fp8_support() || has_nanoo_fp8_support();\n-  }\n-\n-  bool has_ocp_fp8_support() const { return gfx9_mi350() || gfx12_discrete(); }\n-\n-  bool has_nanoo_fp8_support() const { return gfx9_mi300(); }\n-\n-  /// \\brief Invalid gfx id for default gcn_arch_name_ value and testing\n-  static constexpr absl::string_view kInvalidGfx = \"gfx000\";\n-\n- private:\n-  /// \\brief Takes one or more arrays of string-like objects and tests if the\n-  /// result of `gfx_version()` matches to any string in any of the arrays.\n-  template <typename... ArrayOfStrings>\n-  bool IsThisGfxInAnyList(ArrayOfStrings&&... arr) const {\n-    static_assert(sizeof...(arr) >= 1);\n-    const auto gfx = gfx_version();\n-    return (implIsThisGfxInAnyList(std::begin(arr), std::end(arr), gfx) || ...);\n-  }\n-\n-  /// \\brief Template-less implementation of IsThisGfxInAnyList().\n-  /// \\warning Don't use directly!\n-  bool implIsThisGfxInAnyList(const absl::string_view* beg,\n-                              const absl::string_view* end,\n-                              const std::string& gfx) const {\n-    return std::any_of(beg, end, [&gfx = gfx](const absl::string_view& s) {\n-      return gfx == s;\n-    });\n-  }\n-\n-  std::string gcn_arch_name_{kInvalidGfx};  // default to invalid arch.\n-};\n-\n using GpuComputeCapability =\n     std::variant<CudaComputeCapability, RocmComputeCapability>;\n "
        },
        {
            "sha": "6fd7d30c8d3de5fea42a87df63c5a50afb813f17",
            "filename": "third_party/xla/xla/stream_executor/rocm/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2FBUILD?ref=4c61287178bdb5015087c863d7b5a17f8bbe0a1a",
            "patch": "@@ -30,6 +30,15 @@ package_group(\n     packages = stream_executor_friends(),\n )\n \n+cc_library(\n+    name = \"rocm_compute_capability\",\n+    hdrs = [\"rocm_compute_capability.h\"],\n+    deps = [\n+        \"//xla/stream_executor:device_description_proto_cc\",\n+        \"@com_google_absl//absl/strings\",\n+    ],\n+)\n+\n cc_library(\n     name = \"rocm_diagnostics\",\n     srcs = [\"rocm_diagnostics.cc\"],"
        },
        {
            "sha": "4405d2c4a80a1ffcfd4ebcc5d599fd77282f20c5",
            "filename": "third_party/xla/xla/stream_executor/rocm/rocm_compute_capability.h",
            "status": "added",
            "additions": 213,
            "deletions": 0,
            "changes": 213,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2Frocm_compute_capability.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c61287178bdb5015087c863d7b5a17f8bbe0a1a/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2Frocm_compute_capability.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2Frocm_compute_capability.h?ref=4c61287178bdb5015087c863d7b5a17f8bbe0a1a",
            "patch": "@@ -0,0 +1,213 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_STREAM_EXECUTOR_ROCM_ROCM_COMPUTE_CAPABILITY_H_\n+#define XLA_STREAM_EXECUTOR_ROCM_ROCM_COMPUTE_CAPABILITY_H_\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstring>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/strings/match.h\"\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/stream_executor/device_description.pb.h\"\n+\n+namespace stream_executor {\n+\n+// ROCm compute capability, as reported by the device description.\n+class RocmComputeCapability {\n+ public:\n+  // gcn_arch_name example --  gfx90a:sramecc+:xnack-\n+  // gfx_version is the \"gfx90a\" part of the gcn_arch_name\n+  explicit RocmComputeCapability(std::string gcn_arch_name)\n+      : gcn_arch_name_(std::move(gcn_arch_name)) {}\n+\n+  explicit RocmComputeCapability(const RocmComputeCapabilityProto& proto)\n+      : gcn_arch_name_(proto.gcn_arch_name()) {}\n+\n+  RocmComputeCapability() = default;\n+\n+  std::string gcn_arch_name() const { return gcn_arch_name_; }\n+\n+  std::string ToString() const { return gcn_arch_name(); }\n+\n+  RocmComputeCapabilityProto ToProto() const {\n+    RocmComputeCapabilityProto proto;\n+    proto.set_gcn_arch_name(gcn_arch_name_);\n+    return proto;\n+  }\n+\n+  bool operator==(const RocmComputeCapability& other) const {\n+    return gcn_arch_name_ == other.gcn_arch_name_;\n+  }\n+\n+  bool operator!=(const RocmComputeCapability& other) const {\n+    return !this->operator==(other);\n+  }\n+\n+  std::string gfx_version() const {\n+    //  std::strchr() is faster for the case than std::string::find()\n+    const char* const p_colon = std::strchr(gcn_arch_name_.c_str(), ':');\n+    if (nullptr == p_colon) {\n+      return gcn_arch_name_;  // likely it's the default invalid value\n+    }\n+    return std::string(gcn_arch_name_.c_str(), p_colon);\n+  }\n+\n+  // note, while there's no particular reason to make the lists public, it won't\n+  // hurt since they are immutable, but keeping them close to methods simplifies\n+  // maintanance.\n+  static constexpr absl::string_view kSupportedGfxVersions[]{\n+      \"gfx900\",   // MI25\n+      \"gfx906\",   // MI50 / MI60\n+      \"gfx908\",   // MI100\n+      \"gfx90a\",   // MI200\n+      \"gfx942\",   // MI300\n+      \"gfx950\",   // MI350\n+      \"gfx1030\",  // RX68xx / RX69xx\n+      \"gfx1100\",  // RX7900\n+      \"gfx1101\",  // RX7700 / RX7800\n+      \"gfx1103\", \"gfx1150\", \"gfx1151\", \"gfx1200\", \"gfx1201\",\n+  };\n+\n+  bool is_supported_gfx_version() const {\n+    return IsThisGfxInAnyList(kSupportedGfxVersions);\n+  }\n+\n+  std::string supported_gfx_versions_str() const {\n+    return absl::StrJoin(kSupportedGfxVersions, \", \");\n+  }\n+\n+  bool gfx9_mi100() const { return gfx_version() == \"gfx908\"; }\n+\n+  static constexpr absl::string_view kMI100Series[] = {\"gfx908\"};\n+\n+  bool gfx9_mi200() const { return gfx_version() == \"gfx90a\"; }\n+\n+  static constexpr absl::string_view kMI200Series[] = {\"gfx90a\"};\n+\n+  bool gfx9_mi300() const { return gfx_version() == \"gfx942\"; }\n+\n+  bool gfx9_mi350() const { return gfx_version() == \"gfx950\"; }\n+\n+  static constexpr absl::string_view kMI300Series[] = {\"gfx942\", \"gfx950\"};\n+  bool gfx9_mi300_series() const { return IsThisGfxInAnyList(kMI300Series); }\n+\n+  bool gfx9_mi100_or_later() const {\n+    return IsThisGfxInAnyList(kMI300Series, kMI200Series, kMI100Series);\n+  }\n+\n+  bool gfx9_mi200_or_later() const {\n+    return IsThisGfxInAnyList(kMI300Series, kMI200Series);\n+  }\n+\n+  bool gfx10_rx68xx() const { return gfx_version() == \"gfx1030\"; }\n+\n+  bool gfx10_rx69xx() const { return gfx_version() == \"gfx1030\"; }\n+\n+  bool gfx11() const { return absl::StartsWith(gfx_version(), \"gfx11\"); }\n+\n+  static constexpr absl::string_view kGfx11Discrete[] = {\"gfx1100\", \"gfx1101\"};\n+  bool gfx11_discrete() const { return IsThisGfxInAnyList(kGfx11Discrete); }\n+\n+  static constexpr absl::string_view kGfx11Apu[] = {\"gfx1103\", \"gfx1150\",\n+                                                    \"gfx1151\"};\n+  bool gfx11_apu() const { return IsThisGfxInAnyList(kGfx11Apu); }\n+\n+  static constexpr absl::string_view kGfx11Rx7900[] = {\"gfx1100\", \"gfx1101\",\n+                                                       \"gfx1102\"};\n+  bool gfx11_rx7900() const {\n+    // TODO(AMD/TF): instead of this, other gfx11*() methods might be better\n+    return IsThisGfxInAnyList(kGfx11Rx7900);\n+  }\n+\n+  bool gfx12() const { return absl::StartsWith(gfx_version(), \"gfx12\"); }\n+\n+  static constexpr absl::string_view kGfx12Discrete[] = {\"gfx1200\", \"gfx1201\"};\n+  bool gfx12_discrete() const { return IsThisGfxInAnyList(kGfx12Discrete); }\n+\n+  bool gfx12_rx8900() const { return gfx12_discrete(); }\n+\n+  bool has_nhwc_layout_support() const { return gfx9_mi100_or_later(); }\n+\n+  bool has_bf16_dtype_support() const {\n+    return gfx9_mi100_or_later() || gfx12() || gfx11();\n+  }\n+\n+  bool has_fast_fp16_support() const {\n+    return gfx9_mi100_or_later() || gfx11() || gfx10_rx68xx() || gfx10_rx69xx();\n+  }\n+\n+  bool has_mfma_instr_support() const { return gfx9_mi100_or_later(); }\n+\n+  bool has_amd_matrix_core() const {\n+    return gfx9_mi100_or_later() || gfx12() || gfx11();\n+  }\n+\n+  bool has_packed_fp16_atomics_support() const { return gfx9_mi100_or_later(); }\n+\n+  bool has_packed_bf16_atomics_support() const { return gfx9_mi300_series(); }\n+\n+  bool fence_before_barrier() const {\n+    static constexpr absl::string_view kList[] = {\"gfx900\", \"gfx906\"};\n+    return !IsThisGfxInAnyList(kList);\n+  }\n+\n+  bool has_hipblaslt() const {\n+    return IsThisGfxInAnyList(kMI300Series, kMI200Series, kGfx12Discrete,\n+                              kGfx11Discrete, kGfx11Apu);\n+  }\n+\n+  bool has_fp8_support() const {\n+    return has_ocp_fp8_support() || has_nanoo_fp8_support();\n+  }\n+\n+  bool has_ocp_fp8_support() const { return gfx9_mi350() || gfx12_discrete(); }\n+\n+  bool has_nanoo_fp8_support() const { return gfx9_mi300(); }\n+\n+  /// \\brief Invalid gfx id for default gcn_arch_name_ value and testing\n+  static constexpr absl::string_view kInvalidGfx = \"gfx000\";\n+\n+ private:\n+  /// \\brief Takes one or more arrays of string-like objects and tests if the\n+  /// result of `gfx_version()` matches to any string in any of the arrays.\n+  template <typename... ArrayOfStrings>\n+  bool IsThisGfxInAnyList(ArrayOfStrings&&... arr) const {\n+    static_assert(sizeof...(arr) >= 1);\n+    const auto gfx = gfx_version();\n+    return (implIsThisGfxInAnyList(std::begin(arr), std::end(arr), gfx) || ...);\n+  }\n+\n+  /// \\brief Template-less implementation of IsThisGfxInAnyList().\n+  /// \\warning Don't use directly!\n+  bool implIsThisGfxInAnyList(const absl::string_view* beg,\n+                              const absl::string_view* end,\n+                              const std::string& gfx) const {\n+    return std::any_of(beg, end, [&gfx = gfx](const absl::string_view& s) {\n+      return gfx == s;\n+    });\n+  }\n+\n+  std::string gcn_arch_name_{kInvalidGfx};  // default to invalid arch.\n+};\n+\n+}  // namespace stream_executor\n+\n+#endif  // XLA_STREAM_EXECUTOR_ROCM_ROCM_COMPUTE_CAPABILITY_H_"
        }
    ],
    "stats": {
        "total": 416,
        "additions": 228,
        "deletions": 188
    }
}