{
    "author": "beckerhe",
    "message": "Introduce KernelArgumentPackingSpec\n\nThis is a declarative way of defining a transformation from `xla::emitters::KernelArguments` to the actual kernel launch arguments that a specific CUDA or ROCm kernel needs.\n\n`xla::emitters::KernelArguments` derives the kernel arguments from the HLO parameters and result. It's order is fixed and the argument type is always a pointer to a buffer since every HLO value is getting turned into a buffer.\n\nCurrently when we want to launch a custom kernel that don't comply with the order of `xla::emitters::KernelArguments` or when we need some additional parameters we define a `stream_executor::Kernel::KernelArgsPacking` which is callback function that does the argument packing (transformation). This is infinitively flexible but doesn't allow serialization to a proto.\n\n`KernelArgumentPackingSpec` solves that by allowing to create the kernel arguments ahead of time with some placeholders where later on the buffer addresses will be inserted.\n\nPiperOrigin-RevId: 829833532",
    "sha": "07289c060d0a50f56f4b364e3b9ff4a6db556c33",
    "files": [
        {
            "sha": "5e657c7b017f930cd4ce34abd5298a50125732b1",
            "filename": "third_party/xla/xla/stream_executor/BUILD",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2FBUILD?ref=07289c060d0a50f56f4b364e3b9ff4a6db556c33",
            "patch": "@@ -594,6 +594,48 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"kernel_argument_packing_spec\",\n+    srcs = [\"kernel_argument_packing_spec.cc\"],\n+    hdrs = [\"kernel_argument_packing_spec.h\"],\n+    deps = [\n+        \":device_memory\",\n+        \":kernel_args_packed_vector\",\n+        \":kernel_argument_packing_spec_proto_cc\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/base\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)\n+\n+tf_proto_library(\n+    name = \"kernel_argument_packing_spec_proto\",\n+    srcs = [\"kernel_argument_packing_spec.proto\"],\n+)\n+\n+xla_cc_test(\n+    name = \"kernel_argument_packing_spec_test\",\n+    srcs = [\"kernel_argument_packing_spec_test.cc\"],\n+    deps = [\n+        \":device_memory\",\n+        \":kernel_args_packed_vector\",\n+        \":kernel_argument_packing_spec\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/util/proto:parse_text_proto\",\n+        \"//xla/tsl/util/proto:proto_matchers\",\n+        \"@com_google_absl//absl/base\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@com_google_protobuf//:protobuf\",\n+    ],\n+)\n+\n cc_library(\n     name = \"kernel\",\n     srcs = [\"kernel.cc\"],"
        },
        {
            "sha": "e161f3f308351638cbd626e5bc31db6a1a5ec306",
            "filename": "third_party/xla/xla/stream_executor/kernel_argument_packing_spec.cc",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.cc?ref=07289c060d0a50f56f4b364e3b9ff4a6db556c33",
            "patch": "@@ -0,0 +1,172 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/kernel_argument_packing_spec.h\"\n+\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/base/casts.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/kernel_args_packed_vector.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace stream_executor {\n+namespace {\n+ArgumentPackingRelocationProto::Type ToProtoType(\n+    ArgumentPackingRelocation::Type type) {\n+  switch (type) {\n+    case ArgumentPackingRelocation::Type::kBits64Absolute:\n+      return ArgumentPackingRelocationProto::TYPE_BITS64_ABSOLUTE;\n+  }\n+}\n+\n+absl::StatusOr<ArgumentPackingRelocation::Type> FromProtoType(\n+    ArgumentPackingRelocationProto::Type type) {\n+  switch (type) {\n+    case ArgumentPackingRelocationProto::TYPE_BITS64_ABSOLUTE:\n+      return ArgumentPackingRelocation::Type::kBits64Absolute;\n+    default:\n+      return absl::InvalidArgumentError(absl::StrFormat(\n+          \"Unsupported relocation type: %d\", static_cast<int>(type)));\n+  }\n+}\n+}  // namespace\n+\n+absl::StatusOr<std::vector<char>> SingleArgumentPackingSpec::BuildArgument(\n+    absl::Span<const DeviceMemoryBase> args) const {\n+  auto argument = storage_;\n+\n+  for (const ArgumentPackingRelocation& relocation : relocations_) {\n+    switch (relocation.type()) {\n+      case ArgumentPackingRelocation::Type::kBits64Absolute: {\n+        if (args.size() <= relocation.argument_index()) {\n+          return absl::InvalidArgumentError(\n+              absl::StrFormat(\"Not enough arguments for relocation (expected \"\n+                              \"at least %d, but got %d)\",\n+                              relocation.argument_index(), args.size()));\n+        }\n+        if (relocation.offset() + sizeof(uint64_t) > argument.size()) {\n+          return absl::InvalidArgumentError(\n+              absl::StrFormat(\"Not enough storage for relocation (expected \"\n+                              \"at least %d, but got %d)\",\n+                              sizeof(void*), argument.size()));\n+        }\n+        uint64_t ptr = absl::bit_cast<uint64_t>(\n+            args.at(relocation.argument_index()).opaque());\n+        std::memcpy(argument.data() + relocation.offset(), &ptr, sizeof(ptr));\n+        break;\n+      }\n+      default:\n+        return absl::InvalidArgumentError(\n+            absl::StrFormat(\"Unsupported relocation type: %d\",\n+                            static_cast<int>(relocation.type())));\n+    }\n+  }\n+  return argument;\n+}\n+\n+void SingleArgumentPackingSpec::WriteArgumentAddress(int argument_index) {\n+  relocations_.push_back(ArgumentPackingRelocation(\n+      ArgumentPackingRelocation::Type::kBits64Absolute, argument_index,\n+      /*offset=*/storage_.size()));\n+  storage_.insert(storage_.end(), sizeof(uint64_t), 0);\n+}\n+\n+absl::StatusOr<std::unique_ptr<KernelArgsPackedVector>>\n+KernelArgumentsPackingSpec::BuildArguments(\n+    absl::Span<const DeviceMemoryBase> thunk_arguments,\n+    size_t shared_memory_bytes) const {\n+  std::vector<std::vector<char>> result;\n+  result.reserve(kernel_arguments_.size());\n+  for (const SingleArgumentPackingSpec& kernel_argument : kernel_arguments_) {\n+    TF_ASSIGN_OR_RETURN(result.emplace_back(),\n+                        kernel_argument.BuildArgument(thunk_arguments));\n+  }\n+  return std::make_unique<KernelArgsPackedVector>(std::move(result),\n+                                                  shared_memory_bytes);\n+}\n+absl::StatusOr<SingleArgumentPackingSpecProto>\n+SingleArgumentPackingSpec::ToProto() const {\n+  SingleArgumentPackingSpecProto proto;\n+  for (const ArgumentPackingRelocation& relocation : relocations_) {\n+    TF_ASSIGN_OR_RETURN(*proto.add_relocations(), relocation.ToProto());\n+  }\n+  proto.set_data(storage_.data(), storage_.size());\n+  return proto;\n+}\n+\n+absl::StatusOr<SingleArgumentPackingSpec> SingleArgumentPackingSpec::FromProto(\n+    const SingleArgumentPackingSpecProto& proto) {\n+  std::vector<char> storage(proto.data().begin(), proto.data().end());\n+  std::vector<ArgumentPackingRelocation> relocations;\n+  for (const ArgumentPackingRelocationProto& relocation_proto :\n+       proto.relocations()) {\n+    TF_ASSIGN_OR_RETURN(ArgumentPackingRelocation relocation,\n+                        ArgumentPackingRelocation::FromProto(relocation_proto));\n+    relocations.push_back(std::move(relocation));\n+  }\n+  return SingleArgumentPackingSpec(std::move(storage), std::move(relocations));\n+}\n+\n+absl::StatusOr<ArgumentPackingRelocationProto>\n+ArgumentPackingRelocation::ToProto() const {\n+  ArgumentPackingRelocationProto proto;\n+  proto.set_type(ToProtoType(type_));\n+  proto.set_argument_index(argument_index_);\n+  proto.set_offset(offset_);\n+  return proto;\n+}\n+\n+absl::StatusOr<ArgumentPackingRelocation> ArgumentPackingRelocation::FromProto(\n+    const ArgumentPackingRelocationProto& proto) {\n+  TF_ASSIGN_OR_RETURN(ArgumentPackingRelocation::Type type,\n+                      FromProtoType(proto.type()));\n+  return ArgumentPackingRelocation(type, proto.argument_index(),\n+                                   proto.offset());\n+}\n+\n+absl::StatusOr<KernelArgumentsPackingSpecProto>\n+KernelArgumentsPackingSpec::ToProto() const {\n+  KernelArgumentsPackingSpecProto proto;\n+  for (const SingleArgumentPackingSpec& kernel_argument : kernel_arguments_) {\n+    TF_ASSIGN_OR_RETURN(*proto.add_kernel_arguments(),\n+                        kernel_argument.ToProto());\n+  }\n+  return proto;\n+}\n+\n+absl::StatusOr<KernelArgumentsPackingSpec>\n+KernelArgumentsPackingSpec::FromProto(\n+    const KernelArgumentsPackingSpecProto& proto) {\n+  std::vector<SingleArgumentPackingSpec> kernel_arguments;\n+  for (const SingleArgumentPackingSpecProto& kernel_argument_proto :\n+       proto.kernel_arguments()) {\n+    TF_ASSIGN_OR_RETURN(\n+        SingleArgumentPackingSpec kernel_argument,\n+        SingleArgumentPackingSpec::FromProto(kernel_argument_proto));\n+    kernel_arguments.push_back(std::move(kernel_argument));\n+  }\n+  return KernelArgumentsPackingSpec(std::move(kernel_arguments));\n+}\n+\n+}  // namespace stream_executor"
        },
        {
            "sha": "eb04e5fd7a645806a388696b9d186ce42a3ff3a0",
            "filename": "third_party/xla/xla/stream_executor/kernel_argument_packing_spec.h",
            "status": "added",
            "additions": 187,
            "deletions": 0,
            "changes": 187,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.h?ref=07289c060d0a50f56f4b364e3b9ff4a6db556c33",
            "patch": "@@ -0,0 +1,187 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_STREAM_EXECUTOR_KERNEL_ARGUMENT_PACKING_SPEC_H_\n+#define XLA_STREAM_EXECUTOR_KERNEL_ARGUMENT_PACKING_SPEC_H_\n+\n+#include <array>\n+#include <cstddef>\n+#include <cstring>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/log.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/kernel_args_packed_vector.h\"\n+#include \"xla/stream_executor/kernel_argument_packing_spec.pb.h\"\n+\n+namespace stream_executor {\n+\n+// Represents a relocation of an argument to a specific location in the\n+// packed argument buffer. Imagine an arbitrary buffer of bytes with a\n+// placeholder that later on will be replaced by the runtime with a\n+// pointer to the actual argument. Currently only supports 64 bit absolute\n+// pointers to device memory.\n+class ArgumentPackingRelocation {\n+ public:\n+  enum class Type { kBits64Absolute };\n+\n+  explicit ArgumentPackingRelocation(Type type, int argument_index,\n+                                     size_t offset)\n+      : type_(type), argument_index_(argument_index), offset_(offset) {}\n+  Type type() const { return type_; }\n+  int argument_index() const { return argument_index_; }\n+  size_t offset() const { return offset_; }\n+\n+  absl::StatusOr<ArgumentPackingRelocationProto> ToProto() const;\n+\n+  static absl::StatusOr<ArgumentPackingRelocation> FromProto(\n+      const ArgumentPackingRelocationProto& proto);\n+\n+ private:\n+  Type type_;\n+  int argument_index_;\n+  size_t offset_;\n+};\n+\n+// Represents the packing spec for a single argument of a kernel. So this is a\n+// buffer of bytes and a list of relocations (placeholders) that describe\n+// where later on argument buffer addresses will be written to.\n+class SingleArgumentPackingSpec {\n+ public:\n+  SingleArgumentPackingSpec() = default;\n+  SingleArgumentPackingSpec(std::vector<char> storage,\n+                            std::vector<ArgumentPackingRelocation> relocations)\n+      : storage_(std::move(storage)), relocations_(std::move(relocations)) {}\n+\n+  // Materializes the argument buffer for this packing spec. The `args` span\n+  // must contain at least the number of arguments referenced in the packing\n+  // spec, otherwise an error will be returned.\n+  absl::StatusOr<std::vector<char>> BuildArgument(\n+      absl::Span<const DeviceMemoryBase> args) const;\n+\n+  // Writes a placeholder to the argument packing spec that will be replaced\n+  // by the runtime with the address of the argument `argument_index`th\n+  // argument. Currently this is always a 64bits absolute pointer to device\n+  // memory. Other types of relocations will be added in the future if needed.\n+  void WriteArgumentAddress(int argument_index);\n+\n+  // Writes a constant value to the argument packing spec. The value must be\n+  // trivially copyable.\n+  template <typename T>\n+  void WriteConstant(T value) {\n+    static_assert(std::is_trivially_copyable_v<T>,\n+                  \"The given value must be trivially copyable\");\n+    std::array<char, sizeof(T)> temp_storage;\n+    std::memcpy(temp_storage.data(), &value, sizeof(T));\n+    storage_.insert(storage_.end(), temp_storage.begin(), temp_storage.end());\n+  }\n+\n+  absl::StatusOr<SingleArgumentPackingSpecProto> ToProto() const;\n+\n+  static absl::StatusOr<SingleArgumentPackingSpec> FromProto(\n+      const SingleArgumentPackingSpecProto& proto);\n+\n+ private:\n+  std::vector<char> storage_;\n+  std::vector<ArgumentPackingRelocation> relocations_;\n+};\n+\n+// `KernelArgumentsPackingSpec` defines how to convert a list of device buffer\n+// pointers into a packed argument buffer that can be passed to a device kernel.\n+//\n+// When calling a custom kernel from XLA each HLO parameter and HLO result is\n+// represented as a device buffer pointer and by default the custom kernel gets\n+// launched with those pointers as kernel arguments in a predefined order -\n+// input parameters first, then output parameters.\n+//\n+// This is very inflexible so KernelArgumentsPackingSpec allows to specify a\n+// transformation from a list of device buffer pointers (usually created by\n+// xla::emitters::KernelArguments) to a packed argument buffer (list of byte\n+// arrays). Each argument of the custom kernel can be a buffer of arbitrary\n+// bytes with a list of placeholders (which we call relocations - similar to\n+// linker relocations) that will be replaced by the runtime with the address of\n+// the corresponding device buffer.\n+//\n+// Since this is all declarative it is also possible to serialize\n+// KernelArgumentsPackingSpec to a proto.\n+//\n+// Usage example: We want to launch a kernel that has the following launch\n+// arguments:\n+// - Output buffer pointer\n+// - Input buffer pointer\n+// - Constant value 42\n+//\n+// KernelArgumentsPackingSpec packing_spec;\n+// // `1` refers to the second argument as defined by\n+// // xla::emitters::KernelArguments. In case of 1 HLO input this is the first\n+// // output buffer.\n+// packing_spec.AddAddressArgument(1);\n+// // `0` refers to the first argument as defined by\n+// // xla::emitters::KernelArguments.\n+// packing_spec.AddAddressArgument(0);\n+// packing_spec.AddConstantArgument<int64_t>(42);\n+//\n+// custom_kernel.SetArgumentsPackingSpec(packing_spec);\n+//\n+// Now the custom kernel gets launched with a packed argument buffer that looks\n+// like this: | output_ptr | input_ptr | 42 |\n+class KernelArgumentsPackingSpec {\n+ public:\n+  KernelArgumentsPackingSpec() = default;\n+  explicit KernelArgumentsPackingSpec(\n+      std::vector<SingleArgumentPackingSpec> kernel_arguments)\n+      : kernel_arguments_(std::move(kernel_arguments)) {}\n+\n+  // Adds a single argument packing spec to the kernel arguments packing spec.\n+  void AddArgument(SingleArgumentPackingSpec spec) {\n+    kernel_arguments_.push_back(std::move(spec));\n+  }\n+\n+  // Adds a an argument that only contains a pointer to the `argument_index`th\n+  // argument.\n+  void AddAddressArgument(int argument_index) {\n+    kernel_arguments_.push_back(SingleArgumentPackingSpec());\n+    kernel_arguments_.back().WriteArgumentAddress(argument_index);\n+  }\n+\n+  template <typename T>\n+  void AddConstantArgument(T value) {\n+    kernel_arguments_.push_back(SingleArgumentPackingSpec());\n+    kernel_arguments_.back().WriteConstant(value);\n+  }\n+\n+  // Materializes the argument buffers for this packing spec. The `args` span\n+  // must contain at least the number of arguments referenced in the packing\n+  // spec, otherwise an error will be returned.\n+  absl::StatusOr<std::unique_ptr<KernelArgsPackedVector>> BuildArguments(\n+      absl::Span<const DeviceMemoryBase> thunk_arguments,\n+      size_t shared_memory_bytes) const;\n+\n+  absl::StatusOr<KernelArgumentsPackingSpecProto> ToProto() const;\n+\n+  static absl::StatusOr<KernelArgumentsPackingSpec> FromProto(\n+      const KernelArgumentsPackingSpecProto& proto);\n+\n+ private:\n+  std::vector<SingleArgumentPackingSpec> kernel_arguments_;\n+};\n+\n+}  // namespace stream_executor\n+\n+#endif  // XLA_STREAM_EXECUTOR_KERNEL_ARGUMENT_PACKING_SPEC_H_"
        },
        {
            "sha": "fe2d86def0d43617a105e23155c1400a2c94b312",
            "filename": "third_party/xla/xla/stream_executor/kernel_argument_packing_spec.proto",
            "status": "added",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec.proto?ref=07289c060d0a50f56f4b364e3b9ff4a6db556c33",
            "patch": "@@ -0,0 +1,26 @@\n+syntax = \"proto3\";\n+\n+package stream_executor;\n+\n+option java_multiple_files = true;\n+option java_outer_classname = \"KernelArgumentPackingSpec\";\n+\n+message ArgumentPackingRelocationProto {\n+  enum Type {\n+    TYPE_UNSPECIFIED = 0;\n+    TYPE_BITS64_ABSOLUTE = 1;\n+  }\n+\n+  Type type = 1;\n+  int32 argument_index = 2;\n+  int64 offset = 3;\n+}\n+\n+message SingleArgumentPackingSpecProto {\n+  repeated ArgumentPackingRelocationProto relocations = 1;\n+  bytes data = 2;\n+}\n+\n+message KernelArgumentsPackingSpecProto {\n+  repeated SingleArgumentPackingSpecProto kernel_arguments = 1;\n+}"
        },
        {
            "sha": "2ced74b15c006212cd3a9622e867595a7abd74ef",
            "filename": "third_party/xla/xla/stream_executor/kernel_argument_packing_spec_test.cc",
            "status": "added",
            "additions": 218,
            "deletions": 0,
            "changes": 218,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07289c060d0a50f56f4b364e3b9ff4a6db556c33/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fkernel_argument_packing_spec_test.cc?ref=07289c060d0a50f56f4b364e3b9ff4a6db556c33",
            "patch": "@@ -0,0 +1,218 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/kernel_argument_packing_spec.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/base/casts.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/kernel_args_packed_vector.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/util/proto/parse_text_proto.h\"\n+#include \"xla/tsl/util/proto/proto_matchers.h\"\n+\n+namespace stream_executor {\n+namespace {\n+using absl_testing::IsOkAndHolds;\n+using absl_testing::StatusIs;\n+using ::testing::ElementsAre;\n+using ::testing::SizeIs;\n+using tsl::proto_testing::EqualsProto;\n+using tsl::proto_testing::ParseTextProtoOrDie;\n+\n+TEST(SingleArgumentPackingSpecTest, WriteArgumentAddress) {\n+  SingleArgumentPackingSpec first_arg;\n+  first_arg.WriteArgumentAddress(/*argument_index=*/2);\n+\n+  // We fail if not enough arguments are provided.Since we are referencing\n+  // argument #2, we will need to provide 3 arguments.\n+  EXPECT_THAT(first_arg.BuildArgument({DeviceMemoryBase(nullptr, /*size=*/0),\n+                                       DeviceMemoryBase(nullptr, /*size=*/0)}),\n+              StatusIs(absl::StatusCode::kInvalidArgument));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::vector<char> first_arg_storage,\n+      first_arg.BuildArgument(\n+          {DeviceMemoryBase(nullptr, /*size=*/0),\n+           DeviceMemoryBase(nullptr, /*size=*/0),\n+           DeviceMemoryBase(\n+               absl::bit_cast<void*>(static_cast<uintptr_t>(0xff42)),\n+               /*size=*/0)}));\n+  EXPECT_THAT(first_arg_storage,\n+              ElementsAre(0x42, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));\n+}\n+\n+TEST(SingleArgumentPackingSpecTest, WriteMultipleArgumentAddresses) {\n+  SingleArgumentPackingSpec first_arg;\n+  first_arg.WriteArgumentAddress(/*argument_index=*/0);\n+  first_arg.WriteArgumentAddress(/*argument_index=*/1);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::vector<char> first_arg_storage,\n+      first_arg.BuildArgument(\n+          {DeviceMemoryBase(\n+               absl::bit_cast<void*>(static_cast<uintptr_t>(0xff42)),\n+               /*size=*/0),\n+           DeviceMemoryBase(\n+               absl::bit_cast<void*>(static_cast<uintptr_t>(0xaabbccdd)),\n+               /*size=*/0)}));\n+  EXPECT_THAT(first_arg_storage,\n+              ElementsAre(0x42, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdd,\n+                          0xcc, 0xbb, 0xaa, 0x00, 0x00, 0x00, 0x00));\n+}\n+\n+TEST(SingleArgumentPackingSpecTest, WriteConstant) {\n+  SingleArgumentPackingSpec first_arg;\n+  first_arg.WriteConstant(0x1348);\n+  first_arg.WriteConstant(0x2389ul);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::vector<char> first_arg_storage,\n+                          first_arg.BuildArgument(/*args=*/{}));\n+\n+  // SingleArgumentPackingSpec::WriteConstant doesn't take endianness into\n+  // account, so this assertion will fail for big endian architectures - which\n+  // we don't support anyway.\n+  EXPECT_THAT(first_arg_storage,\n+              ElementsAre(0x48, 0x13, 0x00, 0x00, 0x89, 0x23, 0x00, 0x00, 0x00,\n+                          0x00, 0x00, 0x00));\n+}\n+\n+TEST(SingleArgumentPackingSpecTest, WriteConstantAndAddress) {\n+  SingleArgumentPackingSpec first_arg;\n+  first_arg.WriteArgumentAddress(/*argument_index=*/0);\n+  first_arg.WriteConstant(0x1234);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::vector<char> first_arg_storage,\n+      first_arg.BuildArgument({DeviceMemoryBase(\n+          absl::bit_cast<void*>(static_cast<uintptr_t>(0xff42)), 0)}));\n+\n+  EXPECT_THAT(first_arg_storage,\n+              ElementsAre(0x42, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34,\n+                          0x12, 0x00, 0x00));\n+}\n+\n+TEST(SingleArgumentPackingSpecTest, ToProto) {\n+  SingleArgumentPackingSpec first_arg;\n+  first_arg.WriteConstant(0x1234);\n+  first_arg.WriteArgumentAddress(/*argument_index=*/0);\n+\n+  EXPECT_THAT(\n+      first_arg.ToProto(), IsOkAndHolds(EqualsProto(R\"pb(\n+        relocations { type: TYPE_BITS64_ABSOLUTE argument_index: 0 offset: 4 }\n+        data: \"\\x34\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+      )pb\")));\n+}\n+\n+TEST(SingleArgumentPackingSpecTest, FromProto) {\n+  auto proto = ParseTextProtoOrDie<SingleArgumentPackingSpecProto>(\n+      R\"pb(\n+        relocations { type: TYPE_BITS64_ABSOLUTE argument_index: 0 offset: 4 }\n+        data: \"\\x34\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+      )pb\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(SingleArgumentPackingSpec spec,\n+                          SingleArgumentPackingSpec::FromProto(proto));\n+  EXPECT_THAT(spec.BuildArgument({DeviceMemoryBase(\n+                  absl::bit_cast<void*>(static_cast<uintptr_t>(0xff42)), 0)}),\n+              IsOkAndHolds(ElementsAre(0x34, 0x12, 0x00, 0x00, 0x42, 0xff, 0x00,\n+                                       0x00, 0x00, 0x00, 0x00, 0x00)));\n+}\n+\n+TEST(KernelArgumentsPackingSpecTest, BuildArguments) {\n+  KernelArgumentsPackingSpec spec;\n+  spec.AddAddressArgument(/*argument_index=*/0);\n+  spec.AddConstantArgument(0x1234);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<KernelArgsPackedVector> packed_args,\n+      spec.BuildArguments(\n+          {DeviceMemoryBase(\n+              absl::bit_cast<void*>(static_cast<uintptr_t>(0xff42)), 0)},\n+          /*shared_memory_bytes=*/8989));\n+  EXPECT_EQ(packed_args->number_of_arguments(), 2);\n+  EXPECT_EQ(packed_args->number_of_shared_bytes(), 8989);\n+  EXPECT_EQ(packed_args->argument_addresses().size(), 2);\n+  EXPECT_THAT(\n+      absl::Span<const char>(\n+          absl::bit_cast<const char*>(packed_args->argument_addresses().at(0)),\n+          8),\n+      ElementsAre(0x42, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));\n+  EXPECT_THAT(\n+      absl::Span<const char>(\n+          absl::bit_cast<const char*>(packed_args->argument_addresses().at(1)),\n+          4),\n+      ElementsAre(0x34, 0x12, 0x00, 0x00));\n+}\n+\n+TEST(KernelArgumentsPackingSpecTest, ToProto) {\n+  KernelArgumentsPackingSpec spec;\n+  spec.AddAddressArgument(/*argument_index=*/33);\n+  spec.AddConstantArgument(0x1234);\n+\n+  EXPECT_THAT(spec.ToProto(), IsOkAndHolds(EqualsProto(R\"pb(\n+                kernel_arguments {\n+                  relocations {\n+                    type: TYPE_BITS64_ABSOLUTE\n+                    argument_index: 33\n+                    offset: 0\n+                  }\n+                  data: \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+                }\n+                kernel_arguments { data: \"\\x34\\x12\\x00\\x00\" }\n+              )pb\")));\n+}\n+\n+TEST(KernelArgumentsPackingSpecTest, FromProto) {\n+  auto proto = ParseTextProtoOrDie<KernelArgumentsPackingSpecProto>(\n+      R\"pb(\n+        kernel_arguments {\n+          relocations { type: TYPE_BITS64_ABSOLUTE argument_index: 0 offset: 0 }\n+          data: \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+        }\n+        kernel_arguments { data: \"\\x34\\x12\\x00\\x00\" }\n+      )pb\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(KernelArgumentsPackingSpec spec,\n+                          KernelArgumentsPackingSpec::FromProto(proto));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<KernelArgsPackedVector> arguments,\n+      spec.BuildArguments(\n+          {DeviceMemoryBase(\n+              absl::bit_cast<void*>(static_cast<uintptr_t>(0xff42)), 0)},\n+          /*shared_memory_bytes=*/8989));\n+  EXPECT_EQ(arguments->number_of_arguments(), 2);\n+  EXPECT_EQ(arguments->number_of_shared_bytes(), 8989);\n+  ASSERT_THAT(arguments->argument_addresses(), SizeIs(2));\n+  EXPECT_THAT(absl::Span<const char>(absl::bit_cast<const char*>(\n+                                         arguments->argument_addresses().at(0)),\n+                                     8),\n+              ElementsAre(0x42, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));\n+  EXPECT_THAT(absl::Span<const char>(absl::bit_cast<const char*>(\n+                                         arguments->argument_addresses().at(1)),\n+                                     4),\n+              ElementsAre(0x34, 0x12, 0x00, 0x00));\n+}\n+\n+}  // namespace\n+}  // namespace stream_executor"
        }
    ],
    "stats": {
        "total": 645,
        "additions": 645,
        "deletions": 0
    }
}