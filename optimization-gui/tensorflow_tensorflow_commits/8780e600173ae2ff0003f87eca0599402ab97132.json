{
    "author": "ezhulenev",
    "message": "[xla:pjrt] Make PjRtFuture<T> an alias to xla::Future<T> which itself is an alias to tsl::Future<T>\n\nPiperOrigin-RevId: 811201539",
    "sha": "8780e600173ae2ff0003f87eca0599402ab97132",
    "files": [
        {
            "sha": "c0897e9408a50c836cf313ef0f3a04f5cb978210",
            "filename": "third_party/xla/xla/BUILD",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2FBUILD?ref=8780e600173ae2ff0003f87eca0599402ab97132",
            "patch": "@@ -418,6 +418,13 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"future\",\n+    hdrs = [\"future.h\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\"//xla/tsl/concurrency:future\"],\n+)\n+\n cc_library(\n     name = \"shape_util\",\n     srcs = ["
        },
        {
            "sha": "c323545ed77d8dfa3b59a9223e218c1d99ec751f",
            "filename": "third_party/xla/xla/future.h",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ffuture.h?ref=8780e600173ae2ff0003f87eca0599402ab97132",
            "patch": "@@ -0,0 +1,30 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_FUTURE_H_\n+#define XLA_FUTURE_H_\n+\n+#include \"xla/tsl/concurrency/future.h\"  // IWYU pragma: export\n+\n+namespace xla {\n+\n+using ::tsl::Future;\n+using ::tsl::FutureHelpers;\n+using ::tsl::JoinFutures;\n+using ::tsl::Promise;\n+\n+}  // namespace xla\n+\n+#endif  // XLA_FUTURE_H_"
        },
        {
            "sha": "7ea2b35dbeac2dcb0d8ce3323b9cf0b6cea962fd",
            "filename": "third_party/xla/xla/pjrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 24,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD?ref=8780e600173ae2ff0003f87eca0599402ab97132",
            "patch": "@@ -794,35 +794,12 @@ xla_cc_test(\n \n cc_library(\n     name = \"pjrt_future\",\n-    srcs = [\"pjrt_future.cc\"],\n     hdrs = [\"pjrt_future.h\"],\n     visibility = internal_visibility([\":friends\"]),\n     deps = [\n+        \"//xla:future\",\n         \"//xla/tsl/concurrency:async_value\",\n         \"//xla/tsl/concurrency:ref_count\",\n-        \"//xla/tsl/platform:logging\",\n-        \"@com_google_absl//absl/base:core_headers\",\n-        \"@com_google_absl//absl/base:no_destructor\",\n-        \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/meta:type_traits\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/synchronization\",\n-        \"@com_google_absl//absl/types:span\",\n-        \"@com_google_absl//absl/utility\",\n-    ],\n-)\n-\n-xla_cc_test(\n-    name = \"pjrt_future_test\",\n-    srcs = [\"pjrt_future_test.cc\"],\n-    deps = [\n-        \":pjrt_future\",\n-        \"//xla/tsl/platform:test\",\n-        \"//xla/tsl/platform:test_benchmark\",\n-        \"//xla/tsl/platform:test_main\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/status:statusor\",\n     ],\n )\n "
        },
        {
            "sha": "9e47386e8a01d1ded9587ca8d5f1dab3d12ebb23",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 96,
            "changes": 96,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eab7ef416c387381100208584c8b08038c6efe41/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eab7ef416c387381100208584c8b08038c6efe41/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.cc?ref=eab7ef416c387381100208584c8b08038c6efe41",
            "patch": "@@ -1,96 +0,0 @@\n-/* Copyright 2023 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/pjrt/pjrt_future.h\"\n-\n-#include <atomic>\n-#include <cstdint>\n-#include <memory>\n-#include <tuple>\n-#include <utility>\n-\n-#include \"absl/base/no_destructor.h\"\n-#include \"absl/base/optimization.h\"\n-#include \"absl/base/thread_annotations.h\"\n-#include \"absl/log/check.h\"\n-#include \"absl/log/log.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/synchronization/mutex.h\"\n-#include \"absl/types/span.h\"\n-#include \"xla/tsl/concurrency/async_value_ref.h\"\n-\n-namespace xla {\n-\n-// Construct an immediately ready promise in the static storage. This avoids\n-// heap allocation and reference counting operations on a hot path.\n-static tsl::internal::AsyncValueStorage<absl::Status> ready_promise_storage;\n-absl::NoDestructor<tsl::AsyncValueOwningRef<absl::Status>>\n-    PjRtFuture<>::ready_promise_(\n-        tsl::MakeAvailableAsyncValueRef<absl::Status>(ready_promise_storage));\n-\n-namespace {\n-struct State {\n-  explicit State(int32_t size) : pending_count(size) {\n-    std::tie(promise, future) = PjRtFuture<>::MakePromise();\n-  }\n-\n-  std::atomic<int32_t> pending_count;\n-  PjRtFuture<>::Promise promise;\n-  PjRtFuture<> future;\n-\n-  absl::Mutex mu;\n-  absl::Status status ABSL_GUARDED_BY(&mu);\n-};\n-}  // namespace\n-\n-PjRtFuture<> JoinFutures(absl::Span<const PjRtFuture<>> futures) {\n-  VLOG(2) << \"xla::JoinFutures: \" << futures.size() << \" futures\";\n-  if (futures.empty()) {\n-    return PjRtFuture<>(absl::OkStatus());\n-  }\n-  if (futures.size() == 1) {\n-    return futures.front();\n-  }\n-\n-  auto state = std::make_shared<State>(futures.size());\n-\n-  for (const PjRtFuture<>& future : futures) {\n-    future.OnReady([state](absl::Status status) {\n-      if (ABSL_PREDICT_FALSE(!status.ok())) {\n-        absl::MutexLock lock(&state->mu);\n-        if (VLOG_IS_ON(2)) {\n-          if (!state->status.ok() && status.code() != state->status.code()) {\n-            VLOG(2) << \"Ignoring status \" << status\n-                    << \" because first error was \" << state->status;\n-          }\n-        }\n-        state->status.Update(status);\n-      }\n-\n-      int32_t pending_count =\n-          state->pending_count.fetch_sub(1, std::memory_order_acq_rel);\n-      CHECK_GE(pending_count, 1) << \"Pending count can't drop below 0\";\n-\n-      if (pending_count == 1) {\n-        absl::MutexLock lock(&state->mu);\n-        state->promise.Set(std::move(state->status));\n-      }\n-    });\n-  }\n-\n-  return std::move(state->future);\n-}\n-\n-}  // namespace xla"
        },
        {
            "sha": "8d57c2ffd59a9f95a8c8fb563320d0d33aa2cf2b",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 10,
            "deletions": 910,
            "changes": 920,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8780e600173ae2ff0003f87eca0599402ab97132/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=8780e600173ae2ff0003f87eca0599402ab97132",
            "patch": "@@ -16,37 +16,16 @@ limitations under the License.\n #ifndef XLA_PJRT_PJRT_FUTURE_H_\n #define XLA_PJRT_PJRT_FUTURE_H_\n \n-#include <algorithm>\n-#include <cstdint>\n-#include <functional>\n-#include <memory>\n-#include <type_traits>\n-#include <utility>\n-\n-#include \"absl/base/no_destructor.h\"\n-#include \"absl/base/optimization.h\"\n-#include \"absl/meta/type_traits.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/types/span.h\"\n-#include \"absl/utility/utility.h\"\n+#include \"xla/future.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n-#include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n-#include \"xla/tsl/platform/logging.h\"\n \n namespace xla {\n \n-template <class T = void>\n-class PjRtFuture;\n-\n-namespace internal {\n-template <class T, bool is_move_only>\n-class PjRtFutureBase;\n-}\n+template <typename T = void>\n+using PjRtFuture = ::xla::Future<T>;\n \n-// Returns a `PjRtFuture` that will be successful if all `futures` complete\n-// successfully, or return a first encountered error.\n-PjRtFuture<> JoinFutures(absl::Span<const PjRtFuture<>> futures);\n+using PjRtFutureHelpers = ::xla::FutureHelpers;\n \n // An RAII event that a caller can use to tell the PjRtClient about asynchronous\n // actions outside PjRt.\n@@ -58,7 +37,7 @@ PjRtFuture<> JoinFutures(absl::Span<const PjRtFuture<>> futures);\n //\n // The caller can indicate that a ScopedAsyncTrackingEvent event cannot complete\n // until after some PjRtFuture becomes ready, by calling\n-// future.AssertHappensBefore(event).\n+// event.AddDependency(future).\n //\n // The caller indicates that the work tracked by the ScopedAsyncTrackingEvent\n // has completed by letting the event go out of scope.\n@@ -69,896 +48,17 @@ class ScopedAsyncTrackingEvent {\n  public:\n   virtual ~ScopedAsyncTrackingEvent() = default;\n \n- private:\n-  template <class T, bool is_move_only>\n-  friend class internal::PjRtFutureBase;\n-\n-  // Indicates that the ScopedAsyncTrackingEvent won't complete until dependency\n-  // becomes available. Called only by PjRtFuture.\n-  virtual void AddDependency(tsl::RCReference<tsl::AsyncValue> dependency) = 0;\n-};\n-\n-// Helpers for using PjRtFutures.\n-class PjRtFutureHelpers {\n- public:\n-  // Keys that are returned by an implementation-specific handler when a client\n-  // starts to block on a promise.\n-  //\n-  // For now, contains a single UID that can be used to identify a TraceMe, but\n-  // made extensible to allow support for other profilers such as endoscope.\n-  struct ProfilingKeys {\n-    uint64_t traceme_context_id = -1;\n-  };\n-\n-  // Signature of handler called by the PjRtFuture class before it starts to\n-  // block a thread.\n-  using OnBlockStartFn = std::function<ProfilingKeys()>;\n-\n-  // Signature of handler called by the PjRtFuture class after it finishes\n-  // blocking a thread.\n-  using OnBlockEndFn = std::function<void(ProfilingKeys)>;\n-\n-  // Returns a PjRtFuture<T> with optionally updated profiling handlers. If\n-  // profiling handlers are not provided, the original ones will be used.\n   template <typename T>\n-  static PjRtFuture<T> WithProfiling(PjRtFuture<T> future,\n-                                     OnBlockStartFn on_block_start = nullptr,\n-                                     OnBlockEndFn on_block_end = nullptr) {\n-    return PjRtFuture<T>(std::move(future.promise_),\n-                         on_block_start ? std::move(on_block_start)\n-                                        : std::move(future.on_block_start_),\n-                         on_block_end ? std::move(on_block_end)\n-                                      : std::move(future.on_block_end_));\n-  }\n-};\n-\n-namespace internal {\n-\n-// Detects absl::StatusOr<T> specializations to disable them for PjRtFuture<T>.\n-template <typename T>\n-struct IsStatusOr : public std::false_type {};\n-template <typename T>\n-struct IsStatusOr<absl::StatusOr<T>> : public std::true_type {};\n-\n-// A base class to conditionally disable copy constructor and assignment for a\n-// PjRtFuture<T> (by default we always disable copy constructor when `T` is not\n-// copyable), which makes PjRtFuture<T> an `std::unique_ptr`-like container for\n-// move-only types.\n-template <bool is_move_only>\n-class PjRtFutureMoveControl;\n-\n-template <>\n-class PjRtFutureMoveControl</*is_move_only=*/true> {\n- protected:\n-  PjRtFutureMoveControl() = default;\n-\n-  PjRtFutureMoveControl(const PjRtFutureMoveControl&) = delete;\n-  PjRtFutureMoveControl& operator=(const PjRtFutureMoveControl&) = delete;\n-\n-  PjRtFutureMoveControl(PjRtFutureMoveControl&&) = default;\n-  PjRtFutureMoveControl& operator=(PjRtFutureMoveControl&&) = default;\n-};\n-\n-template <>\n-class PjRtFutureMoveControl</*is_move_only=*/false> {\n- protected:\n-  PjRtFutureMoveControl() = default;\n-\n-  PjRtFutureMoveControl(const PjRtFutureMoveControl&) = default;\n-  PjRtFutureMoveControl& operator=(const PjRtFutureMoveControl&) = default;\n-\n-  PjRtFutureMoveControl(PjRtFutureMoveControl&&) = default;\n-  PjRtFutureMoveControl& operator=(PjRtFutureMoveControl&&) = default;\n-};\n-\n-// A base class for a stateful future PjRtFuture<T> and a stateless future\n-// PjRtFuture<>. If `is_move_only` is true, PjRtFuture derived from this class\n-// acts as a move-only type and the value can be passed to the caller only using\n-// move assignment (applied to Await and OnReady APIs).\n-template <typename T, bool is_move_only = !std::is_copy_constructible_v<T>>\n-class PjRtFutureBase : public PjRtFutureMoveControl<is_move_only> {\n- protected:\n-  // A protected constructor that hides AsyncValueRef implementation detail\n-  // from the end users of PjRtFuture and Promise. Must not be made public!\n-  PjRtFutureBase(tsl::AsyncValueRef<T> promise,\n-                 PjRtFutureHelpers::OnBlockStartFn on_block_start,\n-                 PjRtFutureHelpers::OnBlockEndFn on_block_end)\n-      : promise_(std::move(promise)),\n-        on_block_start_(std::move(on_block_start)),\n-        on_block_end_(std::move(on_block_end)) {}\n-\n- public:\n-  PjRtFutureBase() = default;\n-\n-  // Constructor for an already-available PjRtFuture.\n-  //\n-  // Typically used to eagerly return error values when async work will not\n-  // be enqueued, e.g., due to invalid arguments.\n-  explicit PjRtFutureBase(\n-      T t, PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-      PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr)\n-      : PjRtFutureBase(tsl::MakeAvailableAsyncValueRef<T>(std::move(t)),\n-                       std::move(on_block_start), std::move(on_block_end)) {}\n-\n-  bool IsValid() const { return promise_ != nullptr; }\n-\n-  // Two functions exist to know whether the future is ready, to accommodate\n-  // the fact some backends (e.g. distributed ones) could take a non-trivial\n-  // time to check the state of a future.\n-  //\n-  // `IsReady()` is guaranteed to return true if the future became ready\n-  // before `IsReady()` was called. `IsReady()` will return immediately if a\n-  // call to `Await()` has already returned, or any callback passed to\n-  // `OnReady` has already been triggered. Otherwise IsReady() may block for\n-  // the duration of a network message on some backends.\n-  bool IsReady() const {\n-    CHECK(IsValid());\n-    return promise_.IsAvailable();\n-  }\n-  // `IsKnownReady()` is guaranteed to return immediately. `IsKnownReady()` will\n-  // always return true if a call to `Await()` has already returned, or any\n-  // callback passed to `OnReady` has already been triggered. Otherwise,\n-  // `IsKnownReady()` may return false in some cases in which the future was\n-  // ready before `IsKnownReady()` was called.\n-  bool IsKnownReady() const {\n-    CHECK(IsValid());\n-    return promise_.IsAvailable();\n-  }\n-\n-  // Indicates that event will not complete until after this becomes ready.\n-  //\n-  // May safely be called with event==nullptr in which case AssertHappensBefore\n-  // has no effect.\n-  void AssertHappensBefore(ScopedAsyncTrackingEvent* event) {\n-    CHECK(IsValid());\n-    if (event) {\n-      event->AddDependency(promise_.CopyRCRef());\n-    }\n-  }\n-\n-  explicit operator bool() const { return static_cast<bool>(promise_); }\n-\n-  // Returns a pointer to the underlying AsyncValue that can be used to\n-  // track completion of a future. It is undefined behavior to access the\n-  // value stored in the AsyncValue.\n-  tsl::AsyncValue* async_value() const { return promise_.GetAsyncValue(); }\n-\n- protected:\n-  static constexpr bool IsMoveOnly() { return is_move_only; }\n-\n-  // PjRtFuture<T>::Promise provides a facility to store a value or an error\n-  // that is later acquired asynchronously via a PjRtFuture<T> constructed from\n-  // the promise object. Note that the promise object is meant to be used only\n-  // once (set value or error).\n-  class Promise {\n-   public:\n-    Promise() = default;\n-\n-    Promise(Promise&& other) = default;\n-    Promise& operator=(Promise&& other) = default;\n-\n-    explicit operator bool() const { return static_cast<bool>(promise_); }\n-\n-    // Returns if this promise is the unique reference to the underlying value.\n-    // That is, this method returns true only if all of the following conditions\n-    // are satisfied:\n-    //\n-    // - The promise is the only reference to the underlying value, i.e., there\n-    //   are no other promises or futures associated with this value.\n-    // - There are no OnReady callbacks registered to this promise.\n-    //\n-    // This may be used by the caller of `Set()` to short-circuit the work to\n-    // fulfill the promise if no one will ever consume the value. Even in that\n-    // case, consider fulfilling the promise with an error (e.g., `CANCELLED`)\n-    // instead of dropping the promise without fulfilling it in order to make\n-    // debugging easier. Also, be aware that the current promise may still be\n-    // used to mint a future.\n-    bool IsUniqueReference() const {\n-      return promise_.IsUnique() && !promise_.HasWaiter();\n-    }\n-\n-   protected:\n-    explicit Promise(tsl::AsyncValueRef<T> promise)\n-        : promise_(std::move(promise)) {}\n-\n-    template <typename... Args>\n-    void emplace(Args&&... args) const {\n-      DCHECK(promise_) << \"Promise must wrap an async value\";\n-      promise_.template emplace<Args...>(std::forward<Args>(args)...);\n-    }\n-\n-    // Takes a reference to the underlying AsyncValueRef container.\n-    tsl::AsyncValueRef<T> ref() const { return promise_; }\n-\n-   private:\n-    tsl::AsyncValueRef<T> promise_;\n-  };\n-\n-  class ProfilingCleanup {\n-   public:\n-    ProfilingCleanup(const PjRtFutureBase* parent,\n-                     PjRtFutureHelpers::ProfilingKeys keys)\n-        : parent_(parent), keys_(std::move(keys)) {}\n-    ~ProfilingCleanup() {\n-      if (parent_ && parent_->on_block_end_) {\n-        parent_->on_block_end_(std::move(keys_));\n-      }\n-    }\n-    ProfilingCleanup(const ProfilingCleanup& other) = delete;\n-    ProfilingCleanup(ProfilingCleanup&& other) = delete;\n-\n-   private:\n-    const PjRtFutureBase* parent_;\n-    PjRtFutureHelpers::ProfilingKeys keys_;\n-  };\n-\n-  ProfilingCleanup OnBlockStartScope() const {\n-    return ProfilingCleanup(this, on_block_start_\n-                                      ? on_block_start_()\n-                                      : PjRtFutureHelpers::ProfilingKeys());\n-  }\n-\n-  // Calls block_until_ready_fn to wait until the underlying AsyncValue is\n-  // concrete. block_until_ready_fn should be equivalent to\n-  // tsl::BlockUntilReady.\n-  template <typename Fn>\n-  void BlockUntilReady(Fn&& block_until_ready_fn) const {\n-    CHECK(IsValid());\n-    if (!promise_.IsAvailable()) {\n-      ProfilingCleanup scope = OnBlockStartScope();\n-      block_until_ready_fn(promise_.GetAsyncValue());\n-    }\n-    DCHECK(promise_.IsConcrete());\n-  }\n-\n-  // Blocks the calling thread until the future is ready, then returns the\n-  // final value.\n-  const T& Await() const& {\n-    BlockUntilReady(\n-        static_cast<void (*)(tsl::AsyncValue*)>(tsl::BlockUntilReady));\n-    return *promise_;\n-  }\n-\n-  // Blocks the calling thread until the future is ready, then returns the\n-  // final value.\n-  std::conditional_t<is_move_only, T, const T&> Await() && {\n-    BlockUntilReady(\n-        static_cast<void (*)(tsl::AsyncValue*)>(tsl::BlockUntilReady));\n-\n-    if constexpr (is_move_only) {\n-      return std::move(*promise_);\n-    } else {\n-      // We can't move from the promise to the caller because for copyable\n-      // futures we can have multiple copies of the PjRtFuture sharing the\n-      // same underlying promise object.\n-      return *promise_;\n-    }\n-  }\n-\n-  // Returns a PjRtFuture<> that becomes ready when *this is ready. If *this\n-  // completes with an error, the returned future will also be an error.\n-  //\n-  // This function defined out of line as it requires PjRtFuture<> definition.\n-  PjRtFuture<> GetReadyFuture() const;\n-\n-  // Registers callback to be called once the promise is ready, with the final\n-  // value.\n-  //\n-  // callback may be called on an internal system thread or the calling thread.\n-  // The client should avoid any potentially re-entrant API calls within the\n-  // callback, for example by using the callback to enqueue work on a\n-  // client-owned threadpool.\n-  template <typename F,\n-            std::enable_if_t<!is_move_only &&\n-                             std::is_invocable_v<F, const T&>>* = nullptr>\n-  void OnReady(F&& f) const& {\n-    CHECK(IsValid());\n-    promise_.AndThen(\n-        [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-          DCHECK(promise.IsConcrete());\n-          f(*promise);\n-        });\n-  }\n-\n-  // Registers callback to be called once the promise is ready, with the final\n-  // value.\n-  //\n-  // callback may be called on an internal system thread or the calling thread.\n-  // The client should avoid any potentially re-entrant API calls within the\n-  // callback, for example by using the callback to enqueue work on a\n-  // client-owned threadpool.\n-  template <typename F,\n-            std::enable_if_t<is_move_only ? std::is_invocable_v<F, T>\n-                                          : std::is_invocable_v<F, const T&>>* =\n-                nullptr>\n-  void OnReady(F&& f) && {\n-    CHECK(IsValid());\n-    promise_.AndThen(\n-        [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-          DCHECK(promise.IsConcrete());\n-          if constexpr (is_move_only) {\n-            f(std::move(*promise));\n-          } else {\n-            // We can't move from the promise to the caller because for copyable\n-            // futures we can have multiple copies of the PjRtFuture sharing the\n-            // same underlying promise object.\n-            f(*promise);\n-          }\n-        });\n-  }\n-\n- protected:\n-  // Returns a placeholder error that can be used when short-circuiting promises\n-  // with no other references.\n-  static absl::Status AbortedError() {\n-    return absl::AbortedError(\n-        \"Fulfilling the promise with an aborted error since the value is no \"\n-        \"longer referenced by any futures or OnReady callbacks; if this error \"\n-        \"is exposed to any future, that indicates a bug\");\n-  }\n-\n- private:\n-  friend class xla::PjRtFutureHelpers;\n-\n-  tsl::AsyncValueRef<T> promise_;\n-\n-  // Function that is called before a thread starts blocking on the promise.\n-  PjRtFutureHelpers::OnBlockStartFn on_block_start_;\n-  // Function that is called after a thread finishes blocking on the promise.\n-  PjRtFutureHelpers::OnBlockEndFn on_block_end_;\n-};\n-\n-}  // namespace internal\n-\n-// PjRtFuture<T> is a simple future that is returned by PjRt APIs that\n-// enqueue asynchronous work, reporting a value of type T when the work is\n-// complete.\n-//\n-// PjRtFuture can be used by the client to wait for work to complete, either via\n-// a blocking call or a callback.\n-//\n-// The implementation wraps a tsl::AsyncValueRef<T>, but we prefer to\n-// encapsulate the AVR rather than returning it directly for three reasons.\n-//\n-// First, in contrast to AsyncValueRef which has a smart-pointer semantics,\n-// future has more of a value semantics, i.e. future of a move-only type also\n-// is a move-only type. You can think of a move-only future as a box to pass a\n-// value of type T between asynchronous producer/consumer: you can open the box\n-// once to put the value into it and you can open the box only once to take the\n-// value out of it. For copyable types PjRtFuture<T> is a copyable type,\n-// although all copies share the same underlying value.\n-//\n-// Second, we want to retain portability in case a future implementation moves\n-// away from AsyncValueRef ---- we don't want clients to call arbitrary\n-// AsyncValueRef APIs.\n-//\n-// Third, we want to export different semantics, for example we support\n-// integration between blocking and profiling (e.g., TraceMe).\n-template <class T>\n-class PjRtFuture : public internal::PjRtFutureBase<absl::StatusOr<T>> {\n-  using Base = internal::PjRtFutureBase<absl::StatusOr<T>>;\n-\n-  static constexpr bool is_move_only = Base::IsMoveOnly();  // NOLINT\n-\n-  template <typename U>\n-  static constexpr bool is_status_or =  // NOLINT\n-      tsl::internal::is_status_or_v<U>;\n-\n-  static_assert(!std::is_same_v<T, absl::Status>,\n-                \"Use PjRtFuture<> specialization for stateless futures\");\n-\n-  static_assert(\n-      !internal::IsStatusOr<T>::value,\n-      \"PjRtFuture<T> already has an implicit absl::StatusOr<T> semantics\");\n-\n- public:\n-  PjRtFuture() = default;\n-\n-  // Constructs an immediately available future with the given value.\n-  explicit PjRtFuture(absl::StatusOr<T> value) : Base(std::move(value)) {}\n-\n-  // Constructs and immediately available future from the given value.\n-  template <typename U,\n-            std::enable_if_t<std::is_constructible_v<T, U>>* = nullptr>\n-  explicit PjRtFuture(U value) : Base(std::forward<U>(value)) {}\n-\n-  class Promise : public Base::Promise {\n-   public:\n-    using Base::Promise::Promise;\n-\n-    // Sets the value of the promise. Must be called at most once.\n-    //\n-    // After Set is called, value will be delivered to waiters on the PjRtFuture\n-    // constructed from a promise, via blocking or callbacks.\n-    void Set(absl::StatusOr<T> value) {\n-      Base::Promise::emplace(std::move(value));\n-    }\n-\n-    // A helper function to convert move-only Promise to shared_ptr, which is\n-    // useful when the promise has to be captured by a std::function.\n-    std::shared_ptr<Promise> ToShared() && {\n-      return std::make_shared<Promise>(std::move(*this));\n-    }\n-\n-    // Returns a future associated with the promise. We use a trick we an extra\n-    // template parameter to disable converting promise to future for move-only\n-    // types, as it is illegal to create multiple move-only futures sharing the\n-    // underlying async value storage. For move-only types, the only way to\n-    // create a future is to call `MakePromise`.\n-    template <typename U = void,\n-              std::enable_if_t<!is_move_only && std::is_void_v<U>>* = nullptr>\n-    PjRtFuture<T> future(\n-        PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-        PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) const {\n-      return PjRtFuture<T>(*this, std::move(on_block_start),\n-                           std::move(on_block_end));\n-    }\n-\n-   private:\n-    template <typename>\n-    friend class PjRtFuture;\n-  };\n-\n-  // Returns a pair of connected Promise and PjRtFuture<T>. Setting the returned\n-  // promise will fulfill the connected future.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n-  static std::pair<Promise, PjRtFuture<T>> MakePromise(\n-      PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-      PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) {\n-    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::StatusOr<T>>());\n-    PjRtFuture<T> future(promise, std::move(on_block_start),\n-                         std::move(on_block_end));\n-    return std::make_pair(std::move(promise), std::move(future));\n-  }\n-\n-  using Base::Await;\n-  using Base::GetReadyFuture;\n-  using Base::OnReady;\n-\n-  // Returns an PjRtFuture<R> that is constructed from the result of invoking\n-  // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage:\n-  //\n-  // future.Map<R>([](const T& value) -> U {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F,\n-            typename U = std::invoke_result_t<F, const T&>,\n-            std::enable_if_t<!is_move_only && std::is_constructible_v<R, U>>* =\n-                nullptr>\n-  PjRtFuture<R> Map(F&& f) const& {\n-    auto [promise, future] = PjRtFuture<R>::MakePromise();\n-\n-    using Value = const absl::StatusOr<T>&;\n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](Value value) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        promise.emplace(absl::in_place_t{}, f(*value));\n-      } else {\n-        promise.Set(value.status());\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // Returns an PjRtFuture<R> that is constructed from the result of invoking\n-  // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage: move-only type T passed by value\n-  //\n-  // std::move(future).Map<R>([](T value) -> U {\n-  //   return U(std::move(value)); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F,\n-            typename U = std::invoke_result_t<\n-                F, std::conditional_t<is_move_only, T, const T&>>,\n-            std::enable_if_t<std::is_constructible_v<R, U>>* = nullptr>\n-  PjRtFuture<R> Map(F&& f) && {\n-    auto [promise, future] = PjRtFuture<R>::MakePromise();\n-\n-    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n-                                     const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady([promise = std::move(promise),\n-                              f = std::forward<F>(f)](Value value) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        if constexpr (is_move_only) {\n-          promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n-        } else {\n-          promise.emplace(absl::in_place_t{}, f(*value));\n-        }\n-      } else {\n-        promise.Set(value.status());\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // Returns an PjRtFuture<R> that is constructed from the result of invoking\n-  // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error. Functor `f` must return a value of type\n-  // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n-  // is automatically unwrapped and returned as a future payload.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage:\n-  //\n-  // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <\n-      typename R, typename F, typename U = std::invoke_result_t<F, const T&>,\n-      std::enable_if_t<!is_move_only && is_status_or<U> &&\n-                       std::is_constructible_v<R, typename U::value_type>>* =\n-          nullptr>\n-  PjRtFuture<R> TryMap(F&& f) const& {\n-    auto [promise, future] = PjRtFuture<R>::MakePromise();\n-\n-    using Value = const absl::StatusOr<T>&;\n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](Value value) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        auto result = f(*value);\n-        if (ABSL_PREDICT_TRUE(result.ok())) {\n-          promise.emplace(absl::in_place_t{}, *std::move(result));\n-        } else {\n-          promise.Set(std::move(result).status());\n-        }\n-      } else {\n-        promise.Set(value.status());\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // Returns an PjRtFuture<R> that is constructed from the result of invoking\n-  // functor `f` with *this value. If *this completes with an error, returned\n-  // future will also be an error. Functor `f` must return a value of type\n-  // absl::StatusOr<U> where R is constructible from U. Returned absl::StatusOr\n-  // is automatically unwrapped and returned as a future payload.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage: move-only type T passed by rvalue\n-  //\n-  // future.TryMap<R>([](const T& value) -> absl::StatusOr<U> {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F,\n-            typename U = std::invoke_result_t<\n-                F, std::conditional_t<is_move_only, T, const T&>>,\n-            std::enable_if_t<\n-                is_status_or<U> &&\n-                std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n-  PjRtFuture<R> TryMap(F&& f) && {\n-    auto [promise, future] = PjRtFuture<R>::MakePromise();\n-\n-    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n-                                     const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady([promise = std::move(promise),\n-                              f = std::forward<F>(f)](Value value) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(value.ok())) {\n-        auto result = [&] {\n-          if constexpr (is_move_only) {\n-            return f(std::move(*value));\n-          } else {\n-            return f(*value);\n-          }\n-        }();\n-        if (ABSL_PREDICT_TRUE(result.ok())) {\n-          promise.emplace(absl::in_place_t{}, *std::move(result));\n-        } else {\n-          promise.Set(std::move(result).status());\n-        }\n-      } else {\n-        promise.Set(value.status());\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // A `Map` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<F, const T&>>\n-  PjRtFuture<R> Map(F&& f) const& {\n-    return Map<R>(std::forward<F>(f));\n-  }\n-\n-  // A `Map` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<\n-                            F, std::conditional_t<is_move_only, T, const T&>>>\n-  PjRtFuture<R> Map(F&& f) && {\n-    return std::move(*this).template Map<R>(std::forward<F>(f));\n-  }\n-\n-  // A `TryMap` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<F, const T&>,\n-            std::enable_if_t<is_status_or<R>>* = nullptr>\n-  PjRtFuture<typename R::value_type> TryMap(F&& f) const& {\n-    return TryMap<typename R::value_type>(std::forward<F>(f));\n-  }\n-\n-  // A `TryMap` overload that automatically infers the type of result from `f`.\n-  template <typename F,\n-            typename R = std::invoke_result_t<\n-                F, std::conditional_t<is_move_only, T, const T&>>,\n-            std::enable_if_t<is_status_or<R>>* = nullptr>\n-  PjRtFuture<typename R::value_type> TryMap(F&& f) && {\n-    return std::move(*this).template TryMap<typename R::value_type>(\n-        std::forward<F>(f));\n+  void AddDependency(const PjRtFuture<T>& future) {\n+    AddDependency(FormRef(future.async_value()));\n   }\n \n  private:\n-  friend class PjRtFutureHelpers;\n-\n-  // Bring PjRtFutureBase constructors in scope.\n-  using Base::Base;\n-\n-  // Constructor for unavailable future that will be fulfilled later via the\n-  // promise object.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n-  PjRtFuture(const Promise& promise,\n-             PjRtFutureHelpers::OnBlockStartFn on_block_start,\n-             PjRtFutureHelpers::OnBlockEndFn on_block_end)\n-      : Base(promise.ref(), std::move(on_block_start),\n-             std::move(on_block_end)) {}\n-};\n-\n-// PjRtFuture<void> specialization for communicating stateless events.\n-//\n-// See PjRtFuture<T> documentation above for more details.\n-template <>\n-class PjRtFuture<void> : public internal::PjRtFutureBase<absl::Status> {\n-  using Base = internal::PjRtFutureBase<absl::Status>;\n-\n-  template <typename U>\n-  static constexpr bool is_status_or =  // NOLINT\n-      tsl::internal::is_status_or_v<U>;\n-\n- public:\n-  PjRtFuture() = default;\n-\n-  // Constructor for a future that is immediately ready with a given status.\n-  // For futures that are immediately ready with OK status, we use a global non\n-  // reference-counted async value that avoids heap allocation and reference\n-  // counting operations on a hot path.\n-  explicit PjRtFuture(absl::Status status)\n-      : Base(ABSL_PREDICT_TRUE(status.ok())\n-                 ? ready_promise_->AsRef()\n-                 : tsl::MakeAvailableAsyncValueRef<absl::Status>(\n-                       std::move(status)),\n-             /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n-\n-  class Promise : public Base::Promise {\n-   public:\n-    using Base::Promise::Promise;\n-\n-    // Sets the promise completed with a given status. Must be called at most\n-    // once.\n-    //\n-    // After Set is called, completion event will be delivered to waiters on the\n-    // PjRtFuture constructed from a promise, via blocking or callbacks.\n-    void Set(absl::Status status = absl::OkStatus()) {\n-      Base::Promise::emplace(std::move(status));\n-    }\n-\n-    // A helper function to convert move-only Promise to shared_ptr, which is\n-    // useful when the promise has to be captured by a std::function.\n-    std::shared_ptr<Promise> ToShared() && {\n-      return std::make_shared<Promise>(std::move(*this));\n-    }\n-\n-    // Returns a future associated with the promise.\n-    PjRtFuture<> future(\n-        PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-        PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) const {\n-      return PjRtFuture<>(*this, std::move(on_block_start),\n-                          std::move(on_block_end));\n-    }\n-\n-   private:\n-    friend class PjRtFuture<void>;\n-  };\n-\n-  // Returns a pair of connected Promise and PjRtFuture<>. Setting the returned\n-  // promise will fulfill the connected future.\n-  static std::pair<Promise, PjRtFuture<>> MakePromise(\n-      PjRtFutureHelpers::OnBlockStartFn on_block_start = nullptr,\n-      PjRtFutureHelpers::OnBlockEndFn on_block_end = nullptr) {\n-    Promise promise(tsl::MakeUnconstructedAsyncValueRef<absl::Status>());\n-    PjRtFuture<> future(promise, std::move(on_block_start),\n-                        std::move(on_block_end));\n-    return std::make_pair(std::move(promise), std::move(future));\n-  }\n-\n-  using Base::Await;\n-  using Base::BlockUntilReady;\n-  using Base::OnReady;\n-\n-  // Returns an PjRtFuture<R> that is constructed from the result of invoking\n-  // functor `f`. If *this completes with an error, returned future will also be\n-  // an error.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage:\n-  //\n-  // future.Map<R>([]() -> U {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F, typename U = std::invoke_result_t<F>>\n-  PjRtFuture<R> Map(F&& f) {\n-    auto [promise, future] = PjRtFuture<R>::MakePromise();\n-\n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](absl::Status status) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n-        promise.emplace(absl::in_place_t{}, f());\n-      } else {\n-        promise.Set(std::move(status));\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // Returns an PjRtFuture<R> that is constructed from the result of invoking\n-  // functor `f`. If *this completes with an error, returned future will also be\n-  // an error. Functor `f` must return a value of type absl::StatusOr<U> where R\n-  // is constructible from U. Returned absl::StatusOr is automatically unwrapped\n-  // and returned as a future payload.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage:\n-  //\n-  // future.TryMap<R>([]() -> absl::StatusOr<U> {\n-  //   return U(value); // R must be constructible from U\n-  // })\n-  //\n-  template <typename R, typename F, typename U = std::invoke_result_t<F>,\n-            std::enable_if_t<\n-                is_status_or<U> &&\n-                std::is_constructible_v<R, typename U::value_type>>* = nullptr>\n-  PjRtFuture<R> TryMap(F&& f) {\n-    auto [promise, future] = PjRtFuture<R>::MakePromise();\n-\n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](absl::Status status) mutable {\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-      } else if (ABSL_PREDICT_TRUE(status.ok())) {\n-        auto result = f();\n-        if (ABSL_PREDICT_TRUE(result.ok())) {\n-          promise.emplace(absl::in_place_t{}, *std::move(result));\n-        } else {\n-          promise.Set(std::move(result).status());\n-        }\n-      } else {\n-        promise.Set(std::move(status));\n-      }\n-    });\n-\n-    return std::move(future);\n-  }\n-\n-  // A `Map` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<F>>\n-  PjRtFuture<R> Map(F&& f) {\n-    return Map<R>(std::forward<F>(f));\n-  }\n-\n-  // A `TryMap` overload that automatically infers the type of result from `f`.\n-  template <typename F, typename R = std::invoke_result_t<F>,\n-            std::enable_if_t<is_status_or<R>>* = nullptr>\n-  PjRtFuture<typename R::value_type> TryMap(F&& f) {\n-    return TryMap<typename R::value_type>(std::forward<F>(f));\n-  }\n-\n-  // Returns an PjRtFuture<R> that is constructed from the given value. If *this\n-  // completes with an error, returned future will also be an error.\n-  //\n-  // Note: The implementation may choose to not run `f` if it can infer that the\n-  // returned future will never be used. Do not use this method if `f` has a\n-  // side effect that must always be executed when the future becomes ready.\n-  //\n-  // Sample usage: make buffer available when future is ready\n-  //\n-  // std::unique_ptr<Buffer> buffer = ...;\n-  // future.MapTo<R>(std::move(buffer));\n-  template <typename R>\n-  PjRtFuture<absl::remove_cvref_t<R>> MapTo(R&& value) {\n-    return Map<absl::remove_cvref_t<R>>(\n-        [value = std::forward<R>(value)]() mutable {\n-          return std::move(value);\n-        });\n-  }\n-\n- private:\n-  friend class PjRtFutureHelpers;\n-\n-  // A promise that is immediately ready with OK status. Async value allocated\n-  // in the static storage and is not reference-counted.\n-  static absl::NoDestructor<tsl::AsyncValueOwningRef<absl::Status>>\n-      ready_promise_;\n-\n-  // Bring PjRtFutureBase constructors in scope.\n-  using Base::Base;\n-\n-  // Constructor for unavailable future that will be fulfilled later via the\n-  // promise object.\n-  //\n-  // - on_block_start is called before Await starts to block.\n-  // - on_block_end is called after Await finishes blocking.\n-  PjRtFuture(const Promise& promise,\n-             PjRtFutureHelpers::OnBlockStartFn on_block_start,\n-             PjRtFutureHelpers::OnBlockEndFn on_block_end)\n-      : Base(promise.ref(), std::move(on_block_start),\n-             std::move(on_block_end)) {}\n+  // Indicates that the ScopedAsyncTrackingEvent won't complete until dependency\n+  // becomes available. Called only by PjRtFuture.\n+  virtual void AddDependency(tsl::RCReference<tsl::AsyncValue> dependency) = 0;\n };\n \n-//===----------------------------------------------------------------------===//\n-// internal::PjRtFutureBase<T> implementation.\n-//===----------------------------------------------------------------------===//\n-\n-namespace internal {\n-\n-template <typename T, bool is_move_only>\n-PjRtFuture<> PjRtFutureBase<T, is_move_only>::GetReadyFuture() const {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  promise_.AndThen(\n-      [self = promise_.AsPtr(), promise = std::move(promise)]() mutable {\n-        if constexpr (std::is_same_v<T, absl::Status>) {\n-          promise.Set(*self);\n-        } else {\n-          promise.Set(self->status());\n-        }\n-      });\n-  return std::move(future);\n-}\n-\n-}  // namespace internal\n }  // namespace xla\n \n #endif  // XLA_PJRT_PJRT_FUTURE_H_"
        },
        {
            "sha": "657595ab9211353cbbf57d41c936d1b7f690587f",
            "filename": "third_party/xla/xla/pjrt/pjrt_future_test.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 681,
            "changes": 681,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eab7ef416c387381100208584c8b08038c6efe41/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eab7ef416c387381100208584c8b08038c6efe41/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future_test.cc?ref=eab7ef416c387381100208584c8b08038c6efe41",
            "patch": "@@ -1,681 +0,0 @@\n-/* Copyright 2024 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/pjrt/pjrt_future.h\"\n-\n-#include <cstdint>\n-#include <memory>\n-#include <utility>\n-#include <vector>\n-\n-#include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n-#include \"xla/tsl/platform/test.h\"\n-#include \"xla/tsl/platform/test_benchmark.h\"\n-\n-namespace xla {\n-\n-TEST(PjRtFutureTest, StatusConstructedFuture) {\n-  PjRtFuture<> future = PjRtFuture<>(absl::OkStatus());\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_EQ(future.Await(), absl::OkStatus());\n-}\n-\n-TEST(PjRtFutureTest, ValueConstructedFuture) {\n-  PjRtFuture<int32_t> future = PjRtFuture<int32_t>(42);\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_EQ(future.Await(), absl::StatusOr<int32_t>(42));\n-}\n-\n-TEST(PjRtFutureTest, StatelessFuture) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  promise.Set();\n-  EXPECT_TRUE(future.IsReady());\n-\n-  EXPECT_EQ(future.Await(), absl::OkStatus());\n-\n-  future.OnReady(\n-      [](absl::Status status) { EXPECT_EQ(status, absl::OkStatus()); });\n-}\n-\n-TEST(PjRtFutureTest, CreateFutureFromPromise) {\n-  auto [promise, _] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<int32_t> future = promise.future();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  promise.Set(42);\n-  EXPECT_EQ(*future.Await(), 42);\n-}\n-\n-TEST(PjRtFutureTest, StatefulFutureToStateless) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<> ready_future = future.GetReadyFuture();\n-\n-  EXPECT_FALSE(ready_future.IsReady());\n-  promise.Set(42);\n-  EXPECT_EQ(ready_future.Await(), absl::OkStatus());\n-}\n-\n-TEST(PjRtFutureTest, StatefulFutureToStatelessError) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<> ready_future = future.GetReadyFuture();\n-\n-  EXPECT_FALSE(ready_future.IsReady());\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_EQ(ready_future.Await(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, MoveOnlyFutureToStateless) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-  PjRtFuture<> ready_future = future.GetReadyFuture();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(ready_future.IsReady());\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-  EXPECT_EQ(ready_future.Await(), absl::OkStatus());\n-}\n-\n-TEST(PjRtFutureTest, MoveOnlyFutureToStatelessError) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-  PjRtFuture<> ready_future = future.GetReadyFuture();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(ready_future.IsReady());\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_EQ(ready_future.Await(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, CopyableFuture) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-\n-  PjRtFuture<int32_t> copy_constructed(future);\n-  PjRtFuture<int32_t> copy_assigned = future;\n-\n-  EXPECT_FALSE(copy_constructed.IsReady());\n-  EXPECT_FALSE(copy_assigned.IsReady());\n-  promise.Set(42);\n-  EXPECT_TRUE(copy_constructed.IsReady());\n-  EXPECT_TRUE(copy_assigned.IsReady());\n-}\n-\n-TEST(PjRtFutureTest, MoveConstructedFuture) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  PjRtFuture<std::unique_ptr<int32_t>> move_constructed(std::move(future));\n-\n-  EXPECT_FALSE(move_constructed.IsReady());\n-  promise.Set(std::make_unique<int32_t>(42));\n-  EXPECT_TRUE(move_constructed.IsReady());\n-}\n-\n-TEST(PjRtFutureTest, MoveAssignedFuture) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  PjRtFuture<std::unique_ptr<int32_t>> move_assigned = std::move(future);\n-\n-  EXPECT_FALSE(move_assigned.IsReady());\n-  promise.Set(std::make_unique<int32_t>(42));\n-  EXPECT_TRUE(move_assigned.IsReady());\n-}\n-\n-TEST(PjRtFutureTest, AwaitMoveOnlyFuture) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-\n-  EXPECT_EQ(**future.Await(), 42);\n-  EXPECT_EQ(**std::move(future).Await(), 42);\n-}\n-\n-TEST(PjRtFutureTest, OnReadyRvalueFuture) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-\n-  promise.Set(42);\n-\n-  std::move(future).OnReady(\n-      [](absl::StatusOr<int32_t> value) { EXPECT_EQ(*value, 42); });\n-}\n-\n-TEST(PjRtFutureTest, OnReadyMoveOnlyFuture) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-\n-  std::move(future).OnReady([](absl::StatusOr<std::unique_ptr<int32_t>> value) {\n-    EXPECT_EQ(**value, 42);\n-  });\n-}\n-\n-TEST(PjRtFutureTest, UnlinkedPromiseIsUnique) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  EXPECT_FALSE(promise.IsUniqueReference());\n-  future = {};\n-  EXPECT_TRUE(promise.IsUniqueReference());\n-}\n-\n-TEST(PjRtFutureTest, PromiseIsUnique) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-  // Future is linked to the promise object.\n-  EXPECT_FALSE(promise.IsUniqueReference());\n-\n-  // Future is destroyed, but we added a callback to underlying value.\n-  future.OnReady([](const absl::Status&) {});\n-  future = {};\n-  EXPECT_FALSE(promise.IsUniqueReference());\n-\n-  // Once promise is fulfilled, the callback is executed, and because we\n-  // destroyed the future, the underlying value is not referenced by anyone\n-  // else, and the promise becomes unique.\n-  promise.Set();\n-  EXPECT_TRUE(promise.IsUniqueReference());\n-}\n-\n-TEST(PjRtFutureTest, MapCopyableFuture) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(42);\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_TRUE(mapped.IsReady());\n-\n-  EXPECT_EQ(*future.Await(), 42);\n-  EXPECT_EQ(*mapped.Await(), 84.0f);\n-\n-  PjRtFuture<int32_t> mapped_again =\n-      std::move(mapped).Map([](float v) -> int32_t { return v; });\n-  EXPECT_EQ(*mapped_again.Await(), 84);\n-}\n-\n-TEST(PjRtFutureTest, MapCopyableFutureError) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<float> mapped = future.Map([](int32_t v) { return v * 2.0f; });\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, MapMoveOnlyFuture) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  PjRtFuture<std::unique_ptr<float>> mapped =\n-      std::move(future).Map([](std::unique_ptr<int32_t> v) {\n-        return std::make_unique<float>(*v * 2.0f);\n-      });\n-\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(**mapped.Await(), 84.0f);\n-}\n-\n-TEST(PjRtFutureTest, MapMoveOnlyFutureError) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-  PjRtFuture<std::unique_ptr<float>> mapped =\n-      std::move(future).Map([](std::unique_ptr<int32_t> v) {\n-        return std::make_unique<float>(*v * 2.0f);\n-      });\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, MapCopyableWithInplaceConstructor) {\n-  struct Struct {\n-    explicit Struct(int32_t v) : v(v) {}\n-    int32_t v;\n-  };\n-\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<Struct> mapped = future.Map<Struct>([](int32_t v) { return v; });\n-\n-  promise.Set(42);\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await()->v, 42);\n-}\n-\n-TEST(PjRtFutureTest, MapMoveOnlyWithInplaceConstructor) {\n-  struct Struct {\n-    explicit Struct(int32_t v) : v(v) {}\n-    int32_t v;\n-  };\n-\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-  PjRtFuture<Struct> mapped = std::move(future).Map<Struct>(\n-      [](std::unique_ptr<int32_t> v) { return *v; });\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await()->v, 42);\n-}\n-\n-TEST(PjRtFutureTest, MapUnusedResult) {\n-  auto [promise, future] = PjRtFuture<int>::MakePromise();\n-\n-  bool called = false;\n-  future.Map([&](int) {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set(1);\n-  EXPECT_FALSE(called);\n-}\n-\n-TEST(PjRtFutureTest, MapStatusUnusedResult) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-  bool called = false;\n-  future.Map([&]() {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set();\n-  EXPECT_FALSE(called);\n-}\n-\n-TEST(PjRtFutureTest, TryMapCopyableFuture) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<float> mapped = future.TryMap(\n-      [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(42);\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_TRUE(mapped.IsReady());\n-\n-  EXPECT_EQ(*future.Await(), 42);\n-  EXPECT_EQ(*mapped.Await(), 84.0f);\n-\n-  PjRtFuture<int32_t> mapped_again = std::move(mapped).TryMap(\n-      [](float v) -> absl::StatusOr<int32_t> { return v; });\n-  EXPECT_EQ(*mapped_again.Await(), 84);\n-}\n-\n-TEST(PjRtFutureTest, TryMapCopyableFutureForwardError) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<float> mapped = future.TryMap(\n-      [](int32_t v) -> absl::StatusOr<float> { return v * 2.0f; });\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, TryMapCopyableFutureCreateError) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-  PjRtFuture<float> mapped =\n-      future.TryMap([](int32_t v) -> absl::StatusOr<float> {\n-        return absl::InternalError(\"test\");\n-      });\n-\n-  promise.Set(42);\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, TryMapMoveOnlyFuture) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  PjRtFuture<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n-      [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n-        return std::make_unique<float>(*v * 2.0f);\n-      });\n-\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(**mapped.Await(), 84.0f);\n-}\n-\n-TEST(PjRtFutureTest, TryMapMoveOnlyFutureForwardError) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  PjRtFuture<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n-      [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n-        return std::make_unique<float>(*v * 2.0f);\n-      });\n-\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, TryMapMoveOnlyFutureCreateError) {\n-  auto [promise, future] = PjRtFuture<std::unique_ptr<int32_t>>::MakePromise();\n-\n-  PjRtFuture<std::unique_ptr<float>> mapped = std::move(future).TryMap(\n-      [](std::unique_ptr<int32_t> v) -> absl::StatusOr<std::unique_ptr<float>> {\n-        return absl::InternalError(\"test\");\n-      });\n-\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(std::make_unique<int32_t>(42));\n-\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, TryMapUnusedResult) {\n-  auto [promise, future] = PjRtFuture<int>::MakePromise();\n-\n-  bool called = false;\n-  future.TryMap([&](int) -> absl::StatusOr<int> {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set(1);\n-  EXPECT_FALSE(called);\n-}\n-\n-TEST(PjRtFutureTest, TryMapStatusUnusedResult) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-  bool called = false;\n-  future.TryMap([&]() -> absl::StatusOr<int> {\n-    called = true;\n-    return 2;\n-  });\n-  promise.Set();\n-  EXPECT_FALSE(called);\n-}\n-\n-TEST(PjRtFutureTest, StatelessError) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_TRUE(future.IsReady());\n-\n-  absl::Status status = future.Await();\n-  EXPECT_EQ(status, absl::InternalError(\"test\"));\n-\n-  future.OnReady([](absl::Status status) {\n-    EXPECT_EQ(status, absl::InternalError(\"test\"));\n-  });\n-}\n-\n-TEST(PjRtFutureTest, StatelessImmediate) {\n-  PjRtFuture<> ok_future(absl::OkStatus());\n-  PjRtFuture<> error_future(absl::InternalError(\"test\"));\n-\n-  EXPECT_TRUE(ok_future.IsReady());\n-  EXPECT_TRUE(error_future.IsReady());\n-\n-  EXPECT_EQ(ok_future.Await(), absl::OkStatus());\n-  EXPECT_EQ(error_future.Await(), absl::InternalError(\"test\"));\n-\n-  ok_future.OnReady(\n-      [](absl::Status status) { EXPECT_EQ(status, absl::OkStatus()); });\n-\n-  error_future.OnReady([](absl::Status status) {\n-    EXPECT_EQ(status, absl::InternalError(\"test\"));\n-  });\n-}\n-\n-TEST(PjRtFutureTest, MapStatelessFuture) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  PjRtFuture<float> mapped = future.Map([]() { return 42.0f; });\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(absl::OkStatus());\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_TRUE(mapped.IsReady());\n-\n-  EXPECT_EQ(future.Await(), absl::OkStatus());\n-  EXPECT_EQ(*mapped.Await(), 42.0f);\n-}\n-\n-TEST(PjRtFutureTest, MapStatelessFutureError) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  PjRtFuture<float> mapped = future.Map([]() { return 42.0f; });\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_TRUE(mapped.IsReady());\n-\n-  EXPECT_EQ(future.Await(), absl::InternalError(\"test\"));\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, TryMapStatelessFuture) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  PjRtFuture<float> mapped =\n-      future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(absl::OkStatus());\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_TRUE(mapped.IsReady());\n-\n-  EXPECT_EQ(future.Await(), absl::OkStatus());\n-  EXPECT_EQ(*mapped.Await(), 42.0f);\n-}\n-\n-TEST(PjRtFutureTest, TryMapStatelessFutureForwardError) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  PjRtFuture<float> mapped =\n-      future.TryMap([]() -> absl::StatusOr<float> { return 42.0f; });\n-\n-  promise.Set(absl::InternalError(\"test\"));\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, TryMapStatelessFutureCreateError) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  PjRtFuture<float> mapped = future.TryMap(\n-      []() -> absl::StatusOr<float> { return absl::InternalError(\"test\"); });\n-\n-  promise.Set(absl::OkStatus());\n-  EXPECT_TRUE(mapped.IsReady());\n-  EXPECT_EQ(mapped.Await().status(), absl::InternalError(\"test\"));\n-}\n-\n-TEST(PjRtFutureTest, MapToStatelessFuture) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-  PjRtFuture<float> mapped = future.MapTo(42.0f);\n-\n-  EXPECT_FALSE(future.IsReady());\n-  EXPECT_FALSE(mapped.IsReady());\n-\n-  promise.Set(absl::OkStatus());\n-  EXPECT_TRUE(future.IsReady());\n-  EXPECT_TRUE(mapped.IsReady());\n-\n-  EXPECT_EQ(future.Await(), absl::OkStatus());\n-  EXPECT_EQ(*mapped.Await(), 42.0f);\n-}\n-\n-TEST(PjRtFutureTest, StatefulFuture) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  promise.Set(42);\n-  EXPECT_TRUE(future.IsReady());\n-\n-  future.OnReady([](absl::StatusOr<int32_t> value) { EXPECT_EQ(*value, 42); });\n-}\n-\n-TEST(PjRtFutureTest, StatusFuture) {\n-  auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  promise.Set(absl::OkStatus());\n-  EXPECT_TRUE(future.IsReady());\n-\n-  future.OnReady(\n-      [](absl::Status status) { EXPECT_EQ(status, absl::OkStatus()); });\n-}\n-\n-TEST(PjRtFutureTest, StatusOrFuture) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-\n-  EXPECT_FALSE(future.IsReady());\n-  promise.Set(42);\n-  EXPECT_TRUE(future.IsReady());\n-\n-  future.OnReady([](absl::StatusOr<int32_t> value) { EXPECT_EQ(*value, 42); });\n-}\n-\n-TEST(PjRtFutureTest, JoinFutures) {\n-  auto empty_join = JoinFutures({});\n-  EXPECT_TRUE(empty_join.IsReady());\n-  EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n-\n-  auto [promise0, future0] = PjRtFuture<>::MakePromise();\n-  auto [promise1, future1] = PjRtFuture<>::MakePromise();\n-\n-  std::vector<PjRtFuture<>> futures0 = {future0};\n-  std::vector<PjRtFuture<>> futures1 = {future0, future1};\n-\n-  auto join_one = JoinFutures(futures0);\n-  EXPECT_FALSE(join_one.IsReady());\n-\n-  auto join_two = JoinFutures(futures1);\n-  EXPECT_FALSE(join_two.IsReady());\n-\n-  promise0.Set();\n-  EXPECT_TRUE(join_one.IsReady());\n-  EXPECT_FALSE(join_two.IsReady());\n-  EXPECT_EQ(join_one.Await(), absl::OkStatus());\n-\n-  promise1.Set();\n-  EXPECT_TRUE(join_two.IsReady());\n-  EXPECT_EQ(join_two.Await(), absl::OkStatus());\n-}\n-\n-TEST(PjRtFutureTest, JoinErrors) {\n-  auto empty_join = JoinFutures({});\n-  EXPECT_TRUE(empty_join.IsReady());\n-  EXPECT_EQ(empty_join.Await(), absl::OkStatus());\n-\n-  auto [promise0, future0] = PjRtFuture<>::MakePromise();\n-  auto [promise1, future1] = PjRtFuture<>::MakePromise();\n-\n-  std::vector<PjRtFuture<>> futures0 = {future0};\n-  std::vector<PjRtFuture<>> futures1 = {future0, future1};\n-\n-  auto join_one = JoinFutures(futures0);\n-  EXPECT_FALSE(join_one.IsReady());\n-\n-  auto join_two = JoinFutures(futures1);\n-  EXPECT_FALSE(join_two.IsReady());\n-\n-  promise0.Set(absl::InternalError(\"error #0\"));\n-  EXPECT_TRUE(join_one.IsReady());\n-  EXPECT_FALSE(join_two.IsReady());\n-  EXPECT_EQ(join_one.Await(), absl::InternalError(\"error #0\"));\n-\n-  promise1.Set(absl::InternalError(\"error #1\"));\n-  EXPECT_TRUE(join_two.IsReady());\n-  EXPECT_EQ(join_two.Await(), absl::InternalError(\"error #0\"));\n-}\n-\n-TEST(PjRtFutureTest, WithProfiling) {\n-  auto [promise, future] = PjRtFuture<int32_t>::MakePromise(\n-      [&] { return PjRtFutureHelpers::ProfilingKeys{}; },\n-      [&](PjRtFutureHelpers::ProfilingKeys) {});\n-\n-  auto update_profiling = PjRtFutureHelpers::WithProfiling(\n-      std::move(future), [&] { return PjRtFutureHelpers::ProfilingKeys{}; },\n-      [&](PjRtFutureHelpers::ProfilingKeys) {});\n-\n-  EXPECT_FALSE(update_profiling.IsReady());\n-\n-  promise.Set(42);\n-\n-  EXPECT_TRUE(update_profiling.IsReady());\n-  EXPECT_EQ(*update_profiling.Await(), 42);\n-}\n-\n-TEST(PjRtFutureTest, MakeSharedPromise) {\n-  {  // Stateless future.\n-    auto [promise, future] = PjRtFuture<>::MakePromise();\n-\n-    auto shared_promise = std::move(promise).ToShared();\n-    shared_promise->Set();\n-\n-    // NOLINTNEXTLINE(bugprone-use-after-move)\n-    EXPECT_FALSE(static_cast<bool>(promise));\n-\n-    EXPECT_TRUE(future.IsReady());\n-    EXPECT_EQ(future.Await(), absl::OkStatus());\n-  }\n-\n-  {  // Stateful future.\n-    auto [promise, future] = PjRtFuture<int32_t>::MakePromise();\n-\n-    auto shared_promise = std::move(promise).ToShared();\n-    shared_promise->Set(42);\n-\n-    // NOLINTNEXTLINE(bugprone-use-after-move)\n-    EXPECT_FALSE(static_cast<bool>(promise));\n-\n-    EXPECT_TRUE(future.IsReady());\n-    EXPECT_EQ(*future.Await(), 42);\n-  }\n-}\n-\n-//===----------------------------------------------------------------------===//\n-// Performance benchmarks.\n-//===----------------------------------------------------------------------===//\n-\n-static void BM_CreateOkFuture(benchmark::State& state) {\n-  for (auto _ : state) {\n-    PjRtFuture<> future(absl::OkStatus());\n-    benchmark::DoNotOptimize(future);\n-  }\n-}\n-\n-static void BM_StatelessMapTo(benchmark::State& state) {\n-  std::shared_ptr<float> value = std::make_shared<float>(42.0f);\n-\n-  for (auto _ : state) {\n-    PjRtFuture<> future(absl::OkStatus());\n-    PjRtFuture<std::shared_ptr<float>> mapped = future.MapTo(value);\n-    benchmark::DoNotOptimize(mapped);\n-  }\n-}\n-\n-BENCHMARK(BM_CreateOkFuture);\n-BENCHMARK(BM_StatelessMapTo);\n-\n-}  // namespace xla"
        }
    ],
    "stats": {
        "total": 1759,
        "additions": 48,
        "deletions": 1711
    }
}