{
    "author": "ezhulenev",
    "message": "[xla:ffi] Use same id sequence for internal and external types\n\nAdd an API to lookup type id and info by type name. We can't rely on type ids for serialization, as they are not stable and assigned at run time depending on the type registration order. Type names on the other hand must be stable.\n\nPiperOrigin-RevId: 824512487",
    "sha": "5dfa57fd92478090be94073241cc194aeb23feba",
    "files": [
        {
            "sha": "1deca4bd86593b84b2c12a5e62206c9c75cfcb75",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=5dfa57fd92478090be94073241cc194aeb23feba",
            "patch": "@@ -278,6 +278,7 @@ xla_cc_test(\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "8db2bf63241922fda7d7f80297889ddbc793d0df",
            "filename": "third_party/xla/xla/ffi/execution_state.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc?ref=5dfa57fd92478090be94073241cc194aeb23feba",
            "patch": "@@ -35,8 +35,7 @@ ExecutionState::~ExecutionState() {\n }\n \n absl::Status ExecutionState::Set(TypeId type_id, void* state) {\n-  TF_ASSIGN_OR_RETURN(auto type_info,\n-                      TypeRegistry::GetExternalTypeInfo(type_id));\n+  TF_ASSIGN_OR_RETURN(auto type_info, TypeRegistry::GetTypeInfo(type_id));\n   if (type_info.deleter == nullptr) {\n     return InvalidArgument(\n         \"Type id %d does not have a registered type info with a deleter\","
        },
        {
            "sha": "fa45bb8dff850501e871fb2e64946deb68ec4716",
            "filename": "third_party/xla/xla/ffi/type_registry.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 16,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.cc?ref=5dfa57fd92478090be94073241cc194aeb23feba",
            "patch": "@@ -40,24 +40,19 @@ struct TypeRegistration {\n   TypeRegistry::TypeInfo type_info;\n };\n \n-using ExternalTypeRegistry = absl::flat_hash_map<std::string, TypeRegistration>;\n+using TypeRegistryMap = absl::flat_hash_map<std::string, TypeRegistration>;\n \n }  // namespace\n \n ABSL_CONST_INIT absl::Mutex type_registry_mutex(absl::kConstInit);\n \n-static ExternalTypeRegistry& StaticExternalTypeRegistry() {\n-  static absl::NoDestructor<ExternalTypeRegistry> registry;\n+static TypeRegistryMap& StaticTypeRegistryMap() {\n+  static absl::NoDestructor<TypeRegistryMap> registry;\n   return *registry;\n }\n \n-TypeRegistry::TypeId TypeRegistry::GetNextInternalTypeId() {\n-  static auto* counter = new std::atomic<int64_t>(1);\n-  return TypeId(counter->fetch_add(1));\n-}\n-\n-TypeRegistry::TypeId TypeRegistry::GetNextExternalTypeId() {\n-  static auto* counter = new std::atomic<int64_t>(1);\n+TypeRegistry::TypeId TypeRegistry::GetNextTypeId() {\n+  static absl::NoDestructor<std::atomic<int64_t>> counter(1);\n   return TypeId(counter->fetch_add(1));\n }\n \n@@ -66,7 +61,7 @@ absl::StatusOr<TypeRegistry::TypeId> TypeRegistry::AssignExternalTypeId(\n   VLOG(3) << absl::StrFormat(\"Assign external type id: name=%s\", name);\n \n   absl::MutexLock lock(type_registry_mutex);\n-  auto& registry = StaticExternalTypeRegistry();\n+  auto& registry = StaticTypeRegistryMap();\n \n   // Try to emplace with unknow type id and fill it with real type id only if we\n   // successfully acquired an entry for a given name.\n@@ -84,9 +79,9 @@ absl::StatusOr<TypeRegistry::TypeId> TypeRegistry::AssignExternalTypeId(\n   };\n \n   // Create a new type id that is not already in use.\n-  TypeId type_id = GetNextExternalTypeId();\n+  TypeId type_id = GetNextTypeId();\n   while (type_id_is_in_use(type_id)) {\n-    type_id = GetNextExternalTypeId();\n+    type_id = GetNextTypeId();\n   }\n \n   VLOG(3) << absl::StrFormat(\"Assigned external type id: name=%s type_id=%d\",\n@@ -101,7 +96,7 @@ absl::Status TypeRegistry::RegisterExternalTypeId(absl::string_view name,\n                              name, type_id.value());\n \n   absl::MutexLock lock(type_registry_mutex);\n-  auto& registry = StaticExternalTypeRegistry();\n+  auto& registry = StaticTypeRegistryMap();\n \n   auto emplaced = registry.emplace(name, TypeRegistration{type_id, type_info});\n   if (!emplaced.second && emplaced.first->second.type_id != type_id) {\n@@ -113,10 +108,22 @@ absl::Status TypeRegistry::RegisterExternalTypeId(absl::string_view name,\n   return absl::OkStatus();\n }\n \n-absl::StatusOr<TypeRegistry::TypeInfo> TypeRegistry::GetExternalTypeInfo(\n+absl::StatusOr<TypeRegistry::TypeId> TypeRegistry::GetTypeId(\n+    absl::string_view name) {\n+  absl::MutexLock lock(type_registry_mutex);\n+  auto& registry = StaticTypeRegistryMap();\n+\n+  auto it = registry.find(name);\n+  if (it == registry.end()) {\n+    return Internal(\"Type name %s is not registered\", name);\n+  }\n+  return it->second.type_id;\n+}\n+\n+absl::StatusOr<TypeRegistry::TypeInfo> TypeRegistry::GetTypeInfo(\n     TypeId type_id) {\n   absl::MutexLock lock(type_registry_mutex);\n-  auto& registry = StaticExternalTypeRegistry();\n+  auto& registry = StaticTypeRegistryMap();\n \n   auto it = absl::c_find_if(registry, [&](const auto& kv) {\n     auto& [name, registration] = kv;"
        },
        {
            "sha": "8fabc15f4ed55ea04a3a2db8b56e7babd7806b8b",
            "filename": "third_party/xla/xla/ffi/type_registry.h",
            "status": "modified",
            "additions": 23,
            "deletions": 9,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h?ref=5dfa57fd92478090be94073241cc194aeb23feba",
            "patch": "@@ -18,6 +18,7 @@ limitations under the License.\n \n #include <cstdint>\n \n+#include \"absl/base/no_destructor.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -64,6 +65,14 @@ class TypeRegistry {\n     Deleter deleter = nullptr;\n   };\n \n+  // Returns type id for a given type name. Returns an error if type is\n+  // not registered. Works for both external and internal type ids.\n+  static absl::StatusOr<TypeId> GetTypeId(absl::string_view name);\n+\n+  // Returns type info for a given type id. Returns an error if type id is not\n+  // registered. Works for both external and internal type ids.\n+  static absl::StatusOr<TypeInfo> GetTypeInfo(TypeId type_id);\n+\n   // Assigns a unique type id to an external type with a given name. Returns an\n   // error if a type with a given name is already registered in the process.\n   static absl::StatusOr<TypeId> AssignExternalTypeId(absl::string_view name,\n@@ -76,9 +85,9 @@ class TypeRegistry {\n                                              TypeId type_id,\n                                              TypeInfo type_info);\n \n-  // Returns type info for a given external type id. Returns an error if type\n-  // id is not registered.\n-  static absl::StatusOr<TypeInfo> GetExternalTypeInfo(TypeId type_id);\n+  // Returns a type name for a given type. For internal type ids only.\n+  template <typename T>\n+  static absl::string_view GetTypeName();\n \n   // Returns a type id for a given type. For internal type ids only.\n   template <typename T>\n@@ -89,16 +98,21 @@ class TypeRegistry {\n   static TypeInfo GetTypeInfo();\n \n  private:\n-  // We never mix external and internal type ids, so we can use different type\n-  // id spaces to assign unique ids to each type.\n-  static TypeId GetNextInternalTypeId();\n-  static TypeId GetNextExternalTypeId();\n+  static TypeId GetNextTypeId();\n };\n \n+template <typename T>\n+absl::string_view TypeRegistry::GetTypeName() {\n+  return typeid(T).name();\n+}\n+\n template <typename T>\n TypeRegistry::TypeId TypeRegistry::GetTypeId() {\n-  static const TypeId id = GetNextInternalTypeId();\n-  return id;\n+  // We always register internal types in the static type registry, because we\n+  // want to be able to lookup them by name.\n+  static const absl::NoDestructor<absl::StatusOr<TypeId>> id(\n+      AssignExternalTypeId(GetTypeName<T>(), GetTypeInfo<T>()));\n+  return **id;\n }\n \n template <typename T>"
        },
        {
            "sha": "936b4e40231b936631d89e3bfab19b239e6d9f5d",
            "filename": "third_party/xla/xla/ffi/type_registry_test.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5dfa57fd92478090be94073241cc194aeb23feba/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc?ref=5dfa57fd92478090be94073241cc194aeb23feba",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n@@ -53,7 +54,7 @@ TEST(TypeRegistryTest, RegisterExternalTypeId) {\n \n   // Registered type has a correct type info.\n   TF_ASSERT_OK_AND_ASSIGN(TypeRegistry::TypeInfo foo_info,\n-                          TypeRegistry::GetExternalTypeInfo(foo_id));\n+                          TypeRegistry::GetTypeInfo(foo_id));\n   EXPECT_EQ(foo_info.deleter, type_info.deleter);\n \n   // It's ok to register a new type with a user-provided type id.\n@@ -64,14 +65,19 @@ TEST(TypeRegistryTest, RegisterExternalTypeId) {\n \n   // And a new type has a correct type info.\n   TF_ASSERT_OK_AND_ASSIGN(TypeRegistry::TypeInfo bar_info,\n-                          TypeRegistry::GetExternalTypeInfo(bar_id));\n+                          TypeRegistry::GetTypeInfo(bar_id));\n   EXPECT_EQ(bar_info.deleter, type_info.deleter);\n }\n \n TEST(TypeRegistryTest, RegisterInternalTypeId) {\n-  auto int32_type_id = TypeRegistry::GetTypeId<int32_t>();\n-  auto int64_type_id = TypeRegistry::GetTypeId<int64_t>();\n-  EXPECT_NE(int32_type_id, int64_type_id);\n+  auto int32_id = TypeRegistry::GetTypeId<int32_t>();\n+  auto int64_id = TypeRegistry::GetTypeId<int64_t>();\n+  EXPECT_NE(int32_id, int64_id);\n+\n+  absl::string_view int32_name = TypeRegistry::GetTypeName<int32_t>();\n+  absl::string_view int64_name = TypeRegistry::GetTypeName<int64_t>();\n+  EXPECT_EQ(*TypeRegistry::GetTypeId(int32_name), int32_id);\n+  EXPECT_EQ(*TypeRegistry::GetTypeId(int64_name), int64_id);\n }\n \n TEST(TypeRegistryTest, InternalTypeInfo) {"
        }
    ],
    "stats": {
        "total": 91,
        "additions": 59,
        "deletions": 32
    }
}