{
    "author": "nurmukhametov",
    "message": "PR #33212: [ROCm] Enable HloEvaluator for more complex ops\n\nImported from GitHub PR https://github.com/openxla/xla/pull/33212\n\nThis PR enables the HloEvaluator to handle complex numbers in more operations (trigonometric and hyperbolic). Tests are added to check if folding works for these operations.\n\nIt also disables `constant_folding` in `complex_unary_op_test.cc` test, as it was intended to check the accuracy of backends implementations. If constant folding remains enabled, the test ends up checking the accuracy of `libstdc++` implementations for `tan`, `asin`, and `asinh` instead\nCopybara import of the project:\n\n--\naf6ae1d31b7d6bab2401a99dc397945c824e8631 by Aleksei Nurmukhametov <anurmukh@amd.com>:\n\nDo not run constant_folding on complex_unary_op_test.cc\n\n--\nd3074cc139f07ef6e91723f6290b8294dcc38717 by Aleksei Nurmukhametov <anurmukh@amd.com>:\n\nEnable HloEvaluator for more complex ops\n\nMerging this change closes #33212\n\nPiperOrigin-RevId: 828446740",
    "sha": "6b2f4d629fa2c327d16252d4ecacec51c0b3880d",
    "files": [
        {
            "sha": "a334ab084cf4ab02623846bace3ec0fcecf71ebd",
            "filename": "third_party/xla/xla/hlo/evaluator/hlo_evaluator_test.cc",
            "status": "modified",
            "additions": 104,
            "deletions": 1,
            "changes": 105,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Fhlo%2Fevaluator%2Fhlo_evaluator_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Fhlo%2Fevaluator%2Fhlo_evaluator_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fevaluator%2Fhlo_evaluator_test.cc?ref=6b2f4d629fa2c327d16252d4ecacec51c0b3880d",
            "patch": "@@ -114,7 +114,8 @@ class HloEvaluatorTest : public HloHardwareIndependentTestBase {\n     TF_ASSERT_OK_AND_ASSIGN(Literal result, Evaluate());\n \n     auto element_type = expected.shape().element_type();\n-    if (element_type == F32 || element_type == F64) {\n+    if (element_type == F32 || element_type == F64 || element_type == C64 ||\n+        element_type == C128) {\n       ErrorSpec error(aabs);\n       EXPECT_TRUE(LiteralTestUtil::Near(expected, result, error));\n     } else {\n@@ -493,6 +494,108 @@ TEST_P(HloEvaluatorBf16Test, DoesTanR2) {\n   TestUnaryOp(HloOpcode::kTan, std::move(expected), std::move(operand),\n               use_bfloat16_ ? 0.031250 : 9.5367431640625E-7);\n }\n+TEST_F(HloEvaluatorTest, DoesSinC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex64>({1.2985, 0.6350});\n+  TestUnaryOp(HloOpcode::kSin, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesSinC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex128>({1.298457581, 0.634963915});\n+  TestUnaryOp(HloOpcode::kSin, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesCosC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.8337, -0.9889});\n+  TestUnaryOp(HloOpcode::kCos, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesCosC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({1.0, 1.0});\n+  auto expected =\n+      LiteralUtil::CreateR0<complex128>({0.833730025, -0.988897706});\n+  TestUnaryOp(HloOpcode::kCos, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesTanC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.2718, 1.0839});\n+  TestUnaryOp(HloOpcode::kTan, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesTanC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex128>({0.271752585, 1.083923327});\n+  TestUnaryOp(HloOpcode::kTan, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesSinhC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.6350, 1.2985});\n+  TestUnaryOp(HloOpcode::kSinh, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesSinhC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex128>({0.634963915, 1.298457581});\n+  TestUnaryOp(HloOpcode::kSinh, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesCoshC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.8337, 0.9889});\n+  TestUnaryOp(HloOpcode::kCosh, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesCoshC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex128>({0.833730025, 0.988897706});\n+  TestUnaryOp(HloOpcode::kCosh, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesAsinC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.4523, 0.5306});\n+  TestUnaryOp(HloOpcode::kAsin, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesAsinC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex128>({0.452278447, 0.530637531});\n+  TestUnaryOp(HloOpcode::kAsin, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesAcosC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex64>({1.1185, -0.5306});\n+  TestUnaryOp(HloOpcode::kAcos, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesAcosC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({0.5, 0.5});\n+  auto expected =\n+      LiteralUtil::CreateR0<complex128>({1.118517880, -0.530637531});\n+  TestUnaryOp(HloOpcode::kAcos, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesAsinhC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.5306, 0.4523});\n+  TestUnaryOp(HloOpcode::kAsinh, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesAsinhC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex128>({0.530637531, 0.452278447});\n+  TestUnaryOp(HloOpcode::kAsinh, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesAcoshC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex64>({1.0613, 0.9046});\n+  TestUnaryOp(HloOpcode::kAcosh, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesAcoshC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({1.0, 1.0});\n+  auto expected = LiteralUtil::CreateR0<complex128>({1.061275062, 0.904556894});\n+  TestUnaryOp(HloOpcode::kAcosh, std::move(expected), std::move(operand), 1e-9);\n+}\n+TEST_F(HloEvaluatorTest, DoesAtanhC64) {\n+  auto operand = LiteralUtil::CreateR0<complex64>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex64>({0.4024, 0.5536});\n+  TestUnaryOp(HloOpcode::kAtanh, std::move(expected), std::move(operand), 1e-4);\n+}\n+TEST_F(HloEvaluatorTest, DoesAtanhC128) {\n+  auto operand = LiteralUtil::CreateR0<complex128>({0.5, 0.5});\n+  auto expected = LiteralUtil::CreateR0<complex128>({0.402359478, 0.553574359});\n+  TestUnaryOp(HloOpcode::kAtanh, std::move(expected), std::move(operand), 1e-9);\n+}\n TEST_F(HloEvaluatorTest, DoesNotR2) {\n   auto operand =\n       LiteralUtil::CreateR2<int32_t>({{0, std::numeric_limits<int>::min()},"
        },
        {
            "sha": "3ead99f0f0128fde9ea5bba216c6463f6cdd4ac3",
            "filename": "third_party/xla/xla/hlo/evaluator/hlo_evaluator_typed_visitor.h",
            "status": "modified",
            "additions": 63,
            "deletions": 102,
            "changes": 165,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Fhlo%2Fevaluator%2Fhlo_evaluator_typed_visitor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Fhlo%2Fevaluator%2Fhlo_evaluator_typed_visitor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fevaluator%2Fhlo_evaluator_typed_visitor.h?ref=6b2f4d629fa2c327d16252d4ecacec51c0b3880d",
            "patch": "@@ -240,42 +240,31 @@ class HloEvaluatorTypedVisitor : public ConstDfsHloVisitorWithDefault {\n   }\n \n   absl::Status HandleAcos(const HloInstruction* acos) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(acos, [](ElementwiseT elem_operand) {\n-            return std::acos(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(acos, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(acos);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(acos, [](ElementwiseT elem_operand) {\n+                          return std::acos(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(acos, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleAcosh(const HloInstruction* acosh) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(acosh, [](ElementwiseT elem_operand) {\n-            return std::acosh(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(acosh, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(acosh);\n+    TF_ASSIGN_OR_RETURN(\n+        Literal literal,\n+        ElementWiseUnaryOp(acosh, [](ElementwiseT elem_operand) {\n+          return std::acosh(elem_operand);\n+        }));\n+    parent_->SetEvaluatedLiteralFor(acosh, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleAsin(const HloInstruction* asin) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(asin, [](ElementwiseT elem_operand) {\n-            return std::asin(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(asin, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(asin);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(asin, [](ElementwiseT elem_operand) {\n+                          return std::asin(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(asin, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleRound(const HloInstruction* round) override {\n@@ -475,16 +464,13 @@ class HloEvaluatorTypedVisitor : public ConstDfsHloVisitorWithDefault {\n   }\n \n   absl::Status HandleAsinh(const HloInstruction* asinh) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(asinh, [](ElementwiseT elem_operand) {\n-            return std::asinh(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(asinh, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(asinh);\n+    TF_ASSIGN_OR_RETURN(\n+        Literal literal,\n+        ElementWiseUnaryOp(asinh, [](ElementwiseT elem_operand) {\n+          return std::asinh(elem_operand);\n+        }));\n+    parent_->SetEvaluatedLiteralFor(asinh, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleAtan2(const HloInstruction* atan2) override {\n@@ -512,16 +498,13 @@ class HloEvaluatorTypedVisitor : public ConstDfsHloVisitorWithDefault {\n   }\n \n   absl::Status HandleAtanh(const HloInstruction* atanh) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(atanh, [](ElementwiseT elem_operand) {\n-            return std::atanh(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(atanh, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(atanh);\n+    TF_ASSIGN_OR_RETURN(\n+        Literal literal,\n+        ElementWiseUnaryOp(atanh, [](ElementwiseT elem_operand) {\n+          return std::atanh(elem_operand);\n+        }));\n+    parent_->SetEvaluatedLiteralFor(atanh, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleTanh(const HloInstruction* tanh) override {\n@@ -2083,70 +2066,48 @@ class HloEvaluatorTypedVisitor : public ConstDfsHloVisitorWithDefault {\n   }\n \n   absl::Status HandleSin(const HloInstruction* sin) override {\n-    if constexpr (std::is_floating_point_v<ElementwiseT> ||\n-                  is_complex_v<ElementwiseT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(sin, [](ElementwiseT elem_operand) {\n-            return std::sin(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(sin, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(sin);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(sin, [](ElementwiseT elem_operand) {\n+                          return std::sin(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(sin, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleSinh(const HloInstruction* sinh) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(sinh, [](ElementwiseT elem_operand) {\n-            return std::sinh(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(sinh, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(sinh);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(sinh, [](ElementwiseT elem_operand) {\n+                          return std::sinh(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(sinh, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleCos(const HloInstruction* cos) override {\n-    if constexpr (std::is_floating_point_v<ElementwiseT> ||\n-                  is_complex_v<ElementwiseT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(cos, [](ElementwiseT elem_operand) {\n-            return std::cos(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(cos, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(cos);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(cos, [](ElementwiseT elem_operand) {\n+                          return std::cos(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(cos, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleCosh(const HloInstruction* cosh) override {\n-    if constexpr (!is_complex_v<ReturnT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(cosh, [](ElementwiseT elem_operand) {\n-            return std::cosh(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(cosh, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(cosh);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(cosh, [](ElementwiseT elem_operand) {\n+                          return std::cosh(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(cosh, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   absl::Status HandleTan(const HloInstruction* tan) override {\n-    if constexpr (std::is_floating_point_v<ElementwiseT>) {\n-      TF_ASSIGN_OR_RETURN(\n-          Literal literal,\n-          ElementWiseUnaryOp(tan, [](ElementwiseT elem_operand) {\n-            return std::tan(elem_operand);\n-          }));\n-      parent_->SetEvaluatedLiteralFor(tan, std::move(literal));\n-      return absl::OkStatus();\n-    }\n-    return UnsupportedTypeError(tan);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ElementWiseUnaryOp(tan, [](ElementwiseT elem_operand) {\n+                          return std::tan(elem_operand);\n+                        }));\n+    parent_->SetEvaluatedLiteralFor(tan, std::move(literal));\n+    return absl::OkStatus();\n   }\n \n   template <typename NativeT, typename std::enable_if_t<"
        },
        {
            "sha": "5d243167b8b6597bfdc0fa1159dbc2649fda7a0d",
            "filename": "third_party/xla/xla/service/shape_inference.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Fservice%2Fshape_inference.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Fservice%2Fshape_inference.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fshape_inference.cc?ref=6b2f4d629fa2c327d16252d4ecacec51c0b3880d",
            "patch": "@@ -347,18 +347,11 @@ absl::StatusOr<DimAndBound> InferMostSpecificDimAndBound(int64_t dim,\n \n   TF_DCHECK_OK(ShapeUtil::ValidateShapeWithOptionalLayout(shape));\n   switch (opcode) {\n-    case HloOpcode::kAsin:\n-    case HloOpcode::kAsinh:\n-    case HloOpcode::kAcos:\n-    case HloOpcode::kAcosh:\n-    case HloOpcode::kAtanh:\n-    case HloOpcode::kCosh:\n     case HloOpcode::kFloor:\n     case HloOpcode::kCbrt:  // Complex cbrt is not implemented in either of the\n                             // backends.\n     case HloOpcode::kCeil:\n     case HloOpcode::kErf:\n-    case HloOpcode::kSinh:\n     case HloOpcode::kRoundNearestAfz:\n     case HloOpcode::kRoundNearestEven:\n       if (!ShapeUtil::ElementIsFloating(shape)) {\n@@ -368,7 +361,14 @@ absl::StatusOr<DimAndBound> InferMostSpecificDimAndBound(int64_t dim,\n             HloOpcodeString(opcode), PrimitiveType_Name(shape.element_type()));\n       }\n       return shape;\n+    case HloOpcode::kAsin:\n+    case HloOpcode::kAsinh:\n+    case HloOpcode::kAcos:\n+    case HloOpcode::kAcosh:\n+    case HloOpcode::kAtanh:\n+    case HloOpcode::kCosh:\n     case HloOpcode::kCos:\n+    case HloOpcode::kSinh:\n     case HloOpcode::kSin:\n     case HloOpcode::kExp:\n     case HloOpcode::kExpm1:"
        },
        {
            "sha": "50023f9e10357116918c7a8b72efe5fa3c9d8a51",
            "filename": "third_party/xla/xla/tests/complex_unary_op_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Ftests%2Fcomplex_unary_op_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6b2f4d629fa2c327d16252d4ecacec51c0b3880d/third_party%2Fxla%2Fxla%2Ftests%2Fcomplex_unary_op_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fcomplex_unary_op_test.cc?ref=6b2f4d629fa2c327d16252d4ecacec51c0b3880d",
            "patch": "@@ -40,6 +40,14 @@ class ComplexUnaryOpTest\n     : public ClientLibraryTestRunnerMixin<\n           HloPjRtInterpreterReferenceMixin<HloPjRtTestBase>> {\n  protected:\n+  // Disable constant folding to ensure we test the actual backend\n+  // implementation. Otherwise, constant folding pre-computes results using\n+  // HloEvaluator's reference implementation (std c++), not the backend under\n+  // test.\n+  void SetUp() override {\n+    ClientLibraryTestRunnerMixin::SetUp();\n+    mutable_debug_options()->add_xla_disable_hlo_passes(\"constant_folding\");\n+  }\n   template <typename T, size_t index, typename... Types>\n   std::vector<T> get_column(const std::vector<std::tuple<Types...>>& table) {\n     std::vector<T> column;"
        }
    ],
    "stats": {
        "total": 292,
        "additions": 182,
        "deletions": 110
    }
}