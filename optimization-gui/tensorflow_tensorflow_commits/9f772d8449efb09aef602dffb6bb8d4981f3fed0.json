{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Optimize Future::Map for ready futures\n\n```\nname                        cpu/op        cpu/op      vs base\nBM_CreateOkFuture           1.948n ± 0%   1.627n ± 0%  -16.50% (n=80)\nBM_CopyFuture               1.946n ± 0%   1.625n ± 0%  -16.52% (n=80)\nBM_MapStatelessFuture       37.16n ± 0%   15.90n ± 0%  -57.21% (n=80)\nBM_TryMapStatelessFuture    36.03n ± 1%   15.88n ± 0%  -55.93% (n=80)\nBM_MapToFromStatelessFuture 38.04n ± 0%   15.91n ± 0%  -58.19% (n=80)\nBM_MapStatefulFuture        38.43n ± 0%   16.45n ± 0%  -57.18% (n=80)\nBM_TryMapStatefulFuture     37.50n ± 0%   16.45n ± 0%  -56.13% (n=80)\ngeomean                     16.08n        8.368n       -47.97%\n```\n\nPiperOrigin-RevId: 817788917",
    "sha": "9f772d8449efb09aef602dffb6bb8d4981f3fed0",
    "files": [
        {
            "sha": "680cffb842b8478a44984f46da739ef79ae4e5dd",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f772d8449efb09aef602dffb6bb8d4981f3fed0/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f772d8449efb09aef602dffb6bb8d4981f3fed0/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h?ref=9f772d8449efb09aef602dffb6bb8d4981f3fed0",
            "patch": "@@ -432,7 +432,11 @@ class AsyncValue {\n     DestructorFn destructor;\n     GetErrorFn get_error;\n     SetErrorFn set_error;\n+#ifndef NDEBUG\n+    // This function is only used in debug builds, so it can be omitted from the\n+    // type info in optimized builds for better data locality of other members.\n     HasDataFn has_data;\n+#endif\n   };\n \n   template <typename Derived>\n@@ -448,9 +452,11 @@ class AsyncValue {\n         [](AsyncValue* v, absl::Status status) {\n           static_cast<Derived*>(v)->SetError(std::move(status));\n         },\n+#ifndef NDEBUG\n         [](const AsyncValue* v) {\n           return static_cast<const Derived*>(v)->HasData();\n         },\n+#endif\n     };\n   }\n "
        },
        {
            "sha": "da7ab3202c65942d61512194b0679fab9fb1546f",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 89,
            "deletions": 57,
            "changes": 146,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f772d8449efb09aef602dffb6bb8d4981f3fed0/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f772d8449efb09aef602dffb6bb8d4981f3fed0/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=9f772d8449efb09aef602dffb6bb8d4981f3fed0",
            "patch": "@@ -29,7 +29,6 @@ limitations under the License.\n #include \"absl/meta/type_traits.h\"\n #include \"absl/status/status.h\"\n #include \"absl/types/span.h\"\n-#include \"absl/utility/utility.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/executor.h\"\n@@ -136,6 +135,8 @@ class FutureMoveControl</*is_move_only=*/false> {\n template <typename T, bool is_move_only = !std::is_copy_constructible_v<T>>\n class FutureBase : public FutureMoveControl<is_move_only> {\n  protected:\n+  FutureBase() = default;\n+\n   // A protected constructor that hides AsyncValueRef implementation detail\n   // from the end users of Future and Promise. Must not be made public!\n   FutureBase(tsl::AsyncValueRef<T> promise,\n@@ -145,18 +146,14 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n         on_block_start_(std::move(on_block_start)),\n         on_block_end_(std::move(on_block_end)) {}\n \n- public:\n-  FutureBase() = default;\n-\n   // Constructor for an already-available Future.\n-  //\n-  // Typically used to eagerly return error values when async work will not\n-  // be enqueued, e.g., due to invalid arguments.\n-  explicit FutureBase(T t, FutureHelpers::OnBlockStart on_block_start = nullptr,\n-                      FutureHelpers::OnBlockEnd on_block_end = nullptr)\n-      : FutureBase(tsl::MakeAvailableAsyncValueRef<T>(std::move(t)),\n-                   std::move(on_block_start), std::move(on_block_end)) {}\n+  template <typename U, std::enable_if_t<std::is_constructible_v<T, U> ||\n+                                         std::is_same_v<T, U>>* = nullptr>\n+  explicit FutureBase(U&& value)\n+      : FutureBase(tsl::MakeAvailableAsyncValueRef<T>(std::forward<U>(value)),\n+                   /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n \n+ public:\n   bool IsValid() const { return promise_ != nullptr; }\n \n   // Two functions exist to know whether the future is ready, to accommodate\n@@ -286,7 +283,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n       ProfilingCleanup scope = OnBlockStartScope();\n       block_until_ready_fn(promise_.GetAsyncValue());\n     }\n-    DCHECK(promise_.IsConcrete());\n+    DCHECK(promise_.IsAvailable());\n   }\n \n   // Blocks the calling thread until the future is ready, then returns the\n@@ -333,7 +330,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n     CHECK(IsValid());\n     promise_.AndThen(\n         [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-          DCHECK(promise.IsConcrete());\n+          DCHECK(promise.IsAvailable());\n           f(*promise);\n         });\n   }\n@@ -352,7 +349,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n     CHECK(IsValid());\n     promise_.AndThen(\n         [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-          DCHECK(promise.IsConcrete());\n+          DCHECK(promise.IsAvailable());\n           if constexpr (is_move_only) {\n             f(std::move(*promise));\n           } else {\n@@ -366,7 +363,6 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n     promise_.reset();\n   }\n \n- protected:\n   // Returns a placeholder error that can be used when short-circuiting promises\n   // with no other references.\n   static absl::Status AbortedError() {\n@@ -376,6 +372,9 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n         \"is exposed to any future, that indicates a bug\");\n   }\n \n+  // Returns a non-owning pointer to the underlying AsyncValue container.\n+  AsyncValuePtr<T> promise() const { return promise_.AsPtr(); }\n+\n  private:\n   friend class tsl::FutureHelpers;\n \n@@ -440,7 +439,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   // Constructs and immediately available future from the given value.\n   template <typename U,\n             std::enable_if_t<std::is_constructible_v<T, U>>* = nullptr>\n-  explicit Future(U value) : Base(std::forward<U>(value)) {}\n+  explicit Future(U&& value) : Base(std::forward<U>(value)) {}\n \n   class [[nodiscard]] Promise : public Base::Promise {\n    public:\n@@ -537,11 +536,29 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n             typename U = std::invoke_result_t<F, const T&>,\n             internal::Mappable<R, U>* = nullptr>\n   [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const& {\n+    // If `*this` is ready, construct the mapped future immediately.\n+    if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n+      const absl::StatusOr<T>& value = *Base::promise();\n+\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!value.ok())) {\n+        return Future<R>(value.status());\n+      }\n+\n+      // Construct the result future available with a result of invoking `f`.\n+      if constexpr (std::is_void_v<U>) {\n+        return Future<R>((f(*value), absl::OkStatus()));\n+      } else {\n+        return Future<R>(f(*value));\n+      }\n+    }\n+\n+    // If `*this` is not ready yet, we need to create a new promise and fulfill\n+    // it with a result of `f` when `*this` becomes ready.\n     auto [promise, future] = Future<R>::MakePromise();\n \n-    using Value = const absl::StatusOr<T>&;\n     OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](Value value) mutable {\n+             f = std::forward<F>(f)](const absl::StatusOr<T>& value) mutable {\n       // Do not compute `f` if the result is unused.\n       if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n         promise.Set(Base::AbortedError());\n@@ -557,17 +574,8 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n       // Set the result future available with a result of invoking `f`.\n       if constexpr (std::is_void_v<U>) {\n         promise.Set((f(*value), absl::OkStatus()));\n-      } else if constexpr (internal::is_status_v<U>) {\n-        promise.Set(f(*value));\n-      } else if constexpr (internal::is_status_or_v<U>) {\n-        absl::StatusOr<typename U::value_type> result = f(*value);\n-        if (ABSL_PREDICT_TRUE(result.ok())) {\n-          promise.emplace(absl::in_place_t{}, *std::move(result));\n-        } else {\n-          promise.Set(std::move(result).status());\n-        }\n       } else {\n-        promise.emplace(absl::in_place_t{}, f(*value));\n+        promise.Set(f(*value));\n       }\n     });\n \n@@ -603,8 +611,34 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n             internal::Mappable<R, U>* = nullptr>\n   [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) && {\n+    // If `*this` is ready, construct the mapped future immediately.\n+    if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n+      // For copyable types bind to const reference, so that we don't\n+      // accidentally move the value from the underlying async value storage.\n+      using Value = std::conditional_t<is_move_only, absl::StatusOr<T>&,\n+                                       const absl::StatusOr<T>&>;\n+      Value value = *Base::promise();\n+\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!value.ok())) {\n+        return Future<R>(value.status());\n+      }\n+\n+      // Construct the result future available with a result of invoking `f`.\n+      if constexpr (std::is_void_v<U>) {\n+        return Future<R>((f(std::move(*value)), absl::OkStatus()));\n+      } else {\n+        return Future<R>(f(std::move(*value)));\n+      }\n+    }\n+\n+    // If `*this` is not ready yet, we need to create a new promise and fulfill\n+    // it with a result of `f` when `*this` becomes ready.\n     auto [promise, future] = Future<R>::MakePromise();\n \n+    // For copyable types bind to const reference, so that we don't\n+    // accidentally move the value from the underlying async value storage.\n+    // Move-only types are passed by value into the `OnReady` callback.\n     using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n                                      const absl::StatusOr<T>&>;\n     std::move(*this).OnReady([promise = std::move(promise),\n@@ -624,17 +658,8 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n       // Set the result future available with a result of invoking `f`.\n       if constexpr (std::is_void_v<U>) {\n         promise.Set((f(std::move(*value)), absl::OkStatus()));\n-      } else if constexpr (internal::is_status_v<U>) {\n-        promise.Set(f(std::move(*value)));\n-      } else if constexpr (internal::is_status_or_v<U>) {\n-        absl::StatusOr<typename U::value_type> result = f(std::move(*value));\n-        if (ABSL_PREDICT_TRUE(result.ok())) {\n-          promise.emplace(absl::in_place_t{}, *std::move(result));\n-        } else {\n-          promise.Set(std::move(result).status());\n-        }\n       } else {\n-        promise.emplace(absl::in_place_t{}, f(std::move(*value)));\n+        promise.Set(f(std::move(*value)));\n       }\n     });\n \n@@ -719,13 +744,12 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n                        std::move(status)),\n              /*on_block_start=*/nullptr, /*on_block_end=*/nullptr) {}\n \n-  // Support implicit construction from immediate `Status` convertible to\n+  // Support implicit construction from immediate `U` convertible to\n   // `absl::Status`.\n-  template <\n-      typename Status,\n-      std::enable_if_t<std::is_convertible_v<Status, absl::Status>>* = nullptr>\n-  Future(Status&& status)  // NOLINT\n-      : Future(absl::Status(std::forward<Status>(status))) {}\n+  template <typename U,\n+            std::enable_if_t<std::is_convertible_v<U, absl::Status>>* = nullptr>\n+  Future(U&& status)  // NOLINT\n+      : Future(absl::Status(std::forward<U>(status))) {}\n \n   class [[nodiscard]] Promise : public Base::Promise {\n    public:\n@@ -810,7 +834,24 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // See `Map` functor type inference defined below for more details.\n   template <typename R, typename F, typename U = std::invoke_result_t<F>,\n             internal::Mappable<R, U>* = nullptr>\n-  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE Future<R> Map(F&& f) const {\n+    // If `*this` is ready, construct the mapped future immediately.\n+    if (ABSL_PREDICT_TRUE(Base::promise().IsAvailable())) {\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!Base::promise()->ok())) {\n+        return Future<R>(*Base::promise());\n+      }\n+\n+      // Construct the result future available with a result of invoking `f`.\n+      if constexpr (std::is_void_v<U>) {\n+        return Future<R>((f(), absl::OkStatus()));\n+      } else {\n+        return Future<R>(f());\n+      }\n+    }\n+\n+    // If `*this` is not ready yet, we need to create a new promise and fulfill\n+    // it with a result of `f` when `*this` becomes ready.\n     auto [promise, future] = Future<R>::MakePromise();\n \n     OnReady([promise = std::move(promise),\n@@ -830,17 +871,8 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n       // Set the result future available with a result of invoking `f`.\n       if constexpr (std::is_void_v<U>) {\n         promise.Set((f(), absl::OkStatus()));\n-      } else if constexpr (internal::is_status_v<U>) {\n-        promise.Set(f());\n-      } else if constexpr (internal::is_status_or_v<U>) {\n-        absl::StatusOr<typename U::value_type> result = f();\n-        if (ABSL_PREDICT_TRUE(result.ok())) {\n-          promise.emplace(absl::in_place_t{}, *std::move(result));\n-        } else {\n-          promise.Set(std::move(result).status());\n-        }\n       } else {\n-        promise.emplace(absl::in_place_t{}, f());\n+        promise.Set(f());\n       }\n     });\n \n@@ -854,7 +886,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // - `R` is any other type      -> Future<R>\n   //\n   template <typename F, typename R = std::invoke_result_t<F>>\n-  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) const {\n     if constexpr (std::is_void_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {\n@@ -876,7 +908,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   //   future.MapTo(std::move(buffer));\n   //\n   template <typename R>\n-  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto MapTo(R&& value) {\n+  [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto MapTo(R&& value) const {\n     return Map<absl::remove_cvref_t<R>>(\n         [value = std::forward<R>(value)]() mutable {\n           return std::move(value);"
        },
        {
            "sha": "5397eba6f9d24cda9032f2502fd138c9972e098d",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f772d8449efb09aef602dffb6bb8d4981f3fed0/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f772d8449efb09aef602dffb6bb8d4981f3fed0/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=9f772d8449efb09aef602dffb6bb8d4981f3fed0",
            "patch": "@@ -267,7 +267,7 @@ TEST(FutureTest, MapMoveOnlyFutureError) {\n \n TEST(FutureTest, MapCopyableWithInplaceConstructor) {\n   struct Struct {\n-    explicit Struct(int32_t v) : v(v) {}\n+    Struct(int32_t v) : v(v) {}  // NOLINT\n     int32_t v;\n   };\n \n@@ -281,7 +281,7 @@ TEST(FutureTest, MapCopyableWithInplaceConstructor) {\n \n TEST(FutureTest, MapMoveOnlyWithInplaceConstructor) {\n   struct Struct {\n-    explicit Struct(int32_t v) : v(v) {}\n+    Struct(int32_t v) : v(v) {}  // NOLINT\n     int32_t v;\n   };\n "
        }
    ],
    "stats": {
        "total": 156,
        "additions": 97,
        "deletions": 59
    }
}