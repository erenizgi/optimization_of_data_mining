{
    "author": "WillFroom",
    "message": "[XLA:CPU] Sort kernels before consumption in ParallelFusionEmitter.\n\nPiperOrigin-RevId: 799518333",
    "sha": "57bd745088559d916c6d42863069a4bff9b9148a",
    "files": [
        {
            "sha": "dcfde37ea8aa68108823f1e13a0a4afa211b2f2d",
            "filename": "third_party/xla/xla/service/cpu/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/57bd745088559d916c6d42863069a4bff9b9148a/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/57bd745088559d916c6d42863069a4bff9b9148a/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD?ref=57bd745088559d916c6d42863069a4bff9b9148a",
            "patch": "@@ -2049,6 +2049,7 @@ cc_library(\n         \"//xla/service:buffer_assignment\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/functional:function_ref\",\n@@ -2073,6 +2074,7 @@ xla_test(\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:threadpool_interface\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\","
        },
        {
            "sha": "7a1053111de71d7b1818583cbe6b804417302137",
            "filename": "third_party/xla/xla/service/cpu/parallel_fusion_emitter.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/57bd745088559d916c6d42863069a4bff9b9148a/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/57bd745088559d916c6d42863069a4bff9b9148a/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter.cc?ref=57bd745088559d916c6d42863069a4bff9b9148a",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <utility>\n #include <vector>\n \n+#include \"absl/algorithm/container.h\"\n #include \"absl/base/thread_annotations.h\"\n #include \"absl/functional/bind_front.h\"\n #include \"absl/functional/function_ref.h\"\n@@ -189,6 +190,12 @@ ParallelFusionEmitter::ConsumeKernels() {\n     return kernels_status_;\n   }\n \n+  // Sort the kernels by name to ensure a deterministic order.\n+  absl::c_sort(kernels_, [](const LlvmKernelDefinition& lhs,\n+                            const LlvmKernelDefinition& rhs) {\n+    return lhs.spec().name() < rhs.spec().name();\n+  });\n+\n   return std::move(kernels_);\n }\n "
        },
        {
            "sha": "11262fc0b979ef950e5d8f537abc9573090c2e90",
            "filename": "third_party/xla/xla/service/cpu/parallel_fusion_emitter_test.cc",
            "status": "modified",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/57bd745088559d916c6d42863069a4bff9b9148a/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/57bd745088559d916c6d42863069a4bff9b9148a/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fparallel_fusion_emitter_test.cc?ref=57bd745088559d916c6d42863069a4bff9b9148a",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #include \"xla/service/cpu/parallel_fusion_emitter.h\"\n \n #include <cstdint>\n+#include <functional>\n #include <utility>\n \n #include <gmock/gmock.h>\n@@ -28,11 +29,13 @@ limitations under the License.\n #include \"xla/codegen/llvm_kernel_definition.h\"\n #include \"xla/hlo/ir/hlo_casting_utils.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n+#include \"xla/tsl/platform/threadpool_interface.h\"\n \n namespace xla::cpu {\n namespace {\n@@ -78,6 +81,13 @@ FusionCompiler::CompilationHooks ParallelFusionEmitterTest::CreateMockHooks(\n   return hooks;\n }\n \n+class BlockingThreadPool final : public tsl::thread::ThreadPoolInterface {\n+ public:\n+  void Schedule(std::function<void()> fn) override { fn(); }\n+  int NumThreads() const override { return 1; }\n+  int CurrentThreadId() const override { return 0; }\n+};\n+\n TEST_F(ParallelFusionEmitterTest, HappyPathSingleFusion) {\n   constexpr absl::string_view expected_name = \"root_fusion\";\n   constexpr absl::string_view trivial_fusion = R\"(\n@@ -118,6 +128,56 @@ TEST_F(ParallelFusionEmitterTest, HappyPathSingleFusion) {\n             nullptr);\n }\n \n+TEST_F(ParallelFusionEmitterTest, FusionsAreSorted) {\n+  constexpr absl::string_view trivial_fusion = R\"(\n+    fusion_computation_0 {\n+      p = s32[] parameter(0)\n+      c = s32[] constant(1)\n+      ROOT a = s32[] add(p, c)\n+    }\n+\n+    fusion_computation_1 {\n+      p = s32[] parameter(0)\n+      c = s32[] constant(1)\n+      ROOT a = s32[] add(p, c)\n+    }\n+\n+    ENTRY main {\n+      p = s32[] parameter(0)\n+      fusion_0 = s32[] fusion(p), kind=kLoop, calls=fusion_computation_0\n+      fusion_1 = s32[] fusion(p), kind=kLoop, calls=fusion_computation_1\n+      ROOT result_tuple = (s32[], s32[]) tuple(fusion_0, fusion_1)\n+    })\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto hlo_module,\n+                          ParseAndReturnVerifiedModule(trivial_fusion));\n+  HloComputation* computation = hlo_module->entry_computation();\n+  HloInstruction* root_tuple = computation->root_instruction();\n+  const auto* fusion_0 = Cast<HloFusionInstruction>(root_tuple->operand(0));\n+  const auto* fusion_1 = Cast<HloFusionInstruction>(root_tuple->operand(1));\n+\n+  BlockingThreadPool blocking_thread_pool;\n+  tsl::thread::ThreadPool thread_pool(&blocking_thread_pool);\n+\n+  xla::cpu::ParallelFusionEmitter fussion_emitter(\n+      thread_pool, CreateDefaultOptions(), CreateMockHooks(2),\n+      /*buffer_assignment=*/nullptr, /*use_unique_c_name=*/false);\n+\n+  // Add the fusions in reverse order.\n+  TF_ASSERT_OK_AND_ASSIGN(auto kernel_spec_1,\n+                          fussion_emitter.AddFusion(fusion_1));\n+  EXPECT_EQ(kernel_spec_1.name(), \"fusion_1\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto kernel_spec_0,\n+                          fussion_emitter.AddFusion(fusion_0));\n+  EXPECT_EQ(kernel_spec_0.name(), \"fusion_0\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto kernels, fussion_emitter.ConsumeKernels());\n+  ASSERT_EQ(kernels.size(), 2);\n+  EXPECT_EQ(kernels[0].spec().name(), \"fusion_0\");\n+  EXPECT_EQ(kernels[1].spec().name(), \"fusion_1\");\n+}\n+\n // Check that error condition from emitting is propagated.\n TEST_F(ParallelFusionEmitterTest, Error) {\n   // Dot instruction with algorithm dot_bf16_bf16_bf16 is not supported by the"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 69,
        "deletions": 0
    }
}