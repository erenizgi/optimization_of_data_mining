{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 829795220",
    "sha": "b6ac345231f0e5f32a9e158e19ef6e32b74e635b",
    "files": [
        {
            "sha": "e639f9a7dda4765ee8a39fed22b1328a7d5f0aa9",
            "filename": "tensorflow/c/experimental/filesystem/plugins/gcs/expiring_lru_cache_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b6ac345231f0e5f32a9e158e19ef6e32b74e635b/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fexpiring_lru_cache_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b6ac345231f0e5f32a9e158e19ef6e32b74e635b/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fexpiring_lru_cache_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fexpiring_lru_cache_test.cc?ref=b6ac345231f0e5f32a9e158e19ef6e32b74e635b",
            "patch": "@@ -27,7 +27,7 @@ namespace tensorflow {\n namespace {\n \n TEST(ExpiringLRUCacheTest, MaxAge) {\n-  const string key = \"a\";\n+  const std::string key = \"a\";\n   std::unique_ptr<NowSecondsEnv> env(new NowSecondsEnv);\n   tf_gcs_filesystem::ExpiringLRUCache<int> cache(\n       1, 0, [&env]() { return env->NowSeconds(); });\n@@ -95,9 +95,10 @@ TEST(ExpiringLRUCacheTest, MaxEntries) {\n \n TEST(ExpiringLRUCacheTest, LookupOrCompute) {\n   // max_age of 0 means we should always compute.\n-  uint64 num_compute_calls = 0;\n+  uint64_t num_compute_calls = 0;\n   tf_gcs_filesystem::ExpiringLRUCache<int>::ComputeFunc compute_func =\n-      [&num_compute_calls](const string& key, int* value, TF_Status* status) {\n+      [&num_compute_calls](const std::string& key, int* value,\n+                           TF_Status* status) {\n         *value = num_compute_calls;\n         num_compute_calls++;\n         return TF_SetStatus(status, TF_OK, \"\");"
        },
        {
            "sha": "23645ed8e878bfa5e77de532aaf33ae0354ce4db",
            "filename": "tensorflow/c/experimental/filesystem/plugins/gcs/ram_file_block_cache_test.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 24,
            "changes": 49,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b6ac345231f0e5f32a9e158e19ef6e32b74e635b/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fram_file_block_cache_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b6ac345231f0e5f32a9e158e19ef6e32b74e635b/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fram_file_block_cache_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fc%2Fexperimental%2Ffilesystem%2Fplugins%2Fgcs%2Fram_file_block_cache_test.cc?ref=b6ac345231f0e5f32a9e158e19ef6e32b74e635b",
            "patch": "@@ -39,7 +39,7 @@ namespace tensorflow {\n namespace {\n \n absl::Status ReadCache(tf_gcs_filesystem::RamFileBlockCache* cache,\n-                       const string& filename, size_t offset, size_t n,\n+                       const std::string& filename, size_t offset, size_t n,\n                        std::vector<char>* out) {\n   out->clear();\n   out->resize(n, 0);\n@@ -54,7 +54,7 @@ absl::Status ReadCache(tf_gcs_filesystem::RamFileBlockCache* cache,\n }\n \n TEST(RamFileBlockCacheTest, IsCacheEnabled) {\n-  auto fetcher = [](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [](const std::string& filename, size_t offset, size_t n,\n                     char* buffer, TF_Status* status) -> int64_t {\n     // Do nothing.\n     TF_SetStatus(status, TF_OK, \"\");\n@@ -73,14 +73,14 @@ TEST(RamFileBlockCacheTest, IsCacheEnabled) {\n \n TEST(RamFileBlockCacheTest, ValidateAndUpdateFileSignature) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, TF_Status* status) -> int64_t {\n     calls++;\n     memset(buffer, 'x', n);\n     TF_SetStatus(status, TF_OK, \"\");\n     return n;\n   };\n-  string filename = \"file\";\n+  std::string filename = \"file\";\n   tf_gcs_filesystem::RamFileBlockCache cache(16, 32, 0, fetcher);\n   std::vector<char> out;\n \n@@ -101,12 +101,12 @@ TEST(RamFileBlockCacheTest, ValidateAndUpdateFileSignature) {\n }\n \n TEST(RamFileBlockCacheTest, PassThrough) {\n-  const string want_filename = \"foo/bar\";\n+  const std::string want_filename = \"foo/bar\";\n   const size_t want_offset = 42;\n   const size_t want_n = 1024;\n   int calls = 0;\n   auto fetcher = [&calls, want_filename, want_offset, want_n](\n-                     const string& got_filename, size_t got_offset,\n+                     const std::string& got_filename, size_t got_offset,\n                      size_t got_n, char* buffer, TF_Status* status) -> int64_t {\n     EXPECT_EQ(got_filename, want_filename);\n     EXPECT_EQ(got_offset, want_offset);\n@@ -143,7 +143,7 @@ TEST(RamFileBlockCacheTest, BlockAlignment) {\n     buf.push_back(i);\n   }\n   // The fetcher just fetches slices of the buffer.\n-  auto fetcher = [&buf](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&buf](const std::string& filename, size_t offset, size_t n,\n                         char* buffer, TF_Status* status) -> int64_t {\n     int64_t bytes_transferred;\n     if (offset < buf.size()) {\n@@ -191,8 +191,8 @@ TEST(RamFileBlockCacheTest, BlockAlignment) {\n TEST(RamFileBlockCacheTest, CacheHits) {\n   const size_t block_size = 16;\n   std::set<size_t> calls;\n-  auto fetcher = [&calls, block_size](const string& filename, size_t offset,\n-                                      size_t n, char* buffer,\n+  auto fetcher = [&calls, block_size](const std::string& filename,\n+                                      size_t offset, size_t n, char* buffer,\n                                       TF_Status* status) -> int64_t {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset % block_size, 0);\n@@ -202,7 +202,7 @@ TEST(RamFileBlockCacheTest, CacheHits) {\n     TF_SetStatus(status, TF_OK, \"\");\n     return n;\n   };\n-  const uint32 block_count = 256;\n+  const uint32_t block_count = 256;\n   tf_gcs_filesystem::RamFileBlockCache cache(\n       block_size, block_count * block_size, 0, fetcher);\n   std::vector<char> out;\n@@ -225,7 +225,7 @@ TEST(RamFileBlockCacheTest, OutOfRange) {\n   bool first_block = false;\n   bool second_block = false;\n   auto fetcher = [block_size, file_size, &first_block, &second_block](\n-                     const string& filename, size_t offset, size_t n,\n+                     const std::string& filename, size_t offset, size_t n,\n                      char* buffer, TF_Status* status) -> int64_t {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset % block_size, 0);\n@@ -269,8 +269,9 @@ TEST(RamFileBlockCacheTest, Inconsistent) {\n   // where we expected complete blocks.\n   const size_t block_size = 16;\n   // This fetcher returns OK but only fills in one byte for any offset.\n-  auto fetcher = [block_size](const string& filename, size_t offset, size_t n,\n-                              char* buffer, TF_Status* status) -> int64_t {\n+  auto fetcher = [block_size](const std::string& filename, size_t offset,\n+                              size_t n, char* buffer,\n+                              TF_Status* status) -> int64_t {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset % block_size, 0);\n     EXPECT_GE(n, 1);\n@@ -293,8 +294,8 @@ TEST(RamFileBlockCacheTest, Inconsistent) {\n TEST(RamFileBlockCacheTest, LRU) {\n   const size_t block_size = 16;\n   std::list<size_t> calls;\n-  auto fetcher = [&calls, block_size](const string& filename, size_t offset,\n-                                      size_t n, char* buffer,\n+  auto fetcher = [&calls, block_size](const std::string& filename,\n+                                      size_t offset, size_t n, char* buffer,\n                                       TF_Status* status) -> int64_t {\n     EXPECT_EQ(n, block_size);\n     EXPECT_FALSE(calls.empty()) << \"at offset = \" << offset;\n@@ -306,7 +307,7 @@ TEST(RamFileBlockCacheTest, LRU) {\n     TF_SetStatus(status, TF_OK, \"\");\n     return n;\n   };\n-  const uint32 block_count = 2;\n+  const uint32_t block_count = 2;\n   tf_gcs_filesystem::RamFileBlockCache cache(\n       block_size, block_count * block_size, 0, fetcher);\n   std::vector<char> out;\n@@ -342,7 +343,7 @@ TEST(RamFileBlockCacheTest, LRU) {\n \n TEST(RamFileBlockCacheTest, MaxStaleness) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, TF_Status* status) -> int64_t {\n     calls++;\n     memset(buffer, 'x', n);\n@@ -386,7 +387,7 @@ TEST(RamFileBlockCacheTest, MaxStaleness) {\n \n TEST(RamFileBlockCacheTest, RemoveFile) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, TF_Status* status) -> int64_t {\n     calls++;\n     char c = (filename == \"a\") ? 'a' : (filename == \"b\") ? 'b' : 'x';\n@@ -448,7 +449,7 @@ TEST(RamFileBlockCacheTest, RemoveFile) {\n \n TEST(RamFileBlockCacheTest, Prune) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, TF_Status* status) -> int64_t {\n     calls++;\n     memset(buffer, 'x', n);\n@@ -458,7 +459,7 @@ TEST(RamFileBlockCacheTest, Prune) {\n   std::vector<char> out;\n   // Our fake environment is initialized with the current timestamp.\n   std::unique_ptr<NowSecondsEnv> env(new NowSecondsEnv);\n-  uint64 now = Env::Default()->NowSeconds();\n+  uint64_t now = Env::Default()->NowSeconds();\n   env->SetNowSeconds(now);\n   tf_gcs_filesystem::RamFileBlockCache cache(\n       8, 32, 1 /* max staleness */, fetcher,\n@@ -487,7 +488,7 @@ TEST(RamFileBlockCacheTest, Prune) {\n   // timestamp of `now` + 2, file \"a\" is stale because its first block is stale,\n   // but file \"b\" is not stale yet. Thus, once the pruning thread wakes up (in\n   // one second of wall time), it should remove \"a\" and leave \"b\" alone.\n-  uint64 start = Env::Default()->NowSeconds();\n+  uint64_t start = Env::Default()->NowSeconds();\n   do {\n     Env::Default()->SleepForMicroseconds(100000);\n   } while (cache.CacheSize() == 24 && Env::Default()->NowSeconds() - start < 3);\n@@ -515,7 +516,7 @@ TEST(RamFileBlockCacheTest, ParallelReads) {\n   absl::BlockingCounter counter(callers);\n   absl::Notification notification;\n   auto fetcher = [&counter, &notification](\n-                     const string& filename, size_t offset, size_t n,\n+                     const std::string& filename, size_t offset, size_t n,\n                      char* buffer, TF_Status* status) -> int64_t {\n     if (counter.DecrementCount()) {\n       notification.Notify();\n@@ -560,7 +561,7 @@ TEST(RamFileBlockCacheTest, CoalesceConcurrentReads) {\n   int num_requests = 0;\n   absl::Notification notification;\n   auto fetcher = [&num_requests, &notification, block_size](\n-                     const string& filename, size_t offset, size_t n,\n+                     const std::string& filename, size_t offset, size_t n,\n                      char* buffer, TF_Status* status) -> int64_t {\n     EXPECT_EQ(n, block_size);\n     EXPECT_EQ(offset, 0);\n@@ -591,7 +592,7 @@ TEST(RamFileBlockCacheTest, CoalesceConcurrentReads) {\n \n TEST(RamFileBlockCacheTest, Flush) {\n   int calls = 0;\n-  auto fetcher = [&calls](const string& filename, size_t offset, size_t n,\n+  auto fetcher = [&calls](const std::string& filename, size_t offset, size_t n,\n                           char* buffer, TF_Status* status) -> int64_t {\n     calls++;\n     memset(buffer, 'x', n);"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 29,
        "deletions": 27
    }
}