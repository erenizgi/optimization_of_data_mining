{
    "author": "LarryLansing",
    "message": "Add shared ownership to `tstring`'s VIEW type.\n\nThis change introduces `tstring::owner<T>`, a reference-counted wrapper for an object `T`. `tstring` can now be assigned a \"shared view\" using `assign_as_shared_view`, where the underlying data is owned by a `tstring::owner`. The `tstring` will increment the owner's reference count and decrement it when the `tstring` is deallocated or reassigned, ensuring the owner object remains alive as long as any `tstring` holds a shared view to its data. This is implemented by adding a `TStringOwnerCApi` pointer to the `TF_TString_View` struct and updating the relevant `TF_TString` functions to handle the reference counting.\n\nPiperOrigin-RevId: 832101409",
    "sha": "d717dd7dc0f5ed23a101a478650871f51461e492",
    "files": [
        {
            "sha": "e5545445817ec2f3c3ede63a0189b612b0e716ef",
            "filename": "tensorflow/compiler/tf2xla/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d717dd7dc0f5ed23a101a478650871f51461e492/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d717dd7dc0f5ed23a101a478650871f51461e492/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD?ref=d717dd7dc0f5ed23a101a478650871f51461e492",
            "patch": "@@ -375,6 +375,7 @@ cc_library(\n #         \"@local_tsl//tsl/platform:context\",\n #         \"@local_tsl//tsl/platform:cord\",\n #         \"@local_tsl//tsl/platform:env_time\",\n+#         \"@local_tsl//tsl/platform:refcount\",\n #         \"@local_tsl//tsl/platform:ml_dtypes\",\n #         \"@local_tsl//tsl/platform:logging\",\n #         \"@local_tsl//tsl/platform:macros\","
        },
        {
            "sha": "1853f5d6bbb3878ef0e0499fc93d544bfdb4e004",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD?ref=d717dd7dc0f5ed23a101a478650871f51461e492",
            "patch": "@@ -314,6 +314,7 @@ cc_library(\n     deps = [\n         \":cord\",\n         \":platform\",\n+        \":refcount\",\n         \":stringpiece\",\n     ],\n )"
        },
        {
            "sha": "0e45c0e8685636cdedffc46f0f872b593e7489f0",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/ctstring.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fctstring.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fctstring.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fctstring.h?ref=d717dd7dc0f5ed23a101a478650871f51461e492",
            "patch": "@@ -92,6 +92,12 @@ inline char *TF_TString_GetMutableDataPointer(TF_TString *str);\n inline void TF_TString_AssignView(TF_TString *dst, const char *src,\n                                   size_t size);\n \n+// Sets `dst' as an owning VIEW type to `src', taking shared ownership via\n+// `owner_ref`. If `owner_ref` is null, behaves as TF_TString_AssignView.\n+inline void TF_TString_AssignViewWithOwner(TF_TString *dst, const char *src,\n+                                           size_t size,\n+                                           TStringOwnerCApi *owner_ref);\n+\n // Appends `src' onto `dst'.  If `dst' is a VIEW or OFFSET type, it will first\n // be converted to an owned LARGE or SMALL type.  `dst' should not point to\n // memory owned by `src'."
        },
        {
            "sha": "dad9f483b378a1a1b7c57caf69540d1ec00c485f",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/ctstring_internal.h",
            "status": "modified",
            "additions": 51,
            "deletions": 8,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fctstring_internal.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fctstring_internal.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fctstring_internal.h?ref=d717dd7dc0f5ed23a101a478650871f51461e492",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n #define TENSORFLOW_TSL_PLATFORM_CTSTRING_INTERNAL_H_\n \n #include <limits.h>\n+#include <stdbool.h>  // IWYU pragma: keep, provides bool\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -81,6 +82,18 @@ typedef enum TF_TString_Type {  // NOLINT\n   TF_TSTR_TYPE_MASK = 0x03\n } TF_TString_Type;\n \n+// C-compatible API for tstring shared ownership.\n+struct TStringOwnerCApi;\n+\n+typedef void (*tstring_owner_ref_t)(struct TStringOwnerCApi *self);\n+typedef bool (*tstring_owner_unref_t)(struct TStringOwnerCApi *self);\n+\n+typedef struct TStringOwnerCApi {\n+  tstring_owner_ref_t ref;\n+  tstring_owner_unref_t unref;\n+  void *obj;  // Opaque pointer to the C++ owner object\n+} TStringOwnerCApi;\n+\n typedef struct TF_TString_Large {  // NOLINT\n   size_t size;\n   size_t cap;\n@@ -96,6 +109,7 @@ typedef struct TF_TString_Offset {  // NOLINT\n typedef struct TF_TString_View {  // NOLINT\n   size_t size;\n   const char *ptr;\n+  TStringOwnerCApi *owner_ref;\n } TF_TString_View;\n \n typedef struct TF_TString_Raw {  // NOLINT\n@@ -177,6 +191,10 @@ static inline void TF_TString_Dealloc(TF_TString *str) {\n       str->u.large.ptr != NULL) {  // NOLINT\n     free(str->u.large.ptr);\n     TF_TString_Init(str);\n+  } else if (TF_TString_GetType(str) == TF_TSTR_VIEW &&\n+             str->u.view.owner_ref != NULL) {  // NOLINT\n+    (void)str->u.view.owner_ref->unref(str->u.view.owner_ref);\n+    TF_TString_Init(str);\n   }\n }\n \n@@ -231,6 +249,8 @@ static inline char *TF_TString_ResizeUninitialized(TF_TString *str,\n \n   TF_TString_Type curr_type = TF_TString_GetType(str);\n   const char *curr_ptr = TF_TString_GetDataPointer(str);\n+  TStringOwnerCApi *curr_owner_ref =\n+      curr_type == TF_TSTR_VIEW ? str->u.view.owner_ref : NULL;  // NOLINT\n \n   // Case: SMALL/LARGE/VIEW/OFFSET -> SMALL\n   if (new_size <= TF_TString_SmallCapacity) {\n@@ -243,10 +263,10 @@ static inline char *TF_TString_ResizeUninitialized(TF_TString *str,\n \n     if (curr_type == TF_TSTR_LARGE) {\n       free((void *)curr_ptr);  // NOLINT\n+    } else if (curr_owner_ref != NULL) {  // NOLINT\n+      curr_owner_ref->unref(curr_owner_ref);\n     }\n \n-    // We do not clear out the newly excluded region.\n-\n     return str->u.smll.str;\n   }\n \n@@ -273,6 +293,9 @@ static inline char *TF_TString_ResizeUninitialized(TF_TString *str,\n     if (copy_size) {\n       memcpy(new_ptr, curr_ptr, copy_size);\n     }\n+    if (curr_type == TF_TSTR_VIEW && str->u.view.owner_ref != NULL) {  // NOLINT\n+      (void)str->u.view.owner_ref->unref(str->u.view.owner_ref);\n+    }\n   }\n \n   str->u.large.size = TF_TString_ToInternalSizeT(new_size, TF_TSTR_LARGE);\n@@ -333,6 +356,9 @@ static inline void TF_TString_Reserve(TF_TString *str, size_t new_cap) {\n     // Convert to Large\n     char *new_ptr = (char *)malloc(new_cap + 1);  // NOLINT\n     memcpy(new_ptr, curr_ptr, curr_size);\n+    if (curr_type == TF_TSTR_VIEW && str->u.view.owner_ref != NULL) {  // NOLINT\n+      (void)str->u.view.owner_ref->unref(str->u.view.owner_ref);\n+    }\n \n     str->u.large.size = TF_TString_ToInternalSizeT(curr_size, TF_TSTR_LARGE);\n     str->u.large.ptr = new_ptr;\n@@ -362,12 +388,22 @@ static inline char *TF_TString_Resize(TF_TString *str, size_t new_size,\n   return cstr;\n }\n \n-static inline void TF_TString_AssignView(TF_TString *dst, const char *src,\n-                                         size_t size) {\n+static inline void TF_TString_AssignViewWithOwner(TF_TString *dst,\n+                                                  const char *src, size_t size,\n+                                                  TStringOwnerCApi *owner_ref) {\n+  if (owner_ref != NULL) {  // NOLINT\n+    owner_ref->ref(owner_ref);\n+  }\n   TF_TString_Dealloc(dst);\n \n   dst->u.view.size = TF_TString_ToInternalSizeT(size, TF_TSTR_VIEW);\n   dst->u.view.ptr = src;\n+  dst->u.view.owner_ref = owner_ref;\n+}\n+\n+static inline void TF_TString_AssignView(TF_TString *dst, const char *src,\n+                                         size_t size) {\n+  TF_TString_AssignViewWithOwner(dst, src, size, NULL);  // NOLINT\n }\n \n static inline void TF_TString_AppendN(TF_TString *dst, const char *src,\n@@ -400,14 +436,21 @@ static inline void TF_TString_Copy(TF_TString *dst, const char *src,\n static inline void TF_TString_Assign(TF_TString *dst, const TF_TString *src) {\n   if (dst == src) return;\n \n-  TF_TString_Dealloc(dst);\n-\n   switch (TF_TString_GetType(src)) {\n     case TF_TSTR_SMALL:\n-    case TF_TSTR_VIEW:\n+      TF_TString_Dealloc(dst);\n       *dst = *src;\n       return;\n+    case TF_TSTR_VIEW: {\n+      TF_TString_Dealloc(dst);\n+      *dst = *src;\n+      if (dst->u.view.owner_ref != NULL) {  // NOLINT\n+        dst->u.view.owner_ref->ref(dst->u.view.owner_ref);\n+      }\n+      return;\n+    }\n     case TF_TSTR_LARGE: {\n+      TF_TString_Dealloc(dst);\n       const char *src_c = TF_TString_GetDataPointer(src);\n       size_t size = TF_TString_GetSize(src);\n \n@@ -433,9 +476,9 @@ static inline void TF_TString_Move(TF_TString *dst, TF_TString *src) {\n \n   switch (TF_TString_GetType(src)) {\n     case TF_TSTR_SMALL:\n-    case TF_TSTR_VIEW:\n       *dst = *src;\n       return;\n+    case TF_TSTR_VIEW:\n     case TF_TSTR_LARGE:\n       *dst = *src;\n       TF_TString_Init(src);"
        },
        {
            "sha": "4d6c8a571ef96ddd451db63ad24f740e6c09d929",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/tstring.h",
            "status": "modified",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Ftstring.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Ftstring.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Ftstring.h?ref=d717dd7dc0f5ed23a101a478650871f51461e492",
            "patch": "@@ -18,12 +18,15 @@ limitations under the License.\n \n #include <assert.h>\n \n+#include <cstddef>\n #include <ostream>\n #include <string>\n+#include <utility>\n \n #include \"tsl/platform/cord.h\"\n #include \"tsl/platform/ctstring.h\"\n #include \"tsl/platform/platform.h\"\n+#include \"tsl/platform/refcount.h\"\n #include \"tsl/platform/stringpiece.h\"\n \n namespace tsl {\n@@ -92,6 +95,45 @@ class tstring {\n     view& operator=(const view&) = delete;\n   };\n \n+  // `tstring::owner` manages reference-counted shared ownership of a `tstring`\n+  // buffer via an owned object of type `T`. `owner<T>` is useful for cases\n+  // where an existing object already manages a buffer, and we want to transfer\n+  // ownership of that object to a `tstring` via reference counting.\n+  //\n+  // Ownership of `v` is taken via `std::move`, and `value_` is destroyed via\n+  // its destructor when `owner`'s reference count drops to zero. `T` must be\n+  // move-constructible.\n+  template <typename T>\n+  class owner : public tsl::core::RefCounted {\n+   public:\n+    // Constructs an owner by moving `v` into `value_`.\n+    explicit owner(T v) : value_(std::move(v)) {\n+      capi_.ref = &RefImpl;\n+      capi_.unref = &UnrefImpl;\n+      capi_.obj = this;  // Store this to facilitate safe capi_ ref/unref calls.\n+    }\n+\n+    // Accessors for the underlying object.\n+    T& value() { return value_; }\n+    const T& value() const { return value_; }\n+\n+   protected:\n+    ~owner() override = default;\n+\n+   private:\n+    friend class tstring;\n+\n+    static void RefImpl(TStringOwnerCApi* self) {\n+      static_cast<owner*>(self->obj)->Ref();\n+    }\n+    static bool UnrefImpl(TStringOwnerCApi* self) {\n+      return static_cast<owner*>(self->obj)->Unref();\n+    }\n+\n+    TStringOwnerCApi capi_;\n+    T value_;\n+  };\n+\n   typedef const char* const_iterator;\n \n   // Ctor\n@@ -189,6 +231,23 @@ class tstring {\n   tstring& assign_as_view(const char* str, size_t len);\n   tstring& assign_as_view(const char* str);\n \n+  // Assigns `str` as a shared view, where the lifetime of the buffer `str`\n+  // points to is managed by `owner` via reference counting. This is in\n+  // contrast to `assign_as_view`, which creates an unowned view.\n+  //\n+  // This function increments the reference count of `owner`. The caller should\n+  // typically call `owner->Unref()` after this to donate their reference to the\n+  // tstring(s), ensuring `owner` is deleted only when all tstrings referencing\n+  // it are destroyed.\n+  //\n+  // The buffer pointed to by `str` is guaranteed to remain valid as long as\n+  // this tstring (or any copies of it) exists. If `owner` is null, this\n+  // method behaves like `assign_as_view`.\n+  template <typename T>\n+  tstring& assign_as_shared_view(absl::string_view str, owner<T>* owner);\n+  template <typename T>\n+  tstring& assign_as_shared_view(const char* str, size_t len, owner<T>* owner);\n+\n   // Modifiers\n   // NOTE: Invalid input will result in undefined behavior.\n   tstring& append(const tstring& str);\n@@ -486,6 +545,22 @@ inline tstring& tstring::assign_as_view(const char* str) {\n   return *this;\n }\n \n+template <typename T>\n+inline tstring& tstring::assign_as_shared_view(const absl::string_view str,\n+                                        tstring::owner<T>* owner) {\n+  TF_TString_AssignViewWithOwner(&tstr_, str.data(), str.size(),\n+                                 owner ? &owner->capi_ : nullptr);\n+  return *this;\n+}\n+\n+template <typename T>\n+inline tstring& tstring::assign_as_shared_view(const char* str, size_t len,\n+                                        tstring::owner<T>* owner) {\n+  TF_TString_AssignViewWithOwner(&tstr_, str, len,\n+                                 owner ? &owner->capi_ : nullptr);\n+  return *this;\n+}\n+\n // Modifiers\n \n inline tstring& tstring::append(const tstring& str) {"
        },
        {
            "sha": "2b31cf418404d2a7296aa21426d9526906d4458a",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/tstring_test.cc",
            "status": "modified",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Ftstring_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d717dd7dc0f5ed23a101a478650871f51461e492/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Ftstring_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Ftstring_test.cc?ref=d717dd7dc0f5ed23a101a478650871f51461e492",
            "patch": "@@ -407,3 +407,66 @@ TEST(TF_TStringTest, Friends) {\n \n   EXPECT_EQ(std::string(\"\\0a\\0\", 3), ss.str());\n }\n+\n+struct DeletionMarker {\n+  bool* deleted = nullptr;\n+  DeletionMarker() = default;\n+  explicit DeletionMarker(bool* d) : deleted(d) {\n+    if (deleted) *deleted = false;\n+  }\n+  DeletionMarker(DeletionMarker&& other) : deleted(other.deleted) {\n+    other.deleted = nullptr;\n+  }\n+  DeletionMarker& operator=(DeletionMarker&& other) {\n+    deleted = other.deleted;\n+    other.deleted = nullptr;\n+    return *this;\n+  }\n+  ~DeletionMarker() {\n+    if (deleted) *deleted = true;\n+  }\n+};\n+\n+TEST(OwnerTest, RefUnref) {\n+  bool deleted = false;\n+  auto* owner =\n+      new tsl::tstring::owner<DeletionMarker>(DeletionMarker(&deleted));\n+  EXPECT_FALSE(deleted);\n+\n+  tsl::tstring s1;\n+  s1.assign_as_shared_view(\"hello\", owner);\n+  owner->Unref();\n+  EXPECT_FALSE(deleted);\n+\n+  tsl::tstring s2 = s1;\n+  EXPECT_FALSE(deleted);\n+\n+  s1.clear();\n+  EXPECT_FALSE(deleted);\n+\n+  s2.clear();\n+  EXPECT_TRUE(deleted);\n+}\n+\n+TEST(OwnerTest, Assign) {\n+  bool deleted = false;\n+  auto* owner =\n+      new tsl::tstring::owner<DeletionMarker>(DeletionMarker(&deleted));\n+  EXPECT_FALSE(deleted);\n+\n+  tsl::tstring s1;\n+  s1.assign_as_shared_view(\"hello\", owner);\n+  owner->Unref();\n+\n+  tsl::tstring s2;\n+  s2 = s1;\n+\n+  tsl::tstring s3;\n+  s3 = std::move(s1);\n+\n+  s2.clear();\n+  EXPECT_FALSE(deleted);\n+\n+  s3.clear();\n+  EXPECT_TRUE(deleted);\n+}"
        }
    ],
    "stats": {
        "total": 205,
        "additions": 197,
        "deletions": 8
    }
}