{
    "author": "jcai19",
    "message": "[XLA][Numerics][HLO Value Tracking] Handle original values in while loop fusible sinking pass\n\nThis reconstructs the original value for while loops with a rewritten input/output shape during the pass.\n\nPiperOrigin-RevId: 822465131",
    "sha": "95d3b6fe36429a116ecc287e8ed513c1037f2a1b",
    "files": [
        {
            "sha": "852258d294497fc762840fab3f7817ca73a6b804",
            "filename": "third_party/xla/xla/service/while_loop_fusible_sinking.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/95d3b6fe36429a116ecc287e8ed513c1037f2a1b/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/95d3b6fe36429a116ecc287e8ed513c1037f2a1b/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking.cc?ref=95d3b6fe36429a116ecc287e8ed513c1037f2a1b",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n \n #include <cstdint>\n #include <iterator>\n+#include <memory>\n #include <optional>\n #include <vector>\n \n@@ -34,6 +35,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/ir/hlo_original_value.h\"\n #include \"xla/hlo/utils/hlo_query.h\"\n #include \"xla/service/pattern_matcher.h\"\n #include \"xla/service/while_util.h\"\n@@ -95,6 +97,29 @@ absl::Status UpdateWhileUsesWithTuple(HloInstruction* while_instr,\n   return absl::OkStatus();\n }\n \n+void AppendOriginalValues(HloInstruction* instr,\n+                          const HloInstruction::InstructionVector& new_operands,\n+                          int64_t next_index) {\n+  if (instr->original_value() != nullptr && !new_operands.empty()) {\n+    std::shared_ptr<OriginalValue> old_original_value = instr->original_value(),\n+                                   new_original_value =\n+                                       std::make_shared<OriginalValue>(\n+                                           instr->shape());\n+    for (auto& [shape_index, original_array] : old_original_value->tree()) {\n+      *new_original_value->mutable_tree()->mutable_element(shape_index) =\n+          original_array;\n+    }\n+\n+    for (int64_t i = 0; i < new_operands.size(); ++i) {\n+      if (new_operands[i]->original_value() != nullptr) {\n+        new_original_value->mutable_tree()->CopySubtreeFrom(\n+            new_operands[i]->original_value()->tree(), {}, {next_index + i});\n+      }\n+    }\n+    return instr->set_original_value(new_original_value);\n+  }\n+}\n+\n // Appends the given new operand to while input and update loops computations\n // and shape accordingly and returns the gte instruction within the body that\n // represents the new operand.\n@@ -105,6 +130,8 @@ absl::StatusOr<HloInstruction*> AppendToWhileState(\n   ShapeUtil::AppendShapeToTuple(new_operand->shape(),\n                                 while_input->mutable_shape());\n   while_input->AppendOperand(new_operand);\n+  AppendOriginalValues(while_input, {new_operand},\n+                       while_input->operand_count() - 1);\n   // Update the body computation.\n   HloComputation* body = while_instr->while_body();\n   *body->parameter_instruction(0)->mutable_shape() = while_input->shape();\n@@ -122,6 +149,9 @@ absl::StatusOr<HloInstruction*> AppendToWhileState(\n   TF_RETURN_IF_ERROR(\n       UpdateWhileUsesWithTuple(while_instr, while_input->operand_count() - 1));\n   *while_instr->mutable_shape() = while_input->shape();\n+  AppendOriginalValues(while_instr, {new_operand},\n+                       while_input->operand_count() - 1);\n+\n   return new_gte;\n }\n \n@@ -459,6 +489,7 @@ absl::StatusOr<bool> WhileLoopFusibleSinking::TrySinkingFusiblesIntoWhileLoop(\n     HloInstruction* parameter = while_body->parameter_instruction(0);\n     int64_t next_index = init_value->operand_count();\n     new_operands.resize(fusion->operand_count());\n+\n     for (int64_t i = 0; i < fusion->operand_count(); ++i) {\n       init_value->AppendOperand(fusion->mutable_operand(i));\n       parameter->mutable_shape()->mutable_tuple_shapes()->push_back(\n@@ -468,10 +499,15 @@ absl::StatusOr<bool> WhileLoopFusibleSinking::TrySinkingFusiblesIntoWhileLoop(\n       root->AppendOperand(new_operands[i]);\n     }\n     *(init_value->mutable_shape()) = parameter->shape();\n+    AppendOriginalValues(init_value, fusion->operands(),\n+                         next_index - fusion->operand_count());\n     *(while_instr->mutable_shape()) = parameter->shape();\n+    AppendOriginalValues(while_instr, fusion->operands(),\n+                         next_index - fusion->operand_count());\n     *(while_cond->parameter_instruction(0)->mutable_shape()) =\n         parameter->shape();\n     *(root->mutable_shape()) = parameter->shape();\n+\n     auto cloned_fusion = while_body->AddInstruction(\n         fusion->CloneWithNewOperands(fusion->shape(), new_operands));\n     TF_RETURN_IF_ERROR(fusion->parent()->RemoveInstruction(fusion));\n@@ -539,6 +575,7 @@ absl::StatusOr<bool> WhileLoopFusibleSinking::Run(\n       }\n     }\n   }\n+\n   return changed;\n }\n }  // namespace xla"
        },
        {
            "sha": "b5637f997e732254bc831fee6e893896816e6159",
            "filename": "third_party/xla/xla/service/while_loop_fusible_sinking_test.cc",
            "status": "modified",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/95d3b6fe36429a116ecc287e8ed513c1037f2a1b/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/95d3b6fe36429a116ecc287e8ed513c1037f2a1b/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_fusible_sinking_test.cc?ref=95d3b6fe36429a116ecc287e8ed513c1037f2a1b",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/log/check.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/transforms/simplifiers/flatten_call_graph.h\"\n@@ -429,5 +430,100 @@ TEST_F(WhileLoopFusibleSinkingTest, TestNoPlumbWithUnknonwnTripCount) {\n   EXPECT_FALSE(changed);\n }\n \n+TEST_F(WhileLoopFusibleSinkingTest, SinkMaskWithOriginalValue) {\n+  const char* const hlo_string = R\"(\n+HloModule ModuleWithWhile\n+\n+body {\n+  p_body = (f32[5,7],f32[5,7]) parameter(0)\n+  p_body.0 = get-tuple-element(p_body), index=0\n+  p_body.1 = get-tuple-element(p_body), index=1\n+\n+  add.0 = add(p_body.0, p_body.1)\n+  ROOT root = tuple(add.0, p_body.1)\n+}\n+\n+condition {\n+  p_cond = (f32[5,7],f32[5,7]) parameter(0)\n+  ROOT result = pred[] constant(true)\n+}\n+\n+ENTRY entry {\n+  const_0 = f32[5,7] parameter(0), origin={{\"constant\"}}\n+  p = f32[5] parameter(1), origin={{\"parameter\"}}\n+  a = f32[5,7] iota(), iota_dimension=0\n+  b = f32[5,7] iota(), iota_dimension=1\n+  c = add(a, b)\n+  d = f32[5,7] broadcast(p), dimensions={0}\n+  mask = multiply(c,d), origin={{\"mask\"}}\n+  while_init = tuple(const_0, mask), origin={({\"constant\"}, {\"mask\"})}\n+  ROOT while = while(while_init), condition=condition, body=body, origin={({\"while\" {0}}, {\"while\" {1}})}\n+}\n+)\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          WhileLoopFusibleSinking{}.Run(module.get()));\n+  ASSERT_TRUE(changed);\n+\n+  HloInstruction* while_instr = FindInstruction(module.get(), \"while\");\n+  ASSERT_NE(while_instr->original_value(), nullptr);\n+  EXPECT_EQ(while_instr->original_value()->ToString(),\n+            \"({\\\"while\\\" {0}}, {\\\"while\\\" {1}}, {\\\"parameter\\\"})\");\n+  HloInstruction* while_init = while_instr->while_init();\n+  ASSERT_NE(while_init->original_value(), nullptr);\n+  EXPECT_EQ(while_init->original_value()->ToString(),\n+            \"({\\\"constant\\\"}, {\\\"mask\\\"}, {\\\"parameter\\\"})\");\n+}\n+\n+TEST_F(WhileLoopFusibleSinkingTest, PlumbSingleBroadcastWithOriginalValue) {\n+  const std::string hlo_string_before = R\"(\n+  HloModule test\n+\n+  loop.body {\n+    loop_var.1 = (s32[]{:T(128)}, s32[1,1,1,4,3,5]{5,4,3,2,1,0}, s32[4,3,5]{2,1,0}) parameter(0)\n+    get-tuple-element.1 = s32[]{:T(128)} get-tuple-element(loop_var.1), index=0\n+    get-tuple-element.2 = s32[1,1,1,4,3,5]{5,4,3,2,1,0} get-tuple-element(loop_var.1), index=1\n+    get-tuple-element.3 = s32[4,3,5]{2,1,0} get-tuple-element(loop_var.1), index=2\n+    bitcast.12855 = s32[1,1,1,4,3,5]{5,4,3,2,1,0} bitcast(get-tuple-element.3)\n+    add.40974 = s32[1,1,1,4,3,5]{5,4,3,2,1,0} add(get-tuple-element.2, bitcast.12855)\n+    constant.1 = s32[]{:T(128)} constant(1)\n+    idx = s32[]{:T(128)} add(get-tuple-element.1, constant.1)\n+    ROOT tuple = (s32[]{:T(128)}, s32[1,1,1,4,3,5]{5,4,3,2,1,0}, s32[4,3,5]{2,1,0}) tuple(idx, add.40974, get-tuple-element.3)\n+  }\n+\n+  loop.condition {\n+    loop_var.2 = (s32[]{:T(128)}, s32[1,1,1,4,3,5]{5,4,3,2,1,0}, s32[4,3,5]{2,1,0}) parameter(0)\n+    get-tuple-element.3 = s32[]{:T(128)} get-tuple-element(loop_var.2), index=0\n+    constant.2 = s32[]{:T(128)} constant(4)\n+    ROOT less-than = pred[] compare(get-tuple-element.3, constant.2), direction=LT\n+  }\n+\n+  ENTRY %main {\n+    param.1 = s32[4,3,5]{2,1,0} iota(), iota_dimension=0\n+    zero = s32[]{:T(128)} constant(0), origin={{\"zero\"}}\n+    zeros32 = s32[]{:T(128)} constant(0), origin={{\"zeros32\"}}\n+    broadcast = s32[1,1,1,4,3,5]{5,4,3,2,1,0} broadcast(zeros32), origin={{\"broadcast\"}}\n+    input = (s32[]{:T(128)}, s32[1,1,1,4,3,5]{5,4,3,2,1,0}, s32[4,3,5]{2,1,0}) tuple(zero, broadcast, param.1), origin={({\"zero\"}, {\"zeros32\"}, {\"broadcast\"})}\n+    ROOT while = (s32[]{:T(128)}, s32[1,1,1,4,3,5]{5,4,3,2,1,0}, s32[4,3,5]{2,1,0}) while(input), condition=loop.condition, body=loop.body, origin={({\"while\" {0}}, {\"while\" {1}}, {\"while\" {2}})}\n+  }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(hlo_string_before));\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n+                          WhileLoopFusibleSinking{}.Run(module.get()));\n+  EXPECT_TRUE(changed);\n+  HloInstruction* while_instr = FindInstruction(module.get(), \"while\");\n+  ASSERT_NE(while_instr->original_value(), nullptr);\n+  EXPECT_EQ(while_instr->original_value()->ToString(),\n+            \"({\\\"while\\\" {0}}, {\\\"while\\\" {1}}, {\\\"while\\\" {2}}, {\\\"zero\\\"})\");\n+  HloInstruction* while_init = while_instr->while_init();\n+  ASSERT_NE(while_init->original_value(), nullptr);\n+  EXPECT_EQ(while_init->original_value()->ToString(),\n+            \"({\\\"zero\\\"}, {\\\"zeros32\\\"}, {\\\"broadcast\\\"}, {\\\"zero\\\"})\");\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 133,
        "additions": 133,
        "deletions": 0
    }
}