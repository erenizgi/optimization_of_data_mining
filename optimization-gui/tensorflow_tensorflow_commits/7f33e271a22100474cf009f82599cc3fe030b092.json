{
    "author": "pschuh",
    "message": "Add support for buffer slicing to CommonPjRtRawBuffer.\nThis should allow arena allocation and transfer.\n\nPiperOrigin-RevId: 806484065",
    "sha": "7f33e271a22100474cf009f82599cc3fe030b092",
    "files": [
        {
            "sha": "0d4fb3fa998689e6b43987785b0225a98c7508fe",
            "filename": "third_party/xla/xla/pjrt/raw_buffer.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f33e271a22100474cf009f82599cc3fe030b092/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f33e271a22100474cf009f82599cc3fe030b092/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.cc?ref=7f33e271a22100474cf009f82599cc3fe030b092",
            "patch": "@@ -57,6 +57,18 @@ CommonPjRtRawBuffer::RemoveDynamicShapeMetadataIfPresent(\n       \"Dynamic shapes are not supported for \", memory_space()->DebugString()));\n }\n \n+absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n+CommonPjRtRawBuffer::Slice(int64_t offset, int64_t size) {\n+  TF_ASSIGN_OR_RETURN(auto results, MultiSlice({{offset, size}}));\n+  return results[0];\n+}\n+\n+absl::StatusOr<std::vector<tsl::RCReference<CommonPjRtRawBuffer>>>\n+CommonPjRtRawBuffer::MultiSlice(absl::Span<const SliceInfo> slices) {\n+  return absl::UnimplementedError(absl::StrCat(\"Slicing is not supported for \",\n+                                               memory_space()->DebugString()));\n+}\n+\n PjRtFuture<> CommonPjRtRawBuffer::CopyRawDeviceToHost(void* dst, int64_t offset,\n                                                       int64_t transfer_size) {\n   auto event = CopyRawDeviceToHostAndReturnEvent(dst, offset, transfer_size);"
        },
        {
            "sha": "f6bd7e66822b16a262ca5a056c74a04fbf3313f4",
            "filename": "third_party/xla/xla/pjrt/raw_buffer.h",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7f33e271a22100474cf009f82599cc3fe030b092/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7f33e271a22100474cf009f82599cc3fe030b092/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fraw_buffer.h?ref=7f33e271a22100474cf009f82599cc3fe030b092",
            "patch": "@@ -110,6 +110,23 @@ class CommonPjRtRawBuffer : public PjRtRawBuffer {\n   PjRtFuture<> CopyRawDeviceToHost(void* dst, int64_t offset,\n                                    int64_t transfer_size) override;\n \n+  // A sliced buffer is a view into the offset and range of this buffer.\n+  //\n+  // Note that the underlying driver may have requirements\n+  // on the alignment of `offset`. Look at implementations of\n+  // this method for specific alignment requirements.\n+  absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>> Slice(int64_t offset,\n+                                                              int64_t size);\n+\n+  struct SliceInfo {\n+    int64_t offset;\n+    int64_t size;\n+  };\n+\n+  // Batched version of Slice(). May be faster on some implementations.\n+  virtual absl::StatusOr<std::vector<tsl::RCReference<CommonPjRtRawBuffer>>>\n+  MultiSlice(absl::Span<const SliceInfo> slices);\n+\n   // Creates an event which signals when the allocation is complete.\n   virtual absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>\n   MakeAllocationReadyEvent() = 0;"
        }
    ],
    "stats": {
        "total": 29,
        "additions": 29,
        "deletions": 0
    }
}