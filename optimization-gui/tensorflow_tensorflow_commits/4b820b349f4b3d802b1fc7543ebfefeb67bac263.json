{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 846524556",
    "sha": "4b820b349f4b3d802b1fc7543ebfefeb67bac263",
    "files": [
        {
            "sha": "9956e74011d7edd2aa9730a35b9b173a1264eeb1",
            "filename": "tensorflow/core/tfrt/tfrt_session/tfrt_session.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4b820b349f4b3d802b1fc7543ebfefeb67bac263/tensorflow%2Fcore%2Ftfrt%2Ftfrt_session%2Ftfrt_session.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4b820b349f4b3d802b1fc7543ebfefeb67bac263/tensorflow%2Fcore%2Ftfrt%2Ftfrt_session%2Ftfrt_session.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Ftfrt_session%2Ftfrt_session.cc?ref=4b820b349f4b3d802b1fc7543ebfefeb67bac263",
            "patch": "@@ -173,7 +173,7 @@ class TfrtSession : public tensorflow::Session {\n   }\n \n   absl::Status Create(GraphDef&& graph) override {\n-    absl::MutexLock lock(&session_state_lock_);\n+    absl::MutexLock lock(session_state_lock_);\n     return CreateLocked(std::move(graph));\n   }\n \n@@ -279,7 +279,7 @@ class TfrtSession : public tensorflow::Session {\n   }\n \n   absl::Status Extend(GraphDef&& graph) override {\n-    absl::MutexLock lock(&session_state_lock_);\n+    absl::MutexLock lock(session_state_lock_);\n     return ExtendLocked(std::move(graph));\n   }\n \n@@ -299,7 +299,7 @@ class TfrtSession : public tensorflow::Session {\n       std::vector<Tensor>* outputs,\n       const thread::ThreadPoolOptions& thread_pool_options) {\n     {\n-      absl::MutexLock lock(&session_state_lock_);\n+      absl::MutexLock lock(session_state_lock_);\n       if (session_state_ == SessionState::kInitialized) {\n         return errors::Unavailable(\"Session not created yet.\");\n       }\n@@ -401,7 +401,7 @@ class TfrtSession : public tensorflow::Session {\n   // NOTE: This API is still experimental and may change.\n   absl::Status MakeCallable(const CallableOptions& callable_options,\n                             CallableHandle* out_handle) override {\n-    absl::MutexLock lock(&callables_lock_);\n+    absl::MutexLock lock(callables_lock_);\n     *out_handle = next_callable_handle_++;\n     assert(callables_.find(*out_handle) == callables_.end());\n     callables_[*out_handle] = {callable_options};\n@@ -436,7 +436,7 @@ class TfrtSession : public tensorflow::Session {\n       const thread::ThreadPoolOptions& thread_pool_options) override {\n     Callable callable;\n     {\n-      absl::MutexLock lock(&callables_lock_);\n+      absl::MutexLock lock(callables_lock_);\n       auto it = callables_.find(handle);\n       if (it == callables_.end())\n         return errors::InvalidArgument(\"No such callable handle: \", handle);\n@@ -466,7 +466,7 @@ class TfrtSession : public tensorflow::Session {\n   /// session.\n   /// NOTE: This API is still experimental and may change.\n   absl::Status ReleaseCallable(CallableHandle handle) override {\n-    absl::MutexLock lock(&callables_lock_);\n+    absl::MutexLock lock(callables_lock_);\n     auto it = callables_.find(handle);\n     if (it == callables_.end())\n       return errors::InvalidArgument(\"No such callable handle: \", handle);\n@@ -475,7 +475,7 @@ class TfrtSession : public tensorflow::Session {\n   }\n \n   absl::Status Close() override {\n-    absl::MutexLock lock(&session_state_lock_);\n+    absl::MutexLock lock(session_state_lock_);\n     session_state_ = SessionState::kClosed;\n     return absl::OkStatus();\n   }\n@@ -721,7 +721,7 @@ class TfrtSessionFactory::ThreadPoolManager {\n           \"TFRT session does not yet support session local thread pool\");\n     }\n \n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n \n     auto it = named_thread_pools_.find(name);\n     // The thread pool with the given name already exists.\n@@ -842,7 +842,7 @@ absl::Status TfrtSessionFactory::NewSession(const SessionOptions& options,\n \n   *out_session = nullptr;\n \n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   std::vector<std::unique_ptr<Device>> devices;\n   TF_RETURN_IF_ERROR(DeviceFactory::AddDevices(\n       options, \"/job:localhost/replica:0/task:0\", &devices));\n@@ -873,13 +873,13 @@ static TfrtSessionFactory* session_factory = nullptr;\n \n tfrt_stub::Runtime* TfrtSessionFactory::GetRuntime() {\n   DCHECK(session_factory != nullptr);\n-  absl::MutexLock lock(&session_factory->mutex_);\n+  absl::MutexLock lock(session_factory->mutex_);\n   return session_factory->runtime_;\n }\n \n absl::Status InitializeTfrtSession(const TfrtSessionOptions& options) {\n   DCHECK(session_factory != nullptr);\n-  absl::MutexLock lock(&session_factory->mutex_);\n+  absl::MutexLock lock(session_factory->mutex_);\n   DCHECK(!session_factory->IsInitialized());\n   return UpdateTfrtSessionOptionsLocked(options);\n }"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 11,
        "deletions": 11
    }
}