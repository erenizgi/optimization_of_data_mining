{
    "author": "unknown",
    "message": "[XLA:GPU] ThunkBufferDebugPass: implement thunk filtering\n\nInterpret the values passed via command line flags:\n\n- `--xla_gpu_experimental_thunk_buffer_debug_filter_by_thunk_id_ranges`\n- `--xla_gpu_experimental_thunk_buffer_debug_filter_by_profile_annotation_re`\n\nAnd only instrument thunks that pass all the configured filters.\n\nPiperOrigin-RevId: 827881515",
    "sha": "d49810883a367f61a55133d135c1f051cc43f59a",
    "files": [
        {
            "sha": "845388c40af4719a9529d8f61dc9d2846d91bdbb",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d49810883a367f61a55133d135c1f051cc43f59a/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d49810883a367f61a55133d135c1f051cc43f59a/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=d49810883a367f61a55133d135c1f051cc43f59a",
            "patch": "@@ -2904,6 +2904,7 @@ cc_library(\n         \":custom_call_thunk\",\n         \":sequential_thunk\",\n         \":thunk\",\n+        \":thunk_id\",\n         \":thunk_pass_pipeline\",\n         \"//xla:shape_util\",\n         \"//xla:xla_data_proto_cc\",\n@@ -2918,14 +2919,17 @@ cc_library(\n         \"//xla/stream_executor:stream\",\n         \"//xla/stream_executor/gpu:buffer_debug_log\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:nullability\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n         \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_googlesource_code_re2//:re2\",\n     ],\n )\n "
        },
        {
            "sha": "975708accc51996941a7d0b49cfb07394f671a58",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass.cc",
            "status": "modified",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d49810883a367f61a55133d135c1f051cc43f59a/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d49810883a367f61a55133d135c1f051cc43f59a/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc?ref=d49810883a367f61a55133d135c1f051cc43f59a",
            "patch": "@@ -16,25 +16,31 @@ limitations under the License.\n #include \"xla/backends/gpu/runtime/thunk_buffer_debug_pass.h\"\n \n #include <cstddef>\n+#include <cstdint>\n #include <cstring>\n #include <memory>\n+#include <string>\n #include <utility>\n #include <vector>\n \n+#include \"absl/algorithm/container.h\"\n #include \"absl/base/nullability.h\"\n #include \"absl/container/flat_hash_map.h\"\n+#include \"absl/functional/any_invocable.h\"\n #include \"absl/functional/bind_front.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"re2/re2.h\"\n #include \"xla/backends/gpu/runtime/buffer_debug_log_entry_metadata_store.h\"\n #include \"xla/backends/gpu/runtime/buffer_debug_log_structs.h\"\n #include \"xla/backends/gpu/runtime/buffers_checksum_thunk.h\"\n #include \"xla/backends/gpu/runtime/buffers_nan_count_thunk.h\"\n #include \"xla/backends/gpu/runtime/custom_call_thunk.h\"\n #include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n #include \"xla/backends/gpu/runtime/thunk.h\"\n+#include \"xla/backends/gpu/runtime/thunk_id.h\"\n #include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n #include \"xla/ffi/api/c_api.h\"\n #include \"xla/ffi/attribute_map.h\"\n@@ -226,6 +232,103 @@ absl::Status DumpBufferDebugLog(\n   return absl::OkStatus();\n }\n \n+// A boolean-like value returned from thunk filters to indicate whether the\n+// thunk should be instrumented or left as is.\n+enum class InstrumentAction : bool {\n+  // Don't instrument the thunk, leave it as is.\n+  kSkip,\n+  // Instrument the thunk.\n+  kInstrument,\n+};\n+\n+// A function that decides whether the thunk should be instrumented\n+// (kInstrument) or not (kSkip).\n+using ThunkFilter = absl::AnyInvocable<InstrumentAction(const Thunk&) const>;\n+\n+// Creates a thunk filter that filters thunks by their IDs, based the allowed\n+// ranges passed in debug options.\n+ThunkFilter CreateThunkIdFilter(const DebugOptions& debug_options) {\n+  std::vector<std::pair<int64_t, int64_t>> thunk_id_ranges;\n+  for (const auto& range :\n+       debug_options.xla_gpu_experimental_thunk_buffer_debug_filter()\n+           .thunk_id_ranges()) {\n+    VLOG(1) << \"Thunk filter: id range [\" << range.first() << \", \"\n+            << range.last() << \"]\";\n+    thunk_id_ranges.emplace_back(range.first(), range.last());\n+  }\n+\n+  return [id_ranges = std::move(thunk_id_ranges)](const Thunk& thunk) {\n+    if (id_ranges.empty()) {\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    const ThunkId thunk_id = thunk.thunk_info().thunk_id;\n+    if (absl::c_any_of(id_ranges, [&](const auto& range) {\n+          VLOG(2) << \"Thunk filter: check ID range: \" << range.first\n+                  << \" <= \" << thunk_id.value() << \" <= \" << range.second;\n+          return range.first <= thunk_id.value() &&\n+                 thunk_id.value() <= range.second;\n+        })) {\n+      VLOG(2) << \"Thunk filter: ID matches\";\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    VLOG(2) << \"Thunk filter: ID does not match\";\n+    return InstrumentAction::kSkip;\n+  };\n+}\n+\n+// Creates a thunk filter that filters thunks by matching their profile\n+// annotations against regexes configured in debug options.\n+ThunkFilter CreateProfileAnnotationRegexFilter(\n+    const DebugOptions& debug_options) {\n+  std::vector<std::unique_ptr<RE2>> profile_annotation_regexes;\n+  for (const auto& regex :\n+       debug_options.xla_gpu_experimental_thunk_buffer_debug_filter()\n+           .profile_annotation_regexes()) {\n+    VLOG(1) << \"Thunk filter: profile annotation regex: \" << regex;\n+    profile_annotation_regexes.push_back(std::make_unique<RE2>(regex));\n+  }\n+  return [regexes = std::move(profile_annotation_regexes)](const Thunk& thunk) {\n+    if (regexes.empty()) {\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    const std::string& profile_annotation =\n+        thunk.thunk_info().profile_annotation;\n+    if (absl::c_any_of(regexes, [&](const auto& regex) {\n+          VLOG(2) << \"Thunk filter: check profile annotation regex: \"\n+                  << regex->pattern();\n+          return RE2::PartialMatch(profile_annotation, *regex);\n+        })) {\n+      VLOG(2) << \"Thunk filter: profile annotation matches\";\n+      return InstrumentAction::kInstrument;\n+    }\n+\n+    VLOG(2) << \"Thunk filter: profile annotation does not match\";\n+    return InstrumentAction::kSkip;\n+  };\n+}\n+\n+// Creates a thunk filter that filters thunks by all the conditions configured\n+// in debug options.\n+ThunkFilter CreateThunkFilter(const DebugOptions& debug_options) {\n+  std::vector<ThunkFilter> filters;\n+  filters.push_back(CreateThunkIdFilter(debug_options));\n+  filters.push_back(CreateProfileAnnotationRegexFilter(debug_options));\n+\n+  return [filters = std::move(filters)](const Thunk& thunk) {\n+    VLOG(2) << \"Thunk filter: check ID \" << thunk.thunk_info().thunk_id\n+            << \", profile annotation \" << thunk.thunk_info().profile_annotation;\n+    if (absl::c_all_of(filters, [&](const auto& filter) {\n+          return filter(thunk) == InstrumentAction::kInstrument;\n+        })) {\n+      return InstrumentAction::kInstrument;\n+    }\n+    return InstrumentAction::kSkip;\n+  };\n+}\n+\n XLA_FFI_DEFINE_HANDLER_SYMBOL(\n     kDebugLogInitHandler,\n     [](se::Stream* absl_nonnull stream, xla::ffi::Buffer<U8> log_buffer) {\n@@ -285,7 +388,11 @@ absl::StatusOr<bool> ThunkBufferDebugPass::Run(\n                                               /*results=*/{}, /*attributes=*/{},\n                                               hlo_module->entry_computation()));\n \n+  ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n   root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n+    if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n+      return thunk;\n+    }\n     switch (mode_) {\n       case Mode::kChecksum:\n         VLOG(1) << \"Wrapping with checksum thunk\";"
        },
        {
            "sha": "8a95b83d8b178ff20cb672d78233d213dd4fc503",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass_test.cc",
            "status": "modified",
            "additions": 221,
            "deletions": 11,
            "changes": 232,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d49810883a367f61a55133d135c1f051cc43f59a/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d49810883a367f61a55133d135c1f051cc43f59a/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc?ref=d49810883a367f61a55133d135c1f051cc43f59a",
            "patch": "@@ -187,14 +187,6 @@ TEST_F(ThunkBufferDebugPassTest, InsertsBuffersDebugChecksumThunks) {\n       true);\n   se::DeviceDescription device_info;\n   FakeThunkPassBufferAllocator allocator;\n-  // The callbacks created by ThunkBufferDebugPass require a HloModule with\n-  // a non-null entry computation.\n-  auto builder = HloComputation::Builder(\"entry\");\n-  HloInstruction* root = builder.AddInstruction(\n-      HloInstruction::CreateConstant(LiteralUtil::CreateR0(1)));\n-  std::unique_ptr<HloComputation> entry_computation = builder.Build(root);\n-  HloModule hlo_module(\"test_module\", HloModuleConfig());\n-  hlo_module.AddEntryComputation(std::move(entry_computation));\n   // Create a fake thunk with a few different buffer uses.\n   BufferAllocation alloc(0, 1024, 0);\n   BufferAllocation::Slice slice_i(&alloc, 0, 1);\n@@ -224,9 +216,9 @@ TEST_F(ThunkBufferDebugPassTest, InsertsBuffersDebugChecksumThunks) {\n       std::make_unique<SequentialThunk>(Thunk::ThunkInfo(), std::move(thunks));\n \n   ThunkBufferDebugPass pass(ThunkBufferDebugPass::Mode::kChecksum);\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n-                          pass.Run(root_thunk.get(), debug_options, &hlo_module,\n-                                   device_info, allocator));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool changed, pass.Run(root_thunk.get(), debug_options,\n+                             fake_hlo_module_.get(), device_info, allocator));\n   EXPECT_TRUE(changed);\n \n   // Expected thunk structure after the pass:\n@@ -527,6 +519,224 @@ TEST_F(ThunkBufferDebugPassTest, InsertsBuffersDebugNanCounterThunks) {\n               UnorderedElementsAre(Pair(1, slice_o), Pair(2, slice_io)));\n }\n \n+TEST_F(ThunkBufferDebugPassTest, FiltersThunksByIdRanges) {\n+  DebugOptions debug_options;\n+  debug_options.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(\n+      true);\n+  IntRangeInclusive* range =\n+      debug_options.mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+          ->add_thunk_id_ranges();\n+  range->set_first(2);\n+  range->set_last(2);\n+  se::DeviceDescription device_info;\n+  FakeThunkPassBufferAllocator allocator;\n+  // Create a fake thunk with a few different buffer uses.\n+  BufferAllocation alloc(0, 1024, 0);\n+  BufferAllocation::Slice slice1_io(&alloc, 0, 1);\n+  BufferAllocation::Slice slice2_io(&alloc, 1, 1);\n+  Thunk::ThunkInfo fake_thunk1_info;\n+  fake_thunk1_info.thunk_id = ThunkId(1);\n+  auto fake_thunk1 = std::make_unique<FakeThunk>(\n+      fake_thunk1_info, Thunk::BufferUses{BufferUse::Read(slice1_io)});\n+  Thunk::ThunkInfo fake_thunk2_info;\n+  fake_thunk2_info.thunk_id = ThunkId(2);\n+  auto fake_thunk2 = std::make_unique<FakeThunk>(\n+      fake_thunk2_info, Thunk::BufferUses{BufferUse::Read(slice2_io)});\n+  Thunk* fake_thunk1_ptr = fake_thunk1.get();\n+  Thunk* fake_thunk2_ptr = fake_thunk2.get();\n+  std::vector<std::unique_ptr<Thunk>> thunks;\n+  thunks.push_back(std::move(fake_thunk1));\n+  thunks.push_back(std::move(fake_thunk2));\n+  auto root_thunk =\n+      std::make_unique<SequentialThunk>(Thunk::ThunkInfo(), std::move(thunks));\n+\n+  ThunkBufferDebugPass pass(ThunkBufferDebugPass::Mode::kChecksum);\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool changed, pass.Run(root_thunk.get(), debug_options,\n+                             fake_hlo_module_.get(), device_info, allocator));\n+  EXPECT_TRUE(changed);\n+\n+  // Expected thunk structure after the pass:\n+  // 1. CustomCallThunk (buffer debug log init)\n+  // 2. FakeThunk1 (not instrumented due to filter)\n+  // 3. SequentialThunk [\n+  //    1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //    2. FakeThunk2\n+  //    3. BuffersDebugChecksumThunk (checksum output buffers)\n+  // 4. CustomCallThunk (buffer debug log dump)\n+  const std::vector<std::unique_ptr<Thunk>>& new_thunks = root_thunk->thunks();\n+  EXPECT_THAT(\n+      new_thunks,\n+      ElementsAre(\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_init\"),\n+          Pointer(fake_thunk1_ptr),\n+          IsSequentialThunkWith(ElementsAre(IsChecksumThunkChecking(SliceList{\n+                                                {0, slice2_io},\n+                                            }),\n+                                            Pointer(fake_thunk2_ptr),\n+                                            IsChecksumThunkChecking(SliceList{\n+                                                {0, slice2_io},\n+                                            }))),\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_dump\")));\n+}\n+\n+TEST_F(ThunkBufferDebugPassTest, FiltersThunksByProfileAnnotationRegexes) {\n+  DebugOptions debug_options;\n+  debug_options.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(\n+      true);\n+  debug_options.mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+      ->add_profile_annotation_regexes(\"thunk1\");\n+  debug_options.mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+      ->add_profile_annotation_regexes(\"^fake.*2$\");\n+  se::DeviceDescription device_info;\n+  FakeThunkPassBufferAllocator allocator;\n+  // Create a fake thunk with a few different buffer uses.\n+  BufferAllocation alloc(0, 1024, 0);\n+  BufferAllocation::Slice slice1_io(&alloc, 0, 1);\n+  BufferAllocation::Slice slice2_io(&alloc, 1, 1);\n+  Thunk::ThunkInfo fake_thunk1_info;\n+  fake_thunk1_info.thunk_id = ThunkId(1);\n+  fake_thunk1_info.profile_annotation = \"fake_thunk1\";\n+  auto fake_thunk1 = std::make_unique<FakeThunk>(\n+      fake_thunk1_info, Thunk::BufferUses{BufferUse::Read(slice1_io)});\n+  Thunk::ThunkInfo fake_thunk2_info;\n+  fake_thunk2_info.profile_annotation = \"fake_thunk2\";\n+  fake_thunk2_info.thunk_id = ThunkId(2);\n+  auto fake_thunk2 = std::make_unique<FakeThunk>(\n+      fake_thunk2_info, Thunk::BufferUses{BufferUse::Read(slice2_io)});\n+  Thunk::ThunkInfo fake_thunk3_info;\n+  fake_thunk3_info.profile_annotation = \"fake_thunk3\";\n+  fake_thunk3_info.thunk_id = ThunkId(3);\n+  auto fake_thunk3 = std::make_unique<FakeThunk>(\n+      fake_thunk3_info, Thunk::BufferUses{BufferUse::Read(slice2_io)});\n+  Thunk* fake_thunk1_ptr = fake_thunk1.get();\n+  Thunk* fake_thunk2_ptr = fake_thunk2.get();\n+  Thunk* fake_thunk3_ptr = fake_thunk3.get();\n+  std::vector<std::unique_ptr<Thunk>> thunks;\n+  thunks.push_back(std::move(fake_thunk1));\n+  thunks.push_back(std::move(fake_thunk2));\n+  thunks.push_back(std::move(fake_thunk3));\n+  auto root_thunk =\n+      std::make_unique<SequentialThunk>(Thunk::ThunkInfo(), std::move(thunks));\n+\n+  ThunkBufferDebugPass pass(ThunkBufferDebugPass::Mode::kChecksum);\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool changed, pass.Run(root_thunk.get(), debug_options,\n+                             fake_hlo_module_.get(), device_info, allocator));\n+  EXPECT_TRUE(changed);\n+\n+  // Expected thunk structure after the pass:\n+  // 1. CustomCallThunk (buffer debug log init)\n+  // 2. SequentialThunk [\n+  //    1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //    2. FakeThunk1 (instrumented due to thunk1)\n+  //    3. BuffersDebugChecksumThunk (checksum output buffers)\n+  // ]\n+  // 3. SequentialThunk [\n+  //    4. BuffersDebugChecksumThunk (checksum input buffers)\n+  //    5. FakeThunk2 (instrumented due to 2$)\n+  //    6. BuffersDebugChecksumThunk (checksum output buffers)\n+  // ]\n+  // 3. FakeThunk3 (not instrumented)\n+  // 4. CustomCallThunk (buffer debug log dump)\n+  const std::vector<std::unique_ptr<Thunk>>& new_thunks = root_thunk->thunks();\n+  EXPECT_THAT(\n+      new_thunks,\n+      ElementsAre(\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_init\"),\n+          IsSequentialThunkWith(ElementsAre(IsChecksumThunkChecking(SliceList{\n+                                                {0, slice1_io},\n+                                            }),\n+                                            Pointer(fake_thunk1_ptr),\n+                                            IsChecksumThunkChecking(SliceList{\n+                                                {0, slice1_io},\n+                                            }))),\n+          IsSequentialThunkWith(ElementsAre(IsChecksumThunkChecking(SliceList{\n+                                                {0, slice2_io},\n+                                            }),\n+                                            Pointer(fake_thunk2_ptr),\n+                                            IsChecksumThunkChecking(SliceList{\n+                                                {0, slice2_io},\n+                                            }))),\n+          Pointer(fake_thunk3_ptr),\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_dump\")));\n+}\n+\n+TEST_F(ThunkBufferDebugPassTest,\n+       FiltersThunksByIdRangesAndProfileAnnotationRegexes) {\n+  DebugOptions debug_options;\n+  debug_options.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(\n+      true);\n+  IntRangeInclusive* range =\n+      debug_options.mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+          ->add_thunk_id_ranges();\n+  range->set_first(2);\n+  range->set_last(3);\n+  debug_options.mutable_xla_gpu_experimental_thunk_buffer_debug_filter()\n+      ->add_profile_annotation_regexes(\"instrument_me\");\n+  se::DeviceDescription device_info;\n+  FakeThunkPassBufferAllocator allocator;\n+  // Create a fake thunk with a few different buffer uses.\n+  BufferAllocation alloc(0, 1024, 0);\n+  BufferAllocation::Slice slice1_io(&alloc, 0, 1);\n+  BufferAllocation::Slice slice2_io(&alloc, 1, 1);\n+  BufferAllocation::Slice slice3_io(&alloc, 2, 1);\n+  Thunk::ThunkInfo fake_thunk1_info;\n+  fake_thunk1_info.thunk_id = ThunkId(1);\n+  fake_thunk1_info.profile_annotation = \"instrument_me\";\n+  auto fake_thunk1 = std::make_unique<FakeThunk>(\n+      fake_thunk1_info, Thunk::BufferUses{BufferUse::Read(slice1_io)});\n+  Thunk::ThunkInfo fake_thunk2_info;\n+  fake_thunk2_info.thunk_id = ThunkId(2);\n+  fake_thunk2_info.profile_annotation = \"ignore_me\";\n+  auto fake_thunk2 = std::make_unique<FakeThunk>(\n+      fake_thunk2_info, Thunk::BufferUses{BufferUse::Read(slice2_io)});\n+  Thunk::ThunkInfo fake_thunk3_info;\n+  fake_thunk3_info.thunk_id = ThunkId(3);\n+  fake_thunk3_info.profile_annotation = \"instrument_me\";\n+  auto fake_thunk3 = std::make_unique<FakeThunk>(\n+      fake_thunk3_info, Thunk::BufferUses{BufferUse::Read(slice3_io)});\n+  Thunk* fake_thunk1_ptr = fake_thunk1.get();\n+  Thunk* fake_thunk2_ptr = fake_thunk2.get();\n+  Thunk* fake_thunk3_ptr = fake_thunk3.get();\n+  std::vector<std::unique_ptr<Thunk>> thunks;\n+  thunks.push_back(std::move(fake_thunk1));\n+  thunks.push_back(std::move(fake_thunk2));\n+  thunks.push_back(std::move(fake_thunk3));\n+  auto root_thunk =\n+      std::make_unique<SequentialThunk>(Thunk::ThunkInfo(), std::move(thunks));\n+\n+  ThunkBufferDebugPass pass(ThunkBufferDebugPass::Mode::kChecksum);\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool changed, pass.Run(root_thunk.get(), debug_options,\n+                             fake_hlo_module_.get(), device_info, allocator));\n+  EXPECT_TRUE(changed);\n+\n+  // Expected thunk structure after the pass:\n+  // 1. CustomCallThunk (buffer debug log init)\n+  // 2. FakeThunk1 (not instrumented due to thunk ID filter)\n+  // 3. FakeThunk2 (not instrumented due to profile annotation regex filter)\n+  // 4. SequentialThunk [\n+  //    1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //    2. FakeThunk3\n+  //    3. BuffersDebugChecksumThunk (checksum output buffers)\n+  // 5. CustomCallThunk (buffer debug log dump)\n+  const std::vector<std::unique_ptr<Thunk>>& new_thunks = root_thunk->thunks();\n+  EXPECT_THAT(\n+      new_thunks,\n+      ElementsAre(\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_init\"),\n+          Pointer(fake_thunk1_ptr), Pointer(fake_thunk2_ptr),\n+          IsSequentialThunkWith(ElementsAre(IsChecksumThunkChecking(SliceList{\n+                                                {0, slice3_io},\n+                                            }),\n+                                            Pointer(fake_thunk3_ptr),\n+                                            IsChecksumThunkChecking(SliceList{\n+                                                {0, slice3_io},\n+                                            }))),\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_dump\")));\n+}\n+\n }  // namespace\n }  // namespace gpu\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 343,
        "additions": 332,
        "deletions": 11
    }
}