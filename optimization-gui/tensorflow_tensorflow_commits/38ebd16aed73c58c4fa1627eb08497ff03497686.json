{
    "author": "tensorflower-gardener",
    "message": "Remove IndexingMap::GetMutableAffineMap()\n\nThis change removes the GetMutableAffineMap() method from xla::IndexingMap. The mutable access to the underlying mlir::AffineMap can't be used because we will use a different internal implementation (SymbolicMap). I also think it's cleaner to not provide this method.\n\nPiperOrigin-RevId: 824536996",
    "sha": "38ebd16aed73c58c4fa1627eb08497ff03497686",
    "files": [
        {
            "sha": "f92d264833885f22840a748062ed2ee911a7124f",
            "filename": "third_party/xla/xla/codegen/emitters/ir/xla_ops.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 7,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/38ebd16aed73c58c4fa1627eb08497ff03497686/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Fir%2Fxla_ops.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/38ebd16aed73c58c4fa1627eb08497ff03497686/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Fir%2Fxla_ops.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Fir%2Fxla_ops.cc?ref=38ebd16aed73c58c4fa1627eb08497ff03497686",
            "patch": "@@ -561,8 +561,8 @@ struct FoldApplyIndexingResults\n       return rewriter.notifyMatchFailure(indexing_op,\n                                          \"Domain of the indexing map is empty\");\n     }\n-    AffineMap* affine_map = &indexing_map.GetMutableAffineMap();\n-    unsigned num_results = affine_map->getNumResults();\n+    AffineMap affine_map = indexing_map.GetAffineMap();\n+    unsigned num_results = affine_map.getNumResults();\n     SmallVector<AffineExpr, 4> new_exprs;\n     new_exprs.reserve(num_results);\n     SmallVector<Value, 4> new_values;\n@@ -574,7 +574,7 @@ struct FoldApplyIndexingResults\n       }\n \n       unsigned id = opresult.getResultNumber();\n-      AffineExpr result_expr = affine_map->getResult(id);\n+      AffineExpr result_expr = affine_map.getResult(id);\n       if (auto const_expr =\n               mlir::dyn_cast<mlir::AffineConstantExpr>(result_expr)) {\n         new_values.push_back(rewriter.create<arith::ConstantIndexOp>(\n@@ -598,11 +598,14 @@ struct FoldApplyIndexingResults\n       return rewriter.notifyMatchFailure(\n           indexing_op, \"No constant or dim/symbol expression found\");\n     }\n-    *affine_map =\n-        AffineMap::get(affine_map->getNumDims(), affine_map->getNumSymbols(),\n-                       new_exprs, affine_map->getContext());\n+    AffineMap new_affine_map =\n+        AffineMap::get(affine_map.getNumDims(), affine_map.getNumSymbols(),\n+                       new_exprs, affine_map.getContext());\n+    IndexingMap new_indexing_map(\n+        new_affine_map, indexing_map.GetDimVars(), indexing_map.GetRangeVars(),\n+        indexing_map.GetRTVars(), indexing_map.GetConstraints());\n     auto new_indexing_op = rewriter.create<ApplyIndexingOp>(\n-        loc, indexing_op.getOperands(), indexing_map);\n+        loc, indexing_op.getOperands(), new_indexing_map);\n     for (int new_result_id = 0, new_indexing_op_result_id = 0;\n          new_result_id < new_values.size(); ++new_result_id) {\n       auto& new_value = new_values[new_result_id];"
        },
        {
            "sha": "58b5f5bbec139d9ab7bd4f384f653e5052fb17b0",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_map.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/38ebd16aed73c58c4fa1627eb08497ff03497686/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/38ebd16aed73c58c4fa1627eb08497ff03497686/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map.h?ref=38ebd16aed73c58c4fa1627eb08497ff03497686",
            "patch": "@@ -164,7 +164,6 @@ class IndexingMap {\n \n   // Returns the affine map.\n   mlir::AffineMap GetAffineMap() const { return affine_map_; }\n-  mlir::AffineMap& GetMutableAffineMap() { return affine_map_; }\n \n   // Returns the number of indexing map results.\n   int64_t GetNumResults() const { return affine_map_.getNumResults(); }"
        }
    ],
    "stats": {
        "total": 18,
        "additions": 10,
        "deletions": 8
    }
}