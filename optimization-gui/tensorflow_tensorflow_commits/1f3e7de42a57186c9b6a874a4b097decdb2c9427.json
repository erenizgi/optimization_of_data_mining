{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add support for Future::Map() with functors returning void\n\nPiperOrigin-RevId: 814637114",
    "sha": "1f3e7de42a57186c9b6a874a4b097decdb2c9427",
    "files": [
        {
            "sha": "110392e53af30442cd4bd7211b6cee9802334101",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f3e7de42a57186c9b6a874a4b097decdb2c9427/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f3e7de42a57186c9b6a874a4b097decdb2c9427/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=1f3e7de42a57186c9b6a874a4b097decdb2c9427",
            "patch": "@@ -391,6 +391,8 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n template <typename R, typename U>\n struct IsMappable : public std::is_constructible<R, U> {};\n template <>\n+struct IsMappable<void, void> : public std::true_type {};\n+template <>\n struct IsMappable<void, absl::Status> : public std::true_type {};\n template <typename R, typename U>\n struct IsMappable<R, absl::StatusOr<U>> : public std::is_constructible<R, U> {};\n@@ -523,6 +525,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   // Supported `R` and `U` type combinations:\n   //\n+  // - `Future<>`  from `(const T&) -> void`\n   // - `Future<>`  from `(const T&) -> absl::Status`\n   // - `Future<R>` from `(const T&) -> absl::StatusOr<U>`\n   // - `Future<R>` from `(const T&) -> U`\n@@ -550,7 +553,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n       }\n \n       // Set the result future available with a result of invoking `f`.\n-      if constexpr (internal::is_status_v<U>) {\n+      if constexpr (std::is_void_v<U>) {\n+        promise.Set((f(*value), absl::OkStatus()));\n+      } else if constexpr (internal::is_status_v<U>) {\n         promise.Set(f(*value));\n       } else if constexpr (internal::is_status_or_v<U>) {\n         absl::StatusOr<typename U::value_type> result = f(*value);\n@@ -583,6 +588,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   // Supported `R` and `U` type combinations: (*)\n   //\n+  // - `Future<>`  from `(T) -> void`\n   // - `Future<>`  from `(T) -> absl::Status`\n   // - `Future<R>` from `(T) -> absl::StatusOr<U>`\n   // - `Future<R>` from `(T) -> U`\n@@ -614,7 +620,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n       }\n \n       // Set the result future available with a result of invoking `f`.\n-      if constexpr (internal::is_status_v<U>) {\n+      if constexpr (std::is_void_v<U>) {\n+        promise.Set((f(std::move(*value)), absl::OkStatus()));\n+      } else if constexpr (internal::is_status_v<U>) {\n         promise.Set(f(std::move(*value)));\n       } else if constexpr (internal::is_status_or_v<U>) {\n         absl::StatusOr<typename U::value_type> result = f(std::move(*value));\n@@ -639,7 +647,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   template <typename F, typename R = std::invoke_result_t<F, const T&>>\n   auto Map(F&& f) const& {\n-    if constexpr (internal::is_status_v<R>) {\n+    if constexpr (std::is_void_v<R>) {\n+      return Map<void>(std::forward<F>(f));\n+    } else if constexpr (internal::is_status_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_or_v<R>) {\n       return Map<typename R::value_type>(std::forward<F>(f));\n@@ -657,7 +667,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   template <typename F, typename R = std::invoke_result_t<\n                             F, std::conditional_t<is_move_only, T, const T&>>>\n   auto Map(F&& f) && {\n-    if constexpr (internal::is_status_v<R>) {\n+    if constexpr (std::is_void_v<R>) {\n+      return std::move(*this).template Map<void>(std::forward<F>(f));\n+    } else if constexpr (internal::is_status_v<R>) {\n       return std::move(*this).template Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_or_v<R>) {\n       return std::move(*this).template Map<typename R::value_type>(\n@@ -787,6 +799,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   //\n   // Supported `R` and `U` type combinations:\n   //\n+  // - `Future<>`  from `() -> void`\n   // - `Future<>`  from `() -> absl::Status`\n   // - `Future<R>` from `() -> absl::StatusOr<U>`\n   // - `Future<R>` from `() -> U`\n@@ -812,7 +825,9 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n       }\n \n       // Set the result future available with a result of invoking `f`.\n-      if constexpr (internal::is_status_v<U>) {\n+      if constexpr (std::is_void_v<U>) {\n+        promise.Set((f(), absl::OkStatus()));\n+      } else if constexpr (internal::is_status_v<U>) {\n         promise.Set(f());\n       } else if constexpr (internal::is_status_or_v<U>) {\n         absl::StatusOr<typename U::value_type> result = f();\n@@ -837,7 +852,9 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   //\n   template <typename F, typename R = std::invoke_result_t<F>>\n   auto Map(F&& f) {\n-    if constexpr (internal::is_status_v<R>) {\n+    if constexpr (std::is_void_v<R>) {\n+      return Map<void>(std::forward<F>(f));\n+    } else if constexpr (internal::is_status_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_or_v<R>) {\n       return Map<typename R::value_type>(std::forward<F>(f));"
        },
        {
            "sha": "5effd58bb4c781eb811ae29bd2e5f50db3cc22a0",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1f3e7de42a57186c9b6a874a4b097decdb2c9427/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1f3e7de42a57186c9b6a874a4b097decdb2c9427/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=1f3e7de42a57186c9b6a874a4b097decdb2c9427",
            "patch": "@@ -464,6 +464,33 @@ TEST(FutureTest, TryMapUnusedResult) {\n   EXPECT_FALSE(called);\n }\n \n+TEST(FutureTest, MapWithVoidFunctor) {\n+  {\n+    auto [promise, future] = Future<>::MakePromise();\n+    promise.Set(absl::OkStatus());\n+\n+    Future<> mapped = future.Map([] {});\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+  }\n+\n+  {\n+    auto [promise, future] = Future<int32_t>::MakePromise();\n+    promise.Set(42);\n+\n+    Future<> mapped = future.Map([](int32_t value) { EXPECT_EQ(value, 42); });\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+  }\n+\n+  {\n+    auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+    promise.Set(std::make_unique<int32_t>(42));\n+\n+    Future<> mapped = std::move(future).Map(\n+        [](std::unique_ptr<int32_t> value) { EXPECT_EQ(*value, 42); });\n+    EXPECT_EQ(mapped.Await(), absl::OkStatus());\n+  }\n+}\n+\n TEST(FutureTest, StatelessError) {\n   auto [promise, future] = Future<>::MakePromise();\n "
        }
    ],
    "stats": {
        "total": 56,
        "additions": 50,
        "deletions": 6
    }
}