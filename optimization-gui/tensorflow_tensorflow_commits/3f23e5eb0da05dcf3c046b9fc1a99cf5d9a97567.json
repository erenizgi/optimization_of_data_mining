{
    "author": "mehrdadkhani",
    "message": "[XLA:TPU] We introduce MutateBackendConfig(). This change allows to apply in-place modifications to the underlying backend config proto in a thread-safe manner.\n\nPiperOrigin-RevId: 822825180",
    "sha": "3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567",
    "files": [
        {
            "sha": "f6c0655314e82e3dc48bfb579a463ed7181f8b00",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567",
            "patch": "@@ -279,9 +279,11 @@ cc_library(\n         \"//xla:util\",\n         \"//xla/tsl/platform:errors\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_protobuf//:protobuf\",\n         \"@local_tsl//tsl/platform:human_readable_json\",\n         \"@local_tsl//tsl/platform:protobuf\",\n     ],"
        },
        {
            "sha": "852f3fe1311caa823af9e0cc26444538f13cdd8e",
            "filename": "third_party/xla/xla/hlo/ir/backend_config.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fbackend_config.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fbackend_config.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fbackend_config.cc?ref=3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"google/protobuf/message.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/util.h\"\n #include \"tsl/platform/human_readable_json.h\""
        },
        {
            "sha": "22847443b1c20bfb79cfea4c33651006cd43a533",
            "filename": "third_party/xla/xla/hlo/ir/backend_config.h",
            "status": "modified",
            "additions": 58,
            "deletions": 1,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fbackend_config.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fbackend_config.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fbackend_config.h?ref=3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567",
            "patch": "@@ -16,18 +16,26 @@ limitations under the License.\n #ifndef XLA_HLO_IR_BACKEND_CONFIG_H_\n #define XLA_HLO_IR_BACKEND_CONFIG_H_\n \n+#include <functional>\n #include <memory>\n #include <string>\n #include <utility>\n \n #include \"absl/base/thread_annotations.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"google/protobuf/message.h\"\n+#include \"tsl/platform/human_readable_json.h\"\n #include \"tsl/platform/protobuf.h\"\n \n namespace xla {\n \n+template <typename T>\n+using EnableIfProto = typename std::enable_if_t<\n+    std::is_base_of<tsl::protobuf::Message, T>::value>;\n+\n // Returns a string representation of a proto in the format used by\n // HloInstruction::raw_backend_config_string.\n //\n@@ -48,7 +56,7 @@ std::unique_ptr<tsl::protobuf::Message> CloneBackendConfigProto(\n // A wrapper around the BackendConfig proto. It can be initialized either with\n // a proto object or a string representing the JSON encoding of a proto. Once\n // the wrapper is initialized (either during construction or via an assignment)\n-// it becomes immutable and any further assignment attempts will fail.\n+// it can only be mutated by calling the ApplyFnOnProto method.\n //\n // When the wrapper is initialized only the provided format is stored. If the\n // other format is requested from the wrapper later, it is lazily computed and\n@@ -92,6 +100,55 @@ class BackendConfigWrapper {\n   }\n   absl::Status GetProto(tsl::protobuf::Message* output_proto) const;\n \n+  // Type trait to check if a type has the mutable_custom_call_metadata method.\n+  template <typename T, typename = void>\n+  struct has_mutable_custom_call_metadata : std::false_type {};\n+\n+  template <typename T>\n+  struct has_mutable_custom_call_metadata<\n+      T,\n+      std::void_t<decltype(std::declval<T>().mutable_custom_call_metadata())>>\n+      : std::true_type {};\n+\n+  // Applies a function `fn` to the underlying proto. The function receives a\n+  // mutable pointer to a proto of type `ConfigProto`.\n+  //\n+  // If there is no proto initialized, will try to initialize from the\n+  // raw_string_. If raw_string_ is also empty, will return an error.\n+  template <typename ConfigProto, EnableIfProto<ConfigProto>* = nullptr>\n+  absl::Status ApplyFnOnProto(\n+      const std::function<absl::Status(ConfigProto*)>& fn) {\n+    absl::WriterMutexLock lock{&mutex_};\n+    if (proto_ == nullptr) {\n+      if (raw_string_.empty()) {\n+        return absl::InvalidArgumentError(\n+            \"Has no proto to apply the modifier function on.\");\n+      }\n+      auto proto = std::make_unique<ConfigProto>();\n+      absl::Status status =\n+          tsl::HumanReadableJsonToProto(raw_string_, proto.get());\n+      if (!status.ok()) {\n+        // If the proto is unparsable, move the raw string to the custom call\n+        // metadata field. This preserves the original string for lowering\n+        // emitters that might depend on it.\n+        if constexpr (has_mutable_custom_call_metadata<ConfigProto>::value) {\n+          auto* custom_call_metadata = proto->mutable_custom_call_metadata();\n+          custom_call_metadata->set_metadata(raw_string_);\n+          VLOG(1) << \"Moving the unparsable backend config \" << raw_string_\n+                  << \" to custom call metadata.\";\n+          raw_string_.clear();\n+        } else {\n+          return status;\n+        }\n+      }\n+      proto_ = std::move(proto);\n+    }\n+    absl::Status status = fn(static_cast<ConfigProto*>(proto_.get()));\n+    // Invalidate string cache, as the proto might have been mutated.\n+    raw_string_.clear();\n+    return status;\n+  }\n+\n   bool empty() const {\n     absl::MutexLock lock{mutex_};\n     return proto_ == nullptr && raw_string_.empty();"
        },
        {
            "sha": "e1e12dbf2af3f38ab2e944864b6436832bad39e0",
            "filename": "third_party/xla/xla/hlo/ir/hlo_instruction.h",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_instruction.h?ref=3f23e5eb0da05dcf3c046b9fc1a99cf5d9a97567",
            "patch": "@@ -2037,6 +2037,16 @@ class alignas(kInstructionTypeMask + 1) HloInstruction {\n     return proto;\n   }\n \n+  // Applies a function `fn` to the underlying backend config proto. The\n+  // function receives a mutable pointer to a proto of type `ConfigProto`.\n+  //\n+  // If the proto is not already parsed, it will return an error.\n+  template <typename ConfigProto, EnableIfProto<ConfigProto>* = nullptr>\n+  absl::Status MutateBackendConfig(\n+      const std::function<absl::Status(ConfigProto*)>& fn) {\n+    return backend_config_.ApplyFnOnProto(fn);\n+  }\n+\n   absl::Status set_backend_config(const tsl::protobuf::Message& proto) {\n     backend_config_ = BackendConfigWrapper(proto);\n     return absl::OkStatus();"
        }
    ],
    "stats": {
        "total": 72,
        "additions": 71,
        "deletions": 1
    }
}