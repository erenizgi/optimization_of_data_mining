{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add [[nodiscard]] to methods that create Futures\n\nPiperOrigin-RevId: 816348116",
    "sha": "28b5e4231efd91537c99012e573580c8c5bea4a4",
    "files": [
        {
            "sha": "a3b783263e451bca4510f5cc964c644240d58b2f",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 14,
            "deletions": 12,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/28b5e4231efd91537c99012e573580c8c5bea4a4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/28b5e4231efd91537c99012e573580c8c5bea4a4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=28b5e4231efd91537c99012e573580c8c5bea4a4",
            "patch": "@@ -466,8 +466,9 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     // create a future is to call `MakePromise`.\n     template <typename U = void,\n               std::enable_if_t<!is_move_only && std::is_void_v<U>>* = nullptr>\n-    Future<T> future(FutureHelpers::OnBlockStart on_block_start = nullptr,\n-                     FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n+    [[nodiscard]] Future<T> future(\n+        FutureHelpers::OnBlockStart on_block_start = nullptr,\n+        FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n       return Future<T>(*this, std::move(on_block_start),\n                        std::move(on_block_end));\n     }\n@@ -496,7 +497,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   template <typename F, typename R = std::invoke_result_t<F>,\n             std::enable_if_t<std::is_constructible_v<absl::StatusOr<T>, R>>* =\n                 nullptr>\n-  static Future<T> MakeOn(Executor& executor, F&& f) {\n+  [[nodiscard]] static Future<T> MakeOn(Executor& executor, F&& f) {\n     auto [promise, future] = MakePromise();\n     executor.Execute(\n         [promise = std::move(promise), f = std::forward<F>(f)]() mutable {\n@@ -534,7 +535,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   template <typename R, typename F,\n             typename U = std::invoke_result_t<F, const T&>,\n             internal::Mappable<R, U>* = nullptr>\n-  Future<R> Map(F&& f) const& {\n+  [[nodiscard]] Future<R> Map(F&& f) const& {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     using Value = const absl::StatusOr<T>&;\n@@ -600,7 +601,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n             typename U = std::invoke_result_t<\n                 F, std::conditional_t<is_move_only, T, const T&>>,\n             internal::Mappable<R, U>* = nullptr>\n-  Future<R> Map(F&& f) && {\n+  [[nodiscard]] Future<R> Map(F&& f) && {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n@@ -646,7 +647,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   // - `R` is any other type      -> Future<R>\n   //\n   template <typename F, typename R = std::invoke_result_t<F, const T&>>\n-  auto Map(F&& f) const& {\n+  [[nodiscard]] auto Map(F&& f) const& {\n     if constexpr (std::is_void_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {\n@@ -666,7 +667,7 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   template <typename F, typename R = std::invoke_result_t<\n                             F, std::conditional_t<is_move_only, T, const T&>>>\n-  auto Map(F&& f) && {\n+  [[nodiscard]] auto Map(F&& f) && {\n     if constexpr (std::is_void_v<R>) {\n       return std::move(*this).template Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {\n@@ -745,8 +746,9 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n     }\n \n     // Returns a future associated with the promise.\n-    Future<> future(FutureHelpers::OnBlockStart on_block_start = nullptr,\n-                    FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n+    [[nodiscard]] Future<> future(\n+        FutureHelpers::OnBlockStart on_block_start = nullptr,\n+        FutureHelpers::OnBlockEnd on_block_end = nullptr) const {\n       return Future<>(*this, std::move(on_block_start),\n                       std::move(on_block_end));\n     }\n@@ -770,7 +772,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // `f` on the given `executor`.\n   template <typename F, typename R = std::invoke_result_t<F>,\n             std::enable_if_t<internal::is_status_v<R>>* = nullptr>\n-  static Future<> MakeOn(Executor& executor, F&& f) {\n+  [[nodiscard]] static Future<> MakeOn(Executor& executor, F&& f) {\n     auto [promise, future] = MakePromise();\n     executor.Execute(\n         [promise = std::move(promise), f = std::forward<F>(f)]() mutable {\n@@ -807,7 +809,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // See `Map` functor type inference defined below for more details.\n   template <typename R, typename F, typename U = std::invoke_result_t<F>,\n             internal::Mappable<R, U>* = nullptr>\n-  Future<R> Map(F&& f) {\n+  [[nodiscard]] Future<R> Map(F&& f) {\n     auto [promise, future] = Future<R>::MakePromise();\n \n     OnReady([promise = std::move(promise),\n@@ -851,7 +853,7 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // - `R` is any other type      -> Future<R>\n   //\n   template <typename F, typename R = std::invoke_result_t<F>>\n-  auto Map(F&& f) {\n+  [[nodiscard]] auto Map(F&& f) {\n     if constexpr (std::is_void_v<R>) {\n       return Map<void>(std::forward<F>(f));\n     } else if constexpr (internal::is_status_v<R>) {"
        },
        {
            "sha": "1e78a9ea863f81edd0e06a6e31ab2f9a806af327",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/28b5e4231efd91537c99012e573580c8c5bea4a4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/28b5e4231efd91537c99012e573580c8c5bea4a4/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=28b5e4231efd91537c99012e573580c8c5bea4a4",
            "patch": "@@ -298,7 +298,9 @@ TEST(FutureTest, MapUnusedResult) {\n   auto [promise, future] = Future<int>::MakePromise();\n \n   bool called = false;\n-  future.Map([&](int) {\n+  // We intentionally drop returned future to test that promise will not\n+  // execute map functor.\n+  (void)future.Map([&](int) {\n     called = true;\n     return 2;\n   });\n@@ -310,7 +312,9 @@ TEST(FutureTest, MapStatusUnusedResult) {\n   auto [promise, future] = Future<>::MakePromise();\n \n   bool called = false;\n-  future.Map([&]() {\n+  // We intentionally drop returned future to test that promise will not\n+  // execute map functor.\n+  (void)future.Map([&]() {\n     called = true;\n     return 2;\n   });\n@@ -456,7 +460,9 @@ TEST(FutureTest, TryMapUnusedResult) {\n   auto [promise, future] = Future<int>::MakePromise();\n \n   bool called = false;\n-  future.Map([&](int) -> absl::StatusOr<int> {\n+  // We intentionally drop returned future to test that promise will not\n+  // execute map functor.\n+  (void)future.Map([&](int) -> absl::StatusOr<int> {\n     called = true;\n     return 2;\n   });"
        }
    ],
    "stats": {
        "total": 38,
        "additions": 23,
        "deletions": 15
    }
}