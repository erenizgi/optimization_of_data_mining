{
    "author": "ezhulenev",
    "message": "[xla:ffi] NFC: Use AttrTag<T> for tagging regular arguments\n\nPiperOrigin-RevId: 825769996",
    "sha": "d4b7f15aee48be460b95c91d90780a38f59291c3",
    "files": [
        {
            "sha": "3c17a8367249466e71096b00078a8b720650fa5a",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 21,
            "deletions": 48,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d4b7f15aee48be460b95c91d90780a38f59291c3/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d4b7f15aee48be460b95c91d90780a38f59291c3/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=d4b7f15aee48be460b95c91d90780a38f59291c3",
            "patch": "@@ -488,6 +488,10 @@ namespace internal {\n // parameter packs. We need this to be able to pattern match FFI handler\n // signature at compile time.\n \n+// A type tag for decoding argument.\n+template <typename T>\n+struct ArgTag {};\n+\n // A type tag for decoding optional argument.\n template <typename T>\n struct OptionalArgTag {};\n@@ -524,23 +528,23 @@ template <typename T>\n struct CtxTag {};\n \n //----------------------------------------------------------------------------//\n-// A template for counting tagged arguments in the Ts pack (i.e. attributes).\n+// A template for counting tagged arguments in the Ts pack.\n //----------------------------------------------------------------------------//\n \n-template <template <typename> class Tag, typename... Ts>\n+template <template <typename> typename Tag, typename... Ts>\n struct NumTagged;\n \n-template <template <typename> class Tag>\n+template <template <typename> typename Tag>\n struct NumTagged<Tag> {\n   static constexpr int64_t value = 0;\n };\n \n-template <template <typename> class Tag, typename T, typename... Ts>\n+template <template <typename> typename Tag, typename T, typename... Ts>\n struct NumTagged<Tag, Tag<T>, Ts...> {\n   static constexpr int64_t value = 1 + NumTagged<Tag, Ts...>::value;\n };\n \n-template <template <typename> class Tag, typename T, typename... Ts>\n+template <template <typename> typename Tag, typename T, typename... Ts>\n struct NumTagged<Tag, T, Ts...> {\n   static constexpr int64_t value = 0 + NumTagged<Tag, Ts...>::value;\n };\n@@ -622,7 +626,7 @@ template <ExecutionStage stage, typename... Ts>\n class Binding {\n  public:\n   template <typename T>\n-  Binding<stage, Ts..., T> Arg() && {\n+  Binding<stage, Ts..., internal::ArgTag<T>> Arg() && {\n     static_assert(!internal::HasOptionalArgTag<Ts...>::value,\n                   \"argument can't be passed after optional argument\");\n     static_assert(!internal::HasRemainingArgsTag<Ts...>::value,\n@@ -1159,7 +1163,10 @@ struct DecodingContext {\n };\n \n template <typename T>\n-struct Decode {\n+struct Decode;\n+\n+template <typename T>\n+struct Decode<ArgTag<T>> {\n   XLA_FFI_ATTRIBUTE_ALWAYS_INLINE\n   static std::optional<T> call(DecodingOffsets& offsets, DecodingContext& ctx,\n                                DiagnosticEngine& diagnostic) {\n@@ -1178,7 +1185,7 @@ struct Decode<OptionalArgTag<T>> {\n     if (XLA_FFI_PREDICT_FALSE(offsets.args >= ctx.call_frame->args.size)) {\n       return std::optional<T>(std::nullopt);\n     }\n-    return Decode<T>::call(offsets, ctx, diagnostic);\n+    return Decode<ArgTag<T>>::call(offsets, ctx, diagnostic);\n   }\n };\n \n@@ -1464,7 +1471,10 @@ class RemainingRets;\n namespace internal {\n // A helper struct to extract the type of the handler argument.\n template <typename T>\n-struct FnArgType {\n+struct FnArgType;\n+\n+template <typename T>\n+struct FnArgType<internal::ArgTag<T>> {\n   using Type = T;\n };\n \n@@ -1508,44 +1518,6 @@ struct FnArgType<internal::CtxTag<T>> {\n   using Type = typename CtxDecoding<T>::Type;\n };\n \n-// A template for checking if type in a parameter pack is a tagged one and has\n-// a special decoding rule defined by template specialization.\n-template <typename>\n-struct IsTagged : std::false_type {};\n-\n-template <typename T>\n-struct IsTagged<OptionalArgTag<T>> : std::true_type {};\n-template <typename T>\n-struct IsTagged<RetTag<T>> : std::true_type {};\n-template <typename T>\n-struct IsTagged<OptionalRetTag<T>> : std::true_type {};\n-template <typename T>\n-struct IsTagged<AttrTag<T>> : std::true_type {};\n-template <typename T>\n-struct IsTagged<AttrsTag<T>> : std::true_type {};\n-template <typename T>\n-struct IsTagged<CtxTag<T>> : std::true_type {};\n-\n-template <>\n-struct IsTagged<RemainingArgsTag> : std::true_type {};\n-template <>\n-struct IsTagged<RemainingRetsTag> : std::true_type {};\n-\n-// A template for counting regular arguments in the Ts pack (arguments that are\n-// not wrapped into a special tag).\n-template <typename... Ts>\n-struct NumArgs;\n-\n-template <>\n-struct NumArgs<> {\n-  static constexpr int64_t value = 0;\n-};\n-\n-template <typename T, typename... Ts>\n-struct NumArgs<T, Ts...> {\n-  static constexpr int64_t value = !IsTagged<T>::value + NumArgs<Ts...>::value;\n-};\n-\n // A template to detect result encodings that are state constructors. We use\n // this to report back the TypeId of the state as a part of the metadata.\n template <typename ResultEnconding, typename = void>\n@@ -1574,7 +1546,8 @@ template <ExecutionStage stage, typename Fn, typename... Ts>\n class Handler : public Ffi {\n   static constexpr int64_t kSize = sizeof...(Ts);\n \n-  static constexpr int64_t kNumArgs = internal::NumArgs<Ts...>::value;\n+  static constexpr int64_t kNumArgs =\n+      internal::NumTagged<internal::ArgTag, Ts...>::value;\n \n   static constexpr int64_t kNumOptionalArgs =\n       internal::NumTagged<internal::OptionalArgTag, Ts...>::value;"
        },
        {
            "sha": "a42627223a668cccdd2f3c7c221f9b0158eae2cd",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d4b7f15aee48be460b95c91d90780a38f59291c3/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d4b7f15aee48be460b95c91d90780a38f59291c3/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=d4b7f15aee48be460b95c91d90780a38f59291c3",
            "patch": "@@ -61,6 +61,15 @@ limitations under the License.\n \n namespace xla::ffi {\n \n+using xla::ffi::internal::ArgTag;\n+using xla::ffi::internal::NumTagged;\n+using xla::ffi::internal::RetTag;\n+\n+// Compile-time test for the template metaprogramming for counting tags.\n+static_assert(NumTagged<ArgTag, RetTag<int32_t>>::value == 0);\n+static_assert(NumTagged<ArgTag, ArgTag<int32_t>>::value == 1);\n+static_assert(NumTagged<ArgTag, ArgTag<int32_t>, RetTag<int32_t>>::value == 1);\n+\n enum class Int32BasedEnum : int32_t {\n   kOne = 1,\n   kTwo = 2,"
        }
    ],
    "stats": {
        "total": 78,
        "additions": 30,
        "deletions": 48
    }
}