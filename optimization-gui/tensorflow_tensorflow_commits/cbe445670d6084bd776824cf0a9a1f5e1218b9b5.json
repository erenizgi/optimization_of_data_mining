{
    "author": "mkuperst",
    "message": "[XLA] Only split the body of a call once.\n\nWhen the call splitter is called on a non-flat graph, we don't want to implicitly flatten it by creating new bodies at each callsite.\n\nPiperOrigin-RevId: 834875376",
    "sha": "cbe445670d6084bd776824cf0a9a1f5e1218b9b5",
    "files": [
        {
            "sha": "1ea6f5c5d5242ad52e3993afc4ef366465097191",
            "filename": "third_party/xla/xla/hlo/transforms/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD?ref=cbe445670d6084bd776824cf0a9a1f5e1218b9b5",
            "patch": "@@ -599,6 +599,7 @@ xla_cc_test(\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:pattern_matcher_gmock\",\n         \"//xla/hlo/testlib:test\",\n+        \"//xla/hlo/transforms/simplifiers:algebraic_simplifier\",\n         \"//xla/hlo/transforms/simplifiers:call_parameter_cleanup\",\n         \"//xla/hlo/transforms/simplifiers:hlo_dce\",\n         \"//xla/hlo/transforms/simplifiers:tuple_simplifier\","
        },
        {
            "sha": "4f38b34a6c9e27a88072cacfc97b6afd4c57886e",
            "filename": "third_party/xla/xla/hlo/transforms/call_splitter.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc?ref=cbe445670d6084bd776824cf0a9a1f5e1218b9b5",
            "patch": "@@ -276,8 +276,21 @@ absl::StatusOr<bool> CallSplitter::RunImpl(\n   }\n \n   bool changed = false;\n+  split_call_bodies_.clear();\n   for (HloInstruction* call : calls_to_process) {\n-    auto split_result = SplitCallBody(call->to_apply(), boundary_predicate_);\n+    // We may have already split this callee when wer processed another\n+    // callsite, in which case we can reuse the results.\n+    auto get_split = [&](HloComputation* body) {\n+      auto it = split_call_bodies_.find(body);\n+      if (it != split_call_bodies_.end()) {\n+        return it->second;\n+      }\n+      auto split = SplitCallBody(body, boundary_predicate_);\n+      split_call_bodies_[body] = split;\n+      return split;\n+    };\n+\n+    auto split_result = get_split(call->to_apply());\n     if (split_result.first != nullptr) {\n       changed |= true;\n       TF_RETURN_IF_ERROR("
        },
        {
            "sha": "513fc2bbcceefe1f37378b2f971e31414a3ab315",
            "filename": "third_party/xla/xla/hlo/transforms/call_splitter.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.h?ref=cbe445670d6084bd776824cf0a9a1f5e1218b9b5",
            "patch": "@@ -18,6 +18,7 @@ limitations under the License.\n \n #include <utility>\n \n+#include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -86,6 +87,10 @@ class CallSplitter : public HloModulePass {\n   std::pair<HloComputation*, HloComputation*> SplitCallBody(\n       HloComputation* body, HloPredicate boundary_predicate);\n \n+  absl::flat_hash_map<HloComputation*,\n+                      std::pair<HloComputation*, HloComputation*>>\n+      split_call_bodies_;\n+\n  protected:\n   HloPredicate call_predicate_;\n   HloPredicate boundary_predicate_;"
        },
        {
            "sha": "479e2c519bc389ecd2d2609e13ee92de674292f1",
            "filename": "third_party/xla/xla/hlo/transforms/call_splitter_test.cc",
            "status": "modified",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cbe445670d6084bd776824cf0a9a1f5e1218b9b5/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter_test.cc?ref=cbe445670d6084bd776824cf0a9a1f5e1218b9b5",
            "patch": "@@ -28,6 +28,7 @@ limitations under the License.\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/pattern_matcher_gmock.h\"\n #include \"xla/hlo/testlib/test.h\"\n+#include \"xla/hlo/transforms/simplifiers/algebraic_simplifier.h\"\n #include \"xla/hlo/transforms/simplifiers/call_parameter_cleanup.h\"\n #include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n #include \"xla/hlo/transforms/simplifiers/tuple_simplifier.h\"\n@@ -281,6 +282,103 @@ ENTRY entry {\n               GmockMatch(m::Tuple(m::Multiply(), m::Subtract())));\n }\n \n+TEST_F(CallSplitterTest, SplitDownMultipleCallsites) {\n+  const std::string module_str = R\"hlo(\n+HloModule module\n+\n+addmul {\n+  a = s32[] parameter(0)\n+  b = s32[] parameter(1)\n+  c = s32[] parameter(2)\n+  add = s32[] add(a, b)\n+  mul = s32[] multiply(add, c)\n+  ROOT tuple = (s32[]) tuple(mul)\n+}\n+\n+ENTRY entry {\n+  p0 = s32[] parameter(0)\n+  p1 = s32[] parameter(1)\n+  p2 = s32[] parameter(2)\n+  call0 = (s32[]) call(p0, p1, p2), to_apply=addmul\n+  call1 = (s32[]) call(p2, p1, p0), to_apply=addmul\n+  ROOT out = tuple(call0, call1)\n+}\n+\n+)hlo\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  auto split = [](const HloInstruction* instruction) -> bool {\n+    return instruction->opcode() == HloOpcode::kMultiply;\n+  };\n+\n+  CallSplitter splitter(/*call_predicate=*/HloPredicateTrue,\n+                        /*boundary_predicate=*/split);\n+  EXPECT_TRUE(splitter.Run(module.get()).value());\n+\n+  CallParameterCleanup cleanup;\n+  HloDCE dce;\n+  TupleSimplifier tuple_simplifier;\n+  TF_CHECK_OK(cleanup.Run(module.get()).status());\n+  TF_CHECK_OK(dce.Run(module.get()).status());\n+  TF_CHECK_OK(tuple_simplifier.Run(module.get()).status());\n+\n+  HloInstruction* call0_first;\n+  HloInstruction* call1_first;\n+  HloInstruction* call0_second;\n+  HloInstruction* call1_second;\n+\n+  EXPECT_THAT(module->entry_computation()->root_instruction(),\n+              GmockMatch(m::Tuple(\n+                  m::Call(&call0_second, m::Parameter(2),\n+                          m::GetTupleElement(m::Call(&call0_first), 0)),\n+                  m::Call(&call1_second, m::Parameter(0),\n+                          m::GetTupleElement(m::Call(&call1_first), 0)))));\n+\n+  EXPECT_EQ(call0_first->to_apply(), call1_first->to_apply());\n+  EXPECT_EQ(call0_second->to_apply(), call1_second->to_apply());\n+  EXPECT_NE(call0_first->to_apply(), call0_second->to_apply());\n+}\n+\n+TEST_F(CallSplitterTest, ClearCache) {\n+  const std::string module_str = R\"hlo(\n+HloModule module\n+\n+addrem {\n+  a = u32[] parameter(0)\n+  b = u32[] parameter(1)\n+  c = u32[] constant(8)\n+  add = u32[] add(a, b)\n+  rem = u32[] remainder(add, c)\n+  ROOT tuple = (u32[]) tuple(rem)\n+}\n+\n+ENTRY entry {\n+  p0 = u32[] parameter(0)\n+  p1 = u32[] parameter(1)\n+  ROOT call = (u32[]) call(p0, p1), to_apply=addrem\n+}\n+\n+)hlo\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          ParseAndReturnVerifiedModule(module_str));\n+\n+  auto split = [](const HloInstruction* instruction) -> bool {\n+    return instruction->opcode() == HloOpcode::kAnd;\n+  };\n+\n+  CallSplitter splitter(/*call_predicate=*/HloPredicateTrue,\n+                        /*boundary_predicate=*/split);\n+  EXPECT_FALSE(splitter.Run(module.get()).value());\n+\n+  AlgebraicSimplifier simplifier(AlgebraicSimplifierOptions{});\n+  TF_CHECK_OK(simplifier.Run(module.get()).status());\n+\n+  EXPECT_TRUE(splitter.Run(module.get()).value());\n+}\n+\n }  // namespace\n \n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 118,
        "deletions": 1
    }
}