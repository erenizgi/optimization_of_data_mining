{
    "author": "sergachev",
    "message": "PR #30704: Algebraic simplifier: replace no-op bitcast-converts with bitcasts also for different type bit widths.\n\nImported from GitHub PR https://github.com/openxla/xla/pull/30704\n\nCopybara import of the project:\n\n--\na97824266c12ab9e6fd2b001da0b04abff860abf by Ilia Sergachev <isergachev@nvidia.com>:\n\nAlgebraic simplifier: replace no-op bitcast-converts with bitcasts also for different type bit widths.\n\nMerging this change closes #30704\n\nPiperOrigin-RevId: 804728735",
    "sha": "83caf30576adaa965ca9c5f6619ef195127aef53",
    "files": [
        {
            "sha": "614419a1cec28cbf3dc110aab7d138b85d9980b5",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 10,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/83caf30576adaa965ca9c5f6619ef195127aef53/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/83caf30576adaa965ca9c5f6619ef195127aef53/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc?ref=83caf30576adaa965ca9c5f6619ef195127aef53",
            "patch": "@@ -793,8 +793,6 @@ void AlgebraicSimplifierVisitor::ReplaceWithBitcast(HloInstruction* instruction,\n   if (operand == nullptr) {\n     operand = instruction->mutable_operand(0);\n   }\n-  CHECK_EQ(ShapeUtil::ElementsIn(instruction->shape()),\n-           ShapeUtil::ElementsIn(operand->shape()));\n   CHECK_EQ(ShapeUtil::ByteSizeOf(instruction->shape()),\n            ShapeUtil::ByteSizeOf(operand->shape()));\n \n@@ -1628,15 +1626,40 @@ absl::Status AlgebraicSimplifierVisitor::HandleBitcastConvert(\n     return absl::OkStatus();\n   }\n   if (options_.is_layout_sensitive() &&\n-      options_.rewrite_no_op_bitcast_convert_to_bitcast() &&\n-      // Equal shape ignoring element type implies same bitwidth, as for\n-      // different bitwidth shape inference would yield a different shape for\n-      // the output. A bitcast-convert with same shape but different bitwidth\n-      // would fail the HloVerifier.\n-      ShapeUtil::EqualIgnoringElementType(bitcast->shape(), operand->shape())) {\n-    ReplaceWithBitcast(bitcast);\n-    return absl::OkStatus();\n+      options_.rewrite_no_op_bitcast_convert_to_bitcast()) {\n+    // Equal shape ignoring element type implies same bitwidth, as for\n+    // different bitwidth shape inference would yield a different shape for\n+    // the output. A bitcast-convert with same shape but different bitwidth\n+    // would fail the HloVerifier.\n+    if (ShapeUtil::EqualIgnoringElementType(bitcast->shape(),\n+                                            operand->shape())) {\n+      ReplaceWithBitcast(bitcast);\n+      return absl::OkStatus();\n+    }\n+\n+    auto last_dim_is_contiguous = [](const Shape& shape) {\n+      if (!ShapeUtil::LastDimIsMinorMost(shape)) {\n+        return false;\n+      }\n+      const int type_bit_width = primitive_util::BitWidth(shape.element_type());\n+      if (!shape.has_layout() || shape.layout().element_size_in_bits() == 0) {\n+        return type_bit_width % 8 == 0;\n+      }\n+      return shape.layout().element_size_in_bits() == type_bit_width;\n+    };\n+\n+    const Shape& shape_with_extra_dimension =\n+        operand->shape().dimensions().size() >\n+                bitcast->shape().dimensions().size()\n+            ? operand->shape()\n+            : bitcast->shape();\n+\n+    if (last_dim_is_contiguous(shape_with_extra_dimension)) {\n+      ReplaceWithBitcast(bitcast);\n+      return absl::OkStatus();\n+    }\n   }\n+\n   // Eliminate bitcast converts between same shape.\n   ReplaceInstructionIfCompatible(bitcast, bitcast->mutable_operand(0));\n   return absl::OkStatus();"
        },
        {
            "sha": "c36fb91987d5370ababeb305a4ed3c76187250f9",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier_test.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 6,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/83caf30576adaa965ca9c5f6619ef195127aef53/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/83caf30576adaa965ca9c5f6619ef195127aef53/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc?ref=83caf30576adaa965ca9c5f6619ef195127aef53",
            "patch": "@@ -11415,8 +11415,16 @@ TEST_F(AlgebraicSimplifierTest,\n               GmockMatch(m::Bitcast()));\n }\n \n-TEST_F(AlgebraicSimplifierTest,\n-       DoNotSimplifyBitcastConvertIfDifferentBitwidth) {\n+class SimplifyNoOpBitcastConvertTest : public AlgebraicSimplifierTest {\n+  void SetUp() override {\n+    AlgebraicSimplifierTest::SetUp();\n+    default_options_.set_is_layout_sensitive(true);\n+    default_options_.set_rewrite_no_op_bitcast_convert_to_bitcast(true);\n+  }\n+};\n+\n+TEST_F(SimplifyNoOpBitcastConvertTest,\n+       SimplifyBitcastConvertToNarrowerBitwidth) {\n   constexpr absl::string_view kModuleStr = R\"(\n     HloModule m\n \n@@ -11426,10 +11434,49 @@ TEST_F(AlgebraicSimplifierTest,\n     }\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n-  AlgebraicSimplifierOptions options;\n-  options.set_is_layout_sensitive(true);\n-  options.set_rewrite_no_op_bitcast_convert_to_bitcast(true);\n-  EXPECT_FALSE(AlgebraicSimplifier(options).Run(m.get()).value());\n+  EXPECT_TRUE(AlgebraicSimplifier(default_options_).Run(m.get()).value());\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              GmockMatch(m::Bitcast()));\n+}\n+\n+TEST_F(SimplifyNoOpBitcastConvertTest,\n+       DoNotSimplifyBitcastConvertToNonMinorDim) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+    HloModule m\n+\n+    ENTRY test {\n+      p0 = s32[10]{0} parameter(0)\n+      ROOT out = s16[10,2]{0,1} bitcast-convert(p0)\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  EXPECT_FALSE(AlgebraicSimplifier(default_options_).Run(m.get()).value());\n+}\n+\n+TEST_F(SimplifyNoOpBitcastConvertTest,\n+       DoNotSimplifyBitcastConvertFromNonPackedDim) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+    HloModule m\n+\n+    ENTRY test {\n+      p0 = s4[5,2]{1,0:E(8)} parameter(0)\n+      ROOT out = s8[5]{0} bitcast-convert(p0)\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  EXPECT_FALSE(AlgebraicSimplifier(default_options_).Run(m.get()).value());\n+}\n+\n+TEST_F(SimplifyNoOpBitcastConvertTest, SimplifyBitcastConvertToWiderBitwidth) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+m {\n+  a = s4[3,5,2]{2,1,0:E(4)} parameter(0)\n+  b = s8[3,5]{1,0} bitcast-convert(a)\n+})\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  EXPECT_TRUE(AlgebraicSimplifier(default_options_).Run(m.get()).value());\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              GmockMatch(m::Bitcast()));\n }\n \n TEST_F(AlgebraicSimplifierTest, SimplifyBitcastConvertChain) {"
        }
    ],
    "stats": {
        "total": 102,
        "additions": 86,
        "deletions": 16
    }
}