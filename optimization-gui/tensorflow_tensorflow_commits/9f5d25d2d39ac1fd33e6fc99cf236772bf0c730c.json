{
    "author": "bchetioui",
    "message": "[XLA] Solidify the invariants of `TiledHloSchedule`.\n\nIn order to support arbitrary schedules with a predictable number of\nparameters, we produce a map with a single parameter representing the\nentire iteration space---circumventing otherwise limiting divisibility\nconstraints (e.g. given two axis of prime length, there are only two\nvalid schedules that can be expressed with 2 parameters, but many more 1D\nschedules).\n\nFollow-up changes will focus on implementing other schedules and integrating\nit as a parameter to `SymbolicTileAnalysis::ComputeTiledHloInstructions`.\n\nPiperOrigin-RevId: 817067449",
    "sha": "9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c",
    "files": [
        {
            "sha": "5056574c12b021424d65f0e511a456bd948560a7",
            "filename": "third_party/xla/xla/codegen/tiling/BUILD",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD?ref=9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c",
            "patch": "@@ -118,13 +118,14 @@ cc_library(\n     hdrs = [\"tiled_hlo_schedule.h\"],\n     deps = [\n         \":tiling_specification\",\n+        \"//xla:util\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n-        \"//xla/hlo/ir:hlo\",\n-        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n         \"@llvm-project//mlir:IR\",\n     ],\n )\n@@ -134,16 +135,12 @@ xla_cc_test(\n     srcs = [\"tiled_hlo_schedule_test.cc\"],\n     deps = [\n         \":tiled_hlo_schedule\",\n-        \":tiling_specification\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n-        \"//xla/hlo/analysis:indexing_test_utils\",\n         \"//xla/hlo/analysis:interval\",\n-        \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n-        \"//xla/hlo/testlib:verified_hlo_module\",\n-        \"//xla/service/gpu/model/experimental:symbolic_expr\",\n         \"//xla/tsl/platform:statusor\",\n-        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@llvm-project//mlir:IR\",\n     ],\n@@ -341,6 +338,7 @@ cc_library(\n         \":tiled_hlo_computation\",\n         \":tiled_hlo_fusion_instruction\",\n         \":tiled_hlo_instruction\",\n+        \":tiled_hlo_schedule\",\n         \":tiling_specification\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n@@ -382,6 +380,7 @@ xla_cc_test(\n         \":tiled_hlo_computation\",\n         \":tiled_hlo_fusion_instruction\",\n         \":tiled_hlo_instruction\",\n+        \":tiled_hlo_schedule\",\n         \":tiling_specification\",\n         \"//xla:util\",\n         \"//xla/hlo/analysis:indexing_test_utils\","
        },
        {
            "sha": "59d099fb3ba4622e5ad50305b2a3cba7aa84c5c3",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 87,
            "changes": 131,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.cc?ref=9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c",
            "patch": "@@ -16,111 +16,68 @@ limitations under the License.\n #include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n \n #include <cstdint>\n-#include <utility>\n #include <vector>\n \n-#include \"absl/algorithm/container.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/AffineMap.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/tiling_specification.h\"\n+#include \"xla/hlo/analysis/indexing_analysis.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n-#include \"xla/hlo/ir/hlo_instruction.h\"\n-#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/util.h\"\n \n namespace xla {\n \n-namespace {\n-\n-bool IsDotLike(const HloInstruction* hlo) {\n-  return hlo->opcode() == HloOpcode::kDot ||\n-         hlo->opcode() == HloOpcode::kScaledDot;\n-}\n-\n-// Given a parameter mapping, produces its \"input\" (or indexing) space, i.e.,\n-// for each parameter, the length of the dimension it abstracts over.\n-std::vector<int64_t> InputSpaceForParameterMapping(\n-    const TilingSpecification::ParameterMapping& parameter_mapping) {\n-  int64_t num_parameters = absl::c_accumulate(\n-      parameter_mapping, 0,\n-      [](int64_t sum,\n-         const TilingSpecification::InstructionAndNumTilingParameters&\n-             mapping) { return sum + mapping.num_tiling_parameters; });\n-  std::vector<int64_t> input_space;\n-  input_space.reserve(num_parameters);\n-\n-  for (const auto& [hlo, num_parameters] : parameter_mapping) {\n-    // TODO(b/419026602): handle reductions.\n-    if (IsDotLike(hlo)) {\n-      auto contracting_dimensions =\n-          hlo->dot_dimension_numbers().lhs_contracting_dimensions();\n-      // First, we need to add the contracting dimensions of the `dot`\n-      // instruction to the input space.\n-      for (int64_t contracting_dimension : contracting_dimensions) {\n-        input_space.push_back(\n-            hlo->operand(0)->shape().dimensions(contracting_dimension));\n-      }\n-      int64_t num_contracting_dimensions = contracting_dimensions.size();\n-      // Optionally, we also add the output dimensions of the `dot` instruction,\n-      // if they are actual parameters.\n-      if (num_parameters != num_contracting_dimensions) {\n-        CHECK_EQ(num_parameters,\n-                 num_contracting_dimensions + hlo->shape().dimensions().size());\n-        for (int64_t output_dimension : hlo->shape().dimensions()) {\n-          input_space.push_back(output_dimension);\n-        }\n-      }\n-      continue;\n-    }\n-\n-    CHECK_EQ(hlo->shape().dimensions().size(), num_parameters);\n-    for (int64_t dimension : hlo->shape().dimensions()) {\n-      input_space.push_back(dimension);\n-    }\n+absl::StatusOr<IndexingMap> MajorToMinorTiledHloSchedule::Schedule(\n+    const IndexingMap& tile_offsets_indexing, IterationSpace iteration_space,\n+    mlir::MLIRContext* ctx) const {\n+  if (iteration_space.size() != tile_offsets_indexing.GetDimVarsCount()) {\n+    return absl::InvalidArgumentError(absl::StrFormat(\n+        \"Expected iteration space to have exactly as many dimensions as there \"\n+        \"are parameters in the tile offsets indexing map, but iteration space \"\n+        \"has %d dimensions, and tile offsets indexing map has %d dimensions.\",\n+        iteration_space.size(), tile_offsets_indexing.GetDimVarsCount()));\n   }\n \n-  return input_space;\n-}\n-}  // namespace\n-\n-absl::StatusOr<IndexingMap> MajorToMinorTiledHloSchedule::RootSchedule(\n-    const HloInstruction* root,\n-    const TilingSpecification::ParameterMapping& parameter_mapping,\n-    mlir::MLIRContext* ctx) const {\n-  std::vector<int64_t> input_space =\n-      InputSpaceForParameterMapping(parameter_mapping);\n-  int64_t num_output_parameters = root->shape().dimensions().size();\n+  mlir::AffineExpr program_id = mlir::getAffineDimExpr(0, ctx);\n \n-  std::vector<mlir::AffineExpr> result_exprs;\n-  result_exprs.reserve(num_output_parameters);\n+  std::vector<int64_t> iteration_space_sizes;\n+  iteration_space_sizes.reserve(iteration_space.size());\n+  for (const auto& dim_info : iteration_space) {\n+    iteration_space_sizes.push_back(dim_info.dimension_size);\n+  }\n \n-  int64_t dim_offset = 0;\n-  for (const auto& [hlo, num_tiling_parameters] : parameter_mapping) {\n-    if (hlo != root) {\n-      dim_offset += num_tiling_parameters;\n-      continue;\n+  std::vector<mlir::AffineExpr> tile_exprs(\n+      tile_offsets_indexing.GetDimVarsCount(),\n+      mlir::getAffineConstantExpr(0, ctx));\n+\n+  for (auto [dim_info, tile_expr] :\n+       llvm::zip(iteration_space,\n+                 DelinearizeIndex(iteration_space_sizes, program_id, ctx))) {\n+    if (dim_info.dimension_id >= tile_exprs.size()) {\n+      return absl::InvalidArgumentError(absl::StrFormat(\n+          \"Dimension id %d is out of bounds for tile offsets indexing map with \"\n+          \"%d dimensions. This can happen if \",\n+          dim_info.dimension_id, tile_exprs.size()));\n     }\n-    int64_t num_hidden_parameters =\n-        num_tiling_parameters - num_output_parameters;\n-    for (int64_t parameter_index = num_hidden_parameters;\n-         parameter_index < num_tiling_parameters; ++parameter_index) {\n-      result_exprs.push_back(\n-          mlir::getAffineDimExpr(dim_offset + parameter_index, ctx));\n-    }\n-    CHECK_EQ(result_exprs.size(), num_output_parameters);\n-\n-    mlir::AffineMap affine_map = mlir::AffineMap::get(\n-        input_space.size(), /*symbolCount=*/0, result_exprs, ctx);\n-\n-    return IndexingMap::FromTensorSizes(affine_map, std::move(input_space),\n-                                        /*symbol_upper_bounds=*/{});\n+    tile_exprs[dim_info.dimension_id] = tile_expr;\n   }\n-  return absl::NotFoundError(absl::StrCat(\n-      \"No mapping found for root instruction: \", root->ToString()));\n+  std::vector<IndexingMap::Variable> dim_vars{\n+      {0, Product(iteration_space_sizes) - 1, \"pid_0\"}};\n+  IndexingMap program_id_to_output_dims{\n+      mlir::AffineMap::get(\n+          /*dimCount=*/1, /*symbolCount=*/0, tile_exprs, ctx),\n+      dim_vars, /*range_vars=*/{}, /*rt_vars=*/{}};\n+  auto scheduled_indexing =\n+      ComposeIndexingMaps(program_id_to_output_dims, tile_offsets_indexing);\n+  scheduled_indexing.Simplify();\n+  scheduled_indexing.RescaleSymbols();\n+  scheduled_indexing.RemoveUnusedSymbols();\n+  return scheduled_indexing;\n }\n \n }  // namespace xla"
        },
        {
            "sha": "57e2e0db215ce9a7b72b3bfe6813374b887b2f59",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule.h",
            "status": "modified",
            "additions": 44,
            "deletions": 21,
            "changes": 65,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule.h?ref=9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c",
            "patch": "@@ -16,14 +16,30 @@ limitations under the License.\n #ifndef XLA_CODEGEN_TILING_TILED_HLO_SCHEDULE_H_\n #define XLA_CODEGEN_TILING_TILED_HLO_SCHEDULE_H_\n \n+#include <cstdint>\n+\n #include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n-#include \"xla/hlo/ir/hlo_instruction.h\"\n \n namespace xla {\n \n+// Helper data structure to compute a schedule.\n+//\n+// TODO(b/422676780): When rewriting to use the new tiling space instead of a\n+// tiling specification, we should be able to easily replace this with a\n+// `TilingSpace::DimensionInfo` where the dimension size corresponds to the\n+// iteration space over tiles.\n+struct DimensionInfo {\n+  // An identifier for the dimension.\n+  int64_t dimension_id;\n+  // The size of the iteration space of the dimension.\n+  int64_t dimension_size;\n+};\n+\n+using IterationSpace = absl::Span<const DimensionInfo>;\n+\n // A `TiledHloSchedule` exposes methods for scheduling a `TiledHloComputation`,\n // i.e. it specifies an iteration order over tiles.\n class TiledHloSchedule {\n@@ -32,31 +48,38 @@ class TiledHloSchedule {\n \n   // Returns a schedule for the given root instruction as an indexing map.\n   //\n+  // `iteration_space` must contain one entry for each dimension id in the\n+  // discrete range {0, ..., iteration_space.size() - 1}, and the number of\n+  // dimensions in `iteration_space` must match the number of dimension\n+  // parameters in `tile_offsets_indexing`.\n+  //\n+  // We unfortunately can't pass a `TilingSpecification` here directly in order\n+  // to handle assumption-breaking calls in the case of multi-output fusions.\n+  // Once those are resolved, using a `TilingSpecification` (or new\n+  // `TilingSpace`) should be possible and preferable.\n+  //\n   // The resulting indexing map must satisfy the following properties:\n-  // (1) the map must have exactly as many parameters as there are tiling\n-  //     parameters in `parameter_mapping`;\n-  // (2) the parameters in the resulting map must appear in the same order as\n-  //     they appear in `parameter_mapping`;\n-  // (3) the map must have as many results as there are output dimensions in\n-  //     the instruction---although the results are allowed to be outside the\n-  //     range of the instruction's output space;\n-  // (4) iterating over the entire input space of the map must yield the\n-  //     entire output space of the instruction.\n-  virtual absl::StatusOr<IndexingMap> RootSchedule(\n-      const HloInstruction* root,\n-      const TilingSpecification::ParameterMapping& parameter_mapping,\n+  // (1) the map must have a single input whose range of values is the size of\n+  //     the iteration space (i.e. the product of `iteration_space`'s\n+  //     `dimension_size`s);\n+  // (2) the set of results generatable with the map must be equal to the set\n+  //     of results of `tile_offsets_indexing` (i.e. the map may only reorder\n+  //     how the results are generated, but may not change the results\n+  //     themselves);\n+  virtual absl::StatusOr<IndexingMap> Schedule(\n+      const IndexingMap& tile_offsets_indexing, IterationSpace iteration_space,\n       mlir::MLIRContext* ctx) const = 0;\n };\n \n-// The indexing map returned by this schedule uses parameters\n-// in major-to-minor order (i.e. in the order in which they are specified in\n-// the relevant parameter mapping).\n+// The indexing map returned by this schedule iterates over the iteration space\n+// being specified in major-to-minor order (i.e. it first iterates over the\n+// trailing dimension of the iteration space and last over the leading\n+// dimension).\n class MajorToMinorTiledHloSchedule : public TiledHloSchedule {\n  public:\n-  absl::StatusOr<IndexingMap> RootSchedule(\n-      const HloInstruction* root,\n-      const TilingSpecification::ParameterMapping& parameter_mapping,\n-      mlir::MLIRContext* ctx) const override;\n+  absl::StatusOr<IndexingMap> Schedule(const IndexingMap& tile_offsets_indexing,\n+                                       IterationSpace iteration_space,\n+                                       mlir::MLIRContext* ctx) const override;\n };\n \n // TODO(b/417977182): implement the `PlanarSnakeTiledHloSchedule` schedule."
        },
        {
            "sha": "94db2ddecc0a6841abf9260a09ab4ccce8142d6b",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_schedule_test.cc",
            "status": "modified",
            "additions": 73,
            "deletions": 67,
            "changes": 140,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_schedule_test.cc?ref=9f5d25d2d39ac1fd33e6fc99cf236772bf0c730c",
            "patch": "@@ -16,93 +16,99 @@ limitations under the License.\n #include \"xla/codegen/tiling/tiled_hlo_schedule.h\"\n \n #include <cstdint>\n-#include <memory>\n+#include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n-#include \"absl/strings/substitute.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/MLIRContext.h\"\n-#include \"xla/codegen/tiling/tiling_specification.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n-#include \"xla/hlo/analysis/indexing_test_utils.h\"\n+#include \"xla/hlo/analysis/indexing_map_serialization.h\"\n #include \"xla/hlo/analysis/interval.h\"\n-#include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n-#include \"xla/hlo/testlib/verified_hlo_module.h\"\n-#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n #include \"xla/tsl/platform/statusor.h\"\n \n namespace xla {\n namespace {\n \n-using ::testing::ElementsAre;\n+using ::absl_testing::StatusIs;\n+using ::testing::HasSubstr;\n \n class TiledHloScheduleTest : public HloHardwareIndependentTestBase {\n  protected:\n   mlir::MLIRContext ctx_;\n };\n \n-TEST_F(TiledHloScheduleTest,\n-       MajorToMinorTiledHloScheduleSatisfiesRootScheduleProperties) {\n-  constexpr int64_t batch_size = 5;\n-  constexpr int64_t lhs_non_contracting_size = 2;\n-  constexpr int64_t rhs_non_contracting_size = 4;\n-  constexpr int64_t contracting_size = 97;\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(absl::Substitute(\n-                              R\"(\n-ENTRY main {\n-  p0 = f32[$0,$1,$3] parameter(0)\n-  p1 = f32[$0,$3,$2] parameter(1)\n-  ROOT dot = f32[$0,$1,$2] dot(p0, p1),\n-    lhs_contracting_dims={2}, rhs_contracting_dims={1},\n-    lhs_batch_dims={0}, rhs_batch_dims={0}\n-})\",\n-                              batch_size, lhs_non_contracting_size,\n-                              rhs_non_contracting_size, contracting_size)));\n-  const HloInstruction* root = module->entry_computation()->root_instruction();\n-\n-  // The dot instruction has 4 tiling parameters (1 batch, 2 non-contracting\n-  // dimensions, and 1 contracting dimension).\n-  constexpr int64_t kNumDotTilingParameters = 4;\n-  TilingSpecification::ParameterMapping parameter_mapping{\n-      {root, kNumDotTilingParameters}};\n-\n-  MajorToMinorTiledHloSchedule schedule;\n+using MajorToMinorTiledHloScheduleTest = TiledHloScheduleTest;\n+\n+TEST_F(MajorToMinorTiledHloScheduleTest,\n+       MajorToMinorTiledHloScheduleSatisfiesScheduleProperties) {\n+  IndexingMap offsets_indexing = *ParseIndexingMap(R\"(\n+      (d0, d1, d2, d3) -> (d2, d3),\n+      domain: d0 in [0, 1], d1 in [0, 2], d2 in [0, 4], d3 in [0, 6])\",\n+                                                   &ctx_);\n+  auto bound = [&offsets_indexing](int64_t dim) {\n+    return offsets_indexing.GetDimensionBound(dim).upper + 1;\n+  };\n+  std::vector<DimensionInfo> iteration_space = {\n+      {/*dimension_id=*/2, /*dimension_size=*/bound(2)},\n+      {/*dimension_id=*/0, /*dimension_size=*/bound(0)},\n+      {/*dimension_id=*/1, /*dimension_size=*/bound(1)},\n+      {/*dimension_id=*/3, /*dimension_size=*/bound(3)},\n+  };\n+\n+  MajorToMinorTiledHloSchedule scheduler;\n   TF_ASSERT_OK_AND_ASSIGN(\n-      IndexingMap indexing_map,\n-      schedule.RootSchedule(root, parameter_mapping, &ctx_));\n-\n-  // (1) the map must have exactly as many parameters as there are tiling\n-  //     parameters in `parameter_mapping`.\n-  EXPECT_EQ(indexing_map.GetDimVarsCount(), kNumDotTilingParameters);\n-\n-  // (2) the parameters in the resulting map must appear in the same order as\n-  //     they appear in `parameter_mapping`.\n-  Interval contracting_interval{0, contracting_size - 1};\n-  Interval batch_interval{0, batch_size - 1};\n-  Interval lhs_non_contracting_interval{0, lhs_non_contracting_size - 1};\n-  Interval rhs_non_contracting_interval{0, rhs_non_contracting_size - 1};\n-\n-  auto bounds = indexing_map.GetDimensionBounds();\n-\n-  EXPECT_THAT(bounds, ElementsAre(contracting_interval, batch_interval,\n-                                  lhs_non_contracting_interval,\n-                                  rhs_non_contracting_interval));\n-  // (3) the map must have as many results as there are output dimensions in\n-  //     the instruction---although the results are allowed to be outside the\n-  //     range of the instruction's output space.\n-  EXPECT_EQ(indexing_map.GetNumResults(), root->shape().dimensions().size());\n-\n-  // (4) iterating over the entire input space of the map must yield the\n-  //     entire output space of the instruction.\n-  // TODO(b/449934916): fix the layering violation.\n-  gpu::SymbolicExprContext symbolic_expr_context(&ctx_);\n-  EXPECT_EQ(indexing_map.GetAffineMap(),\n-            ParseAffineMap(\"(d0, d1, d2, d3) -> (d1, d2, d3)\",\n-                           &symbolic_expr_context));\n+      IndexingMap scheduled_indexing,\n+      scheduler.Schedule(offsets_indexing, iteration_space, &ctx_));\n+\n+  // (1) the map must have a single input whose range of values is the size of\n+  //     the iteration space (i.e. the product of `iteration_space`'s\n+  //     `dimension_size`s);\n+  EXPECT_EQ(scheduled_indexing.GetDimVarsCount(), 1);\n+  int64_t iteration_space_size = bound(0) * bound(1) * bound(2) * bound(3);\n+  Interval expected_parameter_interval{0, iteration_space_size - 1};\n+  EXPECT_EQ(scheduled_indexing.GetDimensionBound(0),\n+            expected_parameter_interval);\n+\n+  // (2) the set of results generatable with the map must be equal to the set\n+  //     of results of `tile_offsets_indexing` (i.e. the map may only reorder\n+  //     how the results are generated, but may not change the results\n+  //     themselves);\n+  EXPECT_EQ(scheduled_indexing, *ParseIndexingMap(R\"(\n+    (pid_0) -> (pid_0 floordiv 42, pid_0 mod 7), domain: pid_0 in [0, 209]\n+  )\",\n+                                                  &ctx_));\n+\n+  // `pid_0 floordiv 42` has the same upper bound as `d2`.\n+  EXPECT_EQ(iteration_space_size / 42, bound(2));\n+  // `pid_0 mod 7` has the same upper bound as `d3`.\n+  EXPECT_EQ(7, bound(3));\n+}\n+\n+TEST_F(MajorToMinorTiledHloScheduleTest,\n+       MajorToMinorTiledHloScheduleFailsForInvalidIterationSpace) {\n+  IndexingMap offsets_indexing = *ParseIndexingMap(\n+      \"(d0, d1) -> (d1), domain: d0 in [0, 1], d1 in [0, 2]\", &ctx_);\n+  MajorToMinorTiledHloSchedule scheduler;\n+\n+  // The iteration space has the wrong number of dimensions.\n+  EXPECT_THAT(\n+      scheduler.Schedule(offsets_indexing, /*iteration_space=*/{}, &ctx_),\n+      StatusIs(\n+          absl::StatusCode::kInvalidArgument,\n+          HasSubstr(\n+              \"Expected iteration space to have exactly as many dimensions\")));\n+\n+  // The iteration space has an out-of-bounds dimension ID.\n+  EXPECT_THAT(scheduler.Schedule(offsets_indexing, /*iteration_space=*/\n+                                 {{/*dimension_id=*/0, /*dimension_size=*/1},\n+                                  {/*dimension_id=*/2, /*dimension_size=*/0}},\n+                                 &ctx_),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Dimension id 2 is out of bounds\")));\n }\n \n }  // namespace"
        }
    ],
    "stats": {
        "total": 353,
        "additions": 169,
        "deletions": 184
    }
}