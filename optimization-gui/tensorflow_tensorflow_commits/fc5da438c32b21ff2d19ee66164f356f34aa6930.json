{
    "author": "tensorflower-gardener",
    "message": "[XLA] Calculate peak GPU memory usage from xspace proto.\n\nThis metric will be used for pre/post-submit tests.\n\nAlso refactor compute_xspace_stats to remove hardcoded strings\n\nPiperOrigin-RevId: 798320409",
    "sha": "fc5da438c32b21ff2d19ee66164f356f34aa6930",
    "files": [
        {
            "sha": "68fa5088aec289bed11eba2034152b3d000a3b37",
            "filename": "third_party/xla/xla/tools/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2FBUILD?ref=fc5da438c32b21ff2d19ee66164f356f34aa6930",
            "patch": "@@ -789,6 +789,10 @@ cc_library(\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/profiler/utils:tf_xplane_visitor\",\n+        \"//xla/tsl/profiler/utils:xplane_schema\",\n+        \"//xla/tsl/profiler/utils:xplane_utils\",\n+        \"//xla/tsl/profiler/utils:xplane_visitor\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n@@ -805,6 +809,11 @@ xla_cc_test(\n     deps = [\n         \":compute_xspace_stats\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/profiler/utils:group_events\",\n+        \"//xla/tsl/profiler/utils:xplane_builder\",\n+        \"//xla/tsl/profiler/utils:xplane_schema\",\n+        \"//xla/tsl/profiler/utils:xplane_test_utils\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n     ],"
        },
        {
            "sha": "eac7613deed5446c44fc1ae2d31060c082fe90a7",
            "filename": "third_party/xla/xla/tools/compute_xspace_stats.cc",
            "status": "modified",
            "additions": 129,
            "deletions": 41,
            "changes": 170,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats.cc?ref=fc5da438c32b21ff2d19ee66164f356f34aa6930",
            "patch": "@@ -17,21 +17,48 @@ limitations under the License.\n \n #include <cstdint>\n #include <iostream>\n+#include <optional>\n #include <string>\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n+#include \"absl/strings/match.h\"\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/profiler/utils/tf_xplane_visitor.h\"\n+#include \"xla/tsl/profiler/utils/xplane_schema.h\"\n+#include \"xla/tsl/profiler/utils/xplane_utils.h\"\n+#include \"xla/tsl/profiler/utils/xplane_visitor.h\"\n #include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n namespace xla::gpu {\n \n+using ::tensorflow::profiler::XLine;\n+using ::tensorflow::profiler::XPlane;\n+using ::tensorflow::profiler::XSpace;\n+using ::tsl::profiler::StatType;\n+using ::tsl::profiler::XEventVisitor;\n+using ::tsl::profiler::XLineVisitor;\n+using ::tsl::profiler::XPlaneVisitor;\n+using ::tsl::profiler::XStatVisitor;\n+\n+namespace {\n+\n+bool IsMemoryAllocation(int64_t event_type) {\n+  return event_type == tsl::profiler::HostEventType::kMemoryAllocation;\n+}\n+\n+bool IsMemoryDeallocation(int64_t event_type) {\n+  return event_type == tsl::profiler::HostEventType::kMemoryDeallocation;\n+}\n+\n+}  // namespace\n+\n // Checks if an event is a memcpy operation.\n bool IsMemcpy(const tensorflow::profiler::XEvent& event,\n               int64_t memcpy_details_id) {\n@@ -43,8 +70,8 @@ bool IsMemcpy(const tensorflow::profiler::XEvent& event,\n   return false;\n }\n \n-absl::StatusOr<LineStats> ProcessLineEvents(\n-    const tensorflow::profiler::XLine& line, int64_t memcpy_details_id) {\n+absl::StatusOr<LineStats> ProcessLineEvents(const XLine& line,\n+                                            int64_t memcpy_details_id) {\n   LineStats stats;\n   for (const auto& event : line.events()) {\n     stats.total_time_ps += event.duration_ps();\n@@ -55,17 +82,15 @@ absl::StatusOr<LineStats> ProcessLineEvents(\n   return stats;\n }\n \n-absl::StatusOr<LineStats> ProcessLineEvents(\n-    const tensorflow::profiler::XLine& line) {\n+absl::StatusOr<LineStats> ProcessLineEvents(const XLine& line) {\n   LineStats line_stats;\n   for (const auto& event : line.events()) {\n     line_stats.total_time_ps += event.duration_ps();\n   }\n   return line_stats;\n }\n \n-absl::StatusOr<int64_t> GetTotalTimePs(\n-    const tensorflow::profiler::XPlane& plane) {\n+absl::StatusOr<int64_t> GetTotalTimePs(const XPlane& plane) {\n   int64_t total_time_ps = 0;\n   for (const auto& line : plane.lines()) {\n     TF_ASSIGN_OR_RETURN(xla::gpu::LineStats line_stats,\n@@ -75,46 +100,109 @@ absl::StatusOr<int64_t> GetTotalTimePs(\n   return total_time_ps;\n }\n \n-absl::StatusOr<int64_t> GetWallTimePs(\n-    const tensorflow::profiler::XSpace& xspace) {\n+absl::StatusOr<int64_t> GetWallTimePs(const XSpace& xspace) {\n   int64_t wall_time_ps = 0;\n-  for (const tensorflow::profiler::XPlane& plane : xspace.planes()) {\n-    if (plane.name() != \"Task Environment\") {\n-      continue;\n+  if (const XPlane* env_plane = tsl::profiler::FindPlaneWithName(\n+          xspace, tsl::profiler::kTaskEnvPlaneName)) {\n+    std::optional<int64_t> start_time_ns;\n+    std::optional<int64_t> stop_time_ns;\n+    XPlaneVisitor visitor(env_plane, {}, {tsl::profiler::FindTaskEnvStatType});\n+    if (auto stat = visitor.GetStat(\n+            tsl::profiler::TaskEnvStatType::kEnvProfileStartTime)) {\n+      start_time_ns = stat->UintValue();\n     }\n-    int64_t start_time_ns = 0;\n-    int64_t stop_time_ns = 0;\n-    absl::flat_hash_map<std::string, int64_t> stat_metadata_map;\n-    for (const auto& stat_metadata : plane.stat_metadata()) {\n-      stat_metadata_map[stat_metadata.second.name()] =\n-          stat_metadata.second.id();\n+    if (auto stat = visitor.GetStat(\n+            tsl::profiler::TaskEnvStatType::kEnvProfileStopTime)) {\n+      stop_time_ns = stat->UintValue();\n     }\n \n-    for (const auto& stat : plane.stats()) {\n-      if (stat.metadata_id() == stat_metadata_map[\"profile_start_time\"]) {\n-        start_time_ns = stat.uint64_value();\n-      } else if (stat.metadata_id() == stat_metadata_map[\"profile_stop_time\"]) {\n-        stop_time_ns = stat.uint64_value();\n-      }\n+    if (start_time_ns.has_value() && stop_time_ns.has_value()) {\n+      wall_time_ps = (*stop_time_ns - *start_time_ns) * 1000;  // ns to ps\n     }\n+  }\n+  return wall_time_ps;\n+}\n \n-    if (start_time_ns > 0 && stop_time_ns > 0) {\n-      wall_time_ps = (stop_time_ns - start_time_ns) * 1000;  // ns to ps\n+absl::StatusOr<int64_t> GetGPUPeakMemory(const XPlane* plane) {\n+  XPlaneVisitor plane_visitor = tsl::profiler::CreateTfXPlaneVisitor(plane);\n+  absl::flat_hash_map<std::string, int64_t> peak_memory_usage_per_allocator;\n+  plane_visitor.ForEachLine([&](const XLineVisitor& line) {\n+    line.ForEachEvent([&](const XEventVisitor& event) {\n+      int64_t event_type = event.Type().value_or(\n+          tsl::profiler::HostEventType::kUnknownHostEventType);\n+      if (!(IsMemoryAllocation(event_type) ||\n+            IsMemoryDeallocation(event_type))) {\n+        return;\n+      }\n+      std::optional<std::string> memory_allocator_id;\n+      std::optional<int64_t> peak_bytes_in_use;\n+      event.ForEachStat([&](const XStatVisitor& stat) {\n+        if (!stat.Type().has_value()) {\n+          return;\n+        }\n+        switch (stat.Type().value()) {\n+          case StatType::kAllocatorName:\n+            memory_allocator_id = std::string(stat.StrOrRefValue());\n+            break;\n+          case StatType::kPeakBytesInUse:\n+            peak_bytes_in_use = stat.IntValue();\n+            break;\n+          default:\n+            break;\n+        }\n+      });\n+      if (memory_allocator_id.has_value() && peak_bytes_in_use.has_value()) {\n+        peak_memory_usage_per_allocator[*memory_allocator_id] =\n+            std::max(peak_memory_usage_per_allocator[*memory_allocator_id],\n+                     *peak_bytes_in_use);\n+      }\n+    });\n+  });\n+\n+  // This logic relies on string matching on allocator names, which can be\n+  // brittle. If allocator naming conventions change, this function may need to\n+  // be updated. These are the current names being used:\n+  // Host allocators:\n+  //     - gpu_host_bfc\n+  //     - xla_gpu_host_bfc\n+  //     - bfc_cpu_allocator_for_gpu\n+  // GPU allocators:\n+  //     - GPU_ + device_ordinal + _bfc\n+  //     - GPU_collectivememory_ + device_ordinal + _bfc\n+  auto is_allocator_for_device = [&](absl::string_view allocator_name) {\n+    auto lower_case_name = absl::AsciiStrToLower(allocator_name);\n+    return absl::StrContains(lower_case_name, \"gpu\") &&\n+           !absl::StrContains(lower_case_name, \"host\") &&\n+           !absl::StrContains(lower_case_name, \"cpu\");\n+  };\n+\n+  int64_t peak_bytes = -1;\n+  for (const auto& [id, bytes_used] : peak_memory_usage_per_allocator) {\n+    if (!is_allocator_for_device(id)) {\n+      continue;\n     }\n-    break;\n+    peak_bytes = std::max(peak_bytes, bytes_used);\n   }\n-  return wall_time_ps;\n+  if (peak_bytes == -1) {\n+    return absl::InternalError(\"Could not find peak memory usage.\");\n+  }\n+  return peak_bytes;\n }\n \n-absl::StatusOr<GpuDeviceStats> CalculateGpuDeviceStats(\n-    const tensorflow::profiler::XSpace& xspace) {\n+absl::StatusOr<GpuDeviceStats> CalculateGpuDeviceStats(const XSpace& xspace) {\n   GpuDeviceStats result;\n   int64_t total_time_ps = 0;\n   int64_t memcpy_time_ps = 0;\n   absl::string_view device_name = \"/device:GPU:0\";\n \n+  if (const XPlane* host_plane = tsl::profiler::FindPlaneWithName(\n+          xspace, tsl::profiler::kHostThreadsPlaneName)) {\n+    TF_ASSIGN_OR_RETURN(result.peak_memory_usage_bytes,\n+                        GetGPUPeakMemory(host_plane));\n+  }\n+\n   // Iterate over planes to find the device\n-  for (const tensorflow::profiler::XPlane& plane : xspace.planes()) {\n+  for (const XPlane& plane : xspace.planes()) {\n     if (plane.name() != device_name) {\n       continue;  // Skip planes that aren't the target device.\n     }\n@@ -152,18 +240,14 @@ absl::StatusOr<GpuDeviceStats> CalculateGpuDeviceStats(\n   return result;\n }\n \n-absl::StatusOr<xla::gpu::CpuStats> CalculateCpuStats(\n-    const tensorflow::profiler::XSpace& xspace) {\n+absl::StatusOr<xla::gpu::CpuStats> CalculateCpuStats(const XSpace& xspace) {\n   xla::gpu::CpuStats result;\n \n-  // Iterate over planes to find the CPU plane\n-  for (const tensorflow::profiler::XPlane& plane : xspace.planes()) {\n-    if (plane.name() != \"/host:CPU\") {\n-      continue;  // Skip planes that aren't the target device.\n-    }\n-    TF_ASSIGN_OR_RETURN(int64_t total_time_ps, GetTotalTimePs(plane));\n+  // Process the host CPU plane\n+  if (const XPlane* host_plane = tsl::profiler::FindPlaneWithName(\n+          xspace, tsl::profiler::kHostThreadsPlaneName)) {\n+    TF_ASSIGN_OR_RETURN(int64_t total_time_ps, GetTotalTimePs(*host_plane));\n     result.cpu_time_us = static_cast<double>(total_time_ps) / 1e6;\n-    break;  // Assuming only one /host:CPU plane\n   }\n \n   // Calculate Wall Time from the \"Task Environment\" plane\n@@ -180,12 +264,14 @@ absl::Status Run(absl::string_view input_file, absl::string_view device_type) {\n   LOG(INFO) << \"Input file: \" << input_file;\n   // Read the XSpace protobuf\n   tsl::Env* env = tsl::Env::Default();\n-  tensorflow::profiler::XSpace xspace_proto;\n+  XSpace xspace_proto;\n   TF_RETURN_IF_ERROR(\n       tsl::ReadBinaryProto(env, std::string(input_file), &xspace_proto));\n \n   LOG(INFO) << \"Successfully parsed XSpace proto.\";\n \n+  // Any change in the format of the output needs to reflect in\n+  // .github/workflows/benchmarks/run_benchmark.sh\n   if (device_type == \"GPU\") {\n     absl::StatusOr<GpuDeviceStats> stats =\n         CalculateGpuDeviceStats(xspace_proto);\n@@ -196,7 +282,9 @@ absl::Status Run(absl::string_view input_file, absl::string_view device_type) {\n     std::cout << absl::StrFormat(\"Device Time: %.2f us\\n\",\n                                  stats->device_time_us)\n               << absl::StrFormat(\"Device Memcpy Time: %.2f us\\n\",\n-                                 stats->device_memcpy_time_us);\n+                                 stats->device_memcpy_time_us)\n+              << absl::StrFormat(\"Peak Memory: %d bytes\\n\",\n+                                 stats->peak_memory_usage_bytes);\n   } else if (device_type == \"CPU\") {\n     absl::StatusOr<CpuStats> cpu_stats = CalculateCpuStats(xspace_proto);\n     if (!cpu_stats.ok()) {"
        },
        {
            "sha": "1bcff14836e0d05aba1a845305eac5ffc3a3b986",
            "filename": "third_party/xla/xla/tools/compute_xspace_stats.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats.h?ref=fc5da438c32b21ff2d19ee66164f356f34aa6930",
            "patch": "@@ -31,6 +31,7 @@ struct GpuDeviceStats {\n   double device_time_us = 0.0;\n   double device_memcpy_time_us = 0.0;\n   double wall_time_us = 0.0;\n+  int64_t peak_memory_usage_bytes = 0;\n };\n \n struct CpuStats {"
        },
        {
            "sha": "a11c8ab2f136c73357bf593d3b0c6b6b6030103d",
            "filename": "third_party/xla/xla/tools/compute_xspace_stats_test.cc",
            "status": "modified",
            "additions": 157,
            "deletions": 38,
            "changes": 195,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fc5da438c32b21ff2d19ee66164f356f34aa6930/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fcompute_xspace_stats_test.cc?ref=fc5da438c32b21ff2d19ee66164f356f34aa6930",
            "patch": "@@ -15,61 +15,180 @@ limitations under the License.\n \n #include \"xla/tools/compute_xspace_stats.h\"\n \n+#include <cstdint>\n+#include <memory>\n+\n #include <gtest/gtest.h>\n+#include \"absl/strings/string_view.h\"\n #include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/profiler/utils/group_events.h\"\n+#include \"xla/tsl/profiler/utils/xplane_builder.h\"\n+#include \"xla/tsl/profiler/utils/xplane_schema.h\"\n+#include \"xla/tsl/profiler/utils/xplane_test_utils.h\"\n #include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n namespace xla::gpu {\n namespace {\n \n-TEST(ComputeXSpaceStatsTest, IsMemcpyTest) {\n-  tensorflow::profiler::XEvent event;\n-  event.add_stats()->set_metadata_id(1);\n-  EXPECT_TRUE(xla::gpu::IsMemcpy(event, 1));\n-  EXPECT_FALSE(xla::gpu::IsMemcpy(event, 2));\n+using ::tsl::profiler::StatType;\n+\n+// Stat metadata IDs for clarity and maintainability.\n+constexpr int64_t kMemcpyDetailsMetadataId = 1;\n+constexpr int64_t kOtherDetailsMetadataId = 2;\n+\n+// Test fixture for ComputeGpuDeviceStatsTest to reduce verbosity.\n+class ComputeGpuDeviceStatsTest : public testing::Test {\n+ protected:\n+  tsl::profiler::XSpace xspace_;\n+  tsl::profiler::XPlane* device_plane_;\n+  tsl::profiler::XPlane* host_plane_;\n+\n+  ComputeGpuDeviceStatsTest() = default;\n+\n+  void SetUp() override {\n+    device_plane_ = xspace_.add_planes();\n+    device_plane_->set_name(\"/device:GPU:0\");\n+    host_plane_ = tsl::profiler::GetOrCreateHostXPlane(&xspace_);\n+    AddMemcpyStatMetadata();\n+    SetupHostPlaneBuilder();\n+  }\n+\n+  void AddMemcpyStatMetadata() {\n+    tensorflow::profiler::XStatMetadata* stat_metadata =\n+        &(*device_plane_->mutable_stat_metadata())[kMemcpyDetailsMetadataId];\n+    stat_metadata->set_id(kMemcpyDetailsMetadataId);\n+    stat_metadata->set_name(\"memcpy_details\");\n+  }\n+\n+  void SetupHostPlaneBuilder() {\n+    host_plane_builder_ =\n+        std::make_unique<tsl::profiler::XPlaneBuilder>(host_plane_);\n+    host_plane_builder_->ReserveLines(1);\n+    tf_executor_thread_ = std::make_unique<tsl::profiler::XLineBuilder>(\n+        host_plane_builder_->GetOrCreateLine(0));\n+  }\n+\n+  void AddDeviceStat(absl::string_view stat_name, absl::string_view value) {\n+    device_plane_builder_ =\n+        std::make_unique<tsl::profiler::XPlaneBuilder>(device_plane_);\n+    device_plane_builder_->AddStatValue(\n+        *device_plane_builder_->GetOrCreateStatMetadata(stat_name), value);\n+  }\n+\n+  void AddDeviceStat(absl::string_view stat_name, uint64_t value) {\n+    device_plane_builder_ =\n+        std::make_unique<tsl::profiler::XPlaneBuilder>(device_plane_);\n+    device_plane_builder_->AddStatValue(\n+        *device_plane_builder_->GetOrCreateStatMetadata(stat_name), value);\n+  }\n+\n+  tensorflow::profiler::XLine* AddLineToDevicePlane() {\n+    return device_plane_->add_lines();\n+  }\n+\n+  tensorflow::profiler::XEvent* AddEventToLine(\n+      tensorflow::profiler::XLine* line, int64_t duration_ps,\n+      int64_t metadata_id) {\n+    tensorflow::profiler::XEvent* event = line->add_events();\n+    event->set_duration_ps(duration_ps);\n+    event->add_stats()->set_metadata_id(metadata_id);\n+    return event;\n+  }\n+\n+  void AddMemoryAllocationEvent(int64_t start_timestamp_ps) {\n+    tsl::profiler::CreateXEvent(\n+        host_plane_builder_.get(), tf_executor_thread_.get(),\n+        \"MemoryAllocation\", start_timestamp_ps, 1000,\n+        {{StatType::kBytesReserved, int64_t{2000}},\n+         {StatType::kBytesAllocated, int64_t{3000}},\n+         {StatType::kBytesAvailable, int64_t{5000}},\n+         {StatType::kPeakBytesInUse, int64_t{8500}},\n+         {StatType::kRequestedBytes, int64_t{200}},\n+         {StatType::kAllocationBytes, int64_t{256}},\n+         {StatType::kAddress, int64_t{222333}},\n+         {StatType::kStepId, int64_t{-93746}},\n+         {StatType::kDataType, int64_t{1}},\n+         {StatType::kAllocatorName, \"GPU_0_bfc\"},\n+         {StatType::kTfOp, \"foo/bar\"},\n+         {StatType::kRegionType, \"output\"},\n+         {StatType::kTensorShapes, \"[3, 3, 512, 512]\"}});\n+  }\n+\n+  void AddMemoryDeallocationEvent(int64_t start_timestamp_ps) {\n+    tsl::profiler::CreateXEvent(host_plane_builder_.get(),\n+                                tf_executor_thread_.get(), \"MemoryDeallocation\",\n+                                start_timestamp_ps, 1000,\n+                                {{StatType::kBytesReserved, int64_t{2000}},\n+                                 {StatType::kBytesAllocated, int64_t{2744}},\n+                                 {StatType::kBytesAvailable, int64_t{5256}},\n+                                 {StatType::kPeakBytesInUse, int64_t{8500}},\n+                                 {StatType::kRequestedBytes, int64_t{200}},\n+                                 {StatType::kAllocationBytes, int64_t{256}},\n+                                 {StatType::kAddress, int64_t{222333}},\n+                                 {StatType::kStepId, int64_t{0}},\n+                                 {StatType::kDataType, int64_t{0}},\n+                                 {StatType::kAllocatorName, \"GPU_0_bfc\"},\n+                                 {StatType::kRegionType, \"\"},\n+                                 {StatType::kTensorShapes, \"\"}});\n+  }\n+\n+  std::unique_ptr<tsl::profiler::XPlaneBuilder> host_plane_builder_;\n+  std::unique_ptr<tsl::profiler::XLineBuilder> tf_executor_thread_;\n+  std::unique_ptr<tsl::profiler::XPlaneBuilder> device_plane_builder_;\n+};\n+\n+TEST_F(ComputeGpuDeviceStatsTest, IsMemcpyTest) {\n+  tsl::profiler::XEvent event;\n+  event.add_stats()->set_metadata_id(kMemcpyDetailsMetadataId);\n+  EXPECT_TRUE(IsMemcpy(event, kMemcpyDetailsMetadataId));\n+  EXPECT_FALSE(IsMemcpy(event, kOtherDetailsMetadataId));\n }\n \n-TEST(ComputeXSpaceStatsTest, ProcessLineEventsTest) {\n-  tensorflow::profiler::XLine line;\n-  tensorflow::profiler::XEvent* event = line.add_events();\n-  event->set_duration_ps(1000);\n-  event->add_stats()->set_metadata_id(1);\n-  event = line.add_events();\n-  event->set_duration_ps(2000);\n-  event->add_stats()->set_metadata_id(2);\n-  event = line.add_events();\n-  event->set_duration_ps(3000);\n-  event->add_stats()->set_metadata_id(1);\n+TEST_F(ComputeGpuDeviceStatsTest, ProcessLineEventsTest) {\n+  tsl::profiler::XLine line;\n+  AddEventToLine(&line, 1000, kMemcpyDetailsMetadataId);\n+  AddEventToLine(&line, 2000, kOtherDetailsMetadataId);\n+  AddEventToLine(&line, 3000, kMemcpyDetailsMetadataId);\n+\n   TF_ASSERT_OK_AND_ASSIGN(LineStats stats,\n-                          xla::gpu::ProcessLineEvents(line, 1));\n+                          ProcessLineEvents(line, kMemcpyDetailsMetadataId));\n   EXPECT_EQ(stats.total_time_ps, 6000);\n   EXPECT_EQ(stats.memcpy_time_ps, 4000);\n }\n \n-TEST(ComputeXSpaceStatsTest, CalculateDeviceTimeAndMemcpyTest) {\n-  tensorflow::profiler::XSpace xspace;\n-  tensorflow::profiler::XPlane* plane = xspace.add_planes();\n-  plane->set_name(\"/device:GPU:0\");\n-  tensorflow::profiler::XStatMetadata* stat_metadata =\n-      &(*plane->mutable_stat_metadata())[1];\n-  stat_metadata->set_id(1);\n-  stat_metadata->set_name(\"memcpy_details\");\n-  tensorflow::profiler::XLine* line = plane->add_lines();\n-  tensorflow::profiler::XEvent* event = line->add_events();\n-  event->set_duration_ps(1000);\n-  event->add_stats()->set_metadata_id(1);\n-  event = line->add_events();\n-  event->set_duration_ps(2000);\n-  event->add_stats()->set_metadata_id(2);\n-  event = line->add_events();\n-  event->set_duration_ps(3000);\n-  event->add_stats()->set_metadata_id(1);\n+TEST_F(ComputeGpuDeviceStatsTest, CalculateDeviceTimeAndMemcpyTest) {\n+  tsl::profiler::XLine* line = AddLineToDevicePlane();\n+  tsl::profiler::XEvent* event =\n+      AddEventToLine(line, 1000, kMemcpyDetailsMetadataId);\n+  AddEventToLine(line, 2000, kOtherDetailsMetadataId);\n+  AddEventToLine(line, 3000, kMemcpyDetailsMetadataId);\n+\n+  AddMemoryAllocationEvent(40000);\n+  AddMemoryDeallocationEvent(50000);\n+\n+  // Device properties setup\n+  constexpr int kClockRateKHz = 1530000;\n+  constexpr int kCoreCount = 80;\n+  constexpr int64_t kMemoryBandwidthBytesPerSecond = 900000000000;\n+  constexpr int kComputeCapMajor = 7;\n+  constexpr int kComputeCapMinor = 0;\n+\n+  AddDeviceStat(GetStatTypeStr(StatType::kDevVendor),\n+                tsl::profiler::kDeviceVendorNvidia);\n+  AddDeviceStat(\"clock_rate\", kClockRateKHz);\n+  AddDeviceStat(\"core_count\", kCoreCount);\n+  AddDeviceStat(\"memory_bandwidth\", kMemoryBandwidthBytesPerSecond);\n+  AddDeviceStat(\"compute_cap_major\", kComputeCapMajor);\n+  AddDeviceStat(\"compute_cap_minor\", kComputeCapMinor);\n+\n+  tsl::profiler::GroupTfEvents(&xspace_);\n   TF_ASSERT_OK_AND_ASSIGN(GpuDeviceStats stats,\n-                          xla::gpu::CalculateGpuDeviceStats(xspace));\n+                          CalculateGpuDeviceStats(xspace_));\n   EXPECT_EQ(stats.device_time_us, 0.006);\n   EXPECT_EQ(stats.device_memcpy_time_us, 0.004);\n-  EXPECT_TRUE(xla::gpu::IsMemcpy(*event, 1));\n-  EXPECT_FALSE(xla::gpu::IsMemcpy(*event, 2));\n+  EXPECT_TRUE(IsMemcpy(*event, kMemcpyDetailsMetadataId));\n+  EXPECT_FALSE(IsMemcpy(*event, kOtherDetailsMetadataId));\n+  EXPECT_EQ(stats.peak_memory_usage_bytes, 8500);\n }\n \n TEST(ComputeXSpaceStatsTest, CalculateCpuTimeTest) {"
        }
    ],
    "stats": {
        "total": 375,
        "additions": 296,
        "deletions": 79
    }
}