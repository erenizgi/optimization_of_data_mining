{
    "author": "allanrenucci",
    "message": "Unify OSS and internal logging libraries.\n\nThis removes the duplicated implementation of `LOG`, `VLOG` and `CHECK` macros\nand relies directly on the implementation provided by Abseil.\n\nTSL logging is not consistently used in XLA. Sometime the Abseil logging headers are included instead. This is not a problem internally because TSL logging aliases Abseil logging. However in OSS, TSL logging is a custom logging library. Abseil logging doesn't recognise the `TF_CPP_MAX_VLOG_LEVEL` and `TF_CPP_VMODULE` environment variables while OSS TSL logging doesn't recognise the `--vmodule` and `--v` flags.\n\nTo preserve backward compatibility in OSS, we run static initialisation logic that initialises Abseil logging from the `TF_CPP_MIN_LOG_LEVEL`/`TF_CPP_MAX_VLOG_LEVEL`/`TF_CPP_VMODULE` env variables.\n\nPiperOrigin-RevId: 799665233",
    "sha": "266e3f28e870f7e17b3ccabe4086c0f571efb571",
    "files": [
        {
            "sha": "3b37da874b585be9f91c164857fff7ac72d95f7c",
            "filename": "tensorflow/compiler/tf2xla/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -369,12 +369,10 @@ cc_library(\n #         \"@local_xla//xla/tsl/platform/default:context\",\n #         \"@local_xla//xla/tsl/platform/default:cord\",\n #         \"@local_xla//xla/tsl/platform/default:env_time\",\n-#         \"@local_xla//xla/tsl/platform/default:logging\",\n #         \"@local_xla//xla/tsl/platform/default:types\",\n #         \"@local_xla//xla/tsl/platform/google:context\",\n #         \"@local_xla//xla/tsl/platform/google:cord\",\n #         \"@local_xla//xla/tsl/platform/google:env_time\",\n-#         \"@local_xla//xla/tsl/platform/google:logging\",\n #         \"@local_xla//xla/tsl/platform/google:types\",\n #         \"@local_xla//xla/tsl/platform/windows:env_time\",\n #         \"//tensorflow/core/platform:bfloat16\","
        },
        {
            "sha": "8fde99e62ff656217a167b922d579c03842edcbc",
            "filename": "tensorflow/core/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -495,7 +495,6 @@ cc_library(\n         \"@local_xla//xla/tsl/framework:numeric_types.h\",\n         \"@local_xla//xla/tsl/framework:type_traits.h\",\n         \"@local_xla//xla/tsl/platform/default:integral_types.h\",\n-        \"@local_xla//xla/tsl/platform/default:logging.h\",\n     ],\n     visibility = [\"//visibility:public\"],\n     deps = [\n@@ -1539,7 +1538,6 @@ cc_library(\n         \"//tensorflow/core/platform:tflite_portable_logging_hdrs\",\n         \"@local_tsl//tsl/platform:tflite_portable_logging_hdrs\",\n         \"@local_xla//xla/tsl/platform/default:integral_types.h\",\n-        \"@local_xla//xla/tsl/platform/default:logging.h\",\n     ],\n     compatible_with = get_compatible_with_portable(),\n     copts = tf_copts(),"
        },
        {
            "sha": "8c27edc30dcc7c097bbb1a28649d60c093070b0e",
            "filename": "tensorflow/core/lib/gif/BUILD",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2Flib%2Fgif%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2Flib%2Fgif%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fgif%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -53,18 +53,26 @@ cc_library(\n         \"//tensorflow/core/platform:gif_internal_hdrs\",\n         \"@local_tsl//tsl/platform:gif_internal_hdrs\",\n         \"@local_xla//xla/tsl/platform/default:integral_types.h\",\n-        \"@local_xla//xla/tsl/platform/default:logging.h\",\n     ],\n     copts = tf_copts(),\n     features = [\"-layering_check\"],\n     linkopts = if_android([\"-ldl\"]),\n     deps = [\n+        \"//tensorflow/core/platform:byte_order\",\n+        \"//tensorflow/core/platform:cord\",\n         \"//tensorflow/core/platform:dynamic_annotations\",\n         \"//tensorflow/core/platform:gif\",\n         \"//tensorflow/core/platform:logging\",\n         \"//tensorflow/core/platform:stringpiece\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:dynamic_annotations\",\n         \"@com_google_absl//absl/strings\",\n+        \"@eigen_archive//:eigen3\",\n+        \"@gif\",\n+        \"@local_tsl//tsl/platform:logging\",\n+        \"@local_tsl//tsl/platform:tstring\",\n+        \"@local_tsl//tsl/platform:types\",\n+        \"@local_xla//xla/tsl/platform:types\",\n     ],\n )\n "
        },
        {
            "sha": "628b027ad9f6581b57106d2c5808f4ec62166110",
            "filename": "tensorflow/core/lib/jpeg/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2Flib%2Fjpeg%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2Flib%2Fjpeg%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fjpeg%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -62,7 +62,6 @@ cc_library(\n         \"//tensorflow/core/platform:jpeg_internal_hdrs\",\n         \"@local_tsl//tsl/platform:jpeg_internal_hdrs\",\n         \"@local_xla//xla/tsl/platform/default:integral_types.h\",\n-        \"@local_xla//xla/tsl/platform/default:logging.h\",\n     ],\n     copts = tf_copts(),\n     linkopts = if_android([\"-ldl\"]),"
        },
        {
            "sha": "21e07095b6ba80462dfb671cffd7119fe06814ac",
            "filename": "tensorflow/core/platform/build_config.bzl",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2Fplatform%2Fbuild_config.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fcore%2Fplatform%2Fbuild_config.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fplatform%2Fbuild_config.bzl?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -17,7 +17,6 @@ load(\n     _tf_google_mobile_srcs_only_runtime = \"tf_google_mobile_srcs_only_runtime\",\n     _tf_jspb_proto_library = \"tf_jspb_proto_library\",\n     _tf_lib_proto_parsing_deps = \"tf_lib_proto_parsing_deps\",\n-    _tf_logging_deps = \"tf_logging_deps\",\n     _tf_platform_alias = \"tf_platform_alias\",\n     _tf_platform_deps = \"tf_platform_deps\",\n     _tf_portable_deps_no_runtime = \"tf_portable_deps_no_runtime\",\n@@ -58,7 +57,6 @@ tf_google_mobile_srcs_no_runtime = _tf_google_mobile_srcs_no_runtime\n tf_google_mobile_srcs_only_runtime = _tf_google_mobile_srcs_only_runtime\n tf_jspb_proto_library = _tf_jspb_proto_library\n tf_lib_proto_parsing_deps = _tf_lib_proto_parsing_deps\n-tf_logging_deps = _tf_logging_deps\n tf_platform_alias = _tf_platform_alias\n tf_platform_deps = _tf_platform_deps\n tf_portable_proto_lib = _tf_portable_proto_lib"
        },
        {
            "sha": "f180d5bda473f7f5ee3c93c3c3a123d482133f53",
            "filename": "tensorflow/python/_pywrap_tensorflow.def",
            "status": "modified",
            "additions": 3,
            "deletions": 10,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fpython%2F_pywrap_tensorflow.def",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/tensorflow%2Fpython%2F_pywrap_tensorflow.def",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2F_pywrap_tensorflow.def?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -44,7 +44,6 @@ EXPORTS\n   ??0CalibrationOptions@quantization@stablehlo@@IEAA@PEAVArena@protobuf@google@@@Z\n   ??0CalibrationStatistics@calibrator@tensorflow@@IEAA@PEAVArena@protobuf@google@@@Z\n   ??0CancellationManager@tsl@@QEAA@XZ\n-  ??0CheckOpMessageBuilder@internal@tsl@@QEAA@PEBD@Z\n   ??0CheckpointReader@checkpoint@tensorflow@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUTSL_Status@@@Z\n   ??0ConfigProto@tensorflow@@IEAA@PEAVArena@protobuf@google@@@Z\n   ??0ConfigProto@tensorflow@@IEAA@PEAVArena@protobuf@google@@AEBV01@@Z\n@@ -73,9 +72,7 @@ EXPORTS\n   ??0Impl@MakeErrorStream@status_macros@xla@@QEAA@PEBDHW4Code@error@tensorflow@@PEAV123@_N@Z\n   ??0LayoutProto@dtensor@tensorflow@@IEAA@PEAVArena@protobuf@google@@@Z\n   ??0LayoutProto@dtensor@tensorflow@@IEAA@PEAVArena@protobuf@google@@AEBV012@@Z\n-  ??0LogMessage@internal@tsl@@QEAA@PEBDHW4LogSeverity@lts_20250512@absl@@@Z\n   ??0LogMessage@log_internal@lts_20250512@absl@@QEAA@PEBDHUInfoTag@0123@@Z\n-  ??0LogMessageFatal@internal@tsl@@QEAA@PEBDH@Z\n   ??0LogMessageFatal@log_internal@lts_20250512@absl@@QEAA@PEBDH0@Z\n   ??0LogMessageFatal@log_internal@lts_20250512@absl@@QEAA@PEBDH@Z\n   ??0MLIRContext@mlir@@QEAA@AEBVDialectRegistry@1@W4Threading@01@@Z\n@@ -95,6 +92,7 @@ EXPORTS\n   ??0OpKernel@tensorflow@@QEAA@PEAVOpKernelConstruction@1@@Z\n   ??0OpLevelCostEstimator@grappler@tensorflow@@QEAA@XZ\n   ??0OpPerformanceList@tensorflow@@IEAA@PEAVArena@protobuf@google@@@Z\n+  ??0OstreamView@LogMessage@log_internal@lts_20250512@absl@@QEAA@AEAULogMessageData@1234@@Z\n   ??0PyInstanceChecker@py_dispatch@tensorflow@@QEAA@AEBV?$vector@PEAU_object@@V?$allocator@PEAU_object@@@std@@@std@@@Z\n   ??0PySignatureChecker@py_dispatch@tensorflow@@QEAA@V?$vector@U?$pair@HV?$shared_ptr@VPyTypeChecker@py_dispatch@tensorflow@@@std@@@std@@V?$allocator@U?$pair@HV?$shared_ptr@VPyTypeChecker@py_dispatch@tensorflow@@@std@@@std@@@2@@std@@@Z\n   ??0PythonAPIDispatcher@py_dispatch@tensorflow@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Span@PEBD@lts_20250512@absl@@V?$Span@PEAU_object@@@67@@Z\n@@ -133,7 +131,6 @@ EXPORTS\n   ??1CalibrationOptions@quantization@stablehlo@@UEAA@XZ\n   ??1CalibrationStatistics@calibrator@tensorflow@@UEAA@XZ\n   ??1CancellationManager@tsl@@QEAA@XZ\n-  ??1CheckOpMessageBuilder@internal@tsl@@QEAA@XZ\n   ??1ConfigProto@tensorflow@@UEAA@XZ\n   ??1CoordinatedTask@tensorflow@@UEAA@XZ\n   ??1DataServiceMetadata@data@tensorflow@@UEAA@XZ\n@@ -151,9 +148,7 @@ EXPORTS\n   ??1Impl@MakeErrorStream@status_macros@xla@@QEAA@XZ\n   ??1KernelDefBuilder@tensorflow@@QEAA@XZ\n   ??1LayoutProto@dtensor@tensorflow@@UEAA@XZ\n-  ??1LogMessage@internal@tsl@@UEAA@XZ\n   ??1LogMessage@log_internal@lts_20250512@absl@@QEAA@XZ\n-  ??1LogMessageFatal@internal@tsl@@UEAA@XZ\n   ??1LogMessageFatal@log_internal@lts_20250512@absl@@QEAA@XZ\n   ??1MLIRContext@mlir@@QEAA@XZ\n   ??1MeshProto@dtensor@tensorflow@@UEAA@XZ\n@@ -165,6 +160,7 @@ EXPORTS\n   ??1OpInfo_TensorProperties@tensorflow@@UEAA@XZ\n   ??1OpKernel@tensorflow@@UEAA@XZ\n   ??1OpPerformanceList@tensorflow@@UEAA@XZ\n+  ??1OstreamView@LogMessage@log_internal@lts_20250512@absl@@UEAA@XZ\n   ??1ProfilerServer@profiler@tsl@@QEAA@XZ\n   ??1ProfilerSession@tsl@@QEAA@XZ\n   ??1PyContextManager@tensorflow@@QEAA@XZ\n@@ -270,7 +266,6 @@ EXPORTS\n   ?CreateMesh@Mesh@dtensor@tensorflow@@SA?AV123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@5@AEBV?$vector@_JV?$allocator@_J@std@@@5@2121_N@Z\n   ?CreateRecordReaderOptions@RecordReaderOptions@io@tsl@@SA?AU123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z\n   ?CreateRecordWriterOptions@RecordWriterOptions@io@tsl@@SA?AU123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z\n-  ?CreateTypeInfoAndReturnTypeIdImpl@AsyncValue@tsl@@CAGAEBUTypeInfo@12@@Z\n   ?CtxFailure@OpKernelConstruction@tensorflow@@QEAAXPEBDHAEBVStatus@lts_20250512@absl@@@Z\n   ?CtxFailure@OpKernelContext@tensorflow@@QEAAXPEBDHAEBVStatus@lts_20250512@absl@@@Z\n   ?CtxFailureWithWarning@OpKernelConstruction@tensorflow@@QEAAXPEBDHAEBVStatus@lts_20250512@absl@@@Z\n@@ -352,7 +347,6 @@ EXPORTS\n   ?FlushExecutionFiles@DebugEventsWriter@tfdbg@tensorflow@@QEAA?AVStatus@lts_20250512@absl@@XZ\n   ?FlushNonExecutionFiles@DebugEventsWriter@tfdbg@tensorflow@@QEAA?AVStatus@lts_20250512@absl@@XZ\n   ?ForEachPayload@StatusRep@status_internal@lts_20250512@absl@@QEBAXV?$FunctionRef@$$A6AXV?$basic_string_view@DU?$char_traits@D@std@@@std@@AEBVCord@lts_20250512@absl@@@Z@34@@Z\n-  ?ForVar2@CheckOpMessageBuilder@internal@tsl@@QEAAPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@XZ\n   ?FormatConvertImpl@str_format_internal@lts_20250512@absl@@YA?AU?$ArgConvertResult@$0IAAAE@@123@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VFormatConversionSpecImpl@123@PEAVFormatSinkImpl@123@@Z\n   ?FormatPack@str_format_internal@lts_20250512@absl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VUntypedFormatSpecImpl@123@V?$Span@$$CBVFormatArgImpl@str_format_internal@lts_20250512@absl@@@23@@Z\n   ?FromProto@Layout@dtensor@tensorflow@@SA?AV?$StatusOr@VLayout@dtensor@tensorflow@@@lts_20250512@absl@@AEBVLayoutProto@23@@Z\n@@ -535,7 +529,6 @@ EXPORTS\n   ?NewDispatchServer@data@tensorflow@@YA?AVStatus@lts_20250512@absl@@AEBVDispatcherConfig@experimental@12@AEAV?$unique_ptr@VDispatchGrpcDataServer@data@tensorflow@@U?$default_delete@VDispatchGrpcDataServer@data@tensorflow@@@std@@@std@@@Z\n   ?NewProfiler@tfprof@tensorflow@@YA_NPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z\n   ?NewRandomAccessFile@Env@tsl@@QEAA?AVStatus@lts_20250512@absl@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$unique_ptr@VRandomAccessFile@tsl@@U?$default_delete@VRandomAccessFile@tsl@@@std@@@7@@Z\n-  ?NewString@CheckOpMessageBuilder@internal@tsl@@QEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ\n   ?NewWorkerServer@data@tensorflow@@YA?AVStatus@lts_20250512@absl@@AEBVWorkerConfig@experimental@12@AEAV?$unique_ptr@VWorkerGrpcDataServer@data@tensorflow@@U?$default_delete@VWorkerGrpcDataServer@data@tensorflow@@@std@@@std@@@Z\n   ?NewWritableFile@Env@tsl@@QEAA?AVStatus@lts_20250512@absl@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$unique_ptr@VWritableFile@tsl@@U?$default_delete@VWritableFile@tsl@@@std@@@7@@Z\n   ?NotFoundError@lts_20250512@absl@@YA?AVStatus@12@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@Z\n@@ -776,7 +769,6 @@ EXPORTS\n   ?UpdateEdge@tensorflow@@YAXPEAUTF_Graph@@UTF_Output@@UTF_Input@@PEAUTSL_Status@@@Z\n   ?ValidateType@ResourceHandle@tensorflow@@QEBA?AVStatus@lts_20250512@absl@@AEBVTypeIndex@2@@Z\n   ?Vector@InferenceContext@shape_inference@tensorflow@@QEAA?AVShapeHandle@23@UDimensionOrConstant@23@@Z\n-  ?VmoduleActivated@LogMessage@internal@tsl@@SA_NPEBDH@Z\n   ?WaitCommon@CondVar@lts_20250512@absl@@AEAA_NPEAVMutex@23@VKernelTimeout@synchronization_internal@23@@Z\n   ?Watch@Tape@gradients@tensorflow@@QEAAXPEBVAbstractTensorHandle@3@@Z\n   ?WithRank@InferenceContext@shape_inference@tensorflow@@QEAA?AVStatus@lts_20250512@absl@@VShapeHandle@23@_JPEAV723@@Z\n@@ -846,6 +838,7 @@ EXPORTS\n   ?set_requested_device@Node@tensorflow@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z\n   ?set_tf2_execution@tensorflow@@YAX_N@Z\n   ?sharding_spec_strs@Layout@dtensor@tensorflow@@QEBA?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ\n+  ?stream@OstreamView@LogMessage@log_internal@lts_20250512@absl@@QEAAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@XZ\n   ?tensor_data@Tensor@tensorflow@@QEBA?AV?$basic_string_view@DU?$char_traits@D@std@@@std@@XZ\n   ?tensor_float_32_execution_enabled@tsl@@YA_NXZ\n   ?tf2_execution_enabled@tensorflow@@YA_NXZ"
        },
        {
            "sha": "bb59a46744e32a8ddd0c30bbfce443bded3bf94e",
            "filename": "third_party/xla/xla/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -264,7 +264,6 @@ xla_cc_test(\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test_main\",\n         \"@com_google_absl//absl/base:log_severity\",\n-        \"@com_google_absl//absl/log:log_sink\",\n         \"@com_google_absl//absl/log:scoped_mock_log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\","
        },
        {
            "sha": "965265f7e667f6a552b3529323f37169f4d938bc",
            "filename": "third_party/xla/xla/service/debug/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -66,10 +66,8 @@ xla_cc_test(\n     deps = [\n         \":unstable_reduction_detector\",\n         \"//xla/hlo/parser:hlo_parser\",\n-        \"//xla/tsl/platform:logging\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/base:log_severity\",\n-        \"@com_google_absl//absl/log:log_sink\",\n         \"@com_google_absl//absl/log:scoped_mock_log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\","
        },
        {
            "sha": "ebdb041f0e76243eab67b34d2ec18988d23eada2",
            "filename": "third_party/xla/xla/service/debug/unstable_reduction_detector_test.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 34,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fdebug%2Funstable_reduction_detector_test.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -15,18 +15,14 @@ limitations under the License.\n \n #include \"xla/service/debug/unstable_reduction_detector.h\"\n \n-#include <type_traits>\n-\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/base/log_severity.h\"\n-#include \"absl/log/log_sink.h\"\n #include \"absl/log/scoped_mock_log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/parser/hlo_parser.h\"\n-#include \"xla/tsl/platform/logging.h\"\n #include \"xla/tsl/platform/statusor.h\"\n \n namespace xla {\n@@ -80,18 +76,16 @@ TEST(UnstableReductionDetectorTest, FailOnUnstableReductions) {\n           DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_FAIL);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(\n-        log,\n-        Log(LogSeverity::kWarning, _,\n-            HasSubstr(\"1 unstable reductions found in module 'module_main'\")));\n-    EXPECT_CALL(log,\n-                Log(LogSeverity::kWarning, _,\n-                    \"Unstable reduction: %red.1 = bf16[] reduce(%p0.1, %init), \"\n-                    \"dimensions={0}, to_apply=%red, \"\n-                    \"metadata={op_name=\\\"op_name\\\" \"\n-                    \"source_file=\\\"source_file.py\\\" source_line=42}\"));\n-  }\n+  EXPECT_CALL(\n+      log,\n+      Log(LogSeverity::kWarning, _,\n+          HasSubstr(\"1 unstable reductions found in module 'module_main'\")));\n+  EXPECT_CALL(log,\n+              Log(LogSeverity::kWarning, _,\n+                  \"Unstable reduction: %red.1 = bf16[] reduce(%p0.1, %init), \"\n+                  \"dimensions={0}, to_apply=%red, \"\n+                  \"metadata={op_name=\\\"op_name\\\" \"\n+                  \"source_file=\\\"source_file.py\\\" source_line=42}\"));\n   log.StartCapturingLogs();\n   EXPECT_THAT(\n       detector.Run(module.get(), /*execution_threads=*/{}),\n@@ -110,16 +104,13 @@ TEST(UnstableReductionDetectorTest, WarningOnUnstableReduction) {\n           DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_WARNING);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(log,\n-                Log(LogSeverity::kWarning, _,\n-                    \"1 unstable reductions found in module 'module_main'\"));\n-    EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n-                         \"Unstable reduction: %red.1 = bf16[] reduce(%p0.1, \"\n-                         \"%init), dimensions={0}, to_apply=%red, \"\n-                         \"metadata={op_name=\\\"op_name\\\" \"\n-                         \"source_file=\\\"source_file.py\\\" source_line=42}\"));\n-  }\n+  EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n+                       \"1 unstable reductions found in module 'module_main'\"));\n+  EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n+                       \"Unstable reduction: %red.1 = bf16[] reduce(%p0.1, \"\n+                       \"%init), dimensions={0}, to_apply=%red, \"\n+                       \"metadata={op_name=\\\"op_name\\\" \"\n+                       \"source_file=\\\"source_file.py\\\" source_line=42}\"));\n   log.StartCapturingLogs();\n   EXPECT_THAT(detector.Run(module.get(), /*execution_threads=*/{}),\n               IsOkAndHolds(false));\n@@ -135,14 +126,11 @@ TEST(UnstableReductionDetectorTest, FailOnUnstableReductionNoMetadata) {\n           DebugOptions::UNSTABLE_REDUCTION_DETECTION_MODE_FAIL);\n   UnstableReductionDetector detector;\n   ::absl::ScopedMockLog log;\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(log,\n-                Log(LogSeverity::kWarning, _,\n-                    \"1 unstable reductions found in module 'module_main'\"));\n-    EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n-                         \"Unstable reduction: %red.1 = bf16[] reduce(%p0.1, \"\n-                         \"%init), dimensions={0}, to_apply=%red\"));\n-  }\n+  EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n+                       \"1 unstable reductions found in module 'module_main'\"));\n+  EXPECT_CALL(log, Log(LogSeverity::kWarning, _,\n+                       \"Unstable reduction: %red.1 = bf16[] reduce(%p0.1, \"\n+                       \"%init), dimensions={0}, to_apply=%red\"));\n   log.StartCapturingLogs();\n   EXPECT_THAT(detector.Run(module.get(), /*execution_threads=*/{}),\n               StatusIs(absl::StatusCode::kFailedPrecondition,"
        },
        {
            "sha": "b3ccf9de8b3b50648d560cf1b9eeb91bb965ef1b",
            "filename": "third_party/xla/xla/service/gpu/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -1762,7 +1762,6 @@ xla_test(\n         \"@com_google_absl//absl/base:log_severity\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/log:log_sink\",\n         \"@com_google_absl//absl/log:scoped_mock_log\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/status:statusor\",\n@@ -2281,7 +2280,6 @@ xla_test(\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:log_severity\",\n         \"@com_google_absl//absl/log\",\n-        \"@com_google_absl//absl/log:log_sink\",\n         \"@com_google_absl//absl/log:scoped_mock_log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings:string_view\","
        },
        {
            "sha": "8e8a2b6042dc199a752f3fce3dee35a7943b21cf",
            "filename": "third_party/xla/xla/service/gpu/gpu_compiler_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_compiler_test.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -25,7 +25,6 @@ limitations under the License.\n #include <ostream>\n #include <string>\n #include <tuple>\n-#include <type_traits>\n #include <utility>\n #include <variant>\n #include <vector>\n@@ -35,7 +34,6 @@ limitations under the License.\n #include \"absl/base/log_severity.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n-#include \"absl/log/log_sink.h\"\n #include \"absl/log/scoped_mock_log.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/status/statusor.h\"\n@@ -1908,15 +1906,12 @@ ENTRY %main {\n \n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n                           ParseAndReturnVerifiedModule(kHlo, config));\n-  // absl::ScopedMockLog only works if we're actually using ABSL logging, and\n-  // TSL supports a homegrown logging implementation, so we should only check\n-  // the log is emitted when ABSL logging is used.\n+\n   absl::ScopedMockLog mock_log(absl::MockLogDefault::kIgnoreUnexpected);\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(mock_log,\n-                Log(absl::LogSeverity::kWarning, EndsWith(\"/gpu_compiler.cc\"),\n-                    StartsWith(\"Using fallback sort algorithm\")));\n-  }\n+  EXPECT_CALL(mock_log,\n+              Log(absl::LogSeverity::kWarning, EndsWith(\"/gpu_compiler.cc\"),\n+                  StartsWith(\"Using fallback sort algorithm\")));\n+\n   // StartCapturingLogs has to be called even if we expect not to capture any\n   // logs.\n   mock_log.StartCapturingLogs();"
        },
        {
            "sha": "8368e2f404561f09704db6a0118a8c616d056c1e",
            "filename": "third_party/xla/xla/service/gpu/gpu_hlo_schedule_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 11,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_hlo_schedule_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_hlo_schedule_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_hlo_schedule_test.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -22,15 +22,13 @@ limitations under the License.\n #include <optional>\n #include <string>\n #include <tuple>\n-#include <type_traits>\n #include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/algorithm/container.h\"\n #include \"absl/base/log_severity.h\"\n #include \"absl/log/log.h\"\n-#include \"absl/log/log_sink.h\"\n #include \"absl/log/scoped_mock_log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/string_view.h\"\n@@ -1809,15 +1807,10 @@ TEST_F(GpuHloScheduleTest, LogAnErrorWhenArgumentSizeExceedsMemoryLimit) {\n       auto module, ParseAndReturnVerifiedModule(kHloText, module_config));\n \n   absl::ScopedMockLog mock_log(absl::MockLogDefault::kIgnoreUnexpected);\n-  // absl::ScopedMockLog only works if we're actually using ABSL logging, and\n-  // TSL supports a homegrown logging implementation, so we should only check\n-  // the log is emitted when ABSL logging is used.\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(mock_log,\n-                Log(absl::LogSeverity::kError, _,\n-                    EndsWith(\"This indicates an error in the calculation!\")))\n-        .Times(1);\n-  }\n+  EXPECT_CALL(mock_log,\n+              Log(absl::LogSeverity::kError, _,\n+                  EndsWith(\"This indicates an error in the calculation!\")))\n+      .Times(1);\n   mock_log.StartCapturingLogs();\n   TF_ASSERT_OK_AND_ASSIGN(auto metadata, ScheduleGpuModule(module.get()));\n   EXPECT_EQ(metadata.scheduler_mem_limit, 0);"
        },
        {
            "sha": "58ca597f29a8fa33a583e17ae437868caa21cafd",
            "filename": "third_party/xla/xla/status_macros_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 17,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fstatus_macros_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Fstatus_macros_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstatus_macros_test.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -17,13 +17,11 @@ limitations under the License.\n \n #include <functional>\n #include <string>\n-#include <type_traits>\n #include <utility>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/base/log_severity.h\"\n-#include \"absl/log/log_sink.h\"\n #include \"absl/log/scoped_mock_log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n@@ -93,15 +91,10 @@ TEST(StatusMacros, RetCheckFailingWithExtraMessage) {\n }\n \n TEST(StatusMacros, RetCheckLogWarning) {\n-  // absl::ScopedMockLog only works if we're actually using ABSL logging, and\n-  // TSL supports a homegrown logging implementation, so we should only check\n-  // the log is emitted when ABSL logging is used.\n   absl::ScopedMockLog mock_log(absl::MockLogDefault::kIgnoreUnexpected);\n   const std::string kExpectedRegex = \"RET_CHECK.*1 == 2 extra message\";\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(mock_log, Log(absl::LogSeverity::kWarning, ::testing::_,\n-                              ::testing::ContainsRegex(kExpectedRegex)));\n-  }\n+  EXPECT_CALL(mock_log, Log(absl::LogSeverity::kWarning, ::testing::_,\n+                            ::testing::ContainsRegex(kExpectedRegex)));\n   mock_log.StartCapturingLogs();\n   absl::Status status =\n       RetCheckFailWithLogSeverity(absl::LogSeverity::kWarning);\n@@ -112,10 +105,8 @@ TEST(StatusMacros, RetCheckLogWarning) {\n TEST(StatusMacros, RetCheckLogInfo) {\n   absl::ScopedMockLog mock_log(absl::MockLogDefault::kIgnoreUnexpected);\n   const std::string kExpectedRegex = \"RET_CHECK.*1 == 2 extra message\";\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(mock_log, Log(absl::LogSeverity::kInfo, ::testing::_,\n-                              ::testing::ContainsRegex(kExpectedRegex)));\n-  }\n+  EXPECT_CALL(mock_log, Log(absl::LogSeverity::kInfo, ::testing::_,\n+                            ::testing::ContainsRegex(kExpectedRegex)));\n   mock_log.StartCapturingLogs();\n   absl::Status status = RetCheckFailWithLogSeverity(absl::LogSeverity::kInfo);\n   EXPECT_EQ(status.code(), tsl::error::INTERNAL);\n@@ -184,10 +175,8 @@ TEST(StatusMacros, AssignOrReturnUnsuccessfully) {\n TEST(StatusMacros, XlaRetCheckFailLogWarning) {\n   absl::ScopedMockLog mock_log(absl::MockLogDefault::kIgnoreUnexpected);\n   const std::string kExpectedLog = \"xla ret check fail message\";\n-  if constexpr (std::is_same_v<absl::LogSink, tsl::TFLogSink>) {\n-    EXPECT_CALL(mock_log, Log(absl::LogSeverity::kWarning, ::testing::_,\n-                              ::testing::HasSubstr(kExpectedLog)));\n-  }\n+  EXPECT_CALL(mock_log, Log(absl::LogSeverity::kWarning, ::testing::_,\n+                            ::testing::HasSubstr(kExpectedLog)));\n   mock_log.StartCapturingLogs();\n   absl::Status status = XlaRetCheckFailLogWarning();\n   EXPECT_EQ(status.code(), tsl::error::INTERNAL);"
        },
        {
            "sha": "f030405f0b709c823f46211d361f7b1924f0c716",
            "filename": "third_party/xla/xla/tsl/platform/BUILD",
            "status": "modified",
            "additions": 27,
            "deletions": 5,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -5,13 +5,13 @@ load(\n load(\n     \"//xla/tsl:tsl.bzl\",\n     \"if_not_fuchsia\",\n+    \"if_oss\",\n     \"internal_visibility\",\n     \"tsl_copts\",\n )\n load(\"//xla/tsl:tsl.default.bzl\", \"get_compatible_with_portable\")\n load(\n     \"//xla/tsl/platform:build_config.bzl\",\n-    \"tf_logging_deps\",\n     \"tf_platform_alias\",\n     \"tf_platform_deps\",\n     \"tf_protobuf_compiler_deps\",\n@@ -51,7 +51,6 @@ exports_files(\n         \"rocm_rocdl_path.h\",\n         \"resource_loader.h\",\n         \"file_system.cc\",\n-        \"logging.h\",\n         \"file_system.h\",\n         \"file_system_helper.cc\",\n         \"file_system_helper.h\",\n@@ -305,6 +304,7 @@ filegroup(\n     name = \"xla_cpu_runtime_srcs\",\n     srcs = [\n         \"dynamic_annotations.h\",\n+        \"env_time.h\",\n         \"macros.h\",\n     ],\n     compatible_with = get_compatible_with_portable(),\n@@ -468,12 +468,31 @@ cc_library(\n \n cc_library(\n     name = \"logging\",\n+    srcs = [\"logging.cc\"],\n+    hdrs = [\"logging.h\"],\n     compatible_with = get_compatible_with_portable(),\n-    textual_hdrs = [\"logging.h\"],\n     visibility = [\n         \"//visibility:public\",\n     ],\n-    deps = tf_logging_deps(),\n+    deps = [\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/log:globals\",\n+        \"@com_google_absl//absl/log:vlog_is_on\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ] + if_oss([\":logging_initializer\"]),\n+)\n+\n+cc_library(\n+    name = \"logging_initializer\",\n+    srcs = [\"logging_initializer.cc\"],\n+    deps = [\n+        \"@com_google_absl//absl/base:log_severity\",\n+        \"@com_google_absl//absl/log:globals\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ],\n+    alwayslink = True,\n )\n \n tsl_cc_test(\n@@ -486,11 +505,11 @@ tsl_cc_test(\n         \":logging\",\n         \":statusor\",\n         \":test\",\n-        \"@com_google_absl//absl/base:log_severity\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_googletest//:gtest\",\n         \"@local_tsl//tsl/platform:path\",\n         \"@local_tsl//tsl/platform:stacktrace_handler\",\n     ],\n@@ -518,6 +537,9 @@ cc_library(\n         \"@com_google_absl//absl/functional:function_ref\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/log:log_entry\",\n+        \"@com_google_absl//absl/log:log_sink\",\n+        \"@com_google_absl//absl/log:log_sink_registry\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:cord\","
        },
        {
            "sha": "d32012e7b09e6b7cb09013cd4cf0c0a1ea3acb63",
            "filename": "third_party/xla/xla/tsl/platform/build_config.bzl",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fbuild_config.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fbuild_config.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fbuild_config.bzl?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -23,7 +23,6 @@ load(\n     _tf_google_mobile_srcs_only_runtime = \"tf_google_mobile_srcs_only_runtime\",\n     _tf_jspb_proto_library = \"tf_jspb_proto_library\",\n     _tf_lib_proto_parsing_deps = \"tf_lib_proto_parsing_deps\",\n-    _tf_logging_deps = \"tf_logging_deps\",\n     _tf_platform_alias = \"tf_platform_alias\",\n     _tf_platform_deps = \"tf_platform_deps\",\n     _tf_portable_deps_no_runtime = \"tf_portable_deps_no_runtime\",\n@@ -62,7 +61,6 @@ tf_google_mobile_srcs_no_runtime = _tf_google_mobile_srcs_no_runtime\n tf_google_mobile_srcs_only_runtime = _tf_google_mobile_srcs_only_runtime\n tf_jspb_proto_library = _tf_jspb_proto_library\n tf_lib_proto_parsing_deps = _tf_lib_proto_parsing_deps\n-tf_logging_deps = _tf_logging_deps\n tf_platform_alias = _tf_platform_alias\n tf_platform_deps = _tf_platform_deps\n tf_portable_proto_lib = _tf_portable_proto_lib"
        },
        {
            "sha": "00c171cce5063f54ccc46f747a7cef701dc650bc",
            "filename": "third_party/xla/xla/tsl/platform/default/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2FBUILD?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -292,32 +292,6 @@ cc_library(\n     ]),\n )\n \n-cc_library(\n-    name = \"logging\",\n-    srcs = [\"logging.cc\"],\n-    hdrs = [\"//xla/tsl/platform:logging.h\"],\n-    tags = [\n-        \"manual\",\n-        \"no_oss\",\n-        \"nobuilder\",\n-    ],\n-    textual_hdrs = [\"logging.h\"],\n-    deps = [\n-        \"//xla/tsl/platform:env_time\",\n-        \"//xla/tsl/platform:macros\",\n-        \"//xla/tsl/platform:types\",\n-        \"@com_google_absl//absl/base\",\n-        \"@com_google_absl//absl/base:core_headers\",\n-        \"@com_google_absl//absl/base:log_severity\",\n-        \"@com_google_absl//absl/container:flat_hash_map\",\n-        \"@com_google_absl//absl/strings\",\n-        \"@com_google_absl//absl/strings:str_format\",\n-        \"@com_google_absl//absl/strings:string_view\",\n-        \"@com_google_absl//absl/synchronization\",\n-        \"@local_tsl//tsl/platform\",\n-    ],\n-)\n-\n filegroup(\n     name = \"xla_cpu_runtime_srcs\",\n     srcs = [\n@@ -663,7 +637,6 @@ exports_files(\n         [\"*\"],\n         exclude = [\n             \"integral_types.h\",\n-            \"logging.h\",\n             \"test.cc\",\n         ],\n     ),\n@@ -673,7 +646,6 @@ exports_files(\n exports_files(\n     srcs = [\n         \"integral_types.h\",\n-        \"logging.h\",\n         \"test.cc\",\n     ],\n     visibility = internal_visibility(["
        },
        {
            "sha": "93d1d7e4128a71440f1f178fc9ed41da914e18ea",
            "filename": "third_party/xla/xla/tsl/platform/default/build_config.bzl",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Fbuild_config.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Fbuild_config.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Fbuild_config.bzl?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -318,7 +318,6 @@ def tf_additional_lib_hdrs():\n         clean_dep(\"//xla/tsl/platform/default:context.h\"),\n         clean_dep(\"//xla/tsl/platform/default:criticality.h\"),\n         clean_dep(\"//xla/tsl/platform/default:integral_types.h\"),\n-        clean_dep(\"//xla/tsl/platform/default:logging.h\"),\n         clean_dep(\"//xla/tsl/platform/default:stacktrace.h\"),\n         clean_dep(\"//xla/tsl/platform/default:status.h\"),\n         clean_dep(\"//xla/tsl/platform/default:statusor.h\"),\n@@ -549,9 +548,6 @@ def tf_stream_executor_deps(name, platform_dir = \"@local_xla//xla/tsl/platform/\"\n def tf_platform_alias(name, platform_dir = \"@local_xla//xla/tsl/platform/\"):\n     return [platform_dir + \"default:\" + name]\n \n-def tf_logging_deps():\n-    return [clean_dep(\"//xla/tsl/platform/default:logging\")]\n-\n def tf_error_logging_deps():\n     return [clean_dep(\"//xla/tsl/platform/default:error_logging\")]\n "
        },
        {
            "sha": "14b3f1afc4b090c10a779726e0752ed8056c78bf",
            "filename": "third_party/xla/xla/tsl/platform/default/logging.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 568,
            "changes": 568,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c56ab243cf23106edd0ddece64cc1966bc401100/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Flogging.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c56ab243cf23106edd0ddece64cc1966bc401100/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Flogging.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Flogging.cc?ref=c56ab243cf23106edd0ddece64cc1966bc401100",
            "patch": "@@ -1,568 +0,0 @@\n-/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/tsl/platform/default/logging.h\"\n-\n-#include <atomic>\n-#include <cassert>\n-#include <cstddef>\n-#include <cstdint>\n-#include <cstdio>\n-#include <limits>\n-#include <ostream>\n-#include <vector>\n-\n-// TODO(b/142492876): Avoid depending on absl internal.\n-#include \"absl/base/internal/cycleclock.h\"\n-#include \"absl/base/internal/sysinfo.h\"\n-#include \"absl/base/log_severity.h\"\n-#include \"absl/base/optimization.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/strings/numbers.h\"\n-#include \"absl/strings/str_format.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"absl/synchronization/mutex.h\"\n-#include \"xla/tsl/platform/env_time.h\"\n-#include \"xla/tsl/platform/types.h\"\n-\n-#if defined(PLATFORM_POSIX_ANDROID)\n-#include <android/log.h>\n-\n-#include <iostream>\n-#include <sstream>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <time.h>\n-\n-#include <algorithm>\n-#include <queue>\n-\n-namespace tsl {\n-\n-namespace internal {\n-namespace {\n-\n-// This is an internal singleton class that manages the log sinks. It allows\n-// adding and removing the log sinks, as well as handling sending log messages\n-// to all the registered log sinks.\n-class TFLogSinks {\n- public:\n-  // Gets the TFLogSinks instance. This is the entry point for using this class.\n-  static TFLogSinks& Instance();\n-\n-  // Adds a log sink. The sink argument must not be a nullptr. TFLogSinks\n-  // takes ownership of the pointer, the user must not free the pointer.\n-  // The pointer will remain valid until the application terminates or\n-  // until TFLogSinks::Remove is called for the same pointer value.\n-  void Add(TFLogSink* sink);\n-\n-  // Removes a log sink. This will also erase the sink object. The pointer\n-  // to the sink becomes invalid after this call.\n-  void Remove(TFLogSink* sink);\n-\n-  // Gets the currently registered log sinks.\n-  std::vector<TFLogSink*> GetSinks() const;\n-\n-  // Sends a log message to all registered log sinks.\n-  //\n-  // If there are no log sinks are registered:\n-  //\n-  // NO_DEFAULT_LOGGER is defined:\n-  // Up to 128 messages will be queued until a log sink is added.\n-  // The queue will then be logged to the first added log sink.\n-  //\n-  // NO_DEFAULT_LOGGER is not defined:\n-  // The messages will be logged using the default logger. The default logger\n-  // will log to stdout on all platforms except for Android. On Androit the\n-  // default Android logger will be used.\n-  void Send(const TFLogEntry& entry);\n-\n- private:\n-  TFLogSinks();\n-  void SendToSink(TFLogSink& sink, const TFLogEntry& entry);\n-\n-  std::queue<TFLogEntry> log_entry_queue_;\n-  static const size_t kMaxLogEntryQueueSize = 128;\n-\n-  mutable absl::Mutex mutex_;\n-  std::vector<TFLogSink*> sinks_;\n-};\n-\n-TFLogSinks::TFLogSinks() {\n-#ifndef NO_DEFAULT_LOGGER\n-  static TFDefaultLogSink* const default_sink = new TFDefaultLogSink();\n-  sinks_.push_back(default_sink);\n-#endif\n-}\n-\n-TFLogSinks& TFLogSinks::Instance() {\n-  static TFLogSinks* const instance = new TFLogSinks();\n-  return *instance;\n-}\n-\n-void TFLogSinks::Add(TFLogSink* sink) {\n-  assert(sink != nullptr && \"The sink must not be a nullptr\");\n-\n-  absl::MutexLock lock(&mutex_);\n-  sinks_.push_back(sink);\n-\n-  // If this is the only sink log all the queued up messages to this sink\n-  if (sinks_.size() == 1) {\n-    while (!log_entry_queue_.empty()) {\n-      for (const auto& sink : sinks_) {\n-        SendToSink(*sink, log_entry_queue_.front());\n-      }\n-      log_entry_queue_.pop();\n-    }\n-  }\n-}\n-\n-void TFLogSinks::Remove(TFLogSink* sink) {\n-  assert(sink != nullptr && \"The sink must not be a nullptr\");\n-\n-  absl::MutexLock lock(&mutex_);\n-  auto it = std::find(sinks_.begin(), sinks_.end(), sink);\n-  if (it != sinks_.end()) sinks_.erase(it);\n-}\n-\n-std::vector<TFLogSink*> TFLogSinks::GetSinks() const {\n-  absl::MutexLock lock(&mutex_);\n-  return sinks_;\n-}\n-\n-void TFLogSinks::Send(const TFLogEntry& entry) {\n-  absl::MutexLock lock(&mutex_);\n-\n-  // If we don't have any sinks registered, queue them up\n-  if (sinks_.empty()) {\n-    // If we've exceeded the maximum queue size, drop the oldest entries\n-    while (log_entry_queue_.size() >= kMaxLogEntryQueueSize) {\n-      log_entry_queue_.pop();\n-    }\n-    log_entry_queue_.push(entry);\n-    return;\n-  }\n-\n-  // If we have items in the queue, push them out first\n-  while (!log_entry_queue_.empty()) {\n-    for (const auto& sink : sinks_) {\n-      SendToSink(*sink, log_entry_queue_.front());\n-    }\n-    log_entry_queue_.pop();\n-  }\n-\n-  // ... and now we can log the current log entry\n-  for (const auto& sink : sinks_) {\n-    SendToSink(*sink, entry);\n-  }\n-}\n-\n-void TFLogSinks::SendToSink(TFLogSink& sink, const TFLogEntry& entry) {\n-  sink.Send(entry);\n-  sink.WaitTillSent();\n-}\n-\n-// A class for managing the text file to which VLOG output is written.\n-// If the environment variable TF_CPP_VLOG_FILENAME is set, all VLOG\n-// calls are redirected from stderr to a file with corresponding name.\n-class VlogFileMgr {\n- public:\n-  // Determines if the env variable is set and if necessary\n-  // opens the file for write access.\n-  VlogFileMgr();\n-  // Closes the file.\n-  ~VlogFileMgr();\n-  // Returns either a pointer to the file or stderr.\n-  FILE* FilePtr() const;\n-\n- private:\n-  FILE* vlog_file_ptr;\n-  char* vlog_file_name;\n-};\n-\n-VlogFileMgr::VlogFileMgr() {\n-  vlog_file_name = getenv(\"TF_CPP_VLOG_FILENAME\");\n-  vlog_file_ptr =\n-      vlog_file_name == nullptr ? nullptr : fopen(vlog_file_name, \"w\");\n-\n-  if (vlog_file_ptr == nullptr) {\n-    vlog_file_ptr = stderr;\n-  }\n-}\n-\n-VlogFileMgr::~VlogFileMgr() {\n-  if (vlog_file_ptr != stderr) {\n-    fclose(vlog_file_ptr);\n-  }\n-}\n-\n-FILE* VlogFileMgr::FilePtr() const { return vlog_file_ptr; }\n-\n-int ParseInteger(absl::string_view str) {\n-  int level;\n-  if (!absl::SimpleAtoi(str, &level)) {\n-    return 0;\n-  }\n-  return level;\n-}\n-\n-// Parse log level (int64) from environment variable (char*)\n-int64_t LogLevelStrToInt(const char* tf_env_var_val) {\n-  if (tf_env_var_val == nullptr) {\n-    return 0;\n-  }\n-  return ParseInteger(tf_env_var_val);\n-}\n-\n-using VmoduleMap = absl::flat_hash_map<absl::string_view, int>;\n-\n-// Returns a mapping from module name to VLOG level, derived from the\n-// TF_CPP_VMODULE environment variable; ownership is transferred to the caller.\n-VmoduleMap* VmodulesMapFromEnv() {\n-  // The value of the env var is supposed to be of the form:\n-  //    \"foo=1,bar=2,baz=3\"\n-  const char* env = getenv(\"TF_CPP_VMODULE\");\n-  if (env == nullptr) {\n-    // If there is no TF_CPP_VMODULE configuration (most common case), return\n-    // nullptr so that the ShouldVlogModule() API can fast bail out of it.\n-    return nullptr;\n-  }\n-  // The memory returned by getenv() can be invalidated by following getenv() or\n-  // setenv() calls. And since we keep references to it in the VmoduleMap in\n-  // form of StringData objects, make a copy of it.\n-  const char* env_data = strdup(env);\n-  absl::string_view env_view(env_data);\n-  VmoduleMap* result = new VmoduleMap();\n-  while (!env_view.empty()) {\n-    size_t eq_pos = env_view.find('=');\n-    if (eq_pos == absl::string_view::npos) {\n-      break;\n-    }\n-    absl::string_view module_name = env_view.substr(0, eq_pos);\n-    env_view.remove_prefix(eq_pos + 1);\n-\n-    // Comma either points at the next comma delimiter, or at a null terminator.\n-    // We check that the integer we parse ends at this delimiter.\n-    size_t level_end_pos = env_view.find(',');\n-    absl::string_view level_str = env_view.substr(0, level_end_pos);\n-    (*result)[module_name] = ParseInteger(level_str);\n-    if (level_end_pos != absl::string_view::npos) {\n-      env_view.remove_prefix(level_end_pos + 1);\n-    }\n-  }\n-  return result;\n-}\n-\n-bool EmitThreadIdFromEnv() {\n-  const char* tf_env_var_val = getenv(\"TF_CPP_LOG_THREAD_ID\");\n-  return tf_env_var_val == nullptr ? false : ParseInteger(tf_env_var_val) != 0;\n-}\n-\n-}  // namespace\n-\n-absl::LogSeverityAtLeast MinLogLevelFromEnv() {\n-  // We don't want to print logs during fuzzing as that would slow fuzzing down\n-  // by almost 2x. So, if we are in fuzzing mode (not just running a test), we\n-  // return a value so that nothing is actually printed. Since LOG uses >=\n-  // (see ~LogMessage in this file) to see if log messages need to be printed,\n-  // the value we're interested on to disable printing is the maximum severity.\n-  // See also http://llvm.org/docs/LibFuzzer.html#fuzzer-friendly-build-mode\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-  return absl::LogSeverityAtLeast::kInfinity;\n-#else\n-  const char* tf_env_var_val = getenv(\"TF_CPP_MIN_LOG_LEVEL\");\n-  return static_cast<absl::LogSeverityAtLeast>(\n-      LogLevelStrToInt(tf_env_var_val));\n-#endif\n-}\n-\n-int MaxVLogLevelFromEnv() {\n-  // We don't want to print logs during fuzzing as that would slow fuzzing down\n-  // by almost 2x. So, if we are in fuzzing mode (not just running a test), we\n-  // return a value so that nothing is actually printed. Since VLOG uses <=\n-  // (see VLOG_IS_ON in logging.h) to see if log messages need to be printed,\n-  // the value we're interested on to disable printing is 0.\n-  // See also http://llvm.org/docs/LibFuzzer.html#fuzzer-friendly-build-mode\n-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n-  return 0;\n-#else\n-  const char* tf_env_var_val = getenv(\"TF_CPP_MAX_VLOG_LEVEL\");\n-  return LogLevelStrToInt(tf_env_var_val);\n-#endif\n-}\n-\n-LogMessage::LogMessage(const char* fname, int line, absl::LogSeverity severity)\n-    : fname_(fname), line_(line), severity_(severity) {}\n-\n-LogMessage& LogMessage::AtLocation(absl::string_view fname, int line) {\n-  fname_ = fname;\n-  line_ = line;\n-  return *this;\n-}\n-\n-LogMessage::~LogMessage() {\n-  // Read the min log level once during the first call to logging.\n-  static absl::LogSeverityAtLeast min_log_level = MinLogLevelFromEnv();\n-  if (severity_ >= min_log_level) {\n-    GenerateLogMessage();\n-  }\n-}\n-\n-void LogMessage::GenerateLogMessage() {\n-  TFLogSinks::Instance().Send(TFLogEntry(severity_, fname_, line_, str()));\n-}\n-\n-int LogMessage::MaxVLogLevel() {\n-  static int max_vlog_level = MaxVLogLevelFromEnv();\n-  return max_vlog_level;\n-}\n-\n-bool LogMessage::VmoduleActivated(const char* fname, int level) {\n-  if (level <= MaxVLogLevel()) {\n-    return true;\n-  }\n-  static VmoduleMap* vmodules = VmodulesMapFromEnv();\n-  if (ABSL_PREDICT_TRUE(vmodules == nullptr)) {\n-    return false;\n-  }\n-  absl::string_view module(fname);\n-  if (size_t last_slash = module.rfind('/');\n-      last_slash != absl::string_view::npos) {\n-    module.remove_prefix(last_slash + 1);\n-  }\n-  if (size_t dot_after = module.find('.');\n-      dot_after != absl::string_view::npos) {\n-    module.remove_suffix(module.size() - dot_after);\n-  }\n-  auto it = vmodules->find(module);\n-  return it != vmodules->end() && it->second >= level;\n-}\n-\n-LogMessageFatal::LogMessageFatal(const char* file, int line)\n-    : LogMessage(file, line, absl::LogSeverity::kFatal) {}\n-LogMessageFatal::~LogMessageFatal() {\n-  // abort() ensures we don't return (we promised we would not via\n-  // ATTRIBUTE_NORETURN).\n-  GenerateLogMessage();\n-  abort();\n-}\n-\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const char& v) {\n-  if (v >= 32 && v <= 126) {\n-    (*os) << \"'\" << v << \"'\";\n-  } else {\n-    (*os) << \"char value \" << static_cast<int16>(v);\n-  }\n-}\n-\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const signed char& v) {\n-  if (v >= 32 && v <= 126) {\n-    (*os) << \"'\" << v << \"'\";\n-  } else {\n-    (*os) << \"signed char value \" << static_cast<int16>(v);\n-  }\n-}\n-\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const unsigned char& v) {\n-  if (v >= 32 && v <= 126) {\n-    (*os) << \"'\" << v << \"'\";\n-  } else {\n-    (*os) << \"unsigned char value \" << static_cast<uint16>(v);\n-  }\n-}\n-\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const std::nullptr_t& v) {\n-  (*os) << \"nullptr\";\n-}\n-\n-CheckOpMessageBuilder::CheckOpMessageBuilder(const char* exprtext)\n-    : stream_(new std::ostringstream) {\n-  *stream_ << \"Check failed: \" << exprtext << \" (\";\n-}\n-\n-CheckOpMessageBuilder::~CheckOpMessageBuilder() { delete stream_; }\n-\n-std::ostream* CheckOpMessageBuilder::ForVar2() {\n-  *stream_ << \" vs. \";\n-  return stream_;\n-}\n-\n-string* CheckOpMessageBuilder::NewString() {\n-  *stream_ << \")\";\n-  return new string(stream_->str());\n-}\n-\n-namespace {\n-// The following code behaves like AtomicStatsCounter::LossyAdd() for\n-// speed since it is fine to lose occasional updates.\n-// Returns old value of *counter.\n-uint32 LossyIncrement(std::atomic<uint32>* counter) {\n-  const uint32 value = counter->load(std::memory_order_relaxed);\n-  counter->store(value + 1, std::memory_order_relaxed);\n-  return value;\n-}\n-}  // namespace\n-\n-bool LogEveryNState::ShouldLog(int n) {\n-  return n != 0 && (LossyIncrement(&counter_) % n) == 0;\n-}\n-\n-bool LogFirstNState::ShouldLog(int n) {\n-  const int counter_value =\n-      static_cast<int>(counter_.load(std::memory_order_relaxed));\n-  if (counter_value < n) {\n-    counter_.store(counter_value + 1, std::memory_order_relaxed);\n-    return true;\n-  }\n-  return false;\n-}\n-\n-bool LogEveryPow2State::ShouldLog(int ignored) {\n-  const uint32 new_value = LossyIncrement(&counter_) + 1;\n-  return (new_value & (new_value - 1)) == 0;\n-}\n-\n-bool LogEveryNSecState::ShouldLog(double seconds) {\n-  LossyIncrement(&counter_);\n-  const int64_t now_cycles = absl::base_internal::CycleClock::Now();\n-  int64_t next_cycles = next_log_time_cycles_.load(std::memory_order_relaxed);\n-  do {\n-    if (now_cycles <= next_cycles) return false;\n-  } while (!next_log_time_cycles_.compare_exchange_weak(\n-      next_cycles,\n-      now_cycles + seconds * absl::base_internal::CycleClock::Frequency(),\n-      std::memory_order_relaxed, std::memory_order_relaxed));\n-  return true;\n-}\n-\n-}  // namespace internal\n-\n-void TFAddLogSink(TFLogSink* sink) {\n-  internal::TFLogSinks::Instance().Add(sink);\n-}\n-\n-void TFRemoveLogSink(TFLogSink* sink) {\n-  internal::TFLogSinks::Instance().Remove(sink);\n-}\n-\n-std::vector<TFLogSink*> TFGetLogSinks() {\n-  return internal::TFLogSinks::Instance().GetSinks();\n-}\n-\n-void TFDefaultLogSink::Send(const TFLogEntry& entry) {\n-#ifdef PLATFORM_POSIX_ANDROID\n-  int android_log_level;\n-  switch (entry.log_severity()) {\n-    case absl::LogSeverity::kInfo:\n-      android_log_level = ANDROID_LOG_INFO;\n-      break;\n-    case absl::LogSeverity::kWarning:\n-      android_log_level = ANDROID_LOG_WARN;\n-      break;\n-    case absl::LogSeverity::kError:\n-      android_log_level = ANDROID_LOG_ERROR;\n-      break;\n-    case absl::LogSeverity::kFatal:\n-      android_log_level = ANDROID_LOG_FATAL;\n-      break;\n-    default:\n-      if (entry.log_severity() < absl::LogSeverity::kInfo) {\n-        android_log_level = ANDROID_LOG_VERBOSE;\n-      } else {\n-        android_log_level = ANDROID_LOG_ERROR;\n-      }\n-      break;\n-  }\n-\n-  std::stringstream ss;\n-  const auto& fname = entry.FName();\n-  auto pos = fname.find(\"/\");\n-  ss << (pos != std::string::npos ? fname.substr(pos + 1) : fname) << \":\"\n-     << entry.Line() << \" \" << entry.ToString();\n-  __android_log_write(android_log_level, \"native\", ss.str().c_str());\n-\n-  // Also log to stderr (for standalone Android apps).\n-  // Don't use 'std::cerr' since it crashes on Android.\n-  fprintf(stderr, \"native : %s\\n\", ss.str().c_str());\n-\n-  // Android logging at level FATAL does not terminate execution, so abort()\n-  // is still required to stop the program.\n-  if (entry.log_severity() == absl::LogSeverity::kFatal) {\n-    abort();\n-  }\n-#else   // PLATFORM_POSIX_ANDROID\n-  static const internal::VlogFileMgr vlog_file;\n-  static bool log_thread_id = internal::EmitThreadIdFromEnv();\n-  uint64_t now_micros = EnvTime::NowMicros();\n-  time_t now_seconds = static_cast<time_t>(now_micros / 1000000);\n-  int32_t micros_remainder = static_cast<int32_t>(now_micros % 1000000);\n-  const size_t time_buffer_size = 30;\n-  char time_buffer[time_buffer_size];\n-  struct tm* tp;\n-#if defined(__linux__) || defined(__APPLE__)\n-  struct tm now_tm;\n-  tp = localtime_r(&now_seconds, &now_tm);\n-#else\n-  tp = localtime(&now_seconds);  // NOLINT(runtime/threadsafe_fn)\n-#endif\n-  strftime(time_buffer, time_buffer_size, \"%Y-%m-%d %H:%M:%S\", tp);\n-  uint64_t tid = absl::base_internal::GetTID();\n-  constexpr size_t kTidBufferSize =\n-      (1 + std::numeric_limits<uint64_t>::digits10 + 1);\n-  char tid_buffer[kTidBufferSize] = \"\";\n-  if (log_thread_id) {\n-    absl::SNPrintF(tid_buffer, sizeof(tid_buffer), \" %7u\", tid);\n-  }\n-\n-  char sev;\n-  switch (entry.log_severity()) {\n-    case absl::LogSeverity::kInfo:\n-      sev = 'I';\n-      break;\n-\n-    case absl::LogSeverity::kWarning:\n-      sev = 'W';\n-      break;\n-\n-    case absl::LogSeverity::kError:\n-      sev = 'E';\n-      break;\n-\n-    case absl::LogSeverity::kFatal:\n-      sev = 'F';\n-      break;\n-\n-    default:\n-      assert(false && \"Unknown logging severity\");\n-      sev = '?';\n-      break;\n-  }\n-\n-  absl::FPrintF(vlog_file.FilePtr(), \"%s.%06d: %c%s %s:%d] %s\\n\", time_buffer,\n-                micros_remainder, sev, tid_buffer, entry.FName().c_str(),\n-                entry.Line(), entry.ToString().c_str());\n-  fflush(vlog_file.FilePtr());  // Ensure logs are written immediately.\n-#endif  // PLATFORM_POSIX_ANDROID\n-}\n-\n-void UpdateLogVerbosityIfDefined(const char* env_var) {}\n-\n-}  // namespace tsl"
        },
        {
            "sha": "a8137d152e2929d13478d72299708983ee4cfbaa",
            "filename": "third_party/xla/xla/tsl/platform/default/logging.h",
            "status": "removed",
            "additions": 0,
            "deletions": 635,
            "changes": 635,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c56ab243cf23106edd0ddece64cc1966bc401100/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Flogging.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c56ab243cf23106edd0ddece64cc1966bc401100/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Flogging.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fdefault%2Flogging.h?ref=c56ab243cf23106edd0ddece64cc1966bc401100",
            "patch": "@@ -1,635 +0,0 @@\n-/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#if defined(_WIN32)\n-// prevent compile error because MSVC doesn't realize in debug build that\n-// LOG(FATAL) finally invokes abort()\n-#pragma warning(disable : 4716)\n-#endif  // _WIN32\n-\n-#ifndef XLA_TSL_PLATFORM_DEFAULT_LOGGING_H_\n-#define XLA_TSL_PLATFORM_DEFAULT_LOGGING_H_\n-\n-// IWYU pragma: private, include \"xla/tsl/platform/logging.h\"\n-// IWYU pragma: friend third_party/tensorflow/compiler/xla/tsl/platform/logging.h\n-\n-#include <atomic>\n-#include <limits>\n-#include <memory>\n-#include <sstream>\n-#include <string>\n-#include <vector>\n-\n-#include \"absl/base/log_severity.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"xla/tsl/platform/macros.h\"\n-#include \"xla/tsl/platform/types.h\"\n-\n-// TODO(mrry): Prevent this Windows.h #define from leaking out of our headers.\n-#undef ERROR\n-\n-// Undef everything in case we're being mixed with some other Google library\n-// which already defined them itself.  Presumably all Google libraries will\n-// support the same syntax for these so it should not be a big deal if they\n-// end up using our definitions instead.\n-#undef LOG\n-#undef LOG_EVERY_N\n-#undef LOG_FIRST_N\n-#undef LOG_EVERY_POW_2\n-#undef LOG_EVERY_N_SEC\n-#undef VLOG\n-\n-#undef CHECK\n-#undef CHECK_EQ\n-#undef CHECK_NE\n-#undef CHECK_LT\n-#undef CHECK_LE\n-#undef CHECK_GT\n-#undef CHECK_GE\n-\n-#undef DCHECK\n-#undef DCHECK_EQ\n-#undef DCHECK_NE\n-#undef DCHECK_LT\n-#undef DCHECK_LE\n-#undef DCHECK_GT\n-#undef DCHECK_GE\n-\n-#undef QCHECK\n-#undef QCHECK_EQ\n-#undef QCHECK_NE\n-#undef QCHECK_LT\n-#undef QCHECK_LE\n-#undef QCHECK_GT\n-#undef QCHECK_GE\n-\n-#undef PCHECK\n-\n-namespace tsl {\n-\n-namespace internal {\n-\n-class LogMessage : public std::basic_ostringstream<char> {\n- public:\n-  LogMessage(const char* fname, int line, absl::LogSeverity severity);\n-  ~LogMessage() override;\n-\n-  // Change the location of the log message.\n-  LogMessage& AtLocation(absl::string_view fname, int line);\n-\n-  // Returns the maximum log level for VLOG statements.\n-  // E.g., if MaxVLogLevel() is 2, then VLOG(2) statements will produce output,\n-  // but VLOG(3) will not. Defaults to 0.\n-  static int MaxVLogLevel();\n-\n-  // Returns whether VLOG level lvl is activated for the file fname.\n-  //\n-  // E.g. if the environment variable TF_CPP_VMODULE contains foo=3 and fname is\n-  // foo.cc and lvl is <= 3, this will return true. It will also return true if\n-  // the level is lower or equal to TF_CPP_MAX_VLOG_LEVEL (default zero).\n-  //\n-  // It is expected that the result of this query will be cached in the VLOG-ing\n-  // call site to avoid repeated lookups. This routine performs a hash-map\n-  // access against the VLOG-ing specification provided by the env var.\n-  static bool VmoduleActivated(const char* fname, int level);\n-\n- protected:\n-  void GenerateLogMessage();\n-\n- private:\n-  absl::string_view fname_;\n-  int line_;\n-  absl::LogSeverity severity_;\n-};\n-\n-// Uses the lower operator & precedence to voidify a LogMessage reference, so\n-// that the ternary VLOG() implementation is balanced, type wise.\n-struct Voidifier {\n-  template <typename T>\n-  void operator&(const T&) const {}\n-};\n-\n-// LogMessageFatal ensures the process will exit in failure after\n-// logging this message.\n-class LogMessageFatal : public LogMessage {\n- public:\n-  LogMessageFatal(const char* file, int line) TF_ATTRIBUTE_COLD;\n-  TF_ATTRIBUTE_NORETURN ~LogMessageFatal() override;\n-};\n-\n-// LogMessageNull supports the DVLOG macro by simply dropping any log messages.\n-class LogMessageNull : public std::basic_ostringstream<char> {\n- public:\n-  LogMessageNull() = default;\n-  ~LogMessageNull() override {}\n-};\n-\n-#define _TF_LOG_INFO \\\n-  ::tsl::internal::LogMessage(__FILE__, __LINE__, absl::LogSeverity::kInfo)\n-#define _TF_LOG_WARNING \\\n-  ::tsl::internal::LogMessage(__FILE__, __LINE__, absl::LogSeverity::kWarning)\n-#define _TF_LOG_ERROR \\\n-  ::tsl::internal::LogMessage(__FILE__, __LINE__, absl::LogSeverity::kError)\n-#define _TF_LOG_FATAL ::tsl::internal::LogMessageFatal(__FILE__, __LINE__)\n-\n-#define _TF_LOG_QFATAL _TF_LOG_FATAL\n-\n-#ifdef NDEBUG\n-#define _TF_LOG_DFATAL _TF_LOG_ERROR\n-#else\n-#define _TF_LOG_DFATAL _TF_LOG_FATAL\n-#endif\n-\n-#define LOG(severity) _TF_LOG_##severity\n-\n-#ifdef IS_MOBILE_PLATFORM\n-\n-// Turn VLOG off when under mobile devices for considerations of binary size.\n-#define VLOG_IS_ON(lvl) ((lvl) <= 0)\n-\n-#else\n-\n-// Otherwise, set TF_CPP_MAX_VLOG_LEVEL environment to update minimum log level\n-// of VLOG, or TF_CPP_VMODULE to set the minimum log level for individual\n-// translation units.\n-#define VLOG_IS_ON(lvl)                                              \\\n-  (([](int level, const char* fname) {                               \\\n-    static const bool vmodule_activated =                            \\\n-        ::tsl::internal::LogMessage::VmoduleActivated(fname, level); \\\n-    return vmodule_activated;                                        \\\n-  })(lvl, __FILE__))\n-\n-#endif\n-\n-#define VLOG(level)                                       \\\n-  TF_PREDICT_TRUE(!VLOG_IS_ON(level))                     \\\n-  ? (void)0                                               \\\n-  : ::tsl::internal::Voidifier() &                        \\\n-          ::tsl::internal::LogMessage(__FILE__, __LINE__, \\\n-                                      absl::LogSeverity::kInfo)\n-\n-// `DVLOG` behaves like `VLOG` in debug mode (i.e. `#ifndef NDEBUG`).\n-// Otherwise, it compiles away and does nothing.\n-#ifndef NDEBUG\n-#define DVLOG VLOG\n-#else\n-#define DVLOG(verbose_level) \\\n-  while (false && (verbose_level) > 0) ::tsl::internal::LogMessageNull()\n-#endif\n-\n-class LogEveryNState {\n- public:\n-  bool ShouldLog(int n);\n-  uint32_t counter() { return counter_.load(std::memory_order_relaxed); }\n-\n- private:\n-  std::atomic<uint32> counter_{0};\n-};\n-\n-class LogFirstNState {\n- public:\n-  bool ShouldLog(int n);\n-  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n-\n- private:\n-  std::atomic<uint32> counter_{0};\n-};\n-\n-class LogEveryPow2State {\n- public:\n-  bool ShouldLog(int ignored);\n-  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n-\n- private:\n-  std::atomic<uint32> counter_{0};\n-};\n-\n-class LogEveryNSecState {\n- public:\n-  bool ShouldLog(double seconds);\n-  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n-\n- private:\n-  std::atomic<uint32> counter_{0};\n-  // Cycle count according to CycleClock that we should next log at.\n-  std::atomic<int64_t> next_log_time_cycles_{0};\n-};\n-\n-// This macro has a lot going on!\n-//\n-// * A local static (`logging_internal_stateful_condition_state`) is\n-//   declared in a scope such that each `LOG_EVERY_N` (etc.) line has its own\n-//   state.\n-// * `COUNTER`, the third variable, is used to support `<< COUNTER`. It is not\n-//   mangled, so shadowing can be a problem, albeit more of a\n-//   shoot-yourself-in-the-foot one.  Don't name your variables `COUNTER`.\n-// * A single for loop can declare state and also test\n-//   `condition && state.ShouldLog()`, but there's no way to constrain it to run\n-//   only once (or not at all) without declaring another variable.  The outer\n-//   for-loop declares this variable (`do_log`).\n-// * Using for loops instead of if statements means there's no risk of an\n-//   ambiguous dangling else statement.\n-#define LOGGING_INTERNAL_STATEFUL_CONDITION(kind, condition, arg)   \\\n-  for (bool logging_internal_stateful_condition_do_log(condition);  \\\n-       logging_internal_stateful_condition_do_log;                  \\\n-       logging_internal_stateful_condition_do_log = false)          \\\n-    for (static ::tsl::internal::Log##kind##State                   \\\n-             logging_internal_stateful_condition_state;             \\\n-         logging_internal_stateful_condition_do_log &&              \\\n-         logging_internal_stateful_condition_state.ShouldLog(arg);  \\\n-         logging_internal_stateful_condition_do_log = false)        \\\n-      for (const uint32_t COUNTER ABSL_ATTRIBUTE_UNUSED =           \\\n-               logging_internal_stateful_condition_state.counter(); \\\n-           logging_internal_stateful_condition_do_log;              \\\n-           logging_internal_stateful_condition_do_log = false)\n-\n-// An instance of `LOG_EVERY_N` increments a hidden zero-initialized counter\n-// every time execution passes through it and logs the specified message when\n-// the counter's value is a multiple of `n`, doing nothing otherwise.  Each\n-// instance has its own counter.  The counter's value can be logged by streaming\n-// the symbol `COUNTER`.  `LOG_EVERY_N` is thread-safe.\n-// Example:\n-//\n-//   for (const auto& user : all_users) {\n-//     LOG_EVERY_N(INFO, 1000) << \"Processing user #\" << COUNTER;\n-//     ProcessUser(user);\n-//   }\n-#define LOG_EVERY_N(severity, n)                       \\\n-  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryN, true, n) \\\n-  LOG(severity)\n-// `LOG_FIRST_N` behaves like `LOG_EVERY_N` except that the specified message is\n-// logged when the counter's value is less than `n`.  `LOG_FIRST_N` is\n-// thread-safe.\n-#define LOG_FIRST_N(severity, n)                       \\\n-  LOGGING_INTERNAL_STATEFUL_CONDITION(FirstN, true, n) \\\n-  LOG(severity)\n-// `LOG_EVERY_POW_2` behaves like `LOG_EVERY_N` except that the specified\n-// message is logged when the counter's value is a power of 2.\n-// `LOG_EVERY_POW_2` is thread-safe.\n-#define LOG_EVERY_POW_2(severity)                         \\\n-  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryPow2, true, 0) \\\n-  LOG(severity)\n-// An instance of `LOG_EVERY_N_SEC` uses a hidden state variable to log the\n-// specified message at most once every `n_seconds`.  A hidden counter of\n-// executions (whether a message is logged or not) is also maintained and can be\n-// logged by streaming the symbol `COUNTER`.  `LOG_EVERY_N_SEC` is thread-safe.\n-// Example:\n-//\n-//   LOG_EVERY_N_SEC(INFO, 2.5) << \"Got \" << COUNTER << \" cookies so far\";\n-#define LOG_EVERY_N_SEC(severity, n_seconds)                      \\\n-  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryNSec, true, n_seconds) \\\n-  LOG(severity)\n-\n-// CHECK dies with a fatal error if condition is not true.  It is *not*\n-// controlled by NDEBUG, so the check will be executed regardless of\n-// compilation mode.  Therefore, it is safe to do things like:\n-//    CHECK(fp->Write(x) == 4)\n-#define CHECK(condition)              \\\n-  if (TF_PREDICT_FALSE(!(condition))) \\\n-  LOG(FATAL) << \"Check failed: \" #condition \" \"\n-\n-// Function is overloaded for integral types to allow static const\n-// integrals declared in classes and not defined to be used as arguments to\n-// CHECK* macros. It's not encouraged though.\n-template <typename T>\n-inline const T& GetReferenceableValue(const T& t) {\n-  return t;\n-}\n-inline char GetReferenceableValue(char t) { return t; }\n-inline unsigned char GetReferenceableValue(unsigned char t) { return t; }\n-inline signed char GetReferenceableValue(signed char t) { return t; }\n-inline int16 GetReferenceableValue(int16_t t) { return t; }\n-inline uint16 GetReferenceableValue(uint16 t) { return t; }\n-inline int GetReferenceableValue(int t) { return t; }\n-inline unsigned int GetReferenceableValue(unsigned int t) { return t; }\n-inline int64_t GetReferenceableValue(int64_t t) { return t; }\n-inline uint64 GetReferenceableValue(uint64 t) { return t; }\n-\n-// This formats a value for a failing CHECK_XX statement.  Ordinarily,\n-// it uses the definition for operator<<, with a few special cases below.\n-template <typename T>\n-inline void MakeCheckOpValueString(std::ostream* os, const T& v) {\n-  (*os) << v;\n-}\n-\n-// Overrides for char types provide readable values for unprintable\n-// characters.\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const char& v);\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const signed char& v);\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const unsigned char& v);\n-\n-#if LANG_CXX11\n-// We need an explicit specialization for std::nullptr_t.\n-template <>\n-void MakeCheckOpValueString(std::ostream* os, const std::nullptr_t& v);\n-#endif\n-\n-// A container for a string pointer which can be evaluated to a bool -\n-// true iff the pointer is non-NULL.\n-struct CheckOpString {\n-  explicit CheckOpString(string* str) : str_(str) {}\n-  // No destructor: if str_ is non-NULL, we're about to LOG(FATAL),\n-  // so there's no point in cleaning up str_.\n-  explicit operator bool() const { return TF_PREDICT_FALSE(str_ != nullptr); }\n-  string* str_;\n-};\n-\n-// Build the error message string. Specify no inlining for code size.\n-template <typename T1, typename T2>\n-string* MakeCheckOpString(const T1& v1, const T2& v2,\n-                          const char* exprtext) TF_ATTRIBUTE_NOINLINE;\n-\n-// A helper class for formatting \"expr (V1 vs. V2)\" in a CHECK_XX\n-// statement.  See MakeCheckOpString for sample usage.  Other\n-// approaches were considered: use of a template method (e.g.,\n-// base::BuildCheckOpString(exprtext, base::Print<T1>, &v1,\n-// base::Print<T2>, &v2), however this approach has complications\n-// related to volatile arguments and function-pointer arguments).\n-class CheckOpMessageBuilder {\n- public:\n-  // Inserts \"exprtext\" and \" (\" to the stream.\n-  explicit CheckOpMessageBuilder(const char* exprtext);\n-  // Deletes \"stream_\".\n-  ~CheckOpMessageBuilder();\n-  // For inserting the first variable.\n-  std::ostream* ForVar1() { return stream_; }\n-  // For inserting the second variable (adds an intermediate \" vs. \").\n-  std::ostream* ForVar2();\n-  // Get the result (inserts the closing \")\").\n-  string* NewString();\n-\n- private:\n-  std::ostringstream* stream_;\n-};\n-\n-template <typename T1, typename T2>\n-string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n-  CheckOpMessageBuilder comb(exprtext);\n-  MakeCheckOpValueString(comb.ForVar1(), v1);\n-  MakeCheckOpValueString(comb.ForVar2(), v2);\n-  return comb.NewString();\n-}\n-\n-// Helper functions for CHECK_OP macro.\n-// We use the full name Check_EQ, Check_NE, etc. in case the file including\n-// absl/log/log.h provides its own #defines for the simpler names EQ, NE, etc.\n-// This happens if, for example, those are used as token names in a\n-// yacc grammar.\n-// The (int, int) overload works around the issue that the compiler\n-// will not instantiate the template version of the function on values of\n-// unnamed enum type - see comment below.\n-#define TF_DEFINE_CHECK_OP_IMPL(name, op)                           \\\n-  template <typename T1, typename T2>                               \\\n-  inline string* name##Impl(const T1& v1, const T2& v2,             \\\n-                            const char* exprtext) {                 \\\n-    if (TF_PREDICT_TRUE(v1 op v2))                                  \\\n-      return NULL;                                                  \\\n-    else                                                            \\\n-      return ::tsl::internal::MakeCheckOpString(v1, v2, exprtext);  \\\n-  }                                                                 \\\n-  inline string* name##Impl(int v1, int v2, const char* exprtext) { \\\n-    return name##Impl<int, int>(v1, v2, exprtext);                  \\\n-  }\n-\n-// The (size_t, int) and (int, size_t) specialization are to handle unsigned\n-// comparison errors while still being thorough with the comparison.\n-\n-TF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\n-// Compilation error with CHECK_EQ(NULL, x)?\n-// Use CHECK(x == NULL) instead.\n-\n-inline string* Check_EQImpl(int v1, size_t v2, const char* exprtext) {\n-  if (TF_PREDICT_FALSE(v1 < 0))\n-    ::tsl::internal::MakeCheckOpString(v1, v2, exprtext);\n-\n-  return Check_EQImpl(size_t(v1), v2, exprtext);\n-}\n-\n-inline string* Check_EQImpl(size_t v1, int v2, const char* exprtext) {\n-  return Check_EQImpl(v2, v1, exprtext);\n-}\n-\n-TF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\n-\n-inline string* Check_NEImpl(int v1, size_t v2, const char* exprtext) {\n-  if (v1 < 0) return NULL;\n-\n-  return Check_NEImpl(size_t(v1), v2, exprtext);\n-}\n-\n-inline string* Check_NEImpl(size_t v1, int v2, const char* exprtext) {\n-  return Check_NEImpl(v2, v1, exprtext);\n-}\n-\n-TF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\n-\n-inline string* Check_LEImpl(int v1, size_t v2, const char* exprtext) {\n-  if (v1 <= 0) return NULL;\n-\n-  return Check_LEImpl(size_t(v1), v2, exprtext);\n-}\n-\n-inline string* Check_LEImpl(size_t v1, int v2, const char* exprtext) {\n-  if (TF_PREDICT_FALSE(v2 < 0))\n-    return ::tsl::internal::MakeCheckOpString(v1, v2, exprtext);\n-  return Check_LEImpl(v1, size_t(v2), exprtext);\n-}\n-\n-TF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\n-\n-inline string* Check_LTImpl(int v1, size_t v2, const char* exprtext) {\n-  if (v1 < 0) return NULL;\n-\n-  return Check_LTImpl(size_t(v1), v2, exprtext);\n-}\n-\n-inline string* Check_LTImpl(size_t v1, int v2, const char* exprtext) {\n-  if (v2 < 0) return ::tsl::internal::MakeCheckOpString(v1, v2, exprtext);\n-  return Check_LTImpl(v1, size_t(v2), exprtext);\n-}\n-\n-// Implement GE,GT in terms of LE,LT\n-template <typename T1, typename T2>\n-inline string* Check_GEImpl(const T1& v1, const T2& v2, const char* exprtext) {\n-  return Check_LEImpl(v2, v1, exprtext);\n-}\n-\n-template <typename T1, typename T2>\n-inline string* Check_GTImpl(const T1& v1, const T2& v2, const char* exprtext) {\n-  return Check_LTImpl(v2, v1, exprtext);\n-}\n-\n-#undef TF_DEFINE_CHECK_OP_IMPL\n-\n-// In optimized mode, use CheckOpString to hint to compiler that\n-// the while condition is unlikely.\n-#define CHECK_OP_LOG(name, op, val1, val2)                                     \\\n-  while (::tsl::internal::CheckOpString _result{::tsl::internal::name##Impl(   \\\n-      ::tsl::internal::GetReferenceableValue(val1),                            \\\n-      ::tsl::internal::GetReferenceableValue(val2), #val1 \" \" #op \" \" #val2)}) \\\n-  ::tsl::internal::LogMessageFatal(__FILE__, __LINE__) << *(_result.str_)\n-\n-#define CHECK_OP(name, op, val1, val2) CHECK_OP_LOG(name, op, val1, val2)\n-\n-// CHECK_EQ/NE/...\n-#define CHECK_EQ(val1, val2) CHECK_OP(Check_EQ, ==, val1, val2)\n-#define CHECK_NE(val1, val2) CHECK_OP(Check_NE, !=, val1, val2)\n-#define CHECK_LE(val1, val2) CHECK_OP(Check_LE, <=, val1, val2)\n-#define CHECK_LT(val1, val2) CHECK_OP(Check_LT, <, val1, val2)\n-#define CHECK_GE(val1, val2) CHECK_OP(Check_GE, >=, val1, val2)\n-#define CHECK_GT(val1, val2) CHECK_OP(Check_GT, >, val1, val2)\n-#define CHECK_NOTNULL(val)                          \\\n-  ::tsl::internal::CheckNotNull(__FILE__, __LINE__, \\\n-                                \"'\" #val \"' Must be non NULL\", (val))\n-\n-#ifndef NDEBUG\n-// DCHECK_EQ/NE/...\n-#define DCHECK(condition) CHECK(condition)\n-#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)\n-#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)\n-#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)\n-#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)\n-#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)\n-#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)\n-\n-#else\n-\n-#define DCHECK(condition) \\\n-  while (false && (condition)) LOG(FATAL)\n-\n-// NDEBUG is defined, so DCHECK_EQ(x, y) and so on do nothing.\n-// However, we still want the compiler to parse x and y, because\n-// we don't want to lose potentially useful errors and warnings.\n-// _DCHECK_NOP is a helper, and should not be used outside of this file.\n-#define _TF_DCHECK_NOP(x, y) \\\n-  while (false && ((void)(x), (void)(y), 0)) LOG(FATAL)\n-\n-#define DCHECK_EQ(x, y) _TF_DCHECK_NOP(x, y)\n-#define DCHECK_NE(x, y) _TF_DCHECK_NOP(x, y)\n-#define DCHECK_LE(x, y) _TF_DCHECK_NOP(x, y)\n-#define DCHECK_LT(x, y) _TF_DCHECK_NOP(x, y)\n-#define DCHECK_GE(x, y) _TF_DCHECK_NOP(x, y)\n-#define DCHECK_GT(x, y) _TF_DCHECK_NOP(x, y)\n-\n-#endif\n-\n-// These are for when you don't want a CHECK failure to print a verbose\n-// stack trace.  The implementation of CHECK* in this file already doesn't.\n-#define QCHECK(condition) CHECK(condition)\n-#define QCHECK_EQ(x, y) CHECK_EQ(x, y)\n-#define QCHECK_NE(x, y) CHECK_NE(x, y)\n-#define QCHECK_LE(x, y) CHECK_LE(x, y)\n-#define QCHECK_LT(x, y) CHECK_LT(x, y)\n-#define QCHECK_GE(x, y) CHECK_GE(x, y)\n-#define QCHECK_GT(x, y) CHECK_GT(x, y)\n-\n-template <typename T>\n-T&& CheckNotNull(const char* file, int line, const char* exprtext, T&& t) {\n-  if (t == nullptr) {\n-    LogMessageFatal(file, line) << string(exprtext);\n-  }\n-  return std::forward<T>(t);\n-}\n-\n-absl::LogSeverityAtLeast MinLogLevelFromEnv();\n-\n-int MaxVLogLevelFromEnv();\n-\n-}  // namespace internal\n-\n-// LogSink support adapted from absl/log/log.h\n-//\n-// `LogSink` is an interface which can be extended to intercept and process\n-// all log messages. LogSink implementations must be thread-safe. A single\n-// instance will be called from whichever thread is performing a logging\n-// operation.\n-class TFLogEntry {\n- public:\n-  explicit TFLogEntry(absl::LogSeverity severity, absl::string_view message)\n-      : severity_(severity), message_(message) {}\n-\n-  explicit TFLogEntry(absl::LogSeverity severity, absl::string_view fname,\n-                      int line, absl::string_view message)\n-      : severity_(severity), fname_(fname), line_(line), message_(message) {}\n-\n-  absl::LogSeverity log_severity() const { return severity_; }\n-  std::string FName() const { return fname_; }\n-  int Line() const { return line_; }\n-  std::string ToString() const { return message_; }\n-  absl::string_view text_message() const { return message_; }\n-\n-  // Returning similar result as `text_message` as there is no prefix in this\n-  // implementation.\n-  absl::string_view text_message_with_prefix() const { return message_; }\n-\n- private:\n-  const absl::LogSeverity severity_;\n-  const std::string fname_;\n-  int line_ = -1;\n-  const std::string message_;\n-};\n-\n-class TFLogSink {\n- public:\n-  virtual ~TFLogSink() = default;\n-\n-  // `Send` is called synchronously during the log statement.  The logging\n-  // module guarantees not to call `Send` concurrently on the same log sink.\n-  // Implementations should be careful not to call`LOG` or `CHECK` or take\n-  // any locks that might be held by the `LOG` caller, to avoid deadlock.\n-  //\n-  // `e` is guaranteed to remain valid until the subsequent call to\n-  // `WaitTillSent` completes, so implementations may store a pointer to or\n-  // copy of `e` (e.g. in a thread local variable) for use in `WaitTillSent`.\n-  virtual void Send(const TFLogEntry& entry) = 0;\n-\n-  // `WaitTillSent` blocks the calling thread (the thread that generated a log\n-  // message) until the sink has finished processing the log message.\n-  // `WaitTillSent` is called once per log message, following the call to\n-  // `Send`.  This may be useful when log messages are buffered or processed\n-  // asynchronously by an expensive log sink.\n-  // The default implementation returns immediately.  Like `Send`,\n-  // implementations should be careful not to call `LOG` or `CHECK or take any\n-  // locks that might be held by the `LOG` caller, to avoid deadlock.\n-  virtual void WaitTillSent() {}\n-};\n-\n-// This is the default log sink. This log sink is used if there are no other\n-// log sinks registered. To disable the default log sink, set the\n-// \"no_default_logger\" Bazel config setting to true or define a\n-// NO_DEFAULT_LOGGER preprocessor symbol. This log sink will always log to\n-// stderr.\n-class TFDefaultLogSink : public TFLogSink {\n- public:\n-  void Send(const TFLogEntry& entry) override;\n-};\n-\n-// Add or remove a `LogSink` as a consumer of logging data.  Thread-safe.\n-void TFAddLogSink(TFLogSink* sink);\n-void TFRemoveLogSink(TFLogSink* sink);\n-\n-// Get all the log sinks.  Thread-safe.\n-std::vector<TFLogSink*> TFGetLogSinks();\n-\n-// Change verbose level of pre-defined files if envorionment\n-// variable `env_var` is defined. This is currently a no op.\n-void UpdateLogVerbosityIfDefined(const char* env_var);\n-\n-}  // namespace tsl\n-\n-#endif  // XLA_TSL_PLATFORM_DEFAULT_LOGGING_H_"
        },
        {
            "sha": "6106f9b93fc9b4522d697ff86884202be3f9d0e3",
            "filename": "third_party/xla/xla/tsl/platform/logging.cc",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -0,0 +1,91 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tsl/platform/logging.h\"\n+\n+#include <cstdlib>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/log/globals.h\"\n+#include \"absl/strings/string_view.h\"\n+\n+namespace tsl {\n+\n+void UpdateLogVerbosityIfDefined(absl::string_view env_var) {\n+  if (env_var.empty()) {\n+    return;\n+  }\n+  int vlog_level = 0;\n+  std::vector<std::string> bridge_files = {\n+      \"bridge\",\n+      \"bridge_logger\",\n+      \"cluster_tf\",\n+      \"compile_mlir_util\",\n+      \"graph_analysis\",\n+      \"import_model\",\n+      \"legalize_tf\",\n+      \"mlir_bridge_pass\",\n+      \"mlir_graph_optimization_pass\",\n+      \"optimization_registry\",\n+      \"tf_dialect_to_executor\",\n+      \"tpu_compile\",\n+      \"tpu_compile_op_impl\",\n+      \"xla_compiler\",\n+  };\n+\n+  const char* env_var_val = getenv(env_var.data());\n+  if (!env_var_val) {\n+    return;\n+  }\n+  int log_verbosity = std::stoi(env_var_val);\n+  switch (log_verbosity) {\n+    case 1:\n+      // This level prints minimum logs with statements only.\n+      vlog_level = 1;\n+      bridge_files = {\"bridge_logger\", \"graph_analysis\", \"tpu_compile\",\n+                      \"tpu_compile_op_impl\"};\n+      break;\n+    case 2:\n+      // This level enables logging before and after the entire pass pipeline.\n+      vlog_level = 1;\n+      break;\n+    case 3:\n+      // This level enables logging before and after each of the passes in the\n+      // pass pipeline as well as other important points during compilation\n+      // outside of the pipeline.\n+      vlog_level = 5;\n+      break;\n+    default:\n+      LOG(INFO) << \"Unknown value for bridge log verbosity: \" << log_verbosity;\n+      return;\n+  }\n+  // NOLINTBEGIN(abseil-no-internal-dependencies)\n+  for (const auto& file : bridge_files) {\n+    int curr_vlog_level = absl::log_internal::VLogLevel(file);\n+    if (vlog_level > curr_vlog_level) {\n+      LOG(INFO) << \"Updating vlog level of \" << file << \".cc from \"\n+                << curr_vlog_level << \" to \" << vlog_level;\n+      absl::SetVLogLevel(file, vlog_level);\n+    } else {\n+      LOG(INFO) << \"Current vlog level of \" << file << \".cc (\"\n+                << curr_vlog_level << \") is greater than or equal to \"\n+                << vlog_level;\n+    }\n+  }\n+  // NOLINTEND(abseil-no-internal-dependencies)\n+}\n+\n+}  // namespace tsl"
        },
        {
            "sha": "1cb30bf5734c27996760580cce6f128dc59600a3",
            "filename": "third_party/xla/xla/tsl/platform/logging.h",
            "status": "modified",
            "additions": 28,
            "deletions": 9,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging.h?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -16,14 +16,33 @@ limitations under the License.\n #ifndef XLA_TSL_PLATFORM_LOGGING_H_\n #define XLA_TSL_PLATFORM_LOGGING_H_\n \n-#include \"tsl/platform/platform.h\"\n-\n-#if defined(PLATFORM_GOOGLE) || defined(PLATFORM_GOOGLE_ANDROID) || \\\n-    defined(PLATFORM_GOOGLE_IOS) || defined(GOOGLE_LOGGING) ||      \\\n-    defined(PLATFORM_PORTABLE_GOOGLE)\n-#include \"xla/tsl/platform/google/logging.h\"  // IWYU pragma: export\n-#else\n-#include \"xla/tsl/platform/default/logging.h\"  // IWYU pragma: export\n-#endif\n+#include \"absl/log/check.h\"       // IWYU pragma: export\n+#include \"absl/log/log.h\"         // IWYU pragma: export\n+#include \"absl/log/vlog_is_on.h\"  // IWYU pragma: export\n+#include \"absl/strings/string_view.h\"\n+\n+namespace tsl {\n+namespace internal {\n+\n+#ifndef CHECK_NOTNULL\n+template <typename T>\n+T&& CheckNotNull(absl::string_view file, int line, absl::string_view exprtext,\n+                 T&& t) {\n+  if (t == nullptr) {\n+    LOG(FATAL).AtLocation(file, line) << exprtext;\n+  }\n+  return std::forward<T>(t);\n+}\n+\n+#define CHECK_NOTNULL(val)                          \\\n+  ::tsl::internal::CheckNotNull(__FILE__, __LINE__, \\\n+                                \"'\" #val \"' Must be non NULL\", (val))\n+#endif  // CHECK_NOTNULL\n+\n+}  // namespace internal\n+\n+void UpdateLogVerbosityIfDefined(absl::string_view env_var);\n+\n+}  // namespace tsl\n \n #endif  // XLA_TSL_PLATFORM_LOGGING_H_"
        },
        {
            "sha": "3a44685a563f6da52d6253a562d303cc22f9f188",
            "filename": "third_party/xla/xla/tsl/platform/logging_initializer.cc",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging_initializer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging_initializer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging_initializer.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -0,0 +1,80 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include <cstdint>\n+#include <cstdlib>\n+#include <cstring>\n+#include <optional>\n+#include <vector>\n+\n+#include \"absl/base/log_severity.h\"\n+#include \"absl/log/globals.h\"\n+#include \"absl/strings/numbers.h\"\n+#include \"absl/strings/str_split.h\"\n+#include \"absl/strings/string_view.h\"\n+\n+namespace tsl {\n+namespace {\n+\n+std::optional<int64_t> LogLevelStrToInt(const char* str) {\n+  if (str == nullptr || strlen(str) == 0) {\n+    return std::nullopt;\n+  }\n+  if (int level; absl::SimpleAtoi(str, &level)) {\n+    return level;\n+  }\n+  return std::nullopt;\n+}\n+\n+void UpdateVlogLevels(const char* spec) {\n+  if (spec == nullptr || strlen(spec) == 0) {\n+    return;\n+  }\n+  for (absl::string_view entry : absl::StrSplit(spec, ',')) {\n+    std::vector<absl::string_view> parts = absl::StrSplit(entry, '=');\n+    if (parts.size() != 2) {\n+      continue;\n+    }\n+    absl::string_view module = parts[0];\n+    if (int level; absl::SimpleAtoi(parts[1], &level)) {\n+      absl::SetVLogLevel(module, level);\n+    }\n+  }\n+}\n+\n+// Initializes logging and configures it based on environment variables.\n+// This class is intended to be used as a global instance, ensuring that\n+// logging is initialized before any other code that might use it.\n+class LoggingInitializer {\n+ public:\n+  LoggingInitializer() {\n+    // We log everything to stderr for backwards compatibility with TSL logging.\n+    absl::SetStderrThreshold(absl::LogSeverityAtLeast::kInfo);\n+    if (auto severity = LogLevelStrToInt(std::getenv(\"TF_CPP_MIN_LOG_LEVEL\"))) {\n+      absl::SetMinLogLevel(static_cast<absl::LogSeverityAtLeast>(*severity));\n+    }\n+    if (auto threshold =\n+            LogLevelStrToInt(std::getenv(\"TF_CPP_MAX_VLOG_LEVEL\"))) {\n+      absl::SetGlobalVLogLevel(*threshold);\n+    }\n+    UpdateVlogLevels(std::getenv(\"TF_CPP_VMODULE\"));\n+  }\n+};\n+\n+// Global instance. Its constructor is called before main().\n+LoggingInitializer g_initializer;\n+\n+}  // namespace\n+}  // namespace tsl"
        },
        {
            "sha": "e5dceca8c7fcb732b3c3b73a359b29842ecbdd2f",
            "filename": "third_party/xla/xla/tsl/platform/logging_test.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 167,
            "changes": 176,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Flogging_test.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -20,17 +20,15 @@ limitations under the License.\n #include <cstdio>\n #include <cstdlib>\n #include <memory>\n-#include <sstream>\n-#include <vector>\n+#include <string>\n \n-#include \"absl/base/log_severity.h\"\n+#include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n-#include \"tsl/platform/path.h\"\n #include \"tsl/platform/stacktrace_handler.h\"\n \n // Make sure popen and pclose are available on Windows.\n@@ -47,107 +45,6 @@ namespace {\n using ::testing::HasSubstr;\n using ::testing::Not;\n \n-TEST(Logging, Log) {\n-  LOG(INFO) << \"Hello\";\n-  LOG(INFO) << \"Another log message\";\n-  LOG(ERROR) << \"Error message\";\n-  VLOG(1) << \"A VLOG message\";\n-  VLOG(2) << \"A higher VLOG message\";\n-  DVLOG(1) << \"A DVLOG message\";\n-  DVLOG(2) << \"A higher DVLOG message\";\n-}\n-\n-TEST(Logging, CheckChecks) {\n-  CHECK(true);\n-  CHECK(7 > 5);\n-  string a(\"abc\");\n-  string b(\"xyz\");\n-  CHECK_EQ(a, a);\n-  CHECK_NE(a, b);\n-  CHECK_EQ(3, 3);\n-  CHECK_NE(4, 3);\n-  CHECK_GT(4, 3);\n-  CHECK_GE(3, 3);\n-  CHECK_LT(2, 3);\n-  CHECK_LE(2, 3);\n-\n-  DCHECK(true);\n-  DCHECK(7 > 5);\n-  DCHECK_EQ(a, a);\n-  DCHECK_NE(a, b);\n-  DCHECK_EQ(3, 3);\n-  DCHECK_NE(4, 3);\n-  DCHECK_GT(4, 3);\n-  DCHECK_GE(3, 3);\n-  DCHECK_LT(2, 3);\n-  DCHECK_LE(2, 3);\n-}\n-\n-TEST(LoggingDeathTest, FailedChecks) {\n-  string a(\"abc\");\n-  string b(\"xyz\");\n-  const char* p_const = \"hello there\";\n-  const char* p_null_const = nullptr;\n-  char mybuf[10];\n-  char* p_non_const = mybuf;\n-  char* p_null = nullptr;\n-  CHECK_NOTNULL(p_const);\n-  CHECK_NOTNULL(p_non_const);\n-\n-  ASSERT_DEATH(CHECK(false), \"false\");\n-  ASSERT_DEATH(CHECK(9 < 7), \"9 < 7\");\n-  ASSERT_DEATH(CHECK_EQ(a, b), \"a == b\");\n-  ASSERT_DEATH(CHECK_EQ(3, 4), \"3 == 4\");\n-  ASSERT_DEATH(CHECK_NE(3, 3), \"3 != 3\");\n-  ASSERT_DEATH(CHECK_GT(2, 3), \"2 > 3\");\n-  ASSERT_DEATH(CHECK_GE(2, 3), \"2 >= 3\");\n-  ASSERT_DEATH(CHECK_LT(3, 2), \"3 < 2\");\n-  ASSERT_DEATH(CHECK_LE(3, 2), \"3 <= 2\");\n-  ASSERT_DEATH(CHECK(false), \"false\");\n-  ASSERT_DEATH(printf(\"%s\", CHECK_NOTNULL(p_null)), \"Must be non NULL\");\n-  ASSERT_DEATH(printf(\"%s\", CHECK_NOTNULL(p_null_const)), \"Must be non NULL\");\n-#ifndef NDEBUG\n-  ASSERT_DEATH(DCHECK(9 < 7), \"9 < 7\");\n-  ASSERT_DEATH(DCHECK(9 < 7), \"9 < 7\");\n-  ASSERT_DEATH(DCHECK_EQ(a, b), \"a == b\");\n-  ASSERT_DEATH(DCHECK_EQ(3, 4), \"3 == 4\");\n-  ASSERT_DEATH(DCHECK_NE(3, 3), \"3 != 3\");\n-  ASSERT_DEATH(DCHECK_GT(2, 3), \"2 > 3\");\n-  ASSERT_DEATH(DCHECK_GE(2, 3), \"2 >= 3\");\n-  ASSERT_DEATH(DCHECK_LT(3, 2), \"3 < 2\");\n-  ASSERT_DEATH(DCHECK_LE(3, 2), \"3 <= 2\");\n-#endif\n-}\n-\n-class TestSink : public TFLogSink {\n- public:\n-  void Send(const TFLogEntry& entry) override {\n-    ss_ << entry.text_message() << std::endl;\n-  }\n-\n-  std::string Get() const { return ss_.str(); }\n-\n- private:\n-  std::stringstream ss_;\n-};\n-\n-TEST(LogSinkTest, testLogSinks) {\n-  const int sinks_initial_size = TFGetLogSinks().size();\n-  TestSink sink;\n-\n-  TFAddLogSink(&sink);\n-\n-  EXPECT_EQ(TFGetLogSinks().size(), sinks_initial_size + 1);\n-\n-  LOG(INFO) << \"Foo\";\n-  LOG(INFO) << \"Bar\";\n-  EXPECT_EQ(sink.Get(), \"Foo\\nBar\\n\");\n-\n-  TFRemoveLogSink(&sink);\n-\n-  EXPECT_EQ(TFGetLogSinks().size(), sinks_initial_size);\n-}\n-\n std::string ReadFromFilePointer(FILE* fp) {\n   std::string result;\n   while (!feof(fp)) {\n@@ -158,15 +55,6 @@ std::string ReadFromFilePointer(FILE* fp) {\n   return result;\n }\n \n-absl::StatusOr<std::string> ReadFromFile(const std::string& filename) {\n-  std::shared_ptr<FILE> fp(fopen(filename.c_str(), \"r\"), fclose);\n-  if (fp == nullptr) {\n-    return absl::ErrnoToStatus(errno,\n-                               absl::StrFormat(\"Cannot fopen '%s'\", filename));\n-  }\n-  return ReadFromFilePointer(fp.get());\n-}\n-\n class SubcommandTest : public ::testing::Test {\n  public:\n   static constexpr absl::string_view kLogVLog = \"log_and_vlog\";\n@@ -190,8 +78,8 @@ class SubcommandTest : public ::testing::Test {\n   }\n \n  protected:\n-  absl::StatusOr<std::string> CaptureOutput(const char* invocation) {\n-    std::shared_ptr<FILE> fp(popen(invocation, \"r\"), pclose);\n+  absl::StatusOr<std::string> CaptureOutput(absl::string_view invocation) {\n+    std::shared_ptr<FILE> fp(popen(invocation.data(), \"r\"), pclose);\n     if (fp == nullptr) {\n       return absl::ErrnoToStatus(\n           errno, absl::StrFormat(\"Cannot popen '%s'\", invocation));\n@@ -207,7 +95,7 @@ TEST_F(SubcommandTest, LogDefaultTest) {\n   command += \" --alsologtostderr\";\n #endif\n   command += \" 2>&1\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command.c_str()));\n+  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command));\n   EXPECT_THAT(out, HasSubstr(\"LOG INFO\"));\n   EXPECT_THAT(out, HasSubstr(\"LOG WARNING\"));\n   EXPECT_THAT(out, HasSubstr(\"LOG ERROR\"));\n@@ -226,7 +114,7 @@ TEST_F(SubcommandTest, MinLogLevelTest) {\n   command = absl::StrFormat(\"TF_CPP_MIN_LOG_LEVEL=1 %s\", command);\n #endif\n   command += \" 2>&1\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command.c_str()));\n+  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command));\n   EXPECT_THAT(out, Not(HasSubstr(\"LOG INFO\")));\n   EXPECT_THAT(out, HasSubstr(\"LOG WARNING\"));\n   EXPECT_THAT(out, HasSubstr(\"LOG ERROR\"));\n@@ -239,7 +127,7 @@ TEST_F(SubcommandTest, VLogDefaultTest) {\n   command += \" --alsologtostderr\";\n #endif\n   command += \" 2>&1\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command.c_str()));\n+  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command));\n   EXPECT_THAT(out, Not(HasSubstr(\"VLevel 1\")));\n   EXPECT_THAT(out, Not(HasSubstr(\"VLevel 2\")));\n   EXPECT_THAT(out, Not(HasSubstr(\"VLevel 3\")));\n@@ -255,7 +143,7 @@ TEST_F(SubcommandTest, MaxVLogLevelTest) {\n   command = absl::StrFormat(\"TF_CPP_MAX_VLOG_LEVEL=2 %s\", command);\n #endif\n   command += \" 2>&1\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command.c_str()));\n+  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command));\n   EXPECT_THAT(out, HasSubstr(\"VLevel 1\"));\n   EXPECT_THAT(out, HasSubstr(\"VLevel 2\"));\n   EXPECT_THAT(out, Not(HasSubstr(\"VLevel 3\")));\n@@ -276,7 +164,7 @@ TEST_F(SubcommandTest, VModuleTest) {\n                             command);\n #endif\n   command += \" 2>&1\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command.c_str()));\n+  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command));\n   EXPECT_THAT(out, HasSubstr(\"VLevel 1\"));\n   EXPECT_THAT(out, HasSubstr(\"VLevel 2\"));\n   EXPECT_THAT(out, Not(HasSubstr(\"VLevel 3\")));\n@@ -285,52 +173,6 @@ TEST_F(SubcommandTest, VModuleTest) {\n   EXPECT_THAT(out, HasSubstr(\"VLOG_IS_ON(3)? 0\"));\n }\n \n-TEST_F(SubcommandTest, VLogFilenameTest) {\n-#if defined(PLATFORM_GOOGLE)\n-  constexpr bool kVLogFilenameEnvVarIsSupported = false;\n-#else\n-  constexpr bool kVLogFilenameEnvVarIsSupported = true;\n-#endif\n-  if (!kVLogFilenameEnvVarIsSupported) {\n-    GTEST_SKIP() << \"Not supported on this platform\";\n-  }\n-\n-  std::string command = absl::StrFormat(\"%s %s\", program_name, kLogVLog);\n-  std::string filename = io::GetTempFilename(\"logging_test\");\n-#if defined(PLATFORM_WINDOWS)\n-  command = absl::StrFormat(\n-      \"set TF_CPP_VLOG_FILENAME=%s && set TF_CPP_MAX_VLOG_LEVEL=1 && %s\",\n-      filename, command);\n-#else\n-  command = absl::StrFormat(\n-      \"TF_CPP_VLOG_FILENAME=%s TF_CPP_MAX_VLOG_LEVEL=1 %s\", filename, command);\n-#endif\n-  command += \" 2>&1\";\n-\n-  // All output should be in the file, not in stderr.\n-  TF_ASSERT_OK_AND_ASSIGN(std::string out, CaptureOutput(command.c_str()));\n-  EXPECT_THAT(out, Not(HasSubstr(\"LOG INFO\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"LOG WARNING\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"LOG ERROR\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"VLOG_IS_ON(1)?\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"VLOG_IS_ON(2)?\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"VLOG_IS_ON(3)?\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"VLevel 1\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"VLevel 2\")));\n-  EXPECT_THAT(out, Not(HasSubstr(\"VLevel 3\")));\n-\n-  TF_ASSERT_OK_AND_ASSIGN(std::string log_file, ReadFromFile(filename));\n-  EXPECT_THAT(log_file, HasSubstr(\"LOG INFO\"));\n-  EXPECT_THAT(log_file, HasSubstr(\"LOG WARNING\"));\n-  EXPECT_THAT(log_file, HasSubstr(\"LOG ERROR\"));\n-  EXPECT_THAT(log_file, HasSubstr(\"VLOG_IS_ON(1)\"));\n-  EXPECT_THAT(log_file, HasSubstr(\"VLOG_IS_ON(2)\"));\n-  EXPECT_THAT(log_file, HasSubstr(\"VLOG_IS_ON(3)\"));\n-  EXPECT_THAT(log_file, HasSubstr(\"VLevel 1\"));\n-  EXPECT_THAT(log_file, Not(HasSubstr(\"VLevel 2\")));\n-  EXPECT_THAT(log_file, Not(HasSubstr(\"VLevel 3\")));\n-}\n-\n }  // namespace\n }  // namespace tsl\n "
        },
        {
            "sha": "9aa60c12f567e914b188f8eacbcd862af15e7caf",
            "filename": "third_party/xla/xla/tsl/platform/status.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fstatus.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/266e3f28e870f7e17b3ccabe4086c0f571efb571/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fstatus.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fstatus.cc?ref=266e3f28e870f7e17b3ccabe4086c0f571efb571",
            "patch": "@@ -33,6 +33,9 @@ limitations under the License.\n #include \"absl/functional/function_ref.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n+#include \"absl/log/log_entry.h\"\n+#include \"absl/log/log_sink.h\"\n+#include \"absl/log/log_sink_registry.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/cord.h\"\n #include \"absl/strings/numbers.h\"\n@@ -56,7 +59,7 @@ namespace {\n \n // Log sink is used to collect recent warning and error log messages to be\n // attached to the error status.\n-class StatusLogSink : public TFLogSink {\n+class StatusLogSink : public absl::LogSink {\n  public:\n   static StatusLogSink* GetInstance() {\n     static StatusLogSink* const sink = new StatusLogSink();\n@@ -78,7 +81,7 @@ class StatusLogSink : public TFLogSink {\n       }\n \n       if (num_messages_ > 0) {\n-        TFAddLogSink(this);\n+        absl::AddLogSink(this);\n       }\n     });\n   }\n@@ -91,7 +94,7 @@ class StatusLogSink : public TFLogSink {\n     }\n   }\n \n-  void Send(const TFLogEntry& entry) override TF_LOCKS_EXCLUDED(mu_) {\n+  void Send(const absl::LogEntry& entry) override TF_LOCKS_EXCLUDED(mu_) {\n     if (entry.log_severity() < absl::LogSeverity::kWarning) return;\n \n     absl::MutexLock lock(&mu_);"
        }
    ],
    "stats": {
        "total": 1806,
        "additions": 290,
        "deletions": 1516
    }
}