{
    "author": "beckerhe",
    "message": "Make RedzoneBuffer constructible from ProgramShape\n\nThis adds a new factory function to the `RedzoneBuffers` type. It now can be constructed from a `ProgramShape` value.\n\nI'm also changing the implementation of the other two factory function which\ncan now be implemented in terms of the new FromProgramShape factory function.\n\nI also had to change the parameter to `CreateInputs` and `CreateOutputs` which used to operate on HloInstructions, but all they need are shapes.\n\nThis will help making the autotuner independent of HLO since the ProgramShape can be requested from a GpuExecutable without accessing the HLO module.\n\nPiperOrigin-RevId: 800004538",
    "sha": "9b437d10c9b311c49ffb9ad582b32271e8504ab4",
    "files": [
        {
            "sha": "54aae0c0d081b227fecc203a32eed845bc1b36a1",
            "filename": "third_party/xla/xla/service/gpu/autotuning/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2FBUILD?ref=9b437d10c9b311c49ffb9ad582b32271e8504ab4",
            "patch": "@@ -488,7 +488,6 @@ cc_library(\n         \"//xla:xla_data_proto_cc\",\n         \"//xla:xla_proto_cc\",\n         \"//xla/hlo/ir:hlo\",\n-        \"//xla/service:executable\",\n         \"//xla/stream_executor:device_memory\",\n         \"//xla/stream_executor:device_memory_allocator\",\n         \"//xla/stream_executor:stream\","
        },
        {
            "sha": "040abcc04f08d5c110e7b7a7b5647ba876f129b7",
            "filename": "third_party/xla/xla/service/gpu/autotuning/redzone_buffers.cc",
            "status": "modified",
            "additions": 39,
            "deletions": 44,
            "changes": 83,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers.cc?ref=9b437d10c9b311c49ffb9ad582b32271e8504ab4",
            "patch": "@@ -19,13 +19,15 @@ limitations under the License.\n #include <iterator>\n #include <limits>\n #include <memory>\n+#include <string>\n #include <vector>\n \n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/types/span.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/hlo/ir/hlo_clone_context.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n@@ -48,33 +50,31 @@ absl::StatusOr<RedzoneBuffers> RedzoneBuffers::FromInstruction(\n     se::Stream* stream, BuffersToCreate buffers_to_create,\n     bool should_init_buffers, bool should_check_correctness,\n     int redzone_padding_bytes) {\n-  tsl::profiler::TraceMe traceme(\"create redzone buffers\");\n-  RedzoneBuffers buffers;\n-  buffers.redzone_allocator_ = std::make_unique<se::RedzoneAllocator>(\n-      stream, allocator,\n-      /*memory_limit=*/std::numeric_limits<int64_t>::max(),\n-      /*redzone_size=*/should_check_correctness ? redzone_padding_bytes : 0);\n-\n-  int64_t rng_state = 0;\n-\n-  HloInstruction::InstructionVector operands = instruction.operands();\n-  TF_RETURN_IF_ERROR(\n-      buffers.CreateInputs(operands, should_init_buffers, rng_state));\n-\n-  if (buffers_to_create == BuffersToCreate::kAllInputsAllOutputs ||\n-      buffers_to_create == BuffersToCreate::kAllInputsOutputsNoScratch) {\n-    TF_RETURN_IF_ERROR(buffers.CreateOutputs(instruction, buffers_to_create,\n-                                             should_init_buffers, rng_state));\n+  ProgramShape program_shape;\n+  for (const HloInstruction* operand : instruction.operands()) {\n+    program_shape.AddParameter(operand->shape(), std::string(operand->name()));\n   }\n-\n-  return buffers;\n+  *program_shape.mutable_result() = instruction.shape();\n+  return FromProgramShape(program_shape, buffers_to_create, should_init_buffers,\n+                          should_check_correctness, redzone_padding_bytes,\n+                          allocator, stream);\n }\n \n absl::StatusOr<RedzoneBuffers> RedzoneBuffers::FromComputation(\n     const HloComputation& computation, se::DeviceMemoryAllocator* allocator,\n     se::Stream* stream, BuffersToCreate buffers_to_create,\n     bool should_init_buffers, bool should_check_correctness,\n     int redzone_padding_bytes) {\n+  return FromProgramShape(computation.ComputeProgramShape(), buffers_to_create,\n+                          should_init_buffers, should_check_correctness,\n+                          redzone_padding_bytes, allocator, stream);\n+}\n+\n+absl::StatusOr<RedzoneBuffers> RedzoneBuffers::FromProgramShape(\n+    const ProgramShape& program_shape, BuffersToCreate buffers_to_create,\n+    bool should_init_buffers, bool should_check_correctness,\n+    int redzone_padding_bytes, se::DeviceMemoryAllocator* allocator,\n+    se::Stream* stream) {\n   tsl::profiler::TraceMe traceme(\"create redzone buffers\");\n   RedzoneBuffers buffers;\n   buffers.redzone_allocator_ = std::make_unique<se::RedzoneAllocator>(\n@@ -84,55 +84,50 @@ absl::StatusOr<RedzoneBuffers> RedzoneBuffers::FromComputation(\n \n   int64_t rng_state = 0;\n \n-  HloInstruction::InstructionVector parameters =\n-      computation.parameter_instructions();\n-  TF_RETURN_IF_ERROR(\n-      buffers.CreateInputs(parameters, should_init_buffers, rng_state));\n+  TF_RETURN_IF_ERROR(buffers.CreateInputs(program_shape.parameters(),\n+                                          should_init_buffers, rng_state));\n \n   if (buffers_to_create == BuffersToCreate::kAllInputsAllOutputs ||\n       buffers_to_create == BuffersToCreate::kAllInputsOutputsNoScratch) {\n-    const HloInstruction* root = computation.root_instruction();\n-    TF_RETURN_IF_ERROR(buffers.CreateOutputs(*root, buffers_to_create,\n+    TF_RETURN_IF_ERROR(buffers.CreateOutputs(program_shape.result(),\n+                                             buffers_to_create,\n                                              should_init_buffers, rng_state));\n   }\n-\n   return buffers;\n }\n \n-absl::Status RedzoneBuffers::CreateInputs(\n-    const HloInstruction::InstructionVector& instructions,\n-    bool should_init_buffers, int64_t& rng_state) {\n+absl::Status RedzoneBuffers::CreateInputs(absl::Span<const Shape> input_shapes,\n+                                          bool should_init_buffers,\n+                                          int64_t& rng_state) {\n   tsl::profiler::TraceMe traceme(\"create inputs\");\n-  for (const auto* instruction : instructions) {\n-    TF_ASSIGN_OR_RETURN(\n-        se::DeviceMemoryBase buf,\n-        redzone_allocator_->CreateBuffer(instruction->shape(),\n-                                         should_init_buffers, rng_state));\n+  for (const auto& input_shape : input_shapes) {\n+    TF_ASSIGN_OR_RETURN(se::DeviceMemoryBase buf,\n+                        redzone_allocator_->CreateBuffer(\n+                            input_shape, should_init_buffers, rng_state));\n     input_buffers_.push_back(buf);\n-    input_shapes_.push_back(instruction->shape());\n+    input_shapes_.push_back(input_shape);\n   }\n   return absl::OkStatus();\n }\n \n-absl::Status RedzoneBuffers::CreateOutputs(const HloInstruction& instruction,\n+absl::Status RedzoneBuffers::CreateOutputs(const Shape& output_shape,\n                                            BuffersToCreate buffers_to_create,\n                                            bool should_init_buffers,\n                                            int64_t& rng_state) {\n   tsl::profiler::TraceMe traceme(\"create outputs\");\n-  if (!instruction.shape().IsTuple()) {\n-    TF_ASSIGN_OR_RETURN(\n-        se::DeviceMemoryBase buf,\n-        redzone_allocator_->CreateBuffer(instruction.shape(),\n-                                         should_init_buffers, rng_state));\n+  if (!output_shape.IsTuple()) {\n+    TF_ASSIGN_OR_RETURN(se::DeviceMemoryBase buf,\n+                        redzone_allocator_->CreateBuffer(\n+                            output_shape, should_init_buffers, rng_state));\n     output_buffers_.push_back(buf);\n-    output_shape_ = instruction.shape();\n+    output_shape_ = output_shape;\n     return absl::OkStatus();\n   }\n \n   // The output is a tuple.\n \n-  auto current_shape_it = instruction.shape().tuple_shapes().begin();\n-  auto end = instruction.shape().tuple_shapes().end();\n+  auto current_shape_it = output_shape.tuple_shapes().begin();\n+  auto end = output_shape.tuple_shapes().end();\n   end -= buffers_to_create == kAllInputsAllOutputs ? 0 : 1;\n \n   output_shape_ = std::distance(current_shape_it, end) == 1"
        },
        {
            "sha": "c372d200c79eab6201d10dde3bf180b7cbb95114",
            "filename": "third_party/xla/xla/service/gpu/autotuning/redzone_buffers.h",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers.h?ref=9b437d10c9b311c49ffb9ad582b32271e8504ab4",
            "patch": "@@ -22,9 +22,9 @@ limitations under the License.\n \n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/hlo/ir/hlo_clone_context.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n-#include \"xla/service/executable.h\"\n #include \"xla/shape.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/device_memory_allocator.h\"\n@@ -70,6 +70,12 @@ class RedzoneBuffers {\n       bool should_init_buffers, bool should_check_correctness,\n       int redzone_padding_bytes);\n \n+  static absl::StatusOr<RedzoneBuffers> FromProgramShape(\n+      const ProgramShape& program_shape, BuffersToCreate buffers_to_create,\n+      bool should_init_buffers, bool should_check_correctness,\n+      int redzone_padding_bytes, se::DeviceMemoryAllocator* allocator,\n+      se::Stream* stream);\n+\n   const std::vector<se::DeviceMemoryBase>& input_buffers() const {\n     return input_buffers_;\n   }\n@@ -84,11 +90,10 @@ class RedzoneBuffers {\n   se::RedzoneAllocator& RedzoneAllocator() const { return *redzone_allocator_; }\n \n  private:\n-  absl::Status CreateInputs(\n-      const HloInstruction::InstructionVector& instructions,\n-      bool should_init_buffers, int64_t& rng_state);\n+  absl::Status CreateInputs(absl::Span<const Shape> input_shapes,\n+                            bool should_init_buffers, int64_t& rng_state);\n \n-  absl::Status CreateOutputs(const HloInstruction& instruction,\n+  absl::Status CreateOutputs(const Shape& output_shape,\n                              BuffersToCreate buffers_to_create,\n                              bool should_init_buffers, int64_t& rng_state);\n "
        },
        {
            "sha": "0be6b4308f6967bb01553e4c0a0e401db3eb41be",
            "filename": "third_party/xla/xla/service/gpu/autotuning/redzone_buffers_test.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9b437d10c9b311c49ffb9ad582b32271e8504ab4/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fautotuning%2Fredzone_buffers_test.cc?ref=9b437d10c9b311c49ffb9ad582b32271e8504ab4",
            "patch": "@@ -18,11 +18,13 @@ limitations under the License.\n #include <memory>\n #include <vector>\n \n+#include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/service/platform_util.h\"\n+#include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/stream_executor/platform.h\"\n #include \"xla/stream_executor/stream.h\"\n@@ -33,6 +35,8 @@ limitations under the License.\n \n namespace xla::gpu {\n namespace {\n+using ::testing::ElementsAre;\n+using ::testing::SizeIs;\n \n using RedzoneBuffersTest = HloTestBase;\n \n@@ -231,5 +235,36 @@ TEST_F(RedzoneBuffersTest, FromExecutable) {\n   EXPECT_NE(rzb.output_shape(), ShapeUtil::MakeShape(F32, {1, 2, 3}));\n }\n \n+TEST_F(RedzoneBuffersTest, FromProgramShape) {\n+  ProgramShape program_shape;\n+  program_shape.AddParameter(ShapeUtil::MakeShape(F32, {2, 2}), \"p0\");\n+  program_shape.AddParameter(ShapeUtil::MakeShape(F32, {4, 4}), \"p1\");\n+  program_shape.AddParameter(ShapeUtil::MakeShape(F32, {6, 6}), \"p2\");\n+  *program_shape.mutable_result() = ShapeUtil::MakeShape(F32, {1, 2, 3});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(se::Platform * platform,\n+                          PlatformUtil::GetDefaultPlatform());\n+  TF_ASSERT_OK_AND_ASSIGN(se::StreamExecutor * stream_executor,\n+                          platform->ExecutorForDevice(0));\n+  auto allocator =\n+      std::make_unique<se::StreamExecutorMemoryAllocator>(stream_executor);\n+  TF_ASSERT_OK_AND_ASSIGN(se::Stream * stream, allocator->GetStream(0));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      RedzoneBuffers rzb,\n+      RedzoneBuffers::FromProgramShape(\n+          program_shape, RedzoneBuffers::kAllInputsAllOutputs,\n+          /*should_init_buffers=*/true, /*should_check_correctness=*/true,\n+          kRedzonePaddingBytes, allocator.get(), stream));\n+\n+  EXPECT_THAT(rzb.input_shapes(),\n+              ElementsAre(ShapeUtil::MakeShape(F32, {2, 2}),\n+                          ShapeUtil::MakeShape(F32, {4, 4}),\n+                          ShapeUtil::MakeShape(F32, {6, 6})));\n+  EXPECT_THAT(rzb.input_buffers(), SizeIs(3));\n+  EXPECT_THAT(rzb.output_buffers(), SizeIs(1));\n+  EXPECT_EQ(rzb.output_shape(), ShapeUtil::MakeShape(F32, {1, 2, 3}));\n+}\n+\n }  // namespace\n }  // namespace xla::gpu"
        }
    ],
    "stats": {
        "total": 134,
        "additions": 84,
        "deletions": 50
    }
}