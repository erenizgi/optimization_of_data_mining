{
    "author": "unknown",
    "message": "[XLA:GPU] Add SdcLog\n\nA class that wraps a fixed-size log in device memory, that holds checksums\nof thunk input/output buffers. Intended for use in detecting nondeterministic\ncomputations or silent data corruption.\n\nConceptually write-only on device, read-only on host.\n\nPiperOrigin-RevId: 810046619",
    "sha": "7b50e62d2bedd993c196cb99615222dbe5e78728",
    "files": [
        {
            "sha": "0a4fec35d4c7e7df2b36c21e733222106e49d000",
            "filename": "third_party/xla/xla/stream_executor/cuda/BUILD",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2FBUILD?ref=7b50e62d2bedd993c196cb99615222dbe5e78728",
            "patch": "@@ -424,6 +424,40 @@ cuda_library(\n     ],\n )\n \n+cc_library(\n+    name = \"sdc_log\",\n+    srcs = [\"sdc_log.cc\"],\n+    hdrs = [\"sdc_log.h\"],\n+    tags = [\"gpu\"],\n+    deps = [\n+        \"//xla/stream_executor:device_memory\",\n+        \"//xla/stream_executor:device_memory_allocator\",\n+        \"//xla/stream_executor:stream\",\n+        \"//xla/stream_executor:stream_executor_h\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+    ],\n+)\n+\n+xla_test(\n+    name = \"sdc_log_test\",\n+    srcs = [\"sdc_log_test.cc\"],\n+    backends = [\"gpu\"],\n+    deps = [\n+        \":sdc_log\",\n+        \"//xla/stream_executor:platform\",\n+        \"//xla/stream_executor:platform_manager\",\n+        \"//xla/stream_executor:stream\",\n+        \"//xla/stream_executor:stream_executor_h\",\n+        \"//xla/stream_executor:stream_executor_memory_allocator\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"cudnn_plugin\",\n     srcs = [\"cuda_dnn.cc\"],"
        },
        {
            "sha": "728480a9f743b8f4b37208406043aed97dfd1f66",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_log.cc",
            "status": "added",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.cc?ref=7b50e62d2bedd993c196cb99615222dbe5e78728",
            "patch": "@@ -0,0 +1,85 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/cuda/sdc_log.h\"\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <cstring>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/device_memory_allocator.h\"\n+#include \"xla/stream_executor/stream.h\"\n+#include \"xla/stream_executor/stream_executor.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace stream_executor::cuda {\n+\n+absl::StatusOr<SdcLog> SdcLog::CreateOnDevice(\n+    uint32_t max_entries, Stream& stream, DeviceMemoryAllocator& allocator) {\n+  TF_ASSIGN_OR_RETURN(\n+      OwningDeviceMemory memory,\n+      allocator.Allocate(\n+          stream.parent()->device_ordinal(),\n+          sizeof(SdcLogHeader) + max_entries * sizeof(SdcLogEntry)));\n+  if (memory.is_null()) {\n+    return absl::InternalError(absl::StrFormat(\n+        \"Failed to allocate SdcLog for %u entries\", max_entries));\n+  }\n+\n+  const SdcLogHeader empty_header{\n+      /*write_idx=*/0,\n+      /*capacity=*/max_entries,\n+  };\n+  TF_RETURN_IF_ERROR(\n+      stream.Memcpy(memory.ptr(), &empty_header, sizeof(empty_header)));\n+  return SdcLog(std::move(memory));\n+}\n+\n+absl::StatusOr<SdcLogHeader> SdcLog::ReadHeaderFromDevice(\n+    Stream& stream) const {\n+  SdcLogHeader header;\n+  TF_RETURN_IF_ERROR(stream.Memcpy(&header, memory_.cref(), sizeof(header)));\n+  TF_RETURN_IF_ERROR(stream.BlockHostUntilDone());\n+  return header;\n+}\n+\n+absl::StatusOr<std::vector<SdcLogEntry>> SdcLog::ReadFromDevice(\n+    Stream& stream) const {\n+  std::vector<uint8_t> buffer(memory_->size());\n+  TF_RETURN_IF_ERROR(\n+      stream.Memcpy(buffer.data(), memory_.cref(), memory_->size()));\n+  TF_RETURN_IF_ERROR(stream.BlockHostUntilDone());\n+\n+  SdcLogHeader header;\n+  memcpy(&header, buffer.data(), sizeof(header));\n+\n+  const size_t initialized_entries =\n+      std::min(header.capacity, header.write_idx);\n+  std::vector<SdcLogEntry> entries(initialized_entries);\n+  memcpy(entries.data(), buffer.data() + sizeof(header),\n+         initialized_entries * sizeof(SdcLogEntry));\n+\n+  return entries;\n+}\n+\n+}  // namespace stream_executor::cuda"
        },
        {
            "sha": "2e435af34bcff54187482f76d072a2346b221863",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_log.h",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log.h?ref=7b50e62d2bedd993c196cb99615222dbe5e78728",
            "patch": "@@ -0,0 +1,113 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_STREAM_EXECUTOR_CUDA_SDC_LOG_H_\n+#define XLA_STREAM_EXECUTOR_CUDA_SDC_LOG_H_\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"xla/stream_executor/device_memory.h\"\n+#include \"xla/stream_executor/device_memory_allocator.h\"\n+#include \"xla/stream_executor/stream.h\"\n+\n+namespace stream_executor::cuda {\n+\n+struct SdcLogEntry {\n+  // An ID that uniquely identifies a thunk and its specific input or output\n+  // buffer.\n+  uint32_t entry_id;\n+  uint32_t checksum;\n+};\n+\n+// The struct layout must match on both host and device.\n+static_assert(_Alignof(SdcLogEntry) == _Alignof(uint32_t));\n+static_assert(sizeof(SdcLogEntry) == sizeof(uint32_t) * 2);\n+static_assert(offsetof(SdcLogEntry, entry_id) == 0);\n+static_assert(offsetof(SdcLogEntry, checksum) == sizeof(uint32_t));\n+\n+struct SdcLogHeader {\n+  // The first entry in `SdcLogEntry` following the header that has not\n+  // been written to. May be bigger than `capacity` if the log was truncated.\n+  uint32_t write_idx;\n+  // The number of `SdcLogEntry` structs the log can hold.\n+  uint32_t capacity;\n+};\n+\n+// The struct layout must match on both host and device.\n+static_assert(_Alignof(SdcLogHeader) == _Alignof(uint32_t));\n+static_assert(sizeof(SdcLogHeader) == sizeof(uint32_t) * 2);\n+static_assert(offsetof(SdcLogHeader, write_idx) == 0);\n+static_assert(offsetof(SdcLogHeader, capacity) == sizeof(uint32_t));\n+\n+// A device memory buffer that holds a SdcLogHeader and a variable number of\n+// SdcLogEntry structs.\n+class SdcLog {\n+ public:\n+  // Uses `allocator` to allocate an empty `SdcLog` on the device with enough\n+  // capacity to hold `max_entries` of `SdcLogEntry` structs.\n+  //\n+  // `allocator` must be associated with the same device as `stream`, and must\n+  // outlive the returned `SdcLog`.\n+  //\n+  // Contents of the log can be retrieved with `SdcLog::ReadFromDevice`.\n+  static absl::StatusOr<SdcLog> CreateOnDevice(\n+      uint32_t max_entries, Stream& stream, DeviceMemoryAllocator& allocator);\n+\n+  // Reads the header from the device log.\n+  //\n+  // `stream` must be associated with the same device as the one used to create\n+  // the log.\n+  absl::StatusOr<SdcLogHeader> ReadHeaderFromDevice(Stream& stream) const;\n+\n+  // Reads all entries from the device log into host memory.\n+  //\n+  // Returned vector contains all initialized entries. If the log overflowed,\n+  // excess elements are silently discarded.\n+  //\n+  // `stream` must be associated with the same device as the one used to create\n+  // the log.\n+  absl::StatusOr<std::vector<SdcLogEntry>> ReadFromDevice(Stream& stream) const;\n+\n+  // Returns a view of the `SdcLogHeader`.\n+  //\n+  // The returned `DeviceMemory` gets invalidated when the `SdcLog` is\n+  // destroyed.\n+  DeviceMemory<SdcLogHeader> GetDeviceHeader() const {\n+    return DeviceMemory<SdcLogHeader>(\n+        memory_->GetByteSlice(0, sizeof(SdcLogHeader)));\n+  }\n+\n+  // Returns a view of the `SdcLogEntry` array.\n+  //\n+  // The returned `DeviceMemory` gets invalidated when the `SdcLog` is\n+  // destroyed.\n+  DeviceMemory<SdcLogEntry> GetDeviceEntries() const {\n+    return DeviceMemory<SdcLogEntry>(memory_->GetByteSlice(\n+        sizeof(SdcLogHeader), memory_->size() - sizeof(SdcLogHeader)));\n+  }\n+\n+ private:\n+  explicit SdcLog(OwningDeviceMemory&& memory) : memory_(std::move(memory)) {}\n+\n+  OwningDeviceMemory memory_;\n+};\n+\n+}  // namespace stream_executor::cuda\n+\n+#endif  // XLA_STREAM_EXECUTOR_CUDA_SDC_LOG_H_"
        },
        {
            "sha": "4611d5311c725539dc8f4b79c54b6011fc6ea2ab",
            "filename": "third_party/xla/xla/stream_executor/cuda/sdc_log_test.cc",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7b50e62d2bedd993c196cb99615222dbe5e78728/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Fcuda%2Fsdc_log_test.cc?ref=7b50e62d2bedd993c196cb99615222dbe5e78728",
            "patch": "@@ -0,0 +1,87 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/stream_executor/cuda/sdc_log.h\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+\n+#include <gtest/gtest.h>\n+#include \"xla/stream_executor/platform.h\"\n+#include \"xla/stream_executor/platform_manager.h\"\n+#include \"xla/stream_executor/stream.h\"\n+#include \"xla/stream_executor/stream_executor.h\"\n+#include \"xla/stream_executor/stream_executor_memory_allocator.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace se = stream_executor;\n+\n+namespace {\n+\n+class SdcLogTest : public ::testing::Test {\n+ protected:\n+  void SetUp() override {\n+    TF_ASSERT_OK_AND_ASSIGN(platform_,\n+                            se::PlatformManager::PlatformWithName(\"CUDA\"));\n+    TF_ASSERT_OK_AND_ASSIGN(executor_, platform_->ExecutorForDevice(0));\n+    TF_ASSERT_OK_AND_ASSIGN(stream_, executor_->CreateStream(std::nullopt));\n+    allocator_ =\n+        std::make_unique<se::StreamExecutorMemoryAllocator>(stream_->parent());\n+  }\n+\n+  se::Platform* platform_;\n+  se::StreamExecutor* executor_;\n+  std::unique_ptr<se::Stream> stream_;\n+  std::unique_ptr<se::StreamExecutorMemoryAllocator> allocator_;\n+};\n+\n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_AllocatesEmptyLog) {\n+  TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLog device_log,\n+                          se::cuda::SdcLog::CreateOnDevice(\n+                              /*max_entries=*/10, *stream_, *allocator_));\n+  TF_ASSERT_OK_AND_ASSIGN(auto host_log, device_log.ReadFromDevice(*stream_));\n+\n+  EXPECT_EQ(host_log.size(), 0);\n+}\n+\n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_AllocatesEnoughSpace) {\n+  constexpr uint32_t kMaxEntries = 10;\n+  constexpr size_t kExpectedHeaderSize = sizeof(se::cuda::SdcLogHeader);\n+  constexpr size_t kExpectedEntriesSize =\n+      sizeof(se::cuda::SdcLogEntry) * kMaxEntries;\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      se::cuda::SdcLog device_log,\n+      se::cuda::SdcLog::CreateOnDevice(kMaxEntries, *stream_, *allocator_));\n+  EXPECT_EQ(device_log.GetDeviceHeader().size(), kExpectedHeaderSize);\n+  EXPECT_EQ(device_log.GetDeviceEntries().size(), kExpectedEntriesSize);\n+}\n+\n+TEST_F(SdcLogTest, CreateSdcLogOnDevice_InitializesHeader) {\n+  constexpr uint32_t kMaxEntries = 10;\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      se::cuda::SdcLog device_log,\n+      se::cuda::SdcLog::CreateOnDevice(kMaxEntries, *stream_, *allocator_));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(se::cuda::SdcLogHeader header,\n+                          device_log.ReadHeaderFromDevice(*stream_));\n+  EXPECT_EQ(header.write_idx, 0);\n+  EXPECT_EQ(header.capacity, kMaxEntries);\n+}\n+\n+}  // namespace"
        }
    ],
    "stats": {
        "total": 319,
        "additions": 319,
        "deletions": 0
    }
}