{
    "author": "hawkinsp",
    "message": "[XLA:Python] Fix Python profiler hooks under Python free threading.\n\nPiperOrigin-RevId: 815072110",
    "sha": "d36ddc31f6d687c0e17c927f098dfe986126ae67",
    "files": [
        {
            "sha": "bcb97ab2f164e2c3869463ac79b6709f16288df2",
            "filename": "third_party/xla/xla/python/profiler/internal/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d36ddc31f6d687c0e17c927f098dfe986126ae67/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d36ddc31f6d687c0e17c927f098dfe986126ae67/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2FBUILD?ref=d36ddc31f6d687c0e17c927f098dfe986126ae67",
            "patch": "@@ -30,8 +30,10 @@ cc_library(\n         \"//xla/tsl/profiler/utils:xplane_utils\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/memory\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n         \"@local_tsl//tsl/platform:path\",\n         \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n         \"@pybind11\","
        },
        {
            "sha": "052a2a06da60214400d15e8fc208f2a5fa12cdb4",
            "filename": "third_party/xla/xla/python/profiler/internal/python_hooks.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 39,
            "changes": 80,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d36ddc31f6d687c0e17c927f098dfe986126ae67/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2Fpython_hooks.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d36ddc31f6d687c0e17c927f098dfe986126ae67/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2Fpython_hooks.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2Fpython_hooks.cc?ref=d36ddc31f6d687c0e17c927f098dfe986126ae67",
            "patch": "@@ -14,10 +14,11 @@ limitations under the License.\n ==============================================================================*/\n #include \"xla/python/profiler/internal/python_hooks.h\"\n \n-#include <atomic>\n #include <cstdint>\n #include <string>\n+#include <utility>\n \n+#include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n@@ -30,6 +31,10 @@ limitations under the License.\n #include \"tsl/platform/path.h\"\n #include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n+#ifdef Py_GIL_DISABLED\n+#include \"absl/synchronization/mutex.h\"\n+#endif  // Py_GIL_DISABLED\n+\n namespace xla {\n namespace profiler {\n \n@@ -66,11 +71,7 @@ std::string GetEventName(absl::string_view method_name, PyObject* module) {\n   // Use module name and function/method name instead.\n   std::string filename;\n   bool filename_ok;\n-#if PY_MAJOR_VERSION < 3\n-  filename_ok = (module != nullptr && PyString_Check(module));\n-#else\n   filename_ok = (module != nullptr && PyUnicode_Check(module));\n-#endif\n   if (filename_ok) {\n     filename = py::reinterpret_borrow<py::str>(module);\n   } else {\n@@ -142,17 +143,6 @@ void PythonHookContext::Start(const PythonHooksOptions& options) {\n     return;\n   }\n \n-#if PY_MAJOR_VERSION < 3 || (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 7)\n-  // Before Python 3.7, the GIL is created on demand by PyEval_InitThreads().\n-  // When a thread was not started by Python (e.g., when starting profiling via\n-  // RPC) there might be no GIL. Before Python 3.6, PyGILState_Ensure would\n-  // crash. The crash was fixed in Python 3.6 but the fix introduced a race for\n-  // GIL creation. Calling PyEval_InitThreads() prevents the race. This is a\n-  // no-op when called for a second time so it is innocuous. See\n-  // https://vstinner.github.io/python37-gil-change.html for details.\n-  PyEval_InitThreads();\n-#endif\n-\n   options_ = options;\n   start_timestamp_ns_ = tsl::profiler::GetCurrentTimeNanos();\n   if (options_.enable_python_traceme || options_.enable_trace_python_function) {\n@@ -209,29 +199,35 @@ void PythonHookContext::CollectData(tensorflow::profiler::XPlane* raw_plane) {\n     raw_plane = &*end_to_end_xplane_;\n   }\n   tsl::profiler::XPlaneBuilder plane(raw_plane);\n-  for (auto& it : entries_) {\n-    int64_t thread_id = it.first;\n-    auto& thread_events = it.second;\n-    VLOG(1) << \"Collecting \" << thread_events.completed.size() << \":\"\n-            << thread_events.active.size() << \" events on thread \" << thread_id;\n-    auto line = plane.GetOrCreateLine(thread_id);\n-    line.SetTimestampNs(start_timestamp_ns_);\n-    for (const auto& event : thread_events.completed) {\n-      AddEventToXLine(event, &line, &plane);\n-    }\n-    if (options_.include_incomplete_events) {\n-      uint64_t now = tsl::profiler::GetCurrentTimeNanos();\n-      while (!thread_events.active.empty()) {\n-        auto& event = thread_events.active.top();\n-        event.end_time_ns = now;\n+  for (auto& shard : entry_shards_) {\n+#ifdef Py_GIL_DISABLED\n+    absl::MutexLock lock(shard.mu);\n+#else\n+    DCHECK(PyGILState_Check());\n+#endif  // Py_GIL_DISABLED\n+    for (auto& it : shard.entries) {\n+      int64_t thread_id = it.first;\n+      auto& thread_events = it.second;\n+      VLOG(1) << \"Collecting \" << thread_events.completed.size() << \":\"\n+              << thread_events.active.size() << \" events on thread \"\n+              << thread_id;\n+      auto line = plane.GetOrCreateLine(thread_id);\n+      line.SetTimestampNs(start_timestamp_ns_);\n+      for (const auto& event : thread_events.completed) {\n         AddEventToXLine(event, &line, &plane);\n-        thread_events.active.pop();\n+      }\n+      if (options_.include_incomplete_events) {\n+        uint64_t now = tsl::profiler::GetCurrentTimeNanos();\n+        while (!thread_events.active.empty()) {\n+          auto& event = thread_events.active.top();\n+          event.end_time_ns = now;\n+          AddEventToXLine(event, &line, &plane);\n+          thread_events.active.pop();\n+        }\n       }\n     }\n+    shard.entries.clear();\n   }\n-  PyGILState_STATE gil_state = PyGILState_Ensure();\n-  entries_.clear();\n-  PyGILState_Release(gil_state);\n }\n \n void PythonHookContext::Finalize(tensorflow::profiler::XSpace* space) {\n@@ -293,7 +289,14 @@ void PythonHookContext::ProfileFast(PyFrameObject* frame, int what,\n                                     PyObject* arg) {\n   const int64_t thread_id = tsl::Env::Default()->GetCurrentThreadId();\n   uint64_t now = tsl::profiler::GetCurrentTimeNanos();\n-  auto& thread_traces = entries_[thread_id];\n+  int shard_id = thread_id % kNumEntryShards;\n+  EntryShard& shard = entry_shards_[shard_id];\n+#ifdef Py_GIL_DISABLED\n+  absl::MutexLock lock(shard.mu);\n+#else\n+  DCHECK(PyGILState_Check());\n+#endif  // Py_GIL_DISABLED\n+  auto& thread_traces = shard.entries[thread_id];\n \n   switch (what) {\n     case PyTrace_CALL: {\n@@ -330,7 +333,7 @@ void PythonHookContext::ProfileFast(PyFrameObject* frame, int what,\n       if (PyCFunction_Check(arg)) {\n         // Python stack does not have a filename/line_no for native calls.\n         auto* func = reinterpret_cast<PyCFunctionObject*>(arg);\n-        entries_[thread_id].active_c.emplace(now, 0, func);\n+        thread_traces.active_c.emplace(now, 0, func);\n       }\n       break;\n     }\n@@ -346,8 +349,7 @@ void PythonHookContext::ProfileFast(PyFrameObject* frame, int what,\n           // Only the end of the events is recorded, use profiler start as\n           // start timestamp of the new event.\n           auto* func = reinterpret_cast<PyCFunctionObject*>(arg);\n-          entries_[thread_id].completed.emplace_back(start_timestamp_ns_, now,\n-                                                     func);\n+          thread_traces.completed.emplace_back(start_timestamp_ns_, now, func);\n         }\n       }\n       break;"
        },
        {
            "sha": "fd1ffbf4c925c3e97f4a434410b76a630fd0d517",
            "filename": "third_party/xla/xla/python/profiler/internal/python_hooks.h",
            "status": "modified",
            "additions": 21,
            "deletions": 3,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d36ddc31f6d687c0e17c927f098dfe986126ae67/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2Fpython_hooks.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d36ddc31f6d687c0e17c927f098dfe986126ae67/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2Fpython_hooks.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fprofiler%2Finternal%2Fpython_hooks.h?ref=d36ddc31f6d687c0e17c927f098dfe986126ae67",
            "patch": "@@ -15,24 +15,28 @@ limitations under the License.\n #ifndef XLA_PYTHON_PROFILER_INTERNAL_PYTHON_HOOKS_H_\n #define XLA_PYTHON_PROFILER_INTERNAL_PYTHON_HOOKS_H_\n \n+#include <array>\n+#include <cstddef>\n #include <cstdint>\n #include <deque>\n #include <memory>\n #include <optional>\n #include <stack>\n #include <string>\n #include <utility>\n-#include <vector>\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/memory/memory.h\"\n #include \"pybind11/cast.h\"\n #include \"pybind11/pybind11.h\"\n #include \"pybind11/pytypes.h\"\n #include \"xla/tsl/platform/macros.h\"\n-#include \"xla/tsl/platform/types.h\"\n #include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n+#ifdef Py_GIL_DISABLED\n+#include \"absl/synchronization/mutex.h\"\n+#endif  // Py_GIL_DISABLED\n+\n namespace xla {\n namespace profiler {\n \n@@ -141,7 +145,21 @@ class PythonHookContext {\n \n   // The thread id to entries map, Note: by convention the thread id is\n   // int64_t to be consistent with cpu tracer when serialize to Xspace.\n-  absl::flat_hash_map<int64_t, PerThreadEvents> entries_;\n+  struct EntryShard {\n+    // If the GIL is enabled, this data structure is protected by the GIL.\n+    // Otherwise, it is protected by mu.\n+#ifdef Py_GIL_DISABLED\n+    absl::Mutex mu;\n+#endif  // Py_GIL_DISABLED\n+    absl::flat_hash_map<int64_t, PerThreadEvents> entries;\n+  };\n+\n+#ifdef Py_GIL_DISABLED\n+  static constexpr size_t kNumEntryShards = 16;\n+#else   // Py_GIL_DISABLED\n+  static constexpr size_t kNumEntryShards = 1;\n+#endif  // Py_GIL_DISABLED\n+  std::array<EntryShard, kNumEntryShards> entry_shards_;\n   uint64_t start_timestamp_ns_;\n   PythonHooksOptions options_;\n   // In end to end mode, Python get uninitialized before Stop()/Finalize(), we"
        }
    ],
    "stats": {
        "total": 106,
        "additions": 64,
        "deletions": 42
    }
}