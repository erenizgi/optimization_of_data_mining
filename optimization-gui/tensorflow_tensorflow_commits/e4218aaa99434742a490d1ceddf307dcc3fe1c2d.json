{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 808482131",
    "sha": "e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
    "files": [
        {
            "sha": "4e8daeb8f04dde6a23235fdabd617d885abf41df",
            "filename": "tensorflow/core/framework/attr_value_util_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fattr_value_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fattr_value_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fattr_value_util_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -143,7 +143,7 @@ TEST(AttrValueUtil, DeepAttr) {\n TEST(AttrValueUtil, SummarizeAttrValueDoesNotElideShortStrings) {\n   AttrValue attr_value;\n   SetAttrValue(string(40, '-'), &attr_value);\n-  EXPECT_EQ(strings::StrCat(\"\\\"\", string(40, '-'), \"\\\"\"),\n+  EXPECT_EQ(absl::StrCat(\"\\\"\", string(40, '-'), \"\\\"\"),\n             SummarizeAttrValue(attr_value));\n }\n "
        },
        {
            "sha": "b2f4b856ec9feb125ed17d9ad8c939f2428a36c2",
            "filename": "tensorflow/core/framework/collective.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 26,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fcollective.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fcollective.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fcollective.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -49,8 +49,8 @@ std::vector<RegistrationInfo>* MutableCollectiveRegistry() {\n }  // namespace\n \n string CollGroupRuntimeDetails::ToString() const {\n-  return strings::StrCat(\"CollGroupRuntimeDetails {communicator_key=\",\n-                         absl::CEscape(communicator_key), \"}\");\n+  return absl::StrCat(\"CollGroupRuntimeDetails {communicator_key=\",\n+                      absl::CEscape(communicator_key), \"}\");\n }\n \n string CollGroupParams::ToString() const {\n@@ -59,13 +59,13 @@ string CollGroupParams::ToString() const {\n       \" device_type=\", device_type.type_string(), \" num_tasks=\", num_tasks,\n       \" runtime_details=\", runtime_details.ToString(), \" devices {\");\n   for (const auto& m : members) {\n-    strings::StrAppend(&v, m.device.name(), \",\");\n+    absl::StrAppend(&v, m.device.name(), \",\");\n   }\n-  strings::StrAppend(&v, \"} num_devices_per_task={\");\n+  absl::StrAppend(&v, \"} num_devices_per_task={\");\n   for (const auto& dpt : num_devices_per_task) {\n-    strings::StrAppend(&v, dpt.first, \": \", dpt.second, \", \");\n+    absl::StrAppend(&v, dpt.first, \": \", dpt.second, \", \");\n   }\n-  strings::StrAppend(&v, \"}\");\n+  absl::StrAppend(&v, \"}\");\n   return v;\n }\n \n@@ -99,51 +99,51 @@ string CollInstanceParams::ToString() const {\n       strings::StrCat(\"CollInstanceParams { instance_key=\", instance_key,\n                       \" type=\", type, \" data_type=\", DataTypeString(data_type),\n                       \" shape=\", shape.DebugString(), \" devices {\");\n-  strings::StrAppend(&v, \"}, collective_name=\", impl_details.collective_name,\n-                     \", subdiv_offsets={\");\n-  strings::StrAppend(&v, \"}, subdiv_offsets={\");\n+  absl::StrAppend(&v, \"}, collective_name=\", impl_details.collective_name,\n+                  \", subdiv_offsets={\");\n+  absl::StrAppend(&v, \"}, subdiv_offsets={\");\n   for (const auto& d : impl_details.subdiv_offsets) {\n-    strings::StrAppend(&v, d, \",\");\n+    absl::StrAppend(&v, d, \",\");\n   }\n-  strings::StrAppend(&v, \"}, subdiv_perms={\");\n+  absl::StrAppend(&v, \"}, subdiv_perms={\");\n   for (const auto& p : impl_details.subdiv_permutations) {\n-    strings::StrAppend(&v, \"{\");\n+    absl::StrAppend(&v, \"{\");\n     for (const auto& i : p) {\n-      strings::StrAppend(&v, i, \",\");\n+      absl::StrAppend(&v, i, \",\");\n     }\n-    strings::StrAppend(&v, \"}\");  // one subdiv\n+    absl::StrAppend(&v, \"}\");  // one subdiv\n   }\n   if (!impl_details.subdiv_source_rank.empty()) {\n-    strings::StrAppend(&v, \" subdiv_source_rank={\");\n+    absl::StrAppend(&v, \" subdiv_source_rank={\");\n     for (const auto& r : impl_details.subdiv_source_rank) {\n-      strings::StrAppend(&v, r, \",\");\n+      absl::StrAppend(&v, r, \",\");\n     }\n-    strings::StrAppend(&v, \"}\");\n+    absl::StrAppend(&v, \"}\");\n   }  // all subdivs\n   if (type == PERMUTE_COLLECTIVE) {\n-    strings::StrAppend(&v, \"}, permute_devices {\");\n+    absl::StrAppend(&v, \"}, permute_devices {\");\n     for (const auto& d : devices) {\n-      strings::StrAppend(&v, d, \",\");\n+      absl::StrAppend(&v, d, \",\");\n     }\n-    strings::StrAppend(&v, \"}, permute_permutation {\");\n+    absl::StrAppend(&v, \"}, permute_permutation {\");\n     for (const auto& p : permutation) {\n-      strings::StrAppend(&v, p, \",\");\n+      absl::StrAppend(&v, p, \",\");\n     }\n-    strings::StrAppend(&v, \"}\");\n+    absl::StrAppend(&v, \"}\");\n   }\n   return v;\n }\n \n string CollectiveParams::ToString() const {\n-  string v = strings::StrCat(\"CollectiveParams \", name, \" {\", group.ToString());\n-  strings::StrAppend(&v, \" \", instance.ToString());\n+  string v = absl::StrCat(\"CollectiveParams \", name, \" {\", group.ToString());\n+  absl::StrAppend(&v, \" \", instance.ToString());\n   strings::StrAppend(&v, \" default_rank=\", default_rank,\n                      \" is_source=\", is_source, \" source_rank=\", source_rank,\n                      \" subdiv_rank={\");\n   for (const auto& r : subdiv_rank) {\n-    strings::StrAppend(&v, r, \",\");\n+    absl::StrAppend(&v, r, \",\");\n   }\n-  strings::StrAppend(&v, \"}}\");\n+  absl::StrAppend(&v, \"}}\");\n   return v;\n }\n "
        },
        {
            "sha": "9bc8a20208096fcc9ce04a31237ceaf800acc4cb",
            "filename": "tensorflow/core/framework/common_shape_fns_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fcommon_shape_fns_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fcommon_shape_fns_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fcommon_shape_fns_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -42,10 +42,10 @@ OpDef MakeOpDef(int num_inputs, int num_outputs) {\n   OpRegistrationData op_reg_data;\n   OpDefBuilder b(\"dummy\");\n   for (int i = 0; i < num_inputs; ++i) {\n-    b.Input(strings::StrCat(\"i\", i, \": float\"));\n+    b.Input(absl::StrCat(\"i\", i, \": float\"));\n   }\n   for (int i = 0; i < num_outputs; ++i) {\n-    b.Output(strings::StrCat(\"o\", i, \": float\"));\n+    b.Output(absl::StrCat(\"o\", i, \": float\"));\n   }\n   CHECK(b.Attr(\"foo:string\").Finalize(&op_reg_data).ok());\n   return op_reg_data.op_def;\n@@ -1790,7 +1790,7 @@ TEST(CommonShapeFnsTest, ReduceScatter_NotEvenlyDivisible) {\n   EXPECT_EQ(3, c.num_inputs());\n   EXPECT_EQ(1, c.num_outputs());\n   EXPECT_THAT(ReduceScatterShape(&c),\n-              tensorflow::testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::INVALID_ARGUMENT,\n                   \"Dimension size must be evenly divisible by 2 but is 3\"));\n }\n@@ -1818,7 +1818,7 @@ TEST(CommonShapeFnsTest, ReduceScatter_INVALID_GROUP_ASSIGNMENT) {\n   EXPECT_EQ(3, c.num_inputs());\n   EXPECT_EQ(1, c.num_outputs());\n   EXPECT_THAT(ReduceScatterShape(&c),\n-              tensorflow::testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::INVALID_ARGUMENT,\n                   \"ReduceScatter group_assignment should be rank 2\"));\n }"
        },
        {
            "sha": "491eb5293f22ad2403160be4da088a7738f7f458",
            "filename": "tensorflow/core/framework/dataset.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fdataset.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fdataset.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fdataset.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -59,7 +59,7 @@ static std::unordered_set<string>* get_dataset_op_registry() {\n \n std::string UniqueNodeName(const std::string& base) {\n   static std::atomic<int64_t> counter(0);\n-  return strings::StrCat(base, \"/\", counter.fetch_add(1));\n+  return absl::StrCat(base, \"/\", counter.fetch_add(1));\n }\n \n // A wrapper class for storing a `DatasetBase` instance in a DT_VARIANT tensor.\n@@ -780,7 +780,7 @@ void DatasetBase::Initialize(const Metadata& metadata) {\n   if (metadata_.name() == \"\") {\n     static std::atomic<int64_t> id_counter(0);\n     *metadata_.mutable_name() =\n-        strings::StrCat(type_string(), \":\", id_counter.fetch_add(1));\n+        absl::StrCat(type_string(), \":\", id_counter.fetch_add(1));\n   }\n }\n \n@@ -886,7 +886,7 @@ absl::Status DatasetBase::MakeIterator(\n   tsl::profiler::TraceMe traceme(\n       [&] {\n         return tsl::profiler::TraceMeEncode(\n-            strings::StrCat(\"MakeIterator::\", type_string()), {});\n+            absl::StrCat(\"MakeIterator::\", type_string()), {});\n       },\n       tsl::profiler::TraceMeLevel::kInfo);\n   *iterator = MakeIteratorInternal(output_prefix);\n@@ -1079,22 +1079,22 @@ DatasetBaseIterator::DatasetBaseIterator(const BaseParams& params)\n     : params_(params) {\n   params_.dataset->Ref();\n   VLOG(2) << prefix() << \" constructor\";\n-  strings::StrAppend(&traceme_metadata_, \"name=\", dataset()->metadata().name());\n-  strings::StrAppend(&traceme_metadata_, \",shapes=\");\n+  absl::StrAppend(&traceme_metadata_, \"name=\", dataset()->metadata().name());\n+  absl::StrAppend(&traceme_metadata_, \",shapes=\");\n   auto& shapes = output_shapes();\n   for (int i = 0; i < shapes.size(); ++i) {\n     if (i > 0) {\n-      strings::StrAppend(&traceme_metadata_, \" \");\n+      absl::StrAppend(&traceme_metadata_, \" \");\n     }\n-    strings::StrAppend(&traceme_metadata_, shapes.at(i).DebugString());\n+    absl::StrAppend(&traceme_metadata_, shapes.at(i).DebugString());\n   }\n-  strings::StrAppend(&traceme_metadata_, \",types=\");\n+  absl::StrAppend(&traceme_metadata_, \",types=\");\n   auto& types = output_dtypes();\n   for (int i = 0; i < types.size(); ++i) {\n     if (i > 0) {\n-      strings::StrAppend(&traceme_metadata_, \" \");\n+      absl::StrAppend(&traceme_metadata_, \" \");\n     }\n-    strings::StrAppend(&traceme_metadata_, DataTypeString(types.at(i)));\n+    absl::StrAppend(&traceme_metadata_, DataTypeString(types.at(i)));\n   }\n }\n \n@@ -1107,24 +1107,24 @@ string DatasetBaseIterator::BuildTraceMeName() {\n   string result =\n       strings::StrCat(params_.prefix, \"#\", traceme_metadata_, \",id=\", id_);\n   if (parent_) {\n-    strings::StrAppend(&result, \",parent_id=\", parent_id_);\n+    absl::StrAppend(&result, \",parent_id=\", parent_id_);\n   }\n   TraceMeMetadata metadata = GetTraceMeMetadata();\n   for (const auto& pair : metadata) {\n-    strings::StrAppend(&result, \",\", pair.first, \"=\", pair.second);\n+    absl::StrAppend(&result, \",\", pair.first, \"=\", pair.second);\n   }\n   if (model_node() != nullptr) {\n     if (model_node()->buffered_elements() > 0) {\n-      strings::StrAppend(\n+      absl::StrAppend(\n           &result, \",buffered_elements=\",\n           static_cast<long long>(model_node()->buffered_elements()));\n-      strings::StrAppend(\n+      absl::StrAppend(\n           &result, \",buffered_bytes_MB=\",\n           static_cast<long long>(\n               static_cast<double>(model_node()->buffered_bytes()) * 1e-6));\n     }\n   }\n-  strings::StrAppend(&result, \"#\");\n+  absl::StrAppend(&result, \"#\");\n   return result;\n }\n "
        },
        {
            "sha": "2b778ca0134c7068df8c6e277aeb98eae48e3ac0",
            "filename": "tensorflow/core/framework/function.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 67,
            "changes": 133,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ffunction.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ffunction.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ffunction.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -200,7 +200,7 @@ class FunctionInstantiationHelper {\n         AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n     // Creates dtypes.size() nodes in the graph.\n     for (size_t i = 0; i < dtypes.size(); ++i) {\n-      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n+      TF_RETURN_IF_ERROR(AddItem(absl::StrCat(arg_def.name(), \":\", i),\n                                  {true, arg_index, 0, false, {dtypes[i]}}));\n       if (arg_index != result_.nodes.size()) {\n         return errors::Internal(\n@@ -209,7 +209,7 @@ class FunctionInstantiationHelper {\n       }\n       string name = arg_def.name();\n       if (dtypes.size() > 1) {\n-        strings::StrAppend(&name, \"_\", i);\n+        absl::StrAppend(&name, \"_\", i);\n       }\n       NodeDef* gnode = AddNode(name);\n       if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n@@ -260,12 +260,12 @@ class FunctionInstantiationHelper {\n       // Note that we rely on the backwards-compatibility test enforcing\n       // that output_arg(*).name() doesn't change here.\n       const string base_name =\n-          strings::StrCat(node.name(), \":\", node_sig->output_arg(i).name());\n+          absl::StrCat(node.name(), \":\", node_sig->output_arg(i).name());\n       TF_RETURN_IF_ERROR(\n           AddItem(base_name, {false, arg_index, start, is_type_list, dtypes}));\n       for (int j = 0; j < static_cast<int>(dtypes.size()); ++j) {\n         TF_RETURN_IF_ERROR(\n-            AddItem(strings::StrCat(base_name, \":\", j),\n+            AddItem(absl::StrCat(base_name, \":\", j),\n                     {false, arg_index, start + j, false, {dtypes[j]}}));\n       }\n       start += dtypes.size();\n@@ -401,9 +401,9 @@ class FunctionInstantiationHelper {\n                                      DataTypeVectorString(item->dtypes));\n     }\n     for (size_t i = 0; i < dtypes.size(); ++i) {\n-      string name = strings::StrCat(ret_def.name(), \"_RetVal\");\n+      string name = absl::StrCat(ret_def.name(), \"_RetVal\");\n       if (dtypes.size() > 1) {\n-        strings::StrAppend(&name, \"_\", i);\n+        absl::StrAppend(&name, \"_\", i);\n       }\n       NodeDef* gnode = AddNode(name);\n       if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n@@ -459,8 +459,8 @@ class FunctionInstantiationHelper {\n   absl::Status AddItem(const string& name, const NameInfoItem& item) {\n     if (!index_.insert({name, item}).second) {\n       return errors::InvalidArgument(\n-          strings::StrCat(\"Duplicated \", item.is_func_arg ? \"arg\" : \"ret\",\n-                          \" name: \"),\n+          absl::StrCat(\"Duplicated \", item.is_func_arg ? \"arg\" : \"ret\",\n+                       \" name: \"),\n           name);\n     }\n     return absl::OkStatus();\n@@ -471,7 +471,7 @@ class FunctionInstantiationHelper {\n   }\n \n   string Dep(int node_index) const {\n-    return strings::StrCat(\"^\", Name(node_index));\n+    return absl::StrCat(\"^\", Name(node_index));\n   }\n \n   string Name(int node_index) const {\n@@ -483,7 +483,7 @@ class FunctionInstantiationHelper {\n     if (output_index == 0) {\n       return Name(node_index);\n     } else {\n-      return strings::StrCat(Name(node_index), \":\", output_index);\n+      return absl::StrCat(Name(node_index), \":\", output_index);\n     }\n   }\n \n@@ -527,17 +527,17 @@ class FunctionInstantiationHelper {\n // Various helpers Print(proto) to print relevant protos to ascii.\n string Print(const OpDef::ArgDef& arg) {\n   string out;\n-  strings::StrAppend(&out, arg.name(), \":\");\n-  if (arg.is_ref()) strings::StrAppend(&out, \"Ref(\");\n+  absl::StrAppend(&out, arg.name(), \":\");\n+  if (arg.is_ref()) absl::StrAppend(&out, \"Ref(\");\n   if (!arg.number_attr().empty()) {\n-    strings::StrAppend(&out, arg.number_attr(), \"*\");\n+    absl::StrAppend(&out, arg.number_attr(), \"*\");\n   }\n   if (arg.type() != DT_INVALID) {\n-    strings::StrAppend(&out, DataTypeString(arg.type()));\n+    absl::StrAppend(&out, DataTypeString(arg.type()));\n   } else {\n-    strings::StrAppend(&out, arg.type_attr());\n+    absl::StrAppend(&out, arg.type_attr());\n   }\n-  if (arg.is_ref()) strings::StrAppend(&out, \")\");\n+  if (arg.is_ref()) absl::StrAppend(&out, \")\");\n   return out;\n }\n \n@@ -553,51 +553,50 @@ string Print(const AttrValue& attr_value,\n              (attr_value.list().type_size() > 0)) {\n     string ret = \"{\";\n     for (int i = 0; i < attr_value.list().type_size(); ++i) {\n-      if (i > 0) strings::StrAppend(&ret, \", \");\n-      strings::StrAppend(&ret, DataTypeString(attr_value.list().type(i)));\n+      if (i > 0) absl::StrAppend(&ret, \", \");\n+      absl::StrAppend(&ret, DataTypeString(attr_value.list().type(i)));\n     }\n-    strings::StrAppend(&ret, \"}\");\n+    absl::StrAppend(&ret, \"}\");\n     return ret;\n   } else if (attr_value.value_case() == AttrValue::kFunc) {\n     if (attr_value.func().attr_size() == 0) {\n       return attr_value.func().name();\n     }\n     std::vector<string> entries;\n     for (const auto& p : attr_value.func().attr()) {\n-      entries.push_back(strings::StrCat(p.first, \"=\", Print(p.second)));\n+      entries.push_back(absl::StrCat(p.first, \"=\", Print(p.second)));\n     }\n     std::sort(entries.begin(), entries.end());\n-    return strings::StrCat(attr_value.func().name(), \"[\",\n-                           absl::StrJoin(entries, \", \"), \"]\");\n+    return absl::StrCat(attr_value.func().name(), \"[\",\n+                        absl::StrJoin(entries, \", \"), \"]\");\n   } else if (attr_value.value_case() == AttrValue::kS && hash_string_attrs) {\n-    return strings::StrCat(Fingerprint64(attr_value.s()));\n+    return absl::StrCat(Fingerprint64(attr_value.s()));\n   }\n   return SummarizeAttrValue(attr_value);\n }\n \n // TODO(josh11b): Merge this with SummarizeNodeDef().\n string Print(const NodeDef& n) {\n   string out;\n-  strings::StrAppend(&out, n.name(), \" = \", n.op());\n+  absl::StrAppend(&out, n.name(), \" = \", n.op());\n   if (n.attr_size() > 0) {\n     std::vector<string> entries;\n     for (auto& a : n.attr()) {\n-      entries.push_back(strings::StrCat(a.first, \"=\", Print(a.second)));\n+      entries.push_back(absl::StrCat(a.first, \"=\", Print(a.second)));\n     }\n     std::sort(entries.begin(), entries.end());\n     // Add a short device string at the end of all attributes.\n     if (!n.device().empty()) {\n       DeviceNameUtils::ParsedName parsed;\n       if (DeviceNameUtils::ParseFullName(n.device(), &parsed)) {\n-        entries.push_back(\n-            strings::StrCat(\"device=\", parsed.type, \":\", parsed.id));\n+        entries.push_back(absl::StrCat(\"device=\", parsed.type, \":\", parsed.id));\n       } else {\n         entries.push_back(\"device=<FAILED_TO_PARSE>\");\n       }\n     }\n-    strings::StrAppend(&out, \"[\", absl::StrJoin(entries, \", \"), \"]\");\n+    absl::StrAppend(&out, \"[\", absl::StrJoin(entries, \", \"), \"]\");\n   }\n-  strings::StrAppend(&out, \"(\");\n+  absl::StrAppend(&out, \"(\");\n   std::vector<absl::string_view> dat;\n   std::vector<string> dep;\n   for (absl::string_view s : n.input()) {\n@@ -607,51 +606,51 @@ string Print(const NodeDef& n) {\n       dat.push_back(s);\n     }\n   }\n-  strings::StrAppend(&out, absl::StrJoin(dat, \", \"), \")\");\n+  absl::StrAppend(&out, absl::StrJoin(dat, \", \"), \")\");\n   if (!dep.empty()) {\n-    strings::StrAppend(&out, \" @ \", absl::StrJoin(dep, \", \"));\n+    absl::StrAppend(&out, \" @ \", absl::StrJoin(dep, \", \"));\n   }\n   return out;\n }\n \n string Print(const FunctionDef& fdef) {\n   string out;\n   const OpDef& sig = fdef.signature();\n-  strings::StrAppend(&out, \"\\n\", sig.name());\n+  absl::StrAppend(&out, \"\\n\", sig.name());\n   if (sig.attr_size() > 0) {\n-    strings::StrAppend(&out, \"[\");\n+    absl::StrAppend(&out, \"[\");\n     for (int i = 0; i < sig.attr_size(); ++i) {\n       const auto& a = sig.attr(i);\n-      if (i > 0) strings::StrAppend(&out, \", \");\n+      if (i > 0) absl::StrAppend(&out, \", \");\n       if (a.type() == \"type\") {\n-        strings::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n+        absl::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n       } else {\n-        strings::StrAppend(&out, a.name(), \":\", a.type());\n+        absl::StrAppend(&out, a.name(), \":\", a.type());\n       }\n     }\n-    strings::StrAppend(&out, \"]\");\n+    absl::StrAppend(&out, \"]\");\n   }\n-  strings::StrAppend(&out, \"(\");\n+  absl::StrAppend(&out, \"(\");\n   for (int i = 0; i < sig.input_arg_size(); ++i) {\n-    if (i > 0) strings::StrAppend(&out, \", \");\n-    strings::StrAppend(&out, Print(sig.input_arg(i)));\n+    if (i > 0) absl::StrAppend(&out, \", \");\n+    absl::StrAppend(&out, Print(sig.input_arg(i)));\n   }\n-  strings::StrAppend(&out, \") -> (\");\n+  absl::StrAppend(&out, \") -> (\");\n   for (int i = 0; i < sig.output_arg_size(); ++i) {\n-    if (i > 0) strings::StrAppend(&out, \", \");\n-    strings::StrAppend(&out, Print(sig.output_arg(i)));\n+    if (i > 0) absl::StrAppend(&out, \", \");\n+    absl::StrAppend(&out, Print(sig.output_arg(i)));\n   }\n-  strings::StrAppend(&out, \") {\\n\");\n+  absl::StrAppend(&out, \") {\\n\");\n   for (const auto& n : fdef.node_def()) {\n-    strings::StrAppend(&out, \"  \", Print(n), \"\\n\");\n+    absl::StrAppend(&out, \"  \", Print(n), \"\\n\");\n   }\n   for (const auto& cr : fdef.control_ret()) {\n     strings::StrAppend(&out, \"  @return \", cr.first, \" = \", cr.second, \"\\n\");\n   }\n   for (const auto& r : fdef.ret()) {\n     strings::StrAppend(&out, \"  return \", r.first, \" = \", r.second, \"\\n\");\n   }\n-  strings::StrAppend(&out, \"}\\n\");\n+  absl::StrAppend(&out, \"}\\n\");\n   return out;\n }\n \n@@ -680,7 +679,7 @@ string Print(absl::Span<const NodeDef* const> nodes) {\n   std::sort(arg.begin(), arg.end(), comp);\n   std::sort(ret.begin(), ret.end(), comp);\n   string out;\n-  strings::StrAppend(&out, \"\\n(\");\n+  absl::StrAppend(&out, \"\\n(\");\n   auto get_type_and_device = [](const NodeDef& n) {\n     DataType dt;\n     if (!TryGetNodeAttr(n, \"T\", &dt)) {\n@@ -694,22 +693,22 @@ string Print(absl::Span<const NodeDef* const> nodes) {\n       } else {\n         LOG(WARNING) << \"Failed to parse device \\\"\" << n.device() << \"\\\" in \"\n                      << n.op() << \":\" << n.name();\n-        return strings::StrCat(DataTypeString(dt), \"@\",\n-                               \"<FAILED_TO_PARSE_DEVICE>\");\n+        return absl::StrCat(DataTypeString(dt), \"@\",\n+                            \"<FAILED_TO_PARSE_DEVICE>\");\n       }\n     }\n     return DataTypeString(dt);\n   };\n   for (size_t i = 0; i < arg.size(); ++i) {\n     const NodeDef* n = arg[i];\n-    if (i > 0) strings::StrAppend(&out, \", \");\n+    if (i > 0) absl::StrAppend(&out, \", \");\n     CHECK_GE(n->attr_size(), 2);\n-    strings::StrAppend(&out, n->name(), \":\", get_type_and_device(*n));\n+    absl::StrAppend(&out, n->name(), \":\", get_type_and_device(*n));\n   }\n-  strings::StrAppend(&out, \") -> (\");\n+  absl::StrAppend(&out, \") -> (\");\n   for (size_t i = 0; i < ret.size(); ++i) {\n     const NodeDef* n = ret[i];\n-    if (i > 0) strings::StrAppend(&out, \", \");\n+    if (i > 0) absl::StrAppend(&out, \", \");\n     CHECK_LE(2, n->attr_size());\n \n     // The _RetVal op should have a unique non-control input. We assert that\n@@ -720,19 +719,19 @@ string Print(absl::Span<const NodeDef* const> nodes) {\n         DCHECK_EQ(found_non_control_input, false)\n             << \"RetVal node has more than one non-control input: \"\n             << absl::StrJoin(n->input(), \", \");\n-        strings::StrAppend(&out, n->input(0), \":\", get_type_and_device(*n));\n+        absl::StrAppend(&out, n->input(0), \":\", get_type_and_device(*n));\n         found_non_control_input = true;\n       }\n     }\n     DCHECK_EQ(found_non_control_input, true)\n         << \"RetVal did not have any non-control inputs: \"\n         << absl::StrJoin(n->input(), \", \");\n   }\n-  strings::StrAppend(&out, \") {\\n\");\n+  absl::StrAppend(&out, \") {\\n\");\n   for (size_t i = 0; i < body.size(); ++i) {\n-    strings::StrAppend(&out, \"  \", Print(*body[i]), \"\\n\");\n+    absl::StrAppend(&out, \"  \", Print(*body[i]), \"\\n\");\n   }\n-  strings::StrAppend(&out, \"}\\n\");\n+  absl::StrAppend(&out, \"}\\n\");\n   return out;\n }\n \n@@ -892,11 +891,11 @@ string DebugString(absl::Span<const NodeDef> instantiated_func_nodes) {\n string DebugStringWhole(const GraphDef& gdef) {\n   string ret;\n   for (const auto& fdef : gdef.library().function()) {\n-    strings::StrAppend(&ret, Print(fdef));\n+    absl::StrAppend(&ret, Print(fdef));\n   }\n-  strings::StrAppend(&ret, \"\\n\");\n+  absl::StrAppend(&ret, \"\\n\");\n   for (const auto& ndef : gdef.node()) {\n-    strings::StrAppend(&ret, Print(ndef), \"\\n\");\n+    absl::StrAppend(&ret, Print(ndef), \"\\n\");\n   }\n   return ret;\n }\n@@ -1030,10 +1029,10 @@ class AttrKeyAndValue {\n     if (key_suffix_ >= 0) {\n       strings::StrAppend(s, first ? \"\" : \",\", key_name_, key_suffix_, \"=\", v);\n     } else {\n-      strings::StrAppend(s, first ? \"\" : \",\", key_name_, \"=\", v);\n+      absl::StrAppend(s, first ? \"\" : \",\", key_name_, \"=\", v);\n     }\n     if (add_escaped) {\n-      strings::StrAppend(s, absl::CEscape(value_));\n+      absl::StrAppend(s, absl::CEscape(value_));\n     }\n   }\n \n@@ -1132,7 +1131,7 @@ string Canonicalize(const string& funcname, AttrSlice attrs,\n                                       AttrKeyAndValue::kCEscape));\n   }\n   std::sort(entries.begin(), entries.end());\n-  string result = strings::StrCat(funcname, \"[\");\n+  string result = absl::StrCat(funcname, \"[\");\n   bool first = true;\n   for (const auto& entry : entries) {\n     entry.AppendTo(first, &result);\n@@ -1742,10 +1741,10 @@ string FunctionLibraryDefinition::UniqueFunctionName(\n     absl::string_view prefix) const {\n   tf_shared_lock l(mu_);\n   int index = 0;\n-  string name = strings::StrCat(prefix, index);\n+  string name = absl::StrCat(prefix, index);\n   while (records_.find(name) != records_.end()) {\n     ++index;\n-    name = strings::StrCat(prefix, index);\n+    name = absl::StrCat(prefix, index);\n   }\n   return name;\n }\n@@ -2082,7 +2081,7 @@ NodeDef FunctionDefHelper::Node::ToNodeDef() const {\n     n.add_input(a);\n   }\n   for (const string& d : this->dep) {\n-    n.add_input(strings::StrCat(\"^\", d));\n+    n.add_input(absl::StrCat(\"^\", d));\n   }\n   if (!this->device.empty()) {\n     n.set_device(this->device);\n@@ -2198,7 +2197,7 @@ FunctionDef FunctionDefHelper::Define(const string& name,\n       n->add_input(iter->second);\n     }\n     for (const string& d : src.dep) {\n-      n->add_input(strings::StrCat(\"^\", d));\n+      n->add_input(absl::StrCat(\"^\", d));\n     }\n \n     // Add the outputs of this node to ret_index."
        },
        {
            "sha": "c603ced808d370110e55ef47a596d12cd3c39ccc",
            "filename": "tensorflow/core/framework/graph_def_util.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_def_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_def_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fgraph_def_util.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -37,10 +37,10 @@ namespace tensorflow {\n \n string SummarizeGraphDef(const GraphDef& graph_def) {\n   string ret;\n-  strings::StrAppend(\n-      &ret, \"versions = \", graph_def.versions().ShortDebugString(), \";\\n\");\n+  absl::StrAppend(&ret, \"versions = \", graph_def.versions().ShortDebugString(),\n+                  \";\\n\");\n   for (const NodeDef& node : graph_def.node()) {\n-    strings::StrAppend(&ret, SummarizeNodeDef(node), \";\\n\");\n+    absl::StrAppend(&ret, SummarizeNodeDef(node), \";\\n\");\n   }\n   return ret;\n }"
        },
        {
            "sha": "12a1ee29fe792eff1135d185ad9a96e37e82c866",
            "filename": "tensorflow/core/framework/graph_def_util_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_def_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_def_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fgraph_def_util_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -296,7 +296,7 @@ TEST(StrippedOpListForGraphTest, FlatTest) {\n         graph_def.add_node()->set_op(\"F\");\n       } else {\n         for (const string& op : graph_ops[order]) {\n-          string name = strings::StrCat(\"name\", graph_def.node_size());\n+          string name = absl::StrCat(\"name\", graph_def.node_size());\n           NodeDef* node = graph_def.add_node();\n           node->set_name(name);\n           node->set_op(op);"
        },
        {
            "sha": "95b6287c4e56b60d3b29a11e451402a525503b22",
            "filename": "tensorflow/core/framework/graph_to_functiondef.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_to_functiondef.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_to_functiondef.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fgraph_to_functiondef.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -113,7 +113,7 @@ string NodeNameMapping::UniquifyHelper(const string& name) {\n \n   // Add a suffix to name to make it unique.\n   while (true) {\n-    const string candidate = strings::StrCat(name, \"_\", it.first->second);\n+    const string candidate = absl::StrCat(name, \"_\", it.first->second);\n     it.first->second++;\n     if (used_names_.emplace(candidate, 0).second) return candidate;\n   }\n@@ -245,7 +245,7 @@ absl::Status FillFunctionBody(\n             ParseTensorName(node->requested_inputs()[i]).ToString();\n       } else {\n         original_input_name =\n-            strings::StrCat(edge->src()->name(), \":\", edge->src_output());\n+            absl::StrCat(edge->src()->name(), \":\", edge->src_output());\n       }\n \n       const auto iter = tensor_renaming.find(original_input_name);\n@@ -272,7 +272,7 @@ absl::Status FillFunctionBody(\n             \" is not in the body. Encountered while creating function '\",\n             fn_name, \"'\");\n       }\n-      node_def->add_input(strings::StrCat(\"^\", normalized));\n+      node_def->add_input(absl::StrCat(\"^\", normalized));\n     }\n \n     // A function is stateful if any of its nodes are stateful.\n@@ -418,7 +418,7 @@ absl::Status GraphToFunctionDefHelper(\n     if (resource_arg_unique_id >= 0) {\n       (*fdef->mutable_resource_arg_unique_id())[idx] = resource_arg_unique_id;\n     }\n-    tensor_renaming[strings::StrCat(node->name(), \":\", idx)] = input_name;\n+    tensor_renaming[absl::StrCat(node->name(), \":\", idx)] = input_name;\n   }\n \n   // Populate tensor_renaming and node_names.\n@@ -443,7 +443,7 @@ absl::Status GraphToFunctionDefHelper(\n       int index_start = output.second.first;\n       int index_end = output.second.second;\n       for (int i = index_start; i < index_end; ++i) {\n-        const string& original_name = strings::StrCat(node->name(), \":\", i);\n+        const string& original_name = absl::StrCat(node->name(), \":\", i);\n         const string& new_name =\n             strings::StrCat(node_name, \":\", output_name, \":\", i - index_start);\n         // Record the mapping if this tensor is not already mapped.\n@@ -468,11 +468,10 @@ absl::Status GraphToFunctionDefHelper(\n     if (outputs[r].node->IsRetval()) {\n       Edge const* edge;\n       TF_RETURN_IF_ERROR(outputs[r].node->input_edge(0, &edge));\n-      return_value =\n-          strings::StrCat(edge->src()->name(), \":\", edge->src_output());\n+      return_value = absl::StrCat(edge->src()->name(), \":\", edge->src_output());\n     } else {\n       return_value =\n-          strings::StrCat(outputs[r].node->name(), \":\", outputs[r].index);\n+          absl::StrCat(outputs[r].node->name(), \":\", outputs[r].index);\n     }\n     const auto iter = tensor_renaming.find(return_value);\n     if (iter == tensor_renaming.end()) {\n@@ -497,7 +496,7 @@ absl::Status GraphToFunctionDefHelper(\n     // keeps more entropy.\n     std::replace(encoded.begin(), encoded.end(), '-', 'a');\n     std::replace(encoded.begin(), encoded.end(), '_', 'A');\n-    fdef->mutable_signature()->set_name(strings::StrCat(fn_name, \"_\", encoded));\n+    fdef->mutable_signature()->set_name(absl::StrCat(fn_name, \"_\", encoded));\n   } else {\n     fdef->mutable_signature()->set_name(fn_name);\n   }"
        },
        {
            "sha": "d71f6b9ff47a3b67bcc0c6a30950f3bf3e0ba515",
            "filename": "tensorflow/core/framework/graph_to_functiondef_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_to_functiondef_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fgraph_to_functiondef_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fgraph_to_functiondef_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -136,7 +136,7 @@ TEST(GraphToFunctionDefTest, DuplicatedOutputNames) {\n   // Duplicated output names.\n   auto status = GraphToFunctionDef(*root.graph(), \"test_fn\", {\"d\", \"d\"}, &fdef);\n \n-  EXPECT_THAT(status, tensorflow::testing::StatusIs(\n+  EXPECT_THAT(status, absl_testing::StatusIs(\n                           error::INVALID_ARGUMENT,\n                           \"Cannot have duplicate output names. Name 'd' \"\n                           \"appears more than once in 'output_names' array.\"));"
        },
        {
            "sha": "14f23b06d0e5e398068921163189c988e86eca12",
            "filename": "tensorflow/core/framework/logging.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Flogging.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Flogging.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Flogging.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -42,7 +42,7 @@ bool LogToListeners(string msg, string end) {\n     return false;\n   }\n \n-  string ended_msg = strings::StrCat(msg, end);\n+  string ended_msg = absl::StrCat(msg, end);\n \n   for (auto& listener : *listeners) {\n     listener(ended_msg.c_str());"
        },
        {
            "sha": "06524726e5cfc11df2010d80ea6f16625fac2d50",
            "filename": "tensorflow/core/framework/lookup_interface.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Flookup_interface.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Flookup_interface.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Flookup_interface.h?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -134,7 +134,7 @@ class LookupInterface : public ResourceBase {\n                                   const Tensor& default_value);\n \n   string DebugString() const override {\n-    return strings::StrCat(\"A lookup table of size: \", size());\n+    return absl::StrCat(\"A lookup table of size: \", size());\n   }\n \n   // Returns an InitializableLookupTable, a subclass of LookupInterface, if the"
        },
        {
            "sha": "654b15b9ac0201184c49ac5bc2a2c8153c3db2a7",
            "filename": "tensorflow/core/framework/model.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 32,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fmodel.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fmodel.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fmodel.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -2038,26 +2038,22 @@ void Node::CollectTunableParametersHelper(\n void Node::DebugStringHelper(absl::flat_hash_map<string, string>* debug_strings)\n     const TF_SHARED_LOCKS_REQUIRED(mu_) {\n   string result;\n-  strings::StrAppend(&result, long_name(), \":\\n\");\n-  strings::StrAppend(&result, \"  autotune=\", autotune_.load(), \"\\n\");\n-  strings::StrAppend(&result, \"  buffered_bytes=\", buffered_bytes_.load(),\n-                     \"\\n\");\n-  strings::StrAppend(&result, \"  buffered_elements=\", buffered_elements_.load(),\n-                     \"\\n\");\n-  strings::StrAppend(&result, \"  bytes_consumed=\", bytes_consumed_.load(),\n-                     \"\\n\");\n-  strings::StrAppend(&result, \"  bytes_produced=\", bytes_produced_.load(),\n-                     \"\\n\");\n-  strings::StrAppend(&result, \"  processing_time=\", processing_time_.load(),\n-                     \"\\n\");\n-  strings::StrAppend(&result, \"  num_elements=\", num_elements_.load(), \"\\n\");\n+  absl::StrAppend(&result, long_name(), \":\\n\");\n+  absl::StrAppend(&result, \"  autotune=\", autotune_.load(), \"\\n\");\n+  absl::StrAppend(&result, \"  buffered_bytes=\", buffered_bytes_.load(), \"\\n\");\n+  absl::StrAppend(&result, \"  buffered_elements=\", buffered_elements_.load(),\n+                  \"\\n\");\n+  absl::StrAppend(&result, \"  bytes_consumed=\", bytes_consumed_.load(), \"\\n\");\n+  absl::StrAppend(&result, \"  bytes_produced=\", bytes_produced_.load(), \"\\n\");\n+  absl::StrAppend(&result, \"  processing_time=\", processing_time_.load(), \"\\n\");\n+  absl::StrAppend(&result, \"  num_elements=\", num_elements_.load(), \"\\n\");\n   string inputs;\n   for (auto& input : inputs_) {\n-    strings::StrAppend(&inputs, input->long_name(), \",\");\n+    absl::StrAppend(&inputs, input->long_name(), \",\");\n   }\n-  strings::StrAppend(&result, \"  inputs={\", inputs, \"}\\n\");\n+  absl::StrAppend(&result, \"  inputs={\", inputs, \"}\\n\");\n   for (auto& input : inputs_) {\n-    strings::StrAppend(&result, debug_strings->at(input->long_name()));\n+    absl::StrAppend(&result, debug_strings->at(input->long_name()));\n   }\n   debug_strings->insert(std::make_pair(long_name(), result));\n }\n@@ -2261,7 +2257,7 @@ Model::Model(std::optional<std::string> dataset_name)\n     : dataset_name_(std::move(dataset_name)),\n       optimization_period_ms_(kOptimizationPeriodMinMs),\n       safe_to_collect_metrics_(std::make_shared<GuardedBool>(true)) {\n-  model_id_ = strings::StrCat(reinterpret_cast<uint64>(this));\n+  model_id_ = absl::StrCat(reinterpret_cast<uint64>(this));\n   model_gauge_cell_ = metrics::GetTFDataModelGauge(model_id_);\n \n   // Capture `safe_to_collect_metrics_` by value to avoid use-after-free issues\n@@ -2893,9 +2889,9 @@ void Model::OptimizeStageBasedAsyncInterleaveManyNodes(\n       // updating the parameter state values.\n       parallelism_parameter->value -= 1.0;\n       // Removes the `<index>` of `[<index>]` to reduce the number of labels.\n-      metrics::RecordTFDataAutotuneStoppingCriteria(strings::StrCat(\n-          \"ram_budget_exceeded:\",\n-          RemoveArrayIndices(critical_root.second->long_name())));\n+      metrics::RecordTFDataAutotuneStoppingCriteria(\n+          absl::StrCat(\"ram_budget_exceeded:\",\n+                       RemoveArrayIndices(critical_root.second->long_name())));\n       return;\n     }\n     model_timing.ComputeNodeTotalTime(*critical_root.second);\n@@ -2963,16 +2959,16 @@ void Model::OptimizeStageBasedNonAsyncInterleaveManyNodes(\n     // it has reached the max parallelism value.\n     if (parallelism_parameter == nullptr) {\n       // Removes the `<index>` of `[<index>]` to reduce the number of labels.\n-      metrics::RecordTFDataAutotuneStoppingCriteria(strings::StrCat(\n-          \"no_optimizable_parameter:\",\n-          RemoveArrayIndices(critical_root.second->long_name())));\n+      metrics::RecordTFDataAutotuneStoppingCriteria(\n+          absl::StrCat(\"no_optimizable_parameter:\",\n+                       RemoveArrayIndices(critical_root.second->long_name())));\n       break;\n     }\n     if (parallelism_parameter->value >= parallelism_parameter->max) {\n       // Removes the `<index>` of `[<index>]` to reduce the number of labels.\n-      metrics::RecordTFDataAutotuneStoppingCriteria(strings::StrCat(\n-          \"parameter_max_exceeded:\",\n-          RemoveArrayIndices(critical_root.second->long_name())));\n+      metrics::RecordTFDataAutotuneStoppingCriteria(\n+          absl::StrCat(\"parameter_max_exceeded:\",\n+                       RemoveArrayIndices(critical_root.second->long_name())));\n       break;\n     }\n     parallelism_parameter->value += 1.0;\n@@ -2986,9 +2982,9 @@ void Model::OptimizeStageBasedNonAsyncInterleaveManyNodes(\n       // recording the stopping criteria.\n \n       // Removes the `<index>` of `[<index>]` to reduce the number of labels.\n-      metrics::RecordTFDataAutotuneStoppingCriteria(strings::StrCat(\n-          \"ram_budget_exceeded:\",\n-          RemoveArrayIndices(critical_root.second->long_name())));\n+      metrics::RecordTFDataAutotuneStoppingCriteria(\n+          absl::StrCat(\"ram_budget_exceeded:\",\n+                       RemoveArrayIndices(critical_root.second->long_name())));\n       return;\n     }\n     // Compute the new total time and put the node back in the queue after its\n@@ -3001,9 +2997,9 @@ void Model::OptimizeStageBasedNonAsyncInterleaveManyNodes(\n         (root_timing->total_time_nsec * root_timing->pipeline_ratio)) {\n       parallelism_parameter->value -= 1.0;\n       // Removes the `<index>` of `[<index>]` to reduce the number of labels.\n-      metrics::RecordTFDataAutotuneStoppingCriteria(strings::StrCat(\n-          \"total_time_not_improved:\",\n-          RemoveArrayIndices(critical_root.second->long_name())));\n+      metrics::RecordTFDataAutotuneStoppingCriteria(\n+          absl::StrCat(\"total_time_not_improved:\",\n+                       RemoveArrayIndices(critical_root.second->long_name())));\n       break;\n     }\n     // Push it back to the priority queue."
        },
        {
            "sha": "fd47c91842721c7b9a36d6ff26f77812b121fcf1",
            "filename": "tensorflow/core/framework/model.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fmodel.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fmodel.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fmodel.h?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -413,7 +413,7 @@ class Node {\n   }\n \n   // Returns a longer node name that is guaranteed to be unique.\n-  string long_name() const { return strings::StrCat(name_, \"(id:\", id_, \")\"); }\n+  string long_name() const { return absl::StrCat(name_, \"(id:\", id_, \")\"); }\n \n   // Returns the node name.\n   const string& name() const { return name_; }"
        },
        {
            "sha": "b7d42eaa0522d31465594a5c6c3645022430b90f",
            "filename": "tensorflow/core/framework/model_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fmodel_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fmodel_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fmodel_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -1401,7 +1401,7 @@ TEST(ModelTest, ModelMetrics) {\n   std::shared_ptr<Node> root = model::MakeUnknownNode({0, \"unknown0\", nullptr});\n   model.AddNode([&root](model::Node::Args args) { return root; }, root->name(),\n                 nullptr, &root);\n-  std::string model_id = strings::StrCat(reinterpret_cast<uintptr_t>(&model));\n+  std::string model_id = absl::StrCat(reinterpret_cast<uintptr_t>(&model));\n   EXPECT_THAT(cell_reader.Read(model_id),\n               AllOf(HasSubstr(\"key: 0\"), HasSubstr(\"name: \\\"unknown0\\\"\"),\n                     HasSubstr(\"autotune: true\")));\n@@ -1416,7 +1416,7 @@ TEST(ModelTest, ModelCollectOptimizationMetrics) {\n   model.output()->record_element();\n   model.output()->record_start(100);\n   model.output()->record_stop(200);\n-  std::string model_id = strings::StrCat(reinterpret_cast<uintptr_t>(&model));\n+  std::string model_id = absl::StrCat(reinterpret_cast<uintptr_t>(&model));\n   // Before optimization, whatever metrics collected are returned.\n   EXPECT_THAT(cell_reader.Read(model_id),\n               AllOf(HasSubstr(\"key: 0\"), HasSubstr(\"name: \\\"unknown0\\\"\"),\n@@ -1460,7 +1460,7 @@ TEST(ModelTest, ModelCollectOptimizationMetrics) {\n TEST(ModelTest, ModelCollectAndDestroyRaceCondition) {\n   CellReader<std::string> cell_reader(\"/tensorflow/data/model\");\n   auto* model = new model::Model();\n-  std::string model_id = strings::StrCat(reinterpret_cast<uintptr_t>(model));\n+  std::string model_id = absl::StrCat(reinterpret_cast<uintptr_t>(model));\n   thread::ThreadPool threads(Env::Default(), \"collect_and_destroy_race\", 2);\n   threads.Schedule([&]() { cell_reader.Read(model_id); });\n   threads.Schedule([&]() { delete model; });"
        },
        {
            "sha": "92fb66395efbf850a075b61b0209fb71a1f5b9fa",
            "filename": "tensorflow/core/framework/node_def_builder.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 13,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_builder.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -80,9 +80,8 @@ bool NodeDefBuilder::NextArgAvailable() {\n   if (op_def_ == nullptr) {\n     return false;\n   } else if (inputs_specified_ >= op_def_->input_arg_size()) {\n-    errors_.push_back(strings::StrCat(\"More Input() calls than the \",\n-                                      op_def_->input_arg_size(),\n-                                      \" input_args\"));\n+    errors_.push_back(absl::StrCat(\"More Input() calls than the \",\n+                                   op_def_->input_arg_size(), \" input_args\"));\n     return false;\n   }\n   return true;\n@@ -123,8 +122,8 @@ void NodeDefBuilder::SingleInput(const OpDef::ArgDef* input_arg,\n \n   if (!input_arg->number_attr().empty() ||\n       !input_arg->type_list_attr().empty()) {\n-    errors_.push_back(strings::StrCat(\"Single tensor passed to '\",\n-                                      input_arg->name(), \"', expected list\"));\n+    errors_.push_back(absl::StrCat(\"Single tensor passed to '\",\n+                                   input_arg->name(), \"', expected list\"));\n     return;\n   }\n \n@@ -168,9 +167,9 @@ void NodeDefBuilder::ListInput(const OpDef::ArgDef* input_arg,\n     }\n     Attr(input_arg->type_list_attr(), type_vec);\n   } else {\n-    errors_.push_back(strings::StrCat(\"List provided to input '\",\n-                                      input_arg->name(),\n-                                      \"' when single Tensor expected\"));\n+    errors_.push_back(absl::StrCat(\"List provided to input '\",\n+                                   input_arg->name(),\n+                                   \"' when single Tensor expected\"));\n   }\n }\n \n@@ -179,9 +178,9 @@ void NodeDefBuilder::AddInput(absl::string_view src_node, int src_index) {\n     errors_.push_back(\"Empty input node name\");\n   } else if (src_node[0] == '^') {\n     errors_.push_back(\n-        strings::StrCat(\"Non-control input starting with ^: \", src_node));\n+        absl::StrCat(\"Non-control input starting with ^: \", src_node));\n   } else if (src_index > 0) {\n-    node_def_.add_input(strings::StrCat(src_node, \":\", src_index));\n+    node_def_.add_input(absl::StrCat(src_node, \":\", src_index));\n   } else {\n     node_def_.add_input(string(src_node));\n   }\n@@ -223,8 +222,8 @@ absl::Status NodeDefBuilder::Finalize(NodeDef* node_def, bool consume) {\n     // a copy of the existing errors.\n     errors_storage = errors_;\n     errors_storage.push_back(\n-        strings::StrCat(inputs_specified_, \" inputs specified of \",\n-                        op_def_->input_arg_size(), \" inputs in Op\"));\n+        absl::StrCat(inputs_specified_, \" inputs specified of \",\n+                     op_def_->input_arg_size(), \" inputs in Op\"));\n     errors_ptr = &errors_storage;\n   }\n \n@@ -260,7 +259,7 @@ absl::Status NodeDefBuilder::Finalize(NodeDef* node_def, bool consume) {\n \n     // Add control inputs after the regular inputs.\n     for (const auto& control_input : control_inputs_) {\n-      node_def->add_input(strings::StrCat(\"^\", control_input));\n+      node_def->add_input(absl::StrCat(\"^\", control_input));\n     }\n \n     // Add default values for unspecified attrs."
        },
        {
            "sha": "b5429579bc889bffc42788e8a3c6c0605420401f",
            "filename": "tensorflow/core/framework/node_def_builder_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_builder_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -58,7 +58,7 @@ class NodeDefBuilderTest : public ::testing::Test {\n     TF_EXPECT_OK(status);\n     if (!status.ok()) return;\n     NodeDef expected;\n-    protobuf::TextFormat::ParseFromString(strings::StrCat(\"name: 'n' \", proto),\n+    protobuf::TextFormat::ParseFromString(absl::StrCat(\"name: 'n' \", proto),\n                                           &expected);\n     EXPECT_EQ(node_def.DebugString(), expected.DebugString());\n "
        },
        {
            "sha": "507e2275afc3b5525991b1644740c52c961604ce",
            "filename": "tensorflow/core/framework/node_def_util.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_util.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -76,25 +76,25 @@ string SummarizeAttrsHelper(AttrSlice attrs, absl::string_view device) {\n   std::sort(attr_names.begin(), attr_names.end());\n   bool first = true;\n   for (const string& attr_name : attr_names) {\n-    if (!first) strings::StrAppend(&ret, \", \");\n+    if (!first) absl::StrAppend(&ret, \", \");\n     first = false;\n-    strings::StrAppend(&ret, attr_name, \"=\",\n-                       SummarizeAttrValue(*attrs.Find(attr_name)));\n+    absl::StrAppend(&ret, attr_name, \"=\",\n+                    SummarizeAttrValue(*attrs.Find(attr_name)));\n   }\n \n   // Consider the device to be a final attr with name \"_device\".\n   if (!device.empty()) {\n-    if (!first) strings::StrAppend(&ret, \", \");\n+    if (!first) absl::StrAppend(&ret, \", \");\n     first = false;\n-    strings::StrAppend(&ret, \"_device=\\\"\", device, \"\\\"\");\n+    absl::StrAppend(&ret, \"_device=\\\"\", device, \"\\\"\");\n   }\n   return ret;\n }\n \n string AttrSlice::SummarizeNode() const {\n   return ndef_\n              ? SummarizeNodeDef(*ndef_)\n-             : strings::StrCat(\n+             : absl::StrCat(\n                    \"[\", SummarizeAttrsHelper(*this, absl::string_view()), \"]\");\n }\n \n@@ -111,23 +111,23 @@ string AttrSlice::DebugString() const {\n }\n \n string SummarizeNodeDef(const NodeDef& node_def, int max_inputs_in_summary) {\n-  string ret = strings::StrCat(errors::FormatNodeNameForError(node_def.name()),\n-                               \" = \", node_def.op(), \"[\");\n-  strings::StrAppend(&ret, SummarizeAttrsHelper(node_def, node_def.device()));\n-  strings::StrAppend(&ret, \"](\");\n+  string ret = absl::StrCat(errors::FormatNodeNameForError(node_def.name()),\n+                            \" = \", node_def.op(), \"[\");\n+  absl::StrAppend(&ret, SummarizeAttrsHelper(node_def, node_def.device()));\n+  absl::StrAppend(&ret, \"](\");\n \n   // Output inputs, including control inputs, verbatim.\n   bool first = true;\n   for (const string& input : node_def.input()) {\n-    if (!first) strings::StrAppend(&ret, \", \");\n+    if (!first) absl::StrAppend(&ret, \", \");\n     first = false;\n     if (max_inputs_in_summary-- == 0) {\n-      strings::StrAppend(&ret, \"...\");\n+      absl::StrAppend(&ret, \"...\");\n       break;\n     }\n-    strings::StrAppend(&ret, input);\n+    absl::StrAppend(&ret, input);\n   }\n-  strings::StrAppend(&ret, \")\");\n+  absl::StrAppend(&ret, \")\");\n   return ret;\n }\n \n@@ -702,8 +702,8 @@ absl::Status ValidateNodeDef(const NodeDef& node_def, const OpDef& op_def) {\n   if (!op_attrs.empty()) {\n     string attrs;\n     for (const auto& attr_pair : op_attrs) {\n-      if (!attrs.empty()) strings::StrAppend(&attrs, \"', '\");\n-      strings::StrAppend(&attrs, attr_pair.first);\n+      if (!attrs.empty()) absl::StrAppend(&attrs, \"', '\");\n+      absl::StrAppend(&attrs, attr_pair.first);\n     }\n     return errors::InvalidArgument(\n         \"NodeDef missing attr\", op_attrs.size() == 1 ? \" '\" : \"s '\", attrs,\n@@ -989,15 +989,15 @@ absl::Status AddPrefixAndSuffixToNode(absl::string_view prefix,\n                                       absl::string_view suffix,\n                                       NodeDef* node_def,\n                                       bool uniquify_frame_name) {\n-  node_def->set_name(strings::StrCat(prefix, node_def->name(), suffix));\n+  node_def->set_name(absl::StrCat(prefix, node_def->name(), suffix));\n \n   // Update frame name to avoid multiple LoopCond nodes in one frame.\n   if (uniquify_frame_name &&\n       (node_def->op() == \"Enter\" || node_def->op() == \"RefEnter\")) {\n     string frame_name;\n     TF_RETURN_IF_ERROR(GetNodeAttr(*node_def, \"frame_name\", &frame_name));\n     AttrValue& attr = (*node_def->mutable_attr())[\"frame_name\"];\n-    frame_name = strings::StrCat(prefix, frame_name, suffix);\n+    frame_name = absl::StrCat(prefix, frame_name, suffix);\n     attr.set_s(frame_name);\n   }\n \n@@ -1018,7 +1018,7 @@ absl::Status MaybeAddPrefixToColocationConstraints(\n     if (absl::ConsumePrefix(&original, kColocationGroupPrefixStringPiece)) {\n       if (match.find(string(original)) != match.end()) {\n         (*constraints_list->mutable_s(i)) =\n-            strings::StrCat(kColocationGroupPrefix, prefix, original);\n+            absl::StrCat(kColocationGroupPrefix, prefix, original);\n       }\n     }\n   }\n@@ -1039,7 +1039,7 @@ absl::Status MaybeUpdateColocationConstraintsWithMap(\n     if (absl::ConsumePrefix(&original, kColocationGroupPrefixStringPiece)) {\n       if (node_name_map.find(original) != node_name_map.end()) {\n         (*constraints_list->mutable_s(i)) =\n-            strings::StrCat(kColocationGroupPrefix, node_name_map.at(original));\n+            absl::StrCat(kColocationGroupPrefix, node_name_map.at(original));\n       }\n     }\n   }"
        },
        {
            "sha": "5296dcc7075dc6c7c0197ce9048fe3b9a6690b60",
            "filename": "tensorflow/core/framework/node_def_util_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fnode_def_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fnode_def_util_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -775,9 +775,9 @@ TEST(MaybeAddPrefixToColocationConstraints, Basic) {\n   node_def.set_name(\"Identity\");\n   node_def.set_op(\"Identity\");\n   AddNodeAttr(kColocationAttrName,\n-              {strings::StrCat(kColocationGroupPrefix, \"Node1\"),\n-               strings::StrCat(kColocationGroupPrefix, \"Node2\"),\n-               strings::StrCat(kColocationGroupPrefix, \"Node3\")},\n+              {absl::StrCat(kColocationGroupPrefix, \"Node1\"),\n+               absl::StrCat(kColocationGroupPrefix, \"Node2\"),\n+               absl::StrCat(kColocationGroupPrefix, \"Node3\")},\n               &node_def);\n \n   std::unordered_set<string> match;\n@@ -808,9 +808,9 @@ TEST(MaybeUpdateColocationConstraintsWithMap, Basic) {\n   node_def.set_name(\"Identity\");\n   node_def.set_op(\"Identity\");\n   AddNodeAttr(kColocationAttrName,\n-              {strings::StrCat(kColocationGroupPrefix, \"Node1\"),\n-               strings::StrCat(kColocationGroupPrefix, \"Node2\"),\n-               strings::StrCat(kColocationGroupPrefix, \"Node3\")},\n+              {absl::StrCat(kColocationGroupPrefix, \"Node1\"),\n+               absl::StrCat(kColocationGroupPrefix, \"Node2\"),\n+               absl::StrCat(kColocationGroupPrefix, \"Node3\")},\n               &node_def);\n \n   std::map<absl::string_view, absl::string_view> node_map;"
        },
        {
            "sha": "31aeb2421bc652c38679a23883b13cd30d529d4a",
            "filename": "tensorflow/core/framework/op.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -200,7 +200,7 @@ string OpRegistry::DebugString(bool include_internal) const {\n   Export(include_internal, &op_list);\n   string ret;\n   for (const auto& op : op_list.op()) {\n-    strings::StrAppend(&ret, SummarizeOpDef(op), \"\\n\");\n+    absl::StrAppend(&ret, SummarizeOpDef(op), \"\\n\");\n   }\n   return ret;\n }"
        },
        {
            "sha": "e4ec9e50497d7305cee949912c5e9fb94e635aeb",
            "filename": "tensorflow/core/framework/op_def_builder.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 12,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_builder.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -37,7 +37,7 @@ namespace tensorflow {\n namespace {\n \n string AttrError(absl::string_view orig, const string& op_name) {\n-  return strings::StrCat(\" from Attr(\\\"\", orig, \"\\\") for Op \", op_name);\n+  return absl::StrCat(\" from Attr(\\\"\", orig, \"\\\") for Op \", op_name);\n }\n \n bool ConsumeAttrName(absl::string_view* sp, absl::string_view* out) {\n@@ -247,7 +247,7 @@ void FinalizeAttr(absl::string_view spec, bool allow_attr_type_any,\n     VERIFY(absl::ConsumePrefix(&spec, \")\"),\n            \"Expected ) to close 'list(', not: '\", spec, \"'\");\n     str_util::RemoveLeadingWhitespace(&spec);\n-    attr->set_type(strings::StrCat(\"list(\", type, \")\"));\n+    attr->set_type(absl::StrCat(\"list(\", type, \")\"));\n   } else {\n     attr->set_type(type);\n   }\n@@ -427,8 +427,7 @@ void FinalizeInputOrOutput(absl::string_view spec, bool is_output,\n #undef VERIFY\n \n string ControlOutError(absl::string_view orig, const string& op_name) {\n-  return strings::StrCat(\" from ControlOutput(\\\"\", orig, \"\\\") for Op \",\n-                         op_name);\n+  return absl::StrCat(\" from ControlOutput(\\\"\", orig, \"\\\") for Op \", op_name);\n }\n \n void FinalizeControlOutput(absl::string_view name, OpDef* op_def,\n@@ -438,8 +437,8 @@ void FinalizeControlOutput(absl::string_view name, OpDef* op_def,\n   // Parse control output name.\n   absl::string_view tmp_name;\n   if (!ConsumeControlOutName(&orig, &tmp_name)) {\n-    errors->push_back(strings::StrCat(\"Trouble parsing 'name:'\",\n-                                      ControlOutError(orig, op_def->name())));\n+    errors->push_back(absl::StrCat(\"Trouble parsing 'name:'\",\n+                                   ControlOutError(orig, op_def->name())));\n   }\n \n   *op_def->add_control_output() = string(tmp_name.data(), tmp_name.size());\n@@ -552,9 +551,9 @@ void FinalizeDoc(const string& text, OpDef* op_def,\n       }\n     }\n     if (!found) {\n-      errors->push_back(\n-          strings::StrCat(\"No matching input/output/attr for name '\", name,\n-                          \"' from Doc() for Op \", op_def->name()));\n+      errors->push_back(absl::StrCat(\"No matching input/output/attr for name '\",\n+                                     name, \"' from Doc() for Op \",\n+                                     op_def->name()));\n       return;\n     }\n   }\n@@ -590,7 +589,7 @@ OpDefBuilder& OpDefBuilder::Doc(string text) {\n #ifndef TF_LEAN_BINARY\n   if (!doc_.empty()) {\n     errors_.push_back(\n-        strings::StrCat(\"Extra call to Doc() for Op \", op_def()->name()));\n+        absl::StrCat(\"Extra call to Doc() for Op \", op_def()->name()));\n   } else {\n     doc_ = std::move(text);\n   }\n@@ -626,7 +625,7 @@ OpDefBuilder& OpDefBuilder::SetIsDistributedCommunication() {\n OpDefBuilder& OpDefBuilder::Deprecated(int version, string explanation) {\n   if (op_def()->has_deprecation()) {\n     errors_.push_back(\n-        strings::StrCat(\"Deprecated called twice for Op \", op_def()->name()));\n+        absl::StrCat(\"Deprecated called twice for Op \", op_def()->name()));\n   } else {\n     OpDeprecation* deprecation = op_def()->mutable_deprecation();\n     deprecation->set_version(version);\n@@ -655,7 +654,7 @@ OpDefBuilder& OpDefBuilder::SetReverseTypeFn(int input_number,\n OpDefBuilder& OpDefBuilder::SetShapeFn(OpShapeInferenceFn fn) {\n   if (op_reg_data_.shape_inference_fn != nullptr) {\n     errors_.push_back(\n-        strings::StrCat(\"SetShapeFn called twice for Op \", op_def()->name()));\n+        absl::StrCat(\"SetShapeFn called twice for Op \", op_def()->name()));\n   } else {\n     op_reg_data_.shape_inference_fn = OpShapeInferenceFn(fn);\n   }"
        },
        {
            "sha": "3e8c805bcb419ff29f14e1b641204d84fdf295c1",
            "filename": "tensorflow/core/framework/op_def_builder_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_builder_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -49,7 +49,7 @@ class OpDefBuilderTest : public ::testing::Test {\n     if (status.ok()) {\n       OpDef expected;\n       protobuf::TextFormat::ParseFromString(\n-          strings::StrCat(\"name: 'Test' \", proto), &expected);\n+          absl::StrCat(\"name: 'Test' \", proto), &expected);\n       // Allow different orderings\n       CanonicalizeAttrTypeListOrder(&op_def);\n       CanonicalizeAttrTypeListOrder(&expected);\n@@ -69,7 +69,7 @@ class OpDefBuilderTest : public ::testing::Test {\n     if (status.ok()) {\n       OpDef expected;\n       protobuf::TextFormat::ParseFromString(\n-          strings::StrCat(\"name: 'Test' \", proto), &expected);\n+          absl::StrCat(\"name: 'Test' \", proto), &expected);\n       EXPECT_EQ(op_def.ShortDebugString(), expected.ShortDebugString());\n     }\n   }"
        },
        {
            "sha": "e228d1f4969a7c4a04650854bd615b50d4bce507",
            "filename": "tensorflow/core/framework/op_def_util.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_util.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -51,10 +51,10 @@ absl::Status AllowedTypeValue(DataType dt, const OpDef::AttrDef& attr) {\n   string allowed_str;\n   for (int i = 0; i < allowed_values.list().type_size(); ++i) {\n     if (!allowed_str.empty()) {\n-      strings::StrAppend(&allowed_str, \", \");\n+      absl::StrAppend(&allowed_str, \", \");\n     }\n-    strings::StrAppend(&allowed_str,\n-                       DataTypeString(allowed_values.list().type(i)));\n+    absl::StrAppend(&allowed_str,\n+                    DataTypeString(allowed_values.list().type(i)));\n   }\n   return errors::InvalidArgument(\n       \"Value for attr '\", attr.name(), \"' of \", DataTypeString(dt),\n@@ -71,9 +71,9 @@ absl::Status AllowedStringValue(const string& str, const OpDef::AttrDef& attr) {\n   string allowed_str;\n   for (const string& allowed : allowed_values.list().s()) {\n     if (!allowed_str.empty()) {\n-      strings::StrAppend(&allowed_str, \", \");\n+      absl::StrAppend(&allowed_str, \", \");\n     }\n-    strings::StrAppend(&allowed_str, \"\\\"\", allowed, \"\\\"\");\n+    absl::StrAppend(&allowed_str, \"\\\"\", allowed, \"\\\"\");\n   }\n   return errors::InvalidArgument(\n       \"Value for attr '\", attr.name(), \"' of \\\"\", str,\n@@ -193,8 +193,8 @@ const ApiDef::Arg* FindInputArg(absl::string_view name, const ApiDef& api_def) {\n static absl::Status ValidateArg(const OpDef::ArgDef& arg, const OpDef& op_def,\n                                 bool output,\n                                 absl::flat_hash_set<absl::string_view>* names) {\n-  const string suffix = strings::StrCat(\n-      output ? \" for output '\" : \" for input '\", arg.name(), \"'\");\n+  const string suffix =\n+      absl::StrCat(output ? \" for output '\" : \" for input '\", arg.name(), \"'\");\n   VALIDATE(names->emplace(arg.name()).second, \"Duplicate name: \", arg.name());\n   VALIDATE(HasAttrStyleType(arg), \"Missing type\", suffix);\n \n@@ -321,7 +321,7 @@ absl::Status ValidateOpDef(const OpDef& op_def) {\n     // Validate allowed_values\n     if (attr.has_allowed_values()) {\n       const string list_type =\n-          is_list ? attr.type() : strings::StrCat(\"list(\", attr.type(), \")\");\n+          is_list ? attr.type() : absl::StrCat(\"list(\", attr.type(), \")\");\n       TF_RETURN_WITH_CONTEXT_IF_ERROR(\n           AttrValueHasType(attr.allowed_values(), list_type), \" for attr '\",\n           attr.name(), \"' in Op '\", op_def.name(), \"'\");\n@@ -381,59 +381,59 @@ namespace {\n string SummarizeArgs(const protobuf::RepeatedPtrField<OpDef::ArgDef>& args) {\n   string ret;\n   for (const OpDef::ArgDef& arg : args) {\n-    if (!ret.empty()) strings::StrAppend(&ret, \", \");\n-    strings::StrAppend(&ret, arg.name(), \":\");\n-    if (arg.is_ref()) strings::StrAppend(&ret, \"Ref(\");\n+    if (!ret.empty()) absl::StrAppend(&ret, \", \");\n+    absl::StrAppend(&ret, arg.name(), \":\");\n+    if (arg.is_ref()) absl::StrAppend(&ret, \"Ref(\");\n     if (!arg.number_attr().empty()) {\n-      strings::StrAppend(&ret, arg.number_attr(), \"*\");\n+      absl::StrAppend(&ret, arg.number_attr(), \"*\");\n     }\n     if (arg.type() != DT_INVALID) {\n-      strings::StrAppend(&ret, DataTypeString(arg.type()));\n+      absl::StrAppend(&ret, DataTypeString(arg.type()));\n     } else {\n-      strings::StrAppend(&ret, arg.type_attr());\n+      absl::StrAppend(&ret, arg.type_attr());\n     }\n-    if (arg.is_ref()) strings::StrAppend(&ret, \")\");\n+    if (arg.is_ref()) absl::StrAppend(&ret, \")\");\n   }\n   return ret;\n }\n \n }  // namespace\n \n string SummarizeOpDef(const OpDef& op_def) {\n-  string ret = strings::StrCat(\"Op<name=\", op_def.name());\n-  strings::StrAppend(&ret, \"; signature=\", SummarizeArgs(op_def.input_arg()),\n-                     \" -> \", SummarizeArgs(op_def.output_arg()));\n+  string ret = absl::StrCat(\"Op<name=\", op_def.name());\n+  absl::StrAppend(&ret, \"; signature=\", SummarizeArgs(op_def.input_arg()),\n+                  \" -> \", SummarizeArgs(op_def.output_arg()));\n   for (int i = 0; i < op_def.attr_size(); ++i) {\n-    strings::StrAppend(&ret, \"; attr=\", op_def.attr(i).name(), \":\",\n-                       op_def.attr(i).type());\n+    absl::StrAppend(&ret, \"; attr=\", op_def.attr(i).name(), \":\",\n+                    op_def.attr(i).type());\n     if (op_def.attr(i).has_default_value()) {\n-      strings::StrAppend(&ret, \",default=\",\n-                         SummarizeAttrValue(op_def.attr(i).default_value()));\n+      absl::StrAppend(&ret, \",default=\",\n+                      SummarizeAttrValue(op_def.attr(i).default_value()));\n     }\n     if (op_def.attr(i).has_minimum()) {\n-      strings::StrAppend(&ret, \",min=\", op_def.attr(i).minimum());\n+      absl::StrAppend(&ret, \",min=\", op_def.attr(i).minimum());\n     }\n     if (op_def.attr(i).has_allowed_values()) {\n-      strings::StrAppend(&ret, \",allowed=\",\n-                         SummarizeAttrValue(op_def.attr(i).allowed_values()));\n+      absl::StrAppend(&ret, \",allowed=\",\n+                      SummarizeAttrValue(op_def.attr(i).allowed_values()));\n     }\n   }\n   if (op_def.is_commutative()) {\n-    strings::StrAppend(&ret, \"; is_commutative=true\");\n+    absl::StrAppend(&ret, \"; is_commutative=true\");\n   }\n   if (op_def.is_aggregate()) {\n-    strings::StrAppend(&ret, \"; is_aggregate=true\");\n+    absl::StrAppend(&ret, \"; is_aggregate=true\");\n   }\n   if (op_def.is_stateful()) {\n-    strings::StrAppend(&ret, \"; is_stateful=true\");\n+    absl::StrAppend(&ret, \"; is_stateful=true\");\n   }\n   if (op_def.allows_uninitialized_input()) {\n-    strings::StrAppend(&ret, \"; allows_uninitialized_input=true\");\n+    absl::StrAppend(&ret, \"; allows_uninitialized_input=true\");\n   }\n   if (op_def.is_distributed_communication()) {\n-    strings::StrAppend(&ret, \"; is_distributed_communication=true\");\n+    absl::StrAppend(&ret, \"; is_distributed_communication=true\");\n   }\n-  strings::StrAppend(&ret, \">\");\n+  absl::StrAppend(&ret, \">\");\n   return ret;\n }\n \n@@ -497,7 +497,7 @@ bool HigherMinimum(const OpDef::AttrDef& old_attr,\n \n string MinStr(const OpDef::AttrDef& attr) {\n   if (!attr.has_minimum()) return \"no minimum\";\n-  return strings::StrCat(attr.minimum());\n+  return absl::StrCat(attr.minimum());\n }\n \n typedef absl::flat_hash_map<absl::string_view, const OpDef::AttrDef*> AttrMap;\n@@ -511,7 +511,7 @@ void FillAttrMap(const OpDef& op_def, AttrMap* attr_map) {\n // initialized to false).\n void AddComma(string* s, bool* add_comma) {\n   if (*add_comma) {\n-    strings::StrAppend(s, \", \");\n+    absl::StrAppend(s, \", \");\n   } else {\n     *add_comma = true;\n   }\n@@ -520,7 +520,7 @@ void AddComma(string* s, bool* add_comma) {\n // Will add the `name` from arg if name is true.\n void AddName(string* s, bool name, const OpDef::ArgDef& arg) {\n   if (name) {\n-    strings::StrAppend(s, arg.name(), \":\");\n+    absl::StrAppend(s, arg.name(), \":\");\n   }\n }\n \n@@ -549,7 +549,7 @@ string ComputeArgSignature(\n         // Both old and new have the list(type) attr, so can use it directly.\n         AddComma(&s, &add_comma);\n         AddName(&s, names, arg);\n-        strings::StrAppend(&s, arg.type_list_attr());\n+        absl::StrAppend(&s, arg.type_list_attr());\n         ref->push_back(arg.is_ref());\n       } else {\n         // Missing the list(type) attr in the old, so use the default\n@@ -561,7 +561,7 @@ string ComputeArgSignature(\n         for (int i = 0; i < type_list.size(); ++i) {\n           AddComma(&s, &add_comma);\n           AddName(&s, names, arg);\n-          strings::StrAppend(\n+          absl::StrAppend(\n               &s, DataTypeString(static_cast<DataType>(type_list.Get(i))));\n           ref->push_back(arg.is_ref());\n         }\n@@ -576,7 +576,7 @@ string ComputeArgSignature(\n             gtl::FindPtrOrNull(old_attrs, arg.number_attr());\n         if (old_attr) {\n           // Both old and new have the number attr, so can use it directly.\n-          strings::StrAppend(&type, arg.number_attr(), \" * \");\n+          absl::StrAppend(&type, arg.number_attr(), \" * \");\n         } else {\n           // Missing the number attr in the old, so use the default\n           // value for the attr from new instead.\n@@ -588,27 +588,27 @@ string ComputeArgSignature(\n \n       if (arg.type() != DT_INVALID) {\n         // int32, float, etc. case\n-        strings::StrAppend(&type, DataTypeString(arg.type()));\n+        absl::StrAppend(&type, DataTypeString(arg.type()));\n       } else {\n         const OpDef::AttrDef* old_attr =\n             gtl::FindPtrOrNull(old_attrs, arg.type_attr());\n         if (old_attr) {\n           // Both old and new have the type attr, so can use it directly.\n-          strings::StrAppend(&type, arg.type_attr());\n+          absl::StrAppend(&type, arg.type_attr());\n         } else {\n           // Missing the type attr in the old, so use the default\n           // value for the attr from new instead.\n           const OpDef::AttrDef* new_attr =\n               gtl::FindPtrOrNull(new_attrs, arg.type_attr());\n-          strings::StrAppend(&type,\n-                             DataTypeString(new_attr->default_value().type()));\n+          absl::StrAppend(&type,\n+                          DataTypeString(new_attr->default_value().type()));\n         }\n       }\n \n       // Record `num` * `type` in the signature.\n       for (int i = 0; i < num; ++i) {\n         AddComma(&s, &add_comma);\n-        strings::StrAppend(&s, type);\n+        absl::StrAppend(&s, type);\n         ref->push_back(arg.is_ref());\n       }\n     }"
        },
        {
            "sha": "333a103cef7e656196e8a6509a35038eb8c742ee",
            "filename": "tensorflow/core/framework/op_def_util_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_def_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_def_util_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -519,10 +519,10 @@ TEST(OpDefEqualityTest, EqualAndHash) {\n   string a1 = \"attr { name: 'a' type: 'string' } \";\n   string a2 = \"attr { name: 'b' type: 'string' } \";\n   string a3 = \"attr { name: 'c' type: 'int32' } \";\n-  OpDef o1 = FromText(strings::StrCat(\"name: 'MatMul' \", a1));\n-  OpDef o2 = FromText(strings::StrCat(\"name: 'MatMul' \", a2));\n-  OpDef o3 = FromText(strings::StrCat(\"name: 'MatMul' \", a1, a2));\n-  OpDef o4 = FromText(strings::StrCat(\"name: 'MatMul' \", a2, a1));\n+  OpDef o1 = FromText(absl::StrCat(\"name: 'MatMul' \", a1));\n+  OpDef o2 = FromText(absl::StrCat(\"name: 'MatMul' \", a2));\n+  OpDef o3 = FromText(absl::StrCat(\"name: 'MatMul' \", a1, a2));\n+  OpDef o4 = FromText(absl::StrCat(\"name: 'MatMul' \", a2, a1));\n \n   ExpectEqual(o1, o1);\n   ExpectEqual(o3, o4);"
        },
        {
            "sha": "026b8e677ac66899f5f12f5cddc3058831e3dfcc",
            "filename": "tensorflow/core/framework/op_gen_lib.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_gen_lib.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -34,20 +34,20 @@ string WordWrap(absl::string_view prefix, absl::string_view str, int width) {\n   const string indent_next_line = \"\\n\" + Spaces(prefix.size());\n   width -= prefix.size();\n   string result;\n-  strings::StrAppend(&result, prefix);\n+  absl::StrAppend(&result, prefix);\n \n   while (!str.empty()) {\n     if (static_cast<int>(str.size()) <= width) {\n       // Remaining text fits on one line.\n-      strings::StrAppend(&result, str);\n+      absl::StrAppend(&result, str);\n       break;\n     }\n     auto space = str.rfind(' ', width);\n     if (space == absl::string_view::npos) {\n       // Rather make a too-long line and break at a space.\n       space = str.find(' ');\n       if (space == absl::string_view::npos) {\n-        strings::StrAppend(&result, str);\n+        absl::StrAppend(&result, str);\n         break;\n       }\n     }\n@@ -62,8 +62,8 @@ string WordWrap(absl::string_view prefix, absl::string_view str, int width) {\n     }\n \n     // Go on to the next line.\n-    strings::StrAppend(&result, to_append);\n-    if (!str.empty()) strings::StrAppend(&result, indent_next_line);\n+    absl::StrAppend(&result, to_append);\n+    if (!str.empty()) absl::StrAppend(&result, indent_next_line);\n   }\n \n   return result;\n@@ -150,16 +150,16 @@ static bool ConvertLine(absl::string_view line,\n   // Find a string to mark the end that isn't in unescaped.\n   string end = \"END\";\n   for (int s = 0; unescaped.find(end) != string::npos; ++s) {\n-    end = strings::StrCat(\"END\", s);\n+    end = absl::StrCat(\"END\", s);\n   }\n \n   // Actually start writing the converted output.\n   strings::StrAppend(ml, up_to_colon, \": <<\", end, \"\\n\", unescaped, \"\\n\", end);\n   if (!suffix.empty()) {\n     // Output suffix, in case there was a trailing comment in the source.\n-    strings::StrAppend(ml, suffix);\n+    absl::StrAppend(ml, suffix);\n   }\n-  strings::StrAppend(ml, \"\\n\");\n+  absl::StrAppend(ml, \"\\n\");\n   return true;\n }\n \n@@ -175,7 +175,7 @@ string PBTxtToMultiline(absl::string_view pbtxt,\n     SplitAt('\\n', &pbtxt, &line);\n     // Convert line or output it unchanged\n     if (!ConvertLine(line, multi_line_fields, &ml)) {\n-      strings::StrAppend(&ml, line, \"\\n\");\n+      absl::StrAppend(&ml, line, \"\\n\");\n     }\n   }\n   return ml;\n@@ -205,15 +205,15 @@ string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n   while (!multiline_pbtxt.empty()) {\n     // Split multiline_pbtxt into its first line and everything after.\n     if (!SplitAt('\\n', &multiline_pbtxt, &line)) {\n-      strings::StrAppend(&pbtxt, line);\n+      absl::StrAppend(&pbtxt, line);\n       break;\n     }\n \n     string end;\n     auto colon = line.find(':');\n     if (!FindMultiline(line, colon, &end)) {\n       // Normal case: not a multi-line string, just output the line as-is.\n-      strings::StrAppend(&pbtxt, line, \"\\n\");\n+      absl::StrAppend(&pbtxt, line, \"\\n\");\n       continue;\n     }\n \n@@ -226,7 +226,7 @@ string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n     //     something: \"xx\\nyy\"\n \n     // Output everything up to the colon (\"    something:\").\n-    strings::StrAppend(&pbtxt, line.substr(0, colon + 1));\n+    absl::StrAppend(&pbtxt, line.substr(0, colon + 1));\n \n     // Add every line to unescaped until we see the \"END\" string.\n     string unescaped;\n@@ -239,7 +239,7 @@ string PBTxtFromMultiline(absl::string_view multiline_pbtxt) {\n       } else {\n         unescaped.push_back('\\n');\n       }\n-      strings::StrAppend(&unescaped, line);\n+      absl::StrAppend(&unescaped, line);\n       line = absl::string_view();\n     }\n \n@@ -273,8 +273,8 @@ static void StringReplace(const string& from, const string& to, string* s) {\n \n static void RenameInDocs(const string& from, const string& to,\n                          ApiDef* api_def) {\n-  const string from_quoted = strings::StrCat(\"`\", from, \"`\");\n-  const string to_quoted = strings::StrCat(\"`\", to, \"`\");\n+  const string from_quoted = absl::StrCat(\"`\", from, \"`\");\n+  const string to_quoted = absl::StrCat(\"`\", to, \"`\");\n   for (int i = 0; i < api_def->in_arg_size(); ++i) {\n     if (!api_def->in_arg(i).description().empty()) {\n       StringReplace(from_quoted, to_quoted,\n@@ -459,11 +459,11 @@ absl::Status MergeApiDefs(ApiDef* base_api_def, const ApiDef& new_api_def) {\n \n   if (!new_api_def.description_prefix().empty()) {\n     description =\n-        strings::StrCat(new_api_def.description_prefix(), \"\\n\", description);\n+        absl::StrCat(new_api_def.description_prefix(), \"\\n\", description);\n   }\n   if (!new_api_def.description_suffix().empty()) {\n     description =\n-        strings::StrCat(description, \"\\n\", new_api_def.description_suffix());\n+        absl::StrCat(description, \"\\n\", new_api_def.description_suffix());\n   }\n   base_api_def->set_description(description);\n   return absl::OkStatus();\n@@ -496,8 +496,8 @@ absl::Status ApiDefMap::LoadFile(Env* env, const string& filename) {\n   if (!status.ok()) {\n     // Return failed status annotated with filename to aid in debugging.\n     return errors::CreateWithUpdatedMessage(\n-        status, strings::StrCat(\"Error parsing ApiDef file \", filename, \": \",\n-                                status.message()));\n+        status, absl::StrCat(\"Error parsing ApiDef file \", filename, \": \",\n+                             status.message()));\n   }\n   return absl::OkStatus();\n }"
        },
        {
            "sha": "056db3d9fc264489bf464f6b54da8b0e6f49c509",
            "filename": "tensorflow/core/framework/op_kernel.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_kernel.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_kernel.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_kernel.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -229,10 +229,10 @@ string OpKernel::ShapeTraceString(const OpKernelContext& ctx) const {\n       tensor_shapes.emplace_back();  // Placeholder\n       continue;\n     }\n-    tensor_shapes.emplace_back(strings::StrCat(\n+    tensor_shapes.emplace_back(absl::StrCat(\n         DataTypeString(input_dtype), ctx.input(i).shape().DebugString()));\n   }\n-  return strings::StrCat(\"(\", absl::StrJoin(tensor_shapes, \";\"), \")\");\n+  return absl::StrCat(\"(\", absl::StrJoin(tensor_shapes, \";\"), \")\");\n }\n \n string OpKernel::TraceString(const OpKernelContext& ctx, bool verbose) const {\n@@ -1649,16 +1649,16 @@ string KernelsRegisteredForOp(absl::string_view op_name) {\n   if (kernel_list.kernel_size() == 0) return \"  <no registered kernels>\\n\";\n   string ret;\n   for (const auto& kernel_def : kernel_list.kernel()) {\n-    strings::StrAppend(&ret, \"  device='\", kernel_def.device_type(), \"'\");\n+    absl::StrAppend(&ret, \"  device='\", kernel_def.device_type(), \"'\");\n     if (!kernel_def.label().empty()) {\n-      strings::StrAppend(&ret, \"; label='\", kernel_def.label(), \"'\");\n+      absl::StrAppend(&ret, \"; label='\", kernel_def.label(), \"'\");\n     }\n     for (int i = 0; i < kernel_def.constraint_size(); ++i) {\n-      strings::StrAppend(\n+      absl::StrAppend(\n           &ret, \"; \", kernel_def.constraint(i).name(), \" in \",\n           SummarizeAttrValue(kernel_def.constraint(i).allowed_values()));\n     }\n-    strings::StrAppend(&ret, \"\\n\");\n+    absl::StrAppend(&ret, \"\\n\");\n   }\n   return ret;\n }"
        },
        {
            "sha": "9a38f4a11e1f3adf9a2c897a8935c52a63f02e89",
            "filename": "tensorflow/core/framework/op_kernel_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_kernel_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_kernel_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_kernel_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -509,12 +509,12 @@ TEST_F(OpKernelTest, AllocateOutput) {\n \n   // Allocating to index -1 should fail (Only 0 should work).\n   absl::Status s = ctx->allocate_output(-1, TensorShape({}), &output);\n-  EXPECT_THAT(s, tensorflow::testing::StatusIs(error::INTERNAL));\n+  EXPECT_THAT(s, absl_testing::StatusIs(error::INTERNAL));\n   EXPECT_THAT(s.message(), ::testing::ContainsRegex(\"bad index=-1\"));\n \n   // Allocating to index 1 should fail (Only 0 should work).\n   s = ctx->allocate_output(1, TensorShape({}), &output);\n-  EXPECT_THAT(s, tensorflow::testing::StatusIs(error::INTERNAL));\n+  EXPECT_THAT(s, absl_testing::StatusIs(error::INTERNAL));\n   EXPECT_THAT(s.message(), ::testing::ContainsRegex(\"bad index=1\"));\n \n   // Testing allocate_output when allocator attributes are set.\n@@ -524,12 +524,12 @@ TEST_F(OpKernelTest, AllocateOutput) {\n \n   // Index -1 should fail as only 1 output for the op.\n   s = ctx->allocate_output(-1, TensorShape({}), &output, attrs);\n-  EXPECT_THAT(s, tensorflow::testing::StatusIs(error::INTERNAL));\n+  EXPECT_THAT(s, absl_testing::StatusIs(error::INTERNAL));\n   EXPECT_THAT(s.message(), ::testing::ContainsRegex(\"bad index=-1\"));\n \n   // Index 1 should fail as only 1 output for the op.\n   s = ctx->allocate_output(1, TensorShape({}), &output, attrs);\n-  EXPECT_THAT(s, tensorflow::testing::StatusIs(error::INTERNAL));\n+  EXPECT_THAT(s, absl_testing::StatusIs(error::INTERNAL));\n   EXPECT_THAT(s.message(), ::testing::ContainsRegex(\"bad index=1\"));\n }\n \n@@ -1110,7 +1110,7 @@ void BM_ConcatInputRange(::testing::benchmark::State& state) {\n   node_def.mutable_attr()->insert({\"T\", attr_T});\n   node_def.mutable_attr()->insert({\"Tidx\", attr_Tidx});\n   for (size_t i = 0; i < 5; ++i) {\n-    node_def.add_input(strings::StrCat(\"a:\", i));\n+    node_def.add_input(absl::StrCat(\"a:\", i));\n   }\n \n   BM_InputRangeHelper(state, node_def, \"values\", 0, 4);\n@@ -1125,7 +1125,7 @@ void BM_SelectInputRange(::testing::benchmark::State& state) {\n   attr_T.set_type(DT_FLOAT);\n   node_def.mutable_attr()->insert({\"T\", attr_T});\n   for (size_t i = 0; i < 3; ++i) {\n-    node_def.add_input(strings::StrCat(\"a:\", i));\n+    node_def.add_input(absl::StrCat(\"a:\", i));\n   }\n \n   BM_InputRangeHelper(state, node_def, \"condition\", 0, 1);\n@@ -1146,7 +1146,7 @@ void BM_TraceString(::testing::benchmark::State& state) {\n   transpose_b.set_b(true);\n   node_def.mutable_attr()->insert({\"transpose_b\", transpose_b});\n   for (size_t i = 0; i < 2; ++i) {\n-    node_def.add_input(strings::StrCat(\"a:\", i));\n+    node_def.add_input(absl::StrCat(\"a:\", i));\n   }\n \n   // Build OpKernel and OpKernelContext"
        },
        {
            "sha": "a6db270b40dd400f0599c24ee17b29def1cb190a",
            "filename": "tensorflow/core/framework/op_requires_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_requires_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_requires_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_requires_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -77,7 +77,7 @@ TEST(OpRequires, RequiresOkWithFailedStatus) {\n \n   TestFunction(ctx, /*success=*/false, reached);\n   EXPECT_THAT(ctx.stored_status,\n-              Optional(StatusIs(absl::StatusCode::kInternal)));\n+              Optional(absl_testing::StatusIs(absl::StatusCode::kInternal)));\n   EXPECT_FALSE(reached);\n }\n \n@@ -110,7 +110,7 @@ TEST(OpRequires, RequiresOkAsyncWithFailedStatus) {\n \n   TestFunctionAsync(ctx, /*success=*/false, reached, handled);\n   EXPECT_THAT(ctx.stored_status,\n-              Optional(StatusIs(absl::StatusCode::kInternal)));\n+              Optional(absl_testing::StatusIs(absl::StatusCode::kInternal)));\n   EXPECT_FALSE(reached);\n   EXPECT_TRUE(handled);\n }"
        },
        {
            "sha": "9fcf1b2b09f318d8db190e0277a14dddf9a78e13",
            "filename": "tensorflow/core/framework/op_segment_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_segment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fop_segment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fop_segment_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -38,12 +38,12 @@ class OpSegmentTest : public ::testing::Test {\n   OpSegmentTest() : device_(Env::Default()) {\n     for (int i = 0; i < 10; ++i) {\n       NodeDef def;\n-      TF_CHECK_OK(NodeDefBuilder(strings::StrCat(\"op\", i), \"Mul\")\n+      TF_CHECK_OK(NodeDefBuilder(absl::StrCat(\"op\", i), \"Mul\")\n                       .Input(\"x\", 0, DT_INT32)\n                       .Input(\"y\", 0, DT_INT32)\n                       .Finalize(&def));\n       int32_nodedefs_.push_back(def);\n-      TF_CHECK_OK(NodeDefBuilder(strings::StrCat(\"op\", i), \"Mul\")\n+      TF_CHECK_OK(NodeDefBuilder(absl::StrCat(\"op\", i), \"Mul\")\n                       .Input(\"x\", 0, DT_FLOAT)\n                       .Input(\"y\", 0, DT_FLOAT)\n                       .Finalize(&def));\n@@ -97,13 +97,11 @@ TEST_F(OpSegmentTest, Basic) {\n   };\n   for (int i = 0; i < 10; ++i) {\n     // Lookup op in session A.\n-    TF_EXPECT_OK(\n-        opseg.FindOrCreate(\"A\", strings::StrCat(\"op\", i), &op, reterr));\n+    TF_EXPECT_OK(opseg.FindOrCreate(\"A\", absl::StrCat(\"op\", i), &op, reterr));\n     ValidateOpAndTypes(op, float_nodedefs_[i], DT_FLOAT);\n \n     // Lookup op in session B.\n-    TF_EXPECT_OK(\n-        opseg.FindOrCreate(\"B\", strings::StrCat(\"op\", i), &op, reterr));\n+    TF_EXPECT_OK(opseg.FindOrCreate(\"B\", absl::StrCat(\"op\", i), &op, reterr));\n     ValidateOpAndTypes(op, int32_nodedefs_[i], DT_INT32);\n   }\n "
        },
        {
            "sha": "9debcd204a7b155074ddc3793c513ac7b65438b5",
            "filename": "tensorflow/core/framework/partial_tensor_shape_test.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fpartial_tensor_shape_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fpartial_tensor_shape_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fpartial_tensor_shape_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -148,21 +148,22 @@ TEST(PartialTensorShapeTest, PartialTensorShapeIsValidShape) {\n \n   proto.add_dim()->set_size(1);\n   EXPECT_THAT(PartialTensorShape::IsValidShape(proto),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INVALID_ARGUMENT,\n                   ::testing::ContainsRegex(\n                       \"An unknown shape must not have any dimensions set.\")));\n \n   proto.set_unknown_rank(false);\n   proto.add_dim()->set_size(-1);\n   proto.add_dim()->set_size(-2);\n-  EXPECT_THAT(PartialTensorShape::IsValidShape(proto),\n-              testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                                ::testing::ContainsRegex(\n-                                    \"has dimensions with values below -1\")));\n+  EXPECT_THAT(\n+      PartialTensorShape::IsValidShape(proto),\n+      absl_testing::StatusIs(\n+          error::Code::INVALID_ARGUMENT,\n+          ::testing::ContainsRegex(\"has dimensions with values below -1\")));\n \n   EXPECT_THAT(TensorShape::IsValidShape(proto),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INVALID_ARGUMENT,\n                   ::testing::ContainsRegex(\"Shape.*is not fully defined\")));\n }\n@@ -181,11 +182,11 @@ TEST(PartialTensorShapeTest, BuildPartialTensorShape) {\n   EXPECT_EQ(s4.AsProto().DebugString(), sp3.DebugString());\n \n   sp3.add_dim()->set_size(std::numeric_limits<int64_t>::max());\n-  EXPECT_THAT(\n-      PartialTensorShape::BuildPartialTensorShape(sp3, &s4),\n-      testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                        ::testing::ContainsRegex(\n-                            \"Encountered overflow when multiplying shape\")));\n+  EXPECT_THAT(PartialTensorShape::BuildPartialTensorShape(sp3, &s4),\n+              absl_testing::StatusIs(\n+                  error::Code::INVALID_ARGUMENT,\n+                  ::testing::ContainsRegex(\n+                      \"Encountered overflow when multiplying shape\")));\n }\n \n TEST(PartialTensorShapeTest, PartialShapeFullyDefined) {\n@@ -347,17 +348,18 @@ TEST(PartialTensorShapeTest, PartialShapeMergeWithInvalidData) {\n   const PartialTensorShape d({-1, std::numeric_limits<int64_t>::max(), -1});\n \n   EXPECT_THAT(a.MergeWith(b, &a),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\"Cannot output result to itself\")));\n   EXPECT_THAT(b.MergeWith(c, &a),\n-              testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                                ::testing::ContainsRegex(\n-                                    \"Incompatible shapes during merge\")));\n-  EXPECT_THAT(c.MergeWith(d, &a),\n-              testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                                ::testing::ContainsRegex(\n-                                    \"Encountered overflow when multiplying\")));\n+              absl_testing::StatusIs(error::Code::INVALID_ARGUMENT,\n+                                     ::testing::ContainsRegex(\n+                                         \"Incompatible shapes during merge\")));\n+  EXPECT_THAT(\n+      c.MergeWith(d, &a),\n+      absl_testing::StatusIs(\n+          error::Code::INVALID_ARGUMENT,\n+          ::testing::ContainsRegex(\"Encountered overflow when multiplying\")));\n }\n \n TEST(PartialTensorShapeTest, MakePartialShapeEmpty) {"
        },
        {
            "sha": "bda429e3194668e68bed56bb91184fb13e9c5cac",
            "filename": "tensorflow/core/framework/queue_interface.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fqueue_interface.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fqueue_interface.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fqueue_interface.h?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -90,7 +90,7 @@ class QueueInterface : public ResourceBase {\n   virtual const DataTypeVector& component_dtypes() const = 0;\n \n   string DebugString() const override {\n-    return strings::StrCat(\"A Queue of size: \", size());\n+    return absl::StrCat(\"A Queue of size: \", size());\n   }\n \n  protected:"
        },
        {
            "sha": "9f7188f25264e813b622de54c2dd2aeeb37d2819",
            "filename": "tensorflow/core/framework/reader_base.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Freader_base.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Freader_base.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Freader_base.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -234,7 +234,7 @@ void ReaderBase::SaveBaseState(ReaderBaseState* state) const {\n }\n \n tstring ReaderBase::KeyName(const tstring& key) const {\n-  return strings::StrCat(current_work(), \":\", key);\n+  return absl::StrCat(current_work(), \":\", key);\n }\n \n absl::Status ReaderBase::RestoreBaseState(const ReaderBaseState& state) {"
        },
        {
            "sha": "d67b8e41b5e35e23d7d90b63da0765f1c14f58e4",
            "filename": "tensorflow/core/framework/rendezvous_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Frendezvous_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Frendezvous_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Frendezvous_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -61,8 +61,7 @@ TEST(RendezvousTest, Key) {\n                                     \"/job:mnist/replica:1/task:2/device:GPU:0;\",\n                                     &parsed)\n                    .ok());\n-  EXPECT_FALSE(\n-      Rendezvous::ParseKey(strings::StrCat(key, \";\", key), &parsed).ok());\n+  EXPECT_FALSE(Rendezvous::ParseKey(absl::StrCat(key, \";\", key), &parsed).ok());\n }\n \n class LocalRendezvousTest : public ::testing::Test {\n@@ -300,14 +299,14 @@ TEST_F(LocalRendezvousTest, RandomSendRecv) {\n     SchedClosure([this, i, micros]() {\n       Env::Default()->SleepForMicroseconds(micros);\n       Rendezvous::Args args;\n-      TF_ASSERT_OK(rendez_->Send(MakeKey(strings::StrCat(i)), args,\n-                                 V(strings::StrCat(i)), false));\n+      TF_ASSERT_OK(rendez_->Send(MakeKey(absl::StrCat(i)), args,\n+                                 V(absl::StrCat(i)), false));\n     });\n     auto recv_done = [this, &state, i](const absl::Status& status,\n                                        const Rendezvous::Args& sender_args,\n                                        const Rendezvous::Args& recver_args,\n                                        const Tensor& val, const bool val_dead) {\n-      EXPECT_EQ(strings::StrCat(i), V(val));\n+      EXPECT_EQ(absl::StrCat(i), V(val));\n       bool done = false;\n       {\n         mutex_lock l(state.lock);\n@@ -323,7 +322,7 @@ TEST_F(LocalRendezvousTest, RandomSendRecv) {\n     micros = 100 + rnd.Uniform(1000);\n     SchedClosure([this, i, micros, recv_done]() {\n       Env::Default()->SleepForMicroseconds(micros);\n-      rendez_->RecvAsync(MakeKey(strings::StrCat(i)), Rendezvous::Args(),\n+      rendez_->RecvAsync(MakeKey(absl::StrCat(i)), Rendezvous::Args(),\n                          recv_done);\n     });\n   }\n@@ -343,7 +342,7 @@ TEST_F(LocalRendezvousTest, MultiSends) {\n   Rendezvous::Args args;\n   SchedClosure([=]() {\n     for (int i = 0; i < N; ++i) {\n-      TF_ASSERT_OK(rendez_->Send(key_foo, args, V(strings::StrCat(i)), false));\n+      TF_ASSERT_OK(rendez_->Send(key_foo, args, V(absl::StrCat(i)), false));\n       RandomSleep();\n     }\n   });"
        },
        {
            "sha": "771c49626c59f81efb7f6dd5b83b13b25a294eac",
            "filename": "tensorflow/core/framework/resource_mgr.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_mgr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_mgr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_mgr.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -50,7 +50,7 @@ ResourceHandle MakeResourceHandle(\n   result.set_definition_stack_trace(definition_stack_trace);\n   if (name == ResourceHandle::ANONYMOUS_NAME) {\n     result.set_name(\n-        strings::StrCat(\"_AnonymousVar\", ResourceHandle::GenerateUniqueId()));\n+        absl::StrCat(\"_AnonymousVar\", ResourceHandle::GenerateUniqueId()));\n   } else {\n     result.set_name(name);\n   }\n@@ -406,7 +406,7 @@ absl::Status ContainerInfo::Init(ResourceMgr* rmgr, const NodeDef& ndef,\n   } else {\n     resource_is_private_to_kernel_ = true;\n     static std::atomic<int64_t> counter(0);\n-    name_ = strings::StrCat(\"_\", counter.fetch_add(1), \"_\", ndef.name());\n+    name_ = absl::StrCat(\"_\", counter.fetch_add(1), \"_\", ndef.name());\n   }\n   return absl::OkStatus();\n }"
        },
        {
            "sha": "4dfba330ed8d89ad319b3196f9723c7d72557e77",
            "filename": "tensorflow/core/framework/resource_mgr.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_mgr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_mgr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_mgr.h?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -88,15 +88,15 @@ class ScopedStepContainer {\n   ScopedStepContainer(const int64_t step_id,\n                       std::function<void(const string&)> cleanup)\n       : step_id_(step_id),\n-        container_(strings::StrCat(\"__per_step_\", step_id)),\n+        container_(absl::StrCat(\"__per_step_\", step_id)),\n         cleanup_(cleanup),\n         dirty_(false) {}\n \n   ScopedStepContainer(const int64_t step_id,\n                       std::function<void(const string&)> cleanup,\n                       const std::string& prefix)\n       : step_id_(step_id),\n-        container_(strings::StrCat(\"__\", prefix, \"_per_step_\", step_id)),\n+        container_(absl::StrCat(\"__\", prefix, \"_per_step_\", step_id)),\n         cleanup_(cleanup),\n         dirty_(false) {}\n "
        },
        {
            "sha": "dec1a9583a49a24931b1747a88d5c0ca22a469a9",
            "filename": "tensorflow/core/framework/resource_mgr_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_mgr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_mgr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_mgr_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -48,7 +48,7 @@ class Resource : public ResourceBase {\n   explicit Resource(const string& label) : label_(label) {}\n   ~Resource() override {}\n \n-  string DebugString() const override { return strings::StrCat(\"R/\", label_); }\n+  string DebugString() const override { return absl::StrCat(\"R/\", label_); }\n \n  private:\n   string label_;\n@@ -59,7 +59,7 @@ class Other : public ResourceBase {\n   explicit Other(const string& label) : label_(label) {}\n   ~Other() override {}\n \n-  string DebugString() const override { return strings::StrCat(\"O/\", label_); }\n+  string DebugString() const override { return absl::StrCat(\"O/\", label_); }\n \n  private:\n   string label_;\n@@ -305,8 +305,8 @@ TEST(ResourceMgrTest, CreateFailAfterFinalize) {\n   int finalize_count_ = 0;\n   Finalizable* finalizable = new Finalizable(&finalize_count_);\n   EXPECT_THAT(rm.Create(\"container\", \"resource-name\", finalizable),\n-              StatusIs(absl::StatusCode::kFailedPrecondition,\n-                       HasSubstr(\"ResourceMgr is finalized\")));\n+              absl_testing::StatusIs(absl::StatusCode::kFailedPrecondition,\n+                                     HasSubstr(\"ResourceMgr is finalized\")));\n   finalizable->Unref();\n }\n \n@@ -318,8 +318,8 @@ TEST(ResourceMgrTest, CreateUnownedFailAfterFinalize) {\n   int finalize_count_ = 0;\n   Finalizable* finalizable = new Finalizable(&finalize_count_);\n   EXPECT_THAT(rm.CreateUnowned(\"container\", \"resource-name\", finalizable),\n-              StatusIs(absl::StatusCode::kFailedPrecondition,\n-                       HasSubstr(\"ResourceMgr is finalized\")));\n+              absl_testing::StatusIs(absl::StatusCode::kFailedPrecondition,\n+                                     HasSubstr(\"ResourceMgr is finalized\")));\n   finalizable->Unref();\n }\n "
        },
        {
            "sha": "db879c40654be508afc9b374eb383f4af90af95b",
            "filename": "tensorflow/core/framework/resource_op_kernel_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_op_kernel_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_op_kernel_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_op_kernel_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -88,7 +88,7 @@ class ResourceOpKernelTest : public ::testing::Test {\n                                                  const string& shared_name) {\n     static std::atomic<int64_t> count(0);\n     NodeDef node_def;\n-    TF_CHECK_OK(NodeDefBuilder(strings::StrCat(\"test-node\", count.fetch_add(1)),\n+    TF_CHECK_OK(NodeDefBuilder(absl::StrCat(\"test-node\", count.fetch_add(1)),\n                                \"StubResourceOp\")\n                     .Attr(\"code\", code)\n                     .Attr(\"shared_name\", shared_name)"
        },
        {
            "sha": "20ed85ae5b96aa4669167d15c9d90a30ed36d9bc",
            "filename": "tensorflow/core/framework/resource_var.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_var.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fresource_var.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fresource_var.h?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -89,8 +89,8 @@ class Var : public ResourceBase {\n   absl::Status AsGraphDef(GraphDefBuilder* builder, Node** out) const override;\n \n   std::string DebugString() const override {\n-    return strings::StrCat(DataTypeString(tensor_.dtype()), \"/\",\n-                           tensor_.shape().DebugString());\n+    return absl::StrCat(DataTypeString(tensor_.dtype()), \"/\",\n+                        tensor_.shape().DebugString());\n   }\n \n   std::string MakeRefCountingHandleName(int64_t resource_id) const override;"
        },
        {
            "sha": "5ba580d2f492766038cb79cc8a0501b0ce92d5f1",
            "filename": "tensorflow/core/framework/shape_inference.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fshape_inference.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fshape_inference.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fshape_inference.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -286,23 +286,23 @@ string InferenceContext::DebugString(ShapeHandle s) {\n   if (RankKnown(s)) {\n     std::vector<string> vals;\n     for (auto d : s->dims_) vals.push_back(DebugString(d));\n-    return strings::StrCat(\"[\", absl::StrJoin(vals, \",\"), \"]\");\n+    return absl::StrCat(\"[\", absl::StrJoin(vals, \",\"), \"]\");\n   } else {\n     return \"?\";\n   }\n }\n \n string InferenceContext::DebugString(DimensionHandle d) {\n-  return ValueKnown(d) ? strings::StrCat(Value(d)) : \"?\";\n+  return ValueKnown(d) ? absl::StrCat(Value(d)) : \"?\";\n }\n \n string InferenceContext::DebugString() const {\n-  return strings::StrCat(\"InferenceContext for node: \", attrs_.SummarizeNode());\n+  return absl::StrCat(\"InferenceContext for node: \", attrs_.SummarizeNode());\n }\n \n string InferenceContext::DebugString(const ShapeAndType& shape_and_type) {\n-  return strings::StrCat(DebugString(shape_and_type.shape), \":\",\n-                         DataTypeString(shape_and_type.dtype));\n+  return absl::StrCat(DebugString(shape_and_type.shape), \":\",\n+                      DataTypeString(shape_and_type.dtype));\n }\n \n string InferenceContext::DebugString(\n@@ -311,7 +311,7 @@ string InferenceContext::DebugString(\n   for (const ShapeAndType& s : shape_and_types) {\n     pieces.push_back(DebugString(s));\n   }\n-  return strings::StrCat(\"[\", absl::StrJoin(pieces, \",\"), \"]\");\n+  return absl::StrCat(\"[\", absl::StrJoin(pieces, \",\"), \"]\");\n }\n \n absl::Status InferenceContext::WithRank(ShapeHandle shape, int64_t rank,\n@@ -1187,7 +1187,7 @@ absl::Status InferenceContext::AttachContext(const absl::Status& status) {\n         i < input_tensors_as_shapes_size &&\n         input_tensors_as_shapes_[i].IsSet() &&\n         RankKnown(input_tensors_as_shapes_[i])) {\n-      input_from_tensors_as_shape_str.push_back(strings::StrCat(\n+      input_from_tensors_as_shape_str.push_back(absl::StrCat(\n           \"input[\", i, \"] = \", DebugString(input_tensors_as_shapes_[i])));\n     } else if (requested_input_tensor_[i] && i < input_tensors_size &&\n                input_tensors_[i] != nullptr) {\n@@ -1197,22 +1197,22 @@ absl::Status InferenceContext::AttachContext(const absl::Status& status) {\n     }\n   }\n \n-  string error_context = strings::StrCat(\n-      \" for '\", attrs_.SummarizeNode(),\n-      \"' with input shapes: \", absl::StrJoin(input_shapes, \", \"));\n+  string error_context =\n+      absl::StrCat(\" for '\", attrs_.SummarizeNode(),\n+                   \"' with input shapes: \", absl::StrJoin(input_shapes, \", \"));\n   if (!input_from_tensors_str.empty()) {\n-    strings::StrAppend(&error_context, \" and with computed input tensors: \",\n-                       absl::StrJoin(input_from_tensors_str, \", \"));\n+    absl::StrAppend(&error_context, \" and with computed input tensors: \",\n+                    absl::StrJoin(input_from_tensors_str, \", \"));\n   }\n   if (!input_from_tensors_as_shape_str.empty()) {\n-    strings::StrAppend(&error_context,\n-                       \" and with input tensors computed as partial shapes: \",\n-                       absl::StrJoin(input_from_tensors_as_shape_str, \",\"));\n+    absl::StrAppend(&error_context,\n+                    \" and with input tensors computed as partial shapes: \",\n+                    absl::StrJoin(input_from_tensors_as_shape_str, \",\"));\n   }\n \n-  strings::StrAppend(&error_context, \".\");\n+  absl::StrAppend(&error_context, \".\");\n   return errors::CreateWithUpdatedMessage(\n-      status, strings::StrCat(status.message(), error_context));\n+      status, absl::StrCat(status.message(), error_context));\n }\n \n bool InferenceContext::MergeHandleShapesAndTypes("
        },
        {
            "sha": "e07b9b75f0b64847ff9a75f3e7cb9d7686f7aedd",
            "filename": "tensorflow/core/framework/shape_inference_test.cc",
            "status": "modified",
            "additions": 134,
            "deletions": 114,
            "changes": 248,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fshape_inference_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fshape_inference_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fshape_inference_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -96,18 +96,18 @@ TEST_F(ShapeInferenceTest, InputOutputByName) {\n   EXPECT_EQ(\"3\", c.DebugString(c.NumElements(c.input(2))));\n   // Test getters.\n   std::vector<ShapeHandle> shapes;\n-  EXPECT_THAT(\n-      c.input(\"nonexistent\", &shapes),\n-      StatusIs(error::INVALID_ARGUMENT, HasSubstr(\"Unknown input name\")));\n+  EXPECT_THAT(c.input(\"nonexistent\", &shapes),\n+              absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                                     HasSubstr(\"Unknown input name\")));\n   TF_EXPECT_OK(c.input(\"input\", &shapes));\n   EXPECT_EQ(\"[1,5]\", c.DebugString(shapes[0]));\n   EXPECT_EQ(\"[2,5]\", c.DebugString(shapes[1]));\n   EXPECT_EQ(\"[1,3]\", c.DebugString(shapes[2]));\n \n   // Test setters.\n-  EXPECT_THAT(\n-      c.set_output(\"nonexistent\", shapes),\n-      StatusIs(error::INVALID_ARGUMENT, HasSubstr(\"Unknown output name\")));\n+  EXPECT_THAT(c.set_output(\"nonexistent\", shapes),\n+              absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                                     HasSubstr(\"Unknown output name\")));\n   TF_EXPECT_OK(c.set_output(\"output\", shapes));\n   EXPECT_EQ(\"5\", c.DebugString(c.NumElements(c.output(0))));\n   EXPECT_EQ(\"10\", c.DebugString(c.NumElements(c.output(1))));\n@@ -169,9 +169,10 @@ TEST_F(ShapeInferenceTest, Run) {\n     // Extra error message is attached when Run fails.\n     EXPECT_THAT(\n         c.Run(fn),\n-        StatusIs(error::INVALID_ARGUMENT,\n-                 AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 1\"),\n-                       HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"))));\n+        absl_testing::StatusIs(\n+            error::INVALID_ARGUMENT,\n+            AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 1\"),\n+                  HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"))));\n   }\n }\n \n@@ -193,10 +194,11 @@ TEST_F(ShapeInferenceTest, AttachContext) {\n     };\n     EXPECT_THAT(\n         c.Run(fn),\n-        StatusIs(error::INVALID_ARGUMENT,\n-                 AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 3\"),\n-                       HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n-                       HasSubstr(\"input shapes: [1,2,3]\"))));\n+        absl_testing::StatusIs(\n+            error::INVALID_ARGUMENT,\n+            AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 3\"),\n+                  HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n+                  HasSubstr(\"input shapes: [1,2,3]\"))));\n   }\n \n   // Error when a constant tensor value was requested.\n@@ -216,12 +218,13 @@ TEST_F(ShapeInferenceTest, AttachContext) {\n     };\n     EXPECT_THAT(\n         c.Run(fn),\n-        StatusIs(error::INVALID_ARGUMENT,\n-                 AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 3\"),\n-                       HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n-                       HasSubstr(\"input shapes: [1,2,3], [4,5] and with \"\n-                                 \"computed input tensors: \"\n-                                 \"input[1] = <1.1 2.2 3.3 4.4 5.5>.\"))));\n+        absl_testing::StatusIs(\n+            error::INVALID_ARGUMENT,\n+            AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 3\"),\n+                  HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n+                  HasSubstr(\"input shapes: [1,2,3], [4,5] and with \"\n+                            \"computed input tensors: \"\n+                            \"input[1] = <1.1 2.2 3.3 4.4 5.5>.\"))));\n   }\n \n   // Error when a constant tensor value as shape was requested, but no partial\n@@ -242,12 +245,13 @@ TEST_F(ShapeInferenceTest, AttachContext) {\n     };\n     EXPECT_THAT(\n         c.Run(fn),\n-        StatusIs(error::INVALID_ARGUMENT,\n-                 AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 1\"),\n-                       HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n-                       HasSubstr(\"with input shapes: [3], [4] and with \"\n-                                 \"computed input tensors: input[1] \"\n-                                 \"= <1 2 3 4 5>.\"))));\n+        absl_testing::StatusIs(\n+            error::INVALID_ARGUMENT,\n+            AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 1\"),\n+                  HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n+                  HasSubstr(\"with input shapes: [3], [4] and with \"\n+                            \"computed input tensors: input[1] \"\n+                            \"= <1 2 3 4 5>.\"))));\n   }\n \n   // Error when a constant tensor value as shape was requested, and a partial\n@@ -268,7 +272,7 @@ TEST_F(ShapeInferenceTest, AttachContext) {\n     };\n     EXPECT_THAT(\n         c.Run(fn),\n-        StatusIs(\n+        absl_testing::StatusIs(\n             error::INVALID_ARGUMENT,\n             AllOf(HasSubstr(\"Shape must be at most rank 0 but is rank 1\"),\n                   HasSubstr(\"node foo\"), HasSubstr(\"foo_op\"),\n@@ -362,9 +366,10 @@ TEST_F(ShapeInferenceTest, WithRank) {\n \n   // WithRank on shape with known dimensionality.\n   s1 = in1;\n-  EXPECT_THAT(c.WithRank(in1, 2, &s1),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Shape must be rank 2 but is rank 3\")));\n+  EXPECT_THAT(\n+      c.WithRank(in1, 2, &s1),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Shape must be rank 2 but is rank 3\")));\n \n   EXPECT_FALSE(IsSet(s1));\n   TF_EXPECT_OK(c.WithRank(in1, 3, &s1));\n@@ -396,10 +401,10 @@ TEST_F(ShapeInferenceTest, WithRankAtMost) {\n \n   // WithRankAtMost on shape with known dimensionality.\n   s1 = in1;\n-  EXPECT_THAT(\n-      c.WithRankAtMost(in1, 2, &s1),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Shape must be at most rank 2 but is rank 3\")));\n+  EXPECT_THAT(c.WithRankAtMost(in1, 2, &s1),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Shape must be at most rank 2 but is rank 3\")));\n \n   EXPECT_FALSE(IsSet(s1));\n   TF_EXPECT_OK(c.WithRankAtMost(in1, 3, &s1));\n@@ -435,10 +440,10 @@ TEST_F(ShapeInferenceTest, WithRankAtLeast) {\n \n   // WithRankAtLeast on shape with known dimensionality.\n   s1 = in1;\n-  EXPECT_THAT(\n-      c.WithRankAtLeast(in1, 4, &s1),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Shape must be at least rank 4 but is rank 3\")));\n+  EXPECT_THAT(c.WithRankAtLeast(in1, 4, &s1),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Shape must be at least rank 4 but is rank 3\")));\n \n   EXPECT_FALSE(IsSet(s1));\n   TF_EXPECT_OK(c.WithRankAtLeast(in1, 3, &s1));\n@@ -478,14 +483,16 @@ TEST_F(ShapeInferenceTest, WithValue) {\n   // WithValue on dimension with known size.\n   out1 = d0;\n \n-  EXPECT_THAT(c.WithValue(d0, 0, &out1),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimension must be 0 but is 1\")));\n+  EXPECT_THAT(\n+      c.WithValue(d0, 0, &out1),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Dimension must be 0 but is 1\")));\n   EXPECT_FALSE(IsSet(out1));\n   out1 = d0;\n-  EXPECT_THAT(c.WithValue(d0, 2, &out1),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimension must be 2 but is 1\")));\n+  EXPECT_THAT(\n+      c.WithValue(d0, 2, &out1),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Dimension must be 2 but is 1\")));\n \n   EXPECT_FALSE(IsSet(out1));\n   TF_EXPECT_OK(c.WithValue(d0, 1, &out1));\n@@ -545,13 +552,15 @@ TEST_F(ShapeInferenceTest, MergeDim) {\n \n   // Merging unequal values is an error.\n   EXPECT_THAT(c.Merge(d2, d1, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimensions must be equal, but are 2 and 1\")));\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimensions must be equal, but are 2 and 1\")));\n \n   EXPECT_FALSE(IsSet(out));\n   EXPECT_THAT(c.Merge(d1, d2, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimensions must be equal, but are 1 and 2\")));\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimensions must be equal, but are 1 and 2\")));\n \n   EXPECT_FALSE(IsSet(out));\n \n@@ -760,7 +769,7 @@ TEST_F(ShapeInferenceTest, MergeShape) {\n   out = s_unknown;\n   EXPECT_THAT(\n       c.Merge(s_u_2, s_1_3, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\n               \"Dimension 1 in both shapes must be equal, but are 2 and 3\")));\n@@ -769,17 +778,17 @@ TEST_F(ShapeInferenceTest, MergeShape) {\n   out = s_unknown;\n   EXPECT_THAT(\n       c.Merge(s_1_3, s_u_2, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\n               \"Dimension 1 in both shapes must be equal, but are 3 and 2\")));\n \n   EXPECT_FALSE(IsSet(out));\n   out = s_unknown;\n-  EXPECT_THAT(\n-      c.Merge(s_1, s_1_2, &out),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Shapes must be equal rank, but are 1 and 2\")));\n+  EXPECT_THAT(c.Merge(s_1, s_1_2, &out),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Shapes must be equal rank, but are 1 and 2\")));\n \n   EXPECT_FALSE(IsSet(out));\n \n@@ -827,18 +836,19 @@ TEST_F(ShapeInferenceTest, MergePrefix) {\n   s_out = s_unknown;\n   s_prefix_out = s_unknown;\n   EXPECT_THAT(c.MergePrefix(s_1_u_3, s_2_4, &s_out, &s_prefix_out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimensions must be equal, but are 1 and 2\")));\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimensions must be equal, but are 1 and 2\")));\n \n   EXPECT_FALSE(IsSet(s_out));\n   EXPECT_FALSE(IsSet(s_prefix_out));\n \n   s_out = s_unknown;\n   s_prefix_out = s_unknown;\n-  EXPECT_THAT(\n-      c.MergePrefix(s_2_4, s_1_u_3, &s_out, &s_prefix_out),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Shape must be at least rank 3 but is rank 2\")));\n+  EXPECT_THAT(c.MergePrefix(s_2_4, s_1_u_3, &s_out, &s_prefix_out),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Shape must be at least rank 3 but is rank 2\")));\n   EXPECT_FALSE(IsSet(s_out));\n   EXPECT_FALSE(IsSet(s_prefix_out));\n }\n@@ -898,15 +908,16 @@ TEST_F(ShapeInferenceTest, Subshape) {\n   out = unknown;\n   EXPECT_THAT(\n       c.Subshape(in0, 6, -3, &out),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Subshape must have computed start <= end, but is 5 \"\n-                         \"and 2 (computed from start 6 and end -3 over shape \"\n-                         \"with rank 5)\")));\n+      absl_testing::StatusIs(\n+          error::INVALID_ARGUMENT,\n+          HasSubstr(\"Subshape must have computed start <= end, but is 5 \"\n+                    \"and 2 (computed from start 6 and end -3 over shape \"\n+                    \"with rank 5)\")));\n   EXPECT_FALSE(IsSet(out));\n   out = unknown;\n   EXPECT_THAT(\n       c.Subshape(in0, -50, 100, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\n               \"Subshape start out of bounds: -50, for shape with rank 5\")));\n@@ -915,7 +926,7 @@ TEST_F(ShapeInferenceTest, Subshape) {\n   out = unknown;\n   EXPECT_THAT(\n       c.Subshape(in0, 0, -50, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\"Subshape end out of bounds: -50, for shape with rank 5\")));\n \n@@ -974,14 +985,14 @@ TEST_F(ShapeInferenceTest, ReplaceDim) {\n   EXPECT_EQ(\"?\", c.DebugString(replaced));\n \n   // out of range indexing.\n-  EXPECT_THAT(\n-      c.ReplaceDim(in, 3, c.Dim(in, 1), &replaced),\n-      StatusIs(error::INVALID_ARGUMENT, HasSubstr(\"Out of range dim_index\")));\n+  EXPECT_THAT(c.ReplaceDim(in, 3, c.Dim(in, 1), &replaced),\n+              absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                                     HasSubstr(\"Out of range dim_index\")));\n   EXPECT_FALSE(IsSet(replaced));\n   replaced = in;\n-  EXPECT_THAT(\n-      c.ReplaceDim(in, -4, c.Dim(in, 1), &replaced),\n-      StatusIs(error::INVALID_ARGUMENT, HasSubstr(\"Out of range dim_index\")));\n+  EXPECT_THAT(c.ReplaceDim(in, -4, c.Dim(in, 1), &replaced),\n+              absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                                     HasSubstr(\"Out of range dim_index\")));\n   EXPECT_FALSE(IsSet(replaced));\n }\n \n@@ -1216,8 +1227,9 @@ TEST_F(ShapeInferenceTest, MakeShapeFromShapeProto) {\n   proto.add_dim()->set_size(0);\n   EXPECT_THAT(\n       c.MakeShapeFromShapeProto(proto, &out),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"An unknown shape must not have any dimensions set\")));\n+      absl_testing::StatusIs(\n+          error::INVALID_ARGUMENT,\n+          HasSubstr(\"An unknown shape must not have any dimensions set\")));\n   EXPECT_FALSE(IsSet(out));\n \n   // With known rank.\n@@ -1233,7 +1245,7 @@ TEST_F(ShapeInferenceTest, MakeShapeFromShapeProto) {\n   proto.add_dim()->set_size(-2);\n   EXPECT_THAT(\n       c.MakeShapeFromShapeProto(proto, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\"Shape [0,?,1000,-2] has dimensions with values below -1 \"\n                     \"(where -1 means unknown)\")));\n@@ -1302,23 +1314,23 @@ TEST_F(ShapeInferenceTest, MakeDimForScalarInput) {\n   TF_EXPECT_OK(c.MakeDimForScalarInput(0, &d));\n   EXPECT_EQ(\"20\", c.DebugString(d));\n \n-  EXPECT_THAT(\n-      c.MakeDimForScalarInput(1, &d),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Dimension size, given by scalar input 1, must be \"\n-                         \"non-negative but is -1\")));\n+  EXPECT_THAT(c.MakeDimForScalarInput(1, &d),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimension size, given by scalar input 1, must be \"\n+                            \"non-negative but is -1\")));\n \n   // Same tests, with int64 values.\n   t1 = tensorflow::test::AsScalar<int64_t>(20);\n   t2 = tensorflow::test::AsScalar<int64_t>(-1);\n   TF_EXPECT_OK(c.MakeDimForScalarInput(0, &d));\n   EXPECT_EQ(\"20\", c.DebugString(d));\n \n-  EXPECT_THAT(\n-      c.MakeDimForScalarInput(1, &d),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Dimension size, given by scalar input 1, must be \"\n-                         \"non-negative but is -1\")));\n+  EXPECT_THAT(c.MakeDimForScalarInput(1, &d),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimension size, given by scalar input 1, must be \"\n+                            \"non-negative but is -1\")));\n }\n \n TEST_F(ShapeInferenceTest, MakeDimForScalarInputWithNegativeIndexing) {\n@@ -1339,17 +1351,19 @@ TEST_F(ShapeInferenceTest, MakeDimForScalarInputWithNegativeIndexing) {\n   EXPECT_EQ(\"2\", c.DebugString(d));\n \n   EXPECT_THAT(c.MakeDimForScalarInputWithNegativeIndexing(0, 1, &d),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimension size, given by scalar input -2 \"\n-                                 \"must be in range [-1, 1)\")));\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimension size, given by scalar input -2 \"\n+                            \"must be in range [-1, 1)\")));\n \n   TF_EXPECT_OK(c.MakeDimForScalarInputWithNegativeIndexing(1, 4, &d));\n   EXPECT_EQ(\"3\", c.DebugString(d));\n \n   EXPECT_THAT(c.MakeDimForScalarInputWithNegativeIndexing(1, 2, &d),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimension size, given by scalar input 3 \"\n-                                 \"must be in range [-2, 2)\")));\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimension size, given by scalar input 3 \"\n+                            \"must be in range [-2, 2)\")));\n }\n \n TEST_F(ShapeInferenceTest, GetAttr) {\n@@ -1404,33 +1418,38 @@ TEST_F(ShapeInferenceTest, Divide) {\n \n   EXPECT_THAT(\n       c.Divide(d_6, 5, evenly_divisible, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\"Dimension size must be evenly divisible by 5 but is 6\")));\n \n-  EXPECT_THAT(c.Divide(d_6, 0, evenly_divisible, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Divisor must be positive but is 0\")));\n-  EXPECT_THAT(c.Divide(d_6, d_0, evenly_divisible, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Divisor must be positive but is 0\")));\n+  EXPECT_THAT(\n+      c.Divide(d_6, 0, evenly_divisible, &out),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Divisor must be positive but is 0\")));\n+  EXPECT_THAT(\n+      c.Divide(d_6, d_0, evenly_divisible, &out),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Divisor must be positive but is 0\")));\n \n-  EXPECT_THAT(c.Divide(d_6, -1, evenly_divisible, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Divisor must be positive but is -1\")));\n+  EXPECT_THAT(\n+      c.Divide(d_6, -1, evenly_divisible, &out),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Divisor must be positive but is -1\")));\n \n   // Repeat error cases above with evenly_divisible=false.\n   evenly_divisible = false;\n   TF_EXPECT_OK(c.Divide(d_6, 5, evenly_divisible, &out));\n   EXPECT_EQ(\"1\", c.DebugString(out));\n \n-  EXPECT_THAT(c.Divide(d_6, 0, evenly_divisible, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Divisor must be positive but is 0\")));\n+  EXPECT_THAT(\n+      c.Divide(d_6, 0, evenly_divisible, &out),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Divisor must be positive but is 0\")));\n \n-  EXPECT_THAT(c.Divide(d_6, -1, evenly_divisible, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Divisor must be positive but is -1\")));\n+  EXPECT_THAT(\n+      c.Divide(d_6, -1, evenly_divisible, &out),\n+      absl_testing::StatusIs(error::INVALID_ARGUMENT,\n+                             HasSubstr(\"Divisor must be positive but is -1\")));\n }\n \n TEST_F(ShapeInferenceTest, Add) {\n@@ -1480,9 +1499,10 @@ TEST_F(ShapeInferenceTest, Add) {\n   EXPECT_TRUE(SameHandle(out, d_6));\n \n   EXPECT_THAT(c.Add(d_6, std::numeric_limits<int64_t>::max() - 5, &out),\n-              StatusIs(error::INVALID_ARGUMENT,\n-                       HasSubstr(\"Dimension size overflow from adding 6 and \"\n-                                 \"9223372036854775802\")));\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Dimension size overflow from adding 6 and \"\n+                            \"9223372036854775802\")));\n }\n \n TEST_F(ShapeInferenceTest, Subtract) {\n@@ -1532,7 +1552,7 @@ TEST_F(ShapeInferenceTest, Subtract) {\n \n   EXPECT_THAT(\n       c.Subtract(d_5, d_6, &out),\n-      StatusIs(\n+      absl_testing::StatusIs(\n           error::INVALID_ARGUMENT,\n           HasSubstr(\"Negative dimension size caused by subtracting 6 from 5\")));\n }\n@@ -1589,10 +1609,10 @@ TEST_F(ShapeInferenceTest, Multiply) {\n   TF_EXPECT_OK(c.Multiply(d_6, c.UnknownDim(), &out));\n   EXPECT_EQ(\"?\", c.DebugString(out));\n \n-  EXPECT_THAT(\n-      c.Multiply(d_6, std::numeric_limits<int64_t>::max() / 2, &out),\n-      StatusIs(error::INVALID_ARGUMENT,\n-               HasSubstr(\"Negative dimension size caused by overflow\")));\n+  EXPECT_THAT(c.Multiply(d_6, std::numeric_limits<int64_t>::max() / 2, &out),\n+              absl_testing::StatusIs(\n+                  error::INVALID_ARGUMENT,\n+                  HasSubstr(\"Negative dimension size caused by overflow\")));\n }\n \n TEST_F(ShapeInferenceTest, FullyDefined) {"
        },
        {
            "sha": "e77fed6b3f83a729a90f10998c00805c98406527",
            "filename": "tensorflow/core/framework/shape_inference_testutil.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fshape_inference_testutil.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fshape_inference_testutil.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fshape_inference_testutil.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -92,9 +92,8 @@ absl::Status ShapeInferenceTestutil::InferShapes(ShapeInferenceTestOp op,\n     absl::string_view expected(expected_outs_v[i]);\n     shape_inference::ShapeHandle out = c.output(i);\n \n-    string err_prefix = strings::StrCat(\"Output \", i);\n-    string err_suffix =\n-        strings::StrCat(\". Output shape was \", c.DebugString(out));\n+    string err_prefix = absl::StrCat(\"Output \", i);\n+    string err_suffix = absl::StrCat(\". Output shape was \", c.DebugString(out));\n \n     int in_index = -1;\n     for (int i = 0; i < c.num_inputs(); ++i) {\n@@ -113,7 +112,7 @@ absl::Status ShapeInferenceTestutil::InferShapes(ShapeInferenceTestOp op,\n                        err_suffix);\n       }\n       auto v = str_util::Split(expected, '|');\n-      if (std::find(v.begin(), v.end(), strings::StrCat(\"in\", in_index)) ==\n+      if (std::find(v.begin(), v.end(), absl::StrCat(\"in\", in_index)) ==\n           v.end()) {\n         return Unknown(\n             err_prefix, \" matched input \", in_index,\n@@ -154,7 +153,7 @@ absl::Status ShapeInferenceTestutil::InferShapes(ShapeInferenceTestOp op,\n                      \" but was \", c.Rank(out), err_suffix);\n     }\n     for (int j = 0; j < expected_dims.size(); ++j) {\n-      err_prefix = strings::StrCat(\"Output dim \", i, \",\", j);\n+      err_prefix = absl::StrCat(\"Output dim \", i, \",\", j);\n       absl::string_view expected_dim(expected_dims[j]);\n       DimensionHandle out_dim = c.Dim(out, j);\n \n@@ -191,8 +190,8 @@ absl::Status ShapeInferenceTestutil::InferShapes(ShapeInferenceTestOp op,\n               \"DimensionHandle for an input, but did not\", err_suffix);\n         }\n         if (std::find(v.begin(), v.end(),\n-                      strings::StrCat(\"d\", in_dim_idx.first, \"_\",\n-                                      in_dim_idx.second)) == v.end()) {\n+                      absl::StrCat(\"d\", in_dim_idx.first, \"_\",\n+                                   in_dim_idx.second)) == v.end()) {\n           return Unknown(err_prefix, \" matched input d\", in_dim_idx.first, \"_\",\n                          in_dim_idx.second,\n                          \", but should have matched one of (\", expected_dim,"
        },
        {
            "sha": "4dc00a66af3adbf1d852905a85dc5c7e153d0a05",
            "filename": "tensorflow/core/framework/tensor_shape.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_shape.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_shape.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftensor_shape.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -757,36 +757,36 @@ string TensorShapeRep::DebugString() const {\n   if (shape.unknown_rank()) return \"<unknown>\";\n   string s = \"[\";\n   for (int i = 0; i < shape.dims(); i++) {\n-    if (i > 0) strings::StrAppend(&s, \",\");\n+    if (i > 0) absl::StrAppend(&s, \",\");\n     int64_t dim = shape.dim_size(i);\n     if (dim < 0) {\n-      strings::StrAppend(&s, \"?\");\n+      absl::StrAppend(&s, \"?\");\n     } else {\n-      strings::StrAppend(&s, dim);\n+      absl::StrAppend(&s, dim);\n     }\n   }\n-  strings::StrAppend(&s, \"]\");\n+  absl::StrAppend(&s, \"]\");\n   return s;\n }\n \n string TensorShapeRep::DebugString(const TensorShapeProto& proto) {\n   string s;\n   if (proto.unknown_rank()) {\n-    strings::StrAppend(&s, \"<unknown>\");\n+    absl::StrAppend(&s, \"<unknown>\");\n     if (proto.dim_size() == 0) return s;\n   }\n-  strings::StrAppend(&s, \"[\");\n+  absl::StrAppend(&s, \"[\");\n   bool first = true;\n   for (const auto& d : proto.dim()) {\n-    if (!first) strings::StrAppend(&s, \",\");\n+    if (!first) absl::StrAppend(&s, \",\");\n     if (d.size() == -1) {\n-      strings::StrAppend(&s, \"?\");\n+      absl::StrAppend(&s, \"?\");\n     } else {\n-      strings::StrAppend(&s, d.size());\n+      absl::StrAppend(&s, d.size());\n     }\n     first = false;\n   }\n-  strings::StrAppend(&s, \"]\");\n+  absl::StrAppend(&s, \"]\");\n   return s;\n }\n \n@@ -869,10 +869,10 @@ string TensorShapeUtils::ShapeListString(\n   string result = \"[\";\n   bool first = true;\n   for (const TensorShape& shape : shapes) {\n-    strings::StrAppend(&result, (first ? \"\" : \", \"), shape.DebugString());\n+    absl::StrAppend(&result, first ? \"\" : \", \", shape.DebugString());\n     first = false;\n   }\n-  strings::StrAppend(&result, \"]\");\n+  absl::StrAppend(&result, \"]\");\n   return result;\n }\n \n@@ -990,10 +990,10 @@ string PartialTensorShapeUtils::PartialShapeListString(\n   string result = \"[\";\n   bool first = true;\n   for (const PartialTensorShape& shape : shapes) {\n-    strings::StrAppend(&result, (first ? \"\" : \", \"), shape.DebugString());\n+    absl::StrAppend(&result, first ? \"\" : \", \", shape.DebugString());\n     first = false;\n   }\n-  strings::StrAppend(&result, \"]\");\n+  absl::StrAppend(&result, \"]\");\n   return result;\n }\n "
        },
        {
            "sha": "3de9b9b8462a33007804c80175d9e6fdfd02fec3",
            "filename": "tensorflow/core/framework/tensor_shape_test.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 44,
            "changes": 91,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_shape_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_shape_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftensor_shape_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -74,11 +74,11 @@ TEST(TensorShapeTest, RemoveDimWithStatus) {\n   EXPECT_EQ(s.num_elements(), 5);\n   EXPECT_EQ(s.dims(), 1);\n \n-  EXPECT_THAT(\n-      s.RemoveDimWithStatus(-1),\n-      testing::StatusIs(error::Code::INTERNAL,\n-                        ::testing::ContainsRegex(\n-                            \"Expected dimension index to be non-negative\")));\n+  EXPECT_THAT(s.RemoveDimWithStatus(-1),\n+              absl_testing::StatusIs(\n+                  error::Code::INTERNAL,\n+                  ::testing::ContainsRegex(\n+                      \"Expected dimension index to be non-negative\")));\n }\n \n TEST(TensorShapeTest, RemoveAndAddDim) {\n@@ -111,9 +111,9 @@ TEST(TensorShapeTest, RemoveLastDimsWithStatus) {\n \n   EXPECT_THAT(\n       s.RemoveLastDimsWithStatus(4),\n-      testing::StatusIs(error::Code::INTERNAL,\n-                        ::testing::ContainsRegex(\n-                            \"Expected dimension index to be at most 3\")));\n+      absl_testing::StatusIs(error::Code::INTERNAL,\n+                             ::testing::ContainsRegex(\n+                                 \"Expected dimension index to be at most 3\")));\n }\n \n TEST(TensorShapeTest, RemoveDimRange) {\n@@ -202,22 +202,22 @@ TEST(TensorShapeTest, RemoveDimRangeWithStatusWithInvalidBeginEnd) {\n   TensorShape s3({2, 5, 7});\n \n   EXPECT_THAT(s3.RemoveDimRangeWithStatus(-5, 0),\n-              testing::StatusIs(error::Code::INTERNAL,\n-                                ::testing::ContainsRegex(\n-                                    \"Start index must be non-negative\")));\n+              absl_testing::StatusIs(error::Code::INTERNAL,\n+                                     ::testing::ContainsRegex(\n+                                         \"Start index must be non-negative\")));\n \n   EXPECT_THAT(s3.RemoveDimRangeWithStatus(5, 0),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\"Start index must be less than 3\")));\n \n   EXPECT_THAT(s3.RemoveDimRangeWithStatus(0, -5),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\"End index must be non-negative\")));\n \n   EXPECT_THAT(s3.RemoveDimRangeWithStatus(0, 5),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\"End index must be less than 3\")));\n }\n@@ -238,20 +238,21 @@ TEST(TensorShapeTest, InsertDimWithStatusWithInvalidData) {\n   TensorShape s({10, 5, 20});\n \n   EXPECT_THAT(s.InsertDimWithStatus(1, -5),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INVALID_ARGUMENT,\n                   ::testing::ContainsRegex(\"Expected a non-negative size\")));\n \n   EXPECT_THAT(\n       s.InsertDimWithStatus(-1, 5),\n-      testing::StatusIs(error::Code::INTERNAL,\n-                        ::testing::ContainsRegex(\n-                            \"The insertion index must be non-negative\")));\n-\n-  EXPECT_THAT(s.InsertDimWithStatus(4, 5),\n-              testing::StatusIs(error::Code::INTERNAL,\n-                                ::testing::ContainsRegex(\n-                                    \"The insertion index must be at most 3\")));\n+      absl_testing::StatusIs(error::Code::INTERNAL,\n+                             ::testing::ContainsRegex(\n+                                 \"The insertion index must be non-negative\")));\n+\n+  EXPECT_THAT(\n+      s.InsertDimWithStatus(4, 5),\n+      absl_testing::StatusIs(\n+          error::Code::INTERNAL,\n+          ::testing::ContainsRegex(\"The insertion index must be at most 3\")));\n }\n \n TEST(TensorShapeTest, InsertDimWithStatusWithTooManyDims) {\n@@ -261,7 +262,7 @@ TEST(TensorShapeTest, InsertDimWithStatusWithTooManyDims) {\n     TF_EXPECT_OK(s.InsertDimWithStatus(1, 1));\n   }\n   EXPECT_THAT(s.InsertDimWithStatus(1, 1),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\n                       \"Shape has.*dimensions which is the maximum allowed\")));\n@@ -348,17 +349,17 @@ TEST(TensorShapeTest, SetDimWithStatus) {\n   EXPECT_EQ(s.dim_size(1), 2);\n \n   EXPECT_THAT(s.SetDimWithStatus(-1, 2),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INVALID_ARGUMENT,\n                   ::testing::ContainsRegex(\"Index must be non-negative\")));\n \n-  EXPECT_THAT(\n-      s.SetDimWithStatus(4, 2),\n-      testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                        ::testing::ContainsRegex(\"Index must be less than 3\")));\n+  EXPECT_THAT(s.SetDimWithStatus(4, 2),\n+              absl_testing::StatusIs(\n+                  error::Code::INVALID_ARGUMENT,\n+                  ::testing::ContainsRegex(\"Index must be less than 3\")));\n \n   EXPECT_THAT(s.SetDimWithStatus(0, -2),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INVALID_ARGUMENT,\n                   ::testing::ContainsRegex(\"Expected a non-negative size\")));\n }\n@@ -436,10 +437,11 @@ TEST(TensorShapeTest, AddDimWithStatus) {\n   EXPECT_EQ(absl::StatusCode::kInvalidArgument, status.code());\n \n   TensorShape s2({std::numeric_limits<int64_t>::max()});\n-  EXPECT_THAT(s2.AddDimWithStatus(2),\n-              testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                                ::testing::ContainsRegex(\n-                                    \"Encountered overflow when multiplying\")));\n+  EXPECT_THAT(\n+      s2.AddDimWithStatus(2),\n+      absl_testing::StatusIs(\n+          error::Code::INVALID_ARGUMENT,\n+          ::testing::ContainsRegex(\"Encountered overflow when multiplying\")));\n }\n \n TEST(TensorShapeTest, AppendShapeWithStatus) {\n@@ -450,10 +452,11 @@ TEST(TensorShapeTest, AppendShapeWithStatus) {\n   EXPECT_EQ(s.dims(), 4);\n \n   TensorShape s3({std::numeric_limits<int64_t>::max()});\n-  EXPECT_THAT(s2.AppendShapeWithStatus(s3),\n-              testing::StatusIs(error::Code::INVALID_ARGUMENT,\n-                                ::testing::ContainsRegex(\n-                                    \"Encountered overflow when multiplying\")));\n+  EXPECT_THAT(\n+      s2.AppendShapeWithStatus(s3),\n+      absl_testing::StatusIs(\n+          error::Code::INVALID_ARGUMENT,\n+          ::testing::ContainsRegex(\"Encountered overflow when multiplying\")));\n }\n \n TEST(TensorShapeTest, Factory) {\n@@ -481,7 +484,7 @@ TEST(TensorShapeTest, AsEigenDSizess) {\n \n   Eigen::DSizes<Eigen::DenseIndex, 2> dsizes_out2;\n   EXPECT_THAT(s.AsEigenDSizesWithStatus<2>(&dsizes_out2),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\n                       \"tensor of 2 dimensions from a tensor of 3 dimensions\")));\n@@ -501,7 +504,7 @@ TEST(TensorShapeTest, AsEigenDSizesWithPadding) {\n \n   Eigen::DSizes<Eigen::DenseIndex, 2> dsizes_out2;\n   EXPECT_THAT(s.AsEigenDSizesWithPaddingWithStatus<2>(&dsizes_out2),\n-              testing::StatusIs(\n+              absl_testing::StatusIs(\n                   error::Code::INTERNAL,\n                   ::testing::ContainsRegex(\n                       \"at most 2 dimensions from a tensor of 3 dimensions\")));\n@@ -792,18 +795,18 @@ TensorShapeIterOld TensorShapeOld::end() const {\n }\n \n string TensorShapeOld::DebugString() const {\n-  return strings::StrCat(\n+  return absl::StrCat(\n       \"[\", absl::StrJoin(absl::Span<const int64_t>(dim_sizes_), \",\"), \"]\");\n }\n \n string TensorShapeOld::DebugString(const TensorShapeProto& proto) {\n   string s = \"[\";\n   bool first = true;\n   for (const auto& d : proto.dim()) {\n-    strings::StrAppend(&s, first ? \"\" : \",\", d.size());\n+    absl::StrAppend(&s, first ? \"\" : \",\", d.size());\n     first = false;\n   }\n-  strings::StrAppend(&s, \"]\");\n+  absl::StrAppend(&s, \"]\");\n   return s;\n }\n // End of old implementation\n@@ -999,7 +1002,7 @@ TEST(TensorShapeUtilsTest, NumElements) {\n   EXPECT_THAT(\n       TensorShapeUtils::NumElements({int64_max_val, int64_max_val},\n                                     &num_elements),\n-      testing::StatusIs(\n+      absl_testing::StatusIs(\n           error::Code::INVALID_ARGUMENT,\n           ::testing::ContainsRegex(\n               \"Can't compute total size of shape.*product would overflow\")));"
        },
        {
            "sha": "0eed9342c404ec6136fee059e4255871f7a4c724",
            "filename": "tensorflow/core/framework/tensor_slice.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_slice.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_slice.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftensor_slice.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -162,7 +162,7 @@ string TensorSlice::DebugString() const {\n     if (IsFullAt(d)) {\n       buffer.append(\"-\");\n     } else {\n-      strings::StrAppend(&buffer, starts_[d], \",\", lengths_[d]);\n+      absl::StrAppend(&buffer, starts_[d], \",\", lengths_[d]);\n     }\n     first = false;\n   }"
        },
        {
            "sha": "43a80931c18c75e4ee2780d4109a8758d798f49e",
            "filename": "tensorflow/core/framework/tensor_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftensor_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -1265,7 +1265,7 @@ TEST(Tensor_String, SimpleWithHelper) {\n   Tensor t2(DT_STRING, {2, 3});\n   for (int i = 0; i < 2; ++i) {\n     for (int j = 0; j < 3; ++j) {\n-      t2.matrix<tstring>()(i, j) = strings::StrCat(i * 3 + j);\n+      t2.matrix<tstring>()(i, j) = absl::StrCat(i * 3 + j);\n     }\n   }\n \n@@ -1662,7 +1662,7 @@ TEST(SummarizeValue, Uninitialized) {\n   Tensor x(DT_INT32);\n   TensorTestHelper::set_shape(&x, TensorShape({4, 4}));\n   EXPECT_EQ(\n-      strings::StrCat(\"uninitialized Tensor of 16 elements of type \", DT_INT32),\n+      absl::StrCat(\"uninitialized Tensor of 16 elements of type \", DT_INT32),\n       x.SummarizeValue(16));\n }\n "
        },
        {
            "sha": "9b26845e94820114cc6e0fca8348da3976292452",
            "filename": "tensorflow/core/framework/tensor_util_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftensor_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftensor_util_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -273,7 +273,7 @@ TEST(TensorUtil, Split) {\n TEST(TensorUtil, ConcatSplitStrings) {\n   Tensor x(DT_STRING, TensorShape({4, 3}));\n   for (int i = 0; i < 4 * 3; ++i) {\n-    x.flat<tstring>()(i) = strings::StrCat(\"foo_\", i);\n+    x.flat<tstring>()(i) = absl::StrCat(\"foo_\", i);\n   }\n \n   std::vector<Tensor> split;\n@@ -287,7 +287,7 @@ TEST(TensorUtil, ConcatSplitStrings) {\n \n   // Ensure that no memory is being shared between 'x' and 'x_round_tripped'.\n   for (int i = 0; i < 4 * 3; ++i) {\n-    x_round_tripped.flat<tstring>()(i) = strings::StrCat(\"bar_\", i);\n+    x_round_tripped.flat<tstring>()(i) = absl::StrCat(\"bar_\", i);\n   }\n   for (int i = 0; i < 4 * 3; ++i) {\n     EXPECT_NE(x.flat<tstring>()(i), x_round_tripped.flat<tstring>()(i));"
        },
        {
            "sha": "1e9274fbbb6cc1bf153152d8648d0c8b373eb5b7",
            "filename": "tensorflow/core/framework/types.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftypes.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftypes.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftypes.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -152,15 +152,15 @@ string DataTypeStringInternal(DataType dtype) {\n       return \"variant\";\n     default:\n       LOG(ERROR) << \"Unrecognized DataType enum value \" << dtype;\n-      return strings::StrCat(\"unknown dtype enum (\", dtype, \")\");\n+      return absl::StrCat(\"unknown dtype enum (\", dtype, \")\");\n   }\n }\n }  // end namespace\n \n string DataTypeString(DataType dtype) {\n   if (IsRefType(dtype)) {\n     DataType non_ref = static_cast<DataType>(dtype - kDataTypeRefOffset);\n-    return strings::StrCat(DataTypeStringInternal(non_ref), \"_ref\");\n+    return absl::StrCat(DataTypeStringInternal(non_ref), \"_ref\");\n   }\n   return DataTypeStringInternal(dtype);\n }\n@@ -284,8 +284,7 @@ string DeviceTypeString(const DeviceType& device_type) {\n string DataTypeSliceString(const DataTypeSlice types) {\n   string out;\n   for (auto it = types.begin(); it != types.end(); ++it) {\n-    strings::StrAppend(&out, ((it == types.begin()) ? \"\" : \", \"),\n-                       DataTypeString(*it));\n+    absl::StrAppend(&out, it == types.begin() ? \"\" : \", \", DataTypeString(*it));\n   }\n   return out;\n }"
        },
        {
            "sha": "745416098d71b9fcfb3389f80d4cb12069788190",
            "filename": "tensorflow/core/framework/types_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftypes_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Ftypes_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Ftypes_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -53,7 +53,7 @@ TEST(TypesTest, kDataTypeRefOffset) {\n     absl::string_view enum_name = enum_descriptor->FindValueByNumber(e)->name();\n     absl::string_view enum_ref_name =\n         enum_descriptor->FindValueByNumber(e_ref)->name();\n-    EXPECT_EQ(strings::StrCat(enum_name, \"_REF\"), enum_ref_name)\n+    EXPECT_EQ(absl::StrCat(enum_name, \"_REF\"), enum_ref_name)\n         << enum_name << \"_REF should have value \" << e_ref << \" not \"\n         << enum_ref_name;\n     // Validate DataTypeString() as well."
        },
        {
            "sha": "40028b91a956504d7d2945017d317030785bca3b",
            "filename": "tensorflow/core/framework/variant_tensor_data.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fvariant_tensor_data.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fvariant_tensor_data.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fvariant_tensor_data.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -94,7 +94,7 @@ string VariantTensorData::DebugString() const {\n   string repeated_field = \"\";\n   for (const auto& t : tensors_) {\n     repeated_field =\n-        strings::StrCat(repeated_field, \" tensors: \", t.DebugString());\n+        absl::StrCat(repeated_field, \" tensors: \", t.DebugString());\n   }\n   return strings::StrCat(\"type_name: \", type_name(), \" metadata: \", metadata_,\n                          repeated_field);"
        },
        {
            "sha": "2dbd0157e79b8f8469234ee4c20bd2b808e0e736",
            "filename": "tensorflow/core/framework/variant_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fvariant_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4218aaa99434742a490d1ceddf307dcc3fe1c2d/tensorflow%2Fcore%2Fframework%2Fvariant_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fframework%2Fvariant_test.cc?ref=e4218aaa99434742a490d1ceddf307dcc3fe1c2d",
            "patch": "@@ -591,8 +591,8 @@ TEST(VariantTest, TensorListTest) {\n   EXPECT_EQ(y_unknown.TypeName(), \"TensorList\");\n   EXPECT_EQ(y_unknown.TypeId(), TypeIndex::Make<VariantTensorDataProto>());\n   EXPECT_EQ(y_unknown.DebugString(),\n-            strings::StrCat(\n-                \"Variant<type: TensorList value: \", data.DebugString(), \">\"));\n+            absl::StrCat(\"Variant<type: TensorList value: \", data.DebugString(),\n+                         \">\"));\n }\n \n template <bool BIG>"
        }
    ],
    "stats": {
        "total": 1124,
        "additions": 568,
        "deletions": 556
    }
}