{
    "author": "seantalts",
    "message": "[XLA:CPU] Split IntrinsicFunction into its own lib for later use.\n\nPiperOrigin-RevId: 822800836",
    "sha": "03be5156fe82c1768280768d2f7bfba502d3eded",
    "files": [
        {
            "sha": "e96ef0b88a1d9b6fbd389f9bd8a933016841810d",
            "filename": "third_party/xla/xla/codegen/BUILD",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2FBUILD?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -206,11 +206,24 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"intrinsic_function\",\n+    hdrs = [\"intrinsic_function.h\"],\n+    deps = [\n+        \"//xla/codegen/intrinsic\",\n+        \"//xla/codegen/intrinsic:type\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:ir_headers\",\n+    ],\n+)\n+\n cc_library(\n     name = \"intrinsic_lib\",\n     srcs = [\"intrinsic_lib.cc\"],\n     hdrs = [\"intrinsic_lib.h\"],\n     deps = [\n+        \":intrinsic_function\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/codegen/intrinsic\",\n         \"//xla/codegen/intrinsic:erf\",\n@@ -226,14 +239,15 @@ cc_library(\n         \"//xla/service/llvm_ir:llvm_util\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n-        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Analysis\",\n         \"@llvm-project//llvm:ExecutionEngine\",\n         \"@llvm-project//llvm:IPO\",\n         \"@llvm-project//llvm:JITLink\",\n+        \"@llvm-project//llvm:Linker\",\n         \"@llvm-project//llvm:Passes\",\n         \"@llvm-project//llvm:Scalar\",\n         \"@llvm-project//llvm:Support\","
        },
        {
            "sha": "e4cc331938e5bba2a3f1fa1d984533d54fca39d7",
            "filename": "third_party/xla/xla/codegen/intrinsic/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2FBUILD?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -185,6 +185,7 @@ cc_library(\n     hdrs = [\"vec_name_mangler.h\"],\n     deps = [\n         \":type\",\n+        \"//xla:util\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/strings\","
        },
        {
            "sha": "30d6e31088a581023c1953330feda6d60c783eb2",
            "filename": "third_party/xla/xla/codegen/intrinsic/intrinsic.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fintrinsic.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fintrinsic.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fintrinsic.h?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -95,7 +95,7 @@ class Intrinsic {\n \n   template <typename... Types>\n   static std::string Name(Types... args) {\n-    return ::xla::codegen::intrinsic::FunctionName(\n+    return ::xla::codegen::intrinsic::GetTypedName(\n         Derived::kLastArgIsReturnType, {args...}, Derived::kName);\n   }\n "
        },
        {
            "sha": "515f8f31a3c02c6fa8589069ae7a1dcf1ab047fb",
            "filename": "third_party/xla/xla/codegen/intrinsic/vec_name_mangler.h",
            "status": "modified",
            "additions": 56,
            "deletions": 1,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fvec_name_mangler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fvec_name_mangler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fvec_name_mangler.h?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -24,9 +24,11 @@ limitations under the License.\n #include \"absl/log/check.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n+#include \"absl/strings/str_split.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/codegen/intrinsic/type.h\"\n+#include \"xla/util.h\"\n \n namespace xla::codegen::intrinsic {\n \n@@ -82,7 +84,7 @@ inline std::string GetMangledNamePrefix(\n                               param_cardinalities);\n }\n \n-inline std::string FunctionName(bool last_arg_is_return_type,\n+inline std::string GetTypedName(bool last_arg_is_return_type,\n                                 absl::Span<const intrinsics::Type> types,\n                                 absl::string_view func_name) {\n   std::vector<std::string> type_names;\n@@ -96,6 +98,59 @@ inline std::string FunctionName(bool last_arg_is_return_type,\n   return absl::StrCat(\"xla.\", func_name, \".\", absl::StrJoin(type_names, \".\"));\n }\n \n+struct ParsedFunctionName {\n+  std::string base_name;\n+  std::vector<intrinsics::Type> types;\n+  bool last_arg_is_return_type;\n+  bool is_masked;  // TODO: Add support for masked functions.\n+};\n+\n+inline std::string GetTypedName(const ParsedFunctionName& parsed_name) {\n+  return GetTypedName(parsed_name.last_arg_is_return_type, parsed_name.types,\n+                      parsed_name.base_name);\n+}\n+\n+inline absl::StatusOr<ParsedFunctionName> ParseFunctionName(\n+    absl::string_view function_name) {\n+  // The `to` in a typed function name is used to specify the return type, so\n+  // we ignore it when parsing the function name.\n+  static constexpr absl::string_view kIgnoredParts[] = {\"to\"};\n+  std::vector<intrinsics::Type> types;\n+  auto parts = absl::StrSplit(function_name, '.');\n+  int i = -1;\n+  ParsedFunctionName result;\n+  result.last_arg_is_return_type = false;\n+  result.is_masked = false;\n+  for (absl::string_view part : parts) {\n+    // Skip the first two parts, which will be `xla.<func_name>`:\n+    i++;\n+    if (i == 0) {\n+      if (part != \"xla\") {\n+        return InvalidArgument(\"Invalid function name: %s\", function_name);\n+      }\n+      // skip `xla.`\n+      continue;\n+    }\n+    if (i == 1) {\n+      result.base_name = std::string(part);\n+      continue;\n+    }\n+    if (bool ignored =\n+            absl::c_find(kIgnoredParts, part) != std::end(kIgnoredParts)) {\n+      if (part == \"to\") {\n+        result.last_arg_is_return_type = true;\n+      }\n+      continue;\n+    }\n+    types.push_back(intrinsics::Type::FromName(part));\n+  }\n+  if (i < 2) {\n+    return InvalidArgument(\"Invalid function name: %s\", function_name);\n+  }\n+  result.types = types;\n+  return result;\n+}\n+\n }  // namespace xla::codegen::intrinsic\n \n #endif  // XLA_CODEGEN_INTRINSIC_VEC_NAME_MANGLER_H_"
        },
        {
            "sha": "dd65f351ad9c85159c74ff3785c229a405bab833",
            "filename": "third_party/xla/xla/codegen/intrinsic_function.h",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_function.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_function.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_function.h?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -0,0 +1,63 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_CODEGEN_INTRINSIC_FUNCTION_H_\n+#define XLA_CODEGEN_INTRINSIC_FUNCTION_H_\n+\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/IR/Function.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"xla/codegen/intrinsic/intrinsic.h\"\n+#include \"xla/codegen/intrinsic/type.h\"\n+\n+namespace xla::codegen {\n+\n+// Interface representing a single vectorized math function approximation.\n+// Each implementation may support multiple vector widths and primitive types,\n+// defined by the SupportedVectorTypes() method. To emit LLVM IR for a\n+// particular vector width and primitive type, call CreateDefinition() with the\n+// desired vector_width and primitive_type.\n+class IntrinsicFunction {\n+ public:\n+  virtual ~IntrinsicFunction() = default;\n+  // The name of the function being approximated.\n+  virtual absl::string_view FunctionName() const = 0;\n+\n+  // Returns the vector types supported well by this approximation.\n+  virtual std::vector<std::vector<intrinsics::Type>> SupportedVectorTypes(\n+      absl::string_view features) const = 0;\n+\n+  // Returns the LLVM IR function definition for the approximation.\n+  virtual llvm::Function* CreateDefinition(llvm::Module& module,\n+                                           intrinsics::IntrinsicOptions options,\n+                                           absl::string_view name) const = 0;\n+\n+  // The vectorized function name, e.g. \"xla.ldexp.v8f64.v8i32\".\n+  virtual std::string GenerateVectorizedFunctionName(\n+      absl::Span<const intrinsics::Type> types) const = 0;\n+\n+  // The LLVM mangled prefix for the vectorized function, e.g.\n+  // \"_ZGV_LLVM_N8\" used in llvm::VecDesc.\n+  virtual std::string GenerateMangledSimdPrefix(\n+      absl::Span<const intrinsics::Type> types) const = 0;\n+};\n+\n+}  // namespace xla::codegen\n+\n+#endif  // XLA_CODEGEN_INTRINSIC_FUNCTION_H_"
        },
        {
            "sha": "23809838c1ebbe831ade98de4df5fac59b0b6fe1",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 23,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.cc?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -15,7 +15,6 @@ limitations under the License.\n \n #include \"xla/codegen/intrinsic_lib.h\"\n \n-#include <algorithm>\n #include <cstddef>\n #include <functional>\n #include <memory>\n@@ -27,7 +26,7 @@ limitations under the License.\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/check.h\"\n-#include \"absl/strings/str_split.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/Analysis/CGSCCPassManager.h\"\n@@ -48,6 +47,7 @@ limitations under the License.\n #include \"llvm/IR/Type.h\"\n #include \"llvm/IR/Value.h\"\n #include \"llvm/IR/Verifier.h\"\n+#include \"llvm/Linker/Linker.h\"\n #include \"llvm/Passes/PassBuilder.h\"\n #include \"llvm/Passes/StandardInstrumentations.h\"\n #include \"llvm/Support/Casting.h\"\n@@ -90,25 +90,6 @@ template <size_t N, typename F, typename Container>\n decltype(auto) apply_vector(F&& f, const Container& v) {\n   return apply_vector(f, v, std::make_index_sequence<N>{});\n }\n-\n-std::vector<Type> ParseTypesFromFunctionName(absl::string_view function_name) {\n-  // The `to` in a typed function name is used to specify the return type, so\n-  // we ignore it when parsing the function name.\n-  static constexpr absl::string_view kIgnoredParts[] = {\"to\"};\n-  std::vector<Type> types;\n-  auto parts = absl::StrSplit(function_name, '.');\n-  size_t i = 0;\n-  for (absl::string_view part : parts) {\n-    // Skip the first two parts, which will be `xla.<func_name>`:\n-    if (i++ < 2 || std::find(std::begin(kIgnoredParts), std::end(kIgnoredParts),\n-                             part) != std::end(kIgnoredParts)) {\n-      continue;\n-    }\n-    types.push_back(Type::FromName(part));\n-  }\n-  return types;\n-}\n-\n }  // namespace\n \n using intrinsics::IntrinsicOptions;\n@@ -131,7 +112,9 @@ class IntrinsicAdapter : public IntrinsicFunction {\n   llvm::Function* CreateDefinition(llvm::Module& module,\n                                    IntrinsicOptions options,\n                                    absl::string_view name) const override {\n-    std::vector<Type> types = ParseTypesFromFunctionName(name);\n+    absl::StatusOr<intrinsic::ParsedFunctionName> parsed =\n+        intrinsic::ParseFunctionName(name);\n+    CHECK_OK(parsed);\n     return apply_vector<Intrinsic::kNumArgs>(\n                [&](auto... args) {\n                  if constexpr (std::is_invocable_v<\n@@ -144,7 +127,7 @@ class IntrinsicAdapter : public IntrinsicFunction {\n                    return Intrinsic::CreateDefinition(&module, args...);\n                  }\n                },\n-               types)\n+               parsed->types)\n         .value();\n   }\n "
        },
        {
            "sha": "2907dcc0badb85ba418572e030e195e722732a65",
            "filename": "third_party/xla/xla/codegen/intrinsic_lib.h",
            "status": "modified",
            "additions": 1,
            "deletions": 33,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/03be5156fe82c1768280768d2f7bfba502d3eded/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic_lib.h?ref=03be5156fe82c1768280768d2f7bfba502d3eded",
            "patch": "@@ -17,51 +17,19 @@ limitations under the License.\n #define XLA_CODEGEN_INTRINSIC_LIB_H_\n \n #include <memory>\n-#include <string>\n #include <vector>\n \n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/strings/string_view.h\"\n-#include \"absl/types/span.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n-#include \"llvm/IR/Function.h\"\n #include \"llvm/IR/Module.h\"\n #include \"xla/codegen/intrinsic/intrinsic.h\"\n+#include \"xla/codegen/intrinsic_function.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla::codegen {\n \n-// Interface representing a single vectorized math function approximation.\n-// Each implementation may support multiple vector widths and primitive types,\n-// defined by the SupportedVectorTypes() method. To emit LLVM IR for a\n-// particular vector width and primitive type, call CreateDefinition() with the\n-// desired vector_width and primitive_type.\n-class IntrinsicFunction {\n- public:\n-  virtual ~IntrinsicFunction() = default;\n-  // The name of the function being approximated.\n-  virtual absl::string_view FunctionName() const = 0;\n-\n-  // Returns the vector types supported well by this approximation.\n-  virtual std::vector<std::vector<intrinsics::Type>> SupportedVectorTypes(\n-      absl::string_view features) const = 0;\n-\n-  // Returns the LLVM IR function definition for the approximation.\n-  virtual llvm::Function* CreateDefinition(llvm::Module& module,\n-                                           intrinsics::IntrinsicOptions options,\n-                                           absl::string_view name) const = 0;\n-\n-  // The vectorized function name, e.g. \"xla.ldexp.v8f64.v8i32\".\n-  virtual std::string GenerateVectorizedFunctionName(\n-      absl::Span<const intrinsics::Type> types) const = 0;\n-\n-  // The LLVM mangled prefix for the vectorized function, e.g.\n-  // \"_ZGV_LLVM_N8\" used in llvm::VecDesc.\n-  virtual std::string GenerateMangledSimdPrefix(\n-      absl::Span<const intrinsics::Type> types) const = 0;\n-};\n-\n // A library of intrinsic functions and math approximations.\n // The library hooks into LLVM compilation in two places:\n // 1. It provides a set of VecDescs that are used to replace LLVM"
        }
    ],
    "stats": {
        "total": 202,
        "additions": 143,
        "deletions": 59
    }
}