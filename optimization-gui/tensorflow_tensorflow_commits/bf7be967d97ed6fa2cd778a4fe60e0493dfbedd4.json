{
    "author": "unknown",
    "message": "Convert a slice taking a single element from the minor dim of a reshape into a strided slice to allow more performant tiling on some platforms.\n\nPiperOrigin-RevId: 836832835",
    "sha": "bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4",
    "files": [
        {
            "sha": "4a3cdecba58f3ca0861a6c53410faab7a45939a4",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.cc",
            "status": "modified",
            "additions": 82,
            "deletions": 0,
            "changes": 82,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc?ref=bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4",
            "patch": "@@ -6904,6 +6904,88 @@ absl::Status AlgebraicSimplifierVisitor::HandleSlice(HloInstruction* slice) {\n     }\n   }\n \n+  // Simplify:\n+  //    Txx[...,1]   slice(Txx[..., K] reshape(Txx[...,N*K])) // N > 1\n+  // To:\n+  //    Txx[...,1] reshape(Txx[..., N]   slice(Txx[...,N*K], stride(-1)=K)\n+  //\n+  // Maintaining data-parallelism to improve throughput on some architectures.\n+  HloInstruction* reshape;\n+  if (Match(slice, m::Slice(m::Reshape(&reshape, m::Op())))) {\n+    HloInstruction* input = reshape->mutable_operand(0);\n+    const Shape& input_shape = input->shape();\n+    const Shape& reshape_shape = reshape->shape();\n+\n+    const int64_t input_rank = input_shape.dimensions().size();\n+    const int64_t reshape_rank = reshape_shape.dimensions().size();\n+    const int64_t slice_rank = slice->shape().dimensions().size();\n+\n+    // Reshape must have at least 2 dimensions and same number of\n+    // dimensions as slice.\n+    if (reshape_rank >= 2 && reshape_rank == slice_rank) {\n+      bool is_valid_reshape_slice = true;\n+      for (int64_t i = 0; i < slice_rank; ++i) {\n+        if (i == slice_rank - 1) {\n+          // Continue if we are slicing exactly one element from the last\n+          // dimension.\n+          if (slice->slice_limits()[i] - slice->slice_starts()[i] == 1 &&\n+              slice->slice_strides()[i] == 1) {\n+            continue;\n+          }\n+        } else {\n+          // Continue if we are not slicing any other dimension.\n+          if (slice->slice_starts()[i] == 0 &&\n+              slice->slice_limits()[i] == reshape_shape.dimensions(i) &&\n+              slice->slice_strides()[i] == 1) {\n+            continue;\n+          }\n+        }\n+        // If the rules above are not met, prevent a match.\n+        is_valid_reshape_slice = false;\n+        break;\n+      }\n+\n+      // Check if slice is selecting a single element from the last dimension.\n+      if (is_valid_reshape_slice) {\n+        int64_t slice_index = slice->slice_starts()[slice_rank - 1];\n+        int64_t K = reshape_shape.dimensions(reshape_rank - 1);\n+\n+        // Check if input shape can be viewed as [..., N*K], where N is two or\n+        // more, e.g. Input [1, 2024, 4, 128], Reshape [518144, 2].\n+        // Last dim of input 128 is multiple of 2.\n+        if (!input_shape.dimensions().empty()) {\n+          int64_t last_dim = input_shape.dimensions(input_rank - 1);\n+          if (last_dim % K == 0 && last_dim / K > 1 &&\n+              ShapeUtil::ElementsIn(reshape_shape) ==\n+                  ShapeUtil::ElementsIn(input_shape)) {\n+            // It matches!\n+            DimensionVector starts(input_rank, 0);\n+            DimensionVector limits(input_shape.dimensions().begin(),\n+                                   input_shape.dimensions().end());\n+            DimensionVector strides(input_rank, 1);\n+\n+            starts[input_rank - 1] = slice_index;\n+            limits[input_rank - 1] = last_dim;\n+            strides[input_rank - 1] = K;\n+\n+            Shape new_slice_shape = input_shape;\n+            new_slice_shape.set_dimensions(\n+                input_rank - 1, input_shape.dimensions(input_rank - 1) / K);\n+            simplifier_->UpdateLayout(&new_slice_shape);\n+\n+            HloInstruction* new_slice =\n+                slice->parent()->AddInstruction(HloInstruction::CreateSlice(\n+                    new_slice_shape, input, starts, limits, strides));\n+            HloInstruction* new_reshape = slice->parent()->AddInstruction(\n+                HloInstruction::CreateReshape(slice->shape(), new_slice));\n+\n+            return ReplaceInstruction(slice, new_reshape);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n   if (slice->operand(0)->opcode() == HloOpcode::kSlice &&\n       hlo_instruction_utils::IsUnstridedSlice(slice) &&\n       hlo_instruction_utils::IsUnstridedSlice(slice->operand(0))) {"
        },
        {
            "sha": "19951fdedca0a4fab88ed88b32d4c9ae47ec3628",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier_test.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc?ref=bf7be967d97ed6fa2cd778a4fe60e0493dfbedd4",
            "patch": "@@ -5299,6 +5299,72 @@ TEST_F(AlgebraicSimplifierTest, SliceOfSliceToSlice) {\n   EXPECT_EQ(computation->root_instruction()->slice_limits(1), dim1 - 4);\n }\n \n+TEST_F(AlgebraicSimplifierTest, SliceWithReshape) {\n+  const absl::string_view hlo_string = R\"hlo(\n+  HloModule SliceWithReshape\n+\n+  ENTRY main {\n+    %arg = f32[1,2024,4,128]{3,2,1,0} parameter(0)\n+    %reshape.1 = f32[2,259072,2]{2,1,0} reshape(%arg)\n+    %slice = f32[2,259072,1]{2,1,0} slice(%reshape.1), slice={[0:2], [0:259072], [1:2]}\n+    ROOT %reshape.2 = f32[518144]{0} reshape(%slice)\n+  }\n+)hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  ASSERT_TRUE(AlgebraicSimplifier(default_options_).Run(module.get()).value());\n+\n+  auto* root = module->entry_computation()->root_instruction();\n+  LOG(INFO) << module->ToString();\n+\n+  // Expected: Reshape(Slice(Arg))\n+  // AlgebraicSimplifier merges the two reshapes.\n+  ASSERT_EQ(root->opcode(), HloOpcode::kReshape);\n+  ASSERT_EQ(root->operand_count(), 1);\n+  ASSERT_EQ(root->operand(0)->opcode(), HloOpcode::kSlice);\n+  ASSERT_EQ(root->operand(0)->operand_count(), 1);\n+  ASSERT_EQ(root->operand(0)->operand(0)->opcode(), HloOpcode::kParameter);\n+\n+  auto* slice = root->operand(0);\n+  EXPECT_EQ(slice->slice_strides()[3], 2);\n+  EXPECT_EQ(slice->slice_starts()[3], 1);\n+  EXPECT_EQ(slice->slice_limits()[3], 128);\n+  EXPECT_EQ(slice->shape().dimensions(3), 64);\n+}\n+\n+TEST_F(AlgebraicSimplifierTest, SmallSliceWithReshape) {\n+  const absl::string_view hlo_string = R\"hlo(\n+  HloModule SliceWithReshape\n+\n+  ENTRY main {\n+    %arg = f32[2]{0} parameter(0)\n+    %reshape.1 = f32[2,1]{1,0} reshape(%arg)\n+    %slice = f32[1,1]{1,0} slice(%reshape.1), slice={[0:1], [0:1]}\n+    ROOT %reshape.2 = f32[1]{0} reshape(%slice)\n+  }\n+)hlo\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  ASSERT_TRUE(AlgebraicSimplifier(default_options_).Run(module.get()).value());\n+\n+  auto* root = module->entry_computation()->root_instruction();\n+  LOG(INFO) << module->ToString();\n+\n+  // Expected: Reshape(Slice(Arg))\n+  // AlgebraicSimplifier merges the two reshapes.\n+  ASSERT_EQ(root->opcode(), HloOpcode::kReshape);\n+  ASSERT_EQ(root->operand_count(), 1);\n+  ASSERT_EQ(root->operand(0)->opcode(), HloOpcode::kSlice);\n+  ASSERT_EQ(root->operand(0)->operand_count(), 1);\n+  ASSERT_EQ(root->operand(0)->operand(0)->opcode(), HloOpcode::kParameter);\n+\n+  auto* slice = root->operand(0);\n+  EXPECT_EQ(slice->slice_strides()[0], 1);\n+  EXPECT_EQ(slice->slice_starts()[0], 0);\n+  EXPECT_EQ(slice->slice_limits()[0], 1);\n+  EXPECT_EQ(slice->shape().dimensions(0), 1);\n+}\n+\n TEST_F(AlgebraicSimplifierTest, SliceOfBroadcastToBroadcast) {\n   HloComputation::Builder builder(TestName());\n   const int64_t dim0 = 11;"
        }
    ],
    "stats": {
        "total": 148,
        "additions": 148,
        "deletions": 0
    }
}