{
    "author": "loislo",
    "message": "[XLA:GPU] Refactor: Separate Checksum and FloatCheck pass logic in ThunkBufferDebugPass\n\nThis change refactors `ThunkBufferDebugPass::Run` to use distinct internal functions, `RunChecksumPassInternal` and `RunFloatCheckPassInternal`, for handling the Checksum and FloatChecker modes, respectively. This improves modularity by encapsulating the mode-specific logic. Helper functions `CreateDebugInitThunk` and `CreateBufferDebugDumpThunk` are introduced to create the common initialization and dump thunks.\n\nPiperOrigin-RevId: 830398035",
    "sha": "088b21c29e0fdc058835145776cd27d8adb12686",
    "files": [
        {
            "sha": "4b1b30c03df010db712f3ad5b88110b74a660ce8",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/088b21c29e0fdc058835145776cd27d8adb12686/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/088b21c29e0fdc058835145776cd27d8adb12686/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=088b21c29e0fdc058835145776cd27d8adb12686",
            "patch": "@@ -3005,6 +3005,7 @@ cc_library(\n         \":buffers_float_check_thunk\",\n         \":custom_call_thunk\",\n         \":sequential_thunk\",\n+        \":shaped_slice\",\n         \":thunk\",\n         \":thunk_id\",\n         \":thunk_pass_pipeline\",\n@@ -3020,6 +3021,7 @@ cc_library(\n         \"//xla/stream_executor:device_description\",\n         \"//xla/stream_executor:stream\",\n         \"//xla/stream_executor/gpu:buffer_debug_log\",\n+        \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:nullability\","
        },
        {
            "sha": "416c0e57d02381a10b47548c989d88f099754b35",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass.cc",
            "status": "modified",
            "additions": 117,
            "deletions": 53,
            "changes": 170,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/088b21c29e0fdc058835145776cd27d8adb12686/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/088b21c29e0fdc058835145776cd27d8adb12686/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc?ref=088b21c29e0fdc058835145776cd27d8adb12686",
            "patch": "@@ -39,6 +39,7 @@ limitations under the License.\n #include \"xla/backends/gpu/runtime/buffers_float_check_thunk.h\"\n #include \"xla/backends/gpu/runtime/custom_call_thunk.h\"\n #include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n+#include \"xla/backends/gpu/runtime/shaped_slice.h\"\n #include \"xla/backends/gpu/runtime/thunk.h\"\n #include \"xla/backends/gpu/runtime/thunk_id.h\"\n #include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n@@ -54,6 +55,7 @@ limitations under the License.\n #include \"xla/stream_executor/device_description.h\"\n #include \"xla/stream_executor/gpu/buffer_debug_log.h\"\n #include \"xla/stream_executor/stream.h\"\n+#include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -207,7 +209,7 @@ std::unique_ptr<Thunk> WrapWithFloatCheckThunk(\n // `metadata_store` is used to retrieve the metadata for the log entries.\n // The filename is derived from the HLO module name and the log dump path\n // configured in `debug_options`.\n-absl::Status DumpBufferDebugLog(\n+absl::Status DumpBufferDebugChecksumLog(\n     std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n     se::Stream* stream, const HloComputation* absl_nonnull hlo_computation,\n     xla::ffi::Buffer<U8> log_buffer) {\n@@ -350,90 +352,152 @@ ThunkFilter CreateThunkFilter(const DebugOptions& debug_options) {\n }\n \n XLA_FFI_DEFINE_HANDLER_SYMBOL(\n-    kDebugLogInitHandler,\n+    kBufferDebugChecksumLogInitHandler,\n     [](se::Stream* absl_nonnull stream, xla::ffi::Buffer<U8> log_buffer) {\n       return se::gpu::BufferDebugLog::CreateOnDevice<BufferDebugLogEntry>(\n                  *stream, log_buffer.device_memory())\n           .status();\n     },\n     xla::ffi::Ffi::Bind().Ctx<xla::ffi::Stream>().Arg<xla::ffi::Buffer<U8>>());\n \n-}  // namespace\n-\n-absl::StatusOr<bool> ThunkBufferDebugPass::Run(\n-    SequentialThunk* root_thunk, const DebugOptions& debug_options,\n-    const HloModule* absl_nullable hlo_module,\n-    const se::DeviceDescription& device_info,\n-    ThunkPassBufferAllocator& allocator) {\n-  VLOG(1) << \"ThunkBufferDebugPass running\";\n-  if (hlo_module == nullptr) {\n-    // We need the HLO module to dump the buffer debug log proto to a file. If\n-    // it's not available, there's no point in doing extra work.\n-    VLOG(1) << \"HLO module is null, skip buffer checksumming\";\n-    return false;\n-  }\n-\n-  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n-      std::make_shared<BufferDebugLogEntryMetadataStore>();\n-\n-  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n-                      allocator.NewEmptyAllocation(kLogSizeBytes));\n-  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n+absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateDebugInitThunk(\n+    BufferAllocation::Slice log_slice,\n+    const HloModule* absl_nonnull hlo_module) {\n   ShapedSlice shaped_log_slice{\n       /*slice=*/log_slice,\n-      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_alloc->size()}),\n+      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n   };\n \n   XLA_FFI_Handler_Bundle buffer_debug_init_bundle{};\n-  buffer_debug_init_bundle.execute = kDebugLogInitHandler;\n-  TF_ASSIGN_OR_RETURN(\n-      auto buffer_debug_init_thunk,\n-      CustomCallThunk::Create(\n-          Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_init\",\n-          buffer_debug_init_bundle, /*operands=*/{shaped_log_slice},\n-          /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation()));\n+  buffer_debug_init_bundle.execute = kBufferDebugChecksumLogInitHandler;\n+  return CustomCallThunk::Create(\n+      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_init\",\n+      buffer_debug_init_bundle, /*operands=*/{shaped_log_slice},\n+      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n+}\n+\n+absl::StatusOr<std::unique_ptr<CustomCallThunk>> CreateBufferDebugDumpThunk(\n+    std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store,\n+    BufferAllocation::Slice log_slice,\n+    const HloModule* absl_nonnull hlo_module) {\n+  ShapedSlice shaped_log_slice{\n+      /*slice=*/log_slice,\n+      /*shape=*/Shape(PrimitiveType::U8, /*dimensions=*/{log_slice.size()}),\n+  };\n \n   CustomCallThunk::OwnedHandlerBundle dump_bundle{};\n   dump_bundle.execute =\n       xla::ffi::Ffi::Bind()\n           .Ctx<xla::ffi::Stream>()\n           .Ctx<xla::ffi::CalledComputation>()\n           .Arg<xla::ffi::Buffer<U8>>()\n-          .To(absl::bind_front(DumpBufferDebugLog, metadata_store));\n-  TF_ASSIGN_OR_RETURN(auto buffer_debug_dump_thunk,\n-                      CustomCallThunk::Create(Thunk::ThunkInfo(),\n-                                              \"xla_gpu_buffer_debug_log_dump\",\n-                                              std::move(dump_bundle),\n-                                              /*operands=*/{shaped_log_slice},\n-                                              /*results=*/{}, /*attributes=*/{},\n-                                              hlo_module->entry_computation()));\n+          .To(absl::bind_front(DumpBufferDebugChecksumLog, metadata_store));\n+  return CustomCallThunk::Create(\n+      Thunk::ThunkInfo(), \"xla_gpu_buffer_debug_log_dump\",\n+      std::move(dump_bundle),\n+      /*operands=*/{shaped_log_slice},\n+      /*results=*/{}, /*attributes=*/{}, hlo_module->entry_computation());\n+}\n+\n+absl::Status RunChecksumPassInternal(SequentialThunk* root_thunk,\n+                                     const DebugOptions& debug_options,\n+                                     const HloModule* absl_nonnull hlo_module,\n+                                     ThunkPassBufferAllocator& allocator) {\n+  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n+      std::make_shared<BufferDebugLogEntryMetadataStore>();\n+\n+  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n+                      allocator.NewEmptyAllocation(kLogSizeBytes));\n+  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n+\n+  TF_ASSIGN_OR_RETURN(auto buffer_debug_init_thunk,\n+                      CreateDebugInitThunk(log_slice, hlo_module));\n+\n+  TF_ASSIGN_OR_RETURN(\n+      auto buffer_debug_dump_thunk,\n+      CreateBufferDebugDumpThunk(metadata_store, log_slice, hlo_module));\n \n   ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n   root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n     if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n       return thunk;\n     }\n-    switch (mode_) {\n-      case Mode::kChecksum:\n-        VLOG(1) << \"Wrapping with checksum thunk\";\n-        return WrapWithChecksumThunk(\n-            std::move(thunk), log_slice,\n-            /*predecessor_thunk=*/*buffer_debug_init_thunk,\n-            /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n-      case Mode::kFloatChecker:\n-        VLOG(1) << \"Wrapping with float check thunk\";\n-        return WrapWithFloatCheckThunk(\n-            std::move(thunk), log_slice,\n-            /*predecessor_thunk=*/*buffer_debug_init_thunk,\n-            /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n+    VLOG(1) << \"Wrapping with checksum thunk\";\n+    return WrapWithChecksumThunk(std::move(thunk), log_slice,\n+                                 /*predecessor_thunk=*/*buffer_debug_init_thunk,\n+                                 /*successor_thunk=*/*buffer_debug_dump_thunk,\n+                                 metadata_store);\n+  });\n+\n+  ThunkSequence& thunks = root_thunk->thunks();\n+  thunks.reserve(thunks.size() + 2);\n+  thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n+  thunks.push_back(std::move(buffer_debug_dump_thunk));\n+  return absl::OkStatus();\n+}\n+\n+absl::Status RunFloatCheckPassInternal(SequentialThunk* root_thunk,\n+                                       const DebugOptions& debug_options,\n+                                       const HloModule* absl_nonnull hlo_module,\n+                                       ThunkPassBufferAllocator& allocator) {\n+  std::shared_ptr<BufferDebugLogEntryMetadataStore> metadata_store =\n+      std::make_shared<BufferDebugLogEntryMetadataStore>();\n+\n+  TF_ASSIGN_OR_RETURN(BufferAllocation * log_alloc,\n+                      allocator.NewEmptyAllocation(kLogSizeBytes));\n+  BufferAllocation::Slice log_slice(log_alloc, 0, log_alloc->size());\n+\n+  TF_ASSIGN_OR_RETURN(auto buffer_debug_init_thunk,\n+                      CreateDebugInitThunk(log_slice, hlo_module));\n+\n+  TF_ASSIGN_OR_RETURN(\n+      auto buffer_debug_dump_thunk,\n+      CreateBufferDebugDumpThunk(metadata_store, log_slice, hlo_module));\n+\n+  ThunkFilter thunk_filter = CreateThunkFilter(debug_options);\n+  root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n+    if (thunk_filter(*thunk) == InstrumentAction::kSkip) {\n+      return thunk;\n     }\n-    return thunk;\n+    VLOG(1) << \"Wrapping with float check thunk\";\n+    return WrapWithFloatCheckThunk(\n+        std::move(thunk), log_slice,\n+        /*predecessor_thunk=*/*buffer_debug_init_thunk,\n+        /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n   });\n \n   ThunkSequence& thunks = root_thunk->thunks();\n   thunks.reserve(thunks.size() + 2);\n   thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n   thunks.push_back(std::move(buffer_debug_dump_thunk));\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace\n+\n+absl::StatusOr<bool> ThunkBufferDebugPass::Run(\n+    SequentialThunk* root_thunk, const DebugOptions& debug_options,\n+    const HloModule* absl_nullable hlo_module,\n+    const se::DeviceDescription& device_info,\n+    ThunkPassBufferAllocator& allocator) {\n+  VLOG(1) << \"ThunkBufferDebugPass running\";\n+  if (hlo_module == nullptr) {\n+    // We need the HLO module to dump the buffer debug log proto to a file. If\n+    // it's not available, there's no point in doing extra work.\n+    VLOG(1) << \"HLO module is null, skip buffer checksumming\";\n+    return false;\n+  }\n+\n+  switch (mode_) {\n+    case Mode::kChecksum:\n+      TF_RETURN_IF_ERROR(RunChecksumPassInternal(root_thunk, debug_options,\n+                                                 hlo_module, allocator));\n+      break;\n+    case Mode::kFloatChecker:\n+      TF_RETURN_IF_ERROR(RunFloatCheckPassInternal(root_thunk, debug_options,\n+                                                   hlo_module, allocator));\n+      break;\n+  }\n \n   return true;\n }"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 119,
        "deletions": 53
    }
}