{
    "author": "GleasonK",
    "message": "[Linalg] Add option to not implicitly capture scalars in StableHLO->Linalg\n\nPiperOrigin-RevId: 812253586",
    "sha": "bc3f18366fd8b42bc318c1225d2a0f6743e98d8e",
    "files": [
        {
            "sha": "4c7ccc90fb608a5218d8d935554854a7a65c276b",
            "filename": "third_party/xla/third_party/stablehlo/temporary.patch",
            "status": "modified",
            "additions": 311,
            "deletions": 0,
            "changes": 311,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bc3f18366fd8b42bc318c1225d2a0f6743e98d8e/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bc3f18366fd8b42bc318c1225d2a0f6743e98d8e/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fstablehlo%2Ftemporary.patch?ref=bc3f18366fd8b42bc318c1225d2a0f6743e98d8e",
            "patch": "@@ -9,6 +9,317 @@ diff --ruN a/stablehlo/BUILD.bazel b/stablehlo/BUILD.bazel\n          \":stablehlo_aggressive_simplification_inc_gen\",\n          \":stablehlo_ops\",\n          \":stablehlo_pass_inc_gen\",\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/tests/pointwise.mlir b/stablehlo/stablehlo/conversions/linalg/tests/pointwise.mlir\n+--- stablehlo/stablehlo/conversions/linalg/tests/pointwise.mlir\n++++ stablehlo/stablehlo/conversions/linalg/tests/pointwise.mlir\n+@@ -1,5 +1,6 @@\n+ // RUN: stablehlo-opt %s --stablehlo-legalize-to-linalg --split-input-file --canonicalize | FileCheck %s\n+ // RUN: stablehlo-opt %s --stablehlo-legalize-to-linalg=\"enable-primitive-ops=true\" --split-input-file --canonicalize | FileCheck %s --check-prefix=CHECK-PRIMITIVE\n++// RUN: stablehlo-opt %s --stablehlo-legalize-to-linalg=\"capture-scalar-inputs=false\" --split-input-file --canonicalize | FileCheck %s --check-prefix=CHECK-NO-CAPTURE\n+ \n+ // CHECK: #map = affine_map<(d0, d1) -> (d0, d1)>\n+ // CHECK-LABEL: func @float_add\n+@@ -534,6 +535,19 @@\n+   %0 = \"stablehlo.sign\"(%arg0) : (tensor<2x2xcomplex<f32>>)\n+                           -> tensor<2x2xcomplex<f32>>\n+   func.return %0 : tensor<2x2xcomplex<f32>>\n++}\n++\n++// -----\n++\n++// CHECK-LABEL: func @float_tan\n++// CHECK-PRIMITIVE-LABEL: func @float_tan\n++func.func @float_tan(%arg0: tensor<2x2xf32>) -> tensor<2x2xf32> {\n++  // CHECK: linalg.generic\n++  // CHECK: tan\n++  // CHECK-PRIMITIVE: linalg.map\n++  // CHECK-PRIMITIVE: tan\n++  %0 = \"stablehlo.tan\"(%arg0) : (tensor<2x2xf32>) -> tensor<2x2xf32>\n++  func.return %0 : tensor<2x2xf32>\n+ }\n+ \n+ // -----\n+@@ -926,6 +940,23 @@\n+ // CHECK-PRIMITIVE:      (%[[LHS_:.*]]: f32, %[[RHS_:.*]]: f32) {\n+ // CHECK-PRIMITIVE:        %[[RES:.*]] = arith.select %[[PRED_ELEM]], %[[LHS_]], %[[RHS_]] : f32\n+ // CHECK-PRIMITIVE:        linalg.yield %[[RES]]\n++\n++// CHECK-NO-CAPTURE:      #[[SCALAR_MAP:.*]] = affine_map<(d0, d1) -> ()>\n++// CHECK-NO-CAPTURE:      #[[ID_MAP:.*]] = affine_map<(d0, d1) -> (d0, d1)>\n++// CHECK-NO-CAPTURE:      func @select_scalar_pred_dyn\n++// CHECK-NO-CAPTURE-SAME:  (%[[PRED:.*]]: tensor<i1>, %[[LHS:.*]]: tensor<2x?xf32>, %[[RHS:.*]]: tensor<2x?xf32>)\n++// CHECK-NO-CAPTURE-DAG:  %[[C1:.*]] = arith.constant 1\n++// CHECK-NO-CAPTURE-DAG:  %[[DIM:.*]] =  tensor.dim %[[LHS]], %[[C1]]\n++// CHECK-NO-CAPTURE-DAG:  %[[DST:.*]] = tensor.empty(%[[DIM]])\n++// CHECK-NO-CAPTURE:      linalg.generic\n++// CHECK-NO-CAPTURE-SAME:   indexing_maps = [#[[SCALAR_MAP]], #[[ID_MAP]], #[[ID_MAP]], #[[ID_MAP]]]\n++// CHECK-NO-CAPTURE-SAME:   iterator_types = [\"parallel\", \"parallel\"]\n++// CHECK-NO-CAPTURE-SAME:   ins(%[[PRED]], %[[LHS]], %[[RHS]] : tensor<i1>, tensor<2x?xf32>, tensor<2x?xf32>)\n++// CHECK-NO-CAPTURE-SAME:   outs(%[[DST]] : tensor<2x?xf32>)\n++// CHECK-NO-CAPTURE-SAME:   {someattr}\n++// CHECK-NO-CAPTURE:      ^bb0(%[[PRED_:.*]]: i1, %[[LHS_:.*]]: f32, %[[RHS_:.*]]: f32, %{{.*}}: f32):\n++// CHECK-NO-CAPTURE:        %[[RES:.*]] = arith.select %[[PRED_]], %[[LHS_]], %[[RHS_]] : f32\n++// CHECK-NO-CAPTURE:        linalg.yield %[[RES]]\n+ \n+ // -----\n+ \n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/LegalizeToLinalgUtils.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/LegalizeToLinalgUtils.cpp\n+--- stablehlo/stablehlo/conversions/linalg/transforms/LegalizeToLinalgUtils.cpp\n++++ stablehlo/stablehlo/conversions/linalg/transforms/LegalizeToLinalgUtils.cpp\n+@@ -140,12 +140,11 @@\n+   // (any sign-op, or an integral abs-op).\n+   // TODO(peiming, ajcbik): these all can potentially be optimized by applying\n+   // value transform on sparse_tenosr.value memref\n+-  if (isa<mlir::stablehlo::SignOp>(op) || isa<mlir::stablehlo::NegOp>(op) ||\n++  if (isa<mlir::stablehlo::SignOp, mlir::stablehlo::NegOp,\n++          mlir::stablehlo::TanOp>(op) ||\n+       (isa<mlir::stablehlo::AbsOp>(op) && hasIntegralShapeType(op)) ||\n+-      isa<chlo::AsinOp>(op) || isa<chlo::AsinhOp>(op) ||\n+-      isa<chlo::AtanOp>(op) || isa<chlo::AtanhOp>(op) ||\n+-      isa<chlo::BesselI1eOp>(op) || isa<chlo::SinhOp>(op) ||\n+-      isa<chlo::TanOp>(op)) {\n++      isa<chlo::AsinOp, chlo::AsinhOp, chlo::AtanOp, chlo::AtanhOp,\n++          chlo::BesselI1eOp, chlo::SinhOp, chlo::TanOp>(op)) {\n+     if (!sparse_tensor::getSparseTensorEncoding(op->getResult(0).getType()) &&\n+         !sparse_tensor::getSparseTensorEncoding(op->getOperand(0).getType()))\n+       return Value();\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/MapStablehloToScalarOp.h b/stablehlo/stablehlo/conversions/linalg/transforms/MapStablehloToScalarOp.h\n+--- stablehlo/stablehlo/conversions/linalg/transforms/MapStablehloToScalarOp.h\n++++ stablehlo/stablehlo/conversions/linalg/transforms/MapStablehloToScalarOp.h\n+@@ -153,14 +153,11 @@\n+   using FOp = ::mlir::math::SinOp;\n+   using COp = ::mlir::complex::SinOp;\n+ };\n+-// FIXME(Jakub)\n+-/*\n+ template <>\n+ struct StablehloToScalarOp<stablehlo::TanOp> {\n+   using FOp = ::mlir::math::TanOp;\n+   using COp = ::mlir::complex::TanOp;\n+ };\n+-*/\n+ template <>\n+ struct StablehloToScalarOp<stablehlo::Atan2Op> {\n+   using FOp = ::mlir::math::Atan2Op;\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/Passes.td b/stablehlo/stablehlo/conversions/linalg/transforms/Passes.td\n+--- stablehlo/stablehlo/conversions/linalg/transforms/Passes.td\n++++ stablehlo/stablehlo/conversions/linalg/transforms/Passes.td\n+@@ -39,7 +39,11 @@\n+                  Option<\"enableSparseOps\", \"enable-sparse-ops\", \"bool\",\n+                         /*default=*/\"false\",\n+                         \"Lower to Sparse Tensor ops (sparse_tensor.concatenate)\"\n+-                        \"when possible, instead of linalg.generic\">];\n++                        \"when possible, instead of linalg.generic\">,\n++                 Option<\"captureScalarInputs\", \"capture-scalar-inputs\", \"bool\",\n++                        /*default=*/\"true\",\n++                        \"Capture scalar inputs in generic ops instead of\"\n++                        \"passing as tensor-scalar argument.\">];\n+ }\n+ \n+ #endif  // STABLEHLO_TO_LINALG_PASSES\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/Rewriters.h b/stablehlo/stablehlo/conversions/linalg/transforms/Rewriters.h\n+--- stablehlo/stablehlo/conversions/linalg/transforms/Rewriters.h\n++++ stablehlo/stablehlo/conversions/linalg/transforms/Rewriters.h\n+@@ -26,11 +26,12 @@\n+ //===----------------------------------------------------------------------===//\n+ \n+ /// Populates the patterns that convert from StableHLO to Linalg on tensors.\n+-void populateStablehloToLinalgConversionPatterns(MLIRContext *context,\n+-                                                 TypeConverter &typeConverter,\n+-                                                 RewritePatternSet *patterns,\n++void populateStablehloToLinalgConversionPatterns(MLIRContext* context,\n++                                                 TypeConverter& typeConverter,\n++                                                 RewritePatternSet* patterns,\n+                                                  bool enablePrimitiveOps,\n+-                                                 bool enableSparseOps);\n++                                                 bool enableSparseOps,\n++                                                 bool captureScalarInputs);\n+ \n+ //===----------------------------------------------------------------------===//\n+ // Fine-grained patterns used by the implementation.\n+@@ -39,8 +40,9 @@\n+ /// Populates the patterns that convert from elementwise StableHLO ops to Linalg\n+ /// on tensors.\n+ void populatePointwiseStablehloToLinalgConversionPatterns(\n+-    MLIRContext *context, TypeConverter &typeConverter,\n+-    RewritePatternSet *patterns, bool enablePrimitiveOps);\n++    MLIRContext* context, TypeConverter& typeConverter,\n++    RewritePatternSet* patterns, bool enablePrimitiveOps,\n++    bool captureScalarInputs);\n+ \n+ /// Populates the patterns that convert from convolution StableHLO ops to Linalg\n+ /// on tensors.\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/StablehloLegalizeToLinalg.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/StablehloLegalizeToLinalg.cpp\n+--- stablehlo/stablehlo/conversions/linalg/transforms/StablehloLegalizeToLinalg.cpp\n++++ stablehlo/stablehlo/conversions/linalg/transforms/StablehloLegalizeToLinalg.cpp\n+@@ -2634,7 +2634,8 @@\n+ \n+     RewritePatternSet patterns_(context);\n+     populateStablehloToLinalgConversionPatterns(\n+-        context, converter, &patterns_, enablePrimitiveOps, enableSparseOps);\n++        context, converter, &patterns_, enablePrimitiveOps, enableSparseOps,\n++        captureScalarInputs);\n+     patterns = std::move(patterns_);\n+ \n+     return success();\n+@@ -2657,7 +2658,8 @@\n+                                                  TypeConverter& typeConverter,\n+                                                  RewritePatternSet* patterns,\n+                                                  bool enablePrimitiveOps,\n+-                                                 bool enableSparseOps) {\n++                                                 bool enableSparseOps,\n++                                                 bool captureScalarInputs) {\n+   // clang-format off\n+   patterns->add<ConcatenateConverter>(typeConverter, context,\n+                                       enablePrimitiveOps);\n+@@ -2680,7 +2682,8 @@\n+       >(typeConverter, context);\n+ \n+   detail::populatePointwiseStablehloToLinalgConversionPatterns(\n+-      context, typeConverter, patterns, enablePrimitiveOps);\n++      context, typeConverter, patterns, enablePrimitiveOps,\n++      captureScalarInputs);\n+ \n+   if (enableSparseOps) {\n+     patterns->add<SparseConcatenateConverter>(typeConverter, context);\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/StablehloToArith.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/StablehloToArith.cpp\n+--- stablehlo/stablehlo/conversions/linalg/transforms/StablehloToArith.cpp\n++++ stablehlo/stablehlo/conversions/linalg/transforms/StablehloToArith.cpp\n+@@ -145,6 +145,7 @@\n+       ScalarHloToArithmeticPattern<mlir::stablehlo::SineOp>,\n+       ScalarHloToArithmeticPattern<mlir::stablehlo::SqrtOp>,\n+       ScalarHloToArithmeticPattern<mlir::stablehlo::SubtractOp>,\n++      ScalarHloToArithmeticPattern<mlir::stablehlo::TanOp>,\n+       ScalarHloToArithmeticPattern<mlir::stablehlo::TanhOp>,\n+       ScalarHloToArithmeticPattern<mlir::stablehlo::XorOp>>(typeConverter,\n+                                                             context, filterFn);\n+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgPointwise.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgPointwise.cpp\n+--- stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgPointwise.cpp\n++++ stablehlo/stablehlo/conversions/linalg/transforms/StablehloToLinalgPointwise.cpp\n+@@ -23,6 +23,7 @@\n+ \n+ #include \"llvm/ADT/STLExtras.h\"\n+ #include \"llvm/ADT/SmallVector.h\"\n++#include \"llvm/Support/Debug.h\"\n+ #include \"mlir/Dialect/Linalg/IR/Linalg.h\"\n+ #include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n+ #include \"mlir/IR/AffineMap.h\"\n+@@ -43,6 +44,8 @@\n+ #include \"stablehlo/conversions/linalg/transforms/Rewriters.h\"\n+ #include \"stablehlo/dialect/StablehloOps.h\"\n+ \n++#define DEBUG_TYPE \"stablehlo-conversions\"\n++\n+ namespace mlir::stablehlo {\n+ namespace {\n+ int64_t getRank(Value v) { return cast<ShapedType>(v.getType()).getRank(); }\n+@@ -142,6 +145,11 @@\n+ struct PointwiseToLinalgMapConverter : OpConversionPattern<OpTy> {\n+   using OpConversionPattern<OpTy>::OpConversionPattern;\n+   using OpAdaptor = typename OpTy::Adaptor;\n++\n++  PointwiseToLinalgMapConverter(TypeConverter& typeConverter,\n++                                MLIRContext* context, bool captureScalarInputs)\n++      : OpConversionPattern<OpTy>(typeConverter, context),\n++        captureScalarInputs(captureScalarInputs) {}\n+ \n+   virtual FailureOr<Operation *> createLinalgOp(\n+       OpTy &op, ConversionPatternRewriter &rewriter,\n+@@ -190,8 +198,11 @@\n+             rewriter, loc, cast<TypedValue<ShapedType>>(input),\n+             cast<ShapedType>(emptyTensor.getType())));\n+         scalarInputs.push_back(nullptr);\n++      } else if (captureScalarInputs) {\n++        scalarInputs.push_back(rewriter.create<tensor::ExtractOp>(loc, input));\n+       } else {\n+-        scalarInputs.push_back(rewriter.create<tensor::ExtractOp>(loc, input));\n++        mappedInputs.push_back(input);\n++        scalarInputs.push_back(nullptr);\n+       }\n+     }\n+ \n+@@ -202,6 +213,8 @@\n+     rewriter.replaceOp(op, (*mapOp)->getResults());\n+     return success();\n+   }\n++\n++  bool captureScalarInputs;\n+ };\n+ \n+ /// Converts a HLO operation to a linalg.generic op that contains the\n+@@ -211,12 +224,12 @@\n+   using PointwiseToLinalgMapConverter<OpTy>::PointwiseToLinalgMapConverter;\n+   using OpAdaptor = typename OpTy::Adaptor;\n+ \n+-  FailureOr<Operation *> createLinalgOp(OpTy &op,\n+-                                        ConversionPatternRewriter &rewriter,\n+-                                        ArrayRef<Value> mappedInputs,\n+-                                        ArrayRef<Value> scalarVals,\n+-                                        Value emptyTensor,\n+-                                        int64_t maxRank) const override {\n++  FailureOr<Operation*> createLinalgOp(OpTy& op,\n++                                       ConversionPatternRewriter& rewriter,\n++                                       ArrayRef<Value> mappedInputs,\n++                                       ArrayRef<Value> scalarVals,\n++                                       Value emptyTensor,\n++                                       int64_t maxRank) const override {\n+     // Create indexing maps.\n+     AffineMap scalarMap = AffineMap::get(maxRank, 0, rewriter.getContext());\n+     AffineMap idMap = rewriter.getMultiDimIdentityMap(maxRank);\n+@@ -225,10 +238,10 @@\n+       maps.push_back(isScalar(v) ? scalarMap : idMap);\n+     maps.push_back(idMap);\n+     bool failed = false;\n+-    Operation *linalgOp = rewriter.create<linalg::GenericOp>(\n++    Operation* linalgOp = rewriter.create<linalg::GenericOp>(\n+         op.getLoc(), emptyTensor.getType(), mappedInputs, emptyTensor, maps,\n+         getNParallelLoopsAttrs(maxRank),\n+-        [&](OpBuilder &nestedBuilder, Location /*nested_loc*/,\n++        [&](OpBuilder& nestedBuilder, Location /*nested_loc*/,\n+             ValueRange args) {\n+           Type innerResultTy = getElementTypeOrSelf(emptyTensor);\n+           auto argvec =\n+@@ -253,8 +266,9 @@\n+ \n+ namespace detail {\n+ void populatePointwiseStablehloToLinalgConversionPatterns(\n+-    MLIRContext *context, TypeConverter &typeConverter,\n+-    RewritePatternSet *patterns, bool enablePrimitiveOps) {\n++    MLIRContext* context, TypeConverter& typeConverter,\n++    RewritePatternSet* patterns, bool enablePrimitiveOps,\n++    bool captureScalarInputs) {\n+   if (enablePrimitiveOps) {\n+     patterns->add<\n+         PointwiseToLinalgMapConverter<mlir::stablehlo::AbsOp>,\n+@@ -301,12 +315,12 @@\n+         PointwiseToLinalgMapConverter<mlir::stablehlo::SineOp>,\n+         PointwiseToLinalgMapConverter<mlir::stablehlo::SqrtOp>,\n+         PointwiseToLinalgMapConverter<mlir::stablehlo::SubtractOp>,\n++        PointwiseToLinalgMapConverter<mlir::stablehlo::TanOp>,\n+         PointwiseToLinalgMapConverter<mlir::stablehlo::TanhOp>,\n+-        PointwiseToLinalgMapConverter<mlir::stablehlo::XorOp>>(typeConverter,\n+-                                                               context);\n++        PointwiseToLinalgMapConverter<mlir::stablehlo::XorOp>>(\n++        typeConverter, context, captureScalarInputs);\n+     return;\n+   }\n+-\n+   patterns\n+       ->add<PointwiseToLinalgConverter<mlir::stablehlo::AbsOp>,\n+             PointwiseToLinalgConverter<mlir::stablehlo::AddOp>,\n+@@ -352,9 +366,10 @@\n+             PointwiseToLinalgConverter<mlir::stablehlo::SineOp>,\n+             PointwiseToLinalgConverter<mlir::stablehlo::SqrtOp>,\n+             PointwiseToLinalgConverter<mlir::stablehlo::SubtractOp>,\n++            PointwiseToLinalgConverter<mlir::stablehlo::TanOp>,\n+             PointwiseToLinalgConverter<mlir::stablehlo::TanhOp>,\n+-            PointwiseToLinalgConverter<mlir::stablehlo::XorOp>>(typeConverter,\n+-                                                                context);\n++            PointwiseToLinalgConverter<mlir::stablehlo::XorOp>>(\n++          typeConverter, context, captureScalarInputs);\n+ }\n+ }  // namespace detail\n+ }  // namespace mlir::stablehlo\n diff --ruN a/stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir b/stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir\n --- stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir\n +++ stablehlo/stablehlo/conversions/tosa/tests/legalize_quant_ops_to_tosa_rescale.mlir"
        }
    ],
    "stats": {
        "total": 311,
        "additions": 311,
        "deletions": 0
    }
}