{
    "author": "mwhittaker",
    "message": "Added buildable copy of preemption.\n\nThis is part of an effort to make a copy of the coordination service used exclusively by JAX.\n\nPiperOrigin-RevId: 839946057",
    "sha": "905f6367736d22ff51647e9c58eac6c817fdddca",
    "files": [
        {
            "sha": "bdd4dff4e0eac1e1ea497b7e8876eb4a2010f38c",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/BUILD",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2FBUILD?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,98 @@\n+load(\"//xla:xla.default.bzl\", \"xla_cc_test\")\n+load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\")\n+load(\"//xla/tsl:tsl.default.bzl\", \"get_compatible_with_portable\")\n+load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_library\")\n+\n+package(\n+    # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n+    default_visibility = internal_visibility([\n+        \"//xla/tsl:internal\",\n+        \"//third_party/py/jax:__subpackages__\",\n+    ]),\n+    licenses = [\"notice\"],\n+)\n+\n+cc_library(\n+    name = \"preemption_notifier\",\n+    srcs = [\"preemption_notifier.cc\"],\n+    hdrs = [\"preemption_notifier.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    deps = [\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/time\",\n+        \"@local_tsl//tsl/platform:thread_annotations\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"preemption_notifier_test\",\n+    size = \"small\",\n+    srcs = [\"preemption_notifier_test.cc\"],\n+    deps = [\n+        \":preemption_notifier\",\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:status\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/time\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"preemption_sync_manager\",\n+    srcs = [\"preemption_sync_manager.cc\"],\n+    hdrs = [\"preemption_sync_manager.h\"],\n+    deps = [\n+        \":preemption_notifier\",\n+        \"//xla/pjrt/distributed/coordination:coordination_service_agent\",\n+        \"//xla/tsl/distributed_runtime:call_options\",\n+        \"//xla/tsl/lib/monitoring:gauge\",\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/protobuf:coordination_service_proto_cc\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/memory\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/time\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"preemption_sync_manager_test\",\n+    size = \"small\",\n+    srcs = [\"preemption_sync_manager_test.cc\"],\n+    deps = [\n+        \":preemption_notifier\",\n+        \":preemption_sync_manager\",\n+        \"//xla/pjrt/distributed/coordination:coordination_client\",\n+        \"//xla/pjrt/distributed/coordination:coordination_service\",\n+        \"//xla/pjrt/distributed/coordination:coordination_service_agent\",\n+        \"//xla/pjrt/distributed/coordination:grpc_coordination_client\",\n+        \"//xla/pjrt/distributed/coordination:grpc_coordination_service_impl\",\n+        \"//xla/tsl/distributed_runtime/rpc:async_service_interface\",\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/protobuf:coordination_config_proto_cc_impl\",\n+        \"@com_github_grpc_grpc//:grpc++\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/memory\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/time\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)"
        },
        {
            "sha": "548dce2179f8e30bdbe91771fec91118b08a6f11",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_notifier.cc",
            "status": "added",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.cc?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,123 @@\n+/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#include \"xla/pjrt/distributed/preemption/preemption_notifier.h\"\n+\n+#include <atomic>\n+#include <csignal>\n+#include <functional>\n+#include <memory>\n+#include <utility>\n+\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/synchronization/notification.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/tsl/platform/env.h\"\n+\n+namespace xla {\n+\n+namespace {\n+constexpr absl::Duration kListenInterval = absl::Seconds(1);\n+constexpr absl::Time kUnsetDeathTime = absl::InfinitePast();\n+static std::atomic_bool sigterm_received(false);\n+\n+class SigtermNotifier : public PreemptionNotifier {\n+ public:\n+  explicit SigtermNotifier(tsl::Env* env);\n+  ~SigtermNotifier() override {\n+    // Trigger shutdown logic in listener thread.\n+    shutdown_notification_.Notify();\n+  }\n+\n+ private:\n+  void StartListenerThread();\n+  absl::Notification shutdown_notification_;\n+  std::unique_ptr<tsl::Thread> preempt_listener_thread_;\n+};\n+\n+SigtermNotifier::SigtermNotifier(tsl::Env* env) : PreemptionNotifier(env) {\n+  sigterm_received.store(false);\n+  StartListenerThread();\n+  std::signal(SIGTERM, [](int signal) { sigterm_received.store(true); });\n+}\n+\n+void SigtermNotifier::StartListenerThread() {\n+  preempt_listener_thread_.reset(\n+      GetEnv()->StartThread({}, \"PreemptionNotifier_Listen\", [this]() {\n+        // Poll for SIGTERM receipt every kListenInterval.\n+        while (!sigterm_received.load()) {\n+          if (shutdown_notification_.WaitForNotificationWithTimeout(\n+                  kListenInterval)) {\n+            // Shutdown:\n+            // 1) Cancel any pending callbacks and blocking WillBePreemptedAt()\n+            // calls.\n+            NotifyRegisteredListeners(\n+                absl::CancelledError(\"Preemption notifier is being deleted.\"));\n+            // 2) Exit listener thread.\n+            return;\n+          }\n+        }\n+        const absl::Time death_time = absl::Now();\n+        LOG(WARNING) << \"SIGTERM caught at \" << death_time;\n+        // Notify registered listeners.\n+        NotifyRegisteredListeners(death_time);\n+      }));\n+}\n+\n+}  // namespace\n+\n+absl::StatusOr<absl::Time> PreemptionNotifier::WillBePreemptedAt() {\n+  absl::Notification n;\n+  absl::StatusOr<absl::Time> result;\n+  WillBePreemptedAtAsync(\n+      [&n, &result](absl::StatusOr<absl::Time> async_result) {\n+        result = async_result;\n+        n.Notify();\n+      });\n+  n.WaitForNotification();\n+  return result;\n+}\n+\n+void PreemptionNotifier::WillBePreemptedAtAsync(PreemptTimeCallback callback) {\n+  absl::MutexLock l(mu_);\n+  if (death_time_ == kUnsetDeathTime) {\n+    // Did not receive preemption notice yet.\n+    callbacks_.push_back(std::move(callback));\n+  } else {\n+    // Already received preemption notice, respond immediately.\n+    callback(death_time_);\n+  }\n+}\n+\n+void PreemptionNotifier::NotifyRegisteredListeners(\n+    absl::StatusOr<absl::Time> death_time) {\n+  absl::MutexLock l(mu_);\n+  if (death_time.ok()) {\n+    death_time_ = death_time.value();\n+  }\n+  for (const auto& callback : callbacks_) {\n+    callback(death_time);\n+  }\n+  callbacks_.clear();\n+}\n+\n+REGISTER_PREEMPTION_NOTIFIER(\n+    \"sigterm\", [](tsl::Env* env) -> std::unique_ptr<PreemptionNotifier> {\n+      return std::make_unique<SigtermNotifier>(env);\n+    });\n+}  // namespace xla"
        },
        {
            "sha": "b917309ca7394fde5d7f45fdc5ee2138c6810996",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_notifier.h",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.h?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,148 @@\n+/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#ifndef XLA_PJRT_DISTRIBUTED_PREEMPTION_PREEMPTION_NOTIFIER_H_\n+#define XLA_PJRT_DISTRIBUTED_PREEMPTION_PREEMPTION_NOTIFIER_H_\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"tsl/platform/thread_annotations.h\"\n+\n+namespace xla {\n+\n+// Static registration for preemption notifiers.\n+#define REGISTER_PREEMPTION_NOTIFIER(notifier_type_name, factory_fn)        \\\n+  REGISTER_PREEMPTION_NOTIFIER_UNIQ_HELPER(__COUNTER__, notifier_type_name, \\\n+                                           factory_fn)\n+#define REGISTER_PREEMPTION_NOTIFIER_UNIQ_HELPER(counter, notifier_type_name, \\\n+                                                 factory_fn)                  \\\n+  static bool static_preemption_notifier_##counter TF_ATTRIBUTE_UNUSED =      \\\n+      []() {                                                                  \\\n+        ::xla::PreemptionNotifier::RegisterPreemptionNotifier(                \\\n+            notifier_type_name, factory_fn);                                  \\\n+        return true;                                                          \\\n+      }()\n+\n+// Base class for listening and propagating task preemption notices.\n+//\n+// This class provides common mechanism to block on waiting for preemption\n+// signals, or register callbacks that will be triggered upon preemption.\n+//\n+// Example:\n+//\n+//    // Monitors the SIGTERM preemption signal\n+//    notifier = PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+//\n+//    // Register callback that will be invoked once preempted\n+//    notifier->WillBePreemptedAtAsync(\n+//      [](absl::StatusOr<absl::Time> status_or_time) {\n+//        if (status_or_time.ok()) {\n+//          LOG(INFO) << \"Preempted at time: \" << status_or_time.value();\n+//        } else {\n+//          LOG(ERROR) << \"Received error: \" << status_or_time.status();\n+//        }\n+//      });\n+//\n+//    // Block current thread until preemption\n+//    absl::Time preempt_time = notifier->WillBePreemptedAt().value();\n+//\n+// Users can extend this class to support custom preemption signals, by subclass\n+// `PreemptionNotifier` with a custom constructor, register its creator (factory\n+// function) with `REGISTER_PREEMPTION_NOTIFIER`. The custom constructor should\n+// set up the communication with the cluster scheduler, and invoke the\n+// `NotifyRegisteredListeners` method once a preemption signal is received.\n+// See `SigtermNotifier` as an example.\n+\n+class PreemptionNotifier {\n+ public:\n+  typedef std::function<void(absl::StatusOr<absl::Time>)> PreemptTimeCallback;\n+  using PreemptionNotifierFactory =\n+      std::function<std::unique_ptr<PreemptionNotifier>(tsl::Env* env)>;\n+\n+  explicit PreemptionNotifier(tsl::Env* env) : env_(env) {}\n+  virtual ~PreemptionNotifier() = default;\n+\n+  static void RegisterPreemptionNotifier(const std::string& notifier_type_name,\n+                                         PreemptionNotifierFactory factory_fn) {\n+    GetPreemptionNotifierFactories()->emplace(notifier_type_name,\n+                                              std::move(factory_fn));\n+  }\n+\n+  static std::unique_ptr<PreemptionNotifier> CreatePreemptionNotifier(\n+      const std::string& notifier_type, tsl::Env* env) {\n+    const auto* factories = GetPreemptionNotifierFactories();\n+    auto it = factories->find(notifier_type);\n+    if (it == factories->end()) {\n+      std::vector<std::string> registered_types;\n+      registered_types.reserve(factories->size());\n+      for (auto& kv : *factories) {\n+        registered_types.push_back(kv.first);\n+      }\n+      LOG(ERROR) << \"No preemption notifier factory found for notifier type \"\n+                 << notifier_type\n+                 << \". All registered preemption notifier types are: \"\n+                 << absl::StrJoin(registered_types, \", \")\n+                 << \". Make sure the library is loaded to the program.\";\n+      return nullptr;\n+    }\n+    return it->second(env);\n+  }\n+\n+  // This is a blocking call that returns a death time when preemption /\n+  // termination will occur once the listener receives the preemption\n+  // notification. If no death time is specified, absl::Now() is returned.\n+  // Returns error::Cancelled if UnregisterListeners() is called.\n+  absl::StatusOr<absl::Time> WillBePreemptedAt();\n+\n+  // Registers a callback that takes the death time as input once the listener\n+  // receives the preemption notification.\n+  // If no death time is specified, absl::Now() is specified as input.\n+  // Note: callback should be kept as simple and fast as possible (e.g. simply\n+  // retrieve result). It should not wait for work done by another callback, and\n+  // invoke ahy PreemptionNotifier method (e.g. Reset(), destructor).\n+  void WillBePreemptedAtAsync(PreemptTimeCallback callback);\n+\n+ protected:\n+  tsl::Env* GetEnv() { return env_; }\n+  // Invokes all pending callbacks upon receipt of preemption notice with death\n+  // time or errors (e.g. cancellation during shutdown).\n+  void NotifyRegisteredListeners(absl::StatusOr<absl::Time> death_time);\n+\n+ private:\n+  static std::unordered_map<std::string, PreemptionNotifierFactory>*\n+  GetPreemptionNotifierFactories() {\n+    static auto* preemption_notifier_factories =\n+        new std::unordered_map<std::string, PreemptionNotifierFactory>();\n+    return preemption_notifier_factories;\n+  }\n+\n+  tsl::Env* env_;  // Not owned.\n+  absl::Mutex mu_;\n+  absl::Time death_time_ TF_GUARDED_BY(mu_) = absl::InfinitePast();\n+  std::vector<PreemptTimeCallback> callbacks_ TF_GUARDED_BY(mu_);\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_PJRT_DISTRIBUTED_PREEMPTION_PREEMPTION_NOTIFIER_H_"
        },
        {
            "sha": "7bf8216b338ef593440bc850e533dcf0d305d824",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_notifier_test.cc",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier_test.cc?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,154 @@\n+/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#include \"xla/pjrt/distributed/preemption/preemption_notifier.h\"\n+\n+#include <csignal>\n+#include <functional>\n+#include <memory>\n+#include <utility>\n+\n+#include \"absl/synchronization/notification.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/status.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n+\n+namespace xla {\n+namespace {\n+\n+TEST(PreemptNotifierTest, WillBePreemptedAt) {\n+  auto env = tsl::Env::Default();\n+  std::unique_ptr<PreemptionNotifier> preempt_notifier =\n+      PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+  absl::Time start_time = absl::Now();\n+  env->SchedClosureAfter(/*micros=*/absl::ToInt64Microseconds(absl::Seconds(1)),\n+                         []() { std::raise(SIGTERM); });\n+\n+  // Preempt time should be current timestamp.\n+  absl::StatusOr<absl::Time> result = preempt_notifier->WillBePreemptedAt();\n+  TF_CHECK_OK(result.status());\n+  absl::Time preempt_time = result.value();\n+\n+  // Make sure that preempt time is approximately correct.\n+  absl::Duration time_diff = preempt_time - start_time;\n+  // Signal was raised 1 second after start time.\n+  EXPECT_GT(time_diff, absl::Seconds(1.0));\n+  // Listen to signal once per second, so we should catch within 2 seconds.\n+  EXPECT_LT(time_diff, absl::Seconds(3));\n+}\n+\n+TEST(PreemptNotifierTest,\n+     WillBePreemptedAt_AlreadyPreempted_ReturnsImmediately) {\n+  auto env = tsl::Env::Default();\n+  std::unique_ptr<PreemptionNotifier> preempt_notifier =\n+      PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+  absl::Time start_time = absl::Now();\n+  std::raise(SIGTERM);\n+  // Note: sleep for a while to ensure that (a) SIGTERM is fully handled and (b)\n+  // the correct death time is returned (time when signal is caught instead of\n+  // when WillBePreemptedAt() is called).\n+  env->SleepForMicroseconds(absl::ToInt64Microseconds(absl::Seconds(2)));\n+\n+  // Preempt time should be current timestamp.\n+  absl::StatusOr<absl::Time> result = preempt_notifier->WillBePreemptedAt();\n+  TF_CHECK_OK(result.status());\n+  absl::Time preempt_time = result.value();\n+\n+  // Make sure that preempt time is approximately correct.\n+  absl::Duration time_diff = preempt_time - start_time;\n+  // Signal was raised immediately after start time.\n+  EXPECT_GT(time_diff, absl::ZeroDuration());\n+  // Verify that preempt time is not set at the time of call (2 seconds after\n+  // signal was raised).\n+  EXPECT_LT(time_diff, absl::Seconds(2));\n+}\n+\n+TEST(PreemptNotifierTest, WillBePreemptedAtAsync_SameResultForAllCallbacks) {\n+  auto env = tsl::Env::Default();\n+  std::unique_ptr<PreemptionNotifier> preempt_notifier =\n+      PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+  env->SchedClosureAfter(/*micros=*/absl::ToInt64Microseconds(absl::Seconds(1)),\n+                         []() { std::raise(SIGTERM); });\n+\n+  // Preempt time should be current timestamp.\n+  absl::StatusOr<absl::Time> preempt_time;\n+  absl::StatusOr<absl::Time> preempt_time_2;\n+  absl::Notification n;\n+  absl::Notification n_2;\n+  preempt_notifier->WillBePreemptedAtAsync(\n+      [&preempt_time, &n](absl::StatusOr<absl::Time> result) {\n+        preempt_time = result;\n+        n.Notify();\n+      });\n+  preempt_notifier->WillBePreemptedAtAsync(\n+      [&preempt_time_2, &n_2](absl::StatusOr<absl::Time> result) {\n+        preempt_time_2 = result;\n+        n_2.Notify();\n+      });\n+  n.WaitForNotification();\n+  n_2.WaitForNotification();\n+\n+  TF_CHECK_OK(preempt_time.status());\n+  TF_CHECK_OK(preempt_time_2.status());\n+  // Make sure that the same preempt time is returned for both calls.\n+  EXPECT_EQ(preempt_time.value(), preempt_time_2.value());\n+}\n+\n+TEST(PreemptNotifierTest, Reset_TwoDifferentPreemptTimesRecorded) {\n+  auto env = tsl::Env::Default();\n+  std::unique_ptr<PreemptionNotifier> preempt_notifier =\n+      PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+\n+  // Raise first signal.\n+  std::raise(SIGTERM);\n+  absl::StatusOr<absl::Time> result = preempt_notifier->WillBePreemptedAt();\n+  TF_CHECK_OK(result.status());\n+  absl::Time preempt_time = result.value();\n+\n+  preempt_notifier =\n+      PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+\n+  // Raise second signal.\n+  std::raise(SIGTERM);\n+  absl::Time preempt_time_2 = preempt_notifier->WillBePreemptedAt().value();\n+\n+  // Verify that two different preempt times are recorded.\n+  EXPECT_NE(preempt_time, preempt_time_2);\n+}\n+\n+TEST(PreemptNotifierTest, DestructorCancelsPendingCalls) {\n+  auto env = tsl::Env::Default();\n+  std::unique_ptr<PreemptionNotifier> preempt_notifier =\n+      PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n+  absl::StatusOr<absl::Time> result;\n+  absl::Notification n;\n+  preempt_notifier->WillBePreemptedAtAsync(\n+      [&result, &n](absl::StatusOr<absl::Time> status_or_time) {\n+        result = status_or_time;\n+        n.Notify();\n+      });\n+\n+  // Invoke dtor.\n+  preempt_notifier = nullptr;\n+  n.WaitForNotification();\n+\n+  // Verify that pending callbacks are cancelled.\n+  EXPECT_TRUE(absl::IsCancelled(result.status()));\n+}\n+}  // namespace\n+}  // namespace xla"
        },
        {
            "sha": "b199eadcf5c11f238170bf7ce0a0d5a5bf852fef",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_sync_manager.cc",
            "status": "added",
            "additions": 327,
            "deletions": 0,
            "changes": 327,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager.cc?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,327 @@\n+/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#include \"xla/pjrt/distributed/preemption/preemption_sync_manager.h\"\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/memory/memory.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/numbers.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/synchronization/notification.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/pjrt/distributed/coordination/coordination_service_agent.h\"\n+#include \"xla/pjrt/distributed/preemption/preemption_notifier.h\"\n+#include \"xla/tsl/lib/monitoring/gauge.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/protobuf/coordination_service.pb.h\"\n+\n+namespace xla {\n+namespace {\n+using tensorflow::CoordinatedTask;\n+using tensorflow::KeyValueEntry;\n+\n+constexpr char kPreemptionNoticeKey[] = \"RECEIVED_PREEMPTION_NOTICE\";\n+constexpr char kPreemptionCounterDirKey[] = \"PREEMPTION_CURRENT_COUNTER/\";\n+constexpr char kPreemptionBarrier[] = \"PREEMPTION_SYNC_BARRIER\";\n+constexpr absl::Duration kPreemptionBarrierTimeout = absl::Minutes(3);\n+\n+auto* sync_usage_metric = tsl::monitoring::Gauge<bool, 0>::New(\n+    \"/coordination_service/preempt_manager/reached_sync_point_usage\",\n+    \"Records if preempt sync manager's ReachSyncPoint() was called at least \"\n+    \"once.\");\n+\n+auto* notified_metric = tsl::monitoring::Gauge<bool, 0>::New(\n+    \"/coordination_service/preempt_manager/notified\",\n+    \"Records receipt of preemption notification.\");\n+\n+auto* set_sync_point_metric = tsl::monitoring::Gauge<bool, 0>::New(\n+    \"/coordination_service/preempt_manager/set_sync_point\",\n+    \"Records that sync point is set.\");\n+\n+auto* reached_sync_point_metric = tsl::monitoring::Gauge<bool, 0>::New(\n+    \"/coordination_service/preempt_manager/reached_sync_point\",\n+    \"Records that sync point is reached.\");\n+\n+// Only start protocol if death time is within `kProtocolDuration`, so that we\n+// don't synchronize too early.\n+// TODO(b/230630494): Make this configurable so that users can extend this to\n+// accommodate higher checkpoint durations.\n+constexpr absl::Duration kProtocolDuration = absl::Minutes(15);\n+\n+}  // namespace\n+\n+absl::Status PreemptionSyncManager::Initialize(\n+    CoordinationServiceAgent* agent) {\n+  return Initialize(agent, \"sigterm\");\n+}\n+\n+absl::Status PreemptionSyncManager::Initialize(\n+    CoordinationServiceAgent* agent,\n+    const std::string& preemption_notifier_type) {\n+  TF_ASSIGN_OR_RETURN(tsl::Env * env, agent->GetEnv());\n+  return Initialize(agent, PreemptionNotifier::CreatePreemptionNotifier(\n+                               preemption_notifier_type, env));\n+}\n+\n+absl::Status PreemptionSyncManager::Initialize(\n+    CoordinationServiceAgent* agent,\n+    std::unique_ptr<PreemptionNotifier> notifier) {\n+  {\n+    absl::MutexLock l(mu_);\n+    CHECK(!shut_down_);\n+  }\n+\n+  TF_ASSIGN_OR_RETURN(tsl::Env * env, agent->GetEnv());\n+  env_ = env;\n+  agent_ = agent;\n+  preemption_notifier_ = std::move(notifier);\n+  TF_ASSIGN_OR_RETURN(CoordinatedTask own_task, agent->GetOwnTask());\n+  const std::string task_name =\n+      absl::StrCat(\"/job:\", own_task.job_name(), \"/task:\", own_task.task_id());\n+  current_call_counter_key_ = absl::StrCat(kPreemptionCounterDirKey, task_name);\n+\n+  /* Listen for preemption notice within this task, then notify coordination\n+   * service when death time is within kProtocolDuration.\n+   */\n+  preemption_notifier_->WillBePreemptedAtAsync(\n+      [agent = agent_, task_name](absl::StatusOr<absl::Time> death_time) {\n+        if (!death_time.ok()) {\n+          // The preemption notifier invokes callback with Cancelled error when\n+          // its being destructed.\n+          if (absl::IsCancelled(death_time.status())) {\n+            LOG(INFO) << \"Preemption sync protocol cancelled by notifier: \"\n+                      << death_time.status()\n+                      << \". This is expected during program shutdown.\";\n+          } else {\n+            LOG(ERROR) << \"Error from preemption notifier: \"\n+                       << death_time.status();\n+          }\n+          return;\n+        }\n+        notified_metric->GetCell()->Set(true);\n+        // Notify coordination service about preemption notice.\n+        const absl::Status s = agent->InsertKeyValue(\n+            kPreemptionNoticeKey, absl::FormatTime(*death_time));\n+        LOG(INFO) << \"Notified coordination service that this task will \"\n+                     \"be preempted at \"\n+                  << *death_time << \". absl::Status: \" << s;\n+      });\n+\n+  /* Listen for preemption notice (death time) from coordination service, which\n+   * triggers the sync protocol.\n+   */\n+  call_opts_ = agent_->GetKeyValueAsync(\n+      kPreemptionNoticeKey,\n+      [this, agent = agent_](absl::StatusOr<std::string> status_or_death_time) {\n+        if (absl::IsCancelled(status_or_death_time.status())) {\n+          // The agent cancels pending GetKeyValue RPCs because of shutdown,\n+          // so simply log and return.\n+          LOG(INFO) << \"Cancelled call to retrieve preemption notice. This is \"\n+                       \"expected upon program shutdown.\";\n+          return;\n+        }\n+        if (!status_or_death_time.ok()) {\n+          LOG(WARNING)\n+              << \"Failed to retrieve preemption notice from \"\n+                 \"coordination service: \"\n+              << status_or_death_time.status()\n+              << \". This is only expected if one of the tasks is unhealthy.\"\n+                 \" Check the logs for the actual root cause.\";\n+          // Notify other tasks to not wait at the barrier. Note:\n+          // CancelPreemptionBarrier() cannot be used because this may be\n+          // triggered after preemption sync manager has been destroyed.\n+          agent->CancelBarrierAsync(\n+              kPreemptionBarrier, [](const absl::Status& status) {\n+                if (!status.ok()) {\n+                  LOG(ERROR)\n+                      << \"Failed to cancel preemption barrier: \" << status;\n+                }\n+              });\n+          return;\n+        }\n+        std::string err;\n+        absl::Time death_time;\n+        if (absl::ParseTime(absl::RFC3339_full, *status_or_death_time,\n+                            &death_time, &err)) {\n+          LOG(INFO) << \"Received preemption notice with death_time \"\n+                    << death_time;\n+        } else {\n+          LOG(ERROR) << \"Unable to parse preemption notice's death time: \"\n+                     << err;\n+          CancelPreemptionBarrier();\n+          return;\n+        }\n+\n+        // Trigger protocol in a separate thread: compute max call counter.\n+        {\n+          absl::MutexLock l(mu_);\n+          if (shut_down_) {\n+            return;\n+          }\n+          sync_protocol_thread_ = absl::WrapUnique(env_->StartThread(\n+              {}, \"PreemptionSyncManager_SyncProtocol\",\n+              std::bind(&PreemptionSyncManager::ComputeSyncCallCounter, this,\n+                        death_time)));\n+        }\n+      });\n+\n+  return absl::OkStatus();\n+}\n+\n+void PreemptionSyncManager::Shutdown() {\n+  absl::MutexLock l(mu_);\n+  if (shut_down_) {\n+    LOG(INFO) << \"PreemptionSyncManager already shut down\";\n+    return;\n+  }\n+  shut_down_ = true;\n+\n+  LOG(INFO) << \"Shutting down PreemptionSyncManager...\";\n+  shutdown_.Notify();\n+  if (call_opts_) {\n+    call_opts_->StartCancel();\n+  }\n+  if (sync_protocol_thread_) {\n+    sync_protocol_thread_.reset();\n+  }\n+  LOG(INFO) << \"PreemptionSyncManager shut down.\";\n+}\n+\n+void PreemptionSyncManager::ComputeSyncCallCounter(absl::Time death_time) {\n+  // 1. If death time is in the distant future, sleep until there's\n+  // `kProtocolDuration` left until death time before we begin the protocol.\n+  const absl::Duration remaining_time = death_time - absl::Now();\n+  if (remaining_time > kProtocolDuration) {\n+    LOG(INFO) << \"Will begin preemption sync protocol in \" << remaining_time;\n+    const absl::Duration sleep_time = remaining_time - kProtocolDuration;\n+\n+    if (shutdown_.WaitForNotificationWithTimeout(sleep_time)) {\n+      // If shutdown is triggered midway, exit thread immediately.\n+      LOG(WARNING)\n+          << \"Shutdown is triggered before preemption sync protocol has begun.\";\n+      CancelPreemptionBarrier();\n+      return;\n+    }\n+  }\n+\n+  // 2. Send coordination service the task's current call counter. Hold the lock\n+  // to prevent updates to `call_counter_` until the protocol completes and this\n+  // function exits, implying that we have decided on a new\n+  // `preemption_sync_counter_` or the protocol failed. This ensures correctness\n+  // of the preemption sync protocol.\n+  absl::MutexLock l(mu_);\n+  const absl::Status notified_status = agent_->InsertKeyValue(\n+      current_call_counter_key_, std::to_string(call_counter_));\n+  if (!notified_status.ok()) {\n+    LOG(ERROR) << \"Preemption sync failed - could not inform service of \"\n+                  \"current call counter: \"\n+               << notified_status;\n+    CancelPreemptionBarrier();\n+    return;\n+  }\n+\n+  // 3. Impose a barrier to wait until everybody sends their current call\n+  // counter.\n+  const absl::Status barrier_status =\n+      agent_->WaitAtBarrier(kPreemptionBarrier, kPreemptionBarrierTimeout, {});\n+  if (!barrier_status.ok()) {\n+    LOG(ERROR) << \"Preemption sync barrier failed: \" << barrier_status;\n+    return;\n+  }\n+\n+  // 4. Retrieve every task's current call counter.\n+  absl::StatusOr<std::vector<KeyValueEntry>> all_counters =\n+      agent_->GetKeyValueDir(kPreemptionCounterDirKey);\n+  if (!all_counters.ok()) {\n+    LOG(ERROR) << \"Preemption sync failed - unable to retrieve call counters: \"\n+               << all_counters.status();\n+    return;\n+  }\n+\n+  // 5. Compute the fastest task's call counter.\n+  // Note: Each task should retrieve the same set of call counters and arrive at\n+  // the same maximum. We have to calculate this max within each task because\n+  // coordination service does not provide GetMaxKeyValue().\n+  int64_t max_counter = kPreemptionSyncUnsetCounter;\n+  for (const auto& kv : *all_counters) {\n+    int64_t call_counter;\n+    if (!absl::SimpleAtoi(kv.value(), &call_counter)) {\n+      LOG(ERROR) << \"Preemption sync failed - failed to parse preemption call \"\n+                    \"counter: \"\n+                 << kv.DebugString();\n+      return;\n+    }\n+    max_counter = std::max(max_counter, call_counter);\n+  }\n+\n+  if (max_counter == kPreemptionSyncUnsetCounter) {\n+    LOG(ERROR) << \"Preemption sync failed - no call counters found.\";\n+    return;\n+  }\n+\n+  // 6. Set sync point to be the next possible call counter of the fastest task.\n+  preemption_sync_counter_ = max_counter + 1;\n+  LOG(INFO) << \"Preemption sync counter is set: \" << preemption_sync_counter_;\n+  set_sync_point_metric->GetCell()->Set(true);\n+}\n+\n+void PreemptionSyncManager::CancelPreemptionBarrier() {\n+  agent_->CancelBarrierAsync(\n+      kPreemptionBarrier, [](const absl::Status& status) {\n+        if (!status.ok()) {\n+          LOG(ERROR) << \"Failed to cancel preemption barrier: \" << status;\n+        }\n+      });\n+}\n+\n+bool PreemptionSyncManager::ReachedSyncPoint(int step_counter) {\n+  // Record that this API was called at least once.\n+  sync_usage_metric->GetCell()->Set(true);\n+  // Note: if a preemption notice has been received and ComputeSyncCallCounter()\n+  // is ongoing , this method will be blocked until it acquires the lock. This\n+  // prevents updates to `call_counter_` while `preemption_sync_counter_` is\n+  // being computed, which ensures correctness of the preemption sync protocol.\n+  absl::MutexLock l(mu_);\n+  CHECK(!shut_down_);\n+  // Track current call.\n+  call_counter_ = step_counter;\n+  VLOG(3) << \"Current call counter: \" << call_counter_\n+          << \", Preemption sync point: \" << preemption_sync_counter_;\n+\n+  const bool reached_sync_point = preemption_sync_counter_ == call_counter_;\n+  if (reached_sync_point) {\n+    // Record that this job reached the sync point.\n+    reached_sync_point_metric->GetCell()->Set(true);\n+  }\n+  return reached_sync_point;\n+}\n+\n+std::unique_ptr<PreemptionSyncManager> CreatePreemptionSyncManager() {\n+  return std::make_unique<PreemptionSyncManager>();\n+}\n+}  // namespace xla"
        },
        {
            "sha": "3c2468e8dcc4f25116a9f282b3a504635446a6a4",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_sync_manager.h",
            "status": "added",
            "additions": 103,
            "deletions": 0,
            "changes": 103,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager.h?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,103 @@\n+/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#ifndef XLA_PJRT_DISTRIBUTED_PREEMPTION_PREEMPTION_SYNC_MANAGER_H_\n+#define XLA_PJRT_DISTRIBUTED_PREEMPTION_PREEMPTION_SYNC_MANAGER_H_\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"absl/synchronization/notification.h\"\n+#include \"absl/time/time.h\"\n+#include \"xla/pjrt/distributed/coordination/coordination_service_agent.h\"\n+#include \"xla/pjrt/distributed/preemption/preemption_notifier.h\"\n+#include \"xla/tsl/distributed_runtime/call_options.h\"\n+#include \"xla/tsl/platform/env.h\"\n+\n+namespace xla {\n+\n+// Enables multiple tasks to coordinate on a safe sync point if any of the tasks\n+// receive a preemption notice. Example: tasks agree on a safe checkpointing\n+// step after a preemption notice so that training can resume with minimal\n+// disruption after the preemption.\n+// Note: the sync point can only be set once whenever the first preemption\n+// occurs.\n+// TODO(b/230630494): Add Reset() to allow multiple sync points to be set.\n+class PreemptionSyncManager {\n+ public:\n+  PreemptionSyncManager() = default;\n+  ~PreemptionSyncManager() { Shutdown(); }\n+  absl::Status Initialize(CoordinationServiceAgent* agent);\n+  absl::Status Initialize(CoordinationServiceAgent* agent,\n+                          const std::string& preemption_notifier_type);\n+  absl::Status Initialize(CoordinationServiceAgent* agent,\n+                          std::unique_ptr<PreemptionNotifier> notifier);\n+\n+  // Shuts down the PreemptionSyncManager. Shutdown cannot be called\n+  // concurrently with other methods. After Shutdown is called, no other methods\n+  // should be called.\n+  void Shutdown();\n+\n+  // Check if the synchronized point has been reached. When a task has been\n+  // preempted, a safe sync point will be determined by using the fastest task's\n+  // next possible sync point, which is then propagated to all tasks via this\n+  // method.\n+  // Notes:\n+  // 1) This must be called during every possible sync point so that the library\n+  //    is aware of each task's progress.\n+  // 2) This assumes that each task begins from the same point.\n+  //    Internally, it updates a counter to track the last `step_counter` passed\n+  //    in as argument to record each task's current progress.\n+  // Example use case: this can be called during every training step for every\n+  // task. Once a preemption notice is received, all tasks will agree on a safe\n+  // step to pause training and handle the preemption (e.g. save checkpoint and\n+  // exit, or wait for preempted task to restart, then resume training).\n+  bool ReachedSyncPoint(int step_counter);\n+\n+ private:\n+  static constexpr int64_t kPreemptionSyncUnsetCounter = -1;\n+\n+  // Determine the sync point upon receipt of preemption notice (death time).\n+  void ComputeSyncCallCounter(absl::Time death_time);\n+  // Notify other tasks to not wait at the barrier if the sync protocol failed\n+  // midway.\n+  void CancelPreemptionBarrier();\n+\n+  absl::Mutex mu_;\n+  // Shutdown flag\n+  bool shut_down_ ABSL_GUARDED_BY(mu_) = false;\n+  // Tracks the last step_counter passed into ReachedSyncPoint();\n+  int64_t call_counter_ ABSL_GUARDED_BY(mu_) = 0;\n+  // If set, determines the sync point.\n+  int64_t preemption_sync_counter_ ABSL_GUARDED_BY(mu_) =\n+      kPreemptionSyncUnsetCounter;\n+  std::string current_call_counter_key_;\n+\n+  tsl::Env* env_;                    // Not owned;\n+  CoordinationServiceAgent* agent_;  // Not owned.\n+  absl::Notification shutdown_;\n+  std::unique_ptr<tsl::Thread> sync_protocol_thread_ ABSL_GUARDED_BY(mu_);\n+  std::unique_ptr<PreemptionNotifier> preemption_notifier_;\n+  std::shared_ptr<tsl::CallOptions> call_opts_;\n+};\n+\n+std::unique_ptr<PreemptionSyncManager> CreatePreemptionSyncManager();\n+\n+}  // namespace xla\n+\n+#endif  // XLA_PJRT_DISTRIBUTED_PREEMPTION_PREEMPTION_SYNC_MANAGER_H_"
        },
        {
            "sha": "6db1efa38497493342ddc41d64d420b5de45fdb0",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_sync_manager_test.cc",
            "status": "added",
            "additions": 313,
            "deletions": 0,
            "changes": 313,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/905f6367736d22ff51647e9c58eac6c817fdddca/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc?ref=905f6367736d22ff51647e9c58eac6c817fdddca",
            "patch": "@@ -0,0 +1,313 @@\n+/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#include \"xla/pjrt/distributed/preemption/preemption_sync_manager.h\"\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/memory/memory.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/time/clock.h\"\n+#include \"absl/time/time.h\"\n+#include \"grpcpp/server.h\"\n+#include \"grpcpp/server_builder.h\"\n+#include \"grpcpp/support/channel_arguments.h\"\n+#include \"xla/pjrt/distributed/coordination/coordination_client.h\"\n+#include \"xla/pjrt/distributed/coordination/coordination_service.h\"\n+#include \"xla/pjrt/distributed/coordination/coordination_service_agent.h\"\n+#include \"xla/pjrt/distributed/coordination/grpc_coordination_client.h\"\n+#include \"xla/pjrt/distributed/coordination/grpc_coordination_service_impl.h\"\n+#include \"xla/pjrt/distributed/preemption/preemption_notifier.h\"\n+#include \"xla/tsl/distributed_runtime/rpc/async_service_interface.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/test.h\"\n+#include \"xla/tsl/platform/threadpool.h\"\n+#include \"xla/tsl/protobuf/coordination_config.pb.h\"\n+\n+namespace xla {\n+namespace {\n+using tensorflow::CoordinatedJob;\n+using tensorflow::CoordinatedTask;\n+using tensorflow::CoordinationServiceConfig;\n+\n+constexpr char kJobName[] = \"test_worker\";\n+\n+// Send fake preemption notices at any time for testing.\n+class FakePreemptionNotifier : public PreemptionNotifier {\n+ public:\n+  FakePreemptionNotifier() : PreemptionNotifier(/*env=*/nullptr) {}\n+\n+  ~FakePreemptionNotifier() override {\n+    NotifyRegisteredListeners(\n+        absl::CancelledError(\"~FakePreemptionNotifier() was called.\"));\n+  }\n+\n+  void AnnounceDeath(absl::Time death_time) {\n+    LOG(WARNING) << \"Received preemption notice with death time: \"\n+                 << death_time;\n+    NotifyRegisteredListeners(death_time);\n+  }\n+};\n+\n+class PreemptionSyncManagerTest : public ::testing::Test {\n+ protected:\n+  PreemptionSyncManagerTest() {\n+    // Setup coordination service.\n+    StartCoordinationService();\n+    InitializeAndConnectCoordinationAgents();\n+\n+    // Create preempt sync manager for task 1.\n+    auto preempt_notifier = std::make_unique<FakePreemptionNotifier>();\n+    preempt_notifier_ = preempt_notifier.get();\n+    CHECK_OK(preempt_sync_mgr_->Initialize(coord_agent_.get(),\n+                                           std::move(preempt_notifier)));\n+\n+    // Create preempt sync manager for task 2.\n+    auto preempt_notifier2 = std::make_unique<FakePreemptionNotifier>();\n+    preempt_notifier2_ = preempt_notifier2.get();\n+    CHECK_OK(preempt_sync_mgr2_->Initialize(coord_agent2_.get(),\n+                                            std::move(preempt_notifier2)));\n+  }\n+  ~PreemptionSyncManagerTest() override {\n+    // Tear down coordination service objects in order.\n+    preempt_sync_mgr_ = nullptr;\n+    preempt_sync_mgr2_ = nullptr;\n+    coord_agent_ = nullptr;\n+    coord_agent2_ = nullptr;\n+    coord_service_ = nullptr;\n+    static_cast<GrpcCoordinationServiceImpl*>(coord_rpc_service_.get())\n+        ->SetCoordinationServiceInstance(nullptr);\n+    grpc_server_->Shutdown();\n+    coord_rpc_service_->Shutdown();\n+  }\n+\n+  // `to_task1` toggles which of the two tasks receives preemption notice.\n+  void SendPreemptionNotice(absl::Time death_time = absl::Now(),\n+                            bool to_task1 = true) {\n+    if (to_task1) {\n+      preempt_notifier_->AnnounceDeath(death_time);\n+    } else {\n+      preempt_notifier2_->AnnounceDeath(death_time);\n+    }\n+    // Block main thread for a short while to allow preemption sync manager to\n+    // process the notice.\n+    tsl::Env::Default()->SleepForMicroseconds(\n+        absl::ToInt64Microseconds(absl::Seconds(1)));\n+  }\n+\n+  // Report to coordination service that task two is unhealthy.\n+  void SimulateUnhealthyTaskTwo() {\n+    CoordinatedTask task2;\n+    task2.set_job_name(kJobName);\n+    task2.set_task_id(1);\n+    CHECK_OK(coord_service_->ReportTaskError(\n+        task2, absl::InternalError(\"test_error\")));\n+  }\n+\n+  // Allow access to objects under test.\n+  std::unique_ptr<PreemptionSyncManager> preempt_sync_mgr_ =\n+      CreatePreemptionSyncManager();\n+  std::unique_ptr<PreemptionSyncManager> preempt_sync_mgr2_ =\n+      CreatePreemptionSyncManager();\n+\n+ protected:\n+  // Utility methods to set up coordination service and agents.\n+  void StartCoordinationService() {\n+    ::grpc::ServerBuilder builder;\n+    coord_service_ = EnableCoordinationService();\n+    coord_compute_pool_ = std::make_unique<tsl::thread::ThreadPool>(\n+        tsl::Env::Default(), \"CoordinationServiceRpcHandler\",\n+        /*num_threads=*/1);\n+    coord_rpc_service_ = std::make_unique<GrpcCoordinationServiceImpl>(\n+        coord_compute_pool_.get(), &builder);\n+    auto* grpc_coord_service =\n+        static_cast<GrpcCoordinationServiceImpl*>(coord_rpc_service_.get());\n+    grpc_coord_service->SetCoordinationServiceInstance(coord_service_.get());\n+    grpc_server_ = builder.BuildAndStart();\n+    coord_rpc_thread_ = absl::WrapUnique(tsl::Env::Default()->StartThread(\n+        /*thread_options=*/{}, /*name=*/\"CoordinationServiceHandleRPCsLoop\",\n+        [service = coord_rpc_service_.get()]() { service->HandleRPCsLoop(); }));\n+  }\n+  std::unique_ptr<CoordinationService> EnableCoordinationService() {\n+    CoordinationServiceConfig config;\n+    config.set_service_type(\"standalone\");\n+    CoordinatedJob* job = config.mutable_coordinated_job_list()->Add();\n+    job->set_name(kJobName);\n+    job->set_num_tasks(2);\n+    return CoordinationService::Create(tsl::Env::Default(), config,\n+                                       /*cache=*/nullptr);\n+  }\n+  void InitializeAndConnectCoordinationAgents() {\n+    std::unique_ptr<CoordinationClient> coord_client =\n+        absl::WrapUnique(NewGrpcCoordinationClient(\n+            grpc_server_->InProcessChannel(::grpc::ChannelArguments())));\n+    std::unique_ptr<CoordinationClient> coord_client2 =\n+        absl::WrapUnique(NewGrpcCoordinationClient(\n+            grpc_server_->InProcessChannel(::grpc::ChannelArguments())));\n+    auto error_fn = [](const absl::Status& status) {\n+      LOG(ERROR) << \"Coordination service agent in error status: \" << status;\n+    };\n+    CoordinationServiceConfig coord_config;\n+    coord_config.set_service_leader(\"test_leader\");\n+    CHECK_OK(coord_agent_->Initialize(tsl::Env::Default(), kJobName,\n+                                      /*task_id=*/0, coord_config,\n+                                      std::move(coord_client), error_fn));\n+    CHECK_OK(coord_agent2_->Initialize(tsl::Env::Default(), kJobName,\n+                                       /*task_id=*/1, coord_config,\n+                                       std::move(coord_client2), error_fn));\n+    CHECK_OK(coord_agent_->Connect());\n+    CHECK_OK(coord_agent2_->Connect());\n+  }\n+\n+  // Coordination service.\n+  std::unique_ptr<CoordinationService> coord_service_;\n+  std::unique_ptr<::grpc::Server> grpc_server_;\n+  std::unique_ptr<tsl::thread::ThreadPool> coord_compute_pool_;\n+  std::unique_ptr<tsl::AsyncServiceInterface> coord_rpc_service_;\n+  std::unique_ptr<tsl::Thread> coord_rpc_thread_;\n+  // Owned by task 1.\n+  std::unique_ptr<CoordinationServiceAgent> coord_agent_ =\n+      CreateCoordinationServiceAgent();\n+  FakePreemptionNotifier* preempt_notifier_;\n+  // Owned by task 2.\n+  std::unique_ptr<CoordinationServiceAgent> coord_agent2_ =\n+      CreateCoordinationServiceAgent();\n+  FakePreemptionNotifier* preempt_notifier2_;\n+};\n+\n+/* Single task tests */\n+TEST_F(PreemptionSyncManagerTest, NoPreemption_NoSyncPoint) {\n+  int step_counter = 0;\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+}\n+\n+TEST_F(PreemptionSyncManagerTest, Preemption_SingleSyncPoint) {\n+  // Simulate task doing work and making progress.\n+  int step_counter = 0;\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  SendPreemptionNotice();\n+\n+  // Since this is the only task, sync point must be reached.\n+  EXPECT_TRUE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+\n+  // Now, we moved past the sync point.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+}\n+\n+TEST_F(PreemptionSyncManagerTest, DelayedPreemption_NoSyncPointYet) {\n+  int step_counter = 0;\n+  // Simulate task doing work and making progress.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  // Send notice about scheduled preemption in an hour.\n+  SendPreemptionNotice(absl::Now() + absl::Hours(1));\n+\n+  // Protocol didn't trigger yet, so there should be no sync point.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+}\n+\n+TEST_F(PreemptionSyncManagerTest, UnhealthyTask_NoSyncPoint) {\n+  int step_counter = 0;\n+  // Simulate task doing work and making progress.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  SimulateUnhealthyTaskTwo();\n+  SendPreemptionNotice();\n+\n+  // No sync point is created since one of the tasks is unhealthy.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+}\n+\n+TEST_F(PreemptionSyncManagerTest, ShutdownTasksWithoutPreemption) {\n+  int step_counter = 0;\n+  // Simulate task doing work and making progress.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+\n+  // Shutdown coordination service agents.\n+  CHECK_OK(coord_agent_->Shutdown());\n+  CHECK_OK(coord_agent2_->Shutdown());\n+  // Protocol is not triggered, so there should be no sync point.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter++));\n+}\n+\n+// Explicitly shut down without preemption.\n+TEST_F(PreemptionSyncManagerTest, ShutdownWithoutPreemption) {\n+  preempt_sync_mgr_->Shutdown();\n+}\n+\n+// Explicitly shut down without initialization.\n+TEST_F(PreemptionSyncManagerTest, ShutdownWithoutInitialization) {\n+  std::unique_ptr<PreemptionSyncManager> m = CreatePreemptionSyncManager();\n+  m->Shutdown();\n+}\n+\n+// Explicitly shut down with preemption.\n+TEST_F(PreemptionSyncManagerTest, ShutdownWithPreemption) {\n+  SendPreemptionNotice(absl::Now());\n+  preempt_sync_mgr_->Shutdown();\n+}\n+\n+/* Two task tests */\n+TEST_F(PreemptionSyncManagerTest, PreemptSlowTask) {\n+  int step_counter0 = 0;\n+  int step_counter2 = 0;\n+  // Simulate slow task 1 that is only at call #1.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+  // Simulate fast task 3 that is already at call #3.\n+  EXPECT_FALSE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+  EXPECT_FALSE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+  EXPECT_FALSE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+  SendPreemptionNotice();\n+\n+  // Sync point should be set at call #4.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+  EXPECT_TRUE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+\n+  // Task 2 was already at call #3, so the next call should be the sync point.\n+  EXPECT_TRUE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+}\n+\n+// Same as PreemptSlowTask, but we send the preemption notice to the faster\n+// task 2.\n+TEST_F(PreemptionSyncManagerTest, PreemptFastTask) {\n+  int step_counter0 = 0;\n+  int step_counter2 = 0;\n+  // Simulate slow task 1 that is only at call #1.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+  // Simulate fast task 3 that is already at call #3.\n+  EXPECT_FALSE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+  EXPECT_FALSE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+  EXPECT_FALSE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+  SendPreemptionNotice(absl::Now(), /*=to_task1=*/false);\n+\n+  // Sync point should be set at call #4.\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+  EXPECT_FALSE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+  EXPECT_TRUE(preempt_sync_mgr_->ReachedSyncPoint(step_counter0++));\n+\n+  // Task 2 was already at call #3, so the next call should be the sync point.\n+  EXPECT_TRUE(preempt_sync_mgr2_->ReachedSyncPoint(step_counter2++));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 1266,
        "additions": 1266,
        "deletions": 0
    }
}