{
    "author": "tensorflower-gardener",
    "message": "Integrate LLVM at llvm/llvm-project@b8649098a7fc\n\nUpdates LLVM usage to match\n[b8649098a7fc](https://github.com/llvm/llvm-project/commit/b8649098a7fc)\n\nPiperOrigin-RevId: 810400496",
    "sha": "afe5cb53474f1f1dc58315c0eb107b41f426345c",
    "files": [
        {
            "sha": "97b592d617f13522bdf2d70105d3b102334de0d2",
            "filename": "third_party/xla/third_party/llvm/generated.patch",
            "status": "modified",
            "additions": 169,
            "deletions": 520,
            "changes": 689,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fgenerated.patch?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -1,531 +1,180 @@\n Auto generated patch. Do not edit or delete it, even if empty.\n-diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CGExpr.cpp b/clang/lib/CodeGen/CGExpr.cpp\n---- a/clang/lib/CodeGen/CGExpr.cpp\n-+++ b/clang/lib/CodeGen/CGExpr.cpp\n-@@ -6496,11 +6496,8 @@\n-     SanitizerDebugLocation SanScope(this, {CheckOrdinal}, CheckHandler);\n-     EmitSanitizerStatReport(llvm::SanStat_CFI_ICall);\n- \n--    llvm::Metadata *MD;\n--    if (CGM.getCodeGenOpts().SanitizeCfiICallGeneralizePointers)\n--      MD = CGM.CreateMetadataIdentifierGeneralized(QualType(FnType, 0));\n--    else\n--      MD = CGM.CreateMetadataIdentifierForType(QualType(FnType, 0));\n-+    llvm::Metadata *MD =\n-+        CGM.CreateMetadataIdentifierForFnType(QualType(FnType, 0));\n- \n-     llvm::Value *TypeId = llvm::MetadataAsValue::get(getLLVMContext(), MD);\n- \n-diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CodeGenModule.cpp b/clang/lib/CodeGen/CodeGenModule.cpp\n---- a/clang/lib/CodeGen/CodeGenModule.cpp\n-+++ b/clang/lib/CodeGen/CodeGenModule.cpp\n-@@ -2339,12 +2339,28 @@\n-   return llvm::ConstantInt::get(Int64Ty, llvm::MD5Hash(MDS->getString()));\n- }\n- \n--// Generalize pointer types to a void pointer with the qualifiers of the\n--// originally pointed-to type, e.g. 'const char *' and 'char * const *'\n--// generalize to 'const void *' while 'char *' and 'const char **' generalize to\n--// 'void *'.\n--static QualType GeneralizeType(ASTContext &Ctx, QualType Ty) {\n--  if (!Ty->isPointerType())\n-+static QualType GeneralizeTransparentUnion(QualType Ty) {\n-+  const RecordType *UT = Ty->getAsUnionType();\n-+  if (!UT)\n-+    return Ty;\n-+  const RecordDecl *UD = UT->getOriginalDecl()->getDefinitionOrSelf();\n-+  if (!UD->hasAttr<TransparentUnionAttr>())\n-+    return Ty;\n-+  for (const auto *it : UD->fields()) {\n-+    return it->getType();\n-+  }\n-+  return Ty;\n-+}\n-+\n-+// If `GeneralizePointers` is true, generalizes types to a void pointer with the\n-+// qualifiers of the originally pointed-to type, e.g. 'const char *' and 'char *\n-+// const *' generalize to 'const void *' while 'char *' and 'const char **'\n-+// generalize to 'void *'.\n-+static QualType GeneralizeType(ASTContext &Ctx, QualType Ty,\n-+                               bool GeneralizePointers) {\n-+  Ty = GeneralizeTransparentUnion(Ty);\n-+\n-+  if (!GeneralizePointers || !Ty->isPointerType())\n-     return Ty;\n- \n-   return Ctx.getPointerType(\n-@@ -2353,26 +2369,29 @@\n- }\n- \n- // Apply type generalization to a FunctionType's return and argument types\n--static QualType GeneralizeFunctionType(ASTContext &Ctx, QualType Ty) {\n-+static QualType GeneralizeFunctionType(ASTContext &Ctx, QualType Ty,\n-+                                       bool GeneralizePointers) {\n-   if (auto *FnType = Ty->getAs<FunctionProtoType>()) {\n-     SmallVector<QualType, 8> GeneralizedParams;\n-     for (auto &Param : FnType->param_types())\n--      GeneralizedParams.push_back(GeneralizeType(Ctx, Param));\n-+      GeneralizedParams.push_back(\n-+          GeneralizeType(Ctx, Param, GeneralizePointers));\n- \n--    return Ctx.getFunctionType(GeneralizeType(Ctx, FnType->getReturnType()),\n--                               GeneralizedParams, FnType->getExtProtoInfo());\n-+    return Ctx.getFunctionType(\n-+        GeneralizeType(Ctx, FnType->getReturnType(), GeneralizePointers),\n-+        GeneralizedParams, FnType->getExtProtoInfo());\n-   }\n- \n-   if (auto *FnType = Ty->getAs<FunctionNoProtoType>())\n-     return Ctx.getFunctionNoProtoType(\n--        GeneralizeType(Ctx, FnType->getReturnType()));\n-+        GeneralizeType(Ctx, FnType->getReturnType(), GeneralizePointers));\n- \n-   llvm_unreachable(\"Encountered unknown FunctionType\");\n- }\n- \n- llvm::ConstantInt *CodeGenModule::CreateKCFITypeId(QualType T, StringRef Salt) {\n--  if (getCodeGenOpts().SanitizeCfiICallGeneralizePointers)\n--    T = GeneralizeFunctionType(getContext(), T);\n-+  T = GeneralizeFunctionType(\n-+      getContext(), T, getCodeGenOpts().SanitizeCfiICallGeneralizePointers);\n-   if (auto *FnType = T->getAs<FunctionProtoType>())\n-     T = getContext().getFunctionType(\n-         FnType->getReturnType(), FnType->getParamTypes(),\n-@@ -3041,9 +3060,14 @@\n-   if (isa<CXXMethodDecl>(FD) && !cast<CXXMethodDecl>(FD)->isStatic())\n-     return;\n- \n--  llvm::Metadata *MD = CreateMetadataIdentifierForType(FD->getType());\n-+  QualType FnType = GeneralizeFunctionType(getContext(), FD->getType(),\n-+                                           /*GeneralizePointers=*/false);\n-+  llvm::Metadata *MD = CreateMetadataIdentifierForType(FnType);\n-   F->addTypeMetadata(0, MD);\n--  F->addTypeMetadata(0, CreateMetadataIdentifierGeneralized(FD->getType()));\n-+\n-+  QualType GenPtrFnType = GeneralizeFunctionType(getContext(), FD->getType(),\n-+                                                 /*GeneralizePointers=*/true);\n-+  F->addTypeMetadata(0, CreateMetadataIdentifierGeneralized(GenPtrFnType));\n- \n-   // Emit a hash-based bit set entry for cross-DSO calls.\n-   if (CodeGenOpts.SanitizeCfiCrossDso)\n-@@ -7934,6 +7958,15 @@\n-   return InternalId;\n+diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCXXScopeSpec.cpp b/clang/lib/Sema/SemaCXXScopeSpec.cpp\n+--- a/clang/lib/Sema/SemaCXXScopeSpec.cpp\n++++ b/clang/lib/Sema/SemaCXXScopeSpec.cpp\n+@@ -220,10 +220,11 @@\n+ ///\n+ bool Sema::RequireCompleteEnumDecl(EnumDecl *EnumD, SourceLocation L,\n+                                    CXXScopeSpec *SS) {\n+-  if (EnumD->isCompleteDefinition()) {\n++  if (EnumDecl *Def = EnumD->getDefinition();\n++      Def && Def->isCompleteDefinition()) {\n+     // If we know about the definition but it is not visible, complain.\n+     NamedDecl *SuggestedDef = nullptr;\n+-    if (!hasReachableDefinition(EnumD, &SuggestedDef,\n++    if (!hasReachableDefinition(Def, &SuggestedDef,\n+                                 /*OnlyNeedComplete*/ false)) {\n+       // If the user is going to see an error here, recover by making the\n+       // definition visible.\n+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx20-using-enum.cpp b/clang/test/SemaCXX/cxx20-using-enum.cpp\n+--- a/clang/test/SemaCXX/cxx20-using-enum.cpp\n++++ b/clang/test/SemaCXX/cxx20-using-enum.cpp\n+@@ -288,4 +288,14 @@\n+   };\n+ };\n  }\n- \n-+llvm::Metadata *CodeGenModule::CreateMetadataIdentifierForFnType(QualType T) {\n-+  assert(isa<FunctionType>(T));\n-+  T = GeneralizeFunctionType(\n-+      getContext(), T, getCodeGenOpts().SanitizeCfiICallGeneralizePointers);\n-+  if (getCodeGenOpts().SanitizeCfiICallGeneralizePointers)\n-+    return CreateMetadataIdentifierGeneralized(T);\n-+  return CreateMetadataIdentifierForType(T);\n-+}\n-+\n- llvm::Metadata *CodeGenModule::CreateMetadataIdentifierForType(QualType T) {\n-   return CreateMetadataIdentifierImpl(T, MetadataIdMap, \"\");\n- }\n-@@ -7944,8 +7977,8 @@\n- }\n- \n- llvm::Metadata *CodeGenModule::CreateMetadataIdentifierGeneralized(QualType T) {\n--  return CreateMetadataIdentifierImpl(GeneralizeFunctionType(getContext(), T),\n--                                      GeneralizedMetadataIdMap, \".generalized\");\n-+  return CreateMetadataIdentifierImpl(T, GeneralizedMetadataIdMap,\n-+                                      \".generalized\");\n- }\n- \n- /// Returns whether this module needs the \"all-vtables\" type identifier.\n-diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CodeGenModule.h b/clang/lib/CodeGen/CodeGenModule.h\n---- a/clang/lib/CodeGen/CodeGenModule.h\n-+++ b/clang/lib/CodeGen/CodeGenModule.h\n-@@ -1623,6 +1623,9 @@\n-   /// Generate a KCFI type identifier for T.\n-   llvm::ConstantInt *CreateKCFITypeId(QualType T, StringRef Salt);\n- \n-+  /// Create a metadata identifier for the given function type.\n-+  llvm::Metadata *CreateMetadataIdentifierForFnType(QualType T);\n-+\n-   /// Create a metadata identifier for the given type. This may either be an\n-   /// MDString (for external identifiers) or a distinct unnamed MDNode (for\n-   /// internal identifiers).\n-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/cfi-icall-generalize.c b/clang/test/CodeGen/cfi-icall-generalize.c\n---- a/clang/test/CodeGen/cfi-icall-generalize.c\n-+++ b/clang/test/CodeGen/cfi-icall-generalize.c\n-@@ -15,5 +15,21 @@\n-   fp(0, 0);\n- }\n- \n-+union Union {\n-+  char *c;\n-+  long *n;\n-+} __attribute__((transparent_union));\n-+\n-+// CHECK: define{{.*}} void @uni({{.*}} !type [[TYPE2:![0-9]+]] !type [[TYPE2_GENERALIZED:![0-9]+]]\n-+void uni(void (*fn)(union Union), union Union arg1) {\n-+  // UNGENERALIZED: call i1 @llvm.type.test(ptr {{.*}}, metadata !\"_ZTSFvPcE\")\n-+  // GENERALIZED: call i1 @llvm.type.test(ptr {{.*}}, metadata !\"_ZTSFvPvE.generalized\")\n-+    fn(arg1);\n-+}\n-+\n- // CHECK: [[TYPE]] = !{i64 0, !\"_ZTSFPPiPKcPS2_E\"}\n- // CHECK: [[TYPE_GENERALIZED]] = !{i64 0, !\"_ZTSFPvPKvS_E.generalized\"}\n +\n-+// CHECK: [[TYPE2]] = !{i64 0, !\"_ZTSFvPFv5UnionEPcE\"}\n-+// CHECK: [[TYPE2_GENERALIZED]] = !{i64 0, !\"_ZTSFvPvS_E.generalized\"}\n-+\n-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/cfi-icall-normalize2.c b/clang/test/CodeGen/cfi-icall-normalize2.c\n---- a/clang/test/CodeGen/cfi-icall-normalize2.c\n-+++ b/clang/test/CodeGen/cfi-icall-normalize2.c\n-@@ -24,6 +24,20 @@\n-     fn(arg1, arg2, arg3);\n- }\n- \n-+union Union {\n-+  char *c;\n-+  long *n;\n-+} __attribute__((transparent_union));\n-+\n-+void uni(void (*fn)(union Union), union Union arg1) {\n-+    // CHECK-LABEL: define{{.*}}uni\n-+    // CHECK-SAME: {{.*}}!type ![[TYPE4:[0-9]+]] !type !{{[0-9]+}}\n-+    // CHECK: call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFvPu2i8E.normalized\")\n-+    fn(arg1);\n-+}\n-+\n- // CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvPFvu3i32ES_E.normalized\"}\n- // CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFvPFvu3i32S_ES_S_E.normalized\"}\n- // CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFvPFvu3i32S_S_ES_S_S_E.normalized\"}\n-+// CHECK: ![[TYPE4]] = !{i64 0, !\"_ZTSFvPFv5UnionEPu2i8E.normalized\"}\n-+\n-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/kcfi-generalize.c b/clang/test/CodeGen/kcfi-generalize.c\n---- a/clang/test/CodeGen/kcfi-generalize.c\n-+++ b/clang/test/CodeGen/kcfi-generalize.c\n-@@ -26,8 +26,23 @@\n-   fp(0, 0);\n- }\n- \n-+union Union {\n-+  char *c;\n-+  long *n;\n-+} __attribute__((transparent_union));\n-+\n-+// CHECK: define{{.*}} void @uni({{.*}} !kcfi_type [[TYPE4:![0-9]+]]\n-+void uni(void (*fn)(union Union), union Union arg1) {\n-+  // UNGENERALIZED: call {{.*}} [ \"kcfi\"(i32 -587217045) ]\n-+  // GENERALIZED: call {{.*}} [ \"kcfi\"(i32 2139530422) ]\n-+    fn(arg1);\n-+}\n-+\n- // UNGENERALIZED: [[TYPE]] = !{i32 1296635908}\n- // GENERALIZED: [[TYPE]] = !{i32 -49168686}\n- \n- // UNGENERALIZED: [[TYPE3]] = !{i32 874141567}\n- // GENERALIZED: [[TYPE3]] = !{i32 954385378}\n-+\n-+// UNGENERALIZED: [[TYPE4]] = !{i32 -1619636625}\n-+// GENERALIZED: [[TYPE4]] = !{i32 -125078496}\n-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/kcfi-normalize.c b/clang/test/CodeGen/kcfi-normalize.c\n---- a/clang/test/CodeGen/kcfi-normalize.c\n-+++ b/clang/test/CodeGen/kcfi-normalize.c\n-@@ -1,5 +1,5 @@\n--// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -o - %s | FileCheck %s\n--// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -x c++ -o - %s | FileCheck %s\n-+// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -o - %s | FileCheck %s --check-prefixes=CHECK,C\n-+// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -x c++ -o - %s | FileCheck %s --check-prefixes=CHECK,CPP\n- #if !__has_feature(kcfi)\n- #error Missing kcfi?\n++namespace Redecl {\n++  enum class A : int { X };\n++  enum class A : int;\n++  template <class> struct B {\n++    using enum A;\n++    using Z = decltype(X);\n++  };\n++  template struct B<int>;\n++} // namespace Redecl\n  #endif\n-@@ -28,7 +28,22 @@\n-     fn(arg1, arg2, arg3);\n+diff -ruN --strip-trailing-cr a/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp b/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp\n+--- a/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp\n++++ b/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp\n+@@ -69,6 +69,9 @@\n  }\n  \n-+union Union {\n-+  char *c;\n-+  long *n;\n-+} __attribute__((transparent_union));\n-+\n-+void uni(void (*fn)(union Union), union Union arg1) {\n-+    // CHECK-LABEL: define{{.*}}uni\n-+    // CHECK-SAME: {{.*}}!kcfi_type ![[TYPE4:[0-9]+]]\n-+    // C: call void %0(ptr %1) [ \"kcfi\"(i32 1819770848) ]\n-+    // CPP: call void %0(ptr %1) [ \"kcfi\"(i32 -1430221633) ]\n-+    fn(arg1);\n+ void TracePC::HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop) {\n++  if (Start == Stop) {\n++    return;\n++  }\n+   const PCTableEntry *B = reinterpret_cast<const PCTableEntry *>(Start);\n+   const PCTableEntry *E = reinterpret_cast<const PCTableEntry *>(Stop);\n+   if (NumPCTables && ModulePCTable[NumPCTables - 1].Start == B) return;\n+diff -ruN --strip-trailing-cr a/compiler-rt/test/fuzzer/empty-module.test b/compiler-rt/test/fuzzer/empty-module.test\n+--- a/compiler-rt/test/fuzzer/empty-module.test\n++++ b/compiler-rt/test/fuzzer/empty-module.test\n+@@ -0,0 +1,7 @@\n++CHECK: BINGO\n++RUN: %cpp_compiler %S/SimulateEmptyModuleTest.cpp -o %t-SimulateEmptyModuleTest\n++\n++RUN: not %run %t-SimulateEmptyModuleTest         2>&1 | FileCheck %s\n++\n++# only_ascii mode. Will perform some minimal self-validation.\n++RUN: not %run %t-SimulateEmptyModuleTest -only_ascii=1 2>&1\n+diff -ruN --strip-trailing-cr a/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp b/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp\n+--- a/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp\n++++ b/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp\n+@@ -0,0 +1,60 @@\n++// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n++// See https://llvm.org/LICENSE.txt for license information.\n++// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n++\n++// Like SimpleTest, but simulates an \"empty\" module (i.e. one without any functions to instrument).\n++// This reproduces a previous bug (when libFuzzer is compiled with assertions enabled).\n++\n++#include <assert.h>\n++#include <cstddef>\n++#include <cstdint>\n++#include <cstdlib>\n++#include <iostream>\n++#include <ostream>\n++\n++extern \"C\" {\n++void __sanitizer_cov_8bit_counters_init(uint8_t *Start, uint8_t *Stop);\n++void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg,\n++                              const uintptr_t *pcs_end);\n +}\n +\n- // CHECK: ![[#]] = !{i32 4, !\"cfi-normalize-integers\", i32 1}\n- // CHECK: ![[TYPE1]] = !{i32 -1143117868}\n- // CHECK: ![[TYPE2]] = !{i32 -460921415}\n- // CHECK: ![[TYPE3]] = !{i32 -333839615}\n-+// C: ![[TYPE4]] = !{i32 -650530463}\n-+// CPP: ![[TYPE4]] = !{i32 1766237188}\n-diff -ruN --strip-trailing-cr a/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp b/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp\n---- a/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp\n-+++ b/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp\n-@@ -952,7 +952,7 @@\n-         return status.ToError();\n-       thread_data.name.assign (prpsinfo.pr_fname, strnlen (prpsinfo.pr_fname, sizeof (prpsinfo.pr_fname)));\n-       SetID(prpsinfo.pr_pid);\n--      m_executable_name = prpsinfo.pr_fname;\n-+      m_executable_name = thread_data.name;\n-       break;\n-     }\n-     case ELF::NT_SIGINFO: {\n-diff -ruN --strip-trailing-cr a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp\n---- a/llvm/lib/Analysis/ScalarEvolution.cpp\n-+++ b/llvm/lib/Analysis/ScalarEvolution.cpp\n-@@ -3217,26 +3217,18 @@\n-       }\n- \n-       // Try to fold (C1 * D /u C2) -> C1/C2 * D, if C1 and C2 are powers-of-2,\n--      // D is a multiple of C2, and C1 is a multiple of C2. If C2 is a multiple\n--      // of C1, fold to (D /u (C2 /u C1)).\n-+      // D is a multiple of C2, and C1 is a multiple of C2.\n-       const SCEV *D;\n-       APInt C1V = LHSC->getAPInt();\n--      // (C1 * D /u C2) == -1 * -C1 * D /u C2 when C1 != INT_MIN. Don't treat -1\n--      // as -1 * 1, as it won't enable additional folds.\n--      if (C1V.isNegative() && !C1V.isMinSignedValue() && !C1V.isAllOnes())\n-+      // (C1 * D /u C2) == -1 * -C1 * D /u C2 when C1 != INT_MIN.\n-+      if (C1V.isNegative() && !C1V.isMinSignedValue())\n-         C1V = C1V.abs();\n-       const SCEVConstant *C2;\n-       if (C1V.isPowerOf2() &&\n-           match(Ops[1], m_scev_UDiv(m_SCEV(D), m_SCEVConstant(C2))) &&\n--          C2->getAPInt().isPowerOf2() &&\n-+          C2->getAPInt().isPowerOf2() && C1V.uge(C2->getAPInt()) &&\n-           C1V.logBase2() <= getMinTrailingZeros(D)) {\n--        const SCEV *NewMul;\n--        if (C1V.uge(C2->getAPInt())) {\n--          NewMul = getMulExpr(getUDivExpr(getConstant(C1V), C2), D);\n--        } else {\n--          assert(C1V.ugt(1) && \"C1 <= 1 should have been folded earlier\");\n--          NewMul = getUDivExpr(D, getUDivExpr(C2, getConstant(C1V)));\n--        }\n-+        const SCEV *NewMul = getMulExpr(getUDivExpr(getConstant(C1V), C2), D);\n-         return C1V == LHSC->getAPInt() ? NewMul : getNegativeSCEV(NewMul);\n-       }\n-     }\n-diff -ruN --strip-trailing-cr a/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll b/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll\n---- a/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll\n-+++ b/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll\n-@@ -21,7 +21,7 @@\n- ; CHECK-NEXT:    %gep.8 = getelementptr i8, ptr %A, i64 %iv\n- ; CHECK-NEXT:    --> {(((zext i32 %start to i64) /u 4) + %A),+,1}<%loop> U: full-set S: full-set Exits: (((zext i32 %start to i64) /u 2) + %A) LoopDispositions: { %loop: Computable }\n- ; CHECK-NEXT:    %gep.16 = getelementptr i16, ptr %A, i64 %iv\n--; CHECK-NEXT:    --> {(((zext i32 %start to i64) /u 2) + %A),+,2}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) + %A) LoopDispositions: { %loop: Computable }\n-+; CHECK-NEXT:    --> {((2 * ((zext i32 %start to i64) /u 4))<nuw><nsw> + %A),+,2}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) + %A) LoopDispositions: { %loop: Computable }\n- ; CHECK-NEXT:    %gep.32 = getelementptr i32, ptr %A, i64 %iv\n- ; CHECK-NEXT:    --> {((zext i32 %start to i64) + %A),+,4}<%loop> U: full-set S: full-set Exits: ((2 * (zext i32 %start to i64))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }\n- ; CHECK-NEXT:    %gep.40 = getelementptr <{ i32, i8 }>, ptr %A, i64 %iv\n-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll b/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll\n---- a/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll\n-+++ b/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll\n-@@ -18,7 +18,8 @@\n- ; CHECK:       [[FOR_BODY_PREHEADER_NEW]]:\n- ; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[MUL]], -4\n- ; CHECK-NEXT:    [[TMP4:%.*]] = add i64 [[UNROLL_ITER]], -4\n--; CHECK-NEXT:    [[TMP3:%.*]] = lshr i64 [[TMP4]], 1\n-+; CHECK-NEXT:    [[TMP5:%.*]] = lshr i64 [[TMP4]], 2\n-+; CHECK-NEXT:    [[TMP3:%.*]] = shl nuw nsw i64 [[TMP5]], 1\n- ; CHECK-NEXT:    [[LSR_IV_NEXT:%.*]] = sub i64 -3, [[TMP3]]\n- ; CHECK-NEXT:    br label %[[FOR_BODY:.*]]\n- ; CHECK:       [[FOR_BODY]]:\n-diff -ruN --strip-trailing-cr a/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll b/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll\n---- a/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll\n-+++ b/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll\n-@@ -26,36 +26,43 @@\n- \n- ; No value.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\"}' >> %t\n- ; RUN: not %{RUN} TOO-FEW\n- \n- ; i16 value.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i16 5}' >> %t\n- ; RUN: %{RUN} GOOD\n- \n- ; i32 value.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i32 5}' >> %t\n- ; RUN: %{RUN} GOOD\n- \n- ; i64 value.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i64 5}' >> %t\n- ; RUN: not %{RUN} BAD-VALUE\n- \n- ; MDString value.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", !\"5\"}' >> %t\n- ; RUN: not %{RUN} BAD-VALUE\n- \n- ; MDNode value.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", !2}' >> %t\n- ; RUN: echo '!2 = !{i32 5}' >> %t\n- ; RUN: not %{RUN} BAD-VALUE\n- \n- ; Too many values.\n- ; RUN: cp %s %t\n-+; RUN: chmod u+w %t\n- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i32 5, i32 5}' >> %t\n- ; RUN: not %{RUN} TOO-MANY\n-diff -ruN --strip-trailing-cr a/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h b/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h\n---- a/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h\n-+++ b/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h\n-@@ -264,7 +264,7 @@\n-   bool allowUnregisteredDialectsFlag = false;\n- \n-   /// Remark format\n--  RemarkFormat remarkFormatFlag;\n-+  RemarkFormat remarkFormatFlag = REMARK_FORMAT_STDOUT;\n-   /// Remark file to output to\n-   std::string remarksOutputFileFlag = \"\";\n-   /// Remark filters\n-diff -ruN --strip-trailing-cr a/mlir/lib/Bindings/Python/IRCore.cpp b/mlir/lib/Bindings/Python/IRCore.cpp\n---- a/mlir/lib/Bindings/Python/IRCore.cpp\n-+++ b/mlir/lib/Bindings/Python/IRCore.cpp\n-@@ -1079,23 +1079,38 @@\n- PyModule::PyModule(PyMlirContextRef contextRef, MlirModule module)\n-     : BaseContextObject(std::move(contextRef)), module(module) {}\n- \n--PyModule::~PyModule() { mlirModuleDestroy(module); }\n-+PyModule::~PyModule() {\n-+  nb::gil_scoped_acquire acquire;\n-+  auto &liveModules = getContext()->liveModules;\n-+  assert(liveModules.count(module.ptr) == 1 &&\n-+         \"destroying module not in live map\");\n-+  liveModules.erase(module.ptr);\n-+  mlirModuleDestroy(module);\n-+}\n- \n- PyModuleRef PyModule::forModule(MlirModule module) {\n-   MlirContext context = mlirModuleGetContext(module);\n-   PyMlirContextRef contextRef = PyMlirContext::forContext(context);\n- \n--  // Create.\n--  PyModule *unownedModule = new PyModule(std::move(contextRef), module);\n--  // Note that the default return value policy on cast is `automatic_reference`,\n--  // which means \"does not take ownership, does not call delete/dtor\".\n--  // We use `take_ownership`, which means \"Python will call the C++ destructor\n--  // and delete operator when the Python wrapper is garbage collected\", because\n--  // MlirModule actually wraps OwningOpRef<ModuleOp> (see mlirModuleCreateParse\n--  // etc).\n--  nb::object pyRef = nb::cast(unownedModule, nb::rv_policy::take_ownership);\n--  unownedModule->handle = pyRef;\n--  return PyModuleRef(unownedModule, std::move(pyRef));\n-+  nb::gil_scoped_acquire acquire;\n-+  auto &liveModules = contextRef->liveModules;\n-+  auto it = liveModules.find(module.ptr);\n-+  if (it == liveModules.end()) {\n-+    // Create.\n-+    PyModule *unownedModule = new PyModule(std::move(contextRef), module);\n-+    // Note that the default return value policy on cast is automatic_reference,\n-+    // which does not take ownership (delete will not be called).\n-+    // Just be explicit.\n-+    nb::object pyRef = nb::cast(unownedModule, nb::rv_policy::take_ownership);\n-+    unownedModule->handle = pyRef;\n-+    liveModules[module.ptr] =\n-+        std::make_pair(unownedModule->handle, unownedModule);\n-+    return PyModuleRef(unownedModule, std::move(pyRef));\n++void dummy_func() {}\n++\n++uint8_t empty_8bit_counters[0];\n++uintptr_t empty_pcs[0];\n++\n++uint8_t fake_8bit_counters[1] = {0};\n++uintptr_t fake_pcs[2] = {reinterpret_cast<uintptr_t>(&dummy_func),\n++                         reinterpret_cast<uintptr_t>(&dummy_func)};\n++\n++// Register two modules at program launch (same time they'd normally be registered).\n++// Triggering the bug requires loading an empty module, then a non-empty module after it.\n++bool dummy = []() {\n++  // First, simulate loading an empty module.\n++  __sanitizer_cov_8bit_counters_init(empty_8bit_counters, empty_8bit_counters);\n++  __sanitizer_cov_pcs_init(empty_pcs, empty_pcs);\n++\n++  // Next, simulate loading a non-empty module.\n++  __sanitizer_cov_8bit_counters_init(fake_8bit_counters,\n++                                     fake_8bit_counters + 1);\n++  __sanitizer_cov_pcs_init(fake_pcs, fake_pcs + 2);\n++\n++  return true;\n++}();\n++\n++static volatile int Sink;\n++\n++extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n++  assert(Data);\n++  if (Size > 0 && Data[0] == 'H') {\n++    Sink = 1;\n++    if (Size > 1 && Data[1] == 'i') {\n++      Sink = 2;\n++      if (Size > 2 && Data[2] == '!') {\n++        std::cout << \"BINGO; Found the target, exiting\\n\" << std::flush;\n++        exit(0);\n++      }\n++    }\n +  }\n-+  // Use existing.\n-+  PyModule *existing = it->second.second;\n-+  nb::object pyRef = nb::borrow<nb::object>(it->second.first);\n-+  return PyModuleRef(existing, std::move(pyRef));\n- }\n- \n- nb::object PyModule::createFromCapsule(nb::object capsule) {\n-@@ -2084,6 +2099,8 @@\n-   return PyInsertionPoint{block, std::move(nextOpRef)};\n- }\n- \n-+size_t PyMlirContext::getLiveModuleCount() { return liveModules.size(); }\n-+\n- nb::object PyInsertionPoint::contextEnter(nb::object insertPoint) {\n-   return PyThreadContextEntry::pushInsertionPoint(insertPoint);\n++  return 0;\n++}\n+diff -ruN --strip-trailing-cr a/llvm/lib/IR/Metadata.cpp b/llvm/lib/IR/Metadata.cpp\n+--- a/llvm/lib/IR/Metadata.cpp\n++++ b/llvm/lib/IR/Metadata.cpp\n+@@ -986,10 +986,15 @@\n  }\n-@@ -2923,6 +2940,7 @@\n-              PyMlirContextRef ref = PyMlirContext::forContext(self.get());\n-              return ref.releaseObject();\n-            })\n-+      .def(\"_get_live_module_count\", &PyMlirContext::getLiveModuleCount)\n-       .def_prop_ro(MLIR_PYTHON_CAPI_PTR_ATTR, &PyMlirContext::getCapsule)\n-       .def(MLIR_PYTHON_CAPI_FACTORY_ATTR, &PyMlirContext::createFromCapsule)\n-       .def(\"__enter__\", &PyMlirContext::contextEnter)\n-diff -ruN --strip-trailing-cr a/mlir/lib/Bindings/Python/IRModule.h b/mlir/lib/Bindings/Python/IRModule.h\n---- a/mlir/lib/Bindings/Python/IRModule.h\n-+++ b/mlir/lib/Bindings/Python/IRModule.h\n-@@ -218,6 +218,10 @@\n-   /// Gets the count of live context objects. Used for testing.\n-   static size_t getLiveCount();\n  \n-+  /// Gets the count of live modules associated with this context.\n-+  /// Used for testing.\n-+  size_t getLiveModuleCount();\n-+\n-   /// Enter and exit the context manager.\n-   static nanobind::object contextEnter(nanobind::object context);\n-   void contextExit(const nanobind::object &excType,\n-@@ -244,6 +248,14 @@\n-   static nanobind::ft_mutex live_contexts_mutex;\n-   static LiveContextMap &getLiveContexts();\n- \n-+  // Interns all live modules associated with this context. Modules tracked\n-+  // in this map are valid. When a module is invalidated, it is removed\n-+  // from this map, and while it still exists as an instance, any\n-+  // attempt to access it will raise an error.\n-+  using LiveModuleMap =\n-+      llvm::DenseMap<const void *, std::pair<nanobind::handle, PyModule *>>;\n-+  LiveModuleMap liveModules;\n-+\n-   bool emitErrorDiagnostics = false;\n- \n-   MlirContext context;\n-diff -ruN --strip-trailing-cr a/mlir/test/python/ir/module.py b/mlir/test/python/ir/module.py\n---- a/mlir/test/python/ir/module.py\n-+++ b/mlir/test/python/ir/module.py\n-@@ -121,6 +121,7 @@\n- def testModuleOperation():\n-     ctx = Context()\n-     module = Module.parse(r\"\"\"module @successfulParse {}\"\"\", ctx)\n-+    assert ctx._get_live_module_count() == 1\n-     op1 = module.operation\n-     # CHECK: module @successfulParse\n-     print(op1)\n-@@ -145,6 +146,7 @@\n-     op1 = None\n-     op2 = None\n-     gc.collect()\n-+    assert ctx._get_live_module_count() == 0\n- \n- \n- # CHECK-LABEL: TEST: testModuleCapsule\n-@@ -152,17 +154,17 @@\n- def testModuleCapsule():\n-     ctx = Context()\n-     module = Module.parse(r\"\"\"module @successfulParse {}\"\"\", ctx)\n-+    assert ctx._get_live_module_count() == 1\n-     # CHECK: \"mlir.ir.Module._CAPIPtr\"\n-     module_capsule = module._CAPIPtr\n-     print(module_capsule)\n-     module_dup = Module._CAPICreate(module_capsule)\n--    assert module is not module_dup\n-+    assert module is module_dup\n-     assert module == module_dup\n--    module._clear_mlir_module()\n--    assert module != module_dup\n-     assert module_dup.context is ctx\n-     # Gc and verify destructed.\n-     module = None\n-     module_capsule = None\n-     module_dup = None\n-     gc.collect()\n-+    assert ctx._get_live_module_count() == 0\n+ template <class NodeTy> struct MDNode::HasCachedHash {\n++  using Yes = char[1];\n++  using No = char[2];\n++  template <class U, U Val> struct SFINAE {};\n++\n+   template <class U>\n+-  using check = decltype(static_cast<void (U::*)(unsigned)>(&U::setHash));\n++  static Yes &check(SFINAE<void (U::*)(unsigned), &U::setHash> *);\n++  template <class U> static No &check(...);\n+ \n+-  static constexpr bool value = is_detected<check, NodeTy>::value;\n++  static const bool value = sizeof(check<NodeTy>(nullptr)) == sizeof(Yes);\n+ };\n+ \n+ MDNode *MDNode::uniquify() {\n+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n+--- a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n++++ b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n+@@ -796,18 +796,19 @@\n+       if (Count && !ProfcheckDisableMetadataFixes) {\n+         std::optional<llvm::Function::ProfileCount> MaybeCloneCount =\n+             Clone->getEntryCount();\n+-        assert(MaybeCloneCount && \"Clone entry count was not set!\");\n+-        uint64_t CallCount = *Count + MaybeCloneCount->getCount();\n+-        Clone->setEntryCount(CallCount);\n+-        if (std::optional<llvm::Function::ProfileCount> MaybeOriginalCount =\n+-                S.F->getEntryCount()) {\n+-          uint64_t OriginalCount = MaybeOriginalCount->getCount();\n+-          if (OriginalCount >= *Count) {\n+-            S.F->setEntryCount(OriginalCount - *Count);\n+-          } else {\n+-            // This should generally not happen as that would mean there are\n+-            // more computed calls to the function than what was recorded.\n+-            LLVM_DEBUG(S.F->setEntryCount(0));\n++        if (MaybeCloneCount) {\n++          uint64_t CallCount = *Count + MaybeCloneCount->getCount();\n++          Clone->setEntryCount(CallCount);\n++          if (std::optional<llvm::Function::ProfileCount> MaybeOriginalCount =\n++                  S.F->getEntryCount()) {\n++            uint64_t OriginalCount = MaybeOriginalCount->getCount();\n++            if (OriginalCount >= *Count) {\n++              S.F->setEntryCount(OriginalCount - *Count);\n++            } else {\n++              // This should generally not happen as that would mean there are\n++              // more computed calls to the function than what was recorded.\n++              LLVM_DEBUG(S.F->setEntryCount(0));\n++            }\n+           }\n+         }\n+       }"
        },
        {
            "sha": "08eb4742a4011f0214c84f6b1c3a024de4d73488",
            "filename": "third_party/xla/third_party/llvm/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fllvm%2Fworkspace.bzl?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n \n def repo(name):\n     \"\"\"Imports LLVM.\"\"\"\n-    LLVM_COMMIT = \"f3b712f6e4e9afed735962c6b96e0a2cadb03dc1\"\n-    LLVM_SHA256 = \"3c1a7a3156635a35e33da13a93a4dd8f2e48ac7280b5674061a951a4aa8475c3\"\n+    LLVM_COMMIT = \"b8649098a7fcf598406d8d8b7d68891d1444e9c8\"\n+    LLVM_SHA256 = \"18e365a1f849b6b66f0ae10810250be6c4a1de791e4892f9eaf900b8974b461b\"\n \n     tf_http_archive(\n         name = name,"
        },
        {
            "sha": "bff58ec81d49a411bc4953fb8d2ee94c26a48210",
            "filename": "third_party/xla/third_party/shardy/temporary.patch",
            "status": "modified",
            "additions": 720,
            "deletions": 0,
            "changes": 720,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Ftemporary.patch?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -0,0 +1,720 @@\n+diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch\n+index a7198bd..97b592d 100644\n+--- a/third_party/llvm/generated.patch\n++++ b/third_party/llvm/generated.patch\n+@@ -1,531 +1,180 @@\n+ Auto generated patch. Do not edit or delete it, even if empty.\n+-diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CGExpr.cpp b/clang/lib/CodeGen/CGExpr.cpp\n+---- a/clang/lib/CodeGen/CGExpr.cpp\n+-+++ b/clang/lib/CodeGen/CGExpr.cpp\n+-@@ -6496,11 +6496,8 @@\n+-     SanitizerDebugLocation SanScope(this, {CheckOrdinal}, CheckHandler);\n+-     EmitSanitizerStatReport(llvm::SanStat_CFI_ICall);\n+- \n+--    llvm::Metadata *MD;\n+--    if (CGM.getCodeGenOpts().SanitizeCfiICallGeneralizePointers)\n+--      MD = CGM.CreateMetadataIdentifierGeneralized(QualType(FnType, 0));\n+--    else\n+--      MD = CGM.CreateMetadataIdentifierForType(QualType(FnType, 0));\n+-+    llvm::Metadata *MD =\n+-+        CGM.CreateMetadataIdentifierForFnType(QualType(FnType, 0));\n+- \n+-     llvm::Value *TypeId = llvm::MetadataAsValue::get(getLLVMContext(), MD);\n+- \n+-diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CodeGenModule.cpp b/clang/lib/CodeGen/CodeGenModule.cpp\n+---- a/clang/lib/CodeGen/CodeGenModule.cpp\n+-+++ b/clang/lib/CodeGen/CodeGenModule.cpp\n+-@@ -2339,12 +2339,28 @@\n+-   return llvm::ConstantInt::get(Int64Ty, llvm::MD5Hash(MDS->getString()));\n+- }\n+- \n+--// Generalize pointer types to a void pointer with the qualifiers of the\n+--// originally pointed-to type, e.g. 'const char *' and 'char * const *'\n+--// generalize to 'const void *' while 'char *' and 'const char **' generalize to\n+--// 'void *'.\n+--static QualType GeneralizeType(ASTContext &Ctx, QualType Ty) {\n+--  if (!Ty->isPointerType())\n+-+static QualType GeneralizeTransparentUnion(QualType Ty) {\n+-+  const RecordType *UT = Ty->getAsUnionType();\n+-+  if (!UT)\n+-+    return Ty;\n+-+  const RecordDecl *UD = UT->getOriginalDecl()->getDefinitionOrSelf();\n+-+  if (!UD->hasAttr<TransparentUnionAttr>())\n+-+    return Ty;\n+-+  for (const auto *it : UD->fields()) {\n+-+    return it->getType();\n+-+  }\n+-+  return Ty;\n+-+}\n+-+\n+-+// If `GeneralizePointers` is true, generalizes types to a void pointer with the\n+-+// qualifiers of the originally pointed-to type, e.g. 'const char *' and 'char *\n+-+// const *' generalize to 'const void *' while 'char *' and 'const char **'\n+-+// generalize to 'void *'.\n+-+static QualType GeneralizeType(ASTContext &Ctx, QualType Ty,\n+-+                               bool GeneralizePointers) {\n+-+  Ty = GeneralizeTransparentUnion(Ty);\n+-+\n+-+  if (!GeneralizePointers || !Ty->isPointerType())\n+-     return Ty;\n+- \n+-   return Ctx.getPointerType(\n+-@@ -2353,26 +2369,29 @@\n+- }\n+- \n+- // Apply type generalization to a FunctionType's return and argument types\n+--static QualType GeneralizeFunctionType(ASTContext &Ctx, QualType Ty) {\n+-+static QualType GeneralizeFunctionType(ASTContext &Ctx, QualType Ty,\n+-+                                       bool GeneralizePointers) {\n+-   if (auto *FnType = Ty->getAs<FunctionProtoType>()) {\n+-     SmallVector<QualType, 8> GeneralizedParams;\n+-     for (auto &Param : FnType->param_types())\n+--      GeneralizedParams.push_back(GeneralizeType(Ctx, Param));\n+-+      GeneralizedParams.push_back(\n+-+          GeneralizeType(Ctx, Param, GeneralizePointers));\n+- \n+--    return Ctx.getFunctionType(GeneralizeType(Ctx, FnType->getReturnType()),\n+--                               GeneralizedParams, FnType->getExtProtoInfo());\n+-+    return Ctx.getFunctionType(\n+-+        GeneralizeType(Ctx, FnType->getReturnType(), GeneralizePointers),\n+-+        GeneralizedParams, FnType->getExtProtoInfo());\n+-   }\n+- \n+-   if (auto *FnType = Ty->getAs<FunctionNoProtoType>())\n+-     return Ctx.getFunctionNoProtoType(\n+--        GeneralizeType(Ctx, FnType->getReturnType()));\n+-+        GeneralizeType(Ctx, FnType->getReturnType(), GeneralizePointers));\n+- \n+-   llvm_unreachable(\"Encountered unknown FunctionType\");\n+- }\n+- \n+- llvm::ConstantInt *CodeGenModule::CreateKCFITypeId(QualType T, StringRef Salt) {\n+--  if (getCodeGenOpts().SanitizeCfiICallGeneralizePointers)\n+--    T = GeneralizeFunctionType(getContext(), T);\n+-+  T = GeneralizeFunctionType(\n+-+      getContext(), T, getCodeGenOpts().SanitizeCfiICallGeneralizePointers);\n+-   if (auto *FnType = T->getAs<FunctionProtoType>())\n+-     T = getContext().getFunctionType(\n+-         FnType->getReturnType(), FnType->getParamTypes(),\n+-@@ -3041,9 +3060,14 @@\n+-   if (isa<CXXMethodDecl>(FD) && !cast<CXXMethodDecl>(FD)->isStatic())\n+-     return;\n+- \n+--  llvm::Metadata *MD = CreateMetadataIdentifierForType(FD->getType());\n+-+  QualType FnType = GeneralizeFunctionType(getContext(), FD->getType(),\n+-+                                           /*GeneralizePointers=*/false);\n+-+  llvm::Metadata *MD = CreateMetadataIdentifierForType(FnType);\n+-   F->addTypeMetadata(0, MD);\n+--  F->addTypeMetadata(0, CreateMetadataIdentifierGeneralized(FD->getType()));\n+-+\n+-+  QualType GenPtrFnType = GeneralizeFunctionType(getContext(), FD->getType(),\n+-+                                                 /*GeneralizePointers=*/true);\n+-+  F->addTypeMetadata(0, CreateMetadataIdentifierGeneralized(GenPtrFnType));\n+- \n+-   // Emit a hash-based bit set entry for cross-DSO calls.\n+-   if (CodeGenOpts.SanitizeCfiCrossDso)\n+-@@ -7934,6 +7958,15 @@\n+-   return InternalId;\n++diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCXXScopeSpec.cpp b/clang/lib/Sema/SemaCXXScopeSpec.cpp\n++--- a/clang/lib/Sema/SemaCXXScopeSpec.cpp\n+++++ b/clang/lib/Sema/SemaCXXScopeSpec.cpp\n++@@ -220,10 +220,11 @@\n++ ///\n++ bool Sema::RequireCompleteEnumDecl(EnumDecl *EnumD, SourceLocation L,\n++                                    CXXScopeSpec *SS) {\n++-  if (EnumD->isCompleteDefinition()) {\n+++  if (EnumDecl *Def = EnumD->getDefinition();\n+++      Def && Def->isCompleteDefinition()) {\n++     // If we know about the definition but it is not visible, complain.\n++     NamedDecl *SuggestedDef = nullptr;\n++-    if (!hasReachableDefinition(EnumD, &SuggestedDef,\n+++    if (!hasReachableDefinition(Def, &SuggestedDef,\n++                                 /*OnlyNeedComplete*/ false)) {\n++       // If the user is going to see an error here, recover by making the\n++       // definition visible.\n++diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx20-using-enum.cpp b/clang/test/SemaCXX/cxx20-using-enum.cpp\n++--- a/clang/test/SemaCXX/cxx20-using-enum.cpp\n+++++ b/clang/test/SemaCXX/cxx20-using-enum.cpp\n++@@ -288,4 +288,14 @@\n++   };\n++ };\n+  }\n+- \n+-+llvm::Metadata *CodeGenModule::CreateMetadataIdentifierForFnType(QualType T) {\n+-+  assert(isa<FunctionType>(T));\n+-+  T = GeneralizeFunctionType(\n+-+      getContext(), T, getCodeGenOpts().SanitizeCfiICallGeneralizePointers);\n+-+  if (getCodeGenOpts().SanitizeCfiICallGeneralizePointers)\n+-+    return CreateMetadataIdentifierGeneralized(T);\n+-+  return CreateMetadataIdentifierForType(T);\n+-+}\n+-+\n+- llvm::Metadata *CodeGenModule::CreateMetadataIdentifierForType(QualType T) {\n+-   return CreateMetadataIdentifierImpl(T, MetadataIdMap, \"\");\n+- }\n+-@@ -7944,8 +7977,8 @@\n+- }\n+- \n+- llvm::Metadata *CodeGenModule::CreateMetadataIdentifierGeneralized(QualType T) {\n+--  return CreateMetadataIdentifierImpl(GeneralizeFunctionType(getContext(), T),\n+--                                      GeneralizedMetadataIdMap, \".generalized\");\n+-+  return CreateMetadataIdentifierImpl(T, GeneralizedMetadataIdMap,\n+-+                                      \".generalized\");\n+- }\n+- \n+- /// Returns whether this module needs the \"all-vtables\" type identifier.\n+-diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CodeGenModule.h b/clang/lib/CodeGen/CodeGenModule.h\n+---- a/clang/lib/CodeGen/CodeGenModule.h\n+-+++ b/clang/lib/CodeGen/CodeGenModule.h\n+-@@ -1623,6 +1623,9 @@\n+-   /// Generate a KCFI type identifier for T.\n+-   llvm::ConstantInt *CreateKCFITypeId(QualType T, StringRef Salt);\n+- \n+-+  /// Create a metadata identifier for the given function type.\n+-+  llvm::Metadata *CreateMetadataIdentifierForFnType(QualType T);\n+-+\n+-   /// Create a metadata identifier for the given type. This may either be an\n+-   /// MDString (for external identifiers) or a distinct unnamed MDNode (for\n+-   /// internal identifiers).\n+-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/cfi-icall-generalize.c b/clang/test/CodeGen/cfi-icall-generalize.c\n+---- a/clang/test/CodeGen/cfi-icall-generalize.c\n+-+++ b/clang/test/CodeGen/cfi-icall-generalize.c\n+-@@ -15,5 +15,21 @@\n+-   fp(0, 0);\n+- }\n+- \n+-+union Union {\n+-+  char *c;\n+-+  long *n;\n+-+} __attribute__((transparent_union));\n+-+\n+-+// CHECK: define{{.*}} void @uni({{.*}} !type [[TYPE2:![0-9]+]] !type [[TYPE2_GENERALIZED:![0-9]+]]\n+-+void uni(void (*fn)(union Union), union Union arg1) {\n+-+  // UNGENERALIZED: call i1 @llvm.type.test(ptr {{.*}}, metadata !\"_ZTSFvPcE\")\n+-+  // GENERALIZED: call i1 @llvm.type.test(ptr {{.*}}, metadata !\"_ZTSFvPvE.generalized\")\n+-+    fn(arg1);\n+-+}\n+-+\n+- // CHECK: [[TYPE]] = !{i64 0, !\"_ZTSFPPiPKcPS2_E\"}\n+- // CHECK: [[TYPE_GENERALIZED]] = !{i64 0, !\"_ZTSFPvPKvS_E.generalized\"}\n+ +\n+-+// CHECK: [[TYPE2]] = !{i64 0, !\"_ZTSFvPFv5UnionEPcE\"}\n+-+// CHECK: [[TYPE2_GENERALIZED]] = !{i64 0, !\"_ZTSFvPvS_E.generalized\"}\n+-+\n+-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/cfi-icall-normalize2.c b/clang/test/CodeGen/cfi-icall-normalize2.c\n+---- a/clang/test/CodeGen/cfi-icall-normalize2.c\n+-+++ b/clang/test/CodeGen/cfi-icall-normalize2.c\n+-@@ -24,6 +24,20 @@\n+-     fn(arg1, arg2, arg3);\n+- }\n+- \n+-+union Union {\n+-+  char *c;\n+-+  long *n;\n+-+} __attribute__((transparent_union));\n+-+\n+-+void uni(void (*fn)(union Union), union Union arg1) {\n+-+    // CHECK-LABEL: define{{.*}}uni\n+-+    // CHECK-SAME: {{.*}}!type ![[TYPE4:[0-9]+]] !type !{{[0-9]+}}\n+-+    // CHECK: call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFvPu2i8E.normalized\")\n+-+    fn(arg1);\n+-+}\n+-+\n+- // CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvPFvu3i32ES_E.normalized\"}\n+- // CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFvPFvu3i32S_ES_S_E.normalized\"}\n+- // CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFvPFvu3i32S_S_ES_S_S_E.normalized\"}\n+-+// CHECK: ![[TYPE4]] = !{i64 0, !\"_ZTSFvPFv5UnionEPu2i8E.normalized\"}\n+-+\n+-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/kcfi-generalize.c b/clang/test/CodeGen/kcfi-generalize.c\n+---- a/clang/test/CodeGen/kcfi-generalize.c\n+-+++ b/clang/test/CodeGen/kcfi-generalize.c\n+-@@ -26,8 +26,23 @@\n+-   fp(0, 0);\n+- }\n+- \n+-+union Union {\n+-+  char *c;\n+-+  long *n;\n+-+} __attribute__((transparent_union));\n+-+\n+-+// CHECK: define{{.*}} void @uni({{.*}} !kcfi_type [[TYPE4:![0-9]+]]\n+-+void uni(void (*fn)(union Union), union Union arg1) {\n+-+  // UNGENERALIZED: call {{.*}} [ \"kcfi\"(i32 -587217045) ]\n+-+  // GENERALIZED: call {{.*}} [ \"kcfi\"(i32 2139530422) ]\n+-+    fn(arg1);\n+-+}\n+-+\n+- // UNGENERALIZED: [[TYPE]] = !{i32 1296635908}\n+- // GENERALIZED: [[TYPE]] = !{i32 -49168686}\n+- \n+- // UNGENERALIZED: [[TYPE3]] = !{i32 874141567}\n+- // GENERALIZED: [[TYPE3]] = !{i32 954385378}\n+-+\n+-+// UNGENERALIZED: [[TYPE4]] = !{i32 -1619636625}\n+-+// GENERALIZED: [[TYPE4]] = !{i32 -125078496}\n+-diff -ruN --strip-trailing-cr a/clang/test/CodeGen/kcfi-normalize.c b/clang/test/CodeGen/kcfi-normalize.c\n+---- a/clang/test/CodeGen/kcfi-normalize.c\n+-+++ b/clang/test/CodeGen/kcfi-normalize.c\n+-@@ -1,5 +1,5 @@\n+--// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -o - %s | FileCheck %s\n+--// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -x c++ -o - %s | FileCheck %s\n+-+// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -o - %s | FileCheck %s --check-prefixes=CHECK,C\n+-+// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -emit-llvm -fsanitize=kcfi -fsanitize-cfi-icall-experimental-normalize-integers -x c++ -o - %s | FileCheck %s --check-prefixes=CHECK,CPP\n+- #if !__has_feature(kcfi)\n+- #error Missing kcfi?\n+++namespace Redecl {\n+++  enum class A : int { X };\n+++  enum class A : int;\n+++  template <class> struct B {\n+++    using enum A;\n+++    using Z = decltype(X);\n+++  };\n+++  template struct B<int>;\n+++} // namespace Redecl\n+  #endif\n+-@@ -28,7 +28,22 @@\n+-     fn(arg1, arg2, arg3);\n++diff -ruN --strip-trailing-cr a/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp b/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp\n++--- a/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp\n+++++ b/compiler-rt/lib/fuzzer/FuzzerTracePC.cpp\n++@@ -69,6 +69,9 @@\n+  }\n+  \n+-+union Union {\n+-+  char *c;\n+-+  long *n;\n+-+} __attribute__((transparent_union));\n+-+\n+-+void uni(void (*fn)(union Union), union Union arg1) {\n+-+    // CHECK-LABEL: define{{.*}}uni\n+-+    // CHECK-SAME: {{.*}}!kcfi_type ![[TYPE4:[0-9]+]]\n+-+    // C: call void %0(ptr %1) [ \"kcfi\"(i32 1819770848) ]\n+-+    // CPP: call void %0(ptr %1) [ \"kcfi\"(i32 -1430221633) ]\n+-+    fn(arg1);\n++ void TracePC::HandlePCsInit(const uintptr_t *Start, const uintptr_t *Stop) {\n+++  if (Start == Stop) {\n+++    return;\n+++  }\n++   const PCTableEntry *B = reinterpret_cast<const PCTableEntry *>(Start);\n++   const PCTableEntry *E = reinterpret_cast<const PCTableEntry *>(Stop);\n++   if (NumPCTables && ModulePCTable[NumPCTables - 1].Start == B) return;\n++diff -ruN --strip-trailing-cr a/compiler-rt/test/fuzzer/empty-module.test b/compiler-rt/test/fuzzer/empty-module.test\n++--- a/compiler-rt/test/fuzzer/empty-module.test\n+++++ b/compiler-rt/test/fuzzer/empty-module.test\n++@@ -0,0 +1,7 @@\n+++CHECK: BINGO\n+++RUN: %cpp_compiler %S/SimulateEmptyModuleTest.cpp -o %t-SimulateEmptyModuleTest\n+++\n+++RUN: not %run %t-SimulateEmptyModuleTest         2>&1 | FileCheck %s\n+++\n+++# only_ascii mode. Will perform some minimal self-validation.\n+++RUN: not %run %t-SimulateEmptyModuleTest -only_ascii=1 2>&1\n++diff -ruN --strip-trailing-cr a/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp b/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp\n++--- a/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp\n+++++ b/compiler-rt/test/fuzzer/SimulateEmptyModuleTest.cpp\n++@@ -0,0 +1,60 @@\n+++// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+++// See https://llvm.org/LICENSE.txt for license information.\n+++// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+++\n+++// Like SimpleTest, but simulates an \"empty\" module (i.e. one without any functions to instrument).\n+++// This reproduces a previous bug (when libFuzzer is compiled with assertions enabled).\n+++\n+++#include <assert.h>\n+++#include <cstddef>\n+++#include <cstdint>\n+++#include <cstdlib>\n+++#include <iostream>\n+++#include <ostream>\n+++\n+++extern \"C\" {\n+++void __sanitizer_cov_8bit_counters_init(uint8_t *Start, uint8_t *Stop);\n+++void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg,\n+++                              const uintptr_t *pcs_end);\n+ +}\n+ +\n+- // CHECK: ![[#]] = !{i32 4, !\"cfi-normalize-integers\", i32 1}\n+- // CHECK: ![[TYPE1]] = !{i32 -1143117868}\n+- // CHECK: ![[TYPE2]] = !{i32 -460921415}\n+- // CHECK: ![[TYPE3]] = !{i32 -333839615}\n+-+// C: ![[TYPE4]] = !{i32 -650530463}\n+-+// CPP: ![[TYPE4]] = !{i32 1766237188}\n+-diff -ruN --strip-trailing-cr a/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp b/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp\n+---- a/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp\n+-+++ b/lldb/source/Plugins/Process/elf-core/ProcessElfCore.cpp\n+-@@ -952,7 +952,7 @@\n+-         return status.ToError();\n+-       thread_data.name.assign (prpsinfo.pr_fname, strnlen (prpsinfo.pr_fname, sizeof (prpsinfo.pr_fname)));\n+-       SetID(prpsinfo.pr_pid);\n+--      m_executable_name = prpsinfo.pr_fname;\n+-+      m_executable_name = thread_data.name;\n+-       break;\n+-     }\n+-     case ELF::NT_SIGINFO: {\n+-diff -ruN --strip-trailing-cr a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp\n+---- a/llvm/lib/Analysis/ScalarEvolution.cpp\n+-+++ b/llvm/lib/Analysis/ScalarEvolution.cpp\n+-@@ -3217,26 +3217,18 @@\n+-       }\n+- \n+-       // Try to fold (C1 * D /u C2) -> C1/C2 * D, if C1 and C2 are powers-of-2,\n+--      // D is a multiple of C2, and C1 is a multiple of C2. If C2 is a multiple\n+--      // of C1, fold to (D /u (C2 /u C1)).\n+-+      // D is a multiple of C2, and C1 is a multiple of C2.\n+-       const SCEV *D;\n+-       APInt C1V = LHSC->getAPInt();\n+--      // (C1 * D /u C2) == -1 * -C1 * D /u C2 when C1 != INT_MIN. Don't treat -1\n+--      // as -1 * 1, as it won't enable additional folds.\n+--      if (C1V.isNegative() && !C1V.isMinSignedValue() && !C1V.isAllOnes())\n+-+      // (C1 * D /u C2) == -1 * -C1 * D /u C2 when C1 != INT_MIN.\n+-+      if (C1V.isNegative() && !C1V.isMinSignedValue())\n+-         C1V = C1V.abs();\n+-       const SCEVConstant *C2;\n+-       if (C1V.isPowerOf2() &&\n+-           match(Ops[1], m_scev_UDiv(m_SCEV(D), m_SCEVConstant(C2))) &&\n+--          C2->getAPInt().isPowerOf2() &&\n+-+          C2->getAPInt().isPowerOf2() && C1V.uge(C2->getAPInt()) &&\n+-           C1V.logBase2() <= getMinTrailingZeros(D)) {\n+--        const SCEV *NewMul;\n+--        if (C1V.uge(C2->getAPInt())) {\n+--          NewMul = getMulExpr(getUDivExpr(getConstant(C1V), C2), D);\n+--        } else {\n+--          assert(C1V.ugt(1) && \"C1 <= 1 should have been folded earlier\");\n+--          NewMul = getUDivExpr(D, getUDivExpr(C2, getConstant(C1V)));\n+--        }\n+-+        const SCEV *NewMul = getMulExpr(getUDivExpr(getConstant(C1V), C2), D);\n+-         return C1V == LHSC->getAPInt() ? NewMul : getNegativeSCEV(NewMul);\n+-       }\n+-     }\n+-diff -ruN --strip-trailing-cr a/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll b/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll\n+---- a/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll\n+-+++ b/llvm/test/Analysis/ScalarEvolution/mul-udiv-folds.ll\n+-@@ -21,7 +21,7 @@\n+- ; CHECK-NEXT:    %gep.8 = getelementptr i8, ptr %A, i64 %iv\n+- ; CHECK-NEXT:    --> {(((zext i32 %start to i64) /u 4) + %A),+,1}<%loop> U: full-set S: full-set Exits: (((zext i32 %start to i64) /u 2) + %A) LoopDispositions: { %loop: Computable }\n+- ; CHECK-NEXT:    %gep.16 = getelementptr i16, ptr %A, i64 %iv\n+--; CHECK-NEXT:    --> {(((zext i32 %start to i64) /u 2) + %A),+,2}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) + %A) LoopDispositions: { %loop: Computable }\n+-+; CHECK-NEXT:    --> {((2 * ((zext i32 %start to i64) /u 4))<nuw><nsw> + %A),+,2}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) + %A) LoopDispositions: { %loop: Computable }\n+- ; CHECK-NEXT:    %gep.32 = getelementptr i32, ptr %A, i64 %iv\n+- ; CHECK-NEXT:    --> {((zext i32 %start to i64) + %A),+,4}<%loop> U: full-set S: full-set Exits: ((2 * (zext i32 %start to i64))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }\n+- ; CHECK-NEXT:    %gep.40 = getelementptr <{ i32, i8 }>, ptr %A, i64 %iv\n+-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll b/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll\n+---- a/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll\n+-+++ b/llvm/test/Transforms/LoopStrengthReduce/duplicated-phis.ll\n+-@@ -18,7 +18,8 @@\n+- ; CHECK:       [[FOR_BODY_PREHEADER_NEW]]:\n+- ; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[MUL]], -4\n+- ; CHECK-NEXT:    [[TMP4:%.*]] = add i64 [[UNROLL_ITER]], -4\n+--; CHECK-NEXT:    [[TMP3:%.*]] = lshr i64 [[TMP4]], 1\n+-+; CHECK-NEXT:    [[TMP5:%.*]] = lshr i64 [[TMP4]], 2\n+-+; CHECK-NEXT:    [[TMP3:%.*]] = shl nuw nsw i64 [[TMP5]], 1\n+- ; CHECK-NEXT:    [[LSR_IV_NEXT:%.*]] = sub i64 -3, [[TMP3]]\n+- ; CHECK-NEXT:    br label %[[FOR_BODY:.*]]\n+- ; CHECK:       [[FOR_BODY]]:\n+-diff -ruN --strip-trailing-cr a/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll b/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll\n+---- a/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll\n+-+++ b/llvm/test/Verifier/llvm.loop.estimated_trip_count.ll\n+-@@ -26,36 +26,43 @@\n+- \n+- ; No value.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\"}' >> %t\n+- ; RUN: not %{RUN} TOO-FEW\n+- \n+- ; i16 value.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i16 5}' >> %t\n+- ; RUN: %{RUN} GOOD\n+- \n+- ; i32 value.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i32 5}' >> %t\n+- ; RUN: %{RUN} GOOD\n+- \n+- ; i64 value.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i64 5}' >> %t\n+- ; RUN: not %{RUN} BAD-VALUE\n+- \n+- ; MDString value.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", !\"5\"}' >> %t\n+- ; RUN: not %{RUN} BAD-VALUE\n+- \n+- ; MDNode value.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", !2}' >> %t\n+- ; RUN: echo '!2 = !{i32 5}' >> %t\n+- ; RUN: not %{RUN} BAD-VALUE\n+- \n+- ; Too many values.\n+- ; RUN: cp %s %t\n+-+; RUN: chmod u+w %t\n+- ; RUN: echo '!1 = !{!\"llvm.loop.estimated_trip_count\", i32 5, i32 5}' >> %t\n+- ; RUN: not %{RUN} TOO-MANY\n+-diff -ruN --strip-trailing-cr a/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h b/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h\n+---- a/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h\n+-+++ b/mlir/include/mlir/Tools/mlir-opt/MlirOptMain.h\n+-@@ -264,7 +264,7 @@\n+-   bool allowUnregisteredDialectsFlag = false;\n+- \n+-   /// Remark format\n+--  RemarkFormat remarkFormatFlag;\n+-+  RemarkFormat remarkFormatFlag = REMARK_FORMAT_STDOUT;\n+-   /// Remark file to output to\n+-   std::string remarksOutputFileFlag = \"\";\n+-   /// Remark filters\n+-diff -ruN --strip-trailing-cr a/mlir/lib/Bindings/Python/IRCore.cpp b/mlir/lib/Bindings/Python/IRCore.cpp\n+---- a/mlir/lib/Bindings/Python/IRCore.cpp\n+-+++ b/mlir/lib/Bindings/Python/IRCore.cpp\n+-@@ -1079,23 +1079,38 @@\n+- PyModule::PyModule(PyMlirContextRef contextRef, MlirModule module)\n+-     : BaseContextObject(std::move(contextRef)), module(module) {}\n+- \n+--PyModule::~PyModule() { mlirModuleDestroy(module); }\n+-+PyModule::~PyModule() {\n+-+  nb::gil_scoped_acquire acquire;\n+-+  auto &liveModules = getContext()->liveModules;\n+-+  assert(liveModules.count(module.ptr) == 1 &&\n+-+         \"destroying module not in live map\");\n+-+  liveModules.erase(module.ptr);\n+-+  mlirModuleDestroy(module);\n+-+}\n+- \n+- PyModuleRef PyModule::forModule(MlirModule module) {\n+-   MlirContext context = mlirModuleGetContext(module);\n+-   PyMlirContextRef contextRef = PyMlirContext::forContext(context);\n+- \n+--  // Create.\n+--  PyModule *unownedModule = new PyModule(std::move(contextRef), module);\n+--  // Note that the default return value policy on cast is `automatic_reference`,\n+--  // which means \"does not take ownership, does not call delete/dtor\".\n+--  // We use `take_ownership`, which means \"Python will call the C++ destructor\n+--  // and delete operator when the Python wrapper is garbage collected\", because\n+--  // MlirModule actually wraps OwningOpRef<ModuleOp> (see mlirModuleCreateParse\n+--  // etc).\n+--  nb::object pyRef = nb::cast(unownedModule, nb::rv_policy::take_ownership);\n+--  unownedModule->handle = pyRef;\n+--  return PyModuleRef(unownedModule, std::move(pyRef));\n+-+  nb::gil_scoped_acquire acquire;\n+-+  auto &liveModules = contextRef->liveModules;\n+-+  auto it = liveModules.find(module.ptr);\n+-+  if (it == liveModules.end()) {\n+-+    // Create.\n+-+    PyModule *unownedModule = new PyModule(std::move(contextRef), module);\n+-+    // Note that the default return value policy on cast is automatic_reference,\n+-+    // which does not take ownership (delete will not be called).\n+-+    // Just be explicit.\n+-+    nb::object pyRef = nb::cast(unownedModule, nb::rv_policy::take_ownership);\n+-+    unownedModule->handle = pyRef;\n+-+    liveModules[module.ptr] =\n+-+        std::make_pair(unownedModule->handle, unownedModule);\n+-+    return PyModuleRef(unownedModule, std::move(pyRef));\n+++void dummy_func() {}\n+++\n+++uint8_t empty_8bit_counters[0];\n+++uintptr_t empty_pcs[0];\n+++\n+++uint8_t fake_8bit_counters[1] = {0};\n+++uintptr_t fake_pcs[2] = {reinterpret_cast<uintptr_t>(&dummy_func),\n+++                         reinterpret_cast<uintptr_t>(&dummy_func)};\n+++\n+++// Register two modules at program launch (same time they'd normally be registered).\n+++// Triggering the bug requires loading an empty module, then a non-empty module after it.\n+++bool dummy = []() {\n+++  // First, simulate loading an empty module.\n+++  __sanitizer_cov_8bit_counters_init(empty_8bit_counters, empty_8bit_counters);\n+++  __sanitizer_cov_pcs_init(empty_pcs, empty_pcs);\n+++\n+++  // Next, simulate loading a non-empty module.\n+++  __sanitizer_cov_8bit_counters_init(fake_8bit_counters,\n+++                                     fake_8bit_counters + 1);\n+++  __sanitizer_cov_pcs_init(fake_pcs, fake_pcs + 2);\n+++\n+++  return true;\n+++}();\n+++\n+++static volatile int Sink;\n+++\n+++extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n+++  assert(Data);\n+++  if (Size > 0 && Data[0] == 'H') {\n+++    Sink = 1;\n+++    if (Size > 1 && Data[1] == 'i') {\n+++      Sink = 2;\n+++      if (Size > 2 && Data[2] == '!') {\n+++        std::cout << \"BINGO; Found the target, exiting\\n\" << std::flush;\n+++        exit(0);\n+++      }\n+++    }\n+ +  }\n+-+  // Use existing.\n+-+  PyModule *existing = it->second.second;\n+-+  nb::object pyRef = nb::borrow<nb::object>(it->second.first);\n+-+  return PyModuleRef(existing, std::move(pyRef));\n+- }\n+- \n+- nb::object PyModule::createFromCapsule(nb::object capsule) {\n+-@@ -2084,6 +2099,8 @@\n+-   return PyInsertionPoint{block, std::move(nextOpRef)};\n+- }\n+- \n+-+size_t PyMlirContext::getLiveModuleCount() { return liveModules.size(); }\n+-+\n+- nb::object PyInsertionPoint::contextEnter(nb::object insertPoint) {\n+-   return PyThreadContextEntry::pushInsertionPoint(insertPoint);\n+++  return 0;\n+++}\n++diff -ruN --strip-trailing-cr a/llvm/lib/IR/Metadata.cpp b/llvm/lib/IR/Metadata.cpp\n++--- a/llvm/lib/IR/Metadata.cpp\n+++++ b/llvm/lib/IR/Metadata.cpp\n++@@ -986,10 +986,15 @@\n+  }\n+-@@ -2923,6 +2940,7 @@\n+-              PyMlirContextRef ref = PyMlirContext::forContext(self.get());\n+-              return ref.releaseObject();\n+-            })\n+-+      .def(\"_get_live_module_count\", &PyMlirContext::getLiveModuleCount)\n+-       .def_prop_ro(MLIR_PYTHON_CAPI_PTR_ATTR, &PyMlirContext::getCapsule)\n+-       .def(MLIR_PYTHON_CAPI_FACTORY_ATTR, &PyMlirContext::createFromCapsule)\n+-       .def(\"__enter__\", &PyMlirContext::contextEnter)\n+-diff -ruN --strip-trailing-cr a/mlir/lib/Bindings/Python/IRModule.h b/mlir/lib/Bindings/Python/IRModule.h\n+---- a/mlir/lib/Bindings/Python/IRModule.h\n+-+++ b/mlir/lib/Bindings/Python/IRModule.h\n+-@@ -218,6 +218,10 @@\n+-   /// Gets the count of live context objects. Used for testing.\n+-   static size_t getLiveCount();\n+  \n+-+  /// Gets the count of live modules associated with this context.\n+-+  /// Used for testing.\n+-+  size_t getLiveModuleCount();\n+-+\n+-   /// Enter and exit the context manager.\n+-   static nanobind::object contextEnter(nanobind::object context);\n+-   void contextExit(const nanobind::object &excType,\n+-@@ -244,6 +248,14 @@\n+-   static nanobind::ft_mutex live_contexts_mutex;\n+-   static LiveContextMap &getLiveContexts();\n+- \n+-+  // Interns all live modules associated with this context. Modules tracked\n+-+  // in this map are valid. When a module is invalidated, it is removed\n+-+  // from this map, and while it still exists as an instance, any\n+-+  // attempt to access it will raise an error.\n+-+  using LiveModuleMap =\n+-+      llvm::DenseMap<const void *, std::pair<nanobind::handle, PyModule *>>;\n+-+  LiveModuleMap liveModules;\n+-+\n+-   bool emitErrorDiagnostics = false;\n+- \n+-   MlirContext context;\n+-diff -ruN --strip-trailing-cr a/mlir/test/python/ir/module.py b/mlir/test/python/ir/module.py\n+---- a/mlir/test/python/ir/module.py\n+-+++ b/mlir/test/python/ir/module.py\n+-@@ -121,6 +121,7 @@\n+- def testModuleOperation():\n+-     ctx = Context()\n+-     module = Module.parse(r\"\"\"module @successfulParse {}\"\"\", ctx)\n+-+    assert ctx._get_live_module_count() == 1\n+-     op1 = module.operation\n+-     # CHECK: module @successfulParse\n+-     print(op1)\n+-@@ -145,6 +146,7 @@\n+-     op1 = None\n+-     op2 = None\n+-     gc.collect()\n+-+    assert ctx._get_live_module_count() == 0\n+- \n+- \n+- # CHECK-LABEL: TEST: testModuleCapsule\n+-@@ -152,17 +154,17 @@\n+- def testModuleCapsule():\n+-     ctx = Context()\n+-     module = Module.parse(r\"\"\"module @successfulParse {}\"\"\", ctx)\n+-+    assert ctx._get_live_module_count() == 1\n+-     # CHECK: \"mlir.ir.Module._CAPIPtr\"\n+-     module_capsule = module._CAPIPtr\n+-     print(module_capsule)\n+-     module_dup = Module._CAPICreate(module_capsule)\n+--    assert module is not module_dup\n+-+    assert module is module_dup\n+-     assert module == module_dup\n+--    module._clear_mlir_module()\n+--    assert module != module_dup\n+-     assert module_dup.context is ctx\n+-     # Gc and verify destructed.\n+-     module = None\n+-     module_capsule = None\n+-     module_dup = None\n+-     gc.collect()\n+-+    assert ctx._get_live_module_count() == 0\n++ template <class NodeTy> struct MDNode::HasCachedHash {\n+++  using Yes = char[1];\n+++  using No = char[2];\n+++  template <class U, U Val> struct SFINAE {};\n+++\n++   template <class U>\n++-  using check = decltype(static_cast<void (U::*)(unsigned)>(&U::setHash));\n+++  static Yes &check(SFINAE<void (U::*)(unsigned), &U::setHash> *);\n+++  template <class U> static No &check(...);\n++ \n++-  static constexpr bool value = is_detected<check, NodeTy>::value;\n+++  static const bool value = sizeof(check<NodeTy>(nullptr)) == sizeof(Yes);\n++ };\n++ \n++ MDNode *MDNode::uniquify() {\n++diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n++--- a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n+++++ b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n++@@ -796,18 +796,19 @@\n++       if (Count && !ProfcheckDisableMetadataFixes) {\n++         std::optional<llvm::Function::ProfileCount> MaybeCloneCount =\n++             Clone->getEntryCount();\n++-        assert(MaybeCloneCount && \"Clone entry count was not set!\");\n++-        uint64_t CallCount = *Count + MaybeCloneCount->getCount();\n++-        Clone->setEntryCount(CallCount);\n++-        if (std::optional<llvm::Function::ProfileCount> MaybeOriginalCount =\n++-                S.F->getEntryCount()) {\n++-          uint64_t OriginalCount = MaybeOriginalCount->getCount();\n++-          if (OriginalCount >= *Count) {\n++-            S.F->setEntryCount(OriginalCount - *Count);\n++-          } else {\n++-            // This should generally not happen as that would mean there are\n++-            // more computed calls to the function than what was recorded.\n++-            LLVM_DEBUG(S.F->setEntryCount(0));\n+++        if (MaybeCloneCount) {\n+++          uint64_t CallCount = *Count + MaybeCloneCount->getCount();\n+++          Clone->setEntryCount(CallCount);\n+++          if (std::optional<llvm::Function::ProfileCount> MaybeOriginalCount =\n+++                  S.F->getEntryCount()) {\n+++            uint64_t OriginalCount = MaybeOriginalCount->getCount();\n+++            if (OriginalCount >= *Count) {\n+++              S.F->setEntryCount(OriginalCount - *Count);\n+++            } else {\n+++              // This should generally not happen as that would mean there are\n+++              // more computed calls to the function than what was recorded.\n+++              LLVM_DEBUG(S.F->setEntryCount(0));\n+++            }\n++           }\n++         }\n++       }\n+diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl\n+index 3bdff1c..08eb474 100644\n+--- a/third_party/llvm/workspace.bzl\n++++ b/third_party/llvm/workspace.bzl\n+@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")\n+ \n+ def repo(name):\n+     \"\"\"Imports LLVM.\"\"\"\n+-    LLVM_COMMIT = \"f3b712f6e4e9afed735962c6b96e0a2cadb03dc1\"\n+-    LLVM_SHA256 = \"3c1a7a3156635a35e33da13a93a4dd8f2e48ac7280b5674061a951a4aa8475c3\"\n++    LLVM_COMMIT = \"b8649098a7fcf598406d8d8b7d68891d1444e9c8\"\n++    LLVM_SHA256 = \"18e365a1f849b6b66f0ae10810250be6c4a1de791e4892f9eaf900b8974b461b\"\n+ \n+     tf_http_archive(\n+         name = name,"
        },
        {
            "sha": "a71d976d36e648e5e46085b3b1c40a826d5c3251",
            "filename": "third_party/xla/third_party/shardy/workspace.bzl",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fshardy%2Fworkspace.bzl?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -3,8 +3,8 @@\n load(\"//third_party:repo.bzl\", \"tf_http_archive\", \"tf_mirror_urls\")\n \n def repo():\n-    SHARDY_COMMIT = \"8de13597e867575386fd35e8ea2ea521089d255e\"\n-    SHARDY_SHA256 = \"38ec677ea45ba3e9ecf901e8de98a603f006f6588484d406c4da1c0cd8358f02\"\n+    SHARDY_COMMIT = \"8a2113977db9a3e69415883b0d26e5bb5d75e1a2\"\n+    SHARDY_SHA256 = \"baf4e9a5cf5dc55209ae794b3169ef81bd861a5bd642eabc7074995fc6fdad61\"\n \n     tf_http_archive(\n         name = \"shardy\","
        },
        {
            "sha": "f44e7e5712659f0c08f0de2e92b9ab28d99cd285",
            "filename": "third_party/xla/third_party/triton/llvm_integration/cl809972027.patch",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Ftriton%2Fllvm_integration%2Fcl809972027.patch",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Ftriton%2Fllvm_integration%2Fcl809972027.patch",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftriton%2Fllvm_integration%2Fcl809972027.patch?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -0,0 +1,40 @@\n+\n+--- a/third_party/amd/lib/TritonAMDGPUToLLVM/TritonGPUToLLVM.cpp\t2025-07-31 00:13:23.000000000 -0700\n++++ b/third_party/amd/lib/TritonAMDGPUToLLVM/TritonGPUToLLVM.cpp\t2025-09-22 05:43:47.000000000 -0700\n+@@ -257,7 +257,7 @@\n+         loc, arrayTy, /*isConstant=*/false, LLVM::Linkage::External,\n+         \"global_smem\", /*value=*/Attribute(), /*alignment=*/16,\n+         // Add ROCm support.\n+-        static_cast<unsigned>(NVVM::NVVMMemorySpace::kSharedMemorySpace));\n++        static_cast<unsigned>(NVVM::NVVMMemorySpace::Shared));\n+   }\n+ };\n+ \n+\n+--- a/third_party/amd/lib/TritonAMDGPUTransforms/Utility.cpp\t2025-04-25 05:19:43.000000000 -0700\n++++ b/third_party/amd/lib/TritonAMDGPUTransforms/Utility.cpp\t2025-09-22 05:43:47.000000000 -0700\n+@@ -24,9 +24,9 @@\n+           deduceMinCountInBlock(ifOp.getElseRegion().front(), countFunc);\n+       count += std::min(minThen, minElse);\n+     } else if (auto forOp = llvm::dyn_cast<scf::ForOp>(op)) {\n+-      auto tripCount = constantTripCount(forOp.getLowerBound(),\n+-                                         forOp.getUpperBound(), forOp.getStep())\n+-                           .value_or(0);\n++      int64_t tripCount = forOp.getStaticTripCount()\n++                              .value_or(llvm::APInt(64, 0))\n++                              .getZExtValue();\n+       if (tripCount > 0) {\n+         count += tripCount * deduceMinCountInBlock(*forOp.getBody(), countFunc);\n+       }\n+\n+--- a/third_party/nvidia/lib/TritonNVIDIAGPUToLLVM/TritonGPUToLLVM.cpp\t2025-08-22 04:02:56.000000000 -0700\n++++ b/third_party/nvidia/lib/TritonNVIDIAGPUToLLVM/TritonGPUToLLVM.cpp\t2025-09-22 05:43:47.000000000 -0700\n+@@ -223,7 +223,7 @@\n+         loc, arrayTy, /*isConstant=*/false, LLVM::Linkage::External,\n+         \"global_smem\", /*value=*/Attribute(), /*alignment=*/16,\n+         // Add ROCm support.\n+-        static_cast<unsigned>(NVVM::NVVMMemorySpace::kSharedMemorySpace));\n++        static_cast<unsigned>(NVVM::NVVMMemorySpace::Shared));\n+   }\n+ };\n+ "
        },
        {
            "sha": "03010c4241c06ae197442f21940630ec8cf95c65",
            "filename": "third_party/xla/third_party/triton/llvm_integration/series.bzl",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Ftriton%2Fllvm_integration%2Fseries.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fthird_party%2Ftriton%2Fllvm_integration%2Fseries.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftriton%2Fllvm_integration%2Fseries.bzl?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -10,5 +10,6 @@ LLVM nor MLIR integrator, please do not add any patches to this list.\n llvm_patch_list = [\n     \"//third_party/triton:llvm_integration/cl801607173.patch\",\n     \"//third_party/triton:llvm_integration/cl808150672.patch\",\n+    \"//third_party/triton:llvm_integration/cl809972027.patch\",\n     # Add new patches just above this line\n ]"
        },
        {
            "sha": "c0dc187ae50e255e19d8f3ec92960a9cc80af025",
            "filename": "third_party/xla/xla/backends/cpu/codegen/emitters/transforms/add_loop_unroll_flags.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Femitters%2Ftransforms%2Fadd_loop_unroll_flags.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Femitters%2Ftransforms%2Fadd_loop_unroll_flags.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Femitters%2Ftransforms%2Fadd_loop_unroll_flags.cc?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -93,12 +93,7 @@ class AddLoopUnrollFlagsPass\n   static int64_t RecursiveWalk(\n       mlir::scf::ForOp for_op,\n       llvm::DenseMap<mlir::scf::ForOp, int64_t>& nested_iteration_map) {\n-    auto lb = for_op.getLowerBound();\n-    auto ub = for_op.getUpperBound();\n-    auto step = for_op.getStep();\n-\n-    std::optional<int64_t> this_trip_count =\n-        mlir::constantTripCount(lb, ub, step);\n+    std::optional<llvm::APInt> this_trip_count = for_op.getStaticTripCount();\n \n     if (!this_trip_count.has_value()) {\n       return 0;\n@@ -113,11 +108,13 @@ class AddLoopUnrollFlagsPass\n \n     nested_iteration_map.insert({for_op, nested_iterations});\n \n+    int64_t this_trip_count_int = this_trip_count->getZExtValue();\n+\n     if (nested_iterations == 0) {\n-      return *this_trip_count;\n+      return this_trip_count_int;\n     }\n \n-    return *this_trip_count * nested_iterations;\n+    return this_trip_count_int * nested_iterations;\n   }\n };\n "
        },
        {
            "sha": "d4566e406d4c5c08d7e9a6185939769388ea73e8",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/fusion_emitter.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ffusion_emitter.cc?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -1887,7 +1887,8 @@ absl::Status CreateInternalError(absl::string_view message,\n void AppendFuncArgType(absl::Span<const int64_t> dims, Type ir_type,\n                        SmallVector<Type>& fn_arg_types) {\n   fn_arg_types.push_back(ttir::PointerType::get(\n-      StorageType(ir_type), mlir::NVVM::kGlobalMemorySpace));\n+      StorageType(ir_type),\n+      static_cast<unsigned>(mlir::NVVM::NVVMMemorySpace::Global)));\n }\n \n // Legacy emitter works with tt.func. New emitter works with func.func."
        },
        {
            "sha": "ebc7be67522b299df6e91edd8a7b031c54f0399c",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/transforms/generalize_kernel_signature.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Fgeneralize_kernel_signature.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Fgeneralize_kernel_signature.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Fgeneralize_kernel_signature.cc?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -61,7 +61,9 @@ void StripParameterAddressSpaces(RewriterBase& rewriter,\n       llvm::map_range(func_ty.getParams(), [](Type type) -> Type {\n         auto ptr_ty = dyn_cast<LLVM::LLVMPointerType>(type);\n         if (!ptr_ty) return type;\n-        if (ptr_ty.getAddressSpace() != NVVM::kGlobalMemorySpace) return type;\n+        if (ptr_ty.getAddressSpace() != NVVM::NVVMMemorySpace::Global) {\n+          return type;\n+        }\n         return LLVM::LLVMPointerType::get(ptr_ty.getContext());\n       }));\n   LLVM::LLVMFunctionType generic_func_ty ="
        },
        {
            "sha": "441253c786ff9b34f80e97694e3b91459309489d",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/transforms/triton_xla_extract_insert_to_triton_pass.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftriton_xla_extract_insert_to_triton_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftriton_xla_extract_insert_to_triton_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftransforms%2Ftriton_xla_extract_insert_to_triton_pass.cc?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -71,8 +71,9 @@ namespace xgt = xg::triton;\n namespace {\n \n PointerType GetTensorPtrType(Type type) {\n-  return PointerType::get(xgt::StorageType(type),\n-                          mlir::NVVM::kGlobalMemorySpace);\n+  return PointerType::get(\n+      xgt::StorageType(type),\n+      static_cast<unsigned>(mlir::NVVM::NVVMMemorySpace::Global));\n }\n \n SmallVector<Value> IndexCast(::xla::EmitterLocOpBuilder& builder, Type type,"
        },
        {
            "sha": "cd420b2e19bcddc40ae3673a911c2f5fb46d72e5",
            "filename": "third_party/xla/xla/codegen/emitters/transforms/flatten_tensors.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fflatten_tensors.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afe5cb53474f1f1dc58315c0eb107b41f426345c/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fflatten_tensors.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fflatten_tensors.cc?ref=afe5cb53474f1f1dc58315c0eb107b41f426345c",
            "patch": "@@ -350,7 +350,7 @@ struct RewriteVectorExtract : OpRewritePattern<mv::ExtractOp> {\n \n   LogicalResult matchAndRewrite(mv::ExtractOp op,\n                                 PatternRewriter& rewriter) const override {\n-    auto vector = op.getVector();\n+    auto vector = op.getSource();\n     auto vector_type = vector.getType();\n     if (vector_type.getRank() < 2) {\n       return rewriter.notifyMatchFailure(op, \"the vector is already flat\");"
        }
    ],
    "stats": {
        "total": 1485,
        "additions": 948,
        "deletions": 537
    }
}