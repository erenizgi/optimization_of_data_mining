{
    "author": "ermilovmaxim",
    "message": "add CustomCall to append Tensor to file\n\nPiperOrigin-RevId: 831020229",
    "sha": "9da042273660460b94d29062ef02428fc98b0758",
    "files": [
        {
            "sha": "8cc7a569a0e44686fe749359ab25f5bf8a36c948",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=9da042273660460b94d29062ef02428fc98b0758",
            "patch": "@@ -3045,12 +3045,18 @@ cc_library(\n         \"//xla/service:platform_util\",\n         \"//xla/stream_executor:memory_allocation\",\n         \"//xla/stream_executor:stream\",\n+        \"//xla/tsl/lib/io:record_writer\",\n+        \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/synchronization\",\n+        \"@local_tsl//tsl/platform:path\",\n+        \"@local_tsl//tsl/platform:platform_port\",\n     ],\n     alwayslink = 1,\n )\n@@ -3061,15 +3067,26 @@ xla_test(\n     backends = [\"gpu\"],\n     deps = [\n         \":runtime_intrinsics\",\n+        \"//xla:literal\",\n+        \"//xla:literal_util\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/tests:hlo_test_base\",\n         \"//xla/tests:xla_internal_test_main\",\n+        \"//xla/tsl/lib/io:record_reader\",\n+        \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n+        \"//xla/tsl/testing:temporary_directory\",\n         \"@com_google_absl//absl/base:log_severity\",\n         \"@com_google_absl//absl/log:scoped_mock_log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_googletest//:gtest\",\n+        \"@local_tsl//tsl/platform:path\",\n+        \"@local_tsl//tsl/platform:tstring\",\n     ],\n )\n "
        },
        {
            "sha": "65bfbb36a5b8dc8af9ee07a8af1f1cdbdc21a0f5",
            "filename": "third_party/xla/xla/backends/gpu/runtime/runtime_intrinsics.cc",
            "status": "modified",
            "additions": 81,
            "deletions": 13,
            "changes": 94,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics.cc?ref=9da042273660460b94d29062ef02428fc98b0758",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include <string>\n #include <vector>\n \n+#include \"absl/base/const_init.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n@@ -29,6 +30,7 @@ limitations under the License.\n #include \"absl/strings/str_replace.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/strings/substitute.h\"\n+#include \"absl/synchronization/mutex.h\"\n #include \"xla/ffi/ffi.h\"\n #include \"xla/ffi/ffi_api.h\"\n #include \"xla/layout_util.h\"\n@@ -41,13 +43,17 @@ limitations under the License.\n #include \"xla/shape_util.h\"\n #include \"xla/stream_executor/memory_allocation.h\"\n #include \"xla/stream_executor/stream.h\"\n+#include \"xla/tsl/lib/io/record_writer.h\"\n+#include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/file_system.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n #include \"xla/xla_data.pb.h\"\n+#include \"tsl/platform/host_info.h\"\n+#include \"tsl/platform/path.h\"\n \n namespace xla {\n-\n namespace {\n \n std::string GetGpuPlatformName() {\n@@ -81,6 +87,23 @@ void NopReturnTokenCustomCall(void* stream_handle, void** buffers,\n   VLOG(1) << \"NopReturnTokenCustomCall called.\";\n }\n \n+absl::StatusOr<Literal> ConvertToLiteral(se::Stream* stream,\n+                                         const ffi::AnyBuffer& arg) {\n+  Shape shape = ShapeUtil::MakeShape(arg.element_type(), arg.dimensions());\n+  LayoutUtil::SetToDefaultLayout(&shape);\n+\n+  TF_ASSIGN_OR_RETURN(Literal literal, Literal::Make(shape));\n+\n+  int64_t size_bytes = arg.size_bytes();\n+  TF_ASSIGN_OR_RETURN(std::unique_ptr<se::MemoryAllocation> host_buffer,\n+                      stream->parent()->HostMemoryAllocate(size_bytes));\n+  TF_RETURN_IF_ERROR(\n+      stream->Memcpy(literal.untyped_data(), arg.device_memory(), size_bytes));\n+  TF_RETURN_IF_ERROR(stream->BlockHostUntilDone());\n+\n+  return literal;\n+}\n+\n absl::Status DebugPrintCustomCall(se::Stream* stream, ffi::RemainingArgs args,\n                                   absl::string_view format,\n                                   ffi::Result<ffi::Buffer<xla::TOKEN>> res) {\n@@ -107,18 +130,9 @@ absl::Status DebugPrintCustomCall(se::Stream* stream, ffi::RemainingArgs args,\n       return absl::FailedPreconditionError(absl::Substitute(\n           \"Missing formatter for argument $0 in debug print custom call\", i));\n     }\n-    const ffi::AnyBuffer& arg = args_buffers[i];\n-    int64_t size_bytes = arg.size_bytes();\n-    TF_ASSIGN_OR_RETURN(std::unique_ptr<se::MemoryAllocation> host_buffer,\n-                        stream->parent()->HostMemoryAllocate(size_bytes));\n-    TF_RETURN_IF_ERROR(\n-        stream->Memcpy(host_buffer->opaque(), arg.device_memory(), size_bytes));\n-    TF_RETURN_IF_ERROR(stream->BlockHostUntilDone());\n-\n-    Shape shape = ShapeUtil::MakeShape(arg.element_type(), arg.dimensions());\n-    LayoutUtil::SetToDefaultLayout(&shape);\n-    MutableBorrowingLiteral literal(static_cast<char*>(host_buffer->opaque()),\n-                                    shape);\n+    TF_ASSIGN_OR_RETURN(Literal literal,\n+                        ConvertToLiteral(stream, args_buffers[i]));\n+\n     formatted =\n         absl::StrReplaceAll(formatted, {{to_substitute, literal.ToString()}});\n   }\n@@ -128,6 +142,49 @@ absl::Status DebugPrintCustomCall(se::Stream* stream, ffi::RemainingArgs args,\n   return absl::OkStatus();\n }\n \n+std::string GetUniqueFilenameForHost() {\n+  return absl::StrCat(tsl::port::Hostname(), tsl::port::JobName(),\n+                      tsl::port::TaskId(), tsl::port::JobUid(), \".tfrecord\");\n+}\n+\n+// This custom call copies its argument to the host and appends it to file.\n+absl::Status AppendToFileCustomCall(se::Stream* stream, ffi::AnyBuffer buffer,\n+                                    absl::string_view dir,\n+                                    absl::string_view metadata,\n+                                    ffi::Result<ffi::Buffer<xla::TOKEN>> res) {\n+  if (!stream) {\n+    return Internal(\"Stream is nullptr.\");\n+  }\n+  static absl::Mutex host_mutex{absl::kConstInit};\n+\n+  TF_ASSIGN_OR_RETURN(Literal literal, ConvertToLiteral(stream, buffer));\n+\n+  auto* env = tsl::Env::Default();\n+  std::string destination{dir};\n+  TF_RETURN_IF_ERROR(env->RecursivelyCreateDir(destination));\n+  std::string path = tsl::io::JoinPath(destination, GetUniqueFilenameForHost());\n+\n+  // Supports tensors 2+GB. Should not be serialized as proto.\n+  TF_ASSIGN_OR_RETURN(std::string serialized, literal.SerializeAsString());\n+\n+  std::unique_ptr<tsl::WritableFile> file;\n+  std::string filename(path);\n+\n+  {\n+    absl::MutexLock lock(&host_mutex);\n+\n+    TF_RETURN_IF_ERROR(env->NewAppendableFile(filename, &file));\n+    tsl::io::RecordWriter writer(file.get());\n+\n+    TF_RETURN_IF_ERROR(writer.WriteRecord(metadata));\n+    TF_RETURN_IF_ERROR(writer.WriteRecord(serialized));\n+\n+    TF_RETURN_IF_ERROR(writer.Close());\n+  }\n+\n+  return absl::OkStatus();\n+}\n+\n }  // namespace\n \n // This custom call copies its arguments to the host and pretty-prints them as\n@@ -144,6 +201,17 @@ XLA_FFI_DEFINE_HANDLER(kXlaGpuDebugPrintCustomCall, DebugPrintCustomCall,\n XLA_FFI_REGISTER_HANDLER(ffi::GetXlaFfiApi(), kXlaGpuDebugPrintCustomCallTag,\n                          GetGpuPlatformName(), kXlaGpuDebugPrintCustomCall);\n \n+XLA_FFI_DEFINE_HANDLER(kXlaGpuAppendToFileCustomCall, AppendToFileCustomCall,\n+                       ffi::Ffi::Bind()\n+                           .Ctx<ffi::Stream>()\n+                           .Arg<ffi::AnyBuffer>()\n+                           .Attr<absl::string_view>(\"dir\")\n+                           .Attr<absl::string_view>(\"metadata\")\n+                           .Ret<xla::ffi::Buffer<xla::TOKEN>>());\n+\n+XLA_FFI_REGISTER_HANDLER(ffi::GetXlaFfiApi(), kXlaGpuAppendToFileCustomCallTag,\n+                         GetGpuPlatformName(), kXlaGpuAppendToFileCustomCall);\n+\n XLA_FFI_DEFINE_HANDLER(kXlaGpuAssertCustomCall, AssertionCustomCall,\n                        ffi::Ffi::Bind()\n                            .Ctx<ffi::Stream>()"
        },
        {
            "sha": "0a42104f9b0139832f06f202e58d2fe85f035148",
            "filename": "third_party/xla/xla/backends/gpu/runtime/runtime_intrinsics.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics.h?ref=9da042273660460b94d29062ef02428fc98b0758",
            "patch": "@@ -26,6 +26,9 @@ inline constexpr absl::string_view kXlaGpuAssertCustomCallTag =\n inline constexpr absl::string_view kXlaGpuDebugPrintCustomCallTag =\n     \"__xla_gpu_debug_print\";\n \n+inline constexpr absl::string_view kXlaGpuAppendToFileCustomCallTag =\n+    \"__xla_gpu_append_to_file\";\n+\n }  // namespace xla\n \n #endif  // XLA_BACKENDS_GPU_RUNTIME_RUNTIME_INTRINSICS_H_"
        },
        {
            "sha": "8153edf3269b2d5416cfc3f47e82afaba4e85bd5",
            "filename": "third_party/xla/xla/backends/gpu/runtime/runtime_intrinsics_test.cc",
            "status": "modified",
            "additions": 86,
            "deletions": 0,
            "changes": 86,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9da042273660460b94d29062ef02428fc98b0758/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fruntime_intrinsics_test.cc?ref=9da042273660460b94d29062ef02428fc98b0758",
            "patch": "@@ -13,18 +13,33 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n+#include <cstdint>\n #include <memory>\n+#include <string>\n #include <utility>\n+#include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/base/log_severity.h\"\n #include \"absl/log/scoped_mock_log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/literal.h\"\n+#include \"xla/literal_util.h\"\n #include \"xla/tests/hlo_test_base.h\"\n+#include \"xla/tsl/lib/io/record_reader.h\"\n+#include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/file_system.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n+#include \"xla/tsl/testing/temporary_directory.h\"\n+#include \"tsl/platform/path.h\"\n+#include \"tsl/platform/tstring.h\"\n \n namespace xla {\n namespace gpu {\n@@ -35,6 +50,40 @@ using RuntimeIntrinsicsTest = HloTestBase;\n using ::testing::EndsWith;\n using ::testing::HasSubstr;\n \n+absl::StatusOr<std::vector<std::pair<std::string, Literal>>>\n+ReadTFRecordIOLiteral(const std::string& dir) {\n+  auto* env = tsl::Env::Default();\n+\n+  std::vector<std::string> files;\n+  TF_RETURN_IF_ERROR(env->GetChildren(dir, &files));\n+\n+  std::vector<std::pair<std::string, Literal>> result;\n+  for (const std::string& path : files) {\n+    std::unique_ptr<tsl::RandomAccessFile> file;\n+    TF_RETURN_IF_ERROR(tsl::Env::Default()->NewRandomAccessFile(\n+        tsl::io::JoinPath(dir, path), &file));\n+    tsl::io::RecordReader reader(file.get());\n+\n+    uint64_t offset = 0;\n+    tsl::tstring record;\n+\n+    for (;;) {\n+      tsl::tstring metadata;\n+      absl::Status status = reader.ReadRecord(&offset, &metadata);\n+      if (absl::IsOutOfRange(status)) {\n+        break;\n+      }\n+      TF_RETURN_IF_ERROR(status);\n+\n+      TF_RETURN_IF_ERROR(reader.ReadRecord(&offset, &record));\n+      TF_ASSIGN_OR_RETURN(Literal literal,\n+                          Literal::DeserializeFromString(record));\n+      result.emplace_back(metadata, std::move(literal));\n+    }\n+  }\n+  return result;\n+}\n+\n TEST_F(RuntimeIntrinsicsTest, NopReturnTokenWorks) {\n   constexpr absl::string_view kHloText = R\"(\n HloModule m\n@@ -140,6 +189,43 @@ ENTRY e {\n   mock_log.StopCapturingLogs();\n }\n \n+TEST_F(RuntimeIntrinsicsTest, AppendToFile) {\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto temp_dir,\n+      tsl::testing::TemporaryDirectory::CreateForCurrentTestcase());\n+\n+  std::string hlo = absl::StrFormat(R\"hlo(\n+HloModule m\n+\n+ENTRY e {\n+  constant = f32[2]{0} constant({1, 2})\n+  ROOT token1 = token[] custom-call(constant),\n+    backend_config=\"{dir = \\\"%1$s\\\", metadata = \\\"op.1\\\"}\",\n+    custom_call_target=\"__xla_gpu_append_to_file\",\n+    custom_call_has_side_effect=true,\n+    api_version=API_VERSION_TYPED_FFI\n+})hlo\",\n+                                    temp_dir.path());\n+\n+  Literal expected = LiteralUtil::CreateR1<float>({1.0f, 2.0f});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                          GetOptimizedModule(hlo));\n+  EXPECT_TRUE(Run(std::move(module), /*run_hlo_passes=*/false));\n+\n+  std::vector<std::pair<std::string, Literal>> literals;\n+  TF_ASSERT_OK_AND_ASSIGN(literals, ReadTFRecordIOLiteral(temp_dir.path()));\n+  EXPECT_EQ(literals.size(), 1);\n+  EXPECT_EQ(literals[0].first, \"op.1\");\n+  EXPECT_EQ(literals[0].second, expected);\n+\n+  // Verify that append works.\n+  TF_ASSERT_OK_AND_ASSIGN(module, GetOptimizedModule(hlo));\n+  EXPECT_TRUE(Run(std::move(module), /*run_hlo_passes=*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(literals, ReadTFRecordIOLiteral(temp_dir.path()));\n+  EXPECT_EQ(literals.size(), 2);\n+}\n+\n }  // namespace\n }  // namespace gpu\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 200,
        "additions": 187,
        "deletions": 13
    }
}