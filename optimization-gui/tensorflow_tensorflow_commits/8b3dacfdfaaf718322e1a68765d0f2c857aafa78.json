{
    "author": "tensorflower-gardener",
    "message": "[SymbolicMap] Integrate SymbolicExprContext into IndexingMap tests\n\nAs a step towards using SymbolicExpr within IndexingMap instead of AffineExpr, this CL integrates `gpu::SymbolicExprContext` into the testing infrastructure.\n - Added `SymbolicExprContext` members to `IndexingTestBase` and `IndexingMapTest`\n - Updated test utilities and test cases to use the `MLIRContext` from the `SymbolicExprContext`.\n - Changed function signatures in `indexing_test_utils` (e.g., `ParseAffineMap`, `ParseAffineExpr`) to accept `gpu::SymbolicExprContext*`.\n\nThis change prepares the codebase for the subsequent replacement of `AffineExpr` with `SymbolicExpr` in the core `IndexingMap` logic.\n\nPiperOrigin-RevId: 814237594",
    "sha": "8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
    "files": [
        {
            "sha": "9185c68e75e0f85e147b0851bfe6c10a784a38b0",
            "filename": "third_party/xla/xla/codegen/tiling/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2FBUILD?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -49,6 +49,7 @@ xla_cc_test(\n         \"//xla/hlo/analysis:indexing_test_utils\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/service/gpu/model/experimental:symbolic_expr\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_googletest//:gtest_main\",\n@@ -104,6 +105,7 @@ xla_cc_test(\n         \"//xla/hlo/analysis:indexing_test_utils\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/service/gpu/model/experimental:symbolic_expr\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@llvm-project//mlir:IR\",\n@@ -213,6 +215,7 @@ xla_cc_test(\n         \":symbolic_tile\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n         \"//xla/hlo/analysis:indexing_test_utils\",\n+        \"//xla/hlo/analysis:interval\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/types:span\","
        },
        {
            "sha": "3921d7f05886c1d1bcf3f2ac81eac58b0c898c4f",
            "filename": "third_party/xla/xla/codegen/tiling/constraint_expression_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fconstraint_expression_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fconstraint_expression_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fconstraint_expression_test.cc?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -42,7 +42,7 @@ class ConstraintExpressionTest : public IndexingTestBase {\n  public:\n   ConstraintExpression::Constraint GetConstraint(const std::string& string_expr,\n                                                  int64_t lower, int64_t upper) {\n-    return {ParseAffineExpr(string_expr, &mlir_context_),\n+    return {ParseAffineExpr(string_expr, &symbolic_expr_context_),\n             Interval{lower, upper}};\n   }\n   ConstraintExpression Simplify(ConstraintExpression constraints) {"
        },
        {
            "sha": "2fdda1d783d7b402bbe6127934ed3fe3c5f4fca5",
            "filename": "third_party/xla/xla/codegen/tiling/symbolic_tile_test.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 18,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Fsymbolic_tile_test.cc?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"xla/hlo/analysis/indexing_analysis.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n \n namespace xla {\n namespace {\n@@ -592,8 +593,8 @@ TEST_F(SymbolicTileTest, CanPropagateTileThroughSummationOfSymbols) {\n   //   reduce_0 = f32[9] reduce(bitcast), dimensions={1}\n   //   reduce_1 = f32[] reduce(reduce_0), dimensions={0}\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n-      ParseAffineMap(\"()[s0, s1] -> (s1 * 2 + s0)\", &mlir_context_), {},\n-      {2, 9});\n+      ParseAffineMap(\"()[s0, s1] -> (s1 * 2 + s0)\", &symbolic_expr_context_),\n+      {}, {2, 9});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),\n               Optional(MatchSymbolicTileString(R\"(\n@@ -612,7 +613,7 @@ TEST_F(SymbolicTileTest, CanPropagateTileModAndFloorDiv) {\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\n           \"(d0) -> (d0 floordiv 35, (d0 floordiv 7) mod 5, d0 mod 7)\",\n-          &mlir_context_),\n+          &symbolic_expr_context_),\n       {105}, {});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),\n@@ -783,12 +784,13 @@ TEST_F(SymbolicTileTest,\n   // https://github.com/google/paxml/blob/91893818862645f5e9f23b84f530e611551745f6/paxml/contrib/gpu/scripts_gpu/configs.py#L107-L120.\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0, d1, d2)[s0] -> (d0 * 2048 + d1, s0)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {4, 2048, 50304}, {50304});\n   // This constraint is redundant, because it can be derived from the domains of\n   // the dimension variables.\n-  indexing_map.AddConstraint(ParseAffineExpr(\"d0 * 2048 + d1\", &mlir_context_),\n-                             Interval{0, 8191});\n+  indexing_map.AddConstraint(\n+      ParseAffineExpr(\"d0 * 2048 + d1\", &symbolic_expr_context_),\n+      Interval{0, 8191});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),\n               Optional(MatchSymbolicTileString(R\"(\n@@ -804,13 +806,14 @@ TEST_F(SymbolicTileTest,\n        CanDeriveTileWhenPreexistingConstraintsModelRightPadding) {\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0, d1, d2)[s0] -> (d0 * 2048 + d1, s0)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {4, 2048, 50304}, {50304});\n   // This constraint is not redundant, but it doesn't prevent us from deriving\n   // a valid tile (although that tile will need to be interpreted as containing\n   // high padding).\n-  indexing_map.AddConstraint(ParseAffineExpr(\"d0 * 2048 + d1\", &mlir_context_),\n-                             Interval{0, 4096});\n+  indexing_map.AddConstraint(\n+      ParseAffineExpr(\"d0 * 2048 + d1\", &symbolic_expr_context_),\n+      Interval{0, 4096});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),\n               Optional(MatchSymbolicTileString(R\"(\n@@ -826,11 +829,12 @@ TEST_F(SymbolicTileTest,\n        BailsOutOnDerivingTileWhenPreexistingConstraintsModelLeftPadding) {\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0, d1, d2)[s0] -> (d0 * 2048 + d1, s0)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {4, 2048, 50304}, {50304});\n   // This constraint models left padding, which we do not handle for now.\n-  indexing_map.AddConstraint(ParseAffineExpr(\"d0 * 2048 + d1\", &mlir_context_),\n-                             Interval{2, 4096});\n+  indexing_map.AddConstraint(\n+      ParseAffineExpr(\"d0 * 2048 + d1\", &symbolic_expr_context_),\n+      Interval{2, 4096});\n \n   EXPECT_FALSE(SymbolicTile::FromIndexingMap(indexing_map).has_value());\n }\n@@ -839,13 +843,13 @@ TEST_F(SymbolicTileTest,\n        BailsOutOnDerivingTileWhenPreexistingConstraintsDoesNotApplyToResult) {\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0, d1, d2)[s0] -> (d0 * 2048 + d1, s0)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {4, 2048, 50304}, {50304});\n   // This constraint does not apply to a result, and actually models dilation\n   // across `d1`. Figuring out how to handle such cases holistically is\n   // difficult, and we bail out for now.\n-  indexing_map.AddConstraint(ParseAffineExpr(\"d1 mod 5\", &mlir_context_),\n-                             Interval{0, 0});\n+  indexing_map.AddConstraint(\n+      ParseAffineExpr(\"d1 mod 5\", &symbolic_expr_context_), Interval{0, 0});\n \n   EXPECT_FALSE(SymbolicTile::FromIndexingMap(indexing_map).has_value());\n }\n@@ -855,7 +859,7 @@ TEST_F(SymbolicTileTest, CanDeriveTileWhenTheIndexingMapHasSymbolsInASum) {\n   // https://github.com/google/paxml/blob/91893818862645f5e9f23b84f530e611551745f6/paxml/contrib/gpu/scripts_gpu/configs.py#L107-L120.\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0, d1, d2)[s0] -> (d0, d1, d2 * 128 + s0)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {4, 2048, 393}, {128});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),\n@@ -872,7 +876,7 @@ TEST_F(SymbolicTileTest, ResultingConstraintsAreSimplifiedAway) {\n   // https://github.com/google/paxml/blob/91893818862645f5e9f23b84f530e611551745f6/paxml/contrib/gpu/scripts_gpu/configs.py#L107-L120.\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0, d1, d2)[s0] -> (d0, d1, d2 * 128 + s0)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {4, 2048, 393}, {128});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),\n@@ -886,7 +890,8 @@ TEST_F(SymbolicTileTest, ResultingConstraintsAreSimplifiedAway) {\n \n TEST_F(SymbolicTileTest, PointDimensionsAreNotSimplified) {\n   IndexingMap indexing_map = IndexingMap::FromTensorSizes(\n-      ParseAffineMap(\"(d0) -> (d0)\", &mlir_context_), /*dim_upper_bounds=*/{1},\n+      ParseAffineMap(\"(d0) -> (d0)\", &symbolic_expr_context_),\n+      /*dim_upper_bounds=*/{1},\n       /*symbol_upper_bounds=*/{});\n \n   EXPECT_THAT(SymbolicTile::FromIndexingMap(indexing_map),"
        },
        {
            "sha": "9861a0e6c63fe2ecef11f924bebfe2182e0fd925",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_fusion_instruction_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_fusion_instruction_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_fusion_instruction_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_fusion_instruction_test.cc?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/platform/status_matchers.h\"\n #include \"xla/xla_data.pb.h\"\n@@ -36,6 +37,7 @@ using ::testing::HasSubstr;\n class TiledHloFusionInstructionTest : public HloHardwareIndependentTestBase {\n  public:\n   mlir::MLIRContext mlir_context_;\n+  gpu::SymbolicExprContext symbolic_expr_context_{&mlir_context_};\n };\n \n TEST_F(TiledHloFusionInstructionTest,\n@@ -46,7 +48,7 @@ TEST_F(TiledHloFusionInstructionTest,\n \n   IndexingMap tile_offsets_indexing = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0) -> (d0 floordiv 16, (d0 mod 16) * 16)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       /*dim_upper_bounds=*/{8},\n       /*symbol_upper_bounds=*/{});\n "
        },
        {
            "sha": "86b41c52fb671d7d1fcbae3fc3a02bbe36c44db0",
            "filename": "third_party/xla/xla/codegen/tiling/tiled_hlo_instruction_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_instruction_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_instruction_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Ftiling%2Ftiled_hlo_instruction_test.cc?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"xla/hlo/analysis/indexing_test_utils.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/platform/status_matchers.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -38,6 +39,7 @@ using ::tsl::testing::IsOk;\n class TiledHloInstructionTest : public HloHardwareIndependentTestBase {\n  public:\n   mlir::MLIRContext mlir_context_;\n+  gpu::SymbolicExprContext symbolic_expr_context_{&mlir_context_};\n };\n \n TEST_F(TiledHloInstructionTest, TileSizesAndStridesShouldMatchHloShapeRank) {\n@@ -47,7 +49,7 @@ TEST_F(TiledHloInstructionTest, TileSizesAndStridesShouldMatchHloShapeRank) {\n \n   IndexingMap tile_offsets_indexing = IndexingMap::FromTensorSizes(\n       ParseAffineMap(\"(d0) -> (d0 floordiv 16, (d0 mod 16) * 16)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       /*dim_upper_bounds=*/{8},\n       /*symbol_upper_bounds=*/{});\n \n@@ -75,7 +77,7 @@ TEST_F(TiledHloInstructionTest,\n       ShapeUtil::MakeShape(PrimitiveType::F32, {32, 64}), \"p0\");\n \n   IndexingMap tile_offsets_indexing = IndexingMap::FromTensorSizes(\n-      ParseAffineMap(\"(d0) -> (2 * d0)\", &mlir_context_),\n+      ParseAffineMap(\"(d0) -> (2 * d0)\", &symbolic_expr_context_),\n       /*dim_upper_bounds=*/{2},\n       /*symbol_upper_bounds=*/{});\n \n@@ -90,7 +92,7 @@ TEST_F(TiledHloInstructionTest,\n           \"must have the same number of results as the rank of the hlo shape\"));\n \n   IndexingMap tile_offsets_indexing2 = IndexingMap::FromTensorSizes(\n-      ParseAffineMap(\"(d0, d1) -> (d0, d1)\", &mlir_context_),\n+      ParseAffineMap(\"(d0, d1) -> (d0, d1)\", &symbolic_expr_context_),\n       /*dim_upper_bounds=*/{8, 4},\n       /*symbol_upper_bounds=*/{});\n \n@@ -117,12 +119,12 @@ TEST_F(TiledHloInstructionTest,\n           /*tile_sizes=*/{16},\n           /*tile_strides=*/{1},\n           IndexingMap::FromTensorSizes(\n-              ParseAffineMap(\"(d0) -> (d0)\", &mlir_context_),\n+              ParseAffineMap(\"(d0) -> (d0)\", &symbolic_expr_context_),\n               /*dim_upper_bounds=*/{4},\n               /*symbol_upper_bounds=*/{})));\n \n   IndexingMap indexing_map(\n-      ParseAffineMap(\"(d0)[rt0] -> (d0 + rt0)\", &mlir_context_),\n+      ParseAffineMap(\"(d0)[rt0] -> (d0 + rt0)\", &symbolic_expr_context_),\n       /*dimensions=*/\n       {IndexingMap::Variable{0, 32, \"d0\"}},\n       /*range_vars=*/{},"
        },
        {
            "sha": "f9aa1dc2f1586d1130cece0824e1c05067de41fb",
            "filename": "third_party/xla/xla/hlo/analysis/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -694,6 +694,7 @@ xla_cc_test(\n         \":interval\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:verified_hlo_module\",\n+        \"//xla/service/gpu/model/experimental:symbolic_expr\",\n         \"//xla/tests:xla_internal_test_main\",\n         \"@com_google_absl//absl/hash:hash_testing\",\n         \"@com_google_absl//absl/strings:string_view\",\n@@ -732,6 +733,7 @@ cc_library(\n         \"//xla:status_macros\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:verified_hlo_module\",\n+        \"//xla/service/gpu/model/experimental:symbolic_expr\",\n         \"//xla/tests:hlo_test_base\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\","
        },
        {
            "sha": "68cf172419c6510c376a9b069108aaf65a71f5b9",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_map_test.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 31,
            "changes": 76,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_map_test.cc?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -36,6 +36,7 @@ limitations under the License.\n #include \"xla/hlo/analysis/interval.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/hlo/testlib/verified_hlo_module.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n #include \"tsl/platform/statusor.h\"\n #include \"tsl/platform/test.h\"\n \n@@ -48,13 +49,17 @@ using ::testing::ElementsAre;\n \n class IndexingMapTest : public HloHardwareIndependentTestBase {\n  public:\n+  IndexingMapTest() : symbolic_expr_context_(&mlir_context_) {}\n+\n   IndexingMap Parse(absl::string_view indexing_map_str) {\n-    auto indexing_map = ParseIndexingMap(indexing_map_str, &mlir_context_);\n+    auto indexing_map = ParseIndexingMap(\n+        indexing_map_str, symbolic_expr_context_.GetMLIRContext());\n     EXPECT_TRUE(indexing_map.has_value());\n     return *indexing_map;\n   }\n \n   mlir::MLIRContext mlir_context_;\n+  gpu::SymbolicExprContext symbolic_expr_context_;\n };\n \n std::vector<bool> ConvertToSTL(const llvm::SmallBitVector& bit_vector) {\n@@ -90,7 +95,7 @@ TEST_F(IndexingMapTest, VariableKind) {\n \n TEST_F(IndexingMapTest, VerifyDimensions) {\n   auto indexing_map = IndexingMap::FromTensorSizes(\n-      ParseAffineMap(\"(d0) -> (d0)\", &mlir_context_),\n+      ParseAffineMap(\"(d0) -> (d0)\", &symbolic_expr_context_),\n       /*dim_upper_bounds=*/{10, 10}, /*symbol_upper_bounds=*/{});\n \n   std::stringstream ss;\n@@ -102,7 +107,7 @@ TEST_F(IndexingMapTest, VerifyDimensions) {\n \n TEST_F(IndexingMapTest, VerifySymbols) {\n   auto indexing_map = IndexingMap::FromTensorSizes(\n-      ParseAffineMap(\"(d0) -> (d0)\", &mlir_context_),\n+      ParseAffineMap(\"(d0) -> (d0)\", &symbolic_expr_context_),\n       /*dim_upper_bounds=*/{10}, /*symbol_upper_bounds=*/{10});\n \n   std::stringstream ss;\n@@ -115,7 +120,7 @@ TEST_F(IndexingMapTest, VerifySymbols) {\n TEST_F(IndexingMapTest, RTVar) {\n   IndexingMap indexing_map(\n       ParseAffineMap(\"(d0, d1)[range, rt0, rt1] -> (d1, d0, range + rt0, rt1)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {IndexingMap::Variable{0, 99, \"d0\"}, IndexingMap::Variable{0, 43, \"d1\"}},\n       {IndexingMap::Variable{-99, 99, \"range\"}},\n       {IndexingMap::Variable{Interval{0, 2}},\n@@ -142,8 +147,10 @@ TEST_F(IndexingMapTest, EvaluateIgnoresDomainRanges) {\n   )\");\n \n   auto results = indexing_map.Evaluate(\n-      mlir::getAffineConstantExprs({1, 2}, &mlir_context_),\n-      mlir::getAffineConstantExprs({3, 4}, &mlir_context_));\n+      mlir::getAffineConstantExprs({1, 2},\n+                                   symbolic_expr_context_.GetMLIRContext()),\n+      mlir::getAffineConstantExprs({3, 4},\n+                                   symbolic_expr_context_.GetMLIRContext()));\n \n   EXPECT_THAT(results, ElementsAre(2, 1, 4, 3));\n }\n@@ -159,16 +166,20 @@ TEST_F(IndexingMapTest, ConstraintsSatisfied) {\n   )\");\n \n   auto feasible = indexing_map.ConstraintsSatisfied(\n-      mlir::getAffineConstantExprs({1, 2}, &mlir_context_),\n-      mlir::getAffineConstantExprs({3, 4}, &mlir_context_));\n+      mlir::getAffineConstantExprs({1, 2},\n+                                   symbolic_expr_context_.GetMLIRContext()),\n+      mlir::getAffineConstantExprs({3, 4},\n+                                   symbolic_expr_context_.GetMLIRContext()));\n   EXPECT_TRUE(feasible);\n \n-  indexing_map.AddConstraint(ParseAffineExpr(\"s0 mod 4\", &mlir_context_),\n-                             Interval{0, 0});\n+  indexing_map.AddConstraint(\n+      ParseAffineExpr(\"s0 mod 4\", &symbolic_expr_context_), Interval{0, 0});\n \n   auto infeasible = indexing_map.ConstraintsSatisfied(\n-      mlir::getAffineConstantExprs({1, 2}, &mlir_context_),\n-      mlir::getAffineConstantExprs({5, 4}, &mlir_context_));\n+      mlir::getAffineConstantExprs({1, 2},\n+                                   symbolic_expr_context_.GetMLIRContext()),\n+      mlir::getAffineConstantExprs({5, 4},\n+                                   symbolic_expr_context_.GetMLIRContext()));\n   EXPECT_FALSE(infeasible);\n }\n \n@@ -283,13 +294,13 @@ TEST_F(IndexingMapTest, Composition_RTVar) {\n   IndexingMap producer(\n       ParseAffineMap(\n           \"(d0, d1, d2)[rt0, rt1, rt2] -> (d0 + rt0, d1 + rt1, d2 + rt2)\",\n-          &mlir_context_),\n+          &symbolic_expr_context_),\n       {IndexingMap::Variable{{0, 0}}, IndexingMap::Variable{{0, 1}},\n        IndexingMap::Variable{{0, 226}}},\n       {}, std::move(rt_vars));\n \n   IndexingMap consumer(\n-      ParseAffineMap(\"(d0, d1)[s] -> (0, d1, s)\", &mlir_context_),\n+      ParseAffineMap(\"(d0, d1)[s] -> (0, d1, s)\", &symbolic_expr_context_),\n       {IndexingMap::Variable{0, 0}, IndexingMap::Variable{0, 1}},\n       {IndexingMap::Variable{0, 31, \"s\"}}, {});\n \n@@ -309,15 +320,15 @@ TEST_F(IndexingMapTest, Composition_RTVar) {\n TEST_F(IndexingMapTest, Composition_OnlyRTVars) {\n   IndexingMap producer(\n       ParseAffineMap(\"(d0, d1)[s0, s1] -> (d0 + s0, d1 + 4 * s1)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {IndexingMap::Variable{0, 24}, IndexingMap::Variable{0, 15}}, {},\n       {IndexingMap::Variable{Interval{0, 2}, \"ps_0\"},\n        IndexingMap::Variable{Interval{0, 1}, \"ps_1\"}});\n \n   std::vector<IndexingMap::Variable> consumer_rt_vars;\n   IndexingMap consumer(\n       ParseAffineMap(\"(d0, d1)[s0, s1] -> (d0 + 2 * s0, d1 + 3 * s1)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {IndexingMap::Variable{0, 24}, IndexingMap::Variable{0, 15}}, {},\n       {IndexingMap::Variable{Interval{0, 25}, \"cs_0\"},\n        IndexingMap::Variable{Interval{0, 16}, \"cs_1\"}});\n@@ -477,14 +488,15 @@ TEST_F(IndexingMapTest, RemoveUnusedSymbols_ConstraintsWithManySymbols) {\n TEST_F(IndexingMapTest, RemoveUnusedSymbols_ConstraintsWithRTVars) {\n   IndexingMap indexing_map(\n       ParseAffineMap(\"(d0)[s0, s1, s2, s3, s4] -> (d0 * 4 + s1 + s3 - 42)\",\n-                     &mlir_context_),\n+                     &symbolic_expr_context_),\n       {IndexingMap::Variable{{0, 31}}},\n       {IndexingMap::Variable{{0, 0}}, IndexingMap::Variable{{0, 1}},\n        IndexingMap::Variable{{0, 2}}},\n       {IndexingMap::Variable{Interval{0, 3}},\n        IndexingMap::Variable{Interval{0, 4}}});\n   indexing_map.AddConstraint(\n-      ParseAffineExpr(\"d0 * 4 + s1 + s3\", &mlir_context_), Interval{24, 459});\n+      ParseAffineExpr(\"d0 * 4 + s1 + s3\", &symbolic_expr_context_),\n+      Interval{24, 459});\n   indexing_map.RemoveUnusedSymbols();\n   // Symbols s0, s2, s4 will be removed and s1 and s3 will become s0 and s1.\n   EXPECT_THAT(indexing_map, MatchIndexingMap(R\"(\n@@ -572,13 +584,13 @@ TEST_F(IndexingMapTest, ConvertSymbolsToDimensions) {\n   IndexingMap indexing_map(\n       ParseAffineMap(\n           \"(d0)[s0, s1, s2, s3] -> (d0 * 4 + s0 + s1 + 2 * s2 + 3 * s3 - 42)\",\n-          &mlir_context_),\n+          &symbolic_expr_context_),\n       {IndexingMap::Variable{{0, 31}}},\n       {IndexingMap::Variable{{0, 0}}, IndexingMap::Variable{{0, 1}}},\n       {IndexingMap::Variable{Interval{0, 3}},\n        IndexingMap::Variable{Interval{0, 4}}});\n   indexing_map.AddConstraint(\n-      ParseAffineExpr(\"d0 * 4 + s0 + 2 * s2\", &mlir_context_),\n+      ParseAffineExpr(\"d0 * 4 + s0 + 2 * s2\", &symbolic_expr_context_),\n       Interval{24, 459});\n   EXPECT_THAT(indexing_map.ConvertSymbolsToDimensions(), MatchIndexingMap(R\"(\n       (d0, d1, d2, d3, d4) -> (d0 * 4 + d1 + d2 + d3 * 2 + d4 * 3 - 42),\n@@ -1324,13 +1336,14 @@ TEST_F(IndexingMapTest,\n   // important for now.\n   EXPECT_THAT(\n       std::make_tuple(result3, constraint_expr, constraint_interval),\n-      AnyOf(\n-          std::make_tuple(ParseAffineExpr(\"s0 * 6 + 3\", &mlir_context_),\n-                          ParseAffineExpr(\"(s0 * 6 + 3) mod 7\", &mlir_context_),\n-                          Interval{5, 5}),\n-          std::make_tuple(ParseAffineExpr(\"s0 * 7 + 5\", &mlir_context_),\n-                          ParseAffineExpr(\"(s0 * 7 + 5) mod 6\", &mlir_context_),\n-                          Interval{3, 3})));\n+      AnyOf(std::make_tuple(\n+                ParseAffineExpr(\"s0 * 6 + 3\", &symbolic_expr_context_),\n+                ParseAffineExpr(\"(s0 * 6 + 3) mod 7\", &symbolic_expr_context_),\n+                Interval{5, 5}),\n+            std::make_tuple(\n+                ParseAffineExpr(\"s0 * 7 + 5\", &symbolic_expr_context_),\n+                ParseAffineExpr(\"(s0 * 7 + 5) mod 6\", &symbolic_expr_context_),\n+                Interval{3, 3})));\n }\n \n TEST_F(IndexingMapTest, RescaleSymbolsKeepsHashmapConsistent) {\n@@ -1361,9 +1374,10 @@ TEST_F(IndexingMapTest, RangeEvaluatorTest) {\n     d2 in [-1, 2],\n     d3 in [0, 0]\n   )\");\n-  RangeEvaluator range_evaluator(indexing_map, &mlir_context_);\n+  RangeEvaluator range_evaluator(indexing_map,\n+                                 symbolic_expr_context_.GetMLIRContext());\n   mlir::AffineExpr d0, d1, d2, d3;\n-  bindDims(&mlir_context_, d0, d1, d2, d3);\n+  bindDims(symbolic_expr_context_.GetMLIRContext(), d0, d1, d2, d3);\n \n   // d0 is always positive.\n   EXPECT_TRUE(range_evaluator.IsAlwaysPositiveOrZero(d0));\n@@ -1507,15 +1521,15 @@ TEST_F(IndexingMapTest, IndexingMapSupportsAbslHashAndEqAndNe) {\n       )\"),\n        IndexingMap(\n            ParseAffineMap(\"(d0)[s0, s1, s2, s3, s4] -> (d0 * 4 + s1 + s3 - 42)\",\n-                          &mlir_context_),\n+                          &symbolic_expr_context_),\n            {IndexingMap::Variable{{0, 31}}},\n            {IndexingMap::Variable{{0, 0}}, IndexingMap::Variable{{0, 1}},\n             IndexingMap::Variable{{0, 2}}},\n            {IndexingMap::Variable{Interval{0, 3}},\n             IndexingMap::Variable{Interval{0, 4}}}),\n        IndexingMap(\n            ParseAffineMap(\"(d0)[s0, s1, s2, s3, s4] -> (d0 * 4 + s1 + s3 - 42)\",\n-                          &mlir_context_),\n+                          &symbolic_expr_context_),\n            {IndexingMap::Variable{{0, 31}}},\n            {IndexingMap::Variable{{0, 0}}, IndexingMap::Variable{{0, 1}},\n             IndexingMap::Variable{{0, 2}}},"
        },
        {
            "sha": "72ebd9c3099ecd1b4017649281b571749ad0cf29",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_test_utils.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 12,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_test_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_test_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_test_utils.cc?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -44,6 +44,7 @@ limitations under the License.\n #include \"xla/hlo/analysis/indexing_analysis.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n #include \"xla/status_macros.h\"\n #include \"tsl/platform/errors.h\"\n \n@@ -72,20 +73,22 @@ HloInstruction* IndexingTestBase::ParseAndGetRoot(\n \n HloInstructionIndexing IndexingTestBase::GetOutputToInputIndexing(\n     const HloInstruction* instr, int output_id, bool use_physical_layout) {\n-  HloInstructionIndexing indexing =\n-      ComputeOutputToInputIndexing(instr, output_id, &mlir_context_);\n+  HloInstructionIndexing indexing = ComputeOutputToInputIndexing(\n+      instr, output_id, symbolic_expr_context_.GetMLIRContext());\n \n   if (!use_physical_layout) {\n     return indexing;\n   }\n \n   IndexingMap output_permutation = GetIndexingMapFromPhysicalLayoutToLogical(\n-      GetOutputShape(instr, output_id), &mlir_context_);\n+      GetOutputShape(instr, output_id),\n+      symbolic_expr_context_.GetMLIRContext());\n \n   for (const auto& [operand_id, indexing_maps] :\n        llvm::enumerate(indexing.indexing_maps)) {\n     IndexingMap operand_permutation = GetIndexingMapFromLogicalToPhysicalLayout(\n-        instr->operand(operand_id)->shape(), &mlir_context_);\n+        instr->operand(operand_id)->shape(),\n+        symbolic_expr_context_.GetMLIRContext());\n \n     OperandIndexingSet operand_indexing_maps;\n     for (const OperandIndexing& indexing_map : indexing_maps) {\n@@ -107,22 +110,24 @@ HloInstructionIndexing IndexingTestBase::GetOutputToInputIndexing(\n \n HloInstructionIndexing IndexingTestBase::GetInputToOutputIndexing(\n     const HloInstruction* instr, int input_id, bool use_physical_layout) {\n-  HloInstructionIndexing indexing =\n-      ComputeInputToOutputIndexing(instr, input_id, &mlir_context_);\n+  HloInstructionIndexing indexing = ComputeInputToOutputIndexing(\n+      instr, input_id, symbolic_expr_context_.GetMLIRContext());\n \n   if (!use_physical_layout) {\n     return indexing;\n   }\n \n   OperandIndexing input_permutation =\n       OperandIndexing(GetIndexingMapFromPhysicalLayoutToLogical(\n-          instr->operand(input_id)->shape(), &mlir_context_));\n+          instr->operand(input_id)->shape(),\n+          symbolic_expr_context_.GetMLIRContext()));\n \n   for (const auto& [output_id, indexing_maps] :\n        llvm::enumerate(indexing.indexing_maps)) {\n     OperandIndexing operand_permutation =\n         OperandIndexing(GetIndexingMapFromLogicalToPhysicalLayout(\n-            GetOutputShape(instr, output_id), &mlir_context_));\n+            GetOutputShape(instr, output_id),\n+            symbolic_expr_context_.GetMLIRContext()));\n \n     OperandIndexingSet operand_indexing_maps;\n     for (const OperandIndexing& indexing_map : indexing_maps) {\n@@ -143,24 +148,26 @@ HloInstructionIndexing IndexingTestBase::GetInputToOutputIndexing(\n }\n \n AffineMap ParseAffineMap(absl::string_view serialized_affine_map,\n-                         MLIRContext* context) {\n+                         gpu::SymbolicExprContext* symbolic_expr_context) {\n   std::string full_affine_map_string =\n       absl::StrCat(\"affine_map<\", serialized_affine_map, \">\");\n   return mlir::cast<mlir::AffineMapAttr>(\n-             mlir::parseAttribute(full_affine_map_string, context))\n+             mlir::parseAttribute(full_affine_map_string,\n+                                  symbolic_expr_context->GetMLIRContext()))\n       .getValue();\n }\n \n // Since MLIR does not have AffineExprAttr, we construct an AffineMap and then\n // retrieve its first result.\n AffineExpr ParseAffineExpr(absl::string_view serialized_affine_expr,\n-                           MLIRContext* context) {\n+                           gpu::SymbolicExprContext* symbolic_expr_context) {\n   std::string full_affine_map_string = absl::StrCat(\n       \"affine_map<(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9)\"\n       \"[s0, s1, s2, s3, s4, s5, s6, s7, s8, s9] -> (\",\n       serialized_affine_expr, \")>\");\n   return mlir::cast<mlir::AffineMapAttr>(\n-             mlir::parseAttribute(full_affine_map_string, context))\n+             mlir::parseAttribute(full_affine_map_string,\n+                                  symbolic_expr_context->GetMLIRContext()))\n       .getValue()\n       .getResult(0);\n }"
        },
        {
            "sha": "349bb703f80d74ecac7bc3db3eec0c17b1f12efe",
            "filename": "third_party/xla/xla/hlo/analysis/indexing_test_utils.h",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_test_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_test_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Findexing_test_utils.h?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -28,12 +28,12 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/AffineMap.h\"\n-#include \"mlir/IR/MLIRContext.h\"\n #include \"xla/hlo/analysis/indexing_analysis.h\"\n #include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/analysis/indexing_map_serialization.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/testlib/verified_hlo_module.h\"\n+#include \"xla/service/gpu/model/experimental/symbolic_expr.h\"\n #include \"xla/tests/hlo_test_base.h\"\n \n namespace xla {\n@@ -68,6 +68,8 @@ MATCHER_P(MatchIndexingString, indexing_string, \"\") {\n \n class IndexingTestBase : public HloTestBase {\n  public:\n+  IndexingTestBase() : symbolic_expr_context_(&mlir_context_) {}\n+\n   HloInstruction* ParseAndGetRoot(absl::string_view hlo_string);\n \n   HloInstructionIndexing GetOutputToInputIndexing(\n@@ -79,24 +81,26 @@ class IndexingTestBase : public HloTestBase {\n       bool use_physical_layout = false);\n \n   mlir::MLIRContext mlir_context_;\n+  gpu::SymbolicExprContext symbolic_expr_context_;\n   std::unique_ptr<VerifiedHloModule> module_;\n };\n \n HloInstructionIndexing ComputeOutputToInputIndexingForEntryComputation(\n-    HloTestBase* test_base, mlir::MLIRContext* mlir_context,\n+    HloTestBase* test_base, gpu::SymbolicExprContext* symbolic_expr_context,\n     absl::string_view hlo_string, int output_id = 0,\n     bool use_physical_layout = false);\n \n HloInstructionIndexing ComputeInputToOutputIndexingForEntryComputation(\n-    HloTestBase* test_base, mlir::MLIRContext* mlir_context,\n+    HloTestBase* test_base, gpu::SymbolicExprContext* symbolic_expr_context,\n     absl::string_view hlo_string, int input_id = 0,\n     bool use_physical_layout = false);\n \n mlir::AffineMap ParseAffineMap(absl::string_view serialized_affine_map,\n-                               mlir::MLIRContext* context);\n+                               gpu::SymbolicExprContext* symbolic_expr_context);\n \n-mlir::AffineExpr ParseAffineExpr(absl::string_view serialized_affine_expr,\n-                                 mlir::MLIRContext* context);\n+mlir::AffineExpr ParseAffineExpr(\n+    absl::string_view serialized_affine_expr,\n+    gpu::SymbolicExprContext* symbolic_expr_context);\n \n // Safely evaluates the given expression, returning nullopt if the result is\n // undefined (due to undefined behavior, e.g. division by zero or overflow)."
        },
        {
            "sha": "38e924b13c0b9d33e23ef1ae95fc241f9f4e7013",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8b3dacfdfaaf718322e1a68765d0f2c857aafa78/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD?ref=8b3dacfdfaaf718322e1a68765d0f2c857aafa78",
            "patch": "@@ -1,6 +1,7 @@\n load(\"@rules_cc//cc:cc_library.bzl\", \"cc_library\")\n load(\"//xla:xla.default.bzl\", \"xla_cc_test\")\n load(\"//xla/tsl:tsl.bzl\", \"internal_visibility\")\n+load(\"//xla/tsl:tsl.default.bzl\", \"get_compatible_with_portable\")\n \n package(\n     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n@@ -239,6 +240,7 @@ cc_library(\n     name = \"symbolic_expr\",\n     srcs = [\"symbolic_expr.cc\"],\n     hdrs = [\"symbolic_expr.h\"],\n+    compatible_with = get_compatible_with_portable(),\n     deps = [\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log\","
        }
    ],
    "stats": {
        "total": 189,
        "additions": 115,
        "deletions": 74
    }
}