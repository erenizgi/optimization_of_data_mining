{
    "author": "nvgrw",
    "message": "Introduce split compilation fail duplicate load feature.\n\nIt is rare that tests load the same executable twice for a given test. That's\nwhy we're introducing a new feature that explictly fails a duplicate load so\nthat we can catch instances of fingerprint collisions that may have previously\ngone unnoticed.\n\nPiperOrigin-RevId: 829066630",
    "sha": "ea9f8804e917315408ea9fbfd9044e33a0e556fe",
    "files": [
        {
            "sha": "b57165983799dadcd35a76f0f5c7fcaef512bc2b",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=ea9f8804e917315408ea9fbfd9044e33a0e556fe",
            "patch": "@@ -4477,6 +4477,7 @@ cc_library(\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:nullability\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:die_if_null\",\n         \"@com_google_absl//absl/status\",\n@@ -4507,7 +4508,9 @@ xla_cc_test(\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\","
        },
        {
            "sha": "653d052352cc29148fe6871b1f4249afa1973968",
            "filename": "third_party/xla/xla/service/hlo_runner_pjrt.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt.cc?ref=ea9f8804e917315408ea9fbfd9044e33a0e556fe",
            "patch": "@@ -944,6 +944,29 @@ ExecutePhaseHloRunnerPjRt::CreateExecutable(std::unique_ptr<HloModule> module,\n   }\n   LOG(INFO) << \"ExecutePhase deserializing \" << module->name() << \" from \"\n             << filename;\n+\n+  // If fail_duplicate_loads_ is enabled, fail if we previously loaded an\n+  // executable at this path, and the file at this path exists.\n+  if (fail_duplicate_loads_) {\n+    if (const auto [unused_it, did_insert] =\n+            loaded_executable_paths_.insert(path);\n+        !did_insert) {\n+      return absl::InvalidArgumentError(absl::StrFormat(\n+          \"ExecutePhaseHloRunnerPjRt::CreateExecutable called with a module \"\n+          \"that loads an executable that was previously loaded. The module \"\n+          \"name is %s and the filename is %s. If this is intentional, please \"\n+          \"set fail_duplicate_loads to false. This error exists to snuff out \"\n+          \"accidental duplicate loads originating from fingerprint collisions. \"\n+          \"If you intended to load two different executables, this error \"\n+          \"indicates that their fingerprints are the same. If you wish to \"\n+          \"avoid this issue in a test, you can either force their fingerprints \"\n+          \"to be different through some superficial change in the module (e.g. \"\n+          \"the module name), or by disabling split compilation by setting \"\n+          \"precompile_test = False in the corresponding xla_test.\",\n+          module->name(), filename));\n+    }\n+  }\n+\n   return DeserializeExecutable(serialized_executable);\n }\n "
        },
        {
            "sha": "7a15edf5596af13161319062bef7445601eea9d3",
            "filename": "third_party/xla/xla/service/hlo_runner_pjrt.h",
            "status": "modified",
            "additions": 16,
            "deletions": 4,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt.h?ref=ea9f8804e917315408ea9fbfd9044e33a0e556fe",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/base/nullability.h\"\n+#include \"absl/container/flat_hash_set.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -189,25 +190,36 @@ class CompilePhaseHloRunnerPjRt : public HloRunnerPjRt {\n };\n \n // This class works just like a HloRunnerPjRt, but it only runs execution\n-// (reading the executable from disk) and does not compile the executable.  If\n-// `compile_if_not_found` is true, this class will attempt to compile the\n+// (reading the executable from disk) and does not compile the executable.\n+//\n+// If `compile_if_not_found` is true, this class will attempt to compile the\n // executable if the serialized version from the compile phase could not be\n // found. This effectively makes this class equivalent to HloRunnerPjRt.\n+//\n+// If `fail_duplicate_loads` is true, calls to CreateExecutable will fail if the\n+// executable was previously loaded using the same runner. Most tests do not\n+// need to load an executable more than once and setting this can help catch\n+// instances where e.g. fingerprints are colliding.\n class ExecutePhaseHloRunnerPjRt : public HloRunnerPjRt {\n  public:\n   ExecutePhaseHloRunnerPjRt(std::unique_ptr<PjRtClient> pjrt_client,\n                             absl::string_view artifact_dir,\n-                            bool compile_if_not_found = true)\n+                            bool compile_if_not_found = true,\n+                            bool fail_duplicate_loads = true)\n       : HloRunnerPjRt(std::move(pjrt_client)),\n         artifact_dir_(artifact_dir),\n-        compile_if_not_found_(compile_if_not_found) {}\n+        compile_if_not_found_(compile_if_not_found),\n+        fail_duplicate_loads_(fail_duplicate_loads) {}\n \n   absl::StatusOr<std::unique_ptr<OpaqueExecutable>> CreateExecutable(\n       std::unique_ptr<HloModule> module, bool run_hlo_passes) override;\n \n  private:\n   std::string artifact_dir_;\n   bool compile_if_not_found_;\n+  bool fail_duplicate_loads_;\n+\n+  absl::flat_hash_set<std::string> loaded_executable_paths_;\n };\n \n }  // namespace xla"
        },
        {
            "sha": "bef7797b6216e743fb42cbc6e0cccc3a1ad2c3fa",
            "filename": "third_party/xla/xla/service/hlo_runner_pjrt_test.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ea9f8804e917315408ea9fbfd9044e33a0e556fe/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fhlo_runner_pjrt_test.cc?ref=ea9f8804e917315408ea9fbfd9044e33a0e556fe",
            "patch": "@@ -40,14 +40,19 @@ limitations under the License.\n #include \"xla/service/hlo_runner_interface.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/status_matchers.h\"\n #include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n #include \"xla/util.h\"\n #include \"tsl/platform/fingerprint.h\"\n #include \"tsl/platform/path.h\"\n \n namespace xla {\n namespace {\n \n+using ::absl_testing::StatusIs;\n+using ::testing::StartsWith;\n+\n class FakeClient : public PjRtClient {\n  public:\n   class Executable : public PjRtExecutable {\n@@ -189,5 +194,36 @@ TEST_F(ExecutePhaseHloRunnerPjRtTest, CreateExecutableReadsFileCorrectly) {\n   ASSERT_EQ(*serialized_representation_read, \"hello world\");\n }\n \n+TEST_F(ExecutePhaseHloRunnerPjRtTest,\n+       CreateExecutableFailsOnDuplicateLoadIfFeatureEnabled) {\n+  TF_ASSERT_OK(tsl::WriteStringToFile(\n+      tsl::Env::Default(),\n+      tsl::io::JoinPath(artifact_dir_, kModuleSerializedName), \"hello world\"));\n+  ExecutePhaseHloRunnerPjRt runner(std::make_unique<FakeClient>(),\n+                                   artifact_dir_);\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> m, CreateFakeModule());\n+  TF_ASSERT_OK(runner.CreateExecutable(m->Clone(\"\"), /*run_hlo_passes=*/false));\n+  EXPECT_THAT(\n+      runner.CreateExecutable(std::move(m), /*run_hlo_passes=*/false),\n+      StatusIs(\n+          absl::StatusCode::kInvalidArgument,\n+          StartsWith(\n+              \"ExecutePhaseHloRunnerPjRt::CreateExecutable called with a \"\n+              \"module that loads an executable that was previously loaded.\")));\n+}\n+\n+TEST_F(ExecutePhaseHloRunnerPjRtTest,\n+       CreateExecutableSucceedsOnDuplicateLoadIfFeatureDisabled) {\n+  TF_ASSERT_OK(tsl::WriteStringToFile(\n+      tsl::Env::Default(),\n+      tsl::io::JoinPath(artifact_dir_, kModuleSerializedName), \"hello world\"));\n+  ExecutePhaseHloRunnerPjRt runner(\n+      std::make_unique<FakeClient>(), artifact_dir_,\n+      /*compile_if_not_found=*/false, /*fail_duplicate_loads=*/false);\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> m, CreateFakeModule());\n+  TF_ASSERT_OK(runner.CreateExecutable(m->Clone(\"\"), /*run_hlo_passes=*/false));\n+  TF_EXPECT_OK(runner.CreateExecutable(std::move(m), /*run_hlo_passes=*/false));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 82,
        "additions": 78,
        "deletions": 4
    }
}