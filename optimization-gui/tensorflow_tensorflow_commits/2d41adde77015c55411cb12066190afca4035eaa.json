{
    "author": "pschuh",
    "message": "Require all AbstractTrackedDeviceBuffer subclasses to provide a raw_buffer and remove the virtual GetRawBuffer().\n\nPiperOrigin-RevId: 834546396",
    "sha": "2d41adde77015c55411cb12066190afca4035eaa",
    "files": [
        {
            "sha": "949eb1abb94f8b98a9c1b5595f54bed2d95ee15d",
            "filename": "third_party/xla/xla/pjrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -193,6 +193,7 @@ xla_cc_test(\n         \"//xla/stream_executor:device_memory_allocator\",\n         \"//xla/tsl/concurrency:async_value\",\n         \"//xla/tsl/concurrency:ref_count\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\","
        },
        {
            "sha": "554bd8cdd8b0a86201cb05f940b61e3b20e285ef",
            "filename": "third_party/xla/xla/pjrt/abstract_tracked_device_buffer.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -289,7 +289,7 @@ absl::Status CommonPjRtBuffer::AcquireScopedRawBuffer(\n   TF_ASSIGN_OR_RETURN(\n       auto device_event,\n       std::move(scoped_acquire)(\n-          device_buffer.buffer()->GetRawBuffer(memory_space_),\n+          device_buffer.buffer()->raw_buffer(),\n           device_buffer.buffer()->GetAsyncValueDefinitionEvents()));\n   device_buffer.ConvertUsageHold(std::move(device_event));\n   return absl::OkStatus();"
        },
        {
            "sha": "d900cdc664fc8d6718778761149aff706d2772ee",
            "filename": "third_party/xla/xla/pjrt/abstract_tracked_device_buffer.h",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -39,16 +39,20 @@ namespace xla {\n class AbstractTrackedDeviceBuffer {\n  public:\n   virtual ~AbstractTrackedDeviceBuffer() = default;\n+  explicit AbstractTrackedDeviceBuffer(\n+      tsl::RCReference<CommonPjRtRawBuffer> raw_buffer)\n+      : raw_buffer_(std::move(raw_buffer)) {}\n \n   // Construct (or return) a vector of tsl::AsyncValue events which\n   // will become ready when this buffer is ready.\n   virtual std::vector<tsl::RCReference<tsl::AsyncValue>>\n   GetAsyncValueDefinitionEvents() = 0;\n \n-  // Construct (or return) a raw buffer which aliases the same\n+  // Returns a raw buffer which aliases the same\n   // underlying memory as this AbstractTrackedDeviceBuffer.\n-  virtual tsl::RCReference<CommonPjRtRawBuffer> GetRawBuffer(\n-      PjRtMemorySpace* memory_space) = 0;\n+  tsl::RCReference<CommonPjRtRawBuffer> raw_buffer() const {\n+    return raw_buffer_;\n+  }\n \n   // Only to be called via the result of\n   // CommonPjRtBuffer::ScopedHold::ConvertUsageHold with an optional device\n@@ -93,6 +97,14 @@ class AbstractTrackedDeviceBuffer {\n     return absl::UnimplementedError(\n         \"WaitUntilBufferReadyOnStream is only implemented for GPU.\");\n   }\n+\n+ protected:\n+  void ReleaseDeviceMemory() {\n+    raw_buffer_ = tsl::RCReference<CommonPjRtRawBuffer>();\n+  }\n+\n+ private:\n+  tsl::RCReference<CommonPjRtRawBuffer> raw_buffer_;\n };\n \n class CommonPjRtBuffer : public PjRtBuffer {"
        },
        {
            "sha": "6f03f432165bce3461a2efc0761215c14998ec5e",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -248,8 +248,7 @@ CommonPjRtClient::CreateAliasBuffer(const Shape& shape,\n           std::move(buffer_promise)(status).IgnoreError();\n           return status;\n         }\n-        auto status = std::move(buffer_promise)(\n-            hold.buffer()->GetRawBuffer(memory_space));\n+        auto status = std::move(buffer_promise)(hold.buffer()->raw_buffer());\n         if (!status.ok()) {\n           definition_event_promise->SetError(status);\n           return status;\n@@ -1022,7 +1021,7 @@ CommonPjRtBufferImpl::AcquireExternalReference() {\n     tsl::RCReference<CommonPjRtRawBuffer> raw_buffer_;\n   };\n \n-  auto raw_buffer = hold.buffer()->GetRawBuffer(memory_space_);\n+  auto raw_buffer = hold.buffer()->raw_buffer();\n   return std::unique_ptr<ExternalReference>(\n       std::make_unique<ScopedHoldAsExternalReference>(std::move(hold),\n                                                       std::move(raw_buffer)));\n@@ -1242,7 +1241,7 @@ CommonPjRtBufferImpl::ReleaseDeviceMemoryOwnership(\n   std::unique_ptr<PjRtBuffer::ExternalReference> ref;\n   if (device_buffer) {\n     ref = std::make_unique<RawBufferAsExternalReference>(\n-        device_buffer->GetRawBuffer(memory_space_));\n+        device_buffer->raw_buffer());\n   }\n   return ref;\n }"
        },
        {
            "sha": "1138d1a5c48a4366baeb53b95aa178caa1025bea",
            "filename": "third_party/xla/xla/pjrt/cpu/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2FBUILD?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -27,9 +27,12 @@ xla_cc_test(\n     srcs = [\"tracked_cpu_device_buffer_test.cc\"],\n     deps = [\n         \":abstract_cpu_buffer\",\n+        \":cpu_client\",\n         \":cpu_event\",\n         \"//xla:util\",\n+        \"//xla/pjrt:pjrt_client\",\n         \"//xla/tsl/concurrency:async_value\",\n+        \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/log:check\","
        },
        {
            "sha": "3a98e4200f496aff01667deee467a18df655769e",
            "filename": "third_party/xla/xla/pjrt/cpu/abstract_cpu_buffer.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 31,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fabstract_cpu_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fabstract_cpu_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fabstract_cpu_buffer.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -101,37 +101,6 @@ void PackOrCopy(PrimitiveType element_type, const LiteralSlice& literal,\n   }\n }\n \n-/*static*/ absl::StatusOr<std::unique_ptr<TrackedCpuDeviceBuffer>>\n-AbstractCpuBuffer::AllocateTrackedDeviceBuffer(\n-    const Shape& on_device_shape,\n-    absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events) {\n-  if (on_device_shape.IsTuple()) {\n-    return absl::InvalidArgumentError(\n-        absl::StrCat(\"Tuples are not supported for cpu-buffers: \",\n-                     on_device_shape.ToString()));\n-  }\n-  size_t byte_size = ShapeUtil::ByteSizeOf(on_device_shape);\n-  TF_ASSIGN_OR_RETURN(tsl::AsyncValueRef<CpuDeviceMemory> device_buffer,\n-                      CpuDeviceMemory::Allocate(byte_size));\n-  return std::make_unique<TrackedCpuDeviceBuffer>(\n-      /*owns_buffers=*/true, std::move(device_buffer),\n-      std::move(definition_events));\n-}\n-\n-/*static*/ void AbstractCpuBuffer::AllocateAvsAndEvents(\n-    const Shape& shape,\n-    absl::InlinedVector<tsl::RCReference<tsl::AsyncValue>, 4>* avs,\n-    absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4>* definition_events) {\n-  // Nested tuple shapes are not supported here.\n-  int num_leaf_buffers = shape.IsTuple() ? shape.tuple_shapes().size() : 1;\n-  for (int i = 0; i < num_leaf_buffers; ++i) {\n-    tsl::AsyncValueRef<CpuEvent> definition_event =\n-        tsl::MakeConstructedAsyncValueRef<CpuEvent>();\n-    definition_events->push_back(definition_event.CopyRef());\n-    avs->push_back(std::move(definition_event));\n-  }\n-}\n-\n /*static*/ bool AbstractCpuBuffer::BufferFromHostBufferSupportsZeroCopy(\n     const void* data, PrimitiveType type, absl::Span<int64_t const> dims,\n     std::optional<absl::Span<int64_t const>> byte_strides, const Shape& shape) {"
        },
        {
            "sha": "1be7191c37d0869098669f58f11fa00b8c2c0a92",
            "filename": "third_party/xla/xla/pjrt/cpu/abstract_cpu_buffer.h",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fabstract_cpu_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fabstract_cpu_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fabstract_cpu_buffer.h?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -78,21 +78,6 @@ class MarkEventReadyOnExit {\n \n class AbstractCpuBuffer {\n  public:\n-  // Allocates a new `TrackedCpuDeviceBuffer` with the given shape and\n-  // definition events.\n-  static absl::StatusOr<std::unique_ptr<TrackedCpuDeviceBuffer>>\n-  AllocateTrackedDeviceBuffer(\n-      const Shape& on_device_shape,\n-      absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events);\n-\n-  // Allocates new cpu events to `avs` and `definition_events`. If `shape` is a\n-  // tuple, multiple events will be allocated. Otherwise, `avs` and\n-  // `definition_events` will only contain one event.\n-  static void AllocateAvsAndEvents(\n-      const Shape& shape,\n-      absl::InlinedVector<tsl::RCReference<tsl::AsyncValue>, 4>* avs,\n-      absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4>* definition_events);\n-\n   // A helper function to determine if a BufferFromHostBuffer call is eligible\n   // for zero copy construction.\n   static bool BufferFromHostBufferSupportsZeroCopy("
        },
        {
            "sha": "c4ffc499a6ed5360da491475bd29e184d5bbe437",
            "filename": "third_party/xla/xla/pjrt/cpu/cpu_client.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 11,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Fcpu_client.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -885,12 +885,13 @@ absl::StatusOr<std::unique_ptr<PjRtBuffer>> PjRtCpuClient::CreateErrorBuffer(\n   // Create a dummy buffer because the rest of the code expects a buffer\n   // regardless of whether the definition event is an error.\n   TF_ASSIGN_OR_RETURN(\n-      auto buffer,\n-      CpuDeviceMemory::Allocate(ShapeUtil::ByteSizeOf(shape), *allocator_));\n+      auto raw_buffer,\n+      CpuRawBuffer::Allocate(memory_space, ShapeUtil::ByteSizeOf(shape),\n+                             *allocator_));\n   return std::make_unique<CommonPjRtBufferImpl>(\n       shape,\n       std::make_unique<TrackedCpuDeviceBuffer>(\n-          /*owns_buffers=*/true, std::move(buffer),\n+          /*owns_buffers=*/true, std::move(raw_buffer),\n           absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4>{\n               tsl::AsyncValueRef<CpuEvent>(\n                   tsl::MakeErrorAsyncValueRef(std::move(error)))}),\n@@ -983,13 +984,13 @@ absl::StatusOr<std::unique_ptr<PjRtBuffer>> PjRtCpuClient::DefineBuffer(\n     definition_events.push_back(\n         tsl::down_cast<CpuTrackedDeviceEvent*>(ev.get())->event());\n   }\n+  auto memory_space = raw_buffer->memory_space();\n   return std::unique_ptr<PjRtBuffer>(std::make_unique<CommonPjRtBufferImpl>(\n       on_device_shape,\n       std::make_unique<TrackedCpuDeviceBuffer>(\n-          /*owns_buffers=*/raw_buffer_is_mutable,\n-          tsl::down_cast<CpuRawBuffer*>(raw_buffer.get())->buffer(),\n+          /*owns_buffers=*/raw_buffer_is_mutable, std::move(raw_buffer),\n           ShapeUtil::ByteSizeOf(on_device_shape), std::move(definition_events)),\n-      raw_buffer->memory_space()));\n+      memory_space));\n }\n \n absl::StatusOr<tsl::RCReference<CommonPjRtRawBuffer>>\n@@ -1825,6 +1826,7 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n   // Create output buffers.\n   const Shape& result_shape = cpu_executable_->result_shape();\n   std::vector<std::unique_ptr<PjRtBuffer>> res;\n+  auto* memory_space = *device->default_memory_space();\n   if (result_shape.IsTuple()) {\n     res.reserve(result_buffers_info.size());\n     for (int i = 0; i < result_buffers_info.size(); ++i) {\n@@ -1834,24 +1836,25 @@ absl::StatusOr<PjRtLoadedExecutable::Result> PjRtCpuExecutable::ExecuteHelper(\n       auto leaf_tracked_device_buffer =\n           std::make_unique<TrackedCpuDeviceBuffer>(\n               result_buffers_info[i].owns_buffer,\n-              std::move(result_buffers_info[i].buffer),\n+              tsl::MakeRef<CpuRawBuffer>(\n+                  memory_space, std::move(result_buffers_info[i].buffer)),\n               result_buffers_info[i].buffer_size, std::move(definition_events));\n       auto leaf_buffer = std::make_unique<CommonPjRtBufferImpl>(\n           result_shape.tuple_shapes(i), std::move(leaf_tracked_device_buffer),\n-          *device->default_memory_space());\n+          memory_space);\n       res.push_back(std::move(leaf_buffer));\n     }\n   } else {\n     CHECK_EQ(result_buffers_info.size(), 1);\n     // Program execution writes to output buffers so it's a definition event.\n     auto tracked_device_buffer = std::make_unique<TrackedCpuDeviceBuffer>(\n         result_buffers_info[0].owns_buffer,\n-        std::move(result_buffers_info[0].buffer),\n+        tsl::MakeRef<CpuRawBuffer>(memory_space,\n+                                   std::move(result_buffers_info[0].buffer)),\n         result_buffers_info[0].buffer_size,\n         /*definition_event=*/execute_event);\n     auto output_buffer = std::make_unique<CommonPjRtBufferImpl>(\n-        result_shape, std::move(tracked_device_buffer),\n-        *device->default_memory_space());\n+        result_shape, std::move(tracked_device_buffer), memory_space);\n     res.push_back(std::move(output_buffer));\n   }\n "
        },
        {
            "sha": "78d53986c7db66ebb52e891efc49854304af2197",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 23,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"xla/backends/cpu/alignment.h\"\n #include \"xla/future.h\"\n+#include \"xla/pjrt/abstract_tracked_device_buffer.h\"\n #include \"xla/pjrt/common_pjrt_client.h\"\n #include \"xla/pjrt/cpu/cpu_event.h\"\n #include \"xla/pjrt/cpu/raw_buffer.h\"\n@@ -208,40 +209,51 @@ absl::Status CpuDeviceMemory::AllocateInto(\n //===----------------------------------------------------------------------===//\n \n TrackedCpuDeviceBuffer::TrackedCpuDeviceBuffer(\n-    bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+    bool owns_buffers, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n     absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events)\n-    : TrackedCpuDeviceBuffer(owns_buffers, std::move(buffer),\n+    : TrackedCpuDeviceBuffer(owns_buffers, std::move(raw_buffer),\n                              AfterAll(definition_events)) {}\n \n TrackedCpuDeviceBuffer::TrackedCpuDeviceBuffer(\n-    bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+    bool owns_buffers, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n     size_t buffer_size,\n     absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events)\n-    : TrackedCpuDeviceBuffer(owns_buffers, std::move(buffer), buffer_size,\n+    : TrackedCpuDeviceBuffer(owns_buffers, std::move(raw_buffer), buffer_size,\n                              AfterAll(definition_events)) {}\n \n TrackedCpuDeviceBuffer::TrackedCpuDeviceBuffer(\n-    bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+    bool owns_buffers, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n     tsl::AsyncValueRef<CpuEvent> definition_event)\n-    : owns_buffers_(owns_buffers),\n-      buffer_(std::move(buffer)),\n+    : AbstractTrackedDeviceBuffer(std::move(raw_buffer)),\n+      owns_buffers_(owns_buffers),\n       definition_event_(std::move(definition_event)) {\n   DCHECK(definition_event_);\n-  CHECK(buffer_.IsConcrete());\n-  buffer_size_ = buffer_->size_bytes();\n+  CHECK(tensorflow::down_cast<CpuRawBuffer*>(this->raw_buffer().get())\n+            ->buffer()\n+            .IsConcrete());\n+  buffer_size_ = this->raw_buffer()->GetOnDeviceSizeInBytes();\n }\n \n TrackedCpuDeviceBuffer::TrackedCpuDeviceBuffer(\n-    bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+    bool owns_buffers, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n     size_t buffer_size, tsl::AsyncValueRef<CpuEvent> definition_event)\n-    : owns_buffers_(owns_buffers),\n-      buffer_(std::move(buffer)),\n+    : AbstractTrackedDeviceBuffer(std::move(raw_buffer)),\n+      owns_buffers_(owns_buffers),\n       buffer_size_(buffer_size),\n       definition_event_(std::move(definition_event)) {\n   DCHECK(definition_event_);\n }\n \n-TrackedCpuDeviceBuffer::~TrackedCpuDeviceBuffer() { ReleaseDeviceMemory(); }\n+TrackedCpuDeviceBuffer::~TrackedCpuDeviceBuffer() = default;\n+\n+const tsl::AsyncValueRef<CpuDeviceMemory>& TrackedCpuDeviceBuffer::buffer() {\n+  if (raw_buffer()) {\n+    return tensorflow::down_cast<CpuRawBuffer*>(this->raw_buffer().get())\n+        ->buffer();\n+  }\n+  static absl::NoDestructor<tsl::AsyncValueRef<CpuDeviceMemory>> missing_buffer;\n+  return *missing_buffer;\n+}\n \n size_t TrackedCpuDeviceBuffer::BufferSize() { return buffer_size_; }\n \n@@ -271,8 +283,8 @@ TrackedCpuDeviceBuffer::LockUseAndTransferUsageEvents() {\n   return std::move(usage_events_);\n }\n \n-void TrackedCpuDeviceBuffer::ReleaseDeviceMemory() {\n-  buffer_ = tsl::AsyncValueRef<CpuDeviceMemory>();\n+void TrackedCpuDeviceBuffer::ConfirmDonation() {\n+  ReleaseDeviceMemory();\n   definition_event_.reset();\n   usage_events_.clear();\n }\n@@ -284,14 +296,6 @@ TrackedCpuDeviceBuffer::GetAsyncValueDefinitionEvents() {\n   return result;\n }\n \n-tsl::RCReference<CommonPjRtRawBuffer> TrackedCpuDeviceBuffer::GetRawBuffer(\n-    PjRtMemorySpace* memory_space) {\n-  if (!buffer_) {\n-    return tsl::RCReference<CommonPjRtRawBuffer>();\n-  }\n-  return tsl::MakeRef<CpuRawBuffer>(memory_space, buffer_);\n-}\n-\n void TrackedCpuDeviceBuffer::AddUsageEvent(\n     tsl::RCReference<PjRtDeviceEvent> event) {\n   if (event) {"
        },
        {
            "sha": "580846b00078c5a471d9157b5e0a4ccf82a6a087",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer.h",
            "status": "modified",
            "additions": 7,
            "deletions": 17,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer.h?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -147,12 +147,12 @@ class TrackedCpuDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   // Constructor for allocated cpu memory, i.e., `buffer` should have concrete\n   // states. Definition event is after the list of `definition_events`.\n   TrackedCpuDeviceBuffer(\n-      bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+      bool owns_buffers, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n       absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events);\n \n   // Variant with single definition event.\n   TrackedCpuDeviceBuffer(bool owns_buffers,\n-                         tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+                         tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n                          tsl::AsyncValueRef<CpuEvent> definition_event);\n \n   // Constructor for unallocated cpu memory, i.e., `buffer` will have\n@@ -161,13 +161,13 @@ class TrackedCpuDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   // list of `definition_events`. Callers need to ensure cpu memory is allocated\n   // before the definition event is ready.\n   TrackedCpuDeviceBuffer(\n-      bool owns_buffers, tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+      bool owns_buffers, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n       size_t buffer_size,\n       absl::InlinedVector<tsl::AsyncValueRef<CpuEvent>, 4> definition_events);\n \n   // Variant with single definition event.\n   TrackedCpuDeviceBuffer(bool owns_buffers,\n-                         tsl::AsyncValueRef<CpuDeviceMemory> buffer,\n+                         tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n                          size_t buffer_size,\n                          tsl::AsyncValueRef<CpuEvent> definition_event);\n \n@@ -177,7 +177,7 @@ class TrackedCpuDeviceBuffer : public AbstractTrackedDeviceBuffer {\n \n   ~TrackedCpuDeviceBuffer();\n \n-  const tsl::AsyncValueRef<CpuDeviceMemory>& buffer() { return buffer_; }\n+  const tsl::AsyncValueRef<CpuDeviceMemory>& buffer();\n \n   size_t BufferSize();\n \n@@ -204,9 +204,6 @@ class TrackedCpuDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>> GetDefinitionEvent(\n       PjRtMemorySpace* memory_space) override;\n \n-  tsl::RCReference<CommonPjRtRawBuffer> GetRawBuffer(\n-      PjRtMemorySpace* memory_space) override;\n-\n   void AddUsageEvent(tsl::RCReference<PjRtDeviceEvent> event) override;\n \n   void Delete(PjRtMemorySpace* memory_space) override;\n@@ -217,18 +214,11 @@ class TrackedCpuDeviceBuffer : public AbstractTrackedDeviceBuffer {\n       PjRtMemorySpace* memory_space) override;\n \n  private:\n-  // Relinquishes ownership of the buffer's device memory, e.g., after the\n-  // buffer is passed to a computation that aliases its inputs to outputs.\n-  void ReleaseDeviceMemory();\n-\n-  void ConfirmDonation() override { ReleaseDeviceMemory(); }\n+  void ConfirmDonation() override;\n \n   bool owns_buffers_;\n \n-  // If non-tuple, `buffers_` contains 1 buffer; otherwise all leaf buffers.\n-  tsl::AsyncValueRef<CpuDeviceMemory> buffer_;\n-  // Should correspond to size of each buffer in `buffers_` when `buffers_` is\n-  // available.\n+  // Should equal raw_buffer()->GetOnDeviceSizeInBytes();\n   size_t buffer_size_;\n   // The definition event are associated with CPU operations that write to the\n   // buffers."
        },
        {
            "sha": "4d54ae1dacb9a4301d11504862d4da5ea6a851d2",
            "filename": "third_party/xla/xla/pjrt/cpu/tracked_cpu_device_buffer_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 6,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcpu%2Ftracked_cpu_device_buffer_test.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -20,9 +20,13 @@ limitations under the License.\n \n #include <gtest/gtest.h>\n #include \"absl/log/check.h\"\n+#include \"xla/pjrt/cpu/cpu_client.h\"\n #include \"xla/pjrt/cpu/cpu_event.h\"\n+#include \"xla/pjrt/cpu/raw_buffer.h\"\n+#include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n@@ -36,17 +40,20 @@ using ::tsl::MakeConstructedAsyncValueRef;\n using ::tsl::thread::ThreadPool;\n \n TEST(TrackedCpuDeviceBufferTest, Basic) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, GetPjRtCpuClient(CpuClientOptions()));\n+  PjRtMemorySpace* memory_space = client->memory_spaces()[0];\n   std::string expected = \"tracked_cpu_device_buffer_test\";\n-  TF_ASSERT_OK_AND_ASSIGN(auto buffer,\n-                          CpuDeviceMemory::Allocate(expected.size()));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto buffer, CpuRawBuffer::Allocate(memory_space, expected.size()));\n \n   auto definition_event = MakeConstructedAsyncValueRef<CpuEvent>();\n \n   ThreadPool thread_pool(tsl::Env::Default(), \"tracked_buffer_test\",\n                          /*num_threads=*/4);\n \n   thread_pool.Schedule([&]() {\n-    std::memcpy(buffer->untyped_data(), expected.data(), expected.size());\n+    std::memcpy(buffer->buffer()->untyped_data(), expected.data(),\n+                expected.size());\n     definition_event.SetStateConcrete();\n   });\n \n@@ -63,7 +70,10 @@ TEST(TrackedCpuDeviceBufferTest, Basic) {\n }\n \n TEST(TrackedCpuDeviceBufferTest, BasicError) {\n-  TF_ASSERT_OK_AND_ASSIGN(auto buffer, CpuDeviceMemory::Allocate(64));\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, GetPjRtCpuClient(CpuClientOptions()));\n+  PjRtMemorySpace* memory_space = client->memory_spaces()[0];\n+  TF_ASSERT_OK_AND_ASSIGN(auto buffer,\n+                          CpuRawBuffer::Allocate(memory_space, 64));\n \n   auto definition_event = MakeConstructedAsyncValueRef<CpuEvent>();\n \n@@ -86,6 +96,8 @@ TEST(TrackedCpuDeviceBufferTest, BasicError) {\n }\n \n TEST(TrackedCpuDeviceBufferTest, DelayedAllocation) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, GetPjRtCpuClient(CpuClientOptions()));\n+  PjRtMemorySpace* memory_space = client->memory_spaces()[0];\n   std::string expected = \"tracked_cpu_device_buffer_test\";\n \n   auto buffer = CpuDeviceMemory::CreateDelayedMemory();\n@@ -95,8 +107,9 @@ TEST(TrackedCpuDeviceBufferTest, DelayedAllocation) {\n   });\n \n   auto definition_event = MakeConstructedAsyncValueRef<CpuEvent>();\n-  TrackedCpuDeviceBuffer tracked_buffer(/*owns_buffers=*/true, buffer,\n-                                        expected.size(), definition_event);\n+  TrackedCpuDeviceBuffer tracked_buffer(\n+      /*owns_buffers=*/true, tsl::MakeRef<CpuRawBuffer>(memory_space, buffer),\n+      expected.size(), definition_event);\n   auto result = tracked_buffer.buffer();\n   ASSERT_FALSE(result.IsAvailable());\n   ASSERT_EQ(tracked_buffer.BufferSize(), expected.size());"
        },
        {
            "sha": "3a348ae185bf7e8fa472ef530e98bcad7971f300",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 15,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -525,10 +525,7 @@ PjRtStreamExecutorClient::DefineBuffer(\n       memory_space->devices()[0]);\n \n   auto dst_device_buffer = std::make_unique<TrackedDeviceBuffer>(\n-      device,\n-      tensorflow::down_cast<PjRtStreamExecutorRawBuffer*>(raw_buffer.get())\n-          ->device_buffer(),\n-      definition_events);\n+      device, std::move(raw_buffer), definition_events);\n \n   auto py_buffer = std::make_unique<CommonPjRtBufferImpl>(\n       on_device_shape, std::move(dst_device_buffer), memory_space);\n@@ -830,7 +827,7 @@ PjRtStreamExecutorClient::CreateErrorBuffer(absl::Status error,\n \n   // Create an empty buffer.\n   auto dummy_device_buffer = std::make_unique<TrackedDeviceBuffer>(\n-      device, tsl::AsyncValueRef<RawSEDeviceMemory>(),\n+      device, tsl::RCReference<CommonPjRtRawBuffer>(),\n       absl::MakeSpan(&definition_event, 1));\n \n   return std::make_unique<CommonPjRtBufferImpl>(\n@@ -925,7 +922,10 @@ PjRtStreamExecutorClient::CreateViewOfDeviceBuffer(\n                                             local_device, definition_stream));\n \n   auto device_buffer = std::make_unique<TrackedDeviceBuffer>(\n-      device, std::move(buffer), definition_events);\n+      device,\n+      tsl::MakeRef<PjRtStreamExecutorRawBuffer>(\n+          this, memory_space, local_device, std::move(buffer)),\n+      definition_events);\n   return std::unique_ptr<PjRtBuffer>(std::make_unique<CommonPjRtBufferImpl>(\n       shape, std::move(device_buffer), memory_space));\n }\n@@ -1179,8 +1179,9 @@ MakeTupleHelper(PjRtStreamExecutorClient* client,\n   for (const CommonPjRtBuffer::ScopedHold& device_buffer : device_buffers) {\n     input_iterator->second = {\n         device_buffer.type() == CommonPjRtBuffer::ScopedHold::kDonation,\n-        tensorflow::down_cast<TrackedDeviceBuffer*>(device_buffer.buffer())\n-            ->device_memory()};\n+        tensorflow::down_cast<PjRtStreamExecutorRawBuffer*>(\n+            device_buffer.buffer()->raw_buffer().get())\n+            ->device_buffer()};\n     ++input_iterator;\n   }\n   CHECK(input_iterator == iterator_end);\n@@ -1217,9 +1218,6 @@ absl::StatusOr<std::unique_ptr<PjRtBuffer>> OutputBufferHelper(\n   for (auto& item : result_buffer) {\n     buffers.push_back(std::move(item.second));\n   }\n-  auto out_buffer = std::make_unique<TrackedDeviceBuffer>(\n-      device, std::move(buffers[0]),\n-      absl::Span<const BufferSequencingEventRef>{definition_event});\n   const Shape& shape = result_buffer.shape();\n   PjRtMemorySpace* memory_space =\n       device->default_memory_space().value_or(nullptr);\n@@ -1242,6 +1240,12 @@ absl::StatusOr<std::unique_ptr<PjRtBuffer>> OutputBufferHelper(\n                          shape.layout().memory_space()));\n     }\n   }\n+  auto raw_buffer = tsl::MakeRef<PjRtStreamExecutorRawBuffer>(\n+      tensorflow::down_cast<PjRtStreamExecutorClient*>(client), memory_space,\n+      local_device, buffers[0]);\n+  auto out_buffer = std::make_unique<TrackedDeviceBuffer>(\n+      device, std::move(raw_buffer),\n+      absl::Span<const BufferSequencingEventRef>{definition_event});\n   auto pjrt_buffer = std::make_unique<CommonPjRtBufferImpl>(\n       result_buffer.shape(), std::move(out_buffer), memory_space);\n   return std::unique_ptr<PjRtBuffer>(std::move(pjrt_buffer));\n@@ -1395,9 +1399,9 @@ PjRtStreamExecutorLoadedExecutable::MakeExecutionInputsAndWaitForEvents(\n           execution_inputs.back();\n       auto input_iterator = execution_input.begin();\n       auto iterator_end = execution_input.end();\n-      const auto& buf = tensorflow::down_cast<TrackedDeviceBuffer*>(\n-                            device_buffers[i].buffer())\n-                            ->device_memory();\n+      const auto& buf = tensorflow::down_cast<PjRtStreamExecutorRawBuffer*>(\n+                            device_buffers[i].buffer()->raw_buffer().get())\n+                            ->device_buffer();\n       CHECK(input_iterator != iterator_end);\n       input_iterator->second = {\n           device_buffers[i].type() == CommonPjRtBuffer::ScopedHold::kDonation,\n@@ -2126,7 +2130,7 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n       if (device_state->allocation_model() == LocalDeviceState::kSynchronous) {\n         buffers_to_release.push_back(\n             tensorflow::down_cast<PjRtStreamExecutorRawBuffer*>(\n-                b.buffer()->GetRawBuffer(b.parent()->memory_space()).get())\n+                b.buffer()->raw_buffer().get())\n                 ->device_buffer());\n       }\n       b.ConvertUsageHold(definition_event);"
        },
        {
            "sha": "4376ec077f11e8480e8f26870bb41d125de780ab",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 38,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -38,6 +38,7 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_stream_executor_client.h\"\n+#include \"xla/pjrt/raw_buffer.h\"\n #include \"xla/pjrt/se_raw_buffer.h\"\n #include \"xla/service/shaped_buffer.h\"\n #include \"xla/shape.h\"\n@@ -143,37 +144,17 @@ tsl::AsyncValueRef<RawSEDeviceMemory> RawSEDeviceMemory::CreateForeign(\n       value, std::move(on_delete_callback));\n }\n \n-ShapedBuffer TrackedDeviceBuffer::AsShapedBuffer(\n-    const Shape& on_device_shape) const {\n-  ShapedBuffer shaped_buffer(on_device_shape,\n-                             device_->local_device_id().value(),\n-                             device_->local_hardware_id().value());\n-  ShapeTree<se::DeviceMemoryBase>::iterator iterator =\n-      shaped_buffer.buffers().begin();\n-  if (device_memory_) {\n-    CHECK(iterator != shaped_buffer.buffers().end());\n-    iterator->second = device_memory_->mem();\n-    ++iterator;\n-  }\n-  CHECK(iterator == shaped_buffer.buffers().end());\n-  return shaped_buffer;\n-}\n-\n TrackedDeviceBuffer::TrackedDeviceBuffer(\n-    PjRtDevice* device, tsl::AsyncValueRef<RawSEDeviceMemory> device_memory,\n+    PjRtDevice* device, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n     absl::Span<const BufferSequencingEventRef> definition_events)\n-    : device_(device),\n-      device_memory_(std::move(device_memory)),\n+    : AbstractTrackedDeviceBuffer(std::move(raw_buffer)),\n+      device_(device),\n       definition_events_(std::make_move_iterator(definition_events.begin()),\n                          std::make_move_iterator(definition_events.end())),\n       in_use_(true) {}\n \n TrackedDeviceBuffer::~TrackedDeviceBuffer() = default;\n \n-void TrackedDeviceBuffer::ReleaseDeviceMemory() {\n-  device_memory_ = tsl::AsyncValueRef<RawSEDeviceMemory>();\n-}\n-\n void TrackedDeviceBuffer::ConfirmDonation() {\n   // As a sanity check ensure no more usage events can be added to the buffer.\n   LockUseAndTransferUsageEvents();\n@@ -228,7 +209,7 @@ TrackedDeviceBuffer::CloneWithControlDependency(PjRtMemorySpace* memory_space,\n                            original_definition_events.end());\n \n   auto new_device_buffer = std::make_unique<TrackedDeviceBuffer>(\n-      device_, device_memory(), std::move(definition_events));\n+      device_, raw_buffer(), std::move(definition_events));\n \n   auto* device = tensorflow::down_cast<PjRtStreamExecutorDevice*>(\n       memory_space->devices()[0]);\n@@ -297,20 +278,6 @@ TrackedDeviceBuffer::GetAsyncValueDefinitionEvents() {\n   return avs;\n }\n \n-tsl::RCReference<CommonPjRtRawBuffer> TrackedDeviceBuffer::GetRawBuffer(\n-    PjRtMemorySpace* memory_space) {\n-  if (!device_memory_) {\n-    return tsl::RCReference<CommonPjRtRawBuffer>();\n-  }\n-  return tsl::MakeRef<PjRtStreamExecutorRawBuffer>(\n-      tensorflow::down_cast<PjRtStreamExecutorClient*>(memory_space->client()),\n-      memory_space,\n-      tensorflow::down_cast<PjRtStreamExecutorDevice*>(\n-          memory_space->devices()[0])\n-          ->local_device_state(),\n-      device_memory_);\n-}\n-\n absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>\n TrackedDeviceBuffer::GetDefinitionEvent(PjRtMemorySpace* memory_space) {\n   if (definition_events_.size() != 1) {"
        },
        {
            "sha": "ecc4a64dc73c4510e0e3a7d5d7b4dd04b8448824",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.h",
            "status": "modified",
            "additions": 1,
            "deletions": 19,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -103,9 +103,6 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n     bool reference_held;\n   };\n \n-  // Builds a ShapedBuffer view onto the buffers of 'tree'.\n-  ShapedBuffer AsShapedBuffer(const Shape& on_device_shape) const;\n-\n   // Adds the owned device buffers in order to 'iterator'. Used to add the\n   // buffers to an ExecutionInput. We require but do not verify that 'iterator'\n   // when passed in is pointing to a sub-tuple of the ExecutionInput whose\n@@ -129,10 +126,6 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n       ExecutionInput* execution_input,\n       se::DeviceMemoryAllocator* allocator) const;\n \n-  const tsl::AsyncValueRef<RawSEDeviceMemory>& device_memory() const {\n-    return device_memory_;\n-  }\n-\n   const absl::InlinedVector<BufferSequencingEventRef, 2>& definition_events()\n       const {\n     return definition_events_;\n@@ -141,10 +134,6 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n     return usage_events_;\n   }\n \n-  // Relinquishes ownership of the buffer's device memory, e.g., after the\n-  // buffer is passed to a computation that aliases its inputs to outputs.\n-  void ReleaseDeviceMemory();\n-\n   // Only to be called by ScopedHold to mark a successful donation.\n   void ConfirmDonation() override;\n \n@@ -167,16 +156,13 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   StreamAndEventContainer LockUseAndTransferUsageEvents();\n \n   TrackedDeviceBuffer(\n-      PjRtDevice* device, tsl::AsyncValueRef<RawSEDeviceMemory> device_memory,\n+      PjRtDevice* device, tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n       absl::Span<const BufferSequencingEventRef> definition_events);\n   ~TrackedDeviceBuffer() override;\n \n   std::vector<tsl::RCReference<tsl::AsyncValue>> GetAsyncValueDefinitionEvents()\n       override;\n \n-  tsl::RCReference<CommonPjRtRawBuffer> GetRawBuffer(\n-      PjRtMemorySpace* memory_space) override;\n-\n   void AddUsageEvent(tsl::RCReference<PjRtDeviceEvent> event) override;\n \n   void Delete(PjRtMemorySpace* memory_space) override;\n@@ -199,10 +185,6 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n \n  private:\n   PjRtDevice* device_;\n-\n-  // Each host-side buffer may have several buffers on-device.\n-  tsl::AsyncValueRef<RawSEDeviceMemory> device_memory_;\n-\n   // Events that are triggered when the content of one or more buffers is ready\n   // during multistream execution. May be nullptr, which is used in the\n   // single-stream execution case where events are not necessary for buffer"
        },
        {
            "sha": "f4d2b8664df14343933154b031f084b8e3230304",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer_test.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 9,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2d41adde77015c55411cb12066190afca4035eaa/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer_test.cc?ref=2d41adde77015c55411cb12066190afca4035eaa",
            "patch": "@@ -37,6 +37,7 @@ limitations under the License.\n #include \"xla/stream_executor/device_memory_allocator.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n #include \"xla/xla_data.pb.h\"\n #include \"tsl/platform/statusor.h\"\n@@ -82,8 +83,8 @@ class TestDevice : public PjRtDevice {\n   }\n };\n \n-absl::StatusOr<std::shared_ptr<TrackedDeviceBuffer>> MakeArray(\n-    const Shape& shape, LocalClient* client, PjRtDevice* device) {\n+absl::StatusOr<tsl::AsyncValueRef<RawSEDeviceMemory>> MakeArray(\n+    const Shape& shape, LocalClient* client) {\n   std::vector<tsl::AsyncValueRef<RawSEDeviceMemory>> device_buffers;\n   TF_RETURN_IF_ERROR(ShapeUtil::ForEachSubshapeWithStatus(\n       client->backend().transfer_manager()->HostShapeToDeviceShape(shape),\n@@ -99,8 +100,7 @@ absl::StatusOr<std::shared_ptr<TrackedDeviceBuffer>> MakeArray(\n             se_mem, [device_memory = std::move(device_memory)]() {}));\n         return absl::OkStatus();\n       }));\n-  return std::make_shared<TrackedDeviceBuffer>(\n-      device, device_buffers[0], absl::Span<const BufferSequencingEventRef>());\n+  return device_buffers[0];\n }\n \n TEST(TrackedDeviceBufferTest, AsShapedBuffer) {\n@@ -110,18 +110,20 @@ TEST(TrackedDeviceBufferTest, AsShapedBuffer) {\n   Shape a_shape = ShapeUtil::MakeShape(F32, {3, 101, 4});\n   Shape b_shape = ShapeUtil::MakeShape(S8, {77});\n   Shape c_shape = ShapeUtil::MakeShape(S64, {});\n-  TF_ASSERT_OK_AND_ASSIGN(auto a_buffer, MakeArray(a_shape, client, &device));\n-  TF_ASSERT_OK_AND_ASSIGN(auto b_buffer, MakeArray(b_shape, client, &device));\n-  TF_ASSERT_OK_AND_ASSIGN(auto c_buffer, MakeArray(c_shape, client, &device));\n+  TF_ASSERT_OK_AND_ASSIGN(auto a_buffer, MakeArray(a_shape, client));\n+  TF_ASSERT_OK_AND_ASSIGN(auto b_buffer, MakeArray(b_shape, client));\n+  TF_ASSERT_OK_AND_ASSIGN(auto c_buffer, MakeArray(c_shape, client));\n \n   std::vector<se::DeviceMemoryBase> expected_buffer_sequence = {\n-      a_buffer->device_memory()->mem(), b_buffer->device_memory()->mem(),\n-      c_buffer->device_memory()->mem()};\n+      a_buffer->mem(), b_buffer->mem(), c_buffer->mem()};\n   ShapedBuffer shaped_a = a_buffer->AsShapedBuffer(\n+      &device,\n       client->backend().transfer_manager()->HostShapeToDeviceShape(a_shape));\n   ShapedBuffer shaped_b = b_buffer->AsShapedBuffer(\n+      &device,\n       client->backend().transfer_manager()->HostShapeToDeviceShape(b_shape));\n   ShapedBuffer shaped_c = c_buffer->AsShapedBuffer(\n+      &device,\n       client->backend().transfer_manager()->HostShapeToDeviceShape(c_shape));\n   auto expected_it = expected_buffer_sequence.begin();\n   for (auto it = shaped_a.buffers().begin(); it != shaped_a.buffers().end();"
        }
    ],
    "stats": {
        "total": 318,
        "additions": 126,
        "deletions": 192
    }
}