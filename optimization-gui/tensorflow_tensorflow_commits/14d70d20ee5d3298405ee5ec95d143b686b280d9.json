{
    "author": "tensorflower-gardener",
    "message": "[XLA] Add tests for tile_assignment.\n\nPiperOrigin-RevId: 819461056",
    "sha": "14d70d20ee5d3298405ee5ec95d143b686b280d9",
    "files": [
        {
            "sha": "7deffe143570d1bf4847d15ce80fe198e24f7074",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14d70d20ee5d3298405ee5ec95d143b686b280d9/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14d70d20ee5d3298405ee5ec95d143b686b280d9/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=14d70d20ee5d3298405ee5ec95d143b686b280d9",
            "patch": "@@ -360,6 +360,20 @@ cc_library(\n     ],\n )\n \n+xla_cc_test(\n+    name = \"tile_assignment_test\",\n+    srcs = [\"tile_assignment_test.cc\"],\n+    deps = [\n+        \":tile_assignment\",\n+        \"//xla:array\",\n+        \"//xla:array2d\",\n+        \"//xla/tsl/platform:test_main\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest\",\n+    ],\n+)\n+\n xla_cc_test(\n     name = \"replica_group_test\",\n     srcs = [\"replica_group_test.cc\"],"
        },
        {
            "sha": "cf9c9d46d46ed6438c00115ab51343caacb6c9ad",
            "filename": "third_party/xla/xla/hlo/ir/tile_assignment_test.cc",
            "status": "added",
            "additions": 297,
            "deletions": 0,
            "changes": 297,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14d70d20ee5d3298405ee5ec95d143b686b280d9/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Ftile_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14d70d20ee5d3298405ee5ec95d143b686b280d9/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Ftile_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Ftile_assignment_test.cc?ref=14d70d20ee5d3298405ee5ec95d143b686b280d9",
            "patch": "@@ -0,0 +1,297 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/ir/tile_assignment.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/array.h\"\n+#include \"xla/array2d.h\"\n+\n+namespace xla {\n+namespace {\n+\n+TEST(IotaTileAssignmentTest, Create) {\n+  // Test with dims only\n+  IotaTileAssignment iota1 = IotaTileAssignment::Create({2, 3});\n+  EXPECT_EQ(iota1.dims(), absl::MakeConstSpan(std::vector<int64_t>{2, 3}));\n+  EXPECT_EQ(iota1.reshape_dims(), absl::MakeConstSpan(std::vector<int64_t>{6}));\n+  EXPECT_EQ(iota1.transpose_perm(), absl::MakeConstSpan(std::vector<int>{0}));\n+  EXPECT_EQ(iota1.num_elements(), 6);\n+\n+  // Test with reshape_dims and transpose_perm\n+  IotaTileAssignment iota2 = IotaTileAssignment::Create({2, 6}, {3, 4}, {0, 1});\n+  EXPECT_EQ(iota2.dims(), absl::MakeConstSpan(std::vector<int64_t>{2, 6}));\n+  EXPECT_EQ(iota2.reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{12}));\n+  EXPECT_EQ(iota2.transpose_perm(), absl::MakeConstSpan(std::vector<int>{0}));\n+  EXPECT_EQ(iota2.num_elements(), 12);\n+\n+  // Test canonicalization: remove size one dims\n+  IotaTileAssignment iota3 = IotaTileAssignment::Create(\n+      {1, 3, 1, 4, 1, 5}, {1, 3, 1, 4, 1, 5}, {4, 3, 2, 5, 1, 0});\n+  EXPECT_EQ(iota3.dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{1, 3, 1, 4, 1, 5}));\n+  EXPECT_EQ(iota3.reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{3, 20}));\n+  EXPECT_EQ(iota3.transpose_perm(),\n+            absl::MakeConstSpan(std::vector<int>{1, 0}));\n+\n+  // Test canonicalization: merge major to minor\n+  IotaTileAssignment iota4 =\n+      IotaTileAssignment::Create({2, 3, 4}, {2, 3, 4}, {0, 1, 2});\n+  EXPECT_EQ(iota4.reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{24}));\n+  EXPECT_EQ(iota4.transpose_perm(), absl::MakeConstSpan(std::vector<int>{0}));\n+\n+  IotaTileAssignment iota5 =\n+      IotaTileAssignment::Create({2, 3, 4}, {2, 3, 4}, {1, 0, 2});\n+  EXPECT_EQ(iota5.reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 3, 4}));\n+  EXPECT_EQ(iota5.transpose_perm(),\n+            absl::MakeConstSpan(std::vector<int>{1, 0, 2}));\n+}\n+\n+TEST(IotaTileAssignmentTest, ToArray) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3}, {6}, {0});\n+  Array<int64_t> array = iota.ToArray();\n+  Array2D<int64_t> expected({{0, 1, 2}, {3, 4, 5}});\n+  EXPECT_EQ(array, expected);\n+\n+  IotaTileAssignment iota2 = IotaTileAssignment::Create({3, 2}, {2, 3}, {1, 0});\n+  Array<int64_t> array2 = iota2.ToArray();\n+  Array2D<int64_t> expected2({{0, 3}, {1, 4}, {2, 5}});\n+  EXPECT_EQ(array2, expected2);\n+\n+  IotaTileAssignment iota3 =\n+      IotaTileAssignment::Create({3, 4, 5}, {3, 4, 5}, {2, 0, 1});\n+  Array<int64_t> array3 = iota3.ToArray();\n+\n+  Array<int64_t> expected3({3, 4, 5});\n+  expected3.FillIota(0);\n+  expected3.TransposeDimensions({2, 0, 1});\n+  expected3.Reshape({3, 4, 5});\n+  EXPECT_EQ(array3, expected3);\n+}\n+\n+TEST(IotaTileAssignmentTest, Transpose) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3}, {6}, {0});\n+\n+  // Noop transpose\n+  auto transposed1 = iota.Transpose({0, 1});\n+  EXPECT_TRUE(transposed1.has_value());\n+  EXPECT_EQ(transposed1->dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 3}));\n+  EXPECT_EQ(transposed1->reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{6}));\n+  EXPECT_EQ(transposed1->transpose_perm(),\n+            absl::MakeConstSpan(std::vector<int>{0}));\n+\n+  // Reshape transpose\n+  IotaTileAssignment iota2 = IotaTileAssignment::Create({2, 1, 3}, {6}, {0});\n+  auto transposed2 = iota2.Transpose({0, 2, 1});\n+  EXPECT_TRUE(transposed2.has_value());\n+  EXPECT_EQ(transposed2->dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 3, 1}));\n+  EXPECT_EQ(transposed2->reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{6}));\n+  EXPECT_EQ(transposed2->transpose_perm(),\n+            absl::MakeConstSpan(std::vector<int>{0}));\n+\n+  // Regular transpose\n+  IotaTileAssignment iota3 = IotaTileAssignment::Create({2, 3}, {2, 3}, {0, 1});\n+  auto transposed3 = iota3.Transpose({1, 0});\n+  EXPECT_TRUE(transposed3.has_value());\n+  EXPECT_EQ(transposed3->dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{3, 2}));\n+  EXPECT_EQ(transposed3->reshape_dims(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 3}));\n+  EXPECT_EQ(transposed3->transpose_perm(),\n+            absl::MakeConstSpan(std::vector<int>{1, 0}));\n+}\n+\n+TEST(IotaTileAssignmentTest, ValueAt) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3}, {6}, {0});\n+  EXPECT_EQ(iota.value_at({0, 0}), 0);\n+  EXPECT_EQ(iota.value_at({0, 1}), 1);\n+  EXPECT_EQ(iota.value_at({1, 0}), 3);\n+  EXPECT_EQ(iota.value_at({1, 2}), 5);\n+\n+  IotaTileAssignment iota2 = IotaTileAssignment::Create({3, 2}, {2, 3}, {1, 0});\n+  EXPECT_EQ(iota2.value_at({0, 0}), 0);\n+  EXPECT_EQ(iota2.value_at({0, 1}), 3);\n+  EXPECT_EQ(iota2.value_at({1, 0}), 1);\n+  EXPECT_EQ(iota2.value_at({2, 1}), 5);\n+}\n+\n+TEST(IotaTileAssignmentTest, ToString) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3});\n+  EXPECT_EQ(iota.ToString(), \"[2,3]<=[6]\");\n+\n+  IotaTileAssignment iota2 = IotaTileAssignment::Create({2, 6}, {3, 4}, {0, 1});\n+  EXPECT_EQ(iota2.ToString(), \"[2,6]<=[12]\");\n+\n+  IotaTileAssignment iota3 =\n+      IotaTileAssignment::Create({3, 4, 5}, {3, 4, 5}, {2, 0, 1});\n+  EXPECT_EQ(iota3.ToString(), \"[3,4,5]<=[12,5]T(1,0)\");\n+}\n+\n+TEST(TileAssignmentTest, FromIota) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3});\n+  TileAssignment tile_assignment(iota);\n+  std::string prefix(\"devices=\");\n+\n+  EXPECT_EQ(tile_assignment.ToString().compare(0, prefix.size(), prefix), 0);\n+  EXPECT_EQ(tile_assignment.dimensions(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 3}));\n+  EXPECT_EQ(tile_assignment.num_elements(), 6);\n+  EXPECT_EQ(tile_assignment({1, 1}), 4);\n+}\n+\n+TEST(TileAssignmentTest, FromArray) {\n+  Array2D<int64_t> array({{0, 1}, {2, 3}});\n+  TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n+  std::string prefix(\"devices=\");\n+\n+  EXPECT_EQ(tile_assignment.ToString().compare(0, prefix.size(), prefix), 0);\n+  EXPECT_EQ(tile_assignment.dimensions(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 2}));\n+  EXPECT_EQ(tile_assignment.num_elements(), 4);\n+  EXPECT_EQ(tile_assignment({1, 1}), 3);\n+}\n+\n+TEST(TileAssignmentTest, Equality) {\n+  IotaTileAssignment iota1 = IotaTileAssignment::Create({2, 3});\n+  IotaTileAssignment iota2 = IotaTileAssignment::Create({2, 3});\n+  IotaTileAssignment iota3 = IotaTileAssignment::Create({3, 2});\n+\n+  TileAssignment ta1(iota1);\n+  TileAssignment ta2(iota2);\n+  TileAssignment ta3(iota3);\n+\n+  EXPECT_EQ(ta1, ta2);\n+  EXPECT_NE(ta1, ta3);\n+\n+  Array2D<int64_t> array1({{0, 1}, {2, 3}});\n+  Array2D<int64_t> array2({{0, 1}, {2, 3}});\n+  Array2D<int64_t> array3({{0, 1}, {2, 4}});\n+\n+  TileAssignment ta4(std::make_shared<Array<int64_t>>(array1));\n+  TileAssignment ta5(std::make_shared<Array<int64_t>>(array2));\n+  TileAssignment ta6(std::make_shared<Array<int64_t>>(array3));\n+\n+  EXPECT_EQ(ta4, ta5);\n+  EXPECT_NE(ta4, ta6);\n+\n+  // Iota vs Array\n+  Array2D<int64_t> array_iota({{0, 1, 2}, {3, 4, 5}});\n+  TileAssignment ta7(std::make_shared<Array<int64_t>>(array_iota));\n+  EXPECT_EQ(ta1, ta7);\n+}\n+\n+TEST(TileAssignmentTest, Reshape) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 6});\n+  TileAssignment ta(iota);\n+  TileAssignment reshaped = ta.Reshape({3, 4});\n+  EXPECT_EQ(reshaped.dimensions(),\n+            absl::MakeConstSpan(std::vector<int64_t>{3, 4}));\n+  EXPECT_EQ(reshaped.num_elements(), 12);\n+  EXPECT_EQ(reshaped({1, 1}), 5);\n+\n+  Array2D<int64_t> array({{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}});\n+  TileAssignment ta2(std::make_shared<Array<int64_t>>(array));\n+  TileAssignment reshaped2 = ta2.Reshape({6, 2});\n+  EXPECT_EQ(reshaped2.dimensions(),\n+            absl::MakeConstSpan(std::vector<int64_t>{6, 2}));\n+  EXPECT_EQ(reshaped2({1, 1}), 3);\n+}\n+\n+TEST(TileAssignmentTest, Transpose) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3});\n+  TileAssignment ta(iota);\n+  TileAssignment transposed = ta.Transpose({1, 0});\n+  EXPECT_EQ(transposed.dimensions(),\n+            absl::MakeConstSpan(std::vector<int64_t>{3, 2}));\n+  EXPECT_EQ(transposed({1, 0}), 1);\n+\n+  Array2D<int64_t> array({{0, 1}, {2, 3}});\n+  TileAssignment ta2(std::make_shared<Array<int64_t>>(array));\n+  TileAssignment transposed2 = ta2.Transpose({1, 0});\n+  EXPECT_EQ(transposed2.dimensions(),\n+            absl::MakeConstSpan(std::vector<int64_t>{2, 2}));\n+  EXPECT_EQ(transposed2({1, 0}), 1);\n+}\n+\n+TEST(TileAssignmentTest, UsesDevice) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3});\n+  TileAssignment ta(iota);\n+  EXPECT_TRUE(ta.UsesDevice(0));\n+  EXPECT_TRUE(ta.UsesDevice(5));\n+  EXPECT_FALSE(ta.UsesDevice(6));\n+\n+  Array2D<int64_t> array({{1, 2}, {3, 4}});\n+  TileAssignment ta2(std::make_shared<Array<int64_t>>(array));\n+  EXPECT_TRUE(ta2.UsesDevice(1));\n+  EXPECT_FALSE(ta2.UsesDevice(0));\n+}\n+\n+TEST(TileAssignmentTest, MaterializeArray) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 3});\n+  TileAssignment ta(iota);\n+  const Array<int64_t>& array = ta.array();\n+  Array2D<int64_t> expected({{0, 1, 2}, {3, 4, 5}});\n+  EXPECT_EQ(array, expected);\n+\n+  std::shared_ptr<const Array<int64_t>> shared_array = ta.shared_array();\n+  EXPECT_EQ(*shared_array, expected);\n+}\n+\n+TEST(TileAssignmentTest, Each) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 2});\n+  TileAssignment ta(iota);\n+  std::vector<std::pair<std::vector<int64_t>, int64_t>> values;\n+  ta.Each([&](absl::Span<const int64_t> indices, int64_t value) {\n+    values.push_back({{indices.begin(), indices.end()}, value});\n+  });\n+  EXPECT_THAT(values, ::testing::ElementsAre(\n+                          ::testing::Pair(std::vector<int64_t>({0, 0}), 0),\n+                          ::testing::Pair(std::vector<int64_t>({0, 1}), 1),\n+                          ::testing::Pair(std::vector<int64_t>({1, 0}), 2),\n+                          ::testing::Pair(std::vector<int64_t>({1, 1}), 3)));\n+}\n+\n+TEST(TileAssignmentTest, EachStatus) {\n+  IotaTileAssignment iota = IotaTileAssignment::Create({2, 2});\n+  TileAssignment ta(iota);\n+  absl::Status status =\n+      ta.EachStatus([&](absl::Span<const int64_t> indices, int64_t value) {\n+        if (value == 3) {\n+          return absl::InternalError(\"Test Error\");\n+        }\n+        return absl::OkStatus();\n+      });\n+  EXPECT_FALSE(status.ok());\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 311,
        "additions": 311,
        "deletions": 0
    }
}