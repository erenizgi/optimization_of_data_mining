{
    "author": "cj401-amd",
    "message": "PR #29769:  [ROCm] upstream using rocprofiler-sdk (v3) for tracing AMD GPU events\n\nImported from GitHub PR https://github.com/openxla/xla/pull/29769\n\n@xla-rotation, would you please kindly help review this PR?\n\nWe are phasing out development and support for roctracer/rocprofiler/rocprof/rocprofv2 in favor of rocprofiler-sdk (v3) in upcoming ROCm releases. rocprofielr-sdk (v3) also moves away from cupti.\n\nThis PR integrates rocprofiler-sdk (v3) into XLA for profiling GPU events on AMD GPUs.\n\n-  Integrate rocprofiler-sdk (v3) to XLA for improved profiling of GPU events, support both time-based and step-based profiling,\n- Add unit tests for rocm_collector and rocm_tracer\nCopybara import of the project:\n\n--\nab064425550acf959ec7b6d404b294b6bc8a34f3 by cj401-amd <chunyjin@amd.com>:\n\nupdate with refactoring based on the PR comments\n\n--\n8f8ad5a5d77e2930a7489815baf3bf2bfbac7558 by cj401-amd <chunyjin@amd.com>:\n\nupdate with VLOG(2) and fix a bug, new line at the EoF\n\n--\n6a85e5cfc4b1696b47df94b7e1082567e3cdac8a by cj401-amd <chunyjin@amd.com>:\n\nupdate the macro\n\n--\ncb13f7e5cce2e9e64efa224ca35cfecf5fcdf5ba by cj401-amd <chunyjin@amd.com>:\n\nupdate header files\n\n--\n15ec380fb3a6e7e053d3d466496496451a2121e8 by cj401-amd <chunyjin@amd.com>:\n\nupdate a: addressing comments, b: add kernel details, c: update rocprofiler-sdk path\n\n--\n3ee71f30300c482de2730c39bb5568d3b5f58509 by cj401-amd <chunyjin@amd.com>:\n\nadd rocprofiler-sdk debs for hermetic build\n\n--\nac2249dbf7978425bf0afe0c12f952d557f2943e by cj401-amd <chunyjin@amd.com>:\n\nupdate with a successful hermetic build locally\n\nMerging this change closes #29769\n\nPiperOrigin-RevId: 828829024",
    "sha": "4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
    "files": [
        {
            "sha": "a16d1ecc077bb0ca7080376a2935b7062391b490",
            "filename": "third_party/xla/third_party/gpus/rocm/BUILD.tpl",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2FBUILD.tpl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2FBUILD.tpl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2FBUILD.tpl?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -368,6 +368,19 @@ cc_library(\n     deps = [\":rocm_config\"],\n )\n \n+cc_library(\n+    name = \"rocprofiler-sdk\",\n+    srcs = glob([\"%{rocm_root}/lib/librocprofiler-sdk*.so*\"]),\n+    hdrs = glob([\"%{rocm_root}/include/rocprofiler-sdk/**\"]),\n+    include_prefix = \"rocm\",\n+    includes = [\n+        \"%{rocm_root}/include/\",\n+    ],\n+    strip_include_prefix = \"%{rocm_root}\",\n+    visibility = [\"//visibility:public\"],\n+    deps = [\":rocm_config\"],\n+)\n+\n cc_library(\n     name = \"rocsolver\",\n     hdrs = glob([\"%{rocm_root}/include/rocsolver/**\"]),"
        },
        {
            "sha": "1d94a2fa5b2a6c1bd81fcb761042fce7179ebe3d",
            "filename": "third_party/xla/third_party/gpus/rocm/rocm_redist_ubuntu_22_04.bzl",
            "status": "modified",
            "additions": 193,
            "deletions": 16,
            "changes": 209,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2Frocm_redist_ubuntu_22_04.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2Frocm_redist_ubuntu_22_04.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2Frocm_redist_ubuntu_22_04.bzl?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -17,14 +17,6 @@ rocm_redist_ubuntu_22_04 = {\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblas/hipblas_2.4.0.60401-83~22.04_amd64.deb\",\n                 sha256 = \"9d1bb3a5006a5b69655abbd890efaad1d347b3cd66b5d0a7fe60a6885494b19b\",\n             ),\n-            struct(\n-                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblaslt6.4.1/hipblaslt6.4.1_0.12.1.60401-83~22.04_amd64.deb\",\n-                sha256 = \"b53019fa5e46dc1ec4725960da9c30c6564db7adc10eb176f00d6dc99f565f3a\",\n-            ),\n-            struct(\n-                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblaslt-dev6.4.1/hipblaslt-dev6.4.1_0.12.1.60401-83~22.04_amd64.deb\",\n-                sha256 = \"23a8ed2da0d56cf79336eef3d502c57daf06934e8ca7225b4e6b449e59de3dab\",\n-            ),\n             struct(\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblas-dev/hipblas-dev_2.4.0.60401-83~22.04_amd64.deb\",\n                 sha256 = \"df5dd894a6840693f060fcdd1e96c0e8cf9eed16b2763643f17a5a9c4baa69a5\",\n@@ -149,6 +141,18 @@ rocm_redist_ubuntu_22_04 = {\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocprofiler-register/rocprofiler-register_0.4.0.60401-83~22.04_amd64.deb\",\n                 sha256 = \"da49a66ca3e6ee8b9491777c2b5170b6020e8308371e26b869d7af81bc50f571\",\n             ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocprofiler-sdk/rocprofiler-sdk_0.6.0-83~22.04_amd64.deb\",\n+                sha256 = \"9890bc2ddbf563edbb50fc8d227a56da462a8bcdd08dbc2f549c924b89c42a59\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocprofiler-sdk-roctx/rocprofiler-sdk-roctx_0.6.0-83~22.04_amd64.deb\",\n+                sha256 = \"87eddf255f80bbe3c371e0a087a1045ec82766903077de2fb708ed1958ab62fb\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hsa-rocr-dev/hsa-rocr-dev_1.15.0.60401-83~22.04_amd64.deb\",\n+                sha256 = \"e1221293f8a5501ef01324c381e61d76a5d2e0f11032e4d33766dc53efc75813\",\n+            ),\n             struct(\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocrand6.4.1/rocrand6.4.1_3.3.0.60401-83~22.04_amd64.deb\",\n                 sha256 = \"ebc85dfef24a03afc28671e3df47519f520bedd08643ef5957dd5b08e15dc1f1\",\n@@ -218,14 +222,6 @@ rocm_redist_ubuntu_22_04 = {\n                 url = \"https://repo.radeon.com/rocm/apt/6.2/pool/main/h/hipblas-dev6.2.0/hipblas-dev6.2.0_2.2.0.60200-66~22.04_amd64.deb\",\n                 sha256 = \"885cf3f3a52ebde9caadf6348a6cda28fd15e3bc52bab0c90b587d72b29ff7ef\",\n             ),\n-            struct(\n-                url = \"https://repo.radeon.com/rocm/apt/6.2/pool/main/h/hipblaslt6.2.0/hipblaslt6.2.0_0.8.0.60200-66~22.04_amd64.deb\",\n-                sha256 = \"af3bea7cda7c1af147c3baae1cb3a8846ff571fe713c3a83d0924810bee734fe\",\n-            ),\n-            struct(\n-                url = \"https://repo.radeon.com/rocm/apt/6.2/pool/main/h/hipblaslt-dev6.2.0/hipblaslt-dev6.2.0_0.8.0.60200-66~22.04_amd64.deb\",\n-                sha256 = \"d9d2c80228ebfe74ebb98fc74fda57be498ab84ca40358355c616dfd38efded2\",\n-            ),\n             struct(\n                 url = \"https://repo.radeon.com/rocm/apt/6.2/pool/main/h/hipcc6.2.0/hipcc6.2.0_1.1.1.60200-66~22.04_amd64.deb\",\n                 sha256 = \"468026fa8eb70121f0c545557a926ddc41228cef9457b4a00d8fc3a36b04310f\",\n@@ -389,4 +385,185 @@ rocm_redist_ubuntu_22_04 = {\n         ],\n         \"rocm_root\": \"opt/rocm-6.2.0\",\n     },\n+    \"6.1.0\": {\n+        \"archives\": [\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/c/comgr6.1.0/comgr6.1.0_2.7.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"49967e2e98b96a95c618a1db7eacf8892b2700e0cf88960b3b0097da081ec1c8\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hip-runtime-amd/hip-runtime-amd_6.1.40091.60100-82~22.04_amd64.deb\",\n+                sha256 = \"8cb31ffd9d313e19a6e9b7bed8a106d0ed59fe92f479fa042405217f787cae16\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hip-dev6.1.0/hip-dev6.1.0_6.1.40091.60100-82~22.04_amd64.deb\",\n+                sha256 = \"7ca5568b754948576555b07924abbb35e24b7448b6f612738a5fdde6ae7020c9\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipblas6.1.0/hipblas6.1.0_2.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"4703e568dd8d6314b81508260b9d799c577ee38ae59655ce6a4782c0f6d3e3ef\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipblas-dev6.1.0/hipblas-dev6.1.0_2.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"3b6ddd2df992002afd0684de4ace6a6e86e497c4db95813febd7c0da851f8da5\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipcc6.1.0/hipcc6.1.0_1.0.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"e11db2414fec41b45f605616a10793956611850b42406bdf5c4f067e195e502a\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipcub-dev6.1.0/hipcub-dev6.1.0_3.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"888d7643506f00023b617beb8446d09608216dae075e978c7862a41adb7e94c2\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipfft6.1.0/hipfft6.1.0_1.0.14.60100-82~22.04_amd64.deb\",\n+                sha256 = \"e8de4cd7a377a718e8c4392e02fafbe3f43f38a2397aaf5cd2136eb03c43a5c3\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipfft-dev6.1.0/hipfft-dev6.1.0_1.0.14.60100-82~22.04_amd64.deb\",\n+                sha256 = \"afaf929e06c43310b5325a735169e73af85cf5e764d43ef319038d25484201b5\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipsolver6.1.0/hipsolver6.1.0_2.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"6bb779344bd39e9da75ee8474d7de5d10e6993d627e6cbd9ac7a3fcf260b1a6a\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipsolver-dev6.1.0/hipsolver-dev6.1.0_2.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"450c0849203b69da15d593fde712555328715626027df980823df9458f9b4631\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipsparse6.1.0/hipsparse6.1.0_3.0.1.60100-82~22.04_amd64.deb\",\n+                sha256 = \"b3806a85a483da4fa06f8e4edf917c5ceb1a4c00af6426ec61fbec23828291b3\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hipsparse-dev6.1.0/hipsparse-dev6.1.0_3.0.1.60100-82~22.04_amd64.deb\",\n+                sha256 = \"7003d85e42e988d9e5b80da0d5b81aa34a393ded1d9d567b0edf06e3ba2fc9b4\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hiprand6.1.0/hiprand6.1.0_2.10.16.60100-82~22.04_amd64.deb\",\n+                sha256 = \"bf6678ba14b9baebe6fe39a0aeaeeb2c10b8154a5e9c6d0223d8b01f36d1a7b9\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hiprand-dev6.1.0/hiprand-dev6.1.0_2.10.16.60100-82~22.04_amd64.deb\",\n+                sha256 = \"3f2069097efc8a9bbf1cb9be60f7240dcd17a5380614b2b6faf29c7b53b657c4\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hsa-rocr6.1.0/hsa-rocr6.1.0_1.13.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"562904659abd5e905a806b4ffc30af5c25442e3d6143e6a99b4660badced2b86\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/m/miopen-hip6.1.0/miopen-hip6.1.0_3.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"2f26448b8ef551383bf16f0e066dd6f4b7539b51f382b7028b377de5164f8b63\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/m/miopen-hip-dev6.1.0/miopen-hip-dev6.1.0_3.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"df6d5a8151f216dc02cd96e45d0ca8133cca51d272ede25eb30898f07d0f3e82\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rccl6.1.0/rccl6.1.0_2.18.6.60100-82~22.04_amd64.deb\",\n+                sha256 = \"2d367697957bba93c79e8da1d1bc7c8bbd8d07fb7f013de7c83824f9047372f1\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rccl-dev6.1.0/rccl-dev6.1.0_2.18.6.60100-82~22.04_amd64.deb\",\n+                sha256 = \"1c4927aa49e4dcb441608c3fa6ec86c9d078aaa767214be2b213c1a8421a3929\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocblas6.1.0/rocblas6.1.0_4.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"43cb1dd308f08a9d766ed846bd4d345b74fcc3a87e6e7ee727c7e5cf49629416\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocblas-dev/rocblas-dev_4.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"fc8bef370666fad72c01fc131749ccb835b8bfcb1639ed43dda26b9e64702b3b\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocfft6.1.0/rocfft6.1.0_1.0.27.60100-82~22.04_amd64.deb\",\n+                sha256 = \"50d0ad3cb37a69285b6132a17fdefbdea2e18ab6faf8265ead44ef3d7a4d16cb\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocfft-dev6.1.0/rocfft-dev6.1.0_1.0.27.60100-82~22.04_amd64.deb\",\n+                sha256 = \"2e091de9499e493c03a79ca7673b9c8640f896051542ff3c4f635efccc97d10f\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocm-core6.1.0/rocm-core6.1.0_6.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"685993f25f9da6e17cf69bc7dc9cdde0ca33b9955474a11bb903cae0d4a25d66\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocm-hip-libraries/rocm-hip-libraries_6.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"57c4212475dd5a8fe2bdab92eeff71332a0d408615dc2a4254482eb46d13e212\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/h/hip-dev6.1.0/hip-dev6.1.0_6.1.40091.60100-82~22.04_amd64.deb\",\n+                sha256 = \"7ca5568b754948576555b07924abbb35e24b7448b6f612738a5fdde6ae7020c9\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocm-device-libs/rocm-device-libs_1.0.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"7e155798e1027dd4fc0d49a89865245f3017090e44ea057584b8b86d5ea931cd\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocminfo/rocminfo_1.0.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"b7cf95b3b20e3accba23de34265ac408603176279412fda116dce47047a36e7b\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocm-llvm/rocm-llvm_17.0.0.24103.60100-82~22.04_amd64.deb\",\n+                sha256 = \"4c245a83e48517d627f34f52c0e7020434dcf4ef4ef073c736afc60e69f8b6f2\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocm-llvm-dev6.1.0/rocm-llvm-dev6.1.0_17.0.0.24103.60100-82~22.04_amd64.deb\",\n+                sha256 = \"c99854c0b92ea9c530be6c656157d26587b74c4ea1e9e12522570438a189d5b9\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocm-smi-lib6.1.0/rocm-smi-lib6.1.0_7.0.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"4b02aa9e5e09a36303e185def69ae67702a7177a5e6793e00565c8c6fdd32f88\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocprim-dev6.1.0/rocprim-dev6.1.0_3.1.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"ce3ce32ed9692c58d1a6ba089a7c07b27d2935b0f126a1c84b214cd2433ebe48\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocprofiler-register6.1.0/rocprofiler-register6.1.0_0.3.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"73b877f13ba65c6ba01197452c3b538f50f687d54ae0b3428c85c07bff20dcb7\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocrand-dev6.1.0/rocrand-dev6.1.0_3.0.1.60100-82~22.04_amd64.deb\",\n+                sha256 = \"afcdfa0cbc71363ccd9bb71f421343b12263bc88d42fa9a4c78c60bbc3fa17d3\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/roctracer6.1.0/roctracer6.1.0_4.1.60100.60100-82~22.04_amd64.deb\",\n+                sha256 = \"c98aedc99d252bf40b8069f497d24d60e2eaca25d001471e42ceb4df531ecba7\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/roctracer-dev6.1.0/roctracer-dev6.1.0_4.1.60100.60100-82~22.04_amd64.deb\",\n+                sha256 = \"9c2967d988e7a1408a3e4b2c83177eb7c88af939619a9d0d5ab7af2db9489884\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocsolver6.1.0/rocsolver6.1.0_3.25.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"65a6270f66194e033af1dc4b238bf7ecdfa439933b9c330bcb307caf516e8b3b\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocsolver-dev6.1.0/rocsolver-dev6.1.0_3.25.0.60100-82~22.04_amd64.deb\",\n+                sha256 = \"ca40789c82d3e46f2951cb0b1a7d5e8026daf5af6d597693746d95b8a49cd9a1\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.1/pool/main/r/rocsparse6.1.0/rocsparse6.1.0_3.1.2.60100-82~22.04_amd64.deb\",\n+                sha256 = \"ede46a9ccd505543425c5f75c6e8180c05c3b865dd638edbe297237664b3fe31\",\n+            ),\n+            struct(\n+                url = \"https://mirror.bazel.build/github.com/alekstheod/rocm-deps/releases/download/rocm-6.2.0/libdrm2_2.4.101-2_amd64.deb\",\n+                sha256 = \"4cd2e10f9486456a2782487f8bfd39f330f35a4d5bd6d693412b9e4ca2a6acbd\",\n+            ),\n+            struct(\n+                url = \"https://mirror.bazel.build/github.com/alekstheod/rocm-deps/releases/download/rocm-6.2.0/libdrm-amdgpu1_2.4.101-2_amd64.deb\",\n+                sha256 = \"d4567a30f7d68b4dcf794f8677b96e89083693c94e88279fecf577ceba8b9774\",\n+            ),\n+            struct(\n+                url = \"https://mirror.bazel.build/github.com/alekstheod/rocm-deps/releases/download/rocm-6.2.0/libelf1_0.176-1.1build1_amd64.deb\",\n+                sha256 = \"78a8761227efc04a1e37527f2f33ba608c6fb5d6c911616346ada5d7b9b72ee3\",\n+            ),\n+            struct(\n+                url = \"https://mirror.bazel.build/github.com/alekstheod/rocm-deps/releases/download/rocm-6.2.0/libnuma1_2.0.12-1_amd64.deb\",\n+                sha256 = \"0b1edf08cf9befecd21fe94e298ac25e476f87fd876ddd4adf42ef713449e637\",\n+            ),\n+        ],\n+        \"rocm_root\": \"opt/rocm-6.1.0\",\n+    },\n }"
        },
        {
            "sha": "f45a1f6f2b66fb789443475c281cfafaefc52c82",
            "filename": "third_party/xla/third_party/gpus/rocm/rocm_redist_ubuntu_24_04.bzl",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2Frocm_redist_ubuntu_24_04.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2Frocm_redist_ubuntu_24_04.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2Frocm_redist_ubuntu_24_04.bzl?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -17,14 +17,6 @@ rocm_redist_ubuntu_24_04 = {\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblas/hipblas_2.4.0.60401-83~24.04_amd64.deb\",\n                 sha256 = \"feaf51ba1b97d59d525a7317f6940dce01de85b18ab1356e198aae6287c9f25a\",\n             ),\n-            struct(\n-                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblaslt6.4.1/hipblaslt6.4.1_0.12.1.60401-83~24.04_amd64.deb\",\n-                sha256 = \"f3b3b5456f0b69b82c7ab1ccc9762a3a09e2ddc42b73cfa38a4c060755d5fb91\",\n-            ),\n-            struct(\n-                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblaslt-dev6.4.1/hipblaslt-dev6.4.1_0.12.1.60401-83~22.04_amd64.deb\",\n-                sha256 = \"23a8ed2da0d56cf79336eef3d502c57daf06934e8ca7225b4e6b449e59de3dab\",\n-            ),\n             struct(\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hipblas-dev/hipblas-dev_2.4.0.60401-83~24.04_amd64.deb\",\n                 sha256 = \"4503107e2979b014870781067e2ad7976b9981e0a84fdde288a6247187e36725\",\n@@ -149,6 +141,18 @@ rocm_redist_ubuntu_24_04 = {\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocprofiler-register/rocprofiler-register_0.4.0.60401-83~24.04_amd64.deb\",\n                 sha256 = \"b0d459cf9deaab61c199c629c9298d50a7f50f538c6f08fc9a99c420290c6e04\",\n             ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocprofiler-sdk-roctx/rocprofiler-sdk-roctx_0.6.0-83~24.04_amd64.deb\",\n+                sha256 = \"a965d93d4de982a7b86e0681bf6ffa0a1b5d8e4b47ab99f611fe664baee920d3\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocprofiler-sdk/rocprofiler-sdk_0.6.0-83~24.04_amd64.deb\",\n+                sha256 = \"5212e822f652f4ecf662077aa469ee649d2d470b9d91d2aba2175b1821050e73\",\n+            ),\n+            struct(\n+                url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/h/hsa-rocr-dev/hsa-rocr-dev_1.15.0.60401-83~24.04_amd64.deb\",\n+                sha256 = \"eb63dfa66564fc3d2ff73aaa763c4f7a61c0308187f62a1ac246bb739a31333e\",\n+            ),\n             struct(\n                 url = \"https://repo.radeon.com/rocm/apt/6.4.1/pool/main/r/rocrand6.4.1/rocrand6.4.1_3.3.0.60401-83~24.04_amd64.deb\",\n                 sha256 = \"d572e64ca54d29482829a694badc65d09893d18ae3352c8d8d37abae23e7fd58\","
        },
        {
            "sha": "58f231603bc879aebc73cbbaaa1698d143f82864",
            "filename": "third_party/xla/third_party/gpus/rocm_configure.bzl",
            "status": "modified",
            "additions": 23,
            "deletions": 17,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm_configure.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm_configure.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm_configure.bzl?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -240,7 +240,6 @@ def _rocm_lib_paths(repository_ctx, lib, basedir):\n         repository_ctx.path(\"%s/lib64/stubs/%s\" % (basedir, file_name)),\n         repository_ctx.path(\"%s/lib/x86_64-linux-gnu/%s\" % (basedir, file_name)),\n         repository_ctx.path(\"%s/lib/%s\" % (basedir, file_name)),\n-        repository_ctx.path(\"%s/lib/%s.0\" % (basedir, file_name)),  # hipblaslt has this pattern\n         repository_ctx.path(\"%s/%s\" % (basedir, file_name)),\n     ]\n \n@@ -311,7 +310,7 @@ def _select_rocm_lib_paths(repository_ctx, libs_paths, bash_bin):\n \n     return libs\n \n-def _find_libs(repository_ctx, rocm_config, bash_bin):\n+def _find_libs(repository_ctx, rocm_config, miopen_path, rccl_path, bash_bin):\n     \"\"\"Returns the ROCm libraries on the system.\n \n     Args:\n@@ -322,26 +321,29 @@ def _find_libs(repository_ctx, rocm_config, bash_bin):\n     Returns:\n       Map of library names to structs of filename and path\n     \"\"\"\n-    repo_path = str(repository_ctx.path(rocm_config.rocm_toolkit_path))\n     libs_paths = [\n         (name, _rocm_lib_paths(repository_ctx, name, path))\n         for name, path in [\n-            (\"amdhip64\", repo_path),\n-            (\"rocblas\", repo_path),\n-            (\"hiprand\", repo_path),\n-            (\"MIOpen\", repo_path),\n-            (\"rccl\", repo_path),\n-            (\"hipsparse\", repo_path),\n-            (\"roctracer64\", repo_path),\n-            (\"rocsolver\", repo_path),\n-            (\"hipfft\", repo_path),\n-            (\"rocrand\", repo_path),\n-            (\"hipsolver\", repo_path),\n-            (\"hipblas\", repo_path),\n-            (\"hipblaslt\", repo_path),\n+            (\"amdhip64\", rocm_config.rocm_toolkit_path),\n+            (\"rocblas\", rocm_config.rocm_toolkit_path),\n+            (\"hiprand\", rocm_config.rocm_toolkit_path),\n+            (\"MIOpen\", miopen_path),\n+            (\"rccl\", rccl_path),\n+            (\"hipsparse\", rocm_config.rocm_toolkit_path),\n+            (\"roctracer64\", rocm_config.rocm_toolkit_path),\n+            (\"rocsolver\", rocm_config.rocm_toolkit_path),\n+            (\"hipfft\", rocm_config.rocm_toolkit_path),\n+            (\"rocrand\", rocm_config.rocm_toolkit_path),\n+            (\"rocprofiler-sdk\", rocm_config.rocm_toolkit_path),\n         ]\n     ]\n+    if int(rocm_config.rocm_version_number) >= 40500:\n+        libs_paths.append((\"hipsolver\", _rocm_lib_paths(repository_ctx, \"hipsolver\", rocm_config.rocm_toolkit_path)))\n+        libs_paths.append((\"hipblas\", _rocm_lib_paths(repository_ctx, \"hipblas\", rocm_config.rocm_toolkit_path)))\n \n+    # hipblaslt may be absent even in versions of ROCm where it exists\n+    # (it is not installed by default in some containers). Autodetect.\n+    libs_paths.append((\"hipblaslt\", _rocm_lib_paths(repository_ctx, \"hipblaslt\", rocm_config.rocm_toolkit_path), True))\n     return _select_rocm_lib_paths(repository_ctx, libs_paths, bash_bin)\n \n def find_rocm_config(repository_ctx, rocm_path):\n@@ -582,12 +584,16 @@ def _create_local_rocm_repository(repository_ctx):\n     rocm_config = _setup_rocm_distro_dir(repository_ctx)\n     rocm_version_number = int(rocm_config.rocm_version_number)\n \n+    # For ROCm 5.2 and above, find MIOpen and RCCL in the main rocm lib path\n+    miopen_path = rocm_config.rocm_toolkit_path + \"/miopen\" if rocm_version_number < 50200 else rocm_config.rocm_toolkit_path\n+    rccl_path = rocm_config.rocm_toolkit_path + \"/rccl\" if rocm_version_number < 50200 else rocm_config.rocm_toolkit_path\n+\n     # Copy header and library files to execroot.\n     # rocm_toolkit_path\n     rocm_toolkit_path = _remove_root_dir(rocm_config.rocm_toolkit_path, \"rocm\")\n \n     bash_bin = get_bash_bin(repository_ctx)\n-    rocm_libs = _find_libs(repository_ctx, rocm_config, bash_bin)\n+    rocm_libs = _find_libs(repository_ctx, rocm_config, miopen_path, rccl_path, bash_bin)\n     rocm_lib_srcs = []\n     rocm_lib_outs = []\n     for lib in rocm_libs.values():"
        },
        {
            "sha": "3440fa031816c3bd8bcdd2c7af4cc42412c335dd",
            "filename": "third_party/xla/xla/backends/profiler/gpu/BUILD",
            "status": "modified",
            "additions": 101,
            "deletions": 55,
            "changes": 156,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2FBUILD?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -65,20 +65,14 @@ cc_library(\n     deps = [\n         \":rocm_collector\",\n         \":rocm_tracer\",\n+        \":rocm_tracer_utils\",\n         \"//xla/stream_executor/rocm:roctracer_wrapper\",\n         \"//xla/tsl/platform:env_time\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/profiler/backends/cpu:annotation_stack\",\n-        \"//xla/tsl/profiler/utils:parse_annotation\",\n-        \"//xla/tsl/profiler/utils:trace_utils\",\n-        \"//xla/tsl/profiler/utils:xplane_builder\",\n-        \"//xla/tsl/profiler/utils:xplane_schema\",\n-        \"//xla/tsl/profiler/utils:xplane_utils\",\n-        \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/strings\",\n-        \"@local_config_rocm//rocm:rocm_headers\",\n         \"@local_tsl//tsl/profiler/lib:profiler_factory\",\n         \"@local_tsl//tsl/profiler/lib:profiler_interface\",\n     ],\n@@ -157,7 +151,9 @@ xla_test(\n         \":cupti_wrapper\",\n         \":mock_cupti\",\n         \"//xla/tsl/profiler/utils:time_utils\",\n+        \"@com_google_absl//absl/memory\",\n         \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n \n@@ -201,6 +197,29 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"cupti_tracer_options_utils\",\n+    srcs = [\"cupti_tracer_options_utils.cc\"],\n+    hdrs = [\"cupti_tracer_options_utils.h\"],\n+    # copybara:uncomment compatible_with = [\"//buildenv/target:non_prod\"],\n+    tags = [\n+        \"cuda-only\",\n+        \"gpu\",\n+    ],\n+    deps = [\n+        \":cupti_collector\",\n+        \":cupti_tracer\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/profiler/utils:profiler_options_util\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@local_config_cuda//cuda:cuda_headers\",\n+        \"@local_tsl//tsl/profiler/protobuf:profiler_options_proto_cc\",\n+    ],\n+)\n+\n cc_library(\n     name = \"cupti_tracer\",\n     srcs = [\"cupti_tracer.cc\"],\n@@ -260,7 +279,6 @@ cc_library(\n         \"cuda-only\",\n         \"gpu\",\n     ],\n-    visibility = [\"//visibility:public\"],\n     deps = [\n         \":cupti_collector\",\n         \":cupti_interface\",\n@@ -287,9 +305,9 @@ cc_library(\n         \"cuda-only\",\n         \"gpu\",\n     ],\n-    visibility = [\"//visibility:public\"],\n     deps = [\n         \":cupti_collector\",\n+        \":cupti_interface\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/time\",\n     ],\n@@ -308,7 +326,6 @@ cc_library(\n         \"gpu\",\n         \"manual\",  # This target requires CUDA 12.6+, therefore we only built it if it was requested via a dependency.\n     ],\n-    visibility = [\"//visibility:public\"],\n     deps = [\n         \":cupti_collector\",\n         \":cupti_interface\",\n@@ -360,6 +377,22 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"rocm_tracer_utils\",\n+    srcs = [\"rocm_tracer_utils.cc\"],\n+    hdrs = [\"rocm_tracer_utils.h\"],\n+    # copybara:uncomment compatible_with = [\"//buildenv/target:non_prod\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/container:node_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/synchronization\",\n+    ],\n+)\n+\n cc_library(\n     name = \"rocm_collector\",\n     srcs = [\"rocm_collector.cc\"],\n@@ -373,30 +406,26 @@ cc_library(\n         \"manual\",\n     ]),\n     deps = [\n+        \":rocm_tracer_utils\",\n         \"//xla/stream_executor/rocm:roctracer_wrapper\",\n-        \"//xla/tsl/profiler/backends/cpu:annotation_stack\",\n+        \"//xla/tsl/platform:status\",\n         \"//xla/tsl/profiler/utils:parse_annotation\",\n+        \"//xla/tsl/profiler/utils:trace_utils\",\n         \"//xla/tsl/profiler/utils:xplane_builder\",\n         \"//xla/tsl/profiler/utils:xplane_schema\",\n         \"//xla/tsl/profiler/utils:xplane_utils\",\n-        \"//xla/tsl/util:env_var\",\n-        \"@com_google_absl//absl/container:fixed_array\",\n+        \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/container:node_hash_map\",\n-        \"@com_google_absl//absl/container:node_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/strings\",\n-        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n+        \"@local_config_rocm//rocm:rocm_headers\",  # buildcleaner: keep\n+        \"@local_config_rocm//rocm:rocprofiler-sdk\",  # buildcleaner: keep\n         \"@local_tsl//tsl/platform:abi\",\n-        \"@local_tsl//tsl/platform:env_time\",\n-        \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:macros\",\n-        \"@local_tsl//tsl/platform:status\",\n-        \"@local_tsl//tsl/platform:thread_annotations\",\n-        \"@local_tsl//tsl/platform:types\",\n-        \"@local_tsl//tsl/profiler/lib:profiler_factory\",\n-        \"@local_tsl//tsl/profiler/lib:profiler_interface\",\n+        \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n     ],\n )\n \n@@ -414,28 +443,68 @@ cc_library(\n     ]),\n     deps = [\n         \":rocm_collector\",\n+        \":rocm_tracer_utils\",\n         \"//xla/stream_executor/rocm:roctracer_wrapper\",\n         \"//xla/tsl/profiler/backends/cpu:annotation_stack\",\n-        \"//xla/tsl/profiler/utils:time_utils\",\n         \"@com_google_absl//absl/container:fixed_array\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n-        \"@com_google_absl//absl/container:node_hash_map\",\n         \"@com_google_absl//absl/container:node_hash_set\",\n-        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n-        \"@local_config_rocm//rocm:rocm_headers\",\n-        \"@local_tsl//tsl/platform:env\",\n+        \"@com_google_absl//absl/types:optional\",\n+        \"@local_config_rocm//rocm:rocm_headers\",  # buildcleaner: keep\n+        \"@local_config_rocm//rocm:rocprofiler-sdk\",  # buildcleaner: keep\n+        \"@local_tsl//tsl/platform:abi\",\n         \"@local_tsl//tsl/platform:errors\",\n-        \"@local_tsl//tsl/platform:logging\",\n         \"@local_tsl//tsl/platform:macros\",\n-        \"@local_tsl//tsl/platform:platform_port\",\n         \"@local_tsl//tsl/platform:status\",\n-        \"@local_tsl//tsl/platform:thread_annotations\",\n         \"@local_tsl//tsl/platform:types\",\n     ],\n )\n \n+xla_cc_test(\n+    name = \"rocm_tracer_test\",\n+    size = \"small\",\n+    srcs = [\"rocm_tracer_test.cc\"],\n+    tags = [\n+        \"gpu\",\n+        \"rocm-only\",\n+    ] + if_google([\n+        # Optional: only run internally if ROCm config is enabled\n+        \"manual\",\n+    ]),\n+    deps = [\n+        \":rocm_collector\",\n+        \":rocm_tracer\",\n+        \":rocm_tracer_utils\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@local_tsl//tsl/profiler/protobuf:xplane_proto_cc\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"rocm_collector_test\",\n+    size = \"small\",\n+    srcs = [\"rocm_collector_test.cc\"],\n+    tags = [\n+        \"gpu\",\n+        \"rocm-only\",\n+    ] + if_google([\n+        \"manual\",\n+    ]),\n+    deps = [\n+        # \":rocm_tracer\",\n+        \":rocm_collector\",\n+        \":rocm_tracer_utils\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"//xla/tsl/profiler/utils:xplane_utils\",\n+    ],\n+)\n+\n cc_library(\n     name = \"cupti_collector\",\n     srcs = [\"cupti_collector.cc\"],\n@@ -690,7 +759,7 @@ xla_test(\n     deps = [\n         \":cupti_collector\",\n         \":cupti_error_manager\",\n-        \":cupti_pm_sampler_stub\",\n+        \":cupti_pm_sampler_factory\",  # buildcleaner: keep\n         \":cupti_tracer\",\n         \":cupti_utils\",\n         \":cupti_wrapper\",\n@@ -701,26 +770,3 @@ xla_test(\n         \"@com_google_googletest//:gtest_main\",\n     ],\n )\n-\n-cc_library(\n-    name = \"cupti_tracer_options_utils\",\n-    srcs = [\"cupti_tracer_options_utils.cc\"],\n-    hdrs = [\"cupti_tracer_options_utils.h\"],\n-    # copybara:uncomment compatible_with = [\"//buildenv/target:non_prod\"],\n-    tags = [\n-        \"cuda-only\",\n-        \"gpu\",\n-    ],\n-    visibility = [\"//visibility:public\"],\n-    deps = [\n-        \":cupti_collector\",\n-        \":cupti_tracer\",\n-        \"//xla/tsl/platform:errors\",\n-        \"//xla/tsl/profiler/utils:profiler_options_util\",\n-        \"@com_google_absl//absl/container:flat_hash_set\",\n-        \"@com_google_absl//absl/status\",\n-        \"@com_google_absl//absl/strings\",\n-        \"@local_config_cuda//cuda:cuda_headers\",\n-        \"@local_tsl//tsl/profiler/protobuf:profiler_options_proto_cc\",\n-    ],\n-)"
        },
        {
            "sha": "bc5efe8eac58d8a08c8838043abf452fd3b252f0",
            "filename": "third_party/xla/xla/backends/profiler/gpu/device_tracer_rocm.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 102,
            "changes": 115,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fdevice_tracer_rocm.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fdevice_tracer_rocm.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Fdevice_tracer_rocm.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -15,17 +15,13 @@ limitations under the License.\n \n #include <cstdint>\n #include <memory>\n-#include <set>\n-#include <vector>\n \n-#include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/str_cat.h\"\n-#include \"rocm/include/hip/amd_detail/hip_prof_str.h\"\n-#include \"rocm/include/roctracer/ext/prof_protocol.h\"\n #include \"xla/backends/profiler/gpu/rocm_collector.h\"\n #include \"xla/backends/profiler/gpu/rocm_tracer.h\"\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n #include \"xla/tsl/platform/env_time.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/profiler/backends/cpu/annotation_stack.h\"\n@@ -38,7 +34,6 @@ namespace profiler {\n using tensorflow::ProfileOptions;\n using tsl::profiler::AnnotationStack;\n using tsl::profiler::ProfilerInterface;\n-using tsl::profiler::RegisterProfilerFactory;\n using tsl::profiler::XSpace;\n \n // GpuTracer for ROCm GPU.\n@@ -59,7 +54,6 @@ class GpuTracer : public profiler::ProfilerInterface {\n   absl::Status DoStop();\n \n   RocmTracerOptions GetRocmTracerOptions();\n-\n   RocmTraceCollectorOptions GetRocmTraceCollectorOptions(uint32_t num_gpus);\n \n   enum State {\n@@ -76,80 +70,8 @@ class GpuTracer : public profiler::ProfilerInterface {\n };\n \n RocmTracerOptions GpuTracer::GetRocmTracerOptions() {\n-  // TODO(rocm-profiler): We need support for context similar to CUDA\n   RocmTracerOptions options;\n-  std::vector<uint32_t> empty_vec;\n-\n-  // clang formatting does not preserve one entry per line\n-  // clang-format off\n-  std::vector<uint32_t> hip_api_domain_ops{\n-      // KERNEL\n-      HIP_API_ID_hipExtModuleLaunchKernel,\n-      HIP_API_ID_hipModuleLaunchKernel,\n-      HIP_API_ID_hipHccModuleLaunchKernel,\n-      HIP_API_ID_hipLaunchKernel,\n-      HIP_API_ID_hipExtLaunchKernel,\n-      // MEMCPY\n-      HIP_API_ID_hipMemcpy,\n-      HIP_API_ID_hipMemcpyAsync,\n-      HIP_API_ID_hipMemcpyDtoD,\n-      HIP_API_ID_hipMemcpyDtoDAsync,\n-      HIP_API_ID_hipMemcpyDtoH,\n-      HIP_API_ID_hipMemcpyDtoHAsync,\n-      HIP_API_ID_hipMemcpyHtoD,\n-      HIP_API_ID_hipMemcpyHtoDAsync,\n-      HIP_API_ID_hipMemcpyPeer,\n-      HIP_API_ID_hipMemcpyPeerAsync,\n-\n-      // MEMSet\n-      HIP_API_ID_hipMemsetD32,\n-      HIP_API_ID_hipMemsetD32Async,\n-      HIP_API_ID_hipMemsetD16,\n-      HIP_API_ID_hipMemsetD16Async,\n-      HIP_API_ID_hipMemsetD8,\n-      HIP_API_ID_hipMemsetD8Async,\n-      HIP_API_ID_hipMemset,\n-      HIP_API_ID_hipMemsetAsync,\n-\n-      // MEMAlloc\n-      HIP_API_ID_hipMalloc,\n-      HIP_API_ID_hipMallocPitch,\n-      // MEMFree\n-      HIP_API_ID_hipFree,\n-      // GENERIC\n-      HIP_API_ID_hipStreamSynchronize,\n-  };\n-  // clang-format on\n-\n-  options.api_tracking_set =\n-      std::set<uint32_t>(hip_api_domain_ops.begin(), hip_api_domain_ops.end());\n-\n-  // These are the list of APIs we track since roctracer activity\n-  // does not provide all the information necessary to fully populate the\n-  // TF events. We need to track the APIs for those activities in API domain but\n-  // we only use them for filling the missing items in their corresponding\n-  // activity (using correlation id).\n-  // clang-format off\n-  std::vector<uint32_t> hip_api_aux_ops{\n-    HIP_API_ID_hipStreamWaitEvent,\n-    // TODO(rocm-profiler): finding device ID from hipEventSynchronize need some\n-    // extra work, we ignore it for now.\n-    // HIP_API_ID_hipEventSynchronize,\n-    HIP_API_ID_hipHostFree,\n-    HIP_API_ID_hipHostMalloc,\n-    HIP_API_ID_hipSetDevice  //  added to track default device\n-  };\n-\n-  // clang-format on\n-\n-  hip_api_domain_ops.insert(hip_api_domain_ops.end(), hip_api_aux_ops.begin(),\n-                            hip_api_aux_ops.end());\n-\n-  // options.api_callbacks.emplace(ACTIVITY_DOMAIN_HIP_API, hip_api_domain_ops);\n-  options.api_callbacks.emplace(ACTIVITY_DOMAIN_HIP_API, empty_vec);\n-\n-  options.activity_tracing.emplace(ACTIVITY_DOMAIN_HIP_OPS, empty_vec);\n-\n+  options.max_annotation_strings = 1024 * 1024;\n   return options;\n }\n \n@@ -164,20 +86,16 @@ RocmTraceCollectorOptions GpuTracer::GetRocmTraceCollectorOptions(\n }\n \n absl::Status GpuTracer::DoStart() {\n-  if (!rocm_tracer_->IsAvailable()) {\n-    return tsl::errors::Unavailable(\"Another profile session running.\");\n-  }\n-\n   AnnotationStack::Enable(true);\n+  uint64_t start_gputime_ns = RocmTracer::GetTimestamp();\n+  uint64_t start_walltime_ns = tsl::EnvTime::NowNanos();\n \n+  RocmTracerOptions tracer_options = GetRocmTracerOptions();\n   RocmTraceCollectorOptions trace_collector_options =\n       GetRocmTraceCollectorOptions(rocm_tracer_->NumGpus());\n-  uint64_t start_gputime_ns = RocmTracer::GetTimestamp();\n-  uint64_t start_walltime_ns = tsl::EnvTime::NowNanos();\n   rocm_trace_collector_ = CreateRocmCollector(\n       trace_collector_options, start_walltime_ns, start_gputime_ns);\n \n-  RocmTracerOptions tracer_options = GetRocmTracerOptions();\n   rocm_tracer_->Enable(tracer_options, rocm_trace_collector_.get());\n \n   return absl::OkStatus();\n@@ -188,9 +106,10 @@ absl::Status GpuTracer::Start() {\n   if (status.ok()) {\n     profiling_state_ = State::kStartedOk;\n     return absl::OkStatus();\n+  } else {\n+    profiling_state_ = State::kStartedError;\n+    return status;\n   }\n-  profiling_state_ = State::kStartedError;\n-  return status;\n }\n \n absl::Status GpuTracer::DoStop() {\n@@ -222,9 +141,7 @@ absl::Status GpuTracer::CollectData(XSpace* space) {\n       VLOG(3) << \"No trace data collected\";\n       return absl::OkStatus();\n     case State::kStoppedOk: {\n-      if (rocm_trace_collector_) {\n-        rocm_trace_collector_->Export(space);\n-      }\n+      if (rocm_trace_collector_) rocm_trace_collector_->Export(space);\n       return absl::OkStatus();\n     }\n   }\n@@ -236,17 +153,11 @@ absl::Status GpuTracer::CollectData(XSpace* space) {\n std::unique_ptr<profiler::ProfilerInterface> CreateGpuTracer(\n     const ProfileOptions& options) {\n   if (options.device_type() != ProfileOptions::GPU &&\n-      options.device_type() != ProfileOptions::UNSPECIFIED) {\n-    return nullptr;\n-  }\n-\n-  profiler::RocmTracer* rocm_tracer =\n-      profiler::RocmTracer::GetRocmTracerSingleton();\n-  if (!rocm_tracer->IsAvailable()) {\n+      options.device_type() != ProfileOptions::UNSPECIFIED)\n     return nullptr;\n-  }\n-\n-  return std::make_unique<profiler::GpuTracer>(rocm_tracer);\n+  auto& rocm_tracer = profiler::RocmTracer::GetRocmTracerSingleton();\n+  if (!rocm_tracer.IsAvailable()) return nullptr;\n+  return std::make_unique<profiler::GpuTracer>(&rocm_tracer);\n }\n \n auto register_rocm_gpu_tracer_factory = [] {"
        },
        {
            "sha": "5bcb9d52e84d1e77a7e1be7b96860ff6ca4f988e",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_collector.cc",
            "status": "modified",
            "additions": 456,
            "deletions": 623,
            "changes": 1079,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -1,4 +1,3 @@\n-\n /* Copyright 2024 The OpenXLA Authors. All Rights Reserved.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n@@ -16,72 +15,52 @@ limitations under the License.\n \n #include \"xla/backends/profiler/gpu/rocm_collector.h\"\n \n-#include \"absl/container/fixed_array.h\"\n+#include <algorithm>\n+#include <cstddef>\n+#include <cstdint>\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n-#include \"absl/container/node_hash_map.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_format.h\"\n #include \"absl/strings/str_join.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n-#include \"xla/stream_executor/rocm/roctracer_wrapper.h\"\n-#include \"xla/tsl/profiler/backends/cpu/annotation_stack.h\"\n+#include \"rocm/include/hip/hip_runtime.h\"\n+#include \"rocm/include/rocprofiler-sdk/fwd.h\"\n+#include \"rocm/include/rocprofiler-sdk/rocprofiler.h\"\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n+#include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/profiler/utils/parse_annotation.h\"\n+#include \"xla/tsl/profiler/utils/trace_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_builder.h\"\n #include \"xla/tsl/profiler/utils/xplane_schema.h\"\n #include \"xla/tsl/profiler/utils/xplane_utils.h\"\n-#include \"xla/tsl/util/env_var.h\"\n #include \"tsl/platform/abi.h\"\n-#include \"tsl/platform/env_time.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/macros.h\"\n-#include \"tsl/platform/status.h\"\n-#include \"tsl/platform/thread_annotations.h\"\n-#include \"tsl/platform/types.h\"\n-#include \"tsl/profiler/lib/profiler_factory.h\"\n-#include \"tsl/profiler/lib/profiler_interface.h\"\n \n namespace xla {\n namespace profiler {\n \n-namespace se = ::stream_executor;\n-using tensorflow::ProfileOptions;\n+using tsl::Status;\n using tsl::profiler::Annotation;\n-using tsl::profiler::AnnotationStack;\n using tsl::profiler::FindOrAddMutablePlaneWithName;\n using tsl::profiler::GetStatTypeStr;\n using tsl::profiler::GpuPlaneName;\n using tsl::profiler::kDeviceVendorAMD;\n-using tsl::profiler::kThreadIdOverhead;\n using tsl::profiler::ParseAnnotationStack;\n-using tsl::profiler::ProfilerInterface;\n-// using tsl::profiler::RegisterProfilerFactory;\n using tsl::profiler::StatType;\n using tsl::profiler::XEventBuilder;\n using tsl::profiler::XEventMetadata;\n using tsl::profiler::XLineBuilder;\n using tsl::profiler::XPlaneBuilder;\n using tsl::profiler::XSpace;\n \n-void AnnotationMap::Add(uint32_t correlation_id,\n-                        const std::string& annotation) {\n-  if (annotation.empty()) return;\n-  VLOG(3) << \"Add annotation: \"\n-          << \" correlation_id=\" << correlation_id\n-          << \", annotation: \" << annotation;\n-  absl::MutexLock lock(map_.mutex);\n-  if (map_.annotations.size() < max_size_) {\n-    absl::string_view annotation_str =\n-        *map_.annotations.insert(annotation).first;\n-    map_.correlation_map.emplace(correlation_id, annotation_str);\n-  }\n-}\n-\n-absl::string_view AnnotationMap::LookUp(uint32_t correlation_id) {\n-  absl::MutexLock lock(map_.mutex);\n-  auto it = map_.correlation_map.find(correlation_id);\n-  return it != map_.correlation_map.end() ? it->second : absl::string_view();\n-}\n-\n //==========\n namespace {\n // Set the all XLines of specified XPlane to starting walltime.\n@@ -100,26 +79,27 @@ std::string GetDeviceXLineName(\n     int64_t stream_id, absl::flat_hash_set<RocmTracerEventType>& event_types) {\n   std::string line_name = absl::StrCat(\"Stream #\", stream_id);\n   event_types.erase(RocmTracerEventType::Unsupported);\n-  if (event_types.empty()) return line_name;\n+  if (event_types.empty()) {\n+    return line_name;\n+  }\n   std::vector<const char*> type_names;\n   for (const auto event_type : event_types) {\n     type_names.emplace_back(GetRocmTracerEventTypeName(event_type));\n   }\n   return absl::StrCat(line_name, \"(\", absl::StrJoin(type_names, \",\"), \")\");\n }\n \n-}  // namespace\n-\n-static void DumpRocmTracerEvent(const RocmTracerEvent& event,\n-                                uint64_t start_walltime_ns,\n-                                uint64_t start_gputime_ns,\n-                                const std::string& message) {\n+void PrintRocmTracerEvent(const RocmTracerEvent& event,\n+                          absl::string_view message = {},\n+                          uint64_t start_walltime_ns = 0,\n+                          uint64_t start_gputime_ns = 0) {\n   std::ostringstream oss;\n   oss << \"correlation_id=\" << event.correlation_id;\n   oss << \",type=\" << GetRocmTracerEventTypeName(event.type);\n   oss << \",source=\" << GetRocmTracerEventSourceName(event.source);\n   oss << \",domain=\" << GetRocmTracerEventDomainName(event.domain);\n   oss << \",name=\" << event.name;\n+  oss << \",corr_id=\" << event.correlation_id;\n   oss << \",annotation=\" << event.annotation;\n   oss << \",start_time_us=\"\n       << (start_walltime_ns + (start_gputime_ns - event.start_time_ns)) / 1000;\n@@ -134,7 +114,6 @@ static void DumpRocmTracerEvent(const RocmTracerEvent& event,\n     case RocmTracerEventType::MemcpyD2H:\n     case RocmTracerEventType::MemcpyH2D:\n     case RocmTracerEventType::MemcpyD2D:\n-    case RocmTracerEventType::MemcpyP2P:\n       oss << \",num_bytes=\" << event.memcpy_info.num_bytes;\n       oss << \",destination=\" << event.memcpy_info.destination;\n       oss << \",async=\" << event.memcpy_info.async;\n@@ -152,542 +131,404 @@ static void DumpRocmTracerEvent(const RocmTracerEvent& event,\n       DCHECK(false);\n       break;\n   }\n-  oss << message;\n-  VLOG(3) << oss.str();\n+  VLOG(3) << oss.str() << ' ' << message;\n }\n \n-static uint64_t get_timestamp() {\n+uint64_t get_timestamp() {\n   uint64_t ts;\n-  if (se::wrap::roctracer_get_timestamp(&ts) != ROCTRACER_STATUS_SUCCESS) {\n-    const char* errstr = se::wrap::roctracer_error_string();\n-    LOG(ERROR) << \"function roctracer_get_timestamp failed with error \"\n+  rocprofiler_status_t CHECKSTATUS = rocprofiler_get_timestamp(&ts);\n+  if (CHECKSTATUS != ROCPROFILER_STATUS_SUCCESS) {\n+    const char* errstr = rocprofiler_get_status_string(CHECKSTATUS);\n+    LOG(ERROR) << \"function rocprofiler_get_timestamp failed with error \"\n                << errstr;\n-    // Return 0 on error.\n     return 0;\n   }\n   return ts;\n }\n+}  // namespace\n \n-struct RocmDeviceOccupancyParams {\n-  hipFuncAttributes attributes = {};\n-  int block_size = 0;\n-  size_t dynamic_smem_size = 0;\n-  void* func_ptr;\n-\n-  friend bool operator==(const RocmDeviceOccupancyParams& lhs,\n-                         const RocmDeviceOccupancyParams& rhs) {\n-    return 0 == memcmp(&lhs, &rhs, sizeof(lhs));\n+OccupancyStats PerDeviceCollector::GetOccupancy(\n+    const RocmDeviceOccupancyParams& params) const {\n+  // TODO(rocm-profiler): hipOccupancyMaxActiveBlocksPerMultiprocessor only\n+  // return hipSuccess for HIP_API_ID_hipLaunchKernel\n+  OccupancyStats stats;\n+  int number_of_active_blocks;\n+  hipError_t err = hipOccupancyMaxActiveBlocksPerMultiprocessor(\n+      &number_of_active_blocks, params.func_ptr, params.block_size,\n+      params.dynamic_smem_size);\n+\n+  if (err != hipError_t::hipSuccess) {\n+    return {};\n   }\n \n-  template <typename H>\n-  friend H AbslHashValue(H hash_state,\n-                         const RocmDeviceOccupancyParams& params) {\n-    return H::combine(\n-        std::move(hash_state), params.attributes.maxThreadsPerBlock,\n-        params.attributes.numRegs, params.attributes.sharedSizeBytes,\n-        params.attributes.maxDynamicSharedSizeBytes, params.block_size,\n-        params.dynamic_smem_size, params.func_ptr);\n-  }\n-};\n-\n-struct OccupancyStats {\n-  double occupancy_pct = 0.0;\n-  int min_grid_size = 0;\n-  int suggested_block_size = 0;\n-};\n-\n-struct CorrelationInfo {\n-  CorrelationInfo(uint32_t t, uint32_t e) : thread_id(t), enqueue_time_ns(e) {}\n-  uint32_t thread_id;\n-  uint64_t enqueue_time_ns;\n-};\n-\n-class PerDeviceCollector {\n- private:\n-  OccupancyStats GetOccupancy(const RocmDeviceOccupancyParams& params) const {\n-    // TODO(rocm-profiler): hipOccupancyMaxActiveBlocksPerMultiprocessor only\n-    // return hipSuccess for HIP_API_ID_hipLaunchKernel\n-\n-    OccupancyStats stats;\n-    int number_of_active_blocks;\n-    hipError_t err = hipOccupancyMaxActiveBlocksPerMultiprocessor(\n-        &number_of_active_blocks, params.func_ptr, params.block_size,\n-        params.dynamic_smem_size);\n-\n-    if (err != hipError_t::hipSuccess) {\n-      return {};\n-    }\n+  stats.occupancy_pct = number_of_active_blocks * params.block_size * 100;\n+  stats.occupancy_pct /= device_properties_.maxThreadsPerMultiProcessor;\n \n-    stats.occupancy_pct = number_of_active_blocks * params.block_size * 100;\n-    stats.occupancy_pct /= device_properties_.maxThreadsPerMultiProcessor;\n+  err = hipOccupancyMaxPotentialBlockSize(\n+      &stats.min_grid_size, &stats.suggested_block_size,\n+      static_cast<const void*>(params.func_ptr), params.dynamic_smem_size, 0);\n \n-    err = hipOccupancyMaxPotentialBlockSize(\n-        &stats.min_grid_size, &stats.suggested_block_size,\n-        static_cast<const void*>(params.func_ptr), params.dynamic_smem_size, 0);\n+  if (err != hipError_t::hipSuccess) {\n+    return {};\n+  }\n \n-    if (err != hipError_t::hipSuccess) {\n-      return {};\n-    }\n+  return stats;\n+}\n \n-    return stats;\n+void PerDeviceCollector::CreateXEvent(const RocmTracerEvent& event,\n+                                      XPlaneBuilder* plane,\n+                                      uint64_t start_gpu_ns,\n+                                      uint64_t end_gpu_ns, XLineBuilder* line) {\n+  if (event.start_time_ns < start_gpu_ns || event.end_time_ns > end_gpu_ns ||\n+      event.start_time_ns > event.end_time_ns) {\n+    VLOG(2) << \"events have abnormal timestamps:\" << event.name\n+            << \" start time(ns): \" << event.start_time_ns\n+            << \" end time(ns): \" << event.end_time_ns\n+            << \" start gpu(ns):\" << start_gpu_ns\n+            << \" end gpu(ns):\" << end_gpu_ns\n+            << \" corr. id:\" << event.correlation_id;\n+    return;\n+  }\n+  std::string kernel_name = tsl::port::MaybeAbiDemangle(event.name.c_str());\n+  if (kernel_name.empty()) {\n+    kernel_name = GetRocmTracerEventTypeName(event.type);\n+  }\n+  XEventMetadata* event_metadata =\n+      plane->GetOrCreateEventMetadata(std::move(kernel_name));\n+  XEventBuilder xevent = line->AddEvent(*event_metadata);\n+  VLOG(7) << \"Adding event to line=\" << line->Id();\n+  xevent.SetTimestampNs(event.start_time_ns);\n+  xevent.SetEndTimestampNs(event.end_time_ns);\n+  if (event.source == RocmTracerEventSource::ApiCallback) {\n+    xevent.AddStatValue(\n+        *plane->GetOrCreateStatMetadata(GetStatTypeStr(StatType::kDeviceId)),\n+        event.device_id);\n+  }\n+  if (event.correlation_id != RocmTracerEvent::kInvalidCorrelationId) {\n+    xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n+                            GetStatTypeStr(StatType::kCorrelationId)),\n+                        event.correlation_id);\n+  }\n+  if (!event.roctx_range.empty()) {\n+    xevent.AddStatValue(\n+        *plane->GetOrCreateStatMetadata(GetStatTypeStr(StatType::kNVTXRange)),\n+        *plane->GetOrCreateStatMetadata(event.roctx_range));\n   }\n \n-  void CreateXEvent(const RocmTracerEvent& event, XPlaneBuilder* plane,\n-                    uint64_t start_gpu_ns, uint64_t end_gpu_ns,\n-                    XLineBuilder* line) {\n-    if (event.start_time_ns < start_gpu_ns || event.end_time_ns > end_gpu_ns ||\n-        event.start_time_ns > event.end_time_ns) {\n-      VLOG(2) << \"events have abnormal timestamps:\" << event.name\n-              << \" start time(ns): \" << event.start_time_ns\n-              << \" end time(ns): \" << event.end_time_ns\n-              << \" start gpu(ns):\" << start_gpu_ns\n-              << \" end gpu(ns):\" << end_gpu_ns\n-              << \" corr. id:\" << event.correlation_id;\n-      return;\n-    }\n-    std::string kernel_name = tsl::port::MaybeAbiDemangle(event.name.c_str());\n-    if (kernel_name.empty()) {\n-      kernel_name = GetRocmTracerEventTypeName(event.type);\n-    }\n-    XEventMetadata* event_metadata =\n-        plane->GetOrCreateEventMetadata(std::move(kernel_name));\n-    XEventBuilder xevent = line->AddEvent(*event_metadata);\n-    VLOG(7) << \"Adding event to line=\" << line->Id();\n-    xevent.SetTimestampNs(event.start_time_ns);\n-    xevent.SetEndTimestampNs(event.end_time_ns);\n-    if (event.source == RocmTracerEventSource::ApiCallback) {\n-      xevent.AddStatValue(\n-          *plane->GetOrCreateStatMetadata(GetStatTypeStr(StatType::kDeviceId)),\n-          event.device_id);\n-    }\n-    if (event.correlation_id != RocmTracerEvent::kInvalidCorrelationId) {\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n-                              GetStatTypeStr(StatType::kCorrelationId)),\n-                          event.correlation_id);\n-    }\n-    if (!event.roctx_range.empty()) {\n-      xevent.AddStatValue(\n-          *plane->GetOrCreateStatMetadata(GetStatTypeStr(StatType::kNVTXRange)),\n-          *plane->GetOrCreateStatMetadata(event.roctx_range));\n-    }\n-\n-    if (event.type == RocmTracerEventType::Kernel &&\n-        event.source == RocmTracerEventSource::Activity) {\n-      RocmDeviceOccupancyParams params{};\n-      params.attributes.maxThreadsPerBlock = INT_MAX;\n-      params.attributes.numRegs =\n-          static_cast<int>(event.kernel_info.registers_per_thread);\n-      params.attributes.sharedSizeBytes =\n-          event.kernel_info.static_shared_memory_usage;\n-      // params.attributes.partitionedGCConfig = PARTITIONED_GC_OFF;\n-      // params.attributes.shmemLimitConfig = FUNC_SHMEM_LIMIT_DEFAULT;\n-      params.attributes.maxDynamicSharedSizeBytes = 0;\n-      params.block_size = static_cast<int>(event.kernel_info.block_x *\n-                                           event.kernel_info.block_y *\n-                                           event.kernel_info.block_z);\n-\n-      params.dynamic_smem_size = event.kernel_info.dynamic_shared_memory_usage;\n-      params.func_ptr = event.kernel_info.func_ptr;\n-\n-      OccupancyStats& occ_stats = occupancy_cache_[params];\n-      if (occ_stats.occupancy_pct == 0.0) {\n-        occ_stats = GetOccupancy(params);\n-      }\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(GetStatTypeStr(\n-                              StatType::kTheoreticalOccupancyPct)),\n-                          occ_stats.occupancy_pct);\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n-                              GetStatTypeStr(StatType::kOccupancyMinGridSize)),\n-                          static_cast<tsl::int32>(occ_stats.min_grid_size));\n-      xevent.AddStatValue(\n-          *plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kOccupancySuggestedBlockSize)),\n-          static_cast<tsl::int32>(occ_stats.suggested_block_size));\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n-                              GetStatTypeStr(StatType::kKernelDetails)),\n-                          *plane->GetOrCreateStatMetadata(ToXStat(\n-                              event.kernel_info, occ_stats.occupancy_pct)));\n-    } else if (event.type == RocmTracerEventType::MemcpyH2D ||\n-               event.type == RocmTracerEventType::MemcpyD2H ||\n-               event.type == RocmTracerEventType::MemcpyD2D ||\n-               event.type == RocmTracerEventType::MemcpyP2P ||\n-               event.type == RocmTracerEventType::MemcpyOther) {\n-      VLOG(7) << \"Add Memcpy stat\";\n-      const auto& memcpy_info = event.memcpy_info;\n-      std::string memcpy_details = absl::StrCat(\n-          // TODO(rocm-profiler): we need to discover the memory kind similar\n-          // to CUDA\n-          \"kind:\", \"Unknown\", \" size:\", memcpy_info.num_bytes,\n-          \" dest:\", memcpy_info.destination, \" async:\", memcpy_info.async);\n-      xevent.AddStatValue(\n-          *plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kMemcpyDetails)),\n-          *plane->GetOrCreateStatMetadata(std::move(memcpy_details)));\n-    } else if (event.type == RocmTracerEventType::MemoryAlloc) {\n-      VLOG(7) << \"Add MemAlloc stat\";\n-      std::string value =\n-          // TODO(rocm-profiler): we need to discover the memory kind similar\n-          // to CUDA\n-          absl::StrCat(\"kind:\", \"Unknown\",\n-                       \" num_bytes:\", event.memalloc_info.num_bytes);\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n-                              GetStatTypeStr(StatType::kMemallocDetails)),\n-                          *plane->GetOrCreateStatMetadata(std::move(value)));\n-    } else if (event.type == RocmTracerEventType::MemoryFree) {\n-      VLOG(7) << \"Add MemFree stat\";\n-      std::string value =\n-          // TODO(rocm-profiler): we need to discover the memory kind similar\n-          // to CUDA\n-          absl::StrCat(\"kind:\", \"Unknown\",\n-                       \" num_bytes:\", event.memalloc_info.num_bytes);\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n-                              GetStatTypeStr(StatType::kMemFreeDetails)),\n-                          *plane->GetOrCreateStatMetadata(std::move(value)));\n-    } else if (event.type == RocmTracerEventType::Memset) {\n-      VLOG(7) << \"Add Memset stat\";\n-      auto value =\n-          // TODO(rocm-profiler): we need to discover the memory kind similar\n-          // to CUDA\n-          absl::StrCat(\"kind:\", \"Unknown\",\n-                       \" num_bytes:\", event.memset_info.num_bytes,\n-                       \" async:\", event.memset_info.async);\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n-                              GetStatTypeStr(StatType::kMemsetDetails)),\n-                          *plane->GetOrCreateStatMetadata(std::move(value)));\n-    }\n-    // TODO(rocm-profiler): we need to support the following event type\n-    /* else if (event.type == CuptiTracerEventType::MemoryResidency) {\n-      VLOG(7) << \"Add MemoryResidency stat\";\n-      std::string value = absl::StrCat(\n-          \"kind:\", GetMemoryKindName(event.memory_residency_info.kind),\n-          \" num_bytes:\", event.memory_residency_info.num_bytes,\n-          \" addr:\", event.memory_residency_info.address);\n-      xevent.AddStatValue(*plane->GetOrCreateStatMetadata(GetStatTypeStr(\n-                              StatType::kMemoryResidencyDetails)),\n-                          *plane->GetOrCreateStatMetadata(std::move(value)));\n-    } */\n-\n-    std::vector<Annotation> annotation_stack =\n-        ParseAnnotationStack(event.annotation);\n-    if (!annotation_stack.empty()) {\n-      xevent.AddStatValue(\n-          *plane->GetOrCreateStatMetadata(GetStatTypeStr(StatType::kTfOp)),\n-          *plane->GetOrCreateStatMetadata(annotation_stack.begin()->name));\n-    }\n-    // If multiple metadata have the same key name, show the values from the\n-    // top of the stack (innermost annotation). Concatenate the values from\n-    // \"hlo_op\".\n-    absl::flat_hash_set<absl::string_view> key_set;\n-\n-    for (auto annotation = annotation_stack.rbegin();\n-         annotation != annotation_stack.rend(); ++annotation) {\n-      for (const Annotation::Metadata& metadata : annotation->metadata) {\n-        if (key_set.insert(metadata.key).second) {\n-          xevent.ParseAndAddStatValue(\n-              *plane->GetOrCreateStatMetadata(metadata.key), metadata.value);\n-        }\n+  if (event.type == RocmTracerEventType::Kernel &&\n+      event.source == RocmTracerEventSource::Activity) {\n+    xevent.AddStatValue(\n+        *plane->GetOrCreateStatMetadata(\n+            GetStatTypeStr(StatType::kKernelDetails)),\n+        *plane->GetOrCreateStatMetadata(ToXStat(event.kernel_info,\n+                                                /*occupancy_pct*/ 0)));\n+  } else if (event.type == RocmTracerEventType::MemcpyH2D ||\n+             event.type == RocmTracerEventType::MemcpyD2H ||\n+             event.type == RocmTracerEventType::MemcpyD2D ||\n+             event.type == RocmTracerEventType::MemcpyOther) {\n+    VLOG(7) << \"Add Memcpy stat\";\n+    const auto& memcpy_info = event.memcpy_info;\n+    std::string memcpy_details = absl::StrCat(\n+        // TODO(rocm-profiler): we need to discover the memory kind similar\n+        // to CUDA\n+        \"kind:\", \"Unknown\", \" size:\", memcpy_info.num_bytes,\n+        \" dest:\", memcpy_info.destination, \" async:\", memcpy_info.async);\n+    xevent.AddStatValue(\n+        *plane->GetOrCreateStatMetadata(\n+            GetStatTypeStr(StatType::kMemcpyDetails)),\n+        *plane->GetOrCreateStatMetadata(std::move(memcpy_details)));\n+  } else if (event.type == RocmTracerEventType::MemoryAlloc) {\n+    VLOG(7) << \"Add MemAlloc stat\";\n+    std::string value =\n+        // TODO(rocm-profiler): we need to discover the memory kind similar\n+        // to CUDA\n+        absl::StrCat(\"kind:\", \"Unknown\",\n+                     \" num_bytes:\", event.memalloc_info.num_bytes);\n+    xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n+                            GetStatTypeStr(StatType::kMemallocDetails)),\n+                        *plane->GetOrCreateStatMetadata(std::move(value)));\n+  } else if (event.type == RocmTracerEventType::MemoryFree) {\n+    VLOG(7) << \"Add MemFree stat\";\n+    std::string value =\n+        // TODO(rocm-profiler): we need to discover the memory kind similar\n+        // to CUDA\n+        absl::StrCat(\"kind:\", \"Unknown\",\n+                     \" num_bytes:\", event.memalloc_info.num_bytes);\n+    xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n+                            GetStatTypeStr(StatType::kMemFreeDetails)),\n+                        *plane->GetOrCreateStatMetadata(std::move(value)));\n+  } else if (event.type == RocmTracerEventType::Memset) {\n+    VLOG(7) << \"Add Memset stat\";\n+    auto value =\n+        // TODO(rocm-profiler): we need to discover the memory kind similar\n+        // to CUDA\n+        absl::StrCat(\"kind:\", \"Unknown\",\n+                     \" num_bytes:\", event.memset_info.num_bytes,\n+                     \" async:\", event.memset_info.async);\n+    xevent.AddStatValue(*plane->GetOrCreateStatMetadata(\n+                            GetStatTypeStr(StatType::kMemsetDetails)),\n+                        *plane->GetOrCreateStatMetadata(std::move(value)));\n+  }\n+  // TODO(rocm-profiler): we need to support the following event type\n+  /* else if (event.type == CuptiTracerEventType::MemoryResidency) {\n+    VLOG(7) << \"Add MemoryResidency stat\";\n+    std::string value = absl::StrCat(\n+        \"kind:\", GetMemoryKindName(event.memory_residency_info.kind),\n+        \" num_bytes:\", event.memory_residency_info.num_bytes,\n+        \" addr:\", event.memory_residency_info.address);\n+    xevent.AddStatValue(*plane->GetOrCreateStatMetadata(GetStatTypeStr(\n+                            StatType::kMemoryResidencyDetails)),\n+                        *plane->GetOrCreateStatMetadata(std::move(value)));\n+  } */\n+\n+  std::vector<Annotation> annotation_stack =\n+      ParseAnnotationStack(event.annotation);\n+  if (!annotation_stack.empty()) {\n+    xevent.AddStatValue(\n+        *plane->GetOrCreateStatMetadata(GetStatTypeStr(StatType::kTfOp)),\n+        *plane->GetOrCreateStatMetadata(annotation_stack.begin()->name));\n+  }\n+  // If multiple metadata have the same key name, show the values from the\n+  // top of the stack (innermost annotation). Concatenate the values from\n+  // \"hlo_op\".\n+  absl::flat_hash_set<absl::string_view> key_set;\n+\n+  for (auto annotation = annotation_stack.rbegin();\n+       annotation != annotation_stack.rend(); ++annotation) {\n+    for (const Annotation::Metadata& metadata : annotation->metadata) {\n+      if (key_set.insert(metadata.key).second) {\n+        xevent.ParseAndAddStatValue(\n+            *plane->GetOrCreateStatMetadata(metadata.key), metadata.value);\n       }\n     }\n   }\n+}\n \n-  void SortByStartTime() {\n-    absl::MutexLock lock(events_mutex);\n-    std::sort(events.begin(), events.end(),\n-              [](const RocmTracerEvent& event1, const RocmTracerEvent& event2) {\n-                return event1.start_time_ns < event2.start_time_ns;\n-              });\n+void PerDeviceCollector::SortByStartTime() {\n+  absl::MutexLock lock(events_mutex_);\n+  std::sort(events_.begin(), events_.end(),\n+            [](const RocmTracerEvent& event1, const RocmTracerEvent& event2) {\n+              return event1.start_time_ns < event2.start_time_ns;\n+            });\n+}\n+\n+bool PerDeviceCollector::IsHostEvent(const RocmTracerEvent& event,\n+                                     int64_t* line_id) {\n+  // DriverCallback(i.e. kernel launching) events are host events.\n+  if (event.source == RocmTracerEventSource::ApiCallback) {\n+    *line_id = event.thread_id;\n+    return true;\n+  } else {  // activities\n+    *line_id = event.stream_id;\n+    return false;\n   }\n \n-  bool IsHostEvent(const RocmTracerEvent& event, tsl::int64* line_id) {\n-    // DriverCallback(i.e. kernel launching) events are host events.\n-    if (event.source == RocmTracerEventSource::ApiCallback) {\n-      *line_id = event.thread_id;\n-      return true;\n-    } else {  // activities\n-      *line_id = event.stream_id;\n-      return false;\n-    }\n+  // TODO(rocm-profiler): do we have such a report in rocm?\n+  // Non-overhead activity events are device events.\n+  /* if (event.type != CuptiTracerEventType::Overhead) {\n+    *line_id = event.stream_id;\n+    return false;\n+  } */\n+  // Overhead events can be associated with a thread or a stream, etc.\n+  // If a valid thread id is specified, we consider it as a host event.\n+  //\n+\n+  if (event.stream_id != RocmTracerEvent::kInvalidStreamId) {\n+    *line_id = event.stream_id;\n+    return false;\n+  } else if (event.thread_id != RocmTracerEvent::kInvalidThreadId &&\n+             event.thread_id != 0) {\n+    *line_id = event.thread_id;\n+    return true;\n+  } else {\n+    *line_id = tsl::profiler::kThreadIdOverhead;\n+    return false;\n+  }\n+}\n \n-    // TODO(rocm-profiler): do we have such a report in rocm?\n-    // Non-overhead activity events are device events.\n-    /* if (event.type != CuptiTracerEventType::Overhead) {\n-      *line_id = event.stream_id;\n-      return false;\n-    } */\n-    // Overhead events can be associated with a thread or a stream, etc.\n-    // If a valid thread id is specified, we consider it as a host event.\n-    //\n-\n-    if (event.stream_id != RocmTracerEvent::kInvalidStreamId) {\n-      *line_id = event.stream_id;\n-      return false;\n-    } else if (event.thread_id != RocmTracerEvent::kInvalidThreadId &&\n-               event.thread_id != 0) {\n-      *line_id = event.thread_id;\n-      return true;\n+void PerDeviceCollector::Export(uint64_t start_walltime_ns,\n+                                uint64_t start_gputime_ns,\n+                                uint64_t end_gputime_ns,\n+                                XPlaneBuilder* device_plane,\n+                                XPlaneBuilder* host_plane) {\n+  int host_ev_cnt = 0, dev_ev_cnt = 0;\n+  absl::MutexLock lock(events_mutex_);\n+  // Tracking event types per line.\n+  absl::flat_hash_map<int64_t, absl::flat_hash_set<RocmTracerEventType> >\n+      events_types_per_line;\n+\n+  for (const RocmTracerEvent& event : events_) {\n+    int64_t line_id = RocmTracerEvent::kInvalidThreadId;\n+    bool is_host_event = IsHostEvent(event, &line_id);\n+\n+    if (is_host_event) {\n+      host_ev_cnt++;\n     } else {\n-      *line_id = tsl::profiler::kThreadIdOverhead;\n-      return false;\n+      dev_ev_cnt++;\n     }\n-  }\n-\n- public:\n-  void Export(uint64_t start_walltime_ns, uint64_t start_gputime_ns,\n-              uint64_t end_gputime_ns, XPlaneBuilder* device_plane,\n-              XPlaneBuilder* host_plane) {\n-    int host_ev_cnt = 0, dev_ev_cnt = 0;\n-    absl::MutexLock l(events_mutex);\n-    // Tracking event types per line.\n-    absl::flat_hash_map<tsl::int64, absl::flat_hash_set<RocmTracerEventType>>\n-        events_types_per_line;\n-    for (const RocmTracerEvent& event : events) {\n-      int64_t line_id = RocmTracerEvent::kInvalidThreadId;\n-      bool is_host_event = IsHostEvent(event, &line_id);\n-\n-      if (is_host_event) {\n-        host_ev_cnt++;\n-      } else {\n-        dev_ev_cnt++;\n-      }\n \n-      if (line_id == RocmTracerEvent::kInvalidThreadId ||\n-          line_id == RocmTracerEvent::kInvalidStreamId) {\n-        VLOG(3) << \"Ignoring event, type=\" << static_cast<int>(event.type);\n-        continue;\n-      }\n-      auto* plane = is_host_event ? host_plane : device_plane;\n-      VLOG(9) << \"Event\"\n-              << \" type=\" << static_cast<int>(event.type)\n-              << \" line_id=\" << line_id\n-              << (is_host_event ? \" host plane=\" : \" device plane=\")\n-              << plane->Name();\n-      XLineBuilder line = plane->GetOrCreateLine(line_id);\n-      line.SetTimestampNs(start_gputime_ns);\n-      CreateXEvent(event, plane, start_gputime_ns, end_gputime_ns, &line);\n-      events_types_per_line[line_id].emplace(event.type);\n+    if (line_id == RocmTracerEvent::kInvalidThreadId ||\n+        line_id == RocmTracerEvent::kInvalidStreamId) {\n+      VLOG(3) << \"Ignoring event, type=\" << static_cast<int>(event.type);\n+      continue;\n     }\n-    device_plane->ForEachLine([&](XLineBuilder line) {\n-      line.SetName(\n-          GetDeviceXLineName(line.Id(), events_types_per_line[line.Id()]));\n-    });\n-    host_plane->ForEachLine([&](XLineBuilder line) {\n-      line.SetName(absl::StrCat(\"Host Threads/\", line.Id()));\n-    });\n-    events.clear();\n+    auto* plane = is_host_event ? host_plane : device_plane;\n+    VLOG(9) << \"Event\" << \" type=\" << static_cast<int>(event.type)\n+            << \" line_id=\" << line_id\n+            << (is_host_event ? \" host plane=\" : \" device plane=\")\n+            << plane->Name();\n+\n+    XLineBuilder line = plane->GetOrCreateLine(line_id);\n+    line.SetTimestampNs(start_gputime_ns);\n+    CreateXEvent(event, plane, start_gputime_ns, end_gputime_ns, &line);\n   }\n \n-  PerDeviceCollector() = default;\n+  device_plane->ForEachLine([&](XLineBuilder line) {\n+    line.SetName(\n+        GetDeviceXLineName(line.Id(), events_types_per_line[line.Id()]));\n+  });\n+  host_plane->ForEachLine([&](XLineBuilder line) {\n+    line.SetName(absl::StrCat(\"Host Threads/\", line.Id()));\n+  });\n+  events_.clear();\n+}\n \n-  void AddEvent(const RocmTracerEvent& event) {\n-    absl::MutexLock l(events_mutex);\n-    if (event.source == RocmTracerEventSource::ApiCallback) {\n-      // Cupti api callback events were used to populate launch times etc.\n-      if (event.correlation_id != RocmTracerEvent::kInvalidCorrelationId) {\n-        correlation_info_.insert(\n-            {event.correlation_id,\n-             CorrelationInfo(event.thread_id, event.start_time_ns)});\n-      }\n-      events.emplace_back(std::move(event));\n-    } else {\n-      // Cupti activity events measure device times etc.\n-      events.emplace_back(std::move(event));\n-    }\n-  }\n+void PerDeviceCollector::AddEvent(RocmTracerEvent&& event) {\n+  absl::MutexLock lock(events_mutex_);\n+  events_.emplace_back(std::move(event));\n+}\n \n-  void GetDeviceCapabilities(int32_t device_ordinal,\n-                             XPlaneBuilder* device_plane) {\n-    device_plane->AddStatValue(*device_plane->GetOrCreateStatMetadata(\n-                                   GetStatTypeStr(StatType::kDevVendor)),\n-                               kDeviceVendorAMD);\n-\n-    if (hipGetDeviceProperties(&device_properties_, device_ordinal) !=\n-        hipSuccess)\n-      return;\n-\n-    auto clock_rate_in_khz =\n-        device_properties_.clockRate;  // this is also in Khz\n-    if (clock_rate_in_khz) {\n-      device_plane->AddStatValue(\n-          *device_plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kDevCapClockRateKHz)),\n-          clock_rate_in_khz);\n-    }\n+void PerDeviceCollector::GetDeviceCapabilities(int32_t device_ordinal,\n+                                               XPlaneBuilder* device_plane) {\n+  device_plane->AddStatValue(*device_plane->GetOrCreateStatMetadata(\n+                                 GetStatTypeStr(StatType::kDevVendor)),\n+                             kDeviceVendorAMD);\n \n-    auto core_count = device_properties_.multiProcessorCount;\n-    if (core_count) {\n-      device_plane->AddStatValue(\n-          *device_plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kDevCapCoreCount)),\n-          core_count);\n-    }\n+  if (hipGetDeviceProperties(&device_properties_, device_ordinal) !=\n+      hipSuccess) {\n+    return;\n+  }\n \n-    auto mem_clock_khz = device_properties_.memoryClockRate;\n-    auto mem_bus_width_bits = device_properties_.memoryBusWidth;\n-\n-    if (mem_clock_khz && mem_bus_width_bits) {\n-      // Times 2 because HBM is DDR memory; it gets two data bits per each\n-      // data lane.\n-      auto memory_bandwidth =\n-          uint64_t{2} * (mem_clock_khz) * 1000 * (mem_bus_width_bits) / 8;\n-      device_plane->AddStatValue(\n-          *device_plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kDevCapMemoryBandwidth)),\n-          memory_bandwidth);\n-    }\n+  auto clock_rate_in_khz = device_properties_.clockRate;  // this is also in Khz\n+  if (clock_rate_in_khz) {\n+    device_plane->AddStatValue(\n+        *device_plane->GetOrCreateStatMetadata(\n+            GetStatTypeStr(StatType::kDevCapClockRateKHz)),\n+        clock_rate_in_khz);\n+  }\n \n-    size_t total_memory = device_properties_.totalGlobalMem;\n-    if (total_memory) {\n-      device_plane->AddStatValue(\n-          *device_plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kDevCapMemorySize)),\n-          static_cast<uint64_t>(total_memory));\n-    }\n+  auto core_count = device_properties_.multiProcessorCount;\n+  if (core_count) {\n+    device_plane->AddStatValue(*device_plane->GetOrCreateStatMetadata(\n+                                   GetStatTypeStr(StatType::kDevCapCoreCount)),\n+                               core_count);\n+  }\n \n-    auto compute_capability_major = device_properties_.major;\n-    if (compute_capability_major) {\n-      device_plane->AddStatValue(\n-          *device_plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kDevCapComputeCapMajor)),\n-          compute_capability_major);\n-    }\n-    auto compute_capability_minor = device_properties_.minor;\n-    if (compute_capability_minor) {\n-      device_plane->AddStatValue(\n-          *device_plane->GetOrCreateStatMetadata(\n-              GetStatTypeStr(StatType::kDevCapComputeCapMinor)),\n-          compute_capability_minor);\n-    }\n+  auto mem_clock_khz = device_properties_.memoryClockRate;\n+  auto mem_bus_width_bits = device_properties_.memoryBusWidth;\n+\n+  if (mem_clock_khz && mem_bus_width_bits) {\n+    // Times 2 because HBM is DDR memory; it gets two data bits per each\n+    // data lane.\n+    auto memory_bandwidth =\n+        uint64_t{2} * (mem_clock_khz) * 1000 * (mem_bus_width_bits) / 8;\n+    device_plane->AddStatValue(\n+        *device_plane->GetOrCreateStatMetadata(\n+            GetStatTypeStr(StatType::kDevCapMemoryBandwidth)),\n+        memory_bandwidth);\n   }\n \n- private:\n-  absl::Mutex events_mutex;\n-  std::vector<RocmTracerEvent> events TF_GUARDED_BY(events_mutex);\n-  absl::flat_hash_map<uint32_t, CorrelationInfo> correlation_info_\n-      TF_GUARDED_BY(events_mutex);\n-  absl::flat_hash_map<RocmDeviceOccupancyParams, OccupancyStats>\n-      occupancy_cache_;\n-  hipDeviceProp_t device_properties_;\n-};\n-\n-class RocmTraceCollectorImpl : public profiler::RocmTraceCollector {\n- public:\n-  RocmTraceCollectorImpl(const RocmTraceCollectorOptions& options,\n-                         uint64_t start_walltime_ns, uint64_t start_gputime_ns)\n-      : RocmTraceCollector(options),\n-        num_callback_events_(0),\n-        num_activity_events_(0),\n-        start_walltime_ns_(start_walltime_ns),\n-        start_gputime_ns_(start_gputime_ns),\n-        num_gpus_(options.num_gpus) {}\n-\n-  void AddEvent(RocmTracerEvent&& event, bool is_auxiliary) override;\n-  void Flush() override;\n-  void Export(XSpace* space) override;\n-\n-  void OnEventsDropped(const std::string& reason,\n-                       uint32_t correlation_id) override {\n-    LOG(INFO) << \"RocmTracerEvent dropped (correlation_id=\" << correlation_id\n-              << \",) : \" << reason << \".\";\n+  size_t total_memory = device_properties_.totalGlobalMem;\n+  if (total_memory) {\n+    device_plane->AddStatValue(*device_plane->GetOrCreateStatMetadata(\n+                                   GetStatTypeStr(StatType::kDevCapMemorySize)),\n+                               static_cast<uint64_t>(total_memory));\n   }\n \n- private:\n-  std::atomic<int> num_callback_events_;\n-  std::atomic<int> num_activity_events_;\n-  uint64_t start_walltime_ns_;\n-  uint64_t start_gputime_ns_;\n-  int num_gpus_;\n-\n-  absl::Mutex event_maps_mutex_;\n-  absl::flat_hash_map<uint32_t, RocmTracerEvent> api_events_map_\n-      TF_GUARDED_BY(event_maps_mutex_);\n-\n-  /* Some apis such as MEMSETD32 (based on an observation with ResNet50),\n-   trigger multiple HIP ops domain activities. We keep them in a vector and\n-   merge them with api activities at flush time.\n- */\n-  absl::flat_hash_map<uint32_t, std::vector<RocmTracerEvent>>\n-      activity_ops_events_map_ TF_GUARDED_BY(event_maps_mutex_);\n-  // This is for the APIs that we track because we need some information from\n-  // them to populate the corresponding activity that we actually track.\n-  absl::flat_hash_map<uint32_t, RocmTracerEvent> auxiliary_api_events_map_\n-      TF_GUARDED_BY(event_maps_mutex_);\n-\n-  const std::vector<RocmTracerEvent> ApiActivityInfoExchange()\n-      TF_EXCLUSIVE_LOCKS_REQUIRED(event_maps_mutex_);\n-\n-  absl::node_hash_map<uint32_t, PerDeviceCollector> per_device_collector_;\n-};\n-//==========\n+  auto compute_capability_major = device_properties_.major;\n+  if (compute_capability_major) {\n+    device_plane->AddStatValue(\n+        *device_plane->GetOrCreateStatMetadata(\n+            GetStatTypeStr(StatType::kDevCapComputeCapMajor)),\n+        compute_capability_major);\n+  }\n+  auto compute_capability_minor = device_properties_.minor;\n+  if (compute_capability_minor) {\n+    device_plane->AddStatValue(\n+        *device_plane->GetOrCreateStatMetadata(\n+            GetStatTypeStr(StatType::kDevCapComputeCapMinor)),\n+        compute_capability_minor);\n+  }\n+}\n \n void RocmTraceCollectorImpl::AddEvent(RocmTracerEvent&& event,\n                                       bool is_auxiliary) {\n   absl::MutexLock lock(event_maps_mutex_);\n \n-  if (event.source == RocmTracerEventSource::ApiCallback && !is_auxiliary) {\n-    if (num_callback_events_ > options_.max_callback_api_events) {\n-      OnEventsDropped(\"max callback event capacity reached\",\n-                      event.correlation_id);\n-      DumpRocmTracerEvent(event, 0, 0, \". Dropped!\");\n-      return;\n+  if (event.source == RocmTracerEventSource::ApiCallback) {\n+    if (!is_auxiliary) {\n+      if (num_callback_events_ >= options_.max_callback_api_events) {\n+        OnEventsDropped(\"max callback event capacity reached\",\n+                        event.correlation_id);\n+        PrintRocmTracerEvent(event, \". Dropped!\");\n+        return;\n+      }\n+      num_callback_events_++;\n     }\n-    num_callback_events_++;\n-  } else if (event.source == RocmTracerEventSource::Activity &&\n-             event.domain == RocmTracerEventDomain::HIP_API) {\n-    // we do not count HIP_OPS activities.\n-    if (num_activity_events_ > options_.max_activity_api_events) {\n-      OnEventsDropped(\"max activity event capacity reached\",\n+    auto& map = is_auxiliary ? auxiliary_api_events_map_ : api_events_map_;\n+    auto [it, added] = map.emplace(event.correlation_id, std::move(event));\n+\n+    if (!added) {\n+      OnEventsDropped(\"event with duplicate correlation_id was received.\",\n                       event.correlation_id);\n-      DumpRocmTracerEvent(event, 0, 0, \". Dropped!\");\n-      return;\n+      PrintRocmTracerEvent(event, \". Dropped!\");\n     }\n-    num_activity_events_++;\n-  }\n-\n-  bool emplace_result = false;\n-  if (event.source == RocmTracerEventSource::ApiCallback) {\n-    auto& target_api_event_map =\n-        (is_auxiliary) ? auxiliary_api_events_map_ : api_events_map_;\n-    std::tie(std::ignore, emplace_result) =\n-        target_api_event_map.emplace(event.correlation_id, std::move(event));\n   } else if (event.source == RocmTracerEventSource::Activity) {\n-    auto result = activity_ops_events_map_.emplace(\n+    if (event.domain == RocmTracerEventDomain::HIP_API) {\n+      // we do not count HIP_OPS activities.\n+      if (num_activity_events_ >= options_.max_activity_api_events) {\n+        OnEventsDropped(\"max activity event capacity reached\",\n+                        event.correlation_id);\n+        PrintRocmTracerEvent(event, \". Dropped!\");\n+        return;\n+      }\n+      num_activity_events_++;\n+    }\n+\n+    auto [it, _] = activity_ops_events_map_.emplace(\n         event.correlation_id, std::vector<RocmTracerEvent>{});\n-    result.first->second.push_back(std::move(event));\n-    emplace_result = true;  // we always accept Hip-Ops events\n-  }\n-  if (!emplace_result) {\n-    OnEventsDropped(\"event with duplicate correlation_id was received.\",\n-                    event.correlation_id);\n-    DumpRocmTracerEvent(event, 0, 0, \". Dropped!\");\n+    it->second.push_back(std::move(event));\n+  } else {\n+    VLOG(3) << \"Dropping unknown event: \" << (int)event.source\n+            << \" domain: \" << (int)event.domain;\n   }\n }\n \n void RocmTraceCollectorImpl::Flush() {\n   absl::MutexLock lock(event_maps_mutex_);\n-  auto& aggregated_events_ = ApiActivityInfoExchange();\n+  auto aggregated_events = ApiActivityInfoExchange();\n \n   VLOG(3) << \"RocmTraceCollector collected \" << num_callback_events_\n           << \" callback events, \" << num_activity_events_\n           << \" activity events, and aggregated them into \"\n-          << aggregated_events_.size() << \" events.\";\n+          << aggregated_events.size() << \" events.\";\n \n   // device ids for GPUs filled in by roctracer are not zero indexed.\n   // They are offset by number of CPUs on the machine\n-  tsl::uint32 min_device_id = INT32_MAX;\n-  ;\n-  for (auto& event : aggregated_events_) {\n+  uint32_t min_device_id = INT32_MAX;\n+\n+  for (const auto& event : aggregated_events) {\n     if (event.device_id < min_device_id) {\n       min_device_id = event.device_id;\n     }\n   }\n \n-  for (auto event : aggregated_events_) {\n-    event.device_id = event.device_id - min_device_id;\n-    if (event.device_id < num_gpus_) {\n-      per_device_collector_[event.device_id].AddEvent(event);\n+  for (auto& event : aggregated_events) {\n+    auto id = event.device_id - min_device_id;\n+    if (id < num_gpus_) {\n+      per_device_collector_[id].AddEvent(std::move(event));\n     } else {\n-      OnEventsDropped(\"Invalid device id for an event.\", event.correlation_id);\n-      DumpRocmTracerEvent(event, 0, 0, \". Dropped!\");\n+      PrintRocmTracerEvent(event, \". Dropped due to invalid device ID!\");\n     }\n   }\n \n@@ -701,24 +542,24 @@ void RocmTraceCollectorImpl::Export(XSpace* space) {\n   XPlaneBuilder host_plane(FindOrAddMutablePlaneWithName(\n       space, tsl::profiler::kRoctracerApiPlaneName));\n \n-  for (int device_ordinal = 0; device_ordinal < num_gpus_; ++device_ordinal) {\n-    std::string name = GpuPlaneName(device_ordinal);\n+  VLOG(3) << \"Calling RocmTraceCollectorImpl::Export num_gpus \" << num_gpus_;\n+\n+  for (int id = 0; id < num_gpus_; id++) {\n+    std::string name = GpuPlaneName(id);\n     XPlaneBuilder device_plane(FindOrAddMutablePlaneWithName(space, name));\n-    device_plane.SetId(device_ordinal);\n+    device_plane.SetId(id);\n     // Calculate device capabilities before flushing, so that device\n     // properties are available to the occupancy calculator in export().\n-    per_device_collector_[device_ordinal].GetDeviceCapabilities(device_ordinal,\n-                                                                &device_plane);\n-    per_device_collector_[device_ordinal].Export(\n-        start_walltime_ns_, start_gputime_ns_, end_gputime_ns, &device_plane,\n-        &host_plane);\n+    per_device_collector_[id].GetDeviceCapabilities(id, &device_plane);\n+    per_device_collector_[id].Export(start_walltime_ns_, start_gputime_ns_,\n+                                     end_gputime_ns, &device_plane,\n+                                     &host_plane);\n     NormalizeTimeStamps(&device_plane, start_walltime_ns_);\n   }\n   NormalizeTimeStamps(&host_plane, start_walltime_ns_);\n }\n \n-const std::vector<RocmTracerEvent>\n-RocmTraceCollectorImpl::ApiActivityInfoExchange() {\n+std::vector<RocmTracerEvent> RocmTraceCollectorImpl::ApiActivityInfoExchange() {\n   /* Different from CUDA, roctracer activity records are not enough to fill a\n     TF event. For most of the activities, we need to enable the corresponding\n     API callsbacks (we call them auxiliary API callbacks) to capture the\n@@ -728,116 +569,108 @@ RocmTraceCollectorImpl::ApiActivityInfoExchange() {\n   */\n \n   std::vector<RocmTracerEvent> aggregated_events;\n+  aggregated_events.reserve(api_events_map_.size());\n \n   // Copy info from activity events to API callback events\n-  for (auto& api_iter : api_events_map_) {\n-    RocmTracerEvent& api_event = api_iter.second;\n-    auto activity_event =\n-        activity_ops_events_map_.find(api_event.correlation_id);\n-\n-    if (activity_event == activity_ops_events_map_.end()) {\n-      OnEventsDropped(\n-          \"An event from HIP API discarded.\"\n-          \"Could not find the counterpart activity.\",\n-          api_event.correlation_id);\n-      DumpRocmTracerEvent(api_event, 0, 0, \". Dropped!\");\n-    } else {\n-      api_event.device_id = activity_event->second.front().device_id;\n-      api_event.stream_id = activity_event->second.front().stream_id;\n-      switch (api_event.type) {\n-        case RocmTracerEventType::Kernel:\n-        case RocmTracerEventType::Memset:\n-        case RocmTracerEventType::MemoryAlloc:\n-        case RocmTracerEventType::MemoryFree:\n-        case RocmTracerEventType::Synchronization: {\n-          aggregated_events.push_back(api_event);\n-          break;\n-        }\n-        case RocmTracerEventType::MemcpyD2H:\n-        case RocmTracerEventType::MemcpyH2D:\n-        case RocmTracerEventType::MemcpyD2D:\n-        case RocmTracerEventType::MemcpyOther: {\n-          api_event.memcpy_info.destination =\n-              activity_event->second.front().device_id;\n-          aggregated_events.push_back(api_event);\n-          break;\n-        }\n-        default:\n-          OnEventsDropped(\"Missing API-Activity information exchange. Dropped!\",\n-                          api_event.correlation_id);\n-          DumpRocmTracerEvent(api_event, 0, 0, \". Dropped!\");\n-          LOG(WARNING) << \"A ROCm API event type with unimplemented activity \"\n-                          \"merge dropped! \"\n-                          \"Type=\"\n-                       << GetRocmTracerEventTypeName(api_event.type);\n-      }\n+  for (auto& [key, api_event] : api_events_map_) {\n+    auto iact = activity_ops_events_map_.find(api_event.correlation_id);\n+\n+    if (iact == activity_ops_events_map_.end()) {\n+      PrintRocmTracerEvent(api_event, \". Dropped!\");\n+      VLOG(1) << api_event.name << \"  could not find activity counterpart!\";\n+      continue;\n     }\n-  }\n+    const auto& item = iact->second.front();\n+    api_event.device_id = item.device_id;\n+    api_event.stream_id = item.stream_id;\n+    switch (api_event.type) {\n+      case RocmTracerEventType::Kernel:\n+        api_event.kernel_info = item.kernel_info;\n+        aggregated_events.push_back(api_event);\n+        break;\n+      case RocmTracerEventType::Memset:\n+      case RocmTracerEventType::MemoryAlloc:\n+      case RocmTracerEventType::MemoryFree:\n+      case RocmTracerEventType::Synchronization:\n+        aggregated_events.push_back(api_event);\n+        break;\n+      case RocmTracerEventType::MemcpyD2H:\n+      case RocmTracerEventType::MemcpyH2D:\n+      case RocmTracerEventType::MemcpyD2D:\n+      case RocmTracerEventType::MemcpyOther:\n+        api_event.memcpy_info = item.memcpy_info;\n+        aggregated_events.push_back(api_event);\n+        break;\n+      default:\n+        OnEventsDropped(\"Missing API-Activity information exchange. Dropped!\",\n+                        api_event.correlation_id);\n+        PrintRocmTracerEvent(api_event, \". Dropped!\");\n+        LOG(WARNING) << \"A ROCm API event type with unimplemented activity \"\n+                        \"merge dropped! \"\n+                        \"Type=\"\n+                     << GetRocmTracerEventTypeName(api_event.type);\n+    }  // switch\n+  }  // for\n \n   // Make sure for all activity events we have API callback events\n   for (auto& activity_iter : activity_ops_events_map_) {\n     RocmTracerEvent& activity_event = activity_iter.second.front();\n+\n     auto api_event = api_events_map_.find(activity_event.correlation_id);\n \n     if (api_event == api_events_map_.end()) {\n       api_event = auxiliary_api_events_map_.find(activity_event.correlation_id);\n-    }\n \n-    if (api_event == auxiliary_api_events_map_.end()) {\n-      OnEventsDropped(\n-          \"An event from activity was discarded.\"\n-          \"Could not find the counterpart HIP API.\",\n-          activity_event.correlation_id);\n-      DumpRocmTracerEvent(activity_event, 0, 0, \". Dropped!\");\n-    } else {\n-      switch (activity_event.type) {\n-        // KERNEL ACTIVITY\n-        case RocmTracerEventType::Kernel: {\n-          activity_event.name = api_event->second.name;\n-          activity_event.kernel_info = api_event->second.kernel_info;\n-          aggregated_events.push_back(activity_event);\n-          break;\n-        }\n-        // MEMCPY ACTIVITY\n-        case RocmTracerEventType::MemcpyD2H:\n-        case RocmTracerEventType::MemcpyH2D:\n-        case RocmTracerEventType::MemcpyD2D:\n-        case RocmTracerEventType::MemcpyOther: {\n-          activity_event.memcpy_info = api_event->second.memcpy_info;\n-          aggregated_events.push_back(activity_event);\n-          break;\n-        }\n-        // MEMSET ACTIVITY\n-        case RocmTracerEventType::Memset: {\n-          activity_event.memset_info = api_event->second.memset_info;\n-          aggregated_events.push_back(activity_event);\n-          break;\n-        }\n-        // MALLOC ACTIVITY, FREE ACTIVITY\n-        case RocmTracerEventType::MemoryAlloc:\n-        case RocmTracerEventType::MemoryFree: {\n-          activity_event.device_id = api_event->second.device_id;\n-          aggregated_events.push_back(activity_event);\n-          break;\n-        }\n-        // SYNCHRONIZATION ACTIVITY\n-        case RocmTracerEventType::Synchronization: {\n-          activity_event.device_id = api_event->second.device_id;\n-          aggregated_events.push_back(activity_event);\n-          break;\n-        }\n-        default:\n-          OnEventsDropped(\"Missing API-Activity information exchange. Dropped!\",\n-                          activity_event.correlation_id);\n-          DumpRocmTracerEvent(activity_event, 0, 0, \". Dropped!\");\n-          LOG(WARNING) << \"A ROCm activity event with unimplemented API \"\n-                          \"callback merge dropped! \"\n-                          \"Type=\"\n-                       << GetRocmTracerEventTypeName(activity_event.type);\n-          break;\n+      if (api_event == auxiliary_api_events_map_.end()) {\n+        OnEventsDropped(\n+            \"An event from activity was discarded.\"\n+            \"Could not find the counterpart HIP API.\",\n+            activity_event.correlation_id);\n+        PrintRocmTracerEvent(activity_event, \". Dropped!\");\n+        continue;\n       }\n     }\n-  }\n+\n+    switch (activity_event.type) {\n+      case RocmTracerEventType::Kernel:\n+        activity_event.kernel_info = api_event->second.kernel_info;\n+        PrintRocmTracerEvent(activity_event,\n+                             \". activity event from api_event.\");\n+        aggregated_events.push_back(activity_event);\n+        break;\n+\n+      case RocmTracerEventType::MemcpyD2H:\n+      case RocmTracerEventType::MemcpyH2D:\n+      case RocmTracerEventType::MemcpyD2D:\n+      case RocmTracerEventType::MemcpyOther:\n+        // activity_event.memcpy_info = api_event->second.memcpy_info;\n+        aggregated_events.push_back(activity_event);\n+        break;\n+      case RocmTracerEventType::Memset:\n+        activity_event.memset_info = api_event->second.memset_info;\n+        aggregated_events.push_back(activity_event);\n+        break;\n+\n+      case RocmTracerEventType::MemoryAlloc:\n+      case RocmTracerEventType::MemoryFree:\n+        activity_event.device_id = api_event->second.device_id;\n+        aggregated_events.push_back(activity_event);\n+        break;\n+\n+      case RocmTracerEventType::Synchronization:\n+        activity_event.device_id = api_event->second.device_id;\n+        aggregated_events.push_back(activity_event);\n+        break;\n+      default:\n+        OnEventsDropped(\"Missing API-Activity information exchange. Dropped!\",\n+                        activity_event.correlation_id);\n+        PrintRocmTracerEvent(activity_event, \". Dropped!\");\n+        LOG(WARNING) << \"A ROCm activity event with unimplemented API \"\n+                        \"callback merge dropped! \"\n+                        \"Type=\"\n+                     << GetRocmTracerEventTypeName(activity_event.type);\n+    }  // switch\n+  }  // for\n \n   return aggregated_events;\n }"
        },
        {
            "sha": "c93dbb2c128f50c1f843d78fbae284e76b11623d",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_collector.h",
            "status": "modified",
            "additions": 165,
            "deletions": 170,
            "changes": 335,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector.h?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -16,213 +16,208 @@ limitations under the License.\n #ifndef XLA_BACKENDS_PROFILER_GPU_ROCM_COLLECTOR_H_\n #define XLA_BACKENDS_PROFILER_GPU_ROCM_COLLECTOR_H_\n \n+#include <atomic>\n+#include <cstddef>\n #include <cstdint>\n-#include <limits>\n+#include <memory>\n+#include <string>\n+#include <tuple>\n+#include <vector>\n \n+#include \"absl/base/thread_annotations.h\"\n #include \"absl/container/flat_hash_map.h\"\n-#include \"absl/container/node_hash_set.h\"\n+#include \"absl/container/node_hash_map.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"rocm/include/hip/hip_runtime.h\"\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n #include \"xla/tsl/profiler/utils/xplane_builder.h\"\n+#include \"tsl/profiler/protobuf/xplane.pb.h\"\n \n namespace xla {\n namespace profiler {\n \n-using tsl::profiler::XSpace;\n-\n-struct MemcpyDetails {\n-  // The amount of data copied for memcpy events.\n-  size_t num_bytes;\n-  // The destination device for peer-2-peer communication (memcpy). The source\n-  // device is implicit: it's the current device.\n-  uint32_t destination;\n-  // Whether or not the memcpy is asynchronous.\n-  bool async;\n-};\n-\n-struct MemAllocDetails {\n-  // The amount of data requested for cudaMalloc events.\n-  uint64_t num_bytes;\n-};\n-\n-struct MemsetDetails {\n-  // The number of memory elements getting set\n-  size_t num_bytes;\n-  // Whether or not the memset is asynchronous.\n-  bool async;\n-};\n-\n-struct KernelDetails {\n-  // The number of registers used in this kernel.\n-  uint32_t registers_per_thread;\n-  // The amount of shared memory space used by a thread block.\n-  uint32_t static_shared_memory_usage;\n-  // The amount of dynamic memory space used by a thread block.\n-  uint32_t dynamic_shared_memory_usage;\n-  // X-dimension of a thread block.\n-  uint32_t block_x;\n-  // Y-dimension of a thread block.\n-  uint32_t block_y;\n-  // Z-dimension of a thread block.\n-  uint32_t block_z;\n-  // X-dimension of a grid.\n-  uint32_t grid_x;\n-  // Y-dimension of a grid.\n-  uint32_t grid_y;\n-  // Z-dimension of a grid.\n-  uint32_t grid_z;\n-\n-  // kernel address. Used for calculating core occupancy\n-  void* func_ptr;\n-};\n-\n inline std::string ToXStat(const KernelDetails& kernel_info,\n                            double occupancy_pct) {\n-  return absl::StrCat(\n-      \"regs:\", kernel_info.registers_per_thread,\n-      \" static_shared:\", kernel_info.static_shared_memory_usage,\n-      \" dynamic_shared:\", kernel_info.dynamic_shared_memory_usage,\n-      \" grid:\", kernel_info.grid_x, \",\", kernel_info.grid_y, \",\",\n-      kernel_info.grid_z, \" block:\", kernel_info.block_x, \",\",\n-      kernel_info.block_y, \",\", kernel_info.block_z,\n-      \" occ_pct:\", occupancy_pct);\n+  uint32_t grid_x = kernel_info.workgroup_x != 0\n+                        ? kernel_info.grid_x / kernel_info.workgroup_x\n+                        : 0,\n+           grid_y = kernel_info.workgroup_y != 0\n+                        ? kernel_info.grid_y / kernel_info.workgroup_y\n+                        : 0,\n+           grid_z = kernel_info.workgroup_z != 0\n+                        ? kernel_info.grid_z / kernel_info.workgroup_z\n+                        : 0;\n+\n+  return absl::StrCat(\" grid:\", grid_x, \",\", grid_y, \",\", grid_z,\n+                      \" block:\", kernel_info.workgroup_x, \",\",\n+                      kernel_info.workgroup_y, \",\", kernel_info.workgroup_z,\n+                      \" private_mem:\", kernel_info.private_segment_size,\n+                      \" group_mem:\", kernel_info.group_segment_size,\n+                      \" occ_pct:\", occupancy_pct);\n }\n \n-enum class RocmTracerEventType {\n-  Unsupported = 0,\n-  Kernel,\n-  MemcpyH2D,\n-  MemcpyD2H,\n-  MemcpyD2D,\n-  MemcpyP2P,\n-  MemcpyOther,\n-  MemoryAlloc,\n-  MemoryFree,\n-  Memset,\n-  Synchronization,\n-  Generic,\n-};\n-\n-const char* GetRocmTracerEventTypeName(const RocmTracerEventType& type);\n-\n-enum class RocmTracerEventSource {\n-  Invalid = 0,\n-  ApiCallback,\n-  Activity,\n-};\n-\n-const char* GetRocmTracerEventSourceName(const RocmTracerEventSource& source);\n-\n-enum class RocmTracerEventDomain {\n-  InvalidDomain = 0,\n-  HIP_API,\n-  HIP_OPS,\n-};\n-const char* GetRocmTracerEventDomainName(const RocmTracerEventDomain& domain);\n-// RocmTracerSyncTypes forward declaration\n-enum class RocmTracerSyncTypes;\n-\n-struct SynchronizationDetails {\n-  RocmTracerSyncTypes sync_type;\n-};\n-\n-struct RocmTracerEvent {\n-  static constexpr uint32_t kInvalidDeviceId =\n-      std::numeric_limits<uint32_t>::max();\n-  static constexpr uint64_t kInvalidThreadId =\n-      std::numeric_limits<uint64_t>::max();\n-  static constexpr uint32_t kInvalidCorrelationId =\n-      std::numeric_limits<uint32_t>::max();\n-  static constexpr uint64_t kInvalidStreamId =\n-      std::numeric_limits<uint64_t>::max();\n-  RocmTracerEventType type;\n-  RocmTracerEventSource source = RocmTracerEventSource::Invalid;\n-  RocmTracerEventDomain domain;\n-  std::string name;\n-  // This points to strings in AnnotationMap, which should outlive the point\n-  // where serialization happens.\n-  absl::string_view annotation;\n-  absl::string_view roctx_range;\n-  uint64_t start_time_ns = 0;\n-  uint64_t end_time_ns = 0;\n-  uint32_t device_id = kInvalidDeviceId;\n-  uint32_t correlation_id = kInvalidCorrelationId;\n-  uint64_t thread_id = kInvalidThreadId;\n-  int64_t stream_id = kInvalidStreamId;\n-  union {\n-    MemcpyDetails memcpy_info;                    // If type == Memcpy*\n-    MemsetDetails memset_info;                    // If type == Memset*\n-    MemAllocDetails memalloc_info;                // If type == MemoryAlloc\n-    KernelDetails kernel_info;                    // If type == Kernel\n-    SynchronizationDetails synchronization_info;  // If type == Synchronization\n-  };\n-};\n+struct RocmDeviceOccupancyParams {\n+  hipFuncAttributes attributes = {};\n+  int block_size = 0;\n+  size_t dynamic_smem_size = 0;\n+  void* func_ptr;\n \n-struct RocmTraceCollectorOptions {\n-  // Maximum number of events to collect from callback API; if -1, no limit.\n-  // if 0, the callback API is enabled to build a correlation map, but no\n-  // events are collected.\n-  uint64_t max_callback_api_events;\n-  // Maximum number of events to collect from activity API; if -1, no limit.\n-  uint64_t max_activity_api_events;\n-  // Maximum number of annotation strings that we can accommodate.\n-  uint64_t max_annotation_strings;\n-  // Number of GPUs involved.\n-  uint32_t num_gpus;\n+  friend bool operator==(const RocmDeviceOccupancyParams& a,\n+                         const RocmDeviceOccupancyParams& b) noexcept {\n+    // Compare only the fields that affect occupancy decisions.\n+    return std::tuple{a.attributes.binaryVersion,\n+                      a.attributes.cacheModeCA,\n+                      a.attributes.constSizeBytes,\n+                      a.attributes.localSizeBytes,\n+                      a.attributes.maxDynamicSharedSizeBytes,\n+                      a.attributes.maxThreadsPerBlock,\n+                      a.attributes.numRegs,\n+                      a.attributes.preferredShmemCarveout,\n+                      a.attributes.ptxVersion,\n+                      a.block_size,\n+                      a.dynamic_smem_size,\n+                      a.func_ptr} ==\n+           std::tuple{b.attributes.binaryVersion,\n+                      b.attributes.cacheModeCA,\n+                      b.attributes.constSizeBytes,\n+                      b.attributes.localSizeBytes,\n+                      b.attributes.maxDynamicSharedSizeBytes,\n+                      b.attributes.maxThreadsPerBlock,\n+                      b.attributes.numRegs,\n+                      b.attributes.preferredShmemCarveout,\n+                      b.attributes.ptxVersion,\n+                      b.block_size,\n+                      b.dynamic_smem_size,\n+                      b.func_ptr};\n+  }\n+\n+  friend bool operator!=(const RocmDeviceOccupancyParams& a,\n+                         const RocmDeviceOccupancyParams& b) noexcept {\n+    return !(a == b);\n+  }\n+\n+  template <typename H>\n+  friend H AbslHashValue(H hash_state,\n+                         const RocmDeviceOccupancyParams& params) {\n+    return H::combine(\n+        std::move(hash_state), params.attributes.maxThreadsPerBlock,\n+        params.attributes.numRegs, params.attributes.sharedSizeBytes,\n+        params.attributes.maxDynamicSharedSizeBytes, params.block_size,\n+        params.dynamic_smem_size, params.func_ptr);\n+  }\n };\n \n-class AnnotationMap {\n- public:\n-  explicit AnnotationMap(uint64_t max_size) : max_size_(max_size) {}\n-  void Add(uint32_t correlation_id, const std::string& annotation);\n-  absl::string_view LookUp(uint32_t correlation_id);\n-\n- private:\n-  struct AnnotationMapImpl {\n-    // The population/consumption of annotations might happen from multiple\n-    // callback/activity api related threads.\n-    absl::Mutex mutex;\n-    // Annotation tends to be repetitive, use a hash_set to store the strings,\n-    // an use the reference to the string in the map.\n-    absl::node_hash_set<std::string> annotations;\n-    absl::flat_hash_map<uint32_t, absl::string_view> correlation_map;\n-  };\n-  const uint64_t max_size_;\n-  AnnotationMapImpl map_;\n-\n- public:\n-  // Disable copy and move.\n-  AnnotationMap(const AnnotationMap&) = delete;\n-  AnnotationMap& operator=(const AnnotationMap&) = delete;\n+// FIXME: rocprofiler-sdk does not have this one yet\n+struct OccupancyStats {\n+  double occupancy_pct = 0.0;\n+  int min_grid_size = 0;\n+  int suggested_block_size = 0;\n };\n \n class RocmTraceCollector {\n  public:\n   explicit RocmTraceCollector(const RocmTraceCollectorOptions& options)\n-      : options_(options), annotation_map_(options.max_annotation_strings) {}\n+      : options_(options) {}\n   virtual ~RocmTraceCollector() {}\n \n   virtual void AddEvent(RocmTracerEvent&& event, bool is_auxiliary) = 0;\n   virtual void OnEventsDropped(const std::string& reason,\n                                uint32_t num_events) = 0;\n   virtual void Flush() = 0;\n-  virtual void Export(XSpace* space) = 0;\n-\n-  AnnotationMap* annotation_map() { return &annotation_map_; }\n+  virtual void Export(tsl::profiler::XSpace* space) = 0;\n \n  protected:\n   RocmTraceCollectorOptions options_;\n \n- private:\n-  AnnotationMap annotation_map_;\n-\n  public:\n   // Disable copy and move.\n   RocmTraceCollector(const RocmTraceCollector&) = delete;\n   RocmTraceCollector& operator=(const RocmTraceCollector&) = delete;\n };\n \n+class PerDeviceCollector {\n+ public:\n+  void Export(uint64_t start_walltime_ns, uint64_t start_gputime_ns,\n+              uint64_t end_gputime_ns,\n+              tsl::profiler::XPlaneBuilder* device_plane,\n+              tsl::profiler::XPlaneBuilder* host_plane);\n+\n+  PerDeviceCollector() = default;\n+\n+  void AddEvent(RocmTracerEvent&& event);\n+  void GetDeviceCapabilities(int32_t device_ordinal,\n+                             tsl::profiler::XPlaneBuilder* device_plane);\n+\n+ private:\n+  OccupancyStats GetOccupancy(const RocmDeviceOccupancyParams& params) const;\n+  void CreateXEvent(const RocmTracerEvent& event,\n+                    tsl::profiler::XPlaneBuilder* plane, uint64_t start_gpu_ns,\n+                    uint64_t end_gpu_ns, tsl::profiler::XLineBuilder* line);\n+  void SortByStartTime();\n+  bool IsHostEvent(const RocmTracerEvent& event, int64_t* line_id);\n+\n+ private:\n+  absl::Mutex events_mutex_;\n+  std::vector<RocmTracerEvent> events_ ABSL_GUARDED_BY(events_mutex_);\n+  absl::flat_hash_map<RocmDeviceOccupancyParams, OccupancyStats>\n+      occupancy_cache_;\n+  hipDeviceProp_t device_properties_;\n+};  // PerDeviceCollector\n+\n+class RocmTraceCollectorImpl : public RocmTraceCollector {\n+ public:\n+  RocmTraceCollectorImpl(const RocmTraceCollectorOptions& options,\n+                         uint64_t start_walltime_ns, uint64_t start_gputime_ns)\n+      : RocmTraceCollector(options),\n+        num_callback_events_(0),\n+        num_activity_events_(0),\n+        start_walltime_ns_(start_walltime_ns),\n+        start_gputime_ns_(start_gputime_ns),\n+        num_gpus_(options.num_gpus) {}\n+\n+  void AddEvent(RocmTracerEvent&& event, bool is_auxiliary) override;\n+  void Flush() override;\n+  void Export(tsl::profiler::XSpace* space) override;\n+\n+  void OnEventsDropped(const std::string& reason,\n+                       uint32_t correlation_id) override {\n+    VLOG(2) << \"RocmTracerEvent dropped (correlation_id=\" << correlation_id\n+            << \",) : \" << reason << \".\";\n+  }\n+\n+ private:\n+  std::atomic<int> num_callback_events_;\n+  std::atomic<int> num_activity_events_;\n+  uint64_t start_walltime_ns_;\n+  uint64_t start_gputime_ns_;\n+  int num_gpus_;\n+\n+  absl::Mutex event_maps_mutex_;\n+  absl::flat_hash_map<uint32_t, RocmTracerEvent> api_events_map_\n+      ABSL_GUARDED_BY(event_maps_mutex_);\n+\n+  /* Some apis such as MEMSETD32 (based on an observation with ResNet50),\n+   trigger multiple HIP ops domain activities. We keep them in a vector and\n+   merge them with api activities at flush time.\n+ */\n+  absl::flat_hash_map<uint32_t, std::vector<RocmTracerEvent>>\n+      activity_ops_events_map_ ABSL_GUARDED_BY(event_maps_mutex_);\n+  // This is for the APIs that we track because we need some information from\n+  // them to populate the corresponding activity that we actually track.\n+  absl::flat_hash_map<uint32_t, RocmTracerEvent> auxiliary_api_events_map_\n+      ABSL_GUARDED_BY(event_maps_mutex_);\n+\n+  std::vector<RocmTracerEvent> ApiActivityInfoExchange()\n+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(event_maps_mutex_);\n+\n+  absl::node_hash_map<uint32_t, PerDeviceCollector> per_device_collector_;\n+};  // RocmTraceCollectorImpl\n+\n std::unique_ptr<RocmTraceCollector> CreateRocmCollector(\n-    const RocmTraceCollectorOptions& options, const uint64_t start_walltime_ns,\n-    const uint64_t start_gputime_ns);\n+    const RocmTraceCollectorOptions& options, uint64_t start_walltime_ns,\n+    uint64_t start_gputime_ns);\n \n }  // namespace profiler\n }  // namespace xla"
        },
        {
            "sha": "1e0d341746546a6f5248f1c2288b4b67394d290e",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_collector_test.cc",
            "status": "added",
            "additions": 108,
            "deletions": 0,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_collector_test.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -0,0 +1,108 @@\n+/* Copyright 2025 The OpenXLA Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/gpu/rocm_collector.h\"\n+\n+#include <cstdint>\n+#include <utility>\n+\n+#include <gtest/gtest.h>\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n+#include \"xla/tsl/profiler/utils/xplane_utils.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace test {\n+\n+using tsl::profiler::FindOrAddMutablePlaneWithName;\n+using tsl::profiler::XSpace;\n+\n+TEST(RocmCollectorTest, TestAddKernelEventAndExport) {\n+  RocmTraceCollectorOptions options;\n+  options.max_callback_api_events = 100;\n+  options.max_activity_api_events = 100;\n+  options.max_annotation_strings = 100;\n+  options.num_gpus = 1;\n+\n+  constexpr uint64_t kStartWallTimeNs = 1000;\n+  constexpr uint64_t kStartGpuTimeNs = 2000;\n+\n+  RocmTraceCollectorImpl collector(options, kStartWallTimeNs, kStartGpuTimeNs);\n+\n+  constexpr uint32_t kCorrelationId = 42;\n+  constexpr uint64_t kStartTimeNs = 3000;\n+  constexpr uint64_t kEndTimeNs = 4000;\n+\n+  // === 1. Add API Callback Event ===\n+  RocmTracerEvent api_event;\n+  api_event.type = RocmTracerEventType::Kernel;\n+  api_event.source = RocmTracerEventSource::ApiCallback;\n+  api_event.domain = RocmTracerEventDomain::HIP_API;\n+  api_event.name = \"test_rocm_kernel\";\n+  api_event.correlation_id = kCorrelationId;\n+  api_event.thread_id = 999;\n+  api_event.kernel_info = KernelDetails{};\n+  api_event.kernel_info.private_segment_size = 32;\n+  api_event.kernel_info.group_segment_size = 1024;\n+  api_event.kernel_info.workgroup_x = 256;\n+  api_event.kernel_info.workgroup_y = 1;\n+  api_event.kernel_info.workgroup_z = 1;\n+  api_event.kernel_info.grid_x = 100;\n+  api_event.kernel_info.grid_y = 1;\n+  api_event.kernel_info.grid_z = 1;\n+  api_event.kernel_info.func_ptr = reinterpret_cast<void*>(0xdeadbeef);\n+\n+  collector.AddEvent(std::move(api_event), /*is_auxiliary=*/false);\n+\n+  // === 2. Add Activity Event ===\n+  RocmTracerEvent activity_event;\n+  activity_event.type = RocmTracerEventType::Kernel;\n+  activity_event.source = RocmTracerEventSource::Activity;\n+  activity_event.domain = RocmTracerEventDomain::HIP_OPS;\n+  activity_event.name = \"test_rocm_kernel\";\n+  activity_event.correlation_id = kCorrelationId;\n+  activity_event.start_time_ns = kStartTimeNs;\n+  activity_event.end_time_ns = kEndTimeNs;\n+  activity_event.device_id = 100;\n+  activity_event.stream_id = 123;\n+\n+  collector.AddEvent(std::move(activity_event), /*is_auxiliary=*/false);\n+\n+  // === 3. Finalize and Export ===\n+  collector.Flush();\n+\n+  tensorflow::profiler::XSpace space;\n+  collector.Export(&space);\n+\n+  // === 4. Check results ===\n+  ASSERT_GE(space.planes_size(), 1);\n+  const auto* gpu_plane =\n+      FindOrAddMutablePlaneWithName(&space, \"/device:GPU:0\");\n+  ASSERT_NE(gpu_plane, nullptr);\n+\n+  ASSERT_GT(gpu_plane->lines_size(), 0);\n+  const auto& line = gpu_plane->lines(0);\n+  ASSERT_GT(line.events_size(), 0);\n+\n+  const auto& event = line.events(0);\n+  EXPECT_EQ(event.offset_ps(), (kStartTimeNs - kStartGpuTimeNs) * 1000);\n+  EXPECT_EQ(event.duration_ps(), (kEndTimeNs - kStartTimeNs) * 1000);\n+  EXPECT_EQ(gpu_plane->event_metadata().at(event.metadata_id()).name(),\n+            \"test_rocm_kernel\");\n+}\n+\n+}  // namespace test\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "40f0e0e96cfbe91ccfd9cc1d46bb4999a2a609a9",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_tracer.cc",
            "status": "modified",
            "additions": 493,
            "deletions": 1501,
            "changes": 1994,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -13,1578 +13,570 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n+// This translation unit is **selfcontained**: it provides minimal stub\n+// implementations for the rocprofiler callbacks that XLA needs to register\n+// (toolInit / toolFinialize / code_object_callback).  They do nothing except\n+// keep the compiler and linker happy.  Once real logging is implemented, you\n+// can replace the stubs with the actual logic.\n+\n #include \"xla/backends/profiler/gpu/rocm_tracer.h\"\n \n-#include <cstdint>\n+#include <time.h>\n+#include <unistd.h>\n \n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/container/node_hash_map.h\"\n-#include \"absl/status/status.h\"\n+#include <atomic>\n+#include <cassert>\n+#include <cstdint>\n+#include <cstring>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/str_format.h\"\n #include \"absl/synchronization/mutex.h\"\n-#include \"rocm/rocm_config.h\"\n+#include \"rocm/include/rocprofiler-sdk/agent.h\"\n+#include \"rocm/include/rocprofiler-sdk/buffer.h\"\n+#include \"rocm/include/rocprofiler-sdk/buffer_tracing.h\"\n+#include \"rocm/include/rocprofiler-sdk/callback_tracing.h\"\n+#include \"rocm/include/rocprofiler-sdk/context.h\"\n+#include \"rocm/include/rocprofiler-sdk/cxx/details/name_info.hpp\"\n+#include \"rocm/include/rocprofiler-sdk/fwd.h\"\n+#include \"rocm/include/rocprofiler-sdk/hip/runtime_api_id.h\"\n+#include \"rocm/include/rocprofiler-sdk/internal_threading.h\"\n+#include \"rocm/include/rocprofiler-sdk/registration.h\"\n+#include \"rocm/include/rocprofiler-sdk/rocprofiler.h\"\n+#include \"xla/backends/profiler/gpu/rocm_collector.h\"\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n #include \"xla/tsl/profiler/backends/cpu/annotation_stack.h\"\n-#include \"xla/tsl/profiler/utils/time_utils.h\"\n-#include \"tsl/platform/env.h\"\n-#include \"tsl/platform/errors.h\"\n-#include \"tsl/platform/logging.h\"\n-#include \"tsl/platform/macros.h\"\n-#include \"tsl/platform/mem.h\"\n+#include \"tsl/platform/abi.h\"\n \n+// for rocprofiler-sdk\n namespace xla {\n namespace profiler {\n \n-namespace se = ::stream_executor;\n using tsl::profiler::AnnotationStack;\n \n+// represents an invalid or uninitialized device ID used in RocmTracer events.\n constexpr uint32_t RocmTracerEvent::kInvalidDeviceId;\n \n-#define RETURN_IF_ROCTRACER_ERROR(expr)                                     \\\n-  do {                                                                      \\\n-    roctracer_status_t status = expr;                                       \\\n-    if (status != ROCTRACER_STATUS_SUCCESS) {                               \\\n-      const char* errstr = se::wrap::roctracer_error_string();              \\\n-      LOG(ERROR) << \"function \" << #expr << \"failed with error \" << errstr; \\\n-      return absl::InternalError(                                           \\\n-          absl::StrCat(\"roctracer call error\", errstr));                    \\\n-    }                                                                       \\\n-  } while (false)\n-\n-namespace {\n-\n-// GetCachedTID() caches the thread ID in thread-local storage (which is a\n-// userspace construct) to avoid unnecessary system calls. Without this caching,\n-// it can take roughly 98ns, while it takes roughly 1ns with this caching.\n-int64_t GetCachedTID() {\n-  static thread_local int64_t current_thread_id =\n-      tsl::Env::Default()->GetCurrentThreadId();\n-  return current_thread_id;\n-}\n-\n-const char* GetActivityDomainName(uint32_t domain) {\n-  switch (domain) {\n-    case ACTIVITY_DOMAIN_HSA_API:\n-      return \"HSA API\";\n-    case ACTIVITY_DOMAIN_HSA_OPS:\n-      return \"HSA OPS\";\n-    case ACTIVITY_DOMAIN_HIP_OPS:\n-      return \"HIP OPS/HCC/VDI\";\n-    case ACTIVITY_DOMAIN_HIP_API:\n-      return \"HIP API\";\n-    case ACTIVITY_DOMAIN_KFD_API:\n-      return \"KFD API\";\n-    case ACTIVITY_DOMAIN_EXT_API:\n-      return \"EXT API\";\n-    case ACTIVITY_DOMAIN_ROCTX:\n-      return \"ROCTX\";\n-    case ACTIVITY_DOMAIN_HSA_EVT:\n-      return \"HSA envents\";\n-    default:\n-      DCHECK(false);\n-      return \"\";\n+inline auto GetCallbackTracingNames() {\n+  return rocprofiler::sdk::get_callback_tracing_names();\n+}\n+\n+std::vector<rocprofiler_agent_v0_t> GetGpuDeviceAgents();\n+\n+//-----------------------------------------------------------------------------\n+// copy api calls\n+bool isCopyApi(uint32_t id) {\n+  switch (id) {\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAtoH:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoD:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoDAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoH:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoHAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoA:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoD:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoDAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2D:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2DAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeer:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeerAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToArray:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync:\n+    case ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyWithStream:\n+      return true;\n+    default: {\n+    };\n   }\n-  return \"\";\n+  return false;\n }\n \n-std::string GetActivityDomainOpName(uint32_t domain, uint32_t op) {\n-  std::ostringstream oss;\n-  oss << GetActivityDomainName(domain) << \" - \";\n-  switch (domain) {\n-    case ACTIVITY_DOMAIN_HIP_API:\n-      oss << hip_api_name(op);\n-      break;\n-    default:\n-      oss << op;\n-      break;\n-  }\n-  return oss.str();\n-}\n-\n-const char* GetActivityPhaseName(uint32_t phase) {\n-  switch (phase) {\n-    case ACTIVITY_API_PHASE_ENTER:\n-      return \"ENTER\";\n-    case ACTIVITY_API_PHASE_EXIT:\n-      return \"EXIT\";\n-    default:\n-      DCHECK(false);\n-      return \"\";\n-  }\n-  return \"\";\n+// ----------------------------------------------------------------------------\n+// Stub implementations for RocmTracer static functions expected by\n+// rocprofiler-sdk.\n+// ----------------------------------------------------------------------------\n+RocmTracer& RocmTracer::GetRocmTracerSingleton() {\n+  static RocmTracer obj;\n+  return obj;\n }\n \n-inline void DumpApiCallbackData(uint32_t domain, uint32_t cbid,\n-                                const void* cbdata) {\n-  std::ostringstream oss;\n-  oss << \"API callback for \" << GetActivityDomainName(domain);\n-  if (domain == ACTIVITY_DOMAIN_HIP_API) {\n-    const hip_api_data_t* data =\n-        reinterpret_cast<const hip_api_data_t*>(cbdata);\n-    oss << \" - \" << hip_api_name(cbid);\n-    oss << \", correlation_id=\" << data->correlation_id;\n-    oss << \", phase=\" << GetActivityPhaseName(data->phase);\n-    switch (cbid) {\n-      case HIP_API_ID_hipModuleLaunchKernel:\n-      case HIP_API_ID_hipExtModuleLaunchKernel:\n-      case HIP_API_ID_hipHccModuleLaunchKernel:\n-      case HIP_API_ID_hipLaunchKernel:\n-      case HIP_API_ID_hipExtLaunchKernel:\n-        break;\n-      case HIP_API_ID_hipMemcpyDtoH:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyDtoH.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemcpyDtoHAsync:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyDtoHAsync.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemcpyHtoD:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyHtoD.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemcpyHtoDAsync:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyHtoDAsync.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemcpyDtoD:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyDtoD.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemcpyDtoDAsync:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyDtoDAsync.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemcpyAsync:\n-        oss << \", sizeBytes=\" << data->args.hipMemcpyAsync.sizeBytes;\n-        break;\n-      case HIP_API_ID_hipMemsetD32:\n-        oss << \", value=\" << data->args.hipMemsetD32.value;\n-        oss << \", count=\" << data->args.hipMemsetD32.count;\n-        break;\n-      case HIP_API_ID_hipMemsetD32Async:\n-        oss << \", value=\" << data->args.hipMemsetD32Async.value;\n-        oss << \", count=\" << data->args.hipMemsetD32Async.count;\n-        break;\n-      case HIP_API_ID_hipMemsetD8:\n-        oss << \", value=\" << data->args.hipMemsetD8.value;\n-        oss << \", count=\" << data->args.hipMemsetD8.count;\n-        break;\n-      case HIP_API_ID_hipMemsetD8Async:\n-        oss << \", value=\" << data->args.hipMemsetD8Async.value;\n-        oss << \", count=\" << data->args.hipMemsetD8Async.count;\n-        break;\n-      case HIP_API_ID_hipMalloc:\n-        oss << \", size=\" << data->args.hipMalloc.size;\n-        break;\n-      case HIP_API_ID_hipFree:\n-        oss << \", ptr=\" << data->args.hipFree.ptr;\n-        break;\n-      case HIP_API_ID_hipStreamSynchronize:\n-        break;\n-      case HIP_API_ID_hipStreamWaitEvent:  // ignore all aux HIP API Events\n-      case HIP_API_ID_hipHostFree:\n-      case HIP_API_ID_hipHostMalloc:\n-      case HIP_API_ID_hipSetDevice:\n-        break;\n-      default:\n-        VLOG(3) << \"Warning: HIP API is not handled: HIP_API_ID_\"\n-                << hip_api_name(cbid);\n-        break;\n-    }\n-  } else {\n-    oss << \": \" << cbid;\n-  }\n-  VLOG(3) << oss.str();\n-}\n-\n-void DumpActivityRecord(const roctracer_record_t* record,\n-                        std::string extra_info) {\n-  std::ostringstream oss;\n-  oss << \"Activity callback for \" << GetActivityDomainName(record->domain);\n-  oss << \", op name= \"\n-      << se::wrap::roctracer_op_string(record->domain, record->op,\n-                                       record->kind);\n-  oss << \", correlation_id=\" << record->correlation_id;\n-  oss << \", begin_ns=\" << record->begin_ns;\n-  oss << \", end_ns=\" << record->end_ns;\n-  oss << \", duration=\" << record->end_ns - record->begin_ns;\n-  oss << \", device_id=\" << record->device_id;\n-  oss << \", queue_id=\" << record->queue_id;\n-  oss << \", process_id=\" << record->process_id;\n-  oss << \", thread_id=\" << record->thread_id;\n-  oss << \", external_id=\" << record->external_id;\n-  oss << \", bytes=\" << record->bytes;\n-  oss << \", domain=\" << record->domain;\n-  oss << \", op=\" << record->op;\n-  oss << \", kind=\" << record->kind;\n-  oss << \", extra_info=\" << extra_info;\n-  VLOG(3) << oss.str();\n-}\n-\n-}  // namespace\n-\n-const char* GetRocmTracerEventTypeName(const RocmTracerEventType& type) {\n-  switch (type) {\n-    case RocmTracerEventType::Kernel:\n-      return \"Kernel\";\n-    case RocmTracerEventType::MemcpyH2D:\n-      return \"MemcpyH2D\";\n-    case RocmTracerEventType::MemcpyD2H:\n-      return \"MemcpyD2H\";\n-    case RocmTracerEventType::MemcpyD2D:\n-      return \"MemcpyD2D\";\n-    case RocmTracerEventType::MemcpyP2P:\n-      return \"MemcpyP2P\";\n-    case RocmTracerEventType::MemcpyOther:\n-      return \"MemcpyOther\";\n-    case RocmTracerEventType::MemoryAlloc:\n-      return \"MemoryAlloc\";\n-    case RocmTracerEventType::MemoryFree:\n-      return \"MemoryFree\";\n-    case RocmTracerEventType::Memset:\n-      return \"Memset\";\n-    case RocmTracerEventType::Synchronization:\n-      return \"Synchronization\";\n-    case RocmTracerEventType::Generic:\n-      return \"Generic\";\n-    default:\n-      DCHECK(false);\n-      return \"\";\n-  }\n-  return \"\";\n+bool RocmTracer::IsAvailable() const {\n+  return !activity_tracing_enabled_ && !api_tracing_enabled_;  // &&NumGpus()\n }\n \n-const char* GetRocmTracerEventSourceName(const RocmTracerEventSource& source) {\n-  switch (source) {\n-    case RocmTracerEventSource::ApiCallback:\n-      return \"ApiCallback\";\n-      break;\n-    case RocmTracerEventSource::Activity:\n-      return \"Activity\";\n-      break;\n-    case RocmTracerEventSource::Invalid:\n-      return \"Invalid\";\n-      break;\n-    default:\n-      DCHECK(false);\n-      return \"\";\n+/*static*/ uint64_t RocmTracer::GetTimestamp() {\n+  uint64_t ts;\n+  if (rocprofiler_get_timestamp(&ts) != ROCPROFILER_STATUS_SUCCESS) {\n+    LOG(ERROR) << \"function rocprofiler_get_timestamp failed with error \";\n+    return 0;\n   }\n-  return \"\";\n+  return ts;\n }\n \n-// FIXME(rocm-profiler): These domain names are not consistent with the\n-// GetActivityDomainName function\n-const char* GetRocmTracerEventDomainName(const RocmTracerEventDomain& domain) {\n-  switch (domain) {\n-    case RocmTracerEventDomain::HIP_API:\n-      return \"HIP_API\";\n-      break;\n-    case RocmTracerEventDomain::HIP_OPS:\n-      return \"HIP_OPS\";\n-      break;\n-    default:\n-      VLOG(3) << \"RocmTracerEventDomain::InvalidDomain\";\n-      DCHECK(false);\n-      return \"\";\n+void RocmTracer::Enable(const RocmTracerOptions& options,\n+                        RocmTraceCollector* collector) {\n+  absl::MutexLock lock(collector_mutex_);\n+  if (collector_ != nullptr) {\n+    LOG(WARNING) << \"ROCM tracer is already running!\";\n+    return;\n   }\n-  return \"\";\n-}\n-\n-absl::Status RocmApiCallbackImpl::operator()(uint32_t domain, uint32_t cbid,\n-                                             const void* cbdata) {\n-  /* Some APIs such as hipMalloc, implicitly work on th devices set by the\n-    user using APIs such as hipSetDevice. API callbacks and activity records\n-    for functions like hipMalloc does not return the device id (CUDA does). To\n-    solve this we need to track the APIs that select the device (such as\n-    hipSetDevice) for each thread.\n-    */\n-\n-  thread_local uint32_t default_device = hipGetStreamDeviceId(nullptr);\n-\n-  // DumpApiCallbackData(domain, cbid, cbdata);\n-\n-  if (domain != ACTIVITY_DOMAIN_HIP_API) return absl::OkStatus();\n-\n-  const hip_api_data_t* data = reinterpret_cast<const hip_api_data_t*>(cbdata);\n-\n-  if (data->phase == ACTIVITY_API_PHASE_ENTER) {\n-    if (options_.api_tracking_set.find(cbid) !=\n-        options_.api_tracking_set.end()) {\n-      absl::MutexLock lock(api_call_start_mutex_);\n-      api_call_start_time_.emplace(data->correlation_id,\n-                                   RocmTracer::GetTimestamp());\n-    }\n-\n-    if (cbid == HIP_API_ID_hipSetDevice) {\n-      default_device = hipGetStreamDeviceId(nullptr);\n-    }\n-  } else if (data->phase == ACTIVITY_API_PHASE_EXIT) {\n-    uint64_t enter_time = 0, exit_time = 0;\n-\n-    if (options_.api_tracking_set.find(cbid) !=\n-        options_.api_tracking_set.end()) {\n-      absl::MutexLock lock(api_call_start_mutex_);\n-      if (api_call_start_time_.find(data->correlation_id) !=\n-          api_call_start_time_.end()) {\n-        enter_time = api_call_start_time_.at(data->correlation_id);\n-        api_call_start_time_.erase(data->correlation_id);\n+  options_ = options;\n+  collector_ = collector;\n+  api_tracing_enabled_ = true;\n+  activity_tracing_enabled_ = true;\n+  rocprofiler_start_context(context_);\n+  LOG(INFO) << \"GpuTracer started with number of GPUs = \" << NumGpus();\n+}\n+\n+void RocmTracer::HipApiEvent(const rocprofiler_record_header_t* hdr,\n+                             RocmTracerEvent* trace_event) {\n+  const auto& rec =\n+      *static_cast<const rocprofiler_buffer_tracing_hip_api_record_t*>(\n+          hdr->payload);\n+\n+  trace_event->type = RocmTracerEventType::Kernel;\n+  trace_event->source = RocmTracerEventSource::ApiCallback;\n+  trace_event->domain = RocmTracerEventDomain::HIP_API;\n+  trace_event->name = \"??\";\n+  trace_event->start_time_ns = rec.start_timestamp;\n+  trace_event->end_time_ns = rec.end_timestamp;\n+  trace_event->device_id = RocmTracerEvent::kInvalidDeviceId;\n+  trace_event->correlation_id = rec.correlation_id.internal;\n+  trace_event->annotation =\n+      annotation_map()->LookUp(trace_event->correlation_id);\n+  trace_event->thread_id = rec.thread_id;\n+  trace_event->stream_id = RocmTracerEvent::kInvalidStreamId;\n+  trace_event->kernel_info = KernelDetails{};\n+\n+  {\n+    // bounds-check name table: kind and operation\n+    absl::MutexLock lock(kernel_lock_);\n+    const size_t kind = static_cast<size_t>(rec.kind);\n+    if (kind < name_info_.size()) {\n+      const auto& vec = name_info_[kind];\n+      const size_t op = static_cast<size_t>(rec.operation);\n+      if (op < vec.operations.size()) {\n+        trace_event->name = vec[op];\n       } else {\n-        LOG(WARNING) << \"An API exit callback received without API enter \"\n-                        \"with same correlation id. Event droped!\";\n-        return absl::OkStatus();  // This API does not belong to us.\n+        static std::atomic<int> once{0};\n+        if (once.fetch_add(1) == 0) {\n+          LOG(ERROR) << \"HIP op OOB: kind \" << kind << \" op = \" << op\n+                     << \" vec.size() = \" << vec.operations.size();\n+        }\n+        trace_event->name = \"HIP_UNKNOWN_OP\";\n       }\n-      exit_time = RocmTracer::GetTimestamp();\n-    }\n-    // Set up the map from correlation id to annotation string.\n-    const std::string& annotation = AnnotationStack::Get();\n-    if (!annotation.empty()) {\n-      collector_->annotation_map()->Add(data->correlation_id, annotation);\n-    }\n-\n-    if (options_.api_tracking_set.find(cbid) ==\n-        options_.api_tracking_set.end()) {\n-      VLOG(3) << \"API callback is from the auxilarity list. Corr. id=\"\n-              << data->correlation_id;\n-    }\n-    DumpApiCallbackData(domain, cbid, cbdata);\n-\n-    switch (cbid) {\n-      // star in comments means it does not exist in the driver wrapper\n-      case HIP_API_ID_hipModuleLaunchKernel:\n-      case HIP_API_ID_hipExtModuleLaunchKernel:  // *\n-      case HIP_API_ID_hipHccModuleLaunchKernel:  // *\n-      case HIP_API_ID_hipLaunchKernel:           // *\n-      case HIP_API_ID_hipExtLaunchKernel:\n-\n-        this->AddKernelEventUponApiExit(cbid, data, enter_time, exit_time);\n-\n-        // Add the correlation_ids for these events to the pending set\n-        // so that we can explicitly wait for their corresponding\n-        // HIP runtime activity records, before exporting the trace data\n-        tracer_->AddToPendingActivityRecords(data->correlation_id);\n-        break;\n-      case HIP_API_ID_hipMemcpy:\n-      case HIP_API_ID_hipMemcpyDtoH:\n-      case HIP_API_ID_hipMemcpyDtoHAsync:\n-      case HIP_API_ID_hipMemcpyHtoD:\n-      case HIP_API_ID_hipMemcpyHtoDAsync:\n-      case HIP_API_ID_hipMemcpyDtoD:\n-      case HIP_API_ID_hipMemcpyDtoDAsync:\n-      case HIP_API_ID_hipMemcpyAsync:\n-        this->AddNormalMemcpyEventUponApiExit(cbid, data, enter_time,\n-                                              exit_time);\n-        tracer_->AddToPendingActivityRecords(data->correlation_id);\n-        break;\n-      case HIP_API_ID_hipMemset:\n-      case HIP_API_ID_hipMemsetAsync:\n-      case HIP_API_ID_hipMemsetD32:\n-      case HIP_API_ID_hipMemsetD32Async:\n-      case HIP_API_ID_hipMemsetD16:\n-      case HIP_API_ID_hipMemsetD16Async:\n-      case HIP_API_ID_hipMemsetD8:\n-      case HIP_API_ID_hipMemsetD8Async:\n-        this->AddMemsetEventUponApiExit(cbid, data, enter_time, exit_time);\n-        break;\n-      case HIP_API_ID_hipMalloc:\n-      case HIP_API_ID_hipMallocPitch:\n-      case HIP_API_ID_hipHostMalloc:\n-      case HIP_API_ID_hipFree:\n-      case HIP_API_ID_hipHostFree:\n-        this->AddMallocFreeEventUponApiExit(cbid, data, default_device,\n-                                            enter_time, exit_time);\n-        break;\n-      case HIP_API_ID_hipStreamSynchronize:\n-      case HIP_API_ID_hipStreamWaitEvent:\n-        // case HIP_API_ID_hipEventSynchronize:\n-        this->AddSynchronizeEventUponApiExit(cbid, data, enter_time, exit_time);\n-        break;\n-      case HIP_API_ID_hipSetDevice:\n-        // we track this ID only to find the device ID\n-        //  for the current thread.\n-        break;\n-      default:\n-        //\n-        VLOG(1) << \"API call \"\n-                << se::wrap::roctracer_op_string(ACTIVITY_DOMAIN_HIP_API, cbid,\n-                                                 0)\n-                << \", corr. id=\" << data->correlation_id\n-                << \" dropped. No capturing function was found!\";\n-        // AddGenericEventUponApiExit(cbid, data);\n-        break;\n+    } else {\n+      static std::atomic<int> once{0};\n+      if (once.fetch_add(1) == 0) {\n+        LOG(ERROR) << \"HIP kind OOB: kind = \" << kind\n+                   << \" name_info_.size() = \" << name_info_.size();\n+      }\n+      trace_event->name = \"HIP_UNKNOWN_KIND\";\n     }\n   }\n-  return absl::OkStatus();\n-}\n \n-void RocmApiCallbackImpl::AddKernelEventUponApiExit(uint32_t cbid,\n-                                                    const hip_api_data_t* data,\n-                                                    const uint64_t enter_time,\n-                                                    const uint64_t exit_time) {\n-  /*\n-  extra fields:\n-    kernel_info, domain\n-\n-  missing fields:\n-    context_id\n-  */\n-  RocmTracerEvent event;\n-\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.type = RocmTracerEventType::Kernel;\n-  event.source = RocmTracerEventSource::ApiCallback;\n-  event.thread_id = GetCachedTID();\n-  event.correlation_id = data->correlation_id;\n-  event.start_time_ns = enter_time;\n-  event.end_time_ns = exit_time;\n-\n-  switch (cbid) {\n-    case HIP_API_ID_hipModuleLaunchKernel: {\n-      const hipFunction_t kernelFunc = data->args.hipModuleLaunchKernel.f;\n-      if (kernelFunc != nullptr) event.name = hipKernelNameRef(kernelFunc);\n-\n-      event.kernel_info.dynamic_shared_memory_usage =\n-          data->args.hipModuleLaunchKernel.sharedMemBytes;\n-      event.kernel_info.block_x = data->args.hipModuleLaunchKernel.blockDimX;\n-      event.kernel_info.block_y = data->args.hipModuleLaunchKernel.blockDimY;\n-      event.kernel_info.block_z = data->args.hipModuleLaunchKernel.blockDimZ;\n-      event.kernel_info.grid_x = data->args.hipModuleLaunchKernel.gridDimX;\n-      event.kernel_info.grid_y = data->args.hipModuleLaunchKernel.gridDimY;\n-      event.kernel_info.grid_z = data->args.hipModuleLaunchKernel.gridDimZ;\n-      event.kernel_info.func_ptr = kernelFunc;\n-      const hipStream_t& stream = data->args.hipModuleLaunchKernel.stream;\n-      // TODO(rocm-profiler): wrap this API if possible.\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipExtModuleLaunchKernel: {\n-      const hipFunction_t kernelFunc = data->args.hipExtModuleLaunchKernel.f;\n-      if (kernelFunc != nullptr) event.name = hipKernelNameRef(kernelFunc);\n-\n-      event.kernel_info.dynamic_shared_memory_usage =\n-          data->args.hipExtModuleLaunchKernel.sharedMemBytes;\n-      unsigned int blockDimX =\n-          data->args.hipExtModuleLaunchKernel.localWorkSizeX;\n-      unsigned int blockDimY =\n-          data->args.hipExtModuleLaunchKernel.localWorkSizeY;\n-      unsigned int blockDimZ =\n-          data->args.hipExtModuleLaunchKernel.localWorkSizeZ;\n-\n-      event.kernel_info.block_x = blockDimX;\n-      event.kernel_info.block_y = blockDimY;\n-      event.kernel_info.block_z = blockDimZ;\n-      event.kernel_info.grid_x =\n-          data->args.hipExtModuleLaunchKernel.globalWorkSizeX / blockDimX;\n-      event.kernel_info.grid_y =\n-          data->args.hipExtModuleLaunchKernel.globalWorkSizeY / blockDimY;\n-      event.kernel_info.grid_z =\n-          data->args.hipExtModuleLaunchKernel.globalWorkSizeZ / blockDimZ;\n-      event.kernel_info.func_ptr = kernelFunc;\n-      const hipStream_t& stream = data->args.hipExtModuleLaunchKernel.hStream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipHccModuleLaunchKernel: {\n-      const hipFunction_t kernelFunc = data->args.hipHccModuleLaunchKernel.f;\n-      if (kernelFunc != nullptr) event.name = hipKernelNameRef(kernelFunc);\n-\n-      event.kernel_info.dynamic_shared_memory_usage =\n-          data->args.hipHccModuleLaunchKernel.sharedMemBytes;\n-      event.kernel_info.block_x = data->args.hipHccModuleLaunchKernel.blockDimX;\n-      event.kernel_info.block_y = data->args.hipHccModuleLaunchKernel.blockDimY;\n-      event.kernel_info.block_z = data->args.hipHccModuleLaunchKernel.blockDimZ;\n-      event.kernel_info.grid_x =\n-          data->args.hipHccModuleLaunchKernel.globalWorkSizeX /\n-          event.kernel_info.block_x;\n-      event.kernel_info.grid_y =\n-          data->args.hipHccModuleLaunchKernel.globalWorkSizeY /\n-          event.kernel_info.block_y;\n-      event.kernel_info.grid_z =\n-          data->args.hipHccModuleLaunchKernel.globalWorkSizeZ /\n-          event.kernel_info.block_z;\n-      event.kernel_info.func_ptr = kernelFunc;\n-      const hipStream_t& stream = data->args.hipHccModuleLaunchKernel.hStream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-      event.kernel_info.dynamic_shared_memory_usage =\n-          data->args.hipHccModuleLaunchKernel.sharedMemBytes;\n-    } break;\n-    case HIP_API_ID_hipLaunchKernel: {\n-      const void* func_addr = data->args.hipLaunchKernel.function_address;\n-      hipStream_t stream = data->args.hipLaunchKernel.stream;\n-      if (func_addr != nullptr)\n-        event.name = hipKernelNameRefByPtr(func_addr, stream);\n-\n-      event.kernel_info.dynamic_shared_memory_usage =\n-          data->args.hipLaunchKernel.sharedMemBytes;\n-      event.kernel_info.block_x = data->args.hipLaunchKernel.dimBlocks.x;\n-      event.kernel_info.block_y = data->args.hipLaunchKernel.dimBlocks.y;\n-      event.kernel_info.block_z = data->args.hipLaunchKernel.dimBlocks.z;\n-      event.kernel_info.grid_x = data->args.hipLaunchKernel.numBlocks.x;\n-      event.kernel_info.grid_y = data->args.hipLaunchKernel.numBlocks.y;\n-      event.kernel_info.grid_z = data->args.hipLaunchKernel.numBlocks.z;\n-      event.kernel_info.func_ptr = (void*)func_addr;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipExtLaunchKernel: {\n-      const void* func_addr = data->args.hipExtLaunchKernel.function_address;\n-      hipStream_t stream = data->args.hipExtLaunchKernel.stream;\n-      if (func_addr != nullptr)\n-        event.name = hipKernelNameRefByPtr(func_addr, stream);\n-\n-      event.kernel_info.dynamic_shared_memory_usage =\n-          data->args.hipExtLaunchKernel.sharedMemBytes;\n-      event.kernel_info.block_x = data->args.hipExtLaunchKernel.dimBlocks.x;\n-      event.kernel_info.block_y = data->args.hipExtLaunchKernel.dimBlocks.y;\n-      event.kernel_info.block_z = data->args.hipExtLaunchKernel.dimBlocks.z;\n-      event.kernel_info.grid_x = data->args.hipExtLaunchKernel.numBlocks.x;\n-      event.kernel_info.grid_y = data->args.hipExtLaunchKernel.numBlocks.y;\n-      event.kernel_info.grid_z = data->args.hipExtLaunchKernel.numBlocks.z;\n-      event.kernel_info.func_ptr = const_cast<void*>(func_addr);\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n+  if (isCopyApi(rec.operation)) {\n+    // actually one needs to set the real type\n+    trace_event->type = RocmTracerEventType::MemcpyOther;\n   }\n-  bool is_auxiliary =\n-      options_.api_tracking_set.find(cbid) == options_.api_tracking_set.end();\n-  collector_->AddEvent(std::move(event), is_auxiliary);\n }\n \n-void RocmApiCallbackImpl::AddNormalMemcpyEventUponApiExit(\n-    uint32_t cbid, const hip_api_data_t* data, uint64_t enter_time,\n-    uint64_t exit_time) {\n-  /*\n-    missing:\n-      device_id(partially, have only for async), context_id,\n-    memcpy_info.kind(CUPTI puts CUPTI_ACTIVITY_MEMCPY_KIND_UNKNOWN),\n-      memcpy_info.destination(partially, only for async)( CUPTI puts device_id),\n-\n-    extra:\n-      domain, name,\n-  */\n-  // for CUDA, it does NOT capture stream id for these types\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.name = se::wrap::roctracer_op_string(ACTIVITY_DOMAIN_HIP_API, cbid, 0);\n-  event.source = RocmTracerEventSource::ApiCallback;\n-  event.thread_id = GetCachedTID();\n-  event.correlation_id = data->correlation_id;\n-  event.start_time_ns = enter_time;\n-  event.end_time_ns = exit_time;\n-\n-  /* The general hipMemcpy or hipMemcpyAsync can support any kind of memory\n-  copy operation, such as H2D, D2D, P2P, and D2H. Here we use MemcpyOther for\n-  all api calls with HipMemcpy(+Async) to carry-on this generality.\n-  We also assume that if we want to copy data BETWEEN devices, we do not use\n-  hipMemcpy(+Async) or hipMemcpyDtoD(+Async) as we explicitly always set the\n-  destenation as the source device id). Ultimately, to figure out the actual\n-  device we can use hipPointerGetAttributes but we do not do that now .In the\n-  other words, we assume we use hipMemcpyPeer to achieve the copy between\n-  devices.\n-  */\n-\n-  switch (cbid) {\n-    case HIP_API_ID_hipMemcpyDtoH: {\n-      event.type = RocmTracerEventType::MemcpyD2H;\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyDtoH.sizeBytes;\n-      event.memcpy_info.async = false;\n-    } break;\n-    case HIP_API_ID_hipMemcpyDtoHAsync: {\n-      event.type = RocmTracerEventType::MemcpyD2H;\n-      const hipStream_t& stream = data->args.hipMemcpyDtoHAsync.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyDtoHAsync.sizeBytes;\n-      event.memcpy_info.async = true;\n-      event.memcpy_info.destination = event.device_id;\n-    } break;\n-    case HIP_API_ID_hipMemcpyHtoD: {\n-      event.type = RocmTracerEventType::MemcpyH2D;\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyHtoD.sizeBytes;\n-      event.memcpy_info.async = false;\n-      // we set the destenattion device id for it using the device id we get\n-      // from activities when they exchange information before flushing\n-    } break;\n-    case HIP_API_ID_hipMemcpyHtoDAsync: {\n-      event.type = RocmTracerEventType::MemcpyH2D;\n-      const hipStream_t& stream = data->args.hipMemcpyHtoDAsync.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyHtoDAsync.sizeBytes;\n-      event.memcpy_info.async = true;\n-      event.memcpy_info.destination = event.device_id;\n-    } break;\n-    case HIP_API_ID_hipMemcpyDtoD: {\n-      event.type = RocmTracerEventType::MemcpyD2D;\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyDtoD.sizeBytes;\n-      event.memcpy_info.async = false;\n-    } break;\n-    case HIP_API_ID_hipMemcpyDtoDAsync: {\n-      event.type = RocmTracerEventType::MemcpyD2D;\n-      const hipStream_t& stream = data->args.hipMemcpyDtoDAsync.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyDtoDAsync.sizeBytes;\n-      event.memcpy_info.async = true;\n-      event.memcpy_info.destination = event.device_id;\n-    } break;\n-    case HIP_API_ID_hipMemcpy: {\n-      event.type = RocmTracerEventType::MemcpyOther;\n-      event.memcpy_info.num_bytes = data->args.hipMemcpy.sizeBytes;\n-      event.memcpy_info.async = false;\n-    } break;\n-    case HIP_API_ID_hipMemcpyAsync: {\n-      event.type = RocmTracerEventType::MemcpyOther;\n-      const hipStream_t& stream = data->args.hipMemcpyAsync.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyAsync.sizeBytes;\n-      event.memcpy_info.async = true;\n-      event.memcpy_info.destination = event.device_id;\n-    } break;\n+void RocmTracer::MemcpyEvent(const rocprofiler_record_header_t* hdr,\n+                             RocmTracerEvent* trace_event) {\n+  const auto& rec =\n+      *static_cast<const rocprofiler_buffer_tracing_memory_copy_record_t*>(\n+          hdr->payload);\n+\n+#define OO(src, target)                              \\\n+  case ROCPROFILER_MEMORY_COPY_##src:                \\\n+    trace_event->type = RocmTracerEventType::target; \\\n+    trace_event->name = #target;                     \\\n+    break;\n+\n+  switch (rec.operation) {\n+    OO(NONE, MemcpyOther)\n+    OO(HOST_TO_HOST, MemcpyOther)\n+    OO(HOST_TO_DEVICE, MemcpyH2D)\n+    OO(DEVICE_TO_HOST, MemcpyD2H)\n+    OO(DEVICE_TO_DEVICE, MemcpyD2D)\n     default:\n-      LOG(WARNING) << \"Unsupported Memcpy API for profiling observed for cbid=\"\n-                   << cbid << \". Event dropped!\";\n-      return;\n-      break;\n+      LOG(WARNING) << \"Unexpected memcopy operation \" << rec.operation;\n+      trace_event->type = RocmTracerEventType::MemcpyOther;\n   }\n-\n-  bool is_auxiliary =\n-      options_.api_tracking_set.find(cbid) == options_.api_tracking_set.end();\n-  collector_->AddEvent(std::move(event), is_auxiliary);\n-}\n-void RocmApiCallbackImpl::AddMemcpyPeerEventUponApiExit(\n-    uint32_t cbid, const hip_api_data_t* data, uint64_t enter_time,\n-    uint64_t exit_time) {\n-  /*\n-    missing: context_id, memcpy_info.kind\n-\n-    extra: domain, name,\n-  */\n-\n-  RocmTracerEvent event;\n-  event.type = RocmTracerEventType::MemcpyP2P;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.name = se::wrap::roctracer_op_string(ACTIVITY_DOMAIN_HIP_API, cbid, 0);\n-  event.source = RocmTracerEventSource::ApiCallback;\n-  event.thread_id = GetCachedTID();\n-  event.correlation_id = data->correlation_id;\n-  event.start_time_ns = enter_time;\n-  event.end_time_ns = exit_time;\n-\n-  switch (cbid) {\n-    case HIP_API_ID_hipMemcpyPeer:\n-      event.device_id = data->args.hipMemcpyPeer.srcDeviceId;\n-      event.memcpy_info.destination = data->args.hipMemcpyPeer.dstDeviceId;\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyPeer.sizeBytes;\n-      event.memcpy_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemcpyPeerAsync:\n-      event.device_id = data->args.hipMemcpyPeerAsync.srcDevice;\n-      event.memcpy_info.destination = data->args.hipMemcpyPeerAsync.dstDeviceId;\n-      event.memcpy_info.num_bytes = data->args.hipMemcpyPeerAsync.sizeBytes;\n-      event.memcpy_info.async = true;\n-      break;\n-    default:\n-      LOG(WARNING)\n-          << \"Unsupported MemcpyPeer API for profiling observed for cbid=\"\n-          << cbid << \". Event dropped!\";\n-      return;\n-      break;\n+#undef OO\n+  const auto &src_gpu = agents_[static_cast<uint32_t>(rec.src_agent_id.handle)],\n+             &dst_gpu = agents_[static_cast<uint32_t>(rec.dst_agent_id.handle)];\n+\n+  // Assign device_id based on copy direction\n+  if (trace_event->type == RocmTracerEventType::MemcpyH2D &&\n+      dst_gpu.type == ROCPROFILER_AGENT_TYPE_GPU) {\n+    trace_event->device_id = dst_gpu.id.handle;  // Destination is GPU\n+  } else if (trace_event->type == RocmTracerEventType::MemcpyD2H &&\n+             src_gpu.type == ROCPROFILER_AGENT_TYPE_GPU) {\n+    trace_event->device_id = src_gpu.id.handle;  // Source is GPU\n+  } else if (trace_event->type == RocmTracerEventType::MemcpyD2D) {\n+    // Prefer destination GPU for D2D\n+    trace_event->device_id = dst_gpu.id.handle;\n+  } else {\n+    // Fallback for MemcpyOther or HOST_TO_HOST\n+    if (dst_gpu.type == ROCPROFILER_AGENT_TYPE_GPU) {\n+      trace_event->device_id = dst_gpu.id.handle;\n+    } else if (src_gpu.type == ROCPROFILER_AGENT_TYPE_GPU) {\n+      trace_event->device_id = src_gpu.id.handle;\n+    } else {\n+      LOG(WARNING) << \"No GPU ID available for memory copy operation: \"\n+                   << trace_event->name << \", src_agent_type=\" << src_gpu.type\n+                   << \", dst_agent_type=\" << dst_gpu.type;\n+      trace_event->device_id = 0;  // Invalid ID or default\n+    }\n   }\n \n-  bool is_auxiliary =\n-      options_.api_tracking_set.find(cbid) == options_.api_tracking_set.end();\n-  collector_->AddEvent(std::move(event), is_auxiliary);\n-}\n-void RocmApiCallbackImpl::AddMemsetEventUponApiExit(uint32_t cbid,\n-                                                    const hip_api_data_t* data,\n-                                                    uint64_t enter_time,\n-                                                    uint64_t exit_time) {\n-  /*\n-    misses:\n-      device_id(only avail. for async), context_id\n-\n-    extras:\n-      domain, name\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.name = se::wrap::roctracer_op_string(ACTIVITY_DOMAIN_HIP_API, cbid, 0);\n-  event.source = RocmTracerEventSource::ApiCallback;\n-  event.thread_id = GetCachedTID();\n-  event.correlation_id = data->correlation_id;\n-  event.start_time_ns = enter_time;\n-  event.end_time_ns = exit_time;\n-\n-  switch (cbid) {\n-    case HIP_API_ID_hipMemsetD8:\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = data->args.hipMemsetD8.count;\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetD8Async: {\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = data->args.hipMemsetD8Async.count;\n-      event.memset_info.async = true;\n-      const hipStream_t& stream = data->args.hipMemsetD8Async.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipMemsetD16:\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = 2 * data->args.hipMemsetD16.count;\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetD16Async: {\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = 2 * data->args.hipMemsetD16Async.count;\n-      event.memset_info.async = true;\n-      const hipStream_t& stream = data->args.hipMemsetD16Async.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipMemsetD32:\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = 4 * data->args.hipMemsetD32.count;\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetD32Async: {\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = 4 * data->args.hipMemsetD32Async.count;\n-      event.memset_info.async = true;\n-      const hipStream_t& stream = data->args.hipMemsetD32Async.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipMemset:\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = data->args.hipMemset.sizeBytes;\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetAsync: {\n-      event.type = RocmTracerEventType::Memset;\n-      event.memset_info.num_bytes = data->args.hipMemsetAsync.sizeBytes;\n-      event.memset_info.async = true;\n-      const hipStream_t& stream = data->args.hipMemsetAsync.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    default:\n-      LOG(WARNING) << \"Unsupported Memset API for profiling observed for cbid=\"\n-                   << cbid << \". Event dropped!\";\n-      return;\n-      break;\n+  trace_event->source = RocmTracerEventSource::Activity;\n+  trace_event->domain = RocmTracerEventDomain::HIP_OPS;\n+  trace_event->start_time_ns = rec.start_timestamp;\n+  trace_event->end_time_ns = rec.end_timestamp;\n+  trace_event->correlation_id = rec.correlation_id.internal;\n+  trace_event->annotation =\n+      annotation_map()->LookUp(trace_event->correlation_id);\n+  trace_event->thread_id = rec.thread_id;\n+  // we do not know valid stream ID for memcpy\n+  // rec.stream_id.handle;\n+  trace_event->stream_id = RocmTracerEvent::kInvalidStreamId;\n+  trace_event->memcpy_info = MemcpyDetails{\n+      .num_bytes = rec.bytes,\n+      .destination = static_cast<uint32_t>(dst_gpu.id.handle),\n+      .async = false,\n+  };\n+\n+  VLOG(2) << \"copy bytes: \" << trace_event->memcpy_info.num_bytes\n+          << \" stream: \" << trace_event->stream_id << \" src_id \"\n+          << trace_event->device_id << \" dst_id \"\n+          << trace_event->memcpy_info.destination;\n+}\n+\n+void RocmTracer::KernelEvent(const rocprofiler_record_header_t* hdr,\n+                             RocmTracerEvent* trace_event) {\n+  const auto& rec =\n+      *static_cast<const rocprofiler_buffer_tracing_kernel_dispatch_record_t*>(\n+          hdr->payload);\n+\n+  const auto& kinfo = rec.dispatch_info;\n+  trace_event->type = RocmTracerEventType::Kernel;\n+  trace_event->source = RocmTracerEventSource::Activity;\n+  trace_event->domain = RocmTracerEventDomain::HIP_OPS;\n+  trace_event->name = \"??\";\n+  trace_event->start_time_ns = rec.start_timestamp;\n+  trace_event->end_time_ns = rec.end_timestamp;\n+  trace_event->device_id = agents_[kinfo.agent_id.handle].id.handle;\n+  trace_event->correlation_id = rec.correlation_id.internal;\n+  trace_event->annotation =\n+      annotation_map()->LookUp(trace_event->correlation_id);\n+  trace_event->thread_id = rec.thread_id;\n+  trace_event->stream_id = kinfo.queue_id.handle;\n+  trace_event->kernel_info = KernelDetails{\n+      .private_segment_size = kinfo.private_segment_size,\n+      .group_segment_size = kinfo.group_segment_size,\n+      .workgroup_x = kinfo.workgroup_size.x,\n+      .workgroup_y = kinfo.workgroup_size.y,\n+      .workgroup_z = kinfo.workgroup_size.z,\n+      .grid_x = kinfo.grid_size.x,\n+      .grid_y = kinfo.grid_size.y,\n+      .grid_z = kinfo.grid_size.z,\n+      .func_ptr = nullptr,\n+  };\n+\n+  auto it = kernel_info_.find(kinfo.kernel_id);\n+  if (it != kernel_info_.end()) trace_event->name = it->second.name;\n+}\n+\n+void RocmTracer::TracingCallback(rocprofiler_context_id_t context,\n+                                 rocprofiler_buffer_id_t buffer_id,\n+                                 rocprofiler_record_header_t** headers,\n+                                 size_t num_headers, uint64_t drop_count) {\n+  if (collector() == nullptr) {\n+    return;\n   }\n+  if (num_headers == 0) {\n+    return;\n+  }\n+  assert(drop_count == 0 && \"drop count should be zero for lossless policy\");\n \n-  bool is_auxiliary =\n-      options_.api_tracking_set.find(cbid) == options_.api_tracking_set.end();\n-  collector_->AddEvent(std::move(event), is_auxiliary);\n-}\n-\n-void RocmApiCallbackImpl::AddMallocFreeEventUponApiExit(\n-    uint32_t cbid, const hip_api_data_t* data, uint32_t device_id,\n-    uint64_t enter_time, uint64_t exit_time) {\n-  /*\n-    misses: context_id\n-\n-    extras: domain\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.type = (cbid == HIP_API_ID_hipFree || cbid == HIP_API_ID_hipHostFree)\n-                   ? RocmTracerEventType::MemoryFree\n-                   : RocmTracerEventType::MemoryAlloc;\n-  event.source = RocmTracerEventSource::ApiCallback;\n-  event.name = se::wrap::roctracer_op_string(ACTIVITY_DOMAIN_HIP_API, cbid, 0);\n-  event.device_id = device_id;\n-  event.thread_id = GetCachedTID();\n-  // We do not set stream_id (probably to zero as Malloc etc. commands seems\n-  // to run on  default stream). Later we use the unassigned stream_id as a\n-  // feature to assign events to host or device.\n-  event.correlation_id = data->correlation_id;\n-  event.start_time_ns = enter_time;\n-  event.end_time_ns = exit_time;\n-\n-  switch (cbid) {\n-    case HIP_API_ID_hipMalloc:\n-      event.memalloc_info.num_bytes = data->args.hipMalloc.size;\n-      break;\n-    case HIP_API_ID_hipMallocPitch:\n-      event.memalloc_info.num_bytes = data->args.hipMallocPitch.pitch__val *\n-                                      data->args.hipMallocPitch.height;\n-      break;\n-    case HIP_API_ID_hipHostMalloc:\n-      event.memalloc_info.num_bytes = data->args.hipHostMalloc.size;\n-      break;\n-    case HIP_API_ID_hipFree:\n-    case HIP_API_ID_hipHostFree:\n-      event.memalloc_info.num_bytes = 0;\n-      break;\n-    default:\n-      LOG(WARNING)\n-          << \"Unsupported Malloc/Free API for profiling observed for cbid=\"\n-          << cbid << \". Event dropped!\";\n-      return;\n-      break;\n+  if (headers == nullptr) {\n+    LOG(ERROR)\n+        << \"rocprofiler invoked a buffer callback with a null pointer to the \"\n+           \"array of headers. this should never happen\";\n+    return;\n   }\n \n-  bool is_auxiliary =\n-      options_.api_tracking_set.find(cbid) == options_.api_tracking_set.end();\n-  collector_->AddEvent(std::move(event), is_auxiliary);\n-}\n+  for (size_t i = 0; i < num_headers; i++) {\n+    RocmTracerEvent event;\n+    auto header = headers[i];\n \n-void RocmApiCallbackImpl::AddSynchronizeEventUponApiExit(\n-    uint32_t cbid, const hip_api_data_t* data, uint64_t enter_time,\n-    uint64_t exit_time) {\n-  // TODO(rocm-profiler): neither CUDA and nor we capture annotaint for this\n-  // event\n-  /*\n-    misses: context_id\n-\n-    extras: domain,\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.type = RocmTracerEventType::Synchronization;\n-  event.source = RocmTracerEventSource::ApiCallback;\n-  event.name = se::wrap::roctracer_op_string(ACTIVITY_DOMAIN_HIP_API, cbid, 0);\n-  event.thread_id = GetCachedTID();\n-  event.correlation_id = data->correlation_id;\n-  event.start_time_ns = enter_time;\n-  event.end_time_ns = exit_time;\n-\n-  switch (cbid) {\n-    case HIP_API_ID_hipStreamSynchronize: {\n-      event.synchronization_info.sync_type =\n-          RocmTracerSyncTypes::StreamSynchronize;\n-      const hipStream_t& stream = data->args.hipStreamSynchronize.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    case HIP_API_ID_hipStreamWaitEvent: {\n-      event.synchronization_info.sync_type = RocmTracerSyncTypes::StreamWait;\n-      const hipStream_t& stream = data->args.hipStreamWaitEvent.stream;\n-      event.device_id = hipGetStreamDeviceId(stream);\n-    } break;\n-    default:\n-      LOG(WARNING)\n-          << \"Unsupported Synchronization API for profiling observed for cbid=\"\n-          << cbid << \". Event dropped!\";\n-      return;\n-      break;\n-  }\n-  bool is_auxiliary =\n-      options_.api_tracking_set.find(cbid) == options_.api_tracking_set.end();\n-  collector_->AddEvent(std::move(event), is_auxiliary);\n-}\n+    if (header->category != ROCPROFILER_BUFFER_CATEGORY_TRACING) continue;\n \n-absl::Status RocmActivityCallbackImpl::operator()(const char* begin,\n-                                                  const char* end) {\n-  // we do not dump activities in this set in logger\n-\n-  static std::set<activity_op_t> dump_excluded_activities = {\n-      HIP_API_ID_hipGetDevice,\n-      HIP_API_ID_hipSetDevice,\n-      HIP_API_ID___hipPushCallConfiguration,\n-      HIP_API_ID___hipPopCallConfiguration,\n-      HIP_API_ID_hipEventQuery,\n-      HIP_API_ID_hipCtxSetCurrent,\n-      HIP_API_ID_hipEventRecord,\n-      HIP_API_ID_hipEventQuery,\n-      HIP_API_ID_hipGetDeviceProperties,\n-      HIP_API_ID_hipPeekAtLastError,\n-      HIP_API_ID_hipModuleGetFunction,\n-      HIP_API_ID_hipEventCreateWithFlags};\n-\n-  const roctracer_record_t* record =\n-      reinterpret_cast<const roctracer_record_t*>(begin);\n-  const roctracer_record_t* end_record =\n-      reinterpret_cast<const roctracer_record_t*>(end);\n-\n-  while (record < end_record) {\n-    // DumpActivityRecord(record);\n-\n-    switch (record->domain) {\n-      // HIP API activities.\n-      case ACTIVITY_DOMAIN_HIP_API:\n-        switch (record->op) {\n-          case HIP_API_ID_hipModuleLaunchKernel:\n-          case HIP_API_ID_hipExtModuleLaunchKernel:\n-          case HIP_API_ID_hipHccModuleLaunchKernel:\n-          case HIP_API_ID_hipLaunchKernel:\n-          case HIP_API_ID_hipExtLaunchKernel:\n-            DumpActivityRecord(record, std::to_string(__LINE__));\n-            AddHipKernelActivityEvent(record);\n-            break;\n-          case HIP_API_ID_hipMemcpyDtoH:\n-          case HIP_API_ID_hipMemcpyHtoD:\n-          case HIP_API_ID_hipMemcpyDtoD:\n-          case HIP_API_ID_hipMemcpyDtoHAsync:\n-          case HIP_API_ID_hipMemcpyHtoDAsync:\n-          case HIP_API_ID_hipMemcpyDtoDAsync:\n-          case HIP_API_ID_hipMemcpyAsync:\n-          case HIP_API_ID_hipMemcpy:\n-            DumpActivityRecord(record, std::to_string(__LINE__));\n-            AddNormalHipMemcpyActivityEvent(record);\n-            break;\n-          case HIP_API_ID_hipMemset:\n-          case HIP_API_ID_hipMemsetAsync:\n-          case HIP_API_ID_hipMemsetD32:\n-          case HIP_API_ID_hipMemsetD32Async:\n-          case HIP_API_ID_hipMemsetD16:\n-          case HIP_API_ID_hipMemsetD16Async:\n-          case HIP_API_ID_hipMemsetD8:\n-          case HIP_API_ID_hipMemsetD8Async:\n-            DumpActivityRecord(record, std::to_string(__LINE__));\n-            AddHipMemsetActivityEvent(record);\n-            break;\n-\n-          case HIP_API_ID_hipMalloc:\n-          case HIP_API_ID_hipMallocPitch:\n-          case HIP_API_ID_hipHostMalloc:\n-          case HIP_API_ID_hipFree:\n-          case HIP_API_ID_hipHostFree:\n-            DumpActivityRecord(record, std::to_string(__LINE__));\n-            AddHipMallocActivityEvent(record);\n-            break;\n-          case HIP_API_ID_hipStreamSynchronize:\n-          case HIP_API_ID_hipStreamWaitEvent:\n-            // case HIP_API_ID_hipStreamWaitEvent:\n-            DumpActivityRecord(record, std::to_string(__LINE__));\n-            AddHipStreamSynchronizeActivityEvent(record);\n-            break;\n-\n-          default:\n-            if (dump_excluded_activities.find(record->op) ==\n-                dump_excluded_activities.end()) {\n-              std::string drop_message(\n-                  \"\\nNot in the API tracked activities. Dropped!\");\n-              DumpActivityRecord(record, drop_message);\n-            }\n-            break;\n-        }  // switch (record->op).\n+    switch (header->kind) {\n+      case ROCPROFILER_BUFFER_TRACING_HIP_RUNTIME_API:\n+        HipApiEvent(header, &event);\n         break;\n \n-      // HCC ops activities.\n-      case ACTIVITY_DOMAIN_HIP_OPS:\n-\n-        switch (record->op) {\n-          case HIP_OP_ID_DISPATCH:\n-            DumpActivityRecord(record, std::to_string(__LINE__));\n-            AddHccKernelActivityEvent(record);\n-            tracer_->RemoveFromPendingActivityRecords(record->correlation_id);\n-            break;\n-          case HIP_OP_ID_COPY:\n-            switch (record->kind) {\n-              // TODO(rocm-profiler): use enum instead.\n-              case 4595:   /*CopyDeviceToHost*/\n-              case 4596:   /*CopyDeviceToDevice*/\n-              case 4597: { /*CopyHostToDevice*/\n-                /*MEMCPY*/\n-                // roctracer returns CopyHostToDevice for hipMemcpyDtoD API\n-                //  Please look at the issue #53 in roctracer GitHub repo.\n-                DumpActivityRecord(record, \"\");\n-                AddNormalHipOpsMemcpyActivityEvent(record);\n-                tracer_->RemoveFromPendingActivityRecords(\n-                    record->correlation_id);\n-              } break;\n-              case 4615: /*FillBuffer*/\n-                /*MEMSET*/\n-                DumpActivityRecord(record, \"\");\n-                AddHipOpsMemsetActivityEvent(record);\n-                break;\n-              case 4606: /*MARKER*/\n-                // making the log shorter.\n-                // markers are with 0ns duration.\n-                break;\n-              default:\n-                std::string drop_message(\n-                    \"\\nNot in the HIP-OPS-COPY tracked activities. Dropeed!\");\n-                DumpActivityRecord(record, drop_message);\n-                break;\n-            }  // switch (record->kind)\n-            break;\n-          default:\n-            std::string drop_message(\n-                \"\\nNot in the HIP-OPS tracked activities. Dropped!\");\n-            DumpActivityRecord(record, drop_message);\n-            break;\n-        }  // switch (record->op).\n+      case ROCPROFILER_BUFFER_TRACING_KERNEL_DISPATCH:\n+        KernelEvent(header, &event);\n         break;\n-      default:\n-        std::string drop_message(\n-            \"\\nNot in the tracked domain activities. Dropped!\");\n-        DumpActivityRecord(record, drop_message);\n-        break;\n-    }\n \n-    RETURN_IF_ROCTRACER_ERROR(static_cast<roctracer_status_t>(\n-#if TF_ROCM_VERSION >= 50300\n-        se::wrap::roctracer_next_record(record, &record)\n-#else\n-        roctracer_next_record(record, &record)\n-#endif\n-            ));\n-  }\n+      case ROCPROFILER_BUFFER_TRACING_MEMORY_COPY:\n+        MemcpyEvent(header, &event);\n+        break;\n \n-  return absl::OkStatus();\n-}\n+      default:\n+        continue;\n+    }  // switch\n \n-void RocmActivityCallbackImpl::AddHipKernelActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-  missing:\n-   name, device_id(got from hcc), context_id, stream_id(got from hcc),\n- nvtx_range, kernel_info\n-\n-  extra:\n-   domain\n- activity record contains process/thread ID\n- */\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.type = RocmTracerEventType::Kernel;\n-  event.source = RocmTracerEventSource::Activity;\n-  // event.name =  /* we use the API name instead*/\n-  //    se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  event.correlation_id = record->correlation_id;\n-  // TODO(rocm-profiler): CUDA uses device id and correlation ID for finding\n-  // annotations.\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-\n-  event.start_time_ns = record->begin_ns;\n-  event.end_time_ns = record->end_ns;\n-\n-  collector_->AddEvent(std::move(event), false);\n+    absl::MutexLock lock(collector_mutex_);\n+    if (collector()) {\n+      collector()->AddEvent(std::move(event), false);\n+    }\n+  }  // for\n }\n \n-void RocmActivityCallbackImpl::AddNormalHipMemcpyActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-  ---------------NormalMemcpy-------------------\n-    misses:context_id, memcpy_info.kind, memcpy_info.srckind,\n-  memcpy_info.dstkind, memcpy_info.num_bytes, memcpy_info.destenation,\n-  device_id, stream_id,\n-\n-    extras: domain\n-  ---------------PeerMemcpy---------------------\n-    misses: device_id, context_id, stream_id, memcpy_info.kind,\n-      memcpy_info.num_bytes, memcpy_info.destination,\n-    extras:\n-      domain,\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.start_time_ns = record->begin_ns;\n-  event.end_time_ns = record->end_ns;\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-  // TODO(roc-profiler): record->bytes is not a valid value\n-  // event.memcpy_info.num_bytes = record->bytes;\n-  event.name =\n-      se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  switch (record->op) {\n-    case HIP_API_ID_hipMemcpyDtoH:\n-    case HIP_API_ID_hipMemcpyDtoHAsync:\n-      event.type = RocmTracerEventType::MemcpyD2H;\n-      event.memcpy_info.async =\n-          (record->op == HIP_API_ID_hipMemcpyDtoHAsync) ? true : false;\n-      break;\n-    case HIP_API_ID_hipMemcpyHtoD:\n-    case HIP_API_ID_hipMemcpyHtoDAsync:\n-      event.type = RocmTracerEventType::MemcpyH2D;\n-      event.memcpy_info.async =\n-          (record->op == HIP_API_ID_hipMemcpyHtoDAsync) ? true : false;\n-      break;\n-    case HIP_API_ID_hipMemcpyDtoD:\n-    case HIP_API_ID_hipMemcpyDtoDAsync:\n-      event.type = RocmTracerEventType::MemcpyD2D;\n-      event.memcpy_info.async =\n-          (record->op == HIP_API_ID_hipMemcpyDtoDAsync) ? true : false;\n-      break;\n-    case HIP_API_ID_hipMemcpy:\n-    case HIP_API_ID_hipMemcpyAsync:\n-      event.type = RocmTracerEventType::MemcpyOther;\n-      event.memcpy_info.async =\n-          (record->op == HIP_API_ID_hipMemcpyAsync) ? true : false;\n-      break;\n-    case HIP_API_ID_hipMemcpyPeer:\n-    case HIP_API_ID_hipMemcpyPeerAsync:\n-      event.type = RocmTracerEventType::MemcpyP2P;\n-      event.memcpy_info.async =\n-          (record->op == HIP_API_ID_hipMemcpyPeerAsync) ? true : false;\n-      break;\n-    default:\n-      LOG(WARNING) << \"Unsupported Memcpy/MemcpyPeer activity for profiling \"\n-                      \"observed for cbid=\"\n-                   << record->op << \". Event dropped!\";\n-      return;\n-      break;\n+void RocmTracer::CodeObjectCallback(\n+    rocprofiler_callback_tracing_record_t record, void* callback_data) {\n+  if (record.kind == ROCPROFILER_CALLBACK_TRACING_CODE_OBJECT &&\n+      record.operation == ROCPROFILER_CODE_OBJECT_LOAD) {\n+    if (record.phase == ROCPROFILER_CALLBACK_PHASE_UNLOAD) {\n+      // mainly for debugging\n+      LOG(WARNING)\n+          << \"Callback phase unload without registering kernel names ...\";\n+    }\n+  } else if (record.kind == ROCPROFILER_CALLBACK_TRACING_CODE_OBJECT &&\n+             record.operation ==\n+                 ROCPROFILER_CODE_OBJECT_DEVICE_KERNEL_SYMBOL_REGISTER) {\n+    auto* data = static_cast<kernel_symbol_data_t*>(record.payload);\n+    if (record.phase == ROCPROFILER_CALLBACK_PHASE_LOAD) {\n+      absl::MutexLock lock(kernel_lock_);\n+      kernel_info_.emplace(\n+          data->kernel_id,\n+          ProfilerKernelInfo{tsl::port::MaybeAbiDemangle(data->kernel_name),\n+                             *data});\n+    } else if (record.phase == ROCPROFILER_CALLBACK_PHASE_UNLOAD) {\n+      // FIXME: clear these?  At minimum need kernel names at shutdown, async\n+      // completion We don't erase it just in case a buffer callback still needs\n+      // this kernel_info_.erase(data->kernel_id);\n+    }\n   }\n-\n-  collector_->AddEvent(std::move(event), false);\n }\n \n-void RocmActivityCallbackImpl::AddHipMemsetActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-    misses:\n-      device_id, context_id, stram_id, memset_info.num_bytes\n-      memset_info.kind\n-\n-    extras:\n-      domain, annotation\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.name =\n-      se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-\n-  event.type = RocmTracerEventType::Memset;\n-\n-  switch (record->op) {\n-    case HIP_API_ID_hipMemset:\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetAsync:\n-      event.memset_info.async = true;\n-      break;\n-    case HIP_API_ID_hipMemsetD8:\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetD8Async:\n-      event.memset_info.async = true;\n-      break;\n-    case HIP_API_ID_hipMemsetD16:\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetD16Async:\n-      event.memset_info.async = true;\n-      break;\n-    case HIP_API_ID_hipMemsetD32:\n-      event.memset_info.async = false;\n-      break;\n-    case HIP_API_ID_hipMemsetD32Async:\n-      event.memset_info.async = true;\n-      break;\n+static void code_object_callback(rocprofiler_callback_tracing_record_t record,\n+                                 rocprofiler_user_data_t* user_data,\n+                                 void* callback_data) {\n+  RocmTracer::GetRocmTracerSingleton().CodeObjectCallback(record,\n+                                                          callback_data);\n+}\n+\n+static void tool_tracing_callback(rocprofiler_context_id_t context,\n+                                  rocprofiler_buffer_id_t buffer_id,\n+                                  rocprofiler_record_header_t** headers,\n+                                  size_t num_headers, void* user_data,\n+                                  uint64_t drop_count) {\n+  RocmTracer::GetRocmTracerSingleton().TracingCallback(\n+      context, buffer_id, headers, num_headers, drop_count);\n+}\n+\n+int RocmTracer::toolInit(rocprofiler_client_finalize_t fini_func,\n+                         void* tool_data) {\n+  // Gather API names\n+  name_info_ = GetCallbackTracingNames();\n+\n+  // Gather agent info\n+  num_gpus_ = 0;\n+  for (const auto& agent : GetGpuDeviceAgents()) {\n+    LOG(INFO) << \"agent id = \" << agent.id.handle\n+              << \", dev = \" << agent.device_id\n+              << \", name = \" << (agent.name ? agent.name : \"null\");\n+    agents_[agent.id.handle] = agent;\n+    if (agent.type == ROCPROFILER_AGENT_TYPE_GPU) {\n+      num_gpus_++;\n+    }\n   }\n \n-  event.start_time_ns = record->begin_ns;\n-  event.end_time_ns = record->end_ns;\n-\n-  collector_->AddEvent(std::move(event), false);\n-}\n-\n-void RocmActivityCallbackImpl::AddHipMallocActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-    misses: device_id, context_id, memory_residency_info (num_byts, kind,\n-    address)\n-\n-    extras:\n-      annotation, domain,\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.type = RocmTracerEventType::MemoryAlloc;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.name =\n-      se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-  // similar to CUDA we set this to the default stream\n-  event.stream_id = 0;\n-  event.start_time_ns = record->begin_ns;\n-  // making sure it does not have 0ns duration. Otherwise, it may not show up in\n-  // the trace view\n-  event.end_time_ns = std::max(record->end_ns, record->begin_ns + 1);\n-\n-  collector_->AddEvent(std::move(event), false);\n-}\n-\n-void RocmActivityCallbackImpl::AddHipStreamSynchronizeActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-  misses: context_id, device_id (cuda also does not provide but we can get from\n-  API-CB)\n-\n-  extras: domain, synchronization_info.sync_type, annotation\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_API;\n-  event.type = RocmTracerEventType::Synchronization;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.name =\n-      se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-  event.start_time_ns = record->begin_ns;\n-\n-  // making sure it does not have 0ns duration. Otherwise, it may not show up in\n-  // the trace view\n-  event.end_time_ns = std::max(record->end_ns, record->begin_ns + 1);\n-\n-  switch (record->op) {\n-    case HIP_API_ID_hipStreamSynchronize:\n-      event.synchronization_info.sync_type =\n-          RocmTracerSyncTypes::StreamSynchronize;\n-      break;\n-    case HIP_API_ID_hipStreamWaitEvent:\n-      event.synchronization_info.sync_type = RocmTracerSyncTypes::StreamWait;\n-      break;\n-    default:\n-      event.synchronization_info.sync_type = RocmTracerSyncTypes::InvalidSync;\n-      break;\n+  // Utility context to gather codeobject info\n+  rocprofiler_create_context(&utility_context_);\n+\n+  // buffered tracing\n+  auto code_object_ops = std::vector<rocprofiler_tracing_operation_t>{\n+      ROCPROFILER_CODE_OBJECT_DEVICE_KERNEL_SYMBOL_REGISTER};\n+\n+  rocprofiler_configure_callback_tracing_service(\n+      utility_context_, ROCPROFILER_CALLBACK_TRACING_CODE_OBJECT,\n+      code_object_ops.data(), code_object_ops.size(), code_object_callback,\n+      nullptr);\n+\n+  rocprofiler_start_context(utility_context_);\n+  LOG(INFO) << \"rocprofiler start utilityContext\";\n+\n+  // a multiple of the page size, and the gap allows the buffer to absorb bursts\n+  // of GPU events\n+  constexpr auto buffer_size_bytes = 100 * 4096;\n+  constexpr auto buffer_watermark_bytes = 40 * 4096;\n+\n+  // Utility context to gather codeobject info\n+  rocprofiler_create_context(&context_);\n+\n+  rocprofiler_create_buffer(context_, buffer_size_bytes, buffer_watermark_bytes,\n+                            ROCPROFILER_BUFFER_POLICY_LOSSLESS,\n+                            tool_tracing_callback, tool_data, &buffer_);\n+\n+  rocprofiler_configure_buffer_tracing_service(\n+      context_, ROCPROFILER_BUFFER_TRACING_HIP_RUNTIME_API, nullptr, 0,\n+      buffer_);\n+\n+  rocprofiler_configure_buffer_tracing_service(\n+      context_, ROCPROFILER_BUFFER_TRACING_KERNEL_DISPATCH, nullptr, 0,\n+      buffer_);\n+\n+  rocprofiler_configure_buffer_tracing_service(\n+      context_, ROCPROFILER_BUFFER_TRACING_MEMORY_COPY, nullptr, 0, buffer_);\n+\n+  {\n+    // for annotations\n+    const rocprofiler_tracing_operation_t* hip_ops = nullptr;\n+    size_t hip_ops_count = 0;\n+\n+    rocprofiler_configure_callback_tracing_service(\n+        context_, ROCPROFILER_CALLBACK_TRACING_HIP_RUNTIME_API, hip_ops,\n+        hip_ops_count,\n+        [](rocprofiler_callback_tracing_record_t record,\n+           rocprofiler_user_data_t*, void*) {\n+          if (record.phase == ROCPROFILER_CALLBACK_PHASE_ENTER) {\n+            const std::string& annotation =\n+                tsl::profiler::AnnotationStack::Get();\n+            if (!annotation.empty()) {\n+              RocmTracer::GetRocmTracerSingleton().annotation_map()->Add(\n+                  record.correlation_id.internal, annotation);\n+            }\n+          }\n+        },\n+        nullptr);\n   }\n-  collector_->AddEvent(std::move(event), false);\n-}\n-\n-// TODO(rocm-profiler): rename this function. this is HIP-OP\n-void RocmActivityCallbackImpl::AddHccKernelActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-   missing:\n-     name, context_id, nvtx_range, kernel_info\n-\n-   extra:\n-     domain (thread id from the HIP activity)\n-\n-   activity record contains device/stream ID\n- */\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_OPS;\n-  event.type = RocmTracerEventType::Kernel;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-  event.start_time_ns = record->begin_ns;\n-  event.end_time_ns = record->end_ns;\n-  event.device_id = record->device_id;\n-  event.stream_id = record->queue_id;\n-\n-  collector_->AddEvent(std::move(event), false);\n-}\n-\n-void RocmActivityCallbackImpl::AddNormalHipOpsMemcpyActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-    misses:\n-      type, name(the name set here is not clear enough but we keep it for\n-    debug), context_id, memcpy_info.kind, memcpy_info.num_bytes,\n-    memcpy_info.async, memcpy_info.src_mem_kind, memcpy_info.dst_mem_kind\n-\n-    extras:\n-      domain,\n-\n-  */\n-\n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_OPS;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.name =  // name is stored for debug\n-      se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n-\n-  event.start_time_ns = record->begin_ns;\n-  event.end_time_ns = record->end_ns;\n-  event.device_id = record->device_id;\n-  event.memcpy_info.destination = event.device_id;\n-  event.stream_id = record->queue_id;\n-\n-  // we set the type as MemcpyOther as HIP-OPS activity record does not carry\n-  // this information\n-  event.type = RocmTracerEventType::MemcpyOther;\n-\n-  collector_->AddEvent(std::move(event), false);\n-}\n-\n-void RocmActivityCallbackImpl::AddHipOpsMemsetActivityEvent(\n-    const roctracer_record_t* record) {\n-  /*\n-    misses:\n-      name (name recorder here is not clear enough for Memset. We only capture\n-    it for debug), context_id, memset_info.kind, memset_info.num_bytes,\n-    memset_info.async\n-\n-    extras:\n-      dommain, annotation,\n-\n-  */\n \n-  RocmTracerEvent event;\n-  event.domain = RocmTracerEventDomain::HIP_OPS;\n-  event.source = RocmTracerEventSource::Activity;\n-  event.name =  // name is stored for debug\n-      se::wrap::roctracer_op_string(record->domain, record->op, record->kind);\n-  event.correlation_id = record->correlation_id;\n-  event.annotation = collector_->annotation_map()->LookUp(event.correlation_id);\n+  auto client_thread = rocprofiler_callback_thread_t{};\n+  rocprofiler_create_callback_thread(&client_thread);\n+  rocprofiler_assign_callback_thread(buffer_, client_thread);\n \n-  event.start_time_ns = record->begin_ns;\n-  event.end_time_ns = record->end_ns;\n-  event.device_id = record->device_id;\n-  event.stream_id = record->queue_id;\n-\n-  event.type = RocmTracerEventType::Memset;\n+  int isValid = 0;\n+  rocprofiler_context_is_valid(context_, &isValid);\n+  if (isValid == 0) {\n+    context_.handle = 0;  // Leak on failure.\n+    return -1;\n+  }\n \n-  collector_->AddEvent(std::move(event), false);\n+  return 0;\n }\n \n-/* static */ RocmTracer* RocmTracer::GetRocmTracerSingleton() {\n-  static auto* const singleton = new RocmTracer();\n-  return singleton;\n-}\n-\n-// FIXME(rocm-profiler): we should also check if we have AMD GPUs\n-bool RocmTracer::IsAvailable() const {\n-  return !activity_tracing_enabled_ && !api_tracing_enabled_;  // &&NumGpus()\n-}\n-\n-int RocmTracer::NumGpus() {\n-  static int num_gpus = []() -> int {\n-    if (hipInit(0) != hipSuccess) {\n-      return 0;\n-    }\n-    int gpu_count;\n-    if (hipGetDeviceCount(&gpu_count) != hipSuccess) {\n-      return 0;\n-    }\n-    LOG(INFO) << \"Profiler found \" << gpu_count << \" GPUs\";\n-    return gpu_count;\n-  }();\n-  return num_gpus;\n-}\n-\n-void RocmTracer::Enable(const RocmTracerOptions& options,\n-                        RocmTraceCollector* collector) {\n-  options_ = options;\n-  collector_ = collector;\n-  api_cb_impl_ = new RocmApiCallbackImpl(options, this, collector);\n-  activity_cb_impl_ = new RocmActivityCallbackImpl(options, this, collector);\n-\n-  // From ROCm 3.5 onwards, the following call is required.\n-  // don't quite know what it does (no documentation!), only that without it\n-  // the call to enable api/activity tracing will run into a segfault\n-  se::wrap::roctracer_set_properties(ACTIVITY_DOMAIN_HIP_API, nullptr);\n-\n-  EnableApiTracing().IgnoreError();\n-  EnableActivityTracing().IgnoreError();\n-  LOG(INFO) << \"GpuTracer started\";\n+void RocmTracer::toolFinalize(void* tool_data) {\n+  auto& obj = RocmTracer::GetRocmTracerSingleton();\n+  LOG(INFO) << \"Calling toolFinalize!\";\n+  rocprofiler_stop_context(obj.utility_context_);\n+  obj.utility_context_.handle = 0;\n+  rocprofiler_stop_context(obj.context_);\n+  // flush buffer here or in disable?\n+  obj.context_.handle = 0;\n }\n \n void RocmTracer::Disable() {\n-  // TODO(rocm-profiler): TF has a SyncAndFlush() function\n-  // to be called before disabling. It makes sure all the contexts\n-  // has finished all the tasks before shutting down the profiler\n-  DisableApiTracing().IgnoreError();\n-  DisableActivityTracing().IgnoreError();\n-  delete api_cb_impl_;\n-  delete activity_cb_impl_;\n+  absl::MutexLock lock(collector_mutex_);\n   collector_->Flush();\n   collector_ = nullptr;\n-  options_.reset();\n-  LOG(INFO) << \"GpuTracer stopped\";\n-}\n-\n-void ApiCallback(uint32_t domain, uint32_t cbid, const void* cbdata,\n-                 void* user_data) {\n-  RocmTracer* tracer = reinterpret_cast<RocmTracer*>(user_data);\n-  tracer->ApiCallbackHandler(domain, cbid, cbdata).IgnoreError();\n-}\n-\n-absl::Status RocmTracer::ApiCallbackHandler(uint32_t domain, uint32_t cbid,\n-                                            const void* cbdata) {\n-  if (api_tracing_enabled_)\n-    TF_RETURN_IF_ERROR((*api_cb_impl_)(domain, cbid, cbdata));\n-  return absl::OkStatus();\n-}\n-\n-absl::Status RocmTracer::EnableApiTracing() {\n-  if (api_tracing_enabled_) return absl::OkStatus();\n-  api_tracing_enabled_ = true;\n-\n-  for (auto& iter : options_->api_callbacks) {\n-    activity_domain_t domain = iter.first;\n-    std::vector<uint32_t>& ops = iter.second;\n-    if (ops.size() == 0) {\n-      VLOG(3) << \"Enabling API tracing for domain \"\n-              << GetActivityDomainName(domain);\n-      RETURN_IF_ROCTRACER_ERROR(se::wrap::roctracer_enable_domain_callback(\n-          domain, ApiCallback, this));\n-    } else {\n-      VLOG(3) << \"Enabling API tracing for \" << ops.size() << \" ops in domain \"\n-              << GetActivityDomainName(domain);\n-      for (auto& op : ops) {\n-        VLOG(3) << \"Enabling API tracing for \"\n-                << GetActivityDomainOpName(domain, op);\n-        RETURN_IF_ROCTRACER_ERROR(se::wrap::roctracer_enable_op_callback(\n-            domain, op, ApiCallback, this));\n-      }\n-    }\n-  }\n-  return absl::OkStatus();\n-}\n-\n-absl::Status RocmTracer::DisableApiTracing() {\n-  if (!api_tracing_enabled_) return absl::OkStatus();\n   api_tracing_enabled_ = false;\n-\n-  for (auto& iter : options_->api_callbacks) {\n-    activity_domain_t domain = iter.first;\n-    std::vector<uint32_t>& ops = iter.second;\n-    if (ops.size() == 0) {\n-      VLOG(3) << \"Disabling API tracing for domain \"\n-              << GetActivityDomainName(domain);\n-      RETURN_IF_ROCTRACER_ERROR(\n-          se::wrap::roctracer_disable_domain_callback(domain));\n-    } else {\n-      VLOG(3) << \"Disabling API tracing for \" << ops.size() << \" ops in domain \"\n-              << GetActivityDomainName(domain);\n-      for (auto& op : ops) {\n-        VLOG(3) << \"Disabling API tracing for \"\n-                << GetActivityDomainOpName(domain, op);\n-        RETURN_IF_ROCTRACER_ERROR(\n-            se::wrap::roctracer_disable_op_callback(domain, op));\n-      }\n-    }\n-  }\n-  return absl::OkStatus();\n-}\n-\n-void ActivityCallback(const char* begin, const char* end, void* user_data) {\n-  RocmTracer* tracer = reinterpret_cast<RocmTracer*>(user_data);\n-  tracer->ActivityCallbackHandler(begin, end).IgnoreError();\n-}\n-\n-absl::Status RocmTracer::ActivityCallbackHandler(const char* begin,\n-                                                 const char* end) {\n-  if (activity_tracing_enabled_) {\n-    TF_RETURN_IF_ERROR((*activity_cb_impl_)(begin, end));\n-  } else {\n-    LOG(WARNING) << \"ActivityCallbackHandler called when \"\n-                    \"activity_tracing_enabled_ is false\";\n-\n-    VLOG(3) << \"Dropped Activity Records Start\";\n-    const roctracer_record_t* record =\n-        reinterpret_cast<const roctracer_record_t*>(begin);\n-    const roctracer_record_t* end_record =\n-        reinterpret_cast<const roctracer_record_t*>(end);\n-    while (record < end_record) {\n-      DumpActivityRecord(record,\n-                         \"activity_tracing_enabled_ is false. Dropped!\");\n-#if TF_ROCM_VERSION >= 50300\n-      RETURN_IF_ROCTRACER_ERROR(static_cast<roctracer_status_t>(\n-          se::wrap::roctracer_next_record(record, &record)));\n-#else\n-      RETURN_IF_ROCTRACER_ERROR(static_cast<roctracer_status_t>(\n-          roctracer_next_record(record, &record)));\n-#endif\n-    }\n-    VLOG(3) << \"Dropped Activity Records End\";\n-  }\n-  return absl::OkStatus();\n-}\n-\n-absl::Status RocmTracer::EnableActivityTracing() {\n-  if (activity_tracing_enabled_) return absl::OkStatus();\n-  activity_tracing_enabled_ = true;\n-\n-  if (!options_->activity_tracing.empty()) {\n-    // Create the memory pool to store activity records in\n-    if (se::wrap::roctracer_default_pool_expl(nullptr) == NULL) {\n-      roctracer_properties_t properties{};\n-      properties.buffer_size = 0x1000;\n-      properties.buffer_callback_fun = ActivityCallback;\n-      properties.buffer_callback_arg = this;\n-      VLOG(3) << \"Creating roctracer activity buffer: buff-size=\"\n-              << properties.buffer_size;\n-      RETURN_IF_ROCTRACER_ERROR(\n-          se::wrap::roctracer_open_pool_expl(&properties, nullptr));\n-    }\n-  }\n-\n-  for (auto& iter : options_->activity_tracing) {\n-    activity_domain_t domain = iter.first;\n-    std::vector<uint32_t>& ops = iter.second;\n-    if (ops.size() == 0) {\n-      VLOG(3) << \"Enabling Activity tracing for domain \"\n-              << GetActivityDomainName(domain);\n-      RETURN_IF_ROCTRACER_ERROR(\n-          se::wrap::roctracer_enable_domain_activity_expl(domain, nullptr));\n-    } else {\n-      VLOG(3) << \"Enabling Activity tracing for \" << ops.size()\n-              << \" ops in domain \" << GetActivityDomainName(domain);\n-      for (auto& op : ops) {\n-        VLOG(3) << \"Enabling Activity tracing for \"\n-                << GetActivityDomainOpName(domain, op);\n-        // roctracer library has not exported \"roctracer_enable_op_activity\"\n-        RETURN_IF_ROCTRACER_ERROR(\n-            se::wrap::roctracer_enable_op_activity_expl(domain, op, nullptr));\n-      }\n-    }\n-  }\n-\n-  return absl::OkStatus();\n-}\n-\n-absl::Status RocmTracer::DisableActivityTracing() {\n-  if (!activity_tracing_enabled_) return absl::OkStatus();\n-\n-  for (auto& iter : options_->activity_tracing) {\n-    activity_domain_t domain = iter.first;\n-    std::vector<uint32_t>& ops = iter.second;\n-    if (ops.size() == 0) {\n-      VLOG(3) << \"Disabling Activity tracing for domain \"\n-              << GetActivityDomainName(domain);\n-      RETURN_IF_ROCTRACER_ERROR(\n-          se::wrap::roctracer_disable_domain_activity(domain));\n-    } else {\n-      VLOG(3) << \"Disabling Activity tracing for \" << ops.size()\n-              << \" ops in domain \" << GetActivityDomainName(domain);\n-      for (auto& op : ops) {\n-        VLOG(3) << \"Disabling Activity tracing for \"\n-                << GetActivityDomainOpName(domain, op);\n-        RETURN_IF_ROCTRACER_ERROR(\n-            se::wrap::roctracer_disable_op_activity(domain, op));\n-      }\n-    }\n-  }\n-\n-  // TODO(rocm-profiler): this stopping mechanism needs improvement.\n-  // Flush the activity buffer BEFORE setting the activity_tracing_enable_\n-  // flag to FALSE. This is because the activity record callback routine is\n-  // gated by the same flag\n-  VLOG(3) << \"Flushing roctracer activity buffer\";\n-  RETURN_IF_ROCTRACER_ERROR(se::wrap::roctracer_flush_activity_expl(nullptr));\n-  // roctracer_flush_buf();\n-\n-  // Explicitly wait for (almost) all pending activity records\n-  // The choice of all of the following is based what seemed to work\n-  // best when enabling tracing on a large testcase (BERT)\n-  // * 100 ms as the initial sleep duration AND\n-  // * 1 as the initial threshold value\n-  // * 6 as the maximum number of iterations\n-  int duration_ms = 100;\n-  size_t threshold = 1;\n-  for (int i = 0; i < 6; i++, duration_ms *= 2, threshold *= 2) {\n-    if (GetPendingActivityRecordsCount() < threshold) break;\n-    VLOG(3) << \"Wait for pending activity records :\"\n-            << \" Pending count = \" << GetPendingActivityRecordsCount()\n-            << \", Threshold = \" << threshold;\n-    VLOG(3) << \"Wait for pending activity records : sleep for \" << duration_ms\n-            << \" ms\";\n-    tsl::profiler::SleepForMillis(duration_ms);\n-  }\n-  ClearPendingActivityRecordsCount();\n-\n   activity_tracing_enabled_ = false;\n-\n-  return absl::OkStatus();\n+  LOG(INFO) << \"GpuTracer stopped\";\n }\n \n-/*static*/ uint64_t RocmTracer::GetTimestamp() {\n-  uint64_t ts;\n-  if (se::wrap::roctracer_get_timestamp(&ts) != ROCTRACER_STATUS_SUCCESS) {\n-    const char* errstr = se::wrap::roctracer_error_string();\n-    LOG(ERROR) << \"function roctracer_get_timestamp failed with error \"\n-               << errstr;\n-    // Return 0 on error.\n-    return 0;\n-  }\n-  return ts;\n+// ----------------------------------------------------------------------------\n+// Helper that returns all device agents (GPU + CPU for now).\n+// ----------------------------------------------------------------------------\n+std::vector<rocprofiler_agent_v0_t> GetGpuDeviceAgents() {\n+  std::vector<rocprofiler_agent_v0_t> agents;\n+\n+  rocprofiler_query_available_agents_cb_t iterate_cb =\n+      [](rocprofiler_agent_version_t agents_ver, const void** agents_arr,\n+         size_t num_agents, void* udata) {\n+        if (agents_ver != ROCPROFILER_AGENT_INFO_VERSION_0) {\n+          LOG(ERROR) << \"unexpected rocprofiler agent version: \" << agents_ver;\n+          return ROCPROFILER_STATUS_ERROR;\n+        }\n+        auto* agents_vec =\n+            static_cast<std::vector<rocprofiler_agent_v0_t>*>(udata);\n+        for (size_t i = 0; i < num_agents; ++i) {\n+          const auto* agent =\n+              static_cast<const rocprofiler_agent_v0_t*>(agents_arr[i]);\n+          agents_vec->push_back(*agent);\n+        }\n+        return ROCPROFILER_STATUS_SUCCESS;\n+      };\n+\n+  rocprofiler_query_available_agents(ROCPROFILER_AGENT_INFO_VERSION_0,\n+                                     iterate_cb, sizeof(rocprofiler_agent_t),\n+                                     static_cast<void*>(&agents));\n+  return agents;\n+}\n+\n+static int toolInitStatic(rocprofiler_client_finalize_t finalize_func,\n+                          void* tool_data) {\n+  return RocmTracer::GetRocmTracerSingleton().toolInit(finalize_func,\n+                                                       tool_data);\n+}\n+\n+// ----------------------------------------------------------------------------\n+// Clinkage entrypoint expected by rocprofiler-sdk.\n+// ----------------------------------------------------------------------------\n+extern \"C\" rocprofiler_tool_configure_result_t* rocprofiler_configure(\n+    uint32_t version, const char* runtime_version, uint32_t priority,\n+    rocprofiler_client_id_t* id) {\n+  auto& obj = RocmTracer::GetRocmTracerSingleton();  // Ensure constructed,\n+                                                     // critical for tracing.\n+\n+  id->name = \"XLA-with-rocprofiler-sdk\";\n+  obj.client_id_ = id;\n+\n+  LOG(INFO) << \"Configure rocprofiler-sdk...\";\n+\n+  const uint32_t major = version / 10000;\n+  const uint32_t minor = (version % 10000) / 100;\n+  const uint32_t patch = version % 100;\n+\n+  LOG(INFO) << absl::StrFormat(\n+      \"%s Configure XLA with rocprofv3... (priority=%u) is using \"\n+      \"rocprofiler-sdk v%u.%u.%u (%s)\",\n+      id->name, static_cast<unsigned>(priority), static_cast<unsigned>(major),\n+      static_cast<unsigned>(minor), static_cast<unsigned>(patch),\n+      runtime_version ? runtime_version : \"unknown\");\n+\n+  static rocprofiler_tool_configure_result_t cfg{\n+      sizeof(rocprofiler_tool_configure_result_t), &toolInitStatic,\n+      &RocmTracer::toolFinalize, nullptr};\n+\n+  return &cfg;\n }\n \n }  // namespace profiler\n }  // namespace xla\n+\n+void __attribute__((constructor)) init_rocm_lib() {\n+  rocprofiler_force_configure(xla::profiler::rocprofiler_configure);\n+}"
        },
        {
            "sha": "7bc139d8c4340ced803fd965b5e3a3a7ccdd23e9",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_tracer.h",
            "status": "modified",
            "additions": 71,
            "deletions": 151,
            "changes": 222,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer.h?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -16,194 +16,113 @@ limitations under the License.\n #ifndef XLA_BACKENDS_PROFILER_GPU_ROCM_TRACER_H_\n #define XLA_BACKENDS_PROFILER_GPU_ROCM_TRACER_H_\n \n-#include <optional>\n-\n #include \"absl/container/fixed_array.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/container/node_hash_set.h\"\n-#include \"absl/synchronization/mutex.h\"\n-#include \"xla/backends/profiler/gpu/rocm_collector.h\"\n+#include \"absl/types/optional.h\"\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n #include \"xla/stream_executor/rocm/roctracer_wrapper.h\"\n #include \"tsl/platform/errors.h\"\n #include \"tsl/platform/macros.h\"\n #include \"tsl/platform/status.h\"\n-#include \"tsl/platform/thread_annotations.h\"\n #include \"tsl/platform/types.h\"\n \n namespace xla {\n namespace profiler {\n-\n-enum class RocmTracerSyncTypes {\n-  InvalidSync = 0,\n-  StreamSynchronize,  // caller thread wait stream to become empty\n-  EventSynchronize,   // caller thread will block until event happens\n-  StreamWait          // compute stream will wait for event to happen\n-};\n+// forward declare (interface)\n+class RocmTraceCollector;\n \n struct RocmTracerOptions {\n-  std::set<uint32_t> api_tracking_set;  // actual api set we want to profile\n-\n-  // map of domain --> ops for which we need to enable the API callbacks\n-  // If the ops vector is empty, then enable API callbacks for entire domain\n-  absl::flat_hash_map<activity_domain_t, std::vector<uint32_t> > api_callbacks;\n-\n-  // map of domain --> ops for which we need to enable the Activity records\n-  // If the ops vector is empty, then enable Activity records for entire domain\n-  absl::flat_hash_map<activity_domain_t, std::vector<uint32_t> >\n-      activity_tracing;\n-};\n-\n-class RocmTracer;\n-\n-class RocmApiCallbackImpl {\n- public:\n-  RocmApiCallbackImpl(const RocmTracerOptions& options, RocmTracer* tracer,\n-                      RocmTraceCollector* collector)\n-      : options_(options), tracer_(tracer), collector_(collector) {}\n-\n-  absl::Status operator()(uint32_t domain, uint32_t cbid, const void* cbdata);\n-\n- private:\n-  void AddKernelEventUponApiExit(uint32_t cbid, const hip_api_data_t* data,\n-                                 uint64_t enter_time, uint64_t exit_time);\n-  void AddNormalMemcpyEventUponApiExit(uint32_t cbid,\n-                                       const hip_api_data_t* data,\n-                                       uint64_t enter_time, uint64_t exit_time);\n-  void AddMemcpyPeerEventUponApiExit(uint32_t cbid, const hip_api_data_t* data,\n-                                     uint64_t enter_time, uint64_t exit_time);\n-  void AddMemsetEventUponApiExit(uint32_t cbid, const hip_api_data_t* data,\n-                                 uint64_t enter_time, uint64_t exit_time);\n-  void AddMallocFreeEventUponApiExit(uint32_t cbid, const hip_api_data_t* data,\n-                                     uint32_t device_id, uint64_t enter_time,\n-                                     uint64_t exit_time);\n-  void AddStreamSynchronizeEventUponApiExit(uint32_t cbid,\n-                                            const hip_api_data_t* data,\n-                                            uint64_t enter_time,\n-                                            uint64_t exit_time);\n-  void AddSynchronizeEventUponApiExit(uint32_t cbid, const hip_api_data_t* data,\n-                                      uint64_t enter_time, uint64_t exit_time);\n-\n-  RocmTracerOptions options_;\n-  RocmTracer* tracer_ = nullptr;\n-  RocmTraceCollector* collector_ = nullptr;\n-  absl::Mutex api_call_start_mutex_;\n-  // TODO(rocm-profiler): replace this with absl hashmap\n-  // keep a map from the corr. id to enter time for API callbacks.\n-  std::map<uint32_t, uint64_t> api_call_start_time_\n-      TF_GUARDED_BY(api_call_start_mutex_);\n-};\n-\n-class RocmActivityCallbackImpl {\n- public:\n-  RocmActivityCallbackImpl(const RocmTracerOptions& options, RocmTracer* tracer,\n-                           RocmTraceCollector* collector)\n-      : options_(options), tracer_(tracer), collector_(collector) {}\n-\n-  absl::Status operator()(const char* begin, const char* end);\n-\n- private:\n-  void AddHipKernelActivityEvent(const roctracer_record_t* record);\n-  void AddNormalHipMemcpyActivityEvent(const roctracer_record_t* record);\n-  void AddHipMemsetActivityEvent(const roctracer_record_t* record);\n-  void AddHipMallocActivityEvent(const roctracer_record_t* record);\n-  void AddHipStreamSynchronizeActivityEvent(const roctracer_record_t* record);\n-  void AddHccKernelActivityEvent(const roctracer_record_t* record);\n-  void AddNormalHipOpsMemcpyActivityEvent(const roctracer_record_t* record);\n-  void AddHipOpsMemsetActivityEvent(const roctracer_record_t* record);\n-  RocmTracerOptions options_;\n-  RocmTracer* tracer_ = nullptr;\n-  RocmTraceCollector* collector_ = nullptr;\n+  // maximum number of annotation strings that AnnotationMap in RocmTracer can\n+  // store. e.g. 1M\n+  uint64_t max_annotation_strings;\n };\n \n-// The class uses roctracer callback/activity API and forward the collected\n-// trace events to RocmTraceCollector. There should be only one RocmTracer\n-// per process.\n+// The class use to enable rocprofiler-sdk buffered callback/activity tracing\n+// and forward the collected trace events to RocmTraceCollector. There should be\n+// only one RocmTracer per process.\n class RocmTracer {\n  public:\n-  // Returns a pointer to singleton RocmTracer.\n-  static RocmTracer* GetRocmTracerSingleton();\n+  // Returns a reference to the singleton instance of RocmTracer.\n+  // This ensures that only one global instance exists throughout the process\n+  // lifetime. The first call to this function lazily constructs the instance in\n+  // a thread-safe manner. Subsequent calls return the same instance, enabling\n+  // centralized tracer state management.\n+  static RocmTracer& GetRocmTracerSingleton();\n \n   // Only one profile session can be live in the same time.\n   bool IsAvailable() const;\n \n-  void Enable(const RocmTracerOptions& options, RocmTraceCollector* collector);\n+  void Enable(const RocmTracerOptions& options, RocmTraceCollector* collector_);\n   void Disable();\n \n-  absl::Status ApiCallbackHandler(uint32_t domain, uint32_t cbid,\n-                                  const void* cbdata);\n-  absl::Status ActivityCallbackHandler(const char* begin, const char* end);\n-\n   static uint64_t GetTimestamp();\n-  static int NumGpus();\n+  uint32_t NumGpus() const { return num_gpus_; };\n+  RocmTraceCollector* collector() { return collector_; }\n \n-  void AddToPendingActivityRecords(uint32_t correlation_id) {\n-    pending_activity_records_.Add(correlation_id);\n-  }\n+  int toolInit(rocprofiler_client_finalize_t finalize_func, void* tool_data);\n+  static void toolFinalize(void* tool_data);\n \n-  void RemoveFromPendingActivityRecords(uint32_t correlation_id) {\n-    pending_activity_records_.Remove(correlation_id);\n-  }\n+  void TracingCallback(rocprofiler_context_id_t context,\n+                       rocprofiler_buffer_id_t buffer_id,\n+                       rocprofiler_record_header_t** headers,\n+                       size_t num_headers, uint64_t drop_count);\n \n-  void ClearPendingActivityRecordsCount() { pending_activity_records_.Clear(); }\n+  void CodeObjectCallback(rocprofiler_callback_tracing_record_t record,\n+                          void* callback_data);\n \n-  size_t GetPendingActivityRecordsCount() {\n-    return pending_activity_records_.Count();\n-  }\n+  AnnotationMap* annotation_map() { return &annotation_map_; }\n \n  protected:\n   // protected constructor for injecting mock cupti interface for testing.\n-  explicit RocmTracer() : num_gpus_(NumGpus()) {}\n+  RocmTracer() = default;\n+\n+  void HipApiEvent(const rocprofiler_record_header_t* hdr, RocmTracerEvent* ev);\n+  void KernelEvent(const rocprofiler_record_header_t* hdr, RocmTracerEvent* ev);\n+  void MemcpyEvent(const rocprofiler_record_header_t* hdr, RocmTracerEvent* ev);\n \n  private:\n-  absl::Status EnableApiTracing();\n-  absl::Status DisableApiTracing();\n+  uint32_t num_gpus_{0};\n+  std::optional<RocmTracerOptions> options_;\n+  RocmTraceCollector* collector_{nullptr};\n+  absl::Mutex collector_mutex_;\n \n-  absl::Status EnableActivityTracing();\n-  absl::Status DisableActivityTracing();\n+  bool api_tracing_enabled_{false};\n+  bool activity_tracing_enabled_{false};\n \n-  int num_gpus_;\n-  std::optional<RocmTracerOptions> options_;\n-  RocmTraceCollector* collector_ = nullptr;\n-\n-  bool api_tracing_enabled_ = false;\n-  bool activity_tracing_enabled_ = false;\n-\n-  RocmApiCallbackImpl* api_cb_impl_;\n-  RocmActivityCallbackImpl* activity_cb_impl_;\n-\n-  class PendingActivityRecords {\n-   public:\n-    // add a correlation id to the pending set\n-    void Add(uint32_t correlation_id) {\n-      absl::MutexLock lock(mutex);\n-      pending_set.insert(correlation_id);\n-    }\n-    // remove a correlation id from the pending set\n-    void Remove(uint32_t correlation_id) {\n-      absl::MutexLock lock(mutex);\n-      pending_set.erase(correlation_id);\n-    }\n-    // clear the pending set\n-    void Clear() {\n-      absl::MutexLock lock(mutex);\n-      pending_set.clear();\n-    }\n-    // count the number of correlation ids in the pending set\n-    size_t Count() {\n-      absl::MutexLock lock(mutex);\n-      return pending_set.size();\n-    }\n-\n-   private:\n-    // set of co-relation ids for which the hcc activity record is pending\n-    absl::flat_hash_set<uint32_t> pending_set;\n-    // the callback which processes the activity records (and consequently\n-    // removes items from the pending set) is called in a separate thread\n-    // from the one that adds item to the list.\n-    absl::Mutex mutex;\n+  AnnotationMap annotation_map_{/* default size, e.g. */ 1024 * 1024};\n+\n+ public:\n+  using kernel_symbol_data_t =\n+      rocprofiler_callback_tracing_code_object_kernel_symbol_register_data_t;\n+\n+  struct ProfilerKernelInfo {\n+    std::string name;\n+    kernel_symbol_data_t data;\n   };\n-  PendingActivityRecords pending_activity_records_;\n+\n+  using kernel_info_map_t =\n+      std::unordered_map<rocprofiler_kernel_id_t, ProfilerKernelInfo>;\n+\n+  using agent_info_map_t = std::unordered_map<uint64_t, rocprofiler_agent_v0_t>;\n+\n+  using callback_name_info = rocprofiler::sdk::callback_name_info;\n+\n+  rocprofiler_client_id_t* client_id_{nullptr};\n+  // Contexts ----------------------------------------------------------\n+  // for registering kernel names\n+  rocprofiler_context_id_t utility_context_{};\n+  // for buffered callback services\n+  rocprofiler_context_id_t context_{};\n+  rocprofiler_buffer_id_t buffer_{};\n+\n+  // Maps & misc -------------------------------------------------------\n+  kernel_info_map_t kernel_info_{};\n+  absl::Mutex kernel_lock_;\n+\n+  callback_name_info name_info_;\n+  agent_info_map_t agents_;\n \n  public:\n   // Disable copy and move.\n@@ -213,4 +132,5 @@ class RocmTracer {\n \n }  // namespace profiler\n }  // namespace xla\n+\n #endif  // XLA_BACKENDS_PROFILER_GPU_ROCM_TRACER_H_"
        },
        {
            "sha": "d8ad1392738d20b74605be87b877e1d64d18003b",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_tracer_test.cc",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_test.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -0,0 +1,129 @@\n+/* Copyright 2025 The OpenXLA Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/gpu/rocm_tracer.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+\n+#include <gtest/gtest.h>\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/backends/profiler/gpu/rocm_collector.h\"\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n+#include \"tsl/profiler/protobuf/xplane.pb.h\"\n+\n+namespace xla {\n+namespace profiler {\n+namespace {\n+\n+using tsl::profiler::XSpace;\n+\n+// Minimal mock collector implementation based on RocmTraceCollectorImpl.\n+class TestRocmTraceCollector : public RocmTraceCollectorImpl {\n+ public:\n+  TestRocmTraceCollector(const RocmTraceCollectorOptions& options,\n+                         uint64_t start_walltime_ns, uint64_t start_gputime_ns)\n+      : RocmTraceCollectorImpl(options, start_walltime_ns, start_gputime_ns) {}\n+\n+  void Export(XSpace* space) override {\n+    exported_ = true;\n+    exported_space_ = space;\n+  }\n+\n+  void OnEventsDropped(const std::string& reason,\n+                       uint32_t correlation_id) override {\n+    dropped_reason_ = reason;\n+    dropped_id_ = correlation_id;\n+  }\n+\n+  bool exported() const { return exported_; }\n+  const std::string& dropped_reason() const { return dropped_reason_; }\n+  uint32_t dropped_id() const { return dropped_id_; }\n+  XSpace* exported_space() const { return exported_space_; }\n+\n+ private:\n+  bool exported_ = false;\n+  std::string dropped_reason_;\n+  uint32_t dropped_id_ = 0;\n+  XSpace* exported_space_ = nullptr;\n+};\n+\n+// Utility to create valid options for the test collector.\n+std::unique_ptr<TestRocmTraceCollector> CreateTestCollector() {\n+  RocmTraceCollectorOptions options;\n+  options.max_callback_api_events = 2 * 1024 * 1024;\n+  options.max_activity_api_events = 2 * 1024 * 1024;\n+  options.max_annotation_strings = 1024 * 1024;\n+  options.num_gpus = 1;\n+\n+  uint64_t walltime_ns = RocmTracer::GetTimestamp();\n+  uint64_t gputime_ns = RocmTracer::GetTimestamp();\n+\n+  return std::make_unique<TestRocmTraceCollector>(options, walltime_ns,\n+                                                  gputime_ns);\n+}\n+\n+TEST(RocmTracerTest, SingletonInstance) {\n+  LOG(INFO) << \"Before RocmTracer::GetRocmTracerSingleton()\";\n+  RocmTracer& tracer1 = RocmTracer::GetRocmTracerSingleton();\n+  RocmTracer& tracer2 = RocmTracer::GetRocmTracerSingleton();\n+  LOG(INFO) << \"Before RocmTracer::GetRocmTracerSingleton()\";\n+  EXPECT_EQ(&tracer1, &tracer2) << \"RocmTracer must be a singleton\";\n+}\n+\n+TEST(RocmTracerTest, InitialStateIsAvailable) {\n+  RocmTracer& tracer = RocmTracer::GetRocmTracerSingleton();\n+  EXPECT_TRUE(tracer.IsAvailable())\n+      << \"Tracer should be available before Enable()\";\n+}\n+\n+TEST(RocmTracerTest, EnableAndDisableLifecycle) {\n+  RocmTracer& tracer = RocmTracer::GetRocmTracerSingleton();\n+  auto collector = CreateTestCollector();\n+\n+  RocmTracerOptions tracer_options{/*max_annotation_strings=*/128};\n+  tracer.Enable(tracer_options, collector.get());\n+\n+  EXPECT_FALSE(tracer.IsAvailable())\n+      << \"Tracer should not be available after Enable()\";\n+  EXPECT_EQ(tracer.collector(), collector.get())\n+      << \"Collector should be set after Enable()\";\n+  ASSERT_NE(tracer.annotation_map(), nullptr)\n+      << \"Annotation map should be initialized\";\n+\n+  tracer.Disable();\n+\n+  EXPECT_TRUE(tracer.IsAvailable())\n+      << \"Tracer should be available after Disable()\";\n+}\n+\n+TEST(RocmTracerTest, AnnotationMapWorks) {\n+  RocmTracer& tracer = RocmTracer::GetRocmTracerSingleton();\n+  AnnotationMap* map = tracer.annotation_map();\n+  ASSERT_NE(map, nullptr);\n+\n+  uint64_t id = 42;\n+  std::string annotation = \"matmul_fused_op\";\n+  map->Add(id, annotation);\n+\n+  absl::string_view result = map->LookUp(id);\n+  EXPECT_EQ(result, annotation);\n+}\n+\n+}  // namespace\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "0e02383f12afc48eae144f809fd96869175c6983",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_tracer_utils.cc",
            "status": "added",
            "additions": 112,
            "deletions": 0,
            "changes": 112,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_utils.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -0,0 +1,112 @@\n+/* Copyright 2025 The OpenXLA Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/profiler/gpu/rocm_tracer_utils.h\"\n+\n+#include <cstdint>\n+#include <string>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+\n+// for rocprofiler-sdk\n+namespace xla {\n+namespace profiler {\n+\n+//-----------------------------------------------------------------------------\n+const char* GetRocmTracerEventSourceName(const RocmTracerEventSource& source) {\n+  switch (source) {\n+    case RocmTracerEventSource::ApiCallback:\n+      return \"ApiCallback\";\n+      break;\n+    case RocmTracerEventSource::Activity:\n+      return \"Activity\";\n+      break;\n+    case RocmTracerEventSource::Invalid:\n+      return \"Invalid\";\n+      break;\n+    default:\n+      DCHECK(false);\n+      return \"\";\n+  }\n+  return \"\";\n+}\n+\n+// FIXME(rocm-profiler): These domain names are not consistent with the\n+// GetActivityDomainName function\n+const char* GetRocmTracerEventDomainName(const RocmTracerEventDomain& domain) {\n+  switch (domain) {\n+    case RocmTracerEventDomain::HIP_API:\n+      return \"HIP_API\";\n+      break;\n+    case RocmTracerEventDomain::HIP_OPS:\n+      return \"HIP_OPS\";\n+      break;\n+    default:\n+      LOG(WARNING) << \"RocmTracerEventDomain::InvalidDomain\";\n+      DCHECK(false);\n+      return \"\";\n+  }\n+  return \"\";\n+}\n+\n+const char* GetRocmTracerEventTypeName(const RocmTracerEventType& type) {\n+#define OO(x)                  \\\n+  case RocmTracerEventType::x: \\\n+    return #x;\n+  switch (type) {\n+    OO(Kernel)\n+    OO(MemcpyH2D)\n+    OO(MemcpyD2H)\n+    OO(MemcpyD2D)\n+    OO(MemcpyOther)\n+    OO(MemoryAlloc)\n+    OO(MemoryFree)\n+    OO(Memset)\n+    OO(Synchronization)\n+    OO(Generic)\n+    default: {\n+    };\n+  }\n+#undef OO\n+  DCHECK(false);\n+  return \"\";\n+}\n+\n+void AnnotationMap::Add(uint32_t correlation_id,\n+                        const std::string& annotation) {\n+  if (annotation.empty()) {\n+    return;\n+  }\n+  VLOG(3) << \"Add annotation: \" << \" correlation_id=\" << correlation_id\n+          << \", annotation: \" << annotation;\n+  absl::MutexLock lock(map_.mutex);\n+  if (map_.annotations.size() < max_size_) {\n+    absl::string_view annotation_str =\n+        *map_.annotations.insert(annotation).first;\n+    map_.correlation_map.emplace(correlation_id, annotation_str);\n+  }\n+}\n+\n+absl::string_view AnnotationMap::LookUp(uint32_t correlation_id) {\n+  absl::MutexLock lock(map_.mutex);\n+  auto it = map_.correlation_map.find(correlation_id);\n+  return it != map_.correlation_map.end() ? it->second : absl::string_view();\n+}\n+\n+}  // namespace profiler\n+}  // namespace xla"
        },
        {
            "sha": "10b7ad5a24be7322c0158038aaf5e1084654e38c",
            "filename": "third_party/xla/xla/backends/profiler/gpu/rocm_tracer_utils.h",
            "status": "added",
            "additions": 191,
            "deletions": 0,
            "changes": 191,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fprofiler%2Fgpu%2Frocm_tracer_utils.h?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -0,0 +1,191 @@\n+/* Copyright 2025 The OpenXLA Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_PROFILER_GPU_ROCM_TRACER_UTILS_H_\n+#define XLA_BACKENDS_PROFILER_GPU_ROCM_TRACER_UTILS_H_\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <limits>\n+#include <string>\n+\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/node_hash_set.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+\n+namespace xla {\n+namespace profiler {\n+\n+struct MemcpyDetails {\n+  // The amount of data copied for memcpy events.\n+  size_t num_bytes;\n+  // The destination device for peer-2-peer communication (memcpy). The source\n+  // device is implicit: it's the current device.\n+  uint32_t destination;\n+  // Whether or not the memcpy is asynchronous.\n+  bool async;\n+};\n+\n+struct MemAllocDetails {\n+  // The amount of data requested for cudaMalloc events.\n+  uint64_t num_bytes;\n+};\n+\n+struct MemsetDetails {\n+  // The number of memory elements getting set\n+  size_t num_bytes;\n+  // Whether or not the memset is asynchronous.\n+  bool async;\n+};\n+\n+struct KernelDetails {\n+  // The amount of private memory used by kernel,\n+  // number of register per thread (register spillage if > 0)\n+  uint32_t private_segment_size;\n+  // The amount of shared memory (SMEM)\n+  uint32_t group_segment_size;\n+  // X-dimension of a workgroup (grid.x*block.x)\n+  uint32_t workgroup_x;\n+  // Y-dimension of a workgroup (grid.x*block.x)\n+  uint32_t workgroup_y;\n+  // Z-dimension of a workgroup (grid.x*block.x)\n+  uint32_t workgroup_z;\n+  // X-dimension of a grid.\n+  uint32_t grid_x;\n+  // Y-dimension of a grid.\n+  uint32_t grid_y;\n+  // Z-dimension of a grid.\n+  uint32_t grid_z;\n+\n+  // kernel address. Used for calculating core occupancy\n+  void* func_ptr;\n+};\n+\n+enum class RocmTracerEventType {\n+  Unsupported = 0,\n+  Kernel,\n+  MemcpyH2D,\n+  MemcpyD2H,\n+  MemcpyD2D,\n+  MemcpyP2P,\n+  MemcpyOther,\n+  MemoryAlloc,\n+  MemoryFree,\n+  Memset,\n+  Synchronization,\n+  Generic,\n+};\n+\n+const char* GetRocmTracerEventTypeName(const RocmTracerEventType& type);\n+\n+enum class RocmTracerEventSource {\n+  Invalid = 0,\n+  ApiCallback,\n+  Activity,\n+};\n+\n+const char* GetRocmTracerEventSourceName(const RocmTracerEventSource& source);\n+\n+enum class RocmTracerEventDomain {\n+  InvalidDomain = 0,\n+  HIP_API,\n+  HIP_OPS,\n+};\n+\n+const char* GetRocmTracerEventDomainName(const RocmTracerEventDomain& domain);\n+\n+// RocmTracerSyncTypes forward declaration\n+enum class RocmTracerSyncTypes;\n+\n+struct SynchronizationDetails {\n+  RocmTracerSyncTypes sync_type;\n+};\n+\n+struct RocmTracerEvent {\n+  static constexpr uint32_t kInvalidDeviceId =\n+      std::numeric_limits<uint32_t>::max();\n+  static constexpr uint64_t kInvalidThreadId =\n+      std::numeric_limits<uint64_t>::max();\n+  static constexpr uint32_t kInvalidCorrelationId =\n+      std::numeric_limits<uint32_t>::max();\n+  static constexpr uint64_t kInvalidStreamId =\n+      std::numeric_limits<uint64_t>::max();\n+  RocmTracerEventType type;\n+  RocmTracerEventSource source = RocmTracerEventSource::Invalid;\n+  RocmTracerEventDomain domain;\n+  std::string name;\n+  // This points to strings in AnnotationMap, which should outlive the point\n+  // where serialization happens.\n+  absl::string_view annotation;\n+  absl::string_view roctx_range;\n+  uint64_t start_time_ns = 0;\n+  uint64_t end_time_ns = 0;\n+  uint32_t device_id = kInvalidDeviceId;\n+  uint32_t correlation_id = kInvalidCorrelationId;\n+  uint64_t thread_id = kInvalidThreadId;\n+  uint64_t stream_id = kInvalidStreamId;\n+\n+  union {\n+    MemcpyDetails memcpy_info;                    // If type == Memcpy*\n+    MemsetDetails memset_info;                    // If type == Memset*\n+    MemAllocDetails memalloc_info;                // If type == MemoryAlloc\n+    KernelDetails kernel_info;                    // If type == Kernel\n+    SynchronizationDetails synchronization_info;  // If type == Synchronization\n+  };\n+};\n+\n+struct RocmTraceCollectorOptions {\n+  // Maximum number of events to collect from callback API; if -1, no limit.\n+  // if 0, the callback API is enabled to build a correlation map, but no\n+  // events are collected.\n+  uint64_t max_callback_api_events;\n+  // Maximum number of events to collect from activity API; if -1, no limit.\n+  uint64_t max_activity_api_events;\n+  // Maximum number of annotation strings that we can accommodate.\n+  uint64_t max_annotation_strings;\n+  // Number of GPUs involved.\n+  uint32_t num_gpus;\n+};\n+\n+class AnnotationMap {\n+ public:\n+  explicit AnnotationMap(uint64_t max_size) : max_size_(max_size) {}\n+  void Add(uint32_t correlation_id, const std::string& annotation);\n+  absl::string_view LookUp(uint32_t correlation_id);\n+\n+ private:\n+  struct AnnotationMapImpl {\n+    // The population/consumption of annotations might happen from multiple\n+    // callback/activity api related threads.\n+    absl::Mutex mutex;\n+    // Annotation tends to be repetitive, use a hash_set to store the strings,\n+    // an use the reference to the string in the map.\n+    absl::node_hash_set<std::string> annotations;\n+    absl::flat_hash_map<uint32_t, absl::string_view> correlation_map;\n+  };\n+  const uint64_t max_size_;\n+  AnnotationMapImpl map_;\n+\n+ public:\n+  // Disable copy and move.\n+  AnnotationMap(const AnnotationMap&) = delete;\n+  AnnotationMap& operator=(const AnnotationMap&) = delete;\n+};\n+\n+}  // namespace profiler\n+}  // namespace xla\n+\n+#endif  // XLA_BACKENDS_PROFILER_GPU_ROCM_TRACER_UTILS_H_"
        },
        {
            "sha": "52ad7a29a123931b91e5503832371532eab92c3b",
            "filename": "third_party/xla/xla/stream_executor/rocm/roctracer_wrapper.h",
            "status": "modified",
            "additions": 10,
            "deletions": 87,
            "changes": 97,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2Froctracer_wrapper.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2Froctracer_wrapper.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fstream_executor%2Frocm%2Froctracer_wrapper.h?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -1,3 +1,4 @@\n+\n /* Copyright 2021 The OpenXLA Authors.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n@@ -20,92 +21,14 @@ limitations under the License.\n #ifndef XLA_STREAM_EXECUTOR_ROCM_ROCTRACER_WRAPPER_H_\n #define XLA_STREAM_EXECUTOR_ROCM_ROCTRACER_WRAPPER_H_\n \n-#include \"rocm/include/roctracer/roctracer.h\"\n-#include \"rocm/include/roctracer/roctracer_hip.h\"\n-#include \"rocm/rocm_config.h\"\n-#if TF_ROCM_VERSION >= 50300\n-#include \"rocm/include/roctracer/roctracer_roctx.h\"\n-#else\n-#include \"rocm/include/roctracer/roctracer_hcc.h\"\n-#endif\n-#include \"xla/tsl/platform/env.h\"\n-#include \"tsl/platform/dso_loader.h\"\n-#include \"tsl/platform/platform.h\"\n-\n-namespace stream_executor {\n-namespace wrap {\n-\n-#ifdef PLATFORM_GOOGLE\n-\n-#define ROCTRACER_API_WRAPPER(API_NAME)                            \\\n-  template <typename... Args>                                      \\\n-  auto API_NAME(Args... args) -> decltype((::API_NAME)(args...)) { \\\n-    return (::API_NAME)(args...);                                  \\\n-  }\n-\n-#else\n-\n-#define ROCTRACER_API_WRAPPER(API_NAME)                                    \\\n-  template <typename... Args>                                              \\\n-  auto API_NAME(Args... args) -> decltype(::API_NAME(args...)) {           \\\n-    using FuncPtrT = std::add_pointer<decltype(::API_NAME)>::type;         \\\n-    static FuncPtrT loaded = []() -> FuncPtrT {                            \\\n-      static const char* kName = #API_NAME;                                \\\n-      void* f;                                                             \\\n-      auto s = tsl::Env::Default()->GetSymbolFromLibrary(                  \\\n-          tsl::internal::CachedDsoLoader::GetRoctracerDsoHandle().value(), \\\n-          kName, &f);                                                      \\\n-      CHECK(s.ok()) << \"could not find \" << kName                          \\\n-                    << \" in roctracer DSO; dlerror: \" << s.message();      \\\n-      return reinterpret_cast<FuncPtrT>(f);                                \\\n-    }();                                                                   \\\n-    return loaded(args...);                                                \\\n-  }\n-\n-#endif  // PLATFORM_GOOGLE\n-\n-#if TF_ROCM_VERSION >= 50300\n-#define FOREACH_ROCTRACER_API(DO_FUNC)           \\\n-  DO_FUNC(roctracer_default_pool_expl)           \\\n-  DO_FUNC(roctracer_disable_domain_activity)     \\\n-  DO_FUNC(roctracer_disable_domain_callback)     \\\n-  DO_FUNC(roctracer_disable_op_activity)         \\\n-  DO_FUNC(roctracer_disable_op_callback)         \\\n-  DO_FUNC(roctracer_enable_domain_activity_expl) \\\n-  DO_FUNC(roctracer_enable_domain_callback)      \\\n-  DO_FUNC(roctracer_enable_op_activity_expl)     \\\n-  DO_FUNC(roctracer_enable_op_callback)          \\\n-  DO_FUNC(roctracer_error_string)                \\\n-  DO_FUNC(roctracer_flush_activity_expl)         \\\n-  DO_FUNC(roctracer_get_timestamp)               \\\n-  DO_FUNC(roctracer_op_string)                   \\\n-  DO_FUNC(roctracer_open_pool_expl)              \\\n-  DO_FUNC(roctracer_set_properties)              \\\n-  DO_FUNC(roctracer_next_record)\n-#else\n-#define FOREACH_ROCTRACER_API(DO_FUNC)           \\\n-  DO_FUNC(roctracer_default_pool_expl)           \\\n-  DO_FUNC(roctracer_disable_domain_activity)     \\\n-  DO_FUNC(roctracer_disable_domain_callback)     \\\n-  DO_FUNC(roctracer_disable_op_activity)         \\\n-  DO_FUNC(roctracer_disable_op_callback)         \\\n-  DO_FUNC(roctracer_enable_domain_activity_expl) \\\n-  DO_FUNC(roctracer_enable_domain_callback)      \\\n-  DO_FUNC(roctracer_enable_op_activity_expl)     \\\n-  DO_FUNC(roctracer_enable_op_callback)          \\\n-  DO_FUNC(roctracer_error_string)                \\\n-  DO_FUNC(roctracer_flush_activity_expl)         \\\n-  DO_FUNC(roctracer_get_timestamp)               \\\n-  DO_FUNC(roctracer_op_string)                   \\\n-  DO_FUNC(roctracer_open_pool_expl)              \\\n-  DO_FUNC(roctracer_set_properties)\n-#endif\n-FOREACH_ROCTRACER_API(ROCTRACER_API_WRAPPER)\n-\n-#undef FOREACH_ROCTRACER_API\n-#undef ROCTRACER_API_WRAPPER\n-\n-}  // namespace wrap\n-}  // namespace stream_executor\n+#include \"rocm/include/rocprofiler-sdk/buffer.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/buffer_tracing.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/callback_tracing.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/cxx/name_info.hpp\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/external_correlation.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/fwd.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/internal_threading.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/registration.h\"  // IWYU pragma: export\n+#include \"rocm/include/rocprofiler-sdk/rocprofiler.h\"  // IWYU pragma: export\n \n #endif  // XLA_STREAM_EXECUTOR_ROCM_ROCTRACER_WRAPPER_H_"
        },
        {
            "sha": "53f062cafd3c27aef6dff90f3b4891022c4159d6",
            "filename": "third_party/xla/xla/tsl/profiler/utils/xplane_schema.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4c2bbe253e0c2379c5aae56bb25e4fed39a88e45/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fprofiler%2Futils%2Fxplane_schema.cc?ref=4c2bbe253e0c2379c5aae56bb25e4fed39a88e45",
            "patch": "@@ -568,7 +568,7 @@ bool IsInternalEvent(std::optional<int64_t> event_type) {\n bool IsInternalStat(std::optional<int64_t> stat_type) {\n   if (!stat_type.has_value()) return false;\n   switch (*stat_type) {\n-    case StatType::kKernelDetails:\n+    // case StatType::kKernelDetails:  # removed for rocm gpu kernel details\n     case StatType::kProducerType:\n     case StatType::kProducerId:\n     case StatType::kConsumerType:"
        }
    ],
    "stats": {
        "total": 4822,
        "additions": 2091,
        "deletions": 2731
    }
}