{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add Future::OnReady overrides that can take Executor to run the callback\n\nname                        cpu/op        cpu/op      vs base\nBM_CreateOkFuture           1.784n ± 0%   1.860n ± 1%  +4.26% (p=0.000 n=40)\nBM_CopyFuture               1.737n ± 0%   1.727n ± 0%  -0.58% (p=0.001 n=40)\nBM_MapStatelessFuture       14.29n ± 0%   14.27n ± 0%       ~ (p=0.283 n=40)\nBM_TryMapStatelessFuture    14.31n ± 0%   14.25n ± 0%       ~ (p=0.062 n=40)\nBM_MapToFromStatelessFuture 14.43n ± 0%   14.08n ± 1%  -2.44% (p=0.000 n=40)\nBM_MapStatefulFuture        14.55n ± 0%   14.51n ± 0%       ~ (p=0.607 n=40)\nBM_TryMapStatefulFuture     14.54n ± 0%   14.49n ± 1%       ~ (p=0.405 n=40)\ngeomean                     7.908n        7.908n       -0.00%\n\nPiperOrigin-RevId: 817817852",
    "sha": "1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
    "files": [
        {
            "sha": "2306d1823dd41bbc74bb0a0a987e660cc0e88bfa",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
            "patch": "@@ -134,7 +134,10 @@ cc_library(\n     name = \"executor\",\n     hdrs = [\"executor.h\"],\n     compatible_with = get_compatible_with_portable(),\n-    deps = [\"@com_google_absl//absl/functional:any_invocable\"],\n+    deps = [\n+        \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/functional:any_invocable\",\n+    ],\n )\n \n cc_library("
        },
        {
            "sha": "8dba7e9c07f1f07aaf8bf7d0ddd51b9e79a4b7d9",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h?ref=1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
            "patch": "@@ -1060,7 +1060,7 @@ void AsyncValue::AndThen(Executor& executor, Waiter&& waiter) {\n   }\n \n   EnqueueWaiter(\n-      [&executor, waiter = std::forward<Waiter>(waiter)] {\n+      [&executor, waiter = std::forward<Waiter>(waiter)]() mutable {\n         executor.Execute(std::move(waiter));\n       },\n       waiters_and_state);"
        },
        {
            "sha": "e87ae85d4e9fba8c8133a980d19d355799b51d86",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ptr_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ptr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ptr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ptr_test.cc?ref=1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
            "patch": "@@ -622,10 +622,6 @@ TEST(AsyncValuePtrTest, Cast) {\n // Performance benchmarks below\n //===----------------------------------------------------------------------===//\n \n-struct InlineExecutor : public Executor {\n-  void Execute(Task task) final { std::move(task)(); }\n-};\n-\n static void BM_MapIntToFloat(benchmark::State& state) {\n   auto ref = MakeAvailableAsyncValueRef<int32_t>(42);\n   auto ptr = ref.AsPtr();"
        },
        {
            "sha": "bc109ab226b4042a8a49032874dab8c1bbfd621d",
            "filename": "third_party/xla/xla/tsl/concurrency/executor.h",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fexecutor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fexecutor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fexecutor.h?ref=1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
            "patch": "@@ -16,6 +16,9 @@ limitations under the License.\n #ifndef XLA_TSL_CONCURRENCY_EXECUTOR_H_\n #define XLA_TSL_CONCURRENCY_EXECUTOR_H_\n \n+#include <utility>\n+\n+#include \"absl/base/no_destructor.h\"\n #include \"absl/functional/any_invocable.h\"\n \n namespace tsl {\n@@ -38,6 +41,18 @@ class Executor {\n   virtual void Execute(Task task) = 0;\n };\n \n+// Executor that executes tasks inline in the caller thread.\n+class InlineExecutor final : public Executor {\n+ public:\n+  // Returns a singleton instance of the inline executor.\n+  static InlineExecutor& Instance() {\n+    static absl::NoDestructor<InlineExecutor> executor;\n+    return *executor;\n+  }\n+\n+  void Execute(Task task) final { std::move(task)(); }\n+};\n+\n }  // namespace tsl\n \n #endif  // XLA_TSL_CONCURRENCY_EXECUTOR_H_"
        },
        {
            "sha": "7c570ce2a735681420e4e433fdc02918e0509229",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 53,
            "deletions": 36,
            "changes": 89,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
            "patch": "@@ -316,50 +316,44 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   // This function defined out of line as it requires Future<> definition.\n   [[nodiscard]] Future<> GetReadyFuture() const;\n \n+  // A type predicate to check if `F` is a valid `OnReady` callback.\n+  template <typename F, bool rvalue = false>\n+  using OnReadyFunctor = std::enable_if_t<std::is_invocable_v<\n+      F, std::conditional_t<rvalue && is_move_only, T, const T&>>>;\n+\n   // Registers callback to be called once the promise is ready, with the final\n-  // value.\n-  //\n-  // callback may be called on an internal system thread or the calling thread.\n-  // The client should avoid any potentially re-entrant API calls within the\n-  // callback, for example by using the callback to enqueue work on a\n-  // client-owned threadpool.\n-  template <typename F,\n-            std::enable_if_t<!is_move_only &&\n-                             std::is_invocable_v<F, const T&>>* = nullptr>\n+  // value. Callback will be invoked on a thread that sets the promise value,\n+  // or in the caller thread if the future is already available.\n+  template <typename F, OnReadyFunctor<F>* = nullptr>\n   ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(F&& f) const& {\n     CHECK(IsValid());\n-    promise_.AndThen(\n-        [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-          DCHECK(promise.IsAvailable());\n-          f(*promise);\n-        });\n+    promise_.AndThen(Wrap(std::forward<F>(f)));\n   }\n \n   // Registers callback to be called once the promise is ready, with the final\n-  // value.\n-  //\n-  // callback may be called on an internal system thread or the calling thread.\n-  // The client should avoid any potentially re-entrant API calls within the\n-  // callback, for example by using the callback to enqueue work on a\n-  // client-owned threadpool.\n-  template <typename F,\n-            std::enable_if_t<std::is_invocable_v<\n-                F, std::conditional_t<is_move_only, T, const T&>>>* = nullptr>\n+  // value. Callback will be invoked on a user-specified executor.\n+  template <typename F, OnReadyFunctor<F>* = nullptr>\n+  ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(Executor& executor, F&& f) const& {\n+    CHECK(IsValid());\n+    promise_.AndThen(executor, Wrap(std::forward<F>(f)));\n+  }\n+\n+  // Registers callback to be called once the promise is ready, with the final\n+  // value. Callback will be invoked on a thread that sets the promise value,\n+  // or in the caller thread if the future is already available.\n+  template <typename F, OnReadyFunctor<F, true>* = nullptr>\n   ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(F&& f) && {\n     CHECK(IsValid());\n-    promise_.AndThen(\n-        [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-          DCHECK(promise.IsAvailable());\n-          if constexpr (is_move_only) {\n-            f(std::move(*promise));\n-          } else {\n-            // We can't move from the promise to the caller because for copyable\n-            // futures we can have multiple copies of the Future sharing the\n-            // same underlying promise object.\n-            f(*promise);\n-          }\n-        });\n-    // Reset the promise to make the moved-from future \"empty\".\n+    promise_.AndThen(std::move(*this).Wrap(std::forward<F>(f)));\n+    promise_.reset();\n+  }\n+\n+  // Registers callback to be called once the promise is ready, with the final\n+  // value. Callback will be invoked on a user-specified executor.\n+  template <typename F, OnReadyFunctor<F, true>* = nullptr>\n+  ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(Executor& executor, F&& f) && {\n+    CHECK(IsValid());\n+    promise_.AndThen(executor, std::move(*this).Wrap(std::forward<F>(f)));\n     promise_.reset();\n   }\n \n@@ -378,6 +372,29 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n  private:\n   friend class tsl::FutureHelpers;\n \n+  // Wraps a callback into a functor compatible with AsyncValue::AndThen.\n+  template <typename F>\n+  auto Wrap(F&& f) const& {\n+    return [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n+      f(*promise);\n+    };\n+  }\n+\n+  // Wraps a callback into a functor compatible with AsyncValue::AndThen.\n+  template <typename F>\n+  auto Wrap(F&& f) && {\n+    return [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n+      if constexpr (is_move_only) {\n+        f(std::move(*promise));\n+      } else {\n+        // We can't move from the promise to the caller because for copyable\n+        // futures we can have multiple copies of the Future sharing the\n+        // same underlying promise object.\n+        f(*promise);\n+      }\n+    };\n+  }\n+\n   tsl::AsyncValueRef<T> promise_;\n \n   // Function that is called before a thread starts blocking on the promise."
        },
        {
            "sha": "4b5e060c3870c260d04154880095d1ef6bf273cd",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 4,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=1ae52eb0f811bd3c9e5933ef81ddb609e4f8408d",
            "patch": "@@ -767,10 +767,6 @@ TEST(FutureTest, MakeSharedPromise) {\n   }\n }\n \n-struct InlineExecutor : public Executor {\n-  void Execute(Task task) final { std::move(task)(); }\n-};\n-\n TEST(FutureTest, MakeOnStateless) {\n   InlineExecutor e;\n \n@@ -823,6 +819,22 @@ TEST(FutureTest, MakeOnStateful) {\n   }\n }\n \n+TEST(FutureTest, OnReadyOnExecutor) {\n+  Future<> future0(absl::OkStatus());\n+  future0.OnReady(InlineExecutor::Instance(), [](absl::Status status) {\n+    ASSERT_EQ(status, absl::OkStatus());\n+  });\n+\n+  Future<int32_t> future1(42);\n+  future1.OnReady(InlineExecutor::Instance(),\n+                  [](absl::StatusOr<int32_t> x) { ASSERT_EQ(*x, 42); });\n+\n+  Future<std::unique_ptr<int32_t>> future2(std::make_unique<int32_t>(42));\n+  std::move(future2).OnReady(\n+      InlineExecutor::Instance(),\n+      [](absl::StatusOr<std::unique_ptr<int32_t>> x) { ASSERT_EQ(**x, 42); });\n+}\n+\n //===----------------------------------------------------------------------===//\n // Performance benchmarks.\n //===----------------------------------------------------------------------===//\n@@ -890,12 +902,24 @@ static void BM_TryMapStatefulFuture(benchmark::State& state) {\n   }\n }\n \n+static void BM_CreateAndMapStatelessFuture(benchmark::State& state) {\n+  Future<> future(absl::OkStatus());\n+\n+  for (auto _ : state) {\n+    auto [promise, future] = Future<>::MakePromise();\n+    Future<int32_t> mapped = future.Map([] { return 42; });\n+    promise.Set(absl::OkStatus());\n+    benchmark::DoNotOptimize(mapped);\n+  }\n+}\n+\n BENCHMARK(BM_CreateOkFuture);\n BENCHMARK(BM_CopyFuture);\n BENCHMARK(BM_MapStatelessFuture);\n BENCHMARK(BM_TryMapStatelessFuture);\n BENCHMARK(BM_MapToFromStatelessFuture);\n BENCHMARK(BM_MapStatefulFuture);\n BENCHMARK(BM_TryMapStatefulFuture);\n+BENCHMARK(BM_CreateAndMapStatelessFuture);\n \n }  // namespace tsl"
        }
    ],
    "stats": {
        "total": 147,
        "additions": 101,
        "deletions": 46
    }
}