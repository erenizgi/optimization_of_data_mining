{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845719651",
    "sha": "2b9d8450d26cc2f41560781c9267dc0bc7487f99",
    "files": [
        {
            "sha": "4fbd1edfba920a048f0031dbbfe0bfeb6e901a61",
            "filename": "tensorflow/core/kernels/immutable_constant_op.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op.cc?ref=2b9d8450d26cc2f41560781c9267dc0bc7487f99",
            "patch": "@@ -26,15 +26,15 @@ class MemmappedTensorAllocator : public Allocator {\n  public:\n   MemmappedTensorAllocator() {}\n \n-  absl::Status InitializeFromRegion(const string& name, Env* env) {\n+  absl::Status InitializeFromRegion(const std::string& name, Env* env) {\n     const auto status =\n         env->NewReadOnlyMemoryRegionFromFile(name, &memory_region_);\n     if (!status.ok()) {\n       return status;\n     }\n     return absl::OkStatus();\n   }\n-  string Name() override { return \"MemmappedTensorAllocator\"; }\n+  std::string Name() override { return \"MemmappedTensorAllocator\"; }\n \n   void* AllocateRaw(size_t alignment, size_t num_bytes) override {\n     if ((reinterpret_cast<intptr_t>(memory_region_->data())) % alignment != 0) {"
        },
        {
            "sha": "cd645686bddcfaebd2e1051cfebcc0bcfe1dd8a7",
            "filename": "tensorflow/core/kernels/immutable_constant_op.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op.h?ref=2b9d8450d26cc2f41560781c9267dc0bc7487f99",
            "patch": "@@ -38,7 +38,7 @@ class ImmutableConstantOp : public OpKernel {\n   static constexpr char const* kMemoryRegionNameAttr = \"memory_region_name\";\n \n  private:\n-  string region_name_;\n+  std::string region_name_;\n   DataType dtype_;\n   TensorShape shape_;\n   ImmutableConstantOp(const ImmutableConstantOp&) = delete;"
        },
        {
            "sha": "955d3f8751c12ab8c659dccfb71c6fbee900cbbb",
            "filename": "tensorflow/core/kernels/immutable_constant_op_test.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 13,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fimmutable_constant_op_test.cc?ref=2b9d8450d26cc2f41560781c9267dc0bc7487f99",
            "patch": "@@ -40,19 +40,19 @@ constexpr size_t kTestTensorSizeBytes = kTestTensorSize * sizeof(float);\n class TestReadOnlyMemoryRegion : public ReadOnlyMemoryRegion {\n  public:\n   TestReadOnlyMemoryRegion() = delete;\n-  explicit TestReadOnlyMemoryRegion(uint64 length)\n+  explicit TestReadOnlyMemoryRegion(uint64_t length)\n       : memptr_(cpu_allocator()->AllocateRaw(kTestAlignment, length)),\n         length_(length) {}\n   ~TestReadOnlyMemoryRegion() override {\n     cpu_allocator()->DeallocateRaw(memptr_);\n   }\n   const void* data() override { return memptr_; }\n   float* GetWritableDataStart() { return reinterpret_cast<float*>(memptr_); }\n-  uint64 length() override { return length_; }\n+  uint64_t length() override { return length_; }\n \n  protected:\n   void* memptr_;\n-  uint64 length_;\n+  uint64_t length_;\n };\n \n // A mock file system and environment class that creates ReadOnlyMemoryRegion\n@@ -65,7 +65,7 @@ class TestFileSystem : public NullFileSystem {\n   using NullFileSystem::NewReadOnlyMemoryRegionFromFile;\n \n   absl::Status NewReadOnlyMemoryRegionFromFile(\n-      const string& fname, TransactionToken* token,\n+      const std::string& fname, TransactionToken* token,\n       std::unique_ptr<ReadOnlyMemoryRegion>* result) override {\n     float val = 0;\n     absl::string_view scheme, host, path;\n@@ -146,13 +146,13 @@ TEST(ImmutableConstantOpTest, ExecutionError) {\n       error::INTERNAL);\n }\n \n-absl::Status CreateTempFileFloat(Env* env, float value, uint64 size,\n-                                 string* filename) {\n-  const string dir = testing::TmpDir();\n+absl::Status CreateTempFileFloat(Env* env, float value, uint64_t size,\n+                                 std::string* filename) {\n+  const std::string dir = testing::TmpDir();\n   *filename = io::JoinPath(dir, absl::StrCat(\"file_\", value));\n   std::unique_ptr<WritableFile> file;\n   TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n-  for (uint64 i = 0; i < size; ++i) {\n+  for (uint64_t i = 0; i < size; ++i) {\n     absl::string_view sp(static_cast<char*>(static_cast<void*>(&value)),\n                          sizeof(value));\n     TF_RETURN_IF_ERROR(file->Append(sp));\n@@ -166,7 +166,7 @@ TEST(ImmutableConstantOpTest, FromFile) {\n   Env* env = Env::Default();\n   auto root = Scope::NewRootScope().ExitOnError();\n \n-  string two_file, three_file;\n+  std::string two_file, three_file;\n   TF_ASSERT_OK(CreateTempFileFloat(env, 2.0f, 1000, &two_file));\n   TF_ASSERT_OK(CreateTempFileFloat(env, 3.0f, 1000, &three_file));\n   auto node1 = ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, two_file);\n@@ -191,9 +191,10 @@ TEST(ImmutableConstantOpTest, FromFile) {\n   EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n }\n \n-absl::Status CreateTempFileBadString(Env* env, char value, uint64 size,\n-                                     const string suffix, string* filename) {\n-  const string dir = testing::TmpDir();\n+absl::Status CreateTempFileBadString(Env* env, char value, uint64_t size,\n+                                     const std::string suffix,\n+                                     std::string* filename) {\n+  const std::string dir = testing::TmpDir();\n   *filename = io::JoinPath(dir, absl::StrCat(\"file_\", suffix));\n   std::unique_ptr<WritableFile> file;\n   TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n@@ -207,7 +208,7 @@ TEST(ImmutableConstantOpTest, FromFileStringUnimplmented) {\n   Env* env = Env::Default();\n   auto root = Scope::NewRootScope().ExitOnError();\n \n-  string bad_file;\n+  std::string bad_file;\n   TF_ASSERT_OK(CreateTempFileBadString(env, '\\xe2', 128, \"bad_e2\", &bad_file));\n   auto result =\n       ops::ImmutableConst(root, DT_STRING, kFileTensorShape, bad_file);"
        },
        {
            "sha": "e5d03f902eb58ff29a0530427fe7b77118e29579",
            "filename": "tensorflow/core/kernels/in_topk_op.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fin_topk_op.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fin_topk_op.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fin_topk_op.cc?ref=2b9d8450d26cc2f41560781c9267dc0bc7487f99",
            "patch": "@@ -89,32 +89,32 @@ REGISTER_KERNEL_BUILDER(Name(\"InTopK\")\n                             .HostMemory(\"predictions\")\n                             .HostMemory(\"targets\")\n                             .HostMemory(\"precision\")\n-                            .TypeConstraint<int32>(\"T\"),\n-                        InTopK<CPUDevice, float, int32>);\n+                            .TypeConstraint<int32_t>(\"T\"),\n+                        InTopK<CPUDevice, float, int32_t>);\n REGISTER_KERNEL_BUILDER(Name(\"InTopK\")\n                             .Device(DEVICE_CPU)\n                             .HostMemory(\"predictions\")\n                             .HostMemory(\"targets\")\n                             .HostMemory(\"precision\")\n                             .TypeConstraint<int64_t>(\"T\"),\n-                        InTopK<CPUDevice, float, int64>);\n+                        InTopK<CPUDevice, float, int64_t>);\n \n REGISTER_KERNEL_BUILDER(Name(\"InTopKV2\")\n                             .Device(DEVICE_CPU)\n                             .HostMemory(\"predictions\")\n                             .HostMemory(\"targets\")\n                             .HostMemory(\"k\")\n                             .HostMemory(\"precision\")\n-                            .TypeConstraint<int32>(\"T\"),\n-                        InTopK<CPUDevice, float, int32>);\n+                            .TypeConstraint<int32_t>(\"T\"),\n+                        InTopK<CPUDevice, float, int32_t>);\n REGISTER_KERNEL_BUILDER(Name(\"InTopKV2\")\n                             .Device(DEVICE_CPU)\n                             .HostMemory(\"predictions\")\n                             .HostMemory(\"targets\")\n                             .HostMemory(\"k\")\n                             .HostMemory(\"precision\")\n                             .TypeConstraint<int64_t>(\"T\"),\n-                        InTopK<CPUDevice, float, int64>);\n+                        InTopK<CPUDevice, float, int64_t>);\n \n #if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n "
        },
        {
            "sha": "ad10dad72bf717b7327bdbebe3b2be059f38bc2e",
            "filename": "tensorflow/core/kernels/in_topk_op.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fin_topk_op.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Fin_topk_op.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Fin_topk_op.h?ref=2b9d8450d26cc2f41560781c9267dc0bc7487f99",
            "patch": "@@ -62,7 +62,7 @@ struct InTopKFunctor<CPUDevice, T, TargetT> {\n     int64_t k_val = k.k_value;\n     if (k.k_tensor != nullptr) {\n       if (k.k_tensor->dtype() == DT_INT32) {\n-        k_val = k.k_tensor->scalar<int32>()();\n+        k_val = k.k_tensor->scalar<int32_t>()();\n       } else {\n         k_val = k.k_tensor->scalar<int64_t>()();\n       }"
        },
        {
            "sha": "1380406a8a33ccf64f504046e83282962ef6500c",
            "filename": "tensorflow/core/kernels/inplace_ops.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Finplace_ops.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2b9d8450d26cc2f41560781c9267dc0bc7487f99/tensorflow%2Fcore%2Fkernels%2Finplace_ops.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fkernels%2Finplace_ops.cc?ref=2b9d8450d26cc2f41560781c9267dc0bc7487f99",
            "patch": "@@ -106,7 +106,7 @@ class ParallelConcatUpdate : public OpKernel {\n   }\n \n  private:\n-  int32 loc_;\n+  int32_t loc_;\n };\n \n template <typename Device, typename T>\n@@ -251,7 +251,7 @@ namespace functor {\n template <typename T>\n void DoInplaceOp(const CPUDevice& d, InplaceOpType op, const Tensor& i,\n                  const Tensor& v, Tensor* y) {\n-  auto Ti = i.flat<int32>();\n+  auto Ti = i.flat<int32_t>();\n   auto Tv = v.flat_outer_dims<T>();\n   auto Ty = y->flat_outer_dims<T>();\n   auto nrows = Ty.dimension(0);\n@@ -274,7 +274,7 @@ void DoInplaceOp(const CPUDevice& d, InplaceOpType op, const Tensor& i,\n // String type only supports inplace update.\n void DoInplaceStringUpdateOp(const CPUDevice& d, const Tensor& i,\n                              const Tensor& v, Tensor* y) {\n-  auto Ti = i.flat<int32>();\n+  auto Ti = i.flat<int32_t>();\n   auto Tv = v.flat_outer_dims<tstring>();\n   auto Ty = y->flat_outer_dims<tstring>();\n   auto nrows = Ty.dimension(0);\n@@ -398,10 +398,10 @@ class EmptyOp : public OpKernel {\n         ctx, TensorShapeUtils::IsVector(shape.shape()),\n         errors::InvalidArgument(\"shape must be a vector of int32, got shape \",\n                                 shape.shape().DebugString()));\n-    auto dims = shape.flat<int32>();\n+    auto dims = shape.flat<int32_t>();\n     TensorShape out_shape;\n     OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n-                            reinterpret_cast<const int32*>(dims.data()),\n+                            reinterpret_cast<const int32_t*>(dims.data()),\n                             dims.size(), &out_shape));\n     Tensor* out = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n@@ -474,30 +474,30 @@ REGISTER_KERNEL_BUILDER(Name(\"InplaceUpdate\")\n                             .HostMemory(\"i\")\n                             .HostMemory(\"v\")\n                             .HostMemory(\"y\")\n-                            .TypeConstraint<int32>(\"T\"),\n+                            .TypeConstraint<int32_t>(\"T\"),\n                         InplaceOp<CPUDevice, functor::I_UPDATE>);\n REGISTER_KERNEL_BUILDER(Name(\"InplaceAdd\")\n                             .Device(DEVICE_DEFAULT)\n                             .HostMemory(\"x\")\n                             .HostMemory(\"i\")\n                             .HostMemory(\"v\")\n                             .HostMemory(\"y\")\n-                            .TypeConstraint<int32>(\"T\"),\n+                            .TypeConstraint<int32_t>(\"T\"),\n                         InplaceOp<CPUDevice, functor::I_ADD>);\n REGISTER_KERNEL_BUILDER(Name(\"InplaceSub\")\n                             .Device(DEVICE_DEFAULT)\n                             .HostMemory(\"x\")\n                             .HostMemory(\"i\")\n                             .HostMemory(\"v\")\n                             .HostMemory(\"y\")\n-                            .TypeConstraint<int32>(\"T\"),\n+                            .TypeConstraint<int32_t>(\"T\"),\n                         InplaceOp<CPUDevice, functor::I_SUB>);\n \n REGISTER_KERNEL_BUILDER(Name(\"DeepCopy\")\n                             .Device(DEVICE_DEFAULT)\n                             .HostMemory(\"x\")\n                             .HostMemory(\"y\")\n-                            .TypeConstraint<int32>(\"T\"),\n+                            .TypeConstraint<int32_t>(\"T\"),\n                         CopyOp<CPUDevice>);\n \n }  // end namespace"
        }
    ],
    "stats": {
        "total": 65,
        "additions": 33,
        "deletions": 32
    }
}