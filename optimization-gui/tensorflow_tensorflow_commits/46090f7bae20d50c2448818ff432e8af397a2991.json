{
    "author": "jcai19",
    "message": "Reverts dc9840f59256095aea4f23e1ac3c49456c6b68ef\n\nPiperOrigin-RevId: 814544805",
    "sha": "46090f7bae20d50c2448818ff432e8af397a2991",
    "files": [
        {
            "sha": "6fc5e1d4a42728b90df297b514861e3b477ae973",
            "filename": "third_party/xla/xla/hlo/translate/hlo_to_mhlo/hlo_function_importer.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Fhlo_function_importer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Fhlo_function_importer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Fhlo_function_importer.cc?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -564,6 +564,7 @@ absl::Status HloFunctionImporter::ImportAsRegion(\n absl::StatusOr<Value> HloFunctionImporter::ImportInstructionsImpl(\n     const HloComputation& computation,\n     const llvm::SmallVectorImpl<Value>& arguments, mlir::OpBuilder* builder) {\n+  llvm::errs() << \"computation: \" << computation.name() << \"\\n\";\n   // Setup the input parameters.\n   const int num_parameters = computation.num_parameters();\n \n@@ -717,6 +718,13 @@ absl::StatusOr<mlir::Operation*> HloFunctionImporter::ImportInstructionImpl(\n         ConvertSharding(instruction->sharding(), builder_)));\n   }\n \n+  if (instruction->original_value()) {\n+    attributes.push_back(builder_->getNamedAttr(\n+        kMhloOriginalValueAttr,\n+        builder_->getStringAttr(\n+            \"{\" + instruction->original_value()->ToString() + \"}\")));\n+  }\n+\n   llvm::SmallVector<NamedAttribute, 4> frontend_attributes;\n   for (const auto& [k, v] : instruction->frontend_attributes().map()) {\n     frontend_attributes.push_back("
        },
        {
            "sha": "d621ad93d6c4a60b7bfc840e8a960e56c9f57789",
            "filename": "third_party/xla/xla/hlo/translate/hlo_to_mhlo/location_importer.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 19,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Flocation_importer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Flocation_importer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Flocation_importer.cc?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -24,7 +24,6 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/translate/hlo_to_mhlo/hlo_utils.h\"\n #include \"xla/hlo/translate/hlo_to_mhlo/stack_location_utils.h\"\n-#include \"xla/mlir_hlo/utils/unregistered_attributes.h\"\n \n namespace mlir {\n namespace hlo {\n@@ -33,21 +32,10 @@ mlir::Location GenerateInstructionLocation(\n     const xla::HloInstruction* instruction, mlir::MLIRContext* context) {\n   mlir::Builder b(context);\n \n-  auto fuse_original_value_if_present = [&](mlir::Location loc) {\n-    auto original_value = instruction->original_value();\n-    if (original_value) {\n-      return b.getFusedLoc(\n-          {loc, mlir::NameLoc::get(\n-                    b.getStringAttr(std::string(xla::kMhloOriginalValueAttr) +\n-                                    \"={\" + original_value->ToString() + \"}\"))});\n-    }\n-    return loc;\n-  };\n-\n   const std::string& op_name = instruction->metadata().op_name();\n   if (op_name.empty()) {\n-    return fuse_original_value_if_present(mlir::NameLoc::get(\n-        b.getStringAttr(xla::ToStringRef(instruction->name()))));\n+    return mlir::NameLoc::get(\n+        b.getStringAttr(xla::ToStringRef(instruction->name())));\n   }\n \n   if (instruction->metadata().stack_frame_id() != 0) {\n@@ -56,22 +44,21 @@ mlir::Location GenerateInstructionLocation(\n                                   instruction->parent()->parent());\n \n     if (!isa<mlir::UnknownLoc>(frame_location)) {\n-      return fuse_original_value_if_present(\n-          mlir::NameLoc::get(b.getStringAttr(op_name), frame_location));\n+      return mlir::NameLoc::get(b.getStringAttr(op_name), frame_location);\n     }\n   }\n \n   mlir::Location op_name_loc = mlir::NameLoc::get(b.getStringAttr(op_name));\n   const std::string& source_file = instruction->metadata().source_file();\n \n   if (source_file.empty()) {\n-    return fuse_original_value_if_present(op_name_loc);\n+    return op_name_loc;\n   }\n \n-  return fuse_original_value_if_present(b.getFusedLoc(\n+  return b.getFusedLoc(\n       {op_name_loc,\n        mlir::FileLineColLoc::get(b.getContext(), source_file,\n-                                 instruction->metadata().source_line(), 0)}));\n+                                 instruction->metadata().source_line(), 0)});\n }\n \n }  // namespace hlo"
        },
        {
            "sha": "fcce0947bfd16a4326be00660a605c020b539c03",
            "filename": "third_party/xla/xla/hlo/translate/hlo_to_mhlo/tests/import.hlo",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Ftests%2Fimport.hlo",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Ftests%2Fimport.hlo",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Ftests%2Fimport.hlo?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -2127,4 +2127,12 @@ add {\n // CHECK:  mhlo.topk([[ARG]], k = 2) : tensor<4x4xf32> -> (tensor<4x2xf32>, tensor<4x2xi32>)\n \n // FLATTEN-CHECK-LABEL:  func private @test_topk\n-// FLATTEN-CHECK-SAME:  ([[ARG:%.*]]: tensor<4x4xf32>) -> (tensor<4x2xf32>, tensor<4x2xi32>)\n\\ No newline at end of file\n+// FLATTEN-CHECK-SAME:  ([[ARG:%.*]]: tensor<4x4xf32>) -> (tensor<4x2xf32>, tensor<4x2xi32>)\n+\n+// Test HLO original value\n+// CHECK-LABEL:  func private @test_original_value\n+%test_original_value (Arg_0: f32[192]) -> f32[1,17,17,192] {\n+  %Arg_0 = f32[192]{0} parameter(0)\n+  // CHECK: \"mhlo.broadcast_in_dim\"(%arg0) <{broadcast_dimensions = dense<3> : tensor<1xi64>}> {mhlo.original_value = \"{{[{][{]}}\\22broadcast.2342\\22{{[}][}]}}\"} : (tensor<192xf32>) -> tensor<1x17x17x192xf32>\n+  ROOT %broadcast.2342 = f32[1,17,17,192]{3,2,1,0} broadcast(f32[192]{0} %Arg_0), dimensions={3}, origin={{\"broadcast.2342\"}}\n+}"
        },
        {
            "sha": "0fcd2326b5bd469501b8f9fb3d50883691b251e6",
            "filename": "third_party/xla/xla/hlo/translate/hlo_to_mhlo/tests/location.hlo",
            "status": "modified",
            "additions": 18,
            "deletions": 20,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Ftests%2Flocation.hlo",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Ftests%2Flocation.hlo",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fhlo_to_mhlo%2Ftests%2Flocation.hlo?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -2,26 +2,24 @@\n // TODO: hlo-translate does not set the metadata for arguments properly.\n \n HloModule Test\n-// CHECK: #[[LOC1:.*]] = loc(\"x\")\n-// CHECK: #[[LOC2:.*]] = loc(\"mhlo.original_value={{[{][{]}}\\22x\\22{{[}][}]}}\")\n-// CHECK: #[[LOC3:.*]] = loc(\"y\")\n-// CHECK: #[[LOC4:.*]] = loc(\"mhlo.original_value={{[{][{]}}\\22y\\22{{[}][}]}}\")\n+\n // CHECK-LABEL: func @main\n-ENTRY main {\n-  %arg0 = f32[4] parameter(0), metadata={op_name=\"x\"}, origin={{\"x\"}}\n-  %arg1 = f32[4] parameter(1), metadata={op_name=\"y\"}, origin={{\"y\"}}\n-  // CHECK-NEXT: loc(#[[LOC5:.*]])\n+ENTRY A {\n+  // CHECK: loc(\"x\")\n+  %arg0 = f32[4] parameter(0), metadata={op_name=\"x\"}\n+  // CHECK: loc(\"y\")\n+  %arg1 = f32[4] parameter(1), metadata={op_name=\"y\"}\n+\n+  // CHECK: loc(#[[LOC0:.*]])\n   %add0 = f32[4] add(f32[4] %arg0, f32[4] %arg1)\n-  // CHECK-NEXT: loc(#[[LOC13:.*]])\n-  %add1 = f32[4] add(f32[4] %add0, f32[4] %arg1), metadata={op_type=\"Add\" op_name=\"embedded_inference/Add_0\"}, origin={{\"add1\"}}\n-  // CHECK-NEXT: loc(#[[LOC14:.*]])\n-  ROOT %add2 = f32[4] add(f32[4] %add1, f32[4] %arg1), metadata={op_type=\"Add\" op_name=\"embedded_inference/Add_1\", source_file=\"source.txt\", source_line=17}, origin={{\"add2\"}}\n+  // CHECK: loc(#[[LOC1:.*]])\n+  %add1 = f32[4] add(f32[4] %add0, f32[4] %arg1), metadata={op_type=\"Add\" op_name=\"embedded_inference/Add_0\"}\n+  // CHECK: loc(#[[LOC4:.*]])\n+  ROOT %add2 = f32[4] add(f32[4] %add1, f32[4] %arg1), metadata={op_type=\"Add\" op_name=\"embedded_inference/Add_1\", source_file=\"source.txt\", source_line=17}\n+\n+  // CHECK: #[[LOC0]] = loc(\"add0\")\n+  // CHECK: #[[LOC1]] = loc(\"embedded_inference/Add_0\")\n+  // CHECK: #[[LOC2:.*]] = loc(\"embedded_inference/Add_1\")\n+  // CHECK: #[[LOC3:.*]] = loc(\"source.txt\":17:0)\n+  // CHECK: #[[LOC4]] = loc(fused[#[[LOC2]], #[[LOC3]]])\n }\n-// CHECK: #[[LOC5]] = loc(\"add0\")\n-// CHECK: #[[LOC6:.*]] = loc(\"embedded_inference/Add_0\")\n-// CHECK: #[[LOC7:.*]] = loc(\"mhlo.original_value={{[{][{]}}\\22add1\\22{{[}][}]}}\")\n-// CHECK: #[[LOC8:.*]] = loc(\"embedded_inference/Add_1\")\n-// CHECK: #[[LOC9:.*]] = loc(\"source.txt\":17:0)\n-// CHECK: #[[LOC10:.*]] = loc(\"mhlo.original_value={{[{][{]}}\\22add2\\22{{[}][}]}}\")\n-// CHECK: #[[LOC13]] = loc(fused[#[[LOC6]], #[[LOC7]]])\n-// CHECK: #[[LOC14]] = loc(fused[#[[LOC8]], #[[LOC9]], #[[LOC10]]])"
        },
        {
            "sha": "cf7013bcb3fb211f9fb974dea8b04b4fdc917c3d",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/gen_hlo_op_writer.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fgen_hlo_op_writer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fgen_hlo_op_writer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fgen_hlo_op_writer.cc?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -218,7 +218,7 @@ static bool OperatorWritersMain(raw_ostream& os, const RecordKeeper& records) {\n   // Create a scoped object to assign original values to generated XLA ops.\n   os << \"  xla::XlaScopedOriginalValueAssignment \"\n         \"original_value(lowering_context.builder, \"\n-        \"mlir::mhlo::CreateOriginalValueFromOp(op));\\n\\n\";\n+        \"CreateOriginalValueFromOp(op));\\n\\n\";\n \n   // Retrieve all the definitions derived from MHLO_Op and sort by record name.\n   for (auto dialect_def : dialect_defs) {"
        },
        {
            "sha": "6bb48be9bc80cf54921c3bd142a270f45515714b",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/location_exporter.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 64,
            "changes": 64,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Flocation_exporter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Flocation_exporter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Flocation_exporter.cc?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -15,8 +15,6 @@ limitations under the License.\n \n #include \"xla/hlo/translate/mhlo_to_hlo/location_exporter.h\"\n \n-#include <memory>\n-#include <optional>\n #include <string>\n \n #include \"llvm/ADT/STLExtras.h\"\n@@ -28,11 +26,8 @@ limitations under the License.\n #include \"mlir/IR/Operation.h\"\n #include \"mlir/IR/Visitors.h\"\n #include \"mlir/Support/LLVM.h\"\n-#include \"xla/hlo/ir/hlo_original_value.h\"\n-#include \"xla/hlo/parser/hlo_parser.h\"\n #include \"xla/hlo/translate/hlo_to_mhlo/hlo_utils.h\"\n #include \"xla/hlo/translate/mhlo_to_hlo/stack_frame_index_builder.h\"\n-#include \"xla/mlir_hlo/utils/unregistered_attributes.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace mlir {\n@@ -51,9 +46,6 @@ static std::string GetNameFromLocImpl(Location loc) {\n       // in functions where the op's name is first.\n       auto name = name_loc.getName().strref().split('@').first;\n       // Skip if the name is for op type.\n-      if (name.starts_with(xla::kMhloOriginalValueAttr)) {\n-        continue;\n-      }\n       if (name.ends_with(\":\")) {\n         locs.push_back(name_loc.getChildLoc());\n       } else {\n@@ -85,9 +77,6 @@ static std::string GetOpTypeFromLoc(Location loc) {\n       // Add name in NameLoc. For NameLoc we also account for names due to ops\n       // in functions where the op's name is first.\n       auto op_type = name_loc.getName().strref().split('@').first;\n-      if (op_type.starts_with(xla::kMhloOriginalValueAttr)) {\n-        continue;\n-      }\n       if (op_type.ends_with(\":\")) {\n         op_type = op_type.substr(0, op_type.size() - 1);\n         loc_op_types.push_back(op_type);\n@@ -107,39 +96,6 @@ static std::string GetOpTypeFromLoc(Location loc) {\n   return llvm::join(loc_op_types.begin(), loc_op_types.end(), \";\");\n }\n \n-static std::shared_ptr<xla::OriginalValue> GetOriginalValueFromLoc(\n-    Location loc) {\n-  llvm::StringRef loc_original_value;\n-  llvm::SmallVector<Location, 8> locs;\n-  locs.push_back(loc);\n-\n-  while (!locs.empty()) {\n-    Location curr_loc = locs.pop_back_val();\n-\n-    if (auto name_loc = mlir::dyn_cast<NameLoc>(curr_loc)) {\n-      auto original_value = name_loc.getName().strref().split('@').first;\n-      if (!original_value.starts_with(xla::kMhloOriginalValueAttr)) {\n-        continue;\n-      }\n-      loc_original_value = original_value.split('=').second;\n-      break;\n-    }\n-    if (auto fused_loc = mlir::dyn_cast<FusedLoc>(curr_loc)) {\n-      // Push all locations in FusedLoc in reverse order, so locations are\n-      // visited based on order in FusedLoc.\n-      auto reversed_fused_locs = llvm::reverse(fused_loc.getLocations());\n-      locs.append(reversed_fused_locs.begin(), reversed_fused_locs.end());\n-    }\n-  }\n-\n-  auto original_value =\n-      xla::ParseOriginalValue(xla::ToStringView(loc_original_value));\n-  if (!original_value.ok()) {\n-    return nullptr;\n-  }\n-  return original_value.value();\n-}\n-\n static void SetSourceFileAndLine(Location loc, xla::OpMetadata& metadata) {\n   if (auto file_line_col_loc = mlir::dyn_cast<mlir::FileLineColLoc>(loc)) {\n     metadata.set_source_file(file_line_col_loc.getFilename().str());\n@@ -205,25 +161,5 @@ std::string GetDebugNameFromLocation(mlir::Location loc) {\n   return GetNameFromLocImpl(loc);\n }\n \n-std::optional<xla::OriginalValueProto> CreateOriginalValueFromOp(\n-    mlir::Operation* op) {\n-  mlir::Location loc = op->getLoc();\n-  return CreateOriginalValueFromLocation(loc);\n-}\n-\n-std::optional<xla::OriginalValueProto> CreateOriginalValueFromLocation(\n-    mlir::Location loc) {\n-  if (isa<mlir::UnknownLoc>(loc)) {\n-    return std::nullopt;\n-  }\n-\n-  if (std::shared_ptr<xla::OriginalValue> original_value =\n-          GetOriginalValueFromLoc(loc)) {\n-    return original_value->ToProto();\n-  }\n-\n-  return std::nullopt;\n-}\n-\n }  // namespace mhlo\n }  // namespace mlir"
        },
        {
            "sha": "70ab1d6395076a430c63c668b1975548a9ad4072",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/location_exporter.h",
            "status": "modified",
            "additions": 0,
            "deletions": 8,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Flocation_exporter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Flocation_exporter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Flocation_exporter.h?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -34,14 +34,6 @@ namespace mhlo {\n xla::OpMetadata CreateOpMetadataFromLocation(\n     Operation* op, StackFrameIndexBuilder* frame_index_builder);\n \n-// Returns an OriginalValueProto based on the location. If the location is\n-// unknown or the original value is not present, an empty proto is returned.\n-std::optional<xla::OriginalValueProto> CreateOriginalValueFromLocation(\n-    mlir::Location loc);\n-\n-// Returns an OriginalValueProto based on the location of the op.\n-std::optional<xla::OriginalValueProto> CreateOriginalValueFromOp(Operation* op);\n-\n // Returns a name that can be used for debugging purposes, e.g., naming\n // variable names in generated IR or producing logging output.\n std::string GetDebugNameFromLocation(Location location);"
        },
        {
            "sha": "3f9b8658bbf6350dc54084594dabfbd40c938d3b",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/mlir_hlo_to_hlo.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.cc?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -6224,8 +6224,6 @@ LogicalResult ConvertToHloModule::LowerBasicBlockAsFunction(\n         // debugging.\n         xla::XlaScopedOpMetadataAssignment op_metadata(\n             builder, GetOpNameMetadataFromLocation(arg));\n-        xla::XlaScopedOriginalValueAssignment original_value(\n-            builder, mlir::mhlo::CreateOriginalValueFromLocation(arg.getLoc()));\n         // Use the user-specified op_name from the location if available,\n         // otherwise use the default prefix.\n         std::string name = mhlo::GetDebugNameFromLocation(arg.getLoc());\n@@ -6523,4 +6521,14 @@ absl::Status ConvertMlirHloToHlo(mlir::ModuleOp module,\n   return ConvertMlirHloToHlo(module, hlo_proto, options);\n }\n \n+std::optional<xla::OriginalValueProto> CreateOriginalValueFromOp(\n+    mlir::Operation* op) {\n+  auto original_value_attr =\n+      op->getAttrOfType<mlir::StringAttr>(xla::kMhloOriginalValueAttr);\n+  if (!original_value_attr) {\n+    return std::nullopt;\n+  }\n+  return xla::ConvertOriginalValue(original_value_attr.getValue());\n+}\n+\n }  // namespace mlir"
        },
        {
            "sha": "574238506c978ba241dea740327f4274da8390cf",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/mlir_hlo_to_hlo.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.h?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -101,6 +101,11 @@ absl::Status BuildHloFromMlirHlo(mlir::Block& block, xla::XlaBuilder& builder,\n                                  std::vector<xla::XlaOp>& returns,\n                                  MlirToHloConversionOptions options = {});\n \n+// Returns an OriginalValueProto from the \"original_value\" attribute of the op.\n+// Returns std::nullopt if the op doesn't have the attribute.\n+std::optional<xla::OriginalValueProto> CreateOriginalValueFromOp(\n+    mlir::Operation* op);\n+\n }  // namespace mlir\n \n #endif  // XLA_HLO_TRANSLATE_MHLO_TO_HLO_MLIR_HLO_TO_HLO_H_"
        },
        {
            "sha": "b80d14e55a152da43b57aa8adccdf2b077541f1a",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/tests/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2FBUILD?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -37,7 +37,6 @@ lit_test_suite(\n             \"int4.mlir\",\n             \"layouts_and_names.mlir\",\n             \"location_to_op_metadata.mlir\",\n-            \"location_to_original_value.mlir\",\n             \"location_to_stacktrace.mlir\",\n             \"missing_main.mlir\",\n             \"module_config.mlir\","
        },
        {
            "sha": "51833546ef7f458c44d8b9dad7aa6e446722866a",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/tests/export.mlir",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2Fexport.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2Fexport.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2Fexport.mlir?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -3169,6 +3169,30 @@ func.func @main(%input0: tensor<16x16xf32>, %input1: tensor<16x16xi32>) {\n   func.return\n }\n \n+// -----\n+// CHECK: HloModule\n+// CHECK: ENTRY\n+// CHECK: %[[ARG0:.*]] = f32[192] parameter(0)\n+// CHECK: ROOT %[[RESULT:.*]] = f32[1,17,17,192] broadcast(%[[ARG0]]), dimensions={3}, origin={{[{][{]}}\"broadcast.2342\"{{[}][}]}}\n+\n+func.func @main(%arg0: tensor<192xf32>) -> tensor<1x17x17x192xf32> {\n+  %0 = \"mhlo.broadcast_in_dim\"(%arg0) <{broadcast_dimensions = dense<3> : tensor<1xi64>}> {mhlo.original_value = \"{{\\22broadcast.2342\\22}}\"} : (tensor<192xf32>) -> tensor<1x17x17x192xf32>\n+  return %0 : tensor<1x17x17x192xf32>\n+}\n+\n+// -----\n+\n+// CHECK: HloModule\n+// CHECK: ENTRY\n+// CHECK:  %Arg_0.1 = f32[10] parameter(0)\n+// CHECK:  %[[TOPK:.*]] = (f32[8], s32[8]) topk(%Arg_0.1), k=8, largest=true, origin={({\"t\" {0}{{[}]}}, {\"t\" {1}{{[}]}})}\n+// CHECK:  ROOT %[[GTE0:.*]] = f32[8] get-tuple-element(%[[TOPK]]), index=0, origin={{[{][{]}}\"t\" {0}{{[}][}]}}\n+// CHECK:  %[[GTE1:.*]] = s32[8] get-tuple-element(%[[TOPK]]), index=1, origin={{[{][{]}}\"t\" {1}{{[}][}]}}\n+func.func @main(%arg0: tensor<10xf32>) -> tensor<8xf32> {\n+  %0:2 = mhlo.topk(%arg0, k=8, largest=true) {mhlo.original_value=\"{({\\22t\\22 {0}}, {\\22t\\22 {1}})}\"} : tensor<10xf32> -> (tensor<8xf32>, tensor<8xi32>)\n+  return %0#0 : tensor<8xf32>\n+}\n+\n // -----\n \n // CHECK: HloModule"
        },
        {
            "sha": "8280927ea5eb6edb6cfd5dbf46604a0d254114f3",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/tests/location_to_original_value.mlir",
            "status": "removed",
            "additions": 0,
            "deletions": 52,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6d89bdc637a213ad952e2e2539b9abbb3865a112/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2Flocation_to_original_value.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6d89bdc637a213ad952e2e2539b9abbb3865a112/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2Flocation_to_original_value.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Ftests%2Flocation_to_original_value.mlir?ref=6d89bdc637a213ad952e2e2539b9abbb3865a112",
            "patch": "@@ -1,52 +0,0 @@\n-// RUN: xla-translate -split-input-file -mlir-hlo-to-hlo-text %s | FileCheck %s --dump-input=always --check-prefixes=CHECK\n-\n-\n-#loc1 = loc(\"x\")\n-#loc2 = loc(\"mhlo.original_value={{\\22x\\22}}\")\n-#loc3 = loc(\"y\")\n-#loc4 = loc(\"mhlo.original_value={{\\22y\\22}}\")\n-#loc5 = loc(\"add0\")\n-#loc6 = loc(\"Add_0\")\n-#loc7 = loc(\"mhlo.original_value={{\\22add1\\22}}\")\n-#loc8 = loc(\"Add_1\")\n-#loc9 = loc(\"source.txt\":17:0)\n-#loc10 = loc(\"mhlo.original_value={{\\22add2\\22}}\")\n-#loc11 = loc(fused[#loc1, #loc2])\n-#loc12 = loc(fused[#loc3, #loc4])\n-#loc13 = loc(fused[#loc6, #loc7])\n-#loc14 = loc(fused[#loc8, #loc9, #loc10])\n-#loc15 = loc(\"TopK_0\")\n-#loc16 = loc(\"mhlo.original_value={({\\22t\\22 {0}}, {\\22t\\22 {1}})}\")\n-#loc17 = loc(fused[#loc15, #loc16])\n-\n-module @Test {\n-\n-// CHECK-LABEL: main\n-// CHECK: %[[ARG0:.*]] = f32[4] parameter(0), origin={{[{][{]}}\"x\"{{[}][}]}}\n-// CHECK: %[[ARG1:.*]] = f32[4] parameter(1), origin={{[{][{]}}\"y\"{{[}][}]}}\n-// CHECK: %[[ADD0:.*]] = f32[4] add(%[[ARG0]], %[[ARG1]])\n-// CHECK-NOT: origin\n-// CHECK-SAME: metadata={op_name=\"add0\"}\n-// CHECK: %[[ADD1:.*]] = f32[4] add(%[[ADD0]], %[[ARG1]]), origin={{[{][{]}}\"add1\"{{[}][}]}}, metadata=\n-// CHECK: ROOT %[[ADD2:.*]] = f32[4] add(%[[ADD1]], %[[ARG1]]), origin={{[{][{]}}\"add2\"{{[}][}]}}, metadata=\n-  func.func @main(%arg0: tensor<4xf32> loc(fused[#loc1, #loc2]), %arg1: tensor<4xf32> loc(fused[#loc3, #loc4])) -> tensor<4xf32> {\n-    %0 = mhlo.add %arg0, %arg1 : tensor<4xf32> loc(#loc5)\n-    %1 = mhlo.add %0, %arg1 : tensor<4xf32> loc(#loc13)\n-    %2 = mhlo.add %1, %arg1 : tensor<4xf32> loc(#loc14)\n-    return %2 : tensor<4xf32>\n-  }\n-\n-\n-// CHECK-LABEL: tuple_results\n-// CHECK:  %Arg_0.1 = f32[10] parameter(0)\n-// CHECK:  %[[TOPK:.*]] = (f32[8], s32[8]) topk(%Arg_0.1), k=8, largest=true, origin={({\"t\" {0}{{[}]}}, {\"t\" {1}{{[}]}})}\n-// CHECK:  ROOT %[[GTE0:.*]] = f32[8] get-tuple-element(%[[TOPK]]), index=0, origin={{[{][{]}}\"t\" {0}{{[}][}]}}\n-// CHECK:  %[[GTE1:.*]] = s32[8] get-tuple-element(%[[TOPK]]), index=1, origin={{[{][{]}}\"t\" {1}{{[}][}]}}\n-  func.func @tuple_results(%arg0: tensor<10xf32>) -> tensor<8xf32> {\n-    %0:2 = mhlo.topk(%arg0, k=8, largest=true) : tensor<10xf32> -> (tensor<8xf32>, tensor<8xi32>) loc(#loc17)\n-    return %0#0 : tensor<8xf32>\n-  }\n-\n-}\n-\n-"
        },
        {
            "sha": "08f7c3b05f4dc4578a26e58171a4cdbc4ce7a614",
            "filename": "third_party/xla/xla/hlo/translate/tests/stablehlo.mlir",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Ftests%2Fstablehlo.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46090f7bae20d50c2448818ff432e8af397a2991/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Ftests%2Fstablehlo.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Ftests%2Fstablehlo.mlir?ref=46090f7bae20d50c2448818ff432e8af397a2991",
            "patch": "@@ -1950,6 +1950,34 @@ module {\n \n // -----\n \n+// CHECK-LABEL: HloModule main\n+\n+// CHECK: ENTRY\n+// CHECK: %[[ARG0:.*]] = f32[192] parameter(0)\n+// CHECK: ROOT %[[RESULT:.*]] = f32[1,17,17,192] broadcast(%[[ARG0]]), dimensions={3}, origin={{[{][{]}}\"broadcast.2342\"{{[}][}]}}\n+\n+module {\n+  func.func @main(%arg0: tensor<192xf32>) -> tensor<1x17x17x192xf32> {\n+    %0 = stablehlo.broadcast_in_dim %arg0, dims = [3] {mhlo.original_value = \"{{\\22broadcast.2342\\22}}\"} : (tensor<192xf32>) -> tensor<1x17x17x192xf32>\n+    return %0 : tensor<1x17x17x192xf32>\n+  }\n+}\n+\n+// -----\n+\n+// CHECK-LABEL: HloModule main\n+// CHECK: ENTRY\n+// CHECK:  %Arg_0.1 = f32[10] parameter(0)\n+// CHECK:  %[[TOPK:.*]] = (f32[8], s32[8]) topk(%Arg_0.1), k=8, largest=true, origin={({\"t\" {0}{{[}]}}, {\"t\" {1}{{[}]}})}\n+// CHECK:  ROOT %[[GTE0:.*]] = f32[8] get-tuple-element(%[[TOPK]]), index=0, origin={{[{][{]}}\"t\" {0}{{[}][}]}}\n+// CHECK:  %[[GTE1:.*]] = s32[8] get-tuple-element(%[[TOPK]]), index=1, origin={{[{][{]}}\"t\" {1}{{[}][}]}}\n+func.func @main(%arg0: tensor<10xf32>) -> tensor<8xf32> {\n+  %0:2 = mhlo.topk(%arg0, k=8, largest=true) {mhlo.original_value=\"{({\\22t\\22 {0}}, {\\22t\\22 {1}})}\"} : tensor<10xf32> -> (tensor<8xf32>, tensor<8xi32>)\n+  return %0#0 : tensor<8xf32>\n+}\n+\n+// -----\n+\n // CHECK-LABEL: HloModule main\n // CHECK: ENTRY\n func.func @main() -> tensor<128x2048xf32> {"
        }
    ],
    "stats": {
        "total": 277,
        "additions": 109,
        "deletions": 168
    }
}