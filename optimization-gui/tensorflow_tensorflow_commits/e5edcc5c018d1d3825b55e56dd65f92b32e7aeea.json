{
    "author": "junwhanahn",
    "message": "Implement device time measurement in IFRT Proxy\n\nThis CL propagates device time measured during execution back to the IFRT Proxy client. If there is an active device time measurement on the client side, IFRT Proxy enables device time measurement on the server side and propagate the measured time back to the client. The caller can wait for `ExecuteResult::status` and read the device time.\n\nPiperOrigin-RevId: 843862101",
    "sha": "e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
    "files": [
        {
            "sha": "1c34eea924511b190c937f52a7c6ab0dde3b90a1",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/BUILD",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2FBUILD?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -442,6 +442,7 @@ cc_library(\n         \"//xla/pjrt:host_callback\",\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/pjrt/profiling:device_time_measurement\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:attribute_map\",\n         \"//xla/python/ifrt:sharding_serdes\",\n@@ -470,6 +471,7 @@ cc_library(\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:cord\",\n         \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/time\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n         \"@local_tsl//tsl/platform:platform_port\",\n@@ -623,6 +625,8 @@ ifrt_proxy_cc_test(\n         \":version\",\n         \"//xla:shape_util\",\n         \"//xla:xla_data_proto_cc\",\n+        \"//xla/pjrt/profiling:device_time_measurement\",\n+        \"//xla/pjrt/profiling/test_util:mock_device_time_measurement\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:basic_device_list\",\n         \"//xla/python/ifrt:mock\",\n@@ -643,6 +647,7 @@ ifrt_proxy_cc_test(\n         \"@com_google_googletest//:gtest_main\",\n         \"@com_google_protobuf//:protobuf\",\n         \"@llvm-project//llvm:Support\",\n+        \"@local_tsl//tsl/platform\",\n         \"@local_tsl//tsl/platform:protobuf\",\n     ],\n )"
        },
        {
            "sha": "957b9fd5e4841dd872b76ae42d8f365eb4f8643c",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/executable.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 7,
            "changes": 73,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.cc?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -35,13 +35,15 @@\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"absl/time/time.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/Support/Casting.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/layout.h\"\n #include \"xla/pjrt/host_callback.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n+#include \"xla/pjrt/profiling/device_time_measurement.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/array_spec.h\"\n #include \"xla/python/ifrt/attribute_map.h\"\n@@ -735,10 +737,17 @@ LoadedExecutable::Execute(absl::Span<xla::ifrt::ArrayRef> args,\n     }\n   }\n \n+  std::optional<uint64_t> device_time_key = xla::GetDeviceTimeMeasurementKey();\n+  if (device_time_key.has_value()) {\n+    // An active device time measurement requires the server to respond with\n+    // measured device times after the execution is complete.\n+    req->mutable_execute_options()->set_fill_status(true);\n+  }\n+\n   // Starting version 6, the server populates the status future only if it was\n   // explicitly requested via `options.fill_status`.\n-  const bool result_needs_exec_status =\n-      rpc_helper_->protocol_version() < 6 || options.fill_status;\n+  const bool result_needs_exec_status = rpc_helper_->protocol_version() < 6 ||\n+                                        req->execute_options().fill_status();\n \n   // The client generates handles if the protocol version is sufficiently newer,\n   // and we've already seen at least one response from an execute (and thus know\n@@ -789,10 +798,13 @@ LoadedExecutable::Execute(absl::Span<xla::ifrt::ArrayRef> args,\n     }\n     rpc_helper_->LoadedExecutableExecute(std::move(req));\n     if (result_needs_exec_status) {\n-      // Note that `CheckFuture` needs to be sent after\n+      // Note that the RPCs within `FetchExecuteResult` need to be sent after\n       // `LoadedExecutableExecute` above, or the server will not recognize the\n       // handle being sent.\n-      result.status = rpc_helper_->CheckFuture(status_handle);\n+      tsl::Future<> status = FetchExecuteResult(status_handle, device_time_key);\n+      if (options.fill_status) {\n+        result.status = std::move(status);\n+      }\n     }\n \n     return result;\n@@ -808,8 +820,8 @@ LoadedExecutable::Execute(absl::Span<xla::ifrt::ArrayRef> args,\n       Array::Destruct(rpc_helper_.get(), ArrayHandle{output.array_handle()});\n     }\n     if (result_needs_exec_status) {\n-      // `CheckFuture` deletes the server-side future handle.\n-      rpc_helper_->CheckFuture(response->status_handle());\n+      // `FetchExecuteResult` deletes the server-side future handle.\n+      FetchExecuteResult(response->status_handle(), device_time_key);\n     }\n     return status;\n   }\n@@ -836,7 +848,11 @@ LoadedExecutable::Execute(absl::Span<xla::ifrt::ArrayRef> args,\n     }\n   }\n   if (result_needs_exec_status) {\n-    result.status = rpc_helper_->CheckFuture(response->status_handle());\n+    tsl::Future<> status =\n+        FetchExecuteResult(response->status_handle(), device_time_key);\n+    if (options.fill_status) {\n+      result.status = std::move(status);\n+    }\n   } else {\n     CHECK_EQ(response->status_handle(), 0);\n   }\n@@ -853,6 +869,49 @@ absl::Span<xla::ifrt::Device* const> LoadedExecutable::addressable_devices()\n   return addressable_devices_;\n }\n \n+tsl::Future<> LoadedExecutable::FetchExecuteResult(\n+    uint64_t status_handle, std::optional<uint64_t> device_time_key) {\n+  if (rpc_helper_->protocol_version() < protocol_version::kExecuteResult) {\n+    return rpc_helper_->CheckFuture(status_handle);\n+  }\n+  auto req = std::make_unique<LoadedExecutableFetchExecuteResultRequest>();\n+  req->set_result_status_handle(status_handle);\n+\n+  using RespT = std::shared_ptr<LoadedExecutableFetchExecuteResultResponse>;\n+\n+  tsl::Future<RespT> result =\n+      rpc_helper_->LoadedExecutableFetchExecuteResult(std::move(req));\n+\n+  if (device_time_key.has_value()) {\n+    result.OnReady([device_time_key](const absl::StatusOr<RespT>& resp) {\n+      if (!resp.ok()) {\n+        LOG_EVERY_N_SEC(ERROR, 60)\n+            << \"Device time measurement was requested but failed to retrieve \"\n+               \"the execution result: \"\n+            << resp.status();\n+        return;\n+      }\n+\n+      for (const auto& [device_type_name, duration] : (*resp)->device_time()) {\n+        xla::DeviceTimeMeasurement::DeviceType device_type;\n+        if (device_type_name == \"tpu\") {\n+          device_type = xla::DeviceTimeMeasurement::DeviceType::kTpu;\n+        } else if (device_type_name == \"gpu\") {\n+          device_type = xla::DeviceTimeMeasurement::DeviceType::kGpu;\n+        } else {\n+          device_type = xla::DeviceTimeMeasurement::DeviceType::kUnknown;\n+        }\n+        if (device_type != xla::DeviceTimeMeasurement::DeviceType::kUnknown) {\n+          xla::RecordDeviceTimeMeasurement(\n+              *device_time_key, absl::Microseconds(duration), device_type);\n+        }\n+      }\n+    });\n+  }\n+\n+  return result.GetReadyFuture();\n+}\n+\n char LoadedExecutable::ID = 0;  // NOLINT\n \n }  // namespace proxy"
        },
        {
            "sha": "56c74a83e718bbec4e8ed309a9713175561e2440",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/executable.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable.h?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -143,6 +143,9 @@ class LoadedExecutable final\n     int64_t size_of_generated_code_in_bytes;\n   };\n \n+  tsl::Future<> FetchExecuteResult(uint64_t status_handle,\n+                                   std::optional<uint64_t> device_time_key);\n+\n   xla::ifrt::Client* client_;\n   std::shared_ptr<RpcHelper> rpc_helper_;\n "
        },
        {
            "sha": "c2c46a215ce144608e83171ecc2cccf6e9f035bd",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/executable_test.cc",
            "status": "modified",
            "additions": 91,
            "deletions": 11,
            "changes": 102,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Fexecutable_test.cc?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -16,6 +16,7 @@\n \n #include <cstdint>\n #include <memory>\n+#include <optional>\n #include <utility>\n #include <vector>\n \n@@ -28,6 +29,8 @@\n #include \"llvm/Support/Casting.h\"\n #include \"google/protobuf/text_format.h\"\n #include \"xla/layout_util.h\"\n+#include \"xla/pjrt/profiling/device_time_measurement.h\"\n+#include \"xla/pjrt/profiling/test_util/mock_device_time_measurement.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/basic_device_list.h\"\n #include \"xla/python/ifrt/device.h\"\n@@ -55,6 +58,7 @@\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/util/proto/proto_matchers.h\"\n #include \"xla/xla_data.pb.h\"\n+#include \"tsl/platform/platform.h\"\n #include \"tsl/platform/protobuf.h\"  // IWYU pragma: keep\n \n using ::testing::_;\n@@ -232,7 +236,7 @@ TEST_F(LoadedExecutableTest, Execute) {\n   exec_options.fill_status = true;\n \n   IfrtResponse execute_response;\n-  IfrtResponse check_future_response;\n+  IfrtResponse fetch_execute_result_response;\n \n   ASSERT_TRUE(TextFormat::ParseFromString(R\"pb(\n                                             loaded_executable_execute_response {\n@@ -277,12 +281,13 @@ TEST_F(LoadedExecutableTest, Execute) {\n                                               }\n                                             }\n                                           )pb\",\n-                                          &check_future_response));\n+                                          &fetch_execute_result_response));\n   EXPECT_CALL(*session_,\n-              Enqueue(Pointee(Partially(EquivToProto(R\"pb(check_future_request {\n-                                                            future_handle: 2000\n-                                                          })pb\")))))\n-      .WillOnce(MockClientSessionReturnResponse(check_future_response));\n+              Enqueue(Pointee(Partially(EquivToProto(\n+                  R\"pb(loaded_executable_fetch_execute_result_request {\n+                         result_status_handle: 2000\n+                       })pb\")))))\n+      .WillOnce(MockClientSessionReturnResponse(fetch_execute_result_response));\n \n   DeviceListRef devices = BasicDeviceList::Create({&device});\n \n@@ -333,21 +338,23 @@ TEST_F(LoadedExecutableTest, Execute) {\n       Enqueue(IfrtRequestOfType(IfrtRequest::kLoadedExecutableExecuteRequest)))\n       .WillOnce(MockClientCaptureAndReturn(&requests_queue, execute_response));\n   EXPECT_CALL(*session_,\n-              Enqueue(IfrtRequestOfType(IfrtRequest::kCheckFutureRequest)))\n-      .WillOnce(\n-          MockClientCaptureAndReturn(&requests_queue, check_future_response));\n+              Enqueue(IfrtRequestOfType(\n+                  IfrtRequest::kLoadedExecutableFetchExecuteResultRequest)))\n+      .WillOnce(MockClientCaptureAndReturn(&requests_queue,\n+                                           fetch_execute_result_response));\n \n   TF_ASSERT_OK_AND_ASSIGN(\n       result, executable.Execute(absl::MakeSpan(args), exec_options, devices));\n \n   auto execute_req = requests_queue.Pop().loaded_executable_execute_request();\n-  auto check_future_req = requests_queue.Pop().check_future_request();\n+  auto fetch_execute_result_req =\n+      requests_queue.Pop().loaded_executable_fetch_execute_result_request();\n \n   EXPECT_THAT(\n       result.status.Await(),\n       absl_testing::StatusIs(absl::StatusCode::kUnknown, \"injected error\"));\n   EXPECT_EQ(execute_req.result_status_handle(),\n-            check_future_req.future_handle());\n+            fetch_execute_result_req.result_status_handle());\n \n   ASSERT_THAT(result.outputs, SizeIs(2));\n   ASSERT_THAT(execute_req.result_array_handle(), SizeIs(2));\n@@ -361,6 +368,79 @@ TEST_F(LoadedExecutableTest, Execute) {\n             execute_req.result_array_handle()[1]);\n }\n \n+TEST_F(LoadedExecutableTest, DeviceTime) {\n+  if (tsl::kIsOpenSource) {\n+    GTEST_SKIP()\n+        << \"DeviceTimeMeasurement implementation isn't available in OSS.\";\n+  }\n+\n+  MockClient client;\n+\n+  IfrtResponse response;\n+  ASSERT_TRUE(TextFormat::ParseFromString(\n+      R\"pb(\n+        loaded_executable_metadata_response {\n+          parameter_shardings {}\n+          output_shardings {}\n+          output_layouts_list {}\n+        }\n+      )pb\",\n+      &response));\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_metadata_request {\n+                                    loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .WillOnce(MockClientSessionReturnResponse(response));\n+\n+  LoadedExecutable executable(\n+      &client, rpc_helper_, /*handle=*/1234, /*name=*/\"foo\",\n+      /*num_devices=*/1, /*devices=*/{}, /*addressable_devices=*/{},\n+      /*fingerprint=*/\"fingerprint\",\n+      /*ready_future=*/tsl::Future<>(absl::OkStatus()),\n+      /*loaded_host_callbacks=*/{}, /*loaded_host_callback_handles=*/{});\n+\n+  xla::ifrt::LoadedExecutable::ExecuteOptions exec_options;\n+  exec_options.fill_status = true;\n+\n+  IfrtResponse execute_response;\n+  IfrtResponse fetch_execute_result_response;\n+\n+  ASSERT_TRUE(TextFormat::ParseFromString(\n+      R\"pb(\n+        loaded_executable_execute_response { status_handle: 2000 }\n+      )pb\",\n+      &execute_response));\n+  EXPECT_CALL(*session_, Enqueue(Pointee(Partially(EquivToProto(\n+                             R\"pb(loaded_executable_execute_request {\n+                                    loaded_executable_handle: 1234\n+                                  })pb\")))))\n+      .WillOnce(MockClientSessionReturnResponse(execute_response));\n+\n+  ASSERT_TRUE(TextFormat::ParseFromString(\n+      R\"pb(\n+        loaded_executable_fetch_execute_result_response {\n+          device_time { key: \"tpu\" value: 1234.0 }\n+        }\n+      )pb\",\n+      &fetch_execute_result_response));\n+  EXPECT_CALL(*session_,\n+              Enqueue(Pointee(Partially(EquivToProto(\n+                  R\"pb(loaded_executable_fetch_execute_result_request {\n+                         result_status_handle: 2000\n+                       })pb\")))))\n+      .WillOnce(MockClientSessionReturnResponse(fetch_execute_result_response));\n+\n+  auto device_time = xla::CreateDeviceTimeMeasurement();\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto result,\n+                          executable.Execute({}, exec_options, std::nullopt));\n+  EXPECT_OK(result.status.Await());\n+\n+  EXPECT_THAT(device_time->GetTotalDuration(\n+                  xla::DeviceTimeMeasurement::DeviceType::kTpu),\n+              absl::Microseconds(1234.0));\n+}\n+\n }  // namespace\n }  // namespace proxy\n }  // namespace ifrt"
        },
        {
            "sha": "42ade73d4d3c518e7b4eb728c35c6add65e27ff0",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.cc?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -477,6 +477,7 @@ RPC(LoadedExecutableMpmdCostAnalysis, loaded_executable_mpmd_cost_analysis);\n RPC(LoadedExecutableHumanReadableProgramText,\n     loaded_executable_human_readable_program_text);\n RPC(LoadedExecutableExecute, loaded_executable_execute);\n+RPC(LoadedExecutableFetchExecuteResult, loaded_executable_fetch_execute_result);\n RPC(LoadedExecutableDelete, loaded_executable_delete);\n RPC(LoadedExecutableIsDeleted, loaded_executable_is_deleted);\n RPC(LoadedExecutableDestruct, loaded_executable_destruct);"
        },
        {
            "sha": "14e78f496b2147c3c927eb60367dfb90a231a762",
            "filename": "third_party/xla/xla/python/ifrt_proxy/client/rpc_helper.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fclient%2Frpc_helper.h?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -152,6 +152,9 @@ class RpcHelper {\n       std::unique_ptr<LoadedExecutableHumanReadableProgramTextRequest> req);\n   ResponseFuture<LoadedExecutableExecuteResponse> LoadedExecutableExecute(\n       std::unique_ptr<LoadedExecutableExecuteRequest> req);\n+  ResponseFuture<LoadedExecutableFetchExecuteResultResponse>\n+  LoadedExecutableFetchExecuteResult(\n+      std::unique_ptr<LoadedExecutableFetchExecuteResultRequest> req);\n   ResponseFuture<LoadedExecutableDeleteResponse> LoadedExecutableDelete(\n       std::unique_ptr<LoadedExecutableDeleteRequest> req);\n   ResponseFuture<LoadedExecutableIsDeletedResponse> LoadedExecutableIsDeleted("
        },
        {
            "sha": "84691a8c5de6bd3da504249cd1a0975c711a3407",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/VERSION.md",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FVERSION.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FVERSION.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2FVERSION.md?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -124,3 +124,10 @@\n     *   Added support for `MpmdLoadedExecutable::GetMpmdAddressableDevices()`.\n     *   Added support for `MpmdLoadedExecutable::GetMpmdCompiledMemoryStats()`.\n     *   Added support for `MpmdLoadedExecutable::GetMpmdCostAnalysis()`.\n+\n+## Version kExecutionResult\n+\n+*   Added date: 2025-12-11\n+*   Changes:\n+    *   Added a new op `LoadedExecutableFetchExecuteResult` for reading\n+        execution results."
        },
        {
            "sha": "d8638b40629de40cfad7b81c78bcb19609947ea7",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/ifrt_service.proto",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fifrt_service.proto?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -37,7 +37,7 @@ message IfrtProxyVersion {\n   int32 ifrt_serdes_version_number = 2;\n }\n \n-// Next ID: 32.\n+// Next ID: 33.\n message IfrtRequest {\n   RequestMetadata request_metadata = 1;\n \n@@ -73,6 +73,8 @@ message IfrtRequest {\n     // ===== LoadedExecutable =====\n     LoadedExecutableMetadataRequest loaded_executable_metadata_request = 14;\n     LoadedExecutableExecuteRequest loaded_executable_execute_request = 15;\n+    LoadedExecutableFetchExecuteResultRequest\n+        loaded_executable_fetch_execute_result_request = 32;\n     LoadedExecutableCostAnalysisRequest\n         loaded_executable_cost_analysis_request = 28;\n     LoadedExecutableHumanReadableProgramTextRequest\n@@ -102,7 +104,7 @@ message IfrtRequest {\n   reserved 10;\n }\n \n-// Next ID: 32.\n+// Next ID: 33.\n message IfrtResponse {\n   ResponseMetadata response_metadata = 1;\n \n@@ -138,6 +140,8 @@ message IfrtResponse {\n     // ===== LoadedExecutable =====\n     LoadedExecutableMetadataResponse loaded_executable_metadata_response = 14;\n     LoadedExecutableExecuteResponse loaded_executable_execute_response = 15;\n+    LoadedExecutableFetchExecuteResultResponse\n+        loaded_executable_fetch_execute_result_response = 32;\n     LoadedExecutableCostAnalysisResponse\n         loaded_executable_cost_analysis_response = 28;\n     LoadedExecutableHumanReadableProgramTextResponse\n@@ -604,6 +608,14 @@ message LoadedExecutableExecuteResponse {\n   repeated Output outputs = 2;\n }\n \n+message LoadedExecutableFetchExecuteResultRequest {\n+  fixed64 result_status_handle = 1;\n+}\n+message LoadedExecutableFetchExecuteResultResponse {\n+  // Map from device types to device time in microseconds.\n+  map<string, double> device_time = 1;\n+}\n+\n // Mirrors `LoadedExecutable::Delete`. Returns a handle of a future that becomes\n // ready when the deletion completes.\n message LoadedExecutableDeleteRequest {"
        },
        {
            "sha": "fbbc0675084768be01c4767015208550fc7d6721",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/versions.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fversions.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fversions.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Fversions.h?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -66,6 +66,10 @@ enum {\n   // GetMpmdCostAnalysis.\n   kMpmdLoadedExecutableMethods = 20,\n \n+  // kExecuteResult adds a separate request/response type for Execution\n+  // results to return extra information such as device time measurement.\n+  kExecuteResult = 21,\n+\n   // kSentiel is used to derive kCurrent below. Keep this as the last value of\n   // the enum.\n   kSentiel,"
        },
        {
            "sha": "8faa6a591e9647205dea2c5bf30de292103b2eb1",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2FBUILD?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -134,6 +134,7 @@ cc_library(\n         \"//xla:status_macros\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/pjrt/profiling:device_time_measurement\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:attribute_map\",\n         \"//xla/python/ifrt:basic_device_list\",\n@@ -197,6 +198,7 @@ ifrt_proxy_cc_test(\n         \"//xla/pjrt:host_callback\",\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/pjrt/profiling:device_time_measurement\",\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:attribute_map\",\n         \"//xla/python/ifrt:basic_device_list\",\n@@ -234,10 +236,12 @@ ifrt_proxy_cc_test(\n         \"@com_google_absl//absl/strings:cord\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/synchronization\",\n+        \"@com_google_absl//absl/time\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n         \"@com_google_protobuf//:protobuf\",\n         \"@llvm-project//llvm:Support\",\n+        \"@local_tsl//tsl/platform\",\n         \"@local_tsl//tsl/platform:protobuf\",\n     ],\n )"
        },
        {
            "sha": "21d8272662662a1a44ded625451c7604e06c5173",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 94,
            "deletions": 13,
            "changes": 107,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -46,6 +46,7 @@\n #include \"xla/future.h\"\n #include \"xla/layout.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n+#include \"xla/pjrt/profiling/device_time_measurement.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/array_spec.h\"\n #include \"xla/python/ifrt/attribute_map.h\"\n@@ -636,19 +637,34 @@ tsl::Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n           HandleLoadedExecutableExecuteRequest(*asr, std::move(request));\n       if (client_generated_status_handle != 0) {\n         // Populate the handle if not already populated.\n-        absl::MutexLock l(futures_mutex_);\n-        const bool inserted = futures_\n-                                  .insert({client_generated_status_handle,\n-                                           tsl::Future<>(result.status())})\n-                                  .second;\n-        // If `HandleLoadedExecutableExecuteRequest` returned OK, verify that\n-        // it already has populated status_handle.\n-        if (result.ok()) {\n-          CHECK(!inserted);\n+        if (protocol_version() >= protocol_version::kExecuteResult) {\n+          absl::MutexLock l(execute_results_mutex_);\n+          if (result.ok()) {\n+            CHECK(execute_results_.contains(client_generated_status_handle));\n+          } else {\n+            CHECK(execute_results_\n+                      .insert({client_generated_status_handle,\n+                               tsl::Future<ExecuteResult>(result.status())})\n+                      .second);\n+          }\n+        } else {\n+          absl::MutexLock l(futures_mutex_);\n+          const bool inserted = futures_\n+                                    .insert({client_generated_status_handle,\n+                                             tsl::Future<>(result.status())})\n+                                    .second;\n+          // If `HandleLoadedExecutableExecuteRequest` returned OK, verify that\n+          // it already has populated status_handle.\n+          if (result.ok()) {\n+            CHECK(!inserted);\n+          }\n         }\n       }\n       return tsl::Future<Response>(asr->ProcessResponse(std::move(result)));\n     }\n+    case IfrtRequest::RequestCase::kLoadedExecutableFetchExecuteResultRequest:\n+      return HandleLoadedExecutableFetchExecuteResultRequest(\n+          std::move(request));\n     case IfrtRequest::RequestCase::kLoadedExecutableDeleteRequest:\n       return tsl::Future<Response>(\n           HandleLoadedExecutableDeleteRequest(std::move(request)));\n@@ -1815,6 +1831,11 @@ IfrtBackend::HandleLoadedExecutableExecuteRequest(\n     TF_ASSIGN_OR_RETURN(devices, client_->MakeDeviceList(std::move(d)));\n   }\n \n+  std::unique_ptr<xla::DeviceTimeMeasurement> device_time;\n+  if (execute_options.fill_status) {\n+    device_time = xla::CreateDeviceTimeMeasurement();\n+  }\n+\n   TF_ASSIGN_OR_RETURN(xla::ifrt::LoadedExecutable::ExecuteResult result,\n                       executable_info->executable->Execute(\n                           absl::MakeSpan(args), execute_options, devices));\n@@ -1894,15 +1915,31 @@ IfrtBackend::HandleLoadedExecutableExecuteRequest(\n   // atomically (as in ACID) across all handles.\n   [&]() -> void {\n     if (execute_options.fill_status) {\n-      // Caller is expected to call `CheckFuture` exactly once to check for its\n-      // status and erase it.\n-      absl::MutexLock lock(futures_mutex_);\n       uint64_t status_handle = execute.result_status_handle();\n       if (status_handle == 0) {\n         status_handle = handle_generator_.GenerateAtServer();\n       }\n       execute_response->set_status_handle(status_handle);\n-      futures_.insert({status_handle, std::move(result.status)});\n+\n+      if (version_.protocol_version() >= protocol_version::kExecuteResult) {\n+        // Caller is expected to call `LoadedExecutableFetchExecuteResult`\n+        // exactly once to check for its status and erase it.\n+        absl::MutexLock lock(execute_results_mutex_);\n+        tsl::Future<ExecuteResult> future = result.status.Map<ExecuteResult>(\n+            [device_time = std::move(device_time)]() mutable {\n+              ExecuteResult result;\n+              if (device_time != nullptr) {\n+                result.device_time = device_time->GetTotalDurations();\n+              }\n+              return result;\n+            });\n+        execute_results_.insert({status_handle, std::move(future)});\n+      } else {\n+        // Caller is expected to call `CheckFuture` exactly once to check for\n+        // its status and erase it.\n+        absl::MutexLock lock(futures_mutex_);\n+        futures_.insert({status_handle, std::move(result.status)});\n+      }\n     }\n \n     std::vector<uint64_t> result_handles = asr.Fill(result.outputs);\n@@ -1926,6 +1963,50 @@ IfrtBackend::HandleLoadedExecutableExecuteRequest(\n   return ifrt_resp;\n }\n \n+tsl::Future<BackendInterface::Response>\n+IfrtBackend::HandleLoadedExecutableFetchExecuteResultRequest(\n+    std::unique_ptr<IfrtRequest> request) {\n+  const auto& fetch = request->loaded_executable_fetch_execute_result_request();\n+\n+  tsl::Future<ExecuteResult> result;\n+  {\n+    absl::MutexLock lock(execute_results_mutex_);\n+    const auto it = execute_results_.find(fetch.result_status_handle());\n+    if (it == execute_results_.end()) {\n+      return tsl::Future<Response>(absl::NotFoundError(absl::StrCat(\n+          \"Unknown result status handle: \", fetch.result_status_handle())));\n+    }\n+    result = std::move(it->second);\n+    execute_results_.erase(it);\n+  }\n+\n+  return result.Map<BackendInterface::Response>(\n+      [op_id =\n+           request->request_metadata().op_id()](const ExecuteResult& result) {\n+        auto ifrt_resp = NewIfrtResponse(op_id);\n+\n+        auto* const fetch_response =\n+            ifrt_resp\n+                ->mutable_loaded_executable_fetch_execute_result_response();\n+        for (const auto& [device_type, duration] : result.device_time) {\n+          switch (device_type) {\n+            case xla::DeviceTimeMeasurement::DeviceType::kTpu:\n+              fetch_response->mutable_device_time()->insert(\n+                  {\"tpu\", absl::ToDoubleMicroseconds(duration)});\n+              break;\n+            case xla::DeviceTimeMeasurement::DeviceType::kGpu:\n+              fetch_response->mutable_device_time()->insert(\n+                  {\"gpu\", absl::ToDoubleMicroseconds(duration)});\n+              break;\n+            case xla::DeviceTimeMeasurement::DeviceType::kUnknown:\n+              break;\n+          }\n+        }\n+\n+        return ifrt_resp;\n+      });\n+}\n+\n // This handler will be deleted on 2025-06-06 since the underlying IFRT API is\n // deprecated. An error is returned until then to gracefully handle old clients.\n absl::StatusOr<BackendInterface::Response>"
        },
        {
            "sha": "ed5945bbc5a8b8db0377e58573094dbb5f574637",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.h",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.h?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -27,7 +27,9 @@\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"absl/time/time.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/pjrt/profiling/device_time_measurement.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/array_spec.h\"\n #include \"xla/python/ifrt/client.h\"\n@@ -157,6 +159,11 @@ class IfrtBackend final : public BackendInterface {\n         ABSL_GUARDED_BY(mu_);\n   };\n \n+  struct ExecuteResult {\n+    absl::flat_hash_map<xla::DeviceTimeMeasurement::DeviceType, absl::Duration>\n+        device_time;\n+  };\n+\n   IfrtBackend(IfrtProxyVersion version, uint64_t session_id,\n               std::shared_ptr<xla::ifrt::Client> ifrt_client,\n               std::shared_ptr<HostBufferStore> host_buffer_store);\n@@ -223,6 +230,8 @@ class IfrtBackend final : public BackendInterface {\n       std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleLoadedExecutableExecuteRequest(\n       ArrayStore::Reservation& asr, std::unique_ptr<IfrtRequest> request);\n+  tsl::Future<Response> HandleLoadedExecutableFetchExecuteResultRequest(\n+      std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleLoadedExecutableDeleteRequest(\n       std::unique_ptr<IfrtRequest> request);\n   absl::StatusOr<Response> HandleLoadedExecutableIsDeletedRequest(\n@@ -292,6 +301,10 @@ class IfrtBackend final : public BackendInterface {\n   absl::flat_hash_map<uint64_t, std::shared_ptr<LoadedExecutableWithInfo>>\n       executables_ ABSL_GUARDED_BY(executables_mutex_);\n \n+  absl::Mutex execute_results_mutex_;\n+  absl::flat_hash_map<uint64_t, tsl::Future<ExecuteResult>> execute_results_\n+      ABSL_GUARDED_BY(execute_results_mutex_);\n+\n   absl::Mutex host_callback_queues_mutex_;\n   absl::flat_hash_map<uint64_t, std::shared_ptr<RemoteLoadedHostCallbackQueue>>\n       host_callback_queues_ ABSL_GUARDED_BY(host_callback_queues_mutex_);"
        },
        {
            "sha": "332c4c7e3b201c24937f2ad36619e0a07b8aae27",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend_test.cc",
            "status": "modified",
            "additions": 106,
            "deletions": 7,
            "changes": 113,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e5edcc5c018d1d3825b55e56dd65f92b32e7aeea/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend_test.cc?ref=e5edcc5c018d1d3825b55e56dd65f92b32e7aeea",
            "patch": "@@ -37,6 +37,7 @@\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"absl/time/time.h\"\n #include \"absl/types/span.h\"\n #include \"llvm/Support/Casting.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n@@ -48,6 +49,7 @@\n #include \"xla/pjrt/host_callback.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n+#include \"xla/pjrt/profiling/device_time_measurement.h\"\n #include \"xla/python/ifrt/array.h\"\n #include \"xla/python/ifrt/attribute_map.h\"\n #include \"xla/python/ifrt/basic_device_list.h\"\n@@ -88,6 +90,7 @@\n #include \"xla/tsl/protobuf/status.pb.h\"\n #include \"xla/tsl/util/proto/proto_matchers.h\"\n #include \"xla/xla_data.pb.h\"\n+#include \"tsl/platform/platform.h\"\n #include \"tsl/platform/protobuf.h\"  // IWYU pragma: keep\n \n namespace xla {\n@@ -102,6 +105,7 @@ using ::testing::ElementsAre;\n using ::testing::ElementsAreArray;\n using ::testing::HasSubstr;\n using ::testing::Invoke;\n+using ::testing::MatchesRegex;\n using ::testing::Not;\n using ::testing::NotNull;\n using ::testing::Optional;\n@@ -1375,19 +1379,36 @@ TEST_P(IfrtBackendHandlerTest, LoadedExecutableExecute) {\n     EXPECT_NE(output.array_handle(), 0);\n   }\n \n+  auto check_execution_result = [&](uint64_t handle) -> absl::Status {\n+    if (handle == 0) {\n+      return absl::InternalError(\"Test error, future handle is 0\");\n+    }\n+    if (Version().protocol_version() >= protocol_version::kExecuteResult) {\n+      auto request = NewIfrtRequest(NewOpId());\n+      request->mutable_loaded_executable_fetch_execute_result_request()\n+          ->set_result_status_handle(handle);\n+      TF_ASSIGN_OR_RETURN(std::shared_ptr<IfrtResponse> response,\n+                          CallBackend(std::move(request)));\n+      return tsl::StatusFromProto(response->response_metadata().status());\n+    } else {\n+      return CheckFuture(handle);\n+    }\n+  };\n+\n   EXPECT_THAT(\n-      CheckFuture(\n+      check_execution_result(\n           response->loaded_executable_execute_response().status_handle()),\n       absl_testing::StatusIs(absl::StatusCode::kInternal,\n                              StrEq(\"injected error\")));\n \n-  // The second call to `CheckFuture` fails since `CheckFuture` above performs a\n-  // destructive read.\n+  // The second call to `check_execution_result` fails since\n+  // `check_execution_result` above performs a destructive read.\n   EXPECT_THAT(\n-      CheckFuture(\n+      check_execution_result(\n           response->loaded_executable_execute_response().status_handle()),\n-      absl_testing::StatusIs(absl::StatusCode::kNotFound,\n-                             HasSubstr(\"Unknown future handle\")));\n+      absl_testing::StatusIs(\n+          absl::StatusCode::kNotFound,\n+          MatchesRegex(\"Unknown (future|result status) handle.*\")));\n }\n \n TEST_P(IfrtBackendHandlerTest, LoadedExecutableExecuteErrorWithClientHandles) {\n@@ -1450,13 +1471,91 @@ TEST_P(IfrtBackendHandlerTest, LoadedExecutableExecuteErrorWithClientHandles) {\n \n   EXPECT_THAT(CallBackend(std::move(request)), status_is_err);\n \n-  EXPECT_THAT(CheckFuture(kFirstResultHandle + kNumOutputs), status_is_err);\n+  {\n+    const uint64_t handle = kFirstResultHandle + kNumOutputs;\n+    if (Version().protocol_version() >= protocol_version::kExecuteResult) {\n+      auto request = NewIfrtRequest(NewOpId());\n+      request->mutable_loaded_executable_fetch_execute_result_request()\n+          ->set_result_status_handle(handle);\n+      EXPECT_THAT(CallBackend(std::move(request)), status_is_err);\n+    } else {\n+      EXPECT_THAT(CheckFuture(handle), status_is_err);\n+    }\n+  }\n \n   for (int i = 0; i < kNumOutputs; ++i) {\n     EXPECT_THAT(CheckValueReady(kFirstResultHandle + i), status_is_err);\n   }\n }\n \n+TEST_P(IfrtBackendHandlerTest, LoadedExecutableDeviceTime) {\n+  if (tsl::kIsOpenSource) {\n+    GTEST_SKIP()\n+        << \"DeviceTimeMeasurement implementation isn't available in OSS.\";\n+  }\n+  if (Version().protocol_version() < protocol_version::kExecuteResult) {\n+    GTEST_SKIP()\n+        << \"Device time measurement is not supported in this protocol version\";\n+  }\n+\n+  MockLoadedExecutable* executable;\n+  uint64_t handle;\n+  {\n+    auto e = std::make_unique<MockLoadedExecutable>();\n+    executable = e.get();\n+    TF_ASSERT_OK_AND_ASSIGN(CompileResponse response,\n+                            CompileTestLoadedExecutable(std::move(e)));\n+    handle = response.loaded_executable_handle();\n+  }\n+\n+  EXPECT_CALL(*executable, Execute(_, _, _))\n+      .WillOnce([&](absl::Span<ArrayRef> args,\n+                    const xla::ifrt::LoadedExecutable::ExecuteOptions& options,\n+                    std::optional<DeviceListRef> devices)\n+                    -> absl::StatusOr<LoadedExecutable::ExecuteResult> {\n+        std::optional<uint64_t> device_time_key =\n+            xla::GetDeviceTimeMeasurementKey();\n+        if (device_time_key.has_value()) {\n+          xla::RecordDeviceTimeMeasurement(\n+              *device_time_key, absl::Microseconds(1234),\n+              xla::DeviceTimeMeasurement::DeviceType::kTpu);\n+        }\n+        LoadedExecutable::ExecuteResult result;\n+        result.status = tsl::Future<>(absl::OkStatus());\n+        return result;\n+      });\n+\n+  constexpr uint64_t kResultStatusHandle = 1000;\n+  {\n+    auto request = NewIfrtRequest(NewOpId());\n+    LoadedExecutableExecuteRequest* execute_request =\n+        request->mutable_loaded_executable_execute_request();\n+    execute_request->set_loaded_executable_handle(handle);\n+    execute_request->set_result_status_handle(kResultStatusHandle);\n+\n+    xla::ifrt::LoadedExecutable::ExecuteOptions execute_options;\n+    execute_options.fill_status = true;\n+    TF_ASSERT_OK(execute_options.ToProto(\n+        *execute_request->mutable_execute_options(), ifrt_serdes_version()));\n+\n+    EXPECT_OK(CallBackend(std::move(request)));\n+  }\n+\n+  {\n+    auto request = NewIfrtRequest(NewOpId());\n+    request->mutable_loaded_executable_fetch_execute_result_request()\n+        ->set_result_status_handle(kResultStatusHandle);\n+    TF_ASSERT_OK_AND_ASSIGN(std::shared_ptr<IfrtResponse> response,\n+                            CallBackend(std::move(request)));\n+    EXPECT_THAT(response, Pointee(Partially(EquivToProto(R\"pb(\n+                  loaded_executable_fetch_execute_result_response {\n+                    device_time { key: \"tpu\" value: 1234.0 }\n+                    device_time { key: \"gpu\" value: 0 }\n+                  }\n+                )pb\"))));\n+  }\n+}\n+\n TEST_P(IfrtBackendHandlerTest, LoadedExecutableDestruct) {\n   MockLoadedExecutable* executable;\n   uint64_t handle;"
        }
    ],
    "stats": {
        "total": 451,
        "additions": 411,
        "deletions": 40
    }
}