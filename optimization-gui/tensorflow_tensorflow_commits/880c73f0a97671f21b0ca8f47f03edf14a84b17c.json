{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 846037511",
    "sha": "880c73f0a97671f21b0ca8f47f03edf14a84b17c",
    "files": [
        {
            "sha": "d5f6c765e51dd0306698b89ac3cd0edd75e27204",
            "filename": "tensorflow/core/lib/core/arena.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/880c73f0a97671f21b0ca8f47f03edf14a84b17c/tensorflow%2Fcore%2Flib%2Fcore%2Farena.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/880c73f0a97671f21b0ca8f47f03edf14a84b17c/tensorflow%2Fcore%2Flib%2Fcore%2Farena.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fcore%2Farena.h?ref=880c73f0a97671f21b0ca8f47f03edf14a84b17c",
            "patch": "@@ -62,7 +62,7 @@ class Arena {\n \n  protected:\n   bool SatisfyAlignment(const size_t alignment);\n-  void MakeNewBlock(const uint32 alignment);\n+  void MakeNewBlock(const uint32_t alignment);\n   void* GetMemoryFallback(const size_t size, const int align);\n   void* GetMemory(const size_t size, const int align) {\n     assert(remaining_ <= block_size_);                  // an invariant\n@@ -88,7 +88,7 @@ class Arena {\n   // The returned AllocatedBlock* is valid until the next call to AllocNewBlock\n   // or Reset (i.e. anything that might affect overflow_blocks_).\n   AllocatedBlock* AllocNewBlock(const size_t block_size,\n-                                const uint32 alignment);\n+                                const uint32_t alignment);\n \n   const size_t block_size_;\n   char* freestart_;  // beginning of the free space in most recent block"
        },
        {
            "sha": "4769cddaca09065adbbaddb20887d72e8ac3be90",
            "filename": "tensorflow/core/lib/core/coding_test.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 45,
            "changes": 90,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/880c73f0a97671f21b0ca8f47f03edf14a84b17c/tensorflow%2Fcore%2Flib%2Fcore%2Fcoding_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/880c73f0a97671f21b0ca8f47f03edf14a84b17c/tensorflow%2Fcore%2Flib%2Fcore%2Fcoding_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fcore%2Fcoding_test.cc?ref=880c73f0a97671f21b0ca8f47f03edf14a84b17c",
            "patch": "@@ -22,46 +22,46 @@ namespace tensorflow {\n namespace core {\n \n TEST(Coding, Fixed16) {\n-  static const uint16 N = 50000;\n+  static const uint16_t N = 50000;\n \n-  string s;\n-  for (uint16 v = 0; v < N; v++) {\n-    char buf[sizeof(uint16)];\n+  std::string s;\n+  for (uint16_t v = 0; v < N; v++) {\n+    char buf[sizeof(uint16_t)];\n     EncodeFixed16(buf, v);\n     s.append(buf, sizeof(buf));\n   }\n \n   const char* p = s.data();\n-  for (uint16 v = 0; v < N; v++) {\n-    uint16 actual = DecodeFixed16(p);\n+  for (uint16_t v = 0; v < N; v++) {\n+    uint16_t actual = DecodeFixed16(p);\n     ASSERT_EQ(v, actual);\n-    p += sizeof(uint16);\n+    p += sizeof(uint16_t);\n   }\n }\n \n TEST(Coding, Fixed32) {\n-  static const uint32 N = 100000;\n+  static const uint32_t N = 100000;\n \n-  string s;\n-  for (uint32 v = 0; v < N; v++) {\n-    char buf[sizeof(uint32)];\n+  std::string s;\n+  for (uint32_t v = 0; v < N; v++) {\n+    char buf[sizeof(uint32_t)];\n     EncodeFixed32(buf, v);\n     s.append(buf, sizeof(buf));\n   }\n \n   const char* p = s.data();\n-  for (uint32 v = 0; v < N; v++) {\n-    uint32 actual = DecodeFixed32(p);\n+  for (uint32_t v = 0; v < N; v++) {\n+    uint32_t actual = DecodeFixed32(p);\n     ASSERT_EQ(v, actual);\n-    p += sizeof(uint32);\n+    p += sizeof(uint32_t);\n   }\n }\n \n TEST(Coding, Fixed64) {\n-  string s;\n+  std::string s;\n   for (int power = 0; power <= 63; power++) {\n-    uint64 v = static_cast<uint64>(1) << power;\n-    char buf[sizeof(uint64)];\n+    uint64_t v = static_cast<uint64_t>(1) << power;\n+    char buf[sizeof(uint64_t)];\n     EncodeFixed64(buf, v - 1);\n     s.append(buf, sizeof(buf));\n     EncodeFixed64(buf, v + 0);\n@@ -72,19 +72,19 @@ TEST(Coding, Fixed64) {\n \n   const char* p = s.data();\n   for (int power = 0; power <= 63; power++) {\n-    uint64 v = static_cast<uint64>(1) << power;\n-    uint64 actual;\n+    uint64_t v = static_cast<uint64_t>(1) << power;\n+    uint64_t actual;\n     actual = DecodeFixed64(p);\n     ASSERT_EQ(v - 1, actual);\n-    p += sizeof(uint64);\n+    p += sizeof(uint64_t);\n \n     actual = DecodeFixed64(p);\n     ASSERT_EQ(v + 0, actual);\n-    p += sizeof(uint64);\n+    p += sizeof(uint64_t);\n \n     actual = DecodeFixed64(p);\n     ASSERT_EQ(v + 1, actual);\n-    p += sizeof(uint64);\n+    p += sizeof(uint64_t);\n   }\n }\n \n@@ -113,17 +113,17 @@ TEST(Coding, EncodingOutput) {\n }\n \n TEST(Coding, Varint32) {\n-  string s;\n-  for (uint32 i = 0; i < (32 * 32); i++) {\n-    uint32 v = (i / 32) << (i % 32);\n+  std::string s;\n+  for (uint32_t i = 0; i < (32 * 32); i++) {\n+    uint32_t v = (i / 32) << (i % 32);\n     PutVarint32(&s, v);\n   }\n \n   const char* p = s.data();\n   const char* limit = p + s.size();\n-  for (uint32 i = 0; i < (32 * 32); i++) {\n-    uint32 expected = (i / 32) << (i % 32);\n-    uint32 actual;\n+  for (uint32_t i = 0; i < (32 * 32); i++) {\n+    uint32_t expected = (i / 32) << (i % 32);\n+    uint32_t actual;\n     p = GetVarint32Ptr(p, limit, &actual);\n     ASSERT_TRUE(p != nullptr);\n     ASSERT_EQ(expected, actual);\n@@ -133,21 +133,21 @@ TEST(Coding, Varint32) {\n \n TEST(Coding, Varint64) {\n   // Construct the list of values to check\n-  std::vector<uint64> values;\n+  std::vector<uint64_t> values;\n   // Some special values\n   values.push_back(0);\n   values.push_back(100);\n-  values.push_back(~static_cast<uint64>(0));\n-  values.push_back(~static_cast<uint64>(0) - 1);\n-  for (uint32 k = 0; k < 64; k++) {\n+  values.push_back(~static_cast<uint64_t>(0));\n+  values.push_back(~static_cast<uint64_t>(0) - 1);\n+  for (uint32_t k = 0; k < 64; k++) {\n     // Test values near powers of two\n-    const uint64 power = 1ull << k;\n+    const uint64_t power = 1ull << k;\n     values.push_back(power);\n     values.push_back(power - 1);\n     values.push_back(power + 1);\n   }\n \n-  string s;\n+  std::string s;\n   for (size_t i = 0; i < values.size(); i++) {\n     PutVarint64(&s, values[i]);\n   }\n@@ -156,7 +156,7 @@ TEST(Coding, Varint64) {\n   const char* limit = p + s.size();\n   for (size_t i = 0; i < values.size(); i++) {\n     ASSERT_TRUE(p < limit);\n-    uint64 actual;\n+    uint64_t actual;\n     p = GetVarint64Ptr(p, limit, &actual);\n     ASSERT_TRUE(p != nullptr);\n     ASSERT_EQ(values[i], actual);\n@@ -165,17 +165,17 @@ TEST(Coding, Varint64) {\n }\n \n TEST(Coding, Varint32Overflow) {\n-  uint32 result;\n-  string input(\"\\x81\\x82\\x83\\x84\\x85\\x11\");\n+  uint32_t result;\n+  std::string input(\"\\x81\\x82\\x83\\x84\\x85\\x11\");\n   ASSERT_TRUE(GetVarint32Ptr(input.data(), input.data() + input.size(),\n                              &result) == nullptr);\n }\n \n TEST(Coding, Varint32Truncation) {\n-  uint32 large_value = (1u << 31) + 100;\n-  string s;\n+  uint32_t large_value = (1u << 31) + 100;\n+  std::string s;\n   PutVarint32(&s, large_value);\n-  uint32 result;\n+  uint32_t result;\n   for (size_t len = 0; len < s.size() - 1; len++) {\n     ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == nullptr);\n   }\n@@ -185,17 +185,17 @@ TEST(Coding, Varint32Truncation) {\n }\n \n TEST(Coding, Varint64Overflow) {\n-  uint64 result;\n-  string input(\"\\x81\\x82\\x83\\x84\\x85\\x81\\x82\\x83\\x84\\x85\\x11\");\n+  uint64_t result;\n+  std::string input(\"\\x81\\x82\\x83\\x84\\x85\\x81\\x82\\x83\\x84\\x85\\x11\");\n   ASSERT_TRUE(GetVarint64Ptr(input.data(), input.data() + input.size(),\n                              &result) == nullptr);\n }\n \n TEST(Coding, Varint64Truncation) {\n-  uint64 large_value = (1ull << 63) + 100ull;\n-  string s;\n+  uint64_t large_value = (1ull << 63) + 100ull;\n+  std::string s;\n   PutVarint64(&s, large_value);\n-  uint64 result;\n+  uint64_t result;\n   for (size_t len = 0; len < s.size() - 1; len++) {\n     ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == nullptr);\n   }"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 47,
        "deletions": 47
    }
}