{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809665612",
    "sha": "eba5c643d9e90c75b4c80fea82f6321b279a13a8",
    "files": [
        {
            "sha": "91b43b070aa5fcc33d4db6cd0a1e84e7ebdc8caa",
            "filename": "third_party/xla/xla/service/lockable.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Flockable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Flockable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Flockable.h?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -92,7 +92,7 @@ class Lockable {\n \n   ~Lockable() {\n     VLOG(2) << \"Destroy \" << LockableName::ToString(value_);\n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n     CHECK_EQ(is_unlocked_, true);  // NOLINT\n   }\n \n@@ -102,7 +102,7 @@ class Lockable {\n                                           {{\"lockable\", ToString()}});\n     });\n \n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n     mutex_.Await(absl::Condition(&is_unlocked_));\n     VLOG(2) << \"Acquired \" << LockableName::ToString(value_);\n     is_unlocked_ = false;\n@@ -111,7 +111,7 @@ class Lockable {\n   }\n \n   Lock TryAcquire() {\n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n \n     // Someone already locked this object, return an empty lock.\n     if (is_unlocked_ == false) {\n@@ -134,7 +134,7 @@ class Lockable {\n   friend class Lock;\n \n   void Release() {\n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n     VLOG(2) << \"Released \" << LockableName::ToString(value_);\n     CHECK(!is_unlocked_);  // NOLINT\n     is_unlocked_ = true;"
        },
        {
            "sha": "2cce84790b028014d27a82b00f2c2700e45bf26c",
            "filename": "third_party/xla/xla/service/rendezvous.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Frendezvous.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Frendezvous.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Frendezvous.cc?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -34,7 +34,7 @@ namespace internal {\n // rendezvous is ready, false if the timeout is exceeded.\n static bool WaitForReadyWithTimeout(RendezvousStateSynchronization& state,\n                                     absl::Duration timeout) {\n-  absl::MutexLock lock(&state.mutex);\n+  absl::MutexLock lock(state.mutex);\n \n   // Keep checking if the rendezvous is ready inside a loop and update TraceMe\n   // annotation to track the rendezvous progress."
        },
        {
            "sha": "21762a4d6b1cc8dd7ac8d804599f79d0aa5a167a",
            "filename": "third_party/xla/xla/service/rendezvous.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Frendezvous.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Frendezvous.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Frendezvous.h?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -236,7 +236,7 @@ class RendezvousMap {\n   using State = RendezvousState<R, V>;\n \n   std::shared_ptr<State> Join(const K& key, size_t num_threads) {\n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n \n     // Erase expired rendezvous from the map.\n     absl::erase_if(state_, [](const auto& e) { return e.second.expired(); });\n@@ -254,7 +254,7 @@ class RendezvousMap {\n   }\n \n   void Complete(const K& key) {\n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n     state_.erase(key);\n   }\n "
        },
        {
            "sha": "1e01756ab7233ac02d1d137fd5dede2b1df334a4",
            "filename": "third_party/xla/xla/service/slow_operation_alarm.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fslow_operation_alarm.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fslow_operation_alarm.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fslow_operation_alarm.cc?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -51,7 +51,7 @@ std::list<SlowOperationAlarm*>* outstanding_alarms ABSL_PT_GUARDED_BY(mu) =\n \n void SlowOperationAlarm::AlarmLoop() {\n   while (true) {\n-    absl::MutexLock lock(&mu);\n+    absl::MutexLock lock(mu);\n \n     // Fire any alarms which are ready.\n     absl::Time now = absl::Now();\n@@ -97,13 +97,13 @@ void SlowOperationAlarm::ScheduleAlarm(SlowOperationAlarm* alarm) {\n         tsl::ThreadOptions(), \"SlowOperationAlarm\", [] { AlarmLoop(); });\n   });\n \n-  absl::MutexLock lock(&mu);\n+  absl::MutexLock lock(mu);\n   outstanding_alarms->push_back(alarm);\n   ready->Signal();\n }\n \n void SlowOperationAlarm::UnscheduleAlarm(const SlowOperationAlarm* alarm) {\n-  absl::MutexLock lock(&mu);\n+  absl::MutexLock lock(mu);\n   CHECK(outstanding_alarms != nullptr);\n   auto it = absl::c_find(*outstanding_alarms, alarm);\n   if (it != outstanding_alarms->end()) {"
        },
        {
            "sha": "96995389d1f7c8c383bf303c7c4db2a491133c28",
            "filename": "third_party/xla/xla/service/stream_pool.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fstream_pool.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fstream_pool.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fstream_pool.cc?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -31,7 +31,7 @@ StreamPool::Ptr StreamPool::BorrowStream(se::StreamPriority priority) {\n   std::unique_ptr<se::Stream> stream = nullptr;\n \n   {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     if (auto it = streams_with_pri_.find(priority);\n         it != streams_with_pri_.end()) {\n       std::vector<std::unique_ptr<se::Stream>>& streams = it->second;\n@@ -71,7 +71,7 @@ StreamPool::Ptr StreamPool::BorrowStream(se::StreamPriority priority) {\n void StreamPool::ReturnStream(se::Stream* stream) {\n   if (stream->ok()) {\n     VLOG(1) << absl::StrFormat(\"StreamPool returning ok stream (%p)\", stream);\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     auto priority = std::get<se::StreamPriority>(stream->priority());\n     streams_with_pri_[priority].emplace_back(stream);\n   } else {"
        },
        {
            "sha": "ed7a5ff4996f195ae7f00f043836928c3c7664bb",
            "filename": "third_party/xla/xla/service/symbol_repository.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fsymbol_repository.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fsymbol_repository.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fsymbol_repository.h?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -76,13 +76,13 @@ class SymbolRepositoryRegistry {\n  public:\n   void Register(const std::string& name,\n                 std::unique_ptr<SymbolRepository> repo) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     VLOG(1) << \"Registering SymbolRepository \" << name;\n     repo_[name] = std::move(repo);\n   }\n \n   SymbolRepository* repo(absl::string_view name) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     const auto it = repo_.find(name);\n     if (it == repo_.end()) {\n       return nullptr;"
        },
        {
            "sha": "4e4c6c8191e809b831a1f031760fac0dc91a257d",
            "filename": "third_party/xla/xla/service/transfer_manager.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Ftransfer_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Ftransfer_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Ftransfer_manager.cc?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -199,15 +199,15 @@ absl::Status TransferManager::ReadDynamicShapes(\n /* static */ void TransferManager::RegisterTransferManager(\n     se::Platform::Id platform_id,\n     TransferManagerCreationFunction creation_function) {\n-  absl::MutexLock lock(&TransferManager::platform_transfer_manager_mutex_);\n+  absl::MutexLock lock(TransferManager::platform_transfer_manager_mutex_);\n   auto* managers = GetPlatformTransferManagers();\n   CHECK(managers->find(platform_id) == managers->end());\n   (*managers)[platform_id].creation_function = creation_function;\n }\n \n /* static */ absl::StatusOr<TransferManager*> TransferManager::GetForPlatform(\n     const se::Platform* platform) {\n-  absl::MutexLock lock(&TransferManager::platform_transfer_manager_mutex_);\n+  absl::MutexLock lock(TransferManager::platform_transfer_manager_mutex_);\n   auto* managers = GetPlatformTransferManagers();\n \n   auto it = managers->find(platform->id());"
        },
        {
            "sha": "cbbafc5a050163c076c8b19c02c430ea3596af02",
            "filename": "third_party/xla/xla/service/xla_debug_info_manager.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fxla_debug_info_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fxla_debug_info_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fxla_debug_info_manager.cc?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -32,7 +32,7 @@ void XlaDebugInfoManager::RegisterModule(\n     std::shared_ptr<const HloModule> hlo_module,\n     std::shared_ptr<const BufferAssignment> buffer_assignment) {\n   CHECK(hlo_module != nullptr);\n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   auto result = modules_.try_emplace(hlo_module->unique_id());\n   CHECK(result.second);\n   XlaModuleEntry& m = result.first->second;\n@@ -45,7 +45,7 @@ void XlaDebugInfoManager::RegisterModule(\n // module id is out of scope, we remove it from our database.\n // However during tracing, we will defer the cleanup after serialization.\n void XlaDebugInfoManager::UnregisterModule(ModuleIdentifier module_id) {\n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   auto it = modules_.find(module_id);\n   CHECK(it != modules_.end());\n   if (!tracing_active_) {\n@@ -57,15 +57,15 @@ void XlaDebugInfoManager::UnregisterModule(ModuleIdentifier module_id) {\n }\n \n void XlaDebugInfoManager::StartTracing() {\n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   tracing_active_ = true;\n }\n \n void XlaDebugInfoManager::StopTracing(\n     std::vector<std::unique_ptr<HloProto>>* module_debug_info) {\n   std::vector<XlaModuleEntry> modules_to_serialize;\n   {\n-    absl::MutexLock lock(&mutex_);\n+    absl::MutexLock lock(mutex_);\n     if (!tracing_active_) return;\n     tracing_active_ = false;\n \n@@ -98,7 +98,7 @@ void XlaDebugInfoManager::StopTracing(\n }\n \n bool XlaDebugInfoManager::TracksModule(ModuleIdentifier module_id) const {\n-  absl::MutexLock lock(&mutex_);\n+  absl::MutexLock lock(mutex_);\n   return modules_.find(module_id) != modules_.end();\n }\n "
        },
        {
            "sha": "619c1018b73850993a819f81ba1d10b2b3b892e7",
            "filename": "third_party/xla/xla/service/xla_debug_info_manager_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fxla_debug_info_manager_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eba5c643d9e90c75b4c80fea82f6321b279a13a8/third_party%2Fxla%2Fxla%2Fservice%2Fxla_debug_info_manager_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fxla_debug_info_manager_test.cc?ref=eba5c643d9e90c75b4c80fea82f6321b279a13a8",
            "patch": "@@ -58,7 +58,7 @@ class XlaDebugInfoManagerTestPeer {\n \n   absl::flat_hash_set<ModuleIdentifier> GetModuleIds() {\n     absl::flat_hash_set<ModuleIdentifier> module_ids;\n-    absl::MutexLock lock(&xla_debug_info_manager_.mutex_);\n+    absl::MutexLock lock(xla_debug_info_manager_.mutex_);\n     for (const auto& it : xla_debug_info_manager_.modules_) {\n       module_ids.insert(it.first);\n     }"
        }
    ],
    "stats": {
        "total": 44,
        "additions": 22,
        "deletions": 22
    }
}