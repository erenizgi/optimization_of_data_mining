{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add APIs to create futures by running callbacks on executor\n\nPiperOrigin-RevId: 813953773",
    "sha": "14ad8727405fd2816ac0f4c7c873db060afbb391",
    "files": [
        {
            "sha": "6d96de6aae8c0eb52f6026a7a87c704aa6fe7c99",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14ad8727405fd2816ac0f4c7c873db060afbb391/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14ad8727405fd2816ac0f4c7c873db060afbb391/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=14ad8727405fd2816ac0f4c7c873db060afbb391",
            "patch": "@@ -144,6 +144,7 @@ cc_library(\n     compatible_with = get_compatible_with_portable(),\n     deps = [\n         \":async_value\",\n+        \":executor\",\n         \":ref_count\",\n         \"//xla/tsl/platform:logging\",\n         \"@com_google_absl//absl/base:core_headers\",\n@@ -162,6 +163,7 @@ tsl_cc_test(\n     name = \"future_test\",\n     srcs = [\"future_test.cc\"],\n     deps = [\n+        \":executor\",\n         \":future\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\","
        },
        {
            "sha": "d2a6463f51596c858e87ac98a9fe9a982f02cbb7",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14ad8727405fd2816ac0f4c7c873db060afbb391/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14ad8727405fd2816ac0f4c7c873db060afbb391/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=14ad8727405fd2816ac0f4c7c873db060afbb391",
            "patch": "@@ -31,6 +31,7 @@ limitations under the License.\n #include \"absl/utility/utility.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/logging.h\"\n \n namespace tsl {\n@@ -478,6 +479,18 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n+  // Returns a future that is constructed from the result of invoking functor\n+  // `f` on the given `executor`.\n+  template <typename F, typename R = std::invoke_result_t<F>,\n+            std::enable_if_t<std::is_constructible_v<absl::StatusOr<T>, R>>* =\n+                nullptr>\n+  static Future<T> MakeOn(Executor& executor, F&& f) {\n+    auto [promise, future] = MakePromise();\n+    executor.Execute([promise = std::move(promise),\n+                      f = std::forward<F>(f)]() mutable { promise.Set(f()); });\n+    return std::move(future);\n+  }\n+\n   using Base::Await;\n   using Base::GetReadyFuture;\n   using Base::OnReady;\n@@ -768,6 +781,17 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n     return std::make_pair(std::move(promise), std::move(future));\n   }\n \n+  // Returns a future that is constructed from the result of invoking functor\n+  // `f` on the given `executor`.\n+  template <typename F, typename R = std::invoke_result_t<F>,\n+            std::enable_if_t<std::is_same_v<R, absl::Status>>* = nullptr>\n+  static Future<> MakeOn(Executor& executor, F&& f) {\n+    auto [promise, future] = MakePromise();\n+    executor.Execute([promise = std::move(promise),\n+                      f = std::forward<F>(f)]() mutable { promise.Set(f()); });\n+    return std::move(future);\n+  }\n+\n   using Base::Await;\n   using Base::BlockUntilReady;\n   using Base::OnReady;"
        },
        {
            "sha": "c0b6a59475e3217702a9c5b139508d766c5cf7d7",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/14ad8727405fd2816ac0f4c7c873db060afbb391/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/14ad8727405fd2816ac0f4c7c873db060afbb391/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=14ad8727405fd2816ac0f4c7c873db060afbb391",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/status/statusor.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n \n@@ -674,6 +675,62 @@ TEST(FutureTest, MakeSharedPromise) {\n   }\n }\n \n+struct InlineExecutor : public Executor {\n+  void Execute(Task task) final { std::move(task)(); }\n+};\n+\n+TEST(FutureTest, MakeOnStateless) {\n+  InlineExecutor e;\n+\n+  {\n+    auto future = Future<>::MakeOn(e, [] { return absl::OkStatus(); });\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(future.Await(), absl::OkStatus());\n+  }\n+\n+  {\n+    auto future =\n+        Future<>::MakeOn(e, [] { return absl::InternalError(\"test\"); });\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(future.Await(), absl::InternalError(\"test\"));\n+  }\n+}\n+\n+TEST(FutureTest, MakeOnStateful) {\n+  InlineExecutor executor;\n+\n+  struct Foo {\n+    Foo(int32_t value) : value(value) {}  // NOLINT\n+    int32_t value;\n+  };\n+\n+  {\n+    auto future = Future<int32_t>::MakeOn(executor, [] { return 42; });\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(*future.Await(), 42);\n+  }\n+\n+  {\n+    auto future = Future<Foo>::MakeOn(executor, [] { return 42; });\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(future.Await()->value, 42);\n+  }\n+\n+  {\n+    auto future = Future<std::unique_ptr<int32_t>>::MakeOn(\n+        executor, [] { return std::make_unique<int32_t>(42); });\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(**future.Await(), 42);\n+  }\n+\n+  {\n+    auto future = Future<int32_t>::MakeOn(\n+        executor, [] { return absl::InternalError(\"test\"); });\n+    EXPECT_TRUE(future.IsReady());\n+    EXPECT_EQ(future.Await().status(), absl::InternalError(\"test\"));\n+  }\n+}\n+\n //===----------------------------------------------------------------------===//\n // Performance benchmarks.\n //===----------------------------------------------------------------------===//"
        }
    ],
    "stats": {
        "total": 83,
        "additions": 83,
        "deletions": 0
    }
}