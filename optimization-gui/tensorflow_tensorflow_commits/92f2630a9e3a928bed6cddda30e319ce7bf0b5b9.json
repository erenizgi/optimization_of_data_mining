{
    "author": "junwhanahn",
    "message": "Use `tsl::Future` and `tsl::Promise` and mark IFRT future/promise as deprecated\n\nPiperOrigin-RevId: 812204429",
    "sha": "92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
    "files": [
        {
            "sha": "f653197472ab7c41f2fd9be3bc2865e375f31083",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -240,6 +240,7 @@ xla_cc_test(\n     srcs = [\"future_test.cc\"],\n     deps = [\n         \":ifrt\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\",\n@@ -483,6 +484,7 @@ cc_library(\n         \"//xla:shape_util\",\n         \"//xla/pjrt:pjrt_layout\",\n         \"//xla/python/ifrt/ir:sharding_param\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n@@ -586,6 +588,7 @@ cc_library(\n         \"//xla/hlo/testlib:test\",\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_layout\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/framework:allocator\",\n         \"@com_google_absl//absl/base:no_destructor\","
        },
        {
            "sha": "383c10b4190e8878bd4c4f27eecbe241063a8fbf",
            "filename": "third_party/xla/xla/python/ifrt/array.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -27,10 +27,10 @@ limitations under the License.\n #include \"llvm/Support/ExtensibleRTTI.h\"\n #include \"xla/pjrt/pjrt_layout.h\"\n #include \"xla/python/ifrt/dtype.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/shape.h\"\n #include \"xla/python/ifrt/sharding.h\"\n #include \"xla/python/ifrt/value.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n@@ -127,7 +127,7 @@ class Array : public llvm::RTTIExtends<Array, Value> {\n   // an API that lets users query the alignment requirement of the specific\n   // implementation.\n   ABSL_MUST_USE_RESULT\n-  virtual Future<> CopyToHostBuffer(\n+  virtual tsl::Future<> CopyToHostBuffer(\n       void* data, std::optional<absl::Span<const int64_t>> byte_strides,\n       ArrayCopySemantics semantics) = 0;\n "
        },
        {
            "sha": "a4833c986aa5356d7848e60ff8329e2be06e9abd",
            "filename": "third_party/xla/xla/python/ifrt/array_impl_test_lib.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -39,14 +39,14 @@ limitations under the License.\n #include \"xla/python/ifrt/device.h\"\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/ir/sharding_param.h\"\n #include \"xla/python/ifrt/memory.h\"\n #include \"xla/python/ifrt/shape.h\"\n #include \"xla/python/ifrt/sharding.h\"\n #include \"xla/python/ifrt/test_util.h\"\n #include \"xla/python/ifrt/user_context.h\"\n #include \"xla/python/ifrt/value.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -396,7 +396,7 @@ TEST(ArrayImplTest, MakeArrayFromHostBufferWithNonCompactByteStrides) {\n   TF_ASSERT_OK(array->GetReadyFuture().Await());\n \n   std::vector<int8_t> out_data(4);\n-  Future<> future =\n+  tsl::Future<> future =\n       array->CopyToHostBuffer(out_data.data(), /*byte_strides=*/std::nullopt,\n                               ArrayCopySemantics::kAlwaysCopy);\n   TF_ASSERT_OK(future.Await());\n@@ -898,7 +898,7 @@ TEST(ArrayImplTest, HostBufferRoundTripAllMemoryKinds) {\n     TF_ASSERT_OK(array->GetReadyFuture().Await());\n \n     std::vector<float> new_data(6);\n-    Future<> future = array->CopyToHostBuffer(\n+    tsl::Future<> future = array->CopyToHostBuffer(\n         static_cast<void*>(new_data.data()), /*byte_strides=*/std::nullopt,\n         ArrayCopySemantics::kReuseInput);\n     TF_ASSERT_OK(future.Await());\n@@ -934,7 +934,7 @@ TEST(ArrayImplTest, HostBufferInt4) {\n     TF_ASSERT_OK(array->GetReadyFuture().Await());\n \n     std::vector<int8_t> out_data(4);\n-    Future<> future =\n+    tsl::Future<> future =\n         array->CopyToHostBuffer(out_data.data(), /*byte_strides=*/std::nullopt,\n                                 ArrayCopySemantics::kAlwaysCopy);\n     TF_ASSERT_OK(future.Await());\n@@ -1505,7 +1505,7 @@ TEST(ArrayImplTest, MakeAndCopyZeroSizedBuffers) {\n                              ArrayCopySemantics::kReuseInput));\n       TF_ASSERT_OK(copied[0]->GetReadyFuture().Await());\n \n-      Future<> future =\n+      tsl::Future<> future =\n           copied[0]->CopyToHostBuffer(nullptr, /*byte_strides=*/std::nullopt,\n                                       ArrayCopySemantics::kAlwaysCopy);\n       TF_ASSERT_OK(future.Await());\n@@ -1556,7 +1556,7 @@ TEST(ArrayImplTest, CopyArraysExhaustive) {\n         EXPECT_EQ(new_array->sharding().memory_kind(), dst_memory->Kind());\n \n         std::vector<float> out_data(6);\n-        Future<void> future = new_array->CopyToHostBuffer(\n+        tsl::Future<void> future = new_array->CopyToHostBuffer(\n             out_data.data(), /*byte_strides=*/std::nullopt,\n             ArrayCopySemantics::kAlwaysCopy);\n         TF_ASSERT_OK(future.Await());"
        },
        {
            "sha": "b083cb621cc808862ce4f108f2efd0e3a1c2a39c",
            "filename": "third_party/xla/xla/python/ifrt/client.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fclient.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fclient.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fclient.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -41,7 +41,6 @@ limitations under the License.\n #include \"xla/python/ifrt/device.h\"\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/memory.h\"\n #include \"xla/python/ifrt/remap_plan.h\"\n #include \"xla/python/ifrt/shape.h\"\n@@ -51,6 +50,7 @@ limitations under the License.\n #include \"xla/python/ifrt/user_context.h\"\n #include \"xla/python/ifrt/value.h\"\n #include \"xla/service/computation_placer.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n@@ -112,7 +112,7 @@ class Client : public llvm::RTTIExtends<Client, llvm::RTTIRoot> {\n   // `on_done_with_host_buffer` will be called iff OK is returned.\n   //\n   // TODO(hyeontaek): Consider changing `on_done_with_host_buffer` into a\n-  // returned `Future<absl::Status>` for consistency with other IFRT APIs.\n+  // returned `tsl::Future<absl::Status>` for consistency with other IFRT APIs.\n   virtual absl::StatusOr<ArrayRef> MakeArrayFromHostBuffer(\n       const void* data, DType dtype, Shape shape,\n       std::optional<absl::Span<const int64_t>> byte_strides,\n@@ -277,7 +277,7 @@ class Client : public llvm::RTTIExtends<Client, llvm::RTTIRoot> {\n   // Note: this API currently accepts a span of `ArrayRef` for\n   // consistency with other APIs. We may change this to take a span of `Array*`\n   // instead to reflect its read-only semantics.\n-  virtual Future<> GetReadyFuture(absl::Span<const ValueRef> values) = 0;\n+  virtual tsl::Future<> GetReadyFuture(absl::Span<const ValueRef> values) = 0;\n \n   // Builds a tuple from a sequence of values.\n   virtual absl::StatusOr<tsl::RCReference<Tuple>> MakeTuple("
        },
        {
            "sha": "5c8672759ca2099102d24a868974b7c7e27376fd",
            "filename": "third_party/xla/xla/python/ifrt/executable.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fexecutable.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -35,11 +35,11 @@ limitations under the License.\n #include \"xla/python/ifrt/device.h\"\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/execute_options.pb.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/serdes.h\"\n #include \"xla/python/ifrt/serdes_default_version_accessor.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n #include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/xla_data.pb.h\"\n \n namespace xla {\n@@ -190,7 +190,7 @@ class LoadedExecutable\n   // compilation work in the background. Implementations must still ensure that\n   // all other methods can be used even without explicitly waiting for the ready\n   // future (e.g., via blocking).\n-  virtual Future<> GetReadyFuture() const = 0;\n+  virtual tsl::Future<> GetReadyFuture() const = 0;\n \n   // The following APIs are taken from `xla::PjRtExecutable` for fast\n   // prototyping.\n@@ -247,7 +247,7 @@ class LoadedExecutable\n   struct ExecuteResult {\n     // Resulting status of the execution. Filled only if\n     // `ExecuteOptions::fill_status` is true.\n-    Future<> status;\n+    tsl::Future<> status;\n     // Output arrays.\n     std::vector<ArrayRef> outputs;\n   };"
        },
        {
            "sha": "942b10b372874b7723f21808e00de53b76760fd5",
            "filename": "third_party/xla/xla/python/ifrt/future.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #ifndef XLA_PYTHON_IFRT_FUTURE_H_\n #define XLA_PYTHON_IFRT_FUTURE_H_\n \n+#include \"absl/base/macros.h\"\n #include \"xla/tsl/concurrency/future.h\"\n \n namespace xla {\n@@ -31,10 +32,10 @@ namespace ifrt {\n // * Awaiting on a `Future` should possibly be cancellable to lower overhead\n // when the `Future` value woudld be no longer useful or relevant.\n template <typename T = void>\n-using Future = ::tsl::Future<T>;\n+using Future ABSL_DEPRECATE_AND_INLINE() = ::tsl::Future<T>;\n \n template <typename T = void>\n-using Promise = ::tsl::Promise<T>;\n+using Promise ABSL_DEPRECATE_AND_INLINE() = ::tsl::Promise<T>;\n \n using ::tsl::JoinFutures;\n "
        },
        {
            "sha": "90578b36d8baa6a4abb3fef8cf718e2fd5585096",
            "filename": "third_party/xla/xla/python/ifrt/future_test.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 21,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture_test.cc?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -24,6 +24,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/types/span.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n \n namespace xla::ifrt {\n@@ -32,27 +33,27 @@ namespace {\n using ::testing::HasSubstr;\n \n TEST(FutureTest, JoinZeroFuture) {\n-  Future<> future = JoinFutures({});\n+  tsl::Future<> future = JoinFutures({});\n \n   TF_EXPECT_OK(future.Await());\n }\n \n TEST(FutureTest, JoinOneOkFuture) {\n-  auto [promise, future] = Future<>::MakePromise();\n-  std::vector<Future<>> futures = {std::move(future)};\n+  auto [promise, future] = tsl::Future<>::MakePromise();\n+  std::vector<tsl::Future<>> futures = {std::move(future)};\n \n-  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n+  tsl::Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n   ASSERT_FALSE(joined.IsReady());\n   promise.Set(absl::OkStatus());\n   TF_EXPECT_OK(joined.Await());\n }\n \n TEST(FutureTest, JoinOneFailingFuture) {\n-  auto [promise, future] = Future<>::MakePromise();\n-  std::vector<Future<>> futures = {std::move(future)};\n+  auto [promise, future] = tsl::Future<>::MakePromise();\n+  std::vector<tsl::Future<>> futures = {std::move(future)};\n \n-  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n+  tsl::Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n   ASSERT_FALSE(joined.IsReady());\n   promise.Set(absl::InvalidArgumentError(\"Some error\"));\n@@ -63,39 +64,39 @@ TEST(FutureTest, JoinOneFailingFuture) {\n \n TEST(FutureTest, JoinAllOkFutures) {\n   constexpr int kNumFutures = 3;\n-  std::vector<Promise<>> promises;\n-  std::vector<Future<>> futures;\n+  std::vector<tsl::Promise<>> promises;\n+  std::vector<tsl::Future<>> futures;\n   promises.reserve(kNumFutures);\n   futures.reserve(kNumFutures);\n   for (int i = 0; i < kNumFutures; ++i) {\n     std::tie(promises.emplace_back(), futures.emplace_back()) =\n-        Future<>::MakePromise();\n+        tsl::Future<>::MakePromise();\n   }\n \n-  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n+  tsl::Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n   ASSERT_FALSE(joined.IsReady());\n-  for (Promise<>& promise : promises) {\n+  for (tsl::Promise<>& promise : promises) {\n     promise.Set(absl::OkStatus());\n   }\n   TF_EXPECT_OK(joined.Await());\n }\n \n TEST(FutureTest, JoinAllFailingFutures) {\n   constexpr int kNumFutures = 3;\n-  std::vector<Promise<>> promises;\n-  std::vector<Future<>> futures;\n+  std::vector<tsl::Promise<>> promises;\n+  std::vector<tsl::Future<>> futures;\n   promises.reserve(kNumFutures);\n   futures.reserve(kNumFutures);\n   for (int i = 0; i < kNumFutures; ++i) {\n     std::tie(promises.emplace_back(), futures.emplace_back()) =\n-        Future<>::MakePromise();\n+        tsl::Future<>::MakePromise();\n   }\n \n-  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n+  tsl::Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n   ASSERT_FALSE(joined.IsReady());\n-  for (Promise<>& promise : promises) {\n+  for (tsl::Promise<>& promise : promises) {\n     promise.Set(absl::InvalidArgumentError(\"Some error\"));\n   }\n   EXPECT_THAT(joined.Await(),\n@@ -108,16 +109,16 @@ class JoinAllOkFuturesExceptForOneTest : public testing::TestWithParam<int> {};\n TEST_P(JoinAllOkFuturesExceptForOneTest, JoinAllOkFuturesExceptForOne) {\n   const int kNumFutures = 3;\n   const int failing_future_idx = GetParam();\n-  std::vector<Promise<>> promises;\n-  std::vector<Future<>> futures;\n+  std::vector<tsl::Promise<>> promises;\n+  std::vector<tsl::Future<>> futures;\n   promises.reserve(kNumFutures);\n   futures.reserve(kNumFutures);\n   for (int i = 0; i < kNumFutures; ++i) {\n     std::tie(promises.emplace_back(), futures.emplace_back()) =\n-        Future<>::MakePromise();\n+        tsl::Future<>::MakePromise();\n   }\n \n-  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n+  tsl::Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n   ASSERT_FALSE(joined.IsReady());\n   for (int i = 0; i < kNumFutures; ++i) {"
        },
        {
            "sha": "893a0ca63acfb8bd8eefd4f4957028af81366995",
            "filename": "third_party/xla/xla/python/ifrt/ir/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2FBUILD?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -511,6 +511,7 @@ cc_library(\n         \"//xla/python/ifrt\",\n         \"//xla/python/ifrt:remap_plan_proto_cc\",\n         \"//xla/python/ifrt/ir/transforms:utils\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/concurrency:ref_count\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\","
        },
        {
            "sha": "b71ac31a4b8daccac03c0c120e6c7b82ec0caf79",
            "filename": "third_party/xla/xla/python/ifrt/ir/program_interpreter.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Fprogram_interpreter.cc?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -46,7 +46,6 @@ limitations under the License.\n #include \"xla/python/ifrt/device_list.h\"\n #include \"xla/python/ifrt/dtype.h\"\n #include \"xla/python/ifrt/executable.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/ir/compiled_ifrt_ir_program.h\"\n #include \"xla/python/ifrt/ir/constants.h\"\n #include \"xla/python/ifrt/ir/ifrt_dialect.h\"\n@@ -57,6 +56,7 @@ limitations under the License.\n #include \"xla/python/ifrt/shape.h\"\n #include \"xla/python/ifrt/sharding.h\"\n #include \"xla/status_macros.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -175,7 +175,7 @@ struct Environment {\n   bool fill_status;\n   // Contains a future for each ifrt.CallOp that is a leaf (i.e., has no outputs\n   // or all its outputs are returned from the program).\n-  std::vector<xla::ifrt::Future<>> leaf_call_op_futures;\n+  std::vector<tsl::Future<>> leaf_call_op_futures;\n };\n \n absl::StatusOr<std::unique_ptr<ProgramInterpreter>> ProgramInterpreter::Create(\n@@ -261,7 +261,7 @@ absl::StatusOr<ExecuteResult> ProgramInterpreter::Execute(\n   VLOG(2) << \"Finished interpreting program: \" << program_->program_name;\n   ExecuteResult result;\n   if (env.fill_status) {\n-    result.status = JoinFutures(absl::MakeSpan(env.leaf_call_op_futures));\n+    result.status = tsl::JoinFutures(absl::MakeSpan(env.leaf_call_op_futures));\n   }\n   result.outputs = std::move(env.outputs);\n   return result;"
        },
        {
            "sha": "e1ee347dea015f759db7e6667cffc78c3b7fd82c",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2FBUILD?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -89,6 +89,7 @@ cc_library(\n         \"//xla/service:hlo_proto_cc\",\n         \"//xla/service/spmd/shardy:constants\",\n         \"//xla/service/spmd/shardy:utils\",\n+        \"//xla/tsl/concurrency:future\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:status\","
        },
        {
            "sha": "493b2276f2f0d312b41f9b4f7a23eb7aa18fa129",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/multi_threaded_atom_program_compiler.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -39,7 +39,6 @@ limitations under the License.\n #include \"xla/client/executable_build_options.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/python/ifrt/dtype.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/hlo/hlo_program.h\"\n #include \"xla/python/ifrt/ir/atom_program_compiler.h\"\n #include \"xla/python/ifrt/ir/constants.h\""
        },
        {
            "sha": "468c30ce09a27c9811f3cec26d1dd085b5ec9c6d",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/multi_threaded_atom_program_compiler.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -25,15 +25,15 @@ limitations under the License.\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/python/ifrt/compiler.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/ir/atom_program_compiler.h\"\n #include \"xla/python/ifrt/ir/ifrt_ops.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n \n namespace xla {\n namespace ifrt {\n \n-using CompileFuture = Future<AtomProgramCompileResult>;\n+using CompileFuture = tsl::Future<AtomProgramCompileResult>;\n \n // Wrapper around `AtomProgramCompiler` that offers multi-threaded dispatch\n // of atom program compilations."
        },
        {
            "sha": "5c1a69df61eefc407a14cb224a89f95a814af676",
            "filename": "third_party/xla/xla/python/ifrt/mock.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fmock.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -46,7 +46,6 @@ limitations under the License.\n #include \"xla/python/ifrt/dtype.h\"\n #include \"xla/python/ifrt/executable.h\"\n #include \"xla/python/ifrt/executable_serdes.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/host_callback.h\"\n #include \"xla/python/ifrt/index_domain.h\"\n #include \"xla/python/ifrt/memory.h\"\n@@ -58,6 +57,7 @@ limitations under the License.\n #include \"xla/python/ifrt/tuple.h\"\n #include \"xla/python/ifrt/user_context.h\"\n #include \"xla/python/ifrt/value.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -73,8 +73,8 @@ class MockArray : public llvm::RTTIExtends<MockArray, Array> {\n \n   // LINT.IfChange\n   MOCK_METHOD(Client*, client, (), (const, final));\n-  MOCK_METHOD(Future<>, GetReadyFuture, (), (const, final));\n-  MOCK_METHOD(Future<>, Delete, (), (final));\n+  MOCK_METHOD(tsl::Future<>, GetReadyFuture, (), (const, final));\n+  MOCK_METHOD(tsl::Future<>, Delete, (), (final));\n   MOCK_METHOD(bool, IsDeleted, (), (const, final));\n \n   MOCK_METHOD(DType, dtype, (), (const, final));\n@@ -91,7 +91,7 @@ class MockArray : public llvm::RTTIExtends<MockArray, Array> {\n               (final));\n   MOCK_METHOD(absl::StatusOr<ArrayRef>, FullyReplicatedShard,\n               (ArrayCopySemantics semantics), (final));\n-  MOCK_METHOD(Future<>, CopyToHostBuffer,\n+  MOCK_METHOD(tsl::Future<>, CopyToHostBuffer,\n               (void* data,\n                std::optional<absl::Span<const int64_t>> byte_strides,\n                ArrayCopySemantics semantics),\n@@ -151,8 +151,8 @@ class MockClient : public llvm::RTTIExtends<MockClient, Client> {\n               (absl::Span<ArrayRef> arrays, absl::Span<const ArraySpec> specs,\n                ArrayCopySemantics semantics),\n               (final));\n-  MOCK_METHOD(Future<>, GetReadyFuture, (absl::Span<const ValueRef> values),\n-              (final));\n+  MOCK_METHOD(tsl::Future<>, GetReadyFuture,\n+              (absl::Span<const ValueRef> values), (final));\n   MOCK_METHOD(absl::StatusOr<tsl::RCReference<Tuple>>, MakeTuple,\n               (absl::Span<ValueRef> values), (final));\n   MOCK_METHOD(absl::string_view, runtime_type, (), (const, final));\n@@ -327,7 +327,7 @@ class MockLoadedExecutable\n               executable_version, (), (const, final));\n   MOCK_METHOD(absl::StatusOr<std::string>, Serialize, (), (const, final));\n   MOCK_METHOD(UserContextRef, user_context, (), (const, final));\n-  MOCK_METHOD(Future<>, GetReadyFuture, (), (const, override));\n+  MOCK_METHOD(tsl::Future<>, GetReadyFuture, (), (const, override));\n   MOCK_METHOD(int, num_devices, (), (const, final));\n   MOCK_METHOD(int64_t, SizeOfGeneratedCodeInBytes, (), (const, final));\n   MOCK_METHOD(absl::StatusOr<CompiledMemoryStats>, GetCompiledMemoryStats, (),"
        },
        {
            "sha": "5571553d7616739cd15d3b539cecd1d1769d19b3",
            "filename": "third_party/xla/xla/python/ifrt/value.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fvalue.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/92f2630a9e3a928bed6cddda30e319ce7bf0b5b9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fvalue.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fvalue.h?ref=92f2630a9e3a928bed6cddda30e319ce7bf0b5b9",
            "patch": "@@ -20,8 +20,8 @@ limitations under the License.\n \n #include \"absl/status/status.h\"\n #include \"llvm/Support/ExtensibleRTTI.h\"\n-#include \"xla/python/ifrt/future.h\"\n #include \"xla/python/ifrt/user_context.h\"\n+#include \"xla/tsl/concurrency/future.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n@@ -48,7 +48,7 @@ class Value : public tsl::ReferenceCounted<Value>,\n \n   // Returns a future that becomes ready when the buffer is computed or has an\n   // error.\n-  virtual Future<> GetReadyFuture() const = 0;\n+  virtual tsl::Future<> GetReadyFuture() const = 0;\n \n   // Deletes the value from the devices. The operation may be asynchronous. The\n   // returned future will have the result of the deletion on the devices, and\n@@ -59,7 +59,7 @@ class Value : public tsl::ReferenceCounted<Value>,\n   // Deletion is idempotent. Deleting an already deleted value is allowed, and\n   // all the futures returned by different calls to Delete() will become ready\n   // with the same status.\n-  virtual Future<> Delete() = 0;\n+  virtual tsl::Future<> Delete() = 0;\n \n   // Returns whether the value has been enqueued for deletion from the devices.\n   virtual bool IsDeleted() const = 0;"
        }
    ],
    "stats": {
        "total": 112,
        "additions": 59,
        "deletions": 53
    }
}