{
    "author": "tensorflower-gardener",
    "message": "[XLA:MSA] Add an option to propagate memory space from fusion parameters instead of operands.\n\nPiperOrigin-RevId: 802645475",
    "sha": "5c62f74b41fe46fc0da3c465bf4702c69aa19eaf",
    "files": [
        {
            "sha": "daae5d0c7b83dda20e441988f75710ddf0c52247",
            "filename": "third_party/xla/xla/hlo/transforms/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD?ref=5c62f74b41fe46fc0da3c465bf4702c69aa19eaf",
            "patch": "@@ -182,6 +182,8 @@ xla_cc_test(\n     srcs = [\"memory_space_propagation_test.cc\"],\n     deps = [\n         \":memory_space_propagation\",\n+        \"//xla/hlo/analysis:hlo_dataflow_analysis\",\n+        \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/parser:hlo_parser\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/tsl/lib/core:status_test_util\","
        },
        {
            "sha": "720636beffa028395f8e6b8e1fe7c6926dc3f8cb",
            "filename": "third_party/xla/xla/hlo/transforms/memory_space_propagation.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation.cc?ref=5c62f74b41fe46fc0da3c465bf4702c69aa19eaf",
            "patch": "@@ -32,6 +32,30 @@ limitations under the License.\n \n namespace xla {\n \n+bool MemorySpacePropagation::RunOnComputation(HloComputation* computation) {\n+  CHECK(dataflow_analysis_ != nullptr);\n+  bool modified = false;\n+  // Propagate the parameter subshapes.\n+  for (int parameter_idx = 0; parameter_idx < computation->num_parameters();\n+       ++parameter_idx) {\n+    ShapeUtil::ForEachLeafShape(\n+        computation->parameter_instruction(parameter_idx)->shape(),\n+        [&](const Shape& sub_shape, const ShapeIndex& index) {\n+          modified |= Propagate(\n+              index, computation->parameter_instruction(parameter_idx),\n+              sub_shape);\n+        });\n+  }\n+  // Propagate output subshapes.\n+  ShapeUtil::ForEachLeafShape(\n+      computation->root_instruction()->shape(),\n+      [&](const Shape& sub_shape, const ShapeIndex& index) {\n+        modified |=\n+            Propagate(index, computation->root_instruction(), sub_shape);\n+      });\n+  return modified;\n+}\n+\n absl::StatusOr<bool> MemorySpacePropagation::Run(\n     HloModule* module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {"
        },
        {
            "sha": "33b4f08c4e31ec9edf84201d391a1dfb2b7cbf85",
            "filename": "third_party/xla/xla/hlo/transforms/memory_space_propagation.h",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation.h?ref=5c62f74b41fe46fc0da3c465bf4702c69aa19eaf",
            "patch": "@@ -16,13 +16,14 @@ limitations under the License.\n #ifndef XLA_HLO_TRANSFORMS_MEMORY_SPACE_PROPAGATION_H_\n #define XLA_HLO_TRANSFORMS_MEMORY_SPACE_PROPAGATION_H_\n \n-#include <cstdint>\n #include <memory>\n+#include <utility>\n \n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/analysis/hlo_dataflow_analysis.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/pass/hlo_pass_interface.h\"\n #include \"xla/shape.h\"\n@@ -33,13 +34,20 @@ namespace xla {\n // split config) in the layout to the fusion computations.\n class MemorySpacePropagation : public HloModulePass {\n  public:\n+  explicit MemorySpacePropagation(\n+      std::unique_ptr<HloDataflowAnalysis> dataflow_analysis = nullptr)\n+      : dataflow_analysis_(std::move(dataflow_analysis)) {}\n   ~MemorySpacePropagation() override = default;\n   absl::string_view name() const override { return \"memory-space-propagation\"; }\n   using HloPassInterface::Run;\n   absl::StatusOr<bool> Run(\n       HloModule* module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n \n+  // Propagates the memory space (and associated split config) in the layout to\n+  // a given fusion computation. Returns true if the computation is modified.\n+  bool RunOnComputation(HloComputation* computation);\n+\n  private:\n   // Given the shape index (operand or output) and its corresponding instruction\n   // in the fused computation (parameter or root), propagates the memory space"
        },
        {
            "sha": "e2a46b570a86d46a077ceda7f139fb96e8483a79",
            "filename": "third_party/xla/xla/hlo/transforms/memory_space_propagation_test.cc",
            "status": "modified",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5c62f74b41fe46fc0da3c465bf4702c69aa19eaf/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fmemory_space_propagation_test.cc?ref=5c62f74b41fe46fc0da3c465bf4702c69aa19eaf",
            "patch": "@@ -15,10 +15,15 @@ limitations under the License.\n \n #include \"xla/hlo/transforms/memory_space_propagation.h\"\n \n+#include <memory>\n+#include <utility>\n+\n #include <gtest/gtest.h>\n #include \"absl/hash/hash.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/analysis/hlo_dataflow_analysis.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/parser/hlo_parser.h\"\n #include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n@@ -37,6 +42,19 @@ class MemorySpacePropagationTest : public HloHardwareIndependentTestBase {\n     return verifier_.Run(module).status();\n   }\n \n+ protected:\n+  // Returns a dataflow analysis for the given module.\n+  std::unique_ptr<HloDataflowAnalysis> GetDataflowAnalysis(\n+      const HloModule& module) {\n+    if (auto status_or =\n+            HloDataflowAnalysis::Run(module, /*ssa_form=*/false,\n+                                     /*bitcast_defines_value=*/true);\n+        status_or.ok()) {\n+      return std::move(status_or.value());\n+    }\n+    return nullptr;\n+  }\n+\n  private:\n   HloVerifier verifier_;\n };\n@@ -416,5 +434,163 @@ TEST_F(MemorySpacePropagationTest, BitcastInFusion) {\n   EXPECT_EQ(absl::HashOf(*module), absl::HashOf(*ref));\n }\n \n+// This test tests RunOnComputation. The parameters do _not_ get the memory\n+// space propagated from the operands. The operations in the fusion get the\n+// memory space propagated from the parameters.\n+TEST_F(MemorySpacePropagationTest, RunOnComputationPropagateFromParameters) {\n+  absl::string_view hlo_string = R\"(\n+    HloModule NoMemorySpace\n+\n+    %fused_computation {\n+      %param_1.3 = s32[6]{0:T(128)S(1)} parameter(0)\n+      %param_2.3 = s32[6]{0:T(128)} parameter(1)\n+      %tuple = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) tuple(%param_1.3, %param_2.3)\n+      %gte_1.3 = s32[6]{0:T(128)} get-tuple-element(%tuple), index=0\n+      %neg_1.3 = s32[6]{0:T(128)} negate(%gte_1.3)\n+      ROOT %root = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) tuple(%neg_1.3, %param_2.3)\n+    }\n+    ENTRY %entry {\n+      %param0 = s32[6]{0:T(128)} parameter(0)\n+      %param1 = s32[6]{0:T(128)} parameter(1)\n+      %param1_copy = s32[6]{0:T(128)S(1)} copy(%param1)\n+      ROOT %fusion = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) fusion(%param0, %param1_copy), kind=kLoop, calls=%fused_computation\n+    }\n+  )\";\n+  absl::string_view expected_hlo_string = R\"(\n+    HloModule NoMemorySpace\n+\n+    %fused_computation {\n+      %param_1.3 = s32[6]{0:T(128)S(1)} parameter(0)\n+      %param_2.3 = s32[6]{0:T(128)} parameter(1)\n+      %tuple = (s32[6]{0:T(128)S(1)}, s32[6]{0:T(128)}) tuple(%param_1.3, %param_2.3)\n+      %gte_1.3 = s32[6]{0:T(128)S(1)} get-tuple-element(%tuple), index=0\n+      %neg_1.3 = s32[6]{0:T(128)} negate(%gte_1.3)\n+      ROOT %root = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) tuple(%neg_1.3, %param_2.3)\n+    }\n+    ENTRY %entry {\n+      %param0 = s32[6]{0:T(128)} parameter(0)\n+      %param1 = s32[6]{0:T(128)} parameter(1)\n+      %param1_copy = s32[6]{0:T(128)S(1)} copy(%param1)\n+      ROOT %fusion = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) fusion(%param0, %param1_copy), kind=kLoop, calls=%fused_computation\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  auto dataflow_analysis = GetDataflowAnalysis(*module);\n+  MemorySpacePropagation memory_space_propagation(std::move(dataflow_analysis));\n+  HloComputation* computation =\n+      module->GetComputationWithName(\"fused_computation\");\n+  EXPECT_TRUE(memory_space_propagation.RunOnComputation(computation));\n+  TF_ASSERT_OK_AND_ASSIGN(auto ref,\n+                          ParseAndReturnVerifiedModule(expected_hlo_string));\n+  EXPECT_EQ(absl::HashOf(*module), absl::HashOf(*ref));\n+}\n+\n+// This test tests that the parameters in nested fusions get the memory space\n+// propagated from the operands.\n+TEST_F(MemorySpacePropagationTest, RunOnComputationFromParametersNestedFusion) {\n+  absl::string_view hlo_string = R\"(\n+    HloModule NoMemorySpace\n+\n+    %nested_fusion {\n+      %param_1.3 = s32[6]{0:T(128)} parameter(0)\n+      ROOT %neg_1.3 = s32[6]{0:T(128)} negate(%param_1.3)\n+    }\n+\n+    %fused_computation {\n+      %param_1.3 = s32[6]{0:T(128)S(1)} parameter(0)\n+      %param_2.3 = s32[6]{0:T(128)} parameter(1)\n+      %tuple = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) tuple(%param_1.3, %param_2.3)\n+      %gte_1.3 = s32[6]{0:T(128)} get-tuple-element(%tuple), index=0\n+      %neg_1.3 = s32[6]{0:T(128)} fusion(%gte_1.3), kind=kLoop, calls=%nested_fusion\n+      ROOT %root = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) tuple(%neg_1.3, %param_2.3)\n+    }\n+\n+    ENTRY %entry {\n+      %param0 = s32[6]{0:T(128)} parameter(0)\n+      %param1 = s32[6]{0:T(128)} parameter(1)\n+      ROOT %fusion = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) fusion(%param0, %param1), kind=kLoop, calls=%fused_computation\n+    }\n+  )\";\n+  absl::string_view expected_hlo_string = R\"(\n+    HloModule NoMemorySpace\n+\n+    %nested_fusion {\n+      %param_1.3 = s32[6]{0:T(128)S(1)} parameter(0)\n+      ROOT %neg_1.3 = s32[6]{0:T(128)} negate(%param_1.3)\n+    }\n+\n+    %fused_computation {\n+      %param_1.3 = s32[6]{0:T(128)S(1)} parameter(0)\n+      %param_2.3 = s32[6]{0:T(128)} parameter(1)\n+      %tuple = (s32[6]{0:T(128)S(1)}, s32[6]{0:T(128)}) tuple(%param_1.3, %param_2.3)\n+      %gte_1.3 = s32[6]{0:T(128)S(1)} get-tuple-element(%tuple), index=0\n+      %neg_1.3 = s32[6]{0:T(128)} fusion(%gte_1.3), kind=kLoop, calls=%nested_fusion\n+      ROOT %root = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) tuple(%neg_1.3, %param_2.3)\n+    }\n+\n+    ENTRY %entry {\n+      %param0 = s32[6]{0:T(128)} parameter(0)\n+      %param1 = s32[6]{0:T(128)} parameter(1)\n+      ROOT %fusion = (s32[6]{0:T(128)}, s32[6]{0:T(128)}) fusion(%param0, %param1), kind=kLoop, calls=%fused_computation\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  auto dataflow_analysis = GetDataflowAnalysis(*module);\n+  MemorySpacePropagation memory_space_propagation(std::move(dataflow_analysis));\n+  HloComputation* computation =\n+      module->GetComputationWithName(\"fused_computation\");\n+  EXPECT_TRUE(memory_space_propagation.RunOnComputation(computation));\n+  TF_ASSERT_OK_AND_ASSIGN(auto ref,\n+                          ParseAndReturnVerifiedModule(expected_hlo_string));\n+  EXPECT_EQ(absl::HashOf(*module), absl::HashOf(*ref));\n+}\n+\n+// This test tests that the operations in the fusion get the memory space\n+// propagated from the output.\n+TEST_F(MemorySpacePropagationTest, RunOnComputationPropagateFromOutput) {\n+  absl::string_view hlo_string = R\"(\n+    HloModule NoMemorySpace\n+\n+    %fused_computation {\n+      %param_1.3 = s32[6]{0:T(128)} parameter(0)\n+      %param_2.3 = s32[6]{0:T(128)} parameter(1)\n+      %neg_1.3 = s32[6]{0:T(128)} negate(%param_1.3)\n+      ROOT %root = (s32[6]{0:T(128)S(1)}, s32[6]{0:T(128)}) tuple(%neg_1.3, %param_2.3)\n+    }\n+    ENTRY %entry {\n+      %param0 = s32[6]{0:T(128)} parameter(0)\n+      %param1 = s32[6]{0:T(128)} parameter(1)\n+      ROOT %fusion = (s32[6]{0:T(128)S(1)}, s32[6]{0:T(128)}) fusion(%param0, %param1), kind=kLoop, calls=%fused_computation\n+    }\n+  )\";\n+  absl::string_view expected_hlo_string = R\"(\n+    HloModule NoMemorySpace\n+\n+    %fused_computation {\n+      %param_1.3 = s32[6]{0:T(128)} parameter(0)\n+      %param_2.3 = s32[6]{0:T(128)} parameter(1)\n+      %neg_1.3 = s32[6]{0:T(128)S(1)} negate(%param_1.3)\n+      ROOT %root = (s32[6]{0:T(128)S(1)}, s32[6]{0:T(128)}) tuple(%neg_1.3, %param_2.3)\n+    }\n+    ENTRY %entry {\n+      %param0 = s32[6]{0:T(128)} parameter(0)\n+      %param1 = s32[6]{0:T(128)} parameter(1)\n+      ROOT %fusion = (s32[6]{0:T(128)S(1)}, s32[6]{0:T(128)}) fusion(%param0, %param1), kind=kLoop, calls=%fused_computation\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+  auto dataflow_analysis = GetDataflowAnalysis(*module);\n+  MemorySpacePropagation memory_space_propagation(std::move(dataflow_analysis));\n+  HloComputation* computation =\n+      module->GetComputationWithName(\"fused_computation\");\n+  EXPECT_TRUE(memory_space_propagation.RunOnComputation(computation));\n+  TF_ASSERT_OK_AND_ASSIGN(auto ref,\n+                          ParseAndReturnVerifiedModule(expected_hlo_string));\n+  EXPECT_EQ(absl::HashOf(*module), absl::HashOf(*ref));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 212,
        "additions": 211,
        "deletions": 1
    }
}