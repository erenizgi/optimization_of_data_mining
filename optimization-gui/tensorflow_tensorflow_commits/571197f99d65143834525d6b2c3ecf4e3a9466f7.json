{
    "author": "loislo",
    "message": "[XLA:GPU] Extend symbolic tile analysis to support `kScaledDot`.\n\nThis change introduces a helper function `IsSomeDot` to check for both `kDot` and `kScaledDot` opcodes. The analysis is updated to correctly handle the operand indices and dimension numbers for `kScaledDot` when determining contracting dimensions and extracting symbols from affine maps.\n\nPiperOrigin-RevId: 803018163",
    "sha": "571197f99d65143834525d6b2c3ecf4e3a9466f7",
    "files": [
        {
            "sha": "cedf2408ec28d07d267b0a60da0b1861235229d5",
            "filename": "third_party/xla/xla/service/gpu/model/symbolic_tile_analysis.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 12,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/571197f99d65143834525d6b2c3ecf4e3a9466f7/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fsymbolic_tile_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/571197f99d65143834525d6b2c3ecf4e3a9466f7/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fsymbolic_tile_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fsymbolic_tile_analysis.cc?ref=571197f99d65143834525d6b2c3ecf4e3a9466f7",
            "patch": "@@ -129,6 +129,11 @@ struct OutputTilingInfo {\n   }\n };\n \n+bool IsSomeDot(const HloInstruction* hlo) {\n+  return hlo->opcode() == HloOpcode::kDot ||\n+         hlo->opcode() == HloOpcode::kScaledDot;\n+}\n+\n llvm::SmallVector<int64_t> GetNumberOfTilesPerDimension(\n     const TiledHloInstruction& tiled_hlo_instr) {\n   llvm::SmallVector<int64_t> result;\n@@ -605,7 +610,7 @@ bool ShouldDerivationSimplifyPointDimensions(const HloFusionAdaptor& fusion) {\n       continue;\n     }\n \n-    if (instruction_adaptor.opcode() == HloOpcode::kDot) {\n+    if (IsSomeDot(&instruction_adaptor.instruction())) {\n       return false;\n     }\n \n@@ -671,7 +676,7 @@ absl::Status PopulateNestedParameters(\n       continue;\n     }\n \n-    if (instruction_adaptor.opcode() == HloOpcode::kDot) {\n+    if (IsSomeDot(&instruction_adaptor.instruction())) {\n       int64_t num_parameters = instruction_adaptor.instruction()\n                                    .dot_dimension_numbers()\n                                    .lhs_contracting_dimensions()\n@@ -894,7 +899,7 @@ std::vector<int64_t> InputSpaceForParameterMapping(\n \n   for (const auto& [hlo, num_parameters] : parameter_mapping) {\n     // TODO(b/419026602): handle reductions.\n-    if (hlo->opcode() == HloOpcode::kDot) {\n+    if (IsSomeDot(hlo)) {\n       auto contracting_dimensions =\n           hlo->dot_dimension_numbers().lhs_contracting_dimensions();\n       // First, we need to add the contracting dimensions of the `dot`\n@@ -1044,22 +1049,36 @@ IndexingMap InsertTilingParameterForContractingDimensions(\n   // TODO(b/419026602): handle reductions here as well once priority fusion can\n   // handle it. By adding a special path for reductions, we can handle them\n   // here as well, even without nests.\n-  if (consumer->opcode() == HloOpcode::kDot) {\n-    CHECK(operand_index == 0 || operand_index == 1);\n-    absl::Span<const int64_t> contracting_dimensions =\n-        operand_index == 0\n-            ? consumer->dot_dimension_numbers().lhs_contracting_dimensions()\n-            : consumer->dot_dimension_numbers().rhs_contracting_dimensions();\n+  if (IsSomeDot(consumer)) {\n+    absl::Span<const int64_t> contracting_dimensions;\n+    if (consumer->opcode() == HloOpcode::kScaledDot) {\n+      CHECK(operand_index >= 0 && operand_index <= 3);\n+      contracting_dimensions =\n+          operand_index <= 1\n+              ? consumer->dot_dimension_numbers().lhs_contracting_dimensions()\n+              : consumer->dot_dimension_numbers().rhs_contracting_dimensions();\n+    }\n+    if (consumer->opcode() == HloOpcode::kDot) {\n+      CHECK(operand_index == 0 || operand_index == 1);\n+      contracting_dimensions =\n+          operand_index == 0\n+              ? consumer->dot_dimension_numbers().lhs_contracting_dimensions()\n+              : consumer->dot_dimension_numbers().rhs_contracting_dimensions();\n+    }\n \n     absl::flat_hash_map<int64_t, int64_t> parameter_index_by_symbol_position;\n     std::vector<int64_t> symbols_to_remove;\n     parameter_index_by_symbol_position.reserve(contracting_dimensions.size());\n     symbols_to_remove.reserve(contracting_dimensions.size());\n     for (auto [parameter_index, contracting_dimension] :\n          llvm::enumerate(contracting_dimensions)) {\n-      auto symbol = mlir::dyn_cast<mlir::AffineSymbolExpr>(\n-          outermost_fusion_root_to_operand.GetAffineMap().getResult(\n-              contracting_dimension));\n+      auto affine_map = outermost_fusion_root_to_operand.GetAffineMap();\n+      auto result = affine_map.getResults()[contracting_dimension];\n+      auto symbol = mlir::dyn_cast<mlir::AffineSymbolExpr>(result);\n+      if (!symbol) {\n+        auto binary_expr = mlir::cast<mlir::AffineBinaryOpExpr>(result);\n+        symbol = mlir::dyn_cast<mlir::AffineSymbolExpr>(binary_expr.getLHS());\n+      }\n       // This can only occur if the wrong arguments were passed to this\n       // function, and our traversal logic is broken.\n       CHECK(symbol);  // Crash OK"
        },
        {
            "sha": "8c714cbb906400df56d7a202d9240dffbc8b8252",
            "filename": "third_party/xla/xla/service/gpu/model/symbolic_tile_analysis_test.cc",
            "status": "modified",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/571197f99d65143834525d6b2c3ecf4e3a9466f7/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fsymbolic_tile_analysis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/571197f99d65143834525d6b2c3ecf4e3a9466f7/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fsymbolic_tile_analysis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fsymbolic_tile_analysis_test.cc?ref=571197f99d65143834525d6b2c3ecf4e3a9466f7",
            "patch": "@@ -855,6 +855,68 @@ ENTRY main {\n   )\"));\n }\n \n+TEST_F(SymbolicTileAnalysisTest, ScaledDotOffsetIndexingIsCorrect) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+fusion {\n+  lhs = f8e4m3fn[128,64] parameter(0)\n+  lhs_scale = f8e8m0fnu[128,2] parameter(1)\n+  rhs = f8e4m3fn[64,128] parameter(2)\n+  rhs_scale = f8e8m0fnu[2,128] parameter(3)\n+  ROOT dot = f32[128,128] scaled-dot(lhs, lhs_scale, rhs, rhs_scale),\n+    lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+}\n+\n+ENTRY main {\n+  p0 = f8e4m3fn[128,64] parameter(0)\n+  p1 = f8e8m0fnu[128,2] parameter(1)\n+  p2 = f8e4m3fn[64,128] parameter(2)\n+  p3 = f8e8m0fnu[2,128] parameter(3)\n+  ROOT fusion = f32[128,128] fusion(p0, p1, p2, p3), kind=kLoop, calls=fusion\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n+  ASSERT_TRUE(analysis.has_value());\n+  const HloInstruction* dot_hlo =\n+      module->entry_computation()->root_instruction()->fused_expression_root();\n+  constexpr int64_t kContractingTileSize = 32;\n+  constexpr int64_t kLhsTileSize = 16;\n+  constexpr int64_t kRhsTileSize = 16;\n+  Tiling tiling(Tiling::TileMapping{\n+      {dot_hlo, {kContractingTileSize, kLhsTileSize, kRhsTileSize}}});\n+  TF_ASSERT_OK_AND_ASSIGN(TiledHloComputation tiled_hlo_computation,\n+                          analysis->ComputeTiledHloInstructions(\n+                              tiling,\n+                              /*constraints_are_known_satisfied=*/false,\n+                              /*compute_all_tile_offset_indexing_maps=*/true));\n+\n+  const TiledHloInstruction* dot = tiled_hlo_computation.GetRoots()[0];\n+  EXPECT_THAT(*dot, MatchTiledHloInstruction(\n+                        /*tile_sizes=*/{16, 16}, /*tile_strides=*/{1, 1},\n+                        /*tile_offsets_indexing=*/R\"(\n+    (pid_0) -> ((pid_0 floordiv 8) * 16, (pid_0 mod 8) * 16),\n+    domain:\n+    pid_0 in [0, 63]\n+  )\"));\n+\n+  const TiledHloInstruction* lhs = dot->operand(0);\n+  EXPECT_THAT(*lhs, MatchTiledHloInstruction(\n+                        /*tile_sizes=*/{16, 32}, /*tile_strides=*/{1, 1},\n+                        /*tile_offsets_indexing=*/R\"(\n+    (pid_0) -> ((pid_0 floordiv 8) * 16, 0),\n+    domain:\n+    pid_0 in [0, 63]\n+  )\"));\n+\n+  const TiledHloInstruction* rhs = dot->operand(2);\n+  EXPECT_THAT(*rhs, MatchTiledHloInstruction(\n+                        /*tile_sizes=*/{32, 16}, /*tile_strides=*/{1, 1},\n+                        /*tile_offsets_indexing=*/R\"(\n+    (pid_0) -> (0, (pid_0 mod 8) * 16),\n+    domain:\n+    pid_0 in [0, 63]\n+  )\"));\n+}\n+\n TEST_F(SymbolicTileAnalysisTest, DoesNotBailOutOnConstrainedReshape) {\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n                           ParseAndReturnVerifiedModule(R\"("
        }
    ],
    "stats": {
        "total": 105,
        "additions": 93,
        "deletions": 12
    }
}