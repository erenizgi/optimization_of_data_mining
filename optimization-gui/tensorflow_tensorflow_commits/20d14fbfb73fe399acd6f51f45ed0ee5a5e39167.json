{
    "author": "pschuh",
    "message": "Rollforward of Update PjRtStreamExecutorRawBuffer::CopyRawHostToDeviceAndReturnEvent to\nsupport staging host buffers (for non-pinned memory). This allows replacing the CopyRawToHost functions.\n\nReverts baf408c724fc745a53964b11d7fd642b30c85574\n\nPiperOrigin-RevId: 821872812",
    "sha": "20d14fbfb73fe399acd6f51f45ed0ee5a5e39167",
    "files": [
        {
            "sha": "69e32714202a6d8ed947b0b1e315d7b2b760a6e4",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 29,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=20d14fbfb73fe399acd6f51f45ed0ee5a5e39167",
            "patch": "@@ -718,11 +718,6 @@ void PjRtStreamExecutorBuffer::ScopedHold::ConvertUsageHold(\n   SetState(kConverted);\n }\n \n-bool PjRtStreamExecutorBuffer::IsOnCpu() const {\n-  return memory_space() != nullptr &&\n-         memory_space()->kind() == PinnedHostMemorySpace::kKind;\n-}\n-\n bool PjRtStreamExecutorClient::IsOnCpu(PjRtMemorySpace* memory_space) {\n   return memory_space->kind() == PinnedHostMemorySpace::kKind;\n }\n@@ -1404,30 +1399,6 @@ void PjRtStreamExecutorBuffer::ConvertUsageHold(TrackedDeviceBuffer* buffer,\n   DecrementUsage();\n }\n \n-absl::StatusOr<size_t> PjRtStreamExecutorBuffer::GetOnDeviceSizeInBytes()\n-    const {\n-  absl::MutexLock lock(&mu_);\n-  if (device_buffer() == nullptr || !device_buffer()->device_memory()) {\n-    return InvalidArgument(\n-        \"GetOnDeviceSizeInBytes called on deleted or donated buffer\");\n-  }\n-  return device_buffer()->device_memory()->mem().size();\n-}\n-\n-Future<> PjRtStreamExecutorBuffer::CopyRawToHost(void* dst, int64_t offset,\n-                                                 int64_t transfer_size) {\n-  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n-  return se_client->CopyRawSubBufferToHost(this, Future<void*>(dst), offset,\n-                                           transfer_size);\n-}\n-\n-Future<> PjRtStreamExecutorBuffer::CopyRawToHostFuture(Future<void*> dst,\n-                                                       int64_t offset,\n-                                                       int64_t transfer_size) {\n-  auto* se_client = tensorflow::down_cast<PjRtStreamExecutorClient*>(client());\n-  return se_client->CopyRawSubBufferToHost(this, dst, offset, transfer_size);\n-}\n-\n PjRtStreamExecutorBuffer::ScopedHold\n PjRtStreamExecutorBuffer::GetBufferWithHold(ScopedHold::Type type) {\n   absl::MutexLock lock(&mu_);"
        },
        {
            "sha": "9bd4291d9aaafa9c0d4e8f86ccd5738622a2f573",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=20d14fbfb73fe399acd6f51f45ed0ee5a5e39167",
            "patch": "@@ -600,14 +600,6 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n   PjRtStreamExecutorBuffer& operator=(const PjRtStreamExecutorBuffer&) = delete;\n   PjRtStreamExecutorBuffer& operator=(PjRtStreamExecutorBuffer&&) = delete;\n \n-  absl::StatusOr<size_t> GetOnDeviceSizeInBytes() const override;\n-\n-  Future<> CopyRawToHost(void* dst, int64_t offset,\n-                         int64_t transfer_size) override;\n-\n-  Future<> CopyRawToHostFuture(Future<void*> dst, int64_t offset,\n-                               int64_t transfer_size) override;\n-\n   // Drops the buffer's reference to its associated device memory, leaving the\n   // buffer in an invalid state. The memory will be freed lazily when all async\n   // operations using the buffer have completed, according to the allocation\n@@ -634,8 +626,6 @@ class PjRtStreamExecutorBuffer : public CommonPjRtBufferImpl {\n \n   Future<> GetReadyFuture() override;\n \n-  bool IsOnCpu() const override;\n-\n   // Similar to Delete, drops the buffer's reference to its associated device\n   // memory, leaving the buffer in an invalid state, but returns the\n   // TrackedDeviceBuffer rather than freeing the device memory, so that another"
        },
        {
            "sha": "16bf23b0b7c91fa4675588eb6c3a048a879ff70a",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 94,
            "deletions": 32,
            "changes": 126,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=20d14fbfb73fe399acd6f51f45ed0ee5a5e39167",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #include \"xla/pjrt/se_raw_buffer.h\"\n \n #include <cstdint>\n+#include <cstring>\n #include <memory>\n #include <optional>\n #include <utility>\n@@ -131,23 +132,55 @@ PjRtStreamExecutorRawBuffer::CopyRawHostToDeviceAndReturnEvent(\n     const void* src, int64_t offset, int64_t transfer_size) {\n   se::Stream* stream = local_device_->host_to_device_stream();\n   auto device_event = BufferSequencingEvent::Create(client_->thread_pool());\n-  client_->thread_pool()->Schedule(\n-      [client = client_, device_event, local_device = local_device_, stream,\n-       src, offset, transfer_size, buf = tsl::FormRef(this)]() mutable {\n-        se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n-        if (transfer_size < sub_buffer.size()) {\n-          sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n-        }\n-        client->WaitForAllocation(stream, *buf);\n-        auto status = stream->Memcpy(&sub_buffer, src, transfer_size);\n-        if (status.ok()) {\n-          status = client->AllocateAndRecordEvent(device_event, local_device,\n-                                                  stream);\n-        }\n-        if (!status.ok()) {\n-          client->SetEventAsError(device_event, status);\n+  client_->thread_pool()->Schedule([client = client_, device_event,\n+                                    local_device = local_device_, stream, src,\n+                                    offset, transfer_size,\n+                                    buf = tsl::FormRef(this)]() mutable {\n+    se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n+    if (transfer_size < sub_buffer.size()) {\n+      sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n+    }\n+    client->WaitForAllocation(stream, *buf);\n+    std::shared_ptr<void> staging_buffer;\n+    auto status = [&]() -> absl::Status {\n+      if (transfer_size > 0) {\n+        if (client->should_stage_host_to_device_transfers() &&\n+            !client->IsDmaMapped(src, transfer_size)) {\n+          if (client->host_memory_allocator() == nullptr) {\n+            return absl::InvalidArgumentError(\n+                \"host_memory_allocator should be initialized for \"\n+                \"staging buffer transfer.\");\n+          }\n+          void* ptr = client->host_memory_allocator()->AllocateRaw(\n+              tsl::Allocator::kAllocatorAlignment, transfer_size);\n+          staging_buffer = std::shared_ptr<void>(\n+              ptr,\n+              [host_memory_allocator = client->host_memory_allocator()](\n+                  void* ptr) { host_memory_allocator->DeallocateRaw(ptr); });\n+          auto copy_to_staging_buffer = [src, transfer_size,\n+                                         staging_buffer]() mutable {\n+            std::memcpy(staging_buffer.get(), src, transfer_size);\n+          };\n+          TF_RETURN_IF_ERROR(stream->DoHostCallback(copy_to_staging_buffer));\n+          TF_RETURN_IF_ERROR(\n+              stream->Memcpy(&sub_buffer, staging_buffer.get(), transfer_size));\n+        } else {\n+          TF_RETURN_IF_ERROR(stream->Memcpy(&sub_buffer, src, transfer_size));\n         }\n-      });\n+      }\n+      return absl::OkStatus();\n+    }();\n+    if (status.ok()) {\n+      status =\n+          client->AllocateAndRecordEvent(device_event, local_device, stream);\n+      if (staging_buffer) {\n+        device_event.AndThen([staging_buffer = std::move(staging_buffer)]() {});\n+      }\n+    }\n+    if (!status.ok()) {\n+      client->SetEventAsError(device_event, status);\n+    }\n+  });\n   return tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(\n       std::move(device_event), \"PjRtStreamExecutorRawBuffer\",\n       \"CopyRawHostToDevice\");\n@@ -158,23 +191,52 @@ PjRtStreamExecutorRawBuffer::CopyRawDeviceToHostAndReturnEvent(\n     void* dst, int64_t offset, int64_t transfer_size) {\n   se::Stream* stream = local_device_->GetDeviceToHostStream();\n   auto device_event = BufferSequencingEvent::Create(client_->thread_pool());\n-  client_->thread_pool()->Schedule(\n-      [client = client_, device_event, local_device = local_device_, stream,\n-       dst, offset, transfer_size, buf = tsl::FormRef(this)]() mutable {\n-        se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n-        if (transfer_size < sub_buffer.size()) {\n-          sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n-        }\n-        client->WaitForAllocation(stream, *buf);\n-        auto status = stream->Memcpy(dst, sub_buffer, transfer_size);\n-        if (status.ok()) {\n-          status = client->AllocateAndRecordEvent(device_event, local_device,\n-                                                  stream);\n-        }\n-        if (!status.ok()) {\n-          client->SetEventAsError(device_event, status);\n+  client_->thread_pool()->Schedule([client = client_, device_event,\n+                                    local_device = local_device_, stream, dst,\n+                                    offset, transfer_size,\n+                                    buf = tsl::FormRef(this)]() mutable {\n+    se::DeviceMemoryBase sub_buffer = buf->device_buffer_->mem();\n+    if (transfer_size < sub_buffer.size()) {\n+      sub_buffer = sub_buffer.GetByteSlice(offset, transfer_size);\n+    }\n+    client->WaitForAllocation(stream, *buf);\n+    auto status = [&]() -> absl::Status {\n+      if (transfer_size > 0) {\n+        if (client->should_stage_host_to_device_transfers() &&\n+            !client->IsDmaMapped(dst, transfer_size)) {\n+          if (client->host_memory_allocator() == nullptr) {\n+            return absl::InvalidArgumentError(\n+                \"host_memory_allocator should be initialized for \"\n+                \"staging buffer transfer.\");\n+          }\n+          void* ptr = client->host_memory_allocator()->AllocateRaw(\n+              tsl::Allocator::kAllocatorAlignment, transfer_size);\n+          std::shared_ptr<void> staging_buffer = std::shared_ptr<void>(\n+              ptr,\n+              [host_memory_allocator = client->host_memory_allocator()](\n+                  void* ptr) { host_memory_allocator->DeallocateRaw(ptr); });\n+          TF_RETURN_IF_ERROR(\n+              stream->Memcpy(staging_buffer.get(), sub_buffer, transfer_size));\n+          auto copy_from_staging_buffer = [dst, transfer_size,\n+                                           staging_buffer]() mutable {\n+            std::memcpy(dst, staging_buffer.get(), transfer_size);\n+          };\n+          // TODO(parkers): This failing maybe consitutes a race.\n+          TF_RETURN_IF_ERROR(stream->DoHostCallback(copy_from_staging_buffer));\n+        } else {\n+          TF_RETURN_IF_ERROR(stream->Memcpy(dst, sub_buffer, transfer_size));\n         }\n-      });\n+      }\n+      return absl::OkStatus();\n+    }();\n+    if (status.ok()) {\n+      status =\n+          client->AllocateAndRecordEvent(device_event, local_device, stream);\n+    }\n+    if (!status.ok()) {\n+      client->SetEventAsError(device_event, status);\n+    }\n+  });\n   return tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(\n       std::move(device_event), \"PjRtStreamExecutorRawBuffer\",\n       \"CopyRawDeviceToHost\");"
        },
        {
            "sha": "ffaeeaca0927c075605f7493f88389b2593eb9c9",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/20d14fbfb73fe399acd6f51f45ed0ee5a5e39167/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc?ref=20d14fbfb73fe399acd6f51f45ed0ee5a5e39167",
            "patch": "@@ -226,6 +226,9 @@ TrackedDeviceBuffer::GetAsyncValueDefinitionEvents() {\n \n tsl::RCReference<CommonPjRtRawBuffer> TrackedDeviceBuffer::GetRawBuffer(\n     PjRtMemorySpace* memory_space) {\n+  if (!device_memory_) {\n+    return tsl::RCReference<CommonPjRtRawBuffer>();\n+  }\n   return tsl::MakeRef<PjRtStreamExecutorRawBuffer>(\n       tensorflow::down_cast<PjRtStreamExecutorClient*>(memory_space->client()),\n       memory_space,"
        }
    ],
    "stats": {
        "total": 168,
        "additions": 97,
        "deletions": 71
    }
}