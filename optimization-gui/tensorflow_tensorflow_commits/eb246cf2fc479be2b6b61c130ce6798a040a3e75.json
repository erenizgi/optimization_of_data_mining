{
    "author": "pizzud",
    "message": "tests: Split testFloatOps and cast-related tests out to their own targets.\n\nThese cases are much slower than the rest of unary_ops_test, especially in\ncoverage mode.\n\nPiperOrigin-RevId: 807956691",
    "sha": "eb246cf2fc479be2b6b61c130ce6798a040a3e75",
    "files": [
        {
            "sha": "b2b2a2dd8732efe6e3f660f08fd1c1c52d833a7c",
            "filename": "tensorflow/compiler/tests/BUILD",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftests%2FBUILD?ref=eb246cf2fc479be2b6b61c130ce6798a040a3e75",
            "patch": "@@ -188,6 +188,9 @@ tf_xla_combined_py_test(\n     name = \"combined_ops_test_e\",\n     size = \"medium\",\n     timeout = \"long\",\n+    exec_properties = {\n+        \"cpp_link.mem\": \"16g\",\n+    },\n     package = \"tensorflow.compiler.tests\",\n     tags = [\n         \"no_cuda_asan\",  # times out in individual tests\n@@ -214,6 +217,9 @@ tf_xla_combined_py_test(\n     # #TODO(b/286470564): Remove once the bug is fixed.\n     # disable_tpu_tfrt = True,\n     # copybara:uncomment_end\n+    exec_properties = {\n+        \"cpp_link.mem\": \"16g\",\n+    },\n     package = \"tensorflow.compiler.tests\",\n     tags = [\n         \"no_pip\",  # TODO(b/149738646): fix pip install so these tests run on kokoro pip\n@@ -222,10 +228,29 @@ tf_xla_combined_py_test(\n         # go/keep-sorted start\n         \":add_n_test_lib\",\n         \":cond_test_lib\",\n+        \":float_ops_test_lib\",\n         \":while_test_lib\",\n         # go/keep-sorted end\n     ],\n )\n+\n+tf_xla_combined_py_test(\n+    name = \"combined_ops_test_g\",\n+    size = \"medium\",\n+    timeout = \"long\",\n+    exec_properties = {\n+        \"cpp_link.mem\": \"16g\",\n+    },\n+    package = \"tensorflow.compiler.tests\",\n+    tags = [\n+        \"no_pip\",  # TODO(b/149738646): fix pip install so these tests run on kokoro pip\n+    ],\n+    tests = [\n+        # go/keep-sorted start\n+        \":cast_test_lib\",\n+        # go/keep-sorted end\n+    ],\n+)\n #LINT.ThenChange(:individual_tests)\n \n #LINT.IfChange(individual_tests)\n@@ -1791,6 +1816,38 @@ tf_xla_py_strict_test(\n     ],\n )\n \n+tf_xla_py_strict_test(\n+    name = \"float_ops_test\",\n+    size = \"medium\",\n+    srcs = [\"float_ops_test.py\"],\n+    tags = [\n+        \"no_cuda_asan\",  # times out\n+        \"no_pip\",  # TODO(b/149738646): fix pip install so these tests run on kokoro pip\n+        \"noasan\",  #times out\n+        \"notap\",\n+    ],\n+    deps = [\n+        \":xla_test\",\n+        \"//tensorflow/python/ops:math_ops\",\n+        \"//tensorflow/python/ops:nn_ops\",\n+        \"//tensorflow/python/platform:test\",\n+        \"//third_party/py/numpy\",\n+    ],\n+)\n+\n+tf_xla_py_strict_test(\n+    name = \"cast_test\",\n+    size = \"medium\",\n+    srcs = [\"cast_test.py\"],\n+    deps = [\n+        \":xla_test\",\n+        \"//tensorflow/python/framework:dtypes\",\n+        \"//tensorflow/python/ops:math_ops\",\n+        \"//tensorflow/python/platform:test\",\n+        \"//third_party/py/numpy\",\n+    ],\n+)\n+\n tf_xla_py_strict_test(\n     name = \"fused_batchnorm_test\",\n     size = \"medium\","
        },
        {
            "sha": "5ac655f3597a612c8786d89c82e53e20c10a41d4",
            "filename": "tensorflow/compiler/tests/build_defs.bzl",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Fbuild_defs.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Fbuild_defs.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftests%2Fbuild_defs.bzl?ref=eb246cf2fc479be2b6b61c130ce6798a040a3e75",
            "patch": "@@ -139,6 +139,10 @@ def tf_xla_py_test(\n                 # version.\n                 continue\n \n+            # Rules may set exec_properties, but Google has internal\n+            # exec_properties values so they don't merge easily. Just strip them\n+            # all for now.\n+            kwargs.pop(\"exec_properties\", {})\n             test_rule(\n                 name = updated_name,\n                 srcs = srcs,"
        },
        {
            "sha": "bc35db4e05f7d5c68e5e01b65b7b2a49e5e76daa",
            "filename": "tensorflow/compiler/tests/cast_test.py",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Fcast_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Fcast_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftests%2Fcast_test.py?ref=eb246cf2fc479be2b6b61c130ce6798a040a3e75",
            "patch": "@@ -0,0 +1,122 @@\n+# Copyright 2025 The OpenXLA Authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+import platform\n+\n+import numpy as np\n+\n+from tensorflow.compiler.tests import xla_test\n+from tensorflow.python.framework import dtypes\n+from tensorflow.python.ops import math_ops\n+from tensorflow.python.platform import googletest\n+\n+\n+class CastTest(xla_test.XLATestCase):\n+\n+  def test_cast(self):\n+    types = {\n+        dtypes.bool,\n+        dtypes.float32,\n+        dtypes.float64,\n+        dtypes.complex64,\n+        dtypes.int32,\n+        dtypes.int64,\n+        dtypes.uint32,\n+        dtypes.uint64,\n+    }\n+    for src_type in types:\n+      for dst_type in types:\n+        self._test_cast(src_type, dst_type)\n+\n+  def test_cast_fp8(self):\n+    if platform.system() == \"Darwin\":\n+      # TODO(b/271327511): Fix issue where casts to FP8 very rarely result in\n+      # NaN on Mac\n+      self.skipTest(\"Casts to FP8 sometimes result in NaN on Mac\")\n+    fp8_types = {\n+        dtypes.float8_e5m2,\n+        dtypes.float8_e4m3fn,\n+        dtypes.float8_e4m3fnuz,\n+        dtypes.float8_e4m3b11fnuz,\n+        dtypes.float8_e5m2fnuz,\n+    }\n+    other_types = {\n+        dtypes.bool,\n+        dtypes.float32,\n+        dtypes.float64,\n+        dtypes.complex64,\n+        dtypes.int32,\n+        dtypes.int64,\n+        dtypes.uint32,\n+        dtypes.uint64,\n+    }\n+    for fp8_type in fp8_types:\n+      for other_type in other_types | fp8_types:\n+        self._test_cast(fp8_type, other_type)\n+        self._test_cast(other_type, fp8_type)\n+\n+  def _test_cast(self, src_type, dst_type):\n+    with self.subTest(src_type=src_type, dst_type=dst_type):\n+      shapes = [[], [4], [2, 3], [2, 0, 4]]\n+      src_np_dtype = src_type.as_numpy_dtype\n+      dst_np_dtype = dst_type.as_numpy_dtype\n+\n+      for shape in shapes:\n+        src = np.arange(np.prod(shape)).astype(src_np_dtype)\n+\n+        if src_type in self.complex_tf_types:\n+          src += (np.arange(np.prod(shape)) * 2j).astype(src_np_dtype)\n+        src = src.reshape(shape)\n+        dst = src.astype(dst_np_dtype)\n+        self.assert_op_output_matches_expected(\n+            lambda x, dst_type=dst_type: math_ops.cast(x, dst_type),\n+            src,\n+            expected=dst,\n+        )\n+\n+      # Check special values.\n+      if src_type.is_integer:\n+        imin = np.iinfo(src_np_dtype).min\n+        imax = np.iinfo(src_np_dtype).max\n+        if src_type.is_unsigned:\n+          src = np.array([imin, imax, 0, 1], dtype=src_np_dtype)\n+        else:\n+          src = np.array([imin, imax, 0, 1, -1], dtype=src_np_dtype)\n+      elif src_type in self.float_tf_types:\n+        if dst_type.is_integer:\n+          imin = np.iinfo(dst_np_dtype).min\n+          imax = np.iinfo(dst_np_dtype).max // 2\n+          src = np.array([imin, imax, 0, 1], dtype=src_np_dtype)\n+        elif dst_type in self.float_tf_types:\n+          fmin = np.finfo(dst_np_dtype).min\n+          fmax = np.finfo(dst_np_dtype).max\n+          tiny = np.finfo(dst_np_dtype).tiny\n+          eps = np.finfo(dst_np_dtype).eps\n+          src = np.array(\n+              [fmin, fmax, np.nan, eps, -eps, tiny, -tiny, np.inf, -np.inf],\n+              dtype=src_np_dtype,\n+          )\n+      dst = src.astype(dst_np_dtype)\n+      self.assert_op_output_matches_expected(\n+          lambda x, dst_type=dst_type: math_ops.cast(x, dst_type),\n+          src,\n+          expected=dst,\n+      )\n+\n+  def test_give_me_a_name(self):\n+    pass\n+\n+\n+if __name__ == \"__main__\":\n+  googletest.main()"
        },
        {
            "sha": "d8743016c20756019b09679c21c2d72b5a193553",
            "filename": "tensorflow/compiler/tests/float_ops_test.py",
            "status": "added",
            "additions": 472,
            "deletions": 0,
            "changes": 472,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Ffloat_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Ffloat_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftests%2Ffloat_ops_test.py?ref=eb246cf2fc479be2b6b61c130ce6798a040a3e75",
            "patch": "@@ -0,0 +1,472 @@\n+# Copyright 2025 The OpenXLA Authors.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+import numpy as np\n+\n+from tensorflow.compiler.tests import xla_test\n+from tensorflow.python.ops import math_ops\n+from tensorflow.python.ops import nn_ops\n+from tensorflow.python.platform import googletest\n+\n+\n+class FloatOpsTest(xla_test.XLATestCase):\n+\n+  def test_float_ops(self):\n+    for dtype in self.float_types:\n+      x = np.arange(-0.90, 0.90, 0.25)\n+      self.assert_op_output_matches_expected(\n+          math_ops.acos, x.astype(dtype), expected=np.arccos(x).astype(dtype)\n+      )\n+      self.assert_op_output_matches_expected(\n+          math_ops.asin, x.astype(dtype), expected=np.arcsin(x).astype(dtype)\n+      )\n+      x = np.arange(-3, 3).reshape(1, 3, 2)\n+      self.assert_op_output_matches_expected(\n+          math_ops.atan, x.astype(dtype), expected=np.arctan(x).astype(dtype)\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.acosh,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n+          expected=np.array(\n+              [0, 1.3169579, 1.76274717, 2.06343707], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.asinh,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n+          expected=np.array(\n+              [0.88137359, 1.44363548, 1.81844646, 2.09471255], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.atanh,\n+          np.array([0.1, 0.2, 0.3, 0.4], dtype=dtype),\n+          expected=np.array(\n+              [0.10033535, 0.20273255, 0.3095196, 0.42364893], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.ceil,\n+          np.array([[-1.7, 1.2]], dtype=dtype),\n+          expected=np.array([[-1, 2]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.cosh,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n+          expected=np.array(\n+              [1.54308063, 3.76219569, 10.067662, 27.30823284], dtype=dtype\n+          ),\n+      )\n+\n+      # Disable float16 testing for now\n+      if dtype != np.float16:\n+        x = np.arange(-10, 10, 1).astype(dtype)\n+        with self.session() as session:\n+          erf_x = session.run(math_ops.erf(x))\n+          erfc_x = session.run(math_ops.erfc(x))\n+\n+        self.assert_op_output_matches_expected(math_ops.erf, x, expected=erf_x)\n+        self.assert_op_output_matches_expected(\n+            math_ops.erfc, x, expected=erfc_x\n+        )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.exp,\n+          np.array([[-1, 1]], dtype=dtype),\n+          expected=np.array([[0.36787945, 2.7182817]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.expm1,\n+          np.array([[-1, 1]], dtype=dtype),\n+          expected=np.array([[-0.63212056, 1.71828183]], dtype=dtype),\n+          rtol=1e-5,\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.floor,\n+          np.array([[-1.7, 1.2]], dtype=dtype),\n+          expected=np.array([[-2, 1]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.is_finite,\n+          np.array(\n+              [[-np.inf, -2, -1, 0, 0.5, 1, 2, np.inf, np.nan]], dtype=dtype\n+          ),\n+          expected=np.array([[0, 1, 1, 1, 1, 1, 1, 0, 0]], dtype=np.bool_),\n+      )\n+\n+      # Tests for tf.nn ops.\n+      self.assert_op_output_matches_expected(\n+          nn_ops.l2_loss, np.array([[[]]], dtype=dtype), expected=dtype(0)\n+      )\n+\n+      self.assert_op_output_matches_expected(nn_ops.l2_loss, dtype(4), dtype(8))\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.l2_loss, np.array([[-2, 4]], dtype=dtype), expected=dtype(10)\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.reciprocal,\n+          np.array([[1, 2]], dtype=dtype),\n+          expected=np.array([[1, 0.5]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.log,\n+          np.array([[1, 2]], dtype=dtype),\n+          expected=np.array([[0, 0.69314718]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.sin,\n+          np.array([[1, 2]], dtype=dtype),\n+          expected=np.array([[0.841478, 0.909302]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.cos,\n+          np.array([[1, 2]], dtype=dtype),\n+          expected=np.array([[0.540297, -0.41614]], dtype=dtype),\n+      )\n+\n+      # Confirm that log1p will remain precise across a range of small values.\n+      self.assert_op_output_matches_expected(\n+          math_ops.log1p,\n+          np.array(\n+              [[1e-14, 1e-15, 0.6, 2] + [x * 1e-5 for x in range(1, 20)]],\n+              dtype=dtype,\n+          ),\n+          expected=np.log1p(\n+              np.array(\n+                  [[1e-14, 1e-15, 0.6, 2] + [x * 1e-5 for x in range(1, 20)]],\n+                  dtype=dtype,\n+              )\n+          ).astype(dtype),\n+          rtol=1e-15 if dtype == np.float64 else 1e-4,\n+          atol=1e-15 if dtype == np.float64 else 1e-4,\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.rint,\n+          np.array(\n+              [\n+                  [-1.7, 1.2, 4.0, 0.0],\n+                  [-3.5, -2.5, -1.5, -0.5],\n+                  [0.5, 1.5, 2.5, 3.5],\n+              ],\n+              dtype=dtype,\n+          ),\n+          expected=np.array(\n+              [[-2, 1, 4, 0], [-4, -2, -2, 0], [0, 2, 2, 4]], dtype=dtype\n+          ),\n+      )\n+      self.assert_op_output_matches_expected(\n+          math_ops.round,\n+          np.array(\n+              [\n+                  [-1.7, 1.2, 4.0, 0.0],\n+                  [-3.5, -2.5, -1.5, -0.5],\n+                  [0.5, 1.5, 2.5, 3.5],\n+              ],\n+              dtype=dtype,\n+          ),\n+          expected=np.array(\n+              [[-2, 1, 4, 0], [-4, -2, -2, 0], [0, 2, 2, 4]], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.rsqrt,\n+          np.array([[4, 16]], dtype=dtype),\n+          expected=np.array([[0.5, 0.25]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.sigmoid,\n+          np.array([[1, 1, 1, 1], [1, 2, 3, 4]], dtype=dtype),\n+          expected=np.array(\n+              [\n+                  [0.7310586, 0.7310586, 0.7310586, 0.7310586],\n+                  [0.7310586, 0.880797, 0.95257413, 0.98201376],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.sigmoid,\n+          np.array([-300, -150, 0, 150, 300], dtype=dtype),\n+          expected=np.array([0, 0, 0.5, 1, 1], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.sinh,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n+          expected=np.array(\n+              [1.17520119, 3.62686041, 10.01787493, 27.2899172], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.sqrt,\n+          np.array([[4, 9]], dtype=dtype),\n+          expected=np.array([[2, 3]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.tan,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n+          expected=np.array(\n+              [1.55740772, -2.18503986, -0.14254654, 1.15782128], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.tanh,\n+          np.array(\n+              [[1, 2, 3, 4], [np.inf, -np.inf, np.nan, 20], [19, -19, 22, -22]],\n+              dtype=dtype,\n+          ),\n+          expected=np.array(\n+              [\n+                  [0.76159418, 0.96402758, 0.99505478, 0.99932933],\n+                  [1.0, -1.0, np.nan, 1.0],\n+                  [1.0, -1.0, 1.0, -1.0],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.log_softmax,\n+          np.array([[1, 1, 1, 1], [1, 2, 3, 4]], dtype=dtype),\n+          expected=np.array(\n+              [\n+                  [-1.3862944, -1.3862944, -1.3862944, -1.3862944],\n+                  [-3.4401896, -2.4401896, -1.4401897, -0.44018969],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.elu,\n+          np.array([[-1, 0, 1, -1e-6]], dtype=dtype),\n+          expected=np.array([[-0.63212056, 0, 1, -9.999995e-07]], dtype=dtype),\n+          rtol=1e-5,\n+          atol=1e-6,\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.selu,\n+          np.array([[-1, 0, 1, -1e-5]], dtype=dtype),\n+          expected=np.array(\n+              [[-1.11133074, 0.0, 1.05070099, -1.758090550379974e-05]],\n+              dtype=dtype,\n+          ),\n+          rtol=1e-5,\n+          atol=1e-6,\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.relu,\n+          np.array([[-1, 1]], dtype=dtype),\n+          expected=np.array([[0, 1]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.relu6,\n+          np.array([[-0.05, 6.05, 5]], dtype=dtype),\n+          expected=np.array([[0, 6, 5]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.leaky_relu,\n+          np.array([[-2, -1, 0, 1, 2]], dtype=dtype),\n+          expected=np.array([[-0.4, -0.2, 0.0, 1.0, 2.0]], dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.softmax,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n+          expected=np.array(\n+              [0.032058604, 0.087144323, 0.23688284, 0.64391428], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.softmax,\n+          np.array([[1, 1, 1, 1], [1, 2, 3, 4]], dtype=dtype),\n+          expected=np.array(\n+              [\n+                  [0.25, 0.25, 0.25, 0.25],\n+                  [0.032058604, 0.087144323, 0.23688284, 0.64391428],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.softmax,\n+          np.array([[[1, 1], [1, 1]], [[1, 2], [3, 4]]], dtype=dtype),\n+          expected=np.array(\n+              [\n+                  [[0.5, 0.5], [0.5, 0.5]],\n+                  [[0.26894142, 0.73105858], [0.26894142, 0.73105858]],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          nn_ops.softsign,\n+          np.array([[-2, -1, 0, 1, 2]], dtype=dtype),\n+          expected=np.array(\n+              [[-0.66666669, -0.5, 0, 0.5, 0.66666669]], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.sign,\n+          np.array(\n+              [[-2.0, -1.0, -0.0, +0.0, 1.0, 2.0, float(\"nan\")]], dtype=dtype\n+          ),\n+          expected=np.array(\n+              [[-1.0, -1.0, -0.0, +0.0, 1.0, 1.0, float(\"nan\")]], dtype=dtype\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.is_finite,\n+          np.array(\n+              [[42, float(\"inf\"), -123], [float(\"nan\"), 0, -0.0]], dtype=dtype\n+          ),\n+          expected=np.array(\n+              [[True, False, True], [False, True, True]], dtype=np.bool_\n+          ),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.lgamma,\n+          np.array(0.5, dtype=dtype),\n+          expected=np.array(np.log(np.pi) / 2, dtype=dtype),\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.lgamma,\n+          np.array(\n+              [\n+                  [1, 2, 3],\n+                  [4, 5, 6],\n+                  [1 / 2, 3 / 2, 5 / 2],\n+                  [-3 / 2, -7 / 2, -11 / 2],\n+              ],\n+              dtype=dtype,\n+          ),\n+          expected=np.array(\n+              [\n+                  [0, 0, np.log(2.0)],\n+                  [np.log(6.0), np.log(24.0), np.log(120)],\n+                  [\n+                      np.log(np.pi) / 2,\n+                      np.log(np.pi) / 2 - np.log(2),\n+                      np.log(np.pi) / 2 - np.log(4) + np.log(3),\n+                  ],\n+                  [\n+                      np.log(np.pi) / 2 - np.log(3) + np.log(4),\n+                      np.log(np.pi) / 2 - np.log(105) + np.log(16),\n+                      np.log(np.pi) / 2 - np.log(10395) + np.log(64),\n+                  ],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+      # The actual result is complex. Take the real part.\n+      self.assert_op_output_matches_expected(\n+          math_ops.lgamma,\n+          np.array([-1 / 2, -5 / 2, -9 / 2], dtype=dtype),\n+          expected=np.array(\n+              [\n+                  np.log(np.pi) / 2 + np.log(2),\n+                  np.log(np.pi) / 2 - np.log(15) + np.log(8),\n+                  np.log(np.pi) / 2 - np.log(945) + np.log(32),\n+              ],\n+              dtype=dtype,\n+          ),\n+          atol=1e-4,\n+      )\n+\n+      self.assert_op_output_matches_expected(\n+          math_ops.digamma,\n+          np.array(\n+              [\n+                  [1.0, 0.5, 1 / 3.0],\n+                  [0.25, 1 / 6.0, 0.125],\n+                  [2.0, 3.0, 4.0],\n+                  [6.0, 8.0, 9.0],\n+              ],\n+              dtype=dtype,\n+          ),\n+          expected=np.array(\n+              [\n+                  [\n+                      -np.euler_gamma,\n+                      -2 * np.log(2) - np.euler_gamma,\n+                      -np.pi / 2 / np.sqrt(3)\n+                      - 3 * np.log(3) / 2\n+                      - np.euler_gamma,\n+                  ],\n+                  [\n+                      -np.pi / 2 - 3 * np.log(2) - np.euler_gamma,\n+                      -np.pi * np.sqrt(3) / 2\n+                      - 2 * np.log(2)\n+                      - 3 * np.log(3) / 2\n+                      - np.euler_gamma,\n+                      -np.pi / 2\n+                      - 4 * np.log(2)\n+                      - (\n+                          np.pi\n+                          + np.log(2 + np.sqrt(2))\n+                          - np.log(2 - np.sqrt(2))\n+                      )\n+                      / np.sqrt(2)\n+                      - np.euler_gamma,\n+                  ],\n+                  [\n+                      1 - np.euler_gamma,\n+                      1.5 - np.euler_gamma,\n+                      11 / 6.0 - np.euler_gamma,\n+                  ],\n+                  [\n+                      137 / 60.0 - np.euler_gamma,\n+                      363 / 140.0 - np.euler_gamma,\n+                      761 / 280.0 - np.euler_gamma,\n+                  ],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+\n+if __name__ == \"__main__\":\n+  googletest.main()"
        },
        {
            "sha": "fad9e5b29399fc1042ce1e9b28bb85be06e4e83c",
            "filename": "tensorflow/compiler/tests/unary_ops_test.py",
            "status": "modified",
            "additions": 405,
            "deletions": 614,
            "changes": 1019,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Funary_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Funary_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftests%2Funary_ops_test.py?ref=eb246cf2fc479be2b6b61c130ce6798a040a3e75",
            "patch": "@@ -14,7 +14,6 @@\n # ==============================================================================\n \"\"\"Tests for XLA JIT compiler.\"\"\"\n \n-import platform\n import unittest\n \n import numpy as np\n@@ -46,13 +45,9 @@ def nhwc_to_format(x, data_format):\n class UnaryOpsTest(xla_test.XLATestCase):\n   \"\"\"Test cases for unary operators.\"\"\"\n \n-  def _assertOpOutputMatchesExpected(self,\n-                                     op,\n-                                     inp,\n-                                     expected,\n-                                     equality_test=None,\n-                                     rtol=1e-3,\n-                                     atol=1e-5):\n+  def _assertOpOutputMatchesExpected(\n+      self, op, inp, expected, equality_test=None, rtol=1e-3, atol=1e-5\n+  ):\n     \"\"\"Verifies that 'op' produces 'expected' when fed input 'inp' .\n \n     Args:\n@@ -67,13 +62,15 @@ def _assertOpOutputMatchesExpected(self,\n     with self.session() as session:\n       with self.test_scope():\n         pinp = array_ops.placeholder(\n-            dtypes.as_dtype(inp.dtype), inp.shape, name=\"a\")\n+            dtypes.as_dtype(inp.dtype), inp.shape, name=\"a\"\n+        )\n         output = op(pinp)\n       result = session.run(output, {pinp: inp})\n       if equality_test is None:\n         self.assertEqual(output.dtype, expected.dtype)\n         self.assertAllCloseAccordingToType(\n-            expected, result, rtol=rtol, atol=atol, bfloat16_rtol=0.03)\n+            expected, result, rtol=rtol, atol=atol, bfloat16_rtol=0.03\n+        )\n       else:\n         equality_test(result, expected, rtol=rtol, atol=atol)\n \n@@ -95,465 +92,166 @@ def AssertAllEqual(self, result, expected, rtol, atol):\n   def testAllTypeOps(self):\n     for dtype in self.numeric_types - {np.int8, np.uint8}:\n       self._assertOpOutputMatchesExpected(\n-          array_ops.diag, np.array([1, 2, 3, 4], dtype=dtype),\n+          array_ops.diag,\n+          np.array([1, 2, 3, 4], dtype=dtype),\n           np.array(\n               [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]],\n-              dtype=dtype))\n+              dtype=dtype,\n+          ),\n+      )\n       self._assertOpOutputMatchesExpected(\n           array_ops.diag_part,\n           np.arange(36).reshape([2, 3, 2, 3]).astype(dtype),\n-          np.array([[0, 7, 14], [21, 28, 35]], dtype=dtype))\n+          np.array([[0, 7, 14], [21, 28, 35]], dtype=dtype),\n+      )\n       self._assertOpOutputMatchesExpected(\n-          array_ops.diag, np.array([[1, 2], [3, 4]], dtype=dtype),\n+          array_ops.diag,\n+          np.array([[1, 2], [3, 4]], dtype=dtype),\n           np.array(\n-              [[[[1, 0], [0, 0]], [[0, 2], [0, 0]]], [[[0, 0], [3, 0]],\n-                                                      [[0, 0], [0, 4]]]],\n-              dtype=dtype))\n+              [\n+                  [[[1, 0], [0, 0]], [[0, 2], [0, 0]]],\n+                  [[[0, 0], [3, 0]], [[0, 0], [0, 4]]],\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.identity,\n           np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[-1, 1]], dtype=dtype))\n+          expected=np.array([[-1, 1]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.prevent_gradient,\n           np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[-1, 1]], dtype=dtype))\n+          expected=np.array([[-1, 1]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.squeeze,\n           np.array([[[[[]]]]], dtype=dtype),\n-          expected=np.array([], dtype=dtype))\n+          expected=np.array([], dtype=dtype),\n+      )\n       self._assertOpOutputMatchesExpected(\n           array_ops.squeeze,\n           np.array([[[1], [2]]], dtype=dtype),\n-          expected=np.array([1, 2], dtype=dtype))\n+          expected=np.array([1, 2], dtype=dtype),\n+      )\n       self._assertOpOutputMatchesExpected(\n           array_ops.squeeze,\n           np.array([[[1]], [[2]]], dtype=dtype),\n-          expected=np.array([1, 2], dtype=dtype))\n+          expected=np.array([1, 2], dtype=dtype),\n+      )\n       self._assertOpOutputMatchesExpected(\n           array_ops.squeeze,\n           np.array([[[1, 2], [3, 4]]], dtype=dtype),\n-          expected=np.array([[1, 2], [3, 4]], dtype=dtype))\n+          expected=np.array([[1, 2], [3, 4]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.stop_gradient,\n           np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[-1, 1]], dtype=dtype))\n+          expected=np.array([[-1, 1]], dtype=dtype),\n+      )\n \n   def testLog(self):\n     for dtype in self.float_types - {dtypes.bfloat16.as_numpy_dtype}:\n       tol = 1e-4 if dtype == np.float32 else 1e-9\n       # pylint: disable=invalid-unary-operand-type\n       x = np.linspace(-np.e, np.e, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.log, x, expected=np.log(x), atol=tol, rtol=tol)\n+          math_ops.log, x, expected=np.log(x), atol=tol, rtol=tol\n+      )\n \n-      x = np.linspace(0., np.e * 1e-30, num=1000, dtype=dtype)\n+      x = np.linspace(0.0, np.e * 1e-30, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.log, x, expected=np.log(x), atol=tol, rtol=tol)\n+          math_ops.log, x, expected=np.log(x), atol=tol, rtol=tol\n+      )\n \n-      x = np.linspace(0., np.pi * 1e30, num=1000, dtype=dtype)\n+      x = np.linspace(0.0, np.pi * 1e30, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.log, x, expected=np.log(x), atol=tol, rtol=tol)\n+          math_ops.log, x, expected=np.log(x), atol=tol, rtol=tol\n+      )\n \n   def testSin(self):\n     for dtype in self.float_types - {dtypes.bfloat16.as_numpy_dtype}:\n       tol = 1e-6 if dtype == np.float32 else 1e-12\n \n       x = np.linspace(-4 * np.e, 4 * np.e, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.sin, x, expected=np.sin(x), rtol=tol, atol=tol)\n+          math_ops.sin, x, expected=np.sin(x), rtol=tol, atol=tol\n+      )\n \n-      x = np.linspace(0., np.e * 1e-30, num=1000, dtype=dtype)\n+      x = np.linspace(0.0, np.e * 1e-30, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.sin, x, expected=np.sin(x), rtol=tol, atol=tol)\n+          math_ops.sin, x, expected=np.sin(x), rtol=tol, atol=tol\n+      )\n \n       if dtype == np.float64:\n-        x = np.linspace(0., np.e * 1e8, num=1000, dtype=dtype)\n+        x = np.linspace(0.0, np.e * 1e8, num=1000, dtype=dtype)\n         self._assertOpOutputMatchesExpected(\n-            math_ops.sin, x, expected=np.sin(x), rtol=tol, atol=1e-5)\n+            math_ops.sin, x, expected=np.sin(x), rtol=tol, atol=1e-5\n+        )\n \n   def testCos(self):\n     for dtype in self.float_types - {dtypes.bfloat16.as_numpy_dtype}:\n       tol = 1e-6 if dtype == np.float32 else 1e-12\n \n       x = np.linspace(-4 * np.e, 4 * np.e, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.cos, x, expected=np.cos(x), rtol=tol, atol=tol)\n+          math_ops.cos, x, expected=np.cos(x), rtol=tol, atol=tol\n+      )\n \n-      x = np.linspace(0., np.e * 1e-30, num=1000, dtype=dtype)\n+      x = np.linspace(0.0, np.e * 1e-30, num=1000, dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.cos, x, expected=np.cos(x), rtol=tol, atol=tol)\n+          math_ops.cos, x, expected=np.cos(x), rtol=tol, atol=tol\n+      )\n \n       if dtype == np.float64:\n-        x = np.linspace(0., np.e * 1e8, num=1000, dtype=dtype)\n+        x = np.linspace(0.0, np.e * 1e8, num=1000, dtype=dtype)\n         self._assertOpOutputMatchesExpected(\n-            math_ops.cos, x, expected=np.cos(x), rtol=tol, atol=1e-5)\n-\n-  def testFloatOps(self):\n-    for dtype in self.float_types:\n-      x = np.arange(-0.90, 0.90, 0.25)\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.acos, x.astype(dtype), expected=np.arccos(x).astype(dtype))\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.asin, x.astype(dtype), expected=np.arcsin(x).astype(dtype))\n-      x = np.arange(-3, 3).reshape(1, 3, 2)\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.atan, x.astype(dtype), expected=np.arctan(x).astype(dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.acosh,\n-          np.array([1, 2, 3, 4], dtype=dtype),\n-          expected=np.array(\n-              [0, 1.3169579, 1.76274717, 2.06343707], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.asinh,\n-          np.array([1, 2, 3, 4], dtype=dtype),\n-          expected=np.array(\n-              [0.88137359, 1.44363548, 1.81844646, 2.09471255], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.atanh,\n-          np.array([0.1, 0.2, 0.3, 0.4], dtype=dtype),\n-          expected=np.array(\n-              [0.10033535, 0.20273255, 0.3095196, 0.42364893], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.ceil,\n-          np.array([[-1.7, 1.2]], dtype=dtype),\n-          expected=np.array([[-1, 2]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.cosh,\n-          np.array([1, 2, 3, 4], dtype=dtype),\n-          expected=np.array(\n-              [1.54308063, 3.76219569, 10.067662, 27.30823284], dtype=dtype))\n-\n-      # Disable float16 testing for now\n-      if dtype != np.float16:\n-        x = np.arange(-10, 10, 1).astype(dtype)\n-        with self.session() as session:\n-          erf_x = session.run(math_ops.erf(x))\n-          erfc_x = session.run(math_ops.erfc(x))\n-\n-        self._assertOpOutputMatchesExpected(math_ops.erf, x, expected=erf_x)\n-        self._assertOpOutputMatchesExpected(math_ops.erfc, x, expected=erfc_x)\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.exp,\n-          np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[0.36787945, 2.7182817]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.expm1,\n-          np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[-0.63212056, 1.71828183]], dtype=dtype),\n-          rtol=1e-5)\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.floor,\n-          np.array([[-1.7, 1.2]], dtype=dtype),\n-          expected=np.array([[-2, 1]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.is_finite,\n-          np.array([[-np.inf, -2, -1, 0, 0.5, 1, 2, np.inf, np.nan]],\n-                   dtype=dtype),\n-          expected=np.array([[0, 1, 1, 1, 1, 1, 1, 0, 0]], dtype=np.bool_))\n-\n-      # Tests for tf.nn ops.\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.l2_loss, np.array([[[]]], dtype=dtype), expected=dtype(0))\n-\n-      self._assertOpOutputMatchesExpected(nn_ops.l2_loss, dtype(4), dtype(8))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.l2_loss, np.array([[-2, 4]], dtype=dtype), expected=dtype(10))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.reciprocal,\n-          np.array([[1, 2]], dtype=dtype),\n-          expected=np.array([[1, 0.5]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.log,\n-          np.array([[1, 2]], dtype=dtype),\n-          expected=np.array([[0, 0.69314718]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.sin,\n-          np.array([[1, 2]], dtype=dtype),\n-          expected=np.array([[0.841478, 0.909302]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.cos,\n-          np.array([[1, 2]], dtype=dtype),\n-          expected=np.array([[0.540297, -0.41614]], dtype=dtype))\n-\n-      # Confirm that log1p will remain precise across a range of small values.\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.log1p,\n-          np.array([[1e-14, 1e-15, 0.6, 2] + [x * 1e-5 for x in range(1, 20)]],\n-                   dtype=dtype),\n-          expected=np.log1p(\n-              np.array(\n-                  [[1e-14, 1e-15, 0.6, 2] + [x * 1e-5 for x in range(1, 20)]],\n-                  dtype=dtype)).astype(dtype),\n-          rtol=1e-15 if dtype == np.float64 else 1e-4,\n-          atol=1e-15 if dtype == np.float64 else 1e-4)\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.rint,\n-          np.array(\n-              [[-1.7, 1.2, 4.0, 0.0], [-3.5, -2.5, -1.5, -0.5],\n-               [0.5, 1.5, 2.5, 3.5]],\n-              dtype=dtype),\n-          expected=np.array(\n-              [[-2, 1, 4, 0], [-4, -2, -2, 0], [0, 2, 2, 4]], dtype=dtype))\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.round,\n-          np.array(\n-              [[-1.7, 1.2, 4.0, 0.0], [-3.5, -2.5, -1.5, -0.5],\n-               [0.5, 1.5, 2.5, 3.5]],\n-              dtype=dtype),\n-          expected=np.array(\n-              [[-2, 1, 4, 0], [-4, -2, -2, 0], [0, 2, 2, 4]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.rsqrt,\n-          np.array([[4, 16]], dtype=dtype),\n-          expected=np.array([[0.5, 0.25]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.sigmoid,\n-          np.array([[1, 1, 1, 1], [1, 2, 3, 4]], dtype=dtype),\n-          expected=np.array(\n-              [[0.7310586, 0.7310586, 0.7310586, 0.7310586],\n-               [0.7310586, 0.880797, 0.95257413, 0.98201376]],\n-              dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.sigmoid,\n-          np.array([-300, -150, 0, 150, 300], dtype=dtype),\n-          expected=np.array([0, 0, 0.5, 1, 1], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.sinh,\n-          np.array([1, 2, 3, 4], dtype=dtype),\n-          expected=np.array(\n-              [1.17520119, 3.62686041, 10.01787493, 27.2899172], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.sqrt,\n-          np.array([[4, 9]], dtype=dtype),\n-          expected=np.array([[2, 3]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.tan,\n-          np.array([1, 2, 3, 4], dtype=dtype),\n-          expected=np.array(\n-              [1.55740772, -2.18503986, -0.14254654, 1.15782128], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.tanh,\n-          np.array([[1, 2, 3, 4], [np.inf, -np.inf, np.nan, 20],\n-                    [19, -19, 22, -22]],\n-                   dtype=dtype),\n-          expected=np.array(\n-              [[0.76159418, 0.96402758, 0.99505478, 0.99932933],\n-               [1.0, -1.0, np.nan, 1.0], [1.0, -1.0, 1.0, -1.0]],\n-              dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.log_softmax,\n-          np.array([[1, 1, 1, 1], [1, 2, 3, 4]], dtype=dtype),\n-          expected=np.array(\n-              [[-1.3862944, -1.3862944, -1.3862944, -1.3862944],\n-               [-3.4401896, -2.4401896, -1.4401897, -0.44018969]],\n-              dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.elu,\n-          np.array([[-1, 0, 1, -1e-6]], dtype=dtype),\n-          expected=np.array([[-0.63212056, 0, 1, -9.999995e-07]], dtype=dtype),\n-          rtol=1e-5,\n-          atol=1e-6)\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.selu,\n-          np.array([[-1, 0, 1, -1e-5]], dtype=dtype),\n-          expected=np.array(\n-              [[-1.11133074, 0., 1.05070099, -1.758090550379974e-05]],\n-              dtype=dtype),\n-          rtol=1e-5,\n-          atol=1e-6)\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.relu,\n-          np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[0, 1]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.relu6,\n-          np.array([[-0.05, 6.05, 5]], dtype=dtype),\n-          expected=np.array([[0, 6, 5]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.leaky_relu,\n-          np.array([[-2, -1, 0, 1, 2]], dtype=dtype),\n-          expected=np.array([[-0.4, -0.2, 0.0, 1.0, 2.0]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.softmax,\n-          np.array([1, 2, 3, 4], dtype=dtype),\n-          expected=np.array([0.032058604, 0.087144323, 0.23688284, 0.64391428],\n-                            dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.softmax,\n-          np.array([[1, 1, 1, 1], [1, 2, 3, 4]], dtype=dtype),\n-          expected=np.array(\n-              [[0.25, 0.25, 0.25, 0.25],\n-               [0.032058604, 0.087144323, 0.23688284, 0.64391428]],\n-              dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.softmax,\n-          np.array([[[1, 1], [1, 1]], [[1, 2], [3, 4]]], dtype=dtype),\n-          expected=np.array(\n-              [[[0.5, 0.5], [0.5, 0.5]],\n-               [[0.26894142, 0.73105858], [0.26894142, 0.73105858]]],\n-              dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          nn_ops.softsign,\n-          np.array([[-2, -1, 0, 1, 2]], dtype=dtype),\n-          expected=np.array(\n-              [[-0.66666669, -0.5, 0, 0.5, 0.66666669]], dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.sign,\n-          np.array([[-2.0, -1.0, -0.0, +0.0, 1.0, 2.0,\n-                     float(\"nan\")]],\n-                   dtype=dtype),\n-          expected=np.array([[-1.0, -1.0, -0.0, +0.0, 1.0, 1.0,\n-                              float(\"nan\")]],\n-                            dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.is_finite,\n-          np.array([[42, float(\"inf\"), -123], [float(\"nan\"), 0, -0.0]],\n-                   dtype=dtype),\n-          expected=np.array([[True, False, True], [False, True, True]],\n-                            dtype=np.bool_))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.lgamma,\n-          np.array(0.5, dtype=dtype),\n-          expected=np.array(np.log(np.pi) / 2, dtype=dtype))\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.lgamma,\n-          np.array(\n-              [[1, 2, 3], [4, 5, 6], [1 / 2, 3 / 2, 5 / 2],\n-               [-3 / 2, -7 / 2, -11 / 2]],\n-              dtype=dtype),\n-          expected=np.array(\n-              [\n-                  [0, 0, np.log(2.0)],\n-                  [np.log(6.0), np.log(24.0),\n-                   np.log(120)],\n-                  [\n-                      np.log(np.pi) / 2,\n-                      np.log(np.pi) / 2 - np.log(2),\n-                      np.log(np.pi) / 2 - np.log(4) + np.log(3)\n-                  ],\n-                  [\n-                      np.log(np.pi) / 2 - np.log(3) + np.log(4),\n-                      np.log(np.pi) / 2 - np.log(105) + np.log(16),\n-                      np.log(np.pi) / 2 - np.log(10395) + np.log(64),\n-                  ],\n-              ],\n-              dtype=dtype))\n-\n-      # The actual result is complex. Take the real part.\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.lgamma,\n-          np.array([-1 / 2, -5 / 2, -9 / 2], dtype=dtype),\n-          expected=np.array(\n-              [\n-                  np.log(np.pi) / 2 + np.log(2),\n-                  np.log(np.pi) / 2 - np.log(15) + np.log(8),\n-                  np.log(np.pi) / 2 - np.log(945) + np.log(32),\n-              ],\n-              dtype=dtype),\n-          atol=1e-4)\n-\n-      self._assertOpOutputMatchesExpected(\n-          math_ops.digamma,\n-          np.array(\n-              [[1.0, 0.5, 1 / 3.0], [0.25, 1 / 6.0, 0.125], [2.0, 3.0, 4.0],\n-               [6.0, 8.0, 9.0]],\n-              dtype=dtype),\n-          expected=np.array(\n-              [\n-                  [\n-                      -np.euler_gamma, -2 * np.log(2) - np.euler_gamma,\n-                      -np.pi / 2 / np.sqrt(3) - 3 * np.log(3) / 2 -\n-                      np.euler_gamma\n-                  ],\n-                  [\n-                      -np.pi / 2 - 3 * np.log(2) - np.euler_gamma,\n-                      -np.pi * np.sqrt(3) / 2 - 2 * np.log(2) -\n-                      3 * np.log(3) / 2 - np.euler_gamma,\n-                      -np.pi / 2 - 4 * np.log(2) -\n-                      (np.pi + np.log(2 + np.sqrt(2)) - np.log(2 - np.sqrt(2)))\n-                      / np.sqrt(2) - np.euler_gamma\n-                  ],\n-                  [\n-                      1 - np.euler_gamma, 1.5 - np.euler_gamma,\n-                      11 / 6.0 - np.euler_gamma\n-                  ],\n-                  [\n-                      137 / 60.0 - np.euler_gamma, 363 / 140.0 - np.euler_gamma,\n-                      761 / 280.0 - np.euler_gamma\n-                  ],\n-              ],\n-              dtype=dtype))\n+            math_ops.cos, x, expected=np.cos(x), rtol=tol, atol=1e-5\n+        )\n \n   def testSigmoidNumericalStability(self):\n     for dtype in self.float_types:\n       if dtype != np.float16:\n         self._assertOpOutputMatchesExpected(\n             lambda x: math_ops.sigmoid(x) / math_ops.log1p(math_ops.exp(x)),\n             np.array([-40, 40], dtype=dtype),\n-            expected=np.array([1.0, 0.025], dtype=dtype))\n+            expected=np.array([1.0, 0.025], dtype=dtype),\n+        )\n \n   def testQuantizeAndDequantize(self):\n     for dtype in self.float_types:\n \n       def quantize_and_dequantize_v2(x):\n         return array_ops.quantize_and_dequantize(\n-            x, -127, 127, signed_input=True, num_bits=8)\n+            x, -127, 127, signed_input=True, num_bits=8\n+        )\n \n       def quantize_and_dequantize_v3(x):\n         return array_ops.quantize_and_dequantize_v3(\n-            x, -127, 127, num_bits=8, signed_input=True, range_given=False)\n+            x, -127, 127, num_bits=8, signed_input=True, range_given=False\n+        )\n \n       def quantize_and_dequantize_v4(x):\n         return array_ops.quantize_and_dequantize_v2(\n-            x, -127, 127, signed_input=True, num_bits=8)\n+            x, -127, 127, signed_input=True, num_bits=8\n+        )\n \n-      test_fns = (quantize_and_dequantize_v2, quantize_and_dequantize_v3,\n-                  quantize_and_dequantize_v4)\n+      test_fns = (\n+          quantize_and_dequantize_v2,\n+          quantize_and_dequantize_v3,\n+          quantize_and_dequantize_v4,\n+      )\n       for test_fn in test_fns:\n         self._assertOpOutputMatchesExpected(\n             test_fn,\n             np.array([-1, -0.5, 0, 0.3], dtype=dtype),\n-            expected=np.array([-1., -0.5, 0., 0.296875], dtype=dtype))\n+            expected=np.array([-1.0, -0.5, 0.0, 0.296875], dtype=dtype),\n+        )\n \n       def quantize_and_dequantize_v2_round_half_up(x):\n         return array_ops.quantize_and_dequantize(\n@@ -563,21 +261,25 @@ def quantize_and_dequantize_v2_round_half_up(x):\n             signed_input=True,\n             num_bits=8,\n             range_given=True,\n-            round_mode=\"HALF_UP\")\n+            round_mode=\"HALF_UP\",\n+        )\n \n       self._assertOpOutputMatchesExpected(\n           quantize_and_dequantize_v2_round_half_up,\n           np.array([-0.8, -0.4, 0, 0.3, 0.8, -2, 33], dtype=dtype),\n-          expected=np.array([\n-              -102.0 / 127,\n-              -51.0 / 127,\n-              0,\n-              38.0 / 127,\n-              102.0 / 127,\n-              -128.0 / 127,\n-              1,\n-          ],\n-                            dtype=dtype))\n+          expected=np.array(\n+              [\n+                  -102.0 / 127,\n+                  -51.0 / 127,\n+                  0,\n+                  38.0 / 127,\n+                  102.0 / 127,\n+                  -128.0 / 127,\n+                  1,\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n \n       def quantize_and_dequantize_v2_round_half_to_even(x):\n         return array_ops.quantize_and_dequantize(\n@@ -587,21 +289,25 @@ def quantize_and_dequantize_v2_round_half_to_even(x):\n             signed_input=True,\n             num_bits=8,\n             range_given=True,\n-            round_mode=\"HALF_TO_EVEN\")\n+            round_mode=\"HALF_TO_EVEN\",\n+        )\n \n       self._assertOpOutputMatchesExpected(\n           quantize_and_dequantize_v2_round_half_to_even,\n           np.array([-0.8, -0.4, 0, 0.3, 0.8, -2, 33], dtype=dtype),\n-          expected=np.array([\n-              -102.0 / 127,\n-              -51.0 / 127,\n-              0,\n-              38.0 / 127,\n-              102.0 / 127,\n-              -128.0 / 127,\n-              1,\n-          ],\n-                            dtype=dtype))\n+          expected=np.array(\n+              [\n+                  -102.0 / 127,\n+                  -51.0 / 127,\n+                  0,\n+                  38.0 / 127,\n+                  102.0 / 127,\n+                  -128.0 / 127,\n+                  1,\n+              ],\n+              dtype=dtype,\n+          ),\n+      )\n \n   def testComplexOps(self):\n     for dtype in self.complex_types:\n@@ -610,41 +316,51 @@ def testComplexOps(self):\n           math_ops.acosh,\n           np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype),\n           expected=np.arccosh(\n-              np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)))\n+              np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)\n+          ),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.asinh,\n           np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype),\n           expected=np.arcsinh(\n-              np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)))\n+              np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)\n+          ),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.atanh,\n           np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype),\n           expected=np.arctanh(\n-              np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)))\n+              np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)\n+          ),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.cosh,\n           np.array([1j, 2 - 3j, 3, 4 + 2j], dtype=dtype),\n-          expected=np.cosh(np.array([1j, 2 - 3j, 3, 4 + 2j], dtype=dtype)))\n+          expected=np.cosh(np.array([1j, 2 - 3j, 3, 4 + 2j], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.sinh,\n           np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype),\n-          expected=np.sinh(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)))\n+          expected=np.sinh(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.exp,\n           np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype),\n-          expected=np.exp(np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype)))\n+          expected=np.exp(np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.expm1,\n           np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype),\n           expected=np.expm1(np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype)),\n           rtol=1e-6,\n-          atol=1e-6)\n+          atol=1e-6,\n+      )\n \n       # For real part close to zero, or imaginary part close to a multiple of\n       # pi.\n@@ -681,114 +397,158 @@ def testComplexOps(self):\n       self._assertOpOutputMatchesExpected(\n           math_ops.reciprocal,\n           np.array([[1, 2j, 2 + 3j]], dtype=dtype),\n-          expected=1.0 / np.array([[1, 2j, 2 + 3j]], dtype=dtype))\n+          expected=1.0 / np.array([[1, 2j, 2 + 3j]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.log,\n           np.array([[5j, 3 - 2j]], dtype=dtype),\n-          expected=np.log(np.array([[5j, 3 - 2j]], dtype=dtype)))\n+          expected=np.log(np.array([[5j, 3 - 2j]], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.sin,\n           np.array([[5j, 3 - 2j]], dtype=dtype),\n-          expected=np.sin(np.array([[5j, 3 - 2j]], dtype=dtype)))\n+          expected=np.sin(np.array([[5j, 3 - 2j]], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.cos,\n           np.array([[5j, 3 - 2j]], dtype=dtype),\n-          expected=np.cos(np.array([[5j, 3 - 2j]], dtype=dtype)))\n+          expected=np.cos(np.array([[5j, 3 - 2j]], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.log1p,\n           np.array([[1e-14, 1e-15j, 0.6 - 0.3j]], dtype=dtype),\n           expected=np.log1p(\n-              np.array([[1e-14, 1e-15j, 0.6 - 0.3j]], dtype=dtype)),\n+              np.array([[1e-14, 1e-15j, 0.6 - 0.3j]], dtype=dtype)\n+          ),\n           rtol=1e-4,\n-          atol=1e-6)\n+          atol=1e-6,\n+      )\n \n       val = np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)\n       self._assertOpOutputMatchesExpected(\n-          math_ops.rsqrt, val, expected=1 / np.sqrt(val))\n+          math_ops.rsqrt, val, expected=1 / np.sqrt(val)\n+      )\n \n       self._assertOpOutputMatchesExpected(\n-          math_ops.sigmoid, val, expected=1 / (1 + np.exp(-val)))\n+          math_ops.sigmoid, val, expected=1 / (1 + np.exp(-val))\n+      )\n \n       self._assertOpOutputMatchesExpected(\n-          math_ops.sqrt, val, expected=np.sqrt(val))\n+          math_ops.sqrt, val, expected=np.sqrt(val)\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.tanh,\n           np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype),\n-          expected=np.tanh(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)))\n+          expected=np.tanh(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.tan,\n           np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype),\n-          expected=np.tan(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)))\n+          expected=np.tan(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)),\n+      )\n \n       ctypes = {np.complex64: np.float32, np.complex128: np.float64}\n       self._assertOpOutputMatchesExpected(\n           math_ops.abs,\n           np.array([[3 - 4j, -1j, np.inf]], dtype=dtype),\n-          expected=np.array([[5, 1, np.inf]], dtype=ctypes[dtype]))\n+          expected=np.array([[5, 1, np.inf]], dtype=ctypes[dtype]),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.negative,\n           np.array([[-1 + 2j, -3j]], dtype=dtype),\n-          expected=np.array([[1 - 2j, 3j]], dtype=dtype))\n+          expected=np.array([[1 - 2j, 3j]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.square,\n           np.array([[-2 - 3j, 3 + 4j, 5j]], dtype=dtype),\n-          expected=np.array([[-2 - 3j, 3 + 4j, 5j]], dtype=dtype)**2)\n+          expected=np.array([[-2 - 3j, 3 + 4j, 5j]], dtype=dtype) ** 2,\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.zeros_like,\n           np.array([[4j, 3 - 2j], [2, -1j]], dtype=dtype),\n-          expected=np.array([[0, 0], [0, 0]], dtype=dtype))\n+          expected=np.array([[0, 0], [0, 0]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.ones_like,\n           np.array([[-4j, 3 + 2j], [2, -1j]], dtype=dtype),\n-          expected=np.array([[1, 1], [1, 1]], dtype=dtype))\n+          expected=np.array([[1, 1], [1, 1]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.angle,\n           np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),\n-          expected=np.angle(np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype)))\n+          expected=np.angle(np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype)),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.conj,\n           np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),\n-          expected=np.array([1 - 3j, -4 - 7j, 2.7, 3j], dtype=dtype))\n+          expected=np.array([1 - 3j, -4 - 7j, 2.7, 3j], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.imag,\n           np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),\n-          expected=np.array([3, 7, 0, -3], dtype=ctypes[dtype]))\n+          expected=np.array([3, 7, 0, -3], dtype=ctypes[dtype]),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.real,\n           np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),\n-          expected=np.array([1, -4, 2.7, 0], dtype=ctypes[dtype]))\n+          expected=np.array([1, -4, 2.7, 0], dtype=ctypes[dtype]),\n+      )\n \n   def testIntOps(self):\n     for dtype in self.int_types - self.unsigned_int_types:\n       self._assertOpOutputMatchesExpected(\n           bitwise_ops.invert,\n           np.array([0, -1, 1, 16, 42], dtype=dtype),\n-          expected=np.array([-1, 0, -2, -17, -43], dtype=dtype))\n+          expected=np.array([-1, 0, -2, -17, -43], dtype=dtype),\n+      )\n \n       # Test population_count for array inputs.\n       raw_inputs = [\n-          0, 1, -1, 3, -3, 5, -5, 14, -14, 127, 128, 255, 256, 65535, 65536,\n-          2**31 - 1, 2**31, 2**32 - 1, 2**32, -2**32 + 1, -2**32, -2**63 + 1,\n-          2**63 - 1\n+          0,\n+          1,\n+          -1,\n+          3,\n+          -3,\n+          5,\n+          -5,\n+          14,\n+          -14,\n+          127,\n+          128,\n+          255,\n+          256,\n+          65535,\n+          65536,\n+          2**31 - 1,\n+          2**31,\n+          2**32 - 1,\n+          2**32,\n+          -(2**32) + 1,\n+          -(2**32),\n+          -(2**63) + 1,\n+          2**63 - 1,\n       ]\n       # Only choose inputs which fit in the int dtype.\n       raw_inputs = list(\n-          filter(lambda x: np.iinfo(dtype).min <= x <= np.iinfo(dtype).max,\n-                 raw_inputs))\n+          filter(\n+              lambda x: np.iinfo(dtype).min <= x <= np.iinfo(dtype).max,\n+              raw_inputs,\n+          )\n+      )\n       inputs = np.array(raw_inputs, dtype=dtype)\n \n       def count_bits(x):\n@@ -799,7 +559,8 @@ def count_bits(x):\n           bitwise_ops.population_count,\n           inputs,\n           expected=np.array(truth, dtype=np.uint8),\n-          equality_test=self.AssertAllEqual)\n+          equality_test=self.AssertAllEqual,\n+      )\n \n       # Test population_count for scalar inputs.\n       for raw_inp in raw_inputs:\n@@ -809,34 +570,40 @@ def count_bits(x):\n             bitwise_ops.population_count,\n             inp,\n             expected=np.uint8(truth),\n-            equality_test=self.AssertAllEqual)\n+            equality_test=self.AssertAllEqual,\n+        )\n \n   def testNumericOps(self):\n     for dtype in self.numeric_types - {np.int8, np.uint8}:\n       self._assertOpOutputMatchesExpected(\n           math_ops.abs,\n           np.array([[2, -1]], dtype=dtype),\n-          expected=np.array([[2, 1]], dtype=np.real(dtype(0)).dtype))\n+          expected=np.array([[2, 1]], dtype=np.real(dtype(0)).dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.negative,\n           np.array([[-1, 1]], dtype=dtype),\n-          expected=np.array([[1, -1]], dtype=dtype))\n+          expected=np.array([[1, -1]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           math_ops.square,\n           np.array([[-2, 3]], dtype=dtype),\n-          expected=np.array([[4, 9]], dtype=dtype))\n+          expected=np.array([[4, 9]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.zeros_like,\n           np.array([[4, 3], [2, 1]], dtype=dtype),\n-          expected=np.array([[0, 0], [0, 0]], dtype=dtype))\n+          expected=np.array([[0, 0], [0, 0]], dtype=dtype),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           array_ops.ones_like,\n           np.array([[4, 3], [2, 1]], dtype=dtype),\n-          expected=np.array([[1, 1], [1, 1]], dtype=dtype))\n+          expected=np.array([[1, 1], [1, 1]], dtype=dtype),\n+      )\n \n   # TODO(phawkins): these tests fail unless fastmath optimizations\n   # are disabled. Use more robust IsInf/IsNaN detection and enable these\n@@ -846,113 +613,46 @@ def testIsInfAndIsNan(self):\n     for dtype in self.float_types:\n       self._assertOpOutputMatchesExpected(\n           math_ops.is_inf,\n-          np.array([[-np.inf, -2, -1, 0, 0.5, 1, 2, np.inf, np.nan]],\n-                   dtype=dtype),\n-          expected=np.array([[1, 0, 0, 0, 0, 0, 0, 1, 0]], dtype=np.bool_))\n+          np.array(\n+              [[-np.inf, -2, -1, 0, 0.5, 1, 2, np.inf, np.nan]], dtype=dtype\n+          ),\n+          expected=np.array([[1, 0, 0, 0, 0, 0, 0, 1, 0]], dtype=np.bool_),\n+      )\n       self._assertOpOutputMatchesExpected(\n           math_ops.is_nan,\n-          np.array([[-np.inf, -2, -1, 0, 0.5, 1, 2, np.inf, np.nan]],\n-                   dtype=dtype),\n-          expected=np.array([[0, 0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.bool_))\n+          np.array(\n+              [[-np.inf, -2, -1, 0, 0.5, 1, 2, np.inf, np.nan]], dtype=dtype\n+          ),\n+          expected=np.array([[0, 0, 0, 0, 0, 0, 0, 0, 1]], dtype=np.bool_),\n+      )\n       self._assertOpOutputMatchesExpected(\n           math_ops.sign,\n           np.array([[np.nan]], dtype=dtype),\n-          expected=np.array([[0.0]], dtype=dtype))\n+          expected=np.array([[0.0]], dtype=dtype),\n+      )\n \n   def testLogicalOps(self):\n     self._assertOpOutputMatchesExpected(\n         math_ops.logical_not,\n         np.array([[True, False], [False, True]], dtype=np.bool_),\n-        expected=np.array([[False, True], [True, False]], dtype=np.bool_))\n+        expected=np.array([[False, True], [True, False]], dtype=np.bool_),\n+    )\n \n   def testBiasAddGrad(self):\n     self._assertOpOutputMatchesExpected(\n         gen_nn_ops.bias_add_grad,\n-        np.array([[1., 2.], [3., 4.]], dtype=np.float32),\n-        expected=np.array([4., 6.], dtype=np.float32))\n+        np.array([[1.0, 2.0], [3.0, 4.0]], dtype=np.float32),\n+        expected=np.array([4.0, 6.0], dtype=np.float32),\n+    )\n \n     self._assertOpOutputMatchesExpected(\n         lambda x: gen_nn_ops.bias_add_grad(x, data_format=\"NCHW\"),\n         np.array(\n-            [[[1., 2.], [3., 4.]], [[5., 6.], [7., 8.]]], dtype=np.float32),\n-        expected=np.array([14., 22.], dtype=np.float32))\n-\n-  def testCast(self):\n-    types = {\n-        dtypes.bool, dtypes.float32, dtypes.float64, dtypes.complex64,\n-        dtypes.int32, dtypes.int64, dtypes.uint32, dtypes.uint64\n-    }\n-    for src_type in types:\n-      for dst_type in types:\n-        self._testCast(src_type, dst_type)\n-\n-  def testCastFp8(self):\n-    if platform.system() == \"Darwin\":\n-      # TODO(b/271327511): Fix issue where casts to FP8 very rarely result in\n-      # NaN on Mac\n-      self.skipTest(\"Casts to FP8 sometimes result in NaN on Mac\")\n-    fp8_types = {\n-        dtypes.float8_e5m2,\n-        dtypes.float8_e4m3fn,\n-        dtypes.float8_e4m3fnuz,\n-        dtypes.float8_e4m3b11fnuz,\n-        dtypes.float8_e5m2fnuz,\n-    }\n-    other_types = {\n-        dtypes.bool, dtypes.float32, dtypes.float64, dtypes.complex64,\n-        dtypes.int32, dtypes.int64, dtypes.uint32, dtypes.uint64\n-    }\n-    for fp8_type in fp8_types:\n-      for other_type in other_types | fp8_types:\n-        self._testCast(fp8_type, other_type)\n-        self._testCast(other_type, fp8_type)\n-\n-  def _testCast(self, src_type, dst_type):\n-    with self.subTest(src_type=src_type, dst_type=dst_type):\n-      shapes = [[], [4], [2, 3], [2, 0, 4]]\n-      src_np_dtype = src_type.as_numpy_dtype\n-      dst_np_dtype = dst_type.as_numpy_dtype\n-\n-      for shape in shapes:\n-        src = np.arange(np.prod(shape)).astype(src_np_dtype)\n-\n-        if src_type in self.complex_tf_types:\n-          src += (np.arange(np.prod(shape)) * 2j).astype(src_np_dtype)\n-        src = src.reshape(shape)\n-        dst = src.astype(dst_np_dtype)\n-        self._assertOpOutputMatchesExpected(\n-            lambda x, dst_type=dst_type: math_ops.cast(x, dst_type),\n-            src,\n-            expected=dst)\n-\n-      # Check special values.\n-      if src_type.is_integer:\n-        imin = np.iinfo(src_np_dtype).min\n-        imax = np.iinfo(src_np_dtype).max\n-        if src_type.is_unsigned:\n-          src = np.array([imin, imax, 0, 1], dtype=src_np_dtype)\n-        else:\n-          src = np.array([imin, imax, 0, 1, -1], dtype=src_np_dtype)\n-      elif src_type in self.float_tf_types:\n-        if dst_type.is_integer:\n-          imin = np.iinfo(dst_np_dtype).min\n-          imax = np.iinfo(dst_np_dtype).max // 2\n-          src = np.array([imin, imax, 0, 1], dtype=src_np_dtype)\n-        elif dst_type in self.float_tf_types:\n-          fmin = np.finfo(dst_np_dtype).min\n-          fmax = np.finfo(dst_np_dtype).max\n-          tiny = np.finfo(dst_np_dtype).tiny\n-          eps = np.finfo(dst_np_dtype).eps\n-          src = np.array(\n-              [fmin, fmax, np.nan, eps, -eps, tiny, -tiny, np.inf, -np.inf],\n-              dtype=src_np_dtype,\n-          )\n-      dst = src.astype(dst_np_dtype)\n-      self._assertOpOutputMatchesExpected(\n-          lambda x, dst_type=dst_type: math_ops.cast(x, dst_type),\n-          src,\n-          expected=dst,\n-      )\n+            [[[1.0, 2.0], [3.0, 4.0]], [[5.0, 6.0], [7.0, 8.0]]],\n+            dtype=np.float32,\n+        ),\n+        expected=np.array([14.0, 22.0], dtype=np.float32),\n+    )\n \n   def testBitcast(self):\n     self._assertOpOutputMatchesExpected(\n@@ -988,7 +688,7 @@ def testBitcast(self):\n               np.uint64,\n           ),\n           expected=np.array(\n-              [0, 1.0, -1.12e+18, 18.000000000000024869], np.float64\n+              [0, 1.0, -1.12e18, 18.000000000000024869], np.float64\n           ),\n           atol=0,\n       )\n@@ -1024,61 +724,73 @@ def invert_twice(x):\n       self._assertOpOutputMatchesExpected(\n           invert_twice,\n           np.array([1, 2, 0], np_dtype),\n-          expected=np.array([1, 2, 0], dtype=np_dtype))\n+          expected=np.array([1, 2, 0], dtype=np_dtype),\n+      )\n \n   def testRank(self):\n     rank_op = lambda x: array_ops.rank_internal(x, optimize=False)\n     for dtype in self.numeric_types:\n       self._assertOpOutputMatchesExpected(\n-          rank_op, dtype(7), expected=np.int32(0))\n+          rank_op, dtype(7), expected=np.int32(0)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          rank_op, np.array([[], []], dtype=dtype), expected=np.int32(2))\n+          rank_op, np.array([[], []], dtype=dtype), expected=np.int32(2)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          rank_op, np.array([0, 1], dtype=dtype), expected=np.int32(1))\n+          rank_op, np.array([0, 1], dtype=dtype), expected=np.int32(1)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          rank_op, np.array([[0, 1]], dtype=dtype), expected=np.int32(2))\n+          rank_op, np.array([[0, 1]], dtype=dtype), expected=np.int32(2)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          rank_op,\n-          np.array([[0], [1], [4]], dtype=dtype),\n-          expected=np.int32(2))\n+          rank_op, np.array([[0], [1], [4]], dtype=dtype), expected=np.int32(2)\n+      )\n \n   def testShape(self):\n     shape_op = lambda x: array_ops.shape_internal(x, optimize=False)\n     for dtype in self.numeric_types:\n       self._assertOpOutputMatchesExpected(\n-          shape_op, dtype(7), expected=np.array([], dtype=np.int32))\n+          shape_op, dtype(7), expected=np.array([], dtype=np.int32)\n+      )\n       self._assertOpOutputMatchesExpected(\n           shape_op,\n           np.array([[], []], dtype=dtype),\n-          expected=np.array([2, 0], dtype=np.int32))\n+          expected=np.array([2, 0], dtype=np.int32),\n+      )\n       self._assertOpOutputMatchesExpected(\n           shape_op,\n           np.array([0, 1], dtype=dtype),\n-          expected=np.array([2], dtype=np.int32))\n+          expected=np.array([2], dtype=np.int32),\n+      )\n       self._assertOpOutputMatchesExpected(\n           shape_op,\n           np.array([[0, 1]], dtype=dtype),\n-          expected=np.array([1, 2], dtype=np.int32))\n+          expected=np.array([1, 2], dtype=np.int32),\n+      )\n       self._assertOpOutputMatchesExpected(\n           shape_op,\n           np.array([[0], [1], [4]], dtype=dtype),\n-          expected=np.array([3, 1], dtype=np.int32))\n+          expected=np.array([3, 1], dtype=np.int32),\n+      )\n \n   def testSize(self):\n     size_op = lambda x: array_ops.size_internal(x, optimize=False)\n     for dtype in self.numeric_types:\n       self._assertOpOutputMatchesExpected(\n-          size_op, dtype(7), expected=np.int32(1))\n+          size_op, dtype(7), expected=np.int32(1)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          size_op, np.array([[], []], dtype=dtype), expected=np.int32(0))\n+          size_op, np.array([[], []], dtype=dtype), expected=np.int32(0)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          size_op, np.array([0, 1], dtype=dtype), expected=np.int32(2))\n+          size_op, np.array([0, 1], dtype=dtype), expected=np.int32(2)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          size_op, np.array([[0, 1]], dtype=dtype), expected=np.int32(2))\n+          size_op, np.array([[0, 1]], dtype=dtype), expected=np.int32(2)\n+      )\n       self._assertOpOutputMatchesExpected(\n-          size_op,\n-          np.array([[0], [1], [4]], dtype=dtype),\n-          expected=np.int32(3))\n+          size_op, np.array([[0], [1], [4]], dtype=dtype), expected=np.int32(3)\n+      )\n \n   def testSizeWithInt64OutType(self):\n \n@@ -1087,37 +799,39 @@ def size_op(x):\n \n     for dtype in self.numeric_types:\n       self._assertOpOutputMatchesExpected(\n-          size_op,\n-          np.array([[0], [1], [4]], dtype=dtype),\n-          expected=np.int64(3))\n+          size_op, np.array([[0], [1], [4]], dtype=dtype), expected=np.int64(3)\n+      )\n \n   def testUnpack(self):\n     self._assertOpOutputMatchesExpected(\n         array_ops_stack.unstack,\n-        np.array([[1., 2.], [3., 4.], [5., 6.]], dtype=np.float32),\n+        np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], dtype=np.float32),\n         expected=[\n-            np.array([1., 2.], dtype=np.float32),\n-            np.array([3., 4.], dtype=np.float32),\n-            np.array([5., 6.], dtype=np.float32),\n+            np.array([1.0, 2.0], dtype=np.float32),\n+            np.array([3.0, 4.0], dtype=np.float32),\n+            np.array([5.0, 6.0], dtype=np.float32),\n         ],\n-        equality_test=self.ListsAreClose)\n+        equality_test=self.ListsAreClose,\n+    )\n \n     self._assertOpOutputMatchesExpected(\n         lambda x: array_ops_stack.unstack(x, axis=1),\n-        np.array([[1., 2.], [3., 4.], [5., 6.]], dtype=np.float32),\n+        np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], dtype=np.float32),\n         expected=[\n-            np.array([1., 3., 5.], dtype=np.float32),\n-            np.array([2., 4., 6.], dtype=np.float32),\n+            np.array([1.0, 3.0, 5.0], dtype=np.float32),\n+            np.array([2.0, 4.0, 6.0], dtype=np.float32),\n         ],\n-        equality_test=self.ListsAreClose)\n+        equality_test=self.ListsAreClose,\n+    )\n \n   def testDepthToSpace(self):\n \n     def make_op(data_format):\n \n       def op(x):\n         return array_ops.depth_to_space(\n-            x, block_size=2, data_format=data_format)\n+            x, block_size=2, data_format=data_format\n+        )\n \n       return op\n \n@@ -1126,50 +840,82 @@ def op(x):\n         self._assertOpOutputMatchesExpected(\n             make_op(data_format),\n             nhwc_to_format(\n-                np.array([[[[1, 2, 3, 4]]]], dtype=dtype), data_format),\n+                np.array([[[[1, 2, 3, 4]]]], dtype=dtype), data_format\n+            ),\n             expected=nhwc_to_format(\n-                np.array([[[[1], [2]], [[3], [4]]]], dtype=dtype), data_format))\n+                np.array([[[[1], [2]], [[3], [4]]]], dtype=dtype), data_format\n+            ),\n+        )\n \n         self._assertOpOutputMatchesExpected(\n             make_op(data_format),\n             nhwc_to_format(\n                 np.array(\n-                    [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]], dtype=dtype),\n-                data_format),\n+                    [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]], dtype=dtype\n+                ),\n+                data_format,\n+            ),\n             expected=nhwc_to_format(\n                 np.array(\n                     [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]],\n-                    dtype=dtype), data_format))\n+                    dtype=dtype,\n+                ),\n+                data_format,\n+            ),\n+        )\n \n         self._assertOpOutputMatchesExpected(\n             make_op(data_format),\n             nhwc_to_format(\n                 np.array(\n-                    [[[[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12],\n-                                                     [13, 14, 15, 16]]]],\n-                    dtype=dtype), data_format),\n+                    [[\n+                        [[1, 2, 3, 4], [5, 6, 7, 8]],\n+                        [[9, 10, 11, 12], [13, 14, 15, 16]],\n+                    ]],\n+                    dtype=dtype,\n+                ),\n+                data_format,\n+            ),\n             expected=nhwc_to_format(\n                 np.array(\n-                    [[[[1], [2], [5], [6]], [[3], [4], [7], [8]],\n-                      [[9], [10], [13], [14]], [[11], [12], [15], [16]]]],\n-                    dtype=dtype), data_format))\n+                    [[\n+                        [[1], [2], [5], [6]],\n+                        [[3], [4], [7], [8]],\n+                        [[9], [10], [13], [14]],\n+                        [[11], [12], [15], [16]],\n+                    ]],\n+                    dtype=dtype,\n+                ),\n+                data_format,\n+            ),\n+        )\n \n       self._assertOpOutputMatchesExpected(\n           make_op(\"NCHW_VECT_C\"),\n           np.arange(32, dtype=dtype).reshape((1, 8, 1, 1, 4)),\n-          expected=np.array([[[[[0, 1, 2, 3], [8, 9, 10, 11]],\n-                               [[16, 17, 18, 19], [24, 25, 26, 27]]],\n-                              [[[4, 5, 6, 7], [12, 13, 14, 15]],\n-                               [[20, 21, 22, 23], [28, 29, 30, 31]]]]],\n-                            dtype=dtype))\n+          expected=np.array(\n+              [[\n+                  [\n+                      [[0, 1, 2, 3], [8, 9, 10, 11]],\n+                      [[16, 17, 18, 19], [24, 25, 26, 27]],\n+                  ],\n+                  [\n+                      [[4, 5, 6, 7], [12, 13, 14, 15]],\n+                      [[20, 21, 22, 23], [28, 29, 30, 31]],\n+                  ],\n+              ]],\n+              dtype=dtype,\n+          ),\n+      )\n \n   def testSpaceToDepth(self):\n \n     def make_op(data_format):\n \n       def op(x):\n         return array_ops.space_to_depth(\n-            x, block_size=2, data_format=data_format)\n+            x, block_size=2, data_format=data_format\n+        )\n \n       return op\n \n@@ -1178,49 +924,77 @@ def op(x):\n         self._assertOpOutputMatchesExpected(\n             make_op(data_format),\n             nhwc_to_format(\n-                np.array([[[[1], [2]], [[3], [4]]]], dtype=dtype), data_format),\n+                np.array([[[[1], [2]], [[3], [4]]]], dtype=dtype), data_format\n+            ),\n             expected=nhwc_to_format(\n-                np.array([[[[1, 2, 3, 4]]]], dtype=dtype), data_format))\n+                np.array([[[[1, 2, 3, 4]]]], dtype=dtype), data_format\n+            ),\n+        )\n \n         self._assertOpOutputMatchesExpected(\n             make_op(data_format),\n             nhwc_to_format(\n                 np.array(\n                     [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]],\n-                    dtype=dtype), data_format),\n+                    dtype=dtype,\n+                ),\n+                data_format,\n+            ),\n             expected=nhwc_to_format(\n                 np.array(\n-                    [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]], dtype=dtype),\n-                data_format))\n+                    [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]], dtype=dtype\n+                ),\n+                data_format,\n+            ),\n+        )\n \n         self._assertOpOutputMatchesExpected(\n             make_op(data_format),\n             nhwc_to_format(\n                 np.array(\n-                    [[[[1], [2], [5], [6]], [[3], [4], [7], [8]],\n-                      [[9], [10], [13], [14]], [[11], [12], [15], [16]]]],\n-                    dtype=dtype), data_format),\n+                    [[\n+                        [[1], [2], [5], [6]],\n+                        [[3], [4], [7], [8]],\n+                        [[9], [10], [13], [14]],\n+                        [[11], [12], [15], [16]],\n+                    ]],\n+                    dtype=dtype,\n+                ),\n+                data_format,\n+            ),\n             expected=nhwc_to_format(\n                 np.array(\n-                    [[[[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12],\n-                                                     [13, 14, 15, 16]]]],\n-                    dtype=dtype), data_format))\n+                    [[\n+                        [[1, 2, 3, 4], [5, 6, 7, 8]],\n+                        [[9, 10, 11, 12], [13, 14, 15, 16]],\n+                    ]],\n+                    dtype=dtype,\n+                ),\n+                data_format,\n+            ),\n+        )\n \n       self._assertOpOutputMatchesExpected(\n           make_op(\"NCHW_VECT_C\"),\n           np.arange(32, dtype=dtype).reshape((1, 2, 2, 2, 4)),\n           expected=np.array(\n-              [[[[[0, 1, 2, 3]]], [[[16, 17, 18, 19]]], [[[4, 5, 6, 7]]],\n-                [[[20, 21, 22, 23]]], [[[8, 9, 10, 11]]], [[[24, 25, 26, 27]]],\n-                [[[12, 13, 14, 15]]], [[[28, 29, 30, 31]]]]],\n-              dtype=dtype))\n-\n-  def _assertSoftplusMatchesExpected(self,\n-                                     features,\n-                                     dtype,\n-                                     equality_test=None,\n-                                     rtol=1e-6,\n-                                     atol=9.1e-6):\n+              [[\n+                  [[[0, 1, 2, 3]]],\n+                  [[[16, 17, 18, 19]]],\n+                  [[[4, 5, 6, 7]]],\n+                  [[[20, 21, 22, 23]]],\n+                  [[[8, 9, 10, 11]]],\n+                  [[[24, 25, 26, 27]]],\n+                  [[[12, 13, 14, 15]]],\n+                  [[[28, 29, 30, 31]]],\n+              ]],\n+              dtype=dtype,\n+          ),\n+      )\n+\n+  def _assertSoftplusMatchesExpected(\n+      self, features, dtype, equality_test=None, rtol=1e-6, atol=9.1e-6\n+  ):\n     features = np.array(features, dtype=dtype)\n     zero = np.asarray(0).astype(dtype)\n     expected = np.logaddexp(zero, features).astype(dtype)\n@@ -1230,53 +1004,70 @@ def _assertSoftplusMatchesExpected(self,\n         expected=expected,\n         equality_test=equality_test,\n         rtol=rtol,\n-        atol=atol)\n+        atol=atol,\n+    )\n \n   def testSoftplus(self):\n     for dtype in self.float_types & {dtypes.float32, dtypes.float64}:\n       self._assertSoftplusMatchesExpected([[-2, 0, 8]], dtype)\n       self._assertSoftplusMatchesExpected(\n-          [[-9, 7, -5, 3, -1], [1, -3, 5, -7, 9]], dtype)\n+          [[-9, 7, -5, 3, -1], [1, -3, 5, -7, 9]], dtype\n+      )\n       if dtype == dtypes.bfloat16.as_numpy_dtype:\n         log_eps = np.log(np.finfo(np.float32).eps)\n       else:\n         log_eps = np.log(np.finfo(dtype).eps)\n       one = dtype(1)\n       ten = dtype(10)\n-      self._assertSoftplusMatchesExpected([\n-          log_eps, log_eps - one, log_eps + one, log_eps - ten, log_eps + ten,\n-          -log_eps, -log_eps - one, -log_eps + one, -log_eps - ten,\n-          -log_eps + ten\n-      ], dtype)\n+      self._assertSoftplusMatchesExpected(\n+          [\n+              log_eps,\n+              log_eps - one,\n+              log_eps + one,\n+              log_eps - ten,\n+              log_eps + ten,\n+              -log_eps,\n+              -log_eps - one,\n+              -log_eps + one,\n+              -log_eps - ten,\n+              -log_eps + ten,\n+          ],\n+          dtype,\n+      )\n \n       self._assertSoftplusMatchesExpected(\n           [0.69302183, 0.69324386],\n           dtype,\n           equality_test=self.AssertCloseAndSorted,\n           rtol=9e-5,\n-          atol=9e-5)\n+          atol=9e-5,\n+      )\n \n   def testToBool(self):\n     for dtype in self.numeric_types - self.complex_types:\n       self._assertOpOutputMatchesExpected(\n           gen_functional_ops.to_bool,\n           np.array(5, dtype=dtype),\n-          expected=np.array(True))\n+          expected=np.array(True),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           gen_functional_ops.to_bool,\n           np.array(0, dtype=dtype),\n-          expected=np.array(False))\n+          expected=np.array(False),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           gen_functional_ops.to_bool,\n           np.array([], dtype=dtype),\n-          expected=np.array(False))\n+          expected=np.array(False),\n+      )\n \n       self._assertOpOutputMatchesExpected(\n           gen_functional_ops.to_bool,\n           np.array([1, 2, 3], dtype=dtype),\n-          expected=np.array(True))\n+          expected=np.array(True),\n+      )\n \n \n if __name__ == \"__main__\":"
        },
        {
            "sha": "20f93d86adfad1de4bc93a1e89183d6446d2bcd5",
            "filename": "tensorflow/compiler/tests/xla_test.py",
            "status": "modified",
            "additions": 110,
            "deletions": 57,
            "changes": 167,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Fxla_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/eb246cf2fc479be2b6b61c130ce6798a040a3e75/tensorflow%2Fcompiler%2Ftests%2Fxla_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftests%2Fxla_test.py?ref=eb246cf2fc479be2b6b61c130ce6798a040a3e75",
            "patch": "@@ -40,13 +40,22 @@\n \n FLAGS = flags.FLAGS\n \n-flags.DEFINE_string('test_device', None,\n-                    'Tensorflow device on which to place operators under test')\n+flags.DEFINE_string(\n+    'test_device',\n+    None,\n+    'Tensorflow device on which to place operators under test',\n+)\n flags.DEFINE_string('types', None, 'Types to test. Comma-separated list.')\n-flags.DEFINE_string('disabled_manifest', None,\n-                    'Path to a file with a list of tests that should not run.')\n-flags.DEFINE_string('tf_xla_flags', None,\n-                    'Value to set the TF_XLA_FLAGS environment variable to')\n+flags.DEFINE_string(\n+    'disabled_manifest',\n+    None,\n+    'Path to a file with a list of tests that should not run.',\n+)\n+flags.DEFINE_string(\n+    'tf_xla_flags',\n+    None,\n+    'Value to set the TF_XLA_FLAGS environment variable to',\n+)\n \n \n def parse_disabled_manifest(manifest_content):\n@@ -84,6 +93,7 @@ def __init__(self, *args, **kwargs):\n \n   def run(self, fetches, feed_dict=None, options=None, run_metadata=None):\n     from tensorflow.python.tpu import tpu  # pylint: disable=g-import-not-at-top\n+\n     if self.topology is None:\n       self.topology = super().run(tpu.initialize_system())\n       assert self.topology is not None\n@@ -114,7 +124,7 @@ def __init__(self, method_name='runTest'):\n       context.context().enable_mlir_bridge = False\n \n     self.device = FLAGS.test_device\n-    self.has_custom_call = (self.device == 'XLA_CPU')\n+    self.has_custom_call = self.device == 'XLA_CPU'\n \n     # Some tests (e.g. ftrl_ops) only work if the program goes through the\n     # _TPUCompileMLIR op. They will set this flag to True.\n@@ -125,41 +135,49 @@ def __init__(self, method_name='runTest'):\n         dtypes.as_dtype(types_pb2.DataType.Value(name))\n         for name in FLAGS.types.split(',')\n     ])\n-    self.int_tf_types = set([\n-        dtype for dtype in self._all_tf_types if dtype.is_integer\n-    ])\n-    self._float_tf_types = set([\n-        dtype for dtype in self._all_tf_types if dtype.is_floating\n-    ])\n-    self.complex_tf_types = set([\n-        dtype for dtype in self._all_tf_types if dtype.is_complex\n-    ])\n+    self.int_tf_types = set(\n+        [dtype for dtype in self._all_tf_types if dtype.is_integer]\n+    )\n+    self._float_tf_types = set(\n+        [dtype for dtype in self._all_tf_types if dtype.is_floating]\n+    )\n+    self.complex_tf_types = set(\n+        [dtype for dtype in self._all_tf_types if dtype.is_complex]\n+    )\n     self._numeric_tf_types = set(\n-        self.int_tf_types | self._float_tf_types | self.complex_tf_types)\n+        self.int_tf_types | self._float_tf_types | self.complex_tf_types\n+    )\n     self.quantized_tf_types = set(\n-        dtype for dtype in self._all_tf_types if dtype.is_quantized)\n+        dtype for dtype in self._all_tf_types if dtype.is_quantized\n+    )\n \n     # Quantized types don't have a numpy equivalent, include them in\n     # all_tf_types but not in all_types.\n     # TODO(b/115960798): Parametrize tests on TF types instead of numpy types\n     # and remove all_types.\n-    self._all_types = set(dtype.as_numpy_dtype\n-                          for dtype in self._all_tf_types\n-                          if not dtype.is_quantized)\n+    self._all_types = set(\n+        dtype.as_numpy_dtype\n+        for dtype in self._all_tf_types\n+        if not dtype.is_quantized\n+    )\n     self._int_types = set([dtype.as_numpy_dtype for dtype in self.int_tf_types])\n-    self.signed_int_types = set(dtype.as_numpy_dtype\n-                                for dtype in self.int_tf_types\n-                                if not dtype.is_unsigned)\n-    self.unsigned_int_types = set(dtype.as_numpy_dtype\n-                                  for dtype in self.int_tf_types\n-                                  if dtype.is_unsigned)\n+    self.signed_int_types = set(\n+        dtype.as_numpy_dtype\n+        for dtype in self.int_tf_types\n+        if not dtype.is_unsigned\n+    )\n+    self.unsigned_int_types = set(\n+        dtype.as_numpy_dtype for dtype in self.int_tf_types if dtype.is_unsigned\n+    )\n     self._float_types = set(\n-        [dtype.as_numpy_dtype for dtype in self._float_tf_types])\n-    self.complex_types = set([\n-        dtype.as_numpy_dtype for dtype in self.complex_tf_types\n-    ])\n-    self._numeric_types = set(self._int_types | self._float_types\n-                              | self.complex_types)\n+        [dtype.as_numpy_dtype for dtype in self._float_tf_types]\n+    )\n+    self.complex_types = set(\n+        [dtype.as_numpy_dtype for dtype in self.complex_tf_types]\n+    )\n+    self._numeric_types = set(\n+        self._int_types | self._float_types | self.complex_types\n+    )\n \n     # Parse the manifest file, if any, into a regex identifying tests to\n     # disable\n@@ -174,8 +192,9 @@ def __init__(self, method_name='runTest'):\n \n     if FLAGS.disabled_manifest is not None:\n       with open(FLAGS.disabled_manifest, 'r') as manifest_file:\n-        disabled_regex, self._method_types_filter = (\n-            parse_disabled_manifest(manifest_file.read()))\n+        disabled_regex, self._method_types_filter = parse_disabled_manifest(\n+            manifest_file.read()\n+        )\n         if disabled_regex:\n           self.disabled_regex = re.compile(disabled_regex)\n \n@@ -185,8 +204,9 @@ def __init__(self, method_name='runTest'):\n   @property\n   def all_tf_types(self):\n     name = '{}.{}'.format(type(self).__name__, self._testMethodName)\n-    tf_types = set([dtypes.as_dtype(t)\n-                    for t in self._method_types_filter.get(name, set())])\n+    tf_types = set(\n+        [dtypes.as_dtype(t) for t in self._method_types_filter.get(name, set())]\n+    )\n     return self._all_tf_types - tf_types\n \n   @property\n@@ -207,8 +227,9 @@ def int_types(self):\n   @property\n   def numeric_tf_types(self):\n     name = '{}.{}'.format(type(self).__name__, self._testMethodName)\n-    tf_types = set([dtypes.as_dtype(t)\n-                    for t in self._method_types_filter.get(name, set())])\n+    tf_types = set(\n+        [dtypes.as_dtype(t) for t in self._method_types_filter.get(name, set())]\n+    )\n     return self._numeric_tf_types - tf_types\n \n   @property\n@@ -255,7 +276,8 @@ def session(self) -> Iterator[session.Session]:\n     # constants which XLA does not understand.  So disable constant folding in\n     # these tests.\n     config.graph_options.rewrite_options.constant_folding = (\n-        rewriter_config_pb2.RewriterConfig.OFF)\n+        rewriter_config_pb2.RewriterConfig.OFF\n+    )\n \n     if self.rewrite_ops_for_tpu:\n       session_type = TPURewriteSession\n@@ -267,11 +289,13 @@ def session(self) -> Iterator[session.Session]:\n \n   def cached_session(self):\n     raise NotImplementedError(\n-        'cached_session not supported on XLATestCase, please use session')\n+        'cached_session not supported on XLATestCase, please use session'\n+    )\n \n   def test_session(self):\n     raise NotImplementedError(\n-        'test_session not supported on XLATestCase, please use session')\n+        'test_session not supported on XLATestCase, please use session'\n+    )\n \n   @contextlib.contextmanager\n   def device_scope(self):\n@@ -283,6 +307,35 @@ def device_scope(self):\n     with ops.device('device:{}:0'.format(self.device)):\n       yield\n \n+  def assert_op_output_matches_expected(\n+      self, op, inp, expected, equality_test=None, rtol=1e-3, atol=1e-5\n+  ):\n+    \"\"\"Verifies that 'op' produces 'expected' when fed input 'inp' .\n+\n+    Args:\n+      op: operator to test\n+      inp: numpy input array to use as input to 'op'.\n+      expected: numpy array representing the expected output of 'op'.\n+      equality_test: either None, or a function that tests two numpy arrays for\n+        equality. If None, self.assertAllClose is used.\n+      rtol: relative tolerance for equality test.\n+      atol: absolute tolerance for equality test.\n+    \"\"\"\n+    with self.session() as local_session:\n+      with self.test_scope():\n+        pinp = array_ops.placeholder(\n+            dtypes.as_dtype(inp.dtype), inp.shape, name='a'\n+        )\n+        output = op(pinp)\n+      result = local_session.run(output, {pinp: inp})\n+      if equality_test is None:\n+        self.assertEqual(output.dtype, expected.dtype)\n+        self.assertAllCloseAccordingToType(\n+            expected, result, rtol=rtol, atol=atol, bfloat16_rtol=0.03\n+        )\n+      else:\n+        equality_test(result, expected, rtol=rtol, atol=atol)\n+\n   def test_scope(self):\n     \"\"\"Deprecated alias of `device_scope`.\n \n@@ -293,28 +346,26 @@ def test_scope(self):\n     return self.device_scope()\n \n \n-def Benchmark(tf_bench,\n-              builder_fn,\n-              use_xla_jit,\n-              device,\n-              separate_compiled_gradients=False):\n+def Benchmark(\n+    tf_bench, builder_fn, use_xla_jit, device, separate_compiled_gradients=False\n+):\n   \"\"\"Build a graph and run benchmarks against it, with or without XLA.\n \n   Args:\n     tf_bench: An instance of tf.test.Benchmark, used to run the benchmark.\n-    builder_fn: A function that builds a graph when invoked, and returns\n-        (name, fetches), where name is the name of the test, and fetches\n-        is a list of tensors to fetch as output.\n+    builder_fn: A function that builds a graph when invoked, and returns (name,\n+      fetches), where name is the name of the test, and fetches is a list of\n+      tensors to fetch as output.\n     use_xla_jit: If true compile with the XLA JIT, otherwise use regular TF.\n     device: The tensorflow device to run on, e.g. \"cpu\", \"gpu\".\n     separate_compiled_gradients: If true put each gradient subgraph into a\n       separate compilation scope. This gives fine-grained control over which\n       portions of the graph will be compiled as a single unit. Compiling\n-      gradients separately may yield better performance for some graphs.\n-      The scope is named based on the scope of the forward computation as well\n-      as the name of the gradients. As a result, the gradients will be compiled\n-      in a scope that is separate from both the forward computation, and from\n-      other gradients.\n+      gradients separately may yield better performance for some graphs. The\n+      scope is named based on the scope of the forward computation as well as\n+      the name of the gradients. As a result, the gradients will be compiled in\n+      a scope that is separate from both the forward computation, and from other\n+      gradients.\n   \"\"\"\n \n   with ops.Graph().as_default():\n@@ -325,7 +376,8 @@ def Benchmark(tf_bench,\n       jit_scope = jit.experimental_jit_scope\n       with jit_scope(\n           compile_ops=use_xla_jit,\n-          separate_compiled_gradients=separate_compiled_gradients):\n+          separate_compiled_gradients=separate_compiled_gradients,\n+      ):\n         name, fetches = builder_fn()\n \n       # We only want to benchmark the operations themselves, and not the data\n@@ -341,4 +393,5 @@ def Benchmark(tf_bench,\n       sess.run(variables.global_variables_initializer())\n       xla = 'xla_' if use_xla_jit else ''\n       tf_bench.run_op_benchmark(\n-          sess, targets, name='%s_%s%s' % (name, xla, device))\n+          sess, targets, name='%s_%s%s' % (name, xla, device)\n+      )"
        }
    ],
    "stats": {
        "total": 1841,
        "additions": 1170,
        "deletions": 671
    }
}