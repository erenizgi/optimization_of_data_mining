{
    "author": "tensorflower-gardener",
    "message": "Reverts 0b0ff7c8ac109b9fb53ad7a9c99d078c56b268e9\n\nPiperOrigin-RevId: 825779916",
    "sha": "c7055c2e5bb6e70365de867dc0ac56e56689a122",
    "files": [
        {
            "sha": "738278d94f6ea457f616f73e04ef06a6e43debcb",
            "filename": "third_party/xla/xla/pjrt/gpu/se_gpu_pjrt_client.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -1367,7 +1367,7 @@ StreamExecutorGpuClient::RunAsync(\n \n   std::set<se::DeviceMemoryBase> buffers_in_result;\n \n-  xla::ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> results(\n+  xla::ShapeTree<tsl::RCReference<RawSEDeviceMemory>> results(\n       gpu_exec->result_shape());\n \n   for (auto& p : results) {\n@@ -1452,7 +1452,7 @@ StreamExecutorGpuClient::RunAsync(\n   TF_RETURN_IF_ERROR(buffer_allocations.TearDown(buffers_in_result,\n                                                  gpu_exec->GetAllocations()));\n \n-  std::vector<tsl::AsyncValueRef<RawSEDeviceMemory>> to_be_released;\n+  std::vector<tsl::RCReference<RawSEDeviceMemory>> to_be_released;\n \n   // Free allocations for arguments.\n   for (ShapeTree<PjRtStreamExecutorExecutionInput>& input : arguments) {"
        },
        {
            "sha": "2a1c57e596041f2bc2c766bc9716a46669ecdadf",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -789,7 +789,7 @@ PjRtStreamExecutorClient::CreateErrorBuffer(absl::Status error,\n \n   // Create an empty buffer.\n   auto dummy_device_buffer = std::make_unique<TrackedDeviceBuffer>(\n-      device, tsl::AsyncValueRef<RawSEDeviceMemory>(),\n+      device, tsl::RCReference<RawSEDeviceMemory>(),\n       absl::MakeSpan(&definition_event, 1));\n \n   return std::make_unique<CommonPjRtBufferImpl>(\n@@ -1168,13 +1168,13 @@ MakeTupleHelper(PjRtStreamExecutorClient* client,\n // Converts a ScopedShapedBuffer returned from an execution into a\n // PjRtBuffer.\n absl::StatusOr<std::unique_ptr<PjRtBuffer>> OutputBufferHelper(\n-    ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> result_buffer,\n+    ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer,\n     BufferSequencingEventRef definition_event, PjRtClient* client,\n     PjRtDevice* device, LocalDeviceState* local_device) {\n   if (result_buffer.shape().IsTuple()) {\n     return absl::InternalError(\"OutputBufferHelper called on tuple.\");\n   }\n-  absl::InlinedVector<tsl::AsyncValueRef<RawSEDeviceMemory>, 1> buffers;\n+  absl::InlinedVector<tsl::RCReference<RawSEDeviceMemory>, 1> buffers;\n   for (auto& item : result_buffer) {\n     buffers.push_back(std::move(item.second));\n   }\n@@ -1641,7 +1641,7 @@ PjRtStreamExecutorClient::RunAsync(\n       ExecutionOutput output,\n       exec.RunAsync(std::move(xla_arguments), std::move(run_options)));\n   ScopedShapedBuffer ssb = output.ConsumeResult();\n-  xla::ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> results(\n+  xla::ShapeTree<tsl::RCReference<RawSEDeviceMemory>> results(\n       ssb.on_device_shape());\n   auto it = results.begin();\n   se::DeviceMemoryAllocator* allocator = ssb.memory_allocator();\n@@ -1672,7 +1672,7 @@ PjRtStreamExecutorClient::RunAsync(\n // converted on success.\n // When `options` has non-zero `launch_id`, use `launch_id` instead of `run_id`\n // to initialize `run_options`.\n-absl::StatusOr<ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>>>\n+absl::StatusOr<ShapeTree<tsl::RCReference<RawSEDeviceMemory>>>\n PjRtStreamExecutorLoadedExecutable::EnqueueExecution(\n     absl::Span<PjRtBuffer* const> argument_handles, int replica, int partition,\n     int executable_idx, const RunId& run_id, const ExecuteOptions& options,\n@@ -1930,7 +1930,7 @@ PjRtStreamExecutorLoadedExecutable::EnqueueExecution(\n absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n PjRtStreamExecutorLoadedExecutable::MakeOutputBuffers(\n     int device_ordinal, const ExecuteOptions& options,\n-    ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> result_buffer,\n+    ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer,\n     BufferSequencingEventRef definition_event, PjRtDevice* device,\n     std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks) const {\n   tsl::profiler::TraceMe traceme(\"MakeOutputBuffers\");\n@@ -1943,7 +1943,7 @@ PjRtStreamExecutorLoadedExecutable::MakeOutputBuffers(\n     // in result_buffer.\n     for (int i = 0; i < tuple_count; ++i) {\n       TF_ASSIGN_OR_RETURN(\n-          ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> tuple_buffer,\n+          ShapeTree<tsl::RCReference<RawSEDeviceMemory>> tuple_buffer,\n           result_buffer.SubShapeTree({i}));\n       TF_ASSIGN_OR_RETURN(\n           std::unique_ptr<PjRtBuffer> buffer,\n@@ -2050,7 +2050,7 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n   std::vector<absl::AnyInvocable<void() &&>> compute_callbacks;\n   std::vector<CommonPjRtBuffer::ScopedHold> device_buffers;\n   device_buffers.reserve(argument_handles.size());\n-  absl::StatusOr<ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>>>\n+  absl::StatusOr<ShapeTree<tsl::RCReference<RawSEDeviceMemory>>>\n       result_buffer_or_status =\n           EnqueueExecution(argument_handles, replica, partition, executable_idx,\n                            run_id, options, device, &device_buffers,\n@@ -2061,7 +2061,7 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n                << \" failed: \" << result_buffer_or_status.status();\n     return result_buffer_or_status.status();\n   }\n-  ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> result_buffer =\n+  ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer =\n       std::move(result_buffer_or_status).value();\n \n   LocalDeviceState* device_state = &(client_->device_state(device_ordinal));\n@@ -2081,14 +2081,14 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n     }\n     return definition_event_or.status();\n   }\n-  std::vector<tsl::AsyncValueRef<RawSEDeviceMemory>> leaves_to_release;\n+  std::vector<tsl::RCReference<RawSEDeviceMemory>> leaves_to_release;\n   if (device_state->allocation_model() == LocalDeviceState::kSynchronous) {\n     leaves_to_release.reserve(result_buffer.leaf_count());\n     for (auto& node : result_buffer.leaves()) {\n       leaves_to_release.push_back(node.second);\n     }\n   }\n-  std::vector<tsl::AsyncValueRef<RawSEDeviceMemory>> buffers_to_release;\n+  std::vector<tsl::RCReference<RawSEDeviceMemory>> buffers_to_release;\n   auto definition_event = tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(\n       *definition_event_or, \"PjRtStreamExecutorLoadedExecutable\", \"Execute\");\n   TF_ASSIGN_OR_RETURN("
        },
        {
            "sha": "16935a9a5213f9b13e15669bebc8f4bb60d57419",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -83,13 +83,13 @@ struct PjRtStreamExecutorExecutionInput {\n   // Donation is not complete until ReleaseDeviceMemory() is called on the\n   // TrackedDeviceBuffer that provides buf.\n   bool is_donated;\n-  tsl::AsyncValueRef<RawSEDeviceMemory> buf;\n+  tsl::RCReference<RawSEDeviceMemory> buf;\n };\n \n struct PjRtStreamExecutorExecutionOutput {\n-  ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> result;\n+  ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result;\n   // Donated inputs which must be freed.\n-  std::vector<tsl::AsyncValueRef<RawSEDeviceMemory>> to_be_released;\n+  std::vector<tsl::RCReference<RawSEDeviceMemory>> to_be_released;\n   // For PjRtStreamExecutorClient implementations that\n   // use OwningDeviceMemory for donated inputs.\n   std::vector<se::OwningDeviceMemory> se_to_be_released;\n@@ -672,7 +672,7 @@ class PjRtStreamExecutorLoadedExecutable : public PjRtLoadedExecutable {\n       absl::Span<const CommonPjRtBuffer::ScopedHold> device_buffers,\n       absl::flat_hash_set<BufferSequencingEvent*>& events) const;\n \n-  absl::StatusOr<ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>>>\n+  absl::StatusOr<ShapeTree<tsl::RCReference<RawSEDeviceMemory>>>\n   EnqueueExecution(\n       absl::Span<PjRtBuffer* const> argument_handles, int replica,\n       int partition, int executable_idx, const RunId& run_id,\n@@ -684,7 +684,7 @@ class PjRtStreamExecutorLoadedExecutable : public PjRtLoadedExecutable {\n   virtual absl::StatusOr<std::vector<std::unique_ptr<PjRtBuffer>>>\n   MakeOutputBuffers(\n       int device_ordinal, const ExecuteOptions& options,\n-      ShapeTree<tsl::AsyncValueRef<RawSEDeviceMemory>> result_buffer,\n+      ShapeTree<tsl::RCReference<RawSEDeviceMemory>> result_buffer,\n       BufferSequencingEventRef definition_event, PjRtDevice* device,\n       std::vector<absl::AnyInvocable<void() &&>>& compute_callbacks) const;\n "
        },
        {
            "sha": "85fa80992f36c4ded509a212bc1fc6535d4e198f",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.h?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -91,10 +91,10 @@ class PjRtStreamExecutorDeviceEventPromise : public PjRtDeviceEventPromise {\n \n class PjRtStreamExecutorRawBuffer : public CommonPjRtRawBuffer {\n  public:\n-  PjRtStreamExecutorRawBuffer(\n-      PjRtStreamExecutorClient* client, PjRtMemorySpace* memory_space,\n-      LocalDeviceState* local_device,\n-      tsl::AsyncValueRef<RawSEDeviceMemory> device_buffer)\n+  PjRtStreamExecutorRawBuffer(PjRtStreamExecutorClient* client,\n+                              PjRtMemorySpace* memory_space,\n+                              LocalDeviceState* local_device,\n+                              tsl::RCReference<RawSEDeviceMemory> device_buffer)\n       : client_(client),\n         memory_space_(memory_space),\n         local_device_(local_device),\n@@ -104,7 +104,7 @@ class PjRtStreamExecutorRawBuffer : public CommonPjRtRawBuffer {\n \n   LocalDeviceState* local_device() const { return local_device_; }\n \n-  const tsl::AsyncValueRef<RawSEDeviceMemory>& device_buffer() const {\n+  const tsl::RCReference<RawSEDeviceMemory>& device_buffer() const {\n     return device_buffer_;\n   }\n \n@@ -150,7 +150,7 @@ class PjRtStreamExecutorRawBuffer : public CommonPjRtRawBuffer {\n   PjRtStreamExecutorClient* client_;\n   PjRtMemorySpace* memory_space_;\n   LocalDeviceState* local_device_;\n-  tsl::AsyncValueRef<RawSEDeviceMemory> device_buffer_;\n+  tsl::RCReference<RawSEDeviceMemory> device_buffer_;\n };\n \n }  // namespace xla"
        },
        {
            "sha": "ae198731505ae844c7dfd53e30d651da7e06e801",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -119,11 +119,11 @@ class AllocatedRawSEDeviceMemory : public RawSEDeviceMemory {\n   size_t sync_point_ = std::numeric_limits<size_t>::max();\n };\n \n-tsl::AsyncValueRef<RawSEDeviceMemory> RawSEDeviceMemory::Create(\n+tsl::RCReference<RawSEDeviceMemory> RawSEDeviceMemory::Create(\n     se::DeviceMemoryBase value, LocalDeviceState* local_device,\n     se::DeviceMemoryAllocator* allocator) {\n-  return tsl::MakeAvailableAsyncValueRef<AllocatedRawSEDeviceMemory>(\n-      value, local_device, allocator);\n+  return tsl::MakeRef<AllocatedRawSEDeviceMemory>(value, local_device,\n+                                                  allocator);\n }\n \n class ForeignRawSEDeviceMemory : public RawSEDeviceMemory {\n@@ -143,11 +143,11 @@ class ForeignRawSEDeviceMemory : public RawSEDeviceMemory {\n   absl::AnyInvocable<void() &&> on_delete_callback_;\n };\n \n-tsl::AsyncValueRef<RawSEDeviceMemory> RawSEDeviceMemory::CreateForeign(\n+tsl::RCReference<RawSEDeviceMemory> RawSEDeviceMemory::CreateForeign(\n     se::DeviceMemoryBase value,\n     absl::AnyInvocable<void() &&> on_delete_callback) {\n-  return tsl::MakeAvailableAsyncValueRef<ForeignRawSEDeviceMemory>(\n-      value, std::move(on_delete_callback));\n+  return tsl::MakeRef<ForeignRawSEDeviceMemory>(value,\n+                                                std::move(on_delete_callback));\n }\n \n ShapedBuffer TrackedDeviceBuffer::AsShapedBuffer(\n@@ -167,7 +167,7 @@ ShapedBuffer TrackedDeviceBuffer::AsShapedBuffer(\n }\n \n TrackedDeviceBuffer::TrackedDeviceBuffer(\n-    PjRtDevice* device, tsl::AsyncValueRef<RawSEDeviceMemory> device_memory,\n+    PjRtDevice* device, tsl::RCReference<RawSEDeviceMemory> device_memory,\n     absl::Span<const BufferSequencingEventRef> definition_events)\n     : device_(device),\n       device_memory_(std::move(device_memory)),\n@@ -178,7 +178,7 @@ TrackedDeviceBuffer::TrackedDeviceBuffer(\n TrackedDeviceBuffer::~TrackedDeviceBuffer() = default;\n \n void TrackedDeviceBuffer::ReleaseDeviceMemory() {\n-  device_memory_ = tsl::AsyncValueRef<RawSEDeviceMemory>();\n+  device_memory_ = tsl::RCReference<RawSEDeviceMemory>();\n }\n \n void TrackedDeviceBuffer::ConfirmDonation() {"
        },
        {
            "sha": "24ed1db45010b4c153ce7355c873aae67df4d4ab",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.h",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -51,6 +51,7 @@ limitations under the License.\n \n namespace xla {\n \n+// TODO(parkers): Implement PjRtRawBuffer API.\n class RawSEDeviceMemory : public tsl::ReferenceCounted<RawSEDeviceMemory> {\n  public:\n   explicit RawSEDeviceMemory(se::DeviceMemoryBase value) : value_(value) {}\n@@ -69,10 +70,10 @@ class RawSEDeviceMemory : public tsl::ReferenceCounted<RawSEDeviceMemory> {\n   ShapedBuffer AsShapedBuffer(PjRtDevice* device,\n                               const Shape& on_device_shape) const;\n \n-  static tsl::AsyncValueRef<RawSEDeviceMemory> Create(\n+  static tsl::RCReference<RawSEDeviceMemory> Create(\n       se::DeviceMemoryBase value, LocalDeviceState* local_device,\n       se::DeviceMemoryAllocator* allocator);\n-  static tsl::AsyncValueRef<RawSEDeviceMemory> CreateForeign(\n+  static tsl::RCReference<RawSEDeviceMemory> CreateForeign(\n       se::DeviceMemoryBase value,\n       absl::AnyInvocable<void() &&> on_delete_callback);\n \n@@ -129,7 +130,7 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n       ExecutionInput* execution_input,\n       se::DeviceMemoryAllocator* allocator) const;\n \n-  const tsl::AsyncValueRef<RawSEDeviceMemory>& device_memory() const {\n+  const tsl::RCReference<RawSEDeviceMemory>& device_memory() const {\n     return device_memory_;\n   }\n \n@@ -167,7 +168,7 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   StreamAndEventContainer LockUseAndTransferUsageEvents();\n \n   TrackedDeviceBuffer(\n-      PjRtDevice* device, tsl::AsyncValueRef<RawSEDeviceMemory> device_memory,\n+      PjRtDevice* device, tsl::RCReference<RawSEDeviceMemory> device_memory,\n       absl::Span<const BufferSequencingEventRef> definition_events);\n   ~TrackedDeviceBuffer() override;\n \n@@ -198,7 +199,7 @@ class TrackedDeviceBuffer : public AbstractTrackedDeviceBuffer {\n   PjRtDevice* device_;\n \n   // Each host-side buffer may have several buffers on-device.\n-  tsl::AsyncValueRef<RawSEDeviceMemory> device_memory_;\n+  tsl::RCReference<RawSEDeviceMemory> device_memory_;\n \n   // Events that are triggered when the content of one or more buffers is ready\n   // during multistream execution. May be nullptr, which is used in the"
        },
        {
            "sha": "c757f3c6cbb724604c2cf60f420e990330183349",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c7055c2e5bb6e70365de867dc0ac56e56689a122/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer_test.cc?ref=c7055c2e5bb6e70365de867dc0ac56e56689a122",
            "patch": "@@ -83,7 +83,7 @@ class TestDevice : public PjRtDevice {\n \n absl::StatusOr<std::shared_ptr<TrackedDeviceBuffer>> MakeArray(\n     const Shape& shape, LocalClient* client, PjRtDevice* device) {\n-  std::vector<tsl::AsyncValueRef<RawSEDeviceMemory>> device_buffers;\n+  std::vector<tsl::RCReference<RawSEDeviceMemory>> device_buffers;\n   TF_RETURN_IF_ERROR(ShapeUtil::ForEachSubshapeWithStatus(\n       client->backend().transfer_manager()->HostShapeToDeviceShape(shape),\n       [&](const Shape& subshape, const ShapeIndex&) -> absl::Status {"
        }
    ],
    "stats": {
        "total": 77,
        "additions": 39,
        "deletions": 38
    }
}