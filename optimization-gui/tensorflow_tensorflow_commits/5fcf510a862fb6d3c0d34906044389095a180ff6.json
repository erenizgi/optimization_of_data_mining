{
    "author": "majnemer",
    "message": "Refactor `tsl::numbers` to use `absl::StrAppendFormat` and improve negative number handling.\n\nThis change replaces usages of `Appendf` with `absl::StrAppendFormat` and updates includes. It also refactors `HumanReadableNum` and `HumanReadableNumBytes` to handle negative inputs, including `std::numeric_limits<int64_t>::min()`, by converting to `uint64_t` for magnitude calculations and prepending a negative sign. The special case for `kint64min` in `HumanReadableNumBytes` is removed, and the output is now a properly formatted byte string.\n\nPiperOrigin-RevId: 828790023",
    "sha": "5fcf510a862fb6d3c0d34906044389095a180ff6",
    "files": [
        {
            "sha": "708de7097833db224c1c5627270d5f696ce59eb4",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/numbers.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 34,
            "changes": 62,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fcf510a862fb6d3c0d34906044389095a180ff6/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fnumbers.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fcf510a862fb6d3c0d34906044389095a180ff6/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fnumbers.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fnumbers.cc?ref=5fcf510a862fb6d3c0d34906044389095a180ff6",
            "patch": "@@ -14,12 +14,9 @@ limitations under the License.\n \n #include \"tsl/platform/numbers.h\"\n \n-#include <stdio.h>\n-#include <stdlib.h>\n-\n #include <algorithm>\n #include <charconv>\n-#include <cmath>\n+#include <cstddef>\n #include <cstdint>\n #include <limits>\n #include <optional>\n@@ -32,9 +29,7 @@ limitations under the License.\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/platform/logging.h\"\n-#include \"xla/tsl/platform/macros.h\"\n #include \"xla/tsl/platform/types.h\"\n-#include \"tsl/platform/stringprintf.h\"\n \n namespace tsl {\n \n@@ -201,46 +196,45 @@ bool HexStringToUint64(absl::string_view s, uint64_t* result) {\n   return true;\n }\n \n-std::string HumanReadableNum(int64_t value) {\n+std::string HumanReadableNum(int64_t signed_value) {\n   std::string s;\n-  if (value < 0) {\n-    s += \"-\";\n+\n+  uint64_t value = static_cast<uint64_t>(signed_value);\n+  if (signed_value < 0) {\n+    s = \"-\";\n     value = -value;\n   }\n   if (value < 1000) {\n-    Appendf(&s, \"%lld\", static_cast<long long>(value));\n+    absl::StrAppendFormat(&s, \"%d\", value);\n   } else if (value >= static_cast<int64_t>(1e15)) {\n     // Number bigger than 1E15; use that notation.\n-    Appendf(&s, \"%0.3G\", static_cast<double>(value));\n+    absl::StrAppendFormat(&s, \"%0.3G\", static_cast<double>(value));\n   } else {\n-    static const char units[] = \"kMBT\";\n-    const char* unit = units;\n+    static absl::string_view kUnits = \"kMBT\";\n+    auto unit = kUnits.begin();\n     while (value >= static_cast<int64_t>(1000000)) {\n       value /= static_cast<int64_t>(1000);\n       ++unit;\n-      CHECK(unit < units + TF_ARRAYSIZE(units));\n+      CHECK(unit < kUnits.end());\n     }\n-    Appendf(&s, \"%.2f%c\", value / 1000.0, *unit);\n+    absl::StrAppendFormat(&s, \"%.2f%c\", value / 1000.0, *unit);\n   }\n   return s;\n }\n \n-std::string HumanReadableNumBytes(int64_t num_bytes) {\n-  if (num_bytes == kint64min) {\n-    // Special case for number with not representable negation.\n-    return \"-8E\";\n-  }\n-\n+std::string HumanReadableNumBytes(int64_t signed_num_bytes) {\n   static absl::string_view kNegSign = \"-\";\n-  absl::string_view neg_str = (num_bytes < 0) ? kNegSign : \"\";\n-  if (num_bytes < 0) {\n+  absl::string_view sign_str;\n+  uint64_t num_bytes = static_cast<uint64_t>(signed_num_bytes);\n+  if (signed_num_bytes < 0) {\n     num_bytes = -num_bytes;\n+    sign_str = kNegSign;\n   }\n \n   // Special case for bytes.\n   if (num_bytes < 1024) {\n     // No fractions for bytes.\n-    return absl::StrCat(neg_str, num_bytes, \"B\");\n+    return absl::StrCat(sign_str, num_bytes, \"B\");\n   }\n \n   static absl::string_view kUnits = \"KMGTPE\";  // int64 only goes up to E.\n@@ -252,7 +246,7 @@ std::string HumanReadableNumBytes(int64_t num_bytes) {\n   }\n \n   // We use SI prefixes.\n-  return absl::StrFormat(\"%s%.*f%ciB\", neg_str, *unit == 'K' ? 1 : 2,\n+  return absl::StrFormat(\"%s%.*f%ciB\", sign_str, *unit == 'K' ? 1 : 2,\n                          num_bytes / 1024.0, *unit);\n }\n \n@@ -269,43 +263,43 @@ std::string HumanReadableElapsedTime(double seconds) {\n   // the tested condition and returning, e.g., \"1e+03 us\" instead of \"1 ms\".\n   const double microseconds = seconds * 1.0e6;\n   if (microseconds < 999.5) {\n-    strings::Appendf(&human_readable, \"%0.3g us\", microseconds);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g us\", microseconds);\n     return human_readable;\n   }\n   double milliseconds = seconds * 1e3;\n   if (milliseconds >= .995 && milliseconds < 1) {\n-    // Round half to even in Appendf would convert this to 0.999 ms.\n+    // Round half to even in StrAppendFormat would convert this to 0.999 ms.\n     milliseconds = 1.0;\n   }\n   if (milliseconds < 999.5) {\n-    strings::Appendf(&human_readable, \"%0.3g ms\", milliseconds);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g ms\", milliseconds);\n     return human_readable;\n   }\n   if (seconds < 60.0) {\n-    strings::Appendf(&human_readable, \"%0.3g s\", seconds);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g s\", seconds);\n     return human_readable;\n   }\n   seconds /= 60.0;\n   if (seconds < 60.0) {\n-    strings::Appendf(&human_readable, \"%0.3g min\", seconds);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g min\", seconds);\n     return human_readable;\n   }\n   seconds /= 60.0;\n   if (seconds < 24.0) {\n-    strings::Appendf(&human_readable, \"%0.3g h\", seconds);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g h\", seconds);\n     return human_readable;\n   }\n   seconds /= 24.0;\n   if (seconds < 30.0) {\n-    strings::Appendf(&human_readable, \"%0.3g days\", seconds);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g days\", seconds);\n     return human_readable;\n   }\n   if (seconds < 365.2425) {\n-    strings::Appendf(&human_readable, \"%0.3g months\", seconds / 30.436875);\n+    absl::StrAppendFormat(&human_readable, \"%0.3g months\", seconds / 30.436875);\n     return human_readable;\n   }\n   seconds /= 365.2425;\n-  strings::Appendf(&human_readable, \"%0.3g years\", seconds);\n+  absl::StrAppendFormat(&human_readable, \"%0.3g years\", seconds);\n   return human_readable;\n }\n "
        },
        {
            "sha": "1cd033e7bc3f25f99a3621c21fcd4e2054674203",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/numbers_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5fcf510a862fb6d3c0d34906044389095a180ff6/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fnumbers_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5fcf510a862fb6d3c0d34906044389095a180ff6/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fnumbers_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fnumbers_test.cc?ref=5fcf510a862fb6d3c0d34906044389095a180ff6",
            "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n #include \"tsl/platform/numbers.h\"\n \n #include <cmath>\n+#include <cstdint>\n #include <cstdlib>\n #include <limits>\n #include <string>\n@@ -75,6 +76,8 @@ TEST(HumanReadableNum, Basic) {\n   EXPECT_EQ(HumanReadableNum(1048576), \"1.05M\");\n   EXPECT_EQ(HumanReadableNum(23956812342), \"23.96B\");\n   EXPECT_EQ(HumanReadableNum(123456789012345678), \"1.23E+17\");\n+  EXPECT_EQ(HumanReadableNum(std::numeric_limits<int64_t>::max()), \"9.22E+18\");\n+  EXPECT_EQ(HumanReadableNum(std::numeric_limits<int64_t>::min()), \"-9.22E+18\");\n }\n \n TEST(HumanReadableNumBytes, Bytes) {\n@@ -101,7 +104,8 @@ TEST(HumanReadableNumBytes, Bytes) {\n   EXPECT_EQ(\"-4B\", HumanReadableNumBytes(-4));\n   EXPECT_EQ(\"-1000B\", HumanReadableNumBytes(-1000));\n   EXPECT_EQ(\"-11.77MiB\", HumanReadableNumBytes(-12345678));\n-  EXPECT_EQ(\"-8E\", HumanReadableNumBytes(kint64min));\n+  EXPECT_EQ(\"-8.00EiB\",\n+            HumanReadableNumBytes(std::numeric_limits<int64_t>::min()));\n }\n \n TEST(HumanReadableElapsedTime, Basic) {"
        }
    ],
    "stats": {
        "total": 68,
        "additions": 33,
        "deletions": 35
    }
}