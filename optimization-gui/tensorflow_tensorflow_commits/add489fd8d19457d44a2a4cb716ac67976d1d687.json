{
    "author": "khasanovaa",
    "message": "Use `std::vector<BufferAllocation>` instead of `std::vector<std::unique_ptr<BufferAllocation>>` in DynamicSliceThunk.\n\n`BufferAllocation::Slice` stores a raw pointer to the corresponding `BufferAllocation`. Now we keep the embedded thunk allocations alive by stroing unique_ptrs in the wrapping DynamicSliceThunk. The current design makes it hard to reuse the existing infrastructure, specifically to serialize `DynamicSliceThunk`. To address this, I'm changing fake_allocations to be  `std::vector<BufferAllocation>`.\n\nThe move constructor `std::vector::vector(std::vector&&)` is guaranteed to have constant time complexity and therefore it steals the internal data buffer from the source vector. This infers that the pointers to allocations are kept stable as long as:\n* we preallocate the vector size\n* we never copy the vector, but move\n\nTo make it safer for later usage, we can explicitely prohibid BufferAllocation to be  copyable/moveable. I'm going to do this in the following cl.\n\nPiperOrigin-RevId: 826440060",
    "sha": "add489fd8d19457d44a2a4cb716ac67976d1d687",
    "files": [
        {
            "sha": "3edb7e69f3221ff03a983b2dd9a150f6f72b9072",
            "filename": "third_party/xla/xla/backends/gpu/codegen/custom.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 31,
            "changes": 60,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Fcustom.cc?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -613,7 +613,7 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n   // different offset by creating new fake allocations so each operand will\n   // have a different buffer index. The slices can thus always start at offset\n   // 0. DynamicSliceThunk will take care of the offset adjustment.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(4);\n+  std::vector<BufferAllocation> fake_allocations(4, {0, 0, 0});\n   if (fusion.shape().IsArray()) {\n     TF_ASSIGN_OR_RETURN(\n         output, GetResultSlice(buffer_assignment, adaptor, fusion, custom_call,\n@@ -645,10 +645,10 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n         offset_buffer_indices, orig_shapes, sliced_shapes, offset_byte_sizes,\n         extracted_offset_modules, arg_idx, can_compute_indvar_on_host, while_op,\n         indvar_idx, inlined_module));\n-    fake_allocations[arg_idx] = std::make_unique<BufferAllocation>(\n+    fake_allocations[arg_idx] = BufferAllocation(\n         /*index=*/arg_idx, workspace->size(), /*color=*/0);\n-    slice_workspace_fake = BufferAllocation::Slice(\n-        fake_allocations[arg_idx].get(), 0, workspace->size());\n+    slice_workspace_fake = BufferAllocation::Slice(&fake_allocations[arg_idx],\n+                                                   0, workspace->size());\n   }\n \n   if (absl::c_all_of(slice_instrs, [&](auto slice_instr) {\n@@ -676,27 +676,27 @@ absl::StatusOr<FusionEmissionResult> EmitGemm(\n     unsigned fake_arg_idx = 0;\n     int64_t lhs_byte_size =\n         ShapeUtil::ByteSizeOf(custom_call.operand(fake_arg_idx)->shape());\n-    fake_allocations[fake_arg_idx] = std::make_unique<BufferAllocation>(\n+    fake_allocations[fake_arg_idx] = BufferAllocation(\n         /*index=*/fake_arg_idx, lhs_byte_size, /*color=*/0);\n-    BufferAllocation::Slice slice_lhs_fake(fake_allocations[fake_arg_idx].get(),\n-                                           0, lhs_byte_size);\n+    BufferAllocation::Slice slice_lhs_fake(&fake_allocations[fake_arg_idx], 0,\n+                                           lhs_byte_size);\n \n     fake_arg_idx++;\n     int64_t rhs_byte_size =\n         ShapeUtil::ByteSizeOf(custom_call.operand(fake_arg_idx)->shape());\n-    fake_allocations[fake_arg_idx] = std::make_unique<BufferAllocation>(\n+    fake_allocations[fake_arg_idx] = BufferAllocation(\n         /*index=*/fake_arg_idx, rhs_byte_size, /*color=*/0);\n-    BufferAllocation::Slice slice_rhs_fake(fake_allocations[fake_arg_idx].get(),\n-                                           0, rhs_byte_size);\n+    BufferAllocation::Slice slice_rhs_fake(&fake_allocations[fake_arg_idx], 0,\n+                                           rhs_byte_size);\n \n     fake_arg_idx++;\n     int64_t out_fake_byte_size = ShapeUtil::ByteSizeOf(\n         custom_call.shape().IsArray() ? custom_call.shape()\n                                       : custom_call.shape().tuple_shapes(0));\n-    fake_allocations[fake_arg_idx] = std::make_unique<BufferAllocation>(\n+    fake_allocations[fake_arg_idx] = BufferAllocation(\n         /*index=*/fake_arg_idx, out_fake_byte_size, /*color=*/0);\n-    BufferAllocation::Slice slice_out_fake(fake_allocations[fake_arg_idx].get(),\n-                                           0, out_fake_byte_size);\n+    BufferAllocation::Slice slice_out_fake(&fake_allocations[fake_arg_idx], 0,\n+                                           out_fake_byte_size);\n     ThunkSequence seq;\n     seq.emplace_back(std::make_unique<GemmThunk>(\n         thunk_info, std::move(config), slice_lhs_fake, slice_rhs_fake,\n@@ -962,7 +962,7 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n                                    ir_emitter_context.platform_name());\n   };\n \n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(num_args);\n+  std::vector<BufferAllocation> fake_allocations(num_args, {0, 0, 0});\n   if (absl::c_any_of(slice_instrs, IsDynamicSliceOrDynamicUpdateSlice)) {\n     // Creating embedded custom call thunk.\n     unsigned fake_arg_idx = 0;\n@@ -982,10 +982,10 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n             }\n \n             int64_t operand_byte_size = ShapeUtil::ByteSizeOf(subshape);\n-            fake_allocations[fake_arg_idx] = std::make_unique<BufferAllocation>(\n+            fake_allocations[fake_arg_idx] = BufferAllocation(\n                 /*index=*/fake_arg_idx, operand_byte_size, /*color=*/0);\n-            BufferAllocation::Slice fake_slice(\n-                fake_allocations[fake_arg_idx].get(), 0, operand_byte_size);\n+            BufferAllocation::Slice fake_slice(&fake_allocations[fake_arg_idx],\n+                                               0, operand_byte_size);\n \n             fake_arg_idx++;\n             fake_operands.push_back(ShapedSlice{fake_slice, subshape});\n@@ -1007,10 +1007,10 @@ absl::StatusOr<FusionEmissionResult> EmitCustomCall(\n           }\n \n           int64_t result_byte_size = ShapeUtil::ByteSizeOf(subshape);\n-          fake_allocations[fake_arg_idx] = std::make_unique<BufferAllocation>(\n+          fake_allocations[fake_arg_idx] = BufferAllocation(\n               /*index=*/fake_arg_idx, result_byte_size, /*color=*/0);\n-          BufferAllocation::Slice fake_slice(\n-              fake_allocations[fake_arg_idx].get(), 0, result_byte_size);\n+          BufferAllocation::Slice fake_slice(&fake_allocations[fake_arg_idx], 0,\n+                                             result_byte_size);\n \n           fake_arg_idx++;\n           fake_results.push_back(ShapedSlice{fake_slice, subshape});\n@@ -1065,7 +1065,7 @@ using Slices = std::vector<Slice>;\n // fake_arguments: the fake slices of the inputs/outputs of the hero\n // instruction, when the slicing is dynamic.\n struct SliceDataForCollectives {\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n+  std::vector<BufferAllocation> fake_allocations;\n   std::vector<HloInstruction*> slice_instrs;\n   Slices arguments, fake_arguments;\n   std::vector<std::optional<std::vector<DynamicSliceThunk::Offset>>>\n@@ -1076,7 +1076,7 @@ struct SliceDataForCollectives {\n   std::unique_ptr<HloModule> init_module, update_module;\n   bool isDynamic, can_compute_indvar_on_host;\n   explicit SliceDataForCollectives(int num_args)\n-      : fake_allocations(num_args),\n+      : fake_allocations(num_args, {0, 0, 0}),\n         slice_instrs(num_args),\n         arguments(num_args, std::nullopt),\n         fake_arguments(num_args, std::nullopt),\n@@ -1197,11 +1197,10 @@ CollectSliceArgumentMetadataForCollectives(\n     unsigned fake_arg_idx = 0;\n     for (HloInstruction* operand : instr->operands()) {\n       int64_t operand_byte_size = ShapeUtil::ByteSizeOf(operand->shape());\n-      slice_data.fake_allocations[fake_arg_idx] =\n-          std::make_unique<BufferAllocation>(\n-              /*index=*/fake_arg_idx, operand_byte_size, /*color=*/0);\n+      slice_data.fake_allocations[fake_arg_idx] = BufferAllocation(\n+          /*index=*/fake_arg_idx, operand_byte_size, /*color=*/0);\n       BufferAllocation::Slice fake_slice(\n-          /*allocation=*/slice_data.fake_allocations[fake_arg_idx].get(),\n+          /*allocation=*/&slice_data.fake_allocations[fake_arg_idx],\n           /*offset=*/0,\n           /*size=*/operand_byte_size);\n       slice_data.fake_arguments[fake_arg_idx] = fake_slice;\n@@ -1217,12 +1216,11 @@ CollectSliceArgumentMetadataForCollectives(\n     }\n     for (const HloInstruction* user : collective_results) {\n       int64_t out_fake_byte_size = ShapeUtil::ByteSizeOf(user->shape());\n-      slice_data.fake_allocations[fake_arg_idx] =\n-          std::make_unique<BufferAllocation>(\n-              /*index=*/fake_arg_idx, /*size=*/out_fake_byte_size,\n-              /*color=*/0);\n+      slice_data.fake_allocations[fake_arg_idx] = BufferAllocation(\n+          /*index=*/fake_arg_idx, /*size=*/out_fake_byte_size,\n+          /*color=*/0);\n       BufferAllocation::Slice fake_slice(\n-          /*allocation=*/slice_data.fake_allocations[fake_arg_idx].get(),\n+          /*allocation=*/&slice_data.fake_allocations[fake_arg_idx],\n           /*offset=*/0, /*size=*/out_fake_byte_size);\n       slice_data.fake_arguments[fake_arg_idx] = fake_slice;\n       fake_arg_idx++;"
        },
        {
            "sha": "3128e938c9ed0b0471898c742f466fd3451e9160",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_cmd.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.cc?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -2377,7 +2377,7 @@ CommandBufferCmd::BufferUseVector CollectiveBroadcastCmd::buffers() const {\n DynamicSliceFusionCmd::DynamicSliceFusionCmd(\n     CommandBufferCmdExecutor embedded_commands,\n     std::vector<std::optional<BufferAllocation::Slice>> arguments,\n-    std::vector<std::unique_ptr<BufferAllocation>> fake_allocations,\n+    std::vector<BufferAllocation> fake_allocations,\n     std::vector<std::optional<std::vector<DynamicSliceThunk::Offset>>> offsets,\n     std::vector<std::optional<Shape>> orig_shapes,\n     std::vector<std::optional<Shape>> sliced_shapes,"
        },
        {
            "sha": "b624f207c3848d89d157870f40ad3e342d4073da",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_cmd.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd.h?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -1217,7 +1217,7 @@ class DynamicSliceFusionCmd : public CommandBufferCmd {\n   DynamicSliceFusionCmd(\n       CommandBufferCmdExecutor embedded_commands,\n       std::vector<std::optional<BufferAllocation::Slice>> arguments,\n-      std::vector<std::unique_ptr<BufferAllocation>> fake_allocations_,\n+      std::vector<BufferAllocation> fake_allocations,\n       std::vector<std::optional<std::vector<DynamicSliceThunk::Offset>>>\n           offsets,\n       std::vector<std::optional<Shape>> orig_shapes,\n@@ -1252,7 +1252,7 @@ class DynamicSliceFusionCmd : public CommandBufferCmd {\n  private:\n   CommandBufferCmdExecutor embedded_commands_;\n   std::vector<DynamicSliceThunk::SliceDef> slices_;\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations_;\n+  std::vector<BufferAllocation> fake_allocations_;\n \n   // Pinned host memory for transferring offset values from device to host.\n   absl::Mutex mutex_;"
        },
        {
            "sha": "dc33b07659f5b1ae5796c381be8a8e3e884997fa",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_cmd_emitter.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_cmd_emitter.cc?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -197,10 +197,10 @@ static absl::StatusOr<Command> Convert(\n       ConvertToCommands(thunk.get_embedded_thunk()->thunks(), options));\n \n   auto& thunk_fake_allocations = thunk.get_fake_allocations();\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n+  std::vector<BufferAllocation> fake_allocations;\n   for (auto it = thunk_fake_allocations.begin();\n        it != thunk_fake_allocations.end(); ++it) {\n-    fake_allocations.push_back(std::make_unique<BufferAllocation>(**it));\n+    fake_allocations.push_back(BufferAllocation(*it));\n   }\n   return std::make_unique<DynamicSliceFusionCmd>(\n       std::move(embedded_cmds), thunk.get_arguments(),"
        },
        {
            "sha": "245c5b65689b50ad16072985ed89f218fed4d970",
            "filename": "third_party/xla/xla/backends/gpu/runtime/command_buffer_thunk_test.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 16,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_thunk_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_thunk_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fcommand_buffer_thunk_test.cc?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -949,24 +949,22 @@ TEST(CommandBufferThunkTest, DISABLED_DynamicSliceFusionCmd) {\n   TF_ASSERT_OK(stream->MemZero(&workspace, 1024 * 1024));\n \n   // Prepare buffer allocations for recording command buffer.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(4);\n-  fake_allocations[0] = std::make_unique<BufferAllocation>(\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(\n       /*index=*/0, fake_lhs_length, /*color=*/0);\n-  fake_allocations[1] =\n-      std::make_unique<BufferAllocation>(/*index=*/1, rhs_length, /*color=*/0);\n-  fake_allocations[2] =\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length,\n-                                         /*color=*/0);\n-\n-  fake_allocations[3] =\n-      std::make_unique<BufferAllocation>(/*index=*/3, 1024 * 1024,\n-                                         /*color=*/0);\n-  BufferAllocation::Slice fake_slice_lhs(fake_allocations[0].get(), 0,\n+  fake_allocations.emplace_back(\n+      /*index=*/1, rhs_length, /*color=*/0);\n+  fake_allocations.emplace_back(/*index=*/2, out_length,\n+                                /*color=*/0);\n+\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024,\n+                                /*color=*/0);\n+  BufferAllocation::Slice fake_slice_lhs(&fake_allocations[0], 0,\n                                          fake_lhs_length);\n-  BufferAllocation::Slice slice_rhs(fake_allocations[1].get(), 0, rhs_length);\n-  BufferAllocation::Slice slice_out(fake_allocations[2].get(), 0, out_length);\n-  BufferAllocation::Slice slice_workspace(fake_allocations[3].get(), 0,\n-                                          1024 * 1024);\n+  BufferAllocation::Slice slice_rhs(&fake_allocations[1], 0, rhs_length);\n+  BufferAllocation::Slice slice_out(&fake_allocations[2], 0, out_length);\n+  BufferAllocation::Slice slice_workspace(&fake_allocations[3], 0, 1024 * 1024);\n   auto config = GemmConfig::For(\n       ShapeUtil::MakeShape(PrimitiveType::F32, {2, 4}), {}, {1},\n       ShapeUtil::MakeShape(PrimitiveType::F32, {4, 3}), {}, {0},"
        },
        {
            "sha": "98763d288d44e0f69f38eaa4d250b0c2fe360047",
            "filename": "third_party/xla/xla/backends/gpu/runtime/dynamic_slice_thunk.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.cc?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -175,7 +175,7 @@ std::string DynamicSliceThunk::SliceDef::ToString() const {\n DynamicSliceThunk::DynamicSliceThunk(\n     ThunkInfo thunk_info, std::unique_ptr<ThunkSequence> embedded_thunk,\n     std::vector<std::optional<BufferAllocation::Slice>> arguments,\n-    std::vector<std::unique_ptr<BufferAllocation>> fake_allocations,\n+    std::vector<BufferAllocation> fake_allocations,\n     std::vector<std::optional<std::vector<Offset>>> offsets,\n     std::vector<std::optional<Shape>> orig_shapes,\n     std::vector<std::optional<Shape>> sliced_shapes,\n@@ -687,8 +687,8 @@ absl::StatusOr<std::unique_ptr<DynamicSliceThunk>> DynamicSliceThunk::FromProto(\n   return std::make_unique<DynamicSliceThunk>(\n       thunk_info, std::make_unique<ThunkSequence>(std::move(embedded_thunks)),\n       std::move(arguments),\n-      /*fake_allocations=*/std::vector<std::unique_ptr<BufferAllocation>>(),\n-      std::move(offsets), std::move(orig_shapes), std::move(sliced_shapes),\n+      /*fake_allocations=*/std::vector<BufferAllocation>(), std::move(offsets),\n+      std::move(orig_shapes), std::move(sliced_shapes),\n       std::move(offset_byte_sizes),\n       std::move(offset_as_function_of_indvar_metadata));\n }"
        },
        {
            "sha": "c0a08b335394fc5d648f3d4d6db939f9c12e9ad7",
            "filename": "third_party/xla/xla/backends/gpu/runtime/dynamic_slice_thunk.h",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk.h?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -114,7 +114,7 @@ class DynamicSliceThunk : public Thunk {\n   DynamicSliceThunk(\n       ThunkInfo thunk_info, std::unique_ptr<ThunkSequence> embedded_thunk,\n       std::vector<std::optional<BufferAllocation::Slice>> arguments,\n-      std::vector<std::unique_ptr<BufferAllocation>> fake_allocations,\n+      std::vector<BufferAllocation> fake_allocations,\n       std::vector<std::optional<std::vector<Offset>>> offsets,\n       std::vector<std::optional<Shape>> orig_shapes,\n       std::vector<std::optional<Shape>> sliced_shapes,\n@@ -150,8 +150,7 @@ class DynamicSliceThunk : public Thunk {\n     return arguments_;\n   }\n \n-  const std::vector<std::unique_ptr<BufferAllocation>>& get_fake_allocations()\n-      const {\n+  const std::vector<BufferAllocation>& get_fake_allocations() const {\n     return fake_allocations_;\n   }\n \n@@ -204,7 +203,7 @@ class DynamicSliceThunk : public Thunk {\n  private:\n   std::unique_ptr<SequentialThunk> embedded_thunk_;\n   std::vector<std::optional<BufferAllocation::Slice>> arguments_;\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations_;\n+  std::vector<BufferAllocation> fake_allocations_;\n   std::vector<std::optional<std::vector<Offset>>> offsets_;\n   std::vector<std::optional<Shape>> orig_shapes_;\n   std::vector<std::optional<Shape>> sliced_shapes_;"
        },
        {
            "sha": "6c09bb8a2288b96a871d65c3b362302d2520c7a5",
            "filename": "third_party/xla/xla/backends/gpu/runtime/dynamic_slice_thunk_test.cc",
            "status": "modified",
            "additions": 90,
            "deletions": 119,
            "changes": 209,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/add489fd8d19457d44a2a4cb716ac67976d1d687/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fdynamic_slice_thunk_test.cc?ref=add489fd8d19457d44a2a4cb716ac67976d1d687",
            "patch": "@@ -161,28 +161,24 @@ absl::StatusOr<std::unique_ptr<DynamicSliceThunk>> CreateSlicedGemmThunk(\n   int64_t out_length = sizeof(float) * 1 * 1;\n   int64_t offset_length = sizeof(int64_t);\n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/0, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_lhs_fake(fake_allocations.back().get(), 0,\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+\n+  fake_allocations.emplace_back(/*index=*/0, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_lhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n \n   auto alloc_lhs =\n       std::make_unique<BufferAllocation>(/*index=*/0, lhs_length, /*color=*/0);\n   BufferAllocation::Slice slice_lhs(alloc_lhs.get(), 0, lhs_length);\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/1, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_rhs(fake_allocations.back().get(), 0,\n-                                    rhs_length);\n-\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length, /*color=*/0));\n-  BufferAllocation::Slice slice_out(fake_allocations.back().get(), 0,\n-                                    out_length);\n+  fake_allocations.emplace_back(/*index=*/1, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_rhs(&fake_allocations.back(), 0, rhs_length);\n+\n+  fake_allocations.emplace_back(/*index=*/2, out_length, /*color=*/0);\n+  BufferAllocation::Slice slice_out(&fake_allocations.back(), 0, out_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, 1024 * 1024, /*color=*/0));\n-  BufferAllocation::Slice slice_workspace(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024, /*color=*/0);\n+  BufferAllocation::Slice slice_workspace(&fake_allocations.back(), 0,\n                                           1024 * 1024);\n \n   auto alloc_lhs_offset_0 = std::make_unique<BufferAllocation>(\n@@ -323,28 +319,24 @@ CreateMultipleSlicedOperandsGemmThunk(\n   int64_t offset_length = sizeof(int64_t);\n   int64_t slice_length = sizeof(float) * 3;\n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/0, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_lhs_fake(fake_allocations.back().get(), 0,\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(/*index=*/0, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_lhs_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/1, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_rhs_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/1, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_rhs_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n   auto alloc_lhs =\n       std::make_unique<BufferAllocation>(/*index=*/0, length, /*color=*/0);\n   BufferAllocation::Slice slice_lhs(alloc_lhs.get(), 0, length);\n   auto alloc_rhs =\n       std::make_unique<BufferAllocation>(/*index=*/1, length, /*color=*/0);\n   BufferAllocation::Slice slice_rhs(alloc_rhs.get(), 0, length);\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length, /*color=*/0));\n-  BufferAllocation::Slice slice_out(fake_allocations.back().get(), 0,\n-                                    out_length);\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, 1024 * 1024, /*color=*/0));\n-  BufferAllocation::Slice slice_workspace(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/2, out_length, /*color=*/0);\n+  BufferAllocation::Slice slice_out(&fake_allocations.back(), 0, out_length);\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024, /*color=*/0);\n+  BufferAllocation::Slice slice_workspace(&fake_allocations.back(), 0,\n                                           1024 * 1024);\n   auto alloc_lhs_offset_0 = std::make_unique<BufferAllocation>(\n       /*index=*/4, offset_length, /*color=*/0);\n@@ -540,21 +532,19 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpy) {\n   // Prepare embedded and dynamic slice thunks.\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(2);\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(2);\n \n   // Fake slices for embedded thunk creation.\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/0, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_src_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/0, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_src_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n \n   BufferAllocation alloc_src(/*index=*/0, src_length, /*color=*/0);\n   BufferAllocation::Slice slice_src(&alloc_src, 0, src_length);\n \n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/1, dst_length, /*color=*/0));\n-  BufferAllocation::Slice slice_dst(fake_allocations.back().get(), 0,\n-                                    dst_length);\n+  fake_allocations.emplace_back(/*index=*/1, dst_length, /*color=*/0);\n+  BufferAllocation::Slice slice_dst(&fake_allocations.back(), 0, dst_length);\n \n   BufferAllocation alloc_offset_0(/*index=*/2, offset_length, /*color=*/0);\n   BufferAllocation::Slice slice_offset_0(&alloc_offset_0, 0, offset_length);\n@@ -678,17 +668,16 @@ TEST_F(DynamicSliceThunkTest, SlicedOutputMemcpy) {\n   // Prepare embedded and dynamic slice thunks.\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(2);\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(2);\n \n   // Fake slices for embedded thunk creation.\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/0, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_src_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/0, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_src_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/1, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_dst_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/1, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_dst_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n \n   BufferAllocation alloc_src(/*index=*/0, src_length, /*color=*/0);\n@@ -868,22 +857,19 @@ CreateSlicedGemmArbitraryArgumentOrderThunk(\n   int64_t offset_length = sizeof(int64_t);\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/0, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_lhs_fake(fake_allocations.back().get(), 0,\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(/*index=*/0, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_lhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/1, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_rhs_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/1, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_rhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length, /*color=*/0));\n-  BufferAllocation::Slice slice_out_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/2, out_length, /*color=*/0);\n+  BufferAllocation::Slice slice_out_fake(&fake_allocations.back(), 0,\n                                          out_length);\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, 1024 * 1024, /*color=*/0));\n-  BufferAllocation::Slice slice_workspace_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024, /*color=*/0);\n+  BufferAllocation::Slice slice_workspace_fake(&fake_allocations.back(), 0,\n                                                1024 * 1024);\n \n   auto alloc_lhs =\n@@ -1043,22 +1029,19 @@ CreateSlicedGemmArbitraryNumberOfArgumentsThunk(\n   int64_t offset_length = sizeof(int64_t);\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/0, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_lhs_fake(fake_allocations.back().get(), 0,\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(/*index=*/0, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_lhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/1, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_rhs_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/1, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_rhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length, /*color=*/0));\n-  BufferAllocation::Slice slice_out_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/2, out_length, /*color=*/0);\n+  BufferAllocation::Slice slice_out_fake(&fake_allocations.back(), 0,\n                                          out_length);\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, 1024 * 1024, /*color=*/0));\n-  BufferAllocation::Slice slice_workspace_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024, /*color=*/0);\n+  BufferAllocation::Slice slice_workspace_fake(&fake_allocations.back(), 0,\n                                                1024 * 1024);\n \n   auto alloc_lhs =\n@@ -1220,29 +1203,24 @@ CreateSlicedTupledOperandGemmThunk(\n   int64_t offset_length = sizeof(int64_t);\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/0, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_lhs_fake(fake_allocations.back().get(), 0,\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(/*index=*/0, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_lhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n \n   auto alloc_lhs = std::make_unique<BufferAllocation>(\n       /*index=*/0, 3 * lhs_length, /*color=*/0);\n   BufferAllocation::Slice slice_lhs(alloc_lhs.get(), lhs_length, lhs_length);\n \n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/1, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_rhs(fake_allocations.back().get(), 0,\n-                                    rhs_length);\n+  fake_allocations.emplace_back(/*index=*/1, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_rhs(&fake_allocations.back(), 0, rhs_length);\n \n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length, /*color=*/0));\n-  BufferAllocation::Slice slice_out(fake_allocations.back().get(), 0,\n-                                    out_length);\n+  fake_allocations.emplace_back(/*index=*/2, out_length, /*color=*/0);\n+  BufferAllocation::Slice slice_out(&fake_allocations.back(), 0, out_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, 1024 * 1024, /*color=*/0));\n-  BufferAllocation::Slice slice_workspace(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024, /*color=*/0);\n+  BufferAllocation::Slice slice_workspace(&fake_allocations.back(), 0,\n                                           1024 * 1024);\n \n   auto alloc_lhs_offset_0 = std::make_unique<BufferAllocation>(\n@@ -1398,17 +1376,16 @@ TEST_F(DynamicSliceThunkTest, SlicedMemcpyOOB) {\n   // Prepare embedded and dynamic slice thunks.\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations(2);\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(2);\n \n   // Fake slices for embedded thunk creation.\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/0, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_src_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/0, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_src_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/1, slice_length, /*color=*/0));\n-  BufferAllocation::Slice slice_dst_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/1, slice_length, /*color=*/0);\n+  BufferAllocation::Slice slice_dst_fake(&fake_allocations.back(), 0,\n                                          slice_length);\n \n   BufferAllocation alloc_src(/*index=*/0, src_length, /*color=*/0);\n@@ -1591,25 +1568,22 @@ CreateSlicedOperandsSameBufferGemmThunk(\n   int64_t offset_length = sizeof(int64_t);\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/0, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_lhs_fake(fake_allocations.back().get(), 0,\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(/*index=*/0, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_lhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n \n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/1, rhs_length, /*color=*/0));\n-  BufferAllocation::Slice slice_rhs_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/1, rhs_length, /*color=*/0);\n+  BufferAllocation::Slice slice_rhs_fake(&fake_allocations.back(), 0,\n                                          rhs_length);\n \n-  fake_allocations.push_back(\n-      std::make_unique<BufferAllocation>(/*index=*/2, out_length, /*color=*/0));\n-  BufferAllocation::Slice slice_out_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/2, out_length, /*color=*/0);\n+  BufferAllocation::Slice slice_out_fake(&fake_allocations.back(), 0,\n                                          out_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, 1024 * 1024, /*color=*/0));\n-  BufferAllocation::Slice slice_workspace_fake(fake_allocations.back().get(), 0,\n+  fake_allocations.emplace_back(/*index=*/3, 1024 * 1024, /*color=*/0);\n+  BufferAllocation::Slice slice_workspace_fake(&fake_allocations.back(), 0,\n                                                1024 * 1024);\n \n   auto alloc = std::make_unique<BufferAllocation>(\n@@ -1804,34 +1778,31 @@ CreateHostInductionVariableAndOffsetEvaluationThunk(\n   int64_t out_length = sizeof(float) * 1 * 1;\n \n   // Preparing buffer allocation slices for thunk creations.\n-  std::vector<std::unique_ptr<BufferAllocation>> fake_allocations;\n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/0, /*size=*/rhs_length, /*color=*/0));\n+  std::vector<BufferAllocation> fake_allocations;\n+  fake_allocations.reserve(4);\n+  fake_allocations.emplace_back(/*index=*/0, /*size=*/rhs_length, /*color=*/0);\n   BufferAllocation::Slice slice_lhs_fake(\n-      /*allocation=*/fake_allocations.back().get(), /*offset=*/0,\n+      /*allocation=*/&fake_allocations.back(), /*offset=*/0,\n       /*size=*/rhs_length);\n \n   auto alloc_lhs = std::make_unique<BufferAllocation>(\n       /*index=*/0, /*size=*/lhs_length, /*color=*/0);\n   BufferAllocation::Slice slice_lhs(alloc_lhs.get(), /*offset=*/0,\n                                     /*size=*/lhs_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/1, /*size=*/rhs_length, /*color=*/0));\n+  fake_allocations.emplace_back(/*index=*/1, /*size=*/rhs_length, /*color=*/0);\n   BufferAllocation::Slice slice_rhs(\n-      /*allocation=*/fake_allocations.back().get(), /*offset=*/0,\n+      /*allocation=*/&fake_allocations.back(), /*offset=*/0,\n       /*size=*/rhs_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/2, /*size=*/out_length, /*color=*/0));\n+  fake_allocations.emplace_back(/*index=*/2, /*size=*/out_length, /*color=*/0);\n   BufferAllocation::Slice slice_out(\n-      /*allocation=*/fake_allocations.back().get(), /*offset=*/0,\n+      /*allocation=*/&fake_allocations.back(), /*offset=*/0,\n       /*size=*/out_length);\n \n-  fake_allocations.push_back(std::make_unique<BufferAllocation>(\n-      /*index=*/3, /*size=*/1024 * 1024, /*color=*/0));\n+  fake_allocations.emplace_back(/*index=*/3, /*size=*/1024 * 1024, /*color=*/0);\n   BufferAllocation::Slice slice_workspace(\n-      /*allocation=*/fake_allocations.back().get(), /*offset=*/0,\n+      /*allocation=*/&fake_allocations.back(), /*offset=*/0,\n       /*size=*/1024 * 1024);\n \n   backing_allocations.push_back(std::move(alloc_lhs));"
        }
    ],
    "stats": {
        "total": 322,
        "additions": 144,
        "deletions": 178
    }
}