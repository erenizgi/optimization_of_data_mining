{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809660690",
    "sha": "ed103054407bcf720b9143c7adeb9e20984d8391",
    "files": [
        {
            "sha": "4befeb379d240923eafcf70100b31bc004258ce3",
            "filename": "third_party/xla/xla/backends/cpu/runtime/rng_state_lib.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ed103054407bcf720b9143c7adeb9e20984d8391/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Frng_state_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ed103054407bcf720b9143c7adeb9e20984d8391/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Frng_state_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Frng_state_lib.cc?ref=ed103054407bcf720b9143c7adeb9e20984d8391",
            "patch": "@@ -33,7 +33,7 @@ RngState::RngState(int64_t delta)\n     : delta_(delta), state_(kRngStateInitialValue) {}\n \n void RngState::GetAndUpdateState(uint64_t* data) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n \n   uint64_t low = absl::Int128Low64(state_);\n   uint64_t high = absl::Int128High64(state_);"
        },
        {
            "sha": "1d42b43f1731ad94a07101a217d2de3c054d22be",
            "filename": "third_party/xla/xla/backends/cpu/runtime/thunk_executor.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ed103054407bcf720b9143c7adeb9e20984d8391/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fthunk_executor.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ed103054407bcf720b9143c7adeb9e20984d8391/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fthunk_executor.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fthunk_executor.cc?ref=ed103054407bcf720b9143c7adeb9e20984d8391",
            "patch": "@@ -644,7 +644,7 @@ void ThunkExecutor::ProcessCompletedOutEdges(\n   // We still continue processing the nodes DAG to eventually mark sink nodes\n   // completed as it's easier than to add a special abort handling logic.\n   if (ABSL_PREDICT_FALSE(node_event.IsError())) {\n-    absl::MutexLock lock(&state->abort_mutex);\n+    absl::MutexLock lock(state->abort_mutex);\n     state->abort = true;\n     state->abort_status.Update(node_event.GetError());\n   }\n@@ -684,7 +684,7 @@ void ThunkExecutor::ProcessCompletedOutEdges(\n     // forward it to the caller via the execute event.\n     if (ABSL_PREDICT_FALSE(state->abort.load(std::memory_order_relaxed))) {\n       auto take_error = [&] {\n-        absl::MutexLock lock(&state->abort_mutex);\n+        absl::MutexLock lock(state->abort_mutex);\n         DCHECK(!state->abort_status.ok())\n             << \"Abort status must be set if execution is aborted\";\n         return std::move(state->abort_status);"
        },
        {
            "sha": "dba284fb1815a8a9ab9595efda5de21b4e9494ba",
            "filename": "third_party/xla/xla/backends/cpu/runtime/xfeed_manager.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ed103054407bcf720b9143c7adeb9e20984d8391/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fxfeed_manager.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ed103054407bcf720b9143c7adeb9e20984d8391/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fxfeed_manager.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fruntime%2Fxfeed_manager.cc?ref=ed103054407bcf720b9143c7adeb9e20984d8391",
            "patch": "@@ -32,7 +32,7 @@ namespace xla::cpu {\n static absl::Mutex xfeed_manager_mutex(absl::kConstInit);\n \n XfeedManager* GetXfeedManager(int device_ordinal) {\n-  absl::MutexLock lock(&xfeed_manager_mutex);\n+  absl::MutexLock lock(xfeed_manager_mutex);\n   static auto* const managers = new absl::flat_hash_map<int, XfeedManager*>();\n \n   auto it = managers->find(device_ordinal);\n@@ -44,7 +44,7 @@ XfeedManager* GetXfeedManager(int device_ordinal) {\n \n void XfeedQueueManager::EnqueueBuffersAtomically(\n     absl::Span<XfeedBuffer* const> buffers) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   for (XfeedBuffer* b : buffers) {\n     VLOG(3) << \"Enqueueing \" << queue_name_ << \" buffer (of \" << buffers.size()\n             << \" buffers) with length: \" << b->length();\n@@ -57,7 +57,7 @@ XfeedBuffer* XfeedQueueManager::BlockingDequeueBuffer() {\n   auto available_buffer = [this]() ABSL_SHARED_LOCKS_REQUIRED(mu_) {\n     return !enqueued_buffers_.empty();\n   };\n-  absl::MutexLock l(&mu_, absl::Condition(&available_buffer));\n+  absl::MutexLock l(mu_, absl::Condition(&available_buffer));\n   VLOG(3) << \"A buffer is available!\";\n   CHECK(current_buffer_ == nullptr);\n   current_buffer_ = enqueued_buffers_.front();\n@@ -70,7 +70,7 @@ void XfeedQueueManager::ReleaseCurrentBuffer(int32_t length, void* data,\n   VLOG(3) << \"Releasing buffer with shape: \"\n           << (shape.ok() ? ShapeUtil::HumanString(shape.value())\n                          : \"<error status>\");\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   CHECK(current_buffer_ != nullptr);\n   CHECK_EQ(length, current_buffer_->length());\n   CHECK_EQ(data, current_buffer_->data());"
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}