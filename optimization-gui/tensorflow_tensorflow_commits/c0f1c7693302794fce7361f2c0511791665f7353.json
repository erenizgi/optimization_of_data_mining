{
    "author": "bixia1",
    "message": "Add tests to verify layout assignment for buffer chains.\n\nPiperOrigin-RevId: 800613801",
    "sha": "c0f1c7693302794fce7361f2c0511791665f7353",
    "files": [
        {
            "sha": "11287c6833a6ad7c32df9db4f884c2b6cb82d037",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c0f1c7693302794fce7361f2c0511791665f7353/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c0f1c7693302794fce7361f2c0511791665f7353/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=c0f1c7693302794fce7361f2c0511791665f7353",
            "patch": "@@ -3939,6 +3939,7 @@ xla_cc_test(\n     srcs = [\"layout_assignment_test.cc\"],\n     deps = [\n         \":computation_layout\",\n+        \":hlo_verifier\",\n         \":layout_assignment\",\n         \":logical_buffer\",\n         \":pattern_matcher\","
        },
        {
            "sha": "0a32f0b0354fb60cdffffb975adb76f894cfd838",
            "filename": "third_party/xla/xla/service/layout_assignment_test.cc",
            "status": "modified",
            "additions": 193,
            "deletions": 0,
            "changes": 193,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c0f1c7693302794fce7361f2c0511791665f7353/third_party%2Fxla%2Fxla%2Fservice%2Flayout_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c0f1c7693302794fce7361f2c0511791665f7353/third_party%2Fxla%2Fxla%2Fservice%2Flayout_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Flayout_assignment_test.cc?ref=c0f1c7693302794fce7361f2c0511791665f7353",
            "patch": "@@ -39,6 +39,7 @@ limitations under the License.\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n #include \"xla/service/computation_layout.h\"\n+#include \"xla/service/hlo_verifier.h\"\n #include \"xla/service/logical_buffer.h\"\n #include \"xla/service/pattern_matcher.h\"\n #include \"xla/shape.h\"\n@@ -68,6 +69,17 @@ class LayoutAssignmentTest : public HloTestBase {\n     EXPECT_IS_OK(layout_assignment.Run(m).status());\n   }\n \n+  absl::StatusOr<bool> AssignLayoutsAndVerifyHlo(\n+      HloModule* m, ComputationLayout* entry_computation_layout,\n+      ChannelLayoutConstraints* channel_constraints = nullptr) {\n+    LayoutAssignment layout_assignment(\n+        entry_computation_layout,\n+        /*channel_constraints=*/channel_constraints);\n+    EXPECT_IS_OK(layout_assignment.Run(m).status());\n+    HloVerifier verifier(/*layout_sensitive=*/true,\n+                         /*allow_mixed_precision=*/false);\n+    return verifier.Run(m);\n+  }\n   std::vector<int64_t> LayoutOf(HloModule* m, absl::string_view name) {\n     HloInstruction* instr = FindInstruction(m, name);\n     CHECK(instr != nullptr) << name;\n@@ -2169,5 +2181,186 @@ TEST_F(LayoutAssignmentTest, CustomCallAliasingOperandToTupleResult) {\n   ExpectLayoutIs(custom_call->shape().tuple_shapes(0), {0, 1});\n   ExpectLayoutIs(custom_call->shape().tuple_shapes(1), {1, 0});\n }\n+\n+// This tests forward propagation in a buffer chain.\n+TEST_F(LayoutAssignmentTest, BufferChainLayoutConstrainedComputationInput) {\n+  const char* module_str = R\"(\n+  HloModule test\n+  ENTRY test_computation {\n+    init = s32[2,8] parameter(0)\n+    b0 = b(s32[2,8]) custom-call(init), custom_call_target=\"Pin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    b1 = b(s32[2,8]) custom-call(b0), custom_call_target=\"CallBack_AddOne\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    ROOT v = s32[2,8] custom-call(b1), custom_call_target=\"Unpin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+  })\";\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<HloModule> m,\n+      ParseAndReturnVerifiedModule(\n+          module_str, /*config=*/{},\n+          HloParserOptions().set_fill_missing_layouts(false)));\n+  ComputationLayout* computation_layout = m->mutable_entry_computation_layout();\n+  *computation_layout->mutable_parameter_layout(0) =\n+      ShapeLayout(ShapeUtil::MakeShapeWithDenseLayout(S32, {2, 8}, {0, 1}));\n+  auto status = AssignLayoutsAndVerifyHlo(m.get(), computation_layout);\n+  EXPECT_TRUE(status.ok());\n+  EXPECT_EQ(FindInstruction(m.get(), HloOpcode::kCopy), nullptr);\n+  // Verify that Unpin custom-call gets the input parameter layout for its\n+  // operand and result.\n+  const HloInstruction* unpin = m->entry_computation()->root_instruction();\n+  ExpectLayoutIs(unpin->shape(), {0, 1});\n+  ExpectLayoutIs(unpin->operand(0)->shape(), {0, 1});\n+}\n+\n+// This tests backward propagation in a buffer chain.\n+TEST_F(LayoutAssignmentTest, BufferChainLayoutConstrainedComputationOutput) {\n+  const char* module_str = R\"(\n+  HloModule test\n+  ENTRY test_computation {\n+    init = s32[2,8] parameter(0)\n+    b0 = b(s32[2,8]) custom-call(init), custom_call_target=\"Pin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    b1 = b(s32[2,8]) custom-call(b0), custom_call_target=\"CallBack_AddOne\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    ROOT v = s32[2,8] custom-call(b1), custom_call_target=\"Unpin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+  })\";\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<HloModule> m,\n+      ParseAndReturnVerifiedModule(\n+          module_str, /*config=*/{},\n+          HloParserOptions().set_fill_missing_layouts(false)));\n+  ComputationLayout* computation_layout = m->mutable_entry_computation_layout();\n+  *computation_layout->mutable_result_layout() =\n+      ShapeLayout(ShapeUtil::MakeShapeWithDenseLayout(S32, {2, 8}, {0, 1}));\n+  auto status = AssignLayoutsAndVerifyHlo(m.get(), computation_layout);\n+  EXPECT_TRUE(status.ok());\n+  EXPECT_EQ(FindInstruction(m.get(), HloOpcode::kCopy), nullptr);\n+  // Verify that the Pin custom-call gets the computation result layout for its\n+  // operand and result.\n+  const HloInstruction* pin = FindInstruction(m.get(), \"b0\");\n+  ExpectLayoutIs(pin->shape(), {0, 1});\n+  ExpectLayoutIs(pin->operand(0)->shape(), {0, 1});\n+}\n+\n+// This shows the correct way of specifying the layout of a buffer is to use\n+// the operand_layout_constraints attribute on the Pin instruction. This is\n+// because Pin is the starting point of a buffer chain, and layout assignment\n+// inserts a copy when it sees an operand with layout constraints, regardless\n+// whether the operand is a buffer or non-buffer.\n+TEST_F(LayoutAssignmentTest, BufferChainLayoutConstrainedPin) {\n+  const char* module_str = R\"(\n+  HloModule test\n+  ENTRY test_computation {\n+    init = s32[2,8] parameter(0)\n+    b0 = b(s32[2,8]{0, 1}) custom-call(init), custom_call_target=\"Pin\",\n+      output_to_operand_aliasing={{}: (0, {})},\n+      operand_layout_constraints={s32[2,8]{0,1}}\n+    b1 = b(s32[2,8]) custom-call(b0), custom_call_target=\"CallBack_AddOne\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    ROOT v = s32[2,8] custom-call(b1), custom_call_target=\"Unpin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+  })\";\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<HloModule> m,\n+      ParseAndReturnVerifiedModule(\n+          module_str, /*config=*/{},\n+          HloParserOptions().set_fill_missing_layouts(false)));\n+  ComputationLayout* computation_layout = m->mutable_entry_computation_layout();\n+  auto status = AssignLayoutsAndVerifyHlo(m.get(), computation_layout);\n+  EXPECT_TRUE(status.ok());\n+\n+  // Verify that the operand_layout_constraints is propagated to the Unpin\n+  // custom-call along the buffer chain.\n+  const HloInstruction* unpin = m->entry_computation()->root_instruction();\n+  ExpectLayoutIs(unpin->shape(), {0, 1});\n+  ExpectLayoutIs(unpin->operand(0)->shape(), {0, 1});\n+\n+  // Verify that the operand of the Pin instruction is a copy with the needed\n+  // layout change.\n+  Layout layout01 = LayoutUtil::MakeLayout({0, 1});\n+  Layout layout10 = LayoutUtil::MakeLayout({1, 0});\n+\n+  EXPECT_THAT(\n+      FindInstruction(m.get(), \"b0\"),\n+      GmockMatch(m::CustomCall(m::Copy(m::Parameter(0).WithShape(\n+                                   m::Shape().WithLayoutEqualTo(&layout10))))\n+                     .WithShape(m::Shape().WithLayoutEqualTo(&layout01))));\n+}\n+\n+// This shows an incorrect way of specifying the layout of a buffer, causing a\n+// copy of the buffer.\n+TEST_F(LayoutAssignmentTest, BufferChainLayoutConstrainedNotPin) {\n+  const char* module_str = R\"(\n+  HloModule test\n+  ENTRY test_computation {\n+    init = s32[2,8] parameter(0)\n+    b0 = b(s32[2,8]) custom-call(init), custom_call_target=\"Pin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    b1 = b(s32[2,8]{0,1}) custom-call(b0), custom_call_target=\"CallBack_AddOne\",\n+      output_to_operand_aliasing={{}: (0, {})},\n+      operand_layout_constraints={b(s32[2,8]{0,1})}\n+    ROOT v = s32[2,8] custom-call(b1), custom_call_target=\"Unpin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+  })\";\n+  // We can't user VerifiedHloModule as its destructor gives an error for an\n+  // invalid HloModule..\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<HloModule> m,\n+      ParseAndReturnUnverifiedModule(\n+          module_str, /*config=*/{},\n+          HloParserOptions().set_fill_missing_layouts(false)));\n+  HloVerifier verifier(/*layout_sensitive=*/false,\n+                       /*allow_mixed_precision=*/false);\n+  EXPECT_TRUE(verifier.Run(m.get()).ok());\n+  ComputationLayout* computation_layout = m->mutable_entry_computation_layout();\n+  auto status = AssignLayoutsAndVerifyHlo(m.get(), computation_layout);\n+  EXPECT_FALSE(status.ok());\n+  EXPECT_NE(FindInstruction(m.get(), HloOpcode::kCopy), nullptr);\n+  EXPECT_THAT(status.status().message(),\n+              ::testing::HasSubstr(\n+                  \"Seen buffers while buffers aren't allowed in this context\"));\n+}\n+\n+// This shows that in general, inconsistent layout constraints for a buffer\n+// chain can cause a copy of the buffer and trigger verification errors.\n+TEST_F(LayoutAssignmentTest, BufferChainLayoutInconsistentConstrains) {\n+  const char* module_str = R\"(\n+  HloModule test\n+  ENTRY test_computation {\n+    init = s32[2,8] parameter(0)\n+    b0 = b(s32[2,8]{0,1}) custom-call(init), custom_call_target=\"Pin\",\n+      output_to_operand_aliasing={{}: (0, {})},\n+      operand_layout_constraints={s32[2,8]{0,1}}\n+    b1 = b(s32[2,8]) custom-call(b0), custom_call_target=\"CallBack_AddOne\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+    ROOT v = s32[2,8] custom-call(b1), custom_call_target=\"Unpin\",\n+      output_to_operand_aliasing={{}: (0, {})}\n+  })\";\n+  // We can't user VerifiedHloModule as its destructor gives an error for an\n+  // invalid HloModule..\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::unique_ptr<HloModule> m,\n+      ParseAndReturnUnverifiedModule(\n+          module_str, /*config=*/{},\n+          HloParserOptions().set_fill_missing_layouts(false)));\n+  HloVerifier verifier(/*layout_sensitive=*/false,\n+                       /*allow_mixed_precision=*/false);\n+  EXPECT_TRUE(verifier.Run(m.get()).ok());\n+  ComputationLayout computation_layout = m->entry_computation_layout();\n+  // Create a layout constraint for the result that is inconsistent with the\n+  // layout of buffer chain, to trigger a copy of the buffer.\n+  *computation_layout.mutable_result_layout() =\n+      ShapeLayout(ShapeUtil::MakeShapeWithDenseLayout(S32, {2, 8}, {1, 0}));\n+\n+  auto status = AssignLayoutsAndVerifyHlo(m.get(), &computation_layout);\n+  EXPECT_FALSE(status.ok());\n+  EXPECT_NE(FindInstruction(m.get(), HloOpcode::kCopy), nullptr);\n+  EXPECT_THAT(status.status().message(),\n+              ::testing::HasSubstr(\n+                  \"Seen buffers while buffers aren't allowed in this context\"));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 194,
        "additions": 194,
        "deletions": 0
    }
}