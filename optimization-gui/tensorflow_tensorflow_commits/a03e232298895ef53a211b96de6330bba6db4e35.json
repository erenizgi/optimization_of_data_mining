{
    "author": "matthiaskramm",
    "message": "stream_executor: Move method implementations out of the .h, into the .cc.\n\nPiperOrigin-RevId: 834014457",
    "sha": "a03e232298895ef53a211b96de6330bba6db4e35",
    "files": [
        {
            "sha": "c45d7137dc157fe5879c7b21fde0b88b43331cf9",
            "filename": "third_party/xla/xla/pjrt/stream_executor_executable.cc",
            "status": "modified",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a03e232298895ef53a211b96de6330bba6db4e35/third_party%2Fxla%2Fxla%2Fpjrt%2Fstream_executor_executable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a03e232298895ef53a211b96de6330bba6db4e35/third_party%2Fxla%2Fxla%2Fpjrt%2Fstream_executor_executable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fstream_executor_executable.cc?ref=a03e232298895ef53a211b96de6330bba6db4e35",
            "patch": "@@ -15,7 +15,9 @@ limitations under the License.\n \n #include \"xla/pjrt/stream_executor_executable.h\"\n \n+#include <cstdint>\n #include <memory>\n+#include <optional>\n #include <string>\n #include <utility>\n #include <variant>\n@@ -26,8 +28,10 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"xla/client/local_client.h\"\n #include \"xla/pjrt/host_memory_spaces.h\"\n+#include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/proto/compile_options.pb.h\"\n #include \"xla/pjrt/stream_executor_executable.pb.h\"\n+#include \"xla/service/buffer_assignment.h\"\n #include \"xla/service/compiler.h\"\n #include \"xla/service/executable.h\"\n #include \"xla/shape.h\"\n@@ -77,6 +81,92 @@ absl::StatusOr<std::string> StreamExecutorExecutable::SerializeExecutable()\n   return proto.SerializeAsString();\n }\n \n+StreamExecutorExecutable::StreamExecutorExecutable(\n+    const CompileOptions& compile_options,\n+    std::optional<HloModuleProto> unoptimized_hlo_module_proto,\n+    std::vector<std::unique_ptr<LocalExecutable>> local_executables,\n+    LocalClient* local_client, int num_replicas, int num_partitions,\n+    absl::string_view name, absl::string_view fingerprint,\n+    absl::string_view default_memory_kind)\n+    : compile_options_(compile_options),\n+      unoptimized_hlo_module_proto_(std::move(unoptimized_hlo_module_proto)),\n+      executables_(std::move(local_executables)),\n+      local_client_(local_client),\n+      num_replicas_(num_replicas),\n+      num_partitions_(num_partitions),\n+      name_(name),\n+      fingerprint_(fingerprint),\n+      default_memory_kind_(default_memory_kind) {\n+  std::vector<std::shared_ptr<HloModule>> hlo_modules;\n+  for (const auto& local_executable :\n+       std::get<std::vector<std::unique_ptr<LocalExecutable>>>(executables_)) {\n+    hlo_modules.push_back(local_executable->executable()->shared_module());\n+  }\n+  hlo_modules_ = std::move(hlo_modules);\n+}\n+\n+absl::StatusOr<CompiledMemoryStats>\n+StreamExecutorExecutable::GetCompiledMemoryStats() const {\n+  CompiledMemoryStats memory_stats = CompiledMemoryStats();\n+  if (auto* aot_executables =\n+          std::get_if<std::vector<std::unique_ptr<xla::AotCompilationResult>>>(\n+              &executables_)) {\n+    if (aot_executables->size() != 1) {\n+      return Unimplemented(\n+          \"Retrieving CompiledMemoryStats is not supported for multiple \"\n+          \"executables.\");\n+    }\n+    const auto& aot_executable = (*aot_executables)[0];\n+    TF_ASSIGN_OR_RETURN(std::unique_ptr<BufferAssignment> buffers,\n+                        aot_executable->buffer_assignment());\n+\n+    BufferAssignmentProto proto = buffers->ToProto();\n+    memory_stats.serialized_buffer_assignment = proto.SerializeAsString();\n+    std::vector<const BufferAllocation*> alloc_ptrs;\n+    alloc_ptrs.reserve(buffers->Allocations().size());\n+    for (const BufferAllocation& alloc : buffers->Allocations()) {\n+      alloc_ptrs.push_back(&alloc);\n+    }\n+    memory_stats.PopulateBufferStatsFromAllocations(alloc_ptrs);\n+    TF_ASSIGN_OR_RETURN(int64_t peak_memory, ComputePeakMemory(proto));\n+    memory_stats.peak_memory_in_bytes = peak_memory;\n+    return memory_stats;\n+  }\n+\n+  const auto& local_executables =\n+      std::get<std::vector<std::unique_ptr<LocalExecutable>>>(executables_);\n+  if (local_executables.size() != 1) {\n+    return absl::UnimplementedError(\n+        \"Retrieving CompiledMemoryStats is not supported for multiple \"\n+        \"executables.\");\n+  }\n+  const BufferAssignmentProto* proto =\n+      local_executables[0]->executable()->buffer_assignment_proto();\n+  if (proto != nullptr) {\n+    memory_stats.serialized_buffer_assignment = proto->SerializeAsString();\n+    TF_ASSIGN_OR_RETURN(int64_t peak_memory, ComputePeakMemory(*proto));\n+    memory_stats.peak_memory_in_bytes = peak_memory;\n+  }\n+  memory_stats.PopulateBufferStatsFromAllocations(\n+      local_executables[0]->executable()->GetAllocations());\n+  memory_stats.generated_code_size_in_bytes = SizeOfGeneratedCodeInBytes();\n+  return memory_stats;\n+}\n+\n+int64_t StreamExecutorExecutable::SizeOfGeneratedCodeInBytes() const {\n+  if (std::holds_alternative<\n+          std::vector<std::unique_ptr<xla::AotCompilationResult>>>(\n+          executables_)) {\n+    return 0;\n+  }\n+  int64_t size = 0;\n+  for (auto& executable :\n+       std::get<std::vector<std::unique_ptr<LocalExecutable>>>(executables_)) {\n+    size += executable->executable()->SizeOfGeneratedCodeInBytes();\n+  }\n+  return size;\n+}\n+\n namespace {\n \n absl::StatusOr<absl::string_view> MemoryKindFromSimpleShape("
        },
        {
            "sha": "cff9d15b53edde5ab75f69e8ed6f9d2c0d2eae07",
            "filename": "third_party/xla/xla/pjrt/stream_executor_executable.h",
            "status": "modified",
            "additions": 3,
            "deletions": 78,
            "changes": 81,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a03e232298895ef53a211b96de6330bba6db4e35/third_party%2Fxla%2Fxla%2Fpjrt%2Fstream_executor_executable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a03e232298895ef53a211b96de6330bba6db4e35/third_party%2Fxla%2Fxla%2Fpjrt%2Fstream_executor_executable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fstream_executor_executable.h?ref=a03e232298895ef53a211b96de6330bba6db4e35",
            "patch": "@@ -58,24 +58,7 @@ class StreamExecutorExecutable : public PjRtExecutable {\n       std::vector<std::unique_ptr<LocalExecutable>> local_executables,\n       LocalClient* local_client, int num_replicas, int num_partitions,\n       absl::string_view name, absl::string_view fingerprint,\n-      absl::string_view default_memory_kind)\n-      : compile_options_(compile_options),\n-        unoptimized_hlo_module_proto_(std::move(unoptimized_hlo_module_proto)),\n-        executables_(std::move(local_executables)),\n-        local_client_(local_client),\n-        num_replicas_(num_replicas),\n-        num_partitions_(num_partitions),\n-        name_(name),\n-        fingerprint_(fingerprint),\n-        default_memory_kind_(default_memory_kind) {\n-    std::vector<std::shared_ptr<HloModule>> hlo_modules;\n-    for (const auto& local_executable :\n-         std::get<std::vector<std::unique_ptr<LocalExecutable>>>(\n-             executables_)) {\n-      hlo_modules.push_back(local_executable->executable()->shared_module());\n-    }\n-    hlo_modules_ = std::move(hlo_modules);\n-  }\n+      absl::string_view default_memory_kind);\n \n   absl::StatusOr<std::string> SerializeExecutable() const override;\n \n@@ -93,52 +76,7 @@ class StreamExecutorExecutable : public PjRtExecutable {\n     return *hlo_modules_;\n   }\n \n-  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override {\n-    CompiledMemoryStats memory_stats = CompiledMemoryStats();\n-    if (auto* aot_executables = std::get_if<\n-            std::vector<std::unique_ptr<xla::AotCompilationResult>>>(\n-            &executables_)) {\n-      if (aot_executables->size() != 1) {\n-        return Unimplemented(\n-            \"Retrieving CompiledMemoryStats is not supported for multiple \"\n-            \"executables.\");\n-      }\n-      const auto& aot_executable = (*aot_executables)[0];\n-      TF_ASSIGN_OR_RETURN(std::unique_ptr<BufferAssignment> buffers,\n-                          aot_executable->buffer_assignment());\n-\n-      BufferAssignmentProto proto = buffers->ToProto();\n-      memory_stats.serialized_buffer_assignment = proto.SerializeAsString();\n-      std::vector<const BufferAllocation*> alloc_ptrs;\n-      alloc_ptrs.reserve(buffers->Allocations().size());\n-      for (const BufferAllocation& alloc : buffers->Allocations()) {\n-        alloc_ptrs.push_back(&alloc);\n-      }\n-      memory_stats.PopulateBufferStatsFromAllocations(alloc_ptrs);\n-      TF_ASSIGN_OR_RETURN(int64_t peak_memory, ComputePeakMemory(proto));\n-      memory_stats.peak_memory_in_bytes = peak_memory;\n-      return memory_stats;\n-    } else {\n-      const auto& local_executables =\n-          std::get<std::vector<std::unique_ptr<LocalExecutable>>>(executables_);\n-      if (local_executables.size() != 1) {\n-        return absl::UnimplementedError(\n-            \"Retrieving CompiledMemoryStats is not supported for multiple \"\n-            \"executables.\");\n-      }\n-      const BufferAssignmentProto* proto =\n-          local_executables[0]->executable()->buffer_assignment_proto();\n-      if (proto != nullptr) {\n-        memory_stats.serialized_buffer_assignment = proto->SerializeAsString();\n-        TF_ASSIGN_OR_RETURN(int64_t peak_memory, ComputePeakMemory(*proto));\n-        memory_stats.peak_memory_in_bytes = peak_memory;\n-      }\n-      memory_stats.PopulateBufferStatsFromAllocations(\n-          local_executables[0]->executable()->GetAllocations());\n-    }\n-    memory_stats.generated_code_size_in_bytes = SizeOfGeneratedCodeInBytes();\n-    return memory_stats;\n-  }\n+  absl::StatusOr<CompiledMemoryStats> GetCompiledMemoryStats() const override;\n \n   absl::StatusOr<std::vector<std::vector<absl::string_view>>>\n   GetOutputMemoryKinds() const override;\n@@ -148,20 +86,7 @@ class StreamExecutorExecutable : public PjRtExecutable {\n     return absl::UnimplementedError(\"GetCostAnalysis is not supported.\");\n   }\n \n-  int64_t SizeOfGeneratedCodeInBytes() const override {\n-    if (std::holds_alternative<\n-            std::vector<std::unique_ptr<xla::AotCompilationResult>>>(\n-            executables_)) {\n-      return 0;\n-    }\n-    int64_t size = 0;\n-    for (auto& executable :\n-         std::get<std::vector<std::unique_ptr<LocalExecutable>>>(\n-             executables_)) {\n-      size += executable->executable()->SizeOfGeneratedCodeInBytes();\n-    }\n-    return size;\n-  }\n+  int64_t SizeOfGeneratedCodeInBytes() const override;\n \n   const CompileOptions& compile_options() const { return compile_options_; }\n "
        }
    ],
    "stats": {
        "total": 171,
        "additions": 93,
        "deletions": 78
    }
}