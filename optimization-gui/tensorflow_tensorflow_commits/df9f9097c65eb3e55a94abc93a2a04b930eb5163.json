{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Conversion] Add V3->{V2,V1} conversion functions.\n\nThis also refactors some logic in V3 implementation so it is easy to get the reshape_dims and transpose perm required for V2 replica groups.\n\nPiperOrigin-RevId: 831589114",
    "sha": "df9f9097c65eb3e55a94abc93a2a04b930eb5163",
    "files": [
        {
            "sha": "e78141fc8fee05638469ab23f4ce4b16dda80def",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 5,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/df9f9097c65eb3e55a94abc93a2a04b930eb5163/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/df9f9097c65eb3e55a94abc93a2a04b930eb5163/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=df9f9097c65eb3e55a94abc93a2a04b930eb5163",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n #include <numeric>\n #include <optional>\n #include <string>\n+#include <tuple>\n #include <utility>\n #include <vector>\n \n@@ -218,16 +219,14 @@ void MeshAxesReplicaGroupList::InitializeDimToReshapeAndAggregateAxes() {\n   dim_to_reshape_and_aggregate_axes_ = dim_map;\n }\n \n-std::vector<std::vector<int64_t>>\n-MeshAxesReplicaGroupList::flattened_replica_groups() {\n+std::pair<std::vector<int64_t>, std::vector<int64_t>>\n+MeshAxesReplicaGroupList::ComputeReindexedAxes() {\n   if (!dim_to_reshape_and_aggregate_axes_.has_value()) {\n     InitializeDimToReshapeAndAggregateAxes();\n   }\n-\n+  std::vector<int64_t> reindex_axis_sizes, reindexed_grouped_axes;\n   absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes> dim_map =\n       dim_to_reshape_and_aggregate_axes_.value();\n-  std::vector<int64_t> reindex_axis_sizes;\n-  std::vector<int64_t> reindexed_grouped_axes;\n   for (int64_t i = 0; i < mesh_.axis_sizes().size(); ++i) {\n     int64_t axis_size = mesh_.axis_size(i);\n     auto it = dim_map.find(i);\n@@ -244,6 +243,13 @@ MeshAxesReplicaGroupList::flattened_replica_groups() {\n       reindexed_grouped_axes.push_back(aggregate_dim + offset_index);\n     }\n   }\n+  return std::make_pair(reindex_axis_sizes, reindexed_grouped_axes);\n+}\n+\n+std::vector<std::vector<int64_t>>\n+MeshAxesReplicaGroupList::flattened_replica_groups() {\n+  std::vector<int64_t> reindex_axis_sizes, reindexed_grouped_axes;\n+  std::tie(reindex_axis_sizes, reindexed_grouped_axes) = ComputeReindexedAxes();\n   return get_replica_groups_for_full_axes(\n       mesh_, reindex_axis_sizes, reindexed_grouped_axes, num_replica_groups(),\n       num_devices_per_group());\n@@ -286,6 +292,30 @@ MeshAxesReplicaGroupList MeshAxesReplicaGroupList::FromProto(\n   return MeshAxesReplicaGroupList(mesh, axes);\n }\n \n+IotaReplicaGroupList MeshAxesReplicaGroupList::ToIotaReplicaGroupList() {\n+  CHECK(mesh_.device_assignment().iota().has_value());\n+  std::vector<int64_t> reshape_dims, reindexed_grouped_axes;\n+  std::tie(reshape_dims, reindexed_grouped_axes) = ComputeReindexedAxes();\n+\n+  std::vector<int> transpose_perm;\n+  for (int64_t reshape_dim = 0; reshape_dim < reshape_dims.size();\n+       ++reshape_dim) {\n+    if (!absl::c_linear_search(reindexed_grouped_axes, reshape_dim)) {\n+      transpose_perm.push_back(reshape_dim);\n+    }\n+  }\n+  for (int64_t grouped_axis : reindexed_grouped_axes) {\n+    transpose_perm.push_back(grouped_axis);\n+  }\n+\n+  return IotaReplicaGroupList(num_replica_groups(), num_devices_per_group(),\n+                              reshape_dims, transpose_perm);\n+}\n+\n+CollectiveDeviceList MeshAxesReplicaGroupList::ToCollectiveDeviceList() {\n+  return CollectiveDeviceList(flattened_replica_groups());\n+}\n+\n /************** IotaReplicaGroupList implementation ***************************/\n int64_t IotaReplicaGroupList::num_replica_groups() const {\n   DCHECK_GE(num_replica_groups_, 0);\n@@ -373,6 +403,16 @@ const std::vector<ReplicaGroup>& CollectiveDeviceList::replica_groups() const {\n   return *replica_groups_;\n }\n \n+std::vector<std::vector<int64_t>>\n+CollectiveDeviceList::flattened_replica_groups() const {\n+  std::vector<std::vector<int64_t>> result;\n+  result.reserve(replica_groups().size());\n+  for (const ReplicaGroup& group : replica_groups()) {\n+    result.emplace_back(group.replica_ids().begin(), group.replica_ids().end());\n+  }\n+  return result;\n+}\n+\n std::string CollectiveDeviceList::ToString(\n     bool print_full_replica_group_list) const {\n   if (iota_replica_group_list_.has_value() && !print_full_replica_group_list) {"
        },
        {
            "sha": "b6e30d24071ef3381327d09405672a53470bea88",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/df9f9097c65eb3e55a94abc93a2a04b930eb5163/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/df9f9097c65eb3e55a94abc93a2a04b930eb5163/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h?ref=df9f9097c65eb3e55a94abc93a2a04b930eb5163",
            "patch": "@@ -38,6 +38,9 @@ limitations under the License.\n \n namespace xla {\n \n+class IotaReplicaGroupList;\n+class CollectiveDeviceList;\n+\n class MeshAxesReplicaGroupList {\n   struct ReshapeAndAggregateAxes {\n     std::vector<int64_t> reshape_dims;\n@@ -69,8 +72,13 @@ class MeshAxesReplicaGroupList {\n   static MeshAxesReplicaGroupList FromProto(\n       const MeshAxesReplicaGroupListProto& proto);\n \n+  // Methods for converting to V2 and V1 representations.\n+  IotaReplicaGroupList ToIotaReplicaGroupList();\n+  CollectiveDeviceList ToCollectiveDeviceList();\n+\n  private:\n   void InitializeDimToReshapeAndAggregateAxes();\n+  std::pair<std::vector<int64_t>, std::vector<int64_t>> ComputeReindexedAxes();\n   Mesh mesh_;\n   std::vector<AxisRef> axes_;\n   std::optional<absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes>>\n@@ -199,6 +207,7 @@ class CollectiveDeviceList {\n \n   // Lazyly explands iota if applicable.\n   const std::vector<ReplicaGroup>& replica_groups() const;\n+  std::vector<std::vector<int64_t>> flattened_replica_groups() const;\n   const std::optional<IotaReplicaGroupList>& iota_replica_group_list() const {\n     return iota_replica_group_list_;\n   }"
        },
        {
            "sha": "b038eaafd041c0644c79cadfd5ff51568b7bcf5a",
            "filename": "third_party/xla/xla/hlo/ir/replica_group_test.cc",
            "status": "modified",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/df9f9097c65eb3e55a94abc93a2a04b930eb5163/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/df9f9097c65eb3e55a94abc93a2a04b930eb5163/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc?ref=df9f9097c65eb3e55a94abc93a2a04b930eb5163",
            "patch": "@@ -365,6 +365,86 @@ TEST(MeshAxesReplicaGroupListTest, ValidatesIncompatibleAxes) {\n       \"Sub-axis size must be strictly less than the full axis size\");\n }\n \n+TEST(MeshAxesReplicaGroupListTest, ToReplicaGroupV2) {\n+  Mesh mesh_ab({6, 6}, {\"a\", \"b\"});\n+\n+  // a:(1)3\n+  MeshAxesReplicaGroupList replica_group_a_1_3(mesh_ab, {AxisRef(0, {1, 3})});\n+  EXPECT_EQ(\n+      replica_group_a_1_3.flattened_replica_groups(),\n+      replica_group_a_1_3.ToIotaReplicaGroupList().flattened_replica_groups());\n+\n+  // b:(3)2\n+  MeshAxesReplicaGroupList replica_group_b_3_2(mesh_ab, {AxisRef(1, {3, 2})});\n+  EXPECT_EQ(\n+      replica_group_b_3_2.flattened_replica_groups(),\n+      replica_group_b_3_2.ToIotaReplicaGroupList().flattened_replica_groups());\n+\n+  // a:(1)2, b:(1)2\n+  MeshAxesReplicaGroupList replica_group_a_1_2_b_1_2(\n+      mesh_ab, {AxisRef(0, {1, 2}), AxisRef(1, {1, 2})});\n+  EXPECT_EQ(replica_group_a_1_2_b_1_2.flattened_replica_groups(),\n+            replica_group_a_1_2_b_1_2.ToIotaReplicaGroupList()\n+                .flattened_replica_groups());\n+\n+  // a:(1)3, b:(1)3\n+  MeshAxesReplicaGroupList replica_group_a_1_3_b_1_3(\n+      mesh_ab, {AxisRef(0, {1, 3}), AxisRef(1, {1, 3})});\n+  EXPECT_EQ(replica_group_a_1_3_b_1_3.flattened_replica_groups(),\n+            replica_group_a_1_3_b_1_3.ToIotaReplicaGroupList()\n+                .flattened_replica_groups());\n+\n+  // b:(1)3, a:(1)3 (Reverse order from above). This should produce the same\n+  // replica groups as the above but with ids in a different order.\n+  MeshAxesReplicaGroupList replica_group_b_1_3_a_1_3(\n+      mesh_ab, {AxisRef(1, {1, 3}), AxisRef(0, {1, 3})});\n+  EXPECT_EQ(replica_group_a_1_3_b_1_3.flattened_replica_groups(),\n+            replica_group_a_1_3_b_1_3.ToIotaReplicaGroupList()\n+                .flattened_replica_groups());\n+\n+  Mesh mesh_cd({8, 6}, {\"c\", \"d\"});\n+\n+  // c\n+  MeshAxesReplicaGroupList replica_group_c(mesh_cd, {AxisRef(0)});\n+  EXPECT_EQ(\n+      replica_group_c.flattened_replica_groups(),\n+      replica_group_c.ToIotaReplicaGroupList().flattened_replica_groups());\n+\n+  // d\n+  MeshAxesReplicaGroupList replica_group_d(mesh_cd, {AxisRef(1)});\n+  EXPECT_EQ(\n+      replica_group_d.flattened_replica_groups(),\n+      replica_group_d.ToIotaReplicaGroupList().flattened_replica_groups());\n+\n+  // c:(1)2, d:(4)2\n+  MeshAxesReplicaGroupList replica_group_c_1_2_c_4_2(\n+      mesh_cd, {AxisRef(0, {1, 2}), AxisRef(0, {4, 2})});\n+  EXPECT_EQ(replica_group_c_1_2_c_4_2.flattened_replica_groups(),\n+            replica_group_c_1_2_c_4_2.ToIotaReplicaGroupList()\n+                .flattened_replica_groups());\n+\n+  // c:(2)3, d:(1)2\n+  MeshAxesReplicaGroupList replica_group_d_2_3_d_1_2(\n+      mesh_cd, {AxisRef(1, {2, 3}), AxisRef(1, {1, 2})});\n+  EXPECT_EQ(replica_group_d_2_3_d_1_2.flattened_replica_groups(),\n+            replica_group_d_2_3_d_1_2.ToIotaReplicaGroupList()\n+                .flattened_replica_groups());\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest, ToCollectiveDeviceList) {\n+  Mesh mesh({6, 6}, {\"a\", \"b\"});\n+\n+  MeshAxesReplicaGroupList replica_group_b(mesh, {AxisRef(0)});\n+  EXPECT_EQ(\n+      replica_group_b.flattened_replica_groups(),\n+      replica_group_b.ToCollectiveDeviceList().flattened_replica_groups());\n+\n+  MeshAxesReplicaGroupList replica_group_a_1_3(mesh, {AxisRef(0, {1, 3})});\n+  EXPECT_EQ(\n+      replica_group_a_1_3.flattened_replica_groups(),\n+      replica_group_a_1_3.ToCollectiveDeviceList().flattened_replica_groups());\n+}\n+\n TEST(CollectiveDeviceListTest, DefaultListToString) {\n   EXPECT_EQ(CollectiveDeviceList().ToString(true), \"{}\");\n   EXPECT_EQ(CollectiveDeviceList().ToString(false), \"{}\");"
        }
    ],
    "stats": {
        "total": 139,
        "additions": 134,
        "deletions": 5
    }
}