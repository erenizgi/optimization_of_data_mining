{
    "author": "tensorflower-gardener",
    "message": "[XLA] Extract TupleTree from ShapeTree\n\nShapeTree is now simply composed of a shape and a TupleTree. It now delegates all of its API to TupleTree.\n\nPiperOrigin-RevId: 797974240",
    "sha": "e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf",
    "files": [
        {
            "sha": "0599e48ae3e86d1f8ccef4f54b4fba4c0182f3e6",
            "filename": "third_party/xla/xla/BUILD",
            "status": "modified",
            "additions": 36,
            "deletions": 4,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2FBUILD?ref=e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf",
            "patch": "@@ -1021,22 +1021,19 @@ xla_cc_test(\n \n cc_library(\n     name = \"shape_tree\",\n-    srcs = [\"shape_tree.cc\"],\n     hdrs = [\"shape_tree.h\"],\n     visibility = [\"//visibility:public\"],\n     deps = [\n         \":shape_util\",\n+        \":tuple_tree\",\n         \"//xla/tsl/lib/gtl:iterator_range\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:logging\",\n         \"//xla/tsl/platform:statusor\",\n-        \"@com_google_absl//absl/base:core_headers\",\n-        \"@com_google_absl//absl/container:inlined_vector\",\n         \"@com_google_absl//absl/functional:function_ref\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/types:span\",\n         \"@com_google_absl//absl/utility\",\n     ],\n )\n@@ -1441,6 +1438,41 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"tuple_tree\",\n+    srcs = [\"tuple_tree.cc\"],\n+    hdrs = [\"tuple_tree.h\"],\n+    deps = [\n+        \":shape_util\",\n+        \"//xla/tsl/lib/gtl:iterator_range\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:inlined_vector\",\n+        \"@com_google_absl//absl/functional:function_ref\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"tuple_tree_test\",\n+    srcs = [\"tuple_tree_test.cc\"],\n+    deps = [\n+        \":shape_util\",\n+        \":tuple_tree\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n bzl_library(\n     name = \"lit_bzl\",\n     srcs = [\"lit.bzl\"],"
        },
        {
            "sha": "af48651b77ac9f5696957eec4dbad137393cd4a7",
            "filename": "third_party/xla/xla/shape_tree.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 82,
            "changes": 82,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b835989e57b935e2012c01b029097814b9e3003e/third_party%2Fxla%2Fxla%2Fshape_tree.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b835989e57b935e2012c01b029097814b9e3003e/third_party%2Fxla%2Fxla%2Fshape_tree.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fshape_tree.cc?ref=b835989e57b935e2012c01b029097814b9e3003e",
            "patch": "@@ -1,82 +0,0 @@\n-/* Copyright 2022 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/shape_tree.h\"\n-\n-#include <cstddef>\n-\n-#include \"absl/base/optimization.h\"\n-#include \"absl/log/check.h\"\n-#include \"absl/types/span.h\"\n-#include \"xla/shape.h\"\n-\n-namespace xla::internal {\n-\n-// Computes the total size of all nested tuples in the given tuple shape.\n-static size_t IndexTableTuplesSize(const Shape& shape) {\n-  DCHECK(shape.IsTuple()) << \"Shape must be a tuple\";\n-\n-  size_t size = shape.tuple_shapes().size();\n-  for (const Shape& subshape : shape.tuple_shapes()) {\n-    if (ABSL_PREDICT_FALSE(subshape.IsTuple())) {\n-      size += IndexTableTuplesSize(subshape);\n-    }\n-  }\n-\n-  return size;\n-}\n-\n-// Initializes the index table in the given entries span. Span must point into\n-// the appropriately sized entries storage.\n-static void InitializeIndexTable(const Shape& shape,\n-                                 absl::Span<IndexTable::Entry> entries,\n-                                 size_t entry_index, size_t& next_node_id,\n-                                 size_t& next_children_start_index) {\n-  IndexTable::Entry& entry = entries[entry_index];\n-  entry.node_id = next_node_id++;\n-\n-  // Stop shape traversal once reaching a leaf shape.\n-  if (!shape.IsTuple()) {\n-    return;\n-  }\n-\n-  // The nodes are in depth-first pre-order. However, in order to efficiently\n-  // lookup indices, we generate the index table using breadth-first.\n-  entry.children_start_id = next_children_start_index;\n-\n-  // Add entry for children first, before recursing, so they are consecutive.\n-  next_children_start_index += shape.tuple_shapes().size();\n-  for (size_t i = 0; i < shape.tuple_shapes().size(); ++i) {\n-    InitializeIndexTable(shape.tuple_shapes(i), entries,\n-                         entry.children_start_id + i, next_node_id,\n-                         next_children_start_index);\n-  }\n-}\n-\n-IndexTable::IndexTable(const Shape& shape) {\n-  if (!shape.IsTuple()) {\n-    return;\n-  }\n-\n-  // Allocate storage for the index table.\n-  entries_.emplace(1 + IndexTableTuplesSize(shape));\n-\n-  size_t next_node_id = 0;\n-  size_t next_children_start_index = 1;\n-  InitializeIndexTable(shape, absl::MakeSpan(*entries_), 0, next_node_id,\n-                       next_children_start_index);\n-}\n-\n-}  // namespace xla::internal"
        },
        {
            "sha": "eb9baa5105693e9f1d169d0666b7ba8f891e85d7",
            "filename": "third_party/xla/xla/shape_tree.h",
            "status": "modified",
            "additions": 122,
            "deletions": 264,
            "changes": 386,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Fshape_tree.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Fshape_tree.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fshape_tree.h?ref=e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf",
            "patch": "@@ -17,82 +17,60 @@ limitations under the License.\n #define XLA_SHAPE_TREE_H_\n \n #include <algorithm>\n-#include <cstddef>\n #include <cstdint>\n-#include <iterator>\n #include <memory>\n-#include <optional>\n-#include <type_traits>\n #include <utility>\n \n-#include \"absl/container/inlined_vector.h\"\n #include \"absl/functional/function_ref.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/types/span.h\"\n #include \"absl/utility/utility.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/lib/gtl/iterator_range.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/logging.h\"  // IWYU pragma: keep\n #include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tuple_tree.h\"\n \n namespace xla {\n \n-namespace internal {\n-\n-class IndexTable {\n- public:\n-  // Use indices, rather than pointers, so index table can be copied between\n-  // ShapeTrees.\n-  struct Entry {\n-    // Index of the node in the nodes vector.\n-    size_t node_id;\n-    // Index of the first child of this node in the index table (-1 for leaves).\n-    std::make_signed_t<size_t> children_start_id = -1;\n-  };\n-\n-  IndexTable() = default;\n-  explicit IndexTable(const Shape& shape);\n-\n-  const Entry& operator[](ShapeIndexView index) const {\n-    static constexpr Entry kRootEntry = {0, -1};\n-\n-    if (!entries_.has_value()) {\n-      DCHECK(index.empty());\n-      return kRootEntry;\n-    }\n-\n-    const Entry* result = &entries_->front();\n-    for (int64_t i : index) {\n-      DCHECK_GE(result->children_start_id, 0);\n-      result = &(*entries_)[result->children_start_id + i];\n-    }\n-    return *result;\n-  }\n-\n- private:\n-  // Entries are computed only if the shape is a tuple.\n-  std::optional<absl::InlinedVector<Entry, 1>> entries_;\n-};\n-\n-}  // namespace internal\n-\n-// A ShapeTree<T> is a recursive data structure which mirrors the structure of a\n-// XLA shape and holds a value of type T for each subshape (i.e. tuple or array)\n-// in the shape. For array shapes, a ShapeTree trivially holds a single value of\n-// type T.\n+// A ShapeTree<T> is a tree data structure that mirrors the structure of an\n+// XLA Shape and holds a value of type T for each subshape.\n+//\n+// Key Characteristics:\n+// - Mirrors an XLA Shape: The tree structure is identical to the Shape's\n+//   tuple nesting.\n+// - Value at Each Node: Every node in the tree, whether it corresponds to a\n+//   tuple or an array, has an associated value of type T.\n+// - Leaf Nodes: Nodes corresponding to array Shapes are leaf nodes in the\n+//   ShapeTree.\n+// - Internal Nodes: Nodes corresponding to tuple Shapes are internal nodes.\n+// - Unique Elements: Each ShapeIndex in the Shape corresponds to a unique\n+//   element of type T in the ShapeTree.\n //\n-// For tuple shapes which can be an arbitrary tree with arrays at the leaves, a\n-// ShapeTree is an identically structured tree with data elements of type T at\n-// every node. I.e. the root is a tuple by definition, all interior nodes are\n-// also tuples, and all leaves are arrays.\n+// Underlying Implementation:\n+// This class is primarily a wrapper around TupleTree<T>, binding it to an\n+// xla::Shape. The actual tree data is stored and managed by the internal\n+// TupleTree instance.\n //\n-// Like the Shape data structure, this is a tree and tuple elements cannot be\n-// duplicated. That is, every distinct ShapeIndex in the Shape has a unique T\n-// object.\n+// Shape Ownership:\n+// Normally a ShapeTree owns its Shape (stored in a std::shared_ptr), but for\n+// efficiency, you can construct it with a const Shape* to avoid copies. In this\n+// case, the caller must ensure the Shape outlives the ShapeTree.\n+//\n+// Example:\n+//   Shape shape = ShapeUtil::MakeTupleShape({\n+//       ShapeUtil::MakeShape(F32, {}),  // Index {0}\n+//       ShapeUtil::MakeShape(S32, {})   // Index {1}\n+//   });\n+//   ShapeTree<int> tree(shape, 0); // Initialize all nodes with 0\n+//   *tree.mutable_element({0}) = 10;\n+//   *tree.mutable_element({1}) = 20;\n+//   // The root element at {} also has a value, initialized to 0.\n+//   LOG(INFO) << tree.element({}); // Prints 0\n+//   LOG(INFO) << tree.element({0}); // Prints 10\n //\n // Normally a ShapeTree owns its Shape, but for efficiency reasons, sometimes\n // it's helpful not to copy a Shape just to make a ShapeTree.  In these cases,\n@@ -105,13 +83,8 @@ class ShapeTree {\n   friend class ShapeTree;\n \n  public:\n-  // TODO(cjfj): Don't store ShapeIndex with data. Generate it or cache it?\n   using Node = std::pair<ShapeIndex, T>;\n-  using Nodes = absl::InlinedVector<Node, 1>;\n-  using IndexTable = internal::IndexTable;\n-\n-  template <typename Iterator, typename ValueType>\n-  class LeafIterator;\n+  using Nodes = typename TupleTree<T>::NodePairs;\n \n   // Default constructor creates a tree with a nil shape (i.e. an empty tuple).\n   ShapeTree() : ShapeTree(ShapeUtil::MakeNil()) {}\n@@ -135,10 +108,15 @@ class ShapeTree {\n   ShapeTree(const Shape* shape, const T& init_value)\n       : ShapeTree(absl::in_place_t{}, shape, init_value) {}\n \n-  // Returns the data element associated with the array in the shape at the\n-  // given index (see ShapeUtil::GetSubshape for how indexes are defined).\n-  const T& element(ShapeIndexView index) const { return find(index)->second; }\n-  T* mutable_element(ShapeIndexView index) { return &find(index)->second; }\n+  // Returns the data element associated with the subshape at the\n+  // given index. This works for any valid index, including internal tuple\n+  // nodes.\n+  const T& element(ShapeIndexView index) const {\n+    return tuple_tree_.element(index);\n+  }\n+  T* mutable_element(ShapeIndexView index) {\n+    return tuple_tree_.mutable_element(index);\n+  }\n \n   // Return the shape represented with this ShapeTree.\n   const Shape& shape() const { return *shape_; }\n@@ -156,173 +134,135 @@ class ShapeTree {\n     shape_ = &shape;\n   }\n \n-  // Returns true if the node at the given index is a leaf node (an array\n-  // shape).\n-  bool IsLeaf(ShapeIndexView index) const {\n-    return index_table_[index].children_start_id == -1;\n-  }\n+  bool IsLeaf(ShapeIndexView index) const { return tuple_tree_.IsLeaf(index); }\n \n-  using iterator = typename Nodes::iterator;\n-  using const_iterator = typename Nodes::const_iterator;\n-  using reverse_iterator = typename Nodes::reverse_iterator;\n-  using const_reverse_iterator = typename Nodes::const_reverse_iterator;\n+  using iterator = typename TupleTree<T>::iterator;\n+  using const_iterator = typename TupleTree<T>::const_iterator;\n+  using reverse_iterator = typename TupleTree<T>::reverse_iterator;\n+  using const_reverse_iterator = typename TupleTree<T>::const_reverse_iterator;\n \n-  using leaf_iterator = LeafIterator<iterator, Node>;\n-  using const_leaf_iterator = LeafIterator<const_iterator, const Node>;\n-  using reverse_leaf_iterator = std::reverse_iterator<leaf_iterator>;\n+  using leaf_iterator = typename TupleTree<T>::leaf_iterator;\n+  using const_leaf_iterator = typename TupleTree<T>::const_leaf_iterator;\n+  using reverse_leaf_iterator = typename TupleTree<T>::reverse_leaf_iterator;\n   using const_reverse_leaf_iterator =\n-      std::reverse_iterator<const_leaf_iterator>;\n-\n-  iterator begin() { return nodes_.begin(); }\n-  iterator end() { return nodes_.end(); }\n-  const_iterator begin() const { return nodes_.begin(); }\n-  const_iterator end() const { return nodes_.end(); }\n-\n-  reverse_iterator rbegin() { return nodes_.rbegin(); }\n-  reverse_iterator rend() { return nodes_.rend(); }\n-  const_reverse_iterator rbegin() const { return nodes_.rbegin(); }\n-  const_reverse_iterator rend() const { return nodes_.rend(); }\n-\n-  // leaf_begin()/leaf_end() iterates over all leaf nodes (nodes with no\n-  // children).\n-  leaf_iterator leaf_begin() { return leaf_iterator(*this, nodes_.begin()); }\n-  leaf_iterator leaf_end() { return leaf_iterator(*this, nodes_.end()); }\n-  const_leaf_iterator leaf_begin() const {\n-    return const_leaf_iterator(*this, nodes_.begin());\n-  }\n-  const_leaf_iterator leaf_end() const {\n-    return const_leaf_iterator(*this, nodes_.end());\n-  }\n+      typename TupleTree<T>::const_reverse_leaf_iterator;\n+\n+  iterator begin() { return tuple_tree_.begin(); }\n+  iterator end() { return tuple_tree_.end(); }\n+  const_iterator begin() const { return tuple_tree_.begin(); }\n+  const_iterator end() const { return tuple_tree_.end(); }\n+\n+  reverse_iterator rbegin() { return tuple_tree_.rbegin(); }\n+  reverse_iterator rend() { return tuple_tree_.rend(); }\n+  const_reverse_iterator rbegin() const { return tuple_tree_.rbegin(); }\n+  const_reverse_iterator rend() const { return tuple_tree_.rend(); }\n+\n+  // leaf_begin()/leaf_end() iterates over all nodes for which IsLeaf() is true\n+  // (i.e., array shapes).\n+  leaf_iterator leaf_begin() { return tuple_tree_.leaf_begin(); }\n+  leaf_iterator leaf_end() { return tuple_tree_.leaf_end(); }\n+  const_leaf_iterator leaf_begin() const { return tuple_tree_.leaf_begin(); }\n+  const_leaf_iterator leaf_end() const { return tuple_tree_.leaf_end(); }\n+\n   // range-based iterator for leaf_begin()/leaf_end().\n   tsl::gtl::iterator_range<leaf_iterator> leaves() {\n-    return tsl::gtl::make_range(leaf_begin(), leaf_end());\n+    return tuple_tree_.leaves();\n   }\n   tsl::gtl::iterator_range<const_leaf_iterator> leaves() const {\n-    return tsl::gtl::make_range(leaf_begin(), leaf_end());\n+    return tuple_tree_.leaves();\n   }\n \n-  reverse_leaf_iterator leaf_rbegin() {\n-    return reverse_leaf_iterator(leaf_end());\n-  }\n-  reverse_leaf_iterator leaf_rend() {\n-    return reverse_leaf_iterator(leaf_begin());\n-  }\n+  reverse_leaf_iterator leaf_rbegin() { return tuple_tree_.leaf_rbegin(); }\n+  reverse_leaf_iterator leaf_rend() { return tuple_tree_.leaf_rend(); }\n   const_reverse_leaf_iterator leaf_rbegin() const {\n-    return const_reverse_leaf_iterator(leaf_end());\n+    return tuple_tree_.leaf_rbegin();\n   }\n   const_reverse_leaf_iterator leaf_rend() const {\n-    return const_reverse_leaf_iterator(leaf_begin());\n+    return tuple_tree_.leaf_rend();\n   }\n \n   // Returns an iterator pointing to the given ShapeIndex.\n   // REQUIRES: index must exist in the ShapeTree.\n-  iterator find(ShapeIndexView index) {\n-    return nodes_.begin() + index_table_[index].node_id;\n-  }\n+  iterator find(ShapeIndexView index) { return tuple_tree_.find(index); }\n   const_iterator find(ShapeIndexView index) const {\n-    return nodes_.begin() + index_table_[index].node_id;\n+    return tuple_tree_.find(index);\n   }\n \n   // Returns the number of leaf nodes in the tree.\n-  int64_t leaf_count() const { return std::distance(leaf_begin(), leaf_end()); }\n+  int64_t leaf_count() const { return ShapeUtil::GetLeafCount(*shape_); }\n \n   // TODO(cjfj): Remove the `ForEach...` methods. They are redundant.\n-  // Recursively traverses the shape and calls the given function at each\n-  // element.\n+  // Traverses all nodes in the tree in pre-order and calls the given function\n+  // at each element.\n   void ForEachElement(\n       absl::FunctionRef<void(const ShapeIndex&, const T&)> func) const {\n-    for (const Node& node : nodes_) {\n-      func(node.first, node.second);\n-    }\n+    tuple_tree_.ForEachElement(func);\n   }\n \n   void ForEachMutableElement(\n       absl::FunctionRef<void(const ShapeIndex&, T*)> func) {\n-    for (Node& node : nodes_) {\n-      func(node.first, &node.second);\n-    }\n+    tuple_tree_.ForEachMutableElement(func);\n   }\n \n   // Like ForEach(Mutable)Element, but the callable returns a absl::Status\n   // instead of void.  The first non-OK return value is returned by the ForEach*\n   // function.\n   absl::Status ForEachElementWithStatus(\n       absl::FunctionRef<absl::Status(const ShapeIndex&, const T&)> func) const {\n-    for (const Node& node : nodes_) {\n-      TF_RETURN_IF_ERROR(func(node.first, node.second));\n-    }\n-    return absl::OkStatus();\n+    return tuple_tree_.ForEachElementWithStatus(func);\n   }\n \n   absl::Status ForEachMutableElementWithStatus(\n       absl::FunctionRef<absl::Status(const ShapeIndex&, T*)> func) {\n-    for (Node& node : nodes_) {\n-      TF_RETURN_IF_ERROR(func(node.first, &node.second));\n-    }\n-    return absl::OkStatus();\n+    return tuple_tree_.ForEachMutableElementWithStatus(func);\n   }\n \n-  // Like the above, but traverses in post-order.  Note children are visited in\n-  // right-to-left order.\n+  // Like the above, but traverses all nodes in post-order. Note children are\n+  // visited in right-to-left order.\n   void ForEachElementPostOrder(\n       absl::FunctionRef<void(const ShapeIndex&, const T&)> func) const {\n-    for (auto node = nodes_.rbegin(); node != nodes_.rend(); ++node) {\n+    for (auto node = tuple_tree_.rbegin(); node != tuple_tree_.rend(); ++node) {\n       func(node->first, node->second);\n     }\n   }\n \n   void ForEachMutableElementPostOrder(\n       absl::FunctionRef<void(const ShapeIndex&, T*)> func) {\n-    for (auto node = nodes_.rbegin(); node != nodes_.rend(); ++node) {\n+    for (auto node = tuple_tree_.rbegin(); node != tuple_tree_.rend(); ++node) {\n       func(node->first, &node->second);\n     }\n   }\n \n   absl::Status ForEachElementPostOrderWithStatus(\n       absl::FunctionRef<absl::Status(const ShapeIndex&, const T&)> func) const {\n-    for (auto node = nodes_.rbegin(); node != nodes_.rend(); ++node) {\n+    for (auto node = tuple_tree_.rbegin(); node != tuple_tree_.rend(); ++node) {\n       TF_RETURN_IF_ERROR(func(node->first, node->second));\n     }\n     return absl::OkStatus();\n   }\n \n   absl::Status ForEachMutableElementPostOrderWithStatus(\n       absl::FunctionRef<absl::Status(const ShapeIndex&, T*)> func) {\n-    for (auto node = nodes_.rbegin(); node != nodes_.rend(); ++node) {\n+    for (auto node = tuple_tree_.rbegin(); node != tuple_tree_.rend(); ++node) {\n       TF_RETURN_IF_ERROR(func(node->first, &node->second));\n     }\n     return absl::OkStatus();\n   }\n \n-  // Maps each element to generate a new tree with the same shape.\n+  // Maps each element's value in this tree to generate a new ShapeTree<U>\n+  // with the same shape structure. The function `func` is applied to the value\n+  // of *every* node (both array and tuple nodes).\n   template <typename U>\n-  ShapeTree<U> Map(absl::FunctionRef<U(const T&)> func) {\n-    typename ShapeTree<U>::Nodes result_nodes;\n-    result_nodes.reserve(nodes_.size());\n-    for (const Node& node : nodes_) {\n-      result_nodes.emplace_back(node.first, func(node.second));\n-    }\n-\n-    ShapeTree<U> result(shape_, std::move(result_nodes));\n-    result.index_table_ = index_table_;\n-    result.shape_storage_ = shape_storage_;\n-    return result;\n+  ShapeTree<U> Map(absl::FunctionRef<U(const T&)> func) const {\n+    return ShapeTree<U>(shape_, tuple_tree_.Map(func), shape_storage_);\n   }\n \n   template <typename U>\n   absl::StatusOr<ShapeTree<U>> MapWithStatus(\n-      absl::FunctionRef<absl::StatusOr<U>(const T&)> func) {\n-    typename ShapeTree<U>::Nodes result_nodes;\n-    result_nodes.reserve(nodes_.size());\n-    for (const Node& node : nodes_) {\n-      TF_ASSIGN_OR_RETURN(U result, func(node.second));\n-      result_nodes.emplace_back(node.first, std::move(result));\n-    }\n-\n-    ShapeTree<U> result(shape_, std::move(result_nodes));\n-    result.index_table_ = index_table_;\n-    result.shape_storage_ = shape_storage_;\n-    return result;\n+      absl::FunctionRef<absl::StatusOr<U>(const T&)> func) const {\n+    TF_ASSIGN_OR_RETURN(TupleTree<U> new_tuple_tree,\n+                        tuple_tree_.MapWithStatus(func));\n+    return ShapeTree<U>(shape_, std::move(new_tuple_tree), shape_storage_);\n   }\n \n   // Copy the subtree of values from 'other' rooted at ShapeIndex 'src_index'\n@@ -337,40 +277,23 @@ class ShapeTree {\n     CHECK(ShapeUtil::Compatible(src_shape, dst_shape))\n         << src_shape << \", \" << dst_shape;\n \n-    // Replace the prefix `src_index` with `dst_index`.\n-    auto replace_shape_index_prefix = [&](const ShapeIndex& index) {\n-      auto without_prefix = ShapeIndexView(index).subspan(src_index.size());\n-      ShapeIndex result;\n-      result.reserve(dst_index.size() + without_prefix.size());\n-      result.insert(result.end(), dst_index.begin(), dst_index.end());\n-      result.insert(result.end(), without_prefix.begin(), without_prefix.end());\n-      return result;\n-    };\n-\n-    auto first = other.find(src_index);\n-    auto last = first + ShapeUtil::SubshapeCount(src_shape);\n-\n-    std::transform(first, last, find(dst_index), [&](const Node& node) -> Node {\n-      return {replace_shape_index_prefix(node.first), node.second};\n-    });\n+    // Although the shapes are compatible, the underlying tuple tree structures\n+    // might differ, e.g. if one side was constructed from shape and the other\n+    // from node pairs.\n+    CHECK_OK(tuple_tree_.CopyCompatibleSubtreeFrom(other.tuple_tree_, src_index,\n+                                                   dst_index));\n   }\n \n   absl::StatusOr<ShapeTree<T>> SubShapeTree(const ShapeIndex& index) const {\n     TF_ASSIGN_OR_RETURN(const Shape* sub_shape,\n                         ShapeUtil::TryGetSubshape(shape(), index));\n-    size_t count = ShapeUtil::SubshapeCount(*sub_shape);\n-    Nodes sub_tree_nodes;\n-    sub_tree_nodes.reserve(count);\n-    for (auto it = find(index), end = it + count; it != end; ++it) {\n-      // For each shape index, remove the prefix `index`.\n-      auto without_prefix = ShapeIndexView(it->first).subspan(index.size());\n-      sub_tree_nodes.push_back(Node{without_prefix, it->second});\n-    }\n-    return ShapeTree(sub_shape, std::move(sub_tree_nodes));\n+    TF_ASSIGN_OR_RETURN(TupleTree<T> sub_tuple_tree,\n+                        tuple_tree_.Subtree(index));\n+    return ShapeTree<T>(sub_shape, std::move(sub_tuple_tree), shape_storage_);\n   }\n \n   bool operator==(const ShapeTree<T>& other) const {\n-    return nodes_ == other.nodes_;\n+    return *shape_ == *other.shape_ && tuple_tree_ == other.tuple_tree_;\n   }\n   bool operator!=(const ShapeTree<T>& other) const { return !(*this == other); }\n \n@@ -384,31 +307,21 @@ class ShapeTree {\n     shape_storage_.swap(shape);\n   }\n \n-  ShapeTree(const Shape* shape, Nodes nodes)\n-      : nodes_(std::move(nodes)), index_table_(*shape), shape_(shape) {\n-    DCHECK_EQ(nodes_.size(), ShapeUtil::SubshapeCount(*shape));\n-  }\n+  ShapeTree(const Shape* shape, TupleTree<T>&& tuple_tree,\n+            std::shared_ptr<Shape> shape_storage)\n+      : tuple_tree_(std::move(tuple_tree)),\n+        shape_storage_(shape_storage),\n+        shape_(shape) {}\n \n-  template <typename... Ts>\n-  ShapeTree(absl::in_place_t, const Shape* shape, Ts&&... args)\n-      : index_table_(*shape), shape_(shape) {\n-    if (!shape->IsTuple()) {\n-      nodes_.emplace_back(ShapeIndex(), T(std::forward<Ts>(args)...));\n-    } else {\n-      nodes_.reserve(ShapeUtil::SubshapeCount(*shape));\n-      ShapeUtil::ForEachSubshape(\n-          *shape, [&](const Shape&, const ShapeIndex& index) {\n-            nodes_.emplace_back(index, T(std::forward<Ts>(args)...));\n-          });\n-    }\n-  }\n+  // This constructor now always takes an init_value.\n+  ShapeTree(absl::in_place_t, const Shape* shape, const T& init_value)\n+      : tuple_tree_(*shape, init_value), shape_(shape) {}\n \n-  // The nodes in this shape tree.\n-  Nodes nodes_;\n+  template <typename... Ts>\n+  ShapeTree(absl::in_place_t, const Shape* shape)\n+      : tuple_tree_(TupleTree<T>::Node::FromShape(*shape)), shape_(shape) {}\n \n-  // Index table for node lookups. Each entry contains the index of the first\n-  // child of the node at that index, or -1 for leaf nodes.\n-  IndexTable index_table_;\n+  TupleTree<T> tuple_tree_;\n \n   // If we own our Shape, this field contains it, and shape_ is a pointer into\n   // here.  Otherwise if we don't own our shape, this is nullptr.\n@@ -419,61 +332,6 @@ class ShapeTree {\n   const Shape* shape_;\n };\n \n-// Internal iterator that performs a pre-order walk of the leaves. This is cheap\n-// to copy. The iterator value_type is equivalent to a std::pair<ShapeIndex,T>&,\n-// similar to std::map.\n-template <typename T>\n-template <typename Iterator, typename ValueType>\n-class ShapeTree<T>::LeafIterator {\n- public:\n-  using iterator_category = std::bidirectional_iterator_tag;\n-  using value_type = ValueType;\n-  using difference_type = ptrdiff_t;\n-  using pointer = value_type*;\n-  using reference = value_type&;\n-\n-  LeafIterator(const ShapeTree& tree, Iterator it) : tree_(tree), it_(it) {\n-    while ((it_ != tree_.nodes_.end()) && !IsLeaf()) ++it_;\n-  }\n-\n-  LeafIterator& operator++() {\n-    do {\n-      ++it_;\n-    } while ((it_ != tree_.nodes_.end()) && !IsLeaf());\n-    return *this;\n-  }\n-\n-  LeafIterator operator++(int) {\n-    auto prev = *this;\n-    ++(*this);\n-    return prev;\n-  }\n-\n-  LeafIterator& operator--() {\n-    do {\n-      --it_;\n-    } while ((it_ != tree_.nodes_.begin()) && !IsLeaf());\n-    return *this;\n-  }\n-\n-  LeafIterator operator--(int) {\n-    auto prev = *this;\n-    --(*this);\n-    return prev;\n-  }\n-\n-  bool operator==(const LeafIterator& other) const { return it_ == other.it_; }\n-  bool operator!=(const LeafIterator& other) const { return !(*this == other); }\n-  ValueType& operator*() const { return *it_; }\n-  ValueType* operator->() const { return &*it_; }\n-\n- private:\n-  bool IsLeaf() const { return tree_.IsLeaf(it_->first); }\n-\n-  const ShapeTree<T>& tree_;\n-  Iterator it_;\n-};\n-\n }  // namespace xla\n \n #endif  // XLA_SHAPE_TREE_H_"
        },
        {
            "sha": "121aea2e7baecf388f80248ac51ec202d80d856c",
            "filename": "third_party/xla/xla/tuple_tree.cc",
            "status": "added",
            "additions": 218,
            "deletions": 0,
            "changes": 218,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Ftuple_tree.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Ftuple_tree.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftuple_tree.cc?ref=e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf",
            "patch": "@@ -0,0 +1,218 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tuple_tree.h\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"absl/base/optimization.h\"\n+#include \"absl/container/inlined_vector.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/shape_util.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+namespace internal {\n+\n+namespace {\n+\n+// Helper function to recursively build the IndexTable for a subtree.\n+void BuildSubTableImpl(const IndexTable& original_table,\n+                       const IndexTable::Entry* original_entry,\n+                       absl::Span<IndexTable::Entry> new_entries,\n+                       size_t current_new_entry_idx, size_t& next_node_id,\n+                       size_t& next_children_start_index) {\n+  IndexTable::Entry& new_entry = new_entries[current_new_entry_idx];\n+  new_entry.node_id = next_node_id++;\n+  new_entry.num_children = original_entry->num_children;\n+\n+  if (original_entry->children_start_id == -1) {\n+    new_entry.children_start_id = -1;\n+    return;\n+  }\n+\n+  new_entry.children_start_id = next_children_start_index;\n+  size_t my_children_start = next_children_start_index;\n+  next_children_start_index += new_entry.num_children;\n+\n+  const auto& original_entries = *original_table.entries();\n+  for (size_t i = 0; i < new_entry.num_children; ++i) {\n+    const IndexTable::Entry* original_child_entry =\n+        &original_entries[original_entry->children_start_id + i];\n+    BuildSubTableImpl(original_table, original_child_entry, new_entries,\n+                      my_children_start + i, next_node_id,\n+                      next_children_start_index);\n+  }\n+}\n+\n+}  // namespace\n+\n+size_t IndexTable::CountSubtreeNodes(const IndexTable& table,\n+                                     const IndexTable::Entry* root_entry) {\n+  if (!table.entries().has_value() || root_entry == nullptr) {\n+    return 0;\n+  }\n+  if (root_entry->children_start_id == -1) {\n+    return 1;\n+  }\n+  size_t count = 1;\n+  const auto& entries = *table.entries();\n+  for (size_t i = 0; i < root_entry->num_children; ++i) {\n+    const IndexTable::Entry* child_entry =\n+        &entries[root_entry->children_start_id + i];\n+    count += CountSubtreeNodes(table, child_entry);\n+  }\n+  return count;\n+}\n+\n+absl::Status IndexTable::IsSubtreeCompatible(const IndexTable& other_table,\n+                                             const Entry* other_entry,\n+                                             const IndexTable& this_table,\n+                                             const Entry* this_entry) {\n+  if (other_entry->num_children != this_entry->num_children) {\n+    return absl::InvalidArgumentError(\n+        \"Subtree structures are incompatible: different number of children\");\n+  }\n+\n+  if (other_entry->children_start_id == -1) {  // Leaf nodes\n+    return absl::OkStatus();\n+  }\n+\n+  const auto& other_entries = *other_table.entries();\n+  const auto& this_entries = *this_table.entries();\n+\n+  for (size_t i = 0; i < other_entry->num_children; ++i) {\n+    const Entry* other_child =\n+        &other_entries[other_entry->children_start_id + i];\n+    const Entry* this_child = &this_entries[this_entry->children_start_id + i];\n+    TF_RETURN_IF_ERROR(\n+        IsSubtreeCompatible(other_table, other_child, this_table, this_child));\n+  }\n+  return absl::OkStatus();\n+}\n+\n+// Computes the total size of all nested tuples in the given tuple shape.\n+size_t IndexTable::IndexTableTuplesSize(const Shape& shape) {\n+  DCHECK(shape.IsTuple()) << \"Shape must be a tuple\";\n+\n+  size_t size = shape.tuple_shapes().size();\n+  for (const Shape& subshape : shape.tuple_shapes()) {\n+    if (ABSL_PREDICT_FALSE(subshape.IsTuple())) {\n+      size += IndexTableTuplesSize(subshape);\n+    }\n+  }\n+\n+  return size;\n+}\n+\n+// Initializes the index table in the given entries span. Span must point into\n+// the appropriately sized entries storage.\n+void IndexTable::InitializeIndexTable(const Shape& shape,\n+                                      absl::Span<IndexTable::Entry> entries,\n+                                      size_t entry_index, size_t& next_node_id,\n+                                      size_t& next_children_start_index) {\n+  IndexTable::Entry& entry = entries[entry_index];\n+  entry.node_id = next_node_id++;\n+\n+  // Stop shape traversal once reaching a leaf shape.\n+  if (!shape.IsTuple()) {\n+    entry.children_start_id = -1;\n+    entry.num_children = 0;\n+    return;\n+  }\n+\n+  // The nodes are in depth-first pre-order. However, in order to efficiently\n+  // lookup indices, we generate the index table using breadth-first.\n+  entry.children_start_id = next_children_start_index;\n+  entry.num_children = shape.tuple_shapes().size();\n+\n+  // Add entry for children first, before recursing, so they are consecutive.\n+  next_children_start_index += shape.tuple_shapes().size();\n+  for (size_t i = 0; i < shape.tuple_shapes().size(); ++i) {\n+    InitializeIndexTable(shape.tuple_shapes(i), entries,\n+                         entry.children_start_id + i, next_node_id,\n+                         next_children_start_index);\n+  }\n+}\n+\n+IndexTable::IndexTable(const Shape& shape) {\n+  if (!shape.IsTuple()) {\n+    entries_.emplace(1);\n+    entries_->front() = {0, -1, 0};\n+    return;\n+  }\n+\n+  // Allocate storage for the index table.\n+  entries_.emplace(1 + IndexTableTuplesSize(shape));\n+\n+  size_t next_node_id = 0;\n+  size_t next_children_start_index = 1;\n+  InitializeIndexTable(shape, absl::MakeSpan(*entries_), 0, next_node_id,\n+                       next_children_start_index);\n+}\n+\n+absl::StatusOr<const IndexTable::Entry*> IndexTable::GetEntry(\n+    ShapeIndexView index) const {\n+  if (!entries_.has_value()) {\n+    return absl::FailedPreconditionError(\"Index table not initialized\");\n+  }\n+  const Entry* current = &entries_->front();\n+  for (int64_t i : index) {\n+    if (i < 0) {\n+      return absl::OutOfRangeError(\"Negative index in ShapeIndex\");\n+    }\n+    if (current->children_start_id == -1) {\n+      return absl::InvalidArgumentError(\"Cannot index into a leaf node\");\n+    }\n+    if (i >= current->num_children) {\n+      return absl::NotFoundError(\"Index out of bounds\");\n+    }\n+    current = &(*entries_)[current->children_start_id + i];\n+  }\n+  return current;\n+}\n+\n+absl::StatusOr<IndexTable> IndexTable::CreateFromSubtree(\n+    const IndexTable& original_table, const ShapeIndex& index) {\n+  TF_ASSIGN_OR_RETURN(const Entry* root_entry, original_table.GetEntry(index));\n+\n+  size_t num_nodes = CountSubtreeNodes(original_table, root_entry);\n+  if (num_nodes == 0) {\n+    return absl::InvalidArgumentError(\"Subtree is empty\");\n+  }\n+\n+  IndexTable new_table;\n+  new_table.entries_.emplace(num_nodes);\n+\n+  size_t next_node_id = 0;\n+  size_t next_children_start_index = 1;\n+  if (num_nodes > 0) {\n+    BuildSubTableImpl(original_table, root_entry,\n+                      absl::MakeSpan(*new_table.entries_), 0, next_node_id,\n+                      next_children_start_index);\n+  }\n+\n+  return new_table;\n+}\n+\n+}  // namespace internal\n+}  // namespace xla"
        },
        {
            "sha": "5ceb322d4e3275cf948995b4fe03b42280532ae1",
            "filename": "third_party/xla/xla/tuple_tree.h",
            "status": "added",
            "additions": 799,
            "deletions": 0,
            "changes": 799,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Ftuple_tree.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Ftuple_tree.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftuple_tree.h?ref=e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf",
            "patch": "@@ -0,0 +1,799 @@\n+/* Copyright 2024 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TUPLE_TREE_H_\n+#define XLA_TUPLE_TREE_H_\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <initializer_list>\n+#include <iterator>\n+#include <optional>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/container/inlined_vector.h\"\n+#include \"absl/functional/function_ref.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/shape_util.h\"\n+#include \"xla/tsl/lib/gtl/iterator_range.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+\n+// Forward declaration for friending.\n+template <typename T>\n+class TupleTree;\n+\n+namespace internal {\n+\n+// Index table for TupleTree.\n+class IndexTable {\n+ public:\n+  struct Entry {\n+    // Index in the TupleTree::nodes_ vector.\n+    size_t node_id;\n+    // Index of the first child of this node in the entries_ vector. -1 for\n+    // nodes with no children array (i.e., Node::IsLeaf() is true).\n+    std::make_signed_t<size_t> children_start_id = -1;\n+    // Number of children. This is necessary for bounds checking in GetEntry,\n+    // as TupleTree doesn't have a separate structure definition like Shape.\n+    size_t num_children = 0;\n+  };\n+\n+  IndexTable() = default;\n+\n+  template <typename T>\n+  static IndexTable Create(const typename TupleTree<T>::Node& root) {\n+    IndexTable table;\n+    table.Initialize<T>(root);\n+    return table;\n+  }\n+\n+  explicit IndexTable(const Shape& shape);\n+\n+  absl::StatusOr<const Entry*> GetEntry(ShapeIndexView index) const;\n+\n+  const std::optional<absl::InlinedVector<Entry, 1>>& entries() const {\n+    return entries_;\n+  }\n+\n+  static absl::StatusOr<IndexTable> CreateFromSubtree(\n+      const IndexTable& original_table, const ShapeIndex& index);\n+\n+  // Checks if two subtrees rooted at the given entries are structurally\n+  // compatible.\n+  static absl::Status IsSubtreeCompatible(const IndexTable& other_table,\n+                                          const Entry* other_entry,\n+                                          const IndexTable& this_table,\n+                                          const Entry* this_entry);\n+\n+  // Counts the number of nodes in the subtree rooted at root_entry.\n+  static size_t CountSubtreeNodes(const IndexTable& table,\n+                                  const Entry* root_entry);\n+\n+ private:\n+  // Computes the total size of all nested tuples in the given tuple shape.\n+  static size_t IndexTableTuplesSize(const Shape& shape);\n+\n+  // Initializes the index table in the given entries span. Span must point into\n+  // the appropriately sized entries storage.\n+  static void InitializeIndexTable(const Shape& shape,\n+                                   absl::Span<IndexTable::Entry> entries,\n+                                   size_t entry_index, size_t& next_node_id,\n+                                   size_t& next_children_start_index);\n+\n+  template <typename U>\n+  static size_t CountNodes(const typename TupleTree<U>::Node& node) {\n+    size_t count = 1;\n+    if (!node.IsLeaf()) {\n+      for (const typename TupleTree<U>::Node& child : node.children()) {\n+        count += CountNodes<U>(child);\n+      }\n+    }\n+    return count;\n+  }\n+\n+  template <typename U>\n+  void Initialize(const typename TupleTree<U>::Node& root) {\n+    size_t num_nodes = CountNodes<U>(root);\n+    entries_.emplace(num_nodes);\n+\n+    size_t next_node_id = 0;\n+    size_t next_children_start_index = 1;\n+    BuildTable<U>(root, absl::MakeSpan(*entries_), 0, next_node_id,\n+                  next_children_start_index);\n+  }\n+\n+  template <typename U>\n+  void BuildTable(const typename TupleTree<U>::Node& node,\n+                  absl::Span<Entry> entries, size_t current_entry_idx,\n+                  size_t& next_node_id, size_t& next_children_start_index) {\n+    Entry& entry = entries[current_entry_idx];\n+    entry.node_id = next_node_id++;\n+\n+    if (node.IsLeaf()) {\n+      entry.children_start_id = -1;\n+      entry.num_children = 0;\n+      return;\n+    }\n+\n+    // !node.IsLeaf(), so it's a tuple node (possibly empty).\n+    const std::vector<typename TupleTree<U>::Node>& children = node.children();\n+    entry.num_children = children.size();\n+    entry.children_start_id = next_children_start_index;\n+\n+    size_t my_children_start = next_children_start_index;\n+    next_children_start_index += entry.num_children;\n+\n+    for (size_t i = 0; i < children.size(); ++i) {\n+      BuildTable<U>(children[i], entries, my_children_start + i, next_node_id,\n+                    next_children_start_index);\n+    }\n+  }\n+\n+  std::optional<absl::InlinedVector<Entry, 1>> entries_;\n+};\n+\n+}  // namespace internal\n+\n+// A TupleTree<T> is a tree data structure where each node, whether an\n+// internal node (tuple) or a leaf node, holds a value of type T. The structure\n+// is defined by the nesting of tuples.\n+//\n+// Key Characteristics:\n+// - Each node in the tree has an associated value of type T.\n+// - Nodes can be either internal nodes (tuples with children) or leaf nodes\n+//   (no children).\n+// - The structure is independent of XLA Shapes.\n+// - Internal nodes' values are distinct from their children's values.\n+//\n+// Non-obvious Behaviors:\n+// - Constructor from Span of Pairs: When constructing from a span of\n+//   {ShapeIndex, T} pairs, only the nodes at the specified indices are\n+//   initialized with the given values. Any necessary ancestor tuple nodes are\n+//   implicitly created and their values are default-initialized (e.g., T()).\n+// - `element()` and `mutable_element()`: These methods can access the value\n+//   of *any* node in the tree, not just leaves, using its ShapeIndex.\n+// - `Map` and `MapWithStatus`: These functions apply the given function to the\n+//   values of *all* nodes in the tree, including internal tuple nodes.\n+// - Iterators:\n+//     - `begin()`/`end()` (and `nodes()`): Iterate over all nodes in the tree\n+//       in pre-order.\n+//     - `leaf_begin()`/`leaf_end()` (and `leaves()`): Iterate only over nodes\n+//       for which `IsLeaf()` is true (i.e., nodes with no children).\n+template <typename T>\n+class TupleTree {\n+ public:\n+  // Represents a node in the tree. It can be either a leaf value of type T\n+  // or a vector of subtrees (inner tuple).\n+  // This class is used for constructing TupleTree instances, defining the\n+  // structure and initial values.\n+  class Node {\n+   public:\n+    // Static factory for leaf nodes.\n+    static Node Leaf(const T& value) { return Node(value, std::nullopt); }\n+    static Node Leaf(T&& value) { return Node(std::move(value), std::nullopt); }\n+\n+    // Static factories for tuple nodes.\n+    static Node Tuple() { return Node(T(), std::vector<Node>()); }\n+    static Node Tuple(const T& value) {\n+      return Node(value, std::vector<Node>());\n+    }\n+    static Node Tuple(T&& value) {\n+      return Node(std::move(value), std::vector<Node>());\n+    }\n+    static Node Tuple(absl::Span<const Node> children) {\n+      return Node(T(), std::vector<Node>(children.begin(), children.end()));\n+    }\n+    static Node Tuple(const T& value, absl::Span<const Node> children) {\n+      return Node(value, std::vector<Node>(children.begin(), children.end()));\n+    }\n+    static Node Tuple(T&& value, absl::Span<const Node> children) {\n+      return Node(std::move(value),\n+                  std::vector<Node>(children.begin(), children.end()));\n+    }\n+\n+    static Node FromShape(const Shape& shape, const T& init_value) {\n+      if (!shape.IsTuple()) {\n+        return Node::Leaf(init_value);\n+      }\n+      std::vector<Node> children;\n+      children.reserve(shape.tuple_shapes().size());\n+      for (const auto& subshape : shape.tuple_shapes()) {\n+        children.push_back(FromShape(subshape, init_value));\n+      }\n+      return Node(init_value, std::move(children));\n+    }\n+\n+    static Node FromShape(const Shape& shape) {\n+      if (!shape.IsTuple()) {\n+        return Node::Leaf(T());\n+      }\n+      std::vector<Node> children;\n+      children.reserve(shape.tuple_shapes().size());\n+      for (const auto& subshape : shape.tuple_shapes()) {\n+        children.push_back(FromShape(subshape));\n+      }\n+      return Node(T(), std::move(children));\n+    }\n+\n+    // Default constructor creates an empty tuple.\n+    Node() : children_({}) {}\n+\n+    // Copy constructor and assignment\n+    Node(const Node& other) = default;\n+    Node& operator=(const Node& other) = default;\n+\n+    // Move constructor and assignment\n+    Node(Node&& other) noexcept = default;\n+    Node& operator=(Node&& other) noexcept = default;\n+\n+    bool IsLeaf() const { return !children_.has_value(); }\n+\n+    const T& value() const { return value_; }\n+    T* mutable_value() { return &value_; }\n+\n+    const std::vector<Node>& children() const {\n+      CHECK(children_.has_value());\n+      return *children_;\n+    }\n+    std::vector<Node>* mutable_children() {\n+      CHECK(children_.has_value());\n+      return &*children_;\n+    }\n+\n+    bool operator==(const Node& other) const {\n+      return value_ == other.value_ && children_ == other.children_;\n+    }\n+    bool operator!=(const Node& other) const { return !(*this == other); }\n+\n+   private:\n+    // Primary constructors\n+    explicit Node(T value, std::optional<std::vector<Node>> children)\n+        : value_(std::move(value)), children_(std::move(children)) {}\n+\n+    T value_;\n+    std::optional<std::vector<Node>> children_;\n+  };\n+\n+  using NodePair = std::pair<ShapeIndex, T>;\n+  using NodePairs = absl::InlinedVector<NodePair, 1>;\n+  using IndexTable = internal::IndexTable;\n+\n+  // Constructor for a single leaf node.\n+  explicit TupleTree(const T& leaf_value, T default_value = T())\n+      : default_value_(std::move(default_value)) {\n+    Initialize(Node::Leaf(leaf_value));\n+  }\n+  explicit TupleTree(T&& leaf_value, T default_value = T())\n+      : default_value_(std::move(default_value)) {\n+    Initialize(Node::Leaf(std::move(leaf_value)));\n+  }\n+\n+  // Constructor for an empty tuple.\n+  TupleTree() { Initialize(Node::Tuple()); }\n+\n+  // Constructor from an initializer list, creating a flat tuple of leaves.\n+  TupleTree(std::initializer_list<T> items, T default_value = T())\n+      : default_value_(std::move(default_value)) {\n+    std::vector<Node> children;\n+    children.reserve(items.size());\n+    for (const auto& item : items) {\n+      children.push_back(Node::Leaf(item));\n+    }\n+    Initialize(Node::Tuple(std::move(children)));\n+  }\n+\n+  // Constructor from an initializer list of Nodes for nested structures.\n+  TupleTree(std::initializer_list<Node> items, T default_value = T())\n+      : default_value_(std::move(default_value)) {\n+    Initialize(Node::Tuple(items));\n+  }\n+\n+  // Basic constructor taking the root node.\n+  explicit TupleTree(Node&& root, T default_value = T())\n+      : default_value_(std::move(default_value)) {\n+    Initialize(std::move(root));\n+  }\n+\n+  // Constructor from a list of shape indices and values.\n+  // U must be std::pair<ShapeIndex, T> or const std::pair<ShapeIndex, T>.\n+  // The tree structure is created based on the provided indices. Nodes at these\n+  // indices are initialized with the given values. Any implicitly created\n+  // parent nodes are value-initialized (e.g., T()).\n+  template <typename U>\n+  explicit TupleTree(absl::Span<U> node_pairs, T default_value = T())\n+      : default_value_(default_value) {\n+    static_assert(\n+        std::is_same_v<U, std::pair<ShapeIndex, T>> ||\n+            std::is_same_v<U, const std::pair<ShapeIndex, T>>,\n+        \"TupleTree constructor requires absl::Span of std::pair<ShapeIndex, T> \"\n+        \"or const std::pair<ShapeIndex, T>\");\n+\n+    Node root_node(Node::Tuple(default_value));\n+    for (U& pair : node_pairs) {\n+      const ShapeIndex& index = pair.first;\n+      Node* node = GetOrCreateNode(root_node, index,\n+                                   /*preserve_leaf_value=*/false);\n+      // Forward the second element to enable move semantics if U is non-const.\n+      *node = Node::Leaf(std::forward<decltype(pair.second)>(pair.second));\n+    }\n+    Initialize(std::move(root_node));\n+  }\n+\n+  // Constructor from a Shape and an initial value for all nodes.\n+  explicit TupleTree(const Shape& shape, const T& init_value = T())\n+      : default_value_(init_value) {\n+    index_table_ = IndexTable(shape);\n+    if (!shape.IsTuple()) {\n+      nodes_.emplace_back(ShapeIndex(), init_value);\n+    } else {\n+      nodes_.reserve(ShapeUtil::SubshapeCount(shape));\n+      ShapeUtil::ForEachSubshape(shape,\n+                                 [&](const Shape&, const ShapeIndex& index) {\n+                                   nodes_.emplace_back(index, init_value);\n+                                 });\n+    }\n+  }\n+\n+  // Returns the data element at the given index. This works for any valid\n+  // index, whether it's an internal node or a leaf node.\n+  // CHECK-fails if the index is invalid.\n+  const T& element(ShapeIndexView index) const {\n+    absl::StatusOr<const internal::IndexTable::Entry*> entry_or =\n+        index_table_.GetEntry(index);\n+    CHECK_OK(entry_or.status());\n+    const internal::IndexTable::Entry* entry = entry_or.value();\n+    return nodes_[entry->node_id].second;\n+  }\n+\n+  // Returns a pointer to the data element at the given index. This works for\n+  // any valid index, whether it's an internal node or a leaf node.\n+  // CHECK-fails if the index is invalid.\n+  T* mutable_element(ShapeIndexView index) {\n+    absl::StatusOr<const internal::IndexTable::Entry*> entry_or =\n+        index_table_.GetEntry(index);\n+    CHECK_OK(entry_or.status());\n+    const internal::IndexTable::Entry* entry = entry_or.value();\n+    return &nodes_[entry->node_id].second;\n+  }\n+\n+  // Returns true if the node at the given index is a leaf node (has no\n+  // children).\n+  bool IsLeaf(ShapeIndexView index) const {\n+    absl::StatusOr<const internal::IndexTable::Entry*> entry_or =\n+        index_table_.GetEntry(index);\n+    if (!entry_or.ok()) {\n+      return false;\n+    }\n+    return entry_or.value()->children_start_id == -1;\n+  }\n+\n+  absl::Status CopyCompatibleSubtreeFrom(const TupleTree<T>& other,\n+                                         const ShapeIndex& src_index,\n+                                         const ShapeIndex& dst_index) {\n+    TF_ASSIGN_OR_RETURN(const internal::IndexTable::Entry* src_entry,\n+                        other.index_table_.GetEntry(src_index));\n+    TF_ASSIGN_OR_RETURN(const internal::IndexTable::Entry* dst_entry,\n+                        this->index_table_.GetEntry(dst_index));\n+\n+    TF_RETURN_IF_ERROR(internal::IndexTable::IsSubtreeCompatible(\n+        other.index_table_, src_entry, this->index_table_, dst_entry));\n+\n+    size_t num_subtree_nodes =\n+        internal::IndexTable::CountSubtreeNodes(other.index_table_, src_entry);\n+\n+    for (size_t i = 0; i < num_subtree_nodes; ++i) {\n+      const auto& src_pair = other.nodes_[src_entry->node_id + i];\n+      auto& dst_pair = this->nodes_[dst_entry->node_id + i];\n+      dst_pair.second = T(src_pair.second);\n+    }\n+\n+    return absl::OkStatus();\n+  }\n+\n+  void CopySubtreeFrom(const TupleTree<T>& other, const ShapeIndex& src_index,\n+                       const ShapeIndex& dst_index) {\n+    absl::StatusOr<Node> src_node_or = other.ToNode(src_index);\n+    CHECK_OK(src_node_or.status());\n+    Node src_node = std::move(src_node_or).value();\n+\n+    if (dst_index.empty()) {\n+      Initialize(std::move(src_node));\n+      return;\n+    }\n+\n+    absl::StatusOr<Node> root_node_or = ToNode();\n+    CHECK_OK(root_node_or.status());\n+    Node root_node = std::move(root_node_or).value();\n+\n+    Node* target_node = GetOrCreateNode(root_node, dst_index,\n+                                        /*preserve_leaf_value=*/true);\n+    *target_node = std::move(src_node);\n+\n+    Initialize(std::move(root_node));\n+  }\n+\n+  absl::StatusOr<TupleTree<T>> Subtree(const ShapeIndex& index) const {\n+    TF_ASSIGN_OR_RETURN(const internal::IndexTable::Entry* root_entry,\n+                        index_table_.GetEntry(index));\n+    size_t root_node_id = root_entry->node_id;\n+\n+    TF_ASSIGN_OR_RETURN(\n+        internal::IndexTable subtree_index_table,\n+        internal::IndexTable::CreateFromSubtree(index_table_, index));\n+\n+    if (!subtree_index_table.entries().has_value()) {\n+      // This case should ideally not be reached if GetEntry succeeded.\n+      return absl::InternalError(\"Subtree index table creation failed\");\n+    }\n+\n+    size_t num_subtree_nodes = subtree_index_table.entries()->size();\n+    typename TupleTree<T>::NodePairs subtree_nodes;\n+    subtree_nodes.reserve(num_subtree_nodes);\n+\n+    for (size_t i = 0; i < num_subtree_nodes; ++i) {\n+      const auto& original_pair = nodes_[root_node_id + i];\n+      ShapeIndex new_index(original_pair.first.begin() + index.size(),\n+                           original_pair.first.end());\n+      subtree_nodes.emplace_back(std::move(new_index), original_pair.second);\n+    }\n+\n+    return TupleTree<T>(std::move(subtree_index_table),\n+                        std::move(subtree_nodes), default_value_);\n+  }\n+\n+  using iterator = typename NodePairs::iterator;\n+  using const_iterator = typename NodePairs::const_iterator;\n+  using reverse_iterator = typename NodePairs::reverse_iterator;\n+  using const_reverse_iterator = typename NodePairs::const_reverse_iterator;\n+\n+  template <typename Iterator, typename ValueType>\n+  class LeafIterator;\n+\n+  using leaf_iterator = LeafIterator<iterator, NodePair>;\n+  using const_leaf_iterator = LeafIterator<const_iterator, const NodePair>;\n+  using reverse_leaf_iterator = std::reverse_iterator<leaf_iterator>;\n+  using const_reverse_leaf_iterator =\n+      std::reverse_iterator<const_leaf_iterator>;\n+\n+  iterator begin() { return nodes_.begin(); }\n+  iterator end() { return nodes_.end(); }\n+  const_iterator begin() const { return nodes_.begin(); }\n+  const_iterator end() const { return nodes_.end(); }\n+\n+  reverse_iterator rbegin() { return nodes_.rbegin(); }\n+  reverse_iterator rend() { return nodes_.rend(); }\n+  const_reverse_iterator rbegin() const { return nodes_.rbegin(); }\n+  const_reverse_iterator rend() const { return nodes_.rend(); }\n+\n+  // leaf_begin()/leaf_end() iterates over all nodes for which IsLeaf() is true\n+  // (i.e., nodes with no children).\n+  leaf_iterator leaf_begin() { return leaf_iterator(*this, nodes_.begin()); }\n+  leaf_iterator leaf_end() { return leaf_iterator(*this, nodes_.end()); }\n+  const_leaf_iterator leaf_begin() const {\n+    return const_leaf_iterator(*this, nodes_.begin());\n+  }\n+  const_leaf_iterator leaf_end() const {\n+    return const_leaf_iterator(*this, nodes_.end());\n+  }\n+  // range-based iterator for leaf_begin()/leaf_end().\n+  tsl::gtl::iterator_range<leaf_iterator> leaves() {\n+    return tsl::gtl::make_range(leaf_begin(), leaf_end());\n+  }\n+  tsl::gtl::iterator_range<const_leaf_iterator> leaves() const {\n+    return tsl::gtl::make_range(leaf_begin(), leaf_end());\n+  }\n+\n+  reverse_leaf_iterator leaf_rbegin() {\n+    return reverse_leaf_iterator(leaf_end());\n+  }\n+  reverse_leaf_iterator leaf_rend() {\n+    return reverse_leaf_iterator(leaf_begin());\n+  }\n+  const_reverse_leaf_iterator leaf_rbegin() const {\n+    return const_reverse_leaf_iterator(leaf_end());\n+  }\n+  const_reverse_leaf_iterator leaf_rend() const {\n+    return const_reverse_leaf_iterator(leaf_begin());\n+  }\n+\n+  // Returns an iterator pointing to the node at the given ShapeIndex.\n+  // Returns end() if the index is not found.\n+  iterator find(ShapeIndexView index) {\n+    absl::StatusOr<const internal::IndexTable::Entry*> entry_or =\n+        index_table_.GetEntry(index);\n+    if (!entry_or.ok()) {\n+      return nodes_.end();\n+    }\n+    return nodes_.begin() + (*entry_or)->node_id;\n+  }\n+  const_iterator find(ShapeIndexView index) const {\n+    absl::StatusOr<const internal::IndexTable::Entry*> entry_or =\n+        index_table_.GetEntry(index);\n+    if (!entry_or.ok()) {\n+      return nodes_.end();\n+    }\n+    return nodes_.begin() + (*entry_or)->node_id;\n+  }\n+\n+  // Traversal functions for all elements. These iterate over ALL nodes.\n+  void ForEachElement(\n+      absl::FunctionRef<void(const ShapeIndex&, const T&)> func) const {\n+    for (const NodePair& node : nodes_) {\n+      func(node.first, node.second);\n+    }\n+  }\n+\n+  void ForEachMutableElement(\n+      absl::FunctionRef<void(const ShapeIndex&, T*)> func) {\n+    for (NodePair& node : nodes_) {\n+      func(node.first, &node.second);\n+    }\n+  }\n+\n+  absl::Status ForEachElementWithStatus(\n+      absl::FunctionRef<absl::Status(const ShapeIndex&, const T&)> func) const {\n+    for (const NodePair& node : nodes_) {\n+      TF_RETURN_IF_ERROR(func(node.first, node.second));\n+    }\n+    return absl::OkStatus();\n+  }\n+\n+  absl::Status ForEachMutableElementWithStatus(\n+      absl::FunctionRef<absl::Status(const ShapeIndex&, T*)> func) {\n+    for (NodePair& node : nodes_) {\n+      TF_RETURN_IF_ERROR(func(node.first, &node.second));\n+    }\n+    return absl::OkStatus();\n+  }\n+\n+  bool operator==(const TupleTree<T>& other) const {\n+    if (nodes_.size() != other.nodes_.size()) {\n+      return false;\n+    }\n+    // The order in nodes_ is deterministic (pre-order).\n+    return nodes_ == other.nodes_;\n+  }\n+  bool operator!=(const TupleTree<T>& other) const { return !(*this == other); }\n+\n+  // Returns a range to iterate over all nodes in pre-order.\n+  tsl::gtl::iterator_range<iterator> nodes() {\n+    return tsl::gtl::make_range(begin(), end());\n+  }\n+  // Returns a const range to iterate over all nodes in pre-order.\n+  tsl::gtl::iterator_range<const_iterator> nodes() const {\n+    return tsl::gtl::make_range(begin(), end());\n+  }\n+\n+  // Maps each node's value to generate a new tree with the same structure.\n+  // The function `func` is applied to the value of *every* node.\n+  template <typename U>\n+  TupleTree<U> Map(absl::FunctionRef<U(const T&)> func) const {\n+    typename TupleTree<U>::NodePairs result_nodes;\n+    result_nodes.reserve(nodes_.size());\n+    for (const NodePair& node : nodes_) {\n+      result_nodes.emplace_back(node.first, func(node.second));\n+    }\n+\n+    return TupleTree<U>(index_table_, std::move(result_nodes));\n+  }\n+\n+  // Maps each node's value to generate a new tree with the same structure,\n+  // allowing the mapping function to return a StatusOr.\n+  // The function `func` is applied to the value of *every* node.\n+  template <typename U>\n+  absl::StatusOr<TupleTree<U>> MapWithStatus(\n+      absl::FunctionRef<absl::StatusOr<U>(const T&)> func) const {\n+    typename TupleTree<U>::NodePairs result_nodes;\n+    result_nodes.reserve(nodes_.size());\n+    for (const NodePair& node : nodes_) {\n+      TF_ASSIGN_OR_RETURN(U result, func(node.second));\n+      result_nodes.emplace_back(node.first, std::move(result));\n+    }\n+\n+    return TupleTree<U>(index_table_, std::move(result_nodes));\n+  }\n+\n+  absl::StatusOr<Node> ToNode(ShapeIndexView index_view = {}) const {\n+    if (!index_table_.entries().has_value()) {\n+      return Node::Tuple(default_value_);\n+    }\n+    ShapeIndex index(index_view.begin(), index_view.end());\n+    return ToNodeImpl(index);\n+  }\n+\n+ private:\n+  template <typename U>\n+  friend class TupleTree;\n+\n+  // Private constructor for internal use (e.g., Map).\n+  TupleTree(const IndexTable& index_table, NodePairs&& nodes)\n+      : nodes_(std::move(nodes)), index_table_(index_table) {}\n+\n+  // Private constructor for SubTree.\n+  TupleTree(internal::IndexTable&& index_table, NodePairs&& nodes,\n+            T default_value)\n+      : default_value_(std::move(default_value)),\n+        nodes_(std::move(nodes)),\n+        index_table_(std::move(index_table)) {}\n+\n+  void Initialize(Node root) {\n+    // First, build the IndexTable from the structure.\n+    index_table_ = internal::IndexTable::template Create<T>(root);\n+\n+    // Then, build the nodes_ vector, moving values from root.\n+    nodes_.clear();\n+    if (index_table_.entries().has_value()) {\n+      nodes_.reserve(index_table_.entries()->size());\n+    }\n+    ShapeIndex current_index;\n+    BuildNodesVector(std::move(root), current_index);\n+  }\n+\n+  void BuildNodesVector(Node node, ShapeIndex& current_index) {\n+    nodes_.emplace_back(current_index, std::move(*node.mutable_value()));\n+    if (!node.IsLeaf()) {\n+      std::vector<Node>* children = node.mutable_children();\n+      for (size_t i = 0; i < children->size(); ++i) {\n+        current_index.push_back(i);\n+        BuildNodesVector(std::move((*children)[i]), current_index);\n+        current_index.pop_back();\n+      }\n+    }\n+  }\n+\n+  size_t BuildNodesVectorFromShape(const Shape& shape, const T& init_value,\n+                                   ShapeIndex& current_index, size_t node_idx) {\n+    nodes_[node_idx] = {current_index, init_value};\n+    if (!shape.IsTuple()) {\n+      return node_idx + 1;\n+    }\n+    size_t current_node_idx = node_idx + 1;\n+    for (size_t i = 0; i < shape.tuple_shapes().size(); ++i) {\n+      current_index.push_back(i);\n+      current_node_idx = BuildNodesVectorFromShape(\n+          shape.tuple_shapes(i), init_value, current_index, current_node_idx);\n+      current_index.pop_back();\n+    }\n+    return current_node_idx;\n+  }\n+\n+  Node* GetOrCreateNode(Node& root, const ShapeIndex& index,\n+                        bool preserve_leaf_value) {\n+    Node* node = &root;\n+    if (index.empty()) {\n+      return node;\n+    }\n+    for (int i = 0; i < index.size(); ++i) {\n+      int64_t idx = index[i];\n+      CHECK_GE(idx, 0);\n+\n+      if (node->IsLeaf()) {\n+        // Transition from leaf to tuple.\n+        if (preserve_leaf_value) {\n+          T original_value = std::move(*node->mutable_value());\n+          *node = Node::Tuple(default_value_);\n+          // The original leaf value is placed at index 0.\n+          node->mutable_children()->push_back(\n+              Node::Leaf(std::move(original_value)));\n+        } else {\n+          *node = Node::Tuple(default_value_);\n+        }\n+      }\n+\n+      std::vector<Node>* children = node->mutable_children();\n+      while (idx >= children->size()) {\n+        children->push_back(Node::Tuple(default_value_));\n+      }\n+      node = &children->at(idx);\n+    }\n+    return node;\n+  }\n+\n+  absl::StatusOr<Node> ToNodeImpl(const ShapeIndex& index) const {\n+    TF_ASSIGN_OR_RETURN(const internal::IndexTable::Entry* entry,\n+                        index_table_.GetEntry(index));\n+\n+    const T& value = nodes_[entry->node_id].second;\n+\n+    if (entry->children_start_id == -1) {  // Is a leaf node\n+      return Node::Leaf(value);\n+    }\n+\n+    // Is an internal tuple node\n+    std::vector<Node> children;\n+    children.reserve(entry->num_children);\n+    ShapeIndex child_index = index;\n+    child_index.push_back(0);\n+    for (size_t i = 0; i < entry->num_children; ++i) {\n+      child_index.back() = i;\n+      TF_ASSIGN_OR_RETURN(Node child_node, ToNodeImpl(child_index));\n+      children.push_back(std::move(child_node));\n+    }\n+    return Node::Tuple(value, std::move(children));\n+  }\n+\n+  T default_value_;\n+  // Leaves sorted in pre-order.\n+  NodePairs nodes_;\n+  IndexTable index_table_;\n+};\n+\n+// Internal iterator that performs a pre-order walk of the leaves. This is cheap\n+// to copy. The iterator value_type is equivalent to a std::pair<ShapeIndex,T>&,\n+// similar to std::map.\n+template <typename T>\n+template <typename Iterator, typename ValueType>\n+class TupleTree<T>::LeafIterator {\n+ public:\n+  using iterator_category = std::bidirectional_iterator_tag;\n+  using value_type = ValueType;\n+  using difference_type = ptrdiff_t;\n+  using pointer = value_type*;\n+  using reference = value_type&;\n+\n+  LeafIterator(const TupleTree& tree, Iterator it) : tree_(tree), it_(it) {\n+    while ((it_ != tree_.nodes_.end()) && !tree_.IsLeaf(it_->first)) {\n+      ++it_;\n+    }\n+  }\n+\n+  LeafIterator& operator++() {\n+    do {\n+      ++it_;\n+    } while ((it_ != tree_.nodes_.end()) && !tree_.IsLeaf(it_->first));\n+    return *this;\n+  }\n+\n+  LeafIterator operator++(int) {\n+    auto prev = *this;\n+    ++(*this);\n+    return prev;\n+  }\n+\n+  LeafIterator& operator--() {\n+    do {\n+      --it_;\n+    } while ((it_ != tree_.nodes_.begin()) && !tree_.IsLeaf(it_->first));\n+    return *this;\n+  }\n+\n+  LeafIterator operator--(int) {\n+    auto prev = *this;\n+    --(*this);\n+    return prev;\n+  }\n+\n+  bool operator==(const LeafIterator& other) const { return it_ == other.it_; }\n+  bool operator!=(const LeafIterator& other) const { return !(*this == other); }\n+  ValueType& operator*() const { return *it_; }\n+  ValueType* operator->() const { return &*it_; }\n+\n+ private:\n+  const TupleTree<T>& tree_;\n+  Iterator it_;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_TUPLE_TREE_H_"
        },
        {
            "sha": "767beebf19a4e592a0241eb1e7085adf31baeff3",
            "filename": "third_party/xla/xla/tuple_tree_test.cc",
            "status": "added",
            "additions": 751,
            "deletions": 0,
            "changes": 751,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Ftuple_tree_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf/third_party%2Fxla%2Fxla%2Ftuple_tree_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftuple_tree_test.cc?ref=e44f9fa90248744cd2c5c5f1b9ec4c9ab0b782cf",
            "patch": "@@ -0,0 +1,751 @@\n+/* Copyright 2024 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tuple_tree.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/shape_util.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+\n+namespace xla {\n+\n+using ::absl_testing::StatusIs;\n+using ::testing::ElementsAre;\n+using ::testing::Eq;\n+using ::testing::Pair;\n+using ::testing::Pointee;\n+\n+// Test fixture for TupleTree.\n+class TupleTreeTest : public ::testing::Test {};\n+\n+namespace {\n+\n+TEST_F(TupleTreeTest, SingleLeafConstructor) {\n+  TupleTree<int> tree(42);\n+  EXPECT_TRUE(tree.IsLeaf({}));\n+  EXPECT_EQ(tree.element({}), 42);\n+}\n+\n+TEST_F(TupleTreeTest, EmptyConstructor) {\n+  TupleTree<int> tree;\n+  EXPECT_FALSE(tree.IsLeaf({}));\n+  EXPECT_THAT(tree.nodes(), ElementsAre(Pair(ShapeIndex({}), 0)));\n+  EXPECT_THAT(tree.leaves(), ElementsAre());\n+  EXPECT_EQ(tree.element({}), 0);\n+}\n+\n+TEST_F(TupleTreeTest, SingleLeafMoveConstructor) {\n+  auto val = std::make_unique<int>(42);\n+  TupleTree<std::unique_ptr<int>> tree(std::move(val));\n+  EXPECT_TRUE(tree.IsLeaf({}));\n+  EXPECT_THAT(tree.element({}), Pointee(Eq(42)));\n+  EXPECT_EQ(val, nullptr);\n+}\n+\n+TEST_F(TupleTreeTest, NodeWithValueAndChildren) {\n+  using Node = TupleTree<int>::Node;\n+\n+  // Node with value and empty children (empty tuple)\n+  TupleTree<int> tree1(Node::Tuple(100));\n+  EXPECT_FALSE(tree1.IsLeaf({}));  // It's a tuple, not a leaf\n+  EXPECT_THAT(tree1.nodes(), ElementsAre(Pair(ShapeIndex({}), 100)));\n+  EXPECT_THAT(tree1.leaves(), ElementsAre());\n+\n+  // Node with value and non-empty children\n+  TupleTree<int> tree2(Node::Tuple(200, {Node::Leaf(1), Node::Leaf(2)}));\n+  EXPECT_FALSE(tree2.IsLeaf({}));\n+  EXPECT_TRUE(tree2.IsLeaf({0}));\n+  EXPECT_EQ(tree2.element({0}), 1);\n+  EXPECT_TRUE(tree2.IsLeaf({1}));\n+  EXPECT_EQ(tree2.element({1}), 2);\n+  EXPECT_THAT(tree2.nodes(),\n+              ElementsAre(Pair(ShapeIndex({}), 200), Pair(ShapeIndex({0}), 1),\n+                          Pair(ShapeIndex({1}), 2)));\n+  EXPECT_THAT(tree2.leaves(),\n+              ElementsAre(Pair(ShapeIndex({0}), 1), Pair(ShapeIndex({1}), 2)));\n+\n+  // Accessing the value of a non-leaf node is not directly supported\n+  // by element() which is only for leaves.\n+}\n+\n+TEST_F(TupleTreeTest, NodeValueAndChildrenConstructors) {\n+  using Node = TupleTree<int>::Node;\n+\n+  // Test various constructors\n+  TupleTree<int> tree1(Node::Tuple(10, {Node::Leaf(1), Node::Leaf(2)}));\n+  EXPECT_FALSE(tree1.IsLeaf({}));\n+  EXPECT_EQ(tree1.element({0}), 1);\n+  EXPECT_EQ(tree1.element({1}), 2);\n+\n+  std::vector<Node> children;\n+  children.push_back(Node::Leaf(3));\n+  children.push_back(Node::Leaf(4));\n+  TupleTree<int> tree2(Node::Tuple(20, std::move(children)));\n+  EXPECT_FALSE(tree2.IsLeaf({}));\n+  EXPECT_EQ(tree2.element({0}), 3);\n+  EXPECT_EQ(tree2.element({1}), 4);\n+\n+  int val = 30;\n+  TupleTree<int> tree3(Node::Tuple(val, {Node::Leaf(5)}));\n+  EXPECT_FALSE(tree3.IsLeaf({}));\n+  EXPECT_EQ(tree3.element({0}), 5);\n+\n+  int val2 = 40;\n+  std::vector<Node> children2;\n+  children2.push_back(Node::Leaf(6));\n+  TupleTree<int> tree4(Node::Tuple(std::move(val2), std::move(children2)));\n+  EXPECT_FALSE(tree4.IsLeaf({}));\n+  EXPECT_EQ(tree4.element({0}), 6);\n+}\n+\n+TEST_F(TupleTreeTest, DistinguishEmptyTupleFromLeaf) {\n+  using Node = TupleTree<int>::Node;\n+\n+  // Leaf node\n+  TupleTree<int> leaf_tree(Node::Leaf(42));\n+  EXPECT_TRUE(leaf_tree.IsLeaf({}));\n+  EXPECT_EQ(leaf_tree.element({}), 42);\n+  EXPECT_THAT(leaf_tree.nodes(), ElementsAre(Pair(ShapeIndex({}), 42)));\n+  EXPECT_THAT(leaf_tree.leaves(), ElementsAre(Pair(ShapeIndex({}), 42)));\n+\n+  // Empty tuple node (with a value)\n+  TupleTree<int> empty_tuple_tree(Node::Tuple(100));\n+  EXPECT_FALSE(empty_tuple_tree.IsLeaf({}));\n+  EXPECT_THAT(empty_tuple_tree.nodes(), ElementsAre(Pair(ShapeIndex({}), 100)));\n+  EXPECT_THAT(empty_tuple_tree.leaves(), ElementsAre());\n+\n+  // Empty tuple node (without a value, default constructor)\n+  TupleTree<int> default_empty_tuple_tree;\n+  EXPECT_FALSE(default_empty_tuple_tree.IsLeaf({}));\n+  EXPECT_THAT(default_empty_tuple_tree.nodes(),\n+              ElementsAre(Pair(ShapeIndex({}), 0)));\n+  EXPECT_THAT(default_empty_tuple_tree.leaves(), ElementsAre());\n+}\n+\n+TEST_F(TupleTreeTest, ElementAccessDeathTest) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree(\n+      {Node::Leaf(1), Node::Tuple({Node::Leaf(2), Node::Leaf(3)})});\n+\n+  // Index out of bounds\n+  EXPECT_DEATH(tree.element({5}), \"Index out of bounds\");\n+\n+  // Index too deep\n+  EXPECT_DEATH(tree.element({0, 0}), \"Cannot index into a leaf node\");\n+}\n+\n+TEST_F(TupleTreeTest, MutableElementAccessDeathTest) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree(\n+      {Node::Leaf(1), Node::Tuple({Node::Leaf(2), Node::Leaf(3)})});\n+\n+  // Index out of bounds\n+  EXPECT_DEATH(tree.mutable_element({5}), \"Index out of bounds\");\n+\n+  // Index too deep\n+  EXPECT_DEATH(tree.mutable_element({0, 0}), \"Cannot index into a leaf node\");\n+}\n+\n+TEST_F(TupleTreeTest, IsLeafInvalidIndex) {\n+  TupleTree<int> tree({1, 2});\n+  EXPECT_FALSE(tree.IsLeaf({5}));     // Out of bounds\n+  EXPECT_FALSE(tree.IsLeaf({0, 0}));  // Too deep\n+}\n+\n+TEST_F(TupleTreeTest, CopySubtreeFromOverwriteLeafWithTuple) {\n+  TupleTree<int> src_tree({10, 20});\n+  TupleTree<int> dst_tree(5);  // Dst is initially a leaf\n+\n+  dst_tree.CopySubtreeFrom(src_tree, {}, {});  // Overwrite root\n+\n+  EXPECT_FALSE(dst_tree.IsLeaf({}));\n+  EXPECT_EQ(dst_tree.element({0}), 10);\n+  EXPECT_EQ(dst_tree.element({1}), 20);\n+}\n+\n+TEST_F(TupleTreeTest, CopySubtreeFromOverwriteTupleWithLeaf) {\n+  TupleTree<int> src_tree(10);\n+  TupleTree<int> dst_tree({1, 2});  // Dst is initially a tuple\n+\n+  dst_tree.CopySubtreeFrom(src_tree, {}, {});  // Overwrite root\n+\n+  EXPECT_TRUE(dst_tree.IsLeaf({}));\n+  EXPECT_EQ(dst_tree.element({}), 10);\n+}\n+\n+TEST_F(TupleTreeTest, CopySubtreeFromCreateNodes) {\n+  TupleTree<int> src_tree(10);\n+  TupleTree<int> dst_tree(5);\n+\n+  // Graft src_tree at {1, 0}, creating node {1}\n+  dst_tree.CopySubtreeFrom(src_tree, {}, {1, 0});\n+\n+  EXPECT_TRUE(dst_tree.IsLeaf({0}));\n+  EXPECT_EQ(dst_tree.element({0}), 5);\n+  EXPECT_FALSE(dst_tree.IsLeaf({1}));\n+  EXPECT_TRUE(dst_tree.IsLeaf({1, 0}));\n+  EXPECT_EQ(dst_tree.element({1, 0}), 10);\n+}\n+\n+TEST_F(TupleTreeTest, ElementAccessIndexErrors) {\n+  TupleTree<int> tree({1, 2});\n+\n+  // Negative index\n+  EXPECT_DEATH(tree.element({-1}), \"Negative index in ShapeIndex\");\n+\n+  // Index into a leaf\n+  EXPECT_DEATH(tree.element({0, 0}), \"Cannot index into a leaf node\");\n+\n+  // Out of bounds\n+  EXPECT_DEATH(tree.element({2}), \"Index out of bounds\");\n+}\n+\n+TEST_F(TupleTreeTest, FlatInitializerListConstructor) {\n+  TupleTree<int> tree({1, 2, 3});\n+\n+  EXPECT_FALSE(tree.IsLeaf({}));\n+  EXPECT_TRUE(tree.IsLeaf({0}));\n+  EXPECT_EQ(tree.element({0}), 1);\n+  EXPECT_TRUE(tree.IsLeaf({1}));\n+  EXPECT_EQ(tree.element({1}), 2);\n+  EXPECT_TRUE(tree.IsLeaf({2}));\n+  EXPECT_EQ(tree.element({2}), 3);\n+}\n+\n+TEST_F(TupleTreeTest, NestedInitializerListConstructor) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree({Node::Leaf(1),\n+                       Node::Tuple({Node::Leaf(2), Node::Leaf(3)}),\n+                       Node::Leaf(4)});\n+\n+  EXPECT_FALSE(tree.IsLeaf({}));\n+  EXPECT_TRUE(tree.IsLeaf({0}));\n+  EXPECT_EQ(tree.element({0}), 1);\n+\n+  EXPECT_FALSE(tree.IsLeaf({1}));\n+  EXPECT_TRUE(tree.IsLeaf({1, 0}));\n+  EXPECT_EQ(tree.element({1, 0}), 2);\n+  EXPECT_TRUE(tree.IsLeaf({1, 1}));\n+  EXPECT_EQ(tree.element({1, 1}), 3);\n+\n+  EXPECT_TRUE(tree.IsLeaf({2}));\n+  EXPECT_EQ(tree.element({2}), 4);\n+}\n+\n+TEST_F(TupleTreeTest, IndicesAndValuesConstructor) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  EXPECT_FALSE(tree.IsLeaf({}));\n+  EXPECT_TRUE(tree.IsLeaf({0}));\n+  EXPECT_EQ(tree.element({0}), 10);\n+\n+  EXPECT_FALSE(tree.IsLeaf({1}));\n+  EXPECT_TRUE(tree.IsLeaf({1, 0}));\n+  EXPECT_EQ(tree.element({1, 0}), 20);\n+  EXPECT_TRUE(tree.IsLeaf({1, 1}));\n+  EXPECT_EQ(tree.element({1, 1}), 30);\n+}\n+\n+TEST_F(TupleTreeTest, ElementAccess) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 1}, {{1, 0}, 2}, {{1, 1}, 3}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  EXPECT_EQ(tree.element({0}), 1);\n+  EXPECT_EQ(tree.element({1, 0}), 2);\n+  EXPECT_EQ(tree.element({1, 1}), 3);\n+}\n+\n+TEST_F(TupleTreeTest, MutableElementAccess) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 1}, {{1, 0}, 2}, {{1, 1}, 3}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  *tree.mutable_element({0}) = 100;\n+  EXPECT_EQ(tree.element({0}), 100);\n+\n+  *tree.mutable_element({1, 1}) = 300;\n+  EXPECT_EQ(tree.element({1, 1}), 300);\n+}\n+\n+TEST_F(TupleTreeTest, IsLeaf) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {{{0}, 1}, {{1, 0}, 2}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  EXPECT_TRUE(tree.IsLeaf({0}));\n+  EXPECT_FALSE(tree.IsLeaf({1}));\n+  EXPECT_TRUE(tree.IsLeaf({1, 0}));\n+}\n+\n+TEST_F(TupleTreeTest, CopySubtreeFrom) {\n+  std::vector<std::pair<ShapeIndex, int>> src_leaves = {{{0}, 10}, {{1}, 20}};\n+  TupleTree<int> src_tree(absl::MakeSpan(src_leaves));\n+\n+  TupleTree<int> dst_tree(0);  // Single leaf\n+\n+  // Graft the whole src_tree at {1} in dst_tree\n+  dst_tree.CopySubtreeFrom(src_tree, {}, {1});\n+\n+  EXPECT_TRUE(dst_tree.IsLeaf({0}));\n+  EXPECT_EQ(dst_tree.element({0}), 0);\n+  EXPECT_FALSE(dst_tree.IsLeaf({1}));\n+  EXPECT_EQ(dst_tree.element({1, 0}), 10);\n+  EXPECT_EQ(dst_tree.element({1, 1}), 20);\n+\n+  // Copy a subtree from src\n+  TupleTree<int> dst2_tree(0);\n+  dst2_tree.CopySubtreeFrom(src_tree, {1}, {0});\n+  EXPECT_FALSE(dst2_tree.IsLeaf({}));\n+  EXPECT_TRUE(dst2_tree.IsLeaf({0}));\n+  EXPECT_EQ(dst2_tree.element({0}), 20);\n+}\n+\n+TEST_F(TupleTreeTest, CopySubtreeFromRoot) {\n+  std::vector<std::pair<ShapeIndex, int>> src_leaves = {{{0}, 10}, {{1}, 20}};\n+  TupleTree<int> src_tree(absl::MakeSpan(src_leaves));\n+\n+  TupleTree<int> dst_tree(0);  // Single leaf\n+\n+  // Copy a leaf subtree from src to the root of dst_tree\n+  dst_tree.CopySubtreeFrom(src_tree, {1}, {});\n+  EXPECT_TRUE(dst_tree.IsLeaf({}));\n+  EXPECT_EQ(dst_tree.element({}), 20);\n+\n+  // Copy a tuple subtree from src to the root of dst_tree\n+  dst_tree.CopySubtreeFrom(src_tree, {}, {});\n+  EXPECT_FALSE(dst_tree.IsLeaf({}));\n+  EXPECT_EQ(dst_tree.element({0}), 10);\n+  EXPECT_EQ(dst_tree.element({1}), 20);\n+}\n+\n+TEST_F(TupleTreeTest, CopyCompatibleSubtreeFromSuccess) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> src_tree(\n+      Node::Tuple(100, {Node::Leaf(1), Node::Tuple(200, {Node::Leaf(2)})}));\n+  TupleTree<int> dst_tree(\n+      Node::Tuple(-1, {Node::Leaf(-2), Node::Tuple(-3, {Node::Leaf(-4)})}));\n+\n+  // Copy entire tree\n+  TF_EXPECT_OK(dst_tree.CopyCompatibleSubtreeFrom(src_tree, {}, {}));\n+  EXPECT_EQ(dst_tree.element({}), 100);\n+  EXPECT_EQ(dst_tree.element({0}), 1);\n+  EXPECT_EQ(dst_tree.element({1}), 200);\n+  EXPECT_EQ(dst_tree.element({1, 0}), 2);\n+\n+  // Reset dst_tree\n+  dst_tree = TupleTree<int>(\n+      Node::Tuple(-1, {Node::Leaf(-2), Node::Tuple(-3, {Node::Leaf(-4)})}));\n+  // Copy subtree from {1} in src to {1} in dst\n+  TF_EXPECT_OK(dst_tree.CopyCompatibleSubtreeFrom(src_tree, {1}, {1}));\n+  EXPECT_EQ(dst_tree.element({}), -1);   // Unchanged\n+  EXPECT_EQ(dst_tree.element({0}), -2);  // Unchanged\n+  EXPECT_EQ(dst_tree.element({1}), 200);\n+  EXPECT_EQ(dst_tree.element({1, 0}), 2);\n+\n+  // Copy leaf subtree\n+  TF_EXPECT_OK(dst_tree.CopyCompatibleSubtreeFrom(src_tree, {0}, {0}));\n+  EXPECT_EQ(dst_tree.element({0}), 1);\n+}\n+\n+TEST_F(TupleTreeTest, CopyCompatibleSubtreeFromFailure) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> src_tree(Node::Tuple(100, {Node::Leaf(1), Node::Leaf(2)}));\n+  TupleTree<int> dst_tree(\n+      Node::Tuple(-1, {Node::Leaf(-2)}));  // Different child count\n+\n+  EXPECT_THAT(\n+      dst_tree.CopyCompatibleSubtreeFrom(src_tree, {}, {}),\n+      StatusIs(\n+          absl::StatusCode::kInvalidArgument,\n+          \"Subtree structures are incompatible: different number of children\"));\n+\n+  TupleTree<int> dst_tree2(Node::Leaf(-1));  // Dst is leaf, src is tuple\n+  EXPECT_THAT(\n+      dst_tree2.CopyCompatibleSubtreeFrom(src_tree, {}, {}),\n+      StatusIs(\n+          absl::StatusCode::kInvalidArgument,\n+          \"Subtree structures are incompatible: different number of children\"));\n+\n+  TupleTree<int> src_tree2(Node::Leaf(1));\n+  TupleTree<int> dst_tree3(\n+      Node::Tuple(-1, {Node::Leaf(-2)}));  // Src is leaf, Dst is tuple\n+  EXPECT_THAT(\n+      dst_tree3.CopyCompatibleSubtreeFrom(src_tree2, {}, {}),\n+      StatusIs(\n+          absl::StatusCode::kInvalidArgument,\n+          \"Subtree structures are incompatible: different number of children\"));\n+\n+  // Compatible at root, but not at deeper level\n+  TupleTree<int> src_tree3(\n+      Node::Tuple(100, {Node::Leaf(1), Node::Tuple(200, {Node::Leaf(2)})}));\n+  TupleTree<int> dst_tree4(\n+      Node::Tuple(-1, {Node::Leaf(-2), Node::Leaf(-3)}));  // {1} is leaf in dst\n+\n+  EXPECT_THAT(\n+      dst_tree4.CopyCompatibleSubtreeFrom(src_tree3, {}, {}),\n+      StatusIs(\n+          absl::StatusCode::kInvalidArgument,\n+          \"Subtree structures are incompatible: different number of children\"));\n+}\n+\n+TEST_F(TupleTreeTest, CopyCompatibleSubtreeFromIndexErrors) {\n+  TupleTree<int> src_tree({1, 2});\n+  TupleTree<int> dst_tree({3, 4});\n+\n+  EXPECT_THAT(dst_tree.CopyCompatibleSubtreeFrom(src_tree, {5}, {}),\n+              StatusIs(absl::StatusCode::kNotFound, \"Index out of bounds\"));\n+  EXPECT_THAT(dst_tree.CopyCompatibleSubtreeFrom(src_tree, {}, {5}),\n+              StatusIs(absl::StatusCode::kNotFound, \"Index out of bounds\"));\n+}\n+\n+TEST_F(TupleTreeTest, SubTree) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(TupleTree<int> sub_tree, tree.Subtree({1}));\n+  EXPECT_FALSE(sub_tree.IsLeaf({}));\n+  EXPECT_EQ(sub_tree.element({0}), 20);\n+  EXPECT_EQ(sub_tree.element({1}), 30);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(TupleTree<int> leaf_sub_tree, tree.Subtree({0}));\n+  EXPECT_TRUE(leaf_sub_tree.IsLeaf({}));\n+  EXPECT_EQ(leaf_sub_tree.element({}), 10);\n+\n+  EXPECT_THAT(tree.Subtree({2}), StatusIs(absl::StatusCode::kNotFound));\n+}\n+\n+TEST_F(TupleTreeTest, ForEachElement) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  std::vector<std::pair<ShapeIndex, int>> visited;\n+  tree.ForEachElement([&](const ShapeIndex& index, int value) {\n+    visited.push_back({index, value});\n+  });\n+\n+  EXPECT_THAT(\n+      visited,\n+      ElementsAre(Pair(ShapeIndex({}), 0), Pair(ShapeIndex({0}), 10),\n+                  Pair(ShapeIndex({1}), 0), Pair(ShapeIndex({1, 0}), 20),\n+                  Pair(ShapeIndex({1, 1}), 30)));\n+}\n+\n+TEST_F(TupleTreeTest, ForEachMutableElement) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  int64_t offset = 0;\n+  tree.ForEachMutableElement(\n+      [&](const ShapeIndex& index, int* value) { *value += offset++; });\n+\n+  EXPECT_EQ(tree.element({}), 0);       // 0 + 0\n+  EXPECT_EQ(tree.element({0}), 11);     // 10 + 1\n+  EXPECT_EQ(tree.element({1}), 2);      // 0 + 2\n+  EXPECT_EQ(tree.element({1, 0}), 23);  // 20 + 3\n+  EXPECT_EQ(tree.element({1, 1}), 34);  // 30 + 4\n+}\n+\n+TEST_F(TupleTreeTest, ForEachMutableElementSingleLeaf) {\n+  TupleTree<int> tree(42);\n+  tree.ForEachMutableElement([&](const ShapeIndex& index, int* value) {\n+    EXPECT_TRUE(index.empty());\n+    *value += 1;\n+  });\n+  EXPECT_EQ(tree.element({}), 43);\n+}\n+\n+TEST_F(TupleTreeTest, ForEachElementWithStatus) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {{{0}, 10}, {{1, 0}, 20}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  EXPECT_THAT(\n+      tree.ForEachElementWithStatus([&](const ShapeIndex& index, int value) {\n+        if (index == ShapeIndex({1, 0})) {\n+          return absl::InternalError(\"Stop here\");\n+        }\n+        return absl::OkStatus();\n+      }),\n+      StatusIs(absl::StatusCode::kInternal));\n+}\n+\n+TEST_F(TupleTreeTest, Equality) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves1 = {{{0}, 10}, {{1, 0}, 20}};\n+  TupleTree<int> tree1(absl::MakeSpan(leaves1));\n+\n+  std::vector<std::pair<ShapeIndex, int>> leaves2 = {{{0}, 10}, {{1, 0}, 20}};\n+  TupleTree<int> tree2(absl::MakeSpan(leaves2));\n+\n+  std::vector<std::pair<ShapeIndex, int>> leaves3 = {{{0}, 10}, {{1, 1}, 20}};\n+  TupleTree<int> tree3(absl::MakeSpan(leaves3));\n+\n+  TupleTree<int> tree4(10);\n+\n+  EXPECT_EQ(tree1, tree2);\n+  EXPECT_NE(tree1, tree3);\n+  EXPECT_NE(tree1, tree4);\n+}\n+\n+TEST_F(TupleTreeTest, Iterators) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  std::vector<std::pair<ShapeIndex, int>> visited;\n+  for (auto& pair : tree.nodes()) {\n+    visited.push_back({pair.first, pair.second});\n+    pair.second += 5;  // Test mutability\n+  }\n+\n+  EXPECT_THAT(\n+      visited,\n+      ElementsAre(Pair(ShapeIndex({}), 0), Pair(ShapeIndex({0}), 10),\n+                  Pair(ShapeIndex({1}), 0), Pair(ShapeIndex({1, 0}), 20),\n+                  Pair(ShapeIndex({1, 1}), 30)));\n+\n+  // Check leaves() as well\n+  std::vector<std::pair<ShapeIndex, int>> visited_leaves;\n+  for (auto& pair : tree.leaves()) {\n+    visited_leaves.push_back({pair.first, pair.second});\n+  }\n+  EXPECT_THAT(visited_leaves, ElementsAre(Pair(ShapeIndex({0}), 15),\n+                                          Pair(ShapeIndex({1, 0}), 25),\n+                                          Pair(ShapeIndex({1, 1}), 35)));\n+\n+  EXPECT_EQ(tree.element({0}), 15);\n+  EXPECT_EQ(tree.element({1, 0}), 25);\n+  EXPECT_EQ(tree.element({1, 1}), 35);\n+}\n+\n+TEST_F(TupleTreeTest, ConstIterators) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  const TupleTree<int> tree(absl::MakeSpan(leaves));\n+\n+  std::vector<std::pair<ShapeIndex, int>> visited;\n+  for (const auto& pair : tree.nodes()) {\n+    visited.push_back({pair.first, pair.second});\n+  }\n+\n+  EXPECT_THAT(\n+      visited,\n+      ElementsAre(Pair(ShapeIndex({}), 0), Pair(ShapeIndex({0}), 10),\n+                  Pair(ShapeIndex({1}), 0), Pair(ShapeIndex({1, 0}), 20),\n+                  Pair(ShapeIndex({1, 1}), 30)));\n+\n+  std::vector<std::pair<ShapeIndex, int>> visited_leaves;\n+  for (const auto& pair : tree.leaves()) {\n+    visited_leaves.push_back({pair.first, pair.second});\n+  }\n+  EXPECT_THAT(visited_leaves, ElementsAre(Pair(ShapeIndex({0}), 10),\n+                                          Pair(ShapeIndex({1, 0}), 20),\n+                                          Pair(ShapeIndex({1, 1}), 30)));\n+}\n+\n+TEST_F(TupleTreeTest, LeafIterators) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree({Node::Leaf(1),\n+                       Node::Tuple(100, {Node::Leaf(2), Node::Leaf(3)}),\n+                       Node::Leaf(4), Node::Tuple(200)});\n+\n+  // Expected leaves: {0}:1, {1,0}:2, {1,1}:3, {2}:4\n+  EXPECT_THAT(\n+      tree.leaves(),\n+      ElementsAre(Pair(ShapeIndex({0}), 1), Pair(ShapeIndex({1, 0}), 2),\n+                  Pair(ShapeIndex({1, 1}), 3), Pair(ShapeIndex({2}), 4)));\n+\n+  // Test const iteration\n+  const TupleTree<int>& const_tree = tree;\n+  std::vector<std::pair<ShapeIndex, int>> const_visited;\n+  for (const auto& pair : const_tree.leaves()) {\n+    const_visited.push_back(pair);\n+  }\n+  EXPECT_THAT(\n+      const_visited,\n+      ElementsAre(Pair(ShapeIndex({0}), 1), Pair(ShapeIndex({1, 0}), 2),\n+                  Pair(ShapeIndex({1, 1}), 3), Pair(ShapeIndex({2}), 4)));\n+\n+  // Test mutability\n+  for (auto& pair : tree.leaves()) {\n+    pair.second *= 10;\n+  }\n+  EXPECT_THAT(\n+      tree.leaves(),\n+      ElementsAre(Pair(ShapeIndex({0}), 10), Pair(ShapeIndex({1, 0}), 20),\n+                  Pair(ShapeIndex({1, 1}), 30), Pair(ShapeIndex({2}), 40)));\n+\n+  EXPECT_EQ(tree.element({0}), 10);\n+  EXPECT_EQ(tree.element({1, 0}), 20);\n+  EXPECT_EQ(tree.element({1, 1}), 30);\n+  EXPECT_EQ(tree.element({2}), 40);\n+  // Non-leaf elements should be unchanged\n+  EXPECT_EQ(tree.element({1}), 100);\n+  EXPECT_EQ(tree.element({3}), 200);\n+}\n+\n+TEST_F(TupleTreeTest, LeafIteratorsSingleLeaf) {\n+  TupleTree<int> tree(42);\n+  EXPECT_THAT(tree.leaves(), ElementsAre(Pair(ShapeIndex({}), 42)));\n+\n+  const TupleTree<int>& const_tree = tree;\n+  EXPECT_THAT(const_tree.leaves(), ElementsAre(Pair(ShapeIndex({}), 42)));\n+\n+  for (auto& pair : tree.leaves()) {\n+    pair.second = 100;\n+  }\n+  EXPECT_THAT(tree.leaves(), ElementsAre(Pair(ShapeIndex({}), 100)));\n+}\n+\n+TEST_F(TupleTreeTest, LeafIteratorsEmptyTuple) {\n+  TupleTree<int> tree;\n+  EXPECT_THAT(tree.leaves(), ElementsAre());\n+\n+  const TupleTree<int>& const_tree = tree;\n+  EXPECT_THAT(const_tree.leaves(), ElementsAre());\n+}\n+\n+TEST_F(TupleTreeTest, Map) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree({Node::Leaf(1),\n+                       Node::Tuple(100, {Node::Leaf(2), Node::Leaf(3)}),\n+                       Node::Leaf(4), Node::Tuple(200)});\n+\n+  TupleTree<int> mapped_tree = tree.Map<int>([](int val) { return val * 2; });\n+\n+  EXPECT_THAT(\n+      mapped_tree.nodes(),\n+      ElementsAre(Pair(ShapeIndex({}), 0), Pair(ShapeIndex({0}), 2),\n+                  Pair(ShapeIndex({1}), 200), Pair(ShapeIndex({1, 0}), 4),\n+                  Pair(ShapeIndex({1, 1}), 6), Pair(ShapeIndex({2}), 8),\n+                  Pair(ShapeIndex({3}), 400)));\n+\n+  // Check that the original tree is unchanged.\n+  EXPECT_THAT(\n+      tree.nodes(),\n+      ElementsAre(Pair(ShapeIndex({}), 0), Pair(ShapeIndex({0}), 1),\n+                  Pair(ShapeIndex({1}), 100), Pair(ShapeIndex({1, 0}), 2),\n+                  Pair(ShapeIndex({1, 1}), 3), Pair(ShapeIndex({2}), 4),\n+                  Pair(ShapeIndex({3}), 200)));\n+}\n+\n+TEST_F(TupleTreeTest, MapSingleLeaf) {\n+  TupleTree<int> tree(42);\n+  TupleTree<int> mapped_tree = tree.Map<int>([](int val) { return val + 1; });\n+  EXPECT_THAT(mapped_tree.nodes(), ElementsAre(Pair(ShapeIndex({}), 43)));\n+}\n+\n+TEST_F(TupleTreeTest, MapWithStatusSuccess) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree({Node::Leaf(1), Node::Leaf(2)});\n+\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TupleTree<int> mapped_tree,\n+      tree.MapWithStatus<int>(\n+          [](int val) -> absl::StatusOr<int> { return val * 2; }));\n+\n+  EXPECT_THAT(mapped_tree.nodes(),\n+              ElementsAre(Pair(ShapeIndex({}), 0), Pair(ShapeIndex({0}), 2),\n+                          Pair(ShapeIndex({1}), 4)));\n+}\n+\n+TEST_F(TupleTreeTest, MapWithStatusFailure) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree({Node::Leaf(1), Node::Leaf(-1), Node::Leaf(2)});\n+\n+  absl::StatusOr<TupleTree<int>> result =\n+      tree.MapWithStatus<int>([](int val) -> absl::StatusOr<int> {\n+        if (val < 0) {\n+          return absl::InvalidArgumentError(\"Negative value\");\n+        }\n+        return val * 2;\n+      });\n+\n+  EXPECT_THAT(result,\n+              StatusIs(absl::StatusCode::kInvalidArgument, \"Negative value\"));\n+}\n+\n+TEST_F(TupleTreeTest, IndicesAndValuesConstructorWithDefaultValue) {\n+  std::vector<std::pair<ShapeIndex, int>> leaves = {\n+      {{0}, 10}, {{1, 0}, 20}, {{1, 1}, 30}};\n+  TupleTree<int> tree(absl::MakeSpan(leaves), /*default_value=*/-1);\n+\n+  EXPECT_FALSE(tree.IsLeaf({}));\n+  EXPECT_EQ(tree.element({}), -1);  // Root node should have the default value\n+  EXPECT_TRUE(tree.IsLeaf({0}));\n+  EXPECT_EQ(tree.element({0}), 10);\n+\n+  EXPECT_FALSE(tree.IsLeaf({1}));\n+  EXPECT_EQ(tree.element({1}),\n+            -1);  // Internal node {1} is value-initialized\n+  EXPECT_TRUE(tree.IsLeaf({1, 0}));\n+  EXPECT_EQ(tree.element({1, 0}), 20);\n+  EXPECT_TRUE(tree.IsLeaf({1, 1}));\n+  EXPECT_EQ(tree.element({1, 1}), 30);\n+}\n+\n+TEST_F(TupleTreeTest, ToNode) {\n+  using Node = TupleTree<int>::Node;\n+  TupleTree<int> tree(\n+      Node::Tuple(100, {Node::Leaf(1),                      // {0}\n+                        Node::Tuple(200, {Node::Leaf(2),    // {1, 0}\n+                                          Node::Leaf(3)}),  // {1, 1}\n+                        Node::Leaf(4)}));                   // {2}\n+\n+  // ToNode on root\n+  TF_ASSERT_OK_AND_ASSIGN(Node root_node, tree.ToNode());\n+  EXPECT_EQ(root_node.value(), 100);\n+  EXPECT_FALSE(root_node.IsLeaf());\n+  EXPECT_EQ(root_node.children().size(), 3);\n+\n+  // ToNode on a leaf node\n+  TF_ASSERT_OK_AND_ASSIGN(Node leaf_node, tree.ToNode({0}));\n+  EXPECT_EQ(leaf_node.value(), 1);\n+  EXPECT_TRUE(leaf_node.IsLeaf());\n+\n+  // ToNode on a tuple node\n+  TF_ASSERT_OK_AND_ASSIGN(Node tuple_node, tree.ToNode({1}));\n+  EXPECT_EQ(tuple_node.value(), 200);\n+  EXPECT_FALSE(tuple_node.IsLeaf());\n+  EXPECT_EQ(tuple_node.children().size(), 2);\n+  EXPECT_EQ(tuple_node.children()[0].value(), 2);\n+  EXPECT_EQ(tuple_node.children()[1].value(), 3);\n+\n+  // ToNode on nested leaf node\n+  TF_ASSERT_OK_AND_ASSIGN(Node nested_leaf_node, tree.ToNode({1, 1}));\n+  EXPECT_EQ(nested_leaf_node.value(), 3);\n+  EXPECT_TRUE(nested_leaf_node.IsLeaf());\n+\n+  // ToNode with invalid index\n+  EXPECT_THAT(tree.ToNode({5}), StatusIs(absl::StatusCode::kNotFound));\n+  EXPECT_THAT(tree.ToNode({0, 0}), StatusIs(absl::StatusCode::kInvalidArgument,\n+                                            \"Cannot index into a leaf node\"));\n+}\n+}  // namespace\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 2276,
        "additions": 1926,
        "deletions": 350
    }
}