{
    "author": "ezhulenev",
    "message": "[xla] Migrate to PjRtFuture<>::MakePromise() API\n\nPiperOrigin-RevId: 806470934",
    "sha": "08c71035a833df0fcf9e9be53dfc90126156dc9a",
    "files": [
        {
            "sha": "74afadf88b38775307f178df2eca141438dda9b8",
            "filename": "third_party/xla/xla/pjrt/gpu/tfrt/tfrt_gpu_buffer.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 25,
            "changes": 50,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/08c71035a833df0fcf9e9be53dfc90126156dc9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/08c71035a833df0fcf9e9be53dfc90126156dc9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_buffer.cc?ref=08c71035a833df0fcf9e9be53dfc90126156dc9a",
            "patch": "@@ -333,23 +333,21 @@ PjRtFuture<> TfrtGpuBuffer::ToLiteral(MutableLiteralBase* literal) {\n PjRtFuture<> TfrtGpuBuffer::ToLiteralHelper(\n     PjRtFuture<MutableLiteralBase*> literal) {\n   tsl::profiler::TraceMe traceme(\"TfrtGpuBuffer::ToLiteral\");\n-  auto promise = PjRtFuture<>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   auto usage_event = tsl::MakeConstructedAsyncValueRef<GpuEvent>();\n   auto* device_buffer = AcquireUsage(usage_event);\n   if (device_buffer == nullptr) {\n     promise.Set(\n         InvalidArgument(\"ToLiteral() called on deleted or donated buffer\"));\n-    return PjRtFuture<>(promise);\n+    return future;\n   }\n \n   bool unpack_subbyte_types =\n       client_->xla_client()->backend().transfer_manager()->PackSubbyteTypes();\n \n-  auto literal_and_transpose_promise =\n+  auto [literal_and_transpose_promise, literal_and_transpose_future] =\n       PjRtFuture<std::pair<MutableLiteralBase*,\n-                           std::shared_ptr<TransposePlan>>>::CreatePromise();\n-  PjRtFuture<std::pair<MutableLiteralBase*, std::shared_ptr<TransposePlan>>>\n-      literal_and_transpose_future(literal_and_transpose_promise);\n+                           std::shared_ptr<TransposePlan>>>::MakePromise();\n   literal.OnReady(\n       [client = client_, on_device_shape{on_device_shape_},\n        promise = std::move(literal_and_transpose_promise)](\n@@ -406,9 +404,9 @@ PjRtFuture<> TfrtGpuBuffer::ToLiteralHelper(\n       });\n \n   auto d2h_copy = [device(device_), device_buffer,\n-                   usage_event(std::move(usage_event)), promise,\n-                   client = client_, on_device_shape{on_device_shape_},\n-                   unpack_subbyte_types,\n+                   usage_event(std::move(usage_event)),\n+                   promise = std::move(promise), client = client_,\n+                   on_device_shape{on_device_shape_}, unpack_subbyte_types,\n                    literal_and_transpose =\n                        std::move(literal_and_transpose_future)]() mutable {\n     tsl::profiler::TraceMe traceme(\"ToLiteral::D2H_copy\");\n@@ -522,8 +520,8 @@ PjRtFuture<> TfrtGpuBuffer::ToLiteralHelper(\n                        {device_buffer->definition_event().CopyRCRef()},\n                        std::move(d2h_copy));\n \n-  return PjRtFuture<>(\n-      std::move(promise),\n+  return PjRtFutureHelpers::WithProfiling(\n+      std::move(future),\n       /*on_block_start=*/\n       []() {\n         tsl::profiler::TraceMeProducer traceme(\"TfrtGpuBuffer::ToLiteral\");\n@@ -550,17 +548,18 @@ PjRtFuture<> TfrtGpuBuffer::CopyRawToHostFuture(PjRtFuture<void*> dst_future,\n                                                 int64_t transfer_size) {\n   VLOG(3) << \"TfrtGpuBuffer::CopyRawToHostFuture\";\n   tsl::profiler::TraceMe traceme(\"TfrtGpuBuffer::CopyRawToHostFuture\");\n-  auto promise = PjRtFuture<>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   auto usage_event = tsl::MakeConstructedAsyncValueRef<GpuEvent>();\n   auto* device_buffer = AcquireUsage(usage_event);\n   MarkGpuEventReadyOnExit usage_event_holder(std::move(usage_event));\n   if (device_buffer == nullptr) {\n     return PjRtFuture<>(\n         InvalidArgument(\"ToLiteral() called on deleted or donated buffer\"));\n   }\n-  auto d2h_copy = [device(device_), device_buffer, promise,\n+  auto d2h_copy = [device(device_), device_buffer,\n                    usage_event_holder = std::move(usage_event_holder),\n-                   client = client_, offset, transfer_size](void* dst) mutable {\n+                   client = client_, offset, transfer_size](\n+                      PjRtFuture<>::Promise promise, void* dst) mutable {\n     if (device_buffer->definition_event().IsError()) {\n       LOG(ERROR) << \"device_buffer->definition_event().GetError(): \"\n                  << device_buffer->definition_event().GetError();\n@@ -611,7 +610,7 @@ PjRtFuture<> TfrtGpuBuffer::CopyRawToHostFuture(PjRtFuture<void*> dst_future,\n     if (use_staging) {\n       status = stream->DoHostCallback(\n           [dst, staging_buffer = std::move(staging_buffer), transfer_size,\n-           promise,\n+           promise = std::move(promise),\n            usage_event_holder = std::move(usage_event_holder)]() mutable {\n             tsl::profiler::TraceMe traceme3(\n                 \"CopyRawToHostFuture::D2H_staging_copy\");\n@@ -622,7 +621,7 @@ PjRtFuture<> TfrtGpuBuffer::CopyRawToHostFuture(PjRtFuture<void*> dst_future,\n           });\n     } else {\n       status = stream->DoHostCallback(\n-          [promise,\n+          [promise = std::move(promise),\n            usage_event_holder = std::move(usage_event_holder)]() mutable {\n             promise.Set(absl::OkStatus());\n           });\n@@ -635,23 +634,24 @@ PjRtFuture<> TfrtGpuBuffer::CopyRawToHostFuture(PjRtFuture<void*> dst_future,\n   };\n \n   dst_future.OnReady(\n-      [client(client_), promise, device_buffer,\n+      [client(client_), promise = std::move(promise), device_buffer,\n        d2h_copy = std::move(d2h_copy)](absl::StatusOr<void*> dst_or) mutable {\n         if (!dst_or.ok()) {\n           promise.Set(dst_or.status());\n           LOG(ERROR) << \"dst resolved to an error: \" << dst_or.status();\n           return;\n         }\n-        EnqueueWorkWhenReady(client->blocking_thread_pool(),\n-                             {device_buffer->definition_event().CopyRCRef()},\n-                             [dst = std::move(dst_or.value()),\n-                              d2h_copy = std::move(d2h_copy)]() mutable {\n-                               std::move(d2h_copy)(dst);\n-                             });\n+        EnqueueWorkWhenReady(\n+            client->blocking_thread_pool(),\n+            {device_buffer->definition_event().CopyRCRef()},\n+            [dst = std::move(dst_or.value()), promise = std::move(promise),\n+             d2h_copy = std::move(d2h_copy)]() mutable {\n+              std::move(d2h_copy)(std::move(promise), dst);\n+            });\n       });\n \n-  return PjRtFuture<>(\n-      std::move(promise),\n+  return PjRtFutureHelpers::WithProfiling(\n+      std::move(future),\n       /*on_block_start=*/\n       []() {\n         tsl::profiler::TraceMeProducer traceme("
        }
    ],
    "stats": {
        "total": 50,
        "additions": 25,
        "deletions": 25
    }
}