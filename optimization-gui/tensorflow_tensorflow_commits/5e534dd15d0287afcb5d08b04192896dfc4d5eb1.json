{
    "author": "tensorflower-gardener",
    "message": "Reverts a05e35e330f70fe1920a07573e709247b09ddb15\n\nPiperOrigin-RevId: 843276404",
    "sha": "5e534dd15d0287afcb5d08b04192896dfc4d5eb1",
    "files": [
        {
            "sha": "ca00349f4c25d51cad1d827ea471a2055eeb8bad",
            "filename": "third_party/xla/xla/hlo/analysis/hlo_dataflow_analysis.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 27,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5e534dd15d0287afcb5d08b04192896dfc4d5eb1/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_dataflow_analysis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5e534dd15d0287afcb5d08b04192896dfc4d5eb1/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_dataflow_analysis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fhlo_dataflow_analysis.cc?ref=5e534dd15d0287afcb5d08b04192896dfc4d5eb1",
            "patch": "@@ -44,7 +44,6 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/layout.h\"\n #include \"xla/map_util.h\"\n #include \"xla/service/call_graph.h\"\n #include \"xla/service/hlo_value.h\"\n@@ -1617,26 +1616,6 @@ HloDataflowAnalysis::GetInPlaceInputOutputPairs(\n   return alias_info->GetInPlaceInputOutputPairs(instruction);\n }\n \n-// Returns true if the instruction is a fusion consisting of a single copy which\n-// changes tiling. This is handled by the emitters and effectively are no-ops.\n-static bool IsChangeTilingCopyFusion(HloInstruction* instr) {\n-  if (!instr->parent()->IsFusionComputation() ||\n-      instr->opcode() != HloOpcode::kFusion ||\n-      instr->called_computations().size() != 1 || instr->operand_count() != 1) {\n-    return false;\n-  }\n-  // These copy fusions should only change tiling (and sometimes memory space).\n-  HloInstruction* fusion_root = instr->fused_expression_root();\n-  const Layout& operand_layout = fusion_root->operand(0)->shape().layout();\n-  const Layout& output_layout = fusion_root->shape().layout();\n-  absl::Span<const Tile> operand_tiles = operand_layout.tiles();\n-  absl::Span<const Tile> output_tiles = output_layout.tiles();\n-  return fusion_root->opcode() == HloOpcode::kCopy &&\n-         Layout::Equal().IgnoreTiles().IgnoreMemorySpace()(operand_layout,\n-                                                           output_layout) &&\n-         operand_tiles != output_tiles;\n-}\n-\n bool HloDataflowAnalysis::CanShareOperandBufferWithUser(\n     HloInstruction* operand, const ShapeIndex& operand_index,\n     HloInstruction* user, const ShapeIndex& user_index,\n@@ -1652,12 +1631,7 @@ bool HloDataflowAnalysis::CanShareOperandBufferWithUser(\n   const Shape& user_subshape =\n       ShapeUtil::GetSubshape(user->shape(), user_index);\n \n-  // During tiling assignment, we can add no-op instructions which appear to\n-  // change tiling (and memory space) of the operand, but don't.\n-  if (IsChangeTilingCopyFusion(user) || IsChangeTilingCopyFusion(operand)) {\n-    return true;\n-  }\n-  const bool shapes_equal = ShapeUtil::Equal(operand_subshape, user_subshape);\n+  auto shapes_equal = ShapeUtil::Equal(operand_subshape, user_subshape);\n   // Check that operand and user emit the same shape and layout.\n   if (shapes_equal) {\n     // Must-alias relationship returns true for in-place operations (DUS and DUS"
        }
    ],
    "stats": {
        "total": 28,
        "additions": 1,
        "deletions": 27
    }
}