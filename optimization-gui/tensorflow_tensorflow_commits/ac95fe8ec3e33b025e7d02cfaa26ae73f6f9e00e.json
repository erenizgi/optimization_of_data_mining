{
    "author": "zacmustin",
    "message": "Add `PjRtCApiLoadedExecutable::device_assignment` to the C API.\n\nThis implementation passes a serialized `DeviceAssignmentProto` across the C API. The client is responsible for destroying this serialized proto once it's no longer needed.\n\nPiperOrigin-RevId: 811179448",
    "sha": "ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
    "files": [
        {
            "sha": "989c43233e7aab7b5568aa93ee6eff538876bd24",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -570,13 +570,15 @@ xla_test(\n         \"//xla/pjrt:pjrt_future\",\n         \"//xla/pjrt/distributed:in_memory_key_value_store\",\n         \"//xla/pjrt/gpu:se_gpu_pjrt_client\",\n+        \"//xla/service:computation_placer_hdr\",\n         \"//xla/service:custom_call_target_registry\",\n         \"//xla/stream_executor/gpu:gpu_init\",\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:status\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/cleanup\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\","
        },
        {
            "sha": "c64afce639210f2a6bc66555fb67346964d3fced",
            "filename": "third_party/xla/xla/pjrt/c/CHANGELOG.md",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -1,5 +1,9 @@\n # PJRT C API changelog\n \n+## 0.79\n+\n+* Added `PJRT_LoadedExecutable_GetDeviceAssignment.`\n+\n ## 0.78\n \n * Add incarnations to `PJRT_ExecuteOptions`."
        },
        {
            "sha": "f9fb13d1b5c150229e61c7f553e19a6d0d88ce06",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 32,
            "deletions": 2,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -102,7 +102,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Extension_Base, next);\n // Changes include:\n // * Adding a new field to the PJRT_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define PJRT_API_MINOR 78\n+#define PJRT_API_MINOR 79\n \n // The plugin should set the major_version and minor_version of\n // PJRT_Api.pjrt_api_version to be the `PJRT_API_MAJOR` and `PJRT_API_MINOR` in\n@@ -1503,6 +1503,35 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_LoadedExecutable_GetExecutable_Args, executable);\n typedef PJRT_Error* PJRT_LoadedExecutable_GetExecutable(\n     PJRT_LoadedExecutable_GetExecutable_Args* args);\n \n+typedef struct PJRT_DeviceAssignmentSerialized PJRT_DeviceAssignmentSerialized;\n+\n+struct PJRT_LoadedExecutable_GetDeviceAssignment_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+  PJRT_LoadedExecutable* executable;\n+\n+  // Lives only as long as serialized_device_assignment\n+  const char* serialized_bytes;  // out\n+  size_t serialized_bytes_size;  // out\n+\n+  PJRT_DeviceAssignmentSerialized*\n+      serialized_device_assignment;  // backs serialized_bytes.\n+  // cleanup fn must be called to free the backing memory for serialized_bytes.\n+  // Should only be called once on serialized_device_assignment.\n+  void (*serialized_device_assignment_deleter)(\n+      PJRT_DeviceAssignmentSerialized* da);  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_LoadedExecutable_GetDeviceAssignment_Args,\n+                          serialized_device_assignment_deleter);\n+\n+// Retrieves the serialized DeviceAssignmentProto for a given\n+// PJRT_LoadedExecutable. The implementation allocates the serialized data,\n+// which is valid as long as `serialized_device_assignment` is alive. The\n+// caller must call `serialized_device_assignment_deleter` to free the\n+// backing memory.\n+typedef PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n+    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args);\n+\n struct PJRT_Executable_Name_Args {\n   size_t struct_size;\n   PJRT_Extension_Base* extension_start;\n@@ -2647,11 +2676,12 @@ typedef struct PJRT_Api {\n   _PJRT_API_STRUCT_FIELD(PJRT_TopologyDescription_Deserialize);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateAliasBuffer);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_FulfillAliasBuffer);\n+  _PJRT_API_STRUCT_FIELD(PJRT_LoadedExecutable_GetDeviceAssignment);\n } PJRT_Api;\n \n enum {\n   PJRT_Api_STRUCT_SIZE =\n-      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Client_FulfillAliasBuffer)\n+      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_LoadedExecutable_GetDeviceAssignment)\n };\n \n #undef _PJRT_API_STRUCT_FIELD"
        },
        {
            "sha": "6ec453a582733b088332588fd5f0bc5168bb52a3",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_gpu_test.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/cleanup/cleanup.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n@@ -61,6 +62,7 @@ limitations under the License.\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n+#include \"xla/service/computation_placer.h\"\n #include \"xla/service/custom_call_target_registry.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n@@ -286,6 +288,44 @@ TEST_F(PjrtCApiGpuExecutableTest, GetCompiledMemoryStats) {\n   EXPECT_EQ(ref_stats.host_temp_size_in_bytes, stats.host_temp_size_in_bytes);\n }\n \n+TEST_F(PjrtCApiGpuExecutableTest, GetDeviceAssignment) {\n+  PJRT_LoadedExecutable_GetDeviceAssignment_Args args;\n+  args.struct_size = PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.executable = executable_.get();\n+\n+  PJRT_Error* error = api_->PJRT_LoadedExecutable_GetDeviceAssignment(&args);\n+  ASSERT_EQ(error, nullptr);\n+\n+  absl::Cleanup cleanup = [&args] {\n+    args.serialized_device_assignment_deleter(\n+        args.serialized_device_assignment);\n+  };\n+\n+  // Deserialize\n+  xla::DeviceAssignmentProto proto;\n+  std::string serialized_proto(args.serialized_bytes,\n+                               args.serialized_bytes_size);\n+  ASSERT_TRUE(proto.ParseFromString(serialized_proto));\n+  TF_ASSERT_OK_AND_ASSIGN(auto device_assignment,\n+                          xla::DeviceAssignment::Deserialize(proto));\n+\n+  // Use the PJRT C++ API to create a reference device assignment.\n+  const xla::DeviceAssignment& ref_device_assignment =\n+      executable_->get()->device_assignment();\n+\n+  // Compare with reference to ensure the C++ and C APIs are equivalent.\n+  EXPECT_EQ(device_assignment->replica_count(),\n+            ref_device_assignment.replica_count());\n+  EXPECT_EQ(device_assignment->computation_count(),\n+            ref_device_assignment.computation_count());\n+  for (int i = 0; i < device_assignment->replica_count(); ++i) {\n+    for (int j = 0; j < device_assignment->computation_count(); ++j) {\n+      EXPECT_EQ((*device_assignment)(i, j), ref_device_assignment(i, j));\n+    }\n+  }\n+}\n+\n TEST_F(PjrtCApiGpuTest, CreateAndDestroyExecuteContext) {\n   PJRT_ExecuteContext_Create_Args create_arg;\n   create_arg.struct_size = PJRT_ExecuteContext_Create_Args_STRUCT_SIZE;"
        },
        {
            "sha": "384c30426621d2bb4f6d80b98f58d5d83687b079",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -942,6 +942,9 @@ FieldOffsetsAndSizesForVersion(int major_version, int minor_version) {\n       add_field(\"PJRT_Client_CreateAliasBuffer\", kFnPtrSize);\n       add_field(\"PJRT_Client_FulfillAliasBuffer\", kFnPtrSize);\n     }\n+    if (minor_version >= 79) {\n+      add_field(\"PJRT_LoadedExecutable_GetDeviceAssignment\", kFnPtrSize);\n+    }\n     return version_offsets_and_sizes;\n   }\n   LOG(FATAL) << \"Unsupported API version: \" << major_version << \".\"\n@@ -1330,6 +1333,9 @@ TEST_F(PjrtCAbiTestBase, FieldOffsetsAndSizes) {\n           {\"PJRT_Client_FulfillAliasBuffer\",\n            {offsetof(PJRT_Api, PJRT_Client_FulfillAliasBuffer),\n             sizeof(PJRT_Api::PJRT_Client_FulfillAliasBuffer)}},\n+          {\"PJRT_LoadedExecutable_GetDeviceAssignment\",\n+           {offsetof(PJRT_Api, PJRT_LoadedExecutable_GetDeviceAssignment),\n+            sizeof(PJRT_Api::PJRT_LoadedExecutable_GetDeviceAssignment)}},\n       };\n   ASSERT_EQ(api_->pjrt_api_version.major_version, PJRT_API_MAJOR);\n   ASSERT_EQ(api_->pjrt_api_version.minor_version, PJRT_API_MINOR);"
        },
        {
            "sha": "0774fdff0ee4ddde9f9f1502be370d521910ee4a",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -2581,6 +2581,57 @@ PJRT_Error* PJRT_TopologyDescription_Deserialize(\n   return nullptr;\n }\n \n+PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n+    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_LoadedExecutable_GetDeviceAssignment_Args\",\n+      PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE,\n+      args->struct_size));\n+\n+  // A portable executable doesn't have a device assignment. Return an empty\n+  // assignment and no-op deleter in this case.\n+  PJRT_ASSIGN_OR_RETURN(\n+      xla::CompileOptions compile_options,\n+      args->executable->executable->GetExecutable()->GetCompileOptions());\n+  if (compile_options.compile_portable_executable) {\n+    args->serialized_bytes_size = 0;\n+    args->serialized_device_assignment = nullptr;\n+    args->serialized_device_assignment_deleter =\n+        +[](PJRT_DeviceAssignmentSerialized* serialized_device_assignment) {};\n+    return nullptr;\n+  }\n+\n+  const xla::DeviceAssignment& device_assignment =\n+      args->executable->executable->device_assignment();\n+\n+  xla::DeviceAssignmentProto proto;\n+  device_assignment.Serialize(&proto);\n+\n+  std::string serialized_proto;\n+  if (!proto.SerializeToString(&serialized_proto)) {\n+    return new PJRT_Error{xla::ResourceExhausted(\n+        \"%s: Device assignment serialization failed, likely due to exceeding \"\n+        \"the max supported protobuf size of 2 GiB.\",\n+        __func__)};\n+  }\n+\n+  PJRT_DeviceAssignmentSerialized* serialized_da =\n+      new PJRT_DeviceAssignmentSerialized;\n+  if (serialized_da == nullptr) {\n+    return new PJRT_Error{xla::ResourceExhausted(\n+        \"Out of memory for `PJRT_LoadedExecutable_GetDeviceAssignment()`\")};\n+  }\n+  serialized_da->serialized = std::move(serialized_proto);\n+  args->serialized_device_assignment = serialized_da;\n+  args->serialized_bytes = serialized_da->serialized.data();\n+  args->serialized_bytes_size = serialized_da->serialized.size();\n+  args->serialized_device_assignment_deleter =\n+      +[](PJRT_DeviceAssignmentSerialized* serialized_device_assignment) {\n+        delete serialized_device_assignment;\n+      };\n+  return nullptr;\n+}\n+\n // ---------------------------------- Layouts ----------------------------------\n \n PJRT_Error* PJRT_Layouts_MemoryLayout_Destroy(\n@@ -3044,6 +3095,8 @@ PJRT_Api CreatePjrtApi(PJRT_Client_Create* create_fn,\n       pjrt::PJRT_Client_CreateAliasBuffer,\n       /*PJRT_Client_FulfillAliasBuffer=*/\n       pjrt::PJRT_Client_FulfillAliasBuffer,\n+      /*PJRT_LoadedExecutable_GetDeviceAssignment=*/\n+      pjrt::PJRT_LoadedExecutable_GetDeviceAssignment,\n   };\n }\n "
        },
        {
            "sha": "dd68fa7f8d6c880e42c6d7fdbb2e166c5c00dbf7",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -210,6 +210,10 @@ struct PJRT_SerializedExecutable {\n   std::string serialized;\n };\n \n+struct PJRT_DeviceAssignmentSerialized {\n+  std::string serialized;\n+};\n+\n struct PJRT_SerializedTopology {\n   std::string serialized;\n };\n@@ -384,6 +388,8 @@ PJRT_Error* PJRT_LoadedExecutable_GetExecutable(\n // until the next major version upgrade.\n PJRT_Error* PJRT_LoadedExecutable_Fingerprint(\n     PJRT_LoadedExecutable_Fingerprint_Args* args);\n+PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n+    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args);\n \n PJRT_Error* PJRT_Buffer_Destroy(PJRT_Buffer_Destroy_Args* args);\n PJRT_Error* PJRT_Buffer_ElementType(PJRT_Buffer_ElementType_Args* args);"
        },
        {
            "sha": "ad7b52cb4dcc3bace1d98d2bb2fc43a0a372bc76",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -1802,6 +1802,7 @@ PjRtCApiLoadedExecutable::PjRtCApiLoadedExecutable(\n   executable_ =\n       std::make_unique<PjRtCApiExecutable>(pjrt_c_api(), args.executable);\n   InitDevices();\n+  InitDeviceAssignment();\n }\n \n void PjRtCApiLoadedExecutable::InitDevices() {\n@@ -1826,6 +1827,40 @@ void PjRtCApiLoadedExecutable::InitDevices() {\n   }\n }\n \n+void PjRtCApiLoadedExecutable::InitDeviceAssignment() {\n+  PJRT_LoadedExecutable_GetDeviceAssignment_Args args;\n+  args.struct_size = PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.executable = c_loaded_executable();\n+\n+  const PJRT_Api* api = pjrt_c_api();\n+\n+  pjrt::LogFatalIfPjrtError(\n+      api->PJRT_LoadedExecutable_GetDeviceAssignment(&args), api);\n+\n+  absl::Cleanup cleanup = [&args] {\n+    args.serialized_device_assignment_deleter(\n+        args.serialized_device_assignment);\n+  };\n+\n+  // If `serialized_bytes_size` is 0, this executable is portable and has no\n+  // device assignment.\n+  if (args.serialized_bytes_size == 0) {\n+    device_assignment_ = nullptr;\n+    return;\n+  }\n+\n+  std::string serialized_proto(args.serialized_bytes,\n+                               args.serialized_bytes_size);\n+  DeviceAssignmentProto proto;\n+  CHECK(proto.ParseFromString(serialized_proto));\n+\n+  absl::StatusOr<std::unique_ptr<DeviceAssignment>> device_assignment =\n+      DeviceAssignment::Deserialize(proto);\n+  CHECK_OK(device_assignment.status());\n+  device_assignment_ = std::move(*device_assignment);\n+}\n+\n static std::vector<std::vector<PJRT_Buffer*>> Convert2DCppBuffersToCBuffers(\n     absl::Span<const std::vector<PjRtBuffer*>> cpp_lists) {\n   std::vector<std::vector<PJRT_Buffer*>> c_lists;"
        },
        {
            "sha": "44c611aece815d547cb4a06c56c2b6729f3673bc",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -617,7 +617,11 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n   }\n \n   const DeviceAssignment& device_assignment() const override {\n-    CHECK(false) << \"PJRT C API does not support device_assignment\";\n+    CHECK(device_assignment_ != nullptr)\n+        << \"device_assignment_ is a nullptr. This is likely because \"\n+           \"PjRtCApiLoadedExecutable::device_assignment() was called on a \"\n+           \"portable executable, which does not have a device assignment.\";\n+    return *device_assignment_;\n   }\n \n   absl::Span<const LogicalDeviceIds> addressable_device_logical_ids()\n@@ -751,8 +755,10 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n       loaded_executable_;\n   std::unique_ptr<PjRtCApiExecutable> executable_;\n   std::vector<PjRtDevice*> addressable_devices_;\n+  std::unique_ptr<const DeviceAssignment> device_assignment_;\n \n   void InitDevices();\n+  void InitDeviceAssignment();\n };\n \n class CApiCopyToDeviceStream : public CopyToDeviceStream {"
        },
        {
            "sha": "5aaaffb2e61d6b9aa5024a9a59fb6dd3ecd47cb4",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client_test.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc?ref=ac95fe8ec3e33b025e7d02cfaa26ae73f6f9e00e",
            "patch": "@@ -350,6 +350,35 @@ TEST(PjRtClientTest, CanQueryMemoryDescriptions) {\n   }\n }\n \n+TEST(PjRtCApiClientTest, GetDeviceAssignment) {\n+  SetUpCpuPjRtApi();\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,\n+                          GetCApiClient(\"cpu\"));\n+  ASSERT_GT(client->addressable_devices().size(), 1);\n+\n+  XlaBuilder builder(\"Identity\");\n+  Shape shape = ShapeUtil::MakeShape(S32, {2, 3});\n+  auto input = Parameter(&builder, 0, shape, \"input\");\n+  auto computation = builder.Build(input).value();\n+\n+  DeviceAssignment device_assignment(1, 2);\n+  device_assignment(0, 0) = 0;\n+  device_assignment(0, 1) = 1;\n+\n+  CompileOptions options;\n+  options.executable_build_options.set_device_assignment(device_assignment);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtLoadedExecutable> executable,\n+                          client->CompileAndLoad(computation, options));\n+\n+  const DeviceAssignment& retrieved_assignment =\n+      executable->device_assignment();\n+  EXPECT_EQ(retrieved_assignment.replica_count(), 1);\n+  EXPECT_EQ(retrieved_assignment.computation_count(), 2);\n+  EXPECT_EQ(retrieved_assignment(0, 0), 0);\n+  EXPECT_EQ(retrieved_assignment(0, 1), 1);\n+}\n+\n TEST(PjRtCApiClientTest, WrapClientAroundCApi) {\n   const PJRT_Api* c_api = ::pjrt::cpu_plugin::GetCpuPjrtApi();\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,"
        }
    ],
    "stats": {
        "total": 217,
        "additions": 214,
        "deletions": 3
    }
}