{
    "author": "mooskagh",
    "message": "[XLA:GPU] Use dot operands instead of the computation parameters to estimate parameter sizes.\n\nWe cannot use computation parameters as at that points we don't have fusions yet.\n\nPiperOrigin-RevId: 831478383",
    "sha": "269aa1db2417509df1a1d3f47da3e9bc7f9869fb",
    "files": [
        {
            "sha": "e0effeae280f6af53d86c16cfa236182fc688562",
            "filename": "third_party/xla/xla/service/gpu/transforms/splitk_rewriter.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/269aa1db2417509df1a1d3f47da3e9bc7f9869fb/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsplitk_rewriter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/269aa1db2417509df1a1d3f47da3e9bc7f9869fb/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsplitk_rewriter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsplitk_rewriter.cc?ref=269aa1db2417509df1a1d3f47da3e9bc7f9869fb",
            "patch": "@@ -56,6 +56,8 @@ struct DotDimensions {\n   int64_t m;  // lhs non-contracting dimensions\n   int64_t n;  // rhs non-contracting dimensions\n   int64_t k;  // contracting dimensions\n+  // LHS and RHS element sizes, after going up the chain of elementwise\n+  // operations. That approximates what will be fused.\n   int64_t lhs_element_bits;\n   int64_t rhs_element_bits;\n   int64_t acc_element_bits;\n@@ -228,14 +230,13 @@ HloInstruction* PadInstruction(HloInstruction* instr, int64_t dimension_idx,\n }\n \n // Returns the padded K dimension so that it is a multiple of split_k and 16B.\n-int64_t GetPaddedK(HloInstruction& dot, int64_t k, int64_t split_k) {\n+int64_t GetPaddedK(HloInstruction& dot, int64_t split_k) {\n+  DotDimensions dims = GetDotDimensions(&dot);\n   const int64_t alignment_in_bits = 16 * 8;\n-  int64_t min_element_size_in_bits = alignment_in_bits;\n-  for (const HloInstruction* p : dot.parent()->parameter_instructions()) {\n-    min_element_size_in_bits = std::min(\n-        min_element_size_in_bits, ShapeUtil::ElementSizeInBits(p->shape()));\n-  }\n-  return RoundUpTo(k, split_k * alignment_in_bits / min_element_size_in_bits);\n+  int64_t min_element_size_in_bits = std::min(\n+      {alignment_in_bits, dims.lhs_element_bits, dims.rhs_element_bits});\n+  return RoundUpTo(dims.k,\n+                   split_k * alignment_in_bits / min_element_size_in_bits);\n }\n \n // The contracting dimension index becomes new batch (split) dimension, and all\n@@ -305,8 +306,7 @@ absl::StatusOr<HloInstruction*> SplitKDimensionOfDot(HloDotInstruction* src_dot,\n       src_dot->dot_dimension_numbers().lhs_contracting_dimensions(0);\n   const int64_t rhs_k_idx =\n       src_dot->dot_dimension_numbers().rhs_contracting_dimensions(0);\n-  const int64_t padded_k = GetPaddedK(\n-      *src_dot, src_dot->operand(0)->shape().dimensions(lhs_k_idx), split_k);\n+  const int64_t padded_k = GetPaddedK(*src_dot, split_k);\n   // The operands' K dimension are split into [split_k, K/split_k] (shifting\n   // right all the dimensions after it).\n   HloInstruction* lhs ="
        }
    ],
    "stats": {
        "total": 18,
        "additions": 9,
        "deletions": 9
    }
}