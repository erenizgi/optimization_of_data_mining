{
    "author": "seantalts",
    "message": "[XLA:CPU] Emit basic aarch64 and x86 versions in cc_to_llvm_ir.\n\nPiperOrigin-RevId: 817843552",
    "sha": "c79f78b70693641c338aaadca2fd2b9c21c819e7",
    "files": [
        {
            "sha": "14f35ab7bdff4d24273ecef889d3c2238327bbe8",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/BUILD",
            "status": "modified",
            "additions": 43,
            "deletions": 50,
            "changes": 93,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2FBUILD?ref=c79f78b70693641c338aaadca2fd2b9c21c819e7",
            "patch": "@@ -1,6 +1,6 @@\n load(\"@rules_cc//cc:cc_library.bzl\", \"cc_library\")\n load(\"//xla:xla.default.bzl\", \"xla_cc_test\")\n-load(\":cc_to_llvm_ir.bzl\", \"cc_to_llvm_ir\")\n+load(\":cc_to_llvm_ir.bzl\", \"cc_ir_header\")\n \n package(\n     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],\n@@ -35,49 +35,45 @@ cc_library(\n     hdrs = [\"vector_ops.h\"],\n )\n \n-cc_to_llvm_ir(\n-    name = \"tanh_ir_file\",\n+cpu_features = select({\n+    \":is_x86_64\": {\n+        \"avx2\": [\n+            \"-mavx2\",\n+            \"-mno-avx512f\",\n+        ],\n+        \"avx512\": [\n+            \"-mavx2\",\n+            \"-mavx512f\",\n+        ],\n+    },\n+    \":is_aarch64\": {\n+        \"neon\": [],\n+    },\n+    \"//conditions:default\": {},\n+})\n+\n+cc_ir_header(\n+    name = \"tanh_ll\",\n     src = \"tanh.cc\",\n-    out = \"tanh.ll\",\n+    cpu_features = cpu_features,\n     deps = [\n         \":cpp_context_provider\",\n         \":tanh\",\n         \":vector_ops\",\n     ],\n )\n \n-genrule(\n-    name = \"tanh_ll_header\",\n-    srcs = [\":tanh_ir_file\"],\n-    outs = [\"tanh_ll.h\"],\n-    # This command wraps the IR text in a C++ raw string literal.\n-    cmd = \"\"\"\n-        echo 'constexpr const char* tanh_ir_string = R\"gen_ir(' > $@ && \\\\\n-        cat $(location :tanh_ir_file) >> $@ && \\\\\n-        echo ')gen_ir\";' >> $@\n-    \"\"\",\n-)\n-\n-cc_library(\n-    name = \"tanh_ll_header_lib\",\n-    hdrs = [\":tanh_ll_header\"],\n-)\n-\n xla_cc_test(\n     name = \"tanh_test\",\n     srcs = [\"tanh_test.cc\"],\n     deps = [\n-        \":tanh\",\n-        \":tanh_ll_header_lib\",\n-        \":vector_ops\",\n+        \":tanh_ll\",\n         \"@com_google_googletest//:gtest_main\",\n-        \"@local_tsl//tsl/platform:status_matchers\",\n-        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n \n cc_library(\n-    name = \"eigen_unary\",\n+    name = \"eigen_unary_lib\",\n     srcs = [\"eigen_unary.cc\"],\n     hdrs = [\"eigen_unary.h\"],\n     deps = [\n@@ -86,39 +82,36 @@ cc_library(\n     ],\n )\n \n-cc_to_llvm_ir(\n-    name = \"eigen_unary_ir_file\",\n+cc_ir_header(\n+    name = \"eigen_unary_ll\",\n     src = \"eigen_unary.cc\",\n-    out = \"eigen_unary.ll\",\n+    cpu_features = cpu_features,\n     deps = [\n         \":cpp_context_provider\",\n-        \":eigen_unary\",\n+        \":eigen_unary_lib\",\n+        \":vector_ops\",\n     ],\n )\n \n-cc_library(\n-    name = \"eigen_unary_ll_header_lib\",\n-    hdrs = [\":eigen_unary_ll_header\"],\n-)\n-\n-genrule(\n-    name = \"eigen_unary_ll_header\",\n-    srcs = [\":eigen_unary_ir_file\"],\n-    outs = [\"eigen_unary_ll.h\"],\n-    cmd = \"\"\"\n-        echo 'constexpr const char* eigen_unary_ir_string = R\"gen_ir(' > $@ && \\\\\n-        cat $(location :eigen_unary_ir_file) >> $@ && \\\\\n-        echo ')gen_ir\";' >> $@\n-    \"\"\",\n-)\n-\n xla_cc_test(\n     name = \"eigen_unary_test\",\n     srcs = [\"eigen_unary_test.cc\"],\n     deps = [\n-        \":eigen_unary\",\n-        \":eigen_unary_ll_header_lib\",\n+        \":eigen_unary_ll\",\n         \"@com_google_googletest//:gtest_main\",\n-        \"@eigen_archive//:eigen3\",\n+    ],\n+)\n+\n+config_setting(\n+    name = \"is_x86_64\",\n+    constraint_values = [\n+        \"@platforms//cpu:x86_64\",\n+    ],\n+)\n+\n+config_setting(\n+    name = \"is_aarch64\",\n+    constraint_values = [\n+        \"@platforms//cpu:aarch64\",\n     ],\n )"
        },
        {
            "sha": "91d023f16154f3f30a8307d7d48fc4236d65f9fc",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/cc_to_llvm_ir.bzl",
            "status": "modified",
            "additions": 119,
            "deletions": 40,
            "changes": 159,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fcc_to_llvm_ir.bzl?ref=c79f78b70693641c338aaadca2fd2b9c21c819e7",
            "patch": "@@ -1,75 +1,154 @@\n \"\"\"\n-Starlark rule for compiling a C++ file to LLVM IR (.ll) in a hermetic way.\n+A rule to compile a C++ file to a header containing LLVM IR for various\n+CPU features on the host platform.\n \"\"\"\n \n+load(\"@rules_cc//cc:cc_library.bzl\", \"cc_library\")\n load(\"@rules_cc//cc:find_cc_toolchain.bzl\", \"find_cc_toolchain\", \"use_cc_toolchain\")\n load(\"@rules_cc//cc/common:cc_common.bzl\", \"cc_common\")\n load(\"//xla/tsl:package_groups.bzl\", \"DEFAULT_LOAD_VISIBILITY\")\n \n visibility(DEFAULT_LOAD_VISIBILITY)\n \n-def _cc_to_llvm_ir_impl(ctx):\n-    cc_toolchain = find_cc_toolchain(ctx)\n+def to_camel_case(s):\n+    \"\"\"Converts a snake_case or kebab-case string to CamelCase.\"\"\"\n+    s_with_underscores = s.replace(\"-\", \"_\")\n+    return \"\".join([p.capitalize() for p in s_with_underscores.split(\"_\")])\n \n+def _cc_ir_header_impl(ctx):\n+    \"\"\"Rule implementation that generates IR for multiple features and embeds them in a header.\"\"\"\n+    cc_toolchain = find_cc_toolchain(ctx)\n     feature_configuration = cc_common.configure_features(\n         ctx = ctx,\n         cc_toolchain = cc_toolchain,\n     )\n-    dep_compilation_contexts = [\n-        dep[CcInfo].compilation_context\n-        for dep in ctx.attr.deps\n-    ]\n-\n-    compilation_outputs = cc_common.compile(\n-        actions = ctx.actions,\n-        feature_configuration = feature_configuration,\n-        cc_toolchain = cc_toolchain,\n-        srcs = [ctx.file.src],\n-        cxx_flags = [\n-            \"-S\",\n-            \"-emit-llvm\",\n-        ],\n-        name = ctx.label.name,\n-        compilation_contexts = dep_compilation_contexts,\n-    )\n+    compilation_contexts = [dep[CcInfo].compilation_context for dep in ctx.attr.deps]\n+    output_header = ctx.outputs.out_header\n+\n+    ir_files = []\n+    ir_definitions = []\n+\n+    for feature, flags in sorted(ctx.attr.cpu_features.items()):\n+        ir_file = ctx.actions.declare_file(\"{}{}.ll\".format(ctx.label.name, to_camel_case(feature)))\n+        ir_files.append(ir_file)\n \n-    # The compile action produces an output file. Even though we requested\n-    # LLVM IR, the filename will likely end in \".o\" or \".pic.o\".\n-    # We take the first (and only) object file from the outputs.\n-    intermediate_ll_file = compilation_outputs[1].pic_objects[0]\n-    final_ll_file = ctx.outputs.out\n+        cxx_flags = list(flags) + [\"-S\", \"-emit-llvm\", \"-O3\"]\n+        compilation_outputs = cc_common.compile(\n+            actions = ctx.actions,\n+            feature_configuration = feature_configuration,\n+            cc_toolchain = cc_toolchain,\n+            srcs = ctx.files.src,\n+            compilation_contexts = compilation_contexts,\n+            cxx_flags = cxx_flags,\n+            name = \"{}_{}_compiler\".format(ctx.label.name, feature),\n+        )\n \n+        # 3. Copy the compiler's output to our declared intermediate file.\n+        temp_ir_output = compilation_outputs[1].pic_objects[0]\n+        ctx.actions.run_shell(\n+            inputs = [temp_ir_output],\n+            outputs = [ir_file],\n+            command = \"cp {} {}\".format(temp_ir_output.path, ir_file.path),\n+            mnemonic = \"CopyLLVMIR{}\".format(to_camel_case(feature)),\n+        )\n+\n+        # 4. Prepare the C++ variable definition for the header.\n+        feature_camel_case = to_camel_case(feature)\n+        ir_definitions.append(\n+            'inline constexpr char k{base_name}{feature}Ir[] = R\"IR(\\\\n$(cat {input})\\\\n)IR\";'.format(\n+                base_name = to_camel_case(ctx.attr.base_name),\n+                feature = feature_camel_case,\n+                input = ir_file.path,\n+            ),\n+        )\n+\n+    # 5. Generate the final C++ header file.\n+    all_definitions = \"\\n\\n\".join(ir_definitions)\n     ctx.actions.run_shell(\n-        inputs = [intermediate_ll_file],\n-        outputs = [final_ll_file],\n-        command = \"cp %s %s\" % (intermediate_ll_file.path, final_ll_file.path),\n-        progress_message = \"Copying LLVM IR for %s\" % ctx.label.name,\n-        mnemonic = \"CopyLlvmIr\",\n+        inputs = ir_files,\n+        outputs = [output_header],\n+        mnemonic = \"EmbeddingLLVMIR\",\n+        command = \"\"\"\n+cat <<EOF > {output}\n+#pragma once\n+\n+// Generated by cc_ir_header rule. DO NOT EDIT.\n+\n+namespace {namespace} {{\n+\n+{defs}\n+\n+}} // namespace {namespace}\n+EOF\n+\"\"\".format(\n+            output = output_header.path,\n+            defs = all_definitions,\n+            namespace = ctx.attr.namespace,\n+        ),\n+        progress_message = \"Embedding LLVM IR into header for %s\" % ctx.label,\n     )\n+    compilation_context = cc_common.create_compilation_context(headers = depset([output_header]))\n+    cc_info = CcInfo(compilation_context = compilation_context)\n \n-    return [DefaultInfo(files = depset([final_ll_file]))]\n+    return [DefaultInfo(files = depset([output_header])), cc_info]\n \n-cc_to_llvm_ir = rule(\n-    implementation = _cc_to_llvm_ir_impl,\n+_cc_ir_header_rule = rule(\n+    implementation = _cc_ir_header_impl,\n     attrs = {\n         \"src\": attr.label(\n             allow_single_file = True,\n             mandatory = True,\n             doc = \"The C++ source file to compile.\",\n         ),\n-        \"out\": attr.output(\n+        \"deps\": attr.label_list(providers = [CcInfo]),\n+        \"out_header\": attr.output(\n+            mandatory = True,\n+            doc = \"The output header file.\",\n+        ),\n+        \"cpu_features\": attr.string_list_dict(\n             mandatory = True,\n-            doc = \"The output .ll (LLVM IR) file.\",\n+            doc = \"A dictionary mapping feature names to lists of CXX flags. Use select() here.\",\n         ),\n-        \"deps\": attr.label_list(\n-            providers = [CcInfo],\n+        \"base_name\": attr.string(\n             mandatory = True,\n-            doc = \"A cc_library target to provide the C++ compilation context. You MUST specify at least one cc_library dependency here so this rule can leech the C++ context required for compilation.\",\n+            doc = \"The base name of the generated IR variables.\",\n+        ),\n+        \"namespace\": attr.string(\n+            default = \"llvm_ir\",\n+            doc = \"The C++ namespace for the generated IR variables.\",\n         ),\n         \"_cc_toolchain\": attr.label(default = \"@bazel_tools//tools/cpp:current_cc_toolchain\"),\n     },\n-    # This declares that the rule needs a C++ toolchain to be present.\n     toolchains = use_cc_toolchain(),\n-    doc = \"Compiles a single C++ file to LLVM IR (.ll) using the C++ toolchain.\",\n     fragments = [\"cpp\"],\n )\n+\n+def cc_ir_header(name, src, deps, cpu_features, **kwargs):\n+    \"\"\"A macro that generates an IR header and wraps it in a cc_library.\n+\n+    Args:\n+      name: The name of the generated cc_library.\n+      src: The C++ source file to compile.\n+      deps: The C++ dependencies of the source file.\n+      cpu_features: A dictionary mapping feature names to lists of CXX flags. Use select() here.\n+      **kwargs: Additional arguments to pass to the generated cc_library.\n+    \"\"\"\n+    out_header = name + \".h\"\n+    generator_name = name + \"_generator\"\n+\n+    _cc_ir_header_rule(\n+        base_name = name,\n+        name = generator_name,\n+        tags = [\"manual\"],\n+        src = src,\n+        deps = deps,\n+        cpu_features = cpu_features,\n+        out_header = out_header,\n+        **kwargs\n+    )\n+\n+    cc_library(\n+        name = name,\n+        hdrs = [\":\" + out_header],\n+        **kwargs\n+    )"
        },
        {
            "sha": "f05d928b00fa0184515bea6c8b622908e71c8a93",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 4,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary.cc?ref=c79f78b70693641c338aaadca2fd2b9c21c819e7",
            "patch": "@@ -20,11 +20,19 @@ limitations under the License.\n \n namespace xla::codegen {\n \n+// Using Packet over a Map'd Array yields better llvm IR on ARM.\n+using Packet4f = Eigen::internal::Packet4f;\n+\n Vec4f FastTanhf(const Vec4f x) {\n-  Eigen::Map<const Eigen::Array4f> eigen_view(\n-      reinterpret_cast<const float*>(&x));\n-  Eigen::Array4f result_array = eigen_view.tanh();\n-  return *reinterpret_cast<Vec4f*>(&result_array);\n+  Packet4f packet = static_cast<Eigen::internal::Packet4f>(x);\n+  Packet4f res = Eigen::internal::ptanh_float(packet);\n+  return *static_cast<Vec4f*>(&res);\n+}\n+\n+Vec8d FastRqsqrtf(const Vec8d x) {\n+  const Eigen::Map<const Eigen::Array<double, 8, 1>> x_arr((const double*)&x);\n+  const Eigen::Array<double, 8, 1> res = x_arr.rsqrt();\n+  return *(Vec8d*)res.data();\n }\n \n }  // namespace xla::codegen"
        },
        {
            "sha": "e3ac659b0ecec9b90c697b782a3aa3a739ebf55c",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/eigen_unary_test.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 3,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Feigen_unary_test.cc?ref=c79f78b70693641c338aaadca2fd2b9c21c819e7",
            "patch": "@@ -12,6 +12,7 @@ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n+\n #include <string>\n \n #include <gmock/gmock.h>\n@@ -21,11 +22,31 @@ limitations under the License.\n namespace xla::codegen {\n namespace {\n using ::testing::ContainsRegex;\n+using ::testing::Not;\n \n TEST(EigenUnaryTest, FastTanhfIsVectorized) {\n-  std::string ir = eigen_unary_ir_string;\n-  EXPECT_THAT(ir, ContainsRegex(\"fmul <4 x float>\"));\n-  EXPECT_THAT(ir, ContainsRegex(\"<4 x float>.*0x3E4DF2A3C0000000\"));\n+#ifdef __x86_64__\n+  const std::string avx2 = llvm_ir::kEigenUnaryLlAvx2Ir;\n+  EXPECT_THAT(avx2, ContainsRegex(\"fmul <4 x float>\"));\n+  EXPECT_THAT(avx2, ContainsRegex(\"<4 x float>.*0x3E4DF2A3C0000000\"));\n+  EXPECT_THAT(avx2, ContainsRegex(\"llvm.x86\"));\n+  EXPECT_THAT(avx2, Not(ContainsRegex(\"llvm.aarch64\")));\n+  EXPECT_THAT(avx2, Not(ContainsRegex(\"llvm.fma.v4f32\")));\n+\n+  const std::string avx512 = llvm_ir::kEigenUnaryLlAvx512Ir;\n+  EXPECT_THAT(avx512, ContainsRegex(\"fmul <4 x float>\"));\n+  EXPECT_THAT(avx512, ContainsRegex(\"<4 x float>.*0x3E4DF2A3C0000000\"));\n+  EXPECT_THAT(avx512, ContainsRegex(\"llvm.x86\"));\n+  EXPECT_THAT(avx512, ContainsRegex(\"llvm.fma.v4f32\"));\n+#endif\n+\n+#ifdef __aarch64__\n+  const std::string neon = llvm_ir::kEigenUnaryLlNeonIr;\n+  EXPECT_THAT(neon, ContainsRegex(\"fmul <4 x float>\"));\n+  EXPECT_THAT(neon, ContainsRegex(\"<4 x float>.*0x3E4DF2A3C0000000\"));\n+  EXPECT_THAT(neon, ContainsRegex(\"llvm.aarch64.neon\"));\n+  EXPECT_THAT(neon, Not(ContainsRegex(\"llvm.x86\")));\n+#endif\n }\n \n }  // namespace"
        },
        {
            "sha": "ecafb9d5b2572fb9b2e6c22e3991aea447535481",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/tanh_test.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Ftanh_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Ftanh_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Ftanh_test.cc?ref=c79f78b70693641c338aaadca2fd2b9c21c819e7",
            "patch": "@@ -26,10 +26,18 @@ using ::testing::ContainsRegex;\n namespace {\n \n TEST(TanhTest, FloatTanhVectorized) {\n-  std::string ir = tanh_ir_string;\n+#ifdef __x86_64__\n+  std::string ir = llvm_ir::kTanhLlAvx2Ir;\n   EXPECT_THAT(ir, ContainsRegex(\"fmul <4 x float>\"));\n   EXPECT_THAT(\n       ir, ContainsRegex(\"fcmp olt <4 x float>.*float 0x3F3A36E2E0000000.*\"));\n+#endif\n+#ifdef __aarch64__\n+  std::string ir = llvm_ir::kTanhLlNeonIr;\n+  EXPECT_THAT(ir, ContainsRegex(\"fmul <4 x float>\"));\n+  EXPECT_THAT(\n+      ir, ContainsRegex(\"fcmp olt <4 x float>.*float 0x3F3A36E2E0000000.*\"));\n+#endif\n }\n }  // namespace\n }  // namespace codegen"
        },
        {
            "sha": "ee2c8e0162811e3e8f038244d5366640b3409285",
            "filename": "third_party/xla/xla/codegen/intrinsic/cpp/vector_ops.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fvector_ops.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79f78b70693641c338aaadca2fd2b9c21c819e7/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fvector_ops.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Fintrinsic%2Fcpp%2Fvector_ops.h?ref=c79f78b70693641c338aaadca2fd2b9c21c819e7",
            "patch": "@@ -27,12 +27,14 @@ typedef float Vec4f __attribute__((vector_size(16)));\n typedef float Vec8f __attribute__((vector_size(32)));\n typedef double Vec2d __attribute__((vector_size(16)));\n typedef double Vec4d __attribute__((vector_size(32)));\n+typedef double Vec8d __attribute__((vector_size(64)));\n \n // Corresponding integer types\n typedef uint32_t Vec4i __attribute__((vector_size(16)));\n typedef uint32_t Vec8i __attribute__((vector_size(32)));\n typedef uint64_t Vec2q __attribute__((vector_size(16)));\n typedef uint64_t Vec4q __attribute__((vector_size(32)));\n+typedef uint64_t Vec8q __attribute__((vector_size(64)));\n \n namespace internal {\n // Helper type to select the corresponding integer vector type.\n@@ -55,6 +57,10 @@ template <>\n struct MakeIntVec<uint64_t, 4> {\n   using type = Vec4q;\n };\n+template <>\n+struct MakeIntVec<uint64_t, 8> {\n+  using type = Vec8q;\n+};\n \n // This trait takes a float vector and provides its integer vector partner.\n template <typename FloatVec>"
        }
    ],
    "stats": {
        "total": 311,
        "additions": 213,
        "deletions": 98
    }
}