{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 850305920",
    "sha": "878d1554b408d546384900ef3ea5bf74295ec4f2",
    "files": [
        {
            "sha": "fa4e972b84b93567d912f9aac0ecffd19749f00e",
            "filename": "tensorflow/core/grappler/utils/canonicalizer_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcanonicalizer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcanonicalizer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcanonicalizer_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -21,7 +21,7 @@ namespace tensorflow {\n namespace grappler {\n namespace {\n \n-NodeDef MakeNode(const string& op) {\n+NodeDef MakeNode(const std::string& op) {\n   NodeDef node;\n   node.set_name(\"node\");\n   node.set_op(op);"
        },
        {
            "sha": "e49cae6bea479a70c7e16da2f46911479ad31673",
            "filename": "tensorflow/core/grappler/utils/colocation.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcolocation.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcolocation.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcolocation.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -30,16 +30,17 @@ namespace {\n // starting node to search. By iteratively following the path from child to\n // parent, we can find the root node for the colocation group that node_name\n // belongs to.\n-string GetColocationGroupRoot(std::unordered_map<string, string>* map,\n-                              const string& node_name) {\n+std::string GetColocationGroupRoot(\n+    std::unordered_map<std::string, std::string>* map,\n+    const std::string& node_name) {\n   if (map->find(node_name) == map->end()) {\n     // If node_name is not in the map, we create a new root node which points\n     // to itself.\n     map->insert({node_name, node_name});\n     return node_name;\n   }\n-  std::list<string> nodes_to_root;\n-  string cur = node_name;\n+  std::list<std::string> nodes_to_root;\n+  std::string cur = node_name;\n   while ((*map)[cur] != cur) {\n     // Backtracing the map until we reach the root node.\n     nodes_to_root.push_back(cur);\n@@ -50,7 +51,7 @@ string GetColocationGroupRoot(std::unordered_map<string, string>* map,\n   // so the further lookups can be faster.\n   if (!nodes_to_root.empty()) {\n     nodes_to_root.pop_back();\n-    for (const string& node : nodes_to_root) {\n+    for (const std::string& node : nodes_to_root) {\n       (*map)[node] = cur;\n     }\n   }\n@@ -59,8 +60,8 @@ string GetColocationGroupRoot(std::unordered_map<string, string>* map,\n \n // Merge two colocation groups into one.\n // left and right is the root node of two colocation groups respectively.\n-void MergeColocationGroup(std::unordered_map<string, string>* map,\n-                          const string& left, const string& right) {\n+void MergeColocationGroup(std::unordered_map<std::string, std::string>* map,\n+                          const std::string& left, const std::string& right) {\n   // Do nothing if left or right node is not in the map.\n   if (map->find(left) == map->end() || map->find(right) == map->end()) {\n     return;\n@@ -85,7 +86,7 @@ void ReassignColocation(GraphDef* graph) {\n   constexpr char kColocPrefix[] = \"loc:@\";\n \n   // A hashmap that maps from a node name to its parent node name.\n-  std::unordered_map<string, string> coloc_groups;\n+  std::unordered_map<std::string, std::string> coloc_groups;\n   NodeMap node_map(graph);\n   for (const auto& node : graph->node()) {\n     auto iter = node.attr().find(kClassAttr);\n@@ -94,7 +95,7 @@ void ReassignColocation(GraphDef* graph) {\n         size_t pos = str.find(kColocPrefix);\n         if (pos == 0) {\n           // After we find a colocation, update the colocation groups.\n-          string colocate_node = str.substr(pos + strlen(kColocPrefix));\n+          std::string colocate_node = str.substr(pos + strlen(kColocPrefix));\n           MergeColocationGroup(\n               &coloc_groups, GetColocationGroupRoot(&coloc_groups, node.name()),\n               GetColocationGroupRoot(&coloc_groups, colocate_node));"
        },
        {
            "sha": "6e3aa2e8dedfdf3c1e3ceb212c0075ec66c1cb57",
            "filename": "tensorflow/core/grappler/utils/colocation_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcolocation_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcolocation_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fcolocation_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -25,7 +25,7 @@ namespace grappler {\n \n class ColocationTest : public ::testing::Test {};\n \n-bool VerifyNodeHasColocation(const NodeDef& ndef, const string& coloc) {\n+bool VerifyNodeHasColocation(const NodeDef& ndef, const std::string& coloc) {\n   if (ndef.attr().empty()) {\n     return false;\n   }"
        },
        {
            "sha": "26eed9362d4133e75cd0ce9e4dc4381146ffe2e8",
            "filename": "tensorflow/core/grappler/utils/frame.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fframe.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fframe.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fframe.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -49,12 +49,13 @@ inline absl::Status FrameView::InferFromGraphViewT(\n \n   // We assign unique int id to each frame, and use this map to track what\n   // frames we've already seen in the graph.\n-  absl::flat_hash_map<string, int> frame_name_to_id;\n+  absl::flat_hash_map<std::string, int> frame_name_to_id;\n \n-  auto process_fanout = [this, graph](\n-                            absl::flat_hash_map<string, int>* frame_name_to_id,\n-                            std::deque<int>* ready_node_indices,\n-                            const NodeDef* ready_node, int fanout_node_index) {\n+  auto process_fanout = [this, graph](absl::flat_hash_map<std::string, int>*\n+                                          frame_name_to_id,\n+                                      std::deque<int>* ready_node_indices,\n+                                      const NodeDef* ready_node,\n+                                      int fanout_node_index) {\n     const NodeDef* fanout_node = &graph->node(fanout_node_index);\n     if (!node_to_frames_.contains(fanout_node)) {\n       // If we have never seen this node before, we add all frames from the\n@@ -75,7 +76,7 @@ inline absl::Status FrameView::InferFromGraphViewT(\n               SummarizeNodeDef(*fanout_node));\n         }\n \n-        const string& frame_name = frame_name_attr->s();\n+        const std::string& frame_name = frame_name_attr->s();\n         int frame_id;\n \n         if (frame_name_to_id->contains(frame_name)) {"
        },
        {
            "sha": "02b85f694d5823f21484be4ee7523ccb2423461c",
            "filename": "tensorflow/core/grappler/utils/frame_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fframe_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fframe_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fframe_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -32,17 +32,19 @@ using GraphTypes =\n template <typename T>\n class FrameViewTest : public ::testing::Test {\n  protected:\n-  NodeDef CreateNode(const string& name, const std::vector<string>& inputs) {\n+  NodeDef CreateNode(const std::string& name,\n+                     const std::vector<std::string>& inputs) {\n     return CreateNode(name, \"\", \"\", inputs);\n   }\n \n-  NodeDef CreateNode(const string& name, const string& op,\n-                     const std::vector<string>& inputs) {\n+  NodeDef CreateNode(const std::string& name, const std::string& op,\n+                     const std::vector<std::string>& inputs) {\n     return CreateNode(name, op, \"\", inputs);\n   }\n \n-  NodeDef CreateNode(const string& name, const string& op, const string& frame,\n-                     const std::vector<string>& inputs) {\n+  NodeDef CreateNode(const std::string& name, const std::string& op,\n+                     const std::string& frame,\n+                     const std::vector<std::string>& inputs) {\n     NodeDef node;\n     node.set_name(name);\n     if (!op.empty()) {\n@@ -53,7 +55,7 @@ class FrameViewTest : public ::testing::Test {\n       frame_name.set_s(frame);\n       node.mutable_attr()->insert({\"frame_name\", frame_name});\n     }\n-    for (const string& input : inputs) {\n+    for (const std::string& input : inputs) {\n       node.add_input(input);\n     }\n     return node;\n@@ -111,7 +113,7 @@ TYPED_TEST(FrameViewTest, NestedLoop) {\n   FrameView frame_view;\n   InferFromGraph<TypeParam>(&frame_view, &graph, /*valid=*/true);\n \n-  std::unordered_map<string, std::vector<int>> expected = {\n+  std::unordered_map<std::string, std::vector<int>> expected = {\n       {\"0\", {}},      {\"1\", {0}},     {\"2\", {0}},     {\"3\", {0}},\n       {\"4\", {0}},     {\"5\", {0}},     {\"6\", {0}},     {\"7\", {0, 1}},\n       {\"8\", {0, 1}},  {\"9\", {0, 1}},  {\"10\", {0, 1}}, {\"11\", {0, 1}},\n@@ -137,7 +139,7 @@ TYPED_TEST(FrameViewTest, MultipleInputsToEnter) {\n   FrameView frame_view;\n   InferFromGraph<TypeParam>(&frame_view, &graph, /*valid=*/true);\n \n-  std::unordered_map<string, std::vector<int>> expected = {\n+  std::unordered_map<std::string, std::vector<int>> expected = {\n       {\"0\", {}}, {\"1\", {}}, {\"2\", {0}}, {\"3\", {0}}};\n \n   EXPECT_EQ(frame_view.num_frames(), 1);\n@@ -159,7 +161,7 @@ TYPED_TEST(FrameViewTest, ExitOutput) {\n   FrameView frame_view;\n   InferFromGraph<TypeParam>(&frame_view, &graph, /*valid=*/true);\n \n-  std::unordered_map<string, std::vector<int>> expected = {\n+  std::unordered_map<std::string, std::vector<int>> expected = {\n       {\"0\", {}}, {\"1\", {0}}, {\"2\", {0}}, {\"3\", {}}, {\"4\", {}}};\n \n   EXPECT_EQ(frame_view.num_frames(), 1);\n@@ -186,7 +188,7 @@ TYPED_TEST(FrameViewTest, MultipleEnterNodes) {\n   FrameView frame_view;\n   InferFromGraph<TypeParam>(&frame_view, &graph, /*valid=*/true);\n \n-  std::unordered_map<string, std::vector<int>> expected = {\n+  std::unordered_map<std::string, std::vector<int>> expected = {\n       {\"0\", {}}, {\"1\", {0}}, {\"2\", {0}}, {\"3\", {0}}, {\"4\", {0}},\n       {\"5\", {}}, {\"6\", {0}}, {\"7\", {0}}, {\"8\", {0}}, {\"9\", {0}}};\n "
        },
        {
            "sha": "bc127f7df35606e85077f8926f257b5638519d0d",
            "filename": "tensorflow/core/grappler/utils/functions.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 12,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -38,7 +38,7 @@ namespace tensorflow {\n namespace grappler {\n \n GrapplerFunctionItem::GrapplerFunctionItem(\n-    string func_name, string description, AttrSlice func_attr,\n+    std::string func_name, std::string description, AttrSlice func_attr,\n     std::vector<const FunctionDef::ArgAttrs*> arg_attr,\n     std::vector<InputArgInstantiation> input_args,\n     std::vector<OutputArgInstantiation> output_args,\n@@ -73,7 +73,9 @@ GrapplerFunctionItem::GrapplerFunctionItem(\n   optimization_options().allow_pruning_stateful_and_dataset_ops = false;\n }\n \n-const string& GrapplerFunctionItem::description() const { return description_; }\n+const std::string& GrapplerFunctionItem::description() const {\n+  return description_;\n+}\n \n const std::vector<InputArgInstantiation>& GrapplerFunctionItem::inputs() const {\n   return input_args_;\n@@ -156,7 +158,7 @@ bool IsParametrized(const FunctionDef& func) {\n \n absl::Status InstantiationTypeParameters(\n     const FunctionDef& func, const AttrSlice& func_instantiation_attr,\n-    absl::flat_hash_map<string, DataType>* type_parameters) {\n+    absl::flat_hash_map<std::string, DataType>* type_parameters) {\n   if (!type_parameters->empty()) {\n     return absl::InvalidArgumentError(\n         \"Type parameters output map must be empty\");\n@@ -193,15 +195,15 @@ absl::Status InstantiationTypeParameters(\n \n absl::Status InstantiationBodyParameters(\n     const FunctionDef& func, const AttrSlice& func_instantiation_attr,\n-    absl::flat_hash_map<string, AttrValue>* body_parameters) {\n+    absl::flat_hash_map<std::string, AttrValue>* body_parameters) {\n   if (!body_parameters->empty()) {\n     return absl::InvalidArgumentError(\n         \"Body parameters output map must be empty\");\n   }\n \n   for (const NodeDef& func_body_node : func.node_def()) {\n     for (auto& attr : func_body_node.attr()) {\n-      const string& placeholder = attr.second.placeholder();\n+      const std::string& placeholder = attr.second.placeholder();\n \n       if (placeholder.empty() || body_parameters->contains(placeholder)) {\n         continue;\n@@ -431,8 +433,8 @@ class MakeFunctionDefHelper {\n   // Converts input name from GraphDef format (name[:position]) to the\n   // FunctionDef input format (name[:output][:position]) using registered input\n   // arg instantiations and function body outputs.\n-  absl::Status AsFunctionDefInput(const string& graph_def_input,\n-                                  string* func_def_input) const;\n+  absl::Status AsFunctionDefInput(const std::string& graph_def_input,\n+                                  std::string* func_def_input) const;\n \n   // Updates Node inputs from GraphDef to FunctionDef format.\n   absl::Status AsFunctionDefNode(NodeDef* function_body_node) const;\n@@ -449,7 +451,8 @@ class MakeFunctionDefHelper {\n   absl::flat_hash_set<absl::string_view> input_nodes_;\n   absl::flat_hash_set<absl::string_view> output_nodes_;\n   // Mapping from function body node name to output names range map.\n-  absl::flat_hash_map<string, tensorflow::NameRangeMap> function_body_outputs_;\n+  absl::flat_hash_map<std::string, tensorflow::NameRangeMap>\n+      function_body_outputs_;\n };\n \n absl::Status MakeFunctionDefHelper::Initialize(\n@@ -476,7 +479,7 @@ absl::Status MakeFunctionDefHelper::Initialize(\n }\n \n absl::Status MakeFunctionDefHelper::AsFunctionDefInput(\n-    const string& graph_def_input, string* func_def_input) const {\n+    const std::string& graph_def_input, std::string* func_def_input) const {\n   if (IsControlInput(graph_def_input)) {\n     *func_def_input = graph_def_input;\n     return absl::OkStatus();\n@@ -516,7 +519,7 @@ absl::Status MakeFunctionDefHelper::AsFunctionDefInput(\n \n absl::Status MakeFunctionDefHelper::AsFunctionDefNode(\n     NodeDef* function_body_node) const {\n-  string func_def_input;\n+  std::string func_def_input;\n \n   for (int i = 0; i < function_body_node->input_size(); ++i) {\n     TF_RETURN_IF_ERROR(\n@@ -540,7 +543,7 @@ absl::Status MakeFunctionDef(const GrapplerFunctionItem& item,\n   TF_RETURN_IF_ERROR(helper.Initialize(item, flib));\n \n   // Mapping from the '_Retval' node name to the output tensor.\n-  absl::flat_hash_map<absl::string_view, string> output_tensors;\n+  absl::flat_hash_map<absl::string_view, std::string> output_tensors;\n   for (const NodeDef& func_body_node : item.function_body().node()) {\n     if (!helper.IsOutputNode(func_body_node)) continue;\n     if (func_body_node.input_size() != 1) {\n@@ -561,7 +564,7 @@ absl::Status MakeFunctionDef(const GrapplerFunctionItem& item,\n \n   // Add function output arguments.\n   for (const OutputArgInstantiation& output_arg : item.outputs()) {\n-    const string output_name =\n+    const std::string output_name =\n         absl::StrReplaceAll(output_arg.node_name, {{\"_RetVal\", \"\"}});\n \n     OpDef::ArgDef arg_def;"
        },
        {
            "sha": "399bd9bcbd9c40e5b8b35459ad1a479917deee1a",
            "filename": "tensorflow/core/grappler/utils/functions.h",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions.h?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -36,25 +36,25 @@ namespace grappler {\n // Function input argument instantiated into an '_Arg' node in the function body\n // graph, with an 'index' attribute corresponding to the input position.\n struct InputArgInstantiation {\n-  InputArgInstantiation(string node_name, DataType data_type)\n+  InputArgInstantiation(std::string node_name, DataType data_type)\n       : node_name(std::move(node_name)), data_type(data_type) {}\n-  string node_name;\n+  std::string node_name;\n   DataType data_type;\n };\n \n // Function output instantiated into a '_Retval' node in the function body\n // graph, with an 'index' attribute corresponding to the output position.\n struct OutputArgInstantiation {\n-  OutputArgInstantiation(string node_name, DataType data_type)\n+  OutputArgInstantiation(std::string node_name, DataType data_type)\n       : node_name(std::move(node_name)), data_type(data_type) {}\n-  string node_name;\n+  std::string node_name;\n   DataType data_type;\n };\n \n // A mapping from control output name to node name in function body graph.\n struct ControlOutput {\n-  string output_name;\n-  string node_name;\n+  std::string output_name;\n+  std::string node_name;\n   bool operator<(const ControlOutput& a) const {\n     return output_name < a.output_name;\n   }\n@@ -65,7 +65,7 @@ class GrapplerFunctionItem : public GrapplerItem {\n  public:\n   GrapplerFunctionItem() = default;\n \n-  const string& description() const;\n+  const std::string& description() const;\n \n   const std::vector<InputArgInstantiation>& inputs() const;\n   const InputArgInstantiation& input(int i) const;\n@@ -98,7 +98,7 @@ class GrapplerFunctionItem : public GrapplerItem {\n                                             GrapplerFunctionItem*,\n                                             std::vector<std::pair<int, int>>*);\n \n-  GrapplerFunctionItem(string func_name, string description,\n+  GrapplerFunctionItem(std::string func_name, std::string description,\n                        AttrSlice func_attr,\n                        std::vector<const FunctionDef::ArgAttrs*> arg_attr,\n                        std::vector<InputArgInstantiation> input_args,\n@@ -107,7 +107,7 @@ class GrapplerFunctionItem : public GrapplerItem {\n                        int graph_def_version, bool is_stateful,\n                        GraphDef&& function_body);\n \n-  string description_;\n+  std::string description_;\n   AttrSlice func_attr_;  // Attributes specific to function definition that\n                          // produced this item (FuncDef.attr field).\n \n@@ -137,14 +137,14 @@ bool IsParametrized(const FunctionDef& func);\n // caller node. Return error if type can't be resolved.\n absl::Status InstantiationTypeParameters(\n     const FunctionDef& func, const AttrSlice& func_instantiation_attr,\n-    absl::flat_hash_map<string, DataType>* type_parameters);\n+    absl::flat_hash_map<std::string, DataType>* type_parameters);\n \n // Resolve function instantiation body parameters (values for the function body\n // attr placeholders) from the attributes of the caller node. Return error if\n // type can't be resolved.\n absl::Status InstantiationBodyParameters(\n     const FunctionDef& func, const AttrSlice& func_instantiation_attr,\n-    absl::flat_hash_map<string, AttrValue>* body_parameters);\n+    absl::flat_hash_map<std::string, AttrValue>* body_parameters);\n \n // Replace one of the function inputs with a constant.\n absl::Status ReplaceInputWithConst(const NodeDef& input_const, int input_index,"
        },
        {
            "sha": "e23f62733c5e904fd592b27368fd276b7c828931",
            "filename": "tensorflow/core/grappler/utils/functions_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 15,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ffunctions_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -78,15 +78,15 @@ TEST_F(FunctionsTest, InstantiationParameters) {\n       /* Mapping between function returns and function node outputs. */\n       {{\"x\", \"cx:output:0\"}, {\"y\", \"cy:output:0\"}});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"key\"].set_s(\"key-value\");\n   func_instantiation_attr[\"A\"].set_type(DT_FLOAT);\n   func_instantiation_attr[\"B\"].set_type(DT_INT32);\n   func_instantiation_attr[\"C\"].mutable_list()->add_type(DT_FLOAT);\n   func_instantiation_attr[\"C\"].mutable_list()->add_type(DT_INT32);\n   func_instantiation_attr[\"D\"].set_type(DT_DOUBLE);\n \n-  absl::flat_hash_map<string, DataType> type_parameters;\n+  absl::flat_hash_map<std::string, DataType> type_parameters;\n   TF_EXPECT_OK(InstantiationTypeParameters(\n       func, AttrSlice(&func_instantiation_attr), &type_parameters));\n \n@@ -97,7 +97,7 @@ TEST_F(FunctionsTest, InstantiationParameters) {\n   EXPECT_EQ(DT_INT32, type_parameters[\"C:1\"]);\n   EXPECT_EQ(DT_DOUBLE, type_parameters[\"D\"]);\n \n-  absl::flat_hash_map<string, AttrValue> body_parameters;\n+  absl::flat_hash_map<std::string, AttrValue> body_parameters;\n   TF_EXPECT_OK(InstantiationBodyParameters(\n       func, AttrSlice(&func_instantiation_attr), &body_parameters));\n \n@@ -123,7 +123,7 @@ TEST_F(FunctionsTest, FromSimpleFunctionDef) {\n           {{\"y\"}, \"Mul\", {\"x\", \"scale\"}, {{\"T\", \"$T\"}}},\n       });\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_FLOAT);\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n@@ -204,7 +204,7 @@ TEST_F(FunctionsTest, FromFunctionDefWithMultiOutputNodes) {\n       // Nodes\n       nodes);\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_FLOAT);\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n@@ -365,7 +365,7 @@ TEST_F(FunctionsTest, FromFunctionDefWithOutputMappings) {\n       // Mapping\n       {{\"out\", \"Exp:y:0\"}});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n   GrapplerFunctionItem item;\n@@ -416,7 +416,7 @@ TEST_F(FunctionsTest, FromFunctionDefWithoutInput) {\n       {{{\"two\"}, \"Const\", {}, {{\"value\", kTwo}, {\"dtype\", DT_INT64}}},\n        {{\"o\"}, \"Cast\", {\"two\"}, {{\"SrcT\", DT_INT64}, {\"DstT\", \"$T\"}}}});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_FLOAT);\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n@@ -456,7 +456,7 @@ TEST_F(FunctionsTest, FromFunctionDefWithSideEffectfulOps) {\n       {{{\"one\"}, \"Const\", {}, {{\"value\", kOne}, {\"dtype\", DT_FLOAT}}},\n        {{\"update\"}, \"AssignAdd\", {\"x\", \"one\"}, {{\"T\", DT_FLOAT}}}});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n   GrapplerFunctionItem item;\n@@ -483,7 +483,7 @@ TEST_F(FunctionsTest, FromFunctionDefWithControlOutputs) {\n       },\n       {}, {{\"side_effects\", \"update\"}});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n   GrapplerFunctionItem item;\n@@ -524,14 +524,15 @@ TEST_F(FunctionsTest, MakeFunctionDef) {\n       });\n \n   // Add an attribute to _Arg 0;\n-  const uint32 arg_index = 0;\n-  const std::pair<string, string> arg_attr_key_and_value = {\"_arg_attr\", \"abc\"};\n+  const uint32_t arg_index = 0;\n+  const std::pair<std::string, std::string> arg_attr_key_and_value = {\n+      \"_arg_attr\", \"abc\"};\n   FunctionDef::ArgAttrs arg_attr;\n   (*arg_attr.mutable_attr())[arg_attr_key_and_value.first].set_s(\n       arg_attr_key_and_value.second);\n   (*func.mutable_arg_attr())[arg_index] = arg_attr;\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_FLOAT);\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n@@ -580,7 +581,7 @@ TEST_F(FunctionsTest, ReplaceInputWithConst) {\n       /* Mapping between function returns and function node outputs. */\n       {{\"z\", \"output:z:0\"}});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_FLOAT);\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n@@ -670,7 +671,7 @@ TEST_F(FunctionsTest, SwapFunctionBodyAndMakeFunctionDef) {\n        NDef(\"read_x\", \"Identity\", {\"x\"}, {{\"T\", \"float\"}}),\n        NDef(\"z_RetVal\", \"_Retval\", {\"read_x\"}, {{\"T\", \"float\"}})});\n \n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_FLOAT);\n \n   FunctionDefLibrary lib_def;\n@@ -717,7 +718,7 @@ TEST_F(FunctionsTest, FunctionDefGrapplerFunctionItemRoundTrip) {\n   FunctionLibraryDefinition flib(OpRegistry::Global(), FunctionDefLibrary());\n \n   GrapplerFunctionItem item;\n-  protobuf::Map<string, AttrValue> func_instantiation_attr;\n+  protobuf::Map<std::string, AttrValue> func_instantiation_attr;\n   func_instantiation_attr[\"T\"].set_type(DT_INT32);\n   TF_EXPECT_OK(MakeGrapplerFunctionItem(func,\n                                         AttrSlice(&func_instantiation_attr),"
        },
        {
            "sha": "b09e0565a34179b4a138b724f083f7491405e0a2",
            "filename": "tensorflow/core/grappler/utils/graph_view.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 20,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -120,10 +120,10 @@ bool GraphView::AddUniqueNodeInternal(const NodeDef* node) {\n absl::Status GraphView::CheckAndAddFaninsInternal(NodeView* node_view) {\n   bool has_observed_control = false;\n   const NodeDef* node = node_view->node();\n-  const string& node_name = node->name();\n+  const std::string& node_name = node->name();\n   const int node_index = node_view->node_index_;\n   node_view->fanins_set_.reserve(node->input_size());\n-  for (const string& input : node->input()) {\n+  for (const std::string& input : node->input()) {\n     TensorId fanin_id = ParseTensorName(input);\n     if (fanin_id.node() == node_name) {\n       return errors::InvalidArgument(kGraphViewError, \"node '\", node_name,\n@@ -224,12 +224,12 @@ Mutation::Mutation(MutableGraphView* graph_view) : graph_view_(graph_view) {}\n \n MutationNewNode Mutation::AddNode(NodeDef&& node, absl::Status* status) {\n   bool has_observed_control = false;\n-  const string& node_name = node.name();\n+  const std::string& node_name = node.name();\n   std::vector<SafeTensorId> regular_fanins;\n-  absl::flat_hash_set<string> controlling_fanins;\n+  absl::flat_hash_set<std::string> controlling_fanins;\n   const int num_fanins = node.input_size();\n   for (int i = 0; i < num_fanins; ++i) {\n-    const string& input = node.input(i);\n+    const std::string& input = node.input(i);\n     TensorId fanin_id = ParseTensorName(input);\n     if (fanin_id.node() == node_name) {\n       *status =\n@@ -506,10 +506,10 @@ absl::Status MutableGraphView::CheckFaninsInternal(\n   for (int i = 0; i < num_nodes; ++i) {\n     bool has_observed_control = false;\n     const NodeDef* node = nodes_[i].node();\n-    const string& node_name = node->name();\n+    const std::string& node_name = node->name();\n     std::vector<TensorId> node_fanins;\n     node_fanins.reserve(node->input_size());\n-    for (const string& input : node->input()) {\n+    for (const std::string& input : node->input()) {\n       TensorId fanin_id = ParseTensorName(input);\n       if (fanin_id.node() == node_name) {\n         return errors::InvalidArgument(kMutableGraphViewError, \"node '\",\n@@ -613,13 +613,13 @@ absl::Status MutableGraphView::GetNodeNamesAndPartitionUpdatedNodes(\n   for (const auto& diff : mutation_.updated_nodes_) {\n     if (diff.update_name) {\n       const int index = diff.node_index;\n-      const string& node_name = nodes_[index].GetName();\n+      const std::string& node_name = nodes_[index].GetName();\n       node_names->emplace(node_name, index);\n     }\n   }\n \n   for (int node_index : mutation_.removed_nodes_) {\n-    const string& node_name = nodes_[node_index].GetName();\n+    const std::string& node_name = nodes_[node_index].GetName();\n     node_names->emplace(node_name, node_index);\n   }\n \n@@ -670,7 +670,7 @@ absl::Status MutableGraphView::GetNodeNamesAndPartitionUpdatedNodes(\n \n   // Get names of new nodes after potential mutation.\n   for (const auto& new_node : mutation_.new_nodes_) {\n-    const string& node_name = new_node.node.name();\n+    const std::string& node_name = new_node.node.name();\n     auto it = node_names->insert({node_name, internal::kNodeNamePresent});\n     if (it.second) {\n       continue;\n@@ -821,7 +821,8 @@ absl::Status MutableGraphView::CheckKernelRegisteredForNodes() {\n       gtl::InsertOrUpdate(&(*diff.processed_attrs), attr_to_add.first,\n                           attr_to_add.second);\n     }\n-    const string& device = diff.update_device ? diff.device : node->device();\n+    const std::string& device =\n+        diff.update_device ? diff.device : node->device();\n     DeviceNameUtils::ParsedName name;\n     if (device.empty() || !DeviceNameUtils::ParseFullName(device, &name) ||\n         !name.has_type) {\n@@ -892,7 +893,7 @@ void MutableGraphView::ReplaceNodeFanouts(MutableNodeView* node, T* fanouts) {\n \n void MutableGraphView::FixRenamedNodes(\n     std::vector<RenamedOrOverwrittenNode>* renamed_nodes,\n-    absl::flat_hash_map<string, NodeViewFanouts>* renamed_fanouts,\n+    absl::flat_hash_map<std::string, NodeViewFanouts>* renamed_fanouts,\n     std::vector<bool>* overwritten_name_removed_nodes) {\n   // Extract all renamed node fanouts.\n   renamed_fanouts->reserve(renamed_nodes->size());\n@@ -944,7 +945,7 @@ void MutableGraphView::FixRenamedNodes(\n }\n \n void MutableGraphView::AddNewNodes(\n-    absl::flat_hash_map<string, NodeViewFanouts>* renamed_fanouts,\n+    absl::flat_hash_map<std::string, NodeViewFanouts>* renamed_fanouts,\n     std::vector<int>* new_node_indices) {\n   new_node_indices->reserve(mutation_.new_nodes_.size());\n   for (auto& new_node : mutation_.new_nodes_) {\n@@ -982,7 +983,7 @@ void MutableGraphView::AddNewNodes(\n }\n \n void MutableGraphView::FixRenamedFanouts(\n-    const absl::flat_hash_map<string, NodeViewFanouts>& renamed_fanouts) {\n+    const absl::flat_hash_map<std::string, NodeViewFanouts>& renamed_fanouts) {\n   // Leftover fanouts in renamed_fanouts are due to nodes not existing anymore\n   // or a node being renamed without another node taking its place. For these\n   // leftover fanouts, mark their respective fanin fanout_index_ to\n@@ -1175,7 +1176,7 @@ inline void MutableGraphView::AddControllingFaninInternal(\n     MutableNodeView* node_view, absl::string_view fanin_node_name) {\n   NodeDef* node = node_view->node();\n   // Add controlling fanin to NodeDef.\n-  node->add_input(AsControlDependency(string(fanin_node_name)));\n+  node->add_input(AsControlDependency(std::string(fanin_node_name)));\n   MutableNodeView* fanin_node_view = GetNode(fanin_node_name);\n   const int index = node_view->controlling_fanins_.size();\n   fanin_node_view->controlled_fanouts_.emplace_back(\n@@ -1283,7 +1284,7 @@ void MutableGraphView::SetNewNodesFanins(\n       AddRegularFaninInternal(&new_node_view, fanin);\n       new_node_def->add_input(SafeTensorIdToString(fanin));\n     }\n-    for (const string& control_to_add : new_node->controlling_fanins) {\n+    for (const std::string& control_to_add : new_node->controlling_fanins) {\n       AddControllingFaninInternal(&new_node_view, control_to_add);\n     }\n     ++new_node;\n@@ -1555,14 +1556,14 @@ absl::Status MutableGraphView::SortTopologically(\n   }\n \n   if (!ignore_cycles && !edges_in_cycle.empty()) {\n-    std::vector<string> edges_formatted;\n+    std::vector<std::string> edges_formatted;\n     edges_formatted.reserve(edges_in_cycle.size());\n     for (const auto& edge : edges_in_cycle) {\n       edges_formatted.push_back(\n           absl::StrCat(\"'\", graph_->node(edge.from).name(), \"' -> '\",\n                        graph_->node(edge.to).name(), \"'\"));\n     }\n-    const string edges_str =\n+    const std::string edges_str =\n         absl::StrCat(\"{\", absl::StrJoin(edges_formatted, \", \"), \"}\");\n     return errors::InvalidArgument(kMutableGraphViewSortTopologicallyError,\n                                    \"detected edge(s) creating cycle(s) \",\n@@ -1593,7 +1594,7 @@ absl::Status MutableGraphView::SortTopologically(\n   for (MutableNodeView& node_view : nodes_) {\n     const int prev_node_index = node_view.node_index_;\n     if (prev_node_index != order[prev_node_index]) {\n-      const string& node_name = graph_->node(prev_node_index).name();\n+      const std::string& node_name = graph_->node(prev_node_index).name();\n       node_view.node_index_ = order[prev_node_index];\n       node_index_by_name_.find(node_name)->second = node_view.node_index_;\n     }\n@@ -1668,7 +1669,7 @@ absl::Status MutableGraphView::ApplyMutationInternal() {\n   }\n \n   // Node name and associated fanouts.\n-  absl::flat_hash_map<string, NodeViewFanouts> renamed_fanouts;\n+  absl::flat_hash_map<std::string, NodeViewFanouts> renamed_fanouts;\n   // Removed nodes where name was overwritten by a renamed node.\n   std::vector<bool> overwritten_name_removed_nodes(nodes_.size());\n   // Fix renaming of existing nodes by swapping fanouts and rehashing names."
        },
        {
            "sha": "cdb0e7efc2801c422836f058ca57201e85743d6e",
            "filename": "tensorflow/core/grappler/utils/graph_view.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view.h?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -481,15 +481,15 @@ class MutableGraphView\n \n   void FixRenamedNodes(\n       std::vector<RenamedOrOverwrittenNode>* renamed_nodes,\n-      absl::flat_hash_map<string, NodeViewFanouts>* renamed_fanouts,\n+      absl::flat_hash_map<std::string, NodeViewFanouts>* renamed_fanouts,\n       std::vector<bool>* overwritten_name_removed_nodes);\n \n   void AddNewNodes(\n-      absl::flat_hash_map<string, NodeViewFanouts>* renamed_fanouts,\n+      absl::flat_hash_map<std::string, NodeViewFanouts>* renamed_fanouts,\n       std::vector<int>* new_node_indices);\n \n   void FixRenamedFanouts(\n-      const absl::flat_hash_map<string, NodeViewFanouts>& renamed_fanouts);\n+      const absl::flat_hash_map<std::string, NodeViewFanouts>& renamed_fanouts);\n \n   inline void RemoveRegularFaninFanoutInternal(MutableNodeView* node_view,\n                                                int i);"
        },
        {
            "sha": "7972adcde6671c4baed8637c2db5e3abc2428534",
            "filename": "tensorflow/core/grappler/utils/graph_view_internal_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view_internal_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view_internal_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view_internal_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -635,8 +635,8 @@ TEST(MutableNodeViewDiffTest, IsWellFormedRenamedSelfLoopRegularUpdate) {\n   EXPECT_TRUE(IsEmpty(&diff));\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n-  string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string old_node_name = \"d\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -665,8 +665,8 @@ TEST(MutableNodeViewDiffTest, IsWellFormedRenamedSelfLoopRegularNew) {\n   EXPECT_TRUE(IsEmpty(&diff));\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n-  string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string old_node_name = \"d\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -695,8 +695,8 @@ TEST(MutableNodeViewDiffTest, IsWellFormedRenamedSelfLoopControl) {\n   EXPECT_TRUE(IsEmpty(&diff));\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n-  string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string old_node_name = \"d\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -725,8 +725,8 @@ TEST(MutableNodeViewDiffTest, IsWellFormedRenamedMissingFaninRegularUpdate) {\n   EXPECT_TRUE(IsEmpty(&diff));\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n-  string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string old_node_name = \"d\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -755,8 +755,8 @@ TEST(MutableNodeViewDiffTest, IsWellFormedRenamedMissingFaninRegularNew) {\n   EXPECT_TRUE(IsEmpty(&diff));\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n-  string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string old_node_name = \"d\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -786,7 +786,7 @@ TEST(MutableNodeViewDiffTest, IsWellFormedRenamedMissingFaninControl) {\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n   std::string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -815,8 +815,8 @@ TEST(MutableNodeViewDiffTest, RenamedAndRemovedFanins) {\n   EXPECT_TRUE(IsEmpty(&diff));\n   EXPECT_TRUE(IsWellFormed(&diff, updated_node_names));\n \n-  string old_node_name = \"d\";\n-  string new_node_name = \"e\";\n+  std::string old_node_name = \"d\";\n+  std::string new_node_name = \"e\";\n   updated_node_names.erase(old_node_name);\n   updated_node_names.emplace(old_node_name, 3);\n   updated_node_names.emplace(new_node_name, -1);\n@@ -1048,7 +1048,7 @@ TEST(MutationNewNodeTest, AddOrUpdateAttribute) {\n   MutationNewNodeForTest new_node(&graph_view, {});\n \n   EXPECT_TRUE(IsWellFormed(&new_node, updated_node_names));\n-  string attr_name = \"attr_name\";\n+  std::string attr_name = \"attr_name\";\n   AttrValue attr_1;\n   attr_1.set_i(8);\n   AddOrUpdateAttribute(&new_node, attr_name, attr_1);\n@@ -1070,7 +1070,7 @@ TEST(MutationNewNodeTest, RemoveAttribute) {\n   MutationNewNodeForTest new_node(&graph_view, {});\n \n   EXPECT_TRUE(IsWellFormed(&new_node, updated_node_names));\n-  string attr_name = \"attr_name\";\n+  std::string attr_name = \"attr_name\";\n   AttrValue attr_1;\n   attr_1.set_i(8);\n   AddOrUpdateAttribute(&new_node, attr_name, attr_1);"
        },
        {
            "sha": "588e561a335536efb5eb864b6bf36edeaf99108f",
            "filename": "tensorflow/core/grappler/utils/graph_view_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgraph_view_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -48,7 +48,7 @@ GraphDef SimpleTestGraph() {\n }\n \n template <typename T>\n-const string GetGraphViewTypeAsString() {\n+const std::string GetGraphViewTypeAsString() {\n   return std::is_same<T, class GraphView>::value ? \"GraphView\"\n                                                  : \"MutableGraphView\";\n }\n@@ -136,9 +136,9 @@ TYPED_TEST(TypedGraphViewTest, GetNodeWithName) {\n   TypeParam graph_view(&graph, &s);\n   TF_ASSERT_OK(s);\n \n-  std::vector<string> node_names = {\"a\", \"b\", \"c\", \"d\"};\n+  std::vector<std::string> node_names = {\"a\", \"b\", \"c\", \"d\"};\n   for (int i = 0; i < node_names.size(); ++i) {\n-    const string& node_name = node_names[i];\n+    const std::string& node_name = node_names[i];\n     const auto* node = graph_view.GetNode(node_name);\n     ASSERT_NE(node, nullptr);\n     EXPECT_EQ(node->node(), graph.mutable_node(i));\n@@ -173,7 +173,7 @@ TYPED_TEST(TypedGraphViewTest, HasNode) {\n   TypeParam graph_view(&graph, &s);\n   TF_ASSERT_OK(s);\n \n-  for (const string& node_name : {\"a\", \"b\", \"c\", \"d\"}) {\n+  for (const std::string& node_name : {\"a\", \"b\", \"c\", \"d\"}) {\n     EXPECT_TRUE(graph_view.HasNode(node_name));\n   }\n \n@@ -801,7 +801,7 @@ class CompareGraphTest : public GrapplerTest {\n     EXPECT_EQ(graph_view->NumNodes(), expected_graph_view.NumNodes());\n \n     for (const NodeView& expected_node_view : expected_graph_view.GetNodes()) {\n-      const string& node_name = expected_node_view.GetName();\n+      const std::string& node_name = expected_node_view.GetName();\n       MutableNodeView* node_view = graph_view->GetNode(node_name);\n       ASSERT_NE(node_view, nullptr);\n \n@@ -1020,7 +1020,7 @@ TEST_F(MutationTest, NewNodeBadFaninsAfterAdd) {\n   mutation->AddOrUpdateRegularFanin(new_node, 1, {\"valid\", 2});\n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: new node 'valid' is ill-formed.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1045,7 +1045,7 @@ TEST_F(MutationTest, NewNodesConflictingNames) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: multiple nodes with the name: 'a' exists in \"\n       \"Mutation.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n@@ -1067,7 +1067,7 @@ TEST_F(MutationTest, UpdateNodeAndAddSelfLoop) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: inplace updated node 'd' is ill-formed.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1089,7 +1089,7 @@ TEST_F(MutationTest, RenameNodeAndAddSelfLoop) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: renamed updated node 'e' ('d') is ill-formed.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1114,7 +1114,7 @@ TEST_F(MutationTest, ExistingNodesConflictingNames) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: multiple nodes with the name: 'b' exists in \"\n       \"Mutation.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n@@ -1140,7 +1140,7 @@ TEST_F(MutationTest, NewAndExistingNodesConflictingNames) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: multiple nodes with the name: 'a' exists in \"\n       \"Mutation.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n@@ -1166,7 +1166,7 @@ TEST_F(MutationTest, NewAndExistingRenamedNodesConflictingNames) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: multiple nodes with the name: 'e' exists in \"\n       \"Mutation.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n@@ -1188,7 +1188,7 @@ TEST_F(MutationTest, RemoveNodesWithFanouts) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: fanout 'd' exist for missing node 'b'.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1222,7 +1222,7 @@ TEST_F(MutationTest, SwapNodeNamesWithCycle) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: renamed updated node 'b' ('d') is ill-formed.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1256,7 +1256,7 @@ TEST_F(MutationTest, RenamedNodeWithFanouts) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: fanout 'd' exist for missing node 'a'.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1344,7 +1344,7 @@ TEST_F(MutationTest, UpdateNodeNameAndRemoveRegularFanout) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: fanout 'd' exist for missing node 'a'.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1388,7 +1388,7 @@ TEST_F(MutationTest, UpdateNodeNameAndRemoveControlledFanout) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: fanout 'd' exist for missing node 'c'.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, SimpleTestGraphForMutation());\n@@ -1705,7 +1705,7 @@ TEST_F(MutationTest, Reset) {\n \n   s = mutation->Apply();\n   EXPECT_FALSE(s.ok());\n-  string expected_error_msg =\n+  std::string expected_error_msg =\n       \"Mutation::Apply error: fanout 'b' exist for missing node 'a'.\";\n   EXPECT_EQ(s.message(), expected_error_msg);\n   CompareGraphViewWithGraph(&graph_view, TestGraphForMutation());\n@@ -2002,7 +2002,7 @@ TEST_F(MutationTest, EmptyMutationUpdateIndexPersisting) {\n class TopologicalSortTest : public CompareGraphTest {\n  protected:\n   void CompareGraphOrder(const MutableGraphView& graph_view,\n-                         absl::Span<const string> node_names) {\n+                         absl::Span<const std::string> node_names) {\n     const int num_nodes = graph_view.NumNodes();\n     ASSERT_EQ(num_nodes, node_names.size());\n     for (int i = 0; i < num_nodes; ++i) {\n@@ -2012,7 +2012,7 @@ class TopologicalSortTest : public CompareGraphTest {\n \n   void CompareGraphNodePrecedences(\n       const MutableGraphView& graph_view,\n-      absl::Span<const std::pair<string, std::string>> node_precedences) {\n+      absl::Span<const std::pair<std::string, std::string>> node_precedences) {\n     for (const auto& node_precedence : node_precedences) {\n       auto* parent_node = graph_view.GetNode(node_precedence.first);\n       ASSERT_NE(parent_node, nullptr);"
        },
        {
            "sha": "c74e83dc7f2708c4f1dd10c597f244e30a99885d",
            "filename": "tensorflow/core/grappler/utils/grappler_test.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 17,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgrappler_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgrappler_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgrappler_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -109,13 +109,13 @@ void GrapplerTest::EnableAllOptimizers() {\n }\n \n std::vector<Tensor> GrapplerTest::EvaluateNodes(\n-    const GraphDef& graph, const std::vector<string>& node_names) const {\n+    const GraphDef& graph, const std::vector<std::string>& node_names) const {\n   return EvaluateNodes(graph, node_names, {});\n }\n \n std::vector<Tensor> GrapplerTest::EvaluateNodes(\n-    const GraphDef& graph, const std::vector<string>& node_names,\n-    const std::vector<std::pair<string, Tensor>>& inputs) const {\n+    const GraphDef& graph, const std::vector<std::string>& node_names,\n+    const std::vector<std::pair<std::string, Tensor>>& inputs) const {\n   std::unique_ptr<tensorflow::Session> session(NewSession(options_));\n   TF_CHECK_OK(session->Create(graph));\n   RunOptions run_options;\n@@ -144,13 +144,14 @@ std::vector<Tensor> GrapplerTest::EvaluateFetchNodes(\n }\n \n NodeDef* GrapplerTest::AddNode(\n-    const string& name, const string& op, const std::vector<string>& inputs,\n-    const std::vector<std::pair<string, AttrValue>>& attributes,\n+    const std::string& name, const std::string& op,\n+    const std::vector<std::string>& inputs,\n+    const std::vector<std::pair<std::string, AttrValue>>& attributes,\n     GraphDef* graph) const {\n   NodeDef* node = graph->add_node();\n   node->set_name(name);\n   node->set_op(op);\n-  for (const string& input : inputs) {\n+  for (const std::string& input : inputs) {\n     node->add_input(input);\n   }\n   for (auto attr : attributes) {\n@@ -171,38 +172,41 @@ void GrapplerTest::CompareNodes(const NodeDef& want, const NodeDef& got) const {\n   EXPECT_EQ(want.name(), got.name());\n   EXPECT_EQ(want.op(), got.op());\n \n-  std::vector<string> want_inputs(want.input().begin(), want.input().end());\n-  std::vector<string> got_inputs(got.input().begin(), got.input().end());\n+  std::vector<std::string> want_inputs(want.input().begin(),\n+                                       want.input().end());\n+  std::vector<std::string> got_inputs(got.input().begin(), got.input().end());\n   EXPECT_EQ(want_inputs, got_inputs);\n \n-  const auto attr_name = [](const std::pair<const string, AttrValue>& attr) {\n-    return attr.first;\n-  };\n+  const auto attr_name =\n+      [](const std::pair<const std::string, AttrValue>& attr) {\n+        return attr.first;\n+      };\n \n-  std::vector<string> want_attrs;\n-  std::vector<string> got_attrs;\n+  std::vector<std::string> want_attrs;\n+  std::vector<std::string> got_attrs;\n   absl::c_transform(want.attr(), std::back_inserter(want_attrs), attr_name);\n   absl::c_transform(got.attr(), std::back_inserter(got_attrs), attr_name);\n   absl::c_sort(want_attrs);\n   absl::c_sort(got_attrs);\n   EXPECT_EQ(want_attrs, got_attrs);\n \n-  for (const string& attr : want_attrs) {\n+  for (const std::string& attr : want_attrs) {\n     EXPECT_TRUE(AreAttrValuesEqual(want.attr().at(attr), got.attr().at(attr)));\n   }\n }\n \n bool GrapplerTest::IsNodesDirectlyConnected(const NodeMap& node_map,\n-                                            const string& src,\n-                                            const string& dst, int position) {\n+                                            const std::string& src,\n+                                            const std::string& dst,\n+                                            int position) {\n   const NodeDef* src_node = node_map.GetNode(src);\n   const NodeDef* dst_node = node_map.GetNode(dst);\n   EXPECT_TRUE(src_node != nullptr) << src << \" node not found\";\n   EXPECT_TRUE(dst_node != nullptr) << dst << \" node not found\";\n   return src_node && dst_node && dst_node->input(position) == src_node->name();\n }\n \n-int GrapplerTest::CountOpNodes(const GraphDef& graph, const string& op) {\n+int GrapplerTest::CountOpNodes(const GraphDef& graph, const std::string& op) {\n   return std::count_if(graph.node().begin(), graph.node().end(),\n                        [&op](const NodeDef& node) { return node.op() == op; });\n }"
        },
        {
            "sha": "906fee3f9da26d64bdcb52a75a13642cd4c1577a",
            "filename": "tensorflow/core/grappler/utils/grappler_test.h",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgrappler_test.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgrappler_test.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fgrappler_test.h?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -41,18 +41,19 @@ class GrapplerTest : public ::testing::Test {\n   void EnableAllOptimizers();\n \n   std::vector<Tensor> EvaluateNodes(\n-      const GraphDef& graph, const std::vector<string>& node_names) const;\n+      const GraphDef& graph, const std::vector<std::string>& node_names) const;\n \n   std::vector<Tensor> EvaluateNodes(\n-      const GraphDef& graph, const std::vector<string>& node_names,\n-      const std::vector<std::pair<string, Tensor>>& inputs) const;\n+      const GraphDef& graph, const std::vector<std::string>& node_names,\n+      const std::vector<std::pair<std::string, Tensor>>& inputs) const;\n \n   std::vector<Tensor> EvaluateFetchNodes(const GrapplerItem& item) const;\n \n-  NodeDef* AddNode(const string& name, const string& op,\n-                   const std::vector<string>& inputs,\n-                   const std::vector<std::pair<string, AttrValue>>& attributes,\n-                   GraphDef* graph) const;\n+  NodeDef* AddNode(\n+      const std::string& name, const std::string& op,\n+      const std::vector<std::string>& inputs,\n+      const std::vector<std::pair<std::string, AttrValue>>& attributes,\n+      GraphDef* graph) const;\n \n   void DisableAllOptimizers(RewriterConfig* cfg);\n \n@@ -78,11 +79,11 @@ class GrapplerTest : public ::testing::Test {\n \n   // Checks if node 'src' is directly connected to the input($position) of\n   // 'dst'.\n-  bool IsNodesDirectlyConnected(const NodeMap& node_map, const string& src,\n-                                const string& dst, int position = 0);\n+  bool IsNodesDirectlyConnected(const NodeMap& node_map, const std::string& src,\n+                                const std::string& dst, int position = 0);\n \n   // Counts nodes of the given op-type in a graph.\n-  int CountOpNodes(const GraphDef& graph, const string& op);\n+  int CountOpNodes(const GraphDef& graph, const std::string& op);\n \n   // Get a random tensor with given shape.\n   template <DataType DTYPE>\n@@ -115,7 +116,7 @@ class GrapplerTest : public ::testing::Test {\n   }\n \n   inline tensorflow::Scope CreateScopeWithDevice(absl::string_view device) {\n-    return tensorflow::Scope::NewRootScope().WithDevice(string(device));\n+    return tensorflow::Scope::NewRootScope().WithDevice(std::string(device));\n   }\n \n  private:"
        },
        {
            "sha": "f494a69e57d5675d42f7e01f632b156af7589249",
            "filename": "tensorflow/core/grappler/utils/pattern_utils.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -24,12 +24,12 @@ namespace tensorflow {\n namespace grappler {\n namespace utils {\n \n-const bool IsCommutativeOp(const string& op) {\n+const bool IsCommutativeOp(const std::string& op) {\n   // TODO(intel-tf): Add more ops to this list if needed.\n-  std::vector<string> op_list = str_util::Split(op, '|');\n-  static const auto* commutative_ops = new absl::flat_hash_set<string>(\n+  std::vector<std::string> op_list = str_util::Split(op, '|');\n+  static const auto* commutative_ops = new absl::flat_hash_set<std::string>(\n       {\"Add\", \"AddV2\", \"Mul\", \"Maximum\", \"SquaredDifference\"});\n-  for (const string& op_ : op_list) {\n+  for (const std::string& op_ : op_list) {\n     if (commutative_ops->contains(op_)) return true;\n   }\n   return false;\n@@ -39,11 +39,11 @@ const bool IsCommutativeOp(const string& op) {\n // registered op in tensorflow and may have multiple ops separated by '|'.\n // op2 is an op name in the computation graph and\n // is always one of the registered ops in tensorflow.\n-bool IsSame(string op1, string op2) {\n+bool IsSame(std::string op1, std::string op2) {\n   if (op1 == \"*\") return true;\n \n-  std::vector<string> op1_list = str_util::Split(op1, '|');\n-  for (const string& op_1 : op1_list) {\n+  std::vector<std::string> op1_list = str_util::Split(op1, '|');\n+  for (const std::string& op_1 : op1_list) {\n     if (op_1 == op2) return true;\n   }\n \n@@ -75,8 +75,8 @@ bool SubGraphMatcher<MatchingDirection::kFollowInputs>::DoesOpTypePatternMatch(\n   } else {\n     // The op field string of current pattern might express an op among multiple\n     // op types (mutually exclusive) separated by '|'.\n-    std::vector<string> op_list = str_util::Split(pattern.op, '|');\n-    for (const string& op : op_list) {\n+    std::vector<std::string> op_list = str_util::Split(pattern.op, '|');\n+    for (const std::string& op : op_list) {\n       if (node_view->node()->op() == op) {\n         op_type_matched = true;\n         break;\n@@ -138,7 +138,7 @@ bool SubGraphMatcher<MatchingDirection::kFollowInputs>::DoesOpTypePatternMatch(\n       // match unless we look two level down the graphs.\n       std::vector<int> pattern_child_indices(num_children);\n       std::iota(pattern_child_indices.begin(), pattern_child_indices.end(), 0);\n-      string op_name = pattern.op;\n+      std::string op_name = pattern.op;\n       if (IsCommutativeOp(op_name) && num_children == 2) {\n         MutableNodeView* graph_child0_node_view =\n             graph_view_->GetNode(graph_children[0].node_index());\n@@ -174,8 +174,8 @@ bool SubGraphMatcher<MatchingDirection::kFollowInputs>::DoesOpTypePatternMatch(\n template <>\n bool SubGraphMatcher<MatchingDirection::kFollowInputs>::GetMatchedNodes(\n     const OpTypePattern& pattern,\n-    const std::unordered_set<string>& nodes_to_preserve,\n-    MutableNodeView* node_view, std::map<string, int>* matched_nodes_map,\n+    const std::unordered_set<std::string>& nodes_to_preserve,\n+    MutableNodeView* node_view, std::map<std::string, int>* matched_nodes_map,\n     std::set<int>* remove_node_indices) {\n   bool found_match = false;\n   match_ = std::make_unique<NodeViewMatch>();"
        },
        {
            "sha": "b358a79de06c85eed1689f57e950e6279ade3b2f",
            "filename": "tensorflow/core/grappler/utils/pattern_utils.h",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils.h?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -126,13 +126,13 @@ enum class NodeStatus { kRemain, kRemove, kReplace };\n // TODO (intel-tf): Support multiple roots by making them children of a single\n // virtual root.\n struct OpTypePattern {\n-  string op;\n-  string label;\n+  std::string op;\n+  std::string label;\n   NodeStatus node_status;\n   std::vector<OpTypePattern> children;\n \n-  string DebugString() const {\n-    string result = \"{(op: \" + op + \", \" + \"label: \" + label + \"), {\";\n+  std::string DebugString() const {\n+    std::string result = \"{(op: \" + op + \", \" + \"label: \" + label + \"), {\";\n     for (const OpTypePattern& child : children) {\n       result += child.DebugString() + \",\";\n     }\n@@ -148,8 +148,8 @@ struct NodeViewMatch {\n   MutableNodeView* node_view = nullptr;\n   std::vector<NodeViewMatch> children;\n \n-  string DebugString() const {\n-    string result = \"{\";\n+  std::string DebugString() const {\n+    std::string result = \"{\";\n     if (node_view == nullptr) {\n       result += \"Non-Matched-Node}\";\n       return result;\n@@ -183,14 +183,14 @@ class SubGraphMatcher {\n   // If a given pattern is matched, this function returns true as well as the\n   // matched node and remove node info is populated.\n   bool GetMatchedNodes(const OpTypePattern& pattern,\n-                       const std::unordered_set<string>& nodes_to_preserve,\n+                       const std::unordered_set<std::string>& nodes_to_preserve,\n                        MutableNodeView* node_view,\n-                       std::map<string, int>* matched_nodes_map,\n+                       std::map<std::string, int>* matched_nodes_map,\n                        std::set<int>* remove_node_indices);\n \n  private:\n   MutableGraphView* graph_view_;\n-  std::map<string, int> node_label_to_index_;\n+  std::map<std::string, int> node_label_to_index_;\n   std::set<int> matched_node_indices_;\n   std::set<int> remove_node_indices_;\n   std::unique_ptr<NodeViewMatch> match_ = nullptr;\n@@ -203,11 +203,11 @@ class SubGraphMatcher {\n   // It performs a sanity check if the candidate nodes for removal in subgraph\n   // fusion is indeed safe to remove.\n   bool IsSafeNodesToRemove(\n-      const std::unordered_set<string>& nodes_to_preserve) {\n+      const std::unordered_set<std::string>& nodes_to_preserve) {\n     for (const auto& node_idx : remove_node_indices_) {\n       auto node_view = graph_view_->GetNode(node_idx);\n       // Check if the node to be removed is in the nodes to be preserved.\n-      string node_name = node_view->GetName();\n+      std::string node_name = node_view->GetName();\n       if (nodes_to_preserve.count(node_name) > 0) return false;\n       // Traverse all the Regular Fanouts. Fanouts are stored as vector of\n       // vector, std::vector<std::vector<MutableFaninView>>. Note that\n@@ -234,8 +234,8 @@ bool SubGraphMatcher<MatchingDirection::kFollowInputs>::DoesOpTypePatternMatch(\n template <>\n bool SubGraphMatcher<MatchingDirection::kFollowInputs>::GetMatchedNodes(\n     const OpTypePattern& pattern,\n-    const std::unordered_set<string>& nodes_to_preserve,\n-    MutableNodeView* node_view, std::map<string, int>* matched_nodes_map,\n+    const std::unordered_set<std::string>& nodes_to_preserve,\n+    MutableNodeView* node_view, std::map<std::string, int>* matched_nodes_map,\n     std::set<int>* remove_node_indices);\n \n }  // namespace utils"
        },
        {
            "sha": "e9c836665e10aa6a2add2a3607ee89a9870f4578",
            "filename": "tensorflow/core/grappler/utils/pattern_utils_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 18,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fpattern_utils_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -104,12 +104,13 @@ OpTypePattern GetMatMulBiasAddGeluPattern() {\n class PatternMatcherTest : public ::testing::Test {\n  protected:\n   struct NodeConfig {\n-    NodeConfig(string name, string op, std::vector<string> inputs)\n+    NodeConfig(std::string name, std::string op,\n+               std::vector<std::string> inputs)\n         : name(std::move(name)), op(std::move(op)), inputs(std::move(inputs)) {}\n \n-    string name;\n-    string op;\n-    std::vector<string> inputs;\n+    std::string name;\n+    std::string op;\n+    std::vector<std::string> inputs;\n   };\n \n   static GraphDef CreateGraph(const std::vector<NodeConfig>& nodes) {\n@@ -119,7 +120,7 @@ class PatternMatcherTest : public ::testing::Test {\n       NodeDef node_def;\n       node_def.set_name(node.name);\n       node_def.set_op(node.op);\n-      for (const string& input : node.inputs) {\n+      for (const std::string& input : node.inputs) {\n         node_def.add_input(input);\n       }\n       *graph.add_node() = std::move(node_def);\n@@ -172,7 +173,7 @@ TEST_F(PatternMatcherTest, Tree) {\n   auto root_node_view = graph_view.GetNode(\"e\");\n \n   SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(&graph_view);\n-  std::map<string, int> matched_nodes_map;  // label to node index map\n+  std::map<std::string, int> matched_nodes_map;  // label to node index map\n   std::set<int> remove_node_indices;\n   bool found_match = graph_matcher.GetMatchedNodes(\n       pattern, {}, root_node_view, &matched_nodes_map, &remove_node_indices);\n@@ -254,8 +255,8 @@ TEST_F(PatternMatcherTest, DAG) {\n   auto root_node_view = graph_view.GetNode(\"e\");\n \n   SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(&graph_view);\n-  std::unordered_set<string> nodes_to_preserve = {\"foo\"};\n-  std::map<string, int> matched_nodes_map;  // label to node index map\n+  std::unordered_set<std::string> nodes_to_preserve = {\"foo\"};\n+  std::map<std::string, int> matched_nodes_map;  // label to node index map\n   std::set<int> remove_node_indices;\n   bool found_match =\n       graph_matcher.GetMatchedNodes(pattern, nodes_to_preserve, root_node_view,\n@@ -354,7 +355,7 @@ TEST_F(PatternMatcherTest, DAGExternalDependent) {\n   auto root_node_view = graph_view.GetNode(\"e\");\n \n   SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(&graph_view);\n-  std::map<string, int> matched_nodes_map;  // label to node index map\n+  std::map<std::string, int> matched_nodes_map;  // label to node index map\n   std::set<int> remove_node_indices;\n   bool found_match = graph_matcher.GetMatchedNodes(\n       pattern, {}, root_node_view, &matched_nodes_map, &remove_node_indices);\n@@ -375,7 +376,7 @@ TEST_F(PatternMatcherTest, MatMulBiasAddGelu) {\n   auto root_node_view = graph_view.GetNode(\"gelu\");\n \n   SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(&graph_view);\n-  std::map<string, int> matched_nodes_map;  // label to node index map\n+  std::map<std::string, int> matched_nodes_map;  // label to node index map\n   std::set<int> remove_node_indices;\n   bool found_match = graph_matcher.GetMatchedNodes(\n       pattern, {}, root_node_view, &matched_nodes_map, &remove_node_indices);\n@@ -411,7 +412,7 @@ TEST_F(PatternMatcherTest, MatMulBiasAddGeluExternalDependent) {\n   auto root_node_view = graph_view.GetNode(\"gelu\");\n \n   SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(&graph_view);\n-  std::map<string, int> matched_nodes_map;  // label to node index map\n+  std::map<std::string, int> matched_nodes_map;  // label to node index map\n   std::set<int> remove_node_indices;\n   bool found_match = graph_matcher.GetMatchedNodes(\n       pattern, {}, root_node_view, &matched_nodes_map, &remove_node_indices);\n@@ -432,7 +433,7 @@ TEST_F(PatternMatcherTest, MatMulBiasAddGeluMutation) {\n   auto root_node_view = graph_view.GetNode(\"gelu\");\n \n   SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(&graph_view);\n-  std::map<string, int> matched_nodes_map;  // label to node index map\n+  std::map<std::string, int> matched_nodes_map;  // label to node index map\n   std::set<int> remove_node_indices;\n   bool found_match = graph_matcher.GetMatchedNodes(\n       pattern, {}, root_node_view, &matched_nodes_map, &remove_node_indices);\n@@ -443,7 +444,7 @@ TEST_F(PatternMatcherTest, MatMulBiasAddGeluMutation) {\n   // Before mutation number of nodes.\n   int num_nodes_before = graph_view.NumNodes();\n   // Before mutation node_names of the remove candidate nodes.\n-  std::vector<string> remove_node_names;\n+  std::vector<std::string> remove_node_names;\n   for (auto const& node_idx : remove_node_indices) {\n     remove_node_names.push_back(graph_view.GetNode(node_idx)->GetName());\n   }\n@@ -514,12 +515,12 @@ TEST_F(PatternMatcherTest, CommutativeInputs) {\n   //   }\n \n   absl::Status status;\n-  std::vector<string> commutative_ops = {\"Mul\", \"Add\", \"AddV2\"};\n+  std::vector<std::string> commutative_ops = {\"Mul\", \"Add\", \"AddV2\"};\n   for (std::string op : commutative_ops) {\n     for (bool should_swap : {false, true}) {\n-      std::vector<string> commutative_operands =\n-          (should_swap ? std::vector<string>{\"d\", \"c\"}\n-                       : std::vector<string>{\"c\", \"d\"});\n+      std::vector<std::string> commutative_operands =\n+          (should_swap ? std::vector<std::string>{\"d\", \"c\"}\n+                       : std::vector<std::string>{\"c\", \"d\"});\n       GraphDef graph = CreateGraph({{\"e\", op, commutative_operands},\n                                     {\"c\", \"C\", {\"b\"}},\n                                     {\"d\", \"D\", {\"b\"}},\n@@ -548,7 +549,7 @@ TEST_F(PatternMatcherTest, CommutativeInputs) {\n \n       SubGraphMatcher<MatchingDirection::kFollowInputs> graph_matcher(\n           &graph_view);\n-      std::map<string, int> matched_nodes_map;  // label to node index map\n+      std::map<std::string, int> matched_nodes_map;  // label to node index map\n       std::set<int> remove_node_indices;\n       bool found_match = graph_matcher.GetMatchedNodes(\n           pattern, {}, root_node_view, &matched_nodes_map,"
        },
        {
            "sha": "c3b24aa9004731db76f0ebaaa8eea2e1eb6a1a12",
            "filename": "tensorflow/core/grappler/utils/scc.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fscc.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fscc.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fscc.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -127,7 +127,7 @@ void StronglyConnectedComponents(\n     const GraphDef& graph, std::unordered_map<const NodeDef*, int>* components,\n     int* num_components) {\n   std::stack<SCCNodeData*> stack;\n-  std::unordered_map<string, SCCNodeData*> name_to_data;\n+  std::unordered_map<std::string, SCCNodeData*> name_to_data;\n   std::vector<SCCNodeData> node_data_container;\n   node_data_container.reserve(graph.node_size());\n   std::unordered_map<const NodeDef*, SCCNodeData*> node_to_data;\n@@ -144,7 +144,7 @@ void StronglyConnectedComponents(\n   // Also create a mapping from nodes to their children.\n   // Inputs might not be present if called on a subgraph.\n   for (const NodeDef& node : graph.node()) {\n-    for (const string& input : node.input()) {\n+    for (const std::string& input : node.input()) {\n       auto it = name_to_data.find(NodeName(input));\n       if (it != name_to_data.end()) {\n         it->second->children.push_back(node_to_data[&node]);\n@@ -204,7 +204,7 @@ int IdentifyLoops(const GraphDef& graph,\n   int loop_id = 0;\n   for (const auto& component : component_ids) {\n     const std::vector<const NodeDef*>& component_nodes = component.second;\n-    std::vector<std::pair<NodeDef*, string>> next_iter_nodes;\n+    std::vector<std::pair<NodeDef*, std::string>> next_iter_nodes;\n     GraphDef subgraph;\n     std::unordered_map<const NodeDef*, const NodeDef*> subgraph_mapping;\n "
        },
        {
            "sha": "eec12fc8bfff6f69e5314b8ff34c9e62fc060dda",
            "filename": "tensorflow/core/grappler/utils/symbolic_shapes.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fsymbolic_shapes.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Fsymbolic_shapes.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Fsymbolic_shapes.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -151,8 +151,8 @@ bool CompareSymbolicallyShapedTensorSizes(const TensorShapeProto& left,\n   // For each shape dimension update \"defined tensor size\", if shape is defined,\n   // or increment a counter for unknown dim.\n   auto process_dimensions =\n-      [&unknown_dim_id](const TensorShapeProto& shape, int64* defined_size,\n-                        std::unordered_map<int64, int64>* unknown_dims) {\n+      [&unknown_dim_id](const TensorShapeProto& shape, int64_t* defined_size,\n+                        std::unordered_map<int64_t, int64_t>* unknown_dims) {\n         for (int i = 0; i < shape.dim_size(); ++i) {\n           const auto& dim = shape.dim(i);\n           int64_t dim_size = dim.size();"
        },
        {
            "sha": "e4d897ece52ea4b816019807e4c7b02cd66676d6",
            "filename": "tensorflow/core/grappler/utils/topological_sort_test.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 13,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftopological_sort_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftopological_sort_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftopological_sort_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -29,14 +29,15 @@ namespace grappler {\n class TopologicalSortTest : public ::testing::Test {\n  protected:\n   struct NodeConfig {\n-    NodeConfig(string name, std::vector<string> inputs)\n+    NodeConfig(std::string name, std::vector<std::string> inputs)\n         : name(std::move(name)), inputs(std::move(inputs)) {}\n-    NodeConfig(string name, string op, std::vector<string> inputs)\n+    NodeConfig(std::string name, std::string op,\n+               std::vector<std::string> inputs)\n         : name(std::move(name)), op(std::move(op)), inputs(std::move(inputs)) {}\n \n-    string name;\n-    string op;\n-    std::vector<string> inputs;\n+    std::string name;\n+    std::string op;\n+    std::vector<std::string> inputs;\n   };\n \n   static GraphDef CreateGraph(const std::vector<NodeConfig>& nodes) {\n@@ -46,7 +47,7 @@ class TopologicalSortTest : public ::testing::Test {\n       NodeDef node_def;\n       node_def.set_name(node.name);\n       node_def.set_op(node.op);\n-      for (const string& input : node.inputs) {\n+      for (const std::string& input : node.inputs) {\n         node_def.add_input(input);\n       }\n       *graph.add_node() = std::move(node_def);\n@@ -69,7 +70,7 @@ TEST_F(TopologicalSortTest, NoLoop) {\n   std::vector<const NodeDef*> topo_order;\n   TF_EXPECT_OK(ComputeTopologicalOrder(graph, &topo_order));\n \n-  const std::vector<string> order = {\"5\", \"4\", \"2\", \"0\", \"3\", \"1\"};\n+  const std::vector<std::string> order = {\"5\", \"4\", \"2\", \"0\", \"3\", \"1\"};\n \n   ASSERT_EQ(topo_order.size(), order.size());\n   for (int i = 0; i < topo_order.size(); ++i) {\n@@ -96,7 +97,7 @@ TEST_F(TopologicalSortTest, WithLoop) {\n   std::vector<const NodeDef*> topo_order;\n   TF_EXPECT_OK(ComputeTopologicalOrder(graph, &topo_order));\n \n-  const std::vector<string> order = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n+  const std::vector<std::string> order = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n \n   ASSERT_EQ(topo_order.size(), order.size());\n   for (int i = 0; i < topo_order.size(); ++i) {\n@@ -120,7 +121,7 @@ TEST_F(TopologicalSortTest, WithIllegalLoop) {\n   });\n \n   EXPECT_FALSE(TopologicalSort(&graph).ok());\n-  std::vector<string> order = {\"2\", \"3\", \"1\"};\n+  std::vector<std::string> order = {\"2\", \"3\", \"1\"};\n   for (int i = 0; i < order.size(); i++) {\n     EXPECT_EQ(graph.node(i).name(), order[i]);\n   }\n@@ -149,7 +150,7 @@ TEST_F(TopologicalSortTest, Idempotent) {\n   });\n \n   TF_EXPECT_OK(TopologicalSort(&graph));\n-  std::vector<string> order = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n+  std::vector<std::string> order = {\"1\", \"2\", \"3\", \"4\", \"5\"};\n   for (int i = 0; i < order.size(); i++) {\n     EXPECT_EQ(graph.node(i).name(), order[i]);\n   }\n@@ -178,12 +179,12 @@ TEST_F(TopologicalSortTest, ExtraDependencies) {\n   std::vector<const NodeDef*> topo_order;\n   TF_EXPECT_OK(ComputeTopologicalOrder(graph, extra_dependencies, &topo_order));\n \n-  const std::vector<string> valid_order_1 = {\"4\", \"5\", \"2\", \"0\", \"3\", \"1\"};\n-  const std::vector<string> valid_order_2 = {\"4\", \"5\", \"0\", \"2\", \"3\", \"1\"};\n+  const std::vector<std::string> valid_order_1 = {\"4\", \"5\", \"2\", \"0\", \"3\", \"1\"};\n+  const std::vector<std::string> valid_order_2 = {\"4\", \"5\", \"0\", \"2\", \"3\", \"1\"};\n \n   ASSERT_EQ(topo_order.size(), valid_order_1.size());\n \n-  std::vector<string> computed_order(6, \"\");\n+  std::vector<std::string> computed_order(6, \"\");\n   for (int i = 0; i < topo_order.size(); ++i) {\n     const NodeDef* node = topo_order[i];\n     computed_order[i] = node->name();"
        },
        {
            "sha": "da028e80e2ae1ce9ced988e93f84d91bf99b0b27",
            "filename": "tensorflow/core/grappler/utils/transitive_fanin.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -26,11 +26,11 @@ namespace tensorflow {\n namespace grappler {\n \n absl::Status ComputeTransitiveFanin(\n-    const GraphDef& graph, const std::vector<string>& terminal_nodes,\n-    std::unordered_map<string, const NodeDef*>* name_to_fanin_node,\n+    const GraphDef& graph, const std::vector<std::string>& terminal_nodes,\n+    std::unordered_map<std::string, const NodeDef*>* name_to_fanin_node,\n     std::vector<const NodeDef*>* fanin_nodes) {\n-  std::unordered_map<string, const NodeDef*> name_to_node;\n-  std::unordered_map<string, const NodeDef*> name_to_send;\n+  std::unordered_map<std::string, const NodeDef*> name_to_node;\n+  std::unordered_map<std::string, const NodeDef*> name_to_send;\n   for (const auto& node : graph.node()) {\n     name_to_node[node.name()] = &node;\n     if (node.op() == \"_Send\") {\n@@ -40,7 +40,7 @@ absl::Status ComputeTransitiveFanin(\n   }\n \n   std::vector<const NodeDef*> queue;\n-  for (const string& root : terminal_nodes) {\n+  for (const std::string& root : terminal_nodes) {\n     const NodeDef* node = name_to_node[NodeName(root)];\n     if (!node) {\n       return errors::InvalidArgument(\"Graph does not contain terminal node \",\n@@ -61,9 +61,9 @@ absl::Status ComputeTransitiveFanin(\n     fanin_nodes->push_back(node);\n     if (name_to_fanin_node) {\n       name_to_fanin_node->insert(\n-          std::pair<string, const NodeDef*>(node->name(), node));\n+          std::pair<std::string, const NodeDef*>(node->name(), node));\n     }\n-    for (const string& input : node->input()) {\n+    for (const std::string& input : node->input()) {\n       const NodeDef* in = name_to_node[NodeName(input)];\n       if (!in) {\n         return errors::InvalidArgument(\"Graph does not contain input \",\n@@ -85,15 +85,15 @@ absl::Status ComputeTransitiveFanin(\n   return absl::OkStatus();\n }\n \n-absl::Status ComputeTransitiveFanin(const GraphDef& graph,\n-                                    const std::vector<string>& terminal_nodes,\n-                                    std::vector<const NodeDef*>* fanin_nodes) {\n+absl::Status ComputeTransitiveFanin(\n+    const GraphDef& graph, const std::vector<std::string>& terminal_nodes,\n+    std::vector<const NodeDef*>* fanin_nodes) {\n   return ComputeTransitiveFanin(graph, terminal_nodes, nullptr, fanin_nodes);\n }\n \n absl::Status SetTransitiveFaninGraph(\n     const GraphDef& input_graph, GraphDef* output_graph,\n-    const std::vector<string>& terminal_nodes) {\n+    const std::vector<std::string>& terminal_nodes) {\n   // Determines transitive fanin nodes from terminal nodes and add them to the\n   // output graph.\n   std::vector<const NodeDef*> keep;"
        },
        {
            "sha": "a3ef9ea4563168a8d5184899c24e79819fef93eb",
            "filename": "tensorflow/core/grappler/utils/transitive_fanin.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin.h?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -29,20 +29,20 @@ namespace grappler {\n // transitive fanin into fanin_nodes. Optionally returns a map of name->node\n // for that graph into name_to_fanin_node if that is not set to nullptr.\n absl::Status ComputeTransitiveFanin(\n-    const GraphDef& graph, const std::vector<string>& terminal_nodes,\n-    std::unordered_map<string, const NodeDef*>* name_to_fanin_node,\n+    const GraphDef& graph, const std::vector<std::string>& terminal_nodes,\n+    std::unordered_map<std::string, const NodeDef*>* name_to_fanin_node,\n     std::vector<const NodeDef*>* fanin_nodes);\n \n-absl::Status ComputeTransitiveFanin(const GraphDef& graph,\n-                                    const std::vector<string>& terminal_nodes,\n-                                    std::vector<const NodeDef*>* fanin_nodes);\n+absl::Status ComputeTransitiveFanin(\n+    const GraphDef& graph, const std::vector<std::string>& terminal_nodes,\n+    std::vector<const NodeDef*>* fanin_nodes);\n \n // Creates output_graph from input_graph using the transitive fanin from the\n // specified terminal nodes. Returns error if the input_graph is deemed\n // structurally invalid.\n-absl::Status SetTransitiveFaninGraph(const GraphDef& input_graph,\n-                                     GraphDef* output_graph,\n-                                     const std::vector<string>& terminal_nodes);\n+absl::Status SetTransitiveFaninGraph(\n+    const GraphDef& input_graph, GraphDef* output_graph,\n+    const std::vector<std::string>& terminal_nodes);\n \n }  // namespace grappler\n }  // namespace tensorflow"
        },
        {
            "sha": "5ced8e1b20e510e47a4729ad12106fa18e067e58",
            "filename": "tensorflow/core/grappler/utils/transitive_fanin_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/878d1554b408d546384900ef3ea5bf74295ec4f2/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Futils%2Ftransitive_fanin_test.cc?ref=878d1554b408d546384900ef3ea5bf74295ec4f2",
            "patch": "@@ -30,14 +30,15 @@ namespace {\n class TransitiveFaninTest : public ::testing::Test {\n  protected:\n   struct NodeConfig {\n-    NodeConfig(string name, std::vector<string> inputs)\n+    NodeConfig(std::string name, std::vector<std::string> inputs)\n         : name(std::move(name)), inputs(std::move(inputs)) {}\n-    NodeConfig(string name, string op, std::vector<string> inputs)\n+    NodeConfig(std::string name, std::string op,\n+               std::vector<std::string> inputs)\n         : name(std::move(name)), op(std::move(op)), inputs(std::move(inputs)) {}\n \n-    string name;\n-    string op;\n-    std::vector<string> inputs;\n+    std::string name;\n+    std::string op;\n+    std::vector<std::string> inputs;\n   };\n \n   static GraphDef CreateGraph(const std::vector<NodeConfig>& nodes) {\n@@ -47,7 +48,7 @@ class TransitiveFaninTest : public ::testing::Test {\n       NodeDef node_def;\n       node_def.set_name(node.name);\n       node_def.set_op(node.op);\n-      for (const string& input : node.inputs) {\n+      for (const std::string& input : node.inputs) {\n         node_def.add_input(input);\n       }\n       *graph.add_node() = std::move(node_def);\n@@ -66,7 +67,7 @@ TEST_F(TransitiveFaninTest, NoPruning) {\n   });\n \n   GraphDef output_graph;\n-  const std::vector<string> terminal_nodes = {\"1\"};\n+  const std::vector<std::string> terminal_nodes = {\"1\"};\n   TF_EXPECT_OK(SetTransitiveFaninGraph(graph, &output_graph, terminal_nodes));\n   NodeMap node_map(&output_graph);\n   ASSERT_TRUE(node_map.NodeExists(\"1\"));\n@@ -85,7 +86,7 @@ TEST_F(TransitiveFaninTest, PruneNodesUnreachableFromSingleTerminalNode) {\n   });\n \n   GraphDef output_graph;\n-  const std::vector<string> terminal_nodes = {\"1\"};\n+  const std::vector<std::string> terminal_nodes = {\"1\"};\n   TF_EXPECT_OK(SetTransitiveFaninGraph(graph, &output_graph, terminal_nodes));\n   NodeMap node_map(&output_graph);\n   ASSERT_TRUE(node_map.NodeExists(\"1\"));\n@@ -106,7 +107,7 @@ TEST_F(TransitiveFaninTest, PruneNodesUnreachableFromMultipleTerminalNodes) {\n   });\n \n   GraphDef output_graph;\n-  const std::vector<string> terminal_nodes = {\"1\", \"5\"};\n+  const std::vector<std::string> terminal_nodes = {\"1\", \"5\"};\n   TF_EXPECT_OK(SetTransitiveFaninGraph(graph, &output_graph, terminal_nodes));\n   NodeMap node_map(&output_graph);\n   ASSERT_TRUE(node_map.NodeExists(\"1\"));\n@@ -128,11 +129,11 @@ TEST_F(TransitiveFaninTest, InvalidGraphOrTerminalNodes) {\n   });\n \n   GraphDef output_graph;\n-  const std::vector<string> terminal_nodes = {\"1\", \"5\"};\n+  const std::vector<std::string> terminal_nodes = {\"1\", \"5\"};\n   auto s = SetTransitiveFaninGraph(graph, &output_graph, terminal_nodes);\n   EXPECT_FALSE(s.ok());\n   EXPECT_EQ(s.message(), \"Graph does not contain input 6 of node 5.\");\n-  const std::vector<string> invalid_terminal_nodes = {\"0\", \"1\", \"5\"};\n+  const std::vector<std::string> invalid_terminal_nodes = {\"0\", \"1\", \"5\"};\n   s = SetTransitiveFaninGraph(graph, &output_graph, invalid_terminal_nodes);\n   EXPECT_FALSE(s.ok());\n   EXPECT_EQ(s.message(), \"Graph does not contain terminal node 0.\");"
        }
    ],
    "stats": {
        "total": 501,
        "additions": 259,
        "deletions": 242
    }
}