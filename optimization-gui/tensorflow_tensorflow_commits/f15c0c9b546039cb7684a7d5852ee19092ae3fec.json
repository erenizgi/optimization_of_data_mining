{
    "author": "derdrdirk",
    "message": "[XLA:GPU] Add documentation to Priority Fusion pass.\n\nPiperOrigin-RevId: 837168939",
    "sha": "f15c0c9b546039cb7684a7d5852ee19092ae3fec",
    "files": [
        {
            "sha": "74debe3b28d8272f97aefeea502015ffc8677bc7",
            "filename": "third_party/xla/xla/service/gpu/transforms/priority_fusion.h",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f15c0c9b546039cb7684a7d5852ee19092ae3fec/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f15c0c9b546039cb7684a7d5852ee19092ae3fec/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.h?ref=f15c0c9b546039cb7684a7d5852ee19092ae3fec",
            "patch": "@@ -39,6 +39,45 @@ limitations under the License.\n namespace xla {\n namespace gpu {\n \n+// PriorityFusion is the main fusion pass for XLA:GPU. It is an HLO pass that\n+// assigns a priority to each producer instruction based on the estimated\n+// performance benefit of fusing it into its consumers. The benefit is\n+// calculated using a performance cost model:\n+//\n+//   priority = time_unfused - time_fused\n+//\n+// Note: If fusing a producer into its consumers requires duplicating the\n+// producer, the cost model accounts for this duplication.\n+//\n+// The algorithm can be summarized in the following steps:\n+// 1. For each producer, call the cost model to estimate the potential benefit\n+//    of fusing it with all its consumers.\n+// 2. Put all producers with a positive benefit into a priority queue, ordered\n+//    by benefit.\n+// 3. Pop the producer with the highest priority from the queue.\n+// 4. Fuse the producer with its consumers. This may result in a new fusion\n+//    instruction, or merging into an existing fusion.\n+// 5. Update the priorities of the operands of the fused instructions and\n+//    of instructions whose consumers have changed, and update them in the\n+//    priority queue.\n+// 6. If the queue is not empty, go to step 3.\n+//\n+// Example:\n+// Consider A -> B -> C, where A, B, and C are fusible operations.\n+// The fusible producers are A and B.\n+//\n+// Priorities are computed:\n+//  - P(A) = benefit of fusing A into B.\n+//  - P(B) = benefit of fusing B into C.\n+//\n+// Assuming P(A)=10 and P(B)=5, the queue is [(A,10), (B,5)].\n+//  - A is popped and fused into B, creating fusion(A+B).\n+//  - The graph becomes fusion(A+B) -> C.\n+//  - Priority of fusion(A+B) is computed, P(fusion(A+B))=8.\n+//  - The queue becomes [(fusion(A+B),8)].\n+//  - fusion(A+B) is popped and fused into C, creating fusion(A+B+C).\n+//  - The queue becomes empty, and fusion terminates.\n+//\n class PriorityFusion : public HloModulePass {\n  public:\n   PriorityFusion(tsl::thread::ThreadPool* thread_pool,"
        }
    ],
    "stats": {
        "total": 39,
        "additions": 39,
        "deletions": 0
    }
}