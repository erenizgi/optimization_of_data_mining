{
    "author": "tensorflower-gardener",
    "message": "Use `mlir::MLIRContext` directly in `SymbolicMap` and related functions.\n\nThis change removes the dependency on `SymbolicExprContext` by using `mlir::MLIRContext` as the primary context for creating symbolic expressions within the `SymbolicMap` and its conversion utilities.\n\nThis simplifies the context management and aligns better with MLIR's infrastructure.\n\nPiperOrigin-RevId: 833323582",
    "sha": "2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
    "files": [
        {
            "sha": "f4d63d404fa2227722c0edc95b92c1cfb9bf6326",
            "filename": "third_party/xla/xla/hlo/analysis/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2FBUILD?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -739,6 +739,7 @@ cc_library(\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:IR\",\n     ],\n )\n "
        },
        {
            "sha": "a8743bacec83bf59bed658fbdb60e01f2d13ec2a",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 13,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.cc?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -29,18 +29,19 @@ limitations under the License.\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/ADT/SmallBitVector.h\"\n #include \"llvm/ADT/SmallVector.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n #include \"xla/hlo/analysis/symbolic_expr.h\"\n \n namespace xla {\n namespace {\n \n-llvm::SmallVector<SymbolicExpr> CreateVariableRange(SymbolicExprContext* ctx,\n+llvm::SmallVector<SymbolicExpr> CreateVariableRange(mlir::MLIRContext* ctx,\n                                                     int64_t n,\n                                                     int64_t offset = 0) {\n   llvm::SmallVector<SymbolicExpr> replacements;\n   replacements.reserve(n);\n   for (int64_t i = 0; i < n; ++i) {\n-    replacements.push_back(ctx->CreateVariable(offset + i));\n+    replacements.push_back(CreateSymbolicVariable(offset + i, ctx));\n   }\n   return replacements;\n }\n@@ -56,15 +57,15 @@ llvm::DenseSet<VariableID> GetUsedVariablesFromExpressions(\n \n }  // namespace\n \n-SymbolicMap::SymbolicMap(SymbolicExprContext* ctx, int64_t num_dimensions,\n+SymbolicMap::SymbolicMap(mlir::MLIRContext* ctx, int64_t num_dimensions,\n                          int64_t num_symbols,\n                          llvm::SmallVector<SymbolicExpr> exprs)\n     : ctx_(ctx),\n       num_dimensions_(num_dimensions),\n       num_symbols_(num_symbols),\n       exprs_(std::move(exprs)) {}\n \n-/*static*/ SymbolicMap SymbolicMap::Get(SymbolicExprContext* ctx,\n+/*static*/ SymbolicMap SymbolicMap::Get(mlir::MLIRContext* ctx,\n                                         int64_t num_dimensions,\n                                         int64_t num_symbols,\n                                         llvm::SmallVector<SymbolicExpr> exprs) {\n@@ -137,15 +138,16 @@ SymbolicMap SymbolicMap::ReplaceDimsAndSymbols(\n     absl::c_copy(dim_replacements, std::back_inserter(all_replacements));\n   } else {\n     for (int i = 0; i < num_dimensions_; ++i) {\n-      all_replacements.push_back(ctx_->CreateVariable(i));\n+      all_replacements.push_back(CreateSymbolicVariable(i, ctx_));\n     }\n   }\n \n   if (!sym_replacements.empty()) {\n     absl::c_copy(sym_replacements, std::back_inserter(all_replacements));\n   } else {\n     for (int i = 0; i < num_symbols_; ++i) {\n-      all_replacements.push_back(ctx_->CreateVariable(num_dimensions_ + i));\n+      all_replacements.push_back(\n+          CreateSymbolicVariable(num_dimensions_ + i, ctx_));\n     }\n   }\n \n@@ -212,10 +214,7 @@ SymbolicMap SymbolicMap::Replace(SymbolicExpr expr,\n }\n \n bool SymbolicMap::operator==(const SymbolicMap& other) const {\n-  const bool same_context =\n-      (ctx_ == other.ctx_) ||\n-      (ctx_ != nullptr && other.ctx_ != nullptr && *ctx_ == *other.ctx_);\n-  return (same_context && num_dimensions_ == other.num_dimensions_ &&\n+  return (ctx_ == other.ctx_ && num_dimensions_ == other.num_dimensions_ &&\n           num_symbols_ == other.num_symbols_ && exprs_ == other.exprs_);\n }\n \n@@ -274,7 +273,7 @@ SymbolicMap CompressDims(const SymbolicMap& map,\n   for (int i = 0; i < map.GetNumDims(); ++i) {\n     if (!unused_dims[i]) {\n       dim_replacements[i] =\n-          map.GetContext()->CreateVariable(current_new_dim_idx++);\n+          CreateSymbolicVariable(current_new_dim_idx++, map.GetContext());\n     }\n   }\n   auto sym_replacements =\n@@ -310,8 +309,8 @@ SymbolicMap CompressSymbols(const SymbolicMap& map,\n   int64_t current_new_sym_idx = 0;\n   for (int i = 0; i < map.GetNumSymbols(); ++i) {\n     if (!unused_symbols[i]) {\n-      sym_replacements[i] =\n-          map.GetContext()->CreateVariable(num_dims + current_new_sym_idx++);\n+      sym_replacements[i] = CreateSymbolicVariable(\n+          num_dims + current_new_sym_idx++, map.GetContext());\n     }\n   }\n   CHECK_EQ(current_new_sym_idx, new_num_symbols);"
        },
        {
            "sha": "d21580977b4dbba04d280acbd70841d50ec1d10c",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map.h",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map.h?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -25,21 +25,21 @@ limitations under the License.\n #include \"llvm/ADT/Hashing.h\"\n #include \"llvm/ADT/SmallBitVector.h\"\n #include \"llvm/ADT/SmallVector.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n #include \"xla/hlo/analysis/symbolic_expr.h\"\n \n namespace xla {\n \n // SymbolicMap abstracts away the fact that dimensions and symbols are both\n // implemented as SymbolicExpr variables. These free functions provide a way to\n // work with them without a SymbolicMap instance.\n-inline SymbolicExpr CreateDimExpr(SymbolicExprContext* context,\n-                                  unsigned dim_id) {\n-  return context->CreateVariable(dim_id);\n+inline SymbolicExpr CreateDimExpr(unsigned dim_id, mlir::MLIRContext* context) {\n+  return CreateSymbolicVariable(dim_id, context);\n }\n \n-inline SymbolicExpr CreateSymbolExpr(SymbolicExprContext* context,\n-                                     unsigned symbol_id, int64_t num_dims) {\n-  return context->CreateVariable(symbol_id + num_dims);\n+inline SymbolicExpr CreateSymbolExpr(unsigned symbol_id, int64_t num_dims,\n+                                     mlir::MLIRContext* context) {\n+  return CreateSymbolicVariable(symbol_id + num_dims, context);\n }\n \n inline bool IsDimension(SymbolicExpr expr, int64_t num_dims) {\n@@ -66,18 +66,18 @@ inline int64_t GetSymbolIndex(SymbolicExpr expr, int64_t num_dims) {\n class SymbolicMap {\n  public:\n   SymbolicMap() = default;\n-  static SymbolicMap Get(SymbolicExprContext* ctx, int64_t num_dimensions,\n+  static SymbolicMap Get(mlir::MLIRContext* ctx, int64_t num_dimensions,\n                          int64_t num_symbols,\n                          llvm::SmallVector<SymbolicExpr> exprs);\n \n-  SymbolicExprContext* GetContext() const { return ctx_; }\n+  mlir::MLIRContext* GetContext() const { return ctx_; }\n   int64_t GetNumDims() const { return num_dimensions_; }\n   int64_t GetNumSymbols() const { return num_symbols_; }\n   SymbolicExpr GetDimExpression(unsigned idx) const {\n-    return CreateDimExpr(ctx_, idx);\n+    return CreateDimExpr(idx, ctx_);\n   }\n   SymbolicExpr GetSymbolExpression(unsigned idx) const {\n-    return CreateSymbolExpr(ctx_, idx, num_dimensions_);\n+    return CreateSymbolExpr(idx, num_dimensions_, ctx_);\n   }\n   int64_t GetNumResults() const { return exprs_.size(); }\n   const llvm::SmallVector<SymbolicExpr>& GetResults() const { return exprs_; }\n@@ -148,10 +148,10 @@ class SymbolicMap {\n   }\n \n  private:\n-  SymbolicMap(SymbolicExprContext* ctx, int64_t num_dimensions,\n+  SymbolicMap(mlir::MLIRContext* ctx, int64_t num_dimensions,\n               int64_t num_symbols, llvm::SmallVector<SymbolicExpr> exprs);\n \n-  SymbolicExprContext* ctx_;\n+  mlir::MLIRContext* ctx_;\n   int64_t num_dimensions_;\n   int64_t num_symbols_;\n   llvm::SmallVector<SymbolicExpr> exprs_;"
        },
        {
            "sha": "7f5edf400b00754dbf5cd9ba8a20cc9022b1d6cb",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_converter.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 28,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter.cc?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -69,67 +69,66 @@ mlir::AffineExpr SymbolicExprToAffineExpr(SymbolicExpr symbolic_expr,\n }\n \n llvm::SmallVector<SymbolicExpr> AffineExprsToSymbolicExprs(\n-    llvm::ArrayRef<mlir::AffineExpr> affine_exprs, SymbolicExprContext* context,\n-    int num_dims) {\n+    llvm::ArrayRef<mlir::AffineExpr> affine_exprs, int num_dims) {\n   llvm::SmallVector<SymbolicExpr> symbolic_exprs;\n   symbolic_exprs.reserve(affine_exprs.size());\n   for (mlir::AffineExpr expr : affine_exprs) {\n-    symbolic_exprs.push_back(AffineExprToSymbolicExpr(expr, context, num_dims));\n+    symbolic_exprs.push_back(AffineExprToSymbolicExpr(expr, num_dims));\n   }\n   return symbolic_exprs;\n }\n \n SymbolicExpr AffineExprToSymbolicExpr(mlir::AffineExpr affine_expr,\n-                                      SymbolicExprContext* context,\n                                       int num_dims) {\n+  mlir::MLIRContext* context = affine_expr.getContext();\n   switch (affine_expr.getKind()) {\n     case mlir::AffineExprKind::Constant:\n-      return context->CreateConstant(\n-          mlir::cast<mlir::AffineConstantExpr>(affine_expr).getValue());\n+      return CreateSymbolicConstant(\n+          mlir::cast<mlir::AffineConstantExpr>(affine_expr).getValue(),\n+          context);\n     case mlir::AffineExprKind::DimId:\n-      return context->CreateVariable(\n-          mlir::cast<mlir::AffineDimExpr>(affine_expr).getPosition());\n+      return CreateSymbolicVariable(\n+          mlir::cast<mlir::AffineDimExpr>(affine_expr).getPosition(), context);\n     case mlir::AffineExprKind::SymbolId:\n-      return context->CreateVariable(\n+      return CreateSymbolicVariable(\n           mlir::cast<mlir::AffineSymbolExpr>(affine_expr).getPosition() +\n-          num_dims);\n+              num_dims,\n+          context);\n     case mlir::AffineExprKind::Add: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims) +\n-             AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), num_dims) +\n+             AffineExprToSymbolicExpr(bin_op.getRHS(), num_dims);\n     }\n     case mlir::AffineExprKind::Mul: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims) *\n-             AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), num_dims) *\n+             AffineExprToSymbolicExpr(bin_op.getRHS(), num_dims);\n     }\n     case mlir::AffineExprKind::FloorDiv: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n-          .floorDiv(\n-              AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), num_dims)\n+          .floorDiv(AffineExprToSymbolicExpr(bin_op.getRHS(), num_dims));\n     }\n     case mlir::AffineExprKind::CeilDiv: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n-          .ceilDiv(\n-              AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), num_dims)\n+          .ceilDiv(AffineExprToSymbolicExpr(bin_op.getRHS(), num_dims));\n     }\n     case mlir::AffineExprKind::Mod: {\n       auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineExprToSymbolicExpr(bin_op.getLHS(), context, num_dims) %\n-             AffineExprToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+      return AffineExprToSymbolicExpr(bin_op.getLHS(), num_dims) %\n+             AffineExprToSymbolicExpr(bin_op.getRHS(), num_dims);\n     }\n   }\n }\n \n-SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n-                                   SymbolicExprContext* context) {\n+SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map) {\n+  mlir::MLIRContext* context = affine_map.getContext();\n   llvm::SmallVector<SymbolicExpr> results;\n   results.reserve(affine_map.getNumResults());\n   int num_dims = affine_map.getNumDims();\n   for (mlir::AffineExpr expr : affine_map.getResults()) {\n-    results.push_back(AffineExprToSymbolicExpr(expr, context, num_dims));\n+    results.push_back(AffineExprToSymbolicExpr(expr, num_dims));\n   }\n   return SymbolicMap::Get(context, num_dims, affine_map.getNumSymbols(),\n                           results);\n@@ -157,11 +156,10 @@ mlir::AffineMap SymbolicMapToAffineMap(SymbolicMap symbolic_map,\n llvm::MapVector<SymbolicExpr, Interval>\n ConvertAffineConstraintsToSymbolicConstraints(\n     const llvm::MapVector<mlir::AffineExpr, Interval>& affine_constraints,\n-    SymbolicExprContext* context, int num_dims) {\n+    int num_dims) {\n   llvm::MapVector<SymbolicExpr, Interval> symbolic_constraints;\n   for (const auto& [affine_expr, interval] : affine_constraints) {\n-    SymbolicExpr expr =\n-        AffineExprToSymbolicExpr(affine_expr, context, num_dims);\n+    SymbolicExpr expr = AffineExprToSymbolicExpr(affine_expr, num_dims);\n     symbolic_constraints[expr] = interval;\n   }\n   return symbolic_constraints;"
        },
        {
            "sha": "5b6b0c3646b1c567522ca753924180825ecad7b7",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_converter.h",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter.h?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -29,22 +29,19 @@ namespace xla {\n \n // Converts an mlir::AffineExpr to xla::SymbolicExpr.\n SymbolicExpr AffineExprToSymbolicExpr(::mlir::AffineExpr affine_expr,\n-                                      SymbolicExprContext* context,\n                                       int num_dims);\n \n // Converts a list of mlir::AffineExpr to xla::SymbolicExpr.\n llvm::SmallVector<SymbolicExpr> AffineExprsToSymbolicExprs(\n-    llvm::ArrayRef<mlir::AffineExpr> affine_exprs, SymbolicExprContext* context,\n-    int num_dims);\n+    llvm::ArrayRef<mlir::AffineExpr> affine_exprs, int num_dims);\n \n // Converts an xla::SymbolicExpr to an mlir::AffineExpr.\n mlir::AffineExpr SymbolicExprToAffineExpr(SymbolicExpr symbolic_expr,\n                                           mlir::MLIRContext* context,\n                                           int num_dims);\n \n // Converts an mlir::AffineMap to xla::SymbolicMap.\n-SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n-                                   SymbolicExprContext* context);\n+SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map);\n \n // Converts xla::SymbolicMap to an mlir::AffineMap.\n // Returns a null AffineMap if the conversion is not possible.\n@@ -55,7 +52,7 @@ mlir::AffineMap SymbolicMapToAffineMap(SymbolicMap symbolic_map,\n llvm::MapVector<SymbolicExpr, Interval>\n ConvertAffineConstraintsToSymbolicConstraints(\n     const llvm::MapVector<mlir::AffineExpr, Interval>& affine_constraints,\n-    SymbolicExprContext* context, int num_dims);\n+    int num_dims);\n \n }  // namespace xla\n "
        },
        {
            "sha": "ec056438efcbd15d0ec8069c81022c3bdada55ca",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_converter_test.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 50,
            "changes": 92,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_converter_test.cc?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -53,87 +53,80 @@ AffineMap ParseAffineMap(absl::string_view serialized_affine_map,\n \n class SymbolicMapConverterTest : public ::testing::Test {\n  public:\n-  SymbolicMapConverterTest() : symbolic_expr_context_(&mlir_context_) {}\n-\n-  MLIRContext mlir_context_;\n-  SymbolicExprContext symbolic_expr_context_;\n+  MLIRContext context_;\n };\n \n TEST_F(SymbolicMapConverterTest, AffineToSymbolicRoundTrip) {\n   AffineMap affine_map = ParseAffineMap(\n       \"(d0, d1)[s0, s1] -> (d0 + s1 * 2, d1 - s0, d0 floordiv 3, d1 mod 4)\",\n-      &mlir_context_);\n+      &context_);\n \n-  SymbolicMap symbolic_map =\n-      AffineMapToSymbolicMap(affine_map, &symbolic_expr_context_);\n+  SymbolicMap symbolic_map = AffineMapToSymbolicMap(affine_map);\n \n   EXPECT_EQ(symbolic_map.GetNumResults(), 4);\n \n-  AffineMap round_trip_map =\n-      SymbolicMapToAffineMap(symbolic_map, &mlir_context_);\n+  AffineMap round_trip_map = SymbolicMapToAffineMap(symbolic_map, &context_);\n   EXPECT_EQ(affine_map, round_trip_map);\n }\n \n TEST_F(SymbolicMapConverterTest, SymbolicToAffineFailure) {\n-  SymbolicExpr d0 = symbolic_expr_context_.CreateVariable(0);\n-  SymbolicExpr c1 = symbolic_expr_context_.CreateConstant(1);\n+  SymbolicExpr d0 = CreateSymbolicVariable(0, &context_);\n+  SymbolicExpr c1 = CreateSymbolicConstant(1, &context_);\n   // kMax is not representable in AffineExpr.\n   SymbolicExpr max_expr = d0.max(c1);\n \n   AffineMap affine_map = SymbolicMapToAffineMap(\n-      SymbolicMap::Get(&symbolic_expr_context_, 1, 0, {max_expr}),\n-      &mlir_context_);\n+      SymbolicMap::Get(&context_, 1, 0, {max_expr}), &context_);\n   EXPECT_FALSE(affine_map);\n }\n \n TEST_F(SymbolicMapConverterTest, SymbolicToAffineNestedFailure) {\n-  SymbolicExpr d0 = symbolic_expr_context_.CreateVariable(0);\n-  SymbolicExpr c1 = symbolic_expr_context_.CreateConstant(1);\n-  SymbolicExpr c2 = symbolic_expr_context_.CreateConstant(2);\n+  SymbolicExpr d0 = CreateSymbolicVariable(0, &context_);\n+  SymbolicExpr c1 = CreateSymbolicConstant(1, &context_);\n+  SymbolicExpr c2 = CreateSymbolicConstant(2, &context_);\n \n   // d0 + max(c1, c2). max is not representable in AffineExpr.\n   SymbolicExpr nested_max_expr = d0 + c1.max(c2);\n \n   // This should not crash and should return a null AffineMap.\n   AffineMap affine_map = SymbolicMapToAffineMap(\n-      SymbolicMap::Get(&symbolic_expr_context_, 1, 0, {nested_max_expr}),\n-      &mlir_context_);\n+      SymbolicMap::Get(&context_, 1, 0, {nested_max_expr}), &context_);\n   EXPECT_FALSE(affine_map);\n }\n \n TEST_F(SymbolicMapConverterTest, AffineExprsToSymbolicExprs) {\n-  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n-  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &mlir_context_);\n-  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context_);\n-  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context_);\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &context_);\n+  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &context_);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &context_);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &context_);\n   llvm::SmallVector<mlir::AffineExpr> affine_exprs = {d0, d1, s0, c1};\n-  llvm::SmallVector<SymbolicExpr> symbolic_exprs = AffineExprsToSymbolicExprs(\n-      affine_exprs, &symbolic_expr_context_, /*num_dims=*/2);\n+  llvm::SmallVector<SymbolicExpr> symbolic_exprs =\n+      AffineExprsToSymbolicExprs(affine_exprs, /*num_dims=*/2);\n   EXPECT_EQ(symbolic_exprs.size(), 4);\n-  EXPECT_EQ(symbolic_exprs[0], symbolic_expr_context_.CreateVariable(0));\n-  EXPECT_EQ(symbolic_exprs[1], symbolic_expr_context_.CreateVariable(1));\n-  EXPECT_EQ(symbolic_exprs[2], symbolic_expr_context_.CreateVariable(2));\n-  EXPECT_EQ(symbolic_exprs[3], symbolic_expr_context_.CreateConstant(1));\n+  EXPECT_EQ(symbolic_exprs[0], CreateSymbolicVariable(0, &context_));\n+  EXPECT_EQ(symbolic_exprs[1], CreateSymbolicVariable(1, &context_));\n+  EXPECT_EQ(symbolic_exprs[2], CreateSymbolicVariable(2, &context_));\n+  EXPECT_EQ(symbolic_exprs[3], CreateSymbolicConstant(1, &context_));\n }\n \n TEST_F(SymbolicMapConverterTest,\n        ConvertAffineConstraintsToSymbolicConstraints) {\n-  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n-  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context_);\n-  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context_);\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &context_);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &context_);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &context_);\n \n   llvm::MapVector<mlir::AffineExpr, Interval> affine_constraints;\n   affine_constraints[d0 + s0] = {0, 127};\n   affine_constraints[s0 * 2] = {0, 63};\n   affine_constraints[d0 - c1] = {10, 20};\n \n   llvm::MapVector<SymbolicExpr, Interval> symbolic_constraints =\n-      ConvertAffineConstraintsToSymbolicConstraints(\n-          affine_constraints, &symbolic_expr_context_, /*num_dims=*/1);\n+      ConvertAffineConstraintsToSymbolicConstraints(affine_constraints,\n+                                                    /*num_dims=*/1);\n \n-  SymbolicExpr sym_d0 = symbolic_expr_context_.CreateVariable(0);\n-  SymbolicExpr sym_s0 = symbolic_expr_context_.CreateVariable(1);\n-  SymbolicExpr sym_c1 = symbolic_expr_context_.CreateConstant(1);\n+  SymbolicExpr sym_d0 = CreateSymbolicVariable(0, &context_);\n+  SymbolicExpr sym_s0 = CreateSymbolicVariable(1, &context_);\n+  SymbolicExpr sym_c1 = CreateSymbolicConstant(1, &context_);\n \n   EXPECT_EQ(symbolic_constraints.size(), 3);\n   EXPECT_EQ(symbolic_constraints[sym_d0 + sym_s0], (Interval{0, 127}));\n@@ -142,12 +135,12 @@ TEST_F(SymbolicMapConverterTest,\n }\n \n TEST_F(SymbolicMapConverterTest, ConvertAffineToSymbolicExpr) {\n-  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n-  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &mlir_context_);\n-  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context_);\n-  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context_);\n-  mlir::AffineExpr c2 = mlir::getAffineConstantExpr(2, &mlir_context_);\n-  mlir::AffineExpr c3 = mlir::getAffineConstantExpr(3, &mlir_context_);\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &context_);\n+  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &context_);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &context_);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &context_);\n+  mlir::AffineExpr c2 = mlir::getAffineConstantExpr(2, &context_);\n+  mlir::AffineExpr c3 = mlir::getAffineConstantExpr(3, &context_);\n \n   mlir::AffineExpr affine_expr =\n       mlir::getAffineBinaryOpExpr(\n@@ -157,18 +150,17 @@ TEST_F(SymbolicMapConverterTest, ConvertAffineToSymbolicExpr) {\n           c3) +\n       d1;  // ((d0 * 2 + s0 - 1) floordiv 2) mod 3 + d1\n \n-  SymbolicExpr exp_d0 = symbolic_expr_context_.CreateVariable(0);\n-  SymbolicExpr exp_d1 = symbolic_expr_context_.CreateVariable(1);\n-  SymbolicExpr exp_s0 = symbolic_expr_context_.CreateVariable(2);\n-  SymbolicExpr exp_c1 = symbolic_expr_context_.CreateConstant(1);\n-  SymbolicExpr exp_c2 = symbolic_expr_context_.CreateConstant(2);\n-  SymbolicExpr exp_c3 = symbolic_expr_context_.CreateConstant(3);\n+  SymbolicExpr exp_d0 = CreateSymbolicVariable(0, &context_);\n+  SymbolicExpr exp_d1 = CreateSymbolicVariable(1, &context_);\n+  SymbolicExpr exp_s0 = CreateSymbolicVariable(2, &context_);\n+  SymbolicExpr exp_c1 = CreateSymbolicConstant(1, &context_);\n+  SymbolicExpr exp_c2 = CreateSymbolicConstant(2, &context_);\n+  SymbolicExpr exp_c3 = CreateSymbolicConstant(3, &context_);\n \n   SymbolicExpr expected_symbolic_expr =\n       ((exp_d0 * exp_c2 + exp_s0 - exp_c1) / exp_c2) % exp_c3 + exp_d1;\n \n-  EXPECT_EQ(AffineExprToSymbolicExpr(affine_expr, &symbolic_expr_context_,\n-                                     /*num_dims=*/2),\n+  EXPECT_EQ(AffineExprToSymbolicExpr(affine_expr, /*num_dims=*/2),\n             expected_symbolic_expr);\n }\n "
        },
        {
            "sha": "9c8cbc9a9795e38dde87b681e141d327750295ec",
            "filename": "third_party/xla/xla/hlo/analysis/symbolic_map_test.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 78,
            "changes": 134,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fanalysis%2Fsymbolic_map_test.cc?ref=2628eb7a6f3c5ec15dc6ba50886ca4273fc6806d",
            "patch": "@@ -29,8 +29,7 @@ namespace {\n using ::testing::ElementsAre;\n \n struct SymbolicMapTest : public ::testing::Test {\n-  mlir::MLIRContext mlir_context;\n-  SymbolicExprContext ctx;\n+  mlir::MLIRContext ctx;\n   SymbolicExpr d0;\n   SymbolicExpr d1;\n   static constexpr int kSampleDims = 2;\n@@ -42,13 +41,12 @@ struct SymbolicMapTest : public ::testing::Test {\n   SymbolicMap sample_map;\n \n   SymbolicMapTest()\n-      : ctx(&mlir_context),\n-        d0(CreateDimExpr(&ctx, 0)),\n-        d1(CreateDimExpr(&ctx, 1)),\n-        s0(CreateSymbolExpr(&ctx, 0, kSampleDims)),\n-        s1(CreateSymbolExpr(&ctx, 1, kSampleDims)),\n-        c2(ctx.CreateConstant(2)),\n-        c10(ctx.CreateConstant(10)),\n+      : d0(CreateDimExpr(0, &ctx)),\n+        d1(CreateDimExpr(1, &ctx)),\n+        s0(CreateSymbolExpr(0, kSampleDims, &ctx)),\n+        s1(CreateSymbolExpr(1, kSampleDims, &ctx)),\n+        c2(CreateSymbolicConstant(2, &ctx)),\n+        c10(CreateSymbolicConstant(10, &ctx)),\n         sample_map(SymbolicMap::Get(&ctx, kSampleDims, kSampleSymbols,\n                                     {d0 + s0, d1 * s1})) {}\n };\n@@ -71,9 +69,9 @@ TEST_F(SymbolicMapTest, ToString) {\n   EXPECT_EQ(dims_only.ToString(), \"(d0, d1)[] -> (d0, d1)\");\n \n   SymbolicExpr s0_no_dims =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/0);\n+      CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/0, &ctx);\n   SymbolicExpr s1_no_dims =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/0);\n+      CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/0, &ctx);\n   SymbolicMap symbols_only =\n       SymbolicMap::Get(&ctx, 0, kSampleSymbols, {s0_no_dims, s1_no_dims});\n   EXPECT_EQ(symbols_only.ToString(), \"()[s0, s1] -> (s0, s1)\");\n@@ -83,43 +81,45 @@ TEST_F(SymbolicMapTest, IsEmpty) {\n   EXPECT_TRUE(SymbolicMap::Get(&ctx, 0, 0, {}).IsEmpty());\n   EXPECT_TRUE(SymbolicMap::Get(&ctx, 2, 1, {}).IsEmpty());\n   EXPECT_FALSE(\n-      SymbolicMap::Get(&ctx, 1, 0, {CreateDimExpr(&ctx, 0)}).IsEmpty());\n+      SymbolicMap::Get(&ctx, 1, 0, {CreateDimExpr(0, &ctx)}).IsEmpty());\n }\n \n TEST_F(SymbolicMapTest, IsIdentity) {\n   SymbolicMap true_identity = SymbolicMap::Get(\n-      &ctx, 2, 0, {CreateDimExpr(&ctx, 0), CreateDimExpr(&ctx, 1)});\n+      &ctx, 2, 0, {CreateDimExpr(0, &ctx), CreateDimExpr(1, &ctx)});\n   EXPECT_TRUE(true_identity.IsIdentity());\n \n   SymbolicMap true_identity_with_symbols = SymbolicMap::Get(\n-      &ctx, 2, 1, {CreateDimExpr(&ctx, 0), CreateDimExpr(&ctx, 1)});\n+      &ctx, 2, 1, {CreateDimExpr(0, &ctx), CreateDimExpr(1, &ctx)});\n   EXPECT_TRUE(true_identity_with_symbols.IsIdentity());\n \n   SymbolicMap few_results =\n-      SymbolicMap::Get(&ctx, 2, 0, {CreateDimExpr(&ctx, 0)});\n+      SymbolicMap::Get(&ctx, 2, 0, {CreateDimExpr(0, &ctx)});\n   EXPECT_FALSE(few_results.IsIdentity());\n \n   SymbolicMap too_many_results = SymbolicMap::Get(\n-      &ctx, 1, 0, {CreateDimExpr(&ctx, 0), CreateDimExpr(&ctx, 1)});\n+      &ctx, 1, 0, {CreateDimExpr(0, &ctx), CreateDimExpr(1, &ctx)});\n   EXPECT_FALSE(too_many_results.IsIdentity());\n \n   SymbolicMap wrong_expr_type = SymbolicMap::Get(\n-      &ctx, 2, 0, {CreateDimExpr(&ctx, 0), ctx.CreateConstant(1)});\n+      &ctx, 2, 0, {CreateDimExpr(0, &ctx), CreateSymbolicConstant(1, &ctx)});\n   EXPECT_FALSE(wrong_expr_type.IsIdentity());\n \n   SymbolicMap unordered_variable_id = SymbolicMap::Get(\n-      &ctx, 2, 0, {CreateDimExpr(&ctx, 1), CreateDimExpr(&ctx, 0)});\n+      &ctx, 2, 0, {CreateDimExpr(1, &ctx), CreateDimExpr(0, &ctx)});\n   EXPECT_FALSE(unordered_variable_id.IsIdentity());\n }\n \n TEST_F(SymbolicMapTest, GetConstantResults) {\n   SymbolicMap all_constants_map = SymbolicMap::Get(\n-      &ctx, 0, 0, {ctx.CreateConstant(5), ctx.CreateConstant(10)});\n+      &ctx, 0, 0,\n+      {CreateSymbolicConstant(5, &ctx), CreateSymbolicConstant(10, &ctx)});\n   EXPECT_TRUE(all_constants_map.IsConstant());\n   EXPECT_THAT(all_constants_map.GetConstantResults(), ElementsAre(5, 10));\n \n   SymbolicMap mixed_map = SymbolicMap::Get(\n-      &ctx, 1, 0, {ctx.CreateConstant(5), ctx.CreateVariable(0)});\n+      &ctx, 1, 0,\n+      {CreateSymbolicConstant(5, &ctx), CreateSymbolicVariable(0, &ctx)});\n   EXPECT_FALSE(mixed_map.IsConstant());\n   EXPECT_DEATH(mixed_map.GetConstantResults(),\n                \"Cannot get constant results from a non-constant map\");\n@@ -130,7 +130,7 @@ TEST_F(SymbolicMapTest, GetConstantResults) {\n }\n \n TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n-  SymbolicExpr c3 = ctx.CreateConstant(30);\n+  SymbolicExpr c3 = CreateSymbolicConstant(30, &ctx);\n \n   SymbolicMap replaced_basic = sample_map.ReplaceDimsAndSymbols(\n       {d1, c2}, {c3, d0}, sample_map.GetNumDims(), sample_map.GetNumSymbols());\n@@ -142,9 +142,9 @@ TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n \n   SymbolicMap map_change_dims = SymbolicMap::Get(&ctx, 1, 1, {d0 + s0 * c2});\n   // Replacements in the context of the NEW map (2 dims, 1 symbol)\n-  SymbolicExpr new_d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr new_d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+  SymbolicExpr new_d0 = CreateDimExpr(0, &ctx);\n+  SymbolicExpr new_d1 = CreateDimExpr(1, &ctx);\n+  SymbolicExpr new_s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/2, &ctx);\n   SymbolicMap replaced_change_dims = map_change_dims.ReplaceDimsAndSymbols(\n       {new_d0 * c10 + new_d1}, {new_s0}, 2, 1);\n   EXPECT_EQ(replaced_change_dims.GetNumDims(), 2);\n@@ -176,9 +176,9 @@ TEST_F(SymbolicMapTest, Compose) {\n \n   // Composition with Symbols\n   SymbolicExpr s0_map1 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+      CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/2, &ctx);\n   SymbolicExpr s0_map2 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n+      CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/1, &ctx);\n   SymbolicMap map1_symbols =\n       SymbolicMap::Get(&ctx, 2, 1, {d0 + s0_map1, d1 * 2});\n   SymbolicMap map2_symbols =\n@@ -188,9 +188,9 @@ TEST_F(SymbolicMapTest, Compose) {\n   EXPECT_EQ(compose_with_symbols.GetNumSymbols(), 2);\n   SymbolicExpr new_d0 = d0;\n   SymbolicExpr new_s0_map1 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n+      CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/1, &ctx);\n   SymbolicExpr new_s0_map2 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/1);\n+      CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/1, &ctx);\n   EXPECT_THAT(\n       compose_with_symbols.GetResults(),\n       ElementsAre((new_d0 - 10) + new_s0_map1, (new_d0 + new_s0_map2) * 2));\n@@ -215,13 +215,13 @@ TEST_F(SymbolicMapTest, Compose) {\n   // The reindexed symbol from map1_symbols is the second symbol in the composed\n   // map.\n   SymbolicExpr reindexed_map1_s0 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/2);\n+      CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/2, &ctx);\n   EXPECT_THAT(compose_left_with_id2dim_1sym.GetResults(),\n               ElementsAre(d0 + reindexed_map1_s0, d1 * 2));\n }\n \n TEST_F(SymbolicMapTest, Replace) {\n-  SymbolicExpr c5 = ctx.CreateConstant(5);\n+  SymbolicExpr c5 = CreateSymbolicConstant(5, &ctx);\n \n   SymbolicExpr expr0 = (d0 + c2) * d1;\n   SymbolicExpr expr1 = d1 + c2;\n@@ -234,17 +234,18 @@ TEST_F(SymbolicMapTest, Replace) {\n   SymbolicMap replaced_just_one = map.Replace(d1 + c2, c5);\n   EXPECT_THAT(replaced_just_one.GetResults(), ElementsAre(expr0, c5));\n \n-  SymbolicMap no_replacement_map = map.Replace(ctx.CreateVariable(99), c5);\n+  SymbolicMap no_replacement_map =\n+      map.Replace(CreateSymbolicVariable(99, &ctx), c5);\n   EXPECT_EQ(no_replacement_map, map);\n }\n \n TEST_F(SymbolicMapTest, GetUnusedVariables) {\n-  [[maybe_unused]] SymbolicExpr d2 = CreateDimExpr(&ctx, 2);\n+  [[maybe_unused]] SymbolicExpr d2 = CreateDimExpr(2, &ctx);\n   // d2 is unused.\n   [[maybe_unused]] SymbolicExpr s0_3dims =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/3);\n+      CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/3, &ctx);\n   SymbolicExpr s1_3dims =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/3);\n+      CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/3, &ctx);\n \n   // Map with used and unused dims and symbols.\n   SymbolicMap map = SymbolicMap::Get(&ctx, 3, 2, {d0 + s1_3dims, d1 * c2});\n@@ -281,8 +282,8 @@ TEST_F(SymbolicMapTest, GetUnusedVariables) {\n   EXPECT_EQ(no_sym_symbols.size(), 0);\n \n   // Map with only symbols\n-  s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/0);\n-  s1 = CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/0);\n+  s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/0, &ctx);\n+  s1 = CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/0, &ctx);\n   SymbolicMap no_dims_map = SymbolicMap::Get(&ctx, 0, 2, {s0 * s1});\n   llvm::SmallBitVector no_dim_dims = GetUnusedDimensionsBitVector(no_dims_map);\n   EXPECT_EQ(no_dim_dims.size(), 0);\n@@ -293,10 +294,10 @@ TEST_F(SymbolicMapTest, GetUnusedVariables) {\n }\n \n TEST_F(SymbolicMapTest, CompressDims) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  [[maybe_unused]] SymbolicExpr d1 = CreateDimExpr(&ctx, 1);  // Unused\n-  SymbolicExpr d2 = CreateDimExpr(&ctx, 2);\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/3);\n+  SymbolicExpr d0 = CreateDimExpr(0, &ctx);\n+  [[maybe_unused]] SymbolicExpr d1 = CreateDimExpr(1, &ctx);  // Unused\n+  SymbolicExpr d2 = CreateDimExpr(2, &ctx);\n+  SymbolicExpr s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/3, &ctx);\n \n   // Map: (d0, d1, d2)[s0] -> {d0 + d2, s0 * 5}\n   SymbolicMap map = SymbolicMap::Get(&ctx, 3, 1, {d0 + d2, s0 * 5});\n@@ -308,9 +309,9 @@ TEST_F(SymbolicMapTest, CompressDims) {\n   EXPECT_EQ(compressed.GetNumDims(), 2);\n   EXPECT_EQ(compressed.GetNumSymbols(), 1);\n \n-  SymbolicExpr new_d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr new_d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n+  SymbolicExpr new_d0 = CreateDimExpr(0, &ctx);\n+  SymbolicExpr new_d1 = CreateDimExpr(1, &ctx);\n+  SymbolicExpr new_s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/2, &ctx);\n   EXPECT_THAT(compressed.GetResults(),\n               ElementsAre(new_d0 + new_d1, new_s0 * 5));\n \n@@ -322,11 +323,11 @@ TEST_F(SymbolicMapTest, CompressDims) {\n }\n \n TEST_F(SymbolicMapTest, CompressSymbols) {\n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n+  SymbolicExpr d0 = CreateDimExpr(0, &ctx);\n+  SymbolicExpr s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/1, &ctx);\n   [[maybe_unused]] SymbolicExpr s1 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/1);  // Unused\n-  SymbolicExpr s2 = CreateSymbolExpr(&ctx, /*symbol_id=*/2, /*num_dims=*/1);\n+      CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/1, &ctx);  // Unused\n+  SymbolicExpr s2 = CreateSymbolExpr(/*symbol_id=*/2, /*num_dims=*/1, &ctx);\n \n   // Map: (d0)[s0, s1, s2] -> {d0 + s2, s0 * 5}\n   SymbolicMap map = SymbolicMap::Get(&ctx, 1, 3, {d0 + s2, s0 * 5});\n@@ -338,10 +339,10 @@ TEST_F(SymbolicMapTest, CompressSymbols) {\n   EXPECT_EQ(compressed.GetNumDims(), 1);\n   EXPECT_EQ(compressed.GetNumSymbols(), 2);\n \n-  SymbolicExpr new_d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr new_s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/1);\n+  SymbolicExpr new_d0 = CreateDimExpr(0, &ctx);\n+  SymbolicExpr new_s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/1, &ctx);\n   SymbolicExpr new_s1 =\n-      CreateSymbolExpr(&ctx, /*symbol_id=*/1, /*num_dims=*/1);  // Original s2\n+      CreateSymbolExpr(/*symbol_id=*/1, /*num_dims=*/1, &ctx);  // Original s2\n   EXPECT_THAT(compressed.GetResults(),\n               ElementsAre(new_d0 + new_s1, new_s0 * 5));\n \n@@ -352,37 +353,14 @@ TEST_F(SymbolicMapTest, CompressSymbols) {\n                \"Attempting to compress a used symbol: 2\");\n }\n \n-TEST_F(SymbolicMapTest, EqualityWithDifferentContexts) {\n-  mlir::MLIRContext mlir_context2;\n-  SymbolicExprContext ctx2(&mlir_context2);\n-  // ctx2 and ctx3 will have the same MLIRContext, and thus the same\n-  // StorageUniquer, so they should be considered equal.\n-  SymbolicExprContext ctx3(&mlir_context2);\n-\n-  SymbolicExpr d0_ctx1 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d0_ctx2 = CreateDimExpr(&ctx2, 0);\n-  SymbolicExpr d0_ctx3 = CreateDimExpr(&ctx3, 0);\n-\n-  SymbolicMap map1 = SymbolicMap::Get(&ctx, 1, 0, {d0_ctx1});\n-  SymbolicMap map2 = SymbolicMap::Get(&ctx2, 1, 0, {d0_ctx2});\n-  SymbolicMap map3 = SymbolicMap::Get(&ctx3, 1, 0, {d0_ctx3});\n-\n-  // Maps with different contexts should not be equal.\n-  EXPECT_TRUE(map1 != map2);\n-\n-  // Maps with the same UniquerStorage and expressions should be equal even if\n-  // they have different SymbolicExprContexts.\n-  EXPECT_TRUE(map2 == map3);\n-}\n-\n TEST_F(SymbolicMapTest, Hashing) {\n   absl::flat_hash_set<SymbolicMap> set;\n \n-  SymbolicExpr d0 = CreateDimExpr(&ctx, 0);\n-  SymbolicExpr d1 = CreateDimExpr(&ctx, 1);\n-  SymbolicExpr s0 = CreateSymbolExpr(&ctx, /*symbol_id=*/0, /*num_dims=*/2);\n-  SymbolicExpr c42 = ctx.CreateConstant(42);\n-  SymbolicExpr c99 = ctx.CreateConstant(99);\n+  SymbolicExpr d0 = CreateDimExpr(0, &ctx);\n+  SymbolicExpr d1 = CreateDimExpr(1, &ctx);\n+  SymbolicExpr s0 = CreateSymbolExpr(/*symbol_id=*/0, /*num_dims=*/2, &ctx);\n+  SymbolicExpr c42 = CreateSymbolicConstant(42, &ctx);\n+  SymbolicExpr c99 = CreateSymbolicConstant(99, &ctx);\n \n   SymbolicMap map1 = SymbolicMap::Get(&ctx, 2, 1, {d0 + s0, d1 * c42});\n   SymbolicMap map2 = SymbolicMap::Get(&ctx, 2, 1, {d0 + s0, d1 * c42});"
        }
    ],
    "stats": {
        "total": 339,
        "additions": 152,
        "deletions": 187
    }
}