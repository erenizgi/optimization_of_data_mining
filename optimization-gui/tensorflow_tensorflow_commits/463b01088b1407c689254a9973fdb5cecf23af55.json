{
    "author": "ezhulenev",
    "message": "[xla:tfcompile] Move memory allocation functions to tf2xla\n\nIn preparation for removing cpu_function_runtime move APIs used only from TF to TF itself.\n\nPiperOrigin-RevId: 816874772",
    "sha": "463b01088b1407c689254a9973fdb5cecf23af55",
    "files": [
        {
            "sha": "a8dedd0e40997a91e3e0c4a8a3cd741df35108a8",
            "filename": "tensorflow/compiler/aot/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Faot%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Faot%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2FBUILD?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -95,6 +95,7 @@ cc_library(\n         \":llvm_targets\",  # fixdeps: keep\n         \":thunk_proto_execution_deserializer\",\n         \"//tensorflow/compiler/tf2xla\",\n+        \"//tensorflow/compiler/tf2xla:allocator\",\n         \"//tensorflow/compiler/tf2xla:mlir_tf2xla\",  # fixdeps: keep\n         \"//tensorflow/compiler/tf2xla:tf2xla_proto_cc\",\n         \"//tensorflow/compiler/tf2xla:tf2xla_util\","
        },
        {
            "sha": "054a7fdde77bd98cb8c67e3c29e3a670cfb21bc1",
            "filename": "tensorflow/compiler/aot/codegen.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Faot%2Fcodegen.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Faot%2Fcodegen.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Faot%2Fcodegen.cc?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -41,6 +41,7 @@ limitations under the License.\n #include \"tensorflow/compiler/aot/embedded_constant_buffers.h\"\n #include \"tensorflow/compiler/aot/embedded_protocol_buffers.h\"\n #include \"tensorflow/compiler/aot/thunk_proto_execution_deserializer.h\"\n+#include \"tensorflow/compiler/tf2xla/allocator.h\"\n #include \"tensorflow/compiler/tf2xla/tf2xla.pb.h\"\n #include \"tensorflow/compiler/tf2xla/tf2xla_util.h\"\n #include \"xla/backends/cpu/runtime/thunk.pb.h\"\n@@ -778,7 +779,7 @@ absl::Status ExtendRewrites(\n         void** buffer_table, xla::ExecutableRunOptions*,\n         std::vector<std::unique_ptr<xla::cpu::RngState>>&)>\n   ThunkRunImplFunction() {\n-    return [](void** buffer_table, xla::ExecutableRunOptions* run_options, \n+    return [](void** buffer_table, xla::ExecutableRunOptions* run_options,\n     std::vector<std::unique_ptr<xla::cpu::RngState>>& rng_states) {\n       {{THUNK_RUN_IMPL}}\n       return true;\n@@ -867,15 +868,13 @@ absl::Status GenerateHeader(\n       CheckEqual(ps.result().tuple_shapes_size(), result_index_table.size(),\n                  \"Result number mismatch, proto vs. result_index_table\"));\n   TF_ASSIGN_OR_RETURN(auto program_shape, xla::ProgramShape::FromProto(ps));\n-  const size_t arg_bytes_aligned =\n-      xla::cpu_function_runtime::AlignedBufferBytes(\n-          buffer_infos_for_args.data(), buffer_infos_for_args.size(),\n-          /*allocate_entry_params=*/true);\n+  const size_t arg_bytes_aligned = tensorflow::AlignedBufferBytes(\n+      buffer_infos_for_args.data(), buffer_infos_for_args.size(),\n+      /*allocate_entry_params=*/true);\n   const size_t arg_bytes_total = TotalBufferBytes(buffer_infos_for_args);\n-  const size_t temp_bytes_aligned =\n-      xla::cpu_function_runtime::AlignedBufferBytes(\n-          buffer_infos_for_temps.data(), buffer_infos_for_temps.size(),\n-          /*allocate_entry_params=*/true);\n+  const size_t temp_bytes_aligned = tensorflow::AlignedBufferBytes(\n+      buffer_infos_for_temps.data(), buffer_infos_for_temps.size(),\n+      /*allocate_entry_params=*/true);\n   const size_t temp_bytes_total = TotalBufferBytes(buffer_infos_for_temps);\n \n   // Create rewrite strings for namespace start and end."
        },
        {
            "sha": "416f1a371797369ead2afd711362c94a36daf608",
            "filename": "tensorflow/compiler/tf2xla/BUILD",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2FBUILD?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -217,6 +217,7 @@ cc_library(\n filegroup(\n     name = \"xla_compiled_cpu_runtime_hdrs\",\n     srcs = [\n+        \"allocator.h\",\n         \"xla_compiled_cpu_function.h\",\n         \"//tensorflow/core/kernels:xla_cpu_runtime_hdrs\",\n         \"//tensorflow/core/platform:xla_cpu_runtime_srcs\",\n@@ -240,6 +241,7 @@ filegroup(\n filegroup(\n     name = \"xla_compiled_cpu_runtime_srcs\",\n     srcs = [\n+        \"allocator.cc\",\n         \"xla_compiled_cpu_function.cc\",\n         \"//tensorflow/core/kernels:xla_cpu_runtime_srcs\",\n         \"//tensorflow/core/platform:xla_cpu_runtime_srcs\",\n@@ -396,13 +398,27 @@ cc_library(\n # )\n # copybara:uncomment_end\n \n+cc_library(\n+    name = \"allocator\",\n+    srcs = [\"allocator.cc\"],\n+    hdrs = [\"allocator.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \"@com_google_absl//absl/base:dynamic_annotations\",\n+        \"@local_xla//xla:cpu_function_runtime\",\n+        \"@local_xla//xla/backends/cpu:alignment\",\n+    ],\n+)\n+\n cc_library(\n     name = \"xla_compiled_cpu_function\",\n     srcs = [\"xla_compiled_cpu_function.cc\"],\n     hdrs = [\"xla_compiled_cpu_function.h\"],\n     compatible_with = get_compatible_with_portable(),\n     visibility = [\"//visibility:public\"],\n     deps = [\n+        \":allocator\",\n         \"@com_google_absl//absl/log:check\",\n         \"@local_xla//xla/service:custom_call_status_internal\",\n         # Keep dependencies to a minimum here; this library is used in every AOT\n@@ -469,6 +485,7 @@ tf_cc_test(\n     name = \"cpu_function_runtime_test\",\n     srcs = [\"cpu_function_runtime_test.cc\"],\n     deps = [\n+        \":allocator\",\n         \"//tensorflow/core:framework\",\n         \"//tensorflow/core:test\",\n         \"//tensorflow/core:test_main\","
        },
        {
            "sha": "7f7c3a351bbe8714fe4f569d8731b64da7b83334",
            "filename": "tensorflow/compiler/tf2xla/allocator.cc",
            "status": "added",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fallocator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fallocator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2Fallocator.cc?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -0,0 +1,117 @@\n+/* Copyright 2025 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"tensorflow/compiler/tf2xla/allocator.h\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <cstdlib>\n+\n+#include \"absl/base/dynamic_annotations.h\"\n+#include \"xla/backends/cpu/alignment.h\"\n+#include \"xla/cpu_function_runtime.h\"\n+\n+namespace tensorflow {\n+\n+namespace {\n+// Inline memory allocation routines here, because depending on 'base' brings\n+// in libraries which use c++ streams, which adds considerable code size on\n+// android.\n+void* aligned_malloc(size_t size, int minimum_alignment) {\n+#if defined(__ANDROID__) || defined(OS_ANDROID) || defined(OS_CYGWIN)\n+  return memalign(minimum_alignment, size);\n+#elif defined(_WIN32)\n+  return _aligned_malloc(size, minimum_alignment);\n+#else  // !__ANDROID__ && !OS_ANDROID && !OS_CYGWIN\n+  void* ptr = nullptr;\n+  // posix_memalign requires that the requested alignment be at least\n+  // sizeof(void*). In this case, fall back on malloc which should return memory\n+  // aligned to at least the size of a pointer.\n+  const int required_alignment = sizeof(void*);\n+  if (minimum_alignment < required_alignment) {\n+    return malloc(size);\n+  }\n+  if (posix_memalign(&ptr, minimum_alignment, size) != 0) {\n+    return nullptr;\n+  }\n+  return ptr;\n+#endif\n+}\n+\n+void aligned_free(void* aligned_memory) {\n+#if defined(_WIN32)\n+  _aligned_free(aligned_memory);\n+#else\n+  free(aligned_memory);\n+#endif\n+}\n+\n+size_t align_to(size_t n, size_t align) {\n+  return (((n - 1) / align) + 1) * align;\n+}\n+}  // namespace\n+\n+size_t AlignedBufferBytes(\n+    const xla::cpu_function_runtime::BufferInfo* buffer_infos, size_t n,\n+    bool allocate_entry_params) {\n+  size_t total = 0;\n+  for (size_t i = 0; i < n; ++i) {\n+    bool should_allocate =\n+        buffer_infos[i].is_temp_buffer() ||\n+        (buffer_infos[i].is_entry_parameter() && allocate_entry_params);\n+\n+    if (should_allocate) {\n+      total += align_to(buffer_infos[i].size(), xla::cpu::Align());\n+    }\n+  }\n+  return total;\n+}\n+\n+void* MallocContiguousBuffers(\n+    const xla::cpu_function_runtime::BufferInfo* buffer_infos, size_t n,\n+    bool allocate_entry_params, void** bufs, bool annotate_initialized) {\n+  const size_t total =\n+      tensorflow::AlignedBufferBytes(buffer_infos, n, allocate_entry_params);\n+  void* contiguous = nullptr;\n+  if (total > 0) {\n+    contiguous = aligned_malloc(total, xla::cpu::Align());\n+    if (annotate_initialized) {\n+      // Since the memory for temp buffers is written to by JITed code, msan has\n+      // no way of knowing the memory was initialized, so explicitly mark it.\n+      ABSL_ANNOTATE_MEMORY_IS_INITIALIZED(contiguous, total);\n+    }\n+  }\n+  uintptr_t pos = reinterpret_cast<uintptr_t>(contiguous);\n+  for (size_t i = 0; i < n; ++i) {\n+    bool should_allocate =\n+        buffer_infos[i].is_temp_buffer() ||\n+        (buffer_infos[i].is_entry_parameter() && allocate_entry_params);\n+    if (should_allocate) {\n+      bufs[i] = reinterpret_cast<void*>(pos);\n+      pos += align_to(buffer_infos[i].size(), xla::cpu::Align());\n+    } else {\n+      bufs[i] = nullptr;\n+    }\n+  }\n+  return contiguous;\n+}\n+\n+void FreeContiguous(void* contiguous) {\n+  if (contiguous != nullptr) {\n+    aligned_free(contiguous);\n+  }\n+}\n+\n+}  // namespace tensorflow"
        },
        {
            "sha": "4ed60e4cb65535835e5dcb9d72e6a28592e39263",
            "filename": "tensorflow/compiler/tf2xla/allocator.h",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fallocator.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fallocator.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2Fallocator.h?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -0,0 +1,55 @@\n+/* Copyright 2025 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef TENSORFLOW_COMPILER_TF2XLA_ALLOCATOR_H_\n+#define TENSORFLOW_COMPILER_TF2XLA_ALLOCATOR_H_\n+\n+#include <cstddef>\n+\n+#include \"xla/cpu_function_runtime.h\"\n+\n+namespace tensorflow {\n+\n+// AlignedBufferBytes returns the sum of the size of each buffer in\n+// `buffer_infos`, skipping constants, on-stack buffers and, if\n+// allocate_entry_params is false, entry parameters.  There are `n` entries in\n+// `buffer_infos`.  Each buffer is aligned to Align() byte boundaries.\n+size_t AlignedBufferBytes(\n+    const xla::cpu_function_runtime::BufferInfo* buffer_infos, size_t n,\n+    bool allocate_entry_params);\n+\n+// MallocContiguousBuffers allocates buffers for use by the entry point\n+// generated by tfcompile.  There are `n` entries in `buffer_infos`.  If\n+// `annotate_initialized` is set, the allocated memory will be annotated as\n+// having been initialized - this is useful when allocating temporary buffers.\n+// If allocate_entry_params is true then allocates temp buffers and entry\n+// parameters, otherwise allocated only temp buffers.  Slots in `bufs`\n+// corresponding to unallocated buffers are set to nullptr.\n+//\n+// A single contiguous block of memory is allocated, and portions of it are\n+// parceled out into `bufs`, which must have space for `n` entries.  Returns\n+// the head of the allocated contiguous block, which should be passed to\n+// FreeContiguous when the buffers are no longer in use.\n+void* MallocContiguousBuffers(\n+    const xla::cpu_function_runtime::BufferInfo* buffer_infos, size_t n,\n+    bool allocate_entry_params, void** bufs, bool annotate_initialized);\n+\n+// FreeContiguous frees the contiguous block of memory allocated by\n+// MallocContiguousBuffers.\n+void FreeContiguous(void* contiguous);\n+\n+}  // namespace tensorflow\n+\n+#endif  // TENSORFLOW_COMPILER_TF2XLA_ALLOCATOR_H_"
        },
        {
            "sha": "6904c58489f861e2ef49492168cbf80216e92fae",
            "filename": "tensorflow/compiler/tf2xla/cpu_function_runtime_test.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 11,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fcpu_function_runtime_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fcpu_function_runtime_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2Fcpu_function_runtime_test.cc?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -15,6 +15,13 @@ limitations under the License.\n \n #include \"xla/cpu_function_runtime.h\"\n \n+#include <algorithm>\n+#include <cstddef>\n+#include <cstdint>\n+#include <iterator>\n+#include <vector>\n+\n+#include \"tensorflow/compiler/tf2xla/allocator.h\"\n #include \"xla/backends/cpu/alignment.h\"\n #include \"tensorflow/core/framework/allocator.h\"\n #include \"tensorflow/core/platform/test.h\"\n@@ -39,7 +46,7 @@ std::vector<BufferInfo> SizesToBufferInfos(const intptr_t* sizes, size_t n) {\n   std::transform(sizes, sizes + n, std::back_inserter(buffer_infos),\n                  [&](intptr_t size) {\n                    if (size == -1) {\n-                     // Use a dummy on-stack buffer allocation to indicat the\n+                     // Use a dummy on-stack buffer allocation to indicate the\n                      // the current slot does not need an allocation.\n                      int64_t on_stack_buffer_size = 4;\n                      return BufferInfo::MakeOnStackBuffer(on_stack_buffer_size);\n@@ -53,16 +60,16 @@ std::vector<BufferInfo> SizesToBufferInfos(const intptr_t* sizes, size_t n) {\n \n size_t AlignedBufferBytesFromSizes(const intptr_t* sizes, size_t n) {\n   std::vector<BufferInfo> buffer_infos = SizesToBufferInfos(sizes, n);\n-  return AlignedBufferBytes(buffer_infos.data(), n,\n-                            /*allocate_entry_params=*/false);\n+  return tensorflow::AlignedBufferBytes(buffer_infos.data(), n,\n+                                        /*allocate_entry_params=*/false);\n }\n \n void* MallocContiguousBuffersFromSizes(const intptr_t* sizes, size_t n,\n                                        void** bufs, bool annotate_initialized) {\n   std::vector<BufferInfo> buffer_infos = SizesToBufferInfos(sizes, n);\n-  return MallocContiguousBuffers(buffer_infos.data(), n,\n-                                 /*allocate_entry_params=*/false, bufs,\n-                                 annotate_initialized);\n+  return tensorflow::MallocContiguousBuffers(buffer_infos.data(), n,\n+                                             /*allocate_entry_params=*/false,\n+                                             bufs, annotate_initialized);\n }\n \n TEST(XlaCompiledCpuFunctionTest, AlignedBufferBytes) {\n@@ -93,15 +100,15 @@ TEST(XlaCompiledCpuFunctionTest, MallocFreeContiguousBuffers) {\n   // Test empty sizes.\n   void* base = MallocContiguousBuffersFromSizes(nullptr, 0, nullptr, false);\n   EXPECT_EQ(base, nullptr);\n-  xla::cpu_function_runtime::FreeContiguous(base);\n+  FreeContiguous(base);\n \n   // Test non-empty sizes with 0 sum.\n   static constexpr intptr_t sizesA[1] = {-1};\n   void* bufA[1];\n   base = MallocContiguousBuffersFromSizes(sizesA, 1, bufA, false);\n   EXPECT_EQ(base, nullptr);\n   EXPECT_EQ(bufA[0], nullptr);\n-  xla::cpu_function_runtime::FreeContiguous(base);\n+  FreeContiguous(base);\n \n   // Test non-empty sizes with non-0 sum.\n   static constexpr intptr_t sizesB[1] = {3};\n@@ -113,7 +120,7 @@ TEST(XlaCompiledCpuFunctionTest, MallocFreeContiguousBuffers) {\n   bufB0_bytes[0] = 'A';\n   bufB0_bytes[1] = 'B';\n   bufB0_bytes[2] = 'C';\n-  xla::cpu_function_runtime::FreeContiguous(base);\n+  FreeContiguous(base);\n \n   // Test non-empty sizes with non-0 sum, and annotate_initialized.\n   static constexpr intptr_t sizesC[1] = {3};\n@@ -125,7 +132,7 @@ TEST(XlaCompiledCpuFunctionTest, MallocFreeContiguousBuffers) {\n   bufC0_bytes[0] = 'A';\n   bufC0_bytes[1] = 'B';\n   bufC0_bytes[2] = 'C';\n-  xla::cpu_function_runtime::FreeContiguous(base);\n+  FreeContiguous(base);\n \n   // Test mixed sizes.\n   static constexpr intptr_t sizesD[7] = {1, -1, 32, -1, 64, 2, 3};\n@@ -148,7 +155,7 @@ TEST(XlaCompiledCpuFunctionTest, MallocFreeContiguousBuffers) {\n       }\n     }\n   }\n-  xla::cpu_function_runtime::FreeContiguous(base);\n+  FreeContiguous(base);\n }\n \n void CheckRoundTripIsOk(const BufferInfo& buffer_info) {"
        },
        {
            "sha": "4603bbf119a8bfeae9fa32799fb45cb199d55993",
            "filename": "tensorflow/compiler/tf2xla/xla_compiled_cpu_function.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fxla_compiled_cpu_function.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/463b01088b1407c689254a9973fdb5cecf23af55/tensorflow%2Fcompiler%2Ftf2xla%2Fxla_compiled_cpu_function.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2Fxla_compiled_cpu_function.cc?ref=463b01088b1407c689254a9973fdb5cecf23af55",
            "patch": "@@ -25,6 +25,7 @@ limitations under the License.\n \n #include \"absl/log/check.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"tensorflow/compiler/tf2xla/allocator.h\"\n #include \"xla/backends/cpu/runtime/rng_state_lib.h\"\n #include \"xla/cpu_function_runtime.h\"\n #include \"tensorflow/core/platform/types.h\"\n@@ -70,7 +71,7 @@ XlaCompiledCpuFunction::XlaCompiledCpuFunction(const StaticData& static_data,\n   bool allocate_entry_params =\n       alloc_mode == AllocMode::ARGS_VARIABLES_RESULTS_PROFILES_AND_TEMPS;\n   // Allocate arg and temp buffers.\n-  alloc_buffer_table_ = xla::cpu_function_runtime::MallocContiguousBuffers(\n+  alloc_buffer_table_ = tensorflow::MallocContiguousBuffers(\n       static_data.buffer_infos_, static_data.num_buffers_,\n       /*allocate_entry_params=*/allocate_entry_params, buffer_table_,\n       /*annotate_initialized=*/true);\n@@ -118,7 +119,7 @@ bool XlaCompiledCpuFunction::Run() {\n }\n \n XlaCompiledCpuFunction::~XlaCompiledCpuFunction() {\n-  xla::cpu_function_runtime::FreeContiguous(alloc_buffer_table_);\n+  FreeContiguous(alloc_buffer_table_);\n   delete[] buffer_table_;\n   delete[] profile_counters_;\n }"
        }
    ],
    "stats": {
        "total": 241,
        "additions": 219,
        "deletions": 22
    }
}