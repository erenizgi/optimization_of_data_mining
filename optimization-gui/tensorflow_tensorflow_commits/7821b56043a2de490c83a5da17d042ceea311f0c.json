{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 811717466",
    "sha": "7821b56043a2de490c83a5da17d042ceea311f0c",
    "files": [
        {
            "sha": "d7df8c42dde196451d97d35bcb9befda9021f8ba",
            "filename": "tensorflow/python/util/nest.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 14,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7821b56043a2de490c83a5da17d042ceea311f0c/tensorflow%2Fpython%2Futil%2Fnest.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7821b56043a2de490c83a5da17d042ceea311f0c/tensorflow%2Fpython%2Futil%2Fnest.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Futil%2Fnest.cc?ref=7821b56043a2de490c83a5da17d042ceea311f0c",
            "patch": "@@ -44,7 +44,7 @@ std::string PyObject_ToString(PyObject* o, int length = -1) {\n     return str;\n   }\n   absl::string_view str_piece(str);\n-  return tensorflow::strings::StrCat(str_piece.substr(length), \"...\");\n+  return absl::StrCat(str_piece.substr(length), \"...\");\n }\n \n // Gets a list of keys from a dict or mapping type object.\n@@ -66,9 +66,8 @@ PyObject* GetKeysFromDictOrMapping(PyObject* o) {\n     auto* o_type = Py_TYPE(o);\n     PyErr_SetString(\n         PyExc_TypeError,\n-        tensorflow::strings::StrCat(\n-            \"Expecting a type compatible with dict or mapping, got '\",\n-            o_type->tp_name, \"'\")\n+        absl::StrCat(\"Expecting a type compatible with dict or mapping, got '\",\n+                     o_type->tp_name, \"'\")\n             .c_str());\n     return nullptr;\n   }\n@@ -78,12 +77,12 @@ PyObject* GetKeysFromDictOrMapping(PyObject* o) {\n \n PyObject* FlattenDictItems(PyObject* dict) {\n   if (!PyDict_Check(dict) && !swig::IsMapping(dict)) {\n-    PyErr_SetString(PyExc_TypeError,\n-                    tensorflow::strings::StrCat(\n-                        \"FlattenDictItems: 'dict' must be a dictionary or \",\n-                        \"collection.Mapping type object, instead of '\",\n-                        Py_TYPE(dict)->tp_name, \"'.\")\n-                        .c_str());\n+    PyErr_SetString(\n+        PyExc_TypeError,\n+        absl::StrCat(\"FlattenDictItems: 'dict' must be a dictionary or \",\n+                     \"collection.Mapping type object, instead of '\",\n+                     Py_TYPE(dict)->tp_name, \"'.\")\n+            .c_str());\n     return nullptr;\n   }\n   PyObject* flat_dictionary = PyDict_New();\n@@ -117,7 +116,7 @@ PyObject* FlattenDictItems(PyObject* dict) {\n         if (PyDict_GetItem(flat_dictionary, flat_key) != nullptr) {\n           PyErr_SetString(\n               PyExc_ValueError,\n-              tensorflow::strings::StrCat(\n+              absl::StrCat(\n                   \"Cannot flatten dict because this key is not unique: \",\n                   PyObject_ToString(flat_key))\n                   .c_str());\n@@ -130,9 +129,8 @@ PyObject* FlattenDictItems(PyObject* dict) {\n       if (PyDict_GetItem(flat_dictionary, key) != nullptr) {\n         PyErr_SetString(\n             PyExc_ValueError,\n-            tensorflow::strings::StrCat(\n-                \"Cannot flatten dict because this key is not unique: \",\n-                PyObject_ToString(key))\n+            absl::StrCat(\"Cannot flatten dict because this key is not unique: \",\n+                         PyObject_ToString(key))\n                 .c_str());\n         Py_DecRef(flat_dictionary);\n         return nullptr;"
        },
        {
            "sha": "cf641b97fa6085fb432b400b4fe1cbdf7bcff128",
            "filename": "tensorflow/python/util/util.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 17,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7821b56043a2de490c83a5da17d042ceea311f0c/tensorflow%2Fpython%2Futil%2Futil.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7821b56043a2de490c83a5da17d042ceea311f0c/tensorflow%2Fpython%2Futil%2Futil.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Futil%2Futil.cc?ref=7821b56043a2de490c83a5da17d042ceea311f0c",
            "patch": "@@ -66,10 +66,9 @@ PyObject* GetRegisteredPyObject(const string& name) {\n   const auto* m = RegisteredPyObjectMap();\n   auto it = m->find(name);\n   if (it == m->end()) {\n-    PyErr_SetString(PyExc_TypeError,\n-                    tensorflow::strings::StrCat(\"No object with name \", name,\n-                                                \" has been registered.\")\n-                        .c_str());\n+    PyErr_SetString(PyExc_TypeError, absl::StrCat(\"No object with name \", name,\n+                                                  \" has been registered.\")\n+                                         .c_str());\n     return nullptr;\n   }\n   return it->second;\n@@ -84,18 +83,17 @@ PyObject* RegisterPyObject(PyObject* name, PyObject* value) {\n     key = PyUnicode_AsUTF8(name);\n #endif\n   } else {\n-    PyErr_SetString(PyExc_TypeError, tensorflow::strings::StrCat(\n-                                         \"Expected name to be a str, got\",\n-                                         PyObjectToString(name))\n-                                         .c_str());\n+    PyErr_SetString(\n+        PyExc_TypeError,\n+        absl::StrCat(\"Expected name to be a str, got\", PyObjectToString(name))\n+            .c_str());\n     return nullptr;\n   }\n \n   auto* m = RegisteredPyObjectMap();\n   if (m->find(key) != m->end()) {\n-    PyErr_SetString(PyExc_TypeError, tensorflow::strings::StrCat(\n-                                         \"Value already registered for \", key)\n-                                         .c_str());\n+    PyErr_SetString(PyExc_TypeError,\n+                    absl::StrCat(\"Value already registered for \", key).c_str());\n     return nullptr;\n   }\n \n@@ -150,7 +148,7 @@ string PyObjectToString(PyObject* o) {\n     string s(PyUnicode_AsUTF8(str));\n #endif\n     Py_DECREF(str);\n-    return tensorflow::strings::StrCat(\"type=\", GetClassName(o), \" str=\", s);\n+    return absl::StrCat(\"type=\", GetClassName(o), \" str=\", s);\n   } else {\n     return \"<failed to execute str() on object>\";\n   }\n@@ -806,7 +804,7 @@ void SetDifferentKeysError(PyObject* dict1, PyObject* dict2, string* error_msg,\n     return;\n   }\n   *is_type_error = false;\n-  *error_msg = tensorflow::strings::StrCat(\n+  *error_msg = absl::StrCat(\n       \"The two dictionaries don't have the same set of keys. \"\n       \"First structure has keys \",\n       PyObjectToString(k1.get()), \", while second structure has keys \",\n@@ -987,10 +985,9 @@ bool AssertSameStructureHelper(\n     }\n     if (struct_compatible.get() == Py_None) {\n       *is_type_error = false;\n-      *error_msg = tensorflow::strings::StrCat(\n-          \"Incompatible CompositeTensor TypeSpecs: \",\n-          PyObjectToString(type_spec_1), \" vs. \",\n-          PyObjectToString(type_spec_2));\n+      *error_msg = absl::StrCat(\"Incompatible CompositeTensor TypeSpecs: \",\n+                                PyObjectToString(type_spec_1), \" vs. \",\n+                                PyObjectToString(type_spec_2));\n       return true;\n     }\n   }"
        }
    ],
    "stats": {
        "total": 57,
        "additions": 26,
        "deletions": 31
    }
}