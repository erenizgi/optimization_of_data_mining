{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809663962",
    "sha": "0c3f75e908b9e76465d96ad2058dadaeeb70187c",
    "files": [
        {
            "sha": "d65de0654f9ed0cbab85261459b7a13031207b7e",
            "filename": "third_party/xla/xla/pjrt/distributed/client_server_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0c3f75e908b9e76465d96ad2058dadaeeb70187c/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient_server_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0c3f75e908b9e76465d96ad2058dadaeeb70187c/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient_server_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient_server_test.cc?ref=0c3f75e908b9e76465d96ad2058dadaeeb70187c",
            "patch": "@@ -126,15 +126,15 @@ TEST_F(ClientServerTest, ConnectAndShutdownAreBarriers) {\n       return connect_count == node_id;\n     };\n     {\n-      absl::MutexLock lock(&mu);\n+      absl::MutexLock lock(mu);\n       mu.Await(absl::Condition(&my_connect_turn));\n       ++connect_count;\n     }\n     TF_RETURN_IF_ERROR(client->Connect());\n     // Verify that all of the threads have called Connect() by the time we get\n     // here.\n     {\n-      absl::MutexLock lock(&mu);\n+      absl::MutexLock lock(mu);\n       TF_RET_CHECK(connect_count == num_nodes);\n     }\n \n@@ -144,13 +144,13 @@ TEST_F(ClientServerTest, ConnectAndShutdownAreBarriers) {\n       return shutdown_count == node_id;\n     };\n     {\n-      absl::MutexLock lock(&mu);\n+      absl::MutexLock lock(mu);\n       mu.Await(absl::Condition(&my_shutdown_turn));\n       ++shutdown_count;\n     }\n     TF_RETURN_IF_ERROR(client->Shutdown());\n     {\n-      absl::MutexLock lock(&mu);\n+      absl::MutexLock lock(mu);\n       TF_RET_CHECK(shutdown_count == num_nodes);\n     }\n "
        },
        {
            "sha": "78565e01a5979f6aacefe8c2d4987d702c91a14f",
            "filename": "third_party/xla/xla/pjrt/distributed/in_memory_key_value_store.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0c3f75e908b9e76465d96ad2058dadaeeb70187c/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fin_memory_key_value_store.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0c3f75e908b9e76465d96ad2058dadaeeb70187c/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fin_memory_key_value_store.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fin_memory_key_value_store.cc?ref=0c3f75e908b9e76465d96ad2058dadaeeb70187c",
            "patch": "@@ -28,7 +28,7 @@ namespace xla {\n \n absl::StatusOr<std::string> InMemoryKeyValueStore::Get(absl::string_view key,\n                                                        absl::Duration timeout) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto cond = [&]() {\n     mu_.AssertHeld();\n     return kv_store_.find(key) != kv_store_.end();\n@@ -43,7 +43,7 @@ absl::StatusOr<std::string> InMemoryKeyValueStore::Get(absl::string_view key,\n \n absl::StatusOr<std::string> InMemoryKeyValueStore::TryGet(\n     absl::string_view key) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto it = kv_store_.find(key);\n   if (it == kv_store_.end()) {\n     return absl::NotFoundError(\n@@ -54,7 +54,7 @@ absl::StatusOr<std::string> InMemoryKeyValueStore::TryGet(\n \n absl::Status InMemoryKeyValueStore::Set(absl::string_view key,\n                                         absl::string_view value) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (!allow_overwrite_) {\n     if (kv_store_.contains(key)) {\n       return absl::AlreadyExistsError("
        },
        {
            "sha": "09ae283e73e35ee92c5ec6dc703534503caf1a56",
            "filename": "third_party/xla/xla/pjrt/distributed/topology_util.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0c3f75e908b9e76465d96ad2058dadaeeb70187c/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Ftopology_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0c3f75e908b9e76465d96ad2058dadaeeb70187c/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Ftopology_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Ftopology_util.cc?ref=0c3f75e908b9e76465d96ad2058dadaeeb70187c",
            "patch": "@@ -136,7 +136,7 @@ static absl::StatusOr<std::vector<LocalTopologyProto>> GetAllLocalTopologies(\n       absl::StatusOr<std::string> local_topology_str =\n           kv_store->Get(GetLocalTopologyKey(platform, i), timeout);\n       {\n-        absl::MutexLock lock(&mu);\n+        absl::MutexLock lock(mu);\n         local_topology_strs[i] = local_topology_str;\n       }\n       blocking_counter.DecrementCount();"
        }
    ],
    "stats": {
        "total": 16,
        "additions": 8,
        "deletions": 8
    }
}