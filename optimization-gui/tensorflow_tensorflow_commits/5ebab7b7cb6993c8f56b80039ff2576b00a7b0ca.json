{
    "author": "emilyfertig",
    "message": "[PJRT] Add tests for the PJRT C API cross-host transfer extension.\n\nAlso moves `CppCrossHostRecvNotifierToC` into the extension so it can be imported by the tests without circular dependencies.\n\nPiperOrigin-RevId: 834569289",
    "sha": "5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca",
    "files": [
        {
            "sha": "f8fbe8eb9e683f7321436f99c84ac05a8ae0553f",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 44,
            "changes": 45,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca",
            "patch": "@@ -965,49 +965,6 @@ absl::Status PjRtCApiClient::DmaUnmap(void* data) {\n   return absl::OkStatus();\n }\n \n-PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n-    const PJRT_Api* c_api, xla::PjRtCrossHostRecvNotifier cpp_notifier) {\n-  auto notifier_function = new PjRtCApiClient::CrossHostRecvNotifierFunction(\n-      [cpp_notifier = std::move(cpp_notifier), c_api](\n-          PJRT_Error* error, const char** serialized_descriptors,\n-          size_t* descriptors_sizes, size_t num_descriptors) {\n-        if (error != nullptr) {\n-          absl::Status state = ::pjrt::PjrtErrorToStatus(error, c_api);\n-          return cpp_notifier(std::move(state));\n-        }\n-        xla::PjRtCrossHostRecvState state;\n-        state.descriptors.reserve(num_descriptors);\n-        for (int i = 0; i < num_descriptors; ++i) {\n-          xla::PjRtCrossHostRecvDescriptors descriptors;\n-          descriptors.serialized_descriptors.push_back(\n-              std::string(serialized_descriptors[i], descriptors_sizes[i]));\n-          state.descriptors.push_back(std::move(descriptors));\n-        }\n-\n-        // TODO(emilyaf): Support cancellation.\n-        xla::PjRtCrossHostSendCancelNotifier cancel_notifier =\n-            [](absl::string_view, absl::Status,\n-               std::function<void(absl::Status)>) {\n-              LOG(FATAL) << \"MakeCrossHostReceiveBuffers: Cancellation is not \"\n-                            \"supported in PJRT C API.\";\n-            };\n-        state.cancel_notifier = cancel_notifier;\n-        return cpp_notifier(std::move(state));\n-      });\n-  return PJRT_Transfers_CrossHostRecvNotifierInfo{\n-      /*user_arg=*/notifier_function,\n-      /*notifier=*/\n-      [](PJRT_Error* error, const char** serialized_descriptors,\n-         size_t* descriptors_sizes, size_t num_descriptors, void* user_arg) {\n-        PjRtCApiClient::CrossHostRecvNotifierFunction* notifier_fn =\n-            reinterpret_cast<PjRtCApiClient::CrossHostRecvNotifierFunction*>(\n-                user_arg);\n-        (*notifier_fn)(error, serialized_descriptors, descriptors_sizes,\n-                       num_descriptors);\n-        delete notifier_fn;\n-      }};\n-}\n-\n // Helper struct and method used to serialize shapes past the C API boundary.\n struct ShapesInfo {\n   std::vector<size_t> shape_num_dims;\n@@ -1088,7 +1045,7 @@ PjRtCApiClient::MakeCrossHostReceiveBuffers(\n   args.element_types = shapes_info.element_type_list.data();\n   args.layouts = shapes_info.layout_list.data();\n \n-  args.notifier = CppCrossHostRecvNotifierToC(c_api, std::move(notifier));\n+  args.notifier = pjrt::CppCrossHostRecvNotifierToC(c_api, std::move(notifier));\n   args.device = tensorflow::down_cast<PjRtCApiDevice*>(device)->c_device();\n \n   std::vector<PJRT_Buffer*> temp_buffers(shapes.size());"
        },
        {
            "sha": "6ac5c74070fa68105c29c5b6945379f226c6d96d",
            "filename": "third_party/xla/xla/pjrt/extensions/cross_host_transfers/BUILD",
            "status": "modified",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2FBUILD?ref=5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca",
            "patch": "@@ -1,3 +1,8 @@\n+load(\"//xla/tests:build_defs.bzl\", \"xla_test\")\n+load(\n+    \"//xla/tsl:tsl.bzl\",\n+    \"if_google\",\n+)\n load(\"//xla/tsl/platform:rules_cc.bzl\", \"cc_library\")\n \n package(\n@@ -17,8 +22,59 @@ cc_library(\n         \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n         \"//xla/pjrt/c:pjrt_c_api_helpers\",\n         \"//xla/pjrt/c:pjrt_c_api_wrapper_impl\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n+    ],\n+)\n+\n+xla_test(\n+    name = \"pjrt_c_api_cross_host_transfers_extension_gpu_test\",\n+    srcs = [\"pjrt_c_api_cross_host_transfers_extension_gpu_test.cc\"],\n+    backends = [\"gpu\"],\n+    tags = if_google([\n+        \"config-cuda-only\",\n+    ]) + [\n+        \"multi_gpu\",\n+        \"no_oss\",\n+    ],\n+    deps = [\n+        \":pjrt_c_api_cross_host_transfer_extension\",\n+        \"//xla:debug_options_flags\",\n+        \"//xla:future\",\n+        \"//xla:literal\",\n+        \"//xla:literal_util\",\n+        \"//xla:shape_util\",\n+        \"//xla:status_macros\",\n+        \"//xla/client:client_library\",\n+        \"//xla/ffi/api:ffi\",\n+        \"//xla/pjrt:pjrt_client\",\n+        \"//xla/pjrt:pjrt_common\",\n+        \"//xla/pjrt/c:pjrt_c_api_gpu\",\n+        \"//xla/pjrt/c:pjrt_c_api_hdrs\",\n+        \"//xla/pjrt/c:pjrt_c_api_helpers\",\n+        \"//xla/pjrt/c:pjrt_c_api_wrapper_impl\",\n+        \"//xla/pjrt/distributed\",\n+        \"//xla/pjrt/distributed:client\",\n+        \"//xla/pjrt/distributed:in_memory_key_value_store\",\n+        \"//xla/pjrt/distributed:service\",\n+        \"//xla/tests:literal_test_util\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:status\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:subprocess\",\n+        \"//xla/tsl/util:command_line_flags\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:str_format\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/time\",\n         \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest\",\n     ],\n )"
        },
        {
            "sha": "4bded1c895c50af70bbf977c176b6b22b4b5de01",
            "filename": "third_party/xla/xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.cc?ref=5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca",
            "patch": "@@ -16,13 +16,16 @@ limitations under the License.\n #include \"xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.h\"\n \n #include <cstddef>\n+#include <functional>\n #include <memory>\n #include <string>\n #include <utility>\n #include <vector>\n \n #include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/future.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n@@ -129,6 +132,50 @@ static xla::PjRtCrossHostRecvNotifier CCrossHostRecvNotifierToCpp(\n }\n }  // namespace\n \n+PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n+    const PJRT_Api* c_api, xla::PjRtCrossHostRecvNotifier cpp_notifier) {\n+  using CrossHostRecvNotifierFunction =\n+      std::function<void(PJRT_Error*, const char**, size_t*, size_t)>;\n+  auto notifier_function = new CrossHostRecvNotifierFunction(\n+      [cpp_notifier = std::move(cpp_notifier), c_api](\n+          PJRT_Error* error, const char** serialized_descriptors,\n+          size_t* descriptors_sizes, size_t num_descriptors) {\n+        if (error != nullptr) {\n+          absl::Status state = ::pjrt::PjrtErrorToStatus(error, c_api);\n+          return cpp_notifier(std::move(state));\n+        }\n+        xla::PjRtCrossHostRecvState state;\n+        state.descriptors.reserve(num_descriptors);\n+        for (int i = 0; i < num_descriptors; ++i) {\n+          xla::PjRtCrossHostRecvDescriptors descriptors;\n+          descriptors.serialized_descriptors.push_back(\n+              std::string(serialized_descriptors[i], descriptors_sizes[i]));\n+          state.descriptors.push_back(std::move(descriptors));\n+        }\n+\n+        // TODO(emilyaf): Support cancellation.\n+        xla::PjRtCrossHostSendCancelNotifier cancel_notifier =\n+            [](absl::string_view, absl::Status,\n+               std::function<void(absl::Status)>) {\n+              LOG(FATAL) << \"MakeCrossHostReceiveBuffers: Cancellation is not \"\n+                            \"supported in PJRT C API.\";\n+            };\n+        state.cancel_notifier = cancel_notifier;\n+        return cpp_notifier(std::move(state));\n+      });\n+  return PJRT_Transfers_CrossHostRecvNotifierInfo{\n+      /*user_arg=*/notifier_function,\n+      /*notifier=*/\n+      [](PJRT_Error* error, const char** serialized_descriptors,\n+         size_t* descriptors_sizes, size_t num_descriptors, void* user_arg) {\n+        CrossHostRecvNotifierFunction* notifier_fn =\n+            reinterpret_cast<CrossHostRecvNotifierFunction*>(user_arg);\n+        (*notifier_fn)(error, serialized_descriptors, descriptors_sizes,\n+                       num_descriptors);\n+        delete notifier_fn;\n+      }};\n+}\n+\n PJRT_Error* PJRT_Transfers_PJRT_Client_MakeCrossHostReceiveBuffers(\n     PJRT_Transfers_PJRT_Client_MakeCrossHostReceiveBuffers_Args* args) {\n   PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual("
        },
        {
            "sha": "3065dc9d32c0422ec51af364fa9286d9240d6470",
            "filename": "third_party/xla/xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension.h?ref=5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca",
            "patch": "@@ -151,6 +151,8 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_CrossHostTransfers_Extension,\n namespace pjrt {\n PJRT_CrossHostTransfers_Extension CreateCrossHostTransfersExtension(\n     PJRT_Extension_Base* next = nullptr);\n+PJRT_Transfers_CrossHostRecvNotifierInfo CppCrossHostRecvNotifierToC(\n+    const PJRT_Api* c_api, xla::PjRtCrossHostRecvNotifier cpp_notifier);\n }  // namespace pjrt\n \n #endif  // XLA_PJRT_EXTENSIONS_CROSS_HOST_TRANSFERS_PJRT_C_API_CROSS_HOST_TRANSFERS_EXTENSION_H_"
        },
        {
            "sha": "b97de53bf04854a350ff9196d51aaa0c5ab82888",
            "filename": "third_party/xla/xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension_gpu_test.cc",
            "status": "added",
            "additions": 369,
            "deletions": 0,
            "changes": 369,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension_gpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension_gpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fextensions%2Fcross_host_transfers%2Fpjrt_c_api_cross_host_transfers_extension_gpu_test.cc?ref=5ebab7b7cb6993c8f56b80039ff2576b00a7b0ca",
            "patch": "@@ -0,0 +1,369 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <cstring>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/time/time.h\"\n+#include \"absl/types/span.h\"\n+#include \"xla/client/client_library.h\"\n+#include \"xla/debug_options_flags.h\"\n+#include \"xla/ffi/api/ffi.h\"\n+#include \"xla/future.h\"\n+#include \"xla/literal.h\"\n+#include \"xla/literal_util.h\"\n+#include \"xla/pjrt/c/pjrt_c_api.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_gpu.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n+#include \"xla/pjrt/c/pjrt_c_api_wrapper_impl.h\"\n+#include \"xla/pjrt/distributed/client.h\"\n+#include \"xla/pjrt/distributed/distributed.h\"\n+#include \"xla/pjrt/distributed/service.h\"\n+#include \"xla/pjrt/extensions/cross_host_transfers/pjrt_c_api_cross_host_transfers_extension.h\"\n+#include \"xla/pjrt/pjrt_client.h\"\n+#include \"xla/pjrt/pjrt_common.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/shape_util.h\"\n+#include \"xla/status_macros.h\"\n+#include \"xla/tests/literal_test_util.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/status.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/subprocess.h\"\n+#include \"xla/tsl/util/command_line_flags.h\"\n+\n+namespace pjrt {\n+namespace {\n+\n+static std::string SuccessfulCrossHostTransferTestName(\n+    const ::testing::TestParamInfo<int>& info) {\n+  return absl::StrFormat(\"num_arrays_%d\", info.param);\n+}\n+\n+absl::StatusOr<PJRT_Client_Create_Args> BuildCreateArg(\n+    ::pjrt::PJRT_KeyValueCallbackData* kv_callback_data,\n+    const std::vector<PJRT_NamedValue>& c_options) {\n+  PJRT_Client_Create_Args args;\n+  args.struct_size = PJRT_Client_Create_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.create_options = c_options.data();\n+  args.num_options = c_options.size();\n+  args.kv_get_callback = kv_callback_data->c_kv_get;\n+  args.kv_get_user_arg = &kv_callback_data->kv_get_c_func;\n+  args.kv_put_callback = kv_callback_data->c_kv_put;\n+  args.kv_put_user_arg = &kv_callback_data->kv_put_c_func;\n+  args.kv_try_get_user_arg = &kv_callback_data->kv_try_get_c_func;\n+  args.kv_try_get_callback = kv_callback_data->c_kv_try_get;\n+  args.client = nullptr;\n+  return args;\n+}\n+\n+absl::Span<PJRT_Device* const> GetClientAddressableDevices(\n+    PJRT_Client* client, const PJRT_Api* api) {\n+  PJRT_Client_AddressableDevices_Args addr_args;\n+  addr_args.struct_size = PJRT_Client_AddressableDevices_Args_STRUCT_SIZE;\n+  addr_args.extension_start = nullptr;\n+  addr_args.client = client;\n+  PJRT_Error* error = api->PJRT_Client_AddressableDevices(&addr_args);\n+  CHECK(error == nullptr);\n+  return absl::MakeSpan(addr_args.addressable_devices,\n+                        addr_args.num_addressable_devices);\n+}\n+\n+class SuccessfulCrossHostTransferTest : public ::testing::TestWithParam<int> {};\n+\n+TEST_P(SuccessfulCrossHostTransferTest, SuccessfulCrossHostTransfer) {\n+  int num_arrays = GetParam();\n+\n+  tsl::SubProcess sender;\n+  tsl::SubProcess receiver;\n+  absl::string_view log_dir = std::getenv(\"TEST_UNDECLARED_OUTPUTS_DIR\");\n+\n+  std::vector<std::string> sender_argv;\n+  sender_argv.push_back(\"successful_cross_host_transfer_test\");\n+  sender_argv.push_back(\"--cross_host_test_role=sender\");\n+  sender_argv.push_back(absl::StrFormat(\"--num_arrays=%d\", num_arrays));\n+  sender_argv.push_back(absl::StrFormat(\"--log_dir=%s\", log_dir));\n+\n+  std::vector<std::string> receiver_argv;\n+  receiver_argv.push_back(\"successful_cross_host_transfer_test\");\n+  receiver_argv.push_back(\"--cross_host_test_role=receiver\");\n+  receiver_argv.push_back(absl::StrFormat(\"--num_arrays=%d\", num_arrays));\n+  receiver_argv.push_back(absl::StrFormat(\"--log_dir=%s\", log_dir));\n+\n+  sender.SetProgram(\"/proc/self/exe\", sender_argv);\n+  sender.SetChannelAction(tsl::CHAN_STDOUT, tsl::ACTION_PIPE);\n+  sender.SetChannelAction(tsl::CHAN_STDERR, tsl::ACTION_PIPE);\n+\n+  receiver.SetProgram(\"/proc/self/exe\", receiver_argv);\n+  receiver.SetChannelAction(tsl::CHAN_STDOUT, tsl::ACTION_PIPE);\n+  receiver.SetChannelAction(tsl::CHAN_STDERR, tsl::ACTION_PIPE);\n+\n+  ASSERT_TRUE(receiver.Start());\n+  ASSERT_TRUE(sender.Start());\n+\n+  std::string sender_stdout, sender_stderr;\n+  std::string receiver_stdout, receiver_stderr;\n+\n+  int sender_status =\n+      sender.Communicate(nullptr, &sender_stdout, &sender_stderr);\n+  int receiver_status =\n+      receiver.Communicate(nullptr, &receiver_stdout, &receiver_stderr);\n+\n+  EXPECT_EQ(sender_status, 0) << \"sender stdout:\\n\"\n+                              << sender_stdout << \"\\nsender stderr:\\n\"\n+                              << sender_stderr;\n+  EXPECT_EQ(receiver_status, 0) << \"receiver stdout:\\n\"\n+                                << receiver_stdout << \"\\nreceiver stderr:\\n\"\n+                                << receiver_stderr;\n+}\n+\n+INSTANTIATE_TEST_SUITE_P(SuccessfulCrossHostTransfer,\n+                         SuccessfulCrossHostTransferTest,\n+                         ::testing::ValuesIn({1, 2, 3}),\n+                         SuccessfulCrossHostTransferTestName);\n+\n+absl::Status SuccessfulCrossHostTransferTestBody(bool is_sender,\n+                                                 int num_arrays) {\n+  std::string log_prefix = is_sender ? \"sender\" : \"receiver\";\n+\n+  // Sender creates a coordination service on so both processes can find each\n+  // other via the distributed runtime (port chosen arbitrarily).\n+  std::unique_ptr<xla::DistributedRuntimeService> service;\n+  if (is_sender) {\n+    TF_ASSIGN_OR_RETURN(\n+        service, xla::GetDistributedRuntimeService(\n+                     \"127.0.0.1:12347\",\n+                     xla::CoordinationServiceImpl::Options{/*num_nodes=*/2}));\n+  }\n+\n+  // Connect to the coordination service.\n+  int32_t node_id = is_sender ? 0 : 1;\n+  xla::DistributedRuntimeClient::Options distributed_options;\n+  distributed_options.node_id = node_id;\n+  distributed_options.init_timeout = absl::Seconds(120);\n+  auto distributed_client =\n+      GetDistributedRuntimeClient(\"127.0.0.1:12347\", distributed_options);\n+  TF_QCHECK_OK(distributed_client->Connect());\n+\n+  auto kv_store = xla::GetDistributedKeyValueStore(distributed_client, \"foo\");\n+  std::shared_ptr<::pjrt::PJRT_KeyValueCallbackData> kv_callback_data =\n+      ::pjrt::ConvertToCKeyValueCallbacks(kv_store);\n+  xla::ClientLibrary::DestroyLocalInstances();\n+\n+  auto api = GetPjrtApi();\n+  PJRT_CrossHostTransfers_Extension* cross_host_transfers_extension =\n+      pjrt::FindExtension<PJRT_CrossHostTransfers_Extension>(\n+          api, PJRT_Extension_Type::PJRT_Extension_Type_CrossHostTransfers);\n+  CHECK_NE(cross_host_transfers_extension, nullptr);\n+  CHECK_NE(cross_host_transfers_extension\n+               ->PJRT_Transfers_PJRT_Buffer_CopyToRemoteDevice,\n+           nullptr);\n+\n+  // Create the GPU client.\n+  absl::flat_hash_map<std::string, xla::PjRtValueType> options = {\n+      {\"num_nodes\", static_cast<int64_t>(2)},\n+      {\"node_id\", static_cast<int64_t>(node_id)},\n+      {\"visible_devices\", std::vector<int64_t>({node_id})}};\n+  TF_ASSIGN_OR_RETURN(std::vector<PJRT_NamedValue> c_options,\n+                      ::pjrt::ConvertToPjRtNamedValueList(options));\n+  TF_ASSIGN_OR_RETURN(PJRT_Client_Create_Args create_arg,\n+                      BuildCreateArg(kv_callback_data.get(), c_options));\n+  std::unique_ptr<PJRT_Error, ::pjrt::PJRT_ErrorDeleter> error(\n+      api->PJRT_Client_Create(&create_arg), ::pjrt::MakeErrorDeleter(api));\n+  if (error != nullptr) {\n+    return error->status;\n+  }\n+  std::unique_ptr<PJRT_Client, ::pjrt::PJRT_ClientDeleter> client_deleter(\n+      create_arg.client, ::pjrt::MakeClientDeleter(api));\n+\n+  std::vector<int64_t> shape = {2, 3};\n+  xla::Shape xla_shape =\n+      xla::ShapeUtil::MakeShape(xla::F32, /*dimensions=*/shape);\n+\n+  // Sender logic.\n+  if (is_sender) {\n+    std::vector<PJRT_Buffer*> raw_buffers;\n+    std::vector<xla::PjRtGlobalDeviceId> dst_device_ids;\n+    std::vector<xla::CrossHostTransferKey> transfer_keys;\n+    for (int i = 0; i < num_arrays; ++i) {\n+      // Create buffers to send.\n+      std::vector<float> data = {1, 2, 3, 4, 5, 6 * static_cast<float>(i)};\n+      PJRT_Client_BufferFromHostBuffer_Args args;\n+      args.struct_size = PJRT_Client_BufferFromHostBuffer_Args_STRUCT_SIZE;\n+      args.extension_start = nullptr;\n+      args.data = data.data();\n+      args.type = ::pjrt::ConvertToPjRtBufferType(xla_shape.element_type());\n+      args.dims = xla_shape.dimensions().data();\n+      args.num_dims = xla_shape.dimensions().size();\n+      args.byte_strides = nullptr;\n+      args.num_byte_strides = 0;\n+      args.device_layout = nullptr;\n+      args.host_buffer_semantics = ::pjrt::ConvertToPjRtHostBufferSemantics(\n+          xla::PjRtClient::HostBufferSemantics::kImmutableOnlyDuringCall);\n+      args.client = create_arg.client;\n+      args.device = GetClientAddressableDevices(create_arg.client, api)[0];\n+      args.memory = nullptr;\n+\n+      auto transfer_error =\n+          std::unique_ptr<PJRT_Error, ::pjrt::PJRT_ErrorDeleter>{\n+              api->PJRT_Client_BufferFromHostBuffer(&args),\n+              ::pjrt::MakeErrorDeleter(api)};\n+      if (transfer_error != nullptr) {\n+        return transfer_error->status;\n+      }\n+      TF_CHECK_OK(args.buffer->buffer->GetReadyFuture().Await());\n+      std::unique_ptr<PJRT_Event, PJRT_EventDeleter> event(\n+          args.done_with_host_buffer, MakeEventDeleter(api));\n+\n+      raw_buffers.push_back(args.buffer);\n+      TF_CHECK_OK(event->future.Await());\n+      xla::PjRtGlobalDeviceId src_device_id =\n+          args.device->device->global_device_id();\n+      dst_device_ids.push_back(1 - src_device_id);\n+      transfer_keys.push_back(xla::CrossHostTransferKey(i));\n+    };\n+\n+    // Send the list of buffers.\n+    PJRT_Transfers_PJRT_Client_CrossHostSendBuffers_Args send_args;\n+    send_args.struct_size =\n+        PJRT_Transfers_PJRT_Client_CrossHostSendBuffers_Args_STRUCT_SIZE;\n+    send_args.extension_start = nullptr;\n+    send_args.client = create_arg.client;\n+    send_args.num_buffers = raw_buffers.size();\n+    send_args.buffers = raw_buffers.data();\n+    send_args.dst_global_device_ids = dst_device_ids.data();\n+    send_args.transfer_keys = transfer_keys.data();\n+    std::vector<PJRT_Event*> temp_events(raw_buffers.size());\n+    send_args.send_events = temp_events.data();\n+    cross_host_transfers_extension\n+        ->PJRT_Transfers_PJRT_Client_CrossHostSendBuffers(&send_args);\n+\n+    for (int i = 0; i < num_arrays; ++i) {\n+      TF_CHECK_OK(send_args.send_events[i]->future.Await());\n+      std::unique_ptr<PJRT_Buffer, ::pjrt::PJRT_BufferDeleter> buffer(\n+          raw_buffers[i], ::pjrt::MakeBufferDeleter(api));\n+      std::unique_ptr<PJRT_Event, PJRT_EventDeleter> send_event(\n+          send_args.send_events[i], MakeEventDeleter(api));\n+      TF_CHECK_OK(send_event->future.Await());\n+    }\n+  } else {\n+    // Receive some data.\n+    std::vector<xla::Literal> expected_literals;\n+    expected_literals.reserve(num_arrays);\n+    for (int i = 0; i < num_arrays; ++i) {\n+      expected_literals.push_back(xla::LiteralUtil::CreateR2<float>(\n+          {{1, 2, 3}, {4, 5, 6 * static_cast<float>(i)}}));\n+    }\n+    std::vector<xla::Shape> shapes;\n+    std::vector<xla::PjRtGlobalDeviceId> src_device_ids;\n+    std::vector<xla::CrossHostTransferKey> transfer_keys;\n+    std::vector<size_t> shape_num_dims;\n+    std::vector<const int64_t*> num_dims;\n+    std::vector<PJRT_Buffer_Type> element_types;\n+    std::vector<PJRT_Buffer_MemoryLayout*> layouts;\n+    xla::PjRtGlobalDeviceId dst_device_id =\n+        GetClientAddressableDevices(create_arg.client, api)[0]\n+            ->device->global_device_id();\n+    for (int i = 0; i < num_arrays; ++i) {\n+      shapes.push_back(xla_shape);\n+      src_device_ids.push_back(xla::PjRtGlobalDeviceId(1 - dst_device_id));\n+      transfer_keys.push_back(xla::CrossHostTransferKey(i));\n+      shape_num_dims.push_back(shapes.back().dimensions().size());\n+      num_dims.push_back(shapes.back().dimensions().data());\n+      element_types.push_back(\n+          ::pjrt::ConvertToPjRtBufferType(shapes.back().element_type()));\n+      layouts.push_back(nullptr);\n+    }\n+\n+    PJRT_Transfers_PJRT_Client_CrossHostReceiveBuffers_Args recv_args;\n+    recv_args.struct_size =\n+        PJRT_Transfers_PJRT_Client_CrossHostReceiveBuffers_Args_STRUCT_SIZE;\n+    recv_args.extension_start = nullptr;\n+    recv_args.client = create_arg.client;\n+    recv_args.num_shapes = shapes.size();\n+    recv_args.shape_num_dims = shape_num_dims.data();\n+    recv_args.num_dims = num_dims.data();\n+    recv_args.element_types = element_types.data();\n+    recv_args.layouts = layouts.data();\n+    recv_args.device = GetClientAddressableDevices(create_arg.client, api)[0];\n+    recv_args.src_global_device_ids = src_device_ids.data();\n+    recv_args.transfer_keys = transfer_keys.data();\n+    std::vector<PJRT_Buffer*> temp_buffers(shapes.size());\n+    recv_args.buffers = temp_buffers.data();\n+    cross_host_transfers_extension\n+        ->PJRT_Transfers_PJRT_Client_CrossHostReceiveBuffers(&recv_args);\n+\n+    for (int i = 0; i < num_arrays; ++i) {\n+      TF_RETURN_IF_ERROR(\n+          recv_args.buffers[i]->buffer->GetReadyFuture().Await());\n+      TF_ASSIGN_OR_RETURN(std::shared_ptr<xla::Literal> recv_literal,\n+                          recv_args.buffers[i]->buffer->ToLiteral().Await());\n+\n+      TF_RET_CHECK(\n+          xla::LiteralTestUtil::Equal(expected_literals[i], *recv_literal));\n+      std::unique_ptr<PJRT_Buffer, ::pjrt::PJRT_BufferDeleter> buffer(\n+          recv_args.buffers[i], ::pjrt::MakeBufferDeleter(api));\n+    }\n+  }\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace\n+}  // namespace pjrt\n+\n+int main(int argc, char* argv[]) {\n+  // Variables used by SuccessfulCrossHostTransfer.\n+  std::string cross_host_test_role;\n+  int num_arrays = -1;\n+\n+  std::vector<tsl::Flag> flag_list = {\n+      tsl::Flag(\"cross_host_test_role\", &cross_host_test_role,\n+                \"Test parameter for SuccessfulCrossHostTransfer; either \"\n+                \"'sender' or 'receiver'.\"),\n+      tsl::Flag(\"num_arrays\", &num_arrays,\n+                \"Test parameter for SuccessfulCrossHostTransfer; number of \"\n+                \"arrays to transfer.\")};\n+\n+  xla::AppendDebugOptionsFlags(&flag_list);\n+  std::string usage = tsl::Flags::Usage(argv[0], flag_list);\n+  tsl::Flags::Parse(&argc, argv, flag_list);\n+\n+  testing::InitGoogleTest(&argc, argv);\n+  if (cross_host_test_role == \"sender\") {\n+    return pjrt::SuccessfulCrossHostTransferTestBody(/*is_sender=*/true,\n+                                                     num_arrays)\n+        .raw_code();\n+  }\n+  if (cross_host_test_role == \"receiver\") {\n+    return pjrt::SuccessfulCrossHostTransferTestBody(/*is_sender=*/false,\n+                                                     num_arrays)\n+        .raw_code();\n+  }\n+  return RUN_ALL_TESTS();\n+}"
        }
    ],
    "stats": {
        "total": 519,
        "additions": 475,
        "deletions": 44
    }
}