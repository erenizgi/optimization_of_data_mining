{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809695954",
    "sha": "965a90938bdce6daa5eb2043bcd3408a7c8f8911",
    "files": [
        {
            "sha": "01a398bf10c2affb02b14c9a60c2abea27562973",
            "filename": "third_party/xla/xla/backends/cpu/collectives/cpu_cliques.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/965a90938bdce6daa5eb2043bcd3408a7c8f8911/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcollectives%2Fcpu_cliques.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/965a90938bdce6daa5eb2043bcd3408a7c8f8911/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcollectives%2Fcpu_cliques.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcollectives%2Fcpu_cliques.cc?ref=965a90938bdce6daa5eb2043bcd3408a7c8f8911",
            "patch": "@@ -84,7 +84,7 @@ static void EraseProcessCpuCliques(CpuCollectives* collectives) {\n   VLOG(3) << \"Erase process CPU cliques for collectives: \" << collectives;\n   ProcessCpuCliques& cliques = GetProcessCpuCliques();\n \n-  absl::MutexLock lock(&cliques.mu);\n+  absl::MutexLock lock(cliques.mu);\n   absl::erase_if(cliques.map, [collectives](const auto& entry) {\n     return entry.first.first == collectives;\n   });\n@@ -125,7 +125,7 @@ absl::StatusOr<Communicator*> AcquireCommunicator(\n \n   // Synchronize access to the process cliques.\n   ThreadSafeClique& thread_safe_clique = [&]() -> ThreadSafeClique& {\n-    absl::MutexLock lock(&cliques.mu);\n+    absl::MutexLock lock(cliques.mu);\n     auto [it, emplaced] = cliques.map.try_emplace(\n         std::make_pair(collectives, clique_key), clique_key);\n \n@@ -144,7 +144,7 @@ absl::StatusOr<Communicator*> AcquireCommunicator(\n   // Create the communicator, once.\n   absl::once_flag* create_comm_once = nullptr;\n   {\n-    absl::MutexLock lock(&thread_safe_clique.mu);\n+    absl::MutexLock lock(thread_safe_clique.mu);\n     std::unique_ptr<absl::once_flag>& x =\n         thread_safe_clique.create_comm_once[rank];\n     if (!x) {\n@@ -156,7 +156,7 @@ absl::StatusOr<Communicator*> AcquireCommunicator(\n     absl::StatusOr<std::unique_ptr<Communicator>> comm =\n         CreateCommunicator(collectives, clique_key, rank);\n \n-    absl::MutexLock lock(&thread_safe_clique.mu);\n+    absl::MutexLock lock(thread_safe_clique.mu);\n     if (!comm.ok()) {\n       thread_safe_clique.create_comm_status[rank] = comm.status();\n       return;\n@@ -167,7 +167,7 @@ absl::StatusOr<Communicator*> AcquireCommunicator(\n     }\n   });\n \n-  absl::MutexLock lock(&thread_safe_clique.mu);\n+  absl::MutexLock lock(thread_safe_clique.mu);\n   TF_RETURN_IF_ERROR(thread_safe_clique.create_comm_status[rank]);\n   return *thread_safe_clique.clique.comm(rank);\n }"
        }
    ],
    "stats": {
        "total": 10,
        "additions": 5,
        "deletions": 5
    }
}