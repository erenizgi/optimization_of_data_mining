{
    "author": "ezhulenev",
    "message": "[xla:ffi] Add support for internal type serialization and deserialization\n\nPiperOrigin-RevId: 842438931",
    "sha": "0eebb72ae29b2349e8e30fe1c6de464bd5badb8a",
    "files": [
        {
            "sha": "b7b2892e016db36ffa15cf214e40b7092e27e9b7",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=0eebb72ae29b2349e8e30fe1c6de464bd5badb8a",
            "patch": "@@ -128,6 +128,7 @@ xla_cc_test(\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest\",\n         \"@com_google_googletest//:gtest_main\",\n     ],\n@@ -325,6 +326,7 @@ cc_library(\n     deps = [\n         \"//xla:util\",\n         \"//xla/tsl/lib/gtl:int_type\",\n+        \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/util:safe_reinterpret_cast\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:core_headers\",\n@@ -348,6 +350,7 @@ xla_cc_test(\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_googletest//:gtest\",\n         \"@com_google_googletest//:gtest_main\","
        },
        {
            "sha": "966c195d05fd7f497458c8fa10f1d2b213250bf7",
            "filename": "third_party/xla/xla/ffi/execution_state.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc?ref=0eebb72ae29b2349e8e30fe1c6de464bd5badb8a",
            "patch": "@@ -116,10 +116,8 @@ absl::StatusOr<ExecutionState> ExecutionState::FromProto(\n         proto.type_name());\n   }\n \n-  TF_ASSIGN_OR_RETURN(void* opaque_state,\n-                      type_info.deserializer(proto.state()));\n-\n-  TF_RETURN_IF_ERROR(state.Set(type_id, type_info, opaque_state));\n+  TF_ASSIGN_OR_RETURN(auto opaque_state, type_info.deserializer(proto.state()));\n+  TF_RETURN_IF_ERROR(state.Set(type_id, type_info, opaque_state.release()));\n   return state;\n }\n "
        },
        {
            "sha": "8c05e4caf9098e874e70f9e555c0d62d3ea6067e",
            "filename": "third_party/xla/xla/ffi/execution_state_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 14,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state_test.cc?ref=0eebb72ae29b2349e8e30fe1c6de464bd5badb8a",
            "patch": "@@ -18,10 +18,12 @@ limitations under the License.\n #include <cstdint>\n #include <memory>\n #include <string>\n+#include <type_traits>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"xla/ffi/type_registry.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -85,22 +87,26 @@ TEST(ExecutionStateTest, SetAndGetForExternalType) {\n   EXPECT_EQ(data, value);\n }\n \n+struct MyState {\n+  std::string value;\n+};\n+\n+template <>\n+struct TypeRegistry::SerDes<MyState> : public std::true_type {\n+  static absl::StatusOr<std::string> Serialize(const MyState& value) {\n+    return value.value;\n+  }\n+  static absl::StatusOr<std::unique_ptr<MyState>> Deserialize(\n+      absl::string_view data) {\n+    auto state = std::make_unique<MyState>();\n+    state->value = data;\n+    return state;\n+  }\n+};\n+\n TEST(ExecutionStateTest, Serialization) {\n-  struct MyState {\n-    std::string value;\n-  };\n+  TypeRegistry::TypeInfo type_info = TypeRegistry::GetTypeInfo<MyState>();\n \n-  TypeRegistry::TypeInfo type_info = {\n-      /*deleter=*/\n-      [](void* ptr) { delete static_cast<MyState*>(ptr); },\n-      /*serializer=*/\n-      [](const void* ptr) -> absl::StatusOr<std::string> {\n-        return static_cast<const MyState*>(ptr)->value;\n-      },\n-      /*deserializer=*/\n-      [](absl::string_view state) -> absl::StatusOr<void*> {\n-        return new MyState{std::string(state)};\n-      }};\n   TF_ASSERT_OK_AND_ASSIGN(\n       TypeRegistry::TypeId type_id,\n       TypeRegistry::AssignExternalTypeId(\"my_state_type\", type_info));"
        },
        {
            "sha": "244fd6c8653a9cc98cab201b564a8ba591e03437",
            "filename": "third_party/xla/xla/ffi/type_registry.h",
            "status": "modified",
            "additions": 74,
            "deletions": 4,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h?ref=0eebb72ae29b2349e8e30fe1c6de464bd5badb8a",
            "patch": "@@ -17,14 +17,18 @@ limitations under the License.\n #define XLA_FFI_TYPE_REGISTRY_H_\n \n #include <cstdint>\n+#include <memory>\n #include <string>\n+#include <type_traits>\n \n #include \"absl/base/no_destructor.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/lib/gtl/int_type.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/util/safe_reinterpret_cast.h\"\n+#include \"xla/util.h\"\n \n namespace xla::ffi {\n \n@@ -63,13 +67,27 @@ class TypeRegistry {\n   struct TypeInfo {\n     using Deleter = void (*)(void*);\n     using Serializer = absl::StatusOr<std::string> (*)(const void*);\n-    using Deserializer = absl::StatusOr<void*> (*)(absl::string_view);\n+    using Deserializer =\n+        absl::StatusOr<std::unique_ptr<void, Deleter>> (*)(absl::string_view);\n \n     Deleter deleter = nullptr;\n     Serializer serializer = nullptr;\n     Deserializer deserializer = nullptr;\n   };\n \n+  // To declare a type `T` as serializable and deserializable, define a\n+  // specialization of `TypeSerDes<T>` with `Serialize` and `Deserialize` apis.\n+  //\n+  //   template <>\n+  //   struct TypeSerDes<T> : public std::true_type {\n+  //     static absl::StatusOr<std::string> Serialize(const T& value);\n+  //     static absl::StatusOr<std::unique_ptr<T>> Deserialize(\n+  //       absl::string_view data);\n+  // };\n+  //\n+  template <typename T>\n+  struct SerDes : public std::false_type {};\n+\n   // Returns type name for a given type id. Returns an error if type id is not\n   // registered. Works for both external and internal type ids.\n   static absl::StatusOr<absl::string_view> GetTypeName(TypeId type_id);\n@@ -106,6 +124,14 @@ class TypeRegistry {\n   template <typename T>\n   static TypeInfo GetTypeInfo();\n \n+  // Serializes a value of a given type. For internal type ids only.\n+  template <typename T>\n+  static absl::StatusOr<std::string> Serialize(const T& value);\n+\n+  // Deserializes a value of a given type. For internal type ids only.\n+  template <typename T>\n+  static absl::StatusOr<std::unique_ptr<T>> Deserialize(absl::string_view data);\n+\n  private:\n   static TypeId GetNextTypeId();\n };\n@@ -126,9 +152,53 @@ TypeRegistry::TypeId TypeRegistry::GetTypeId() {\n \n template <typename T>\n TypeRegistry::TypeInfo TypeRegistry::GetTypeInfo() {\n-  return TypeInfo{\n-      [](void* state) { delete tsl::safe_reinterpret_cast<T*>(state); },\n-  };\n+  // Define deleter as a static member, because it's always available for the\n+  // internal types.\n+  static TypeInfo::Deleter deleter =\n+      +[](void* state) { delete tsl::safe_reinterpret_cast<T*>(state); };\n+\n+  // Serializer and deserializer are defined only if `T` opts in to the\n+  // serializable via the `SerDes` specialization.\n+  TypeInfo::Serializer serializer = nullptr;\n+  TypeInfo::Deserializer deserializer = nullptr;\n+\n+  if constexpr (SerDes<T>::value) {\n+    serializer = +[](const void* value) {\n+      return SerDes<T>::Serialize(*tsl::safe_reinterpret_cast<const T*>(value));\n+    };\n+\n+    deserializer = +[](absl::string_view data)\n+        -> absl::StatusOr<std::unique_ptr<void, TypeInfo::Deleter>> {\n+      TF_ASSIGN_OR_RETURN(auto value, SerDes<T>::Deserialize(data));\n+      return std::unique_ptr<void, TypeInfo::Deleter>(value.release(), deleter);\n+    };\n+  }\n+\n+  return TypeInfo{deleter, serializer, deserializer};\n+}\n+\n+template <typename T>\n+absl::StatusOr<std::string> TypeRegistry::Serialize(const T& value) {\n+  TypeInfo type_info = GetTypeInfo<T>();\n+  if (type_info.serializer == nullptr) {\n+    return FailedPrecondition(\n+        \"Type is not serializable. Did you forget to specialize \"\n+        \"TypeRegistry::SerDes<T>?\");\n+  }\n+  return type_info.serializer(&value);\n+}\n+\n+template <typename T>\n+absl::StatusOr<std::unique_ptr<T>> TypeRegistry::Deserialize(\n+    absl::string_view data) {\n+  TypeInfo type_info = GetTypeInfo<T>();\n+  if (type_info.deserializer == nullptr) {\n+    return FailedPrecondition(\n+        \"Type is not deserializable. Did you forget to specialize \"\n+        \"TypeRegistry::SerDes<T>?\");\n+  }\n+  TF_ASSIGN_OR_RETURN(auto ptr, type_info.deserializer(data));\n+  return std::unique_ptr<T>(tsl::safe_reinterpret_cast<T*>(ptr.release()));\n }\n \n }  // namespace xla::ffi"
        },
        {
            "sha": "15d7c9fd0f419635ecf40e053225423713a44f2e",
            "filename": "third_party/xla/xla/ffi/type_registry_test.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 1,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0eebb72ae29b2349e8e30fe1c6de464bd5badb8a/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc?ref=0eebb72ae29b2349e8e30fe1c6de464bd5badb8a",
            "patch": "@@ -17,18 +17,41 @@ limitations under the License.\n \n #include <cstdint>\n #include <limits>\n+#include <memory>\n+#include <string>\n+#include <type_traits>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n \n namespace xla::ffi {\n-namespace {\n \n+// Define a custom type with `TypeSerDes` specialization to test that TypeInfo\n+// is properly generated for such types.\n+struct MyString {\n+  std::string data;\n+};\n+\n+template <>\n+struct TypeRegistry::SerDes<MyString> : public std::true_type {\n+  static absl::StatusOr<std::string> Serialize(const MyString& type) {\n+    return type.data;\n+  }\n+  static absl::StatusOr<std::unique_ptr<MyString>> Deserialize(\n+      absl::string_view data) {\n+    auto type = std::make_unique<MyString>();\n+    type->data = std::string(data);\n+    return type;\n+  }\n+};\n+\n+namespace {\n using ::testing::HasSubstr;\n \n TEST(TypeRegistryTest, RegisterExternalTypeId) {\n@@ -87,5 +110,18 @@ TEST(TypeRegistryTest, InternalTypeInfo) {\n   type_info.deleter(ptr);\n }\n \n+TEST(TypeRegistryTest, SerializableType) {\n+  MyString str = {\"foo\"};\n+\n+  TypeRegistry::TypeInfo type_info = TypeRegistry::GetTypeInfo<MyString>();\n+  ASSERT_NE(type_info.serializer, nullptr);\n+  ASSERT_NE(type_info.deserializer, nullptr);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::string serialized, TypeRegistry::Serialize(str));\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<MyString> deserialized,\n+                          TypeRegistry::Deserialize<MyString>(serialized));\n+  EXPECT_EQ(deserialized->data, \"foo\");\n+}\n+\n }  // namespace\n }  // namespace xla::ffi"
        }
    ],
    "stats": {
        "total": 159,
        "additions": 136,
        "deletions": 23
    }
}