{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 809684936",
    "sha": "0e40ecf1bd382f25835b06e7a62700cef64a51f1",
    "files": [
        {
            "sha": "f744c203ad0480428faa0607033c1ed6b1e0f93a",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/grpc_service_impl.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fgrpc_service_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fgrpc_service_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fgrpc_service_impl.cc?ref=0e40ecf1bd382f25835b06e7a62700cef64a51f1",
            "patch": "@@ -94,11 +94,11 @@ ::grpc::Status GrpcServiceImpl::IfrtSession(\n   auto host_buffer_store =\n       std::make_shared<xla::ifrt::proxy::HostBufferStore>();\n   {\n-    absl::MutexLock l(&host_buffer_store_mu_);\n+    absl::MutexLock l(host_buffer_store_mu_);\n     CHECK(host_buffer_stores_.insert({session_id, host_buffer_store}).second);\n   }\n   absl::Cleanup cleanup = [&] {\n-    absl::MutexLock l(&host_buffer_store_mu_);\n+    absl::MutexLock l(host_buffer_store_mu_);\n     CHECK_GT(host_buffer_stores_.erase(session_id), 0);\n   };\n \n@@ -135,7 +135,7 @@ ::grpc::Status GrpcServiceImpl::IfrtSession(\n     response.OnReady(\n         [op_id, stream,\n          &writer_mu](absl::StatusOr<std::shared_ptr<IfrtResponse>> response) {\n-          absl::MutexLock l(&writer_mu);\n+          absl::MutexLock l(writer_mu);\n           if (response.ok()) {\n             stream->Write(**response);\n           } else {\n@@ -272,18 +272,18 @@ ::grpc::Status GrpcServiceImpl::HostBufferDelete(\n bool GrpcServiceImpl::Test_InsertHostBufferStore(\n     uint64_t session_id,\n     std::shared_ptr<xla::ifrt::proxy::HostBufferStore> store) {\n-  absl::MutexLock l(&host_buffer_store_mu_);\n+  absl::MutexLock l(host_buffer_store_mu_);\n   return host_buffer_stores_.insert({session_id, std::move(store)}).second;\n }\n \n bool GrpcServiceImpl::Test_DeleteHostBufferStore(uint64_t session_id) {\n-  absl::MutexLock l(&host_buffer_store_mu_);\n+  absl::MutexLock l(host_buffer_store_mu_);\n   return host_buffer_stores_.erase(session_id) > 0;\n }\n \n absl::StatusOr<std::shared_ptr<xla::ifrt::proxy::HostBufferStore>>\n GrpcServiceImpl::GetHostBufferStore(uint64_t session_id) {\n-  absl::MutexLock l(&host_buffer_store_mu_);\n+  absl::MutexLock l(host_buffer_store_mu_);\n   const auto it = host_buffer_stores_.find(session_id);\n   if (it == host_buffer_stores_.end()) {\n     return absl::NotFoundError("
        },
        {
            "sha": "b04999ad0dd5a9dda69665a6d28345d995cb6751",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/host_buffer.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer.cc?ref=0e40ecf1bd382f25835b06e7a62700cef64a51f1",
            "patch": "@@ -35,7 +35,7 @@ namespace proxy {\n \n absl::Status HostBufferStore::Store(uint64_t handle, std::string data) {\n   VLOG(3) << \"HostBuffer::Store \" << handle << \" \" << data.size();\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (shutdown_msg_.has_value()) {\n     return absl::CancelledError(*shutdown_msg_);\n   }\n@@ -55,7 +55,7 @@ absl::StatusOr<std::shared_ptr<const std::string>> HostBufferStore::Lookup(\n           << \" start, timeout=\" << timeout;\n   tsl::profiler::TraceMe traceme(\"HostBufferStore::Lookup\");\n   auto result = [&]() -> absl::StatusOr<std::shared_ptr<const std::string>> {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     auto cond = [&]() ABSL_SHARED_LOCKS_REQUIRED(mu_) {\n       return shutdown_msg_.has_value() || buffers_.contains(handle);\n     };\n@@ -84,7 +84,7 @@ absl::StatusOr<std::shared_ptr<const std::string>> HostBufferStore::Lookup(\n }\n \n absl::Status HostBufferStore::Delete(uint64_t handle) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   VLOG(3) << \"HostBufferStore::Delete \" << handle;\n   if (buffers_.erase(handle) == 0) {\n     return absl::NotFoundError(\n@@ -95,7 +95,7 @@ absl::Status HostBufferStore::Delete(uint64_t handle) {\n \n void HostBufferStore::Shutdown(std::string reason) {\n   VLOG(0) << \"HostBufferStore::Shutdown \" << reason;\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (!shutdown_msg_.has_value()) {\n     shutdown_msg_ = std::move(reason);\n   }"
        },
        {
            "sha": "5a5347cc1024054d2afddf111420c86984ab8b3a",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/host_callback.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_callback.cc?ref=0e40ecf1bd382f25835b06e7a62700cef64a51f1",
            "patch": "@@ -51,7 +51,7 @@ namespace proxy {\n RemoteLoadedHostCallbackQueue::~RemoteLoadedHostCallbackQueue() { Close(); }\n \n absl::Status RemoteLoadedHostCallbackQueue::Push(ExecutionRequest request) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   if (closed_) {\n     return absl::CancelledError(\n         \"RemoteLoadedHostCallback has stopped accepting new execution \"\n@@ -66,7 +66,7 @@ RemoteLoadedHostCallbackQueue::Pop() {\n   auto not_empty = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n     return !requests_.empty() || closed_;\n   };\n-  absl::MutexLock l(&mu_, absl::Condition(&not_empty));\n+  absl::MutexLock l(mu_, absl::Condition(&not_empty));\n   if (closed_) {\n     return std::nullopt;\n   }\n@@ -78,7 +78,7 @@ RemoteLoadedHostCallbackQueue::Pop() {\n void RemoteLoadedHostCallbackQueue::Close() {\n   std::deque<ExecutionRequest> requests;\n   {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (!closed_) {\n       requests.swap(requests_);\n     }"
        },
        {
            "sha": "af188eb18866f81c7b416d15571e0814d00d15bb",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 34,
            "changes": 68,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0e40ecf1bd382f25835b06e7a62700cef64a51f1/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=0e40ecf1bd382f25835b06e7a62700cef64a51f1",
            "patch": "@@ -240,7 +240,7 @@ class IfrtBackend::ArrayStore::Reservation {\n \n   // Checks that `Fill()` and `ProcessResponse()` have been called as expected.\n   ~Reservation() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     CHECK(filled_);\n   }\n \n@@ -276,7 +276,7 @@ absl::StatusOr<IfrtBackend::Response>\n IfrtBackend::ArrayStore::Reservation::ProcessResponse(\n     absl::StatusOr<Response> result) {\n   if (!result.ok()) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     CHECK(!filled_);\n     filled_ = true;\n     parent_->Insert(reserved_handles_, result.status());\n@@ -286,7 +286,7 @@ IfrtBackend::ArrayStore::Reservation::ProcessResponse(\n \n std::vector<uint64_t> IfrtBackend::ArrayStore::Reservation::Fill(\n     absl::Span<const IfrtArrayRef> arrays) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   CHECK(!filled_);\n   filled_ = true;\n \n@@ -332,7 +332,7 @@ class IfrtBackend::InOrderRequestsProcessor {\n \n   void Shutdown(std::string reason) {\n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       if (shutdown_msg_.has_value()) {\n         return;\n       }\n@@ -345,7 +345,7 @@ class IfrtBackend::InOrderRequestsProcessor {\n     std::deque<Entry> should_cancel;\n \n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       entries_.swap(should_cancel);\n     }\n \n@@ -360,7 +360,7 @@ class IfrtBackend::InOrderRequestsProcessor {\n   Future<Response> Push(std::unique_ptr<IfrtRequest> request) {\n     VLOG(3) << \"Enqueuing \" << request->ShortDebugString();\n     auto [promise, future] = Future<Response>::MakePromise();\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (shutdown_msg_.has_value()) {\n       promise.Set(absl::InternalError(absl::StrCat(\n           \"InOrderRequestsProcessor already stopped: \", *shutdown_msg_)));\n@@ -380,7 +380,7 @@ class IfrtBackend::InOrderRequestsProcessor {\n \n  private:\n   std::optional<Entry> Pop() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     auto cond = [&]() ABSL_SHARED_LOCKS_REQUIRED(mu_) {\n       return shutdown_msg_.has_value() || !entries_.empty();\n     };\n@@ -489,15 +489,15 @@ IfrtBackend::~IfrtBackend() {\n \n   // Cancel all in-flight host callback executions.\n   {\n-    absl::MutexLock lock(&host_callback_queues_mutex_);\n+    absl::MutexLock lock(host_callback_queues_mutex_);\n     for (const auto& [key, queue] : host_callback_queues_) {\n       queue->Close();\n     }\n   }\n   absl::flat_hash_map<uint64_t, RemoteLoadedHostCallbackQueue::ExecutionRequest>\n       host_callback_executions;\n   {\n-    absl::MutexLock lock(&host_callback_executions_mutex_);\n+    absl::MutexLock lock(host_callback_executions_mutex_);\n     host_callback_executions.swap(host_callback_executions_);\n   }\n   for (auto& [handle, execution_request] : host_callback_executions) {\n@@ -513,7 +513,7 @@ IfrtBackend::~IfrtBackend() {\n     auto done = [this]() ABSL_SHARED_LOCKS_REQUIRED(in_flight_count_mutex_) {\n       return in_flight_count_ == 0;\n     };\n-    absl::MutexLock lock(&in_flight_count_mutex_, absl::Condition(&done));\n+    absl::MutexLock lock(in_flight_count_mutex_, absl::Condition(&done));\n   }\n }\n \n@@ -600,7 +600,7 @@ Future<BackendInterface::Response> IfrtBackend::ProcessInternal(\n           HandleLoadedExecutableExecuteRequest(*asr, std::move(request));\n       if (client_generated_status_handle != 0) {\n         // Populate the handle if not already populated.\n-        absl::MutexLock l(&futures_mutex_);\n+        absl::MutexLock l(futures_mutex_);\n         const bool inserted = futures_\n                                   .insert({client_generated_status_handle,\n                                            Future<>(result.status())})\n@@ -645,15 +645,15 @@ IfrtBackend::HandleGenerator::HandleGenerator(IfrtBackend* parent)\n     : parent_(parent), current_(kServerGeneratedHandlesMinValue) {}\n \n uint64_t IfrtBackend::HandleGenerator::GenerateAtServer() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   uint64_t result = current_++;\n   CHECK_GE(result, kServerGeneratedHandlesMinValue);\n   return result;\n }\n \n void IfrtBackend::HandleGenerator::GenerateAtServerBulk(\n     absl::Span<uint64_t> result_handles) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   std::iota(result_handles.begin(), result_handles.end(), current_);\n   current_ += result_handles.size();\n   CHECK_GE(current_, kServerGeneratedHandlesMinValue);\n@@ -663,15 +663,15 @@ Future<BackendInterface::Response> IfrtBackend::AsyncExecute(\n     std::function<absl::StatusOr<Response>()> handle_fn,\n     tsl::thread::ThreadPool* thread_pool) {\n   {\n-    absl::MutexLock lock(&in_flight_count_mutex_);\n+    absl::MutexLock lock(in_flight_count_mutex_);\n     ++in_flight_count_;\n   }\n   auto [promise, future] = Future<Response>::MakePromise();\n   auto f = [this, promise = std::move(promise).ToShared(),\n             handle_fn = std::move(handle_fn)]() mutable {\n     promise->Set(handle_fn());\n     {\n-      absl::MutexLock lock(&in_flight_count_mutex_);\n+      absl::MutexLock lock(in_flight_count_mutex_);\n       --in_flight_count_;\n     }\n   };\n@@ -774,7 +774,7 @@ Future<BackendInterface::Response> IfrtBackend::HandleCheckFutureRequest(\n \n   Future<> future;\n   {\n-    absl::MutexLock lock(&futures_mutex_);\n+    absl::MutexLock lock(futures_mutex_);\n     const auto it = futures_.find(check_request.future_handle());\n     if (it == futures_.end()) {\n       return Future<Response>(absl::NotFoundError(absl::StrCat(\n@@ -1332,7 +1332,7 @@ IfrtBackend::HandleDeleteArrayRequest(std::unique_ptr<IfrtRequest> request) {\n \n   uint64_t future_handle = handle_generator_.GenerateAtServer();\n   {\n-    absl::MutexLock lock(&futures_mutex_);\n+    absl::MutexLock lock(futures_mutex_);\n     futures_.insert({future_handle, JoinFutures(deletion_futures)});\n   }\n \n@@ -1482,20 +1482,20 @@ Future<BackendInterface::Response> IfrtBackend::HandleCompileRequest(\n     // `futures_` without checking its status for situations where futures are\n     // not used.\n     {\n-      absl::MutexLock lock(&futures_mutex_);\n+      absl::MutexLock lock(futures_mutex_);\n       compile_resp->set_ready_future_handle(\n           handle_generator_.GenerateAtServer());\n       futures_.insert(\n           {compile_resp->ready_future_handle(), executable->GetReadyFuture()});\n     }\n \n     {\n-      absl::MutexLock lock(&executables_mutex_);\n+      absl::MutexLock lock(executables_mutex_);\n       executables_.insert({handle, std::make_shared<LoadedExecutableWithInfo>(\n                                        std::move(executable))});\n     }\n     {\n-      absl::MutexLock lock(&host_callback_queues_mutex_);\n+      absl::MutexLock lock(host_callback_queues_mutex_);\n       for (int i = 0; i < host_callback_queues.size(); ++i) {\n         host_callback_queues_.insert(\n             {host_callback_handles[i], std::move(host_callback_queues[i])});\n@@ -1662,7 +1662,7 @@ IfrtBackend::HandleLoadedExecutableExecuteRequest(\n   // output specs of a `LoadedExecutable` remains constant across `Execute()`\n   // calls. Verify that this expectation is satisfied.\n   {\n-    absl::MutexLock l(&executable_info->mu);\n+    absl::MutexLock l(executable_info->mu);\n     if (executable_info->output_spec.has_value()) {\n       CHECK_EQ(result.outputs.size(), executable_info->output_spec->size())\n           << \"LoadedExecutable::Execute returned different number of outputs \"\n@@ -1736,7 +1736,7 @@ IfrtBackend::HandleLoadedExecutableExecuteRequest(\n     if (execute_options.fill_status) {\n       // Caller is expected to call `CheckFuture` exactly once to check for its\n       // status and erase it.\n-      absl::MutexLock lock(&futures_mutex_);\n+      absl::MutexLock lock(futures_mutex_);\n       uint64_t status_handle = execute.result_status_handle();\n       if (status_handle == 0) {\n         status_handle = handle_generator_.GenerateAtServer();\n@@ -1778,7 +1778,7 @@ IfrtBackend::HandleLoadedExecutableDeleteRequest(\n   auto* del_response = ifrt_resp->mutable_loaded_executable_delete_response();\n \n   {\n-    absl::MutexLock lock(&futures_mutex_);\n+    absl::MutexLock lock(futures_mutex_);\n     del_response->set_future_handle(handle_generator_.GenerateAtServer());\n     futures_.insert({del_response->future_handle(), std::move(future)});\n   }\n@@ -1806,7 +1806,7 @@ IfrtBackend::HandleLoadedExecutableDestructRequest(\n \n   std::shared_ptr<LoadedExecutableWithInfo> executable;\n   {\n-    absl::MutexLock lock(&executables_mutex_);\n+    absl::MutexLock lock(executables_mutex_);\n     const auto it = executables_.find(destruct.loaded_executable_handle());\n     if (it == executables_.end()) {\n       return absl::NotFoundError(\n@@ -1838,7 +1838,7 @@ IfrtBackend::HandleLoadedHostCallbackPollRequest(\n     // Find the host callback queue associated with the given handle.\n     std::shared_ptr<RemoteLoadedHostCallbackQueue> queue;\n     {\n-      absl::MutexLock lock(&host_callback_queues_mutex_);\n+      absl::MutexLock lock(host_callback_queues_mutex_);\n       auto it = host_callback_queues_.find(handle);\n       if (it == host_callback_queues_.end()) {\n         return absl::NotFoundError(\n@@ -1853,7 +1853,7 @@ IfrtBackend::HandleLoadedHostCallbackPollRequest(\n     auto execution_request = queue->Pop();\n     if (!execution_request.has_value()) {\n       {\n-        absl::MutexLock lock(&host_callback_queues_mutex_);\n+        absl::MutexLock lock(host_callback_queues_mutex_);\n         host_callback_queues_.erase(handle);\n       }\n       auto ifrt_resp = NewIfrtResponse(request->request_metadata().op_id());\n@@ -1883,7 +1883,7 @@ IfrtBackend::HandleLoadedHostCallbackPollRequest(\n \n     const uint64_t execution_handle = handle_generator_.GenerateAtServer();\n     {\n-      absl::MutexLock lock(&host_callback_executions_mutex_);\n+      absl::MutexLock lock(host_callback_executions_mutex_);\n       host_callback_executions_.insert(\n           {execution_handle, *std::move(execution_request)});\n     }\n@@ -1904,7 +1904,7 @@ IfrtBackend::HandleLoadedHostCallbackReturnRequest(\n \n   RemoteLoadedHostCallbackQueue::ExecutionRequest execution_request;\n   {\n-    absl::MutexLock lock(&host_callback_executions_mutex_);\n+    absl::MutexLock lock(host_callback_executions_mutex_);\n     const auto it =\n         host_callback_executions_.find(ret.host_callback_execution_handle());\n     if (it == host_callback_executions_.end()) {\n@@ -2019,7 +2019,7 @@ IfrtBackend::HandleGetDefaultLayoutRequest(\n \n absl::StatusOr<std::shared_ptr<IfrtBackend::LoadedExecutableWithInfo>>\n IfrtBackend::GetLoadedExecutable(uint64_t handle) {\n-  absl::MutexLock lock(&executables_mutex_);\n+  absl::MutexLock lock(executables_mutex_);\n   auto it = executables_.find(handle);\n   if (it == executables_.end()) {\n     return absl::NotFoundError(\n@@ -2029,7 +2029,7 @@ IfrtBackend::GetLoadedExecutable(uint64_t handle) {\n }\n \n absl::StatusOr<IfrtArrayRef> IfrtBackend::ArrayStore::Find(uint64_t handle) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   auto it = arrays_.find(handle);\n   if (it == arrays_.end()) {\n     return absl::NotFoundError(absl::StrCat(\"Unknown array handle: \", handle));\n@@ -2041,7 +2041,7 @@ absl::StatusOr<std::vector<IfrtArrayRef>> IfrtBackend::ArrayStore::Find(\n     absl::Span<const uint64_t> handles) {\n   std::vector<IfrtArrayRef> result;\n   result.reserve(handles.size());\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   for (const uint64_t h : handles) {\n     auto it = arrays_.find(h);\n     if (it == arrays_.end()) {\n@@ -2060,7 +2060,7 @@ std::vector<uint64_t> IfrtBackend::ArrayStore::EraseAndReturnMissing(\n   std::vector<uint64_t> missing_handles;\n   std::vector<xla::ifrt::ArrayRef> to_destruct;\n   {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     for (const uint64_t h : handles) {\n       auto it = arrays_.find(h);\n       if (it == arrays_.end()) {\n@@ -2078,7 +2078,7 @@ std::vector<uint64_t> IfrtBackend::ArrayStore::EraseAndReturnMissing(\n \n void IfrtBackend::ArrayStore::Insert(absl::Span<const uint64_t> handles,\n                                      const absl::Status& status) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   for (const uint64_t h : handles) {\n     CHECK(arrays_.insert({h, status}).second) << h;\n   }\n@@ -2088,7 +2088,7 @@ void IfrtBackend::ArrayStore::Insert(\n     absl::Span<const uint64_t> handles,\n     absl::Span<const xla::ifrt::ArrayRef> arrays) {\n   CHECK_EQ(handles.size(), arrays.size());\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   for (int i = 0; i < handles.size(); ++i) {\n     CHECK(arrays_.insert({handles[i], arrays[i]}).second) << handles[i];\n   }"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 47,
        "deletions": 47
    }
}