{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 847667783",
    "sha": "dfc5b243cae343738a0ecab747bbe7ed96859afd",
    "files": [
        {
            "sha": "0c560b57044cb4cd7058ddfaeb6d3141610a96e9",
            "filename": "tensorflow/core/graph/algorithm_test.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Falgorithm_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Falgorithm_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgraph%2Falgorithm_test.cc?ref=dfc5b243cae343738a0ecab747bbe7ed96859afd",
            "patch": "@@ -47,11 +47,12 @@ REGISTER_OP(\"TestBinary\")\n \n // Compares that the order of nodes in 'inputs' respects the\n // pair orders described in 'ordered_pairs'.\n-bool ExpectBefore(const std::vector<std::pair<string, string>>& ordered_pairs,\n-                  const std::vector<Node*>& inputs, string* error) {\n-  for (const std::pair<string, string>& pair : ordered_pairs) {\n-    const string& before_node = pair.first;\n-    const string& after_node = pair.second;\n+bool ExpectBefore(\n+    const std::vector<std::pair<std::string, std::string>>& ordered_pairs,\n+    const std::vector<Node*>& inputs, std::string* error) {\n+  for (const std::pair<std::string, std::string>& pair : ordered_pairs) {\n+    const std::string& before_node = pair.first;\n+    const std::string& after_node = pair.second;\n     bool seen_before = false;\n     bool seen_both = false;\n     for (const Node* node : inputs) {\n@@ -97,10 +98,10 @@ TEST(AlgorithmTest, ReversePostOrder) {\n   GetReversePostOrder(g, &order);\n \n   // Check that the order respects the dependencies correctly.\n-  std::vector<std::pair<string, string>> reverse_orders = {\n+  std::vector<std::pair<std::string, std::string>> reverse_orders = {\n       {\"W1\", \"input\"}, {\"W1\", \"t1\"},    {\"W1\", \"t2\"}, {\"W1\", \"t3\"},\n       {\"input\", \"t1\"}, {\"input\", \"t3\"}, {\"t1\", \"t2\"}, {\"W2\", \"t3\"}};\n-  string error;\n+  std::string error;\n   EXPECT_TRUE(ExpectBefore(reverse_orders, order, &error)) << error;\n \n   // A false ordering should fail the check.\n@@ -111,7 +112,7 @@ TEST(AlgorithmTest, ReversePostOrder) {\n   GetPostOrder(g, &order);\n \n   // Check that the order respects the dependencies correctly.\n-  std::vector<std::pair<string, string>> orders = {\n+  std::vector<std::pair<std::string, std::string>> orders = {\n       {\"input\", \"W1\"}, {\"t1\", \"W1\"},    {\"t2\", \"W1\"}, {\"t3\", \"W1\"},\n       {\"t1\", \"input\"}, {\"t3\", \"input\"}, {\"t2\", \"t1\"}, {\"t3\", \"W2\"}};\n   EXPECT_TRUE(ExpectBefore(orders, order, &error)) << error;\n@@ -131,7 +132,7 @@ TEST(AlgorithmTest, ReversePostOrderStable) {\n     // raw pointer value of Node. Stable post order suppose to remove this\n     // nondeterminism by enforcing an ordering based on node ids.\n     GraphDefBuilder b(GraphDefBuilder::kFailImmediately);\n-    string error;\n+    std::string error;\n     Node* w1 = SourceOp(\"TestParams\", b.opts().WithName(\"W1\"));\n     Node* input =\n         SourceOp(\"TestInput\", b.opts().WithName(\"input\").WithControlInput(w1));"
        },
        {
            "sha": "2206fc1b309d3b2aed88694c11980ff5f99ae006",
            "filename": "tensorflow/core/graph/collective_order_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Fcollective_order_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Fcollective_order_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgraph%2Fcollective_order_test.cc?ref=dfc5b243cae343738a0ecab747bbe7ed96859afd",
            "patch": "@@ -32,11 +32,12 @@ REGISTER_OP(\"TestParams\").Output(\"o: float\");\n // `expected_collective_nodes`, and that the list of control edges between these\n // collective nodes matches `expected_collective_control_edges`.\n void VerifyGraph(const Graph& graph,\n-                 const std::vector<string>& expected_collective_nodes,\n-                 const std::vector<std::pair<string, string>>&\n+                 const std::vector<std::string>& expected_collective_nodes,\n+                 const std::vector<std::pair<std::string, std::string>>&\n                      expected_collective_control_edges) {\n-  std::vector<string> actual_collective_nodes;\n-  std::vector<std::pair<string, string>> actual_collective_control_edges;\n+  std::vector<std::string> actual_collective_nodes;\n+  std::vector<std::pair<std::string, std::string>>\n+      actual_collective_control_edges;\n   for (const Node* src : graph.nodes()) {\n     if (!src->IsCollective()) {\n       continue;\n@@ -63,21 +64,21 @@ void VerifyGraph(const Graph& graph,\n // `wait_for_map`.\n void VerifyAttrs(\n     const Graph& graph,\n-    const std::unordered_map<string, std::vector<int32>> wait_for_map) {\n+    const std::unordered_map<std::string, std::vector<int32_t>> wait_for_map) {\n   for (const Node* node : graph.nodes()) {\n     if (node->IsCollective() ||\n         wait_for_map.find(node->name()) == wait_for_map.end()) {\n       continue;\n     }\n-    std::vector<int32> wait_for_actual;\n+    std::vector<int32_t> wait_for_actual;\n     TF_EXPECT_OK(GetNodeAttr(node->attrs(), \"wait_for\", &wait_for_actual));\n     auto wait_for_expected = wait_for_map.at(node->name());\n     EXPECT_THAT(wait_for_actual, UnorderedElementsAreArray(wait_for_expected));\n   }\n }\n \n Node* CollectiveReduceNode(GraphDefBuilder* builder, Node* input,\n-                           const string& name, const string& device,\n+                           const std::string& name, const std::string& device,\n                            int instance_key) {\n   Node* collective_node =\n       ops::UnaryOp(\"CollectiveReduce\", input,\n@@ -109,8 +110,8 @@ Node* CollectiveReduceNode(GraphDefBuilder* builder, Node* input,\n // inputs, `id` is identity node.\n std::unique_ptr<Graph> InitGraph() {\n   GraphDefBuilder builder(GraphDefBuilder::kFailImmediately);\n-  const string dev0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n-  const string dev1 = \"/job:localhost/replica:0/task:0/device:CPU:1\";\n+  const std::string dev0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n+  const std::string dev1 = \"/job:localhost/replica:0/task:0/device:CPU:1\";\n   Node* a = ops::SourceOp(\"TestParams\",\n                           builder.opts().WithName(\"a\").WithDevice(dev0));\n   Node* b = ops::SourceOp(\"TestParams\",\n@@ -165,7 +166,7 @@ TEST(CollectiveOrderTest, SimpleOrderAttr) {\n // `id` is identity node.\n std::unique_ptr<Graph> InitGraph2() {\n   GraphDefBuilder builder(GraphDefBuilder::kFailImmediately);\n-  const string dev0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n+  const std::string dev0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n   Node* a = ops::SourceOp(\"TestParams\",\n                           builder.opts().WithName(\"a\").WithDevice(dev0));\n   Node* c1 = CollectiveReduceNode(&builder, a, \"c1\", dev0, 1);\n@@ -201,7 +202,7 @@ TEST(CollectiveOrderTest, SimpleOrder2) {\n //\n std::unique_ptr<Graph> InitGraphForPruning() {\n   GraphDefBuilder builder(GraphDefBuilder::kFailImmediately);\n-  const string dev0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n+  const std::string dev0 = \"/job:localhost/replica:0/task:0/device:CPU:0\";\n   Node* w = ops::SourceOp(\"TestParams\",\n                           builder.opts().WithName(\"w\").WithDevice(dev0));\n   Node* x = ops::SourceOp(\"TestParams\","
        },
        {
            "sha": "fb5ce07959a424f6baba1bcec9d870ebaa1d74c3",
            "filename": "tensorflow/core/graph/graph_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Fgraph_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Fgraph_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgraph%2Fgraph_test.cc?ref=dfc5b243cae343738a0ecab747bbe7ed96859afd",
            "patch": "@@ -100,13 +100,13 @@ class GraphTest : public ::testing::Test {\n     EXPECT_EQ(edges, graph_.num_edges());\n   }\n \n-  Node* AddNodeWithName(const string& name) {\n+  Node* AddNodeWithName(const std::string& name) {\n     Node* node;\n     TF_CHECK_OK(NodeBuilder(name, \"NoOp\").Finalize(&graph_, &node));\n     return node;\n   }\n \n-  Node* FromNodeDef(const string& name, const string& node_type,\n+  Node* FromNodeDef(const std::string& name, const std::string& node_type,\n                     int num_inputs) {\n     auto builder = NodeDefBuilder(name, node_type);\n     for (int i = 0; i < num_inputs; ++i) {\n@@ -122,14 +122,14 @@ class GraphTest : public ::testing::Test {\n     return node;\n   }\n \n-  void FromGraphDef(const string& gdef_ascii) {\n+  void FromGraphDef(const std::string& gdef_ascii) {\n     GraphDef gdef;\n     CHECK(protobuf::TextFormat::ParseFromString(gdef_ascii, &gdef));\n     GraphConstructorOptions opts;\n     TF_CHECK_OK(ConvertGraphDefToGraph(opts, gdef, &graph_));\n   }\n \n-  Node* FindNode(const string& name) {\n+  Node* FindNode(const std::string& name) {\n     for (Node* node : graph_.nodes()) {\n       if (node->name() == name) return node;\n     }\n@@ -158,8 +158,8 @@ class GraphTest : public ::testing::Test {\n  private:\n   // Convert a list of nodes to a sorted list of strings so failure messages\n   // are readable.\n-  static std::vector<string> Stringify(const std::vector<Node*>& nodes) {\n-    std::vector<string> result;\n+  static std::vector<std::string> Stringify(const std::vector<Node*>& nodes) {\n+    std::vector<std::string> result;\n     result.reserve(nodes.size());\n     for (Node* n : nodes) {\n       result.push_back(n->DebugString());\n@@ -322,14 +322,14 @@ TEST_F(GraphTest, NodeIteration) {\n   graph_.RemoveNode(c);\n \n   // expected = set of all node DebugStrings we expect in the graph\n-  std::set<string> expected;\n+  std::set<std::string> expected;\n   expected.insert(graph_.source_node()->DebugString());\n   expected.insert(a->DebugString());\n   expected.insert(d->DebugString());\n   expected.insert(graph_.sink_node()->DebugString());\n \n   // Verify that iterating through ids gets the same set of nodes.\n-  std::set<string> actual;\n+  std::set<std::string> actual;\n   for (int id = 0; id < graph_.num_node_ids(); ++id) {\n     Node* node = graph_.FindNodeId(id);\n     if (node != nullptr) {\n@@ -370,7 +370,7 @@ TEST_F(GraphTest, AddAttr) {\n \n   n1->AddAttr(\"_a\", \"new_attr\");\n \n-  string attr;\n+  std::string attr;\n   EXPECT_EQ(absl::OkStatus(), GetNodeAttr(n1->attrs(), \"_a\", &attr));\n   EXPECT_EQ(\"new_attr\", attr);\n \n@@ -389,13 +389,13 @@ TEST_F(GraphTest, AddAttr) {\n }\n \n // Convert edge iteration results into a sorted string.\n-static string EdgeIter(const Graph& g) {\n+static std::string EdgeIter(const Graph& g) {\n   std::vector<std::pair<int, int> > edges;\n   for (const Edge* e : g.edges()) {\n     edges.push_back(std::make_pair(e->src()->id(), e->dst()->id()));\n   }\n   std::sort(edges.begin(), edges.end());\n-  string result;\n+  std::string result;\n   for (auto& p : edges) {\n     absl::StrAppend(&result, p.first, \"->\", p.second, \";\");\n   }\n@@ -422,9 +422,9 @@ TEST_F(GraphTest, EdgeIteration) {\n }\n \n TEST_F(GraphTest, NewName) {\n-  string a1 = graph_.NewName(\"A\");\n-  string a2 = graph_.NewName(\"A\");\n-  string b1 = graph_.NewName(\"B\");\n+  std::string a1 = graph_.NewName(\"A\");\n+  std::string a2 = graph_.NewName(\"A\");\n+  std::string b1 = graph_.NewName(\"B\");\n   EXPECT_NE(a1, a2);\n   EXPECT_NE(a1, b1);\n   EXPECT_NE(a2, b1);\n@@ -446,19 +446,19 @@ TEST_F(GraphTest, IsValidNode) {\n   // nullptr\n   absl::Status s = graph_.IsValidNode(nullptr);\n   EXPECT_EQ(error::INVALID_ARGUMENT, s.code());\n-  EXPECT_EQ(string(\"Node is null\"), s.message());\n+  EXPECT_EQ(std::string(\"Node is null\"), s.message());\n \n   // node id_ is too high\n   s = graph_.IsValidNode(g2_node2);\n   EXPECT_EQ(error::INVALID_ARGUMENT, s.code());\n-  EXPECT_EQ(string(\"node id 3 is >= than number of nodes in graph 3\"),\n+  EXPECT_EQ(std::string(\"node id 3 is >= than number of nodes in graph 3\"),\n             s.message());\n \n   // valid id_ but different ptr\n   s = graph_.IsValidNode(g2_node1);\n   EXPECT_EQ(error::INVALID_ARGUMENT, s.code());\n-  EXPECT_EQ(string(\"Node with id 2 is different from the passed in node. \"\n-                   \"Does it belong to a different graph?\"),\n+  EXPECT_EQ(std::string(\"Node with id 2 is different from the passed in node. \"\n+                        \"Does it belong to a different graph?\"),\n             s.message());\n }\n \n@@ -695,8 +695,8 @@ TEST_F(GraphTest, BuildNodeNameIndex) {\n   auto node_name_index = graph_.BuildNodeNameIndex();\n   EXPECT_EQ(node_name_index.size(), 5);\n \n-  std::vector<string> node_names{\"_SOURCE\", \"_SINK\", \"A\", \"B\", \"C\"};\n-  for (const string& node_name : node_names) {\n+  std::vector<std::string> node_names{\"_SOURCE\", \"_SINK\", \"A\", \"B\", \"C\"};\n+  for (const std::string& node_name : node_names) {\n     EXPECT_NE(node_name_index.find(node_name), node_name_index.end());\n     EXPECT_EQ(node_name_index[node_name], FindNode(node_name));\n   }"
        },
        {
            "sha": "f18d8a3bca0f1adcbd75b7a369289098e916125d",
            "filename": "tensorflow/core/graph/optimizer_cse.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Foptimizer_cse.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Foptimizer_cse.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgraph%2Foptimizer_cse.cc?ref=dfc5b243cae343738a0ecab747bbe7ed96859afd",
            "patch": "@@ -93,9 +93,9 @@ static size_t kIllegalNodeHash = 0;\n \n class Hasher {\n  public:\n-  uint64 hash() { return h_ == kIllegalNodeHash ? kIllegalNodeHash + 1 : h_; }\n+  uint64_t hash() { return h_ == kIllegalNodeHash ? kIllegalNodeHash + 1 : h_; }\n \n-  void MixString(const string& s) { h_ = Hash64(s.data(), s.size(), h_); }\n+  void MixString(const std::string& s) { h_ = Hash64(s.data(), s.size(), h_); }\n \n   void MixInteger(size_t z) { h_ = Hash64Combine(h_, z); }\n \n@@ -122,7 +122,7 @@ class Hasher {\n     // This kBufSize makes sizeof(HashingOutputStream) == 256.  It's not chosen\n     // for any particular reason except it's a nice even number of cache lines.\n     static constexpr size_t kBufSize = 228;\n-    static constexpr uint64 kDefaultSeed = 2570847921467975139ULL;\n+    static constexpr uint64_t kDefaultSeed = 2570847921467975139ULL;\n     bool Next(void** data, int* size) override {\n       if (i_ == kBufSize) {\n         // Mix the chunk in.\n@@ -174,7 +174,7 @@ class Hasher {\n \n     bool AllowsAliasing() const override { return true; }\n \n-    uint64 hash() {\n+    uint64_t hash() {\n       if (i_ != 0) {\n         Mix(buf_, i_);\n         i_ = 0;\n@@ -190,10 +190,10 @@ class Hasher {\n     char buf_[kBufSize];\n     int i_ = 0;\n     int64_t byte_count_ = 0;\n-    uint64 h_ = kDefaultSeed;\n+    uint64_t h_ = kDefaultSeed;\n   };\n \n-  uint64 h_ = HashingOutputStream::kDefaultSeed;\n+  uint64_t h_ = HashingOutputStream::kDefaultSeed;\n };\n \n size_t OptimizerCSE::NodeHash(const Node* n) {"
        },
        {
            "sha": "a5f4be88e8e5dedaed8fbbef49e4cddc090b5497",
            "filename": "tensorflow/core/graph/subgraph_test.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 19,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Fsubgraph_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/dfc5b243cae343738a0ecab747bbe7ed96859afd/tensorflow%2Fcore%2Fgraph%2Fsubgraph_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgraph%2Fsubgraph_test.cc?ref=dfc5b243cae343738a0ecab747bbe7ed96859afd",
            "patch": "@@ -49,24 +49,24 @@ class SubgraphTest : public ::testing::Test {\n \n   ~SubgraphTest() override {}\n \n-  void ExpectOK(const string& gdef_ascii) {\n+  void ExpectOK(const std::string& gdef_ascii) {\n     CHECK(protobuf::TextFormat::ParseFromString(gdef_ascii, &gdef_));\n     GraphConstructorOptions opts;\n     TF_CHECK_OK(ConvertGraphDefToGraph(opts, gdef_, g_.get()));\n   }\n \n-  Node* FindNode(const string& name) {\n+  Node* FindNode(const std::string& name) {\n     for (Node* n : g_->nodes()) {\n       if (n->name() == name) return n;\n     }\n     return nullptr;\n   }\n \n-  bool HasNode(const string& name) { return FindNode(name) != nullptr; }\n+  bool HasNode(const std::string& name) { return FindNode(name) != nullptr; }\n \n-  void ExpectNodes(const string& nodes) {\n+  void ExpectNodes(const std::string& nodes) {\n     int count = 0;\n-    std::vector<string> actual_nodes;\n+    std::vector<std::string> actual_nodes;\n     for (Node* n : g_->nodes()) {\n       if (n->IsOp()) {\n         count++;\n@@ -77,9 +77,9 @@ class SubgraphTest : public ::testing::Test {\n \n     LOG(INFO) << \"Nodes present: \" << absl::StrJoin(actual_nodes, \" \");\n \n-    std::vector<string> expected_nodes = str_util::Split(nodes, ',');\n+    std::vector<std::string> expected_nodes = str_util::Split(nodes, ',');\n     std::sort(expected_nodes.begin(), expected_nodes.end());\n-    for (const string& s : expected_nodes) {\n+    for (const std::string& s : expected_nodes) {\n       Node* n = FindNode(s);\n       EXPECT_TRUE(n != nullptr) << s;\n       if (n->type_string() == \"_Send\" || n->type_string() == \"_Recv\") {\n@@ -92,28 +92,29 @@ class SubgraphTest : public ::testing::Test {\n         << \"\\nExpected: \" << absl::StrJoin(expected_nodes, \",\");\n   }\n \n-  bool HasEdge(const string& src, int src_out, const string& dst, int dst_in) {\n+  bool HasEdge(const std::string& src, int src_out, const std::string& dst,\n+               int dst_in) {\n     for (const Edge* e : g_->edges()) {\n       if (e->src()->name() == src && e->src_output() == src_out &&\n           e->dst()->name() == dst && e->dst_input() == dst_in)\n         return true;\n     }\n     return false;\n   }\n-  bool HasControlEdge(const string& src, const string& dst) {\n+  bool HasControlEdge(const std::string& src, const std::string& dst) {\n     return HasEdge(src, Graph::kControlSlot, dst, Graph::kControlSlot);\n   }\n \n-  string Subgraph(const string& fed_str, const string& fetch_str,\n-                  const string& targets_str,\n-                  bool use_function_convention = false) {\n+  std::string Subgraph(const std::string& fed_str, const std::string& fetch_str,\n+                       const std::string& targets_str,\n+                       bool use_function_convention = false) {\n     Graph* subgraph = new Graph(OpRegistry::Global());\n     CopyGraph(*g_, subgraph);\n-    std::vector<string> fed =\n+    std::vector<std::string> fed =\n         str_util::Split(fed_str, ',', str_util::SkipEmpty());\n-    std::vector<string> fetch =\n+    std::vector<std::string> fetch =\n         str_util::Split(fetch_str, ',', str_util::SkipEmpty());\n-    std::vector<string> targets =\n+    std::vector<std::string> targets =\n         str_util::Split(targets_str, ',', str_util::SkipEmpty());\n \n     subgraph::RewriteGraphMetadata metadata;\n@@ -355,7 +356,7 @@ void BM_SubgraphHelper(::testing::benchmark::State& state,\n     GraphDefBuilder b(GraphDefBuilder::kFailImmediately);\n     Node* last_node = nullptr;\n     for (int i = 0; i < num_nodes; i++) {\n-      string name = absl::StrCat(\"N\", i);\n+      std::string name = absl::StrCat(\"N\", i);\n       if (i > 0) {\n         last_node = ops::UnaryOp(\"Op\", last_node, b.opts().WithName(name));\n       } else {\n@@ -365,12 +366,12 @@ void BM_SubgraphHelper(::testing::benchmark::State& state,\n     TF_CHECK_OK(GraphDefBuilderToGraph(b, &g));\n   }\n \n-  std::vector<string> fed;\n+  std::vector<std::string> fed;\n   if (num_nodes > 1000) {\n     fed.push_back(absl::StrCat(\"N\", num_nodes - 1000));\n   }\n-  std::vector<string> fetch;\n-  std::vector<string> targets = {absl::StrCat(\"N\", num_nodes - 1)};\n+  std::vector<std::string> fetch;\n+  std::vector<std::string> targets = {absl::StrCat(\"N\", num_nodes - 1)};\n \n   for (auto s : state) {\n     Graph* subgraph = new Graph(OpRegistry::Global());"
        }
    ],
    "stats": {
        "total": 133,
        "additions": 68,
        "deletions": 65
    }
}