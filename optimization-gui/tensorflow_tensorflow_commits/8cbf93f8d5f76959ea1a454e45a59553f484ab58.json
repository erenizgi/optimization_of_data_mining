{
    "author": "mkuperst",
    "message": "[XLA] Another small refactor in call splitter.\n\nPiperOrigin-RevId: 834776465",
    "sha": "8cbf93f8d5f76959ea1a454e45a59553f484ab58",
    "files": [
        {
            "sha": "e877a6c8d1dc2f1f1d177c8fe684acd10c6f6fc9",
            "filename": "third_party/xla/xla/hlo/transforms/call_splitter.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8cbf93f8d5f76959ea1a454e45a59553f484ab58/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8cbf93f8d5f76959ea1a454e45a59553f484ab58/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.cc?ref=8cbf93f8d5f76959ea1a454e45a59553f484ab58",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n \n #include <algorithm>\n #include <memory>\n+#include <utility>\n #include <vector>\n \n #include \"absl/container/flat_hash_map.h\"\n@@ -106,9 +107,10 @@ absl::Status SplitCallSite(HloInstruction* call,\n   second_call->set_to_apply(second_call_computation);\n   return call->ReplaceAllUsesWith(second_call);\n }\n+}  // namespace\n \n-absl::StatusOr<bool> SplitCall(HloInstruction* call,\n-                               HloPredicate boundary_predicate) {\n+std::pair<HloComputation*, HloComputation*> CallSplitter::SplitCallBody(\n+    HloComputation* body, HloPredicate boundary_predicate) {\n   // We need to do several things here:\n   // 1. Figure out which instructions go into the first call and which into the\n   // second. In particular:\n@@ -126,14 +128,12 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n   // TODO(mkuper): This splits \"down\". We also want a version that splits \"up\",\n   // i.e. the boundary ends up in the first call, and the \"irrelevant\"\n   // instructions end up in the second one.\n-\n-  HloComputation* body = call->to_apply();\n   HloModule* module = body->parent();\n \n   std::vector<HloInstruction*> boundary_instructions =\n       GetBoundaryInstructions(body, boundary_predicate);\n   if (boundary_instructions.empty()) {\n-    return false;\n+    return std::make_pair(nullptr, nullptr);\n   }\n \n   absl::flat_hash_set<HloInstruction*> second_call_instructions =\n@@ -146,7 +146,7 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n     }\n   }\n   if (first_call_instructions.empty() || second_call_instructions.empty()) {\n-    return false;\n+    return std::make_pair(nullptr, nullptr);\n   }\n \n   if (VLOG_IS_ON(1)) {\n@@ -170,7 +170,7 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n       // Don't break the function if it would create a control edge that needs\n       // to be threaded between the two new functions.\n       if (first_call_instructions.contains(control_pred)) {\n-        return false;\n+        return std::make_pair(nullptr, nullptr);\n       }\n     }\n     for (HloInstruction* data_pred : instruction->operands()) {\n@@ -229,17 +229,12 @@ absl::StatusOr<bool> SplitCall(HloInstruction* call,\n           &second_call_replacements, /*extra_parameters=*/{},\n           /*context=*/nullptr, /*suffix=*/\"second\", /*new_root=*/nullptr));\n \n-  TF_RETURN_IF_ERROR(\n-      SplitCallSite(call, first_call_computation, second_call_computation));\n-  return true;\n+  return std::make_pair(first_call_computation, second_call_computation);\n }\n \n-}  // namespace\n-\n absl::StatusOr<bool> CallSplitter::RunImpl(\n     HloModule* module,\n     const absl::flat_hash_set<absl::string_view>& execution_threads) {\n-  bool changed = false;\n   // Find all the call instructions that match the predicate. We don't process\n   // them immediately since we're going to change their enclosing computation.\n   // process all calls in a computation together. Note that we want to process\n@@ -280,9 +275,14 @@ absl::StatusOr<bool> CallSplitter::RunImpl(\n     }\n   }\n \n+  bool changed = false;\n   for (HloInstruction* call : calls_to_process) {\n-    TF_ASSIGN_OR_RETURN(bool split, SplitCall(call, boundary_predicate_));\n-    changed |= split;\n+    auto split_result = SplitCallBody(call->to_apply(), boundary_predicate_);\n+    if (split_result.first != nullptr) {\n+      changed |= true;\n+      TF_RETURN_IF_ERROR(\n+          SplitCallSite(call, split_result.first, split_result.second));\n+    }\n   }\n \n   return changed;"
        },
        {
            "sha": "477e1e447fd33248ed56045d301d5b9d0c3dff0f",
            "filename": "third_party/xla/xla/hlo/transforms/call_splitter.h",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8cbf93f8d5f76959ea1a454e45a59553f484ab58/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8cbf93f8d5f76959ea1a454e45a59553f484ab58/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fcall_splitter.h?ref=8cbf93f8d5f76959ea1a454e45a59553f484ab58",
            "patch": "@@ -16,6 +16,8 @@ limitations under the License.\n #ifndef XLA_HLO_TRANSFORMS_CALL_SPLITTER_H_\n #define XLA_HLO_TRANSFORMS_CALL_SPLITTER_H_\n \n+#include <utility>\n+\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -79,6 +81,11 @@ class CallSplitter : public HloModulePass {\n       HloModule* module,\n       const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n \n+  // Splits the body of the given call into two computations, according to the\n+  // given boundary predicate. Returns the two new computations.\n+  std::pair<HloComputation*, HloComputation*> SplitCallBody(\n+      HloComputation* body, HloPredicate boundary_predicate);\n+\n  protected:\n   HloPredicate call_predicate_;\n   HloPredicate boundary_predicate_;"
        }
    ],
    "stats": {
        "total": 37,
        "additions": 22,
        "deletions": 15
    }
}