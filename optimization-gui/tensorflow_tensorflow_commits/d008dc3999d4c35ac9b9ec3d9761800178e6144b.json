{
    "author": "Varcho",
    "message": "Reverts d25ccb438dbedd21f35b53c2169926fc3ee032b6\n\nPiperOrigin-RevId: 826583855",
    "sha": "d008dc3999d4c35ac9b9ec3d9761800178e6144b",
    "files": [
        {
            "sha": "17d4ce9a2f2eb0eddd4fdd800f272081a495e10a",
            "filename": "third_party/xla/xla/array.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Farray.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Farray.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Farray.h?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -22,7 +22,6 @@ limitations under the License.\n #include <cstdint>\n #include <cstring>\n #include <functional>\n-#include <initializer_list>\n #include <iterator>\n #include <limits>\n #include <memory>"
        },
        {
            "sha": "bd8c592cb48c1d6a5a694dba122e7d5d88762097",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -60,6 +60,7 @@ cc_library(\n     deps = [\n         \":backend_config\",\n         \":hlo_sharding\",\n+        \":mesh_and_axis\",\n         \":named_sharding\",\n         \":ptrvec\",\n         \":tile_assignment\",\n@@ -123,6 +124,7 @@ cc_library(\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/types:span\",\n+        \"@com_google_protobuf//:protobuf_lite\",\n         \"@highwayhash\",\n         \"@highwayhash//:arch_specific\",\n         \"@highwayhash//:hh_types\",\n@@ -188,6 +190,7 @@ cc_library(\n         \"//xla:xla_data_proto_cc\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n     ],\n@@ -416,6 +419,9 @@ xla_cc_test(\n     srcs = [\"replica_group_test.cc\"],\n     deps = [\n         \":hlo\",\n+        \":mesh_and_axis\",\n+        \":tile_assignment\",\n+        \"//xla:array\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/service:hlo_proto_cc\",\n         \"//xla/tsl/platform:test_main\",\n@@ -434,8 +440,6 @@ xla_cc_test(\n         \"//xla/tsl/util/proto:proto_matchers\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n-        \"@local_tsl//tsl/platform:status_matchers\",\n-        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n "
        },
        {
            "sha": "affea3ac436d4563617d9b16210e4f6606163c35",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -24,6 +24,8 @@ limitations under the License.\n #include <vector>\n \n #include \"absl/log/check.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n@@ -73,6 +75,28 @@ class Mesh {\n            axes_names_ == other.axes_names_;\n   }\n \n+  std::string ToString() const {\n+    std::string mesh_str = \"@mesh\";\n+    // Add the mesh axes names and sizes.\n+    std::vector<std::string> formatted_axes_names;\n+    formatted_axes_names.reserve(axes_names_.size());\n+    for (int64_t i = 0; i < axes_names_.size(); ++i) {\n+      formatted_axes_names.push_back(\n+          absl::StrCat(axes_names_[i], \"=\", device_assignment_.dim(i)));\n+    }\n+\n+    // Add the device assignment if it is not an iota case.\n+    std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n+    std::string device_assignment_str = \"\";\n+    if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n+      device_assignment_str =\n+          absl::StrCat(\"(\", device_assignment_.ArrayToString(), \")\");\n+    }\n+    absl::StrAppend(&mesh_str, \"<\", absl::StrJoin(formatted_axes_names, \",\"),\n+                    \">\", device_assignment_str);\n+    return mesh_str;\n+  }\n+\n   bool operator!=(const Mesh& other) const { return !(*this == other); }\n \n   bool DeviceAssignmentEquals(const Mesh& other) const {\n@@ -84,6 +108,7 @@ class Mesh {\n   static Mesh FromProto(const MeshProto& proto);\n \n   TileAssignment device_assignment() const { return device_assignment_; }\n+  std::vector<std::string> axis_names() const { return axes_names_; }\n \n  private:\n   // Dimensions of the `device_assignment_` array correspond to the axes of the\n@@ -135,6 +160,17 @@ class AxisRef {\n     return true;\n   }\n \n+  std::string ToString(const Mesh& mesh) const {\n+    CHECK_GE(mesh_axis_index_, 0);\n+    CHECK_LT(mesh_axis_index_, mesh.axis_names().size());\n+    std::string axis_str = mesh.axis_names()[mesh_axis_index()];\n+    if (sub_axis_info_.has_value()) {\n+      absl::StrAppend(&axis_str, \":(\", sub_axis_info_->pre_size, \")\",\n+                      sub_axis_info_->size);\n+    }\n+    return axis_str;\n+  }\n+\n   bool operator!=(const xla::AxisRef& other) const { return !(*this == other); }\n \n   AxisRefProto ToProto() const;"
        },
        {
            "sha": "8038d6f18daa9990b8b5de85bcf49449b90b8fbd",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis_test.cc?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -176,4 +176,20 @@ TEST(MeshAndAxisTest, MeshRoundtripProto) {\n   EXPECT_THAT(mesh_non_iota, Mesh::FromProto(mesh_non_iota.ToProto()));\n }\n \n+TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n+  Mesh mesh_uvw({10, 12, 15}, {\"u\", \"v\", \"w\"});\n+  EXPECT_EQ(mesh_uvw.ToString(), \"@mesh<u=10,v=12,w=15>\");\n+\n+  Mesh mesh_abcd(TileAssignment(IotaTileAssignment::Create(\n+                     /*dims=*/{2, 4, 4, 2}, /*reshape_dims=*/{1, 4, 1, 16},\n+                     /*transpose_perm=*/{2, 3, 0, 1})),\n+                 /*axes_names=*/{\"a\", \"b\", \"c\", \"d\"});\n+  EXPECT_EQ(mesh_abcd.ToString(), \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0))\");\n+\n+  Array<int64_t> array({{8, 3, 7, 5, 4, 2, 6, 0, 1, 9}});\n+  array.Reshape({10});\n+  Mesh mesh_ooo(array, /*axes_names=*/{\"ooo\"});\n+  EXPECT_EQ(mesh_ooo.ToString(), \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9)\");\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "eba41f94d30b0b6ee4dadbfbe04d4fd6c215a73f",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n \n #include <cstdint>\n #include <memory>\n+#include <optional>\n #include <string>\n #include <vector>\n \n@@ -26,6 +27,8 @@ limitations under the License.\n #include \"absl/strings/str_join.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n+#include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/printer.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/tsl/platform/logging.h\"  // IWYU pragma: keep\n@@ -45,6 +48,63 @@ std::string ReplicaGroupsToString(\n   return absl::StrCat(\"{\", absl::StrJoin(replica_group_str, \",\"), \"}\");\n }\n \n+/************** MeshAxesReplicaGroupList implementation ***********************/\n+int64_t MeshAxesReplicaGroupList::num_replica_groups() const {\n+  return mesh_.device_assignment().num_elements() / num_devices_per_group();\n+}\n+\n+int64_t MeshAxesReplicaGroupList::num_devices_per_group() const {\n+  // Number of devices per replica group is equal to the product of the sizes of\n+  // all axes.\n+  int64_t devices_per_group = 1;\n+  for (const AxisRef& axis : axes_) {\n+    int64_t axis_size =\n+        axis.sub_axis_info().has_value()\n+            ? axis.sub_axis_info()->size\n+            : mesh_.device_assignment().dim(axis.mesh_axis_index());\n+    devices_per_group *= axis_size;\n+  }\n+  return devices_per_group;\n+}\n+\n+void MeshAxesReplicaGroupList::Print(Printer* printer) const {\n+  printer->Append(ToString());\n+}\n+\n+std::string MeshAxesReplicaGroupList::ToString() const {\n+  std::string rg_str = \"\";\n+  // Add the axes defining the replica group, using names from the mesh.\n+  std::vector<std::string> group_axes_str;\n+  group_axes_str.reserve(axes_.size());\n+  for (const AxisRef& axis : axes_) {\n+    std::string axis_str = axis.ToString(mesh_);\n+    group_axes_str.push_back(axis_str);\n+  }\n+  absl::StrAppend(&rg_str, mesh_.ToString(), \" {\",\n+                  absl::StrJoin(group_axes_str, \",\"), \"}\");\n+  return rg_str;\n+}\n+\n+MeshAxesReplicaGroupListProto MeshAxesReplicaGroupList::ToProto() const {\n+  MeshAxesReplicaGroupListProto proto;\n+  *proto.mutable_mesh() = mesh_.ToProto();\n+  for (const AxisRef& axis : axes_) {\n+    *proto.add_axes() = axis.ToProto();\n+  }\n+  return proto;\n+}\n+\n+MeshAxesReplicaGroupList MeshAxesReplicaGroupList::FromProto(\n+    const MeshAxesReplicaGroupListProto& proto) {\n+  Mesh mesh = Mesh::FromProto(proto.mesh());\n+  std::vector<AxisRef> axes;\n+  for (const AxisRefProto& axis_proto : proto.axes()) {\n+    axes.push_back(AxisRef::FromProto(axis_proto));\n+  }\n+  return MeshAxesReplicaGroupList(mesh, axes);\n+}\n+\n+/************** IotaReplicaGroupList implementation ***************************/\n int64_t IotaReplicaGroupList::num_replica_groups() const {\n   DCHECK_GE(num_replica_groups_, 0);\n   return num_replica_groups_;\n@@ -121,6 +181,7 @@ std::shared_ptr<std::vector<ReplicaGroup>> ExpandIota(\n }\n }  // namespace\n \n+/************** CollectiveDeviceList implementation ***************************/\n const std::vector<ReplicaGroup>& CollectiveDeviceList::replica_groups() const {\n   if (replica_groups_ == nullptr) {\n     CHECK(iota_replica_group_list_.has_value());"
        },
        {
            "sha": "de8412df22a9026efe0cd415f9e3b9a0b2a53f43",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.h",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -24,8 +24,11 @@ limitations under the License.\n #include <utility>\n #include <vector>\n \n+#include \"absl/log/log.h\"\n #include \"absl/types/span.h\"\n+#include \"google/protobuf/repeated_ptr_field.h\"\n #include \"xla/array.h\"\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/printer.h\"\n #include \"xla/service/hlo.pb.h\"\n@@ -34,6 +37,42 @@ limitations under the License.\n \n namespace xla {\n \n+class MeshAxesReplicaGroupList {\n+ public:\n+  explicit MeshAxesReplicaGroupList(Mesh mesh, std::vector<AxisRef> axes)\n+      : mesh_(std::move(mesh)), axes_(std::move(axes)) {\n+    if (num_devices_per_group() == 1) {\n+      LOG(ERROR) << \"MeshAxesReplicaGroupList: \" << ToString()\n+                 << \" has only one device per replica group.\";\n+    }\n+  }\n+\n+  bool operator==(const MeshAxesReplicaGroupList& other) const {\n+    return mesh_ == other.mesh_ && axes_ == other.axes_;\n+  }\n+\n+  template <typename H>\n+  friend H AbslHashValue(H h, const MeshAxesReplicaGroupList& c) {\n+    return H::combine(std::move(h), c.mesh_, c.axes_);\n+  }\n+\n+  int64_t num_replica_groups() const;\n+  int64_t num_devices_per_group() const;\n+\n+  void Print(Printer* printer) const;\n+\n+  std::string ToString() const;\n+\n+  MeshAxesReplicaGroupListProto ToProto() const;\n+\n+  static MeshAxesReplicaGroupList FromProto(\n+      const MeshAxesReplicaGroupListProto& proto);\n+\n+ private:\n+  Mesh mesh_;\n+  std::vector<AxisRef> axes_;\n+};\n+\n std::string ReplicaGroupsToString(\n     absl::Span<const ReplicaGroup> replica_groups);\n "
        },
        {
            "sha": "5cd40ad68dc259b5e9d6b08eae29cfdca2226ea5",
            "filename": "third_party/xla/xla/hlo/ir/replica_group_test.cc",
            "status": "modified",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -16,10 +16,14 @@ limitations under the License.\n #include \"xla/hlo/ir/replica_group.h\"\n \n #include <cstdint>\n+#include <memory>\n #include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"xla/array.h\"\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n+#include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -37,6 +41,109 @@ CollectiveDeviceListProto CreateDeviceListProto(\n   return proto;\n }\n \n+TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSize) {\n+  Mesh all_axes(TileAssignment(IotaTileAssignment::Create(\n+                    /*dims=*/{4, 4})),\n+                /*axes_names=*/{\"x\", \"y\"});\n+  MeshAxesReplicaGroupList replica_group_across_all_axes(\n+      all_axes,\n+      /*axes=*/{AxisRef(0), AxisRef(1)});\n+  EXPECT_EQ(replica_group_across_all_axes.num_replica_groups(), 1);\n+  EXPECT_EQ(replica_group_across_all_axes.num_devices_per_group(), 16);\n+\n+  Mesh one_axes(TileAssignment(IotaTileAssignment::Create(\n+                    /*dims=*/{3, 5})),\n+                /*axes_names=*/{\"a\", \"b\"});\n+  MeshAxesReplicaGroupList replica_group_across_a(one_axes,\n+                                                  /*axes=*/{AxisRef(0)});\n+  MeshAxesReplicaGroupList replica_group_across_b(one_axes,\n+                                                  /*axes=*/{AxisRef(1)});\n+  EXPECT_EQ(replica_group_across_a.num_replica_groups(), 5);\n+  EXPECT_EQ(replica_group_across_a.num_devices_per_group(), 3);\n+  EXPECT_EQ(replica_group_across_b.num_replica_groups(), 3);\n+  EXPECT_EQ(replica_group_across_b.num_devices_per_group(), 5);\n+\n+  Mesh no_axes(TileAssignment(IotaTileAssignment::Create(\n+                   /*dims=*/{2, 3, 5})),\n+               /*axes_names=*/{\"p1\", \"p2\", \"p3\"});\n+  MeshAxesReplicaGroupList replica_group_across_no_axes(no_axes, /*axes=*/{});\n+  EXPECT_EQ(replica_group_across_no_axes.num_replica_groups(), 2 * 3 * 5);\n+  EXPECT_EQ(replica_group_across_no_axes.num_devices_per_group(), 1);\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n+  Mesh mesh_one_subaxis(TileAssignment(IotaTileAssignment::Create(\n+                            /*dims=*/{2, 6, 10})),\n+                        /*axes_names=*/{\"axis1\", \"axis2\", \"axis3\"});\n+  MeshAxesReplicaGroupList replica_group_across_axis1_subaxis(\n+      mesh_one_subaxis,\n+      /*axes=*/{AxisRef(0, {1, 2})});\n+  MeshAxesReplicaGroupList replica_group_across_axis2_subaxis(\n+      mesh_one_subaxis,\n+      /*axes=*/{AxisRef(1, {2, 3})});\n+  EXPECT_EQ(replica_group_across_axis1_subaxis.num_replica_groups(), 60);\n+  EXPECT_EQ(replica_group_across_axis1_subaxis.num_devices_per_group(), 2);\n+  EXPECT_EQ(replica_group_across_axis2_subaxis.num_replica_groups(), 40);\n+  EXPECT_EQ(replica_group_across_axis2_subaxis.num_devices_per_group(), 3);\n+\n+  Mesh mesh_multiple_subaxis(TileAssignment(IotaTileAssignment::Create(\n+                                 /*dims=*/{2 * 3, 5 * 7, 11 * 13})),\n+                             /*axes_names=*/{\"alpha\", \"beta\", \"gamma\"});\n+  MeshAxesReplicaGroupList replica_group_across_multiple_subaxis1(\n+      mesh_multiple_subaxis,\n+      /*axes=*/{AxisRef(0, {1, 2}), AxisRef(1, {1, 5}), AxisRef(2, {1, 11})});\n+  MeshAxesReplicaGroupList replica_group_across_multiple_subaxis2(\n+      mesh_multiple_subaxis,\n+      /*axes=*/{AxisRef(0, {2, 3}), AxisRef(1, {5, 7}), AxisRef(2, {11, 13})});\n+  EXPECT_EQ(replica_group_across_multiple_subaxis1.num_replica_groups(),\n+            3 * 7 * 13);\n+  EXPECT_EQ(replica_group_across_multiple_subaxis1.num_devices_per_group(),\n+            2 * 5 * 11);\n+  EXPECT_EQ(replica_group_across_multiple_subaxis2.num_replica_groups(),\n+            2 * 5 * 11);\n+  EXPECT_EQ(replica_group_across_multiple_subaxis2.num_devices_per_group(),\n+            3 * 7 * 13);\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n+  // No subaxes and iota device assignment.\n+  Mesh mesh_uvw(TileAssignment(IotaTileAssignment::Create(\n+                    /*dims=*/{10, 12, 15})),\n+                /*axes_names=*/{\"u\", \"v\", \"w\"});\n+  MeshAxesReplicaGroupList replica_group_across_none(mesh_uvw, /*axes=*/{});\n+  EXPECT_EQ(replica_group_across_none.ToString(), \"@mesh<u=10,v=12,w=15> {}\");\n+  MeshAxesReplicaGroupList replica_group_across_uv(\n+      mesh_uvw,\n+      /*axes=*/{AxisRef(0), AxisRef(1)});\n+  EXPECT_EQ(replica_group_across_uv.ToString(), \"@mesh<u=10,v=12,w=15> {u,v}\");\n+\n+  // Subaxes and replica group v2 iota style device assignment.\n+  Mesh mesh_abcd(TileAssignment(IotaTileAssignment::Create(\n+                     /*dims=*/{2, 4, 4, 2}, /*reshape_dims=*/{1, 4, 1, 16},\n+                     /*transpose_perm=*/{2, 3, 0, 1})),\n+                 /*axes_names=*/{\"a\", \"b\", \"c\", \"d\"});\n+  MeshAxesReplicaGroupList rg_abcd_across_none(mesh_abcd, /*axes=*/{});\n+  EXPECT_EQ(rg_abcd_across_none.ToString(),\n+            \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {}\");\n+  MeshAxesReplicaGroupList rg_abcd_across_multiple_axes_and_subaxes(\n+      mesh_abcd, /*axes=*/{AxisRef(0), AxisRef(1, {1, 2}), AxisRef(3)});\n+  EXPECT_EQ(rg_abcd_across_multiple_axes_and_subaxes.ToString(),\n+            \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {a,b:(1)2,d}\");\n+\n+  // Subaxes and random device assignment.\n+  Array<int64_t> array({{8, 3, 7, 5, 4, 2, 6, 0, 1, 9}});\n+  array.Reshape({10});\n+  TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n+  Mesh mesh_ooo(tile_assignment, /*axes_names=*/{\"ooo\"});\n+  MeshAxesReplicaGroupList rg_ooo_across_none(mesh_ooo, /*axes=*/{});\n+  EXPECT_EQ(rg_ooo_across_none.ToString(),\n+            \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {}\");\n+  MeshAxesReplicaGroupList rg_ooo_across_ooo_5_2(mesh_ooo,\n+                                                 /*axes=*/{AxisRef(0, {5, 2})});\n+  EXPECT_EQ(rg_ooo_across_ooo_5_2.ToString(),\n+            \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {ooo:(5)2}\");\n+}\n+\n TEST(CollectiveDeviceListTest, DefaultListToString) {\n   EXPECT_EQ(CollectiveDeviceList().ToString(true), \"{}\");\n   EXPECT_EQ(CollectiveDeviceList().ToString(false), \"{}\");"
        },
        {
            "sha": "9557c9526209a1eefb243d21094cf93382f2aa95",
            "filename": "third_party/xla/xla/xla_data.proto",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fxla_data.proto",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d008dc3999d4c35ac9b9ec3d9761800178e6144b/third_party%2Fxla%2Fxla%2Fxla_data.proto",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fxla_data.proto?ref=d008dc3999d4c35ac9b9ec3d9761800178e6144b",
            "patch": "@@ -1192,6 +1192,19 @@ message ReplicaGroup {\n   repeated int64 replica_ids = 1;\n }\n \n+// Represents a list of replica groups (a list of list of devices) via a mesh\n+// and list of axes. The replica groups correspond to the partitions of the\n+// device ids which would arise if a collective operation was performed over the\n+// specified axes.\n+message MeshAxesReplicaGroupListProto {\n+  // The mesh used to define the full set of axes and devices ids.\n+  MeshProto mesh = 1;\n+  // The axes defining the replica groups. These groups are implicitly defined\n+  // by the device ids which would communicate together if a collective\n+  // operation is performed over these axes.\n+  repeated AxisRefProto axes = 2;\n+}\n+\n // Represents a list of replica groups (a list of list of devices) with\n // reshaping and transposing an iota array (iota tile assignment). Can be used\n // to represent certain common patterns of device lists in a compact, scalable"
        }
    ],
    "stats": {
        "total": 281,
        "additions": 278,
        "deletions": 3
    }
}