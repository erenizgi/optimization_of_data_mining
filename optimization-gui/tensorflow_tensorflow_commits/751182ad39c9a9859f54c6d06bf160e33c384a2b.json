{
    "author": "DottsGit",
    "message": "Add test for decode_image shape inference fix\n\n- Test decode_image + resize compatibility in tf.data pipelines\n- Verifies fix for ValueError: 'images' contains no shape\n- Covers multiple channel counts and edge cases",
    "sha": "751182ad39c9a9859f54c6d06bf160e33c384a2b",
    "files": [
        {
            "sha": "e9b97577d6712b78960e5135cfbb92b8c5a6c44a",
            "filename": "tensorflow/python/ops/image_ops_test.py",
            "status": "modified",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/751182ad39c9a9859f54c6d06bf160e33c384a2b/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/751182ad39c9a9859f54c6d06bf160e33c384a2b/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py?ref=751182ad39c9a9859f54c6d06bf160e33c384a2b",
            "patch": "@@ -6613,6 +6613,81 @@ def testGifFramesWithDiffSize(self):\n     image0, image1_0 = self.evaluate([image0, image1_0])\n     self.assertAllEqual(image0, image1_0)\n \n+  def testDecodeImageShapeInferenceInDataPipeline(self):\n+    \"\"\"Test that decode_image sets proper shape inference in tf.data pipelines.\n+\n+    This test verifies the fix for the issue where tf.image.decode_image\n+    followed by tf.image.resize would fail with \"ValueError: 'images' contains\n+    no shape\" when used in tf.data.Dataset.map() operations.\n+\n+    The fix ensures that when expand_animations=False, the output tensor shape\n+    is properly set to [None, None, channels] for known channel counts or\n+    [None, None, None] for unknown channel counts, enabling proper shape\n+    inference for subsequent operations like resize.\n+    \"\"\"\n+    # Create test JPEG image data\n+    test_image = constant_op.constant([[[255, 0, 0], [0, 255, 0]], \n+                                       [[0, 0, 255], [255, 255, 0]]], \n+                                      dtype=dtypes.uint8)\n+    jpeg_bytes = gen_image_ops.encode_jpeg(test_image)\n+\n+    def process_image_fixed(image_bytes):\n+      \"\"\"Process function using the fix: expand_animations=False.\"\"\"\n+      decoded = image_ops.decode_image(image_bytes, channels=3, \n+                                       expand_animations=False)\n+      # This should work without ValueError due to proper shape inference\n+      resized = image_ops.resize(decoded, [224, 224])\n+      return resized\n+\n+\n+\n+    with self.cached_session():\n+      # Test the fixed version in a data pipeline\n+      dataset_fixed = dataset_ops.Dataset.from_tensor_slices([jpeg_bytes])\n+      dataset_fixed = dataset_fixed.map(process_image_fixed)\n+      \n+      # Verify we can iterate through the dataset without errors\n+      for processed_image in dataset_fixed:\n+        processed_image_val = self.evaluate(processed_image)\n+        self.assertEqual(processed_image_val.shape, (224, 224, 3))\n+\n+      # Test that decode_image with expand_animations=False sets proper shape\n+      decoded_fixed = image_ops.decode_image(jpeg_bytes, channels=3,\n+                                             expand_animations=False)\n+      self.assertEqual(decoded_fixed.shape.rank, 3)\n+      self.assertEqual(decoded_fixed.shape.as_list(), [None, None, 3])\n+\n+      # Test with different channel counts\n+      for channels in [1, 3, 4]:\n+        if channels == 1:\n+          # Create grayscale test image\n+          gray_image = constant_op.constant([[128, 64], [192, 32]], \n+                                           dtype=dtypes.uint8)\n+          gray_image = array_ops.expand_dims(gray_image, -1)\n+          test_bytes = gen_image_ops.encode_png(gray_image)\n+        else:\n+          # Use the RGB image for 3 and 4 channel tests\n+          test_bytes = jpeg_bytes\n+\n+        decoded = image_ops.decode_image(test_bytes, channels=channels,\n+                                         expand_animations=False)\n+        self.assertEqual(decoded.shape.rank, 3)\n+        \n+        if channels <= 3:  # JPEG/PNG support up to 3 channels typically\n+          expected_shape = [None, None, channels]\n+        else:\n+          # For unsupported channel counts, we still get proper rank\n+          expected_shape = [None, None, None]\n+        \n+        # The key fix: shape is properly inferred for resize operations\n+        self.assertTrue(decoded.shape.is_compatible_with(expected_shape))\n+\n+      # Test that unknown channel count still sets proper rank\n+      decoded_unknown = image_ops.decode_image(jpeg_bytes, \n+                                               expand_animations=False)\n+      self.assertEqual(decoded_unknown.shape.rank, 3)\n+      self.assertEqual(decoded_unknown.shape.as_list(), [None, None, None])\n+\n \n if __name__ == \"__main__\":\n   googletest.main()"
        }
    ],
    "stats": {
        "total": 75,
        "additions": 75,
        "deletions": 0
    }
}