{
    "author": "ezhulenev",
    "message": "[xla] Migrate to PjRtFuture<>::MakePromise() API\n\nPiperOrigin-RevId: 806712779",
    "sha": "9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0",
    "files": [
        {
            "sha": "70d8be6e513ff3da4a19b233deb01086dbad8838",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0",
            "patch": "@@ -974,11 +974,10 @@ PJRT_Error* PJRT_Client_BufferFromHostBuffer(\n     }\n   }\n \n-  xla::PjRtFuture<>::Promise promise = xla::PjRtFuture<>::CreatePromise();\n+  auto [promise, future] = xla::PjRtFuture<>::MakePromise();\n \n-  absl::AnyInvocable<void() &&> on_done_with_host_buffer = [promise]() mutable {\n-    promise.Set();\n-  };\n+  absl::AnyInvocable<void() &&> on_done_with_host_buffer =\n+      [promise = std::move(promise)]() mutable { promise.Set(); };\n \n   std::unique_ptr<xla::PjRtBuffer> buffer;\n   bool has_layout_and_memory = layout.has_value() && args->memory != nullptr;\n@@ -1029,8 +1028,7 @@ PJRT_Error* PJRT_Client_BufferFromHostBuffer(\n   }\n \n   args->buffer = new PJRT_Buffer{std::move(buffer), args->client};\n-  args->done_with_host_buffer =\n-      new PJRT_Event{xla::PjRtFuture<>(std::move(promise))};\n+  args->done_with_host_buffer = new PJRT_Event{std::move(future)};\n \n   return nullptr;\n }"
        },
        {
            "sha": "d3bd05a52d636eb975bd484c45fee14e2b19ce19",
            "filename": "third_party/xla/xla/pjrt/gpu/se_gpu_pjrt_client.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 13,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Fse_gpu_pjrt_client.cc?ref=9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0",
            "patch": "@@ -798,7 +798,7 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n         InvalidArgument(\"Copy raw buffer called on an invalid buffer\"));\n   }\n \n-  auto promise = PjRtFuture<>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   auto usage_event = BufferSequencingEvent::Create(this->thread_pool());\n \n   auto definition_events = hold->definition_events();\n@@ -813,28 +813,29 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n   // stall the compute stream.\n   hold.ConvertUsageHold(stream, usage_event, /*reference_held=*/true);\n \n-  auto async_copy = [this, promise, offset, transfer_size, stream, local_device,\n+  auto async_copy = [this, promise = std::move(promise).ToShared(), offset,\n+                     transfer_size, stream, local_device,\n                      owning_device_memory = std::move(device_memory),\n                      definition_events = std::move(definition_events),\n                      usage_event = std::move(usage_event)](\n                         absl::StatusOr<void*> dst) mutable {\n     absl::StatusOr<EventPool::Handle> event =\n         local_device->event_pool().AllocateEvent(stream->parent());\n     if (!event.ok()) {\n-      promise.Set(event.status());\n+      promise->Set(event.status());\n       return;\n     }\n \n     absl::Status defined_status = definition_events[0]->GetDefinedStatus();\n     if (!defined_status.ok()) {\n-      promise.Set(defined_status);\n+      promise->Set(defined_status);\n       return;\n     }\n \n     auto& device_memory = owning_device_memory->mem();\n     if (offset < 0 || offset > device_memory.size() ||\n         device_memory.size() - offset < transfer_size) {\n-      promise.Set(\n+      promise->Set(\n           InvalidArgument(\"Copy raw buffer called on buffer size %lld with \"\n                           \"invalid offset %lld, transfer size %lld\",\n                           device_memory.size(), offset, transfer_size));\n@@ -856,7 +857,7 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n       if (should_stage_host_to_device_transfers() &&\n           !IsDmaMapped(dst.value(), transfer_size)) {\n         if (host_memory_allocator() == nullptr) {\n-          promise.Set(\n+          promise->Set(\n               InvalidArgument(\"host_memory_allocator should be initialized for \"\n                               \"staging buffer transfer.\"));\n           return;\n@@ -871,7 +872,7 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n         if (auto status = stream->Memcpy(staging_buffer.get(), *sub_buffer,\n                                          transfer_size);\n             !status.ok()) {\n-          promise.Set(std::move(status));\n+          promise->Set(std::move(status));\n           return;\n         }\n         auto copy_to_staging_buffer = [dst, transfer_size,\n@@ -880,7 +881,7 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n         };\n         if (auto status = stream->DoHostCallback(copy_to_staging_buffer);\n             !status.ok()) {\n-          promise.Set(std::move(status));\n+          promise->Set(std::move(status));\n           return;\n         }\n       } else {\n@@ -889,7 +890,7 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n         // invoked.\n         auto status = stream->Memcpy(*dst, *sub_buffer, transfer_size);\n         if (!status.ok()) {\n-          promise.Set(std::move(status));\n+          promise->Set(std::move(status));\n           return;\n         }\n       }\n@@ -901,10 +902,10 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n     auto callback_status = local_device->ThenExecuteCallback(\n         stream, [promise, owning_device_memory =\n                               std::move(owning_device_memory)]() mutable {\n-          promise.Set();\n+          promise->Set();\n         });\n     if (!callback_status.ok()) {\n-      promise.Set(std::move(callback_status));\n+      promise->Set(std::move(callback_status));\n       return;\n     }\n   };\n@@ -920,8 +921,8 @@ PjRtFuture<> StreamExecutorGpuClient::CopyRawSubBufferToHost(\n         });\n       });\n \n-  return PjRtFuture<>(\n-      std::move(promise),\n+  return PjRtFutureHelpers::WithProfiling(\n+      std::move(future),\n       /*on_block_start=*/\n       []() {\n         tsl::profiler::TraceMeProducer traceme("
        },
        {
            "sha": "771c3bd29dbe5b07f128d9762355e508ce03b93e",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 18,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=9ebe89ba4cd9d18ee6f3807586a7ccd690e33ad0",
            "patch": "@@ -1781,7 +1781,7 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n                         device_buffer.status().ToString()));\n   }\n \n-  auto promise = PjRtFuture<>::CreatePromise();\n+  auto [promise, future] = PjRtFuture<>::MakePromise();\n   auto usage_event = BufferSequencingEvent::Create(client_->thread_pool());\n \n   TransferManager* transfer_manager =\n@@ -1804,11 +1804,9 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n   // to ToLiteral.\n   device_buffer.ConvertUsageHold(stream, usage_event, /*reference_held=*/true);\n \n-  auto literal_and_transpose_promise =\n+  auto [literal_and_transpose_promise, literal_and_transpose_future] =\n       PjRtFuture<std::pair<MutableLiteralBase*,\n-                           std::shared_ptr<TransposePlan>>>::CreatePromise();\n-  PjRtFuture<std::pair<MutableLiteralBase*, std::shared_ptr<TransposePlan>>>\n-      literal_and_transpose_future(literal_and_transpose_promise);\n+                           std::shared_ptr<TransposePlan>>>::MakePromise();\n \n   literal.OnReady(\n       [client = client_, on_device_shape{on_device_shape_},\n@@ -1873,17 +1871,18 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n                            on_device_shape{on_device_shape_},\n                            literal_and_transpose =\n                                std::move(literal_and_transpose_future),\n-                           promise, local_device]() mutable {\n+                           promise = std::move(promise).ToShared(),\n+                           local_device]() mutable {\n     absl::StatusOr<EventPool::Handle> event_or =\n         local_device->event_pool().AllocateEvent(stream->parent());\n     if (!event_or.ok()) {\n-      promise.Set(event_or.status());\n+      promise->Set(event_or.status());\n       return;\n     }\n \n     absl::Status defined_status = definition_events[0]->GetDefinedStatus();\n     if (!defined_status.ok()) {\n-      promise.Set(defined_status);\n+      promise->Set(defined_status);\n       return;\n     }\n \n@@ -1900,7 +1899,7 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n                 std::pair<MutableLiteralBase*, std::shared_ptr<TransposePlan>>>&\n                 value) mutable {\n           if (!value.ok()) {\n-            promise.Set(value.status());\n+            promise->Set(value.status());\n             return;\n           }\n \n@@ -1939,14 +1938,14 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n                     transpose->Execute(staged->untyped_data(),\n                                        literal->untyped_data());\n                   }\n-                  promise.Set(std::move(status));\n+                  promise->Set(std::move(status));\n                 },\n                 transfer_metadata_ptr);\n           } else {\n             transfer_manager->TransferLiteralFromDevice(\n                 stream, shaped_buffer, literal,\n                 [promise](absl::Status status) mutable {\n-                  promise.Set(std::move(status));\n+                  promise->Set(std::move(status));\n                 },\n                 transfer_metadata_ptr);\n           }\n@@ -1957,16 +1956,16 @@ PjRtFuture<> PjRtStreamExecutorBuffer::ToLiteralHelper(\n           absl::Status defined_status =\n               local_device->ThenRelease(stream, device_memory);\n           if (!defined_status.ok()) {\n-            promise.Set(defined_status);\n+            promise->Set(defined_status);\n           }\n         });\n   };\n \n   first_definition_event->ExecuteOrAddToFutureTasks(\n       \"async_to_literal\", std::move(async_to_literal));\n \n-  return PjRtFuture<>(\n-      std::move(promise),\n+  return PjRtFutureHelpers::WithProfiling(\n+      std::move(future),\n       /*on_block_start=*/\n       []() {\n         tsl::profiler::TraceMeProducer traceme(\n@@ -3354,10 +3353,10 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n     }\n   }\n \n-  std::optional<PjRtFuture<>> future;\n+  std::optional<PjRtFuture<>> maybe_future;\n   if (fill_future) {\n-    auto promise = PjRtFuture<>::CreatePromise();\n-    future = PjRtFuture<>(promise);\n+    auto [promise, future] = PjRtFuture<>::MakePromise();\n+    maybe_future = std::move(future);\n     compute_callbacks.push_back(\n         [promise = std::move(promise)]() mutable { promise.Set(); });\n   }\n@@ -3371,7 +3370,8 @@ PjRtStreamExecutorLoadedExecutable::ExecuteHelper(\n       });\n   metrics::ReportExecutableEnqueueTime(tsl::Env::Default()->NowMicros() -\n                                        start_time_usecs);\n-  return Result({/*future=*/std::move(future), /*buffers=*/std::move(outputs)});\n+  return Result(\n+      {/*future=*/std::move(maybe_future), /*buffers=*/std::move(outputs)});\n }\n \n absl::Status PjRtStreamExecutorLoadedExecutable::VerifyCompatibleDevices()"
        }
    ],
    "stats": {
        "total": 73,
        "additions": 36,
        "deletions": 37
    }
}