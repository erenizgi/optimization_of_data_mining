{
    "author": "KanishAnand",
    "message": "Refactor: Move method definitions from mesh_and_axis.h to .cc file\n\nPiperOrigin-RevId: 825722377",
    "sha": "ff2b8b600d343cd77bff17b21a1e0be1135f2b10",
    "files": [
        {
            "sha": "a72a14aab8c979440c1cdbf75aa9304a4deadb7f",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ff2b8b600d343cd77bff17b21a1e0be1135f2b10/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ff2b8b600d343cd77bff17b21a1e0be1135f2b10/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=ff2b8b600d343cd77bff17b21a1e0be1135f2b10",
            "patch": "@@ -180,6 +180,7 @@ xla_cc_test(\n \n cc_library(\n     name = \"mesh_and_axis\",\n+    srcs = [\"mesh_and_axis.cc\"],\n     hdrs = [\"mesh_and_axis.h\"],\n     deps = [\n         \":tile_assignment\","
        },
        {
            "sha": "72117120a9ce242dcd30c14957e85f92b682b19d",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.cc",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ff2b8b600d343cd77bff17b21a1e0be1135f2b10/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ff2b8b600d343cd77bff17b21a1e0be1135f2b10/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc?ref=ff2b8b600d343cd77bff17b21a1e0be1135f2b10",
            "patch": "@@ -0,0 +1,104 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/algorithm/container.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n+#include \"xla/array.h\"\n+#include \"xla/hlo/ir/tile_assignment.h\"\n+#include \"xla/xla_data.pb.h\"\n+\n+namespace xla {\n+\n+MeshProto Mesh::ToProto() const {\n+  MeshProto proto;\n+  std::vector<MeshProto::MeshAxis> axes;\n+  axes.reserve(axes_names_.size());\n+\n+  for (auto [name, size] :\n+       llvm::zip_equal(axes_names_, device_assignment_.dimensions())) {\n+    MeshProto::MeshAxis axis;\n+    axis.set_name(name);\n+    axis.set_size(size);\n+    axes.push_back(std::move(axis));\n+  }\n+  proto.mutable_axes()->Assign(axes.begin(), axes.end());\n+\n+  std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n+  // Only add device ids for non-iota cases.\n+  if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n+    proto.mutable_device_ids()->Assign(device_assignment_.array().begin(),\n+                                       device_assignment_.array().end());\n+  }\n+  return proto;\n+}\n+\n+Mesh Mesh::FromProto(const MeshProto& proto) {\n+  // TODO(b/454008727): Add validators for Mesh and AxisRef FromProto methods.\n+  std::vector<int64_t> mesh_axis_sizes;\n+  std::vector<std::string> mesh_axis_names;\n+  mesh_axis_sizes.reserve(proto.axes_size());\n+  mesh_axis_names.reserve(proto.axes_size());\n+  for (const auto& axis : proto.axes()) {\n+    mesh_axis_sizes.push_back(axis.size());\n+    mesh_axis_names.push_back(axis.name());\n+  }\n+\n+  // If device ids are not specified, create a mesh with iota tiling.\n+  if (proto.device_ids_size() == 0) {\n+    TileAssignment device_assignment =\n+        TileAssignment(IotaTileAssignment::Create(mesh_axis_sizes));\n+    return Mesh(device_assignment, mesh_axis_names);\n+  }\n+  // Otherwise, create a mesh with the specific device id ordering.\n+  std::vector<int64_t> device_ids(proto.device_ids().begin(),\n+                                  proto.device_ids().end());\n+  Array<int64_t> device_ids_array(mesh_axis_sizes);\n+  absl::c_copy(device_ids, device_ids_array.begin());\n+\n+  TileAssignment tile_assignment =\n+      TileAssignment(std::make_shared<Array<int64_t>>(device_ids_array));\n+  return Mesh(tile_assignment, absl::MakeSpan(mesh_axis_names));\n+}\n+\n+AxisRefProto AxisRef::ToProto() const {\n+  AxisRefProto proto;\n+  proto.set_mesh_axis_index(mesh_axis_index_);\n+  if (sub_axis_info_.has_value()) {\n+    proto.mutable_sub_axis_info()->set_pre_size(sub_axis_info_->pre_size);\n+    proto.mutable_sub_axis_info()->set_size(sub_axis_info_->size);\n+  }\n+  return proto;\n+}\n+\n+AxisRef AxisRef::FromProto(const AxisRefProto& proto) {\n+  AxisRef axis_ref(proto.mesh_axis_index());\n+  if (proto.has_sub_axis_info()) {\n+    axis_ref.sub_axis_info_ = {proto.sub_axis_info().pre_size(),\n+                               proto.sub_axis_info().size()};\n+  }\n+  return axis_ref;\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "f60f6fd0e43245188f4d29c4483532e9dde3e838",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 4,
            "deletions": 70,
            "changes": 74,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ff2b8b600d343cd77bff17b21a1e0be1135f2b10/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ff2b8b600d343cd77bff17b21a1e0be1135f2b10/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=ff2b8b600d343cd77bff17b21a1e0be1135f2b10",
            "patch": "@@ -17,17 +17,13 @@ limitations under the License.\n #define XLA_HLO_IR_MESH_AND_AXIS_H_\n \n #include <cstdint>\n-#include <memory>\n #include <optional>\n #include <string>\n #include <utility>\n #include <vector>\n \n-#include \"absl/algorithm/container.h\"\n #include \"absl/log/check.h\"\n #include \"absl/types/span.h\"\n-#include \"llvm/ADT/STLExtras.h\"\n-#include \"xla/array.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/xla_data.pb.h\"\n \n@@ -61,56 +57,9 @@ class Mesh {\n \n   bool operator!=(const Mesh& other) const { return !(*this == other); }\n \n-  MeshProto ToProto() const {\n-    MeshProto proto;\n-    std::vector<MeshProto::MeshAxis> axes;\n-    axes.reserve(axes_names_.size());\n-\n-    for (auto [name, size] :\n-         llvm::zip_equal(axes_names_, device_assignment_.dimensions())) {\n-      MeshProto::MeshAxis axis;\n-      axis.set_name(name);\n-      axis.set_size(size);\n-      axes.push_back(std::move(axis));\n-    }\n-    proto.mutable_axes()->Assign(axes.begin(), axes.end());\n+  MeshProto ToProto() const;\n \n-    std::optional<IotaTileAssignment> iota = device_assignment_.iota();\n-    // Only add device ids for non-iota cases.\n-    if (!(iota.has_value() && iota->reshape_dims().size() == 1)) {\n-      proto.mutable_device_ids()->Assign(device_assignment_.array().begin(),\n-                                         device_assignment_.array().end());\n-    }\n-    return proto;\n-  }\n-\n-  static Mesh FromProto(const MeshProto& proto) {\n-    // TODO(b/454008727): Add validators for Mesh and AxisRef FromProto methods.\n-    std::vector<int64_t> mesh_axis_sizes;\n-    std::vector<std::string> mesh_axis_names;\n-    mesh_axis_sizes.reserve(proto.axes_size());\n-    mesh_axis_names.reserve(proto.axes_size());\n-    for (const auto& axis : proto.axes()) {\n-      mesh_axis_sizes.push_back(axis.size());\n-      mesh_axis_names.push_back(axis.name());\n-    }\n-\n-    // If device ids are not specified, create a mesh with iota tiling.\n-    if (proto.device_ids_size() == 0) {\n-      TileAssignment device_assignment =\n-          TileAssignment(IotaTileAssignment::Create(mesh_axis_sizes));\n-      return Mesh(device_assignment, mesh_axis_names);\n-    }\n-    // Otherwise, create a mesh with the specific device id ordering.\n-    std::vector<int64_t> device_ids(proto.device_ids().begin(),\n-                                    proto.device_ids().end());\n-    Array<int64_t> device_ids_array(mesh_axis_sizes);\n-    absl::c_copy(device_ids, device_ids_array.begin());\n-\n-    TileAssignment tile_assignment =\n-        TileAssignment(std::make_shared<Array<int64_t>>(device_ids_array));\n-    return Mesh(tile_assignment, absl::MakeSpan(mesh_axis_names));\n-  }\n+  static Mesh FromProto(const MeshProto& proto);\n \n   TileAssignment device_assignment() const { return device_assignment_; }\n \n@@ -166,24 +115,9 @@ class AxisRef {\n \n   bool operator!=(const xla::AxisRef& other) const { return !(*this == other); }\n \n-  AxisRefProto ToProto() const {\n-    AxisRefProto proto;\n-    proto.set_mesh_axis_index(mesh_axis_index_);\n-    if (sub_axis_info_.has_value()) {\n-      proto.mutable_sub_axis_info()->set_pre_size(sub_axis_info_->pre_size);\n-      proto.mutable_sub_axis_info()->set_size(sub_axis_info_->size);\n-    }\n-    return proto;\n-  }\n+  AxisRefProto ToProto() const;\n \n-  static AxisRef FromProto(const AxisRefProto& proto) {\n-    AxisRef axis_ref(proto.mesh_axis_index());\n-    if (proto.has_sub_axis_info()) {\n-      axis_ref.sub_axis_info_ = {proto.sub_axis_info().pre_size(),\n-                                 proto.sub_axis_info().size()};\n-    }\n-    return axis_ref;\n-  }\n+  static AxisRef FromProto(const AxisRefProto& proto);\n \n   int64_t mesh_axis_index() const { return mesh_axis_index_; }\n   std::optional<SubAxis> sub_axis_info() const { return sub_axis_info_; }"
        }
    ],
    "stats": {
        "total": 179,
        "additions": 109,
        "deletions": 70
    }
}