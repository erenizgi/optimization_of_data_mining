{
    "author": "mwhittaker",
    "message": "Make miscellaneous clang-suggested fixes to coordination service.\n\nPiperOrigin-RevId: 845493331",
    "sha": "c744da664cbc3d319688e1d760e4020e2ec27266",
    "files": [
        {
            "sha": "d524685fc760c1610ac1b662f10e28eabaa152c6",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 25,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c744da664cbc3d319688e1d760e4020e2ec27266/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c744da664cbc3d319688e1d760e4020e2ec27266/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service.cc?ref=c744da664cbc3d319688e1d760e4020e2ec27266",
            "patch": "@@ -98,7 +98,9 @@ absl::Status MakeShutdownBarrierError(const absl::Status& error) {\n \n void CoordinationService::ErrorPollingState::SetError(\n     const absl::Status& error) {\n-  if (responded_) return;\n+  if (responded_) {\n+    return;\n+  }\n   responded_ = true;\n   error_ = error;\n   for (auto& [_, done_cb] : done_callbacks_) {\n@@ -119,7 +121,9 @@ void CoordinationService::ErrorPollingState::RemoveTask(\n void CoordinationService::ErrorPollingState::AddTask(\n     const CoordinatedTask& task, tsl::StatusCallback&& done) {\n   // Do not allow to insert a task if the service has already responded.\n-  if (Responded()) return;\n+  if (Responded()) {\n+    return;\n+  }\n   polling_task_names_.insert(GetTaskName(task));\n   RemoveTask(task, \"new request from the same task\");\n   done_callbacks_[task] = done;\n@@ -143,15 +147,19 @@ void CoordinationService::TaskState::Disconnect(\n }\n \n bool CoordinationService::TaskState::SetError(const absl::Status& status) {\n-  if (state_ == CoordinatedTaskState::TASKSTATE_ERROR) return false;\n+  if (state_ == CoordinatedTaskState::TASKSTATE_ERROR) {\n+    return false;\n+  }\n   state_ = CoordinatedTaskState::TASKSTATE_ERROR;\n   status_ = status;\n   return true;\n }\n \n absl::Status CoordinationService::TaskState::RecordHeartbeat(\n     IncarnationId task_incarnation) {\n-  if (!status_.ok()) return status_;\n+  if (!status_.ok()) {\n+    return status_;\n+  }\n   // Record heartbeat.\n   if (task_incarnation_ == task_incarnation) {\n     absl::MutexLock l(last_heartbeat_mu_);\n@@ -161,14 +169,13 @@ absl::Status CoordinationService::TaskState::RecordHeartbeat(\n   // Task incarnation mismatch!\n   if (IsRecoverable()) {\n     return absl::OkStatus();  // Ignore, but don't record new heartbeat.\n-  } else {\n-    return MakeCoordinationError(absl::AbortedError(absl::StrCat(\n-        task_name_, \" Heartbeat: Incarnation ID mismatch: expecting \",\n-        task_incarnation_.value(), \" but got \", task_incarnation.value(),\n-        \". The task has restarted and likely crashed earlier - check for any \"\n-        \"earlier errors or any scheduler events (e.g. preemption, eviction) to \"\n-        \"debug further.\")));\n   }\n+  return MakeCoordinationError(absl::AbortedError(absl::StrCat(\n+      task_name_, \" Heartbeat: Incarnation ID mismatch: expecting \",\n+      task_incarnation_.value(), \" but got \", task_incarnation.value(),\n+      \". The task has restarted and likely crashed earlier - check for any \"\n+      \"earlier errors or any scheduler events (e.g. preemption, eviction) to \"\n+      \"debug further.\")));\n }\n \n int64_t CoordinationService::TaskState::TimeSinceLastHeartbeatMs() {\n@@ -625,7 +632,8 @@ void CoordinationService::RegisterTaskAsync(const CoordinatedTask& task,\n     done(absl::OkStatus());\n     ClusterStateUpdated();\n     return;\n-  } else if (task_state == CoordinatedTaskState::TASKSTATE_CONNECTED) {\n+  }\n+  if (task_state == CoordinatedTaskState::TASKSTATE_CONNECTED) {\n     // This may happen if the service processes the initial RegisterTask(),\n     // but the agent did not receive the response so the agent retries again.\n     if (task_cluster_state->GetTaskIncarnation() == incarnation ||\n@@ -639,12 +647,11 @@ void CoordinationService::RegisterTaskAsync(const CoordinatedTask& task,\n       done(absl::OkStatus());\n       ClusterStateUpdated();\n       return;\n-    } else {\n-      error_message =\n-          absl::StrCat(task_name,\n-                       \" unexpectedly tried to connect with a different \"\n-                       \"incarnation. It has likely restarted.\");\n     }\n+    error_message =\n+        absl::StrCat(task_name,\n+                     \" unexpectedly tried to connect with a different \"\n+                     \"incarnation. It has likely restarted.\");\n   } else {\n     // This task is already in error, which implies it has registered\n     // previously.\n@@ -744,7 +751,8 @@ absl::Status CoordinationService::DisconnectTask(const CoordinatedTask& task) {\n         absl::StrCat(\"Coordination service has stopped. DisconnectTask() \"\n                      \"failed for task_name=\",\n                      task_name)));\n-  } else if (!cluster_state_.contains(task_name)) {\n+  }\n+  if (!cluster_state_.contains(task_name)) {\n     return MakeCoordinationError(absl::InvalidArgumentError(absl::StrCat(\n         \"Unexpected disconnect request with task_name=\", task_name)));\n   }\n@@ -782,11 +790,13 @@ absl::Status CoordinationService::ReportTaskError(const CoordinatedTask& task,\n   if (ServiceHasStopped()) {\n     return MakeCoordinationError(absl::InternalError(\n         \"Coordination service has stopped. ReportTaskError() failed.\"));\n-  } else if (!cluster_state_.contains(task_name)) {\n+  }\n+  if (!cluster_state_.contains(task_name)) {\n     return MakeCoordinationError(absl::InvalidArgumentError(\n         absl::StrCat(\"Unexpected request from task \", task_name)));\n-  } else if (cluster_state_[task_name]->GetState() !=\n-             CoordinatedTaskState::TASKSTATE_CONNECTED) {\n+  }\n+  if (cluster_state_[task_name]->GetState() !=\n+      CoordinatedTaskState::TASKSTATE_CONNECTED) {\n     return MakeCoordinationError(absl::FailedPreconditionError(\n         \"The task is not connected or already has an error.\"));\n   }\n@@ -878,7 +888,8 @@ absl::Status CoordinationService::RecordHeartbeat(const CoordinatedTask& task,\n         \"gracefully. Check the task leader's logs for an earlier error or \"\n         \"scheduler events (e.g. preemption, eviction) to debug the root \"\n         \"cause.\")));\n-  } else if (!cluster_state_.contains(task_name)) {\n+  }\n+  if (!cluster_state_.contains(task_name)) {\n     return MakeCoordinationError(absl::InvalidArgumentError(\n         absl::StrCat(\"Unexpected heartbeat request from task: \", task_name,\n                      \". This usually implies a configuration error.\")));\n@@ -889,7 +900,8 @@ absl::Status CoordinationService::RecordHeartbeat(const CoordinatedTask& task,\n         \"Unexpected heartbeat request from an already-in-error task: \",\n         task_name,\n         \" with existing error: \", task_state->GetStatus().ToString())));\n-  } else if (task_state->IsDisconnectedBeyondGracePeriod()) {\n+  }\n+  if (task_state->IsDisconnectedBeyondGracePeriod()) {\n     // We accept heartbeats for a short grace period to account for the lag\n     // time between the service recording the state change and the agent\n     // stopping heartbeats.\n@@ -960,7 +972,9 @@ std::string NormalizeKey(absl::string_view orig_key) {\n   // Parse all characters\n   while (*src) {\n     // Skip leading slashes\n-    while (*src == '/') src++;\n+    while (*src == '/') {\n+      src++;\n+    }\n     // Copy over all non-slash characters\n     while (*src && *src != '/') {\n       *dst++ = *src++;\n@@ -971,7 +985,9 @@ std::string NormalizeKey(absl::string_view orig_key) {\n     }\n   }\n   // If ending with slash, remove the trailing slash\n-  if (dst > norm_key.begin() && *(dst - 1) == '/') dst--;\n+  if (dst > norm_key.begin() && *(dst - 1) == '/') {\n+    dst--;\n+  }\n   norm_key.resize(dst - norm_key.begin());\n   return norm_key;\n }"
        },
        {
            "sha": "fe6c625e91c9109a8c387b8bdf7d61ec87443266",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c744da664cbc3d319688e1d760e4020e2ec27266/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c744da664cbc3d319688e1d760e4020e2ec27266/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc?ref=c744da664cbc3d319688e1d760e4020e2ec27266",
            "patch": "@@ -461,7 +461,8 @@ absl::Status CoordinationServiceAgent::ReportError(const absl::Status& error) {\n       return MakeCoordinationError(absl::FailedPreconditionError(\n           \"Coordination service agent must be initialized first before \"\n           \"reporting error.\"));\n-    } else if (state_ == CoordinatedTaskState::TASKSTATE_ERROR) {\n+    }\n+    if (state_ == CoordinatedTaskState::TASKSTATE_ERROR) {\n       return MakeCoordinationError(absl::FailedPreconditionError(\n           \"Coordination service agent is already in error state.\"));\n     }\n@@ -837,7 +838,9 @@ absl::Status CoordinationServiceAgent::StopWatchKey(absl::string_view key) {\n void CoordinationServiceAgent::SetError(const absl::Status& error) {\n   assert(!error.ok());\n   absl::MutexLock l(state_mu_);\n-  if (state_ == CoordinatedTaskState::TASKSTATE_ERROR) return;\n+  if (state_ == CoordinatedTaskState::TASKSTATE_ERROR) {\n+    return;\n+  }\n   absl::Status trimmed_error = TrimCoordinationErrorMessage(error);\n \n   state_ = CoordinatedTaskState::TASKSTATE_ERROR;\n@@ -1042,7 +1045,9 @@ absl::Status CoordinationServiceAgent::ValidateRunningAgent(\n           \"Agent must be in CONNECTED state. It is currently UNINITIALIZED.\"));\n \n     case CoordinatedTaskState::TASKSTATE_DISCONNECTED:\n-      if (allow_disconnected) return absl::OkStatus();\n+      if (allow_disconnected) {\n+        return absl::OkStatus();\n+      }\n       return MakeCoordinationError(absl::FailedPreconditionError(\n           \"Agent must be in CONNECTED state. It is currently DISCONNECTED.\"));\n "
        }
    ],
    "stats": {
        "total": 77,
        "additions": 49,
        "deletions": 28
    }
}