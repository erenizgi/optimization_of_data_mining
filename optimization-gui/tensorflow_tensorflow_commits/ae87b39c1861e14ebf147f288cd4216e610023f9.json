{
    "author": "ezhulenev",
    "message": "[xla:ifrt] Migrate to PjRtFuture<>::MakePromise() API\n\nPiperOrigin-RevId: 805531669",
    "sha": "ae87b39c1861e14ebf147f288cd4216e610023f9",
    "files": [
        {
            "sha": "0aaa9e3053345af9e583dbc25a3ef7f3d29cc2a8",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ae87b39c1861e14ebf147f288cd4216e610023f9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ae87b39c1861e14ebf147f288cd4216e610023f9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=ae87b39c1861e14ebf147f288cd4216e610023f9",
            "patch": "@@ -236,8 +236,8 @@ xla_cc_test(\n     deps = [\n         \":ifrt\",\n         \"//xla/tsl/lib/core:status_test_util\",\n-        \"//xla/tsl/platform:status_matchers\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "557c62c2881fd221673bdfe2968ed13fc2f806a4",
            "filename": "third_party/xla/xla/python/ifrt/future_test.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 33,
            "changes": 63,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ae87b39c1861e14ebf147f288cd4216e610023f9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ae87b39c1861e14ebf147f288cd4216e610023f9/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Ffuture_test.cc?ref=ae87b39c1861e14ebf147f288cd4216e610023f9",
            "patch": "@@ -15,21 +15,21 @@ limitations under the License.\n \n #include \"xla/python/ifrt/future.h\"\n \n+#include <tuple>\n+#include <utility>\n #include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"absl/types/span.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n-#include \"xla/tsl/platform/status_matchers.h\"\n \n-namespace xla {\n-namespace ifrt {\n+namespace xla::ifrt {\n namespace {\n \n using ::testing::HasSubstr;\n-using ::tsl::testing::StatusIs;\n \n TEST(FutureTest, JoinZeroFuture) {\n   Future<> future = JoinFutures({});\n@@ -38,27 +38,25 @@ TEST(FutureTest, JoinZeroFuture) {\n }\n \n TEST(FutureTest, JoinOneOkFuture) {\n-  Promise<> promise = Future<>::CreatePromise();\n-  std::vector<Future<>> futures;\n-  futures.push_back(Future<>(promise));\n+  auto [promise, future] = Future<>::MakePromise();\n+  std::vector<Future<>> futures = {std::move(future)};\n \n-  Future<> future = JoinFutures(absl::MakeSpan(futures));\n+  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n-  ASSERT_FALSE(future.IsReady());\n+  ASSERT_FALSE(joined.IsReady());\n   promise.Set(absl::OkStatus());\n-  TF_EXPECT_OK(future.Await());\n+  TF_EXPECT_OK(joined.Await());\n }\n \n TEST(FutureTest, JoinOneFailingFuture) {\n-  Promise<> promise = Future<>::CreatePromise();\n-  std::vector<Future<>> futures;\n-  futures.push_back(Future<>(promise));\n+  auto [promise, future] = Future<>::MakePromise();\n+  std::vector<Future<>> futures = {std::move(future)};\n \n-  Future<> future = JoinFutures(absl::MakeSpan(futures));\n+  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n-  ASSERT_FALSE(future.IsReady());\n+  ASSERT_FALSE(joined.IsReady());\n   promise.Set(absl::InvalidArgumentError(\"Some error\"));\n-  EXPECT_THAT(future.Await(),\n+  EXPECT_THAT(joined.Await(),\n               absl_testing::StatusIs(absl::StatusCode::kInvalidArgument,\n                                      HasSubstr(\"Some error\")));\n }\n@@ -70,17 +68,17 @@ TEST(FutureTest, JoinAllOkFutures) {\n   promises.reserve(kNumFutures);\n   futures.reserve(kNumFutures);\n   for (int i = 0; i < kNumFutures; ++i) {\n-    promises.push_back(Future<>::CreatePromise());\n-    futures.push_back(Future<>(promises.back()));\n+    std::tie(promises.emplace_back(), futures.emplace_back()) =\n+        Future<>::MakePromise();\n   }\n \n-  Future<> future = JoinFutures(absl::MakeSpan(futures));\n+  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n-  ASSERT_FALSE(future.IsReady());\n+  ASSERT_FALSE(joined.IsReady());\n   for (Promise<>& promise : promises) {\n     promise.Set(absl::OkStatus());\n   }\n-  TF_EXPECT_OK(future.Await());\n+  TF_EXPECT_OK(joined.Await());\n }\n \n TEST(FutureTest, JoinAllFailingFutures) {\n@@ -90,17 +88,17 @@ TEST(FutureTest, JoinAllFailingFutures) {\n   promises.reserve(kNumFutures);\n   futures.reserve(kNumFutures);\n   for (int i = 0; i < kNumFutures; ++i) {\n-    promises.push_back(Future<>::CreatePromise());\n-    futures.push_back(Future<>(promises.back()));\n+    std::tie(promises.emplace_back(), futures.emplace_back()) =\n+        Future<>::MakePromise();\n   }\n \n-  Future<> future = JoinFutures(absl::MakeSpan(futures));\n+  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n-  ASSERT_FALSE(future.IsReady());\n+  ASSERT_FALSE(joined.IsReady());\n   for (Promise<>& promise : promises) {\n     promise.Set(absl::InvalidArgumentError(\"Some error\"));\n   }\n-  EXPECT_THAT(future.Await(),\n+  EXPECT_THAT(joined.Await(),\n               absl_testing::StatusIs(absl::StatusCode::kInvalidArgument,\n                                      HasSubstr(\"Some error\")));\n }\n@@ -115,21 +113,21 @@ TEST_P(JoinAllOkFuturesExceptForOneTest, JoinAllOkFuturesExceptForOne) {\n   promises.reserve(kNumFutures);\n   futures.reserve(kNumFutures);\n   for (int i = 0; i < kNumFutures; ++i) {\n-    promises.push_back(Future<>::CreatePromise());\n-    futures.push_back(Future<>(promises.back()));\n+    std::tie(promises.emplace_back(), futures.emplace_back()) =\n+        Future<>::MakePromise();\n   }\n \n-  Future<> future = JoinFutures(absl::MakeSpan(futures));\n+  Future<> joined = JoinFutures(absl::MakeSpan(futures));\n \n-  ASSERT_FALSE(future.IsReady());\n+  ASSERT_FALSE(joined.IsReady());\n   for (int i = 0; i < kNumFutures; ++i) {\n     if (i == failing_future_idx) {\n       promises[i].Set(absl::InvalidArgumentError(\"Some error\"));\n     } else {\n       promises[i].Set(absl::OkStatus());\n     }\n   }\n-  EXPECT_THAT(future.Await(),\n+  EXPECT_THAT(joined.Await(),\n               absl_testing::StatusIs(absl::StatusCode::kInvalidArgument,\n                                      HasSubstr(\"Some error\")));\n }\n@@ -138,5 +136,4 @@ INSTANTIATE_TEST_SUITE_P(FutureTest, JoinAllOkFuturesExceptForOneTest,\n                          testing::Range(0, 3));\n \n }  // namespace\n-}  // namespace ifrt\n-}  // namespace xla\n+}  // namespace xla::ifrt"
        }
    ],
    "stats": {
        "total": 65,
        "additions": 31,
        "deletions": 34
    }
}