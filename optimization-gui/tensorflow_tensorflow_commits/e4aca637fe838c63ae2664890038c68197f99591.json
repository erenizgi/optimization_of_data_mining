{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Make it always safe to run AsyncValue waiters on executor\n\nPiperOrigin-RevId: 818197306",
    "sha": "e4aca637fe838c63ae2664890038c68197f99591",
    "files": [
        {
            "sha": "3fea615d045c85e924ba5fe0c3d1eefdf0e3299e",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=e4aca637fe838c63ae2664890038c68197f99591",
            "patch": "@@ -168,6 +168,7 @@ tsl_cc_test(\n     deps = [\n         \":executor\",\n         \":future\",\n+        \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\",\n         \"//xla/tsl/platform:test_main\","
        },
        {
            "sha": "a74dc9efc2a9cd40dd3f1d9f40bb80f3be947efa",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value.h",
            "status": "modified",
            "additions": 31,
            "deletions": 2,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h?ref=e4aca637fe838c63ae2664890038c68197f99591",
            "patch": "@@ -1048,19 +1048,48 @@ void AsyncValue::AndThen(Waiter&& waiter) {\n \n template <typename Waiter>\n void AsyncValue::AndThen(Executor& executor, Waiter&& waiter) {\n+  // We don't know when the `executor` will run the `waiter`, so we need to add\n+  // a reference to the AsyncValue to keep they underlying value alive for as\n+  // long as the waiter is waiting to be executed.\n+  struct SafeWaiter {\n+    SafeWaiter(AsyncValue* value, Waiter waiter)\n+        : value(value), waiter(std::move(waiter)) {\n+      value->AddRef();\n+    }\n+\n+    SafeWaiter(SafeWaiter&& other) noexcept\n+        : value(other.value), waiter(std::move(other.waiter)) {\n+      other.value = nullptr;\n+    }\n+\n+    SafeWaiter& operator=(SafeWaiter&& other) = delete;\n+\n+    ~SafeWaiter() {\n+      if (value) {\n+        value->DropRef();\n+      }\n+    }\n+\n+    void operator()() { std::move(waiter)(); }\n+\n+    AsyncValue* value;\n+    Waiter waiter;\n+  };\n+\n   // Clients generally want to use AndThen without them each having to check\n   // to see if the value is present. Check for them, and immediately run the\n   // waiter if it is already here.\n   auto waiters_and_state = waiters_and_state_.load(std::memory_order_acquire);\n   if (waiters_and_state.state() == State::kConcrete ||\n       waiters_and_state.state() == State::kError) {\n     DCHECK_EQ(waiters_and_state.waiter(), nullptr);\n-    executor.Execute(std::forward<Waiter>(waiter));\n+    executor.Execute(SafeWaiter(this, std::forward<Waiter>(waiter)));\n     return;\n   }\n \n   EnqueueWaiter(\n-      [&executor, waiter = std::forward<Waiter>(waiter)]() mutable {\n+      [&executor,\n+       waiter = SafeWaiter(this, std::forward<Waiter>(waiter))]() mutable {\n         executor.Execute(std::move(waiter));\n       },\n       waiters_and_state);"
        },
        {
            "sha": "3a66285231d8a660afa14d660351112d162b8a46",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref.h",
            "status": "modified",
            "additions": 37,
            "deletions": 50,
            "changes": 87,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h?ref=e4aca637fe838c63ae2664890038c68197f99591",
            "patch": "@@ -565,14 +565,12 @@ class AsyncValuePtr {\n   // An overload that executes `waiter` on a user-provided executor.\n   template <typename Waiter, StatusOrWaiter<Waiter>* = nullptr>\n   void AndThen(Executor& executor, Waiter&& waiter) const {\n-    // We don't know when the executor will run the callback, so we need to\n-    // copy the AsyncValueRef to keep the underlying value alive.\n     AndThen(executor,\n-            [waiter = std::forward<Waiter>(waiter), ref = CopyRef()]() mutable {\n-              if (ABSL_PREDICT_FALSE(ref.IsError())) {\n-                return waiter(ref.GetError());\n+            [waiter = std::forward<Waiter>(waiter), ptr = *this]() mutable {\n+              if (ABSL_PREDICT_FALSE(ptr.IsError())) {\n+                return waiter(ptr.GetError());\n               }\n-              return waiter(&ref.get());\n+              return waiter(&ptr.get());\n             });\n   }\n \n@@ -606,12 +604,10 @@ class AsyncValuePtr {\n   // An overload that executes `waiter` on a user-provided executor.\n   template <typename Waiter, StatusWaiter<Waiter>* = nullptr>\n   void AndThen(Executor& executor, Waiter&& waiter) const {\n-    // We don't know when the executor will run the callback, so we need to\n-    // copy the AsyncValueRef to keep the underlying value alive.\n     AndThen(executor,\n-            [waiter = std::forward<Waiter>(waiter), ref = CopyRef()]() mutable {\n-              if (ABSL_PREDICT_FALSE(ref.IsError())) {\n-                return waiter(ref.GetError());\n+            [waiter = std::forward<Waiter>(waiter), ptr = *this]() mutable {\n+              if (ABSL_PREDICT_FALSE(ptr.IsError())) {\n+                return waiter(ptr.GetError());\n               }\n               return waiter(absl::OkStatus());\n             });\n@@ -644,16 +640,13 @@ class AsyncValuePtr {\n   template <typename R, typename F, MapFunctor<R, F>* = nullptr>\n   AsyncValueRef<R> Map(Executor& executor, F&& f) {\n     auto result = MakeUnconstructedAsyncValueRef<R>();\n-    // We don't know when the executor will run the callback, so we need to\n-    // copy the AsyncValueRef to keep the underlying value alive.\n-    AndThen(executor,\n-            [f = std::forward<F>(f), result, ref = CopyRef()]() mutable {\n-              if (ABSL_PREDICT_FALSE(ref.IsError())) {\n-                result.SetError(ref.GetError());\n-              } else {\n-                result.emplace(f(*ref));\n-              }\n-            });\n+    AndThen(executor, [f = std::forward<F>(f), result, ptr = *this]() mutable {\n+      if (ABSL_PREDICT_FALSE(ptr.IsError())) {\n+        result.SetError(ptr.GetError());\n+      } else {\n+        result.emplace(f(*ptr));\n+      }\n+    });\n     return result;\n   }\n \n@@ -693,21 +686,18 @@ class AsyncValuePtr {\n   template <typename R, typename F, TryMapFunctor<R, F>* = nullptr>\n   AsyncValueRef<R> TryMap(Executor& executor, F&& f) {\n     auto result = MakeUnconstructedAsyncValueRef<R>();\n-    // We don't know when the executor will run the callback, so we need to\n-    // copy the AsyncValueRef to keep the underlying value alive.\n-    AndThen(executor,\n-            [f = std::forward<F>(f), result, ref = CopyRef()]() mutable {\n-              if (ABSL_PREDICT_FALSE(ref.IsError())) {\n-                result.SetError(ref.GetError());\n-              } else {\n-                auto status_or = f(*ref);\n-                if (status_or.ok()) {\n-                  result.emplace(std::move(status_or.value()));\n-                } else {\n-                  result.SetError(status_or.status());\n-                }\n-              }\n-            });\n+    AndThen(executor, [f = std::forward<F>(f), result, ptr = *this]() mutable {\n+      if (ABSL_PREDICT_FALSE(ptr.IsError())) {\n+        result.SetError(ptr.GetError());\n+      } else {\n+        auto status_or = f(*ptr);\n+        if (status_or.ok()) {\n+          result.emplace(std::move(status_or.value()));\n+        } else {\n+          result.SetError(status_or.status());\n+        }\n+      }\n+    });\n     return result;\n   }\n \n@@ -791,20 +781,17 @@ class AsyncValuePtr {\n     // we must execute user functor on a separate executor and can't call it in\n     // the caller thread.\n     auto promise = MakePromise<R>();\n-    // We don't know when the executor will run the callback, so we need to\n-    // copy the AsyncValueRef to keep the underlying value alive.\n-    AndThen(executor,\n-            [f = std::forward<F>(f), promise, ref = CopyRef()]() mutable {\n-              if (ABSL_PREDICT_FALSE(ref.IsError())) {\n-                promise->SetError(ref.GetError());\n-              } else {\n-                if constexpr (std::is_invocable_v<F, T&>) {\n-                  promise->ForwardTo(f(*ref));\n-                } else {\n-                  promise->ForwardTo(f(ref.AsPtr()));\n-                }\n-              }\n-            });\n+    AndThen(executor, [f = std::forward<F>(f), promise, ptr = *this]() mutable {\n+      if (ABSL_PREDICT_FALSE(ptr.IsError())) {\n+        promise->SetError(ptr.GetError());\n+      } else {\n+        if constexpr (std::is_invocable_v<F, T&>) {\n+          promise->ForwardTo(f(*ptr));\n+        } else {\n+          promise->ForwardTo(f(ptr));\n+        }\n+      }\n+    });\n     return AsyncValueRef<R>(promise);\n   }\n "
        },
        {
            "sha": "1ceefb20aa21e97d1e661aae9f876ff48e438d7b",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e4aca637fe838c63ae2664890038c68197f99591/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=e4aca637fe838c63ae2664890038c68197f99591",
            "patch": "@@ -15,6 +15,8 @@ limitations under the License.\n \n #include \"xla/tsl/concurrency/future.h\"\n \n+#include <atomic>\n+#include <cstddef>\n #include <cstdint>\n #include <memory>\n #include <tuple>\n@@ -25,8 +27,10 @@ limitations under the License.\n #include \"absl/status/status_matchers.h\"\n #include \"absl/status/statusor.h\"\n #include \"xla/tsl/concurrency/executor.h\"\n+#include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n+#include \"xla/tsl/platform/threadpool.h\"\n \n namespace tsl {\n \n@@ -853,6 +857,46 @@ TEST(FutureTest, MapOnExecutor) {\n   EXPECT_EQ(*mapped2.Await(), 43);\n }\n \n+TEST(FutureTest, MapStatelessOnThreadPoolExecutor) {\n+  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+\n+  std::vector<Future<>> mapped;\n+  std::atomic<int32_t> counter = 0;\n+\n+  {  // Create mapped future in a nested scope to make sure that `promise` and\n+    // `future` are destroyed before the end of the test.\n+    auto [promise, future] = Future<>::MakePromise();\n+    for (size_t i = 0; i < 100; ++i) {\n+      mapped.push_back(\n+          future.Map(*thread_pool.AsExecutor(), [&] { ++counter; }));\n+    }\n+    promise.Set();\n+  }\n+\n+  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(counter, 100);\n+}\n+\n+TEST(FutureTest, MapStatefullOnThreadPoolExecutor) {\n+  tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 4);\n+\n+  std::vector<Future<>> mapped;\n+  std::atomic<int32_t> counter = 0;\n+\n+  {  // Create mapped future in a nested scope to make sure that `promise` and\n+    // `future` are destroyed before the end of the test.\n+    auto [promise, future] = Future<int32_t>::MakePromise();\n+    for (size_t i = 0; i < 100; ++i) {\n+      mapped.push_back(future.Map(*thread_pool.AsExecutor(),\n+                                  [&](int32_t value) { counter += value; }));\n+    }\n+    promise.Set(1);\n+  }\n+\n+  EXPECT_EQ(tsl::JoinFutures(mapped).Await(), absl::OkStatus());\n+  EXPECT_EQ(counter, 100);\n+}\n+\n //===----------------------------------------------------------------------===//\n // Performance benchmarks.\n //===----------------------------------------------------------------------===//"
        }
    ],
    "stats": {
        "total": 165,
        "additions": 113,
        "deletions": 52
    }
}