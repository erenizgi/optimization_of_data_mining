{
    "author": "junwhanahn",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 850927089",
    "sha": "0786a6c539540eca6001266f1870704962ce959d",
    "files": [
        {
            "sha": "6b365b3476ed0b44087c57cc906a5178ef27c3d5",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/basic_string_array.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc?ref=0786a6c539540eca6001266f1870704962ce959d",
            "patch": "@@ -68,8 +68,8 @@ absl::StatusOr<tsl::RCReference<BasicStringArray>> BasicStringArray::Create(\n     return absl::InvalidArgumentError(\"Got buffers_ future is invalid\");\n   }\n \n-  auto [buffers_promise, buffers_future] = tsl::Future<Buffers>::MakePromise();\n-  auto [ready_promise, ready_future] = tsl::Future<>::MakePromise();\n+  auto [buffers_promise, buffers_future] = tsl::MakePromise<Buffers>();\n+  auto [ready_promise, ready_future] = tsl::MakePromise<>();\n \n   // Buffers when the become ready must be consistent with the sharding. For\n   // instance, Buffers.size() (the number of per-shard spans of absl::Cords)\n@@ -213,7 +213,7 @@ BasicStringArray::DisassembleIntoSingleDeviceArrays(\n \n   for (int i = 0; i < num_shards; ++i) {\n     std::tie(buffer_promises.emplace_back(), buffer_futures.emplace_back()) =\n-        tsl::Future<Buffers>::MakePromise();\n+        tsl::MakePromise<Buffers>();\n \n     auto current_shard_strings = std::make_shared<PerShardStringStore>();\n     per_shard_strings.push_back(current_shard_strings);\n@@ -276,8 +276,7 @@ tsl::Future<> BasicStringArray::CopyToHostBuffer(\n         sharding_->devices()->size())));\n   }\n \n-  auto [copy_completion_promise, copy_completion_future] =\n-      tsl::Future<>::MakePromise();\n+  auto [copy_completion_promise, copy_completion_future] = tsl::MakePromise<>();\n \n   buffers_.OnReady(\n       [copy_completion_promise = std::move(copy_completion_promise),\n@@ -329,7 +328,7 @@ absl::StatusOr<ArrayRef> BasicStringArray::Copy(\n \n   auto string_store = std::make_shared<StringStore>();\n   auto on_done_with_buffer = [string_store]() {};\n-  auto [buffers_promise, buffers_future] = tsl::Future<Buffers>::MakePromise();\n+  auto [buffers_promise, buffers_future] = tsl::MakePromise<Buffers>();\n \n   auto copier = [string_store = std::move(string_store),\n                  buffers_promise = std::move(buffers_promise)](\n@@ -378,7 +377,7 @@ absl::StatusOr<ArrayRef> BasicStringArray::FullyReplicatedShard(\n \n   auto string_store = std::make_shared<StringStore>();\n   auto on_done_with_buffer = [string_store]() {};\n-  auto [buffers_promise, buffers_future] = tsl::Future<Buffers>::MakePromise();\n+  auto [buffers_promise, buffers_future] = tsl::MakePromise<Buffers>();\n \n   auto copier = [string_store = std::move(string_store),\n                  buffers_promise = std::move(buffers_promise)]("
        },
        {
            "sha": "44c43e1383f7b3723fae1668f57ef40737dbbf15",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/basic_string_array_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array_test.cc?ref=0786a6c539540eca6001266f1870704962ce959d",
            "patch": "@@ -109,7 +109,7 @@ CreateNonReadyTestArray(\n     Client* client, Device* const device,\n     BasicStringArray::OnDoneWithBuffer on_done_with_buffer) {\n   auto [buffers_promise, buffers_future] =\n-      tsl::Future<BasicStringArray::Buffers>::MakePromise();\n+      tsl::MakePromise<BasicStringArray::Buffers>();\n   Shape shape({1});\n   ShardingRef sharding = SingleDeviceSharding::Create(device, MemoryKind());\n \n@@ -158,8 +158,7 @@ TEST(BasicStringArrayTest, Destruction) {\n   BasicStringArray::OnDoneWithBuffer on_done_with_buffer =\n       [&on_done_with_buffer_called]() { on_done_with_buffer_called.Notify(); };\n \n-  auto [array_creation_promise, array_creation_future] =\n-      tsl::Future<>::MakePromise();\n+  auto [array_creation_promise, array_creation_future] = tsl::MakePromise<>();\n \n   tsl::Env::Default()->SchedClosure(\n       ([&, promise = std::move(array_creation_promise)]() mutable {\n@@ -240,7 +239,7 @@ TEST(GetReadyFutureTest, SuccessCase) {\n   TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n   // Make a BasicStringArray with a future that is not ready.\n   auto [promise, buffers_future] =\n-      tsl::Future<BasicStringArray::Buffers>::MakePromise();\n+      tsl::MakePromise<BasicStringArray::Buffers>();\n   TF_ASSERT_OK_AND_ASSIGN(auto array,\n                           CreateTestArray(client.get(), buffers_future,\n                                           /*on_done_with_buffer=*/nullptr));\n@@ -261,7 +260,7 @@ TEST(GetReadyFutureTest, FailureCases) {\n   TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n   // Make a BasicStringArray with a future that is not ready.\n   auto [promise, buffers_future] =\n-      tsl::Future<BasicStringArray::Buffers>::MakePromise();\n+      tsl::MakePromise<BasicStringArray::Buffers>();\n   TF_ASSERT_OK_AND_ASSIGN(auto array,\n                           CreateTestArray(client.get(), buffers_future,\n                                           /*on_done_with_buffer=*/nullptr));"
        },
        {
            "sha": "0c44a3b3421d8959eeb0b333d6eb067fd7c28ec1",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_array.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_array.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_array.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_array.cc?ref=0786a6c539540eca6001266f1870704962ce959d",
            "patch": "@@ -416,7 +416,7 @@ tsl::Future<> PjRtArray::CopyToHostBuffer(\n         static_cast<char*>(data), xla_shape);\n   }\n   auto* literal_ptr = literal.get();\n-  auto [promise, future] = tsl::Future<>::MakePromise();\n+  auto [promise, future] = tsl::MakePromise<>();\n   // TODO(hyeontaek): Handle semantics == kDonateInput.\n   pjrt_buffer->ToLiteral(literal_ptr)\n       .OnReady([literal = std::move(literal),"
        },
        {
            "sha": "f4d7a94cbf27b0326dc2c2be6c78877932b7337f",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_client.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0786a6c539540eca6001266f1870704962ce959d/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc?ref=0786a6c539540eca6001266f1870704962ce959d",
            "patch": "@@ -659,7 +659,7 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n       arrays.size(), std::move(buffer_backing_store));\n \n   auto [buffers_promise, buffers_future] =\n-      tsl::Future<BasicStringArray::Buffers>::MakePromise();\n+      tsl::MakePromise<BasicStringArray::Buffers>();\n \n   auto buffer_copier = [state = buffer_copying_state,\n                         promise = std::move(buffers_promise).ToShared()](\n@@ -1583,7 +1583,7 @@ absl::Status PjRtClient::CrossHostSendBuffers(\n   // TODO(emilyaf): Use an async version of KeyValueStore::Get or query batched\n   // keys together to reduce the number of threads used.\n   for (int i = 0; i < keys.size(); ++i) {\n-    auto [promise, descriptor_future] = tsl::Future<std::string>::MakePromise();\n+    auto [promise, descriptor_future] = tsl::MakePromise<std::string>();\n     work_queue_->Schedule(\n         [this, k = keys[i], promise = std::move(promise).ToShared()]() mutable {\n           std::string key = absl::StrCat(kKeyPrefix, k.value());"
        }
    ],
    "stats": {
        "total": 28,
        "additions": 13,
        "deletions": 15
    }
}