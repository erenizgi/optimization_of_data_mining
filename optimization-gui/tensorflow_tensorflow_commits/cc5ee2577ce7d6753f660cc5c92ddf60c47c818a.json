{
    "author": "ezhulenev",
    "message": "[xla:ffi] Add support for std::variant<> attributes decoding\n\nPiperOrigin-RevId: 824272994",
    "sha": "cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
    "files": [
        {
            "sha": "e923d16fd930137f3eb78725c2a3f5a278de738d",
            "filename": "third_party/xla/xla/ffi/api/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD?ref=cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
            "patch": "@@ -99,6 +99,7 @@ xla_cc_test(\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\",\n         \"//xla/tsl/platform:test_main\",\n+        \"@com_google_absl//absl/functional:overload\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\","
        },
        {
            "sha": "af4132b7eec08a31cf263032b78abfa7ca355a98",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
            "patch": "@@ -1895,6 +1895,47 @@ XLA_FFI_REGISTER_SCALAR_ATTR_DECODING(std::complex<double>,\n \n #undef XLA_FFI_REGISTER_SCALAR_ATTR_DECODING\n \n+// Decoding for an attribute of `std::variant<T0, T1, Ts...>` type.\n+//\n+// Returns the decoding result for a first type that matches the attribute type,\n+// if no type matches, returns std::nullopt.\n+template <typename T0, typename T1, typename... Ts>\n+struct AttrDecoding<std::variant<T0, T1, Ts...>> {\n+  using Type = std::variant<T0, T1, Ts...>;\n+\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static bool Isa(XLA_FFI_AttrType type,\n+                                                  void* attr) {\n+    return AttrDecoding<T0>::Isa(type, attr) ||\n+           AttrDecoding<T1>::Isa(type, attr) ||\n+           (AttrDecoding<Ts>::Isa(type, attr) || ...);\n+  };\n+\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static std::optional<Type> Decode(\n+      XLA_FFI_AttrType type, void* attr, DiagnosticEngine& diagnostic) {\n+    return Decode<T0, T1, Ts...>(type, attr, diagnostic);\n+  }\n+\n+ private:\n+  template <typename U, typename... Us>\n+  XLA_FFI_ATTRIBUTE_ALWAYS_INLINE static std::optional<Type> Decode(\n+      XLA_FFI_AttrType type, void* attr, DiagnosticEngine& diagnostic) {\n+    if (AttrDecoding<U>::Isa(type, attr)) {\n+      if (auto decoded = AttrDecoding<U>::Decode(type, attr, diagnostic);\n+          XLA_FFI_PREDICT_TRUE(decoded)) {\n+        return std::move(*decoded);\n+      }\n+      return std::nullopt;\n+    }\n+\n+    if constexpr (sizeof...(Us) > 0) {\n+      return Decode<Us...>(type, attr, diagnostic);\n+    }\n+\n+    return diagnostic.Emit(\n+        \"Wrong attribute type: it doesn't match any of the variant types\");\n+  }\n+};\n+\n //===----------------------------------------------------------------------===//\n // Automatic dictionary attributes to structs decoding.\n //===----------------------------------------------------------------------===//"
        },
        {
            "sha": "94f03ee763c2e7e6ac29a4e76803a6e1e5daf63b",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 70,
            "deletions": 2,
            "changes": 72,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cc5ee2577ce7d6753f660cc5c92ddf60c47c818a/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=cc5ee2577ce7d6753f660cc5c92ddf60c47c818a",
            "patch": "@@ -23,14 +23,17 @@ limitations under the License.\n #include <string>\n #include <type_traits>\n #include <utility>\n+#include <variant>\n #include <vector>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/functional/overload.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/strings/match.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/blocking_counter.h\"\n #include \"xla/executable_run_options.h\"\n@@ -47,7 +50,6 @@ limitations under the License.\n #include \"xla/tsl/concurrency/chain.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n-#include \"xla/tsl/platform/status_matchers.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n@@ -116,7 +118,6 @@ XLA_FFI_REGISTER_STRUCT_ATTR_DECODING(\n namespace xla::ffi {\n \n using ::testing::HasSubstr;\n-using ::tsl::testing::StatusIs;\n \n TEST(FfiTest, DataTypeEnumValue) {\n   // Verify that xla::PrimitiveType and xla::ffi::DataType use the same\n@@ -892,6 +893,44 @@ TEST(FfiTest, AutoBindingDictionary) {\n   TF_ASSERT_OK(status);\n }\n \n+TEST(FfiTest, VariantAttrDecoding) {\n+  using Integral = std::variant<int8_t, int16_t, int32_t, int64_t>;\n+\n+  auto to_string = absl::Overload{\n+      [](int8_t i) { return absl::StrCat(\"i8: \", i); },\n+      [](int16_t i) { return absl::StrCat(\"i16: \", i); },\n+      [](int32_t i) { return absl::StrCat(\"i32: \", i); },\n+      [](int64_t i) { return absl::StrCat(\"i64: \", i); },\n+  };\n+\n+  auto handler = Ffi::BindTo([&](Dictionary attrs) {\n+    EXPECT_TRUE(attrs.contains<Integral>(\"i32\"));\n+    EXPECT_TRUE(attrs.contains<Integral>(\"i64\"));\n+\n+    Integral i32 = *attrs.get<Integral>(\"i32\");\n+    EXPECT_EQ(i32.index(), 2);\n+\n+    Integral i64 = *attrs.get<Integral>(\"i64\");\n+    EXPECT_EQ(i64.index(), 3);\n+\n+    EXPECT_EQ(std::visit(to_string, i32), \"i32: 42\");\n+    EXPECT_EQ(std::visit(to_string, i64), \"i64: 42\");\n+\n+    return Error::Success();\n+  });\n+\n+  CallFrameBuilder::AttributesBuilder attrs;\n+  attrs.Insert(\"i32\", int32_t{42});\n+  attrs.Insert(\"i64\", int64_t{42});\n+\n+  CallFrameBuilder builder(/*num_args=*/0, /*num_rets=*/0);\n+  builder.AddAttributes(attrs.Build());\n+  auto call_frame = builder.Build();\n+\n+  auto status = Call(*handler, call_frame);\n+  TF_ASSERT_OK(status);\n+}\n+\n // Use opaque struct to define a platform stream type just like platform\n // stream for GPU backend (e.g. `CUstream_st`  and `cudaStream_t`).\n struct TestStreamSt;\n@@ -1751,4 +1790,33 @@ BENCHMARK(BM_EnumAttrs);\n BENCHMARK(BM_EnumAttrsFunction);\n BENCHMARK(BM_EnumAttrsFunctionWrapper);\n \n+//===----------------------------------------------------------------------===//\n+// BM_VariantAttr\n+//===----------------------------------------------------------------------===//\n+\n+void BM_VariantAttr(benchmark::State& state) {\n+  using Integral = std::variant<int8_t, int16_t, int32_t, int64_t>;\n+\n+  CallFrameBuilder::AttributesBuilder attrs;\n+  attrs.Insert(\"i32\", int32_t{0});\n+  attrs.Insert(\"i64\", int64_t{0});\n+\n+  CallFrameBuilder builder(/*num_args=*/0, /*num_rets=*/0);\n+  builder.AddAttributes(attrs.Build());\n+  auto call_frame = builder.Build();\n+\n+  auto handler = Ffi::Bind().Attr<Integral>(\"i32\").Attr<Integral>(\"i64\").To(\n+      [](Integral i32, Integral i64) {\n+        benchmark::DoNotOptimize(i32);\n+        benchmark::DoNotOptimize(i64);\n+        return Error::Success();\n+      });\n+\n+  for (auto _ : state) {\n+    CHECK_OK(Call(*handler, call_frame));\n+  }\n+}\n+\n+BENCHMARK(BM_VariantAttr);\n+\n }  // namespace xla::ffi"
        }
    ],
    "stats": {
        "total": 114,
        "additions": 112,
        "deletions": 2
    }
}