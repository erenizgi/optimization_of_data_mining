{
    "author": "ImanHosseini",
    "message": "extend deannotate unsupported groups to cover more cases\n\nPiperOrigin-RevId: 816128341",
    "sha": "1c59704573a0e09e3ceaf4c044eb65248f7d6244",
    "files": [
        {
            "sha": "7c25ee63443af0ddd553ab99118c1cfd8d14d901",
            "filename": "third_party/xla/xla/service/latency_hiding_scheduler.cc",
            "status": "modified",
            "additions": 170,
            "deletions": 119,
            "changes": 289,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c59704573a0e09e3ceaf4c044eb65248f7d6244/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c59704573a0e09e3ceaf4c044eb65248f7d6244/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.cc?ref=1c59704573a0e09e3ceaf4c044eb65248f7d6244",
            "patch": "@@ -1630,75 +1630,54 @@ absl::StatusOr<HloGraphNode*>\n DefaultSchedulerCore::FindAndExtractBestNodeAvailable(\n     DefaultSchedulerCore::SchedulingState& sched_state,\n     DefaultSchedulerCore::ShouldSkipNodeFunction should_skip_node) {\n-  // Schedule a nop instruction if available.\n-  if (!sched_state.nop_set.empty()) {\n-    HloGraphNode* node = sched_state.nop_set.back();\n-    sched_state.nop_set.pop_back();\n-    return node;\n-  }\n-  absl::InlinedVector<std::pair<HloGraphNode*, SkipNodeReason>, 2>\n-      skipped_nodes_and_reasons;\n-  VLOG(2) << \"Current time: \" << sched_state.current_time;\n-  ReadySetLt ready_lt{&sched_state, target_scheduling_rule_,\n-                      early_target_scheduling_rule_};\n-  // Construct a schedule candidate for caching.\n-  ScheduleCandidate ready_chosen;\n-  ScheduleCandidate ready_chosen_orig;\n-  bool ready_chosen_valid = false;\n-  ScheduleCandidate ready_candidate_orig;\n-  auto chosen_it = sched_state.ready_set.end();\n-\n-  // Try to pick nodes from the ready set first that are the ones that cause the\n-  // most latency hiding.\n-  const bool vlog_2 = VLOG_IS_ON(2);\n-  const bool has_should_skip_node = (should_skip_node != nullptr);\n-  for (auto ready_node_it = sched_state.ready_set.begin(),\n-            e = sched_state.ready_set.end();\n-       ready_node_it != e; ++ready_node_it) {\n-    HloGraphNode* ready_node = *ready_node_it;\n-    if (has_should_skip_node && should_skip_node(ready_node)) {\n-      if (!ready_chosen_valid) {\n-        skipped_nodes_and_reasons.push_back(\n-            {ready_node, SkipNodeReason::kShouldSkipNodeFunction});\n-        if (ABSL_PREDICT_FALSE(vlog_2)) {\n-          VLOG(2) << SkipNodeReasonString(\n-                         skipped_nodes_and_reasons.back().second)\n-                  << \" node: \" << ready_node->GetInstr().name();\n-        }\n-      }\n-      continue;\n-    }\n-    // These ifs will be true when the iterator points to an annotated node,\n-    // but the chosen node is nullptr because the annotation group is not\n-    // ready to be scheduled yet (because of the annotation roots' successors\n-    // not being scheduled yet). So we skip this node and continue to the next\n-    // one.\n-    if (ABSL_PREDICT_FALSE(ready_node->GetAnnotation() != -1)) {\n-      if (!ready_chosen_valid) {\n-        skipped_nodes_and_reasons.push_back(\n-            {ready_node, SkipNodeReason::kAnnotationGroupNotReady});\n-        if (ABSL_PREDICT_FALSE(vlog_2)) {\n-          VLOG(2) << SkipNodeReasonString(\n-                         skipped_nodes_and_reasons.back().second)\n-                  << \" node: \" << ready_node->GetInstr().name();\n+  while (true) {\n+    // Schedule a nop instruction if available.\n+    if (!sched_state.nop_set.empty()) {\n+      HloGraphNode* node = sched_state.nop_set.back();\n+      sched_state.nop_set.pop_back();\n+      return node;\n+    }\n+    absl::InlinedVector<std::pair<HloGraphNode*, SkipNodeReason>, 2>\n+        skipped_nodes_and_reasons;\n+    VLOG(2) << \"Current time: \" << sched_state.current_time;\n+    ReadySetLt ready_lt{&sched_state, target_scheduling_rule_,\n+                        early_target_scheduling_rule_};\n+    // Construct a schedule candidate for caching.\n+    ScheduleCandidate ready_chosen;\n+    ScheduleCandidate ready_chosen_orig;\n+    bool ready_chosen_valid = false;\n+    ScheduleCandidate ready_candidate_orig;\n+    auto chosen_it = sched_state.ready_set.end();\n+\n+    // Try to pick nodes from the ready set first that are the ones that cause\n+    // the most latency hiding.\n+    const bool vlog_2 = VLOG_IS_ON(2);\n+    const bool has_should_skip_node = (should_skip_node != nullptr);\n+    for (auto ready_node_it = sched_state.ready_set.begin(),\n+              e = sched_state.ready_set.end();\n+         ready_node_it != e; ++ready_node_it) {\n+      HloGraphNode* ready_node = *ready_node_it;\n+      if (has_should_skip_node && should_skip_node(ready_node)) {\n+        if (!ready_chosen_valid) {\n+          skipped_nodes_and_reasons.push_back(\n+              {ready_node, SkipNodeReason::kShouldSkipNodeFunction});\n+          if (ABSL_PREDICT_FALSE(vlog_2)) {\n+            VLOG(2) << SkipNodeReasonString(\n+                           skipped_nodes_and_reasons.back().second)\n+                    << \" node: \" << ready_node->GetInstr().name();\n+          }\n         }\n+        continue;\n       }\n-      continue;\n-    }\n-    // If this node would cause the max_concurrent_resource count to go beyond\n-    // the limit do not schedule it and pass to the next node.\n-    if (is_default_scheduling_instruction_crosses_overlap_limit_ &&\n-        !ready_node->HasRecursiveResources()) {\n-      // Default scheduling_instruction_crosses_overlap_limit_ is a noop in\n-      // this case\n-    } else {\n-      // Either scheduling_instruction_crosses_overlap_limit_ is not the\n-      // default, or the node actually has recursive resoures\n-      if (scheduling_instruction_crosses_overlap_limit_(sched_state,\n-                                                        ready_node)) {\n-        if (ready_chosen.node == nullptr) {\n+      // These ifs will be true when the iterator points to an annotated node,\n+      // but the chosen node is nullptr because the annotation group is not\n+      // ready to be scheduled yet (because of the annotation roots' successors\n+      // not being scheduled yet). So we skip this node and continue to the next\n+      // one.\n+      if (ABSL_PREDICT_FALSE(ready_node->GetAnnotation() != -1)) {\n+        if (!ready_chosen_valid) {\n           skipped_nodes_and_reasons.push_back(\n-              {ready_node, SkipNodeReason::kExceedsOverlapLimit});\n+              {ready_node, SkipNodeReason::kAnnotationGroupNotReady});\n           if (ABSL_PREDICT_FALSE(vlog_2)) {\n             VLOG(2) << SkipNodeReasonString(\n                            skipped_nodes_and_reasons.back().second)\n@@ -1707,61 +1686,137 @@ DefaultSchedulerCore::FindAndExtractBestNodeAvailable(\n         }\n         continue;\n       }\n-    }\n-    ScheduleCandidate ready_candidate =\n-        InitializeCandidate(ready_node, sched_state);\n-    if (!ready_chosen_valid) {\n-      ready_chosen = ready_candidate;\n-      chosen_it = ready_node_it;\n-      ready_chosen_valid = true;\n+      // If this node would cause the max_concurrent_resource count to go beyond\n+      // the limit do not schedule it and pass to the next node.\n+      if (is_default_scheduling_instruction_crosses_overlap_limit_ &&\n+          !ready_node->HasRecursiveResources()) {\n+        // Default scheduling_instruction_crosses_overlap_limit_ is a noop in\n+        // this case\n+      } else {\n+        // Either scheduling_instruction_crosses_overlap_limit_ is not the\n+        // default, or the node actually has recursive resources.\n+        if (scheduling_instruction_crosses_overlap_limit_(sched_state,\n+                                                          ready_node)) {\n+          if (ready_chosen.node == nullptr) {\n+            skipped_nodes_and_reasons.push_back(\n+                {ready_node, SkipNodeReason::kExceedsOverlapLimit});\n+            if (ABSL_PREDICT_FALSE(vlog_2)) {\n+              VLOG(2) << SkipNodeReasonString(\n+                             skipped_nodes_and_reasons.back().second)\n+                      << \" node: \" << ready_node->GetInstr().name();\n+            }\n+          }\n+          continue;\n+        }\n+      }\n+      ScheduleCandidate ready_candidate =\n+          InitializeCandidate(ready_node, sched_state);\n+      if (!ready_chosen_valid) {\n+        ready_chosen = ready_candidate;\n+        chosen_it = ready_node_it;\n+        ready_chosen_valid = true;\n+        if (ABSL_PREDICT_FALSE(vlog_2)) {\n+          VLOG(2) << \"Choosing from ready (\"\n+                  << ready_chosen.node->GetInstr().name()\n+                  << \") Reason: First Candidate\";\n+        }\n+        continue;\n+      }\n+\n       if (ABSL_PREDICT_FALSE(vlog_2)) {\n+        ready_chosen_orig = ready_chosen;\n+        ready_candidate_orig = ready_candidate;\n+      }\n+      const char* reason;\n+      bool new_candidate_selected =\n+          ready_lt.MaybeUpdate(ready_candidate, ready_chosen, &reason);\n+      if (ABSL_PREDICT_FALSE(vlog_2)) {\n+        auto print_pressure_change =\n+            [](const DefaultSchedulerCore::ScheduleCandidate& p) {\n+              if (p.has_pressure_change) {\n+                return std::to_string(p.pressure_change_first);\n+              }\n+              return std::string(\"N/A\");\n+            };\n         VLOG(2) << \"Choosing from ready (\"\n-                << ready_chosen.node->GetInstr().name()\n-                << \") Reason: First Candidate\";\n+                << (new_candidate_selected\n+                        ? ready_candidate_orig.node->GetInstr().name()\n+                        : ready_chosen_orig.node->GetInstr().name())\n+                << \") vs (\"\n+                << (new_candidate_selected\n+                        ? ready_chosen_orig.node->GetInstr().name()\n+                        : ready_candidate_orig.node->GetInstr().name())\n+                << \") Reason: \" << reason << \" mem pressure chosen \"\n+                << print_pressure_change(new_candidate_selected\n+                                             ? ready_candidate_orig\n+                                             : ready_chosen_orig)\n+                << \" mem pressure other \"\n+                << print_pressure_change(new_candidate_selected\n+                                             ? ready_chosen_orig\n+                                             : ready_candidate_orig);\n+      }\n+\n+      if (new_candidate_selected) {\n+        chosen_it = ready_node_it;\n+        DCHECK_EQ(ready_chosen.node, *chosen_it);\n+      }\n+    }\n+\n+    if (ready_chosen_valid) {\n+      CHECK(chosen_it != sched_state.ready_set.end());\n+      std::swap(*chosen_it, sched_state.ready_set.back());\n+      sched_state.ready_set.pop_back();\n+      return ready_chosen.node;\n+    }\n+\n+    if (sched_state.config.deannotate_group_if_blocked) {\n+      // If no node was chosen, check if any were skipped due to\n+      // kAnnotationGroupNotReady. Among those groups, pick the one which has\n+      // the smallest number of nodes in it.\n+      HloGraphNode* node_to_deannotate = nullptr;\n+      int64_t min_annotation_size = std::numeric_limits<int64_t>::max();\n+      const HloComputation* comp =\n+          sched_state.sched_graph.GetOriginalInstrList()[0]->parent();\n+\n+      for (const auto& pair : skipped_nodes_and_reasons) {\n+        if (pair.second == SkipNodeReason::kAnnotationGroupNotReady) {\n+          int64_t annotation = pair.first->GetAnnotation();\n+          int64_t current_annotation_size =\n+              annotation_tracker_->GetNumInstructions(comp, annotation);\n+          if (current_annotation_size < min_annotation_size) {\n+            min_annotation_size = current_annotation_size;\n+            node_to_deannotate = pair.first;\n+          }\n+        }\n       }\n-      continue;\n-    }\n-\n-    if (ABSL_PREDICT_FALSE(vlog_2)) {\n-      ready_chosen_orig = ready_chosen;\n-      ready_candidate_orig = ready_candidate;\n-    }\n-    const char* reason;\n-    bool new_candidate_selected =\n-        ready_lt.MaybeUpdate(ready_candidate, ready_chosen, &reason);\n-    if (ABSL_PREDICT_FALSE(vlog_2)) {\n-      auto print_pressure_change =\n-          [](const DefaultSchedulerCore::ScheduleCandidate& p) {\n-            if (p.has_pressure_change) {\n-              return std::to_string(p.pressure_change_first);\n-            }\n-            return std::string(\"N/A\");\n-          };\n-      VLOG(2) << \"Choosing from ready (\"\n-              << (new_candidate_selected\n-                      ? ready_candidate_orig.node->GetInstr().name()\n-                      : ready_chosen_orig.node->GetInstr().name())\n-              << \") vs (\"\n-              << (new_candidate_selected\n-                      ? ready_chosen_orig.node->GetInstr().name()\n-                      : ready_candidate_orig.node->GetInstr().name())\n-              << \") Reason: \" << reason << \" mem pressure chosen \"\n-              << print_pressure_change(new_candidate_selected\n-                                           ? ready_candidate_orig\n-                                           : ready_chosen_orig)\n-              << \" mem pressure other \"\n-              << print_pressure_change(new_candidate_selected\n-                                           ? ready_chosen_orig\n-                                           : ready_candidate_orig);\n-    }\n \n-    if (new_candidate_selected) {\n-      chosen_it = ready_node_it;\n-      DCHECK_EQ(ready_chosen.node, *chosen_it);\n+      if (node_to_deannotate != nullptr) {\n+        int64_t annotation = node_to_deannotate->GetAnnotation();\n+        VLOG(2) << \"FindAndExtractBestNodeAvailable failed, deannotating group \"\n+                << annotation << \" and retrying.\";\n+        const HloComputation* comp =\n+            sched_state.sched_graph.GetOriginalInstrList()[0]->parent();\n+        auto instrs = annotation_tracker_->GetInstructions(comp, annotation);\n+        for (const HloInstruction* instr : instrs) {\n+          HloGraphNode& node = sched_state.sched_graph.GetNode(instr);\n+          node.ClearAnnotation();\n+        }\n+        // Clear the ongoing annotation state as well.\n+        if (sched_state.ongoing_annotation == annotation) {\n+          sched_state.ongoing_annotation = -1;\n+        }\n+        // Remove this annotation from ready_annotations if it's there.\n+        auto it = std::find(sched_state.ready_annotations.begin(),\n+                            sched_state.ready_annotations.end(), annotation);\n+        if (it != sched_state.ready_annotations.end()) {\n+          sched_state.ready_annotations.erase(it);\n+        }\n+        continue;  // Retry the while loop.\n+      }\n     }\n-  }\n \n-  if (!ready_chosen_valid) {\n+    // If we reach here, no node was scheduled and no annotation group could be\n+    // deannotated.\n     if (!sched_state.ready_annotations.empty()) {\n       std::string error_message = absl::StrCat(\n           \"There is a scheduling group which exceeds the overlap limits. \"\n@@ -1790,10 +1845,6 @@ DefaultSchedulerCore::FindAndExtractBestNodeAvailable(\n                                         SkipNodeReasonString(pair.second));\n                       })));\n   }\n-  CHECK(chosen_it != sched_state.ready_set.end());\n-  std::swap(*chosen_it, sched_state.ready_set.back());\n-  sched_state.ready_set.pop_back();\n-  return ready_chosen.node;\n }\n \n void DefaultSchedulerCore::LogInstruction(const HloInstruction* instr) const {"
        },
        {
            "sha": "4d133d0975b4e9840f336722ca8613a69211e8e8",
            "filename": "third_party/xla/xla/service/latency_hiding_scheduler.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1c59704573a0e09e3ceaf4c044eb65248f7d6244/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1c59704573a0e09e3ceaf4c044eb65248f7d6244/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.h?ref=1c59704573a0e09e3ceaf4c044eb65248f7d6244",
            "patch": "@@ -142,6 +142,7 @@ struct SchedulerConfig {\n   int64_t rerun = 0;\n   int64_t parallel_collective_overlap_limit = 1;\n   bool schedule_send_recvs = false;\n+  bool deannotate_group_if_blocked = false;\n   // Consider send recv as the same resource. Some platforms do not take well\n   // overlapping the send/recv ops between themselves.\n   bool force_send_recv_to_use_same_resource = false;"
        }
    ],
    "stats": {
        "total": 290,
        "additions": 171,
        "deletions": 119
    }
}