{
    "author": "junwhanahn",
    "message": "Add array tests that exercise copies between exhaustive combinations of devices and memory kinds\n\nPiperOrigin-RevId: 800580355",
    "sha": "8f2eddfd7e2b233ef6afd0354a6a663052f9d660",
    "files": [
        {
            "sha": "d27070a1061cb2c0c51a9e082c6f3d53338a3471",
            "filename": "third_party/xla/xla/backends/cpu/nanort/ifrt_client_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f2eddfd7e2b233ef6afd0354a6a663052f9d660/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f2eddfd7e2b233ef6afd0354a6a663052f9d660/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc?ref=8f2eddfd7e2b233ef6afd0354a6a663052f9d660",
            "patch": "@@ -321,8 +321,10 @@ int main(int argc, char** argv) {\n       \"MakeArraysFromHostBufferShardsAndCopyToHostBufferWithString:\"\n       // `MakeErrorArrays` is not supported in NanoIfrtClient.\n       \"ArrayImplTest.MakeErrorArrays:\"\n+      \"ArrayImplTest.CopyPoisonedArray:\"\n       // Sub-byte types are not supported in NanoIfrtClient.\n       \"ArrayImplTest.HostBufferInt4:\"\n+      \"ArrayImplTest.CopyArraysSubByteDType:\"\n       // NanoRT does not handle zero-sized buffers correctly.\n       \"ArrayImplTest.MakeAndCopyZeroSizedBuffers:\"\n       // Executable returns a wrong number of devices."
        },
        {
            "sha": "802e732aa2d753a1bef8096903f05f0aedb0396c",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f2eddfd7e2b233ef6afd0354a6a663052f9d660/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f2eddfd7e2b233ef6afd0354a6a663052f9d660/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=8f2eddfd7e2b233ef6afd0354a6a663052f9d660",
            "patch": "@@ -491,6 +491,7 @@ cc_library(\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/time\",\n         \"@com_google_absl//absl/types:span\",\n+        \"@com_google_googletest//:gtest_for_library\",\n     ],\n     alwayslink = True,\n )"
        },
        {
            "sha": "43219b51e8b0d14b6dc41134facc4d7775a2d652",
            "filename": "third_party/xla/xla/python/ifrt/array_impl_test_lib.cc",
            "status": "modified",
            "additions": 151,
            "deletions": 0,
            "changes": 151,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f2eddfd7e2b233ef6afd0354a6a663052f9d660/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f2eddfd7e2b233ef6afd0354a6a663052f9d660/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Farray_impl_test_lib.cc?ref=8f2eddfd7e2b233ef6afd0354a6a663052f9d660",
            "patch": "@@ -20,6 +20,7 @@ limitations under the License.\n #include <utility>\n #include <vector>\n \n+#include <gmock/gmock.h>\n #include \"absl/algorithm/container.h\"\n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/container/inlined_vector.h\"\n@@ -1510,6 +1511,156 @@ TEST(ArrayImplTest, MakeAndCopyZeroSizedBuffers) {\n   }\n }\n \n+TEST(ArrayImplTest, CopyArraysExhaustive) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Device* const src_device = client->addressable_devices().front();\n+\n+  DType dtype(DType::kF32);\n+  Shape shape({2, 3});\n+  std::vector<float> data(6);\n+  std::iota(data.begin(), data.end(), 0);\n+\n+  for (Memory* const src_memory : src_device->Memories()) {\n+    for (Device* const dst_device : client->addressable_devices()) {\n+      for (Memory* const dst_memory : dst_device->Memories()) {\n+        SCOPED_TRACE(absl::StrCat(\n+            src_device->DebugString(), \" \", src_memory->DebugString(), \" -> \",\n+            dst_device->DebugString(), \" \", dst_memory->DebugString()));\n+\n+        ShardingRef sharding =\n+            SingleDeviceSharding::Create(src_device, src_memory->Kind());\n+        TF_ASSERT_OK_AND_ASSIGN(\n+            auto array,\n+            client->MakeArrayFromHostBuffer(\n+                data.data(), dtype, shape,\n+                /*byte_strides=*/std::nullopt, sharding,\n+                Client::HostBufferSemantics::kImmutableOnlyDuringCall,\n+                /*on_done_with_host_buffer=*/{}));\n+        EXPECT_EQ(array->sharding(), *sharding);\n+\n+        ArrayRef new_array;\n+        {\n+          TF_ASSERT_OK_AND_ASSIGN(DeviceListRef device_list,\n+                                  client->MakeDeviceList({dst_device}));\n+          TF_ASSERT_OK_AND_ASSIGN(\n+              auto copied,\n+              client->CopyArrays(absl::MakeSpan(&array, 1),\n+                                 std::move(device_list), dst_memory->Kind(),\n+                                 ArrayCopySemantics::kAlwaysCopy));\n+          new_array = std::move(copied[0]);\n+        }\n+        EXPECT_THAT(new_array->sharding().devices()->devices(),\n+                    ElementsAre(dst_device));\n+        EXPECT_EQ(new_array->sharding().memory_kind(), dst_memory->Kind());\n+\n+        std::vector<float> out_data(6);\n+        Future<void> future = new_array->CopyToHostBuffer(\n+            out_data.data(), /*byte_strides=*/std::nullopt,\n+            ArrayCopySemantics::kAlwaysCopy);\n+        TF_ASSERT_OK(future.Await());\n+        EXPECT_THAT(out_data, ElementsAreArray(data));\n+      }\n+    }\n+  }\n+}\n+\n+TEST(ArrayImplTest, CopyArraysSubByteDType) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Device* const src_device = client->addressable_devices().front();\n+\n+  DType dtype(DType::kS4);\n+  Shape shape({2, 3});\n+  std::vector<int8_t> data(6);\n+  std::iota(data.begin(), data.end(), 0);\n+\n+  for (Memory* const src_memory : src_device->Memories()) {\n+    for (Device* const dst_device : client->addressable_devices()) {\n+      for (Memory* const dst_memory : dst_device->Memories()) {\n+        SCOPED_TRACE(absl::StrCat(\n+            src_device->DebugString(), \" \", src_memory->DebugString(), \" -> \",\n+            dst_device->DebugString(), \" \", dst_memory->DebugString()));\n+\n+        ShardingRef sharding =\n+            SingleDeviceSharding::Create(src_device, src_memory->Kind());\n+        TF_ASSERT_OK_AND_ASSIGN(\n+            auto array,\n+            client->MakeArrayFromHostBuffer(\n+                data.data(), dtype, shape,\n+                /*byte_strides=*/std::nullopt, sharding,\n+                Client::HostBufferSemantics::kImmutableOnlyDuringCall,\n+                /*on_done_with_host_buffer=*/{}));\n+        EXPECT_EQ(array->sharding(), *sharding);\n+\n+        ArrayRef new_array;\n+        {\n+          TF_ASSERT_OK_AND_ASSIGN(DeviceListRef device_list,\n+                                  client->MakeDeviceList({dst_device}));\n+          TF_ASSERT_OK_AND_ASSIGN(\n+              auto copied,\n+              client->CopyArrays(absl::MakeSpan(&array, 1),\n+                                 std::move(device_list), dst_memory->Kind(),\n+                                 ArrayCopySemantics::kAlwaysCopy));\n+          new_array = std::move(copied[0]);\n+        }\n+        EXPECT_THAT(new_array->sharding().devices()->devices(),\n+                    ElementsAre(dst_device));\n+        EXPECT_EQ(new_array->sharding().memory_kind(), dst_memory->Kind());\n+\n+        std::vector<int8_t> out_data(6);\n+        auto future = new_array->CopyToHostBuffer(\n+            out_data.data(), /*byte_strides=*/std::nullopt,\n+            ArrayCopySemantics::kAlwaysCopy);\n+        TF_ASSERT_OK(future.Await());\n+        EXPECT_THAT(out_data, ElementsAreArray(data));\n+      }\n+    }\n+  }\n+}\n+\n+TEST(ArrayImplTest, CopyPoisonedArray) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n+  Device* const src_device = client->addressable_devices().front();\n+\n+  for (Memory* const src_memory : src_device->Memories()) {\n+    for (Device* const dst_device : client->addressable_devices()) {\n+      for (Memory* const dst_memory : dst_device->Memories()) {\n+        SCOPED_TRACE(absl::StrCat(\n+            src_device->DebugString(), \" \", src_memory->DebugString(), \" -> \",\n+            dst_device->DebugString(), \" \", dst_memory->DebugString()));\n+\n+        ArraySpec array_spec = {\n+            /*dtype=*/DType(DType::kF32),\n+            /*shape=*/Shape({2, 3}),\n+            /*sharding=*/\n+            SingleDeviceSharding::Create(src_device, src_memory->Kind()),\n+        };\n+\n+        const absl::Status error = absl::InternalError(\"injected error\");\n+        TF_ASSERT_OK_AND_ASSIGN(auto arrays,\n+                                client->MakeErrorArrays(error, {array_spec}));\n+\n+        EXPECT_EQ(arrays.front()->dtype(), array_spec.dtype);\n+        EXPECT_EQ(arrays.front()->shape(), array_spec.shape);\n+        EXPECT_EQ(arrays.front()->sharding(), *array_spec.sharding);\n+        ASSERT_THAT(arrays.front()->GetReadyFuture().Await(),\n+                    StatusIs(error.code(), HasSubstr(error.message())));\n+\n+        TF_ASSERT_OK_AND_ASSIGN(DeviceListRef device_list,\n+                                client->MakeDeviceList({dst_device}));\n+        TF_ASSERT_OK_AND_ASSIGN(\n+            auto copied,\n+            client->CopyArrays(absl::MakeSpan(arrays), std::move(device_list),\n+                               dst_memory->Kind(),\n+                               ArrayCopySemantics::kAlwaysCopy));\n+        ASSERT_EQ(copied.size(), 1);\n+\n+        EXPECT_THAT(copied[0]->GetReadyFuture().Await(),\n+                    StatusIs(error.code(), HasSubstr(error.message())));\n+      }\n+    }\n+  }\n+}\n+\n TEST(ArrayImplTest, GetReadyFuture) {\n   TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n "
        }
    ],
    "stats": {
        "total": 154,
        "additions": 154,
        "deletions": 0
    }
}