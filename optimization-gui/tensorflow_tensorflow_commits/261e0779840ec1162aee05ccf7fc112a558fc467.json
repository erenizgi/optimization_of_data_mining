{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][MeshAxesReplicaGroupList][2/2] Add `flattened_replica_groups` function for MeshAxesReplicaGroupList.\n\nPiperOrigin-RevId: 826619318",
    "sha": "261e0779840ec1162aee05ccf7fc112a558fc467",
    "files": [
        {
            "sha": "29f62b139bdb4603b6f7ffc26dc56a8da9bea62a",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=261e0779840ec1162aee05ccf7fc112a558fc467",
            "patch": "@@ -422,6 +422,7 @@ xla_cc_test(\n         \":mesh_and_axis\",\n         \":tile_assignment\",\n         \"//xla:array\",\n+        \"//xla:array2d\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/service:hlo_proto_cc\",\n         \"//xla/tsl/platform:test_main\","
        },
        {
            "sha": "a897519d7e818192081380d3948904de82535590",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.cc",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.cc?ref=261e0779840ec1162aee05ccf7fc112a558fc467",
            "patch": "@@ -15,6 +15,7 @@ limitations under the License.\n \n #include \"xla/hlo/ir/mesh_and_axis.h\"\n \n+#include <algorithm>\n #include <cstdint>\n #include <memory>\n #include <optional>\n@@ -101,4 +102,42 @@ AxisRef AxisRef::FromProto(const AxisRefProto& proto) {\n   return axis_ref;\n }\n \n+bool canSubAxesCoexist(int64_t minPreSize, int64_t maxPreSize,\n+                       int64_t minNextPreSize, int64_t maxNextPreSize) {\n+  if (minNextPreSize > maxPreSize) {\n+    // Sub-axes overlap, check if overlapping and non-overlapping parts are\n+    // valid.\n+    return minNextPreSize % maxPreSize == 0 && maxPreSize % minPreSize == 0 &&\n+           maxNextPreSize % minNextPreSize == 0;\n+  }\n+  // Sub-axes don't overlap, check if the gap is valid.\n+  return maxPreSize % minNextPreSize == 0;\n+}\n+\n+bool AxisRef::CanCoexist(const AxisRef& other) const {\n+  if (mesh_axis_index() != other.mesh_axis_index()) {\n+    return true;\n+  }\n+  if (!sub_axis_info_.has_value() || !other.sub_axis_info_.has_value()) {\n+    // If one is a full axis and the other is a sub-axis, they can coexist.\n+    return true;\n+  }\n+\n+  const SubAxis& this_sub_axis = sub_axis_info_.value();\n+  const SubAxis& other_sub_axis = other.sub_axis_info_.value();\n+\n+  int64_t this_pre_size = this_sub_axis.pre_size;\n+  int64_t other_pre_size = other_sub_axis.pre_size;\n+  int64_t this_next_pre_size = this_sub_axis.next_pre_size();\n+  int64_t other_next_pre_size = other_sub_axis.next_pre_size();\n+\n+  auto [min_pre_size, max_pre_size] =\n+      std::minmax(this_pre_size, other_pre_size);\n+  auto [min_next_pre_size, max_next_pre_size] =\n+      std::minmax(this_next_pre_size, other_next_pre_size);\n+\n+  return canSubAxesCoexist(min_pre_size, max_pre_size, min_next_pre_size,\n+                           max_next_pre_size);\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "5dc8c9651dbee29e0b4bc85d307eccf9d9928126",
            "filename": "third_party/xla/xla/hlo/ir/mesh_and_axis.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fmesh_and_axis.h?ref=261e0779840ec1162aee05ccf7fc112a558fc467",
            "patch": "@@ -109,6 +109,12 @@ class Mesh {\n \n   TileAssignment device_assignment() const { return device_assignment_; }\n   std::vector<std::string> axis_names() const { return axes_names_; }\n+  absl::Span<const int64_t> axis_sizes() const {\n+    return device_assignment_.dimensions();\n+  }\n+  int64_t axis_size(int64_t axis_index) const {\n+    return device_assignment_.dim(axis_index);\n+  }\n \n  private:\n   // Dimensions of the `device_assignment_` array correspond to the axes of the\n@@ -127,6 +133,7 @@ class AxisRef {\n   struct SubAxis {\n     int64_t pre_size;\n     int64_t size;\n+    int64_t next_pre_size() const { return pre_size * size; }\n   };\n \n   // Index corresponding to axis in the mesh. It should be a valid index into\n@@ -177,6 +184,8 @@ class AxisRef {\n \n   static AxisRef FromProto(const AxisRefProto& proto);\n \n+  bool CanCoexist(const AxisRef& other) const;\n+\n   int64_t mesh_axis_index() const { return mesh_axis_index_; }\n   std::optional<SubAxis> sub_axis_info() const { return sub_axis_info_; }\n };"
        },
        {
            "sha": "0a02c175b8bcaabe142f89753286f23a56cb6446",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.cc",
            "status": "modified",
            "additions": 239,
            "deletions": 5,
            "changes": 244,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.cc?ref=261e0779840ec1162aee05ccf7fc112a558fc467",
            "patch": "@@ -15,12 +15,18 @@ limitations under the License.\n \n #include \"xla/hlo/ir/replica_group.h\"\n \n+#include <algorithm>\n #include <cstdint>\n #include <memory>\n+#include <numeric>\n #include <optional>\n #include <string>\n+#include <utility>\n #include <vector>\n \n+#include \"absl/algorithm/container.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/strings/str_cat.h\"\n@@ -33,7 +39,6 @@ limitations under the License.\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/tsl/platform/logging.h\"  // IWYU pragma: keep\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/protobuf.h\"\n \n namespace xla {\n \n@@ -49,6 +54,145 @@ std::string ReplicaGroupsToString(\n }\n \n /************** MeshAxesReplicaGroupList implementation ***********************/\n+\n+void HandleSingleAxisRefPerDimension(const AxisRef& axis,\n+                                     int64_t full_axis_size,\n+                                     std::vector<int64_t>& out_reshape_dims,\n+                                     std::vector<int64_t>& out_aggregate_axes) {\n+  if (axis.sub_axis_info().has_value()) {\n+    out_reshape_dims = {axis.sub_axis_info()->pre_size,\n+                        axis.sub_axis_info()->size,\n+                        full_axis_size / axis.sub_axis_info()->next_pre_size()};\n+    // The aggregation axis is the second dimension.\n+    out_aggregate_axes = {1};\n+  } else {\n+    out_reshape_dims = {full_axis_size};\n+    out_aggregate_axes = {0};\n+  }\n+}\n+\n+void HandleMultiAxisRefPerDimension(std::vector<AxisRef>& axes,\n+                                    int64_t full_axis_size,\n+                                    std::vector<int64_t>& out_reshape_dims,\n+                                    std::vector<int64_t>& out_aggregate_axes) {\n+  // --- 1. Sort Axes and Original Indices Together ---\n+  // Sort both the axes and the original indices based on\n+  // sub_axis_info()->pre_size. This allows us to maintain user specified order\n+  // of AxisRef while still building the reshape and aggregate axes.\n+  std::vector<int> original_order(axes.size());\n+  std::iota(original_order.begin(), original_order.end(), 0);\n+  std::sort(original_order.begin(), original_order.end(),\n+            [&axes](int i, int j) {\n+              return axes[i].sub_axis_info()->pre_size <\n+                     axes[j].sub_axis_info()->pre_size;\n+            });\n+  std::sort(axes.begin(), axes.end(), [](const AxisRef& a, const AxisRef& b) {\n+    return a.sub_axis_info()->pre_size < b.sub_axis_info()->pre_size;\n+  });\n+\n+  // --- 2. Build Reshape Dims and Aggregation Axes ---\n+  int64_t current_dim_index = 0;  // Index in the new reshaped tensor\n+  int64_t prefix_product = 1;     // Product of the size of all prior dimensions\n+\n+  for (const AxisRef& axis : axes) {\n+    int64_t pre_size = axis.sub_axis_info()->pre_size;\n+    int64_t size = axis.sub_axis_info()->size;\n+\n+    // Insert \"padding\" dimension if the current prefix product doesn't match\n+    // the required pre_size\n+    if (pre_size != prefix_product) {\n+      int64_t padding_size = pre_size / prefix_product;\n+      out_reshape_dims.push_back(padding_size);\n+      current_dim_index++;\n+      prefix_product *= padding_size;\n+    }\n+\n+    // Insert the sharded size (the part to aggregate)\n+    out_reshape_dims.push_back(size);\n+    out_aggregate_axes.push_back(\n+        current_dim_index);  // This is the axis we aggregate over\n+    current_dim_index++;\n+    prefix_product *= size;\n+  }\n+\n+  // Insert \"suffix\" dimension if the full size hasn't been reached\n+  if (prefix_product != full_axis_size) {\n+    out_reshape_dims.push_back(full_axis_size / prefix_product);\n+  }\n+\n+  // --- 3. Permute Aggregate Axes back to Original Order ---\n+  // The aggregate axes were calculated based on the sorted list.\n+  // We must map them back to the original order to compute the correct\n+  // flattened replica groups.\n+  std::vector<int64_t> permuted_aggregate_axes(original_order.size());\n+  for (int64_t i = 0; i < original_order.size(); ++i) {\n+    permuted_aggregate_axes[original_order[i]] = out_aggregate_axes[i];\n+  }\n+  out_aggregate_axes = permuted_aggregate_axes;\n+}\n+\n+bool ValidateSingleDimensionAxes(int64_t dim, std::vector<AxisRef>& axes,\n+                                 const Mesh& mesh_) {\n+  // If there's only one axis, nothing to check.\n+  if (axes.size() <= 1) {\n+    return true;\n+  }\n+  // --- Step 1: Deduplication ---\n+  // If one is a \"full\" axis (no sub_axis_info), it subsumes all other AxisRefs\n+  // with sub_axis_info.\n+  for (const AxisRef& axis : axes) {\n+    if (!axis.sub_axis_info().has_value()) {\n+      LOG(WARNING) << \"MeshAxesReplicaGroupList: Redundant axis definition at \"\n+                      \"dimension: \"\n+                   << dim\n+                   << \". Keeping only the full axis: \" << axis.ToString(mesh_);\n+      axes = {axis};\n+      return true;\n+    }\n+  }\n+  // --- Step 2: Overlap Check ---\n+  // At this point, all remaining axes MUST have sub_axis_info().\n+  // Verify that the remaining multiple sub-axes do not overlap.\n+  for (int64_t i = 0; i < axes.size() - 1; ++i) {\n+    for (int64_t j = i + 1; j < axes.size(); ++j) {\n+      // CHECK will terminate the program on failure, matching original\n+      // behavior.\n+      CHECK(axes[i].CanCoexist(axes[j]))\n+          << \"Overlapping sub-axes detected: \" << axes[i].ToString(mesh_)\n+          << \" and \" << axes[j].ToString(mesh_);\n+    }\n+  }\n+  return true;  // Passed all checks for this dimension.\n+}\n+\n+MeshAxesReplicaGroupList::MeshAxesReplicaGroupList(Mesh mesh,\n+                                                   std::vector<AxisRef> axes)\n+    : mesh_(std::move(mesh)), axes_(std::move(axes)) {\n+  if (num_devices_per_group() == 1) {\n+    LOG(ERROR) << \"MeshAxesReplicaGroupList: \" << ToString()\n+               << \" has only one device per replica group.\";\n+  }\n+\n+  absl::flat_hash_set<int64_t> dimensions;\n+  absl::flat_hash_map<int64_t, std::vector<AxisRef>> dim_to_axes;\n+  for (const AxisRef& axis : axes_) {\n+    dim_to_axes[axis.mesh_axis_index()].push_back(axis);\n+    dimensions.insert(axis.mesh_axis_index());\n+    if (axis.sub_axis_info().has_value()) {\n+      CHECK(mesh_.axis_size(axis.mesh_axis_index()) %\n+                axis.sub_axis_info()->next_pre_size() ==\n+            0)\n+          << \"Next pre-size must divide the full axis size.\";\n+    }\n+  }\n+\n+  // Validate input AxisRefs.\n+  for (int64_t dim : dimensions) {\n+    std::vector<AxisRef>& axes = dim_to_axes[dim];\n+    CHECK(ValidateSingleDimensionAxes(dim, axes, mesh_));\n+  }\n+}\n+\n int64_t MeshAxesReplicaGroupList::num_replica_groups() const {\n   return mesh_.device_assignment().num_elements() / num_devices_per_group();\n }\n@@ -58,15 +202,105 @@ int64_t MeshAxesReplicaGroupList::num_devices_per_group() const {\n   // all axes.\n   int64_t devices_per_group = 1;\n   for (const AxisRef& axis : axes_) {\n-    int64_t axis_size =\n-        axis.sub_axis_info().has_value()\n-            ? axis.sub_axis_info()->size\n-            : mesh_.device_assignment().dim(axis.mesh_axis_index());\n+    int64_t axis_size = axis.sub_axis_info().has_value()\n+                            ? axis.sub_axis_info()->size\n+                            : mesh_.axis_size(axis.mesh_axis_index());\n     devices_per_group *= axis_size;\n   }\n   return devices_per_group;\n }\n \n+std::vector<std::vector<int64_t>> get_replica_groups_for_full_axes(\n+    const Mesh& mesh, absl::Span<const int64_t> axis_sizes,\n+    const absl::Span<const int64_t> grouped_axes,\n+    const int64_t num_replica_groups, const int64_t num_devices_per_group) {\n+  // Reshape the device assignment array bases on the axis sizes and transpose\n+  // grouped axes to the end.\n+  std::vector<int> transpose_axes;\n+  transpose_axes.reserve(axis_sizes.size());\n+  for (int64_t i = 0; i < axis_sizes.size(); ++i) {\n+    if (!absl::c_linear_search(grouped_axes, i)) {\n+      transpose_axes.push_back(i);\n+    }\n+  }\n+  for (int64_t grouped_axis : grouped_axes) {\n+    transpose_axes.push_back(grouped_axis);\n+  }\n+\n+  TileAssignment device_assignment =\n+      mesh.device_assignment().Reshape(axis_sizes).Transpose(transpose_axes);\n+\n+  std::vector<std::vector<int64_t>> replica_groups;\n+  replica_groups.reserve(num_replica_groups);\n+  for (auto it = device_assignment.array().begin();\n+       it != device_assignment.array().end(); it += num_devices_per_group) {\n+    std::vector<int64_t> group(it, it + num_devices_per_group);\n+    replica_groups.emplace_back(std::move(group));\n+  }\n+  return replica_groups;\n+}\n+\n+void MeshAxesReplicaGroupList::InitializeDimToReshapeAndAggregateAxes() {\n+  absl::flat_hash_map<int64_t, std::vector<AxisRef>> dim_to_axes;\n+  for (const AxisRef& axis : axes_) {\n+    dim_to_axes[axis.mesh_axis_index()].push_back(axis);\n+  }\n+  absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes> dim_map;\n+  // For each dimension determine the reshape that is consistent with it's\n+  // AxisRef(s). Then maintain this reshape and the aggregated dims for easier\n+  // computation of replica groups. As an example for @mesh<\"a\"=8>\n+  // {a}               -> no reshape, aggregate over [0]\n+  // {a:(1)2}          -> reshape [8]->[1,2,4], aggregate over [1]\n+  // {a:(1)2, a:(4)2}  -> reshape [8]->[2,2,2], aggregate over [0,2]\n+  for (auto& [dim, axes] : dim_to_axes) {\n+    int64_t full_axis_size = mesh_.axis_size(dim);\n+    ReshapeAndAggregateAxes reshape_and_aggregate_axes;\n+    if (axes.size() == 1) {\n+      HandleSingleAxisRefPerDimension(\n+          axes[0], full_axis_size, reshape_and_aggregate_axes.reshape_dims,\n+          reshape_and_aggregate_axes.aggregate_axes);\n+    } else {\n+      // Otherwise dimension is a set of axes with sub-axes info.\n+      HandleMultiAxisRefPerDimension(axes, full_axis_size,\n+                                     reshape_and_aggregate_axes.reshape_dims,\n+                                     reshape_and_aggregate_axes.aggregate_axes);\n+    }\n+    dim_map[dim] = reshape_and_aggregate_axes;\n+  }\n+  dim_to_reshape_and_aggregate_axes_ = dim_map;\n+}\n+\n+std::vector<std::vector<int64_t>>\n+MeshAxesReplicaGroupList::flattened_replica_groups() {\n+  if (!dim_to_reshape_and_aggregate_axes_.has_value()) {\n+    InitializeDimToReshapeAndAggregateAxes();\n+  }\n+\n+  absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes> dim_map =\n+      dim_to_reshape_and_aggregate_axes_.value();\n+  std::vector<int64_t> reindex_axis_sizes;\n+  std::vector<int64_t> reindexed_grouped_axes;\n+  for (int64_t i = 0; i < mesh_.axis_sizes().size(); ++i) {\n+    int64_t axis_size = mesh_.axis_size(i);\n+    auto it = dim_map.find(i);\n+    if (it == dim_map.end()) {\n+      reindex_axis_sizes.push_back(axis_size);\n+      continue;\n+    }\n+    int64_t offset_index = reindex_axis_sizes.size();\n+    const ReshapeAndAggregateAxes& reshape_and_aggregate_axes = it->second;\n+    for (int64_t reshape_dim : reshape_and_aggregate_axes.reshape_dims) {\n+      reindex_axis_sizes.push_back(reshape_dim);\n+    }\n+    for (int64_t aggregate_dim : reshape_and_aggregate_axes.aggregate_axes) {\n+      reindexed_grouped_axes.push_back(aggregate_dim + offset_index);\n+    }\n+  }\n+  return get_replica_groups_for_full_axes(\n+      mesh_, reindex_axis_sizes, reindexed_grouped_axes, num_replica_groups(),\n+      num_devices_per_group());\n+}\n+\n void MeshAxesReplicaGroupList::Print(Printer* printer) const {\n   printer->Append(ToString());\n }"
        },
        {
            "sha": "06497aa0ddfe69805492205874b39558c3e35347",
            "filename": "third_party/xla/xla/hlo/ir/replica_group.h",
            "status": "modified",
            "additions": 15,
            "deletions": 7,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group.h?ref=261e0779840ec1162aee05ccf7fc112a558fc467",
            "patch": "@@ -16,14 +16,19 @@ limitations under the License.\n #ifndef XLA_HLO_IR_REPLICA_GROUP_H_\n #define XLA_HLO_IR_REPLICA_GROUP_H_\n \n+#include <algorithm>\n #include <cstddef>\n #include <cstdint>\n #include <memory>\n+#include <numeric>\n #include <optional>\n #include <string>\n #include <utility>\n #include <vector>\n \n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/types/span.h\"\n #include \"google/protobuf/repeated_ptr_field.h\"\n@@ -38,14 +43,13 @@ limitations under the License.\n namespace xla {\n \n class MeshAxesReplicaGroupList {\n+  struct ReshapeAndAggregateAxes {\n+    std::vector<int64_t> reshape_dims;\n+    std::vector<int64_t> aggregate_axes;\n+  };\n+\n  public:\n-  explicit MeshAxesReplicaGroupList(Mesh mesh, std::vector<AxisRef> axes)\n-      : mesh_(std::move(mesh)), axes_(std::move(axes)) {\n-    if (num_devices_per_group() == 1) {\n-      LOG(ERROR) << \"MeshAxesReplicaGroupList: \" << ToString()\n-                 << \" has only one device per replica group.\";\n-    }\n-  }\n+  explicit MeshAxesReplicaGroupList(Mesh mesh, std::vector<AxisRef> axes);\n \n   bool operator==(const MeshAxesReplicaGroupList& other) const {\n     return mesh_ == other.mesh_ && axes_ == other.axes_;\n@@ -58,6 +62,7 @@ class MeshAxesReplicaGroupList {\n \n   int64_t num_replica_groups() const;\n   int64_t num_devices_per_group() const;\n+  std::vector<std::vector<int64_t>> flattened_replica_groups();\n \n   void Print(Printer* printer) const;\n \n@@ -69,8 +74,11 @@ class MeshAxesReplicaGroupList {\n       const MeshAxesReplicaGroupListProto& proto);\n \n  private:\n+  void InitializeDimToReshapeAndAggregateAxes();\n   Mesh mesh_;\n   std::vector<AxisRef> axes_;\n+  std::optional<absl::flat_hash_map<int64_t, ReshapeAndAggregateAxes>>\n+      dim_to_reshape_and_aggregate_axes_;\n };\n \n std::string ReplicaGroupsToString("
        },
        {
            "sha": "9ae886a8e92d21a129bb4d999490fd75b78cca97",
            "filename": "third_party/xla/xla/hlo/ir/replica_group_test.cc",
            "status": "modified",
            "additions": 242,
            "deletions": 21,
            "changes": 263,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/261e0779840ec1162aee05ccf7fc112a558fc467/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Freplica_group_test.cc?ref=261e0779840ec1162aee05ccf7fc112a558fc467",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"xla/array.h\"\n+#include \"xla/array2d.h\"\n #include \"xla/hlo/ir/mesh_and_axis.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n #include \"xla/service/hlo.pb.h\"\n@@ -41,23 +42,230 @@ CollectiveDeviceListProto CreateDeviceListProto(\n   return proto;\n }\n \n-TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSize) {\n+TEST(MeshAxesReplicaGroupListTest, MaterializedReplicaGroups) {\n+  Mesh mesh_xy(TileAssignment({2, 2}), /*axes_names=*/{\"x\", \"y\"});\n+\n+  MeshAxesReplicaGroupList replica_group_none(mesh_xy, {});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_none = {\n+      {0}, {1}, {2}, {3}};\n+  EXPECT_EQ(replica_group_none.flattened_replica_groups(),\n+            expected_replica_groups_none);\n+\n+  MeshAxesReplicaGroupList replica_group_x(mesh_xy, {AxisRef(0)});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_x = {{0, 2},\n+                                                                 {1, 3}};\n+  EXPECT_EQ(replica_group_x.flattened_replica_groups(),\n+            expected_replica_groups_x);\n+\n+  MeshAxesReplicaGroupList replica_group_y(mesh_xy, {AxisRef(1)});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_y = {{0, 1},\n+                                                                 {2, 3}};\n+  EXPECT_EQ(replica_group_y.flattened_replica_groups(),\n+            expected_replica_groups_y);\n+\n+  MeshAxesReplicaGroupList replica_group_xy(mesh_xy, {AxisRef(0), AxisRef(1)});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_xy = {{0, 1, 2, 3}};\n+  EXPECT_EQ(replica_group_xy.flattened_replica_groups(),\n+            expected_replica_groups_xy);\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest, MaterializedReplicaGroupsWithSubaxes) {\n+  Mesh mesh(TileAssignment(IotaTileAssignment::Create(/*dims=*/{6, 6})),\n+            /*axes_names=*/{\"a\", \"b\"});\n+\n+  // a:(1)2\n+  MeshAxesReplicaGroupList replica_group_a_1_2(mesh, {AxisRef(0, {1, 2})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_a_1_2 = {\n+      {0, 18},  {1, 19},  {2, 20},  {3, 21},  {4, 22},  {5, 23},\n+      {6, 24},  {7, 25},  {8, 26},  {9, 27},  {10, 28}, {11, 29},\n+      {12, 30}, {13, 31}, {14, 32}, {15, 33}, {16, 34}, {17, 35}};\n+  EXPECT_EQ(replica_group_a_1_2.flattened_replica_groups(),\n+            expected_replica_groups_a_1_2);\n+\n+  // a:(1)3\n+  MeshAxesReplicaGroupList replica_group_a_1_3(mesh, {AxisRef(0, {1, 3})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_a_1_3 = {\n+      {0, 12, 24}, {1, 13, 25}, {2, 14, 26},  {3, 15, 27},\n+      {4, 16, 28}, {5, 17, 29}, {6, 18, 30},  {7, 19, 31},\n+      {8, 20, 32}, {9, 21, 33}, {10, 22, 34}, {11, 23, 35}};\n+  EXPECT_EQ(replica_group_a_1_3.flattened_replica_groups(),\n+            expected_replica_groups_a_1_3);\n+\n+  // a:(3)2\n+  MeshAxesReplicaGroupList replica_group_a_3_2(mesh, {AxisRef(0, {3, 2})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_a_3_2 = {\n+      {0, 6},   {1, 7},   {2, 8},   {3, 9},   {4, 10},  {5, 11},\n+      {12, 18}, {13, 19}, {14, 20}, {15, 21}, {16, 22}, {17, 23},\n+      {24, 30}, {25, 31}, {26, 32}, {27, 33}, {28, 34}, {29, 35}};\n+  EXPECT_EQ(replica_group_a_3_2.flattened_replica_groups(),\n+            expected_replica_groups_a_3_2);\n+\n+  // b:(1)2\n+  MeshAxesReplicaGroupList replica_group_b_1_2(mesh, {AxisRef(1, {1, 2})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_b_1_2 = {\n+      {0, 3},   {1, 4},   {2, 5},   {6, 9},   {7, 10},  {8, 11},\n+      {12, 15}, {13, 16}, {14, 17}, {18, 21}, {19, 22}, {20, 23},\n+      {24, 27}, {25, 28}, {26, 29}, {30, 33}, {31, 34}, {32, 35}};\n+  EXPECT_EQ(replica_group_b_1_2.flattened_replica_groups(),\n+            expected_replica_groups_b_1_2);\n+\n+  // b:(1)3\n+  MeshAxesReplicaGroupList replica_group_b_1_3(mesh, {AxisRef(1, {1, 3})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_b_1_3 = {\n+      {0, 2, 4},    {1, 3, 5},    {6, 8, 10},   {7, 9, 11},\n+      {12, 14, 16}, {13, 15, 17}, {18, 20, 22}, {19, 21, 23},\n+      {24, 26, 28}, {25, 27, 29}, {30, 32, 34}, {31, 33, 35}};\n+  EXPECT_EQ(replica_group_b_1_3.flattened_replica_groups(),\n+            expected_replica_groups_b_1_3);\n+\n+  // b:(3)2\n+  MeshAxesReplicaGroupList replica_group_b_3_2(mesh, {AxisRef(1, {3, 2})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_b_3_2 = {\n+      {0, 1},   {2, 3},   {4, 5},   {6, 7},   {8, 9},   {10, 11},\n+      {12, 13}, {14, 15}, {16, 17}, {18, 19}, {20, 21}, {22, 23},\n+      {24, 25}, {26, 27}, {28, 29}, {30, 31}, {32, 33}, {34, 35}};\n+  EXPECT_EQ(replica_group_b_3_2.flattened_replica_groups(),\n+            expected_replica_groups_b_3_2);\n+\n+  // a:(1)2, b:(1)2\n+  MeshAxesReplicaGroupList replica_group_a_1_2_b_1_2(\n+      mesh, {AxisRef(0, {1, 2}), AxisRef(1, {1, 2})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_a_1_2_b_1_2 = {\n+      {0, 3, 18, 21},   {1, 4, 19, 22},   {2, 5, 20, 23},\n+      {6, 9, 24, 27},   {7, 10, 25, 28},  {8, 11, 26, 29},\n+      {12, 15, 30, 33}, {13, 16, 31, 34}, {14, 17, 32, 35}};\n+  EXPECT_EQ(replica_group_a_1_2_b_1_2.flattened_replica_groups(),\n+            expected_replica_groups_a_1_2_b_1_2);\n+\n+  // a:(1)3, b:(1)3\n+  MeshAxesReplicaGroupList replica_group_a_1_3_b_1_3(\n+      mesh, {AxisRef(0, {1, 3}), AxisRef(1, {1, 3})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_a_1_3_b_1_3 = {\n+      {0, 2, 4, 12, 14, 16, 24, 26, 28},\n+      {1, 3, 5, 13, 15, 17, 25, 27, 29},\n+      {6, 8, 10, 18, 20, 22, 30, 32, 34},\n+      {7, 9, 11, 19, 21, 23, 31, 33, 35}};\n+  EXPECT_EQ(replica_group_a_1_3_b_1_3.flattened_replica_groups(),\n+            expected_replica_groups_a_1_3_b_1_3);\n+\n+  //  b:(1)3, a:(1)3 (Reverse order from above). This should produce the same\n+  // replica groups as the above but with ids in a different order.\n+  MeshAxesReplicaGroupList replica_group_b_1_3_a_1_3(\n+      mesh, {AxisRef(1, {1, 3}), AxisRef(0, {1, 3})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_b_1_3_a_1_3 = {\n+      {0, 12, 24, 2, 14, 26, 4, 16, 28},\n+      {1, 13, 25, 3, 15, 27, 5, 17, 29},\n+      {6, 18, 30, 8, 20, 32, 10, 22, 34},\n+      {7, 19, 31, 9, 21, 33, 11, 23, 35}};\n+  EXPECT_EQ(replica_group_a_1_3_b_1_3.flattened_replica_groups(),\n+            expected_replica_groups_a_1_3_b_1_3);\n+\n+  // a:(3)2, b:(3)2\n+  MeshAxesReplicaGroupList replica_group_a_3_2_b_3_2(\n+      mesh, {AxisRef(0, {3, 2}), AxisRef(1, {3, 2})});\n+  std::vector<std::vector<int64_t>> expected_replica_groups_a_3_2_b_3_2 = {\n+      {0, 1, 6, 7},     {2, 3, 8, 9},     {4, 5, 10, 11},\n+      {12, 13, 18, 19}, {14, 15, 20, 21}, {16, 17, 22, 23},\n+      {24, 25, 30, 31}, {26, 27, 32, 33}, {28, 29, 34, 35}};\n+  EXPECT_EQ(replica_group_a_3_2_b_3_2.flattened_replica_groups(),\n+            expected_replica_groups_a_3_2_b_3_2);\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest, MaterializedReplicaGroupsMatchExpectedV2) {\n+  Mesh mesh(TileAssignment(IotaTileAssignment::Create(/*dims=*/{8})),\n+            /*axes_names=*/{\"a\"});\n+\n+  // a:(1)2 -> replica_groups=[4,2]<=[2,4]T(1,0)\n+  MeshAxesReplicaGroupList v3_subaxis_1_2(mesh, {AxisRef(0, {1, 2})});\n+  IotaReplicaGroupList v2_subaxis_1_2(4, 2, {2, 4}, {1, 0});\n+  EXPECT_EQ(v3_subaxis_1_2.flattened_replica_groups(),\n+            v2_subaxis_1_2.flattened_replica_groups());\n+\n+  // a:(1)4 -> replica_groups=[2,4]<=[4,2]T(1,0)\n+  MeshAxesReplicaGroupList v3_subaxis_1_4(mesh, {AxisRef(0, {1, 4})});\n+  IotaReplicaGroupList v2_subaxis_1_4(2, 4, {4, 2}, {1, 0});\n+  EXPECT_EQ(v3_subaxis_1_4.flattened_replica_groups(),\n+            v2_subaxis_1_4.flattened_replica_groups());\n+\n+  // a:(2)2 -> replica_groups=[4,2]<=[2,2,2]T(0,2,1)\n+  MeshAxesReplicaGroupList v3_subaxis_2_2(mesh, {AxisRef(0, {2, 2})});\n+  IotaReplicaGroupList v2_subaxis_2_2(4, 2, {2, 2, 2}, {0, 2, 1});\n+  EXPECT_EQ(v3_subaxis_2_2.flattened_replica_groups(),\n+            v2_subaxis_2_2.flattened_replica_groups());\n+\n+  // a:(2)4 -> replica_groups=[2,4]<=[8]\n+  MeshAxesReplicaGroupList v3_subaxis_2_4(mesh, {AxisRef(0, {2, 4})});\n+  IotaReplicaGroupList v2_subaxis_2_4(2, 4, {8}, {0});\n+  EXPECT_EQ(v3_subaxis_2_4.flattened_replica_groups(),\n+            v2_subaxis_2_4.flattened_replica_groups());\n+\n+  // a:(4)2 -> replica_groups=[4,2]<=[8]\n+  MeshAxesReplicaGroupList v3_subaxis_4_2(mesh, {AxisRef(0, {4, 2})});\n+  IotaReplicaGroupList v2_subaxis_4_2(4, 2, {8}, {0});\n+  EXPECT_EQ(v3_subaxis_4_2.flattened_replica_groups(),\n+            v2_subaxis_4_2.flattened_replica_groups());\n+\n+  //  {a:(1)2, a:(4)2} -> replica_groups=[2,4]<=[2,2,2]T(1,0,2)\n+  MeshAxesReplicaGroupList v3_subaxis_1_2_and_4_2(\n+      mesh, {AxisRef(0, {1, 2}), AxisRef(0, {4, 2})});\n+  IotaReplicaGroupList v2_subaxis_1_2_and_4_2(2, 4, {2, 2, 2}, {1, 0, 2});\n+  EXPECT_EQ(v3_subaxis_1_2_and_4_2.flattened_replica_groups(),\n+            v2_subaxis_1_2_and_4_2.flattened_replica_groups());\n+\n+  //  {a:(4)2, a:(1)2} -> replica_groups=[2,4]<=[2,2,2]T(1,2,0)\n+  MeshAxesReplicaGroupList v3_subaxis_4_2_and_1_2(\n+      mesh, {AxisRef(0, {4, 2}), AxisRef(0, {1, 2})});\n+  IotaReplicaGroupList v2_subaxis_4_2_and_1_2(2, 4, {2, 2, 2}, {1, 2, 0});\n+  EXPECT_EQ(v3_subaxis_4_2_and_1_2.flattened_replica_groups(),\n+            v2_subaxis_4_2_and_1_2.flattened_replica_groups());\n+\n+  // a      -> replica_groups=[1,8]<=[8]\n+  MeshAxesReplicaGroupList v3_no_subaxis(mesh, {AxisRef(0)});\n+  IotaReplicaGroupList v2_no_subaxis(1, 8, {8}, {0});\n+  EXPECT_EQ(v3_no_subaxis.flattened_replica_groups(),\n+            v2_no_subaxis.flattened_replica_groups());\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest,\n+     MaterializedReplicaGroupsRespectNonIotaDeviceOrdering) {\n+  // Create a mesh with non-iota device ordering.\n+  Array2D<int64_t> array({{3, 1}, {0, 2}});\n+  TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n+  Mesh mesh_xy(tile_assignment, /*axes_names=*/{\"x\", \"y\"});\n+\n+  // Reduce along x axis.\n+  MeshAxesReplicaGroupList replica_group_x(mesh_xy, {AxisRef(0)});\n+  // With iota device ordering, the expected replica groups would be\n+  // {{0, 2}, {1, 3}}.\n+  std::vector<std::vector<int64_t>> expected_replica_groups_x = {{3, 0},\n+                                                                 {1, 2}};\n+  EXPECT_THAT(replica_group_x.flattened_replica_groups(),\n+              testing::UnorderedElementsAreArray(expected_replica_groups_x));\n+\n+  // Reduce along y axis.\n+  MeshAxesReplicaGroupList replica_group_y(mesh_xy, {AxisRef(1)});\n+  // With iota device ordering, the expected replica groups would be\n+  // {{0, 1}, {2, 3}}.\n+  std::vector<std::vector<int64_t>> expected_replica_groups_y = {{3, 1},\n+                                                                 {0, 2}};\n+  EXPECT_THAT(replica_group_y.flattened_replica_groups(),\n+              testing::UnorderedElementsAreArray(expected_replica_groups_y));\n+}\n+\n+TEST(MeshAxesReplicaGroupListTest, NumReplicaGroups) {\n   Mesh all_axes(TileAssignment(IotaTileAssignment::Create(\n                     /*dims=*/{4, 4})),\n                 /*axes_names=*/{\"x\", \"y\"});\n   MeshAxesReplicaGroupList replica_group_across_all_axes(\n-      all_axes,\n-      /*axes=*/{AxisRef(0), AxisRef(1)});\n+      all_axes, {AxisRef(0), AxisRef(1)});\n   EXPECT_EQ(replica_group_across_all_axes.num_replica_groups(), 1);\n   EXPECT_EQ(replica_group_across_all_axes.num_devices_per_group(), 16);\n \n   Mesh one_axes(TileAssignment(IotaTileAssignment::Create(\n                     /*dims=*/{3, 5})),\n                 /*axes_names=*/{\"a\", \"b\"});\n-  MeshAxesReplicaGroupList replica_group_across_a(one_axes,\n-                                                  /*axes=*/{AxisRef(0)});\n-  MeshAxesReplicaGroupList replica_group_across_b(one_axes,\n-                                                  /*axes=*/{AxisRef(1)});\n+  MeshAxesReplicaGroupList replica_group_across_a(one_axes, {AxisRef(0)});\n+  MeshAxesReplicaGroupList replica_group_across_b(one_axes, {AxisRef(1)});\n   EXPECT_EQ(replica_group_across_a.num_replica_groups(), 5);\n   EXPECT_EQ(replica_group_across_a.num_devices_per_group(), 3);\n   EXPECT_EQ(replica_group_across_b.num_replica_groups(), 3);\n@@ -71,16 +279,30 @@ TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSize) {\n   EXPECT_EQ(replica_group_across_no_axes.num_devices_per_group(), 1);\n }\n \n+TEST(MeshAxesReplicaGroupListTest, ValidateSubAxesCoexistenceCheck) {\n+  Mesh mesh(TileAssignment({8}), /*axes_names=*/{\"1\"});\n+  MeshAxesReplicaGroupList replica_group_multiple_subaxes1(\n+      mesh, {AxisRef(0, {1, 2}), AxisRef(0, {4, 2})});\n+  MeshAxesReplicaGroupList replica_group_multiple_subaxes2(\n+      mesh, {AxisRef(0, {4, 2}), AxisRef(0, {1, 2})});\n+\n+  Mesh overlap_mesh(TileAssignment({2 * 3 * 5}), /*axes_names=*/{\"u\"});\n+  EXPECT_DEATH(\n+      {\n+        MeshAxesReplicaGroupList overlapping_subaxes(\n+            overlap_mesh, {AxisRef(0, {6, 5}), AxisRef(0, {10, 3})});\n+      },\n+      \"Overlapping sub-axes\");\n+}\n+\n TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n   Mesh mesh_one_subaxis(TileAssignment(IotaTileAssignment::Create(\n                             /*dims=*/{2, 6, 10})),\n                         /*axes_names=*/{\"axis1\", \"axis2\", \"axis3\"});\n   MeshAxesReplicaGroupList replica_group_across_axis1_subaxis(\n-      mesh_one_subaxis,\n-      /*axes=*/{AxisRef(0, {1, 2})});\n+      mesh_one_subaxis, {AxisRef(0, {1, 2})});\n   MeshAxesReplicaGroupList replica_group_across_axis2_subaxis(\n-      mesh_one_subaxis,\n-      /*axes=*/{AxisRef(1, {2, 3})});\n+      mesh_one_subaxis, {AxisRef(1, {2, 3})});\n   EXPECT_EQ(replica_group_across_axis1_subaxis.num_replica_groups(), 60);\n   EXPECT_EQ(replica_group_across_axis1_subaxis.num_devices_per_group(), 2);\n   EXPECT_EQ(replica_group_across_axis2_subaxis.num_replica_groups(), 40);\n@@ -91,10 +313,10 @@ TEST(MeshAxesReplicaGroupListTest, ReplicaGroupsCountAndSizeForSubaxes) {\n                              /*axes_names=*/{\"alpha\", \"beta\", \"gamma\"});\n   MeshAxesReplicaGroupList replica_group_across_multiple_subaxis1(\n       mesh_multiple_subaxis,\n-      /*axes=*/{AxisRef(0, {1, 2}), AxisRef(1, {1, 5}), AxisRef(2, {1, 11})});\n+      {AxisRef(0, {1, 2}), AxisRef(1, {1, 5}), AxisRef(2, {1, 11})});\n   MeshAxesReplicaGroupList replica_group_across_multiple_subaxis2(\n       mesh_multiple_subaxis,\n-      /*axes=*/{AxisRef(0, {2, 3}), AxisRef(1, {5, 7}), AxisRef(2, {11, 13})});\n+      {AxisRef(0, {2, 3}), AxisRef(1, {5, 7}), AxisRef(2, {11, 13})});\n   EXPECT_EQ(replica_group_across_multiple_subaxis1.num_replica_groups(),\n             3 * 7 * 13);\n   EXPECT_EQ(replica_group_across_multiple_subaxis1.num_devices_per_group(),\n@@ -110,23 +332,22 @@ TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n   Mesh mesh_uvw(TileAssignment(IotaTileAssignment::Create(\n                     /*dims=*/{10, 12, 15})),\n                 /*axes_names=*/{\"u\", \"v\", \"w\"});\n-  MeshAxesReplicaGroupList replica_group_across_none(mesh_uvw, /*axes=*/{});\n+  MeshAxesReplicaGroupList replica_group_across_none(mesh_uvw, {});\n   EXPECT_EQ(replica_group_across_none.ToString(), \"@mesh<u=10,v=12,w=15> {}\");\n-  MeshAxesReplicaGroupList replica_group_across_uv(\n-      mesh_uvw,\n-      /*axes=*/{AxisRef(0), AxisRef(1)});\n+  MeshAxesReplicaGroupList replica_group_across_uv(mesh_uvw,\n+                                                   {AxisRef(0), AxisRef(1)});\n   EXPECT_EQ(replica_group_across_uv.ToString(), \"@mesh<u=10,v=12,w=15> {u,v}\");\n \n   // Subaxes and replica group v2 iota style device assignment.\n   Mesh mesh_abcd(TileAssignment(IotaTileAssignment::Create(\n                      /*dims=*/{2, 4, 4, 2}, /*reshape_dims=*/{1, 4, 1, 16},\n                      /*transpose_perm=*/{2, 3, 0, 1})),\n                  /*axes_names=*/{\"a\", \"b\", \"c\", \"d\"});\n-  MeshAxesReplicaGroupList rg_abcd_across_none(mesh_abcd, /*axes=*/{});\n+  MeshAxesReplicaGroupList rg_abcd_across_none(mesh_abcd, {});\n   EXPECT_EQ(rg_abcd_across_none.ToString(),\n             \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {}\");\n   MeshAxesReplicaGroupList rg_abcd_across_multiple_axes_and_subaxes(\n-      mesh_abcd, /*axes=*/{AxisRef(0), AxisRef(1, {1, 2}), AxisRef(3)});\n+      mesh_abcd, {AxisRef(0), AxisRef(1, {1, 2}), AxisRef(3)});\n   EXPECT_EQ(rg_abcd_across_multiple_axes_and_subaxes.ToString(),\n             \"@mesh<a=2,b=4,c=4,d=2>([4,16]T(1,0)) {a,b:(1)2,d}\");\n \n@@ -135,11 +356,11 @@ TEST(MeshAxesReplicaGroupListTest, MeshAxesToString) {\n   array.Reshape({10});\n   TileAssignment tile_assignment(std::make_shared<Array<int64_t>>(array));\n   Mesh mesh_ooo(tile_assignment, /*axes_names=*/{\"ooo\"});\n-  MeshAxesReplicaGroupList rg_ooo_across_none(mesh_ooo, /*axes=*/{});\n+  MeshAxesReplicaGroupList rg_ooo_across_none(mesh_ooo, {});\n   EXPECT_EQ(rg_ooo_across_none.ToString(),\n             \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {}\");\n   MeshAxesReplicaGroupList rg_ooo_across_ooo_5_2(mesh_ooo,\n-                                                 /*axes=*/{AxisRef(0, {5, 2})});\n+                                                 {AxisRef(0, {5, 2})});\n   EXPECT_EQ(rg_ooo_across_ooo_5_2.ToString(),\n             \"@mesh<ooo=10>(8,3,7,5,4,2,6,0,1,9) {ooo:(5)2}\");\n }"
        }
    ],
    "stats": {
        "total": 578,
        "additions": 545,
        "deletions": 33
    }
}