{
    "author": "tensorflower-gardener",
    "message": "[XLA:HLO] Refactor: Move `CreateLoopInvariantCopy` to `WhileUtil`.\n\nThis change extracts the `CreateLoopInvariantCopy` function, used in both `while_loop_invariant_code_motion` and `while_loop_expensive_invariant_code_motion`, into a shared utility function in `WhileUtil`.\n\nPiperOrigin-RevId: 814860697",
    "sha": "579d33292b1a97b4b6f873763e514fe8c75fa71c",
    "files": [
        {
            "sha": "8920470410db8d2109d7528ea580f5fbc198708d",
            "filename": "third_party/xla/xla/service/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2FBUILD?ref=579d33292b1a97b4b6f873763e514fe8c75fa71c",
            "patch": "@@ -4881,7 +4881,6 @@ cc_library(\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/strings:string_view\",\n     ],\n )\n@@ -4899,7 +4898,6 @@ xla_cc_test(\n         \"//xla/tests:xla_internal_test_main\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_googletest//:gtest\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n "
        },
        {
            "sha": "209b15aa510468e7892790631f6818bc145d86a6",
            "filename": "third_party/xla/xla/service/while_loop_expensive_invariant_code_motion.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 97,
            "changes": 111,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_expensive_invariant_code_motion.cc?ref=579d33292b1a97b4b6f873763e514fe8c75fa71c",
            "patch": "@@ -17,7 +17,6 @@ limitations under the License.\n \n #include <cstdint>\n #include <iterator>\n-#include <memory>\n #include <optional>\n #include <string>\n #include <utility>\n@@ -30,13 +29,11 @@ limitations under the License.\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/statusor.h\"\n-#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/analysis/while_loop_analysis.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/hlo/ir/hlo_original_value.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/map_util.h\"\n #include \"xla/service/while_util.h\"\n@@ -66,98 +63,6 @@ struct InvariantInfo {\n   // Hoistable instructions depending on this op to be hoisted.\n   InlinedVector<HloInstruction*, 2> blocked_users;\n };\n-\n-// Copies `to_hoist` to the computation containing `while_instr`, hoisting its\n-// operands as needed.  All of its transitive operands are expected to be in\n-// `invariant_instructions`. This function hoists the operands in\n-// `invariant_instructions` and sets the entry's hoisted_copy to the hoisted\n-// instruction.\n-static void CreateLoopInvariantCopy(\n-    flat_hash_map<HloInstruction*, InvariantInfo>* invariant_instructions,\n-    HloInstruction* while_instr, HloInstruction* to_hoist) {\n-  HloComputation* parent_of_while = while_instr->parent();\n-  HloComputation* while_body = while_instr->while_body();\n-\n-  struct DFSFrame {\n-    HloInstruction* instruction;\n-    int64_t operand_index;\n-  };\n-\n-  InlinedVector<DFSFrame, 8> dfs_stack;\n-  dfs_stack.push_back({to_hoist, 0});\n-\n-  HloInstruction* while_body_param = while_body->parameter_instruction(0);\n-  HloInstruction* while_operand = while_instr->mutable_operand(0);\n-\n-  do {\n-    DFSFrame* frame = &dfs_stack.back();\n-    // All of the operands for old_instruction have been cloned, so it is time\n-    // to clone old_instruction itself.\n-    if (frame->operand_index == frame->instruction->operand_count()) {\n-      HloInstruction* old_instruction = frame->instruction;\n-      InvariantInfo& info = FindOrDie(*invariant_instructions, old_instruction);\n-\n-      // Check if this instruction might have already been hoisted.\n-      if (info.hoisted_copy == nullptr) {\n-        auto get_new_operand = [&](HloInstruction* old_operand) {\n-          return old_operand == while_body_param\n-                     ? while_operand\n-                     : FindOrDie(*invariant_instructions, old_operand)\n-                           .hoisted_copy;\n-        };\n-\n-        InlinedVector<HloInstruction*, 4> new_operands;\n-        absl::c_transform(old_instruction->operands(),\n-                          std::back_inserter(new_operands), get_new_operand);\n-\n-        HloInstruction* new_instruction = parent_of_while->AddInstruction(\n-            old_instruction->CloneWithNewOperands(old_instruction->shape(),\n-                                                  new_operands));\n-\n-        std::optional<std::string> original_call_instructions;\n-        if (while_instr->original_value() != nullptr) {\n-          original_call_instructions =\n-              while_instr->original_value()->GetOriginalCallLikeInstructions();\n-        }\n-        if (original_call_instructions.has_value() &&\n-            old_instruction->original_value() != nullptr) {\n-          std::string original_call_prefix;\n-          if (!original_call_instructions->empty()) {\n-            // We only add the wildcard iteration count if the call-like\n-            // instruction is available.\n-            original_call_prefix =\n-                absl::StrCat(*original_call_instructions, \"#*/\");\n-          }\n-\n-          auto new_original_value = std::make_shared<OriginalValue>(\n-              *old_instruction->original_value());\n-          for (auto& [shape_index, original_array] :\n-               new_original_value->mutable_original_arrays()) {\n-            if (original_array) {\n-              original_array->instruction_name = absl::StrCat(\n-                  original_call_prefix, original_array->instruction_name);\n-            }\n-          }\n-          new_instruction->set_original_value(std::move(new_original_value));\n-        }\n-        info.hoisted_copy = new_instruction;\n-      }\n-\n-      dfs_stack.pop_back();\n-      continue;\n-    }\n-\n-    HloInstruction* next_operand =\n-        frame->instruction->mutable_operand(frame->operand_index++);\n-    if (next_operand == while_body_param ||\n-        FindOrDie(*invariant_instructions, next_operand).hoisted_copy !=\n-            nullptr) {\n-      continue;\n-    }\n-\n-    dfs_stack.push_back({next_operand, 0});\n-  } while (!dfs_stack.empty());\n-}\n }  // namespace\n \n absl::StatusOr<bool> WhileLoopExpensiveInvariantCodeMotion::\n@@ -230,14 +135,26 @@ absl::StatusOr<bool> WhileLoopExpensiveInvariantCodeMotion::\n   std::vector<HloInstruction*> instructions_to_replace;\n   std::vector<HloInstruction*> replacement_instructions;\n \n-  auto hoist = [&](HloInstruction* instruction, const InvariantInfo& info) {\n+  auto hoist = [&](HloInstruction* instruction, InvariantInfo& info) {\n     if (info.hoisted_copy) {\n       // Already hoisted.\n       return;\n     }\n     VLOG(2) << \"Hoisting \" << instruction->ToString(print_no_metadata);\n \n-    CreateLoopInvariantCopy(&invariant_instructions, while_instr, instruction);\n+    HloInstruction* to_hoist = instruction;\n+    auto is_hoisted = [&](HloInstruction* instr) {\n+      return FindOrDie(invariant_instructions, instr).hoisted_copy != nullptr;\n+    };\n+    auto get_hoisted = [&](HloInstruction* instr) {\n+      return FindOrDie(invariant_instructions, instr).hoisted_copy;\n+    };\n+    auto set_hoisted = [&](HloInstruction* old_instr,\n+                           HloInstruction* new_instr) {\n+      FindOrDie(invariant_instructions, old_instr).hoisted_copy = new_instr;\n+    };\n+    WhileUtil::CreateLoopInvariantCopy(to_hoist, while_instr, is_hoisted,\n+                                       get_hoisted, set_hoisted);\n \n     instructions_to_replace.push_back(instruction);\n     replacement_instructions.push_back(info.hoisted_copy);"
        },
        {
            "sha": "d0c4275d853a47b6eb59a0dece243f8bacf56057",
            "filename": "third_party/xla/xla/service/while_loop_invariant_code_motion.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 103,
            "changes": 119,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_loop_invariant_code_motion.cc?ref=579d33292b1a97b4b6f873763e514fe8c75fa71c",
            "patch": "@@ -17,10 +17,8 @@ limitations under the License.\n \n #include <cstdint>\n #include <iterator>\n-#include <memory>\n #include <optional>\n #include <string>\n-#include <utility>\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n@@ -29,13 +27,11 @@ limitations under the License.\n #include \"absl/container/inlined_vector.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n-#include \"absl/strings/str_cat.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/hlo/analysis/while_loop_analysis.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n-#include \"xla/hlo/ir/hlo_original_value.h\"\n #include \"xla/hlo/ir/hlo_print_options.h\"\n #include \"xla/hlo/transforms/simplifiers/hlo_dce.h\"\n #include \"xla/hlo/transforms/simplifiers/tuple_simplifier.h\"\n@@ -52,102 +48,6 @@ namespace xla {\n \n using absl::flat_hash_map;\n using absl::flat_hash_set;\n-using absl::InlinedVector;\n-\n-// Copies `to_hoist` to the computation containing `while_instr`, hoisting its\n-// operands as needed.  All of its transitive operands are expected to be either\n-// in `hoisted_instructions` or `unhoisted_invariant_instructions`.  This\n-// function hoists the operands in `unhoisted_invariant_instructions` and moves\n-// them into `hoisted_instructions`.\n-static void CreateLoopInvariantCopy(\n-    flat_hash_map<HloInstruction*, HloInstruction*>* hoisted_instructions,\n-    flat_hash_set<HloInstruction*>* unhoisted_invariant_instructions,\n-    HloInstruction* while_instr, HloInstruction* to_hoist) {\n-  HloComputation* parent_of_while = while_instr->parent();\n-  HloComputation* while_body = while_instr->while_body();\n-\n-  struct DFSFrame {\n-    HloInstruction* instruction;\n-    int64_t operand_index;\n-  };\n-\n-  InlinedVector<DFSFrame, 8> dfs_stack;\n-  dfs_stack.push_back({to_hoist, 0});\n-\n-  HloInstruction* while_body_param = while_body->parameter_instruction(0);\n-  HloInstruction* while_operand = while_instr->mutable_operand(0);\n-\n-  do {\n-    DFSFrame* frame = &dfs_stack.back();\n-    if (frame->operand_index == frame->instruction->operand_count()) {\n-      HloInstruction* old_instruction = frame->instruction;\n-\n-      // All of the operands for old_instruction have been cloned, so it is\n-      // time to clone old_instruction itself.\n-\n-      auto get_new_operand = [&](HloInstruction* old_operand) {\n-        return old_operand == while_body_param\n-                   ? while_operand\n-                   : FindOrDie(*hoisted_instructions, old_operand);\n-      };\n-\n-      InlinedVector<HloInstruction*, 4> new_operands;\n-      absl::c_transform(old_instruction->operands(),\n-                        std::back_inserter(new_operands), get_new_operand);\n-\n-      HloInstruction* new_instruction =\n-          parent_of_while->AddInstruction(old_instruction->CloneWithNewOperands(\n-              old_instruction->shape(), new_operands));\n-\n-      std::optional<std::string> original_call_instructions;\n-      if (while_instr->original_value() != nullptr) {\n-        original_call_instructions =\n-            while_instr->original_value()->GetOriginalCallLikeInstructions();\n-      }\n-      if (original_call_instructions.has_value() &&\n-          old_instruction->original_value() != nullptr) {\n-        std::string original_call_prefix;\n-        if (!original_call_instructions->empty()) {\n-          // We only add the wildcard iteration count if the call-like\n-          // instruction is available.\n-          original_call_prefix =\n-              absl::StrCat(*original_call_instructions, \"#*/\");\n-        }\n-\n-        auto new_original_value =\n-            std::make_shared<OriginalValue>(*old_instruction->original_value());\n-        for (auto& [shape_index, original_array] :\n-             new_original_value->mutable_original_arrays()) {\n-          if (original_array) {\n-            original_array->instruction_name = absl::StrCat(\n-                original_call_prefix, original_array->instruction_name);\n-          }\n-        }\n-        new_instruction->set_original_value(std::move(new_original_value));\n-      }\n-\n-      InsertOrDie(hoisted_instructions, old_instruction, new_instruction);\n-\n-      // Approximately half of the instructions that would normally be present\n-      // in unhoisted_invariant_instructions are constants.  We save a bit of\n-      // compile time by not putting these in the hashtable.\n-      CHECK_EQ(unhoisted_invariant_instructions->erase(old_instruction),\n-               to_hoist != old_instruction &&\n-                   old_instruction->opcode() != HloOpcode::kConstant);\n-      dfs_stack.pop_back();\n-      continue;\n-    }\n-\n-    HloInstruction* next_operand =\n-        frame->instruction->mutable_operand(frame->operand_index++);\n-    if (hoisted_instructions->contains(next_operand) ||\n-        next_operand == while_body_param) {\n-      continue;\n-    }\n-\n-    dfs_stack.push_back({next_operand, 0});\n-  } while (!dfs_stack.empty());\n-}\n \n // Returns true if `instruction` is worth hoisting only if it lets us hoist some\n // instruction using it. The rationale is that hoisting these instructions will\n@@ -336,9 +236,22 @@ WhileLoopInvariantCodeMotion::TryHoistingInvariantInstructionsFromWhileBody(\n \n     VLOG(2) << \"Hoisting \" << instruction->ToString(print_no_metadata);\n \n-    CreateLoopInvariantCopy(&hoisted_instructions,\n-                            &unhoisted_invariant_instructions, while_instr,\n-                            instruction);\n+    HloInstruction* to_hoist = instruction;\n+    auto is_hoisted = [&](HloInstruction* instr) {\n+      return hoisted_instructions.count(instr);\n+    };\n+    auto get_hoisted = [&](HloInstruction* instr) {\n+      return FindOrDie(hoisted_instructions, instr);\n+    };\n+    auto set_hoisted = [&](HloInstruction* old_instr,\n+                           HloInstruction* new_instr) {\n+      InsertOrDie(&hoisted_instructions, old_instr, new_instr);\n+      CHECK_EQ(\n+          unhoisted_invariant_instructions.erase(old_instr),\n+          to_hoist != old_instr && old_instr->opcode() != HloOpcode::kConstant);\n+    };\n+    WhileUtil::CreateLoopInvariantCopy(to_hoist, while_instr, is_hoisted,\n+                                       get_hoisted, set_hoisted);\n \n     instructions_to_replace.push_back(instruction);\n     replacement_instructions.push_back("
        },
        {
            "sha": "5149850241c67d118578b4c26c61e3d22506a58d",
            "filename": "third_party/xla/xla/service/while_util.cc",
            "status": "modified",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.cc?ref=579d33292b1a97b4b6f873763e514fe8c75fa71c",
            "patch": "@@ -16,8 +16,11 @@ limitations under the License.\n #include \"xla/service/while_util.h\"\n \n #include <cstdint>\n+#include <functional>\n #include <iterator>\n #include <memory>\n+#include <optional>\n+#include <string>\n #include <tuple>\n #include <utility>\n #include <vector>\n@@ -134,6 +137,90 @@ WidenWhileBody(HloComputation* narrow_body, const Shape& wide_shape) {\n   return {{wide_while_body, std::move(inlined_instructions_map)}};\n }\n \n+/*static*/ void WhileUtil::CreateLoopInvariantCopy(\n+    HloInstruction* to_hoist, HloInstruction* while_instr,\n+    const std::function<bool(HloInstruction*)>& is_hoisted,\n+    const std::function<HloInstruction*(HloInstruction*)>& get_hoisted,\n+    const std::function<void(HloInstruction*, HloInstruction*)>& set_hoisted) {\n+  HloComputation* parent_of_while = while_instr->parent();\n+  HloComputation* while_body = while_instr->while_body();\n+\n+  struct DFSFrame {\n+    HloInstruction* instruction;\n+    int64_t operand_index;\n+  };\n+\n+  absl::InlinedVector<DFSFrame, 8> dfs_stack;\n+  dfs_stack.push_back({to_hoist, 0});\n+\n+  HloInstruction* while_body_param = while_body->parameter_instruction(0);\n+  HloInstruction* while_operand = while_instr->mutable_operand(0);\n+\n+  do {\n+    DFSFrame* frame = &dfs_stack.back();\n+    // All of the operands for old_instruction have been cloned, so it is time\n+    // to clone old_instruction itself.\n+    if (frame->operand_index == frame->instruction->operand_count()) {\n+      HloInstruction* old_instruction = frame->instruction;\n+\n+      // Check if this instruction might have already been hoisted.\n+      if (!is_hoisted(old_instruction)) {\n+        auto get_new_operand = [&](HloInstruction* old_operand) {\n+          return old_operand == while_body_param ? while_operand\n+                                                 : get_hoisted(old_operand);\n+        };\n+\n+        absl::InlinedVector<HloInstruction*, 4> new_operands;\n+        absl::c_transform(old_instruction->operands(),\n+                          std::back_inserter(new_operands), get_new_operand);\n+\n+        HloInstruction* new_instruction = parent_of_while->AddInstruction(\n+            old_instruction->CloneWithNewOperands(old_instruction->shape(),\n+                                                  new_operands));\n+\n+        std::optional<std::string> original_call_instructions;\n+        if (while_instr->original_value() != nullptr) {\n+          original_call_instructions =\n+              while_instr->original_value()->GetOriginalCallLikeInstructions();\n+        }\n+        if (original_call_instructions.has_value() &&\n+            old_instruction->original_value() != nullptr) {\n+          std::string original_call_prefix;\n+          if (!original_call_instructions->empty()) {\n+            // We only add the wildcard iteration count if the call-like\n+            // instruction is available.\n+            original_call_prefix =\n+                absl::StrCat(*original_call_instructions, \"#*/\");\n+          }\n+\n+          auto new_original_value = std::make_shared<OriginalValue>(\n+              *old_instruction->original_value());\n+          for (auto& [shape_index, original_array] :\n+               new_original_value->mutable_original_arrays()) {\n+            if (original_array) {\n+              original_array->instruction_name = absl::StrCat(\n+                  original_call_prefix, original_array->instruction_name);\n+            }\n+          }\n+          new_instruction->set_original_value(std::move(new_original_value));\n+        }\n+        set_hoisted(old_instruction, new_instruction);\n+      }\n+\n+      dfs_stack.pop_back();\n+      continue;\n+    }\n+\n+    HloInstruction* next_operand =\n+        frame->instruction->mutable_operand(frame->operand_index++);\n+    if (next_operand == while_body_param || is_hoisted(next_operand)) {\n+      continue;\n+    }\n+\n+    dfs_stack.push_back({next_operand, 0});\n+  } while (!dfs_stack.empty());\n+}\n+\n /*static*/ absl::StatusOr<WhileUtil::MakeInstructionsLiveInResult>\n WhileUtil::MakeInstructionsLiveIn(\n     HloInstruction* while_instr,"
        },
        {
            "sha": "c05234d28ae3f03fdf2ba816aa8187b8d304b515",
            "filename": "third_party/xla/xla/service/while_util.h",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/579d33292b1a97b4b6f873763e514fe8c75fa71c/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fwhile_util.h?ref=579d33292b1a97b4b6f873763e514fe8c75fa71c",
            "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n #define XLA_SERVICE_WHILE_UTIL_H_\n \n #include <cstdint>\n+#include <functional>\n #include <memory>\n #include <vector>\n \n@@ -58,6 +59,29 @@ class WhileUtil {\n     CallInliner::InlinedInstructionMap while_condition_instruction_map;\n   };\n \n+  // Copies `to_hoist` to the computation containing `while_instr`, hoisting\n+  // its operands as needed. `to_hoist` is an instruction in\n+  // `while_instr->while_body()`, and this function copies it and its operands\n+  // to `while_instr->parent()` if they are loop invariant.\n+  //\n+  // The function performs a DFS traversal starting from `to_hoist`. If an\n+  // operand of an instruction being hoisted has not yet been hoisted, it is\n+  // recursively hoisted.\n+  //\n+  // `is_hoisted`, `get_hoisted`, and `set_hoisted` are callbacks used to\n+  // manage hoisted instructions:\n+  // - `is_hoisted` should return true if an instruction is already hoisted.\n+  // - `get_hoisted` should return the instruction in `while_instr->parent()`\n+  //   corresponding to the hoisted instruction in `while_instr->while_body()`.\n+  // - `set_hoisted` is called to register a `new_instruction` in\n+  //   `while_instr->parent()` as the hoisted version of `old_instruction` in\n+  //   `while_instr->while_body()`.\n+  static void CreateLoopInvariantCopy(\n+      HloInstruction* to_hoist, HloInstruction* while_instr,\n+      const std::function<bool(HloInstruction*)>& is_hoisted,\n+      const std::function<HloInstruction*(HloInstruction*)>& get_hoisted,\n+      const std::function<void(HloInstruction*, HloInstruction*)>& set_hoisted);\n+\n   // Replaces `while_instr` with a new while instruction that is equivalent to\n   // `while_instr` except that it has all of the HLO instructions in\n   // `instructions` as live-in, loop invariant values.  These new live in values"
        }
    ],
    "stats": {
        "total": 343,
        "additions": 141,
        "deletions": 202
    }
}