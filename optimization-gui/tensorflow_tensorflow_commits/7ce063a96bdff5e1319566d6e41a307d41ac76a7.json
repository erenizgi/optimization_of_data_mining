{
    "author": "jparkerh",
    "message": "Adds `TfrtGpuClient::CreateAliasBuffer` to create a placeholder buffer.\n\nThis method creates a `PjRtBuffer` and a callback. The returned buffer acts as an alias, and its underlying memory and definition event are linked to a real `PjRtBuffer` when the provided callback is executed. The callback takes the real `PjRtBuffer` as input and forwards the alias buffer's internal `AsyncValue` and definition event to those of the real buffer.\n\nPiperOrigin-RevId: 810063291",
    "sha": "7ce063a96bdff5e1319566d6e41a307d41ac76a7",
    "files": [
        {
            "sha": "eced9916329bfe99286ba795a463592e988fea73",
            "filename": "third_party/xla/xla/pjrt/gpu/tfrt/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2FBUILD?ref=7ce063a96bdff5e1319566d6e41a307d41ac76a7",
            "patch": "@@ -55,6 +55,8 @@ cc_library(\n         \"//xla/core/collectives:collectives_registry\",\n         \"//xla/hlo/builder:xla_computation\",\n         \"//xla/hlo/ir:hlo\",\n+        \"//xla/pjrt:abstract_tracked_device_buffer\",\n+        \"//xla/pjrt:device_event\",\n         \"//xla/pjrt:host_callback\",\n         \"//xla/pjrt:host_memory_spaces\",\n         \"//xla/pjrt:layout_mode\",\n@@ -66,6 +68,7 @@ cc_library(\n         \"//xla/pjrt:pjrt_executable\",\n         \"//xla/pjrt:pjrt_future\",\n         \"//xla/pjrt:pjrt_stream_executor_device_description\",\n+        \"//xla/pjrt:raw_buffer\",\n         \"//xla/pjrt:semaphore\",\n         \"//xla/pjrt:stream_executor_executable\",\n         \"//xla/pjrt:transpose\","
        },
        {
            "sha": "59596397f713bb9cea820be2a496de5ff1cbaeb9",
            "filename": "third_party/xla/xla/pjrt/gpu/tfrt/tfrt_gpu_client.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 9,
            "changes": 68,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client.cc?ref=7ce063a96bdff5e1319566d6e41a307d41ac76a7",
            "patch": "@@ -26,13 +26,9 @@ limitations under the License.\n #include <optional>\n #include <string>\n #include <utility>\n-#include <variant>\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/container/flat_hash_set.h\"\n-#include \"absl/container/inlined_vector.h\"\n #include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n@@ -51,7 +47,6 @@ limitations under the License.\n #include \"xla/debug_options_flags.h\"\n #include \"xla/executable_run_options.h\"\n #include \"xla/hlo/builder/xla_computation.h\"\n-#include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/layout.h\"\n #include \"xla/literal.h\"\n #include \"xla/maybe_owning.h\"\n@@ -62,7 +57,6 @@ limitations under the License.\n #include \"xla/pjrt/gpu/gpu_helpers.h\"\n #include \"xla/pjrt/gpu/gpu_topology.h\"\n #include \"xla/pjrt/gpu/gpu_topology.pb.h\"\n-#include \"xla/pjrt/gpu/se_gpu_topology_description.h\"\n #include \"xla/pjrt/gpu/tfrt/gpu_event.h\"\n #include \"xla/pjrt/gpu/tfrt/host_memory_allocator.h\"\n #include \"xla/pjrt/gpu/tfrt/tfrt_gpu_async_host_to_device_transfer_manager.h\"\n@@ -71,14 +65,14 @@ limitations under the License.\n #include \"xla/pjrt/gpu/tfrt/tracked_gpu_device_buffer.h\"\n #include \"xla/pjrt/gpu/tfrt/utils.h\"\n #include \"xla/pjrt/host_memory_spaces.h\"\n-#include \"xla/pjrt/layout_mode.h\"\n #include \"xla/pjrt/mlir_to_hlo.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n #include \"xla/pjrt/pjrt_executable.h\"\n #include \"xla/pjrt/plugin/xla_gpu/xla_gpu_client_options.h\"\n #include \"xla/pjrt/proto/compile_options.pb.h\"\n+#include \"xla/pjrt/raw_buffer.h\"\n #include \"xla/pjrt/stream_executor_executable.h\"\n #include \"xla/pjrt/transpose.h\"\n #include \"xla/pjrt/utils.h\"\n@@ -100,12 +94,10 @@ limitations under the License.\n #include \"xla/stream_executor/stream_executor.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n #include \"xla/tsl/framework/allocator.h\"\n-#include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/logging.h\"\n #include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/platform/statusor.h\"\n-#include \"xla/tsl/platform/threadpool.h\"\n #include \"xla/util.h\"\n #include \"xla/xla_data.pb.h\"\n #include \"tsl/platform/casts.h\"\n@@ -451,6 +443,64 @@ TfrtGpuClient::CreateUninitializedBuffer(const Shape& shape,\n       memory_space);\n }\n \n+absl::StatusOr<\n+    std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+TfrtGpuClient::CreateAliasBuffer(const Shape& shape,\n+                                 PjRtMemorySpace* memory_space) {\n+  auto buffer_promise = tsl::MakeIndirectAsyncValue();\n+  auto definition_event_promise = tsl::MakeIndirectAsyncValue();\n+  auto ready_event_promise = tsl::MakeIndirectAsyncValue();\n+\n+  auto tracked_device_buffer = std::make_unique<TrackedGpuDeviceBuffer>(\n+      tsl::AsyncValueRef<GpuDeviceMemory>(buffer_promise),\n+      tsl::AsyncValueRef<GpuEvent>(definition_event_promise),\n+      tsl::AsyncValueRef<GpuEvent>(ready_event_promise));\n+\n+  if (memory_space->devices().size() != 1) {\n+    return absl::InternalError(\n+        \"CreateAliasBuffer only supports single-device memory spaces\");\n+  }\n+  auto* device = tsl::down_cast<TfrtGpuDevice*>(memory_space->devices()[0]);\n+  auto result_buffer = std::make_unique<TfrtGpuBuffer>(\n+      shape, std::move(tracked_device_buffer), this, device, memory_space);\n+\n+  xla::PjRtFulfillAliasBufferCallback fulfill_alias_buffer_cb =\n+      [buffer_promise = std::move(buffer_promise),\n+       definition_event_promise = std::move(definition_event_promise),\n+       ready_event_promise = std::move(ready_event_promise)](\n+          absl::StatusOr<xla::PjRtBuffer*> buffer_or) -> absl::Status {\n+    if (!buffer_or.ok()) {\n+      definition_event_promise->SetError(buffer_or.status());\n+      ready_event_promise->SetError(buffer_or.status());\n+      buffer_promise->SetError(buffer_or.status());\n+      return buffer_or.status();\n+    }\n+    auto* tfrt_buffer = tsl::down_cast<xla::TfrtGpuBuffer*>(*buffer_or);\n+    if (tfrt_buffer == nullptr) {\n+      auto status = absl::InternalError(\"Failed to cast to TfrtGpuBuffer\");\n+      definition_event_promise->SetError(status);\n+      ready_event_promise->SetError(status);\n+      buffer_promise->SetError(status);\n+      return status;\n+    }\n+    {\n+      absl::MutexLock lock(tfrt_buffer->mu_);\n+      xla::TrackedGpuDeviceBuffer* tracked_gpu_buffer =\n+          tfrt_buffer->tracked_device_buffer_.get();\n+      buffer_promise->ForwardTo(tracked_gpu_buffer->buffer().CopyRCRef());\n+      definition_event_promise->ForwardTo(\n+          tracked_gpu_buffer->definition_event().CopyRCRef());\n+      ready_event_promise->ForwardTo(\n+          tracked_gpu_buffer->ready_event().CopyRCRef());\n+    }\n+\n+    return absl::OkStatus();\n+  };\n+\n+  return std::make_pair(std::move(result_buffer),\n+                        std::move(fulfill_alias_buffer_cb));\n+}\n+\n absl::StatusOr<std::unique_ptr<PjRtExecutable>>\n TfrtGpuClient::BuildPjRtExecutable(\n     std::optional<HloModuleProto> unoptimized_hlo_module_proto,"
        },
        {
            "sha": "2f6ff3d083447b2383cabc9ee9a71b28bf3cbf3c",
            "filename": "third_party/xla/xla/pjrt/gpu/tfrt/tfrt_gpu_client.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client.h?ref=7ce063a96bdff5e1319566d6e41a307d41ac76a7",
            "patch": "@@ -200,6 +200,10 @@ class TfrtGpuClient final : public PjRtClient {\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n       const Shape& shape, PjRtMemorySpace* memory_space) override;\n \n+  absl::StatusOr<\n+      std::pair<std::unique_ptr<PjRtBuffer>, PjRtFulfillAliasBufferCallback>>\n+  CreateAliasBuffer(const Shape& shape, PjRtMemorySpace* memory_space) override;\n+\n   absl::StatusOr<std::unique_ptr<PjRtExecutable>> DeserializeExecutable(\n       absl::string_view serialized,\n       std::optional<CompileOptions> options) override;"
        },
        {
            "sha": "6c76fb58b12a819a89835cd6610c796cc55d93f4",
            "filename": "third_party/xla/xla/pjrt/gpu/tfrt/tfrt_gpu_client_test.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7ce063a96bdff5e1319566d6e41a307d41ac76a7/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fgpu%2Ftfrt%2Ftfrt_gpu_client_test.cc?ref=7ce063a96bdff5e1319566d6e41a307d41ac76a7",
            "patch": "@@ -1881,5 +1881,64 @@ TEST(TfrtGpuClientTest, HostExecuteRuntimeTest) {\n                                      *result_literal));\n }\n \n+TEST(TfrtGpuClientTest, CreateAliasBuffer) {\n+  TF_ASSERT_OK_AND_ASSIGN(auto client, GetTfrtGpuClient(GpuClientOptions()));\n+\n+  std::vector<int32_t> data{1, 2, 3, 4, 5, 6};\n+  Shape shape = ShapeUtil::MakeShape(S32, {2, 3});\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto alias_buffer,\n+      client->CreateAliasBuffer(shape, client->memory_spaces()[0]));\n+\n+  // Create a buffer from host data.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      auto param,\n+      client->BufferFromHostBuffer(\n+          data.data(), shape.element_type(), shape.dimensions(),\n+          /*byte_strides=*/std::nullopt,\n+          PjRtClient::HostBufferSemantics::kImmutableOnlyDuringCall, nullptr,\n+          client->memory_spaces()[0], /*device_layout=*/nullptr));\n+\n+  // Define a simple \"add one\" kernel in StableHLO MLIR.\n+  constexpr char kAddOneMlir[] = R\"(\n+    module @jit_add_one attributes {stablehlo.num_partitions = 1 : i32, stablehlo.num_replicas = 1 : i32} {\n+      func.func @main(%arg0: tensor<2x3xi32>) -> tensor<2x3xi32> {\n+        %0 = stablehlo.constant dense<1> : tensor<i32>\n+        %1 = stablehlo.broadcast_in_dim %0, dims = [] : (tensor<i32>) -> tensor<2x3xi32>\n+        %2 = stablehlo.add %arg0, %1 : tensor<2x3xi32>\n+        return %2 : tensor<2x3xi32>\n+      }\n+    })\";\n+\n+  mlir::MLIRContext context;\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          xla::ParseMlirModuleString(kAddOneMlir, context));\n+\n+  // Compile and load the executable.\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtLoadedExecutable> executable,\n+                          client->CompileAndLoad(*module, CompileOptions()));\n+\n+  // Execute the kernel.\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      std::vector<std::vector<std::unique_ptr<PjRtBuffer>>> results,\n+      executable->Execute({{param.get()}}, ExecuteOptions()));\n+  ASSERT_EQ(results.size(), 1);\n+  ASSERT_EQ(results[0].size(), 1);\n+  std::unique_ptr<PjRtBuffer>& result_buffer = results[0][0];\n+\n+  // Wait for the result buffer to be ready.\n+  TF_ASSERT_OK(result_buffer->GetReadyFuture().Await());\n+\n+  // Fulfill the alias buffer with the result of the add one kernel.\n+  ASSERT_NE(alias_buffer.second, nullptr);\n+  TF_ASSERT_OK(std::move(alias_buffer.second)(result_buffer.get()));\n+  TF_ASSERT_OK_AND_ASSIGN(auto alias_literal,\n+                          alias_buffer.first->ToLiteralSync());\n+\n+  // Expected result: data + 1\n+  EXPECT_TRUE(LiteralTestUtil::Equal(\n+      LiteralUtil::CreateR2<int32_t>({{2, 3, 4}, {5, 6, 7}}), *alias_literal));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 134,
        "additions": 125,
        "deletions": 9
    }
}