{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Do not use executor is detached future is unused\n\n+ use `ptr` when using `AsPtr()` for consistency\n+ rename `Wrap` to `AndThen` as it's more meaningful and makes profiles readable\n\nPiperOrigin-RevId: 823476695",
    "sha": "a5fca6a9b579165421c4bd395847c3c02e8dc393",
    "files": [
        {
            "sha": "f6872f3ea815fce46a4db39e6cfd54e342b178b4",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5fca6a9b579165421c4bd395847c3c02e8dc393/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5fca6a9b579165421c4bd395847c3c02e8dc393/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=a5fca6a9b579165421c4bd395847c3c02e8dc393",
            "patch": "@@ -152,6 +152,7 @@ cc_library(\n         \"//xla/tsl/platform:logging\",\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/base:no_destructor\",\n+        \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/meta:type_traits\","
        },
        {
            "sha": "66ac26d0cf22cb4e67f86245c1399d6cabca2545",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 32,
            "deletions": 15,
            "changes": 47,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5fca6a9b579165421c4bd395847c3c02e8dc393/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5fca6a9b579165421c4bd395847c3c02e8dc393/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=a5fca6a9b579165421c4bd395847c3c02e8dc393",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"absl/base/attributes.h\"\n #include \"absl/base/no_destructor.h\"\n #include \"absl/base/optimization.h\"\n+#include \"absl/functional/bind_front.h\"\n #include \"absl/meta/type_traits.h\"\n #include \"absl/status/status.h\"\n #include \"absl/types/span.h\"\n@@ -368,15 +369,15 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   template <typename F, OnReadyFunctor<F>* = nullptr>\n   ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(F&& f) const& {\n     CHECK(IsValid());\n-    promise_.AndThen(Wrap(std::forward<F>(f)));\n+    promise_.AndThen(AndThen(std::forward<F>(f)));\n   }\n \n   // Registers callback to be called once the promise is ready, with the final\n   // value. Callback will be invoked on a user-specified executor.\n   template <typename F, OnReadyFunctor<F>* = nullptr>\n   ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(Executor& executor, F&& f) const& {\n     CHECK(IsValid());\n-    promise_.AndThen(executor, Wrap(std::forward<F>(f)));\n+    promise_.AndThen(executor, AndThen(std::forward<F>(f)));\n   }\n \n   // Registers callback to be called once the promise is ready, with the final\n@@ -385,7 +386,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   template <typename F, OnReadyFunctor<F, true>* = nullptr>\n   ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(F&& f) && {\n     CHECK(IsValid());\n-    promise_.AndThen(std::move(*this).Wrap(std::forward<F>(f)));\n+    promise_.AndThen(std::move(*this).AndThen(std::forward<F>(f)));\n     promise_.reset();\n   }\n \n@@ -394,7 +395,7 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n   template <typename F, OnReadyFunctor<F, true>* = nullptr>\n   ABSL_ATTRIBUTE_ALWAYS_INLINE void OnReady(Executor& executor, F&& f) && {\n     CHECK(IsValid());\n-    promise_.AndThen(executor, std::move(*this).Wrap(std::forward<F>(f)));\n+    promise_.AndThen(executor, std::move(*this).AndThen(std::forward<F>(f)));\n     promise_.reset();\n   }\n \n@@ -415,23 +416,23 @@ class FutureBase : public FutureMoveControl<is_move_only> {\n \n   // Wraps a callback into a functor compatible with AsyncValue::AndThen.\n   template <typename F>\n-  auto Wrap(F&& f) const& {\n-    return [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n-      f(*promise);\n+  auto AndThen(F&& f) const& {\n+    return [ptr = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n+      std::move(f)(*ptr);\n     };\n   }\n \n   // Wraps a callback into a functor compatible with AsyncValue::AndThen.\n   template <typename F>\n-  auto Wrap(F&& f) && {\n-    return [promise = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n+  auto AndThen(F&& f) && {\n+    return [ptr = promise_.AsPtr(), f = std::forward<F>(f)]() mutable {\n       if constexpr (is_move_only) {\n-        f(std::move(*promise));\n+        std::move(f)(std::move(*ptr));\n       } else {\n         // We can't move from the promise to the caller because for copyable\n         // futures we can have multiple copies of the Future sharing the\n         // same underlying promise object.\n-        f(*promise);\n+        std::move(f)(*ptr);\n       }\n     };\n   }\n@@ -1151,8 +1152,16 @@ Future<future_type_t<T>> FutureBase<T, is_move_only>::Detach(\n   }\n \n   RCReference<IndirectAsyncValue> detached = MakeIndirectAsyncValue<T>();\n-  promise_.AndThen(executor, [detached, ptr = promise_.AsPtr()] {\n-    detached->ForwardTo(ptr.CopyRCRef());\n+  promise_.AndThen([&executor, detached, ptr = promise_.AsPtr()] {\n+    // If we hold the last reference to the detached promise, then we can safely\n+    // forward it to the available value without using an executor, as we know\n+    // that it will not execute any callbacks in the caller thread.\n+    if (ABSL_PREDICT_FALSE(detached->NumRef() == 1 && !detached->HasWaiter())) {\n+      detached->ForwardTo(ptr.CopyRCRef());\n+    } else {\n+      executor.Execute(absl::bind_front(&IndirectAsyncValue::ForwardTo,\n+                                        std::move(detached), ptr.CopyRCRef()));\n+    }\n   });\n   return Future<future_type_t<T>>(AsyncValueRef<T>(std::move(detached)),\n                                   on_block_start_, on_block_end_);\n@@ -1169,8 +1178,16 @@ Future<future_type_t<T>> FutureBase<T, is_move_only>::Detach(\n \n   AsyncValuePtr<T> ptr = promise_.AsPtr();\n   RCReference<IndirectAsyncValue> detached = MakeIndirectAsyncValue<T>();\n-  ptr.AndThen(executor, [detached, ref = std::move(promise_)]() mutable {\n-    detached->ForwardTo(ref.ReleaseRCRef());\n+  ptr.AndThen([&executor, detached, ref = std::move(promise_)]() mutable {\n+    // If we hold the last reference to the detached promise, then we can safely\n+    // forward it to the available value without using an executor, as we know\n+    // that it will not execute any callbacks in the caller thread.\n+    if (ABSL_PREDICT_FALSE(detached->NumRef() == 1 && !detached->HasWaiter())) {\n+      detached->ForwardTo(std::move(ref));\n+    } else {\n+      executor.Execute(absl::bind_front(&IndirectAsyncValue::ForwardTo,\n+                                        std::move(detached), std::move(ref)));\n+    }\n   });\n   return Future<future_type_t<T>>(AsyncValueRef<T>(std::move(detached)),\n                                   std::move(on_block_start_),"
        },
        {
            "sha": "bd6ff8d555d1199e2194ae55d28ca0f38aabd51d",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 1,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a5fca6a9b579165421c4bd395847c3c02e8dc393/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a5fca6a9b579165421c4bd395847c3c02e8dc393/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=a5fca6a9b579165421c4bd395847c3c02e8dc393",
            "patch": "@@ -642,7 +642,7 @@ TEST(FutureTest, DetachMoveOnly) {\n   EXPECT_EQ(executor.num_tasks, 1);\n };\n \n-TEST(DetachFutureTest, DetachOnThreadPool) {\n+TEST(FutureTest, DetachOnThreadPool) {\n   // We use static thread local counter to make sure that all callbacks are\n   // executed on a thread inside the thread pool.\n   static thread_local int32_t counter = 0;\n@@ -676,6 +676,24 @@ TEST(DetachFutureTest, DetachOnThreadPool) {\n   EXPECT_EQ(counter, 0);\n }\n \n+TEST(FutureTest, NoOpDetachDoesNotExecute) {\n+  auto [promise, future] = Future<>::MakePromise();\n+\n+  CountingExecutor executor;\n+  (void)future.Detach(executor);\n+  promise.Set(absl::OkStatus());\n+  EXPECT_EQ(executor.num_tasks, 0);\n+}\n+\n+TEST(FutureTest, NoOpMoveOnlyDetachDoesNotExecute) {\n+  auto [promise, future] = Future<std::unique_ptr<int32_t>>::MakePromise();\n+\n+  CountingExecutor executor;\n+  (void)std::move(future).Detach(executor);\n+  promise.Set(std::make_unique<int32_t>(42));\n+  EXPECT_EQ(executor.num_tasks, 0);\n+}\n+\n TEST(FutureTest, MapOnExecutorDoesNotCopy) {\n   thread::ThreadPool thread_pool(Env::Default(), \"test\", 4);\n   Executor* executor = thread_pool.AsExecutor();"
        }
    ],
    "stats": {
        "total": 68,
        "additions": 52,
        "deletions": 16
    }
}