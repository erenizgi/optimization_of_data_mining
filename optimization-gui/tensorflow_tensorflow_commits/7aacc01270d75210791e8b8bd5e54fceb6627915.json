{
    "author": "tensorflower-gardener",
    "message": "Replace a chain of xpose/reshape to a nop if the composite transpose permutation is idendity\n\nPiperOrigin-RevId: 818461965",
    "sha": "7aacc01270d75210791e8b8bd5e54fceb6627915",
    "files": [
        {
            "sha": "58819862162ab26473eb192304ffe48d7ca1f136",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.cc",
            "status": "modified",
            "additions": 112,
            "deletions": 0,
            "changes": 112,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7aacc01270d75210791e8b8bd5e54fceb6627915/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7aacc01270d75210791e8b8bd5e54fceb6627915/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.cc?ref=7aacc01270d75210791e8b8bd5e54fceb6627915",
            "patch": "@@ -6142,6 +6142,112 @@ absl::Status AlgebraicSimplifierVisitor::HandleRemainder(\n   return absl::OkStatus();\n }\n \n+absl::StatusOr<bool>\n+AlgebraicSimplifierVisitor::TryRemovingReshapeTransposeChain(\n+    HloInstruction* reshape) {\n+  // Detect a chain of transposes and reshapes that can be replaced with a\n+  // nop. All reshapes only add, remove or shuffle degenerate dimensions, such\n+  // as [x,y,z]->[x,y,1,z] or its reverse, [x,y,1,z]->[x,1,y,z], etc. And all\n+  // the shapes in the chain have at most one degenerate dimension. Then all\n+  // the transposes in the chain effectively permute x,y,z, while the\n+  // degenerate dimension is ignored. As long as all transposes compose to\n+  // identity permutation, the chain can be replaced with a nop if the\n+  // starting shape and ending shape match. This is done before layout\n+  // assignment so layout is completely ignored.\n+\n+  auto get_num_of_degenerate_dimensions = [](const Shape& shape) {\n+    return std::accumulate(shape.dimensions().begin(), shape.dimensions().end(),\n+                           0, [](int64_t count, int64_t element) {\n+                             return count + (element == 1 ? 1 : 0);\n+                           });\n+  };\n+\n+  auto is_valid_reshape = [&](const HloInstruction* reshape) {\n+    CHECK(reshape->opcode() == HloOpcode::kReshape);\n+    return get_num_of_degenerate_dimensions(reshape->shape()) <= 1 &&\n+           get_num_of_degenerate_dimensions(reshape->operand(0)->shape()) <=\n+               1 &&\n+           reshape->ReshapeMerelyInsertsOrDeletes1SizedDimensions();\n+  };\n+\n+  auto get_degenerate_dimension = [](const Shape& shape) {\n+    for (int64_t i = 0; i < shape.dimensions().size(); ++i) {\n+      if (shape.dimensions(i) == 1) {\n+        return i;\n+      }\n+    }\n+    return int64_t{-1};\n+  };\n+\n+  // Returns the effective permutation of the transpose. The degenerate\n+  // dimension is ignored.\n+  auto get_effective_permutation =\n+      [&](absl::Span<const int64_t> permutation, const Shape& from_shape,\n+          const Shape& to_shape) -> DimensionVector {\n+    CHECK_EQ(from_shape.dimensions().size(), permutation.size());\n+    CHECK_EQ(to_shape.dimensions().size(), permutation.size());\n+    if (get_num_of_degenerate_dimensions(from_shape) == 1) {\n+      int64_t degenerate_dimension = get_degenerate_dimension(from_shape);\n+      DimensionVector new_permutation;\n+      new_permutation.reserve(permutation.size() - 1);\n+      for (int64_t i = 0; i < permutation.size(); ++i) {\n+        if (permutation[i] == degenerate_dimension) {\n+          CHECK_EQ(to_shape.dimensions(i), 1);\n+          // Skip degenerate dimension.\n+          continue;\n+        }\n+        if (permutation[i] > degenerate_dimension) {\n+          new_permutation.push_back(permutation[i] - 1);\n+        } else {\n+          new_permutation.push_back(permutation[i]);\n+        }\n+      }\n+      return new_permutation;\n+    }\n+\n+    // The shapes should have no degenerate dimension.\n+    return DimensionVector(permutation.begin(), permutation.end());\n+  };\n+\n+  if (!options_.is_layout_sensitive() && is_valid_reshape(reshape)) {\n+    int64_t effective_size = ShapeUtil::TrueNumDimensions(reshape->shape());\n+    std::vector<int64_t> permutation(effective_size);\n+    // Init with identity permutation.\n+    std::iota(permutation.begin(), permutation.end(), 0);\n+\n+    bool is_nop = true;\n+    HloInstruction* starting_instruction = nullptr;\n+    HloInstruction* current = reshape->mutable_operand(0);\n+    while (current->opcode() == HloOpcode::kReshape ||\n+           current->opcode() == HloOpcode::kTranspose) {\n+      if (current->opcode() == HloOpcode::kReshape &&\n+          !is_valid_reshape(current)) {\n+        is_nop = false;\n+        break;\n+      }\n+      if (current->opcode() == HloOpcode::kTranspose) {\n+        permutation = ComposePermutations(\n+            get_effective_permutation(current->dimensions(),\n+                                      current->operand(0)->shape(),\n+                                      current->shape()),\n+            permutation);\n+      }\n+      starting_instruction = current;\n+      current = current->mutable_operand(0);\n+    }\n+    if (is_nop && starting_instruction != nullptr &&\n+        Shape::Equal().IgnoreLayout()(\n+            reshape->shape(), starting_instruction->operand(0)->shape()) &&\n+        IsIdentityPermutation(permutation)) {\n+      VLOG(2) << \"Deleting reshape-transpose chain: \" << reshape->ToString();\n+      TF_RETURN_IF_ERROR(ReplaceInstruction(\n+          reshape, starting_instruction->mutable_operand(0)));\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n absl::Status AlgebraicSimplifierVisitor::HandleReshape(\n     HloInstruction* reshape) {\n   auto operand = reshape->mutable_operand(0);\n@@ -6179,6 +6285,12 @@ absl::Status AlgebraicSimplifierVisitor::HandleReshape(\n     return ReplaceInstruction(reshape, operand);\n   }\n \n+  TF_ASSIGN_OR_RETURN(bool reshape_transpose_chain_removed,\n+                      TryRemovingReshapeTransposeChain(reshape));\n+  if (reshape_transpose_chain_removed) {\n+    return absl::OkStatus();\n+  }\n+\n   if (options_.is_layout_sensitive()) {\n     // Try to reorder copy-reshape to reshape-copy.\n     HloInstruction* copy_before = nullptr;"
        },
        {
            "sha": "4d688d39eb8df654c3726078e1d827b81cbaac9a",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7aacc01270d75210791e8b8bd5e54fceb6627915/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7aacc01270d75210791e8b8bd5e54fceb6627915/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier.h?ref=7aacc01270d75210791e8b8bd5e54fceb6627915",
            "patch": "@@ -845,6 +845,11 @@ class AlgebraicSimplifierVisitor : public DfsHloRewriteVisitor {\n                                         bool multi_output_reduce,\n                                         HloReduceInstruction* reduce);\n \n+  // Detects a chain of transposes and reshapes that can be replaced with a\n+  // nop.\n+  absl::StatusOr<bool> TryRemovingReshapeTransposeChain(\n+      HloInstruction* reshape);\n+\n   // Helper function for HandleReduce. Reorders reduce dot\n   // to a dot reduce. reduce(dot(A, B)) to dot(A, reduce(B))\n   std::optional<absl::Status> ReorderReduceDotToDotReduce("
        },
        {
            "sha": "262d648346bc53d1c5c235d923177f38531bbc68",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/algebraic_simplifier_test.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/7aacc01270d75210791e8b8bd5e54fceb6627915/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/7aacc01270d75210791e8b8bd5e54fceb6627915/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Falgebraic_simplifier_test.cc?ref=7aacc01270d75210791e8b8bd5e54fceb6627915",
            "patch": "@@ -327,6 +327,43 @@ TEST_F(AlgebraicSimplifierTest, FactorFpAddition) {\n                   m::ConstantScalar(0.125))));\n }\n \n+// Reshape-transpose chain is eliminated since effective transposes\n+// compose to identity permutation.\n+TEST_F(AlgebraicSimplifierTest, EliminateReshapeTransposeChain) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+    HloModule m\n+    test {\n+       %param = f32[224,4,1,4096] parameter(0)\n+  %transpose.7800 = f32[224,4096,4,1] transpose(%param), dimensions={0,3,1,2}\n+  %reshape.96335 = f32[224,4096,4] reshape(%transpose.7800)\n+  %transpose.8665 = f32[224,4,4096] transpose(%reshape.96335), dimensions={0,2,1}\n+  ROOT %reshape.96336 = f32[224,4,1,4096] reshape(%transpose.8665)\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  AlgebraicSimplifier(default_options_).Run(m.get()).value();\n+  VLOG(2) << \"Module after: \" << m->ToString();\n+  EXPECT_THAT(m->entry_computation()->root_instruction(),\n+              GmockMatch(m::Parameter(0)));\n+}\n+\n+// Reshape-transpose chain is not eliminated since effective transposes\n+// do not compose to identity permutation.\n+TEST_F(AlgebraicSimplifierTest, NotEliminateReshapeTransposeChain) {\n+  constexpr absl::string_view kModuleStr = R\"(\n+    HloModule m\n+    test {\n+      %param = f32[4,4,1,4] parameter(0)\n+      %transpose.7800 = f32[4,4,4,1] transpose(%param), dimensions={1,0,3,2}\n+      %reshape.96335 = f32[4,4,4] reshape(%transpose.7800)\n+      %transpose.8665 = f32[4,4,4] transpose(%reshape.96335), dimensions={0,2,1}\n+      ROOT %reshape.96336 = f32[4,4,1,4] reshape(%transpose.8665)\n+    }\n+  )\";\n+  TF_ASSERT_OK_AND_ASSIGN(auto m, ParseAndReturnVerifiedModule(kModuleStr));\n+  EXPECT_FALSE(AlgebraicSimplifier(default_options_).Run(m.get()).value());\n+}\n+\n // (Abs(A)) * (Abs(A)) => (A*A)\n TEST_F(AlgebraicSimplifierTest, SquareOfAbs) {\n   constexpr absl::string_view kModuleStr = R\"("
        }
    ],
    "stats": {
        "total": 154,
        "additions": 154,
        "deletions": 0
    }
}