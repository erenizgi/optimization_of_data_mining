{
    "author": "pschuh",
    "message": "Remove overload of CreateUninitializedBuffer for GPU.\n\nPiperOrigin-RevId: 812071987",
    "sha": "ec0829c5136f2b2d35598572d5dc5a303f35fd9b",
    "files": [
        {
            "sha": "b7f017f196aefbe8c11f1cce9da59d08b80096b2",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ec0829c5136f2b2d35598572d5dc5a303f35fd9b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ec0829c5136f2b2d35598572d5dc5a303f35fd9b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=ec0829c5136f2b2d35598572d5dc5a303f35fd9b",
            "patch": "@@ -1090,40 +1090,6 @@ PjRtStreamExecutorClient::LinearizeHostBufferInto(\n   return definition_event;\n }\n \n-absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-PjRtStreamExecutorClient::CreateUninitializedBuffer(\n-    const Shape& shape, PjRtMemorySpace* memory_space) {\n-  return CreateUninitializedBuffer(shape, memory_space, nullptr);\n-}\n-\n-absl::StatusOr<std::unique_ptr<PjRtBuffer>>\n-PjRtStreamExecutorClient::CreateUninitializedBuffer(\n-    const Shape& shape, PjRtMemorySpace* memory_space,\n-    BufferSequencingEventRef definition_event) {\n-  tsl::profiler::TraceMe traceme(\n-      \"PjRtStreamExecutorClient::CreateUninitializedBuffer\");\n-  VLOG(1) << \"PjRtStreamExecutorClient::CreateUninitializedBuffer: shape: \"\n-          << shape.ToString()\n-          << \" memory_space: \" << memory_space->DebugString();\n-  CHECK_EQ(memory_space->devices().size(), 1);\n-  PjRtDevice* device = memory_space->devices().front();\n-  TF_ASSIGN_OR_RETURN(LocalDeviceState * local_device,\n-                      tensorflow::down_cast<PjRtStreamExecutorDevice*>(device)\n-                          ->GetLocalDeviceState());\n-\n-  TransferManager* transfer_manager = client()->backend().transfer_manager();\n-  TF_ASSIGN_OR_RETURN(Shape compact_shape,\n-                      transfer_manager->ChooseCompactLayoutForShape(shape));\n-\n-  TF_ASSIGN_OR_RETURN(\n-      std::unique_ptr<PjRtStreamExecutorBuffer> py_buffer,\n-      AllocateDestinationBuffer(compact_shape, device, local_device,\n-                                /*copy_stream=*/nullptr,\n-                                /*is_uninitialized_create=*/true, this,\n-                                definition_event));\n-  return std::unique_ptr<PjRtBuffer>(std::move(py_buffer));\n-}\n-\n tsl::RCReference<PjRtDeviceEvent>\n PjRtStreamExecutorClient::CreateErrorDeviceEvent(absl::Status error) {\n   auto definition_event = BufferSequencingEvent::Create(this->thread_pool());"
        },
        {
            "sha": "9851616b6862f1681e6bffa44c3297b7d64bc26b",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.h",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ec0829c5136f2b2d35598572d5dc5a303f35fd9b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ec0829c5136f2b2d35598572d5dc5a303f35fd9b/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.h?ref=ec0829c5136f2b2d35598572d5dc5a303f35fd9b",
            "patch": "@@ -317,17 +317,6 @@ class PjRtStreamExecutorClient : public CommonPjRtClient {\n   absl::StatusOr<std::unique_ptr<HloCostAnalysis>> GetHloCostAnalysis()\n       const override;\n \n-  // Creates a buffer on the device without initializing or copying any data.\n-  // An optional `definition_event` may be speficied that can be used to\n-  // ensure the buffer isn't referenced until some external mechanism has\n-  // initialized the data.\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n-      const Shape& shape, PjRtMemorySpace* memory_space) override;\n-  using PjRtClient::CreateUninitializedBuffer;\n-  absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateUninitializedBuffer(\n-      const Shape& shape, PjRtMemorySpace* memory_space,\n-      BufferSequencingEventRef definition_event);\n-\n   absl::StatusOr<std::unique_ptr<PjRtBuffer>> CreateErrorBuffer(\n       absl::Status error, const Shape& shape, PjRtMemorySpace* memory) override;\n "
        },
        {
            "sha": "c31e55fe4cdfde4d2b8bf6c0073810441d942b86",
            "filename": "third_party/xla/xla/pjrt/se_raw_buffer.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ec0829c5136f2b2d35598572d5dc5a303f35fd9b/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ec0829c5136f2b2d35598572d5dc5a303f35fd9b/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fse_raw_buffer.cc?ref=ec0829c5136f2b2d35598572d5dc5a303f35fd9b",
            "patch": "@@ -157,16 +157,21 @@ void PjRtStreamExecutorRawBuffer::CopyToLiteralAsync(\n \n absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>\n PjRtStreamExecutorRawBuffer::MakeAllocationReadyEvent() {\n+  auto* client =\n+      tensorflow::down_cast<PjRtStreamExecutorClient*>(memory_space_->client());\n+  auto result = BufferSequencingEvent::Create(client->thread_pool());\n   if (local_device_->allocation_model() ==\n       LocalDeviceState::kComputeSynchronized) {\n-    auto* client = tensorflow::down_cast<PjRtStreamExecutorClient*>(\n-        memory_space_->client());\n-    auto result = BufferSequencingEvent::Create(client->thread_pool());\n     TF_RETURN_IF_ERROR(client->AllocateAndRecordEvent(\n         result, local_device_, local_device_->compute_stream()));\n-    return tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(std::move(result));\n+  } else {\n+    auto stream = local_device_->BorrowStreamFromPool();\n+    auto status =\n+        client->AllocateAndRecordEvent(result, local_device_, stream.get());\n+    local_device_->ReturnStreamToPool(std::move(stream));\n+    TF_RETURN_IF_ERROR(status);\n   }\n-  return absl::UnimplementedError(\"Cannot make ready event\");\n+  return tsl::MakeRef<PjRtStreamExecutorDeviceEvent>(std::move(result));\n }\n \n void PjRtStreamExecutorRawBuffer::CopyTo("
        }
    ],
    "stats": {
        "total": 60,
        "additions": 10,
        "deletions": 50
    }
}