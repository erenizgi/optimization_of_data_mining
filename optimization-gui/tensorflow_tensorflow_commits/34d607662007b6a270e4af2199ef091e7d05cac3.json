{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 828881457",
    "sha": "34d607662007b6a270e4af2199ef091e7d05cac3",
    "files": [
        {
            "sha": "e17c88971cc0c210d63e81a5a1498e50f3a96765",
            "filename": "tensorflow/core/grappler/clusters/cluster.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fcluster.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fcluster.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fcluster.cc?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -48,7 +48,7 @@ void Cluster::SetNumWarmupSteps(int num_steps) {\n }\n \n // Set executor type to instantiate\n-void Cluster::SetExecutorType(const string* executor_type) {\n+void Cluster::SetExecutorType(const std::string* executor_type) {\n   options_.config.mutable_experimental()->set_executor_type(*executor_type);\n }\n \n@@ -100,8 +100,8 @@ void Cluster::DisableOptimizer(bool disable) {\n   }\n }\n \n-const std::vector<string> Cluster::GetDeviceNames() const {\n-  std::vector<string> device_names;\n+const std::vector<std::string> Cluster::GetDeviceNames() const {\n+  std::vector<std::string> device_names;\n   device_names.reserve(devices_.size());\n   for (const auto& device : devices_) {\n     device_names.push_back(device.first);"
        },
        {
            "sha": "d2662424d5ab2f4a87d147d3488445928101908d",
            "filename": "tensorflow/core/grappler/clusters/cluster.h",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fcluster.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fcluster.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fcluster.h?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -44,7 +44,7 @@ class Cluster {\n   virtual ~Cluster();\n \n   // Returns a string that represent the type of cluster that was instantiated.\n-  virtual string type() const = 0;\n+  virtual std::string type() const = 0;\n \n   // Provision the hardware resources needed to run TensorFlow and start a\n   // TensorFlow session that can take advantage of these resources.\n@@ -76,7 +76,7 @@ class Cluster {\n   void SetNumWarmupSteps(int num_steps);\n \n   // Set executor type to instantiate\n-  void SetExecutorType(const string* executor_type);\n+  void SetExecutorType(const std::string* executor_type);\n \n   // Returns the number of warmup steps.\n   int NumWarmupSteps() const;\n@@ -94,13 +94,13 @@ class Cluster {\n \n   // Return the list of TensorFlow devices that are available to execute a\n   // graph. This is empty until provision() is called.\n-  const std::unordered_map<string, DeviceProperties>& GetDevices() const {\n+  const std::unordered_map<std::string, DeviceProperties>& GetDevices() const {\n     return devices_;\n   }\n \n   // Convenience method that returns the set of device names. These names are\n   // sorted alphabetically.\n-  const std::vector<string> GetDeviceNames() const;\n+  const std::vector<std::string> GetDeviceNames() const;\n \n   // The DeviceSet is not always available, but when it is it contains a\n   // superset of the devices listed in GetDevices/GetDeviceNames().\n@@ -116,7 +116,7 @@ class Cluster {\n   // Returns peak memory of all devices during the session creation and session\n   // runs.\n   virtual absl::Status GetPeakMemoryUsage(\n-      std::unordered_map<string, uint64>* device_peak_memory) const {\n+      std::unordered_map<std::string, uint64_t>* device_peak_memory) const {\n     return absl::UnimplementedError(\n         \"GetPeakMemoryUsage is not implemented for this type of cluster.\");\n   }\n@@ -126,18 +126,18 @@ class Cluster {\n   virtual absl::Status Initialize(const GrapplerItem& item) = 0;\n \n   // Run the specified graph_def and return the corresponding metadata.\n-  virtual absl::Status Run(const GraphDef& graph_def,\n-                           const std::vector<std::pair<string, Tensor>>& feed,\n-                           const std::vector<string>& fetch,\n-                           RunMetadata* metadata) = 0;\n+  virtual absl::Status Run(\n+      const GraphDef& graph_def,\n+      const std::vector<std::pair<std::string, Tensor>>& feed,\n+      const std::vector<std::string>& fetch, RunMetadata* metadata) = 0;\n \n   // Run the specified GrapplerItem and return the corresponding metadata.\n   virtual absl::Status Run(const GrapplerItem& item, RunMetadata* metadata) {\n     return Run(item.graph, item.feed, item.fetch, metadata);\n   }\n \n  protected:\n-  std::unordered_map<string, DeviceProperties> devices_;\n+  std::unordered_map<std::string, DeviceProperties> devices_;\n   const int timeout_s_;\n   SessionOptions options_;\n   RunOptions run_options_;"
        },
        {
            "sha": "de16db2cbdea31e636c7dd2d8be205fb100fc7ac",
            "filename": "tensorflow/core/grappler/clusters/single_machine.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine.cc?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -119,7 +119,7 @@ absl::Status SingleMachine::Provision() {\n                          \": \", s.message()));\n       }\n       attr = GetLocalGPUInfo(platform_device_id);\n-    } else if (dev.device_type().find(\"XLA\") == string::npos) {\n+    } else if (dev.device_type().find(\"XLA\") == std::string::npos) {\n       // Filter out the fake XLA devices to avoid double counting the actual\n       // hardware resources that are available.\n       attr.set_type(dev.device_type());\n@@ -162,8 +162,8 @@ absl::Status SingleMachine::Shutdown() {\n \n absl::Status SingleMachine::Run(\n     const GraphDef& graph_def,\n-    const std::vector<std::pair<string, Tensor>>& feed,\n-    const std::vector<string>& fetch, RunMetadata* metadata) {\n+    const std::vector<std::pair<std::string, Tensor>>& feed,\n+    const std::vector<std::string>& fetch, RunMetadata* metadata) {\n   mutex_lock l(this->last_graph_mu_);\n   if (last_graph_ != &graph_def) {\n     TF_RETURN_IF_ERROR(ResetSession());\n@@ -229,7 +229,7 @@ absl::Status SingleMachine::EnablePeakMemoryStats() {\n }\n \n absl::Status SingleMachine::GetPeakMemoryUsage(\n-    std::unordered_map<string, uint64>* device_peak_memory) const {\n+    std::unordered_map<std::string, uint64_t>* device_peak_memory) const {\n   // Cpu_allocator->TracksAllocationSizes() returns true doesn't always mean the\n   // the AllocatorStats would be collected.\n   if (!cpu_allocator_stats_enabled_) {\n@@ -257,14 +257,14 @@ absl::Status SingleMachine::GetPeakMemoryUsage(\n }\n \n absl::Status SingleMachine::RunWithTimeout(\n-    const std::vector<std::pair<string, Tensor>>& feed,\n-    const std::vector<string>& fetch, RunMetadata* run_metadata) {\n+    const std::vector<std::pair<std::string, Tensor>>& feed,\n+    const std::vector<std::string>& fetch, RunMetadata* run_metadata) {\n   return RunWithTimeout(feed, fetch, run_metadata, timeout_s_);\n }\n \n absl::Status SingleMachine::RunWithTimeout(\n-    const std::vector<std::pair<string, Tensor>>& feed,\n-    const std::vector<string>& fetch, RunMetadata* run_metadata,\n+    const std::vector<std::pair<std::string, Tensor>>& feed,\n+    const std::vector<std::string>& fetch, RunMetadata* run_metadata,\n     int64_t timeout_s) {\n   // We shouldn't be running or closing the session at this point.\n   {\n@@ -403,7 +403,7 @@ void SingleMachine::MergeCosts(CostGraphDef* graph_costs,\n   graph_costs->mutable_node()->Reserve(graph_costs->node_size() +\n                                        init_costs.node_size() +\n                                        queue_costs.node_size());\n-  std::unordered_set<string> nodes_seen;\n+  std::unordered_set<std::string> nodes_seen;\n   int queue_costs_id_offset = graph_costs->node_size();\n   for (const auto& node : graph_costs->node()) {\n     nodes_seen.insert(node.name());"
        },
        {
            "sha": "554f316a3c9c762e2fdade2249a7edee5997b2ad",
            "filename": "tensorflow/core/grappler/clusters/single_machine.h",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine.h?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -44,32 +44,32 @@ class SingleMachine : public Cluster {\n   SingleMachine(int timeout_s, int num_cpu_cores, int num_gpus);\n   ~SingleMachine() override;\n \n-  string type() const override { return \"single_machine\"; }\n+  std::string type() const override { return \"single_machine\"; }\n \n   absl::Status Provision() override;\n   absl::Status Shutdown() override;\n \n   absl::Status Initialize(const GrapplerItem& item) override;\n   absl::Status Run(const GraphDef& item,\n-                   const std::vector<std::pair<string, Tensor>>& feed,\n-                   const std::vector<string>& fetch,\n+                   const std::vector<std::pair<std::string, Tensor>>& feed,\n+                   const std::vector<std::string>& fetch,\n                    RunMetadata* metadata) override;\n \n   const DeviceSet* GetDeviceSet() const override { return device_set_.get(); }\n \n   absl::Status EnablePeakMemoryStats() override;\n \n   // It requires EnableAllocatorStats(true) be called before Provision().\n-  absl::Status GetPeakMemoryUsage(\n-      std::unordered_map<string, uint64>* device_peak_memory) const override;\n+  absl::Status GetPeakMemoryUsage(std::unordered_map<std::string, uint64_t>*\n+                                      device_peak_memory) const override;\n \n  private:\n   absl::Status RunWithTimeout(\n-      const std::vector<std::pair<string, Tensor>>& feed,\n-      const std::vector<string>& fetch, RunMetadata* run_metadata);\n+      const std::vector<std::pair<std::string, Tensor>>& feed,\n+      const std::vector<std::string>& fetch, RunMetadata* run_metadata);\n   absl::Status RunWithTimeout(\n-      const std::vector<std::pair<string, Tensor>>& feed,\n-      const std::vector<string>& fetch, RunMetadata* run_metadata,\n+      const std::vector<std::pair<std::string, Tensor>>& feed,\n+      const std::vector<std::string>& fetch, RunMetadata* run_metadata,\n       int64_t timeout_s);\n   absl::Status ResetSession();\n   absl::Status CloseSession(bool use_timeout);\n@@ -81,10 +81,10 @@ class SingleMachine : public Cluster {\n \n   std::unique_ptr<Session> session_;\n   std::vector<QueueRunnerDef> queue_runner_defs_;\n-  string last_graph_id_;\n+  std::string last_graph_id_;\n   mutex last_graph_mu_;\n   const GraphDef* last_graph_ TF_GUARDED_BY(last_graph_mu_) = nullptr;\n-  std::vector<string> init_ops_;\n+  std::vector<std::string> init_ops_;\n   int64_t expected_init_time_s_;\n   std::unique_ptr<Coordinator> coordinator_;\n   std::unique_ptr<thread::ThreadPool> thread_pool_;"
        },
        {
            "sha": "31b3a76c595bb3e27fb7e998012de62bb1284b50",
            "filename": "tensorflow/core/grappler/clusters/single_machine_test.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 16,
            "changes": 33,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fsingle_machine_test.cc?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -93,7 +93,7 @@ TEST_F(SingleMachineTest, CostModel) {\n   for (const auto& node : metadata.cost_graph().node()) {\n     // Skip the special nodes inserted by TF: these are prefixed with an\n     // underscore.\n-    if (node.name()[0] == '_' || node.name().find(\"/_\") != string::npos) {\n+    if (node.name()[0] == '_' || node.name().find(\"/_\") != std::string::npos) {\n       continue;\n     }\n #ifndef INTEL_MKL\n@@ -140,7 +140,8 @@ TEST_F(SingleMachineTest, MultipleItems) {\n     // in the fake input, plus 1 enqueue and 1 dequeue node.\n     EXPECT_LE(6, metadata1.cost_graph().node_size());\n     for (const auto& node : metadata1.cost_graph().node()) {\n-      if (node.name()[0] == '_' || node.name().find(\"/_\") != string::npos ||\n+      if (node.name()[0] == '_' ||\n+          node.name().find(\"/_\") != std::string::npos ||\n           node.name() == \"queue\") {\n         continue;\n       }\n@@ -161,9 +162,9 @@ TEST_F(SingleMachineTest, MultipleItems) {\n       metadata2.mutable_cost_graph()->mutable_node(i)->set_compute_cost(0);\n       metadata2.clear_step_stats();\n     }\n-    string s1;\n+    std::string s1;\n     ::tensorflow::protobuf::TextFormat::PrintToString(metadata1, &s1);\n-    string s2;\n+    std::string s2;\n     ::tensorflow::protobuf::TextFormat::PrintToString(metadata2, &s2);\n     EXPECT_EQ(s1, s2);\n   }\n@@ -211,7 +212,7 @@ TEST_F(SingleMachineTest, GraphOptimizations) {\n   RunMetadata metadata;\n   TF_CHECK_OK(cluster_->Initialize(item));\n   TF_CHECK_OK(cluster_->Run(item.graph, item.feed, item.fetch, &metadata));\n-  std::set<string> cost_nodes;\n+  std::set<std::string> cost_nodes;\n   for (const auto& node : metadata.cost_graph().node()) {\n #ifdef INTEL_MKL\n     // Skip the special nodes inserted by TF (and MKL): these are either\n@@ -227,7 +228,7 @@ TEST_F(SingleMachineTest, GraphOptimizations) {\n     }\n #endif\n   }\n-  const std::set<string> expected_cost_nodes = {\n+  const std::set<std::string> expected_cost_nodes = {\n       \"zero\",      \"one\",      \"add\",         \"square\",\n       \"new_shape\", \"reshaped\", \"final_shape\", \"expected_shape\",\n       \"valid\",     \"all_dims\", \"all_valid\",   \"assert_valid\"};\n@@ -263,7 +264,7 @@ static void RunInfiniteTFLoop() {\n   shp->set_op(\"Const\");\n   (*shp->mutable_attr())[\"dtype\"].set_type(DT_INT32);\n   Tensor shp_tensor(DT_INT32, TensorShape({1}));\n-  shp_tensor.flat<int32>()(0) = 1;\n+  shp_tensor.flat<int32_t>()(0) = 1;\n   shp_tensor.AsProtoTensorContent(\n       (*shp->mutable_attr())[\"value\"].mutable_tensor());\n \n@@ -394,14 +395,14 @@ TEST_F(SingleMachineTest, InitializationMemory) {\n namespace {\n \n template <class T>\n-inline void SetNodeAttr(const string& key, const T& value, NodeDef* node) {\n+inline void SetNodeAttr(const std::string& key, const T& value, NodeDef* node) {\n   AttrValue attr_value;\n   SetAttrValue(value, &attr_value);\n   auto* attr_map = node->mutable_attr();\n   (*attr_map)[key] = attr_value;\n }\n template <>\n-inline void SetNodeAttr(const string& key, const Tensor& tensor,\n+inline void SetNodeAttr(const std::string& key, const Tensor& tensor,\n                         NodeDef* node) {\n   TensorProto tensor_proto;\n   tensor.AsProtoTensorContent(&tensor_proto);\n@@ -528,7 +529,7 @@ GrapplerItem CreateGrapplerItemWithResourceMemory() {\n   // Add a queue.\n   ops::FIFOQueue queue(s.WithOpName(\"queue\"), {DataType::DT_STRING});\n   Output some_string =\n-      ops::Const(s.WithOpName(\"some_string\"), string(\"nothing\"));\n+      ops::Const(s.WithOpName(\"some_string\"), std::string(\"nothing\"));\n   ops::QueueEnqueue enqueue(s.WithOpName(\"enqueue\"), queue, {some_string});\n   ops::QueueDequeue dequeue(s.WithOpName(\"dequeue\"), queue,\n                             {DataType::DT_STRING});\n@@ -560,7 +561,7 @@ TEST_F(SingleMachineTest, ReleaseMemoryAfterDestruction) {\n   GrapplerItem item = CreateGrapplerItemWithResourceMemory();\n   TF_CHECK_OK(cluster_->Initialize(item));\n \n-  std::unordered_map<string, uint64> device_peak_memory_before;\n+  std::unordered_map<std::string, uint64_t> device_peak_memory_before;\n   TF_CHECK_OK(cluster_->GetPeakMemoryUsage(&device_peak_memory_before));\n   EXPECT_EQ(device_peak_memory_before.size(), 1);\n   // There might be a bit memory used before session's running anything.\n@@ -570,15 +571,15 @@ TEST_F(SingleMachineTest, ReleaseMemoryAfterDestruction) {\n   TF_CHECK_OK(cluster_->Run(item.graph, item.feed, item.fetch, &metadata));\n \n   // Check there is memory that is not released.\n-  std::unordered_map<string, uint64> device_peak_memory;\n+  std::unordered_map<std::string, uint64_t> device_peak_memory;\n   TF_CHECK_OK(cluster_->GetPeakMemoryUsage(&device_peak_memory));\n   EXPECT_EQ(device_peak_memory.size(), 1);\n   EXPECT_GT(device_peak_memory.begin()->second, 0);\n \n   // Reprovisioning the cluster would release all memory.\n   TF_CHECK_OK(cluster_->Shutdown());\n   TF_CHECK_OK(cluster_->Provision());\n-  std::unordered_map<string, uint64> device_peak_memory_after;\n+  std::unordered_map<std::string, uint64_t> device_peak_memory_after;\n   TF_CHECK_OK(cluster_->GetPeakMemoryUsage(&device_peak_memory_after));\n   TF_CHECK_OK(cluster_->Shutdown());\n \n@@ -596,12 +597,12 @@ TEST_F(SingleMachineTest, PeakMemory) {\n   RunMetadata metadata;\n   TF_CHECK_OK(cluster_->Run(item.graph, item.feed, item.fetch, &metadata));\n \n-  std::unordered_map<string, uint64> device_peak_memory;\n+  std::unordered_map<std::string, uint64_t> device_peak_memory;\n   TF_CHECK_OK(cluster_->GetPeakMemoryUsage(&device_peak_memory));\n   ASSERT_NE(\n       device_peak_memory.find(\"/job:localhost/replica:0/task:0/device:CPU:0\"),\n       device_peak_memory.end());\n-  uint64 cpu_memory =\n+  uint64_t cpu_memory =\n       device_peak_memory[\"/job:localhost/replica:0/task:0/device:CPU:0\"];\n   EXPECT_GT(cpu_memory, 0);\n \n@@ -629,7 +630,7 @@ TEST_F(SingleMachineTest, PeakMemoryStatsNotEnabled) {\n   TF_CHECK_OK(cluster.Provision());\n   TF_CHECK_OK(cluster.Initialize(item));\n \n-  std::unordered_map<string, uint64> device_peak_memory;\n+  std::unordered_map<std::string, uint64_t> device_peak_memory;\n   absl::Status s = cluster.GetPeakMemoryUsage(&device_peak_memory);\n   TF_CHECK_OK(cluster.Shutdown());\n   ASSERT_FALSE(s.ok());"
        },
        {
            "sha": "c8c450c91f0edca2a752c49961f9821f5e72a3bc",
            "filename": "tensorflow/core/grappler/clusters/virtual_cluster.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster.cc?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -35,12 +35,12 @@ namespace tensorflow {\n namespace grappler {\n \n VirtualCluster::VirtualCluster(\n-    const std::unordered_map<string, DeviceProperties>& devices)\n+    const std::unordered_map<std::string, DeviceProperties>& devices)\n     : VirtualCluster(devices, std::make_unique<OpLevelCostEstimator>(),\n                      ReadyNodeManagerFactory(\"FirstReady\")) {}\n \n VirtualCluster::VirtualCluster(\n-    const std::unordered_map<string, DeviceProperties>& devices,\n+    const std::unordered_map<std::string, DeviceProperties>& devices,\n     std::unique_ptr<OpLevelCostEstimator> node_estimator,\n     std::unique_ptr<ReadyNodeManager> node_manager)\n     : Cluster(0) {\n@@ -54,7 +54,7 @@ VirtualCluster::VirtualCluster(\n }\n \n VirtualCluster::VirtualCluster(const DeviceSet* device_set)\n-    : VirtualCluster(std::unordered_map<string, DeviceProperties>()) {\n+    : VirtualCluster(std::unordered_map<std::string, DeviceProperties>()) {\n   device_set_ = device_set;\n   for (const auto& device : device_set_->devices()) {\n     DeviceProperties props = GetDeviceInfo(device->parsed_name());\n@@ -74,8 +74,9 @@ absl::Status VirtualCluster::Initialize(const GrapplerItem& item) {\n }\n \n absl::Status VirtualCluster::Run(\n-    const GraphDef& graph, const std::vector<std::pair<string, Tensor>>& feed,\n-    const std::vector<string>& fetch, RunMetadata* metadata) {\n+    const GraphDef& graph,\n+    const std::vector<std::pair<std::string, Tensor>>& feed,\n+    const std::vector<std::string>& fetch, RunMetadata* metadata) {\n   GrapplerItem item;\n   item.graph = graph;\n   item.feed = feed;\n@@ -98,11 +99,12 @@ absl::Status VirtualCluster::Run(const GrapplerItem& item,\n   TF_RETURN_IF_ERROR(\n       estimator_->PredictCosts(item.graph, metadata, /*cost=*/nullptr));\n \n-  const std::unordered_map<string, DeviceProperties>& device = GetDevices();\n-  std::unordered_map<string, int64_t> peak_mem_usage =\n+  const std::unordered_map<std::string, DeviceProperties>& device =\n+      GetDevices();\n+  std::unordered_map<std::string, int64_t> peak_mem_usage =\n       estimator_->GetScheduler()->GetPeakMemoryUsage();\n   for (const auto& mem_usage : peak_mem_usage) {\n-    const string& device_name = mem_usage.first;\n+    const std::string& device_name = mem_usage.first;\n     auto it = device.find(device_name);\n     if (it == device.end()) {\n       // It's probably the fake send/recv device. Eventually we'll need to"
        },
        {
            "sha": "5a6f3d83bccb4fa04be05e52a627ad256c05d604",
            "filename": "tensorflow/core/grappler/clusters/virtual_cluster.h",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster.h?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -39,21 +39,22 @@ namespace grappler {\n class VirtualCluster : public Cluster {\n  public:\n   explicit VirtualCluster(\n-      const std::unordered_map<string, DeviceProperties>& devices);\n-  VirtualCluster(const std::unordered_map<string, DeviceProperties>& devices,\n-                 std::unique_ptr<OpLevelCostEstimator> node_estimator,\n-                 std::unique_ptr<ReadyNodeManager> node_manager);\n+      const std::unordered_map<std::string, DeviceProperties>& devices);\n+  VirtualCluster(\n+      const std::unordered_map<std::string, DeviceProperties>& devices,\n+      std::unique_ptr<OpLevelCostEstimator> node_estimator,\n+      std::unique_ptr<ReadyNodeManager> node_manager);\n   explicit VirtualCluster(const DeviceSet* device_set);\n \n   ~VirtualCluster() override;\n \n-  string type() const override { return \"virtual\"; }\n+  std::string type() const override { return \"virtual\"; }\n \n   absl::Status Provision() override;\n   absl::Status Initialize(const GrapplerItem& item) override;\n   absl::Status Run(const GraphDef& graph,\n-                   const std::vector<std::pair<string, Tensor>>& feed,\n-                   const std::vector<string>& fetch,\n+                   const std::vector<std::pair<std::string, Tensor>>& feed,\n+                   const std::vector<std::string>& fetch,\n                    RunMetadata* metadata) override;\n   absl::Status Run(const GrapplerItem& item, RunMetadata* metadata) override;\n   const DeviceSet* GetDeviceSet() const override { return device_set_; }"
        },
        {
            "sha": "8af18e1e1d6ebad923d621f330fdeff878d4f7a7",
            "filename": "tensorflow/core/grappler/clusters/virtual_cluster_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34d607662007b6a270e4af2199ef091e7d05cac3/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fclusters%2Fvirtual_cluster_test.cc?ref=34d607662007b6a270e4af2199ef091e7d05cac3",
            "patch": "@@ -51,7 +51,7 @@ class VirtualClusterTest : public ::testing::Test {\n     cpu_device.set_l2_cache_size(256 * 1024);\n     cpu_device.set_l3_cache_size(4 * 1024 * 1024);\n     cpu_device.set_memory_size(1024 * 1024);\n-    std::unordered_map<string, DeviceProperties> devices;\n+    std::unordered_map<std::string, DeviceProperties> devices;\n     devices[\"/job:localhost/replica:0/task:0/cpu:0\"] = cpu_device;\n     cluster_ = std::make_unique<VirtualCluster>(devices);\n     TF_CHECK_OK(cluster_->Provision());\n@@ -86,7 +86,7 @@ TEST_F(VirtualClusterTest, CostModel) {\n   EXPECT_LE(4, metadata.cost_graph().node_size());\n   for (const auto& node : metadata.cost_graph().node()) {\n     // Skip the constant node that configures the random number generator.\n-    if (node.name().find(\"Const/Const\") != string::npos) {\n+    if (node.name().find(\"Const/Const\") != std::string::npos) {\n       continue;\n     }\n     EXPECT_EQ(1, node.output_info_size());"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 70,
        "deletions": 66
    }
}