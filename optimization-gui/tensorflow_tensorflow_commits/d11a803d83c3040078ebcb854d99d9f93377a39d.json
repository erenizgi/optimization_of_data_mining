{
    "author": "akuegel",
    "message": "[XLA:GPU] Allow to fuse iotas into sort.\n\nAlso adjust alias info logic to allow sharing the sort fusion operands with the\nright sort fusion outputs.\n\nPiperOrigin-RevId: 846841000",
    "sha": "d11a803d83c3040078ebcb854d99d9f93377a39d",
    "files": [
        {
            "sha": "20378ae18cce67d1903e3ef78209d2086a1d874f",
            "filename": "third_party/xla/xla/service/gpu/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2FBUILD?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -1532,6 +1532,7 @@ cc_library(\n         \"//xla/service/gpu/model:gpu_hlo_cost_analysis\",\n         \"//xla/service/gpu/transforms:multi_output_fusion\",\n         \"//xla/service/gpu/transforms:priority_fusion\",\n+        \"//xla/service/gpu/transforms:sort_iota_fusion\",\n         \"//xla/service/gpu/transforms:variadic_op_splitter\",\n         \"//xla/stream_executor:device_description\",\n         \"//xla/tsl/platform:env\",\n@@ -2822,7 +2823,6 @@ xla_cc_test(\n         \"//xla/tests:xla_internal_test_main\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n "
        },
        {
            "sha": "0db594dc5cd8cd19f6980e075fcf0bd7e7b7542d",
            "filename": "third_party/xla/xla/service/gpu/alias_info.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Falias_info.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Falias_info.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Falias_info.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -128,6 +128,15 @@ std::optional<bool> FusionCanShareBufferHint(\n           continue;\n         }\n       }\n+      // For sort, we can share the buffer if the operand appears only once. We\n+      // can share it with that output buffer that corresponds to the operand.\n+      if (hlo == non_bitcast_root && hlo->opcode() == HloOpcode::kSort &&\n+          absl::c_count(hlo->operands(), hlo_operand) == 1) {\n+        if (user_index != ShapeIndex{hlo->operand_index(hlo_operand)}) {\n+          return false;\n+        }\n+        continue;\n+      }\n       if (non_bitcast_root->opcode() == HloOpcode::kDynamicUpdateSlice &&\n           hlo->opcode() == HloOpcode::kDynamicSlice &&\n           non_bitcast_root->operand(0) == hlo->operand(0) &&"
        },
        {
            "sha": "d64c4ac75a46e2dacf10d3ae171343bc91c42446",
            "filename": "third_party/xla/xla/service/gpu/alias_info_test.cc",
            "status": "modified",
            "additions": 118,
            "deletions": 51,
            "changes": 169,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Falias_info_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Falias_info_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Falias_info_test.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -32,7 +32,6 @@ limitations under the License.\n #include \"xla/service/gpu/gpu_device_info_for_tests.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/stream_executor/device_description.h\"\n-#include \"tsl/platform/statusor.h\"\n \n namespace xla::gpu {\n namespace {\n@@ -79,8 +78,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -102,8 +101,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -125,8 +124,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -151,8 +150,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {0}));\n   // The second operand cannot share the buffer with the second fusion output,\n@@ -182,8 +181,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {0}));\n   // The first operand cannot share the buffer with the second fusion output,\n@@ -222,8 +221,8 @@ ENTRY %main {\n       kind=kLoop, calls=%fused_computation\n })\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {1}));\n }\n@@ -265,8 +264,8 @@ TEST_F(AliasInfoTest, BufferCannotBeSharedScatterMultiOutputFusion) {\n     }\n     )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   // We expect that no buffer can be shared, because when Scatter is involved,\n   // the only buffer we can potentially share is the first operand of scatter,\n@@ -312,8 +311,8 @@ TEST_F(AliasInfoTest, BufferCanBeSharedScatterFusion) {\n     }\n     )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {}));\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(1), {}));\n@@ -353,8 +352,8 @@ TEST_F(AliasInfoTest, BufferCannotBeSharedScatterFusion) {\n     }\n     )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(1), {}));\n@@ -401,8 +400,8 @@ TEST_F(AliasInfoTest, BufferCanBeSharedVariadicScatterFusion) {\n     }\n     )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {0}));\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(1), {1}));\n@@ -441,8 +440,8 @@ TEST_F(AliasInfoTest,\n     }\n     )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(1), {}));\n@@ -486,13 +485,81 @@ TEST_F(AliasInfoTest, BufferCannotBeSharedVariadicScatterFusion) {\n     }\n     )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {0}));\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(1), {1}));\n }\n \n+TEST_F(AliasInfoTest, BufferCanBeSharedSortFusion) {\n+  const char* const kModuleString = R\"(\n+    HloModule module\n+\n+    sorting_computation {\n+      %lhs_key = s32[] parameter(0)\n+      %rhs_key = s32[] parameter(1)\n+      %lhs_update_0 = s32[] parameter(2)\n+      %rhs_update_0 = s32[] parameter(3)\n+      %lhs_permutation = s32[] parameter(4)\n+      %rhs_permutation = s32[] parameter(5)\n+      ROOT %compare = pred[] compare(%lhs_key, %rhs_key), direction=LT\n+    }\n+\n+    sort_fusion {\n+      p0 = s32[16384]{0} parameter(0)\n+      iota = s32[16384]{0} iota(), iota_dimension=0\n+      ROOT sort = (s32[16384]{0}, s32[16384]{0}, s32[16384]{0}) sort(p0, iota, iota), dimensions={0}, is_stable=true, to_apply=sorting_computation\n+    }\n+\n+    ENTRY main {\n+      p = s32[16384]{0} parameter(0)\n+      ROOT fusion = (s32[16384]{0}, s32[16384]{0}, s32[16384]{0}) fusion(p), kind=kInput, calls=sort_fusion\n+    }\n+    )\";\n+\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n+  HloInstruction* fusion = module->entry_computation()->root_instruction();\n+  ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {0}));\n+  ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {1}));\n+  ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {2}));\n+}\n+\n+TEST_F(AliasInfoTest, BufferCannotBeSharedSortFusionDuplicateSortOperand) {\n+  const char* const kModuleString = R\"(\n+    HloModule module\n+\n+    sorting_computation {\n+      %lhs_key = s32[] parameter(0)\n+      %rhs_key = s32[] parameter(1)\n+      %lhs_update_0 = s32[] parameter(2)\n+      %rhs_update_0 = s32[] parameter(3)\n+      %lhs_permutation = s32[] parameter(4)\n+      %rhs_permutation = s32[] parameter(5)\n+      ROOT %compare = pred[] compare(%lhs_key, %rhs_key), direction=LT\n+    }\n+\n+    sort_fusion {\n+      p0 = s32[16384]{0} parameter(0)\n+      iota = s32[16384]{0} iota(), iota_dimension=0\n+      ROOT sort = (s32[16384]{0}, s32[16384]{0}, s32[16384]{0}) sort(p0, iota, p0), dimensions={0}, is_stable=true, to_apply=sorting_computation\n+    }\n+\n+    ENTRY main {\n+      p = s32[16384]{0} parameter(0)\n+      ROOT fusion = (s32[16384]{0}, s32[16384]{0}, s32[16384]{0}) fusion(p), kind=kInput, calls=sort_fusion\n+    }\n+    )\";\n+\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n+  HloInstruction* fusion = module->entry_computation()->root_instruction();\n+  ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {0}));\n+  ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {1}));\n+  ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {2}));\n+}\n+\n TEST_F(AliasInfoTest, BufferCannotBeSharedConvertedShapeDifferentByteWidth) {\n   const char* const kModuleString = R\"(\n HloModule fusion\n@@ -510,8 +577,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -533,8 +600,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -555,8 +622,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -577,8 +644,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -606,8 +673,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -636,8 +703,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -664,8 +731,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {0}));\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {1}));\n@@ -702,8 +769,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {0}));\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {1}));\n@@ -738,8 +805,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {0}));\n }\n@@ -768,8 +835,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalTrue(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -799,8 +866,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -830,8 +897,8 @@ ENTRY main {\n }\n )\";\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(0), {}));\n }\n@@ -862,8 +929,8 @@ ENTRY main {\n   ROOT %address_computation = (f32[8]{0}, (f32[128]{0}, f32[256]{0})) fusion(p0, p1, p2), kind=kCustom, calls=%dynamic-slice-fusion, backend_config={\"fusion_backend_config\":{\"kind\":\"__custom_fusion\",\"custom_fusion_config\":{\"name\":\"address_computation\",\"kernel_index\":0}},\"force_earliest_schedule\":false,\"reification_cost\":[]}\n }\n )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n-                          ParseAndReturnVerifiedModule(kModuleString));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<xla::HloModule> module,\n+                       ParseAndReturnVerifiedModule(kModuleString));\n   HloInstruction* fusion = module->entry_computation()->root_instruction();\n   ExpectOptionalFalse(MayAlias(fusion, fusion->operand(1), {1, 0}));\n }"
        },
        {
            "sha": "f8101d4126e4a4ce695569f0b4cd2d9e001cb0b4",
            "filename": "third_party/xla/xla/service/gpu/fusion_pipeline.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ffusion_pipeline.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ffusion_pipeline.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ffusion_pipeline.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -28,6 +28,7 @@ limitations under the License.\n #include \"xla/service/gpu/model/gpu_hlo_cost_analysis.h\"\n #include \"xla/service/gpu/transforms/multi_output_fusion.h\"\n #include \"xla/service/gpu/transforms/priority_fusion.h\"\n+#include \"xla/service/gpu/transforms/sort_iota_fusion.h\"\n #include \"xla/service/gpu/transforms/variadic_op_splitter.h\"\n #include \"xla/service/hlo_cost_analysis.h\"\n #include \"xla/service/hlo_cse.h\"\n@@ -58,6 +59,7 @@ HloPassPipeline FusionPipeline(\n       std::make_unique<CpuGpuVerifierMetadata>(std::move(opts)),\n       \"hlo verifier (debug)\");\n \n+  fusion.AddPass<SortIotaFusion>();\n   GpuHloCostAnalysis::Options cost_analysis_options{\n       shape_size_bytes_function,\n       /*per_second_rates=*/{},"
        },
        {
            "sha": "58d7222b990469cd5dde69bf89944264167f0ce2",
            "filename": "third_party/xla/xla/service/gpu/tests/sorting_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fsorting_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fsorting_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftests%2Fsorting_test.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -170,7 +170,7 @@ TEST_F(SortingTest, SortFusionWithIotaOperand) {\n \n     ENTRY main {\n       p = s32[16384]{0} parameter(0)\n-      ROOT fusion = (s32[16384]{0}, s32[16384]{0}) fusion(p), kind=kInput, calls=sort_fusion\n+      ROOT fusion = (s32[16384]{0}, s32[16384]{0}) fusion(p), kind=kCustom, calls=sort_fusion\n     }\n   )\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text, ErrorSpec{1e-5, 1e-5}));\n@@ -200,7 +200,7 @@ TEST_F(SortingTest, SortFusionWithIotaOperandTinySortDim) {\n \n     ENTRY main {\n       p = s32[2]{0} parameter(0)\n-      ROOT fusion = (s32[2]{0}, s32[2]{0}) fusion(p), kind=kInput, calls=sort_fusion\n+      ROOT fusion = (s32[2]{0}, s32[2]{0}) fusion(p), kind=kCustom, calls=sort_fusion\n     }\n   )\";\n   EXPECT_TRUE(RunAndCompareNoHloPasses(hlo_text, ErrorSpec{1e-5, 1e-5}));"
        },
        {
            "sha": "07a5b9ac5652594b38c4a842bd2bb66780022c2e",
            "filename": "third_party/xla/xla/service/gpu/transforms/BUILD",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2FBUILD?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -2598,6 +2598,40 @@ xla_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"sort_iota_fusion\",\n+    srcs = [\"sort_iota_fusion.cc\"],\n+    hdrs = [\"sort_iota_fusion.h\"],\n+    deps = [\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/pass:hlo_pass\",\n+        \"//xla/tsl/platform:status_macros\",\n+        \"@com_google_absl//absl/container:flat_hash_set\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"sort_iota_fusion_test\",\n+    srcs = [\n+        \"sort_iota_fusion_test.cc\",\n+    ],\n+    deps = [\n+        \":sort_iota_fusion\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/testlib:pattern_matcher_gmock\",\n+        \"//xla/service:pattern_matcher\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"sort_rewriter\",\n     srcs = [\"sort_rewriter.cc\"],"
        },
        {
            "sha": "1a4e128f41679a127f1ffc4e6f69b9f1062bd354",
            "filename": "third_party/xla/xla/service/gpu/transforms/priority_fusion.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fpriority_fusion.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -1295,12 +1295,12 @@ HloInstruction::FusionKind PriorityFusion::ChooseKind(\n     case HloFusionAnalysis::EmitterFusionKind::kTriton:\n     case HloFusionAnalysis::EmitterFusionKind::kCustomFusion:\n     case HloFusionAnalysis::EmitterFusionKind::kCuDnn:\n+    case HloFusionAnalysis::EmitterFusionKind::kSort:\n       return HloInstruction::FusionKind::kCustom;\n     case HloFusionAnalysis::EmitterFusionKind::kConcatenate:\n     case HloFusionAnalysis::EmitterFusionKind::kReduction:\n     case HloFusionAnalysis::EmitterFusionKind::kTranspose:\n     case HloFusionAnalysis::EmitterFusionKind::kScatter:\n-    case HloFusionAnalysis::EmitterFusionKind::kSort:\n       return HloInstruction::FusionKind::kInput;\n   }\n }"
        },
        {
            "sha": "cba65682acee3866b9a7f11ea2f2978caf82fb5b",
            "filename": "third_party/xla/xla/service/gpu/transforms/sort_iota_fusion.cc",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -0,0 +1,70 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/service/gpu/transforms/sort_iota_fusion.h\"\n+\n+#include <vector>\n+\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/dfs_hlo_visitor_with_default.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/tsl/platform/status_macros.h\"\n+\n+namespace xla::gpu {\n+namespace {\n+\n+class SortIotaFusionGroupVisitor : public DfsHloRewriteVisitor {\n+ public:\n+  absl::Status HandleSort(HloInstruction* sort) override {\n+    VLOG(4) << \"Input: \" << sort->ToString();\n+    std::vector<HloInstruction*> iota_operands;\n+    absl::flat_hash_set<HloInstruction*> different_iotas;\n+    for (HloInstruction* operand : sort->mutable_operands()) {\n+      if (HloPredicateIsOp<HloOpcode::kIota>(operand)) {\n+        if (different_iotas.insert(operand).second) {\n+          iota_operands.push_back(operand);\n+        }\n+      }\n+    }\n+    if (iota_operands.empty()) {\n+      return absl::OkStatus();\n+    }\n+    HloInstruction* fusion =\n+        sort->parent()->AddInstruction(HloInstruction::CreateFusion(\n+            sort->shape(), HloInstruction::FusionKind::kCustom, sort));\n+    for (HloInstruction* iota : iota_operands) {\n+      fusion->FuseInstruction(iota);\n+    }\n+    VLOG(5) << \"Generated fusion: \" << fusion->ToString();\n+    return ReplaceInstruction(sort, fusion);\n+  }\n+};\n+}  // namespace\n+\n+absl::StatusOr<bool> SortIotaFusion::RunImpl(\n+    HloModule* module,\n+    const absl::flat_hash_set<absl::string_view>& execution_threads) {\n+  ASSIGN_OR_RETURN(bool changed, SortIotaFusionGroupVisitor().RunOnModule(\n+                                     module, execution_threads));\n+  return changed;\n+}\n+}  // namespace xla::gpu"
        },
        {
            "sha": "dacb103910c363515c49e3b6bacf634871505f7d",
            "filename": "third_party/xla/xla/service/gpu/transforms/sort_iota_fusion.h",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion.h?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -0,0 +1,39 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#ifndef XLA_SERVICE_GPU_TRANSFORMS_SORT_IOTA_FUSION_H_\n+#define XLA_SERVICE_GPU_TRANSFORMS_SORT_IOTA_FUSION_H_\n+\n+#include \"absl/container/flat_hash_set.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/pass/hlo_pass_interface.h\"\n+\n+namespace xla::gpu {\n+\n+// Fuses iotas into sort.\n+class SortIotaFusion : public HloModulePass {\n+ public:\n+  absl::string_view name() const override { return \"sort-iota-fusion\"; }\n+\n+ protected:\n+  absl::StatusOr<bool> RunImpl(\n+      HloModule* module,\n+      const absl::flat_hash_set<absl::string_view>& execution_threads) override;\n+};\n+\n+}  // namespace xla::gpu\n+\n+#endif  // XLA_SERVICE_GPU_TRANSFORMS_SORT_IOTA_FUSION_H_"
        },
        {
            "sha": "34ba36597c0b75a44da99e29b6367eeb6e1ee83d",
            "filename": "third_party/xla/xla/service/gpu/transforms/sort_iota_fusion_test.cc",
            "status": "added",
            "additions": 71,
            "deletions": 0,
            "changes": 71,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d11a803d83c3040078ebcb854d99d9f93377a39d/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Fsort_iota_fusion_test.cc?ref=d11a803d83c3040078ebcb854d99d9f93377a39d",
            "patch": "@@ -0,0 +1,71 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/service/gpu/transforms/sort_iota_fusion.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status_matchers.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/testlib/pattern_matcher_gmock.h\"\n+#include \"xla/service/pattern_matcher.h\"\n+\n+namespace m = ::xla::match;\n+\n+namespace xla::gpu {\n+namespace {\n+\n+using SortIotaFusionTest = HloHardwareIndependentTestBase;\n+\n+TEST_F(SortIotaFusionTest, FuseIota) {\n+  auto module = *ParseAndReturnVerifiedModule(R\"(\n+    HloModule module\n+\n+    sorting_computation {\n+      %lhs_key = s32[] parameter(0)\n+      %rhs_key = s32[] parameter(1)\n+      %lhs_index = s32[] parameter(2)\n+      %rhs_index = s32[] parameter(3)\n+      %lhs_index2 = s32[] parameter(4)\n+      %rhs_index2 = s32[] parameter(5)\n+      %lt_key = pred[] compare(%lhs_key, %rhs_key), direction=LT\n+      %gt_key = pred[] compare(%rhs_key, %lhs_key), direction=LT\n+      %eq_key = pred[] compare(%lt_key, %gt_key), direction=EQ\n+      %lt_index = pred[] compare(%lhs_index, %rhs_index), direction=LT\n+      ROOT res = pred[] select(%eq_key, %lt_index, %lt_key)\n+    }\n+\n+    ENTRY main {\n+      p0 = s32[16384]{0} parameter(0)\n+      neg = s32[16384]{0} negate(p0)\n+      iota = s32[16384]{0} iota(), iota_dimension=0\n+      ROOT sort = (s32[16384]{0}, s32[16384]{0}, s32[16384]{0}) sort(neg, iota, iota), dimensions={0}, is_stable=true, to_apply=sorting_computation\n+    }\n+  )\");\n+  EXPECT_THAT(SortIotaFusion().Run(module.get()),\n+              absl_testing::IsOkAndHolds(true));\n+\n+  HloInstruction* root = module->entry_computation()->root_instruction();\n+  const HloInstruction* fusion = nullptr;\n+  ASSERT_THAT(root, GmockMatch(m::Fusion(&fusion, m::Negate())));\n+  EXPECT_EQ(fusion->fusion_kind(), HloInstruction::FusionKind::kCustom);\n+  EXPECT_THAT(fusion->fused_expression_root(),\n+              GmockMatch(m::Sort(m::Parameter(), m::Iota(), m::Iota())));\n+}\n+\n+}  // namespace\n+}  // namespace xla::gpu"
        }
    ],
    "stats": {
        "total": 402,
        "additions": 347,
        "deletions": 55
    }
}