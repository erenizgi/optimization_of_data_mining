{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832683746",
    "sha": "c8ae25af9bdde84898686df115f71b8c59f016d3",
    "files": [
        {
            "sha": "c48d27bdabc39d94961588eabe7d817858950d15",
            "filename": "third_party/xla/xla/tsl/lib/gtl/compactptrset_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fcompactptrset_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fcompactptrset_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fcompactptrset_test.cc?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -33,7 +33,7 @@ static std::vector<const char*> SortedContents(const StringSet& set) {\n \n TEST(CompactPointerSetTest, Simple) {\n   // Make some aligned and some unaligned pointers.\n-  string data = \"ABCDEFG\";\n+  std::string data = \"ABCDEFG\";\n   const char* a = &data[0];\n   const char* b = &data[1];\n   const char* c = &data[2];"
        },
        {
            "sha": "c873c40ef2739043baeb2215655469232ef8638c",
            "filename": "third_party/xla/xla/tsl/lib/gtl/flatmap.h",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatmap.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatmap.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatmap.h?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -133,7 +133,7 @@ class FlatMap {\n     iterator(Bucket* b, Bucket* end) : b_(b), end_(end), i_(0) { SkipUnused(); }\n \n     // Make iterator pointing exactly at ith element in b, which must exist.\n-    iterator(Bucket* b, Bucket* end, uint32 i) : b_(b), end_(end), i_(i) {\n+    iterator(Bucket* b, Bucket* end, uint32_t i) : b_(b), end_(end), i_(i) {\n       FillValue();\n     }\n \n@@ -160,7 +160,7 @@ class FlatMap {\n     Bucket* b_;\n     Bucket* end_;\n     char space_ alignas(value_type)[sizeof(value_type)];\n-    uint32 i_;\n+    uint32_t i_;\n \n     pointer val() { return reinterpret_cast<pointer>(space_); }\n     void FillValue() { new (space_) value_type(b_->key(i_), b_->val(i_)); }\n@@ -192,7 +192,7 @@ class FlatMap {\n \n     const_iterator() : rep_() {}\n     const_iterator(Bucket* start, Bucket* end) : rep_(start, end) {}\n-    const_iterator(Bucket* b, Bucket* end, uint32 i) : rep_(b, end, i) {}\n+    const_iterator(Bucket* b, Bucket* end, uint32_t i) : rep_(b, end, i) {}\n \n     reference operator*() const { return *rep_.val(); }\n     pointer operator->() const { return rep_.val(); }\n@@ -321,7 +321,7 @@ class FlatMap {\n   // Bucket stores kWidth <marker, key, value> triples.\n   // The data is organized as three parallel arrays to reduce padding.\n   struct Bucket {\n-    uint8 marker[Rep::kWidth];\n+    uint8_t marker[Rep::kWidth];\n \n     // Wrap keys and values in union to control construction and destruction.\n     union Storage {\n@@ -333,27 +333,27 @@ class FlatMap {\n       ~Storage() {}\n     } storage;\n \n-    Key& key(uint32 i) {\n+    Key& key(uint32_t i) {\n       DCHECK_GE(marker[i], 2);\n       return storage.key[i];\n     }\n-    Val& val(uint32 i) {\n+    Val& val(uint32_t i) {\n       DCHECK_GE(marker[i], 2);\n       return storage.val[i];\n     }\n     template <typename V>\n-    void InitVal(uint32 i, V&& v) {\n+    void InitVal(uint32_t i, V&& v) {\n       new (&storage.val[i]) Val(std::forward<V>(v));\n     }\n-    void Destroy(uint32 i) {\n+    void Destroy(uint32_t i) {\n       storage.key[i].Key::~Key();\n       storage.val[i].Val::~Val();\n     }\n-    void MoveFrom(uint32 i, Bucket* src, uint32 src_index) {\n+    void MoveFrom(uint32_t i, Bucket* src, uint32_t src_index) {\n       new (&storage.key[i]) Key(std::move(src->storage.key[src_index]));\n       new (&storage.val[i]) Val(std::move(src->storage.val[src_index]));\n     }\n-    void CopyFrom(uint32 i, Bucket* src, uint32 src_index) {\n+    void CopyFrom(uint32_t i, Bucket* src, uint32_t src_index) {\n       new (&storage.key[i]) Key(src->storage.key[src_index]);\n       new (&storage.val[i]) Val(src->storage.val[src_index]);\n     }"
        },
        {
            "sha": "34827198d338729b29820c8988ea28f9d615984c",
            "filename": "third_party/xla/xla/tsl/lib/gtl/flatmap_test.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatmap_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatmap_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatmap_test.cc?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -30,10 +30,10 @@ namespace tsl {\n namespace gtl {\n namespace {\n \n-typedef FlatMap<int64_t, int32> NumMap;\n+typedef FlatMap<int64_t, int32_t> NumMap;\n \n // If map has an entry for k, return the corresponding value, else return def.\n-int32 Get(const NumMap& map, int64_t k, int32_t def = -1) {\n+int32_t Get(const NumMap& map, int64_t k, int32_t def = -1) {\n   auto iter = map.find(k);\n   if (iter == map.end()) {\n     EXPECT_EQ(map.count(k), 0);\n@@ -47,7 +47,7 @@ int32 Get(const NumMap& map, int64_t k, int32_t def = -1) {\n }\n \n // Return contents of map as a sorted list of pairs.\n-typedef std::vector<std::pair<int64_t, int32>> NumMapContents;\n+typedef std::vector<std::pair<int64_t, int32_t>> NumMapContents;\n NumMapContents Contents(const NumMap& map) {\n   NumMapContents result;\n   for (const auto& p : map) {\n@@ -146,8 +146,8 @@ TEST(FlatMapTest, Emplace) {\n }\n \n TEST(FlatMapTest, EmplaceUniquePtr) {\n-  FlatMap<int64_t, std::unique_ptr<string>> smap;\n-  smap.emplace(1, std::make_unique<string>(\"hello\"));\n+  FlatMap<int64_t, std::unique_ptr<std::string>> smap;\n+  smap.emplace(1, std::make_unique<std::string>(\"hello\"));\n }\n \n TEST(FlatMapTest, Size) {\n@@ -344,7 +344,7 @@ TEST(FlatMap, InitializerList) {\n   NumMap b({{1, 10}, {2, 20}, {3, 30}});\n   NumMap c = {{1, 10}, {2, 20}, {3, 30}};\n \n-  typedef std::unordered_map<int64_t, int32> StdNumMap;\n+  typedef std::unordered_map<int64_t, int32_t> StdNumMap;\n   StdNumMap std({{1, 10}, {2, 20}, {3, 30}});\n   StdNumMap::value_type std_r1 = *std.find(1);\n   StdNumMap::value_type std_r2 = *std.find(2);\n@@ -591,17 +591,17 @@ TEST(FlatMap, ForwardIterator) {\n // or destructions will show up as errors under a sanitizer or\n // heap checker.\n TEST(FlatMap, ConstructDestruct) {\n-  FlatMap<string, string> map;\n-  string k1 = \"the quick brown fox jumped over the lazy dog\";\n-  string k2 = k1 + k1;\n-  string k3 = k1 + k2;\n+  FlatMap<std::string, std::string> map;\n+  std::string k1 = \"the quick brown fox jumped over the lazy dog\";\n+  std::string k2 = k1 + k1;\n+  std::string k3 = k1 + k2;\n   map[k1] = k2;\n   map[k3] = k1;\n   EXPECT_EQ(k1, map.find(k1)->first);\n   EXPECT_EQ(k2, map.find(k1)->second);\n   EXPECT_EQ(k1, map[k3]);\n   map.erase(k3);\n-  EXPECT_EQ(string(), map[k3]);\n+  EXPECT_EQ(std::string(), map[k3]);\n \n   map.clear();\n   map[k1] = k2;"
        },
        {
            "sha": "51ac65480b9a9cd7f99177a4d79409a56314fea9",
            "filename": "third_party/xla/xla/tsl/lib/gtl/flatrep.h",
            "status": "modified",
            "additions": 28,
            "deletions": 26,
            "changes": 54,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatrep.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatrep.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatrep.h?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -47,8 +47,8 @@ template <typename Key, typename Bucket, class Hash, class Eq>\n class FlatRep {\n  public:\n   // kWidth is the number of entries stored in a bucket.\n-  static constexpr uint32 kBase = 3;\n-  static constexpr uint32 kWidth = (1 << kBase);\n+  static constexpr uint32_t kBase = 3;\n+  static constexpr uint32_t kWidth = (1 << kBase);\n \n   FlatRep(size_t N, const Hash& hf, const Eq& eq) : hash_(hf), equal_(eq) {\n     Init(N);\n@@ -102,7 +102,7 @@ class FlatRep {\n \n   void clear_no_resize() {\n     for (Bucket* b = array_; b != end_; b++) {\n-      for (uint32 i = 0; i < kWidth; i++) {\n+      for (uint32_t i = 0; i < kWidth; i++) {\n         if (b->marker[i] >= 2) {\n           b->Destroy(i);\n           b->marker[i] = kEmpty;\n@@ -134,7 +134,7 @@ class FlatRep {\n   struct SearchResult {\n     bool found;\n     Bucket* b;\n-    uint32 index;\n+    uint32_t index;\n   };\n \n   // Hash value is partitioned as follows:\n@@ -145,13 +145,13 @@ class FlatRep {\n   // Find bucket/index for key k.\n   SearchResult Find(const Key& k) const {\n     size_t h = hash_(k);\n-    const uint32 marker = Marker(h & 0xff);\n+    const uint32_t marker = Marker(h & 0xff);\n     size_t index = (h >> 8) & mask_;  // Holds bucket num and index-in-bucket\n-    uint32 num_probes = 1;            // Needed for quadratic probing\n+    uint32_t num_probes = 1;          // Needed for quadratic probing\n     while (true) {\n-      uint32 bi = index & (kWidth - 1);\n+      uint32_t bi = index & (kWidth - 1);\n       Bucket* b = &array_[index >> kBase];\n-      const uint32 x = b->marker[bi];\n+      const uint32_t x = b->marker[bi];\n       if (x == marker && equal_(b->key(bi), k)) {\n         return {true, b, bi};\n       } else if (x == kEmpty) {\n@@ -170,15 +170,15 @@ class FlatRep {\n   template <typename KeyType>\n   SearchResult FindOrInsert(KeyType&& k) {\n     size_t h = hash_(k);\n-    const uint32 marker = Marker(h & 0xff);\n+    const uint32_t marker = Marker(h & 0xff);\n     size_t index = (h >> 8) & mask_;  // Holds bucket num and index-in-bucket\n-    uint32 num_probes = 1;            // Needed for quadratic probing\n+    uint32_t num_probes = 1;          // Needed for quadratic probing\n     Bucket* del = nullptr;            // First encountered deletion for kInsert\n-    uint32 di = 0;\n+    uint32_t di = 0;\n     while (true) {\n-      uint32 bi = index & (kWidth - 1);\n+      uint32_t bi = index & (kWidth - 1);\n       Bucket* b = &array_[index >> kBase];\n-      const uint32 x = b->marker[bi];\n+      const uint32_t x = b->marker[bi];\n       if (x == marker && equal_(b->key(bi), k)) {\n         return {true, b, bi};\n       } else if (!del && x == kDeleted) {\n@@ -203,7 +203,7 @@ class FlatRep {\n     }\n   }\n \n-  void Erase(Bucket* b, uint32 i) {\n+  void Erase(Bucket* b, uint32_t i) {\n     b->Destroy(i);\n     b->marker[i] = kDeleted;\n     deleted_++;\n@@ -213,7 +213,7 @@ class FlatRep {\n   void Prefetch(const Key& k) const {\n     size_t h = hash_(k);\n     size_t index = (h >> 8) & mask_;  // Holds bucket num and index-in-bucket\n-    uint32 bi = index & (kWidth - 1);\n+    uint32_t bi = index & (kWidth - 1);\n     Bucket* b = &array_[index >> kBase];\n     absl::PrefetchToLocalCache(&b->marker[bi]);\n     absl::PrefetchToLocalCache(&b->storage.key[bi]);\n@@ -247,7 +247,7 @@ class FlatRep {\n \n   Hash hash_;         // User-supplied hasher\n   Eq equal_;          // User-supplied comparator\n-  uint8 lglen_;       // lg(#buckets)\n+  uint8_t lglen_;     // lg(#buckets)\n   Bucket* array_;     // array of length (1 << lglen_)\n   Bucket* end_;       // Points just past last bucket in array_\n   size_t mask_;       // (# of entries in table) - 1\n@@ -258,7 +258,7 @@ class FlatRep {\n \n   // Avoid kEmpty and kDeleted markers when computing hash values to\n   // store in Bucket::marker[].\n-  static uint32 Marker(uint32 hb) { return hb + (hb < 2 ? 2 : 0); }\n+  static uint32_t Marker(uint32_t hb) { return hb + (hb < 2 ? 2 : 0); }\n \n   void Init(size_t N) {\n     // Make enough room for N elements.\n@@ -290,14 +290,16 @@ class FlatRep {\n \n   // Used by FreshInsert when we should copy from source.\n   struct CopyEntry {\n-    inline void operator()(Bucket* dst, uint32 dsti, Bucket* src, uint32 srci) {\n+    inline void operator()(Bucket* dst, uint32_t dsti, Bucket* src,\n+                           uint32_t srci) {\n       dst->CopyFrom(dsti, src, srci);\n     }\n   };\n \n   // Used by FreshInsert when we should move from source.\n   struct MoveEntry {\n-    inline void operator()(Bucket* dst, uint32 dsti, Bucket* src, uint32 srci) {\n+    inline void operator()(Bucket* dst, uint32_t dsti, Bucket* src,\n+                           uint32_t srci) {\n       dst->MoveFrom(dsti, src, srci);\n       src->Destroy(srci);\n       src->marker[srci] = kDeleted;\n@@ -307,7 +309,7 @@ class FlatRep {\n   template <typename Copier>\n   void CopyEntries(Bucket* start, Bucket* end, Copier copier) {\n     for (Bucket* b = start; b != end; b++) {\n-      for (uint32 i = 0; i < kWidth; i++) {\n+      for (uint32_t i = 0; i < kWidth; i++) {\n         if (b->marker[i] >= 2) {\n           FreshInsert(b, i, copier);\n         }\n@@ -320,15 +322,15 @@ class FlatRep {\n   // assume that there are no deletions, and k does not already exist\n   // in the table.\n   template <typename Copier>\n-  void FreshInsert(Bucket* src, uint32 src_index, Copier copier) {\n+  void FreshInsert(Bucket* src, uint32_t src_index, Copier copier) {\n     size_t h = hash_(src->key(src_index));\n-    const uint32 marker = Marker(h & 0xff);\n+    const uint32_t marker = Marker(h & 0xff);\n     size_t index = (h >> 8) & mask_;  // Holds bucket num and index-in-bucket\n-    uint32 num_probes = 1;            // Needed for quadratic probing\n+    uint32_t num_probes = 1;          // Needed for quadratic probing\n     while (true) {\n-      uint32 bi = index & (kWidth - 1);\n+      uint32_t bi = index & (kWidth - 1);\n       Bucket* b = &array_[index >> kBase];\n-      const uint32 x = b->marker[bi];\n+      const uint32_t x = b->marker[bi];\n       if (x == 0) {\n         b->marker[bi] = marker;\n         not_empty_++;\n@@ -340,7 +342,7 @@ class FlatRep {\n     }\n   }\n \n-  inline size_t NextIndex(size_t i, uint32 num_probes) const {\n+  inline size_t NextIndex(size_t i, uint32_t num_probes) const {\n     // Quadratic probing.\n     return (i + num_probes) & mask_;\n   }"
        },
        {
            "sha": "1ffe1cc054ee2edb4cbf39927c30eb87252eb9d6",
            "filename": "third_party/xla/xla/tsl/lib/gtl/flatset.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatset.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatset.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatset.h?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -118,7 +118,7 @@ class FlatSet {\n     }\n \n     // Make iterator pointing exactly at ith element in b, which must exist.\n-    const_iterator(Bucket* b, Bucket* end, uint32 i)\n+    const_iterator(Bucket* b, Bucket* end, uint32_t i)\n         : b_(b), end_(end), i_(i) {}\n \n     reference operator*() const { return key(); }\n@@ -143,7 +143,7 @@ class FlatSet {\n     friend class FlatSet;\n     Bucket* b_;\n     Bucket* end_;\n-    uint32 i_;\n+    uint32_t i_;\n \n     reference key() const { return b_->key(i_); }\n     void SkipUnused() {\n@@ -257,7 +257,7 @@ class FlatSet {\n   // Bucket stores kWidth <marker, key, value> triples.\n   // The data is organized as three parallel arrays to reduce padding.\n   struct Bucket {\n-    uint8 marker[Rep::kWidth];\n+    uint8_t marker[Rep::kWidth];\n \n     // Wrap keys in union to control construction and destruction.\n     union Storage {\n@@ -266,15 +266,15 @@ class FlatSet {\n       ~Storage() {}\n     } storage;\n \n-    Key& key(uint32 i) {\n+    Key& key(uint32_t i) {\n       DCHECK_GE(marker[i], 2);\n       return storage.key[i];\n     }\n-    void Destroy(uint32 i) { storage.key[i].Key::~Key(); }\n-    void MoveFrom(uint32 i, Bucket* src, uint32 src_index) {\n+    void Destroy(uint32_t i) { storage.key[i].Key::~Key(); }\n+    void MoveFrom(uint32_t i, Bucket* src, uint32_t src_index) {\n       new (&storage.key[i]) Key(std::move(src->storage.key[src_index]));\n     }\n-    void CopyFrom(uint32 i, Bucket* src, uint32 src_index) {\n+    void CopyFrom(uint32_t i, Bucket* src, uint32_t src_index) {\n       new (&storage.key[i]) Key(src->storage.key[src_index]);\n     }\n   };"
        },
        {
            "sha": "02831cd1d7ee5b3838eea3f44245d6e25a66dfd8",
            "filename": "third_party/xla/xla/tsl/lib/gtl/flatset_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatset_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatset_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fflatset_test.cc?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -487,10 +487,10 @@ TEST(FlatSet, ForwardIterator) {\n // or destructions will show up as errors under a sanitizer or\n // heap checker.\n TEST(FlatSet, ConstructDestruct) {\n-  FlatSet<string> set;\n-  string k1 = \"the quick brown fox jumped over the lazy dog\";\n-  string k2 = k1 + k1;\n-  string k3 = k1 + k2;\n+  FlatSet<std::string> set;\n+  std::string k1 = \"the quick brown fox jumped over the lazy dog\";\n+  std::string k2 = k1 + k1;\n+  std::string k3 = k1 + k2;\n   set.insert(k1);\n   set.insert(k3);\n   EXPECT_EQ(set.count(k1), 1);"
        },
        {
            "sha": "1205cd7a3e32511fd579de61a8b512225efc6a6d",
            "filename": "third_party/xla/xla/tsl/lib/gtl/int_type_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fint_type_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fint_type_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fint_type_test.cc?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -25,14 +25,14 @@ limitations under the License.\n \n namespace tsl {\n \n-TSL_LIB_GTL_DEFINE_INT_TYPE(Int8_IT, int8);\n-TSL_LIB_GTL_DEFINE_INT_TYPE(UInt8_IT, uint8);\n-TSL_LIB_GTL_DEFINE_INT_TYPE(Int16_IT, int16);\n-TSL_LIB_GTL_DEFINE_INT_TYPE(UInt16_IT, uint16);\n-TSL_LIB_GTL_DEFINE_INT_TYPE(Int32_IT, int32);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(Int8_IT, int8_t);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(UInt8_IT, uint8_t);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(Int16_IT, int16_t);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(UInt16_IT, uint16_t);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(Int32_IT, int32_t);\n TSL_LIB_GTL_DEFINE_INT_TYPE(Int64_IT, int64_t);\n-TSL_LIB_GTL_DEFINE_INT_TYPE(UInt32_IT, uint32);\n-TSL_LIB_GTL_DEFINE_INT_TYPE(UInt64_IT, uint64);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(UInt32_IT, uint32_t);\n+TSL_LIB_GTL_DEFINE_INT_TYPE(UInt64_IT, uint64_t);\n TSL_LIB_GTL_DEFINE_INT_TYPE(Long_IT, long);  // NOLINT\n \n template <typename IntType_Type>\n@@ -252,12 +252,12 @@ TYPED_TEST(IntTypeTest, TestValueAccessor) {\n   // as this code is part of a template class.  Weird syntax though.  Good news\n   // is that only int_type.value<int>() is needed in most code.\n   EXPECT_EQ(static_cast<int>(i), int_type.template value<int>());\n-  EXPECT_EQ(static_cast<int8>(i), int_type.template value<int8>());\n-  EXPECT_EQ(static_cast<int16>(i), int_type.template value<int16>());\n-  EXPECT_EQ(static_cast<int32>(i), int_type.template value<int32>());\n-  EXPECT_EQ(static_cast<uint32>(i), int_type.template value<uint32>());\n+  EXPECT_EQ(static_cast<int8_t>(i), int_type.template value<int8_t>());\n+  EXPECT_EQ(static_cast<int16_t>(i), int_type.template value<int16_t>());\n+  EXPECT_EQ(static_cast<int32_t>(i), int_type.template value<int32_t>());\n+  EXPECT_EQ(static_cast<uint32_t>(i), int_type.template value<uint32_t>());\n   EXPECT_EQ(static_cast<int64_t>(i), int_type.template value<int64_t>());\n-  EXPECT_EQ(static_cast<uint64>(i), int_type.template value<uint64>());\n+  EXPECT_EQ(static_cast<uint64_t>(i), int_type.template value<uint64_t>());\n   EXPECT_EQ(static_cast<long>(i), int_type.template value<long>());  // NOLINT\n   static_assert(int_type.template value<int>() == static_cast<int>(i),\n                 \"value<Value>() failed\");"
        },
        {
            "sha": "af4540f188db80c8005f419f6cd6b493155d2ac5",
            "filename": "third_party/xla/xla/tsl/lib/gtl/map_util_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fmap_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c8ae25af9bdde84898686df115f71b8c59f016d3/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fmap_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fgtl%2Fmap_util_test.cc?ref=c8ae25af9bdde84898686df115f71b8c59f016d3",
            "patch": "@@ -25,7 +25,7 @@ limitations under the License.\n namespace tsl {\n \n TEST(MapUtil, Find) {\n-  typedef std::map<string, string> Map;\n+  typedef std::map<std::string, std::string> Map;\n   Map m;\n \n   // Check that I can use a type that's implicitly convertible to the\n@@ -39,7 +39,7 @@ TEST(MapUtil, Find) {\n }\n \n TEST(MapUtil, LookupOrInsert) {\n-  typedef std::map<string, string> Map;\n+  typedef std::map<std::string, std::string> Map;\n   Map m;\n \n   // Check that I can use a type that's implicitly convertible to the"
        }
    ],
    "stats": {
        "total": 148,
        "additions": 75,
        "deletions": 73
    }
}