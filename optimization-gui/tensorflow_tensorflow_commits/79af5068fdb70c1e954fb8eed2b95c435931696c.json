{
    "author": "derdrdirk",
    "message": "[Autotuner] Avoid compiling all configurations if we only return the first one. This happens when we want to select the first configuration that successfuly compiles. E.g. for determinism.\n\nPiperOrigin-RevId: 847656341",
    "sha": "79af5068fdb70c1e954fb8eed2b95c435931696c",
    "files": [
        {
            "sha": "554895ab1a17e1bc1370089c454af6899c8301ca",
            "filename": "third_party/xla/xla/backends/autotuner/autotuner.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/79af5068fdb70c1e954fb8eed2b95c435931696c/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/79af5068fdb70c1e954fb8eed2b95c435931696c/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner.cc?ref=79af5068fdb70c1e954fb8eed2b95c435931696c",
            "patch": "@@ -444,6 +444,25 @@ std::vector<absl::StatusOr<std::unique_ptr<Executable>>> Autotuner::CompileAll(\n   XLA_SCOPED_LOGGING_TIMER_LEVEL(\"CompileAll\", 5);\n   tsl::profiler::TraceMe traceme(\"CompileAll\");\n   tsl::profiler::ScopedAnnotation annotation(\"XlaAutotunerCompilation\");\n+\n+  if (autotune_config_.select_first_config) {\n+    std::vector<absl::StatusOr<std::unique_ptr<Executable>>> executables;\n+    for (int i = 0; i < configs.size(); ++i) {\n+      absl::StatusOr<std::unique_ptr<Executable>> executable =\n+          configs[i].codegen_backend->Compile(*instr,\n+                                              *configs[i].backend_config);\n+      if (executable.ok()) {\n+        std::vector<absl::StatusOr<std::unique_ptr<Executable>>> success_result;\n+        success_result.push_back(std::move(executable));\n+        Config selected_config = std::move(configs[i]);\n+        configs.clear();\n+        configs.push_back(std::move(selected_config));\n+        return success_result;\n+      }\n+    }\n+    return executables;\n+  }\n+\n   if (thread_pool_ == nullptr) {\n     std::vector<absl::StatusOr<std::unique_ptr<Executable>>> executables;\n     executables.reserve(configs.size());"
        },
        {
            "sha": "449d837c23334d46db0736e162e8f9738baa77a4",
            "filename": "third_party/xla/xla/backends/autotuner/autotuner_test.cc",
            "status": "modified",
            "additions": 124,
            "deletions": 33,
            "changes": 157,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/79af5068fdb70c1e954fb8eed2b95c435931696c/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/79af5068fdb70c1e954fb8eed2b95c435931696c/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fautotuner%2Fautotuner_test.cc?ref=79af5068fdb70c1e954fb8eed2b95c435931696c",
            "patch": "@@ -241,7 +241,7 @@ TEST_F(AutotunerTest, AutotuneButNoSupportedConfigs) {\n   auto profiler = std::make_unique<MockProfiler>();\n   auto device_description = CreateDummyDeviceDescription();\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::move(cache_manager)));\n@@ -269,7 +269,7 @@ TEST_F(AutotunerTest, AutotuneButNoCompiledConfigs) {\n \n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::move(cache_manager)));\n@@ -308,7 +308,7 @@ TEST_F(AutotunerTest, AutotuneAppliesBestConfigAndSkipsNonCompilableConfig) {\n       .WillOnce(Return(ProfileResult({absl::Seconds(1)})));\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::move(cache_manager)));\n@@ -346,7 +346,7 @@ TEST_F(AutotunerTest, AutotuneAppliesBestConfigUsingThreadPool) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n   tsl::thread::ThreadPool thread_pool(tsl::Env::Default(), \"test\", 2);\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::move(cache_manager), &thread_pool));\n@@ -360,27 +360,27 @@ TEST_F(AutotunerTest, AutotuneModuleFindsNoInstructionsToAutotune) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n   auto device_description = CreateDummyDeviceDescription();\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), nullptr, config_,\n                         std::make_unique<MockAutotunerCache>()));\n \n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(kHlo));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       ParseAndReturnVerifiedModule(kHlo));\n   EXPECT_THAT(autotuner->Autotune(\n                   module.get(), [](const HloInstruction& _) { return false; }),\n               absl_testing::IsOk());\n }\n \n TEST_F(AutotunerTest, AutotuneModuleFollowsFilter) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(kHlo));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       ParseAndReturnVerifiedModule(kHlo));\n \n   auto should_autotune = [](const HloInstruction& instruction) {\n     return instruction.opcode() == HloOpcode::kCopy;\n   };\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<Autotuner> autotuner,\n       SetupAutotunerWithExpectations(\n           /*instrs_to_autotune=*/{HloOpcode::kCopy},\n@@ -391,13 +391,13 @@ TEST_F(AutotunerTest, AutotuneModuleFollowsFilter) {\n }\n \n TEST_F(AutotunerTest, AutotuneModuleWithDuplicateInstructions) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(kHlo));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       ParseAndReturnVerifiedModule(kHlo));\n \n   auto should_autotune = [](const HloInstruction& instruction) {\n     return instruction.opcode() == HloOpcode::kAdd;\n   };\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<Autotuner> autotuner,\n       SetupAutotunerWithExpectations(\n           /*instrs_to_autotune=*/{HloOpcode::kAdd},\n@@ -430,7 +430,7 @@ TEST_F(AutotunerTest, AutotuneButOneBackendFails) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(good_backend));\n   backends.push_back(std::move(bad_backend));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::move(cache_manager)));\n@@ -459,7 +459,7 @@ TEST_F(AutotunerTest, CacheHit) {\n \n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::move(cache_manager)));\n@@ -506,7 +506,7 @@ TEST_F(AutotunerTest, AutotuneWithBufferCheckFiltersWrongResults) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend_1));\n   backends.push_back(std::move(backend_2));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::make_unique<MockAutotunerCache>()));\n@@ -543,7 +543,7 @@ TEST_F(AutotunerTest, AutotuneSkipsBufferCheckWhenNoReferenceOutput) {\n \n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::make_unique<MockAutotunerCache>()));\n@@ -600,7 +600,7 @@ TEST_F(AutotunerTest, AutotuneWithScratchBytesOptimization) {\n   backends.push_back(std::move(backend_1));\n   config_.optimize_scratch_bytes = true;\n   config_.scratch_bytes_window_size_us = 8;\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), std::move(profiler), config_,\n                         std::make_unique<MockAutotunerCache>()));\n@@ -620,16 +620,16 @@ TEST_F(AutotunerTest, ExpectAllInstructionsInCache) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n-      auto autotuner, Autotuner::Create(std::move(backends), nullptr, config_,\n-                                        std::move(cache_manager)));\n+  ASSERT_OK_AND_ASSIGN(auto autotuner,\n+                       Autotuner::Create(std::move(backends), nullptr, config_,\n+                                         std::move(cache_manager)));\n   auto dummy_instr = HloInstruction::CreateConstant(LiteralUtil::CreateR0(1));\n   EXPECT_THAT(autotuner->Autotune(dummy_instr.get()),\n               StatusIs(absl::StatusCode::kNotFound));\n }\n \n TEST_F(AutotunerTest, DumpLogsToFile) {\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       tsl::testing::TemporaryDirectory temp_dir,\n       tsl::testing::TemporaryDirectory::CreateForCurrentTestcase());\n   config_.dump_logs_to = tsl::io::JoinPath(temp_dir.path(), \"dump.log\");\n@@ -659,7 +659,7 @@ TEST_F(AutotunerTest, DumpLogsToFile) {\n       .WillOnce(Return(ProfileResult({absl::Seconds(1)})));\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner, Autotuner::Create(std::move(backends),\n                                         std::move(profiler), config_, nullptr));\n   auto module = ParseAndReturnVerifiedModule(kHlo).value();\n@@ -709,7 +709,7 @@ TEST_F(AutotunerTest, ExcludeCublasConfig) {\n   backends.push_back(std::move(backend));\n \n   auto profiler = std::make_unique<MockProfiler>();\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner, Autotuner::Create(std::move(backends),\n                                         std::move(profiler), config_, nullptr));\n   auto module = ParseAndReturnVerifiedModule(kHlo).value();\n@@ -729,7 +729,6 @@ TEST_F(AutotunerTest, SelectFirstConfig) {\n   EXPECT_CALL(*backend, GetSupportedConfigs(_))\n       .WillOnce(Return(std::move(configs)));\n   EXPECT_CALL(*backend, Compile(_, _))\n-      .WillOnce(Return(std::unique_ptr<Executable>()))\n       .WillOnce(Return(std::unique_ptr<Executable>()));\n   EXPECT_CALL(*backend, ApplyConfig(_, ConfigMatcher(\"test_config_1\")))\n       .Times(1)\n@@ -739,14 +738,106 @@ TEST_F(AutotunerTest, SelectFirstConfig) {\n \n   auto profiler = std::make_unique<MockProfiler>();\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n+      auto autotuner, Autotuner::Create(std::move(backends),\n+                                        std::move(profiler), config_, nullptr));\n+  auto module = ParseAndReturnVerifiedModule(kHlo).value();\n+  auto dummy_instr = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(autotuner->Autotune(dummy_instr), absl_testing::IsOk());\n+}\n+\n+TEST_F(AutotunerTest, SelectFirstConfigStopsAfterFirstSuccess) {\n+  config_.select_first_config = true;\n+\n+  std::vector<std::unique_ptr<BackendConfig>> configs;\n+  configs.push_back(GetTestConfig(\"test_config_1\"));\n+  configs.push_back(GetTestConfig(\"test_config_2\"));\n+  configs.push_back(GetTestConfig(\"test_config_3\"));\n+\n+  auto backend = std::make_unique<MockCodegenBackend>();\n+  EXPECT_CALL(*backend, GetSupportedConfigs(_))\n+      .WillOnce(Return(std::move(configs)));\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_1\")))\n+      .WillOnce(Return(std::unique_ptr<Executable>()));\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_2\"))).Times(0);\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_3\"))).Times(0);\n+\n+  EXPECT_CALL(*backend, ApplyConfig(_, ConfigMatcher(\"test_config_1\")))\n+      .Times(1)\n+      .WillRepeatedly(Return(absl::OkStatus()));\n+  std::vector<std::unique_ptr<CodegenBackend>> backends;\n+  backends.push_back(std::move(backend));\n+\n+  auto profiler = std::make_unique<MockProfiler>();\n+\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner, Autotuner::Create(std::move(backends),\n                                         std::move(profiler), config_, nullptr));\n   auto module = ParseAndReturnVerifiedModule(kHlo).value();\n   auto dummy_instr = module->entry_computation()->root_instruction();\n   EXPECT_THAT(autotuner->Autotune(dummy_instr), absl_testing::IsOk());\n }\n \n+TEST_F(AutotunerTest, SelectFirstConfigFirstConfigFails) {\n+  config_.select_first_config = true;\n+\n+  std::vector<std::unique_ptr<BackendConfig>> configs;\n+  configs.push_back(GetTestConfig(\"test_config_1\"));\n+  configs.push_back(GetTestConfig(\"test_config_2\"));\n+\n+  auto backend = std::make_unique<MockCodegenBackend>();\n+  EXPECT_CALL(*backend, GetSupportedConfigs(_))\n+      .WillOnce(Return(std::move(configs)));\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_1\")))\n+      .WillOnce(Return(absl::InternalError(\"test error\")));\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_2\")))\n+      .WillOnce(Return(std::unique_ptr<Executable>()));\n+\n+  EXPECT_CALL(*backend, ApplyConfig(_, ConfigMatcher(\"test_config_2\")))\n+      .Times(1)\n+      .WillRepeatedly(Return(absl::OkStatus()));\n+  std::vector<std::unique_ptr<CodegenBackend>> backends;\n+  backends.push_back(std::move(backend));\n+\n+  auto profiler = std::make_unique<MockProfiler>();\n+\n+  ASSERT_OK_AND_ASSIGN(\n+      auto autotuner, Autotuner::Create(std::move(backends),\n+                                        std::move(profiler), config_, nullptr));\n+  auto module = ParseAndReturnVerifiedModule(kHlo).value();\n+  auto dummy_instr = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(autotuner->Autotune(dummy_instr), absl_testing::IsOk());\n+}\n+\n+TEST_F(AutotunerTest, SelectFirstConfigAllConfigsFail) {\n+  config_.select_first_config = true;\n+\n+  std::vector<std::unique_ptr<BackendConfig>> configs;\n+  configs.push_back(GetTestConfig(\"test_config_1\"));\n+  configs.push_back(GetTestConfig(\"test_config_2\"));\n+\n+  auto backend = std::make_unique<MockCodegenBackend>();\n+  EXPECT_CALL(*backend, GetSupportedConfigs(_))\n+      .WillOnce(Return(std::move(configs)));\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_1\")))\n+      .WillOnce(Return(absl::InternalError(\"test error\")));\n+  EXPECT_CALL(*backend, Compile(_, ConfigMatcher(\"test_config_2\")))\n+      .WillOnce(Return(absl::InternalError(\"test error\")));\n+\n+  std::vector<std::unique_ptr<CodegenBackend>> backends;\n+  backends.push_back(std::move(backend));\n+\n+  auto profiler = std::make_unique<MockProfiler>();\n+\n+  ASSERT_OK_AND_ASSIGN(\n+      auto autotuner, Autotuner::Create(std::move(backends),\n+                                        std::move(profiler), config_, nullptr));\n+  auto module = ParseAndReturnVerifiedModule(kHlo).value();\n+  auto dummy_instr = module->entry_computation()->root_instruction();\n+  EXPECT_THAT(autotuner->Autotune(dummy_instr),\n+              StatusIs(absl::StatusCode::kInternal));\n+}\n+\n TEST_F(AutotunerTest, UseDefaultConfig) {\n   config_.use_default_config = true;\n \n@@ -760,7 +851,7 @@ TEST_F(AutotunerTest, UseDefaultConfig) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), /*profiler=*/nullptr, config_,\n                         /*cache=*/nullptr));\n@@ -782,7 +873,7 @@ TEST_F(AutotunerTest, UseDefaultConfigUnimplemented) {\n   std::vector<std::unique_ptr<CodegenBackend>> backends;\n   backends.push_back(std::move(backend));\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       auto autotuner,\n       Autotuner::Create(std::move(backends), /*profiler=*/nullptr, config_,\n                         /*cache=*/nullptr));\n@@ -810,8 +901,8 @@ AutotunerCacheInterface::Config GetCacheConfig(absl::string_view name) {\n };\n \n TEST_F(AutotunerTest, ShardedAutotuning) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(kHlo));\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n+                       ParseAndReturnVerifiedModule(kHlo));\n   constexpr int kShardCount = 2;\n   auto should_autotune = [](const HloInstruction& instruction) {\n     return instruction.opcode() == HloOpcode::kAdd ||\n@@ -842,7 +933,7 @@ TEST_F(AutotunerTest, ShardedAutotuning) {\n   EXPECT_CALL(*cache, Lookup(InstrPtrMatcher(HloOpcode::kAdd)))\n       .WillOnce(Return(GetCacheConfig(\"best_config\")));\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<Autotuner> autotuner,\n       SetupAutotunerWithExpectations(\n           /*instrs_to_autotune=*/{HloOpcode::kCopy},\n@@ -859,7 +950,7 @@ TEST_F(AutotunerTest, ShardedAutotuning) {\n }\n \n TEST_F(AutotunerTest, DumpHlos) {\n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       tsl::testing::TemporaryDirectory dump_dir,\n       tsl::testing::TemporaryDirectory::CreateForCurrentTestcase());\n   auto module = ParseAndReturnVerifiedModule(kHlo).value();\n@@ -870,7 +961,7 @@ TEST_F(AutotunerTest, DumpHlos) {\n            instruction.opcode() == HloOpcode::kAdd;\n   };\n \n-  TF_ASSERT_OK_AND_ASSIGN(\n+  ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<Autotuner> autotuner,\n       SetupAutotunerWithExpectations(\n           /*instrs_to_autotune=*/{HloOpcode::kCopy, HloOpcode::kAdd},"
        }
    ],
    "stats": {
        "total": 176,
        "additions": 143,
        "deletions": 33
    }
}