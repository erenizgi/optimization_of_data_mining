{
    "author": "subhankarshah",
    "message": "[XLA:MSA] Make concurrent block prefetching logic robust -\n* Earlier - An earliest_prefetch_start_time was found and then we accepted or discarded it based on whether it violated the max concurrent prefetches limit. In other words we might say it is not possible to prefetch some values even when it was possible.\n* In this CL - We track the copy done before times of all prefetches and use that to adhere to the concurrent prefetches limits when looking for the earliest_prefetch_start_time in the first place.\n* Add some comments.\n\nPiperOrigin-RevId: 809115513",
    "sha": "39b46ec372d2d363d8626229ceff98894b6acdba",
    "files": [
        {
            "sha": "75eaa29e3f72491b744f6a025a1286af194f4f1a",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.cc",
            "status": "modified",
            "additions": 49,
            "deletions": 43,
            "changes": 92,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/39b46ec372d2d363d8626229ceff98894b6acdba/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/39b46ec372d2d363d8626229ceff98894b6acdba/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.cc?ref=39b46ec372d2d363d8626229ceff98894b6acdba",
            "patch": "@@ -2027,34 +2027,56 @@ int64_t MsaAlgorithm::MaxReservedScopedMemory() {\n }\n \n std::optional<int64_t> MsaAlgorithm::EarliestBlockPrefetchStartTime(\n-    int64_t earliest_start_time_candidate, int64_t first_use_time,\n-    int64_t last_use_time, int64_t buffer_size,\n+    int64_t previous_block_start_time, int64_t definition_time,\n+    int64_t first_use_time, int64_t last_use_time, int64_t buffer_size,\n     int64_t block_prefetching_limit_bytes,\n-    std::vector<int64_t>& prefetch_end_times) {\n+    int64_t max_in_flight_prefetches_allowed,\n+    std::vector<int64_t>& copy_done_schedule_before_times,\n+    std::vector<int64_t>& block_prefetch_allocation_end_times) {\n   auto can_find_chunk_within_limit =\n       [&](int64_t start_time, int64_t end_time, int64_t buffer_size,\n-          int64_t block_prefetching_limit_bytes) {\n-        MsaBufferInterval interval =\n-            MsaBufferInterval{/*buffer=*/nullptr,\n-                              /*size=*/buffer_size,\n-                              /*start=*/start_time,\n-                              /*end=*/end_time,\n-                              /*colocations=*/{},\n-                              /*need_allocation=*/true};\n-        Chunk chunk_candidate = FindChunkCandidate(interval);\n-        return chunk_candidate.chunk_end() <= block_prefetching_limit_bytes;\n-      };\n+          int64_t block_prefetching_limit_bytes) -> bool {\n+    MsaBufferInterval interval = MsaBufferInterval{/*buffer=*/nullptr,\n+                                                   /*size=*/buffer_size,\n+                                                   /*start=*/start_time,\n+                                                   /*end=*/end_time,\n+                                                   /*colocations=*/{},\n+                                                   /*need_allocation=*/true};\n+    Chunk chunk_candidate = FindChunkCandidate(interval);\n+    return chunk_candidate.chunk_end() <= block_prefetching_limit_bytes;\n+  };\n+  CHECK_LE(previous_block_start_time, first_use_time);\n+  int64_t earliest_start_time_candidate =\n+      std::max(definition_time, previous_block_start_time);\n+  int64_t total_prefetches = copy_done_schedule_before_times.size();\n+  if (total_prefetches >= max_in_flight_prefetches_allowed) {\n+    earliest_start_time_candidate = std::max(\n+        earliest_start_time_candidate,\n+        copy_done_schedule_before_times[total_prefetches -\n+                                        max_in_flight_prefetches_allowed]);\n+  }\n   if (can_find_chunk_within_limit(earliest_start_time_candidate, last_use_time,\n                                   buffer_size, block_prefetching_limit_bytes)) {\n     return earliest_start_time_candidate;\n   }\n-  // Find the first start_time = end_time + 1, where end_time comes from the\n-  // prefetch_end_times list.\n-  auto it_begin =\n-      std::upper_bound(prefetch_end_times.begin(), prefetch_end_times.end(),\n-                       earliest_start_time_candidate - 1);\n-  auto it_end = std::upper_bound(prefetch_end_times.begin(),\n-                                 prefetch_end_times.end(), first_use_time - 1);\n+\n+  // We couldn't find a chunk using earliest_start_time_candidate as our start\n+  // So, we need to search for a valid start time in\n+  // [earliest_start_time_candidate + 1, first_use_time], at the boundaries of\n+  // the previous end times, which free up memory.\n+\n+  // `it_begin` will point to the first element in the prefetch_end_times list\n+  // that is strictly greater than (earliest_start_time_candidate - 1). Note, in\n+  // the loop below, we add one to start time candidates.\n+  auto it_begin = std::upper_bound(block_prefetch_allocation_end_times.begin(),\n+                                   block_prefetch_allocation_end_times.end(),\n+                                   earliest_start_time_candidate - 1);\n+\n+  // `it_end` will point to the first element in the prefetch_end_times list\n+  // that is strictly greater than (first_use_time - 1).\n+  auto it_end = std::upper_bound(block_prefetch_allocation_end_times.begin(),\n+                                 block_prefetch_allocation_end_times.end(),\n+                                 first_use_time - 1);\n   for (auto it = it_begin; it != it_end; ++it) {\n     int64_t start_time = *it + 1;\n     if (can_find_chunk_within_limit(start_time, last_use_time, buffer_size,\n@@ -2191,6 +2213,7 @@ void MsaAlgorithm::ProcessBlockPrefetches() {\n   int64_t max_in_flight_prefetches_allowed =\n       options_.max_outstanding_block_prefetches;\n   std::vector<int64_t> prefetch_end_times;\n+  std::vector<int64_t> copy_done_schedule_before_times;\n \n   absl::flat_hash_map<const HloValue*, Allocation*> value_to_pinned_allocation;\n \n@@ -2209,14 +2232,13 @@ void MsaAlgorithm::ProcessBlockPrefetches() {\n         instruction_schedule.at(original_value->defining_instruction());\n     int64_t end_time = last_use_time;\n     int64_t buffer_size = buffer_intervals_.at(maybe_sliced_value).size;\n-    int64_t earliest_start_time_candidate =\n-        std::max(definition_time, previous_start_time);\n-    CHECK_LE(earliest_start_time_candidate, first_use_time);\n     // Find the earliest start time for which a chunk can be allocated for the\n     // block prefetched value.\n     std::optional<int64_t> optional_start_time = EarliestBlockPrefetchStartTime(\n-        earliest_start_time_candidate, first_use_time, end_time, buffer_size,\n-        block_prefetching_limit_bytes, prefetch_end_times);\n+        previous_start_time, definition_time, first_use_time, end_time,\n+        buffer_size, block_prefetching_limit_bytes,\n+        max_in_flight_prefetches_allowed, copy_done_schedule_before_times,\n+        prefetch_end_times);\n \n     if (!optional_start_time.has_value()) {\n       LOG(WARNING) << \"Could not find a chunk for block prefetched value: \"\n@@ -2227,23 +2249,6 @@ void MsaAlgorithm::ProcessBlockPrefetches() {\n     }\n     int64_t start_time = optional_start_time.value();\n \n-    int64_t n_prefetches_scheduled = prefetch_end_times.size();\n-    int64_t n_prefetches_finished =\n-        std::upper_bound(prefetch_end_times.begin(), prefetch_end_times.end(),\n-                         start_time) -\n-        prefetch_end_times.begin();\n-    int64_t n_prefetches_already_in_flight =\n-        n_prefetches_scheduled - n_prefetches_finished;\n-\n-    if (n_prefetches_already_in_flight >= max_in_flight_prefetches_allowed) {\n-      LOG(WARNING)\n-          << \"block prefetched value exceeds max prefetches in flight: \"\n-          << maybe_sliced_value->defining_position().ToString() << \" \"\n-          << n_prefetches_already_in_flight << \" \"\n-          << max_in_flight_prefetches_allowed;\n-      continue;\n-    }\n-\n     MsaBufferInterval interval = MsaBufferInterval{/*buffer=*/original_value,\n                                                    /*size=*/buffer_size,\n                                                    /*start=*/start_time,\n@@ -2294,6 +2299,7 @@ void MsaAlgorithm::ProcessBlockPrefetches() {\n     auto const sorted_position = std::lower_bound(\n         prefetch_end_times.begin(), prefetch_end_times.end(), end_time);\n     prefetch_end_times.insert(sorted_position, end_time);\n+    copy_done_schedule_before_times.push_back(first_use_time);\n \n     // Bookkeeping Checklist:\n     // Commit the chunk to the alternate memory."
        },
        {
            "sha": "4264d299463b7448776455678289114d9aaaefce",
            "filename": "third_party/xla/xla/service/memory_space_assignment/algorithm.h",
            "status": "modified",
            "additions": 15,
            "deletions": 7,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/39b46ec372d2d363d8626229ceff98894b6acdba/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/39b46ec372d2d363d8626229ceff98894b6acdba/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Falgorithm.h?ref=39b46ec372d2d363d8626229ceff98894b6acdba",
            "patch": "@@ -341,15 +341,23 @@ class MsaAlgorithm : public GlobalDecreasingSizeBestFitHeap<HloValue> {\n   // the program.\n   int64_t MaxReservedScopedMemory();\n \n-  // Returns the earliest time that chunk can be reserved for a block prefetch\n-  // where the start time is between [definition_time, use_time] and use_time\n-  // and the end time is the use_time. The chunk.end() should be within the\n-  // block_prefetching_limit_bytes.\n+  // Finds and returns the earliest block prefetch start time subject to the\n+  // following constraints:\n+  // - We can reserve a chunk of size buffer_size.\n+  // - The chunk's start_time lies between [definition_time, first_use_time].\n+  // - The chunk's end_time is equal to last_use_time.\n+  // - The chunk's ending offset is less than or equal to\n+  //   block_prefetching_limit_bytes.\n+  // - The number of concurrent prefetches is less than or equal to\n+  //   max_in_flight_prefetches_allowed.\n+  // If no such prefetch_start_time exists, returns std::nullopt.\n   std::optional<int64_t> EarliestBlockPrefetchStartTime(\n-      int64_t earliest_start_time_candidate, int64_t first_use_time,\n-      int64_t last_use_time, int64_t buffer_size,\n+      int64_t previous_block_start_time, int64_t definition_time,\n+      int64_t first_use_time, int64_t last_use_time, int64_t buffer_size,\n       int64_t block_prefetching_limit_bytes,\n-      std::vector<int64_t>& prefetch_end_times);\n+      int64_t max_in_flight_prefetches_allowed,\n+      std::vector<int64_t>& copy_done_schedule_before_times,\n+      std::vector<int64_t>& block_prefetch_allocation_end_times);\n \n  protected:\n   // Given a buffer interval, returns the colocated intervals. Unlike the"
        },
        {
            "sha": "db14edcf02f37dce80a79e19160886ca95d2402e",
            "filename": "third_party/xla/xla/service/memory_space_assignment/memory_space_assignment_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/39b46ec372d2d363d8626229ceff98894b6acdba/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/39b46ec372d2d363d8626229ceff98894b6acdba/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fmemory_space_assignment%2Fmemory_space_assignment_test.cc?ref=39b46ec372d2d363d8626229ceff98894b6acdba",
            "patch": "@@ -14678,7 +14678,9 @@ ENTRY entry {\n \n TEST_F(MemorySpaceAssignmentTest, TestBlockPrefetchingLowConcurrentPrefetches) {\n   // The size of alternate memory allows for 4 concurrent block prefetches but\n-  // the maximum number of concurrent block prefetches allowed is 2.\n+  // the maximum number of concurrent block prefetches allowed is 2. The live\n+  // ranges of p0 and p1 are long but their copy dones are early enough that\n+  // other prefetches can start without violating the concurrent prefetch limit.\n   absl::string_view hlo_string = R\"(\n HloModule module, is_scheduled=true\n \n@@ -14745,21 +14747,18 @@ ENTRY entry {\n   HloInstruction* add14 = FindInstruction(module.get(), \"add14\");\n   EXPECT_EQ(add14->operand(0)->shape().layout().memory_space(),\n             kAlternateMemorySpace);\n-\n-  // The following operands are not prefetched because the prefetches are\n-  // limited to 2 concurrent prefetches.\n   HloInstruction* add6 = FindInstruction(module.get(), \"add6\");\n   EXPECT_EQ(add6->operand(0)->shape().layout().memory_space(),\n-            kDefaultMemorySpace);\n+            kAlternateMemorySpace);\n   HloInstruction* add9 = FindInstruction(module.get(), \"add9\");\n   EXPECT_EQ(add9->operand(0)->shape().layout().memory_space(),\n-            kDefaultMemorySpace);\n+            kAlternateMemorySpace);\n   HloInstruction* add12 = FindInstruction(module.get(), \"add12\");\n   EXPECT_EQ(add12->operand(0)->shape().layout().memory_space(),\n-            kDefaultMemorySpace);\n+            kAlternateMemorySpace);\n   HloInstruction* add15 = FindInstruction(module.get(), \"add15\");\n   EXPECT_EQ(add15->operand(0)->shape().layout().memory_space(),\n-            kDefaultMemorySpace);\n+            kAlternateMemorySpace);\n }\n \n TEST_F(MemorySpaceAssignmentTest, TestSingleBufferedBlockPrefetching) {"
        }
    ],
    "stats": {
        "total": 129,
        "additions": 71,
        "deletions": 58
    }
}