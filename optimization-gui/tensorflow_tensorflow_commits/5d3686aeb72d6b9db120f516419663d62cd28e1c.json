{
    "author": "amd-songpiao",
    "message": "PR #34812: [ROCm] Add register spilling detection support AMD\n\nImported from GitHub PR https://github.com/openxla/xla/pull/34812\n\nâœ¨ New Feature\n\nAdded register spilling detection support.\n\nðŸ§ª Execution Test\n\n./bazel-7.4.1-linux-x86_64 build //xla/service/gpu/transforms:triton_fusion_numerics_verifier_test\nbazel-bin/xla/service/gpu/transforms/triton_fusion_numerics_verifier_test_amdgpu_any --gtest_filter=TritonFusionNumericsVerifierTest.CompilationSucceedsEvenIfKernelWillSpillRegisters\n\n```\nI0000 00:00:1764849271.079538 2923925 amdgpu_backend.cc:447] ====== REGISTER SPILLING DETECTED ======\nI0000 00:00:1764849271.079561 2923925 amdgpu_backend.cc:448] Module: triton_softmax_consts\nI0000 00:00:1764849271.079565 2923925 amdgpu_backend.cc:449] SGPR spill count: 0\nI0000 00:00:1764849271.079569 2923925 amdgpu_backend.cc:450] VGPR spill count: 194\nI0000 00:00:1764849271.079572 2923925 amdgpu_backend.cc:451] Private segment size: 780 bytes\nI0000 00:00:1764849271.079574 2923925 amdgpu_backend.cc:452] Performance may be degraded due to register pressure\nI0000 00:00:1764849271.079576 2923925 amdgpu_backend.cc:453] ========================================\nI0000 00:00:1764849271.390972 2923925 amdgpu_backend.cc:447] ====== REGISTER SPILLING DETECTED ======\nI0000 00:00:1764849271.390996 2923925 amdgpu_backend.cc:448] Module: triton_softmax_consts\nI0000 00:00:1764849271.391000 2923925 amdgpu_backend.cc:449] SGPR spill count: 0\nI0000 00:00:1764849271.391005 2923925 amdgpu_backend.cc:450] VGPR spill count: 194\nI0000 00:00:1764849271.391007 2923925 amdgpu_backend.cc:451] Private segment size: 780 bytes\nI0000 00:00:1764849271.391009 2923925 amdgpu_backend.cc:452] Performance may be degraded due to register pressure\nI0000 00:00:1764849271.391012 2923925 amdgpu_backend.cc:453] ========================================\nI0000 00:00:1764849271.397868 2923925 tfrt_gpu_client.cc:197] TfrtGpuClient destroyed.\n[       OK ] TritonFusionNumericsVerifierTest.CompilationSucceedsEvenIfKernelWillSpillRegisters (8019 ms)\n[----------] 1 test from TritonFusionNumericsVerifierTest (8019 ms total)\n\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test suite ran. (8019 ms total)\n[  PASSED  ] 1 test.\n```\n\nThis PR is on top of another bugfix PR (https://github.com/openxla/xla/pull/34806).\n\n@xla-rotation could you review my PR, please?\n\nCopybara import of the project:\n\n--\nebd6e1fa03033bc9f6913351323fce26e1a8e4d2 by Songlin Piao <Songlin.Piao@amd.com>:\n\nreplace the manual calling convention fix with AnnotateFunctionAsGpuKernel\n\n--\nfafc7f1f6ad5a47204a32d433eab2bc5ec44dbd3 by Songlin Piao <Songlin.Piao@amd.com>:\n\nregister spilling by disassembling object file\n\n--\nf6b86f6fc96fd3398608c0078233db2efa74fce7 by Songlin Piao <Songlin.Piao@amd.com>:\n\nadded time measurement to the spilling check\n\n--\n8e5ea8455fc730b73b3768cbdde07079c8c53c29 by Songlin Piao <Songlin.Piao@amd.com>:\n\nadapt the num_warps so that the hlo could be compiled on both amd and nvidia\n\n--\n22ef808416e6d339356c3a901ce1f5d03a396a60 by Songlin Piao <Songlin.Piao@amd.com>:\n\npass though is_autotuning_compilation flag to the function CompileToHsaco\n\n--\nb1d5e976c8051332ca1fc45e5f3b91fcd15a3da8 by Songlin Piao <Songlin.Piao@amd.com>:\n\nimplementation of register spilling by reading meta data of hasco file using llvm-readobj\n\n--\nd74ae83731a0a56a7285c1ac57689678d21e42d4 by Songlin Piao <Songlin.Piao@amd.com>:\n\nadapted functiona calls as is_autotuning_compilation is removed in upstream\n\n--\n07ed74d49361fb1945092cac459a3bb70262265b by Songlin Piao <Songlin.Piao@amd.com>:\n\nutilize amd code object manager library for parsing HSACO metadata\n\n--\n11e83bcb502ee341ddf7db9044b05b4b757ca5e9 by Songlin Piao <Songlin.Piao@amd.com>:\n\nRevert \"replace the manual calling convention fix with AnnotateFunctionAsGpuKernel\"\n\nThis reverts commit ebd6e1fa03033bc9f6913351323fce26e1a8e4d2.\n\nMerging this change closes #34812\n\nPiperOrigin-RevId: 842183737",
    "sha": "5d3686aeb72d6b9db120f516419663d62cd28e1c",
    "files": [
        {
            "sha": "4eba66c971da7200cefcda044a2274db6f83b84b",
            "filename": "third_party/xla/third_party/gpus/rocm/BUILD.tpl",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2FBUILD.tpl",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2FBUILD.tpl",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Fgpus%2Frocm%2FBUILD.tpl?ref=5d3686aeb72d6b9db120f516419663d62cd28e1c",
            "patch": "@@ -150,9 +150,11 @@ cc_library(\n         ],\n         \":multiple_rocm_paths\": [\n             \"-Wl,-rpath=%{rocm_lib_paths}\",\n+            \"-Lexternal/local_config_rocm/rocm/%{rocm_root}/lib\",\n         ],\n         \"//conditions:default\": [\n             \"-Wl,-rpath,/opt/rocm/lib\",\n+            \"-Lexternal/local_config_rocm/rocm/%{rocm_root}/lib\",\n         ],\n     }),\n     visibility = [\"//visibility:public\"],\n@@ -535,7 +537,7 @@ cc_library(\n cc_library(\n     name = \"amd_comgr\",\n     hdrs = glob([\"%{rocm_root}/include/amd_comgr/**\"]),\n-    data = glob([\n+    srcs = glob([\n         \"%{rocm_root}/lib/libamd_comgr_loader.so*\",\n         \"%{rocm_root}/lib/libamd_comgr.so*\",\n         \"%{rocm_root}/lib/llvm/lib/libLLVM.so*\",\n@@ -548,9 +550,12 @@ cc_library(\n         \":build_hermetic\": [\n             \"-lamd_comgr_loader\",\n         ],\n-        \"//conditions:default\": [],\n+        \"//conditions:default\": [\n+            \"-lamd_comgr\",\n+\t],\n     }),\n     strip_include_prefix = \"%{rocm_root}\",\n+    visibility = [\"//visibility:public\"],\n     deps = [\n         \":rocm_config\",\n         \":rocm_rpath\","
        },
        {
            "sha": "edd7570f1ed64c8f15fbd1205abd12011dd4a2a6",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD?ref=5d3686aeb72d6b9db120f516419663d62cd28e1c",
            "patch": "@@ -413,7 +413,6 @@ cc_library(\n         \"//xla/service/gpu:backend_configs_cc\",\n         \"//xla/service/gpu:ir_emission_utils\",\n         \"//xla/service/gpu:launch_dimensions\",\n-        \"//xla/service/gpu/llvm_gpu_backend:amdgpu_backend\",\n         \"//xla/service/gpu/llvm_gpu_backend:nvptx_libdevice_path\",\n         \"//xla/service/gpu:matmul_utils\",\n         \"//xla/service/gpu:triton_fusion_analysis\","
        },
        {
            "sha": "f70483614dd8c989e724fd7c2258b37219a7a761",
            "filename": "third_party/xla/xla/service/gpu/llvm_gpu_backend/BUILD",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fllvm_gpu_backend%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fllvm_gpu_backend%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fllvm_gpu_backend%2FBUILD?ref=5d3686aeb72d6b9db120f516419663d62cd28e1c",
            "patch": "@@ -171,7 +171,9 @@ cc_library(\n         \"HAS_SUPPORT_FOR_EMBEDDED_LIB_DEVICE=1\",\n     ]),\n     tags = [\n+        \"gpu\",\n         \"nofixdeps\",  # This target crashes build_cleaner Â¯\\_(ãƒ„)_/Â¯\n+        \"rocm-only\",\n     ],\n     deps = [\n         \":llvm_gpu_backend\",\n@@ -210,6 +212,8 @@ cc_library(\n         \"@llvm-project//llvm:Support\",\n         \"@llvm-project//llvm:Target\",\n         \"@llvm-project//llvm:TargetParser\",\n+        \"@local_config_rocm//rocm:amd_comgr\",\n+        \"@local_config_rocm//rocm:rocm_headers\",\n         \"@local_tsl//tsl/platform:path\",\n         \"@local_tsl//tsl/platform:random\",\n         \"@local_tsl//tsl/profiler/lib:traceme\","
        },
        {
            "sha": "536216735c9adf214a1e352f038cbc1839e831ac",
            "filename": "third_party/xla/xla/service/gpu/llvm_gpu_backend/amdgpu_backend.cc",
            "status": "modified",
            "additions": 173,
            "deletions": 2,
            "changes": 175,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fllvm_gpu_backend%2Famdgpu_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fllvm_gpu_backend%2Famdgpu_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fllvm_gpu_backend%2Famdgpu_backend.cc?ref=5d3686aeb72d6b9db120f516419663d62cd28e1c",
            "patch": "@@ -15,6 +15,7 @@ limitations under the License.\n \n #include \"xla/service/gpu/llvm_gpu_backend/amdgpu_backend.h\"\n \n+#include <algorithm>\n #include <cstdint>\n #include <cstdlib>\n #include <fstream>\n@@ -39,6 +40,7 @@ limitations under the License.\n #include \"absl/strings/str_split.h\"\n #include \"absl/strings/string_view.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"amd_comgr/amd_comgr.h\"\n #include \"llvm/ADT/SmallVector.h\"\n #include \"llvm/ADT/StringSet.h\"\n #include \"llvm/Analysis/CGSCCPassManager.h\"\n@@ -318,14 +320,151 @@ absl::StatusOr<std::vector<uint8_t>> EmitModuleToHsaco(\n     }\n   }\n \n-  // Read HSACO.\n+  // Read HSACO file into memory (used for both metadata extraction and return)\n   std::ifstream hsaco_file(hsaco_path, std::ios::binary | std::ios::ate);\n+  if (!hsaco_file) {\n+    return xla::Internal(\"Failed to open HSACO file: %s\", hsaco_path);\n+  }\n   std::ifstream::pos_type hsaco_file_size = hsaco_file.tellg();\n-\n   std::vector<uint8_t> hsaco(hsaco_file_size);\n   hsaco_file.seekg(0, std::ios::beg);\n   hsaco_file.read(reinterpret_cast<char*>(hsaco.data()), hsaco_file_size);\n   hsaco_file.close();\n+\n+  // Check for register spilling using HSACO metadata\n+  // Use amd_comgr library for fast in-process metadata extraction\n+  VLOG(2) << \"Checking for register spilling in: \"\n+          << module->getModuleIdentifier();\n+\n+  bool has_spilling = false;\n+  int sgpr_spill_count = 0;\n+  int vgpr_spill_count = 0;\n+  int private_segment_size = 0;\n+\n+  // Use already-loaded HSACO data for amd_comgr parsing\n+  {\n+    // Create amd_comgr data object from HSACO\n+    amd_comgr_data_t comgr_data;\n+    amd_comgr_status_t status =\n+        amd_comgr_create_data(AMD_COMGR_DATA_KIND_EXECUTABLE, &comgr_data);\n+\n+    if (status == AMD_COMGR_STATUS_SUCCESS) {\n+      status = amd_comgr_set_data(comgr_data, hsaco.size(),\n+                                  reinterpret_cast<const char*>(hsaco.data()));\n+\n+      if (status == AMD_COMGR_STATUS_SUCCESS) {\n+        // Get metadata from the executable\n+        amd_comgr_metadata_node_t metadata;\n+        status = amd_comgr_get_data_metadata(comgr_data, &metadata);\n+\n+        if (status == AMD_COMGR_STATUS_SUCCESS) {\n+          // Helper lambda to lookup integer value from metadata map\n+          auto lookup_int_value = [](amd_comgr_metadata_node_t root,\n+                                     const char* key) -> int {\n+            amd_comgr_metadata_node_t value_node;\n+            amd_comgr_status_t s =\n+                amd_comgr_metadata_lookup(root, key, &value_node);\n+            if (s != AMD_COMGR_STATUS_SUCCESS) {\n+              return 0;\n+            }\n+\n+            size_t size = 0;\n+            s = amd_comgr_get_metadata_string(value_node, &size, nullptr);\n+            if (s != AMD_COMGR_STATUS_SUCCESS || size == 0) {\n+              amd_comgr_destroy_metadata(value_node);\n+              return 0;\n+            }\n+\n+            std::string str_value(size, '\\0');\n+            s = amd_comgr_get_metadata_string(value_node, &size,\n+                                              str_value.data());\n+            amd_comgr_destroy_metadata(value_node);\n+\n+            if (s != AMD_COMGR_STATUS_SUCCESS) {\n+              return 0;\n+            }\n+\n+            // Parse the integer value\n+            try {\n+              return std::stoi(str_value);\n+            } catch (...) {\n+              return 0;\n+            }\n+          };\n+\n+          // Navigate to amdhsa.kernels array and check each kernel\n+          amd_comgr_metadata_node_t kernels_node;\n+          if (amd_comgr_metadata_lookup(metadata, \"amdhsa.kernels\",\n+                                        &kernels_node) ==\n+              AMD_COMGR_STATUS_SUCCESS) {\n+            size_t kernel_count = 0;\n+            amd_comgr_get_metadata_list_size(kernels_node, &kernel_count);\n+\n+            for (size_t i = 0; i < kernel_count; ++i) {\n+              amd_comgr_metadata_node_t kernel_node;\n+              if (amd_comgr_index_list_metadata(kernels_node, i,\n+                                                &kernel_node) ==\n+                  AMD_COMGR_STATUS_SUCCESS) {\n+                // Get spill counts for this kernel\n+                int kernel_sgpr_spill =\n+                    lookup_int_value(kernel_node, \".sgpr_spill_count\");\n+                int kernel_vgpr_spill =\n+                    lookup_int_value(kernel_node, \".vgpr_spill_count\");\n+                int kernel_private_size = lookup_int_value(\n+                    kernel_node, \".private_segment_fixed_size\");\n+\n+                // Aggregate max values across all kernels\n+                sgpr_spill_count =\n+                    std::max(sgpr_spill_count, kernel_sgpr_spill);\n+                vgpr_spill_count =\n+                    std::max(vgpr_spill_count, kernel_vgpr_spill);\n+                private_segment_size =\n+                    std::max(private_segment_size, kernel_private_size);\n+\n+                amd_comgr_destroy_metadata(kernel_node);\n+              }\n+            }\n+            amd_comgr_destroy_metadata(kernels_node);\n+          }\n+\n+          amd_comgr_destroy_metadata(metadata);\n+        } else {\n+          VLOG(2) << \"Could not get HSACO metadata via amd_comgr\";\n+        }\n+      }\n+      amd_comgr_release_data(comgr_data);\n+    } else {\n+      VLOG(2) << \"Could not create amd_comgr data object\";\n+    }\n+\n+    if (sgpr_spill_count > 0 || vgpr_spill_count > 0 ||\n+        private_segment_size > 0) {\n+      has_spilling = true;\n+    }\n+  }\n+\n+  if (has_spilling) {\n+    VLOG(0) << \"====== REGISTER SPILLING DETECTED ======\";\n+    VLOG(0) << \"Module: \" << module->getModuleIdentifier();\n+    VLOG(0) << \"SGPR spill count: \" << sgpr_spill_count;\n+    VLOG(0) << \"VGPR spill count: \" << vgpr_spill_count;\n+    VLOG(0) << \"Private segment size: \" << private_segment_size << \" bytes\";\n+    VLOG(0) << \"Performance may be degraded due to register pressure\";\n+    VLOG(0) << \"========================================\";\n+\n+    // Filter out kernels with register spilling during autotuning\n+    // This matches NVIDIA's behavior in ptx_compiler_impl.cc\n+    // TODO: remove ptx from xla_gpu_fail_ptx_compilation_on_register_spilling\n+    // to make the flag more general\n+    if (debug_options.xla_gpu_fail_ptx_compilation_on_register_spilling()) {\n+      return xla::Cancelled(\n+          \"Compilation result discarded due to register spilling\");\n+    }\n+  } else {\n+    VLOG(2) << \"No register spilling detected\";\n+  }\n+\n+  // Clean up temp files\n   if (!keep_tempfiles) {\n     remove(ir_path.c_str());\n     remove(isabin_path.c_str());\n@@ -562,6 +701,34 @@ std::vector<std::string> GetAMDGPUBackendOptions(\n                            backend_extra_llvm_opts.cbegin(),\n                            backend_extra_llvm_opts.cend());\n \n+  // Manually add LLVM debug options for register usage analysis\n+  // Note: The disassembly-based spilling detection is now the primary method.\n+  // These options are mainly useful for debugging the compiler itself.\n+\n+  // Uncomment if you want to see LLVM compilation details:\n+\n+  // Option 1: Enable LLVM statistics (aggregate stats, not per-kernel)\n+  // backend_llvm_opts.push_back(\"-stats\");\n+\n+  // Option 2: Print final machine code (very verbose)\n+  // backend_llvm_opts.push_back(\"-print-after-all\");\n+\n+  // Option 3: Print after register allocation (shows register assignments)\n+  // backend_llvm_opts.push_back(\"-print-after=regallocfast\");\n+  // backend_llvm_opts.push_back(\"-print-after=regallocgreedy\");\n+\n+  // Option 4: Enable pass timing (shows compilation time breakdown)\n+  // backend_llvm_opts.push_back(\"-time-passes\");\n+\n+  // Log the final LLVM options\n+  if (!backend_llvm_opts.empty()) {\n+    LOG(INFO) << \"AMDGPU backend LLVM options (\" << backend_llvm_opts.size()\n+              << \"):\";\n+    for (const auto& opt : backend_llvm_opts) {\n+      LOG(INFO) << \"  \" << opt;\n+    }\n+  }\n+\n   return backend_llvm_opts;\n }\n \n@@ -576,6 +743,10 @@ absl::StatusOr<std::vector<uint8_t>> CompileToHsaco(\n   absl::call_once(backend_init_flag, AMDGPUBackendInit, debug_options,\n                   rocdl_dir_path);\n   auto llvm_opts = GetAMDGPUBackendOptions(debug_options);\n+\n+  VLOG(2) << \"CompileToHsaco called for module: \"\n+          << module->getModuleIdentifier();\n+\n   llvm_ir::LLVMCommandLineOptionsLock llvm_lock(llvm_opts);\n \n   std::vector<uint8_t> hsaco;"
        },
        {
            "sha": "dae6b73eba50a6b041ca0bb75d33238d1b18d7da",
            "filename": "third_party/xla/xla/service/gpu/transforms/triton_fusion_numerics_verifier_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Ftriton_fusion_numerics_verifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5d3686aeb72d6b9db120f516419663d62cd28e1c/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Ftriton_fusion_numerics_verifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Ftransforms%2Ftriton_fusion_numerics_verifier_test.cc?ref=5d3686aeb72d6b9db120f516419663d62cd28e1c",
            "patch": "@@ -393,7 +393,7 @@ ENTRY main {\n         \"kind\":\"__triton\",\n         \"block_level_fusion_config\":{\n           \"output_tiles\":[{\"sizes\":[\"1\",\"256000\"]}],\n-          \"num_warps\":\"32\",\n+          \"num_warps\":\"16\",\n           \"num_ctas\":\"1\",\n           \"num_stages\":\"1\"}}}\n })\","
        }
    ],
    "stats": {
        "total": 191,
        "additions": 185,
        "deletions": 6
    }
}